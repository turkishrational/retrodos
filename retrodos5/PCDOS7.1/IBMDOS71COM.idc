//
// +-------------------------------------------------------------------------+
// |   This file has been generated by The Interactive Disassembler (IDA)    |
// |           Copyright (c) 2018 Hex-Rays, <support@hex-rays.com>           |
// |                            Freeware version                             |
// +-------------------------------------------------------------------------+
//
//
//      This file should be used in the following way:
//         - reload executable into IDA with using switch -c
//         - use File, Load IDC file and load this file.
//
//      NOTE: This file doesn't contain all information from the database.
//

#define UNLOADED_FILE   1
#include <idc.idc>

static main(void)
{
  // set 'loading idc file' mode
  set_inf_attr(INF_GENFLAGS, INFFL_LOADIDC|get_inf_attr(INF_GENFLAGS));
  GenInfo();            // various settings
  Segments();           // segmentation
  Enums();              // enumerations
  Structures();         // structure types
  ApplyStrucTInfos();   // structure type infos
  Patches();            // manual patches
  SegRegs();            // segment register values
  Bytes();              // individual bytes (code,data)
  Functions();          // function definitions
  // clear 'loading idc file' mode
  set_inf_attr(INF_GENFLAGS, ~INFFL_LOADIDC&get_inf_attr(INF_GENFLAGS));
}

//------------------------------------------------------------------------
// General information

static GenInfo(void) {

        delete_all_segments();    // purge database
	set_processor_type("80386r", SETPROC_USER);
	set_inf_attr(INF_COMPILER, 0);
	set_inf_attr(INF_STRLIT_BREAK, 0xA);
	set_flag(INF_CMTFLAG, SW_ALLCMT, 0);
	set_flag(INF_OUTFLAGS, OFLG_SHOW_VOID, 0);
	set_inf_attr(INF_XREFNUM, 2);
	set_flag(INF_OUTFLAGS, OFLG_SHOW_AUTO, 1);
	set_inf_attr(INF_INDENT, 16);
	set_inf_attr(INF_COMMENT, 40);
	set_inf_attr(INF_MAXREF, 0x10);
}

//------------------------------------------------------------------------
// Information about segmentation

static Segments(void) {
	;
	add_segm_ex(0,0X1346,0,0,1,2,ADDSEG_NOSREG);
	SegRename(0,"DOSDATA");
	SegClass (0,"DOSDATA");
	add_segm_ex(0X3F10,0XD210,0,0,1,2,ADDSEG_NOSREG);
	SegRename(0X3F10,"DOSCODE");
	SegClass (0X3F10,"DOSCODE");
	set_inf_attr(INF_LOW_OFF, 0x0);
	set_inf_attr(INF_HIGH_OFF, 0xE556);
}

//------------------------------------------------------------------------
// Information about enum types

static Enums(void) {
        auto id;
        begin_type_updating(UTP_ENUM);
        end_type_updating(UTP_ENUM);
}

//------------------------------------------------------------------------
// Information about type information for structure members

static ApplyStrucTInfos() {
}

//------------------------------------------------------------------------
// Information about structure types

static Structures(void) {
        auto id;
        begin_type_updating(UTP_STRUCT);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_0(void) {
        auto x;
#define id x

	create_byte	(0);
	make_array	(0,	0X4);
	create_word	(0X4);
	set_name	(0X4,	"DataVersion");
	create_byte	(0X6);
	make_array	(0X6,	0X8);
	set_name	(0X6,	"WinoldPatch1");
	create_word	(0XE);
	set_name	(0XE,	"MYNUM");
	create_word	(0X10);
	set_name	(0X10,	"FCBLRU");
	create_word	(0X12);
	set_name	(0X12,	"OpenLRU");
	create_dword	(0X14);
	set_name	(0X14,	"OEM_HANDLER");
	create_word	(x=0X18);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X18,	"LeaveAddr");
	create_word	(0X1A);
	set_name	(0X1A,	"RetryCount");
	create_word	(0X1C);
	set_name	(0X1C,	"RetryLoop");
	create_dword	(0X1E);
	set_name	(0X1E,	"LastBuffer");
	create_word	(0X22);
	set_name	(0X22,	"CONTPOS");
	create_word	(0X24);
	set_name	(0X24,	"arena_head");
	create_dword	(0X26);
	set_name	(0X26,	"DPBHEAD");
	create_dword	(x=0X2A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X2A,	"SFT_ADDR");
	create_dword	(0X2E);
	set_name	(0X2E,	"BCLOCK");
	create_dword	(0X32);
	set_name	(0X32,	"BCON");
	create_word	(x=0X36);
	op_dec		(x,	0);
	set_name	(0X36,	"MAXSEC");
	create_dword	(0X38);
	set_name	(0X38,	"BUFFHEAD");
	create_dword	(0X3C);
	set_name	(0X3C,	"CDSADDR");
	create_dword	(0X40);
	set_name	(0X40,	"SFTFCB");
	create_word	(0X44);
	set_name	(0X44,	"KEEPCOUNT");
	create_byte	(0X46);
	set_name	(0X46,	"NUMIO");
	create_byte	(0X47);
	set_name	(0X47,	"CDSCOUNT");
	create_word	(0X48);
	make_array	(0X48,	0X2);
	set_name	(0X48,	"NULDEV");
	set_cmt	(0X4C,	"Null device attributes = DEVTYP|ISNULL",	0);
	create_word	(0X4C);
	set_cmt	(0X4E,	"Strategy entry point",	0);
	create_word	(x=0X4E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X50,	"Interrupt entry point",	0);
	create_word	(x=0X50);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X52,	"Name of null device",	0);
	create_strlit	(0X52,	0X5A);
	create_byte	(0X5A);
	set_name	(0X5A,	"SPLICES");
	create_word	(0X5B);
	set_name	(0X5B,	"Special_Entries");
	create_dword	(0X5D);
	set_name	(0X5D,	"UU_IFS_DOS_CALL");
	create_word	(0X61);
	set_name	(0X61,	"ChkCopyProt");
	create_word	(0X63);
	set_name	(0X63,	"A20OFF_PSP");
	create_word	(0X65);
	set_name	(0X65,	"BUFFERS_PARM1");
	create_word	(0X67);
	set_name	(0X67,	"BUFFERS_PARM2");
	create_byte	(0X69);
	set_name	(0X69,	"BOOTDRIVE");
	create_byte	(0X6A);
	set_name	(0X6A,	"DDMOVE");
	create_word	(0X6B);
	set_name	(0X6B,	"EXT_MEM_SIZE");
	set_cmt	(0X6D,	"HASHINITVAR",	0);
	create_dword	(0X6D);
	set_name	(0X6D,	"BufferQueue");
	create_word	(0X71);
	set_name	(0X71,	"DirtyBufferCount");
	create_dword	(0X73);
	set_name	(0X73,	"SC_CACHE_PTR");
	create_word	(0X77);
	set_name	(0X77,	"SC_CACHE_COUNT");
	create_byte	(0X79);
	set_name	(0X79,	"BuffInHMA");
	create_dword	(0X7A);
	set_name	(0X7A,	"LoMemBuff");
	create_byte	(0X7E);
	make_array	(0X7E,	0X3);
	set_name	(0X7E,	"UU_BUF_EMS_FIRST_PAGE");
	create_word	(0X81);
	set_name	(0X81,	"CL0FATENTRY");
	create_byte	(0X83);
	set_name	(0X83,	"IoStatFail");
	create_byte	(0X84);
	set_name	(0X84,	"ALLOCMSAVE");
	create_byte	(0X85);
	set_name	(0X85,	"A20OFF_COUNT");
	create_byte	(0X86);
	set_name	(0X86,	"DOS_FLAG");
	create_word	(0X87);
	set_name	(0X87,	"UNPACK_OFFSET");
	create_byte	(0X89);
	set_name	(0X89,	"UMBFLAG");
	create_word	(0X8A);
	set_name	(0X8A,	"SAVE_AX");
	create_word	(0X8C);
	set_name	(0X8C,	"UMB_HEAD");
	create_word	(0X8E);
	set_name	(0X8E,	"START_ARENA");
	create_dword	(x=0X90);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X90,	"JShare");
	create_dword	(x=0X94);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X94,	"MFT_enter");
	create_dword	(x=0X98);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X98,	"MFTClose");
	create_dword	(x=0X9C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X9C,	"MFTclU");
	create_dword	(x=0XA0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XA0,	"MFTCloseP");
	create_dword	(x=0XA4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XA4,	"MFTCloN");
	create_dword	(x=0XA8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XA8,	"set_block");
	create_dword	(x=0XAC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XAC,	"clr_block");
	create_dword	(x=0XB0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB0,	"chk_block");
	create_dword	(x=0XB4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB4,	"MFT_get");
	create_dword	(x=0XB8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB8,	"ShSave");
	create_dword	(x=0XBC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XBC,	"ShChk");
	create_dword	(x=0XC0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC0,	"ShCol");
	create_dword	(x=0XC4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC4,	"ShCloseFile");
	create_dword	(x=0XC8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC8,	"ShSU");
	create_dword	(0XCC);
	set_name	(0XCC,	"SFTABL");
	set_cmt	(0XD0,	"sf_default_number",	0);
	create_word	(0XD0);
	create_byte	(x=0XD2);
	make_array	(x,	0X127);
	op_dec		(x,	0);
	set_name	(0XD2,	"SFT0_SFTable");
	create_byte	(0X1F9);
	set_name	(0X1F9,	"CARPOS");
	create_byte	(0X1FA);
	set_name	(0X1FA,	"STARTPOS");
	create_byte	(x=0X1FB);
	make_array	(x,	0X80);
	op_dec		(x,	0);
	set_name	(0X1FB,	"INBUF");
	create_byte	(x=0X27B);
	make_array	(x,	0X83);
	op_dec		(x,	0);
	set_name	(0X27B,	"CONBUF");
	create_byte	(0X2FE);
	set_name	(0X2FE,	"PFLAG");
	create_byte	(0X2FF);
	set_name	(0X2FF,	"VDERFLG");
	create_byte	(0X300);
	set_name	(0X300,	"CHARCO");
	create_byte	(x=0X301);
	op_chr		(x,	0);
	set_name	(0X301,	"chSwitch");
	create_byte	(0X302);
	set_name	(0X302,	"AllocMethod");
	create_byte	(0X303);
	set_name	(0X303,	"fShare");
	create_byte	(0X304);
	set_name	(0X304,	"DIFFNAM");
	create_byte	(0X305);
	make_array	(0X305,	0X10);
	set_name	(0X305,	"MYNAME");
	create_word	(x=0X315);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X315,	"CritPatch");
	create_word	(x=0X317);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X319);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X31B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0X31D);
	set_cmt	(0X31F,	"SWAPPABLE DATA AREA",	0);
	create_byte	(0X31F);
	set_cmt	(0X320,	"critical error flag",	0);
	create_byte	(0X320);
	set_name	(0X320,	"ERRORMODE");
	create_byte	(0X321);
	set_name	(0X321,	"INDOS");
	set_cmt	(0X322,	"drive on which current critical error occurred",	0);
	create_byte	(0X322);
	set_name	(0X322,	"WPERR");
	set_cmt	(0X323,	"locus of last error",	0);
	create_byte	(0X323);
	set_name	(0X323,	"EXTERR_LOCUS");
	set_cmt	(0X324,	"extended error code of last error",	0);
	create_word	(0X324);
	set_name	(0X324,	"EXTERR");
	set_cmt	(0X326,	"suggested action for last error",	0);
	create_byte	(0X326);
	set_name	(0X326,	"EXTERR_ACTION");
	set_cmt	(0X327,	"class of last error",	0);
	create_byte	(0X327);
	set_name	(0X327,	"EXTERR_CLASS");
	set_cmt	(0X328,	"Extended Error pointer",	0);
	create_dword	(0X328);
	set_name	(0X328,	"EXTERRPT");
	set_cmt	(0X32C,	"current DTA (Disk Transfer Address)",	0);
	create_dword	(0X32C);
	set_name	(0X32C,	"DMAADD");
	create_word	(0X330);
	set_name	(0X330,	"CurrentPDB");
	create_word	(0X332);
	set_name	(0X332,	"ConC_Spsave");
	create_word	(0X334);
	set_name	(0X334,	"exit_code");
	create_byte	(0X336);
	set_name	(0X336,	"CURDRV");
	create_byte	(0X337);
	set_name	(0X337,	"CNTCFLAG");
	create_byte	(0X338);
	set_name	(0X338,	"CPSWFLAG");
	create_byte	(0X339);
	set_name	(0X339,	"CPSWSAVE");
	create_word	(0X33A);
	set_name	(0X33A,	"USER_IN_AX");
	create_word	(0X33C);
	set_name	(0X33C,	"PROC_ID");
	create_word	(0X33E);
	set_name	(0X33E,	"USER_ID");
	create_word	(0X340);
	set_name	(0X340,	"FirstArena");
	create_word	(0X342);
	set_name	(0X342,	"BestArena");
	create_word	(0X344);
	set_name	(0X344,	"LastArena");
	create_word	(0X346);
	set_name	(0X346,	"ENDMEM");
	create_word	(0X348);
	set_name	(0X348,	"LASTENT");
	create_byte	(0X34A);
	set_name	(0X34A,	"FAILERR");
	create_byte	(0X34B);
	set_name	(0X34B,	"ALLOWED");
	create_byte	(0X34C);
	set_name	(0X34C,	"NoSetDir");
	create_byte	(0X34D);
	set_name	(0X34D,	"DidCTRLC");
	create_byte	(0X34E);
	set_name	(0X34E,	"SpaceFlag");
	create_byte	(0X34F);
	create_byte	(0X350);
	set_name	(0X350,	"DAY");
	create_byte	(0X351);
	set_name	(0X351,	"MONTH");
	set_cmt	(0X352,	"YEAR (and CENTURY)",	0);
	create_word	(0X352);
	set_name	(0X352,	"YEAR");
	create_word	(0X354);
	set_name	(0X354,	"DAYCNT");
	create_byte	(0X356);
	set_name	(0X356,	"WEEKDAY");
	create_byte	(0X357);
	set_name	(0X357,	"CONSWAP");
	create_byte	(0X358);
	set_name	(0X358,	"IDLEINT");
	create_byte	(0X359);
	set_name	(0X359,	"fAborting");
	set_cmt	(0X35A,	"offset DEVCALL",	0);
	create_byte	(0X35A);
	set_name	(0X35A,	"DEVCALL_REQLEN");
	create_byte	(0X35B);
	set_name	(0X35B,	"DEVCALL_REQUNIT");
	create_byte	(0X35C);
	set_name	(0X35C,	"DEVCALL_REQFUNC");
	create_word	(0X35D);
	set_name	(0X35D,	"DEVCALL_REQSTAT");
	create_byte	(0X35F);
	make_array	(0X35F,	0X8);
	set_cmt	(0X367,	"CALLMED ; media byte",	0);
	create_byte	(0X367);
	set_name	(0X367,	"CALLUNIT");
	set_cmt	(0X368,	"CALLXAD ; dword",	0);
	create_byte	(0X368);
	set_name	(0X368,	"CALLBR");
	create_byte	(0X369);
	set_name	(0X369,	"CALLVIDM");
	create_word	(0X36A);
	set_name	(0X36A,	"CALLXAD_2");
	set_cmt	(0X36C,	"CALLSCNT",	0);
	create_word	(0X36C);
	set_name	(0X36C,	"CALLBPB");
	create_word	(0X36E);
	set_name	(0X36E,	"CALLSSEC");
	create_dword	(0X370);
	set_name	(0X370,	"CALLVIDRW");
	create_word	(0X374);
	make_array	(0X374,	0X2);
	set_name	(0X374,	"CALLNEWSC");
	create_dword	(0X378);
	set_name	(0X378,	"CALLDEVAD");
	create_byte	(0X37C);
	set_name	(0X37C,	"IOCALL");
	create_byte	(0X37D);
	set_name	(0X37D,	"IOCALL_REQUNIT");
	create_byte	(0X37E);
	set_name	(0X37E,	"IOCALL_REQFUNC");
	create_word	(0X37F);
	set_name	(0X37F,	"IOCALL_REQSTAT");
	create_byte	(0X381);
	make_array	(0X381,	0X8);
	create_byte	(0X389);
	set_name	(0X389,	"IOMED");
	create_dword	(0X38A);
	set_name	(0X38A,	"IOXAD");
	create_word	(0X38E);
	set_name	(0X38E,	"IOSCNT");
	create_word	(0X390);
	set_name	(0X390,	"IOSSEC");
	create_byte	(x=0X392);
	op_dec		(x,	0);
	set_name	(0X392,	"DSKSTCALL");
	create_byte	(0X393);
	create_byte	(0X394);
	set_name	(0X394,	"DSKSTCOM");
	create_word	(0X395);
	set_name	(0X395,	"DSKSTST");
	create_byte	(0X397);
	make_array	(0X397,	0X8);
	create_byte	(0X39F);
	set_name	(0X39F,	"DSKCHRET");
	create_word	(x=0X3A0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X3A0,	"DEVIOBUF_PTR");
	create_word	(0X3A2);
	set_name	(0X3A2,	"DOSSEG_INIT");
	create_word	(0X3A4);
	set_name	(0X3A4,	"DSKSTCNT");
	create_word	(0X3A6);
	create_byte	(0X3A8);
	set_name	(0X3A8,	"CreatePDB");
	create_dword	(0X3A9);
	set_name	(0X3A9,	"Lock_Buffer");
	create_dword	(0X3AD);
	create_byte	(0X3B1);
	set_name	(0X3B1,	"IOCTL_drvnum");
	create_dword	(0X3B2);
	set_name	(0X3B2,	"USERNUM");
	set_cmt	(0X3B6,	"MSDAT001S",	0);
	create_word	(0X3B6);
	make_array	(0X3B6,	0X3);
	set_name	(0X3B6,	"TIMEBUF");
	create_word	(0X3BC);
	set_name	(0X3BC,	"DEVIOBUF");
	create_byte	(x=0X3BE);
	make_array	(x,	0X80);
	op_dec		(x,	0);
	set_name	(0X3BE,	"OPENBUF");
	create_byte	(x=0X43E);
	make_array	(x,	0X80);
	op_dec		(x,	0);
	set_name	(0X43E,	"RENBUF");
	create_byte	(x=0X4BE);
	make_array	(x,	0X35);
	op_dec		(x,	0);
	set_name	(0X4BE,	"SEARCHBUF");
	create_byte	(x=0X4F3);
	make_array	(x,	0X58);
	op_dec		(x,	0);
	set_name	(0X4F3,	"DUMMYCDS");
	set_cmt	(0X54B,	"DEVFCB",	0);
	create_byte	(x=0X54B);
	make_array	(x,	0XC);
	op_dec		(x,	0);
	set_name	(0X54B,	"NAME1");
	create_byte	(x=0X557);
	make_array	(x,	0XD);
	op_dec		(x,	0);
	set_name	(0X557,	"NAME2");
	create_word	(0X564);
	set_name	(0X564,	"DESTSTART");
	set_cmt	(0X566,	"((dir_entry.size)-($-DEVFCB))",	0);
	create_byte	(0X566);
	make_array	(0X566,	0X5);
	create_byte	(0X56B);
	set_name	(0X56B,	"ATTRIB");
	create_byte	(0X56C);
	set_name	(0X56C,	"EXTFCB");
	create_byte	(0X56D);
	set_name	(0X56D,	"SATTRIB");
	create_byte	(0X56E);
	set_name	(0X56E,	"OPEN_ACCESS");
	create_byte	(0X56F);
	set_name	(0X56F,	"FOUNDDEL");
	create_byte	(0X570);
	set_name	(0X570,	"FOUND_DEV");
	create_byte	(0X571);
	set_name	(0X571,	"FSPLICE");
	create_byte	(0X572);
	set_name	(0X572,	"FSHARING");
	create_byte	(0X573);
	set_name	(0X573,	"SECCLUSPOS");
	create_byte	(0X574);
	set_name	(0X574,	"TRANS");
	create_byte	(0X575);
	set_name	(0X575,	"READOP");
	create_byte	(0X576);
	set_name	(0X576,	"THISDRV");
	create_byte	(0X577);
	set_name	(0X577,	"CLUSFAC");
	create_byte	(0X578);
	set_name	(0X578,	"CLUSSPLIT");
	create_byte	(0X579);
	set_name	(0X579,	"INSMODE");
	create_byte	(0X57A);
	set_name	(0X57A,	"CMETA");
	create_byte	(0X57B);
	set_name	(0X57B,	"VOLID");
	create_word	(0X57C);
	set_name	(0X57C,	"EXIT_TYPE");
	create_byte	(0X57E);
	set_name	(0X57E,	"CREATING");
	create_byte	(0X57F);
	set_name	(0X57F,	"DELALL");
	create_dword	(0X580);
	set_name	(0X580,	"EXITHOLD");
	create_word	(0X584);
	set_name	(0X584,	"USER_SP");
	create_word	(0X586);
	set_name	(0X586,	"USER_SS");
	create_word	(0X588);
	set_name	(0X588,	"CONTSTK");
	create_dword	(0X58A);
	set_name	(0X58A,	"THISDPB");
	create_word	(0X58E);
	set_name	(0X58E,	"CLUSSAVE");
	create_dword	(0X590);
	set_name	(0X590,	"CLUSSEC");
	create_word	(0X594);
	set_name	(0X594,	"PREREAD");
	create_word	(0X596);
	set_name	(0X596,	"FATBYT");
	create_word	(0X598);
	set_name	(0X598,	"FATBYTE");
	create_dword	(0X59A);
	set_name	(0X59A,	"DEVPT");
	create_dword	(0X59E);
	set_name	(0X59E,	"THISSFT");
	create_dword	(0X5A2);
	set_name	(0X5A2,	"THISCDS");
	create_dword	(0X5A6);
	set_name	(0X5A6,	"THISFCB");
	create_word	(0X5AA);
	set_name	(0X5AA,	"SFN");
	create_word	(0X5AC);
	set_name	(0X5AC,	"JFN");
	create_dword	(0X5AE);
	set_name	(0X5AE,	"PJFN");
	create_word	(0X5B2);
	set_name	(0X5B2,	"WFP_START");
	create_word	(0X5B4);
	set_name	(0X5B4,	"REN_WFP");
	create_word	(0X5B6);
	set_name	(0X5B6,	"CURR_DIR_END");
	create_word	(0X5B8);
	set_name	(0X5B8,	"NEXTADD");
	create_word	(0X5BA);
	set_name	(0X5BA,	"LASTPOS");
	create_word	(0X5BC);
	set_name	(0X5BC,	"CLUSNUM");
	create_word	(0X5BE);
	make_array	(0X5BE,	0X2);
	set_name	(0X5BE,	"DIRSEC");
	create_word	(0X5C2);
	set_name	(0X5C2,	"DIRSTART");
	create_dword	(0X5C4);
	set_name	(0X5C4,	"SECPOS");
	create_word	(0X5C8);
	make_array	(0X5C8,	0X2);
	set_name	(0X5C8,	"VALSEC");
	create_word	(0X5CC);
	set_name	(0X5CC,	"BYTSECPOS");
	create_dword	(0X5CE);
	set_name	(0X5CE,	"BYTPOS");
	create_word	(0X5D2);
	set_name	(0X5D2,	"BYTCNT1");
	create_word	(0X5D4);
	set_name	(0X5D4,	"BYTCNT2");
	create_word	(0X5D6);
	set_name	(0X5D6,	"SECCNT");
	create_word	(0X5D8);
	set_name	(0X5D8,	"ENTFREE");
	create_word	(0X5DA);
	set_name	(0X5DA,	"ENTLAST");
	create_word	(0X5DC);
	set_name	(0X5DC,	"NXTCLUSNUM");
	create_dword	(0X5DE);
	set_name	(0X5DE,	"GROWCNT");
	create_dword	(0X5E2);
	set_name	(0X5E2,	"CURBUF");
	create_dword	(0X5E6);
	set_name	(0X5E6,	"CONSFT");
	create_word	(0X5EA);
	set_name	(0X5EA,	"SAVEBX");
	create_word	(0X5EC);
	set_name	(0X5EC,	"SAVEDS");
	create_word	(0X5EE);
	set_name	(0X5EE,	"RESTORE_TMP");
	create_word	(0X5F0);
	set_name	(0X5F0,	"NSS");
	create_word	(0X5F2);
	set_name	(0X5F2,	"NSP");
	create_word	(0X5F4);
	set_name	(0X5F4,	"EXTOPEN_FLAG");
	create_byte	(0X5F6);
	set_name	(0X5F6,	"EXTOPEN_ON");
	create_word	(0X5F7);
	set_name	(0X5F7,	"EXTOPEN_IO_MODE");
	create_word	(0X5F9);
	set_name	(0X5F9,	"SAVE_DI");
	create_word	(0X5FB);
	set_name	(0X5FB,	"SAVE_ES");
	create_word	(0X5FD);
	set_name	(0X5FD,	"SAVE_DX");
	create_word	(0X5FF);
	set_name	(0X5FF,	"SAVE_CX");
	create_word	(0X601);
	set_name	(0X601,	"SAVE_BX");
	create_word	(0X603);
	set_name	(0X603,	"SAVE_SI");
	create_word	(0X605);
	set_name	(0X605,	"SAVE_DS");
	create_word	(0X607);
	set_name	(0X607,	"HIGH_SECTOR");
	create_word	(x=0X609);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X609,	"OffsetMagicPatch");
	create_byte	(0X60B);
	set_name	(0X60B,	"DISK_FULL");
	create_word	(0X60C);
	set_name	(0X60C,	"TEMP_VAR");
	create_word	(0X60E);
	set_name	(0X60E,	"TEMP_VAR2");
	create_byte	(0X610);
	set_name	(0X610,	"DrvErr");
	create_word	(0X611);
	set_name	(0X611,	"DOS34_FLAG");
	create_dword	(0X613);
	set_name	(0X613,	"NO_FILTER_PATH");
	create_dword	(0X617);
	set_name	(0X617,	"NO_FILTER_DPATH");
	create_word	(0X61B);
	set_name	(0X61B,	"AbsRdWr_SS");
	create_word	(0X61D);
	set_name	(0X61D,	"AbsRdWr_SP");
	create_byte	(0X61F);
	create_byte	(x=0X620);
	make_array	(x,	0X180);
	op_dec		(x,	0);
	set_name	(0X620,	"RENAMEDMA");
	create_byte	(x=0X7A0);
	make_array	(x,	0X180);
	op_dec		(x,	0);
	set_name	(0X7A0,	"AUXSTACK");
	create_strlit	(0X920,	0X94E);
	set_name	(0X920,	"DSKSTACK");
	set_cmt	(0X94E,	"IOSTACK (just after DSKSTACK)",	0);
	create_byte	(x=0X94E);
	make_array	(x,	0X152);
	op_dec		(x,	0);
	create_byte	(0XAA0);
	set_name	(0XAA0,	"PRINTER_FLAG");
	create_byte	(0XAA1);
	set_name	(0XAA1,	"VOLCHNG_FLAG");
	create_byte	(0XAA2);
	create_word	(0XAA3);
	set_name	(0XAA3,	"TEMP_DOSLOC");
	create_word	(0XAA5);
	set_name	(0XAA5,	"LNE_COUNT");
	create_byte	(x=0XAA7);
	make_array	(x,	0XE);
	op_dec		(x,	0);
	create_word	(0XAB5);
	set_name	(0XAB5,	"ENTLAST_PREV");
	create_byte	(x=0XAB7);
	make_array	(x,	0X24);
	op_dec		(x,	0);
	create_byte	(0XADB);
	set_name	(0XADB,	"absdrw_extd");
	create_word	(0XADC);
	set_name	(0XADC,	"DIRSTART_HW");
	create_word	(0XADE);
	set_name	(0XADE,	"CLUSNUM_HW");
	create_word	(0XAE0);
	set_name	(0XAE0,	"NXTCLUSNUM_HW");
	create_word	(0XAE2);
	set_name	(0XAE2,	"LASTPOS_HW");
	create_word	(0XAE4);
	set_name	(0XAE4,	"FATBYT_HW");
	create_word	(0XAE6);
	set_name	(0XAE6,	"DESTSTART_HW");
	create_word	(0XAE8);
	set_name	(0XAE8,	"CLUSTNUM_HW");
	set_cmt	(0XAEA,	"(0 = release, -1 = allocate) INPUT for PACK",	0);
	create_word	(0XAEA);
	set_name	(0XAEA,	"CLUSDATA_HW");
	set_cmt	(0XAEC,	"UNPACK output",	0);
	create_word	(0XAEC);
	set_name	(0XAEC,	"CCONTENT_HW");
	create_word	(0XAEE);
	set_name	(0XAEE,	"ROOTCLUST_HW");
	set_cmt	(0XAF0,	"for ALLOCATE",	0);
	create_word	(0XAF0);
	set_name	(0XAF0,	"CCOUNT_HW");
	create_word	(0XAF2);
	set_name	(0XAF2,	"CLUSTERS_HW");
	create_word	(0XAF4);
	create_word	(0XAF6);
	set_cmt	(0XAF8,	"\nSWAP_END",	0);
	create_word	(0XAF8);
	set_name	(0XAF8,	"CLSKIP_HW");
	create_word	(x=0XAFA);
	op_dec		(x,	0);
	set_name	(0XAFA,	"UCASE_TAB");
	create_byte	(x=0XAFC);
	make_array	(x,	0X80);
	op_dec		(x,	0);
	set_name	(0XAFC,	"UCASE_TAB_2");
	create_word	(x=0XB7C);
	op_dec		(x,	0);
	set_name	(0XB7C,	"FILE_UCASE_TAB");
	create_byte	(x=0XB7E);
	make_array	(x,	0X80);
	op_dec		(x,	0);
	set_name	(0XB7E,	"FILE_UCASE_TAB_2");
	create_word	(x=0XBFE);
	op_dec		(x,	0);
	set_name	(0XBFE,	"COLLATE_TAB");
	create_byte	(x=0XC00);
	make_array	(x,	0X20);
	op_dec		(x,	0);
	create_strlit	(0XC20,	0XC7F);
	create_byte	(x=0XC7F);
	op_dec		(x,	0);
	create_strlit	(0XC80,	0XCA6);
	create_byte	(x=0XCA6);
	make_array	(x,	0X2);
	op_dec		(x,	0);
	create_byte	(x=0XCA8);
	op_chr		(x,	0);
	create_byte	(x=0XCA9);
	make_array	(x,	0X4);
	op_dec		(x,	0);
	create_byte	(x=0XCAD);
	make_array	(x,	0X3);
	op_chr		(x,	0);
	create_byte	(x=0XCB0);
	make_array	(x,	0X31);
	op_dec		(x,	0);
	create_byte	(x=0XCE1);
	op_chr		(x,	0);
	create_byte	(x=0XCE2);
	make_array	(x,	0X1E);
	op_dec		(x,	0);
	create_word	(0XD00);
	set_name	(0XD00,	"DBCS_TAB");
	create_byte	(x=0XD02);
	make_array	(x,	0X10);
	op_dec		(x,	0);
	set_name	(0XD02,	"DBCS_TAB_2");
	create_byte	(0XD12);
	set_name	(0XD12,	"IBMDOSVERSION");
	set_cmt	(0XD13,	"MSVERSION",	0);
	create_byte	(x=0XD13);
	op_dec		(x,	0);
	create_byte	(x=0XD14);
	make_array	(x,	0X8);
	op_dec		(x,	0);
	set_name	(0XD14,	"YRTAB");
	create_byte	(x=0XD1C);
	op_dec		(x,	0);
	set_name	(0XD1C,	"MONTAB");
	create_byte	(x=0XD1D);
	op_dec		(x,	0);
	set_name	(0XD1D,	"february");
	create_byte	(x=0XD1E);
	make_array	(x,	0XA);
	op_dec		(x,	0);
	set_cmt	(0XD28,	"length",	0);
	create_word	(x=0XD28);
	op_dec		(x,	0);
	set_name	(0XD28,	"FILE_CHAR_TAB");
	set_cmt	(0XD29,	"length",	0);
	set_cmt	(0XD2A,	"include all",	0);
	create_byte	(0XD2A);
	create_byte	(0XD2B);
	create_byte	(x=0XD2C);
	op_dec		(x,	0);
	set_cmt	(0XD2D,	"exclude 0 - 20h",	0);
	create_byte	(0XD2D);
	create_byte	(0XD2E);
	create_byte	(0XD2F);
	create_byte	(0XD30);
	set_cmt	(0XD31,	"exclude 14 special",	0);
	create_byte	(x=0XD31);
	op_dec		(x,	0);
	create_strlit	(0XD32,	0XD40);
	set_cmt	(0XD40,	"reserved",	0);
	create_byte	(x=0XD40);
	make_array	(x,	0X18);
	op_dec		(x,	0);
	set_cmt	(0XD58,	"SYSINITVARS",	0);
	create_word	(x=0XD58);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XD58,	"SysInitTable");
	create_word	(0XD5A);
	create_word	(x=0XD5C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0XD5E);
	create_byte	(0XD60);
	make_array	(0XD60,	0X3);
	create_word	(0XD63);
	set_name	(0XD63,	"TEMPSEG");
	create_byte	(0XD65);
	set_name	(0XD65,	"redir_patch");
	create_byte	(0XD66);
	set_name	(0XD66,	"DosHasHMA");
	create_word	(0XD67);
	set_name	(0XD67,	"FixExePatch");
	create_word	(0XD69);
	set_name	(0XD69,	"RationalPatchPtr");
	create_insn	(0XD6B);
	set_name	(0XD6B,	"MAP_CASE");
	set_cmt	(0XD6D,	"Map no chars below 80H ever",	0);
	set_cmt	(0XD6F,	"\nTurn into index value",	0);
	set_name	(0XD6F,	"Map1");
	set_cmt	(0XD73,	"UCASE_TAB+2",	0);
	create_insn	(x=0XD73);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD78,	"Get upper case character",	0);
	set_name	(0XD7B,	"L_RET");
	create_byte	(x=0XD7C);
	make_array	(x,	0X20);
	op_dec		(x,	0);
	set_name	(0XD7C,	"Dir_Info_Buff");
	create_word	(0XD9C);
	set_name	(0XD9C,	"Next_Element_Start");
	create_word	(x=0XD9E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XD9E,	"USER_SP_2F");
	set_cmt	(0XDA0,	"Packet_Temp",	0);
	create_word	(x=0XDA0);
	make_array	(x,	0XE);
	op_dec		(x,	0);
	set_name	(0XDA0,	"FAKE_STACK_2F");
	create_byte	(0XDBC);
	set_name	(0XDBC,	"SCAN_FLAG");
	create_word	(0XDBD);
	set_name	(0XDBD,	"DATE_FLAG");
	set_cmt	(0XDBF,	"Storage for Abs dsk read/write err",	0);
	create_word	(0XDBF);
	set_name	(0XDBF,	"AbsDskErr");
	set_cmt	(0XDC1,	"null media id",	0);
	create_strlit	(0XDC1,	0XDCC);
	set_name	(0XDC1,	"NO_NAME_ID");
	create_byte	(0XDCC);
	set_name	(0XDCC,	"LOOKSIZ");
	set_cmt	(0XDCD,	"[es:bx+SRHEAD.REQSTAT],STDON",	0);
	create_insn	(x=0XDCD);
	op_hex		(x,	1);
	set_name	(0XDCD,	"SNULDEV");
	set_name	(0XDD3,	"INULDEV");
	create_byte	(0XDD4);
	create_byte	(0XDD5);
	make_array	(0XDD5,	0X5);
	set_name	(0XDD5,	"UmbSave2");
	create_byte	(0XDDA);
	set_name	(0XDDA,	"UmbSaveFlag");
	set_cmt	(0XDDB,	"CLASS ACTION and LOCUS info for the INT 21h errors",	0);
	create_byte	(0XDDB);
	make_array	(0XDDB,	0X80);
	set_name	(0XDDB,	"ERR_TABLE_21");
	set_cmt	(0XE5B,	"CLASS ACTION and LOCUS info for the INT 24h errors",	0);
	create_byte	(0XE5B);
	make_array	(0XE5B,	0X50);
	set_name	(0XE5B,	"ERR_TABLE_24");
	create_byte	(0XEAB);
	make_array	(0XEAB,	0X10);
	set_name	(0XEAB,	"ErrMap24");
	create_word	(0XEBB);
	set_name	(0XEBB,	"SPECIAL_VERSION");
	create_word	(0XEBD);
	set_name	(0XEBD,	"OLD_FIRSTCLUS");
	create_word	(0XEBF);
	set_name	(0XEBF,	"exec_init_SP");
	create_word	(0XEC1);
	set_name	(0XEC1,	"exec_init_SS");
	create_word	(0XEC3);
	set_name	(0XEC3,	"exec_init_IP");
	create_word	(0XEC5);
	set_name	(0XEC5,	"exec_init_CS");
	create_word	(0XEC7);
	set_name	(0XEC7,	"exec_signature");
	create_word	(0XEC9);
	set_name	(0XEC9,	"exec_len_mod_512");
	create_word	(0XECB);
	set_name	(0XECB,	"exec_pages");
	create_word	(0XECD);
	set_name	(0XECD,	"exec_rle_count");
	create_word	(0XECF);
	set_name	(0XECF,	"exec_par_dir");
	create_word	(0XED1);
	set_name	(0XED1,	"exec_min_BSS");
	create_word	(0XED3);
	set_name	(0XED3,	"exec_max_BSS");
	create_word	(0XED5);
	set_name	(0XED5,	"exec_SS");
	create_word	(0XED7);
	set_name	(0XED7,	"exec_SP");
	create_word	(0XED9);
	set_name	(0XED9,	"exec_chksum");
	create_word	(0XEDB);
	set_name	(0XEDB,	"exec_IP");
	create_word	(0XEDD);
	set_name	(0XEDD,	"exec_CS");
	create_word	(0XEDF);
	set_name	(0XEDF,	"exec_rle_table");
	set_cmt	(0XEE1,	"WIN386_SIS version",	0);
	create_byte	(0XEE1);
	make_array	(0XEE1,	0X2);
	set_name	(0XEE1,	"Win386_Info");
	set_cmt	(0XEE3,	".Next_Dev_Ptr",	0);
	create_dword	(0XEE3);
	set_cmt	(0XEE7,	".Virt_Dev_File_Ptr",	0);
	create_dword	(0XEE7);
	set_name	(0XEE7,	"Win386_Inf_Virt_Dev_Ptr");
	set_cmt	(0XEEB,	".Reference_Data",	0);
	create_dword	(0XEEB);
	create_word	(x=0XEEF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XEEF,	"Instance_Data_Ptr");
	create_word	(0XEF1);
	set_name	(0XEF1,	"Win386_Info_16");
	create_word	(x=0XEF3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XEF5,	"Win386_IIS.size",	0);
	create_word	(0XEF5);
	create_word	(x=0XEF7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XEF7,	"Instance_Table");
	create_word	(0XEF9);
	set_name	(0XEF9,	"InsTBL_CONTPOS_seg");
	create_word	(0XEFB);
	create_word	(x=0XEFD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0XEFF);
	create_word	(0XF01);
	create_word	(x=0XF03);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0XF05);
	create_word	(0XF07);
	create_word	(x=0XF09);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0XF0B);
	create_word	(0XF0D);
	create_word	(x=0XF0F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0XF11);
	create_word	(0XF13);
	create_word	(x=0XF15);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0XF17);
	create_word	(0XF19);
	create_word	(x=0XF1B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0XF1D);
	create_word	(0XF1F);
	create_word	(x=0XF21);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0XF23);
	create_word	(0XF25);
	set_cmt	(0XF27,	"what for ?",	0);
	create_word	(x=0XF27);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0XF29);
	create_word	(0XF2B);
	set_cmt	(0XF2D,	"\"devio call in progress\" status flag ptr",	0);
	create_word	(x=0XF2D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0XF2F);
	create_word	(0XF31);
	create_word	(0XF33);
	create_word	(0XF35);
	create_word	(0XF37);
	create_word	(0XF39);
	create_word	(0XF3B);
	set_name	(0XF3B,	"CL0FATENTRY_HW");
	create_word	(0XF3D);
	set_name	(0XF3D,	"Unknown_Table");
	create_word	(0XF3F);
	create_word	(x=0XF41);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0XF43);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0XF45);
	set_cmt	(0XF47,	"?",	0);
	create_word	(x=0XF47);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0XF49);
	create_word	(0XF4B);
	set_cmt	(0XF4D,	"Major_version",	0);
	create_byte	(0XF4D);
	set_name	(0XF4D,	"Win386_DOSVars");
	set_cmt	(0XF4E,	"Minor_version",	0);
	create_byte	(0XF4E);
	create_word	(x=0XF4F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0XF51);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0XF53);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0XF55);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0XF57);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0XF59);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_byte	(0XF5B);
	make_array	(0XF5B,	0X2);
	set_name	(0XF5B,	"IsWin386");
	set_cmt	(0XF5D,	"Patch for Sidekick",	0);
	create_byte	(0XF5D);
	make_array	(0XF5D,	0X6);
	create_byte	(0XF63);
	make_array	(0XF63,	0X2);
	create_byte	(0XF65);
	make_array	(0XF65,	0X5);
	create_byte	(0XF6A);
	make_array	(0XF6A,	0X2);
	set_cmt	(0XF6C,	"Patch for PortOfEntry",	0);
	create_byte	(0XF6C);
	make_array	(0XF6C,	0X5);
	create_byte	(0XF71);
	make_array	(0XF71,	0X2);
	create_byte	(0XF73);
	make_array	(0XF73,	0X3);
	create_dword	(0XF76);
	set_name	(0XF76,	"LocalSFT");
	create_dword	(x=0XF7A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XF7A,	"DOSINTTABLE");
	create_dword	(x=0XF7E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XF7E,	"DOSINTTABLE_4");
	create_dword	(x=0XF82);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XF82,	"DOSINTTABLE_8");
	create_dword	(x=0XF86);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XF86,	"DOSINTTABLE_12");
	create_dword	(x=0XF8A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XF8A,	"DOSINTTABLE_16");
	create_dword	(x=0XF8E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XF8E,	"DOSINTTABLE_20");
	create_dword	(x=0XF92);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XF92,	"DOSINTTABLE_24");
	create_dword	(x=0XF96);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XF96,	"DOSINTTABLE_28");
	create_word	(0XF9A);
	set_name	(0XF9A,	"SS_Save");
	create_word	(0XF9C);
	set_name	(0XF9C,	"SP_Save");
	set_cmt	(0XF9E,	"DIVIDE BY 0 handler",	0);
	create_insn	(0XF9E);
	set_name	(0XF9E,	"ldivov");
	set_cmt	(0XFA0,	"we must turn on A20 if OFF",	0);
	create_insn	(0XFA0);
	set_cmt	(0XFA3,	"jmp to DOS",	0);
	set_name	(0XFA3,	"divov_cont");
	set_cmt	(0XFA8,	"INT 20h Handler",	0);
	create_insn	(0XFA8);
	set_name	(0XFA8,	"lquit");
	create_insn	(0XFAA);
	set_cmt	(0XFAD,	"jmp far [cs:DOSINTTABLE+4] ; jump to DOS",	0);
	set_name	(0XFAD,	"quit_cont");
	set_cmt	(0XFB2,	"INT 21h Handler",	0);
	create_insn	(0XFB2);
	set_name	(0XFB2,	"lcommand");
	create_insn	(0XFB4);
	set_name	(0XFB7,	"command_cont");
	set_cmt	(0XFBC,	"INT 25h",	0);
	create_insn	(0XFBC);
	set_name	(0XFBC,	"labsdrd");
	create_insn	(0XFBE);
	set_name	(0XFC1,	"absdrd_cont");
	set_cmt	(0XFC6,	"INT 26h",	0);
	create_insn	(0XFC6);
	set_name	(0XFC6,	"labsdwrt");
	create_insn	(0XFC8);
	set_name	(0XFCB,	"absdwrt_cont");
	set_cmt	(0XFD0,	"INT 27h",	0);
	create_insn	(0XFD0);
	set_name	(0XFD0,	"lstay_resident");
	create_insn	(0XFD2);
	set_name	(0XFD5,	"sr_cont");
	set_cmt	(0XFDA,	"INT 2Fh",	0);
	create_insn	(0XFDA);
	set_name	(0XFDA,	"lint2f");
	set_cmt	(0XFDC,	"we must turn on A20 if OFF",	0);
	create_insn	(0XFDC);
	set_cmt	(0XFDF,	"jmp far [cs:DOSINTTABLE+24]",	0);
	set_name	(0XFDF,	"int2f_cont");
	set_cmt	(0XFE4,	"CPM entry",	0);
	create_insn	(0XFE4);
	set_name	(0XFE4,	"lcall_entry");
	create_insn	(0XFE6);
	set_cmt	(0XFE9,	"jmp far [cs:DOSINTTABLE+28] ; jmp to DOS",	0);
	set_name	(0XFE9,	"callentry_cont");
	create_dword	(0XFEE);
	set_name	(0XFEE,	"DosRetAddr23");
	create_dword	(0XFF2);
	set_name	(0XFF2,	"DosRetAddr24");
	create_insn	(0XFF6);
	set_name	(0XFF6,	"LowInt23");
	set_cmt	(0X1000,	"DOS - CONTROL \"C\" EXIT ADDRESS\nReturn: return via RETF 2 with CF set\nDOS will abort program with errorlevel 0\nelse\ninterrupted DOS call continues",	0);
	create_insn	(x=0X1000);
	op_hex		(x,	0);
	create_insn	(0X100A);
	set_name	(0X100A,	"LowInt24");
	set_cmt	(0X1014,	"DOS - FATAL ERROR HANDLER ADDRESS\nAutomatically called upon detection of unrecoverable I/O error.",	0);
	create_insn	(x=0X1014);
	op_hex		(x,	0);
	set_cmt	(0X101E,	"DOS 2+ internal - KEYBOARD BUSY LOOP",	0);
	create_insn	(x=0X101E);
	op_hex		(x,	0);
	set_name	(0X101E,	"LowInt28");
	set_cmt	(0X1024,	"disable A20",	0);
	create_insn	(0X1024);
	set_name	(0X1024,	"disa20_xfer");
	set_cmt	(0X1027,	"DS:SI points to entry point\nAX:DI points to initial stack\nDX has PDB pointer\nBX has initial AX value",	0);
	create_insn	(x=0X102E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X1034,	"set up user's stack",	0);
	set_cmt	(0X1036,	"and SP",	0);
	set_cmt	(0X1039,	"fake long call to entry",	0);
	set_cmt	(0X103B,	"set up proper seg registers",	0);
	set_cmt	(0X103F,	"set up proper AX",	0);
	create_insn	(0X1042);
	set_name	(0X1042,	"disa20_iret");
	create_insn	(x=0X1045);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X1049);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X104D,	"restore user stack",	0);
	create_insn	(x=0X104D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X1051);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X1057,	"[BP+user_env.user_AX]",	0);
	create_insn	(x=0X105A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X105E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X1062);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X1065,	"restore user regs",	0);
	set_name	(0X106E,	"lirett");
	create_insn	(0X106F);
	set_name	(0X106F,	"XMMDisableA20");
	set_cmt	(0X1071,	"XMM_LOCAL_DISABLE_A20",	0);
	create_dword	(0X107B);
	set_name	(0X107B,	"XMMcontrol");
	create_dword	(0X107F);
	create_word	(0X1083);
	set_name	(0X1083,	"SC_STATUS");
	create_insn	(0X1085);
	set_name	(0X1085,	"EnsureA20ON");
	set_cmt	(0X108B,	"Compare the 4 words at 0000:0080",	0);
	set_cmt	(0X108D,	"with the 4 at FFFF:0090",	0);
	set_cmt	(0X1090,	"0FFFFh:0090h ; HighMemory",	0);
	set_cmt	(0X1095,	"0000h:0080h ; LowMemory",	0);
	create_insn	(0X10A7);
	create_insn	(x=0X10B7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X10BA,	"XMM_LOCAL_ENABLE_A20",	0);
	set_cmt	(0X10BC,	"call far [cs:XMMcontrol]",	0);
	set_cmt	(0X10C3,	"AX = 0 fatal error",	0);
	create_insn	(0X10D3);
	set_cmt	(0X10D5,	"- VIDEO - GET CURRENT VIDEO MODE\nReturn: AH = number of columns on screen\nAL = current video mode\nBH = current active display page",	0);
	create_insn	(x=0X10D5);
	op_hex		(x,	0);
	set_cmt	(0X10DE,	"- VIDEO - SET VIDEO MODE\nAL = mode",	0);
	create_insn	(x=0X10DE);
	op_hex		(x,	0);
	set_cmt	(0X10E3,	"- VIDEO - SELECT DISPLAY PAGE\nAL = display page, 0-7  for modes 0 & 1, 0-3  for modes 2 & 3",	0);
	create_insn	(x=0X10E3);
	op_hex		(x,	0);
	create_insn	(x=0X10E5);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X10EC,	"indicates end of XMMERRMSG",	0);
	set_cmt	(0X10F5,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X10F5);
	op_hex		(x,	0);
	create_insn	(0X10F9);
	set_cmt	(0X10FC,	"segment of BIOS",	0);
	create_word	(0X10FC);
	set_name	(0X10FC,	"OldInstanceJunk");
	set_cmt	(0X10FE,	"indicate stacks in SYSINIT area",	0);
	create_word	(0X10FE);
	set_cmt	(0X1100,	"6 instance items",	0);
	create_word	(0X1100);
	create_word	(0X1102);
	set_name	(0X1102,	"OldInstanceJunk_6");
	create_word	(x=0X1104);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0X1106);
	create_word	(0X1108);
	create_word	(x=0X110A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0X110C);
	create_word	(0X110E);
	create_word	(x=0X1110);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0X1112);
	create_word	(0X1114);
	create_word	(x=0X1116);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0X1118);
	create_word	(0X111A);
	create_word	(x=0X111C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X111E);
	op_dec		(x,	0);
	create_word	(0X1120);
	set_cmt	(0X1122,	"ALTAH byte in dos bios",	0);
	create_word	(x=0X1122);
	op_hex		(x,	0);
	create_word	(0X1124);
	create_insn	(0X1126);
	set_name	(0X1126,	"RatBugCode");
	create_insn	(x=0X1127);
	set_name	(0X112B,	"rbc_loop");
	create_byte	(x=0X112F);
	make_array	(x,	0XB);
	op_dec		(x,	0);
	set_name	(0X112F,	"UmbSave1");
	create_word	(0X113A);
	set_name	(0X113A,	"OLD_FIRSTCLUS_HW");
	create_word	(0X113C);
	set_name	(0X113C,	"FastOpenTable");
	create_word	(x=0X113E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X113E,	"FastTable_2");
	create_word	(0X1140);
	create_word	(x=0X1142);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0X1144);
	create_byte	(0X1146);
	set_name	(0X1146,	"FastOpenFlg");
	create_byte	(0X1147);
	make_array	(0X1147,	0X6);
	set_name	(0X1147,	"FastOpen_Ext_Info");
	create_word	(0X114D);
	set_name	(0X114D,	"UNKNOWN1");
	create_byte	(0X114F);
	make_array	(0X114F,	0X5);
	create_word	(x=0X1154);
	op_dec		(x,	0);
	set_name	(0X1154,	"PATHNAMELEN");
	create_byte	(x=0X1156);
	make_array	(x,	0X1F);
	op_dec		(x,	0);
	create_byte	(0X1175);
	set_name	(0X1175,	"CurSC_DRIVE");
	create_byte	(0X1176);
	make_array	(0X1176,	0X8);
	set_name	(0X1176,	"WinoldPatch2");
	create_word	(0X117E);
	set_name	(0X117E,	"FIRST_BUFF_ADDR");
	set_cmt	(0X1180,	"Windows 3.1 patches",	0);
	create_byte	(0X1180);
	make_array	(0X1180,	0X3);
	set_name	(0X1180,	"DOSP1_ID");
	create_byte	(0X1183);
	make_array	(0X1183,	0X6);
	create_byte	(0X1189);
	make_array	(0X1189,	0X2);
	create_byte	(0X118B);
	make_array	(0X118B,	0X3);
	set_name	(0X118B,	"DOSP12_ID");
	create_byte	(0X118E);
	make_array	(0X118E,	0X6);
	create_byte	(0X1194);
	make_array	(0X1194,	0X4);
	set_name	(0X1194,	"DOSP3_ID");
	create_byte	(0X1198);
	make_array	(0X1198,	0X3);
	create_byte	(0X119B);
	make_array	(0X119B,	0X4);
	create_byte	(0X119F);
	set_name	(0X119F,	"DOSP4_ID");
	create_byte	(0X11A0);
	set_name	(0X11A0,	"DOSP5_ID");
	create_byte	(0X11A1);
	make_array	(0X11A1,	0X5);
	create_byte	(0X11A6);
	create_byte	(0X11A7);
	make_array	(0X11A7,	0X3);
	set_name	(0X11A7,	"DOSP7_ID");
	create_byte	(0X11AA);
	make_array	(0X11AA,	0X2);
	create_byte	(0X11AC);
	make_array	(0X11AC,	0X3);
	create_byte	(0X11AF);
	make_array	(0X11AF,	0X2);
	create_byte	(0X11B1);
	make_array	(0X11B1,	0X2);
	create_byte	(0X11B3);
	make_array	(0X11B3,	0X2);
	create_byte	(0X11B5);
	make_array	(0X11B5,	0X2);
	create_byte	(0X11B7);
	make_array	(0X11B7,	0X2);
	create_byte	(0X11B9);
	make_array	(0X11B9,	0X2);
	create_byte	(0X11BB);
	make_array	(0X11BB,	0X3);
	set_name	(0X11BB,	"DOSP8_ID");
	create_byte	(0X11BE);
	make_array	(0X11BE,	0X5);
	create_byte	(0X11C3);
	make_array	(0X11C3,	0X2);
	create_byte	(0X11C5);
	make_array	(0X11C5,	0X2);
	set_name	(0X11C5,	"DOSP10_ID");
	create_byte	(0X11C7);
	make_array	(0X11C7,	0X2);
	create_byte	(0X11C9);
	make_array	(0X11C9,	0X5);
	create_byte	(0X11CE);
	make_array	(0X11CE,	0X2);
	create_byte	(0X11D0);
	make_array	(0X11D0,	0X10);
	create_byte	(0X11E0);
	make_array	(0X11E0,	0X18);
	create_byte	(x=0X11F8);
	op_hex		(x,	0);
	create_byte	(x=0X11F9);
	make_array	(x,	0X8);
	op_hex		(x,	0);
	create_byte	(0X1201);
	make_array	(0X1201,	0X3);
	create_byte	(0X1204);
	make_array	(0X1204,	0XF);
	set_name	(0X1204,	"DOSP13_ID");
	create_strlit	(0X1213,	0X1215);
	set_name	(0X1213,	"XMMERRMSG");
	create_strlit	(0X1215,	0X122A);
	set_cmt	(0X122A,	"reserved words",	0);
	create_byte	(0X122A);
	make_array	(0X122A,	0X8);
	set_name	(0X122A,	"COUNTRY_CDPG");
	set_cmt	(0X1232,	"path name of country.sys",	0);
	create_strlit	(0X1232,	0X123F);
	create_byte	(x=0X123F);
	make_array	(x,	0X33);
	op_dec		(x,	0);
	set_cmt	(0X1272,	"system code page id",	0);
	create_word	(x=0X1272);
	op_dec		(x,	0);
	set_cmt	(0X1274,	"number of entries",	0);
	create_word	(0X1274);
	set_cmt	(0X1276,	"SetUcase",	0);
	create_byte	(0X1276);
	set_name	(0X1276,	"COUNTRY_CDPG_76");
	create_word	(x=0X1277);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0X1279);
	set_cmt	(0X127B,	"SetUcaseFile",	0);
	create_byte	(0X127B);
	create_word	(x=0X127C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0X127E);
	set_cmt	(0X1280,	"SetFileList",	0);
	create_byte	(0X1280);
	create_word	(x=0X1281);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0X1283);
	set_cmt	(0X1285,	"SetCollate",	0);
	create_byte	(0X1285);
	create_word	(x=0X1286);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0X1288);
	set_cmt	(0X128A,	"SetDBCS",	0);
	create_byte	(0X128A);
	create_word	(x=0X128B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0X128D);
	set_cmt	(0X128F,	"SetCountryInfo",	0);
	create_byte	(0X128F);
	set_cmt	(0X1290,	"NEW_COUNTRY_SIZE",	0);
	create_word	(x=0X1290);
	op_dec		(x,	0);
	set_cmt	(0X1292,	"USA country id",	0);
	create_word	(0X1292);
	set_name	(0X1292,	"_COUNTRY_ID");
	set_cmt	(0X1294,	"USA system code page id",	0);
	create_word	(x=0X1294);
	op_dec		(x,	0);
	set_cmt	(0X1296,	"date format",	0);
	create_word	(0X1296);
	set_name	(0X1296,	"COUNTRY_CDPG_108");
	set_cmt	(0X1298,	"currency symbol",	0);
	create_strlit	(0X1298,	0X129D);
	set_cmt	(0X129D,	"thousand separator",	0);
	create_strlit	(0X129D,	0X129F);
	set_cmt	(0X129F,	"decimal separator",	0);
	create_strlit	(0X129F,	0X12A1);
	set_cmt	(0X12A1,	"date separator",	0);
	create_strlit	(0X12A1,	0X12A3);
	set_cmt	(0X12A3,	"time separator",	0);
	create_strlit	(0X12A3,	0X12A5);
	set_cmt	(0X12A5,	"currency format flag",	0);
	create_byte	(0X12A5);
	set_cmt	(0X12A6,	"# of digits after decimal in currency",	0);
	create_byte	(0X12A6);
	set_cmt	(0X12A7,	"time format",	0);
	create_byte	(0X12A7);
	set_cmt	(0X12A8,	"mono case routine entry point",	0);
	create_word	(x=0X12A8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X12AA,	"segment of entry point",	0);
	create_word	(0X12AA);
	set_cmt	(0X12AC,	"data list separator",	0);
	create_strlit	(0X12AC,	0X12AE);
	set_cmt	(0X12AE,	"reserved",	0);
	create_word	(0X12AE);
	make_array	(0X12AE,	0X5);
	create_byte	(0X12B8);
	set_name	(0X12B8,	"INDOS_FLAG");
	create_byte	(0X12B9);
	set_name	(0X12B9,	"DEVIO_IN_PROGRESS");
	create_strlit	(0X12BA,	0X12BE);
	set_name	(0X12BA,	"_ENU");
	create_strlit	(0X12BE,	0X12C2);
	set_name	(0X12BE,	"_USA");
	create_strlit	(0X12C2,	0X12C4);
	set_name	(0X12C2,	"_US");
	create_word	(0X12C4);
	create_word	(0X12C6);
	create_word	(0X12C8);
	create_strlit	(0X12CA,	0X12CD);
	set_name	(0X12CA,	"_AM");
	create_strlit	(0X12CD,	0X12D0);
	set_name	(0X12CD,	"_PM");
	create_strlit	(0X12D0,	0X12F4);
	set_name	(0X12D0,	"_MMDDYY");
	create_byte	(0X12F4);
	create_byte	(0X12F5);
	create_word	(0X12F6);
	create_strlit	(0X12F8,	0X1306);
	set_name	(0X12F8,	"VxDpath");
	create_byte	(0X1306);
	create_byte	(0X1307);
	set_name	(0X1307,	"drv_flags_1");
	create_byte	(x=0X1308);
	make_array	(x,	0X1A);
	op_dec		(x,	0);
	set_name	(0X1308,	"drive_flags");
	create_byte	(0X1322);
	set_name	(0X1322,	"DriverLoad");
	create_word	(0X1323);
	make_array	(0X1323,	0X2);
	set_name	(0X1323,	"BiosDataPtr");
	create_byte	(0X1327);
	make_array	(0X1327,	0X5);
	create_word	(0X132C);
	create_word	(x=0X132E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X1330);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X1332);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X1334);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_byte	(x=0X1336);
	op_chr		(x,	0);
	set_name	(0X1336,	"NLS_YES");
	create_byte	(x=0X1337);
	op_chr		(x,	0);
	set_name	(0X1337,	"NLS_NO");
	create_byte	(x=0X1338);
	op_chr		(x,	0);
	set_name	(0X1338,	"NLS_yes2");
	create_byte	(x=0X1339);
	op_chr		(x,	0);
	set_name	(0X1339,	"NLS_no2");
	create_dword	(0X133A);
	set_name	(0X133A,	"unknown_zero_dd");
	create_word	(0X133E);
	set_name	(0X133E,	"Rational386PatchPtr");
	create_insn	(0X1340);
	set_name	(0X1340,	"MagicPatch");
	update_extra_cmt		(0X3F10,	E_PREV + 0,	"; File Name   : C:\\Yedek\\pcdos_7_1\\IBMDOS.COM");
	update_extra_cmt		(0X3F10,	E_PREV + 1,	"; Format      : Binary file");
	update_extra_cmt		(0X3F10,	E_PREV + 2,	"; Base Address: 0000h Range: 0000h - A646h Loaded length: A646h");
	create_insn	(0X3F10);
	set_name	(0X3F10,	"$STARTCODE");
	create_word	(x=0X3F13);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(0X3F15);
	set_name	(0X3F15,	"BioDataSeg");
	set_cmt	(0X3F17,	"DOSDATA segment address",	0);
	create_word	(0X3F17);
	set_name	(0X3F17,	"DosDSeg");
	set_cmt	(0X3F19,	"DOS_MAJOR_VERSION",	0);
	create_byte	(0X3F19);
	set_name	(0X3F19,	"MSMAJOR");
	set_cmt	(0X3F1A,	"DOS_MINOR_VERSION",	0);
	create_byte	(x=0X3F1A);
	op_dec		(x,	0);
	set_name	(0X3F1A,	"MSMINOR");
	set_cmt	(0X3F1B,	"INT 21h Error code mapping table",	0);
	create_byte	(0X3F1B);
	make_array	(0X3F1B,	0XB6);
	set_name	(0X3F1B,	"I21_MAP_E_TAB");
	create_byte	(0X3FD1);
	set_cmt	(0X3FD2,	"Standard Functions (INT 21h System Calls)",	0);
	create_word	(x=0X3FD2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X3FD2,	"DISPATCH");
	create_word	(x=0X3FD4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FD6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FD8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FDA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FDC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FDE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FE0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FE2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FE4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FE6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FE8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FEA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FEC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FEE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FF0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FF2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FF4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FF6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FF8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FFA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FFC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X3FFE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4000);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4002);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4004);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4006);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4008);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X400A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X400C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X400E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4010);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4012);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4014);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4016);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4018);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X401A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X401C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X401E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4020);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4022);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4024);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4026);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4028);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X402A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X402C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X402E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4030);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4032);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4034);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4036);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4038);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X403A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X403C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X403E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4040);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4042);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4044);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4046);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4048);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X404A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X404C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X404E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4050);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4052);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4054);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4056);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4058);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X405A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X405C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X405E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4060);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4062);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4064);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4066);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4068);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X406A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X406C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X406E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4070);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4072);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4074);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4076);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4078);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X407A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X407C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X407E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4080);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4082);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4084);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4086);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4088);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X408A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X408C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X408E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4090);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4092);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4094);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4096);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4098);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X409A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X409C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X409E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40A0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40A2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40A4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40A6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40A8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X40AA,	"6Ch",	0);
	create_word	(x=0X40AA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X40AC,	"6Dh, OS/2 \"DosMkDir2\" - ROM DOS: Find first ROM program",	0);
	create_word	(x=0X40AC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X40AE,	"6Eh, OS/2 \"DosEnumAttrib\" - ROM DOS: Find next ROM program",	0);
	create_word	(x=0X40AE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X40B0,	"6Fh, OS/2 \"DosQMaxEASize\" - ROM DOS: Get/set searched ROM area",	0);
	create_word	(x=0X40B0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X40B2,	"70h, MSDOS 7 (WIN 95) - Get/set extended country information\n        GET/SET INTERNATIONALIZATION INFORMATION",	0);
	create_word	(x=0X40B2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X40B4,	"71h, MSDOS 7 (WIN 95) LONG FILENAME FUNCTIONS",	0);
	create_word	(x=0X40B4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X40B6,	"72h, MSDOS 7 (WIN 95) LFN-FindClose",	0);
	create_word	(x=0X40B6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X40B8,	"73h, MSDOS 7 - FAT32 extended drive functions",	0);
	create_word	(x=0X40B8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40BA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X40BA,	"FOO");
	create_word	(x=0X40BC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X40BC,	"DTab");
	create_byte	(x=0X40BE);
	op_dec		(x,	0);
	set_name	(0X40BE,	"DOSTable");
	create_word	(x=0X40BF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40C1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40C3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40C5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40C7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40C9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40CB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40CD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40CF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40D1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40D3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40D5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40D7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40D9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40DB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40DD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40DF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40E1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40E3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40E5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40E7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40E9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40EB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40ED);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40EF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40F1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40F3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40F5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40F7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40F9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40FB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40FD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X40FF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4101);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4103);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4105);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4107);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4109);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X410B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X410D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X410F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4111);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4113);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4115);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4117);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4119);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X411B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X411D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X411F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4121);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4123,	"Is this a valid subfunction?",	0);
	create_insn	(0X4123);
	set_name	(0X4123,	"$SET_CTRL_C_TRAPPING");
	set_cmt	(0X4125,	"yes",	0);
	create_insn	(0X412A);
	create_insn	(x=0X4132);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4137,	"Check for subfunction 0",	0);
	set_cmt	(0X413B,	"DS:SI --> Ctrl C Status byte",	0);
	create_insn	(0X413F);
	set_cmt	(0X4142,	"mask off bit 0 of DL and",	0);
	create_insn	(x=0X4142);
	op_hex		(x,	1);
	set_cmt	(0X4145,	"save it as new Ctrl C status",	0);
	create_insn	(0X4149);
	set_cmt	(0X414C,	"mask off bit 0 of DL and",	0);
	create_insn	(x=0X414C);
	op_hex		(x,	1);
	set_cmt	(0X414F,	"exchange DL with old status byte",	0);
	set_cmt	(0X4153,	"test for 5 after it was dec twice",	0);
	create_insn	(0X4153);
	set_cmt	(0X4157,	"return boot drive in DL",	0);
	create_insn	(x=0X4157);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X415D);
	set_cmt	(0X415F,	"test for 6 after it was dec twice",	0);
	set_cmt	(0X4163,	"7.10 ; (MINOR_VERSION<<8)+MAJOR_VERSION",	0);
	set_cmt	(0X4166,	"DOSREVNM",	0);
	set_cmt	(0X4169,	"is DOS in HMA? no",	0);
	create_insn	(x=0X4169);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X416F,	"yes",	0);
	set_cmt	(0X4171,	"return version & 'DOS in HMA' status",	0);
	set_cmt	(0X4173,	"clear bit 5 of DOS flag",	0);
	create_insn	(x=0X4173);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X417D,	"set bit 5 of DOS flag",	0);
	create_insn	(x=0X417D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(0X4186);
	create_insn	(0X4188);
	set_name	(0X4188,	"$SET_CURRENT_PDB");
	create_insn	(x=0X418E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X4194);
	set_name	(0X4194,	"$GET_CURRENT_PDB");
	create_insn	(x=0X419A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X41A0);
	set_name	(0X41A0,	"$SET_PRINTER_FLAG");
	create_insn	(x=0X41A6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X41AB);
	set_name	(0X41AB,	"QUIT");
	create_insn	(0X41AF);
	set_name	(0X41AF,	"BADCALL");
	set_name	(0X41B1,	"irett");
	set_cmt	(0X41B2,	"System call entry point and dispatcher\n***\nAn alternative method of entering the system\nis to perform a CALL 5 in the program segment prefix\nwith the contents of CL indicating what system call\nthe user would like",	0);
	create_insn	(0X41B2);
	set_name	(0X41B2,	"CALL_ENTRY");
	create_insn	(x=0X41B8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X41BE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X41C2,	"Re-order the stack \nto simulate an interrupt 21h.",	0);
	set_cmt	(0X41C5,	"Stack now ordered as if INT had been used",	0);
	create_insn	(x=0X41C5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X41C9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X41CE,	"MAXCALL\nThis entry point doesn't get as many calls",	0);
	create_insn	(x=0X41CE);
	op_dec		(x,	1);
	set_cmt	(0X41D7,	"This is the normal INT 21h entry point. \nWe first perform a quick test to see if\nwe need to perform expensive DOS-entry\nfunctions. Certain system calls are done\nwithout interrupts being enabled.",	0);
	create_insn	(0X41D7);
	set_name	(0X41D7,	"COMMAND");
	create_insn	(x=0X41D8);
	op_hex		(x,	1);
	set_cmt	(0X41DD,	"Check Minimum special case number",	0);
	create_insn	(x=0X41DD);
	op_hex		(x,	1);
	set_name	(0X41DD,	"SAVREGS");
	set_cmt	(0X41E4,	"Check Maximum case number",	0);
	create_insn	(x=0X41E4);
	op_hex		(x,	1);
	create_insn	(x=0X41EB);
	op_hex		(x,	1);
	create_insn	(x=0X41F0);
	op_hex		(x,	1);
	create_insn	(x=0X41F5);
	op_hex		(x,	1);
	create_insn	(x=0X420A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X420D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4210);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4214);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4217);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X421A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X421D,	"0",	0);
	set_cmt	(0X421F,	"WIN386 patch. Do not update USER_ID",	0);
	create_insn	(x=0X421F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X4224,	"allow redirection",	0);
	create_insn	(x=0X4224);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4227,	"if win386 present",	0);
	create_insn	(x=0X4229);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X422C,	"Flag that we're in the DOS",	0);
	create_insn	(x=0X422C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4230,	"duplicated INDOS flag (what for ?)",	0);
	create_insn	(x=0X4230);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4234);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4237);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X423B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X423F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4246,	"[PDB.USER_STACK]",	0);
	create_insn	(x=0X4246);
	set_cmt	(0X424A,	"[PDB.USER_STACK+2]",	0);
	create_insn	(x=0X424A);
	create_insn	(x=0X4253);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X4253,	"REDISP");
	set_cmt	(0X425E,	"Clear extended open flag",	0);
	create_insn	(x=0X425E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4261,	"EXEC_AWARE_REDIR\nclear all bits except bit 11",	0);
	create_insn	(x=0X4261);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X4267,	"random clean up of possibly mis-set flags",	0);
	create_insn	(x=0X4267);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X426A,	"set directories on search",	0);
	create_insn	(x=0X426A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X426D,	"FAIL not in progress",	0);
	create_insn	(x=0X426D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4271,	"presume that we can issue INT 28h",	0);
	create_insn	(x=0X4271);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4274,	"Restore AX and BX = 1",	0);
	set_cmt	(0X4277,	"2 bytes per call in table",	0);
	set_cmt	(0X427E,	"GETEXTENDEDERROR",	0);
	create_insn	(x=0X427E);
	op_hex		(x,	1);
	set_cmt	(0X4283,	"STD_CON_INPUT_FLUSH ; 12",	0);
	create_insn	(x=0X4283);
	op_hex		(x,	1);
	set_cmt	(0X4288,	"\nAre we in an INT 24h",	0);
	create_insn	(x=0X4288);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X4288,	"IOROUT");
	set_cmt	(0X428D,	"Stay on AUXSTACK if INT 24h",	0);
	set_cmt	(0X428F,	"mov sp,IOSTACK",	0);
	create_insn	(x=0X428F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4294);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4297);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X429D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X42A5,	"Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7",	0);
	create_insn	(x=0X42A5);
	op_hex		(x,	0);
	create_insn	(x=0X42A8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X42AD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X42B0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X42BC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X42C1);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X42C5);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X42C9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X42CE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0X42D4,	"LeaveDOS");
	create_insn	(x=0X42DA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X42E1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X42E5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X42E9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X42ED);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X42F6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X42FA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X42FD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X430B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X430F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4315);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X431A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X431F);
	set_name	(0X431F,	"restore_world");
	create_insn	(x=0X4324);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4331);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X4336);
	set_name	(0X4336,	"save_world");
	create_insn	(x=0X433B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4348);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4350);
	op_dec		(x,	1);
	create_insn	(0X4355);
	set_name	(0X4355,	"Get_User_Stack");
	create_insn	(x=0X435A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_byte	(0X435F);
	set_name	(0X435F,	"ERRIN");
	create_byte	(0X4360);
	create_byte	(0X4361);
	create_byte	(0X4362);
	create_byte	(0X4363);
	create_byte	(0X4364);
	create_byte	(0X4365);
	set_name	(0X4365,	"ERROUT");
	create_byte	(0X4366);
	create_byte	(0X4367);
	create_byte	(0X4368);
	create_byte	(0X4369);
	create_byte	(0X436A);
	set_cmt	(0X436B,	"Extended ABS Disk Read/Write flag\n(AH=1 for INT 21h ax=7305h function)",	0);
	create_insn	(x=0X436B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X436B,	"AbsSetup");
	set_cmt	(0X4372,	"INT 21h AX=7305h\nINT 25h",	0);
	set_cmt	(0X4374,	"Windows DOSBOX's INDOS flag ?",	0);
	create_insn	(x=0X4374);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4379);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4389);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X4389,	"AbsSetup2");
	set_cmt	(0X4395,	"SET_RQ_SC_PARMS",	0);
	create_insn	(x=0X439D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X43AE,	"Microsoft Networks - CHECK DIRECT I/O\nDS:SI -> ASCIZ disk device name (may be full path or only drive\nspecifier--must include the colon)\nReturn: CF clear if absolute disk access allowed",	0);
	create_insn	(x=0X43AE);
	op_hex		(x,	0);
	set_cmt	(0X43B5,	"error_not_supported",	0);
	create_insn	(x=0X43B5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0X43B5,	"errdriv");
	set_cmt	(0X43BC,	"disk error ? (bad address mark)",	0);
	create_insn	(x=0X43BC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X43C4,	"Interrupt 25h handler (ah=0)",	0);
	create_insn	(0X43C4);
	set_name	(0X43C4,	"ABSDRD");
	set_cmt	(0X43C6,	"clear read/write mode flags\n(used with INT 21h ax=7305h)",	0);
	set_cmt	(0X43C8,	"ah=1",	0);
	set_name	(0X43C8,	"FAT32_ABSDRD");
	create_insn	(x=0X43D2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X43D7,	"(not jumped from ABSDWRT) absolute disk read\n(jumped from ABSDRWT)",	0);
	set_cmt	(0X43DB,	"absolute disk write",	0);
	create_insn	(0X43DE);
	set_cmt	(0X43E0,	"EXTENDED ABSOLUTE DISK READ/WRITE",	0);
	create_insn	(x=0X43E2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X43E6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X43EF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X43F2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X43FB,	"absolute disk read",	0);
	set_cmt	(0X43FD,	"(jumping back to) absolute disk write",	0);
	create_insn	(0X4400);
	set_cmt	(0X4408,	"invalidate secondary cache",	0);
	create_insn	(x=0X4408);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4418);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X441D,	"CX = # of contiguous sectors read\nES:BP -> Drive Parameter Block (DPB)\n[HIGH_SECTOR]:DX = physical sector # of 1st sector in extent\n[TEMP_VAR2]:[TEMP_VAR] = Transfer address",	0);
	create_insn	(x=0X441D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X4427);
	set_name	(0X4429,	"ERR_LEAVE");
	create_insn	(x=0X4431);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4438,	"[ES:DI+NUMERR-1]",	0);
	set_name	(0X443C,	"LEAVECODE");
	create_insn	(x=0X443D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X4442,	"ILEAVE");
	set_cmt	(0X4448,	"FAT32- EXTENDED ABSOLUTE DISK READ/WRITE flag",	0);
	create_insn	(x=0X4448);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X444E,	"INT 21h AX=7305h\nINT 25h",	0);
	create_insn	(x=0X4452);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4456);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X445B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4462);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4467);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X446F);
	create_insn	(x=0X4470);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X4477);
	set_name	(0X4477,	"ABSDWRT");
	create_insn	(0X447C);
	set_name	(0X447C,	"FAT32_ABSDWRT");
	set_cmt	(0X447E,	"floppy disk\nhard disk",	0);
	set_cmt	(0X4489,	"\nNOTE: PCDOS 7.1 kernel does not set\nDOS_FLAG bit 6 or drive_flags bit 7\n(It appears that these bits are set\nby Windows or a system utility or \ndriver that knows the addresses of\nthese FLAGs in the DOSDATA segment.)\nErdogan Tan - 03/01/2024",	0);
	set_cmt	(0X448B,	"test bit 7 (locked bit) ; 29/01/2024",	0);
	create_insn	(x=0X448B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X4490,	"locked (logical drive) -allowed to abs write-\nNOTE: lock/unlock are MSDOS/PCDOS 7 extd functions",	0);
	set_cmt	(0X4492,	"test bit 6 (large disk support -windows- bit?)\nNOTE: Retro DOS v5 kernel must set this bit.",	0);
	create_insn	(x=0X4492);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X4499,	"allowed",	0);
	set_cmt	(0X449C,	"error",	0);
	create_insn	(0X44A0);
	set_cmt	(0X44A1,	"writable disk \n('jumped from ABSDWRT' sign for common r/w code)",	0);
	set_cmt	(0X44A2,	"jump to ABSDRD (common r/w) code",	0);
	create_insn	(0X44A5);
	set_cmt	(0X44B0,	"invalidate secondary cache",	0);
	set_cmt	(0X44B6,	"purge fastopen",	0);
	set_cmt	(0X44C7,	"logical unit number",	0);
	create_insn	(0X44C7);
	set_name	(0X44C7,	"GETBP");
	set_cmt	(0X44C8,	"no increment; need carry flag",	0);
	set_cmt	(0X44CF,	"good drive",	0);
	set_cmt	(0X44D3,	"error_not_DOS_disk",	0);
	set_cmt	(0X44D6,	"unknown media",	0);
	set_cmt	(0X44D9,	"invalid drive or Non DOS drive",	0);
	create_insn	(x=0X44D9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X44DC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X44E6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X44EA,	"[es:bp+curdir.flags+1],\ncurdir_isnet>>8",	0);
	create_insn	(x=0X44EA);
	op_hex		(x,	1);
	set_cmt	(0X44F1,	"error_not_supported",	0);
	create_insn	(x=0X44F1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X44F9,	"[ES:BP+curdir.devptr]",	0);
	create_insn	(0X44F9);
	set_cmt	(0X4503,	"zero address, error",	0);
	create_insn	(x=0X4505);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X4505,	"GOTDPB");
	create_insn	(x=0X4509);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X450E);
	set_name	(0X450E,	"SYS_RET_OK");
	set_cmt	(0X4511,	"[SI+user_env.user_F],~f_Carry",	0);
	create_insn	(x=0X4511);
	op_hex		(x,	1);
	set_cmt	(0X4518,	"hack to allow for smaller error rets",	0);
	create_insn	(0X4518);
	set_name	(0X4518,	"SYS_RET_ERR");
	set_cmt	(0X451A,	"Make sure code is OK, EXTERR gets set",	0);
	set_name	(0X4520,	"From_GetSet");
	set_cmt	(0X4523,	"[SI+user_env.user_F],f_Carry",	0);
	create_insn	(x=0X4523);
	op_hex		(x,	1);
	set_cmt	(0X452A,	"obsolete system calls dispatch to here",	0);
	create_insn	(0X452A);
	set_name	(0X452A,	"NO_OP");
	create_insn	(0X452D);
	set_name	(0X452D,	"FCB_RET_ERR");
	create_insn	(x=0X452F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4536,	"-1",	0);
	create_insn	(0X4539);
	set_name	(0X4539,	"ErrorMap");
	create_insn	(x=0X453A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X453D,	"Check for SPECIAL case.",	0);
	create_insn	(x=0X453D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4543,	"All is OK.",	0);
	set_cmt	(0X4545,	"error_FAIL_I24 ; real reason",	0);
	create_insn	(x=0X4545);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X454C,	"Set CLASS,ACTION,LOCUS for EXTERR",	0);
	set_cmt	(0X4551,	"Look up and set CLASS ACTION and LOCUS values\n for GetExtendedError",	0);
	create_insn	(0X4551);
	set_name	(0X4551,	"CAL_LK");
	set_cmt	(0X4554,	"DOSDATA segment",	0);
	set_cmt	(0X4559,	"Get error in BL",	0);
	create_insn	(x=0X4559);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4560,	"End of table",	0);
	set_cmt	(0X4564,	"Got entry",	0);
	set_cmt	(0X4566,	"Next table entry",	0);
	create_insn	(0X456B);
	set_cmt	(0X4571,	"Set ACTION",	0);
	create_insn	(x=0X4571);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4579,	"Set CLASS",	0);
	create_insn	(x=0X4579);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X457C,	"Get LOCUS",	0);
	create_insn	(x=0X4581);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4588,	"check for appropriate error code",	0);
	create_insn	(0X4588);
	set_name	(0X4588,	"ETAB_LK");
	set_cmt	(0X458E,	"Set EXTERR with \"real\" error",	0);
	create_insn	(x=0X4591);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4594,	"Real code to BH",	0);
	set_cmt	(0X4596,	"Sys call to BL",	0);
	set_cmt	(0X459C,	"End of table?",	0);
	set_cmt	(0X45A0,	"Found call?",	0);
	set_cmt	(0X45A2,	"Yes",	0);
	set_cmt	(0X45A8,	"Next table entry",	0);
	set_cmt	(0X45AC,	"Restore original code",	0);
	create_insn	(0X45AC);
	create_insn	(0X45B0);
	set_cmt	(0X45B2,	"Count of valid err codes to CX",	0);
	set_cmt	(0X45B6,	"Code OK?",	0);
	set_cmt	(0X45B8,	"Yes",	0);
	set_cmt	(0X45BC,	"AX is now valid code",	0);
	set_cmt	(0X45C3,	"error_invalid_function",	0);
	create_insn	(0X45C3);
	set_name	(0X45C3,	"SetBad");
	set_cmt	(0X45CC,	"errLOC_Unk",	0);
	create_insn	(x=0X45CC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X45D4);
	set_name	(0X45D4,	"BadCall");
	create_insn	(0X45D8);
	set_name	(0X45D8,	"OKCall");
	create_insn	(0X45DA);
	set_name	(0X45DA,	"INT2F");
	set_cmt	(0X45DB,	"MultNET",	0);
	set_name	(0X45E0,	"TestInstall");
	set_name	(0X45E4,	"BadFunc");
	set_name	(0X45E7,	"Leave2F");
	set_cmt	(0X45EA,	"MultSHARE",	0);
	create_insn	(0X45EA);
	set_name	(0X45EA,	"INT2FSHR");
	set_cmt	(0X45EF,	"NLSFUNC",	0);
	set_cmt	(0X45F4,	"MultDOS",	0);
	set_cmt	(0X45FC,	"MultWin386",	0);
	create_insn	(0X45FC);
	set_name	(0X45FC,	"check_win");
	set_cmt	(0X4601,	"WINOLDAP",	0);
	create_insn	(x=0X4601);
	op_hex		(x,	1);
	create_insn	(0X4609);
	set_name	(0X4609,	"next_i2f");
	create_insn	(0X460E);
	set_name	(0X460E,	"Win386_Msg");
	set_cmt	(0X4614,	"win386 2.xx instance data call?",	0);
	set_cmt	(0X4618,	"yes, return instance data",	0);
	set_cmt	(0X461B,	"Win386_Exit  ; is it an exit call?",	0);
	create_insn	(0X461B);
	set_name	(0X461B,	"Win386_Msg_exit");
	set_cmt	(0X4622,	"Win386_Devcall ; is it call from DOSMGR?",	0);
	create_insn	(0X4622);
	set_name	(0X4622,	"Win386_Msg_devcall");
	set_cmt	(0X4629,	"Win386_Init ; is it an init call?",	0);
	create_insn	(0X4629);
	set_name	(0X4629,	"Win386_Msg_init");
	create_insn	(0X4630);
	set_name	(0X4630,	"Win386_Starting");
	create_insn	(x=0X4636);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X463D,	"4F43h ('CO' in NASM syntax)",	0);
	create_insn	(x=0X463D);
	op_chr		(x,	1);
	set_name	(0X463D,	"Win386_s_floop");
	set_cmt	(0X4641,	"204Eh ('N ' in NASM syntax)",	0);
	create_insn	(x=0X4641);
	op_chr		(x,	1);
	create_insn	(x=0X4645);
	op_dec		(x,	1);
	set_cmt	(0X464E,	"is this really win386?",	0);
	create_insn	(x=0X464E);
	op_hex		(x,	1);
	set_cmt	(0X4652,	"yes",	0);
	set_cmt	(0X4654,	"win 286 dos extender",	0);
	create_insn	(x=0X4657);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X4657,	"Win386_vchk");
	create_insn	(x=0X465D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4663,	"version >= 400",	0);
	set_name	(0X4669,	"Win386_vxd");
	create_insn	(x=0X466E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4678);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4685,	"not necessary (XOR already clears CF)",	0);
	set_cmt	(0X4686,	"!! PCDOS 7.1 bug !!\njump from 'Win386_Leaving' here was/is wrong\n(DI and SI would be reversed for 'Win386_Leaving')\nErdogan Tan - 05/01/2024",	0);
	set_name	(0X4686,	"restore_ubmhead");
	create_insn	(x=0X4687);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X468A);
	op_dec		(x,	1);
	create_insn	(x=0X468F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4696,	"(not jumped from 'Win386_Leaving')",	0);
	set_cmt	(0X4698,	"(jumped from 'Win386_Leaving' just after 'stc')",	0);
	create_insn	(0X469B);
	set_name	(0X469B,	"restore_ubmhead_c");
	set_cmt	(0X469D,	"SUPPRESS_WINA20",	0);
	create_insn	(x=0X469D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0X469D,	"Vxd31");
	set_name	(0X46AA,	"jmp_to_noVxD31");
	create_insn	(x=0X46AC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X46AC,	"Dont_Supress");
	set_cmt	(0X46AF,	"'A'-1",	0);
	create_insn	(x=0X46B1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X46B4,	"ExtOpen<<8",	0);
	set_cmt	(0X46B7,	"read access, compatibility mode\nno inherit, suppress crit err",	0);
	set_cmt	(0X46BA,	"hidden,system,read-only attr",	0);
	set_cmt	(0X46BE,	"dx bit 0 = 1 ; fail if file does not exist",	0);
	create_insn	(x=0X46BF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X46C5,	"DOS - 4.0 - EXTENDED OPEN/CREATE\nBL = open mode as in AL for normal open (INT 21h/AH=3Dh)\nBH = flags, CX = create attribute, DL = action if file exists/does not exists\nDH = 00h (reserved), DS:SI -> ASCIZ file name",	0);
	create_insn	(x=0X46C5);
	op_hex		(x,	0);
	set_cmt	(0X46CB,	"we found the VxD, go ahead",	0);
	create_insn	(x=0X46D0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X46D5,	"VxDMesLen",	0);
	create_insn	(x=0X46D5);
	op_dec		(x,	1);
	set_cmt	(0X46D8,	"write char to console",	0);
	set_name	(0X46DB,	"vxdlp");
	set_cmt	(0X46DE,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output",	0);
	create_insn	(x=0X46DE);
	op_hex		(x,	0);
	create_insn	(0X46EA);
	set_name	(0X46EA,	"VxDthere");
	create_insn	(x=0X46EC);
	op_hex		(x,	1);
	set_cmt	(0X46EE,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle",	0);
	create_insn	(x=0X46EE);
	op_hex		(x,	0);
	create_insn	(x=0X46F0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X46F3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X46FD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0X46FD,	"noVxD31");
	create_insn	(x=0X4702);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X470A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X4716,	"jmp_to_win_nexti2f");
	set_cmt	(0X4719,	"is this really win386?",	0);
	create_insn	(x=0X4719);
	op_hex		(x,	1);
	set_name	(0X4719,	"Win386_Leaving");
	set_cmt	(0X471D,	"NO! It's win 286 dos extender!",	0);
	set_cmt	(0X471F,	"was umb_arena saved at win start up ?",	0);
	create_insn	(x=0X471F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X471F,	"Win386_Leaving_c");
	set_cmt	(0X4724,	"not saved",	0);
	set_cmt	(0X4726,	"clear UmbSaveFlag \nand restore previously saved umb_head",	0);
	create_insn	(x=0X4726);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4730);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4736,	"CF=1 is a sign to jump 'restore_ubmhead_ok' address\nfrom -the common code at- 'restore_ubmhead' address\n(.. but this is a BUG!)\n;",	0);
	set_cmt	(0X4737,	"!! PCDOS 7.1 bug !! \n(jumped code does not restore umbhead, \nMSDOS 6.22 code was correct, modification is wrong)\nErdogan Tan - 05/01/2024\n\nCorrect code here, would be:\n   cld\n   mov  si,UmbSave1\n   mov  cx,11\n   rep  movsb\n   mov  si,UmbSave2\n   mov  cl,5\n   rep  movsb",	0);
	create_insn	(0X473A);
	set_name	(0X473A,	"restore_ubmhead_ok");
	create_insn	(x=0X473F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0X473F,	"noumb");
	create_insn	(x=0X4744);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X474B,	"Win386_DOSMGR ; is this from DOSMGR?",	0);
	create_insn	(0X474B);
	set_name	(0X474B,	"Win386_Query");
	set_cmt	(0X474E,	"no, ignore it & chain to next",	0);
	set_cmt	(0X4750,	"is it an instance query?",	0);
	set_cmt	(0X4752,	"no, some DOSMGR query",	0);
	set_cmt	(0X4754,	"indicate that data is instanced",	0);
	create_insn	(x=0X4755);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4759,	"es:bx points at offset table",	0);
	create_insn	(0X475C);
	set_name	(0X475C,	"OldWin386Init");
	set_cmt	(0X475D,	"ds:si = instance table",	0);
	create_insn	(x=0X475D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4760,	"'HR' ; indicate instance data present",	0);
	create_insn	(0X4765);
	set_name	(0X4765,	"dosmgr_func");
	set_cmt	(0X4766,	"call to patch DOS",	0);
	set_cmt	(0X4769,	"remove DOS patches, ignore",	0);
	set_cmt	(0X476C,	"get size of DOS data structures",	0);
	set_cmt	(0X476F,	"instance more data",	0);
	set_cmt	(0X4771,	"no functions above this",	0);
	set_cmt	(0X4773,	"Get DOS device driver size\nax = device header segment",	0);
	set_cmt	(0X4775,	"get arena header",	0);
	set_cmt	(0X4777,	"arena header for device driver",	0);
	set_cmt	(0X4779,	"is it a device arena?",	0);
	set_cmt	(0X477D,	"no",	0);
	set_cmt	(0X477F,	"get back device header segment",	0);
	set_cmt	(0X4780,	"owner field pointing at driver?",	0);
	set_cmt	(0X4784,	"no",	0);
	set_cmt	(0X4786,	"get arena size in paragraphs",	0);
	create_insn	(x=0X478B);
	op_dec		(x,	1);
	set_cmt	(0X4794,	"return with device driver size",	0);
	create_insn	(0X4796);
	set_name	(0X4796,	"cantsize");
	set_cmt	(0X4799,	"ask DOSMGR to use its methods",	0);
	set_name	(0X4799,	"win386_inst");
	set_cmt	(0X479D,	"move patch bitfield to bx",	0);
	create_insn	(0X479D);
	set_name	(0X479D,	"win386_patch");
	set_cmt	(0X479F,	"done, return",	0);
	set_cmt	(0X47A1,	"check for CDS size bit",	0);
	create_insn	(x=0X47A1);
	op_hex		(x,	1);
	set_name	(0X47A1,	"win386_size");
	set_cmt	(0X47A4,	"no, unknown structure -- return",	0);
	set_cmt	(0X47A6,	"cx = CDS size",	0);
	create_insn	(x=0X47A6);
	op_dec		(x,	1);
	set_cmt	(0X47A8,	"return with the size",	0);
	create_insn	(0X47AA);
	set_name	(0X47AA,	"jmp_to_win386_inst");
	set_cmt	(0X47AC,	"WIN_OP_DONE",	0);
	create_insn	(0X47AC);
	set_name	(0X47AC,	"win386_done");
	set_cmt	(0X47AF,	"DOSMGR_OP_DONE",	0);
	set_name	(0X47B2,	"PopIret");
	create_insn	(0X47B4);
	set_name	(0X47B4,	"win_nexti2f");
	set_name	(0X47B5,	"win_nexti2f2");
	create_insn	(x=0X47B8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X47B8,	"getwinlast");
	create_insn	(0X47C5);
	set_name	(0X47C5,	"Winold_swap");
	set_cmt	(0X47CF,	"swap Windows out call",	0);
	set_cmt	(0X47D1,	"no, check if Swap in call",	0);
	set_cmt	(0X47D8,	"ds = memory arena of Windows",	0);
	create_insn	(x=0X47DC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X47E3,	"save first 8 bytes",	0);
	create_insn	(x=0X47E7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X47EA,	"save next 8 bytes",	0);
	set_cmt	(0X47EE,	"swap Windows in call?",	0);
	create_insn	(0X47EE);
	set_name	(0X47EE,	"swapin");
	set_cmt	(0X47F0,	"no, something else, pass it on",	0);
	create_insn	(x=0X47F9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4800,	"restore first 8 bytes",	0);
	create_insn	(x=0X4804);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4807,	"restore next 8 bytes",	0);
	set_name	(0X4809,	"winold_done");
	set_cmt	(0X480E,	"chain on",	0);
	set_cmt	(0X4811,	"Windows95 - SET/CLEAR \"REPORT WINDOWS TO DOS PROGRAMS\" FLAG",	0);
	create_insn	(0X4811);
	set_name	(0X4811,	"int_2Fh_1231h");
	set_cmt	(0X481D,	"set byte after \"IsWIN386\" to 01h",	0);
	create_insn	(x=0X481D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X4824);
	set_name	(0X4825,	"not_1231_dl_0");
	set_cmt	(0X4828,	"clear \"IsWIN386\" bit 1",	0);
	set_cmt	(0X482A,	"set \"IsWIN386\" bit 1",	0);
	create_insn	(x=0X482A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(0X4831);
	set_name	(0X4832,	"not_1231_dl_1");
	set_cmt	(0X4837,	"clear bit 1",	0);
	create_insn	(x=0X4837);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X483E,	"return error, ax = 1",	0);
	create_insn	(0X483E);
	set_name	(0X483E,	"not_1231_dl_2");
	set_name	(0X4840,	"int_2f_1231h_retn");
	set_cmt	(0X4842,	"push return address",	0);
	create_insn	(0X4842);
	set_name	(0X4842,	"DispatchDOS");
	set_cmt	(0X4847,	"push table address",	0);
	set_cmt	(0X484C,	"push index",	0);
	set_cmt	(0X484E,	"stack looks like:\n 0  BP\n 2  DISPATCH\n 4  TABLE\n 6  RETURN\n 8  LONG-RETURN\n C  FLAGS\n E  AX",	0);
	set_cmt	(0X4850,	"get AX value",	0);
	create_insn	(x=0X4850);
	op_dec		(x,	1);
	set_cmt	(0X4857,	"return indicates invalid function",	0);
	create_insn	(0X485A);
	set_name	(0X485A,	"DOSGetGroup");
	create_insn	(0X4860);
	set_name	(0X4860,	"DOSInstall");
	set_cmt	(0X4863,	"-1 -> 0",	0);
	create_insn	(0X4863);
	set_name	(0X4863,	"RW32_CONVERT");
	set_cmt	(0X4867,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0X486C,	"FAT32 fs",	0);
	set_cmt	(0X4870,	"[es:bp+DPB.CLUSTER_MASK]",	0);
	set_cmt	(0X4874,	"[es:bp+DPB.MAX_CLUSTER]",	0);
	set_cmt	(0X4878,	"254 ; Sectors/cluster - 1",	0);
	set_cmt	(0X487B,	"removable",	0);
	set_cmt	(0X4883,	"> 32mb ?",	0);
	set_cmt	(0X4887,	"no",	0);
	set_cmt	(0X488B,	"[BX+ABS_32RW.SECTOR_RBA+2]",	0);
	create_insn	(0X488B);
	set_cmt	(0X488F,	"set up ds to DOSDATA",	0);
	create_insn	(x=0X4894);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4899,	"[BX+ABS_32RW.SECTOR_RBA]",	0);
	set_cmt	(0X489B,	"[BX+ABS_32RW.ABS_RW_COUNT]",	0);
	set_cmt	(0X489E,	"[BX+ABS_32RW.BUFFER_ADDR]",	0);
	create_insn	(0X48A3);
	set_name	(0X48A3,	"Fastxxx_Purge");
	set_cmt	(0X48AC,	"Fast_yes ; fastopen installed ?",	0);
	create_insn	(x=0X48AC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X48B2,	"no",	0);
	set_cmt	(0X48B4,	"FastOpen_ID",	0);
	set_cmt	(0X48B6,	"FONC_purge",	0);
	set_cmt	(0X48B8,	"set up drive number",	0);
	set_cmt	(0X48BC,	"call fastopen/seek",	0);
	create_strlit	(0X48C3,	0X48D6);
	set_name	(0X48C3,	"DIVMES");
	create_word	(x=0X48D6);
	op_dec		(x,	0);
	set_name	(0X48D6,	"DivMesLen");
	create_strlit	(0X48D8,	0X493B);
	set_name	(0X48D8,	"NoVxDErrMsg");
	set_cmt	(0X493B,	"CANCEL ; Cancel line character",	0);
	create_byte	(x=0X493B);
	op_hex		(x,	0);
	set_name	(0X493B,	"CANCHAR");
	set_cmt	(0X493C,	"ESCCH ; Lead-in character for escape sequences",	0);
	create_byte	(0X493C);
	set_name	(0X493C,	"ESCCHAR");
	set_cmt	(0X493D,	"Ctrl-Z - F6",	0);
	create_byte	(0X493D);
	set_name	(0X493D,	"ESCTAB");
	set_cmt	(0X493E,	"Copy one char - -->",	0);
	create_byte	(0X493E);
	set_cmt	(0X493F,	"Copy one char - F1",	0);
	create_byte	(0X493F);
	set_cmt	(0X4940,	"Skip one char - DEL",	0);
	create_byte	(0X4940);
	set_cmt	(0X4941,	"Copy to char - F2",	0);
	create_byte	(0X4941);
	set_cmt	(0X4942,	"Skip to char - F4",	0);
	create_byte	(0X4942);
	set_cmt	(0X4943,	"Copy line - F3",	0);
	create_byte	(0X4943);
	set_cmt	(0X4944,	"Kill line (no change to template ) - Not used",	0);
	create_byte	(0X4944);
	set_cmt	(0X4945,	"Reedit line (new template) - F5",	0);
	create_byte	(0X4945);
	set_cmt	(0X4946,	"Backspace - <--",	0);
	create_byte	(0X4946);
	set_cmt	(0X4947,	"Enter insert mode - INS (toggle)",	0);
	create_byte	(0X4947);
	set_cmt	(0X4948,	"Exit insert mode - INS (toggle)",	0);
	create_byte	(0X4948);
	set_cmt	(0X4949,	"Escape character - F7",	0);
	create_byte	(0X4949);
	set_cmt	(0X494A,	"End of table",	0);
	create_byte	(0X494A);
	set_cmt	(0X494B,	"Ignore the escape sequence",	0);
	create_word	(x=0X494B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X494B,	"ESCFUNC");
	create_word	(x=0X494D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X494F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4951,	"ENTERINS",	0);
	create_word	(x=0X4951);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4953);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4955);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4957);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4959);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X495B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X495D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X495F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4961);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4963);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X4965);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X4967);
	set_cmt	(0X496A,	"ESCTABLEN",	0);
	create_insn	(x=0X496A);
	op_dec		(x,	1);
	create_insn	(x=0X496D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4977);
	op_hex		(x,	1);
	create_insn	(x=0X497B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X4980);
	set_name	(0X4980,	"$GET_DATE");
	set_cmt	(0X498F,	"[SI+user_env.user_DX]",	0);
	create_insn	(x=0X4992);
	op_dec		(x,	1);
	set_cmt	(0X4995,	"[SI+user_env.user_CX]",	0);
	set_name	(0X499C,	"_RET24");
	set_cmt	(0X499D,	"-1",	0);
	create_insn	(0X499D);
	set_name	(0X499D,	"$SET_DATE");
	set_cmt	(0X499F,	"Fix bias in year",	0);
	create_insn	(x=0X499F);
	op_dec		(x,	1);
	set_cmt	(0X49A3,	"Error if not big enough",	0);
	set_cmt	(0X49A5,	"Year must be less than 2100",	0);
	create_insn	(x=0X49A5);
	op_dec		(x,	1);
	set_cmt	(0X49B0,	"Error if either month or day is 0",	0);
	set_cmt	(0X49B2,	"Check against max. month",	0);
	create_insn	(x=0X49B2);
	op_dec		(x,	1);
	set_name	(0X49BC,	"RET24");
	create_insn	(0X49BD);
	set_name	(0X49BD,	"$GET_TIME");
	set_cmt	(0X49C2,	"Get pointer to user registers",	0);
	set_cmt	(0X49C5,	"[SI+user_env.user_DX]",	0);
	set_cmt	(0X49C8,	"[SI+user_env.user_CX]",	0);
	set_name	(0X49CB,	"set_time_ok");
	set_name	(0X49CD,	"RET26");
	set_cmt	(0X49CE,	"Flag in case of error",	0);
	create_insn	(0X49CE);
	set_name	(0X49CE,	"$SET_TIME");
	set_cmt	(0X49D0,	"Check hours",	0);
	create_insn	(x=0X49D0);
	op_dec		(x,	1);
	set_cmt	(0X49D5,	"Check minutes",	0);
	create_insn	(x=0X49D5);
	op_dec		(x,	1);
	set_cmt	(0X49DA,	"Check seconds",	0);
	create_insn	(x=0X49DA);
	op_dec		(x,	1);
	set_cmt	(0X49DF,	"Check 1/100's",	0);
	create_insn	(x=0X49DF);
	op_dec		(x,	1);
	create_insn	(x=0X49E8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X49FA,	"Get correct day count",	0);
	create_insn	(x=0X4A02);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4A06);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4A0A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4A0E,	"Set the time",	0);
	create_insn	(0X4A13);
	set_name	(0X4A13,	"DATE16");
	create_insn	(x=0X4A28);
	op_hex		(x,	1);
	create_insn	(x=0X4A2E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4A38);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X4A3C,	"RET21");
	set_cmt	(0X4A3D,	"reset date flag for CPMIO",	0);
	create_insn	(x=0X4A3D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X4A3D,	"READTIME");
	create_insn	(x=0X4A45);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4A52);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4A56,	"Get correct date and time",	0);
	create_insn	(x=0X4A5C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4A5F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4A63);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4A67,	"See if day count is the same",	0);
	create_insn	(x=0X4A67);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4A6D,	"FOURYEARS*30 ; Number of days in 120 years",	0);
	create_insn	(x=0X4A6D);
	op_dec		(x,	1);
	set_cmt	(0X4A70,	"Ignore if too large",	0);
	create_insn	(x=0X4A72);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4A7A,	"FOURYEARS ; Number of days in 4 years",	0);
	create_insn	(x=0X4A7A);
	op_dec		(x,	1);
	set_cmt	(0X4A83,	"Multiply by 8 (no. of half-years)",	0);
	set_cmt	(0X4A85,	"<240 implies AH=0",	0);
	set_cmt	(0X4A87,	"Table of days in each year",	0);
	create_insn	(x=0X4A87);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4A8A,	"Find out which of four years we're in",	0);
	set_cmt	(0X4A8D,	"Convert half-years to whole years",	0);
	create_insn	(x=0X4A8D);
	op_hex		(x,	1);
	set_cmt	(0X4A8F,	"Extra half-year?",	0);
	create_insn	(x=0X4A91);
	op_dec		(x,	1);
	set_cmt	(0X4A98,	"At least at first month in year",	0);
	set_cmt	(0X4A9A,	"Table of days in each month",	0);
	create_insn	(x=0X4A9A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4A9D,	"Find out which month we're in",	0);
	create_insn	(x=0X4AA0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4AA4,	"Remainder is day of month (start with one)",	0);
	create_insn	(x=0X4AA5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4AA9,	"Set day of week",	0);
	set_name	(0X4AAF,	"RET22");
	set_cmt	(0X4AB0,	"(AH is already ZERO here!) 6/1/2024",	0);
	create_insn	(0X4AB0);
	set_name	(0X4AB0,	"DSLIDE");
	set_cmt	(0X4AB2,	"Get count of days",	0);
	set_cmt	(0X4AB3,	"See if it will fit",	0);
	set_cmt	(0X4AB9,	"Count one more month/year",	0);
	create_insn	(0X4ABC);
	set_name	(0X4ABC,	"SETYEAR");
	create_insn	(x=0X4AC1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4AC5,	"Check for leap year",	0);
	create_insn	(x=0X4AC5);
	op_hex		(x,	1);
	set_name	(0X4AC5,	"CHKYR");
	set_cmt	(0X4AC8,	"28 days if no leap year",	0);
	create_insn	(x=0X4AC8);
	op_dec		(x,	1);
	set_cmt	(0X4ACC,	"Add leap day",	0);
	set_cmt	(0X4ACE,	"[MONTAB+1],AL ; Store for February",	0);
	create_insn	(x=0X4ACE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X4AD1,	"RET23");
	set_cmt	(0X4AD2,	"Set Feb. up for new year",	0);
	create_insn	(0X4AD2);
	set_name	(0X4AD2,	"DODATE");
	set_cmt	(0X4AD7,	"MONTAB-1",	0);
	create_insn	(x=0X4AD7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4ADA,	"Look up days in month",	0);
	set_cmt	(0X4ADD,	"-1",	0);
	set_cmt	(0X4ADF,	"Error if too many days",	0);
	set_cmt	(0X4AE4,	"Set both day and month",	0);
	create_insn	(x=0X4AE4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4AE8);
	op_hex		(x,	1);
	create_insn	(x=0X4AEA);
	op_hex		(x,	1);
	set_cmt	(0X4AEC,	"FOURYEARS",	0);
	create_insn	(x=0X4AEC);
	op_dec		(x,	1);
	create_insn	(x=0X4AF3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4AF7);
	op_hex		(x,	1);
	create_insn	(x=0X4AFA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4AFF,	"Two entries per year, so double count",	0);
	set_cmt	(0X4B01,	"Add up the days in each year",	0);
	set_cmt	(0X4B04,	"Month of year",	0);
	create_insn	(x=0X4B06);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4B09,	"Account for months starting with one",	0);
	set_cmt	(0X4B0A,	"Add up days in each month",	0);
	set_cmt	(0X4B0D,	"Day of month",	0);
	set_cmt	(0X4B0F,	"Account for days starting with one",	0);
	set_cmt	(0X4B10,	"Add in to day total",	0);
	set_cmt	(0X4B12,	"Get day count in AX",	0);
	create_insn	(x=0X4B13);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4B19);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4B27);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4B2B,	"Get correct date and time",	0);
	create_insn	(x=0X4B33);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4B38);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4B3C,	"Set the date",	0);
	create_insn	(x=0X4B42);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X4B42,	"WKDAY");
	set_cmt	(0X4B4B,	"First day was Tuesday",	0);
	set_cmt	(0X4B4C,	"Compute day of week",	0);
	create_insn	(x=0X4B4E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X4B52,	"Flag OK",	0);
	create_insn	(0X4B55);
	set_name	(0X4B55,	"DSUM");
	create_insn	(0X4B5F);
	set_name	(0X4B5F,	"$GET_VERSION");
	set_cmt	(0X4B6C,	"return 0 (not ROMDOS version)",	0);
	set_cmt	(0X4B6E,	"Get the version number from the\ncurrent app's PSP segment",	0);
	set_name	(0X4B6E,	"Norm_Vers");
	set_cmt	(0X4B72,	"[PDB.Version]\nAX = DOS version number",	0);
	create_insn	(x=0X4B72);
	set_cmt	(0X4B78,	"[SI+user_env.user_AX]",	0);
	set_name	(0X4B78,	"gdrvfspc_ret");
	set_cmt	(0X4B7A,	"[SI+user_env.user_CX]",	0);
	set_cmt	(0X4B7D,	"[SI+user_env.user_BX]",	0);
	set_name	(0X4B7D,	"set_user_bx");
	create_insn	(0X4B81);
	set_name	(0X4B81,	"$GET_VERIFY_ON_WRITE");
	create_insn	(x=0X4B86);
	op_hex		(x,	1);
	set_name	(0X4B86,	"$SET_VERIFY_ON_WRITE");
	set_name	(0X4B8C,	"RET27");
	set_cmt	(0X4B8D,	"-1 means country code is in BX",	0);
	create_insn	(0X4B8D);
	set_name	(0X4B8D,	"$INTERNATIONAL");
	set_cmt	(0X4B91,	"Put AL country code in BX",	0);
	set_name	(0X4B95,	"BX_HAS_CODE");
	set_cmt	(0X4B98,	"User buffer to ES:DI",	0);
	set_cmt	(0X4B9B,	"-1",	0);
	create_insn	(x=0X4BA4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4BA9,	"0 ; flag it for GetCntry only",	0);
	create_insn	(0X4BA9);
	set_name	(0X4BA9,	"international_find");
	set_cmt	(0X4BB0,	"nlsfunc finished it ?",	0);
	set_cmt	(0X4BB2,	"no, copy by myself",	0);
	set_cmt	(0X4BB4,	"put country back",	0);
	create_insn	(x=0X4BB8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X4BB8,	"international_get");
	set_cmt	(0X4BBB,	"[SI+DOS_CCDPG.ccDosCountry]",	0);
	set_cmt	(0X4BBF,	"= current country id",	0);
	set_cmt	(0X4BC3,	"bx = 0, default code page",	0);
	set_cmt	(0X4BC8,	"- Multiplex - NLSFUNC.COM - INSTALLATION CHECK\nReturn: AL = 00h not installed, OK to install\n01h not installed, not OK\nFFh installed",	0);
	create_insn	(x=0X4BC8);
	op_hex		(x,	0);
	set_cmt	(0X4BCA,	"not in memory",	0);
	set_cmt	(0X4BCE,	"set country info",	0);
	set_cmt	(0X4BD1,	"GetCntry ?",	0);
	set_cmt	(0X4BD5,	"AX = 1404h ; get country info",	0);
	set_cmt	(0X4BD6,	"- Multiplex - NLSFUNC.COM - GET COUNTRY INFO\nBX = code page, DX = country code, DS:SI -> internal code page structure\nES:DI -> user buffer\nReturn: AL = status",	0);
	create_insn	(x=0X4BD6);
	op_hex		(x,	0);
	create_insn	(0X4BDE);
	set_cmt	(0X4BE2,	"[ss:SI+DOS_CCDPG.ccDosCountry]",	0);
	create_insn	(0X4BE2);
	set_name	(0X4BE2,	"international_copy");
	set_cmt	(0X4BE6,	"COUNTRY_CDPG+DOS_CCDPG.ccDFormat",	0);
	create_insn	(x=0X4BE6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4BE9,	"OLD_COUNTRY_SIZE/2",	0);
	create_insn	(x=0X4BE9);
	op_dec		(x,	1);
	set_name	(0X4BF2,	"international_ok3");
	set_cmt	(0X4BF5,	"MOV [SI+user_env.user_BX],BX",	0);
	set_name	(0X4BF8,	"international_ok");
	create_insn	(0X4BFD);
	set_name	(0X4BFD,	"international_set");
	set_name	(0X4C05,	"errtn");
	set_name	(0X4C09,	"errtn1");
	set_cmt	(0X4C0C,	"error_invalid_function",	0);
	create_insn	(0X4C0C);
	set_name	(0X4C0C,	"errtn2");
	set_cmt	(0X4C0E,	"NLSFUNC not existent",	0);
	set_cmt	(0X4C10,	"INT 21h, AH = 70h (06/01/2024 - Erdogan Tan)\nGET/SET INTERNATIONALIZATION INFORMATION\n****\nAL = subfunction\n00h SET general internationalization info\n    CX = buffer size (up to 38 bytes)\n    DS:SI -> buffer containing internationalization info\n first three bytes are skipped, the rest is copied to somewhere\n in the DOS data segment\n01h SET extended internationalization info\n    CX = number of bytes to set (up to 58 bytes)\n    DS:SI -> buffer containing internationalization info\n02h GET extended internationalization info\n    CX = buffer size in bytes (up to 58 bytes used)\n    ES:DI -> buffer\n****\n(Ref: Ralf Brown's Interrupt List) - had some mistakes -",	0);
	create_insn	(0X4C10);
	set_name	(0X4C10,	"$ExtCountryInfo");
	set_cmt	(0X4C18,	"AX = GET 35 bytes info (from offset 3 to 37)\n(38 bytes buffer is used)",	0);
	create_insn	(x=0X4C19);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4C1C,	"NEW_COUNTRY_SIZE = 38",	0);
	set_cmt	(0X4C20,	"skip the 1st 3 bytes of the buffer",	0);
	create_insn	(0X4C27);
	set_name	(0X4C27,	"ext_cntry_inf_1");
	set_cmt	(0X4C29,	"AX = 2",	0);
	set_cmt	(0X4C2B,	"AX = 1 (set)",	0);
	create_insn	(x=0X4C2C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4C31,	"AX = 2 (get)",	0);
	create_insn	(0X4C31);
	set_name	(0X4C31,	"ext_cntry_inf_2");
	create_insn	(x=0X4C32);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4C35,	"0",	0);
	set_name	(0X4C35,	"ext_cntry_inf_3");
	set_cmt	(0X4C37,	"3Ah",	0);
	create_insn	(x=0X4C37);
	op_dec		(x,	1);
	set_cmt	(0X4C3A,	"> 38 ? (58)",	0);
	set_name	(0X4C3A,	"ext_cntry_inf_4");
	set_cmt	(0X4C3C,	"no",	0);
	set_cmt	(0X4C3E,	"yes, decrease size to 38 (58)",	0);
	set_cmt	(0X4C40,	"buffer (filled) size",	0);
	set_name	(0X4C40,	"ext_cntry_inf_5");
	set_cmt	(0X4C42,	"copy byte count",	0);
	set_cmt	(0X4C47,	"ax -> user's cx",	0);
	set_cmt	(0X4C4A,	"CAP_ONE_CHAR  ; < 20h",	0);
	create_insn	(x=0X4C4A);
	op_hex		(x,	1);
	set_name	(0X4C4A,	"$GetExtCntry");
	set_cmt	(0X4C4E,	"UPPER_TABLE",	0);
	create_insn	(x=0X4C4E);
	op_hex		(x,	1);
	set_cmt	(0X4C50,	"file upper case",	0);
	set_cmt	(0X4C52,	"UCASE_TAB+2\nget normal upper case",	0);
	create_insn	(x=0X4C52);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X4C57);
	op_hex		(x,	1);
	set_name	(0X4C57,	"fileupper");
	set_cmt	(0X4C59,	"FILE_UCASE_TAB+2 \nget file upper case",	0);
	create_insn	(x=0X4C59);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4C5C,	"CAP_ONE_CHAR ; cap one char ?",	0);
	create_insn	(x=0X4C5C);
	op_hex		(x,	1);
	set_name	(0X4C5C,	"capit");
	set_cmt	(0X4C60,	"set up AL",	0);
	set_cmt	(0X4C62,	"upper case it",	0);
	set_cmt	(0X4C65,	"get user stack",	0);
	set_cmt	(0X4C68,	"[SI+user_env.user_DX]",	0);
	set_cmt	(0X4C6B,	"done",	0);
	set_cmt	(0X4C6D,	"CHECK_YES_NO",	0);
	create_insn	(x=0X4C6D);
	op_hex		(x,	1);
	set_name	(0X4C6D,	"chkyes");
	set_cmt	(0X4C6F,	"no\nYes/No",	0);
	set_cmt	(0X4C71,	"presume NO",	0);
	set_cmt	(0X4C78,	"Y(ES)",	0);
	set_cmt	(0X4C7F,	"y(es)",	0);
	set_cmt	(0X4C86,	"N(O)",	0);
	set_cmt	(0X4C8D,	"n(o)",	0);
	set_cmt	(0X4C8F,	"not YES or NO",	0);
	set_cmt	(0X4C90,	"YES = 1",	0);
	set_name	(0X4C90,	"yesyes");
	set_name	(0X4C91,	"nono");
	create_insn	(0X4C94);
	set_name	(0X4C94,	"capstring");
	set_cmt	(0X4C96,	"CAP_STRING",	0);
	create_insn	(x=0X4C96);
	op_hex		(x,	1);
	set_cmt	(0X4C9C,	"get char",	0);
	set_name	(0X4C9C,	"concap");
	set_cmt	(0X4C9D,	"upper case it",	0);
	set_cmt	(0X4CA0,	"store back",	0);
	set_cmt	(0X4CA3,	"continue",	0);
	set_cmt	(0X4CA5,	"done",	0);
	set_cmt	(0X4CA7,	"CAP_ASCIIZ",	0);
	create_insn	(x=0X4CA7);
	op_hex		(x,	1);
	set_name	(0X4CA7,	"capascii");
	set_cmt	(0X4CAB,	"get char",	0);
	set_name	(0X4CAB,	"concap2");
	set_cmt	(0X4CAC,	"end of string ?",	0);
	set_cmt	(0X4CAE,	"yes",	0);
	set_cmt	(0X4CB0,	"upper case it",	0);
	set_cmt	(0X4CB3,	"store back",	0);
	set_cmt	(0X4CB6,	"continue",	0);
	set_cmt	(0X4CB8,	"minimum size is 5",	0);
	create_insn	(0X4CB8);
	set_name	(0X4CB8,	"notcap");
	set_cmt	(0X4CBB,	"sizeerror",	0);
	set_name	(0X4CBD,	"GEC_CONT");
	create_insn	(x=0X4CBF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4CC4,	"\nAL = 0 (INT 21h, AX=6500h)\nSet extended country-dependent information\n(SET GENERAL INTERNATIONALIZATION INFO)",	0);
	set_cmt	(0X4CC6,	"minimum 8 bytes",	0);
	set_cmt	(0X4CC9,	"error_invalid_function",	0);
	set_cmt	(0X4CCB,	"[SI+DOS_CCDPG.ccSysCodePage]",	0);
	set_cmt	(0X4CCE,	"SI+DOS_CCDPG.ccCountryInfoLen",	0);
	set_name	(0X4CDC,	"set_inter_info");
	set_cmt	(0X4CE1,	"info length/size (will be written)",	0);
	set_cmt	(0X4CE5,	"DOS_CCDPG.ccDFormat",	0);
	set_cmt	(0X4CE8,	"points to date format",	0);
	set_cmt	(0X4CEB,	"ds:si = user's buffer + 6\nes:di = country info buffer + 7",	0);
	set_cmt	(0X4CF0,	"-1 ; active country ?",	0);
	create_insn	(0X4CF0);
	set_name	(0X4CF0,	"GETCNTRY");
	set_cmt	(0X4CF5,	"[SI+DOS_CCDPG.ccDosCountry]",	0);
	set_cmt	(0X4CF8,	"-1 ; active code page?",	0);
	set_name	(0X4CF8,	"GETCDPG");
	set_cmt	(0X4CFD,	"[SI+DOS_CCDPG.ccDosCodePage] ; get active code page",	0);
	set_cmt	(0X4D00,	"[SI+DOS_CCDPG.ccDosCountry] ; same ?",	0);
	set_name	(0X4D00,	"CHKAGAIN");
	set_cmt	(0X4D03,	"no",	0);
	set_cmt	(0X4D05,	"[SI+DOS_CCDPG.ccDosCodePage] ; same ?",	0);
	set_cmt	(0X4D08,	"no",	0);
	set_cmt	(0X4D0A,	"yes, same code page and same country id\n[SI+DOS_CCDPG.ccSysCodePage]",	0);
	set_name	(0X4D0A,	"CHKTYPE");
	set_cmt	(0X4D0E,	"[SI+DOS_CCDPG.ccNumber_of_entries]",	0);
	set_cmt	(0X4D11,	"COUNTRY_CDPG+DOS_CCDPG.ccSetUcase",	0);
	create_insn	(x=0X4D11);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4D14,	"compare info type",	0);
	set_name	(0X4D14,	"NXTENTRY");
	set_cmt	(0X4D18,	"next entry",	0);
	set_cmt	(0X4D1E,	"error_invalid_function",	0);
	set_name	(0X4D1E,	"capinval");
	set_cmt	(0X4D21,	"move info id byte",	0);
	create_insn	(0X4D21);
	set_name	(0X4D21,	"FOUNDIT");
	set_cmt	(0X4D22,	"restore char count",	0);
	set_cmt	(0X4D23,	"SetCountryInfo ; select country info type ?",	0);
	set_cmt	(0X4D25,	"yes",	0);
	set_cmt	(0X4D27,	"4 bytes will be moved",	0);
	set_cmt	(0X4D2A,	"5 bytes will be returned in CX",	0);
	set_cmt	(0X4D2D,	"copy info",	0);
	set_name	(0X4D2D,	"OK_RETN");
	set_cmt	(0X4D2F,	"CX = actual length returned",	0);
	set_cmt	(0X4D31,	"return sys code page in ax",	0);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_1(void) {
        auto x;
#define id x

	set_cmt	(0X4D33,	"return actual length to user's CX",	0);
	set_name	(0X4D33,	"GETDONE");
	set_cmt	(0X4D36,	"[SI+user_env.user_CX]",	0);
	set_name	(0X4D39,	"nono_jmp");
	set_cmt	(0X4D3C,	"size after length field",	0);
	create_insn	(0X4D3C);
	set_name	(0X4D3C,	"setsize");
	set_cmt	(0X4D3F,	"less than table size",	0);
	set_cmt	(0X4D41,	"no",	0);
	set_cmt	(0X4D43,	"truncate to table size",	0);
	set_cmt	(0X4D45,	"copy actual length to user's buffer",	0);
	set_cmt	(0X4D48,	"update index",	0);
	set_cmt	(0X4D4E,	"AX has the actual length",	0);
	create_insn	(0X4D53);
	set_name	(0X4D53,	"CHKNLS");
	set_cmt	(0X4D5A,	"- Multiplex - NLSFUNC.COM - INSTALLATION CHECK\nReturn: AL = 00h not installed, OK to install\n01h not installed, not OK\nFFh installed",	0);
	create_insn	(x=0X4D5A);
	op_hex		(x,	0);
	set_cmt	(0X4D5E,	"in memory",	0);
	set_name	(0X4D60,	"sizeerror");
	create_insn	(0X4D62);
	set_cmt	(0X4D65,	"- Multiplex - NLSFUNC.COM - GET COUNTRY INFO\nBP = subfunction, BX = code page\nDX = country code, DS:SI -> internal code page structure\nES:DI -> user buffer, CX = size of user buffer\nReturn: AL = status\n00h successful\nelse DOS error code",	0);
	create_insn	(x=0X4D65);
	op_hex		(x,	0);
	set_cmt	(0X4D6B,	"[SI+DOS_CCDPG.ccSysCodePage]",	0);
	create_insn	(0X4D70);
	set_name	(0X4D70,	"NLSERROR");
	create_insn	(0X4D73);
	set_name	(0X4D73,	"$GetSetCdPg");
	create_insn	(x=0X4D75);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4D78,	"get global code page",	0);
	set_cmt	(0X4D7C,	"[SI+DOS_CCDPG.ccDosCodePage]",	0);
	set_cmt	(0X4D7F,	"[SI+DOS_CCDPG.ccSysCodePage]",	0);
	set_cmt	(0X4D88,	"[SI+user_env.user_DX]",	0);
	set_name	(0X4D8B,	"OK_RETURN");
	set_cmt	(0X4D8D,	"set global codepage",	0);
	create_insn	(0X4D8D);
	set_name	(0X4D8D,	"setglpg");
	set_cmt	(0X4D91,	"[SI+DOS_CCDPG.ccDosCountry]",	0);
	set_cmt	(0X4D97,	"- Multiplex - NLSFUNC.COM - INSTALLATION CHECK\nReturn: AL = 00h not installed, OK to install\n01h not installed, not OK\nFFh installed",	0);
	create_insn	(x=0X4D97);
	op_hex		(x,	0);
	set_cmt	(0X4DA0,	"- Multiplex - NLSFUNC.COM - CHANGE CODE PAGE\nDS:SI -> internal code page structure\nBX = new code page, DX = country code???\nReturn: AL = status\n00h successful\nelse DOS error code",	0);
	create_insn	(x=0X4DA0);
	op_hex		(x,	0);
	set_cmt	(0X4DA6,	"set device code page failed",	0);
	create_insn	(x=0X4DA6);
	op_dec		(x,	1);
	set_cmt	(0X4DAE,	"errACT_Ignore",	0);
	set_cmt	(0X4DB3,	"errCLASS_HrdFail",	0);
	set_cmt	(0X4DB8,	"errLOC_SerDev",	0);
	set_cmt	(0X4DC0,	"transfer SYS_RET_ERR",	0);
	create_insn	(0X4DC0);
	set_name	(0X4DC0,	"seterr");
	set_cmt	(0X4DC2,	"function not defined",	0);
	create_insn	(0X4DC2);
	set_name	(0X4DC2,	"nomem");
	create_insn	(0X4DC4);
	set_name	(0X4DC4,	"$GET_DRIVE_FREESPACE");
	set_cmt	(0X4DC8,	"Get drive",	0);
	set_cmt	(0X4DCB,	"User FAILed to I 24",	0);
	set_cmt	(0X4DD6,	"Chuck Fat ID byte",	0);
	create_insn	(0X4DD6);
	set_name	(0X4DD6,	"gdrvfspc_1");
	set_cmt	(0X4DDF,	"\nif hw of total clusters (di) > 0\nsectors per cluster and cluster counts\nwill be modified (shifted)\n(but sectors per clust * clust count will be same)\n/// disk size -calculation- limit = 2 GB ///",	0);
	set_cmt	(0X4DE2,	"bx = free clusters (after xchg)",	0);
	set_name	(0X4DE2,	"gdrvfspc_2");
	set_name	(0X4DE4,	"DoSt");
	set_cmt	(0X4DE7,	"[SI+user_env.user_DX] ; total clusters",	0);
	set_cmt	(0X4DEA,	"ax = sectors per cluster (modified)",	0);
	create_insn	(0X4DED);
	set_name	(0X4DED,	"BADFDRV");
	set_cmt	(0X4DF0,	"-1",	0);
	set_cmt	(0X4DF5,	"Get Disk Transfer Address",	0);
	create_insn	(0X4DF5);
	set_name	(0X4DF5,	"$GET_DMA");
	set_cmt	(0X4E08,	"Set Disk Transfer Address",	0);
	create_insn	(0X4E08);
	set_name	(0X4E08,	"$SET_DMA");
	create_insn	(0X4E13);
	set_name	(0X4E13,	"$GET_DEFAULT_DRIVE");
	create_insn	(0X4E18);
	set_name	(0X4E18,	"$SET_DEFAULT_DRIVE");
	set_cmt	(0X4E1A,	"A=1, B=2...",	0);
	set_cmt	(0X4E1C,	"see if visible drive",	0);
	set_cmt	(0X4E1F,	"errors do not set",	0);
	set_cmt	(0X4E21,	"no, set",	0);
	set_cmt	(0X4E25,	"let user see what the count really is",	0);
	set_name	(0X4E25,	"SETRET");
	create_insn	(0X4E2A);
	set_name	(0X4E2A,	"$GET_INTERRUPT_VECTOR");
	set_cmt	(0X4E33,	"[SI+user_env.user_ES]",	0);
	set_name	(0X4E33,	"set_user_es_bx");
	create_insn	(0X4E39);
	set_name	(0X4E39,	"$SET_INTERRUPT_VECTOR");
	set_cmt	(0X4E45,	"EXECA20OF\nwas the previous call an int 21h exec call ?",	0);
	create_insn	(x=0X4E45);
	op_hex		(x,	1);
	set_cmt	(0X4E4B,	"yes",	0);
	create_insn	(0X4E4E);
	set_name	(0X4E4E,	"siv_1");
	set_cmt	(0X4E56,	"indicate to dos dispatcher to\nturn A20 Off before returning to user",	0);
	set_name	(0X4E5C,	"siv_2");
	create_insn	(0X4E5D);
	set_name	(0X4E5D,	"RECSET");
	create_insn	(x=0X4E63);
	op_hex		(x,	1);
	create_insn	(x=0X4E65);
	op_hex		(x,	1);
	set_cmt	(0X4E68,	"get switch?",	0);
	create_insn	(0X4E68);
	set_name	(0X4E68,	"$CHAR_OPER");
	set_cmt	(0X4E6A,	"assume yes",	0);
	create_insn	(x=0X4E6A);
	op_chr		(x,	1);
	set_cmt	(0X4E6C,	"jump if yes",	0);
	set_cmt	(0X4E6E,	"check device availability?",	0);
	set_cmt	(0X4E70,	"-1 ; assume yes",	0);
	set_cmt	(0X4E72,	"jump if yes",	0);
	set_cmt	(0X4E74,	"otherwise just quit",	0);
	create_insn	(0X4E75);
	set_name	(0X4E75,	"chop_1");
	set_cmt	(0X4E78,	"[SI+user_env.user_DX]\nstore value for user",	0);
	create_insn	(0X4E7C);
	set_name	(0X4E7C,	"$GetExtendedError");
	set_cmt	(0X4E85,	"BL = Action, BH = Class",	0);
	set_cmt	(0X4E90,	"[SI+user_env.user_DI]",	0);
	set_cmt	(0X4E96,	"[SI+user_env.user_CX]",	0);
	set_name	(0X4E99,	"_jmp_to_SYS_RET_OK");
	create_insn	(0X4E9C);
	set_name	(0X4E9C,	"$ECS_Call");
	set_cmt	(0X4EA3,	"[SI+user_env.user_SI],\nDBCS_TAB+2",	0);
	create_insn	(x=0X4EA3);
	op_hex		(x,	0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X4EAE,	"[SI+user_env.user_DS]",	0);
	create_insn	(x=0X4EAE);
	op_dec		(x,	0);
	set_name	(0X4EB2,	"_okok");
	set_cmt	(0X4EB4,	"longname functions are not supported",	0);
	create_insn	(0X4EB4);
	set_name	(0X4EB4,	"$LONGNAME");
	set_name	(0X4EB6,	"lfn_error");
	set_cmt	(0X4EB9,	"[SI+user_env.user_F],f_Carry",	0);
	create_insn	(x=0X4EB9);
	op_hex		(x,	1);
	set_cmt	(0X4EBE,	"[SI+user_env.user_ax]",	0);
	set_cmt	(0X4EC1,	"INT 21h AX = 7305h",	0);
	create_insn	(0X4EC1);
	set_name	(0X4EC1,	"$FAT32EXT");
	set_cmt	(0X4EC5,	"error_invalid_function",	0);
	set_name	(0X4EC7,	"fat32_ext_func_err");
	set_cmt	(0X4ECA,	"error_invalid_parameter",	0);
	create_insn	(x=0X4ECA);
	op_hex		(x,	1);
	set_name	(0X4ECA,	"function_5_invalid_cx");
	set_name	(0X4ECC,	"fat32_ext_func_err_j");
	create_insn	(0X4ECE);
	set_name	(0X4ECE,	"valid_fat32_ext_function");
	set_cmt	(0X4ED0,	"Function 5 - FAT32 - EXTENDED ABSOLUTE DISK READ/WRITE",	0);
	set_cmt	(0X4ED5,	"read/write mode flags",	0);
	create_insn	(x=0X4ED5);
	op_hex		(x,	1);
	set_cmt	(0X4EDB,	"drive number, 1 = A",	0);
	create_insn	(x=0X4EE1);
	op_hex		(x,	1);
	set_cmt	(0X4EE7,	"INT 21h AX = 7305h (SI bit 0 = 1)",	0);
	set_cmt	(0X4EEC,	"INT 21h AX = 7305h (SI bit 0 = 0)",	0);
	create_insn	(0X4EEC);
	set_name	(0X4EEC,	"function_5_read");
	set_name	(0X4EEF,	"fat32_absdrw_ret");
	create_insn	(0X4EF4);
	set_name	(0X4EF4,	"not_function_5");
	set_cmt	(0X4EF6,	"Function 3 - FAT32 - GET EXTENDED FREE SPACE ON DRIVE",	0);
	set_cmt	(0X4EFC,	"Function 2 - FAT32 - \"Get_ExtDPB\" - GET EXTENDED DPB\nFunction 4 - FAT32 - Set DPB TO USE FOR FORMATTING",	0);
	set_cmt	(0X4EFF,	"MSDOS 7 - DRIVE LOCKING AND FLUSHING",	0);
	create_insn	(x=0X4EFF);
	op_dec		(x,	1);
	set_name	(0X4EFF,	"chk_drive_lock_flush");
	set_cmt	(0X4F04,	"invalid drive number",	0);
	set_cmt	(0X4F06,	"ax = error code",	0);
	set_name	(0X4F06,	"drv_lock_flush_err");
	create_insn	(0X4F08);
	set_name	(0X4F08,	"drv_lock_flush_1");
	set_cmt	(0X4F0C,	"0 = default/current drive)",	0);
	set_name	(0X4F11,	"drv_lock_flush_2");
	set_cmt	(0X4F15,	"which flag to get or set",	0);
	set_cmt	(0X4F1A,	"error_invalid_function",	0);
	create_insn	(x=0X4F1E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X4F1E,	"drv_lock_flush_3");
	set_cmt	(0X4F25,	"use bit 1 and bit 2",	0);
	set_cmt	(0X4F27,	"get drive's dirty-buffers flag",	0);
	set_cmt	(0X4F29,	"use bit 3",	0);
	set_cmt	(0X4F2B,	"clear bit 3",	0);
	create_insn	(x=0X4F2B);
	op_hex		(x,	1);
	set_cmt	(0X4F2E,	"izolate bit 3 of the new flag value",	0);
	create_insn	(x=0X4F2E);
	op_hex		(x,	1);
	set_cmt	(0X4F31,	"set AH bit 3 according to CH bit 3",	0);
	set_cmt	(0X4F33,	"set or reset dirty buffer flag",	0);
	create_insn	(x=0X4F33);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X4F38);
	op_hex		(x,	1);
	set_cmt	(0X4F3B,	"bit 3 is set/1",	0);
	set_name	(0X4F42,	"set_dirty_flag_ok");
	set_cmt	(0X4F44,	"izolate dirty buffers flag",	0);
	create_insn	(x=0X4F44);
	op_hex		(x,	1);
	set_name	(0X4F44,	"get_dirty_buf_flag");
	set_cmt	(0X4F47,	"AH = new flag and 08h (bit 3 used)",	0);
	create_insn	(0X4F49);
	set_name	(0X4F49,	"get_set_indctd_flag");
	set_cmt	(0X4F4D,	"clear bit 1 and bit 2",	0);
	create_insn	(x=0X4F4D);
	op_hex		(x,	1);
	set_cmt	(0X4F50,	"new value for indicated flag",	0);
	create_insn	(x=0X4F50);
	op_hex		(x,	1);
	set_cmt	(0X4F53,	"bit 1 is zero",	0);
	set_cmt	(0X4F55,	"set bit 1 and bit 2",	0);
	create_insn	(x=0X4F55);
	op_hex		(x,	1);
	create_insn	(x=0X4F58);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X4F58,	"reset_indctd_flags");
	set_cmt	(0X4F5F,	"AH = new flag and 06h (bits 1 and 2 used)",	0);
	create_insn	(x=0X4F5F);
	op_hex		(x,	1);
	set_name	(0X4F5F,	"get_indicated_flag");
	set_cmt	(0X4F62,	"value of CL on entry",	0);
	set_name	(0X4F62,	"mov_flag_cl_to_al");
	set_name	(0X4F64,	"ret_ax_to_user_cx");
	set_cmt	(0X4F67,	"[SI+user_env.user_cx] ; requested flag",	0);
	set_name	(0X4F6A,	"jmp_to_SYS_RET_OK");
	set_cmt	(0X4F6D,	"FAT32 - GET EXTENDED FREE SPACE ON DRIVE\nAX = 7303h\nDS:DX -> ASCIZ string for drive (\"C:\\\" or \"\\\\SERVER\\Share\")\nES:DI -> buffer for extended free space structure\nCX = length of buffer for extended free space",	0);
	create_insn	(0X4F6D);
	set_name	(0X4F6D,	"function_73_3");
	create_insn	(x=0X4F76);
	op_dec		(x,	1);
	set_cmt	(0X4F86,	"buffer (Structure) size must be 44",	0);
	create_insn	(x=0X4F86);
	op_dec		(x,	1);
	set_cmt	(0X4F8B,	"buffer structure version (must be 0)",	0);
	set_name	(0X4F9B,	"func_73_3_err1");
	set_cmt	(0X4F9E,	"error_invalid_drive",	0);
	set_name	(0X4F9E,	"func_73_3_err2");
	set_name	(0X4FA0,	"jmp_to_SYS_RET_ERR");
	set_cmt	(0X4FA3,	"error_invalid_parameter",	0);
	create_insn	(x=0X4FA3);
	op_hex		(x,	1);
	set_name	(0X4FA3,	"func_73_3_err3");
	set_name	(0X4FA5,	"jmp_to_jmp_SYS_RET_ERR");
	set_cmt	(0X4FA7,	"error_bad_length",	0);
	create_insn	(0X4FA7);
	set_name	(0X4FA7,	"func_73_3_err4");
	create_insn	(0X4FAB);
	set_name	(0X4FAB,	"fill_efs_struc_b");
	set_cmt	(0X4FB2,	"si:dx = free cluster count",	0);
	set_cmt	(0X4FB3,	"di:bx = number of clusters",	0);
	set_cmt	(0X4FB7,	"user's buffer segment (in ES)",	0);
	set_cmt	(0X4FBA,	"user's buffer offset/address (in DI)",	0);
	set_cmt	(0X4FBD,	"total number of clusters on the drive",	0);
	set_cmt	(0X4FC1,	"total allocation units, without adjustment for compression",	0);
	set_cmt	(0X4FC6,	"total number of clusters on the drive, hw",	0);
	set_cmt	(0X4FCA,	"total allocation units, hw",	0);
	set_cmt	(0X4FCE,	"number of available clusters",	0);
	set_cmt	(0X4FD2,	"number of available allocation units, without adjustment",	0);
	set_cmt	(0X4FD7,	"number of available clusters, hw",	0);
	set_cmt	(0X4FDB,	"number of available allocation units, hw",	0);
	set_cmt	(0X4FDF,	"bytes per sector",	0);
	set_cmt	(0X4FE3,	"sectors per cluster (with adjustment for compression)",	0);
	set_cmt	(0X4FE9,	"32 bit multiplication",	0);
	set_cmt	(0X4FEB,	"disk capacity calculation overflow error",	0);
	set_cmt	(0X4FEF,	"total allocation units, lw",	0);
	set_cmt	(0X4FF9,	"set to 0FFFFFFFFh",	0);
	set_name	(0X4FF9,	"dsk_cap_calc_overf");
	set_name	(0X4FFE,	"dsk_cap_calc_ok");
	set_cmt	(0X5002,	"total number of physical sectors on the drive,\nwithout adjustment for compression",	0);
	set_cmt	(0X5006,	"32 bit multiplication",	0);
	set_cmt	(0X5008,	"number of available clusters, hw",	0);
	set_cmt	(0X5010,	"number of available clusters, lw",	0);
	set_name	(0X501A,	"dsk_free_calc_overf");
	set_cmt	(0X501F,	"hw",	0);
	set_name	(0X501F,	"dsk_free_calc_ok");
	set_cmt	(0X5023,	"number of physical sectors available on the drive,\nwithout adjustment for compression",	0);
	set_cmt	(0X5027,	"0",	0);
	set_cmt	(0X5029,	"number of bytes per sector, high word = 0",	0);
	set_cmt	(0X502D,	"number of sectors per cluster, high word = 0",	0);
	set_cmt	(0X5031,	"reserved, 8 bytes zero",	0);
	create_insn	(x=0X5041);
	op_dec		(x,	1);
	set_cmt	(0X5044,	"size of returned structure = 44",	0);
	set_cmt	(0X504A,	"[SI+user_env.user_CX]\nsize of buffer (must be at least 18h)",	0);
	create_insn	(x=0X504A);
	op_dec		(x,	1);
	set_name	(0X504A,	"Set_DPBforFormat");
	set_cmt	(0X5050,	"error_bad_length",	0);
	set_name	(0X5052,	"setdpbf_1");
	set_cmt	(0X5055,	"ES:BP = Drive parameter block",	0);
	create_insn	(0X5055);
	set_name	(0X5055,	"setdpbf_2");
	set_cmt	(0X5057,	"[SI+user_env.user_ES]",	0);
	set_cmt	(0X505A,	"[SI+user_env.user_DI]",	0);
	set_cmt	(0X505F,	"(call) function number",	0);
	set_cmt	(0X5063,	"structure version (must be 0)",	0);
	set_cmt	(0X506A,	"(must be 0)",	0);
	set_cmt	(0X5071,	"(max) 5 functions (0 to 4)",	0);
	set_cmt	(0X5076,	"error_invalid_parameter",	0);
	create_insn	(x=0X5076);
	op_hex		(x,	1);
	set_name	(0X5076,	"setdpbf_3");
	set_cmt	(0X507A,	"(call) size",	0);
	create_insn	(0X507A);
	set_name	(0X507A,	"setdpbf_4");
	set_cmt	(0X5081,	"invalidate DPB counts",	0);
	set_cmt	(0X5086,	"0",	0);
	create_insn	(0X5086);
	set_name	(0X5086,	"setdpbf_5");
	set_cmt	(0X5088,	"DPB.MAX_CLUSTER",	0);
	set_cmt	(0X508B,	"DPB.FAT_SIZE",	0);
	set_cmt	(0X508F,	"not FAT32",	0);
	set_cmt	(0X5094,	"DPB.LAST_CLUSTER",	0);
	set_name	(0X5097,	"setdpbf_6");
	set_cmt	(0X509B,	"new DPB free count \n(00000000h=no change, FFFFFFFFh=unknown)",	0);
	set_name	(0X50A5,	"setdpbf_7");
	set_cmt	(0X50AD,	"(set as UNKNOWN/INITIAL)",	0);
	set_cmt	(0X50AF,	"must be < DPB.LAST_CLUSTER",	0);
	set_name	(0X50AF,	"setdpbf_8");
	set_name	(0X50B5,	"setdpbf_9");
	set_cmt	(0X50B7,	"DPB.FIRST_ACCESS (bit 0 = 1)",	0);
	create_insn	(x=0X50B7);
	op_hex		(x,	1);
	set_name	(0X50B7,	"setdpbf_10");
	set_cmt	(0X50BB,	"DPB.FREE_CNT",	0);
	set_cmt	(0X50BE,	"DP.FAT_SIZE",	0);
	set_cmt	(0X50C2,	"FAT12 or FAT16",	0);
	set_cmt	(0X50C4,	"DPB.FREE_CNT_HW",	0);
	set_name	(0X50C7,	"setdpbf_11");
	set_cmt	(0X50CB,	"new DPB next-free\n(00000000h=no change, FFFFFFFFh=unknown)",	0);
	set_name	(0X50D5,	"setdpbf_12");
	set_cmt	(0X50DD,	"(set as UNKNOWN/INITIAL)",	0);
	set_cmt	(0X50DF,	"must be >= 2",	0);
	set_name	(0X50DF,	"setdpbf_13");
	set_name	(0X50E7,	"setdpbf_14");
	set_cmt	(0X50E9,	"must be < DPB.LAST_CLUSTER",	0);
	set_name	(0X50EF,	"setdpbf_15");
	set_cmt	(0X50F1,	"DPB.FIRST_ACCESS (bit 0 = 1)",	0);
	create_insn	(x=0X50F1);
	op_hex		(x,	1);
	set_name	(0X50F1,	"setdpbf_16");
	set_cmt	(0X50F5,	"DPB.NEXT_FREE",	0);
	set_cmt	(0X50F8,	"DPB.FAT_SIZE",	0);
	set_cmt	(0X50FC,	"FAT16 or FAT12",	0);
	set_cmt	(0X5101,	"DPB.FAT32_NXTFREE",	0);
	set_cmt	(0X5104,	"done (successful)",	0);
	set_name	(0X5104,	"setdpbf_17");
	create_insn	(0X510A);
	set_name	(0X510A,	"setdpbf_18");
	set_cmt	(0X510E,	"rebuild DPB from BPB",	0);
	set_cmt	(0X5110,	"BIOS Parameter Block",	0);
	set_cmt	(0X5116,	"'XE' (NASM syntax)",	0);
	set_cmt	(0X5119,	"'RA' (NASM syntax)",	0);
	create_insn	(0X5122);
	set_name	(0X5122,	"setdpbf_19");
	set_cmt	(0X5124,	"\nforce media change\n(next access to drive rebuild DPB)",	0);
	set_cmt	(0X5126,	"DPB.FIRST_ACCESS (bit 7 = 1)",	0);
	create_insn	(x=0X5126);
	op_hex		(x,	1);
	set_cmt	(0X512D,	"DPB.FAT_SIZE",	0);
	create_insn	(0X512D);
	set_name	(0X512D,	"setdpbf_20");
	set_cmt	(0X5131,	"FAT32",	0);
	set_cmt	(0X5133,	"error_invalid_drive\n(function 3 or 4 are only for drives with FAT32 fs)",	0);
	set_name	(0X5135,	"setdpbf_21");
	create_insn	(0X5138);
	set_name	(0X5138,	"setdpbf_22");
	set_cmt	(0X513A,	"get/set active FAT number and mirroring",	0);
	set_cmt	(0X513C,	"get/set root directory cluster number\nDPB.ROOT_CLUSTER",	0);
	set_cmt	(0X513F,	"(ret) previous root directory cluster number",	0);
	set_cmt	(0X514E,	"(call) new root directory cluster number",	0);
	set_cmt	(0X5152,	"-1 --> return only previous root dir cluster number",	0);
	set_cmt	(0X515C,	"cluster number must be >= 2",	0);
	set_name	(0X515C,	"setdpbf_23");
	set_name	(0X5164,	"setdpbf_24");
	set_cmt	(0X5166,	"error (invalid parameter)",	0);
	set_name	(0X5166,	"setdpbf_25");
	set_cmt	(0X5169,	"must be <= DPB.LAST_CLUSTER",	0);
	create_insn	(0X5169);
	set_name	(0X5169,	"setdpbf_26");
	set_cmt	(0X5171,	"error",	0);
	set_name	(0X5171,	"setdpbf_27");
	set_cmt	(0X5173,	"DPB.ROOT_CLUSTER",	0);
	set_cmt	(0X5179,	"DPB.FIRST_ACCESS (bit 1 = 1)",	0);
	create_insn	(x=0X5179);
	op_hex		(x,	1);
	set_cmt	(0X518C,	"error_gen_failure",	0);
	set_name	(0X518E,	"setdpbf_28");
	create_insn	(0X5190);
	set_name	(0X5190,	"setdpbf_29");
	set_cmt	(0X5193,	"DPB.EXT_FLAGS (clear bit 4-6)",	0);
	create_insn	(x=0X5193);
	op_hex		(x,	1);
	set_name	(0X5193,	"setdpbf_30");
	set_cmt	(0X519B,	"(ret) previous active FAT/mirroring state",	0);
	set_cmt	(0X519F,	"\nput zero to Set_DPBforFormat struc offset 14",	0);
	set_cmt	(0X51A5,	"(call) new active FAT/mirroring state,\n or FFFFFFFFh to get",	0);
	create_insn	(x=0X51B1);
	op_hex		(x,	1);
	set_name	(0X51B1,	"setdpbf_31");
	set_cmt	(0X51B5,	"bit 4-6 of DPB.EXT_FLAGS must be 0",	0);
	set_cmt	(0X51B7,	"error_invalid_parameter",	0);
	create_insn	(x=0X51B7);
	op_hex		(x,	1);
	set_name	(0X51B9,	"setdpbf_32");
	set_cmt	(0X51BB,	"error_invalid_function\n(modification is not allowed)",	0);
	create_insn	(0X51BB);
	set_name	(0X51BB,	"setdpbf_33");
	create_insn	(0X51BF);
	set_name	(0X51BF,	"$PARSE_FILE_DESCRIPTOR");
	set_cmt	(0X51C6,	"[SI+user_env.user_SI]",	0);
	create_insn	(0X51CA);
	set_name	(0X51CA,	"set_exerr_locus_unk");
	set_cmt	(0X51CB,	"errLOC_Unk",	0);
	set_name	(0X51CD,	"set_exerr_locus");
	create_insn	(0X51D3);
	set_name	(0X51D3,	"set_exerr_locus_disk");
	set_cmt	(0X51D4,	"errLOC_Disk",	0);
	create_insn	(0X51D8);
	set_name	(0X51D8,	"set_exerr_locus_ser");
	set_cmt	(0X51D9,	"errLOC_SerDev",	0);
	create_insn	(0X51DD);
	set_name	(0X51DD,	"set_exerr_locus_mem");
	set_cmt	(0X51DE,	"errLOC_Mem",	0);
	set_cmt	(0X51E2,	"default drive",	0);
	create_insn	(0X51E2);
	set_name	(0X51E2,	"$SLEAZEFUNC");
	set_name	(0X51E4,	"$SLEAZEFUNCDL");
	set_cmt	(0X51E8,	"Get CDS structure",	0);
	set_cmt	(0X51F2,	"FAT (MEDIA) ID byte",	0);
	set_cmt	(0X51F6,	"AH = 0\nAL = sectors per cluster",	0);
	set_cmt	(0X51F8,	"di:bx = number of clusters",	0);
	set_cmt	(0X51FF,	"bytes per sector",	0);
	set_cmt	(0X5203,	"ax = sectors per cluster (modified)\ndx = number of clusters (modified)\nif bytes per cluster > 16384\n   and hw of cluster count > 0\n   bx = 0FFFEh (invalidated parms sign)",	0);
	create_insn	(x=0X5204);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X5204,	"sleazefunc1");
	set_cmt	(0X520A,	"[SI+user_env.user_CX]",	0);
	set_cmt	(0X520D,	"[SI+user_env.user_DX]",	0);
	set_cmt	(0X5210,	"[SI+user_env.user_BX]",	0);
	set_cmt	(0X5213,	"[SI+user_env.user_DS]\nstash correct pointer",	0);
	set_cmt	(0X5217,	"error",	0);
	create_insn	(0X5217);
	set_name	(0X5217,	"BADSLDRIVE");
	create_insn	(0X521A);
	set_name	(0X521A,	"$GET_INDOS_FLAG");
	set_cmt	(0X521D,	"[SI+user_env.user_BX]",	0);
	create_insn	(x=0X521D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X5222,	"[SI+user_env.user_ES]",	0);
	set_name	(0X5222,	"getin_segm");
	set_cmt	(0X5226,	"Return Pointer to DOS Variables",	0);
	create_insn	(0X5226);
	set_name	(0X5226,	"$GET_IN_VARS");
	set_cmt	(0X5229,	"[SI+user_env.user_BX],\nSYSINITVARS",	0);
	create_insn	(x=0X5229);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X5230);
	set_name	(0X5230,	"$GET_DEFAULT_DPB");
	set_name	(0X5232,	"$GET_DPB");
	set_cmt	(0X5236,	"Get CDS structure",	0);
	set_cmt	(0X5239,	"error_invalid_drive",	0);
	set_name	(0X523D,	"getdpb_1");
	set_cmt	(0X5240,	"INT 21h, AX = 7302h ? Get_ExtDPB\nGET EXTENDED DPB",	0);
	set_cmt	(0X5246,	"INT 21h, AX = 7304h ? Set_DPBforFormat\nSet DPB TO USE FOR FORMATTING",	0);
	set_name	(0X524C,	"getdpb_2");
	set_cmt	(0X524F,	"-1 ; invalid (or network) drive",	0);
	create_insn	(0X524F);
	set_name	(0X524F,	"ISNODRV");
	create_insn	(0X5252);
	set_name	(0X5252,	"getdpb_3");
	set_cmt	(0X5256,	"[ES:DI+curdir.flags+1],\n(curdir_isnet>>8)",	0);
	create_insn	(x=0X5256);
	op_hex		(x,	1);
	set_cmt	(0X5266,	"error_FAIL_I24",	0);
	create_insn	(x=0X5266);
	op_hex		(x,	1);
	set_cmt	(0X526D,	"INT 21h, AX = 7304h ?",	0);
	set_cmt	(0X5276,	"INT 21h, AX = 7302h ?",	0);
	create_insn	(0X5276);
	set_name	(0X5276,	"getdpb_4");
	set_cmt	(0X5289,	"status = 0 = successful",	0);
	set_cmt	(0X528C,	"error_bad_length",	0);
	create_insn	(x=0X528C);
	op_hex		(x,	1);
	set_name	(0X528C,	"getdpb_5");
	set_cmt	(0X528E,	"[SI+user_env.user_CX]\nlength of buffer (must be 63 bytes)",	0);
	create_insn	(x=0X528E);
	op_dec		(x,	1);
	set_cmt	(0X5292,	"error",	0);
	set_cmt	(0X5294,	"ES:BP = Drive parameter block",	0);
	set_cmt	(0X5296,	"[SI+user_env.user_ES]",	0);
	create_insn	(x=0X5296);
	op_dec		(x,	1);
	set_cmt	(0X5299,	"[SI+user_env.user_DI]",	0);
	create_insn	(x=0X5299);
	op_dec		(x,	1);
	set_cmt	(0X529C,	"[SI+user_env.user_SI] (!)",	0);
	set_cmt	(0X52A1,	"length of following data (003Dh)",	0);
	create_insn	(x=0X52A1);
	op_dec		(x,	1);
	set_cmt	(0X52AB,	"(!) signature (undocumented),\n must be 0F1A6h to get device driver\n address and next-DPB pointer\n(Ref: Ralf Brown's Interrupt List)",	0);
	create_insn	(x=0X52AB);
	op_hex		(x,	1);
	set_cmt	(0X52B1,	"0",	0);
	set_cmt	(0X52B3,	"-1",	0);
	set_cmt	(0X52B4,	"pointer to next DPB (invalidated)",	0);
	set_cmt	(0X52BC,	"pointer to driver address (invalidated)",	0);
	set_cmt	(0X52C4,	"FAT (16 bit) size ?",	0);
	set_name	(0X52C4,	"getdpb_6");
	set_cmt	(0X52C9,	"FAT32\nFAT16 or FAT12",	0);
	set_cmt	(0X52CB,	"DPB.MAX_CLUSTER",	0);
	set_cmt	(0X52CF,	"DPB.LAST_CLUSTER",	0);
	set_cmt	(0X52D3,	"DPB.FAT_SIZE",	0);
	set_cmt	(0X52D7,	"DPB.FAT32_SIZE",	0);
	set_cmt	(0X52DB,	"DPB.NEXT_FREE",	0);
	set_cmt	(0X52DF,	"DPB.FAT32_NXTFREE",	0);
	set_cmt	(0X52E3,	"DPB.FIRST_SECTOR",	0);
	set_cmt	(0X52E7,	"DPB.FCLUS_FSECTOR",	0);
	set_cmt	(0X52EB,	"0",	0);
	set_cmt	(0X52ED,	"DPB.LAST_CLUSTER high word",	0);
	set_cmt	(0X52F1,	"DPB.FAT32_SIZE high word",	0);
	set_cmt	(0X52F5,	"DPB.FAT32_NXTFREE high word",	0);
	set_cmt	(0X52F9,	"DPB.FCLUS_FSECTOR high word",	0);
	set_cmt	(0X52FD,	"DPB.ROOT_CLUSTER",	0);
	set_cmt	(0X5301,	"DPB.ROOT_CLUSTER high word",	0);
	set_cmt	(0X5305,	"DPB.EXT_FLAGS",	0);
	set_cmt	(0X5309,	"-1",	0);
	set_cmt	(0X530A,	"DPB.FSINFO_SECTOR (invalidated)",	0);
	set_cmt	(0X530E,	"DPB.BKBOOT_SECTOR (invalidated)",	0);
	set_cmt	(0X5312,	"DPB.FREE_COUNT (= -1 ?)",	0);
	set_cmt	(0X5318,	"-1 -> 0",	0);
	set_cmt	(0X5319,	"DPB.PB.FREE_COUNT high word",	0);
	set_name	(0X5319,	"getdpb_7");
	set_cmt	(0X531D,	"status = 0 = successful",	0);
	set_name	(0X531D,	"getdpb_8");
	set_cmt	(0X5322,	"-1",	0);
	create_insn	(0X5322);
	set_name	(0X5322,	"$DISK_RESET");
	set_cmt	(0X5329,	"FROM_DISK_RESET",	0);
	create_insn	(x=0X5329);
	op_hex		(x,	1);
	set_cmt	(0X5331,	"NO_FROM_DISK_RESET",	0);
	create_insn	(x=0X5331);
	op_hex		(x,	1);
	set_cmt	(0X533A,	"-1 ?",	0);
	set_name	(0X533A,	"drst_1");
	set_cmt	(0X533D,	"yes, it is the last DPB",	0);
	set_cmt	(0X533F,	"update FSINFO (sector) parameters",	0);
	set_cmt	(0X5342,	"DPB.NEXT_DPB",	0);
	set_cmt	(0X5348,	"Throw out secondary cache",	0);
	create_insn	(0X5348);
	set_name	(0X5348,	"drst_2");
	set_cmt	(0X534E,	"-1",	0);
	set_cmt	(0X5351,	"Invalidate 'last-buffer' used",	0);
	set_cmt	(0X5363,	"Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS\nDS = DOS CS\nReturn: CF clear (successful)",	0);
	create_insn	(x=0X5363);
	op_hex		(x,	0);
	create_word	(0X5367);
	set_name	(0X5367,	"word3");
	set_cmt	(0X5369,	"Buffer address (es:bp)",	0);
	create_insn	(0X5369);
	set_name	(0X5369,	"$SETDPB");
	set_cmt	(0X536B,	"Skip over dpb_drive and dpb_UNIT",	0);
	set_cmt	(0X536D,	"dpb_sector_size ; bytes per sector",	0);
	set_cmt	(0X536E,	".BPB_BYTESPERSECTOR",	0);
	set_cmt	(0X536F,	"'XE' (NASM syntax)\nCX = signature 4558h ('EX') for FAT32 extended BPB/DPB",	0);
	set_cmt	(0X5375,	"'RA' (NASM syntax)\nDX = signature 4152h ('AR') for FAT32 extended BPB/DPB",	0);
	set_cmt	(0X537B,	"0 ; (Do not use FAT32 extensions -32 bit parameters-)",	0);
	set_cmt	(0X537D,	"(*)",	0);
	set_cmt	(0X537E,	".BPB_NUMBEROFFATS",	0);
	set_cmt	(0X5384,	".BPB_SECTORSPERFAT ; BPB_FATSz16",	0);
	set_cmt	(0X538A,	".BPB_FAT32VERSION ; BPB_FSVer",	0);
	create_insn	(x=0X538A);
	op_dec		(x,	0);
	set_cmt	(0X5392,	"DPB.FAT_COUNT = 0",	0);
	set_cmt	(0X5396,	"DPB.DRIVER_ADDR",	0);
	create_insn	(x=0X5396);
	op_dec		(x,	1);
	set_cmt	(0X5399,	".BPB_SECTORSPERTRACK",	0);
	create_insn	(x=0X5399);
	op_dec		(x,	1);
	set_cmt	(0X539C,	"DPB.FAT_SIZE = 0",	0);
	create_insn	(x=0X539C);
	op_dec		(x,	0);
	set_cmt	(0X53A3,	"bytes per sector",	0);
	create_insn	(0X53A3);
	set_cmt	(0X53A5,	".BPB_SECTORSPERCLUSTER",	0);
	set_cmt	(0X53AE,	"DPB.CLUSTER_MASK ; Sectors/cluster - 1",	0);
	create_insn	(x=0X53B1);
	op_hex		(x,	1);
	create_insn	(x=0X53B7);
	op_hex		(x,	1);
	create_insn	(0X53BB);
	set_cmt	(0X53BD,	"DPB.CLUSTER_SHIFT ; Log2 of sectors/cluster",	0);
	set_cmt	(0X53C0,	".BPB_RESERVEDSECTORS -> DPB.FIRST_FAT",	0);
	set_cmt	(0X53C1,	".BPB_NUMBEROFFATS",	0);
	set_cmt	(0X53C2,	"DPB.FAT_COUNT",	0);
	set_cmt	(0X53C5,	".BPB_ROOTENTRIES",	0);
	set_cmt	(0X53C6,	"DPB.ROOT_ENTRIES",	0);
	set_cmt	(0X53C9,	"Directory entries per sector",	0);
	set_cmt	(0X53CC,	"Round Up",	0);
	set_cmt	(0X53D4,	"Number of root directory sectors",	0);
	set_cmt	(0X53D8,	".BPB_TOTALSECTORS -> DPB.MAX_CLUSTER (temporary)",	0);
	set_cmt	(0X53D9,	".BPB_MEDIADESCRIPTOR",	0);
	set_cmt	(0X53DA,	"DPB.MEDIA",	0);
	create_insn	(x=0X53DA);
	op_dec		(x,	0);
	set_cmt	(0X53DE,	".BPB_SECTORSPERFAT",	0);
	set_cmt	(0X53DF,	"DPB.FAT_SIZE",	0);
	set_cmt	(0X53E4,	"16 bit FAT size",	0);
	set_cmt	(0X53E6,	"(*) FAT32 extensions\n(use 32 bit FAT and Root Dir size if >0)",	0);
	set_cmt	(0X53E7,	"(*)",	0);
	set_cmt	(0X53EA,	"Do not use FAT32 extensions\n(do not use 32 bit FAT size field)",	0);
	set_cmt	(0X53EC,	".BPB_SECTORSPERFAT32 ; BPB_FATSz32",	0);
	create_insn	(x=0X53EC);
	op_dec		(x,	1);
	set_cmt	(0X53EF,	".BPB_SECTORSPERFAT32+2",	0);
	create_insn	(x=0X53EF);
	op_dec		(x,	1);
	set_cmt	(0X53F2,	"(**) Root directory sectors",	0);
	set_cmt	(0X53F3,	"32 bit multiply",	0);
	set_cmt	(0X53F5,	"FAT count",	0);
	set_cmt	(0X53FC,	"FAT count",	0);
	set_cmt	(0X5404,	"(**)",	0);
	set_cmt	(0X5411,	"dx:ax = (total) FAT sectors\nadd ax,[es:bp+DPB.FIRST_FAT]",	0);
	create_insn	(0X5411);
	set_cmt	(0X5418,	"DPB.DIR_SECTOR",	0);
	set_cmt	(0X5419,	"+ root directory size",	0);
	set_cmt	(0X541B,	"DPB.FIRST_SECTOR ; First data sector",	0);
	create_insn	(x=0X541B);
	op_dec		(x,	0);
	set_cmt	(0X5422,	"(*)",	0);
	set_cmt	(0X5426,	"DPB.BIG_FIRST_SECTOR ; FAT32 first sector field",	0);
	create_insn	(x=0X5426);
	op_dec		(x,	0);
	create_insn	(x=0X542A);
	op_dec		(x,	0);
	set_cmt	(0X542E,	"cluster shift",	0);
	set_cmt	(0X5430,	"DPB.MAX_CLUSTER\n(contains 16 bit .BPB_TOTALSECTORS as temporary)",	0);
	create_insn	(x=0X5430);
	op_dec		(x,	0);
	set_cmt	(0X543A,	"SI points to .BPB_SECTORSPERTRACK and SI+8 is\n.BPB_BIGTOTALSECTORS (32 bit total sectors)",	0);
	create_insn	(x=0X543D);
	op_dec		(x,	1);
	set_cmt	(0X5443,	"dx:bx = data sectors (for cluster count calc)",	0);
	create_insn	(x=0X544A);
	op_hex		(x,	1);
	create_insn	(x=0X544C);
	op_hex		(x,	1);
	set_cmt	(0X5450,	"dx:ax = cluster count",	0);
	set_cmt	(0X5454,	"first sector - total sectors",	0);
	create_insn	(x=0X5454);
	op_dec		(x,	1);
	set_cmt	(0X545A,	"data sectors = total sectors - first sector",	0);
	set_cmt	(0X545C,	"cluster count",	0);
	set_cmt	(0X545E,	"(*) 0 = not 32 bit fat sectors",	0);
	set_cmt	(0X545F,	"(*)",	0);
	set_cmt	(0X5463,	"calculated # clusters HW",	0);
	set_cmt	(0X5466,	"calculated # clusters LW",	0);
	set_cmt	(0X5468,	"FAT size (16 bit)",	0);
	create_insn	(x=0X5468);
	op_dec		(x,	1);
	set_cmt	(0X546C,	"Do not use 32 bit FAT sectors field",	0);
	set_cmt	(0X5474,	".BPB_SECTORSPERFAT32  ; 32 bit FAT size field.",	0);
	create_insn	(x=0X5474);
	op_dec		(x,	1);
	set_cmt	(0X5477,	".BPB_SECTORSPERFAT32+2",	0);
	create_insn	(x=0X5477);
	op_dec		(x,	1);
	set_cmt	(0X547A,	"cx:ax = FAT size (in sectors)\ndx:bx = calculated number of clusters",	0);
	set_cmt	(0X547C,	"DPB.SECTOR_SIZE",	0);
	set_cmt	(0X5485,	"dx:ax = FAT size in bytes",	0);
	set_cmt	(0X5487,	"calculated # clusters HW",	0);
	set_cmt	(0X548A,	"FAT32",	0);
	set_cmt	(0X5490,	"FAT12",	0);
	set_cmt	(0X5492,	"HW of calculated cluster count",	0);
	set_cmt	(0X5499,	"FAT16",	0);
	set_cmt	(0X549B,	"FAT32 ; 4 byte (32 bit) cluster number\nfatsiz/4 = # of fat entries",	0);
	create_insn	(x=0X549B);
	op_hex		(x,	1);
	create_insn	(x=0X549D);
	op_hex		(x,	1);
	create_insn	(x=0X549F);
	op_hex		(x,	1);
	set_cmt	(0X54A1,	"dx = 0",	0);
	create_insn	(x=0X54A3);
	op_hex		(x,	1);
	set_cmt	(0X54A7,	"FAT16 ; 2 byte (16 bit) cluster number\nfatsiz/2 = # of fat entries",	0);
	create_insn	(x=0X54A7);
	op_hex		(x,	1);
	set_cmt	(0X54A9,	"dx > 0",	0);
	set_cmt	(0X54AB,	"FAT16 ; 2 byte (16 bit) cluster number\nfatsiz/2 = # of fat entries",	0);
	create_insn	(x=0X54AB);
	op_hex		(x,	1);
	set_cmt	(0X54AD,	"4096-10+1",	0);
	set_cmt	(0X54B4,	"FAT12 ; 1.5 byte (12 bit) cluster number\n(fatsiz*2)/3 = # of fat entries",	0);
	create_insn	(0X54B4);
	set_cmt	(0X54B8,	"if our fatspace is more than we need\nuse calculated size",	0);
	set_cmt	(0X54C8,	"is fat big enough?",	0);
	set_cmt	(0X54CE,	"use max value that'll fit",	0);
	set_cmt	(0X54D0,	"use calculated value",	0);
	set_cmt	(0X54D4,	"DPB.FAT_SIZE ; 16 bit FAT size",	0);
	create_insn	(x=0X54D4);
	op_dec		(x,	0);
	set_cmt	(0X54DB,	"DPB.DIR_SECTOR \n(16 bit directory sector field)",	0);
	create_insn	(x=0X54DB);
	op_dec		(x,	0);
	set_cmt	(0X54E1,	"DPB.MAX_CLUSTER (16 bit)",	0);
	create_insn	(x=0X54E1);
	op_dec		(x,	0);
	set_cmt	(0X54E9,	"DPB.MAX_CLUSTER = calculated last cluster number",	0);
	create_insn	(x=0X54E9);
	op_dec		(x,	0);
	set_cmt	(0X54ED,	"(*) 1 = use FAT32 extensions\n    0 = don't use FAT32 extensions (32 bit fields)",	0);
	set_cmt	(0X54EE,	"do not use FAT32 extensions",	0);
	set_cmt	(0X54F0,	"DPB.MAX_CLUSTER32 ; dx:ax = last cluster number",	0);
	create_insn	(x=0X54F0);
	op_dec		(x,	0);
	create_insn	(x=0X54F4);
	op_dec		(x,	0);
	set_cmt	(0X54F8,	"-1",	0);
	set_cmt	(0X54FB,	"DPB.FREE_CNT_HW\nHigh word of free cluster count",	0);
	create_insn	(x=0X54FB);
	op_dec		(x,	1);
	set_cmt	(0X54FE,	"-1 ; 0FFFFh",	0);
	set_cmt	(0X54FF,	"FAT32 flags",	0);
	create_insn	(x=0X54FF);
	op_dec		(x,	1);
	set_cmt	(0X5502,	"DPB FAT32 flags ; [bp+23h]",	0);
	set_cmt	(0X5506,	"FSINFO structure sector number",	0);
	set_cmt	(0X5507,	".BPB_RESERVEDSECTORS ; Number of reserved sectors.",	0);
	set_cmt	(0X5512,	"-1 ; invalid",	0);
	set_cmt	(0X5515,	"DPB FSINFO structure sector number\n[bp+25h]",	0);
	set_cmt	(0X5516,	"Sector number of the backup boot sector",	0);
	set_cmt	(0X551F,	"-1 ; invalid",	0);
	set_cmt	(0X5522,	"DPB backup boot sector address\n[bp+27h]",	0);
	set_cmt	(0X5523,	"[bp+31h]",	0);
	set_cmt	(0X5528,	"[bp+0Fh] ; DPB.MAX_CLUSTER",	0);
	create_insn	(x=0X5528);
	op_dec		(x,	1);
	set_cmt	(0X552E,	"> 0 (not FAT32)",	0);
	set_cmt	(0X5530,	"FAT32 Sectors per FAT ; .BPB_SECTORSPERFAT32",	0);
	create_insn	(x=0X5530);
	op_dec		(x,	1);
	create_insn	(x=0X5533);
	op_dec		(x,	1);
	set_cmt	(0X5536,	"DPB FAT32 FAT size in sectors ; [bp+31h]",	0);
	set_cmt	(0X553A,	"Root directory cluster number",	0);
	set_cmt	(0X553D,	"DPB Root Dir Cluster ; [bp+35h]",	0);
	set_cmt	(0X553F,	"DPB reserved ; [bp+39h]",	0);
	set_cmt	(0X5545,	"DPB.NEXT_FREE ; last allocated cluster #",	0);
	create_insn	(x=0X5545);
	op_dec		(x,	0);
	set_cmt	(0X554A,	"DPB.FREE_CNT (-1 = unknown)",	0);
	create_insn	(x=0X554A);
	op_dec		(x,	0);
	create_insn	(0X554F);
	set_name	(0X554F,	"$DUP_PDB");
	set_cmt	(0X5554,	"indicate a new process",	0);
	create_insn	(x=0X5554);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X5559);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X5560);
	set_name	(0X5560,	"$CREATE_PROCESS_DATA_BLOCK");
	set_cmt	(0X5563,	"[SI+user_env.user_CS]",	0);
	set_cmt	(0X5566,	"[PDB.BLOCK_LEN]",	0);
	set_cmt	(0X556C,	"copy entire PDB",	0);
	create_insn	(x=0X5570);
	op_dec		(x,	1);
	set_cmt	(0X5575,	"FILPERPROC",	0);
	create_insn	(x=0X5575);
	op_dec		(x,	1);
	set_cmt	(0X5578,	"PDB.JFN_TABLE",	0);
	create_insn	(x=0X5578);
	op_hex		(x,	1);
	set_cmt	(0X557C,	"[PDB.JFN_Pointer]",	0);
	create_insn	(x=0X557C);
	create_insn	(x=0X5588);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X5596);
	op_dec		(x,	1);
	set_cmt	(0X559D,	"unassigned JFN",	0);
	set_cmt	(0X55A1,	"[ES:DI+SF_ENTRY.sf_flags+1],\n(sf_no_inherit>>8)",	0);
	create_insn	(x=0X55A1);
	op_hex		(x,	1);
	set_cmt	(0X55A6,	"if no-inherit bit is set, skip dup.",	0);
	set_cmt	(0X55A8,	"[ES:DI+SF_ENTRY.sf_mode]",	0);
	set_cmt	(0X55AC,	"SHARING_MASK",	0);
	create_insn	(x=0X55AC);
	op_hex		(x,	1);
	set_cmt	(0X55AF,	"SHARING_NET_FCB",	0);
	create_insn	(x=0X55AF);
	op_hex		(x,	1);
	create_insn	(x=0X55B4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X55B8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X55C6,	"[ES:BX+PDB.JFN_TABLE]",	0);
	set_cmt	(0X55CA,	"next jfn",	0);
	set_cmt	(0X55CD,	"get current process",	0);
	create_insn	(x=0X55CD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X55D1,	"[ES:PDB.PARENT_PID]",	0);
	create_insn	(x=0X55D6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X55E2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X55E9);
	set_name	(0X55E9,	"SETMEM");
	set_cmt	(0X55EF,	"addr_int_terminate",	0);
	set_cmt	(0X55F2,	"SAVEXIT",	0);
	set_cmt	(0X55FF,	"MAXDIF",	0);
	set_cmt	(0X5604,	"MAXDIF",	0);
	set_cmt	(0X5607,	"Allow for 100h byte \"stack\" in .COM files",	0);
	set_cmt	(0X560A,	"ENTRYPOINTSEG",	0);
	set_cmt	(0X5615,	"[PDB.CPM_CALL+1]",	0);
	set_cmt	(0X5618,	"[PDB.CPM_CALL+3]",	0);
	set_cmt	(0X561C,	"WRAPOFFSET",	0);
	set_cmt	(0X5621,	"[PDB.CPM_CALL+1],0C0h",	0);
	set_cmt	(0X5627,	"[PDB.CPM_CALL+3],0",	0);
	set_cmt	(0X562D,	"PDB.EXIT_CALL],(int_abort*256) + mi_INT",	0);
	set_cmt	(0X5633,	"[PDB.CPM_CALL],mi_Long_CALL",	0);
	set_cmt	(0X5638,	"[PDB.CALL_SYSTEM],(int_command*256) + mi_INT",	0);
	set_cmt	(0X563E,	"[PDB.CALL_SYSTEM+2],mi_Long_RET",	0);
	set_cmt	(0X5643,	"[PDB.JFN_Pointer],PDB.JFN_TABLE",	0);
	set_cmt	(0X5649,	"PDB.JFN_Pointer+2],DS",	0);
	set_cmt	(0X564D,	"[PDB.JFN_Length],FILPERPROC",	0);
	set_cmt	(0X5653,	"[PDB.Next_PDB],-1",	0);
	set_cmt	(0X5659,	"[PDB.Next_PDB+2],-1",	0);
	set_cmt	(0X565F,	"[ES:PDB.Version],\n(MINOR_VERSION*256)+MAJOR_VERSION",	0);
	create_insn	(0X5667);
	set_name	(0X5667,	"$GSetMediaID");
	set_cmt	(0X566E,	"[si+curdir.devptr]\nlocal pointer to DPB or net device",	0);
	set_cmt	(0X5671,	"[si+DPB.FAT_SIZE]",	0);
	set_cmt	(0X5674,	"assume get for IOCTL\nmajor function = Generic IOCtl (08h)\nminor function = GetMediaId (66h)",	0);
	set_cmt	(0X5677,	"set ?",	0);
	set_cmt	(0X5679,	"get",	0);
	set_cmt	(0X567B,	"invalid",	0);
	set_cmt	(0X567D,	"minor function = SetMediaId (46h)",	0);
	create_insn	(x=0X567D);
	op_hex		(x,	1);
	set_cmt	(0X5681,	"FAT32 fs",	0);
	set_name	(0X5683,	"doioctl1");
	set_cmt	(0X5685,	"FAT fs (FAT12, FAT16)",	0);
	set_cmt	(0X5689,	"disk info\n.................................\n00h    WORD    0000h (info level)\n02h    DWORD   disk serial number (binary)\n06h 11 BYTEs   volume label or \"NO NAME    \" if none present\n11h  8 BYTEs   (AL=00h only) filesystem type\n    \"FAT12   \"\n    \"FAT16   \"\n    \"FAT32   \" ; PCDOS 7.1\n    \"CDROM   \"\n    \"CD001   \" \n    \"CDAUDIO \"\n.................................\n; (ref: Ralf Brown's Interrupt List)",	0);
	set_cmt	(0X568B,	"'FA'",	0);
	set_cmt	(0X5692,	"'T3'",	0);
	set_cmt	(0X5699,	"'2 '",	0);
	set_cmt	(0X56A0,	"'  '",	0);
	set_cmt	(0X56A7,	"new generic ioctl function (FAT32)\n(major function bit 6 is 1)",	0);
	create_insn	(x=0X56A7);
	op_hex		(x,	1);
	set_name	(0X56A7,	"doioctl2");
	set_name	(0X56A9,	"doioctl");
	set_cmt	(0X56AB,	"generic IOCTL",	0);
	set_cmt	(0X56AD,	"let IOCTL take care of it",	0);
	set_cmt	(0X56B1,	"error_invalid_function",	0);
	create_insn	(0X56B1);
	set_name	(0X56B1,	"errorfunc");
	create_insn	(0X56B6);
	set_name	(0X56B6,	"StrCmp");
	set_cmt	(0X56BA,	"convert to upper case",	0);
	set_cmt	(0X56BD,	"convert '/' to '\\'",	0);
	set_cmt	(0X56CE,	"Strings dif",	0);
	set_cmt	(0X56D2,	"More string",	0);
	create_insn	(0X56D8);
	set_name	(0X56D8,	"StrCpy");
	set_cmt	(0X56DA,	"convert to upper case",	0);
	set_cmt	(0X56DD,	"convert / to \\",	0);
	create_insn	(0X56E7);
	set_name	(0X56E7,	"FStrCpy");
	create_insn	(0X56F0);
	set_name	(0X56F0,	"StrLen");
	set_cmt	(0X56F2,	"-1 ; 0FFFFh",	0);
	create_insn	(x=0X56F2);
	op_dec		(x,	1);
	create_insn	(0X56FE);
	set_name	(0X56FE,	"DStrLen");
	create_insn	(0X5708);
	set_name	(0X5708,	"XCHGP");
	set_name	(0X570E,	"xchgp_retn");
	create_insn	(0X570F);
	set_name	(0X570F,	"Idle");
	create_insn	(0X5729);
	set_name	(0X5729,	"TableDispatch");
	create_insn	(x=0X572D);
	op_stkvar	(x,	1);
	create_insn	(x=0X5733);
	op_stkvar	(x,	0);
	create_insn	(x=0X5738);
	op_stkvar	(x,	1);
	create_insn	(x=0X573D);
	op_hex		(x,	1);
	create_insn	(x=0X5740);
	op_stkvar	(x,	1);
	create_insn	(x=0X5746);
	op_stkvar	(x,	0);
	create_insn	(x=0X574B);
	op_hex		(x,	1);
	create_insn	(0X574F);
	create_insn	(0X5754);
	set_name	(0X5754,	"TestNet");
	create_insn	(x=0X5759);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X575E,	"-1",	0);
	set_cmt	(0X5761,	"UNC? carry is clear",	0);
	set_cmt	(0X5763,	"[ES:DI+curdir.flags+1],\n(curdir_isnet>>8)",	0);
	create_insn	(x=0X5763);
	op_hex		(x,	1);
	set_cmt	(0X5768,	"jump has carry clear",	0);
	set_cmt	(0X576A,	"carry is clear",	0);
	create_insn	(0X576B);
	set_cmt	(0X576D,	"[ES:DI+SF_ENTRY.sf_flags+1],\n(sf_isnet>>8)",	0);
	create_insn	(x=0X576D);
	op_hex		(x,	1);
	set_name	(0X576D,	"IsSFTNet");
	create_insn	(0X5773);
	set_name	(0X5773,	"FastInit");
	set_cmt	(0X5779,	"points to fastxxx entry",	0);
	create_insn	(x=0X5779);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X577C,	"decrement index",	0);
	create_insn	(x=0X577F);
	op_hex		(x,	1);
	set_cmt	(0X5781,	"each entry is DWORD",	0);
	create_insn	(x=0X5781);
	op_hex		(x,	1);
	set_cmt	(0X5789,	"get DOS segment",	0);
	set_cmt	(0X578B,	"first time installed ?",	0);
	set_cmt	(0X578D,	"yes",	0);
	set_cmt	(0X5792,	"already installed !",	0);
	set_cmt	(0X5794,	"Query only ?",	0);
	set_name	(0X5794,	"ok_install");
	set_cmt	(0X5797,	"yes",	0);
	set_cmt	(0X5799,	"get FASTXXX entry segment",	0);
	set_cmt	(0X579B,	"initialize routine entry\ninitialize routine offset",	0);
	set_cmt	(0X57A2,	"FastFlg",	0);
	create_insn	(x=0X57A2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X57A5,	"index to a FASTXXX flag",	0);
	set_cmt	(0X57A7,	"Fast_yes\nindicate installed",	0);
	create_insn	(x=0X57A7);
	op_hex		(x,	1);
	set_name	(0X57AB,	"FSret");
	create_insn	(0X57AD);
	set_name	(0X57AD,	"FastRet");
	set_cmt	(0X57AE,	"AX = -1, CF = 1",	0);
	set_cmt	(0X57B1,	"set up correct interface for $OPEN",	0);
	create_insn	(0X57B1);
	set_name	(0X57B1,	"NLS_OPEN");
	set_cmt	(0X57B7,	"save user stack",	0);
	create_insn	(0X57B7);
	set_name	(0X57B7,	"NLS_LSEEK");
	set_cmt	(0X57C4,	"set up correct interface for $LSEEK",	0);
	set_cmt	(0X57C9,	"restore user stack",	0);
	set_name	(0X57C9,	"NLS_SEEK_RET");
	set_cmt	(0X57D4,	"replace with INT 2Fh stack",	0);
	create_insn	(0X57D4);
	set_name	(0X57D4,	"Fake_User_Stack");
	create_insn	(x=0X57E3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X57E3,	"GetDevList");
	set_cmt	(0X57ED,	"[SI+SYSI.DEV]",	0);
	set_cmt	(0X57F0,	"[SI+SYSI.DEV+2]",	0);
	create_insn	(0X57F4);
	set_name	(0X57F4,	"NLS_IOCTL");
	set_cmt	(0X5801,	"set up correct interface for $IOCTL",	0);
	set_cmt	(0X5808,	"return extended error",	0);
	create_insn	(0X5808);
	set_name	(0X5808,	"NLS_GETEXT");
	set_name	(0X580C,	"MSG_RETRIEVAL");
	create_insn	(0X580D);
	set_name	(0X580D,	"ECritDisk");
	set_name	(0X581C,	"ECritDisk_1");
	set_cmt	(0X5827,	"Microsoft Networks - BEGIN DOS CRITICAL SECTION\nAL = critical section number (00h-0Fh)",	0);
	create_insn	(x=0X5827);
	op_hex		(x,	0);
	create_insn	(0X582B);
	set_name	(0X582B,	"ECritDisk2");
	set_cmt	(0X5831,	"simulate INT 2Ah",	0);
	set_cmt	(0X5832,	"call far (INT 2Ah vector)",	0);
	create_insn	(x=0X5832);
	create_insn	(0X583B);
	set_name	(0X583B,	"ECritDisk_3");
	create_insn	(0X583D);
	set_name	(0X583D,	"LCritDisk");
	create_insn	(0X584E);
	set_name	(0X584E,	"ECritDevice");
	create_insn	(0X585F);
	set_name	(0X585F,	"LCritDevice");
	set_cmt	(0X5870,	"Input character from console, no echo",	0);
	create_insn	(0X5870);
	set_name	(0X5870,	"$STD_CON_INPUT_NO_ECHO");
	set_cmt	(0X5877,	"is printer idle?",	0);
	set_cmt	(0X587F,	"get input status with system wait",	0);
	set_cmt	(0X5886,	"Microsoft Networks - KEYBOARD BUSY LOOP",	0);
	create_insn	(x=0X5886);
	op_hex		(x,	0);
	set_cmt	(0X5888,	"date is updated may be every",	0);
	set_cmt	(0X588E,	"255 x ? ms if no one calls",	0);
	set_cmt	(0X5899,	"save DEVCALL packet",	0);
	set_cmt	(0X58A2,	"restore DEVCALL packet",	0);
	create_insn	(0X58B1);
	set_cmt	(0X58BE,	"extended code ?",	0);
	set_cmt	(0X58C2,	"set this flag for ALT_Q key",	0);
	set_name	(0X58C7,	"noscan");
	set_cmt	(0X58C8,	"Console String Output",	0);
	create_insn	(0X58C8);
	set_name	(0X58C8,	"$STD_CON_STRING_OUTPUT");
	set_name	(0X58CA,	"NEXT_STR1");
	set_cmt	(0X58D4,	"Input Line from Console",	0);
	create_insn	(0X58D4);
	set_name	(0X58D4,	"$STD_CON_STRING_INPUT");
	set_cmt	(0X58D8,	"0",	0);
	set_cmt	(0X58DD,	"Buffer is 0 length!!?",	0);
	set_cmt	(0X58DF,	"Init template counter",	0);
	set_cmt	(0X58E5,	"If length of buffer inconsistent\n with contents",	0);
	set_cmt	(0X58E7,	"c_CR",	0);
	set_cmt	(0X58EA,	"If CR correctly placed EDIT is OK",	0);
	set_cmt	(0X58EC,	"Reset buffer",	0);
	set_cmt	(0X58F0,	"DL is # of bytes we can put in the buffer",	0);
	set_cmt	(0X58F5,	"Remember position in raw buffer",	0);
	set_cmt	(0X58FA,	"Build the new line here",	0);
	create_insn	(x=0X58FA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X58FD,	"Insert mode off",	0);
	set_cmt	(0X5902,	"No chars from template yet",	0);
	set_cmt	(0X5904,	"No chars to new line yet",	0);
	set_cmt	(0X5906,	"Get first char",	0);
	set_cmt	(0X5909,	"Linefeed ; c_LF",	0);
	set_name	(0X590D,	"GETCH");
	set_cmt	(0X5910,	"Ignore ^F",	0);
	set_cmt	(0X5914,	"function-key lead byte ?",	0);
	set_cmt	(0X5919,	"change reserved keyword",	0);
	set_cmt	(0X591B,	"c_DEL ; destructive backspace",	0);
	set_cmt	(0X591F,	"c_BS ; destructive backspaces",	0);
	set_cmt	(0X5923,	"c_CR ; CR terminates the line.",	0);
	set_cmt	(0X5927,	"c_LF ; LF goes to a new line",	0);
	set_cmt	(0X5929,	"and keeps on reading.",	0);
	set_cmt	(0X592B,	"^X (or ESC) deletes the line",	0);
	set_cmt	(0X5930,	" and starts over",	0);
	set_cmt	(0X5934,	"buffer is full",	0);
	set_cmt	(0X5936,	"save the input character",	0);
	set_cmt	(0X5937,	"increment count in buffer",	0);
	set_cmt	(0X5939,	"Print control chars nicely",	0);
	set_cmt	(0X5942,	"insertmode => don't advance template",	0);
	set_cmt	(0X5946,	"no more characters in template",	0);
	set_cmt	(0X5948,	"Skip to next char in template",	0);
	set_cmt	(0X5949,	"remember position in template",	0);
	set_cmt	(0X594D,	"Bell to signal full buffer",	0);
	create_insn	(0X594D);
	set_cmt	(0X5954,	"let the OEM's handle the key dispatch",	0);
	create_insn	(0X5954);
	set_cmt	(0X5957,	"Put the CR in the buffer",	0);
	create_insn	(0X5957);
	set_cmt	(0X5958,	"Echo it",	0);
	set_cmt	(0X595B,	"Get start of user buffer",	0);
	set_cmt	(0X595C,	"Tell user how many bytes",	0);
	set_cmt	(0X595F,	"DH is length including CR",	0);
	set_cmt	(0X5961,	"XCHG ES,DS",	0);
	set_name	(0X5961,	"COPYNEW");
	create_insn	(x=0X5965);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X5968,	"set up count",	0);
	set_cmt	(0X596A,	"Copy final line to user buffer",	0);
	set_name	(0X596C,	"OLDBAK_RETN");
	set_cmt	(0X596D,	"Output a CRLF to the user screen \nand do NOT store it into the buffer",	0);
	create_insn	(0X596D);
	set_cmt	(0X5972,	"Delete the previous line",	0);
	create_insn	(0X5972);
	set_name	(0X5972,	"LineDel");
	create_insn	(0X597B);
	set_name	(0X597B,	"KILNEW");
	set_cmt	(0X597D,	"Print the CANCEL indicator",	0);
	set_cmt	(0X5980,	"Remember start of edit buffer",	0);
	set_cmt	(0X5981,	"Go to next line on screen",	0);
	set_cmt	(0X5988,	"Tab over",	0);
	set_cmt	(0X598B,	"Start over again",	0);
	set_cmt	(0X598E,	"Destructively back up one char position",	0);
	create_insn	(0X598E);
	set_name	(0X598E,	"BACKSP");
	create_insn	(0X5993);
	set_name	(0X5993,	"BackSpace");
	set_cmt	(0X5995,	"No chars in line,\n do nothing to line",	0);
	set_cmt	(0X5997,	"Do the backup",	0);
	set_cmt	(0X599A,	"Get the deleted char",	0);
	set_cmt	(0X599D,	"Was a normal char",	0);
	set_cmt	(0X59A3,	"Was a tab, fix up users display",	0);
	set_cmt	(0X59A5,	"\"U\"-\"@\" ; ctrl-U is a section symbol\n not ^U",	0);
	set_cmt	(0X59A9,	"\"T\"-\"@\" ; ctrl-T is a paragraphs symbol\n not ^T",	0);
	set_name	(0X59B0,	"OLDBAK");
	set_cmt	(0X59B6,	"In insert mode, done",	0);
	set_cmt	(0X59BA,	"\nNot advanced in template,\n stay where we are",	0);
	set_cmt	(0X59BC,	"Go back in template",	0);
	create_insn	(0X59C0);
	set_name	(0X59C0,	"BAKTAB");
	set_cmt	(0X59C1,	"Back up one char",	0);
	set_cmt	(0X59C2,	"Go backward",	0);
	set_cmt	(0X59C3,	"Number of chars currently in line",	0);
	set_cmt	(0X59C8,	"Max",	0);
	set_cmt	(0X59CA,	"At start, do nothing",	0);
	set_cmt	(0X59CC,	"Look back",	0);
	set_name	(0X59CC,	"FNDPOS");
	set_cmt	(0X59D4,	"Found a tab",	0);
	set_cmt	(0X59D6,	"Back one char if non tab control char",	0);
	set_name	(0X59D8,	"CHKCNT");
	set_name	(0X59DA,	"FIGTAB");
	set_name	(0X59DF,	"HAVTAB");
	set_cmt	(0X59E3,	"CX has correct number to erase",	0);
	create_insn	(x=0X59E3);
	op_hex		(x,	1);
	set_cmt	(0X59E6,	"Back to normal",	0);
	set_cmt	(0X59E9,	"Nothing to erase",	0);
	set_name	(0X59EB,	"TABBAK");
	set_cmt	(0X59EE,	"Erase correct number of chars",	0);
	set_cmt	(0X59F2,	"Back up in line",	0);
	create_insn	(0X59F2);
	set_name	(0X59F2,	"BACKUP");
	set_cmt	(0X59F5,	"c_BS ; Backspace",	0);
	create_insn	(0X59F5);
	set_name	(0X59F5,	"BACKMES");
	set_cmt	(0X59FA,	"SPACE char ; Erase",	0);
	set_cmt	(0X59FF,	"Backspace",	0);
	set_cmt	(0X5A01,	"Done",	0);
	set_cmt	(0X5A04,	"User really wants an ESC character\n in his line",	0);
	create_insn	(0X5A04);
	set_name	(0X5A04,	"TWOESC");
	set_cmt	(0X5A0B,	"Total size of template",	0);
	create_insn	(0X5A0B);
	set_name	(0X5A0B,	"COPYLIN");
	set_cmt	(0X5A0D,	"Minus position in template,\n is number to move",	0);
	set_cmt	(0X5A11,	"Find the char",	0);
	create_insn	(0X5A11);
	set_name	(0X5A11,	"COPYSTR");
	set_cmt	(0X5A14,	"Copy up to it",	0);
	create_insn	(0X5A16);
	set_name	(0X5A16,	"COPYONE");
	set_cmt	(0X5A18,	"All copies turn off insert mode",	0);
	set_cmt	(0X5A20,	"At end of line, can't do anything",	0);
	set_cmt	(0X5A24,	"At end of template, can't do anything",	0);
	set_cmt	(0X5A2B,	"Ahead in template",	0);
	set_cmt	(0X5A2D,	"Ahead in line",	0);
	set_name	(0X5A31,	"GETCH2");
	create_insn	(0X5A34);
	set_name	(0X5A34,	"SKIPONE");
	set_cmt	(0X5A36,	"At end of template",	0);
	set_cmt	(0X5A38,	"Ahead in template",	0);
	set_cmt	(0X5A3D,	"Find out how far to go",	0);
	create_insn	(0X5A3D);
	set_name	(0X5A3D,	"SKIPSTR");
	set_cmt	(0X5A40,	"Go there",	0);
	create_insn	(0X5A46);
	set_name	(0X5A46,	"FINDOLD");
	set_cmt	(0X5A49,	"did he type a function key?",	0);
	set_cmt	(0X5A4E,	"no, set up for scan",	0);
	set_cmt	(0X5A50,	"eat next char",	0);
	set_cmt	(0X5A53,	"go try again",	0);
	create_insn	(0X5A55);
	set_cmt	(0X5A57,	"CX is number of chars to end of template",	0);
	set_cmt	(0X5A59,	"At end of template",	0);
	set_cmt	(0X5A5B,	"Cannot point past end, limit search",	0);
	set_cmt	(0X5A5C,	"If only one char in template, forget it",	0);
	set_cmt	(0X5A62,	"Template to ES:DI",	0);
	set_cmt	(0X5A65,	"Look",	0);
	set_cmt	(0X5A69,	"Didn't find the char",	0);
	set_cmt	(0X5A6B,	"Turn how far to go into how far we went",	0);
	set_cmt	(0X5A6D,	"Add size of template",	0);
	set_cmt	(0X5A6F,	"Subtract current pos,\n result distance to skip",	0);
	set_name	(0X5A71,	"FINDOLD_RETN");
	set_cmt	(0X5A72,	"Chuck return address",	0);
	create_insn	(0X5A72);
	set_cmt	(0X5A75,	"Output re-edit character",	0);
	create_insn	(0X5A75);
	set_name	(0X5A75,	"REEDIT");
	set_cmt	(0X5A7E,	"Copy current line into template",	0);
	set_cmt	(0X5A84,	"Size of line is new size template",	0);
	set_cmt	(0X5A86,	"Start over again",	0);
	set_cmt	(0X5A89,	"ENTERINS",	0);
	create_insn	(0X5A89);
	set_name	(0X5A89,	"EXITINS");
	set_cmt	(0X5A90,	"\"Z\"-\"@\"",	0);
	create_insn	(0X5A90);
	set_name	(0X5A90,	"CTRLZ");
	set_cmt	(0X5A95,	"c_CR",	0);
	create_insn	(0X5A95);
	set_name	(0X5A95,	"CRLF");
	set_cmt	(0X5A9A,	"c_LF",	0);
	set_cmt	(0X5A9F,	"Input/Output raw char from console, no echo",	0);
	create_insn	(0X5A9F);
	set_name	(0X5A9F,	"$RAW_CON_IO");
	set_cmt	(0X5AA1,	"-1 if input",	0);
	set_cmt	(0X5AA5,	"Get pointer to register save area",	0);
	set_cmt	(0X5ABB,	"[ES:DI+user_env.user_F],40h\nSet user's zero flag",	0);
	create_insn	(x=0X5ABB);
	op_hex		(x,	1);
	set_name	(0X5AC2,	"RET17");
	set_cmt	(0X5AC3,	"[ES:DI+user_env.user_F],0FFh-40h\nReset user's zero flag",	0);
	create_insn	(x=0X5AC3);
	op_hex		(x,	1);
	set_name	(0X5AC3,	"RESFLG");
	set_name	(0X5AC8,	"rci0");
	set_name	(0X5ACB,	"$RAW_CON_INPUT");
	set_cmt	(0X5ADD,	"Microsoft Networks - KEYBOARD BUSY LOOP",	0);
	create_insn	(x=0X5ADD);
	op_hex		(x,	0);
	create_insn	(0X5AE1);
	set_name	(0X5AE1,	"rci5");
	create_insn	(0X5AE7);
	set_name	(0X5AE7,	"RAWOUT");
	set_cmt	(0X5AF0,	"[SI+SF_ENTRY.sf_flags]\nDS set up by get_io_sft",	0);
	set_cmt	(0X5AF3,	"sf_isnet+devid_device",	0);
	create_insn	(x=0X5AF3);
	op_hex		(x,	1);
	set_cmt	(0X5AF7,	"devid_device",	0);
	set_cmt	(0X5AFE,	"[SI+SF_ENTRY.sf_devptr]\noutput to special?",	0);
	set_cmt	(0X5B01,	"ISSPEC",	0);
	create_insn	(x=0X5B01);
	op_hex		(x,	1);
	set_cmt	(0X5B06,	"if not, do normally",	0);
	set_cmt	(0X5B0D,	"simulate INT 29h",	0);
	set_cmt	(0X5B0E,	"call far [29h*4] ; call far [00A4h]",	0);
	create_insn	(x=0X5B0E);
	set_name	(0X5B15,	"RAWRET2");
	create_insn	(0X5B16);
	set_cmt	(0X5B1B,	"Output the character in AL to handle in BX",	0);
	create_insn	(0X5B1B);
	set_name	(0X5B1B,	"RAWOUT2");
	create_insn	(0X5B20);
	set_name	(0X5B20,	"RAWOUT3");
	create_insn	(0X5B23);
	set_cmt	(0X5B26,	"[ss:DOS34_FLAG],CTRL_BREAK_FLAG",	0);
	create_insn	(x=0X5B26);
	op_hex		(x,	1);
	set_cmt	(0X5B2D,	"check control break",	0);
	set_cmt	(0X5B37,	"fail on I24 if ax = -1",	0);
	set_cmt	(0X5B39,	"yes, do not send char",	0);
	set_cmt	(0X5B40,	"Clear carry indicating successful",	0);
	create_insn	(0X5B42);
	set_name	(0X5B42,	"Save_Restore_Packet");
	create_insn	(x=0X5B46);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X5B49,	"DEVCALL",	0);
	create_insn	(x=0X5B49);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X5B56);
	op_dec		(x,	1);
	create_insn	(0X5B60);
	set_name	(0X5B60,	"$STD_CON_INPUT");
	set_name	(0X5B68,	"CON_INPUT_RETN");
	create_insn	(0X5B69);
	create_insn	(0X5B70);
	set_name	(0X5B70,	"$STD_CON_OUTPUT");
	create_insn	(0X5B72);
	set_name	(0X5B72,	"OUTT");
	set_cmt	(0X5B81,	"invoke statchk...",	0);
	set_cmt	(0X5B86,	"every 64th character",	0);
	create_insn	(x=0X5B86);
	op_hex		(x,	1);
	set_cmt	(0X5B8E,	"output the character",	0);
	set_cmt	(0X5B93,	"-1",	0);
	create_insn	(x=0X5B93);
	op_hex		(x,	1);
	set_cmt	(0X5BA6,	"[SI+SF_ENTRY.sf_flags]",	0);
	set_cmt	(0X5BA9,	"(sf_isnet>>8)",	0);
	create_insn	(x=0X5BA9);
	op_hex		(x,	1);
	set_cmt	(0X5BAE,	"devid_device",	0);
	create_insn	(x=0X5BAE);
	op_hex		(x,	1);
	set_cmt	(0X5BB6,	"GET_IO_SFT will set up DS:SI to sft entry",	0);
	set_cmt	(0X5BBB,	"[SI+SF_ENTRY.sf_flags+1],\n(sf_net_spool>>8) ; StdPrn redirected?",	0);
	create_insn	(x=0X5BBB);
	op_hex		(x,	1);
	set_cmt	(0X5BC1,	"If a spool, NEVER echo",	0);
	create_insn	(0X5BCA);
	set_cmt	(0X5BCD,	"c_CR",	0);
	create_insn	(0X5BCD);
	set_cmt	(0X5BD1,	"c_BS",	0);
	set_cmt	(0X5BD5,	"c_HT",	0);
	create_insn	(x=0X5BDD);
	op_hex		(x,	1);
	create_insn	(0X5BE1);
	set_name	(0X5BE1,	"TAB");
	create_insn	(0X5BF1);
	create_insn	(0X5BF9);
	set_name	(0X5BF9,	"j_OUTT");
	create_insn	(0X5BFC);
	create_insn	(0X5C04);
	set_name	(0X5C04,	"BUFOUT");
	set_cmt	(0X5C06,	"Normal char",	0);
	set_cmt	(0X5C0A,	"OUT knows how to expand tabs",	0);
	set_cmt	(0X5C0C,	"\"U\"-\"@\" ; turn ^U to section symbol",	0);
	set_cmt	(0X5C10,	"\"T\"-\"@\" ; turn ^T to paragraph symbol",	0);
	set_cmt	(0X5C17,	"Print '^' before control chars",	0);
	set_cmt	(0X5C1B,	"Turn it into Upper case mate",	0);
	create_insn	(x=0X5C1B);
	op_hex		(x,	1);
	set_name	(0X5C20,	"BUFOUT_RETN");
	create_insn	(0X5C21);
	set_name	(0X5C21,	"$STD_AUX_INPUT");
	create_insn	(0X5C2E);
	set_name	(0X5C2E,	"AUXILP");
	set_name	(0X5C31,	"TAISTRT");
	create_insn	(0X5C3E);
	set_name	(0X5C3E,	"$STD_AUX_OUTPUT");
	create_insn	(0X5C44);
	set_name	(0X5C44,	"$STD_PRINTER_OUTPUT");
	set_name	(0X5C48,	"SENDOUT");
	set_name	(0X5C57,	"SCIS_RETN");
	create_insn	(0X5C58);
	set_name	(0X5C58,	"$STD_CON_INPUT_STATUS");
	set_cmt	(0X5C5B,	"no xor!!",	0);
	set_cmt	(0X5C5F,	"-1",	0);
	create_insn	(0X5C61);
	set_name	(0X5C61,	"$STD_CON_INPUT_FLUSH");
	set_name	(0X5C6F,	"BADJFNCON");
	create_insn	(0X5C8A);
	set_name	(0X5C8A,	"REDISPJ");
	set_cmt	(0X5C8E,	"point to FCB",	0);
	create_insn	(0X5C8E);
	set_name	(0X5C8E,	"$GET_FCB_POSITION");
	set_cmt	(0X5C91,	"DX:AX is current record",	0);
	set_cmt	(0X5C94,	"[SI+SYS_FCB.RR] ; drop in low order piece",	0);
	set_cmt	(0X5C97,	"[SI+SYS_FCB.RR+2] ; drop in high order piece",	0);
	set_cmt	(0X5C9A,	"[SI+SYS_FCB.RECSIZ]",	0);
	create_insn	(x=0X5C9A);
	op_dec		(x,	1);
	set_cmt	(0X5CA0,	"[SI+SYS_FCB.RR+2+1]\nSet 4th byte only if record size < 64",	0);
	set_cmt	(0X5CA3,	"jmp FCB_RET_OK",	0);
	set_name	(0X5CA3,	"GetFCBBye");
	create_insn	(x=0X5CA6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X5CA6,	"$FCB_DELETE");
	set_cmt	(0X5CA9,	"convert FCB to path",	0);
	set_cmt	(0X5CAC,	"signal no deletions",	0);
	set_cmt	(0X5CB3,	"do a good return",	0);
	set_cmt	(0X5CB5,	"let someone else signal the error",	0);
	set_name	(0X5CB5,	"BadPath");
	set_cmt	(0X5CB8,	"get real FCB pointer\nDX points to Input FCB",	0);
	create_insn	(0X5CB8);
	set_name	(0X5CB8,	"$GET_FCB_FILE_LENGTH");
	set_cmt	(0X5CBB,	"appropriate buffer in DOSDATA",	0);
	create_insn	(x=0X5CBB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X5CBE,	"save pointer to true FCB",	0);
	set_cmt	(0X5CC0,	"Trans name DS:DX, sets SATTRIB",	0);
	set_cmt	(0X5CC7,	"save pointer",	0);
	set_cmt	(0X5CCB,	"grab the info",	0);
	set_cmt	(0X5CCE,	"get pointer back",	0);
	set_cmt	(0X5CD0,	"invalid something",	0);
	set_cmt	(0X5CD2,	"get high order size",	0);
	set_cmt	(0X5CD4,	"get low order size",	0);
	set_cmt	(0X5CD6,	"[SI+SYS_FCB.RECSIZ]\nget his record size",	0);
	set_cmt	(0X5CD9,	"empty record => 0 size for file",	0);
	set_cmt	(0X5CDB,	"not empty",	0);
	create_insn	(x=0X5CDD);
	op_dec		(x,	1);
	set_cmt	(0X5CDF,	"move high order for divide",	0);
	set_name	(0X5CDF,	"GetSize");
	set_cmt	(0X5CE0,	"clear out high",	0);
	set_cmt	(0X5CE4,	"save dividend",	0);
	set_cmt	(0X5CE5,	"get low order piece",	0);
	set_cmt	(0X5CE9,	"save remainder",	0);
	set_cmt	(0X5CEB,	"get high order dividend",	0);
	set_cmt	(0X5CF1,	"32-bit increment",	0);
	set_cmt	(0X5CF4,	"[SI+SYS_FCB.RR] ; store low order",	0);
	set_name	(0X5CF4,	"LengthStore");
	set_cmt	(0X5CF7,	"[SI+SYS_FCB.RR+2] ; store high order",	0);
	set_cmt	(0X5CFC,	"not storing insignificant zero",	0);
	set_cmt	(0X5CFE,	"[SI+SYS_FCB.RR+3] ; save that high piece",	0);
	set_name	(0X5D01,	"GoodRet");
	set_cmt	(0X5D03,	"default search attributes",	0);
	create_insn	(0X5D03);
	set_name	(0X5D03,	"$FCB_CLOSE");
	set_cmt	(0X5D05,	"DS:SI point to real FCB",	0);
	set_cmt	(0X5D08,	"not extended",	0);
	set_cmt	(0X5D0A,	"get attributes",	0);
	set_cmt	(0X5D0D,	"stash away found attributes",	0);
	set_name	(0X5D0D,	"NoAttr");
	set_cmt	(0X5D16,	"[ES:DI+SF_ENTRY.sf_attr]",	0);
	set_cmt	(0X5D26,	"[ES:DI+SF_ENTRY.sf_attr]\nattempted attribute for close",	0);
	set_name	(0X5D2A,	"NoStash");
	set_cmt	(0X5D2B,	"[SI+SYS_FCB.FDATE]\nmove in the time and date",	0);
	set_cmt	(0X5D2E,	"[ES:DI+SF_ENTRY.sf_date]",	0);
	set_cmt	(0X5D32,	"[ES:DI+SF_ENTRY.sf_time]",	0);
	set_cmt	(0X5D37,	"[SI+SYS_FCB.FILSIZ]",	0);
	set_cmt	(0X5D3A,	"[ES:DI+SF_ENTRY.sf_size]",	0);
	set_cmt	(0X5D3E,	"[ES:DI+SF_ENTRY.sf_size+2]",	0);
	set_cmt	(0X5D42,	"[ES:DI+SF_ENTRY.sf_flags],\nsf_close_nodate",	0);
	create_insn	(x=0X5D42);
	op_hex		(x,	1);
	set_cmt	(0X5D52,	"[ES:DI+SF_ENTRY.sf_attr]\nrestore SFT attribute",	0);
	set_cmt	(0X5D57,	"[ES:DI+SF_ENTRY.sf_ref_count],0\nzero ref count gets blasted",	0);
	set_name	(0X5D64,	"CloseOK");
	set_name	(0X5D65,	"CloseOK2");
	set_cmt	(0X5D67,	"error_invalid_handle",	0);
	set_cmt	(0X5D6B,	"error_file_not_found",	0);
	set_cmt	(0X5D6D,	"fren90",	0);
	set_name	(0X5D6D,	"fcb_close_err");
	set_cmt	(0X5D70,	"get pointer to real FCB",	0);
	create_insn	(0X5D70);
	set_name	(0X5D70,	"$FCB_RENAME");
	set_cmt	(0X5D74,	"get drive byte",	0);
	set_cmt	(0X5D76,	"point to destination",	0);
	create_insn	(x=0X5D79);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X5D7F,	"save source pointer for TransFCB",	0);
	set_cmt	(0X5D80,	"drop in real drive",	0);
	set_cmt	(0X5D82,	"let TransFCB know where the FCB is",	0);
	set_cmt	(0X5D84,	"munch this pathname",	0);
	set_cmt	(0X5D89,	"get path back",	0);
	create_insn	(x=0X5D98);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X5DA0,	"set pathname length to 67\nDIRSTRLEN = 67",	0);
	create_insn	(x=0X5DA0);
	op_dec		(x,	1);
	set_cmt	(0X5DAA,	"fren90",	0);
	create_insn	(0X5DAE);
	set_name	(0X5DAE,	"SaveFCBInfo");
	set_cmt	(0X5DB8,	"[ES:DI+sf_serial_ID]",	0);
	set_cmt	(0X5DBC,	"[SI+fcb_netID]",	0);
	set_cmt	(0X5DBF,	"FCBNETWORK",	0);
	create_insn	(0X5DC3);
	set_cmt	(0X5DC6,	"sharer present",	0);
	set_cmt	(0X5DC8,	"no sharer\n\n[ES:DI+SF_ENTRY.sf_flags],devid_device",	0);
	create_insn	(x=0X5DC8);
	op_hex		(x,	1);
	set_name	(0X5DC8,	"SaveNoShare");
	set_cmt	(0X5DCD,	"Device",	0);
	set_cmt	(0X5DCF,	"[ES:DI+SF_ENTRY.sf_dirsec]",	0);
	set_cmt	(0X5DD3,	"[SI+fcb_nsl_dirsec]",	0);
	set_cmt	(0X5DD6,	"[es:di+SF_ENTRY.sf_dirsec+2]",	0);
	set_cmt	(0X5DDA,	"[es:di+SF_ENTRY.sf_attr]",	0);
	create_insn	(x=0X5DE0);
	op_hex		(x,	1);
	create_insn	(x=0X5DE6);
	op_hex		(x,	1);
	set_cmt	(0X5DEB,	"[si+fcb_sfn] ; sector number = 22 bits",	0);
	set_cmt	(0X5DEE,	"[ES:DI+SF_ENTRY.sf_dirpos]\nlocation in sector",	0);
	set_cmt	(0X5DF2,	"[SI+fcb_nsl_dirpos]",	0);
	set_cmt	(0X5DF5,	"[es:di+SF_ENTRY.sf_chain] ; .sf_chain ! (MSDOS 6.22)\nfirst cluster (32 bit) !?",	0);
	set_cmt	(0X5DF9,	"[SI+fcb_nsl_firclus]",	0);
	set_cmt	(0X5DFE,	"[ES:DI+SF_ENTRY.sf_flags]",	0);
	set_cmt	(0X5E02,	"mask off drive bits",	0);
	create_insn	(x=0X5E02);
	op_hex		(x,	1);
	set_cmt	(0X5E04,	"[ES:DI+SF_ENTRY.sf_mode]\nstick in open mode",	0);
	set_cmt	(0X5E08,	"[SI+fcb_nsl_bits] ; save dirty info",	0);
	set_cmt	(0X5E0D,	"do not save SFN if local file",	0);
	set_cmt	(0X5E0F,	"go and save SFN",	0);
	create_insn	(0X5E11);
	set_cmt	(0X5E12,	"[es:di+SF_ENTRY.sf_devptr]",	0);
	set_cmt	(0X5E16,	"[SI+fcb_nsld_drvptr]",	0);
	set_cmt	(0X5E19,	"[si+fcb_nsld_drvptr+2]",	0);
	set_cmt	(0X5E1C,	"FCBDEVICE",	0);
	create_insn	(x=0X5E1D);
	op_hex		(x,	1);
	set_cmt	(0X5E1F,	"go and save SFN",	0);
	set_cmt	(0X5E21,	"call far [ss:JShare+(10*4)] ; 10 = ShSave",	0);
	create_insn	(0X5E21);
	set_cmt	(0X5E26,	"[DI-SFT.SFTable]",	0);
	set_cmt	(0X5E29,	"Adjust for offset to table.",	0);
	set_cmt	(0X5E2F,	"SF_ENTRY.size",	0);
	create_insn	(x=0X5E2F);
	op_dec		(x,	1);
	set_cmt	(0X5E33,	"[SI+fcb_sfn] ; last used SFN",	0);
	set_cmt	(0X5E36,	"bx = FCB type (net/Share or local)",	0);
	set_cmt	(0X5E37,	"[ES:DI+SF_ENTRY.sf_flags] ; get real drive",	0);
	create_insn	(x=0X5E3B);
	op_hex		(x,	1);
	set_cmt	(0X5E3F,	"[SI+fcb_l_drive]",	0);
	set_cmt	(0X5E42,	"get lru count",	0);
	set_cmt	(0X5E47,	"[ES:DI+sf_LRU]",	0);
	set_cmt	(0X5E4B,	"\nlru flag overflowed",	0);
	set_cmt	(0X5E4D,	"SF_ENTRY.sf_position",	0);
	set_cmt	(0X5E53,	"Set new LRU to AX",	0);
	create_insn	(0X5E58);
	set_name	(0X5E58,	"ResetLRU");
	set_cmt	(0X5E5D,	"get pointer to head",	0);
	set_cmt	(0X5E62,	"[ES:DI+SFT.SFCount]",	0);
	set_cmt	(0X5E66,	"[DI+SFT.SFTable] ; point at table",	0);
	set_cmt	(0X5E69,	"decrement lru count",	0);
	set_cmt	(0X5E6E,	"truncate at 0",	0);
	set_cmt	(0X5E71,	"SF_ENTRY.size",	0);
	create_insn	(x=0X5E71);
	op_dec		(x,	1);
	set_cmt	(0X5E74,	"advance to next",	0);
	create_insn	(0X5E7C);
	set_name	(0X5E7C,	"LRUFCB");
	set_cmt	(0X5E85,	"Check if regenerate allocation",	0);
	set_cmt	(0X5E87,	"Try to find SFT to use",	0);
	create_insn	(x=0X5E89);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X5E8F,	"is address == 0?",	0);
	set_cmt	(0X5E91,	"invalid local SFT, find one",	0);
	create_insn	(x=0X5E93);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X5E97);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X5E9C,	"clear up SFT and return",	0);
	set_cmt	(0X5E9F,	"es:di = SF Table for FCBs",	0);
	create_insn	(x=0X5E9F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X5EA3,	"cx = number of SFTs",	0);
	set_cmt	(0X5EA7,	"[di+SFT.SFTable] ; es:di = first SFT",	0);
	set_cmt	(0X5EAA,	"(max. LRU value)",	0);
	set_cmt	(0X5EB3,	"[es:di+SF_ENTRY.sf_ref_count]\nreference count = 0 ?",	0);
	create_insn	(x=0X5EB3);
	op_hex		(x,	1);
	set_cmt	(0X5EB7,	"yes, SFT is free",	0);
	set_cmt	(0X5EB9,	"[es:di+SF_ENTRY.sf_ref_count],\nsf_busy",	0);
	set_cmt	(0X5EBD,	"not busy, can use it",	0);
	set_cmt	(0X5EBF,	"[ES:DI+SF_ENTRY.sf_flags],\nsf_isnet",	0);
	create_insn	(x=0X5EBF);
	op_hex		(x,	1);
	set_cmt	(0X5EC5,	"network SFT, get net/Share LRU",	0);
	create_insn	(x=0X5ECC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X5ED0,	"store local SFT address",	0);
	create_insn	(x=0X5ED0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X5ED4,	"Is operation = REGEN?",	0);
	set_cmt	(0X5ED6,	"yes, return this SFT for reuse",	0);
	set_cmt	(0X5ED8,	"[es:di+sf_LRU],bx ; SFT.LRU < min?",	0);
	set_cmt	(0X5EDC,	"no, skip",	0);
	set_cmt	(0X5EDE,	"[es:di+sf_LRU] ; yes, store new min",	0);
	set_cmt	(0X5EE2,	"store SFT position",	0);
	set_cmt	(0X5EE4,	"SF_ENTRY.size ; go to next SFT",	0);
	create_insn	(x=0X5EE4);
	op_dec		(x,	1);
	set_cmt	(0X5EEC,	"local SFT available?",	0);
	set_cmt	(0X5EEE,	"yes, return it",	0);
	set_cmt	(0X5EF2,	"net/Share SFT available?",	0);
	set_cmt	(0X5EF4,	"yes, return it",	0);
	set_cmt	(0X5EF6,	"error, no FCB available.",	0);
	set_cmt	(0X5EF8,	"[es:di+sf_LRU],dx ; SFT.LRU < min?",	0);
	create_insn	(0X5EF8);
	set_cmt	(0X5EFC,	"no, skip",	0);
	set_cmt	(0X5EFE,	"[es:di+sf_LRU]\nyes, store new minimum",	0);
	create_insn	(0X5F06);
	set_cmt	(0X5F08,	"save es:di in LocalSFT",	0);
	set_cmt	(0X5F0C,	"Offset same?",	0);
	create_insn	(x=0X5F0C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X5F12,	"Segments same?",	0);
	create_insn	(x=0X5F12);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X5F16,	"no, no need to invalidate",	0);
	create_insn	(x=0X5F1A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X5F1D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X5F23);
	set_cmt	(0X5F27,	"store local SFT address",	0);
	create_insn	(x=0X5F27);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X5F2B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X5F2F,	"set thissft",	0);
	create_insn	(x=0X5F2F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X5F33);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X5F37,	"[es:di+SF_ENTRY.sf_ref_count]\nis ref count still <> 0?",	0);
	set_cmt	(0X5F3B,	"nope, all done",	0);
	set_cmt	(0X5F40,	"no error => clean up",	0);
	set_cmt	(0X5F42,	"error_invalid_handle",	0);
	create_insn	(0X5F49);
	set_cmt	(0X5F4B,	"fill SFT with 0 (AL), 'C' cleared",	0);
	set_cmt	(0X5F57,	"es:di points at allocated SFT",	0);
	create_insn	(x=0X5F57);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X5F5F,	"error_FCB_unavailable",	0);
	create_insn	(x=0X5F5F);
	op_hex		(x,	1);
	set_cmt	(0X5F62,	"load character",	0);
	create_insn	(0X5F62);
	set_name	(0X5F62,	"RegenCopyName");
	set_cmt	(0X5F63,	"convert char to upper case",	0);
	set_cmt	(0X5F66,	"store converted character",	0);
	set_cmt	(0X5F6A,	"[SI+fcb_l_drive]",	0);
	create_insn	(0X5F6A);
	set_name	(0X5F6A,	"FCBRegen");
	set_cmt	(0X5F6D,	"FCBSPECIAL",	0);
	create_insn	(x=0X5F6D);
	op_hex		(x,	1);
	set_cmt	(0X5F71,	"test for sharer",	0);
	set_cmt	(0X5F74,	"yep, fail this.",	0);
	set_cmt	(0X5F79,	"Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK\nReturn: AL = 00h  not installed, OK to install\n01h  not installed, not OK to install\nFFh  installed",	0);
	create_insn	(x=0X5F79);
	op_hex		(x,	0);
	set_cmt	(0X5F7B,	"is it there?",	0);
	set_cmt	(0X5F7D,	"no, just fail the operation",	0);
	set_cmt	(0X5F83,	"FCB_CLOSE",	0);
	set_cmt	(0X5F88,	"massive hard error",	0);
	set_cmt	(0X5F8B,	"carry set",	0);
	create_insn	(0X5F8D);
	set_cmt	(0X5F93,	"indicate it is a regen operation",	0);
	set_cmt	(0X5F9B,	"[ES:DI+SF_ENTRY.sf_mode],\nsf_isFCB+open_for_both+SHARING_COMPAT",	0);
	set_cmt	(0X5FA1,	"get drive number for flags",	0);
	create_insn	(x=0X5FA1);
	op_hex		(x,	1);
	set_cmt	(0X5FA4,	"sf_close_nodate ; normal FCB operation",	0);
	create_insn	(x=0X5FA4);
	op_hex		(x,	1);
	set_cmt	(0X5FA7,	"[SI+fcb_nsl_bits] ; stick in dirty bits.",	0);
	set_cmt	(0X5FAC,	"mask off the dirty/device bits",	0);
	create_insn	(x=0X5FAC);
	op_hex		(x,	1);
	set_cmt	(0X5FB1,	"access_mask  ; get the mode bits",	0);
	create_insn	(x=0X5FB1);
	op_hex		(x,	1);
	set_cmt	(0X5FB4,	"[ES:DI+SF_ENTRY.sf_mode]",	0);
	set_cmt	(0X5FB8,	"[ES:DI+SF_ENTRY.sf_flags],AX ; initial flags",	0);
	set_cmt	(0X5FC0,	"[ES:DI+SF_ENTRY.sf_PID]",	0);
	create_insn	(x=0X5FCA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X5FD0,	"Skip past drive byte to name in FCB",	0);
	set_cmt	(0X5FD1,	"copy the name to NAME1",	0);
	set_cmt	(0X5FD6,	"attr_hidden+attr_system+attr_directory",	0);
	set_cmt	(0X5FE2,	"not found on device list => file",	0);
	set_cmt	(0X5FE4,	"[ES:DI+SF_ENTRY.sf_flags] ; device parms",	0);
	set_cmt	(0X5FE8,	"[ES:DI+SF_ENTRY.sf_attr] ; attribute",	0);
	set_cmt	(0X5FED,	"get device driver",	0);
	set_cmt	(0X5FF2,	"[ES:DI+SF_ENTRY.sf_devptr]",	0);
	create_insn	(0X5FF2);
	set_name	(0X5FF2,	"regen_save_dpb");
	set_cmt	(0X5FF6,	"[ES:DI+SF_ENTRY.sf_devptr+2]",	0);
	create_insn	(0X5FFB);
	set_cmt	(0X5FFD,	"[ES:DI+SF_ENTRY.sf_flags]",	0);
	create_insn	(0X5FFD);
	create_insn	(x=0X6001);
	op_hex		(x,	1);
	set_cmt	(0X6010,	"[SI+fcb_nsl_dirsec]",	0);
	set_cmt	(0X6013,	"[ES:DI+SF_ENTRY.sf_dirsec]",	0);
	set_cmt	(0X6017,	"[si+fcb_sfn]",	0);
	set_cmt	(0X601A,	"get the 2 attribute bits",	0);
	create_insn	(x=0X601A);
	op_hex		(x,	1);
	create_insn	(x=0X601E);
	op_hex		(x,	1);
	create_insn	(x=0X6020);
	op_hex		(x,	1);
	set_cmt	(0X6024,	"mask off unused bits",	0);
	create_insn	(x=0X6024);
	op_hex		(x,	1);
	set_cmt	(0X6026,	"[es:di+SF_ENTRY.sf_attr]",	0);
	set_cmt	(0X602A,	"[si+fcb_sfn]",	0);
	set_cmt	(0X602D,	"mask off top 2 bits -- attr bits",	0);
	create_insn	(x=0X602D);
	op_hex		(x,	1);
	set_cmt	(0X6031,	"[es:di+SF_ENTRY.sf_dirsec+2]\nupdate high word",	0);
	set_cmt	(0X6035,	"[SI+fcb_nsl_firclus]",	0);
	set_cmt	(0X6038,	"[es:di+SF_ENTRY.sf_chain] ; .sf_chain ! (MSDOS 6.22)\nfirst cluster (32 bit) !?",	0);
	set_cmt	(0X603C,	"[ES:DI+SF_ENTRY.sf_lstclus]",	0);
	set_cmt	(0X6040,	"0",	0);
	set_cmt	(0X6042,	"[es:di+SF_ENTRY.sf_chain+2] ; .sf_chain ! (MSDOS 6.22)\nhigh word of first cluster (32 bit) !?",	0);
	set_cmt	(0X6046,	"[ES:DI+SF_ENTRY.sf_lstclus+2]",	0);
	set_cmt	(0X604A,	"[SI+fcb_nsl_dirpos]",	0);
	set_cmt	(0X604D,	"[ES:DI+SF_ENTRY.sf_dirpos]",	0);
	set_cmt	(0X6051,	"Increment reference count",	0);
	set_cmt	(0X6054,	"put SFT entry number in the SFTFCB table\nas FCB index number",	0);
	set_cmt	(0X6057,	"[SI+SYS_FCB.name]",	0);
	set_cmt	(0X605A,	"[DI+SF_ENTRY.sf_name]",	0);
	set_cmt	(0X605D,	"SYS_FCB.EXTENT-SYS_FCB.name ; 12-1",	0);
	create_insn	(x=0X605D);
	op_dec		(x,	1);
	create_insn	(0X6065);
	set_name	(0X6065,	"BlastSFT");
	set_cmt	(0X6069,	"SF_ENTRY.size",	0);
	create_insn	(x=0X6069);
	op_dec		(x,	1);
	set_cmt	(0X606F,	"0",	0);
	set_cmt	(0X6071,	"word [ES:DI+SF_ENTRY.sf_ref_count],0",	0);
	set_cmt	(0X6074,	"%define sf_LRU SF_ENTRY.sf_position\nword [es:di+sf_LRU],0",	0);
	set_cmt	(0X6078,	"-1",	0);
	set_cmt	(0X6079,	"%define sf_OpenAge SF_ENTRY.sf_position+2\nword [es:di+sf_OpenAge],-1",	0);
	set_cmt	(0X607E,	"[si+fcb_l_drive],\nFCBNETWORK|FCBSHARE|FCBDEVICE",	0);
	create_insn	(x=0X607E);
	op_hex		(x,	1);
	set_name	(0X607E,	"CheckFCB");
	set_cmt	(0X6089,	"[ES:DI+SFT.SFCount]",	0);
	create_insn	(x=0X608F);
	op_dec		(x,	1);
	set_cmt	(0X6093,	"[DI+SFT.SFTable]",	0);
	set_cmt	(0X609C,	"[ES:DI+SF_ENTRY.sf_PID]",	0);
	set_cmt	(0X60A0,	"must match process",	0);
	set_cmt	(0X60A2,	"[ES:DI+SF_ENTRY.sf_ref_count]",	0);
	set_cmt	(0X60A6,	"must also be in use",	0);
	set_cmt	(0X60A8,	"[SI+fcb_l_drive]",	0);
	set_cmt	(0X60AB,	"FCBSPECIAL ; a special FCB?",	0);
	create_insn	(x=0X60AB);
	op_hex		(x,	1);
	set_cmt	(0X60AD,	"No. try local or device",	0);
	set_cmt	(0X60B0,	"FCBMASK",	0);
	create_insn	(x=0X60B0);
	op_hex		(x,	1);
	set_cmt	(0X60B2,	"FCBSHARE ; net FCB?",	0);
	set_cmt	(0X60B5,	"no\nyes",	0);
	set_cmt	(0X60B7,	"Call far [ss:JShare+(11*4)] ; 11 = ShChk",	0);
	create_insn	(x=0X60BE);
	op_hex		(x,	1);
	set_cmt	(0X60C0,	"[ES:DI+SF_ENTRY.sf_flags]",	0);
	create_insn	(x=0X60C4);
	op_hex		(x,	1);
	set_name	(0X60CB,	"CheckD_retn");
	create_insn	(0X60CC);
	set_cmt	(0X60CE,	"[SI+fcb_netID]",	0);
	create_insn	(0X60CE);
	set_cmt	(0X60D1,	"%define sf_serial_ID SF_ENTRY.sf_firclus\n[ES:DI+sf_serial_ID]",	0);
	set_cmt	(0X60D8,	"[SI+fcb_nsld_drvptr]",	0);
	create_insn	(0X60D8);
	set_cmt	(0X60DB,	"[ES:DI+SF_ENTRY.sf_devptr]",	0);
	set_cmt	(0X60E1,	"[SI+fcb_nsld_drvptr+2]",	0);
	set_cmt	(0X60E8,	"[ES:DI+SF_ENTRY.sf_devptr+2]",	0);
	create_insn	(0X60EC);
	set_name	(0X60EC,	"SFTFromFCB");
	set_cmt	(0X60EE,	"[SI+fcb_sfn] ; set SFN for check",	0);
	set_cmt	(0X6100,	"no problems, just set thissft",	0);
	set_cmt	(0X6118,	"set process id",	0);
	set_cmt	(0X611D,	"[ES:DI+SF_ENTRY.sf_PID]",	0);
	set_cmt	(0X6121,	"cf=0",	0);
	create_insn	(0X6122);
	set_name	(0X6122,	"FCBHardErr");
	set_cmt	(0X6127,	"error_FCB_unavailable",	0);
	create_insn	(x=0X6127);
	op_hex		(x,	1);
	set_cmt	(0X612A,	"Allowed_FAIL",	0);
	create_insn	(x=0X612A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6130);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6135,	"Fake some registers",	0);
	set_cmt	(0X613C,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0X6140,	"FAT32",	0);
	create_insn	(x=0X6142);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6147,	"[es:bp+DPB.FIRST_SECTOR]",	0);
	set_cmt	(0X614D,	"[es:bp+DPB.FCLUS_FSECTOR+2]",	0);
	create_insn	(0X614D);
	create_insn	(x=0X6151);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6156,	"[es:bp+DPB.FCLUS_FSECTOR]",	0);
	set_cmt	(0X615F,	"[SI+SYS_FCB.RR]",	0);
	create_insn	(0X615F);
	set_name	(0X615F,	"GetRR");
	set_cmt	(0X6162,	"[SI+SYS_FCB.RR+2]",	0);
	set_cmt	(0X6165,	"ignore MSB of RR if recsiz > 64",	0);
	create_insn	(x=0X6165);
	op_dec		(x,	1);
	set_name	(0X616C,	"GetRRBye");
	set_cmt	(0X616D,	"[SI+SYS_FCB.NR]",	0);
	create_insn	(0X616D);
	set_name	(0X616D,	"GetExtent");
	set_cmt	(0X6170,	"[SI+SYS_FCB.EXTENT]",	0);
	create_insn	(x=0X6173);
	op_hex		(x,	1);
	create_insn	(x=0X6175);
	op_hex		(x,	1);
	create_insn	(x=0X6177);
	op_hex		(x,	1);
	create_insn	(0X617F);
	set_name	(0X617F,	"SetExtent");
	set_cmt	(0X6183,	"next rec field",	0);
	create_insn	(x=0X6183);
	op_hex		(x,	1);
	set_cmt	(0X6185,	"[SI+SYS_FCB.NR]",	0);
	set_cmt	(0X6188,	"save upper bit",	0);
	create_insn	(x=0X6188);
	op_hex		(x,	1);
	create_insn	(x=0X618B);
	op_hex		(x,	1);
	set_cmt	(0X618D,	"move high bit of CX to low bit of DX",	0);
	create_insn	(x=0X618D);
	op_hex		(x,	1);
	set_cmt	(0X6193,	"[SI+SYS_FCB.EXTENT],AX  ; all done",	0);
	create_insn	(0X6199);
	set_name	(0X6199,	"GetExtended");
	set_cmt	(0X619B,	"-1 ; look for extention",	0);
	set_cmt	(0X619E,	"not there",	0);
	set_cmt	(0X61A0,	"point to FCB",	0);
	set_cmt	(0X61A3,	"set condition codes",	0);
	set_name	(0X61A5,	"getextd_retn");
	set_cmt	(0X61A6,	"[SI+SYS_FCB.RECSIZ] ; get his record size",	0);
	create_insn	(0X61A6);
	set_name	(0X61A6,	"GetRecSize");
	set_cmt	(0X61A9,	"is it nul?",	0);
	set_cmt	(0X61AD,	"use default size",	0);
	create_insn	(x=0X61AD);
	op_dec		(x,	1);
	set_cmt	(0X61AF,	"stuff it back",	0);
	set_cmt	(0X61B3,	"RANDOM+BLOCK",	0);
	create_insn	(0X61B3);
	set_name	(0X61B3,	"$FCB_RANDOM_WRITE_BLOCK");
	set_cmt	(0X61B7,	"RANDOM+FCBREAD+BLOCK",	0);
	create_insn	(0X61B7);
	set_name	(0X61B7,	"$FCB_RANDOM_READ_BLOCK");
	set_cmt	(0X61BB,	"FCBREAD",	0);
	create_insn	(0X61BB);
	set_name	(0X61BB,	"$FCB_SEQ_READ");
	create_insn	(0X61BF);
	set_name	(0X61BF,	"$FCB_SEQ_WRITE");
	set_cmt	(0X61C3,	"RANDOM+FCBREAD",	0);
	create_insn	(0X61C3);
	set_name	(0X61C3,	"$FCB_RANDOM_READ");
	set_cmt	(0X61C7,	"RANDOM",	0);
	create_insn	(0X61C7);
	set_name	(0X61C7,	"$FCB_RANDOM_WRITE");
	set_name	(0X61C9,	"FCBIO");
	create_insn	(x=0X61CC);
	op_dec		(x,	1);
	set_cmt	(0X61CF,	"FCBOp",	0);
	create_insn	(x=0X61CF);
	op_dec		(x,	0);
	set_cmt	(0X61D2,	"FCBErr",	0);
	set_cmt	(0X61D9,	"test FCBOp,BLOCK",	0);
	create_insn	(x=0X61D9);
	op_dec		(x,	0);
	op_hex		(x,	1);
	set_cmt	(0X61E2,	"mov cRec,cx",	0);
	set_name	(0X61E2,	"GetPos");
	set_cmt	(0X61E5,	"RecPos = GetExtent ();",	0);
	set_cmt	(0X61E8,	"RecSize = GetRecSize ();",	0);
	set_cmt	(0X61EB,	"RecSize",	0);
	set_cmt	(0X61EE,	"test FCBOp,RANDOM",	0);
	create_insn	(x=0X61EE);
	op_dec		(x,	0);
	op_hex		(x,	1);
	set_cmt	(0X61F7,	"mov RecPosL,ax",	0);
	set_name	(0X61F7,	"GetRec");
	set_cmt	(0X61FA,	"mov RecPosH,dx",	0);
	set_cmt	(0X6200,	"RecPosH",	0);
	set_cmt	(0X6207,	"RecPosL",	0);
	set_cmt	(0X620A,	"bPos = RecPos * RecSize",	0);
	set_cmt	(0X620E,	"bPosL",	0);
	create_insn	(x=0X620E);
	op_dec		(x,	0);
	set_cmt	(0X6211,	"bPosH",	0);
	create_insn	(x=0X6211);
	op_dec		(x,	0);
	set_cmt	(0X6214,	"cRec",	0);
	set_cmt	(0X6217,	"cByte = cRec * RecSize",	0);
	set_cmt	(0X6219,	"cByte",	0);
	create_insn	(x=0X6219);
	op_dec		(x,	0);
	set_cmt	(0X621C,	"if (cByte+DMA > 64K) {",	0);
	set_cmt	(0X6226,	"FCBErr = FTRIM;",	0);
	set_cmt	(0X622A,	"cRec = (64K-DMA)/RecSize;",	0);
	set_name	(0X6233,	"DoDiv");
	set_cmt	(0X6237,	"cRec",	0);
	set_cmt	(0X623A,	"cByte = cRec * RecSize;",	0);
	set_cmt	(0X623C,	"cByte\n}",	0);
	create_insn	(x=0X623C);
	op_dec		(x,	0);
	set_name	(0X623F,	"DoOper");
	set_cmt	(0X6241,	"cResult = 0;",	0);
	create_insn	(x=0X6241);
	op_dec		(x,	0);
	set_cmt	(0X6244,	"if (cByte <> 0 ||",	0);
	create_insn	(x=0X6244);
	op_dec		(x,	0);
	set_cmt	(0X6249,	"test FCBErr,FTRIM\n(FCBErr&FTRIM) == 0) {",	0);
	create_insn	(x=0X6249);
	op_hex		(x,	1);
	set_cmt	(0X6251,	"if (!SFTFromFCB (SFT,FCB))",	0);
	create_insn	(0X6251);
	set_name	(0X6251,	"DoGetExt");
	set_cmt	(0X6256,	"signal error, map for extended",	0);
	set_name	(0X6256,	"FCBDeath");
	set_cmt	(0X6259,	"cRecRes\nno bytes transferred",	0);
	create_insn	(x=0X6259);
	op_dec		(x,	0);
	set_cmt	(0X625E,	"MOV FCBErr,FEOF",	0);
	create_insn	(0X6265);
	set_name	(0X6265,	"ContinueOp");
	set_cmt	(0X6266,	"[SI+SYS_FCB.FILSIZ]",	0);
	set_cmt	(0X6269,	"[ES:DI+SF_ENTRY.sf_size]",	0);
	set_cmt	(0X626D,	"[ES:DI+SF_ENTRY.sf_size+2]",	0);
	set_cmt	(0X6271,	"bPos (bPosL, bPosH)",	0);
	create_insn	(x=0X6271);
	op_dec		(x,	1);
	set_cmt	(0X6277,	"[ES:DI+SF_ENTRY.sf_position]",	0);
	set_cmt	(0X627B,	"[ES:DI+SF_ENTRY.sf_position+2]",	0);
	set_cmt	(0X627F,	"save away Open age.",	0);
	set_cmt	(0X6280,	"cByte",	0);
	create_insn	(x=0X6280);
	op_dec		(x,	1);
	create_insn	(x=0X6283);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6286,	"test FCBOp,FCBREAD",	0);
	create_insn	(x=0X6286);
	op_dec		(x,	0);
	op_hex		(x,	1);
	create_insn	(x=0X628C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X628F,	"DoContext");
	set_cmt	(0X6294,	"DOS_READ or DOS_WRITE",	0);
	set_cmt	(0X62A9,	"cResult",	0);
	create_insn	(x=0X62A9);
	op_dec		(x,	0);
	set_name	(0X62A9,	"NODSKFULL");
	set_cmt	(0X62AC,	"SaveFCBInfo (FCB);",	0);
	set_cmt	(0X62AF,	"[ES:DI+SF_ENTRY.sf_position+2]\nrestore open age \n(sf_OpenAge = SF_ENTRY.sf_position+2)",	0);
	set_cmt	(0X62B4,	"[ES:DI+SF_ENTRY.sf_size]",	0);
	set_cmt	(0X62B8,	"[SI+SYS_FCB.FILSIZ]",	0);
	set_cmt	(0X62BB,	"[SI+SYS_FCB.FILSIZ+2]",	0);
	set_cmt	(0X62BF,	"cResult",	0);
	create_insn	(x=0X62BF);
	op_dec		(x,	1);
	set_name	(0X62BF,	"SkipOp");
	set_cmt	(0X62C4,	"cRecRes = cResult / RecSize;",	0);
	set_cmt	(0X62C7,	"cRecRes",	0);
	create_insn	(x=0X62C7);
	op_dec		(x,	0);
	set_cmt	(0X62CA,	"RecPosL",	0);
	set_cmt	(0X62CD,	"RecPosH\nRecPos += cRecResult;",	0);
	set_cmt	(0X62D1,	"if (cRecRes <> cRec)",	0);
	set_cmt	(0X62D6,	"test FCBOp,FCBREAD\nif (OP&FCBRead || !DEVICE)",	0);
	create_insn	(x=0X62D6);
	op_dec		(x,	0);
	op_hex		(x,	1);
	set_cmt	(0X62DC,	"[ES:DI+SF_ENTRY.sf_flags],\ndevid_device",	0);
	create_insn	(x=0X62DC);
	op_hex		(x,	1);
	set_cmt	(0X62E3,	"mov FCBErr,FEOF",	0);
	set_name	(0X62E3,	"SetEOF");
	set_cmt	(0X62E7,	"if (cResult%RecSize <> 0) {",	0);
	set_name	(0X62E7,	"TryBlank");
	set_cmt	(0X62EB,	"RecPosL",	0);
	set_cmt	(0X62EF,	"RecPosH\nRecPos++;",	0);
	set_cmt	(0X62F3,	"test FCBOp,FCBREAD\nif(OP&FCBRead) <> 0) {",	0);
	create_insn	(x=0X62F3);
	op_dec		(x,	0);
	op_hex		(x,	1);
	set_cmt	(0X62F9,	"cRecRes++;",	0);
	create_insn	(x=0X62F9);
	op_dec		(x,	0);
	set_cmt	(0X62FC,	"FCBErr = FTRIM | FEOF;",	0);
	set_cmt	(0X6300,	"Blank (RecSize-cResult%RecSize,\n       DMA+cResult);",	0);
	set_cmt	(0X630C,	"cResult",	0);
	create_insn	(x=0X630C);
	op_dec		(x,	1);
	set_cmt	(0X630F,	"} }",	0);
	set_cmt	(0X6311,	"RecPosH",	0);
	set_name	(0X6311,	"SetExt");
	set_cmt	(0X6314,	"RecPosL",	0);
	set_cmt	(0X6317,	"test FCBOp,RANDOM\nif ((OP&Random) == 0 ||",	0);
	create_insn	(x=0X6317);
	op_dec		(x,	0);
	op_hex		(x,	1);
	set_cmt	(0X631D,	"test FCBOp,BLOCK\n(OP&BLOCK) <> 0)",	0);
	create_insn	(x=0X631D);
	op_dec		(x,	0);
	op_hex		(x,	1);
	set_cmt	(0X6323,	"SetExtent (RecPos, FCB);",	0);
	set_name	(0X6323,	"DoSetExt");
	set_cmt	(0X6326,	"test FCBOp,BLOCK",	0);
	create_insn	(x=0X6326);
	op_dec		(x,	0);
	op_hex		(x,	1);
	set_name	(0X6326,	"TrySetRR");
	set_cmt	(0X632C,	"FCB->RR = RecPos;\n[SI+SYS_FCB.RR]",	0);
	set_cmt	(0X632F,	"[SI+SYS_FCB.RR+2]",	0);
	set_cmt	(0X6332,	"[SI+SYS_FCB.RECSIZ]",	0);
	create_insn	(x=0X6332);
	op_dec		(x,	1);
	set_cmt	(0X6338,	"Set 4th byte only if record size < 64\n[SI+SYS_FCB.RR+2+1]",	0);
	set_cmt	(0X633B,	"test FCBOp,FCBREAD\nif (!(FCBOP & FCBREAD)) {",	0);
	create_insn	(x=0X633B);
	op_dec		(x,	0);
	op_hex		(x,	1);
	set_name	(0X633B,	"TryReturn");
	set_cmt	(0X6346,	"FCB->FDate = date;\n[SI+SYS_FCB.FDATE]",	0);
	set_cmt	(0X6349,	"FCB->FTime = time;\n[SI+SYS_FCB.FTIME]",	0);
	set_cmt	(0X634C,	"test FCBOp,BLOCK \nif ((op&BLOCK) <> 0)",	0);
	create_insn	(x=0X634C);
	op_dec		(x,	0);
	op_hex		(x,	1);
	set_name	(0X634C,	"FCBSave");
	set_cmt	(0X6352,	"cRecRes ; user_CX = cRecRes;",	0);
	create_insn	(x=0X6352);
	op_dec		(x,	1);
	set_cmt	(0X6358,	"[SI+user_env.user_CX]",	0);
	set_cmt	(0X635B,	"FCBErr ; return (FCBERR);",	0);
	set_name	(0X635B,	"DoReturn");
	set_cmt	(0X6362,	"SHARING_COMPAT+open_for_both",	0);
	create_insn	(0X6362);
	set_name	(0X6362,	"$FCB_OPEN");
	create_insn	(x=0X6365);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X6368,	"DoAccess");
	create_insn	(x=0X636C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X636F,	"crunch the fcb",	0);
	set_cmt	(0X6376,	"everything seems ok",	0);
	set_name	(0X6378,	"FCBOpenErr");
	create_insn	(0X637B);
	set_name	(0X637B,	"FindFCB");
	set_cmt	(0X637F,	"indicate Open/Create operation",	0);
	set_cmt	(0X6381,	"get a sft entry (no error)",	0);
	set_cmt	(0X6387,	"[es:di+SF_ENTRY.sf_mode],\nsf_isFCB",	0);
	set_cmt	(0X6394,	"DOS_OPEN or DOS_CREATE",	0);
	set_cmt	(0X639E,	"operation succeeded",	0);
	set_name	(0X63A0,	"failopen");
	set_cmt	(0X63A1,	"clear out field (free sft)",	0);
	set_cmt	(0X63A7,	"error_too_many_open_files",	0);
	set_cmt	(0X63AC,	"error_sharing_buffer_exceeded",	0);
	create_insn	(x=0X63AC);
	op_hex		(x,	1);
	set_name	(0X63B1,	"HardMessage");
	set_name	(0X63B6,	"DeadFCB");
	set_cmt	(0X63B8,	"Non Fat file?",	0);
	create_insn	(0X63B8);
	set_name	(0X63B8,	"FCBOK");
	set_cmt	(0X63BB,	"yes",	0);
	set_cmt	(0X63BD,	"share around?",	0);
	set_cmt	(0X63C0,	"yes",	0);
	set_cmt	(0X63CC,	"[es:di+SFTENTRY.sf_flags],\ndevid_device",	0);
	create_insn	(x=0X63CC);
	op_hex		(x,	1);
	set_name	(0X63CC,	"FCBOK1");
	set_cmt	(0X63D1,	"local device\nlocal (disk) file",	0);
	set_cmt	(0X63D3,	"[es:di+SFTENTRY.sf_attr],\nattr_volume_id",	0);
	create_insn	(x=0X63D3);
	op_hex		(x,	1);
	set_cmt	(0X63DC,	"[es:di+SF_ENTRY.sf_devptr]\nlocal file's DPB",	0);
	set_cmt	(0X63E0,	"[es:di+DPB.FAT_SIZE]",	0);
	set_cmt	(0X63E7,	"not FAT32",	0);
	set_cmt	(0X63E9,	"error_invalid_drive ; for FAT32",	0);
	set_cmt	(0X63EE,	"inc word [ES:DI+SF_ENTRY.sf_ref_count]",	0);
	create_insn	(0X63EE);
	set_name	(0X63EE,	"FCBOK2");
	set_cmt	(0X63F7,	"[ES:DI+SF_ENTRY.sf_flags],\ndevid_device",	0);
	create_insn	(x=0X63F7);
	op_hex		(x,	1);
	set_cmt	(0X6407,	"[SI+SYS_FCB.RECSIZ],128\ndefault record size",	0);
	create_insn	(x=0X6407);
	op_hex		(x,	1);
	set_name	(0X6407,	"FCBNoDrive");
	set_cmt	(0X640D,	"[es:di+SF_ENTRY.sf_time]",	0);
	set_cmt	(0X6411,	"[si+SYS_FCB.FTIME]",	0);
	set_cmt	(0X6414,	"[si+SYS_FCB.FDATE]",	0);
	set_cmt	(0X6419,	"[es:di+SF_ENTRY.sf_size]",	0);
	set_cmt	(0X641D,	"[si+SYS_FCB.FILSIZ]",	0);
	set_cmt	(0X6420,	"[si+SYS_FCB.FILSIZ+2]",	0);
	set_cmt	(0X6424,	"0",	0);
	set_cmt	(0X6426,	"[si+SYS_FCB.EXTENT] ; beginning of file",	0);
	set_cmt	(0X6429,	"pointer to head of the list",	0);
	set_cmt	(0X642E,	"[es:si+SFT.SFCount]\nnumber of SFTs to scan",	0);
	set_cmt	(0X6432,	"[SI+fcb_sfn]",	0);
	set_name	(0X6432,	"OpenScan");
	set_cmt	(0X6438,	"do they match",	0);
	set_cmt	(0X643C,	"found a match!",	0);
	set_cmt	(0X643E,	"advance to next FCB",	0);
	set_name	(0X643E,	"SkipCheck");
	set_cmt	(0X6440,	"table full?",	0);
	set_cmt	(0X6442,	"no, go for more",	0);
	set_cmt	(0X6444,	"return success",	0);
	set_name	(0X6444,	"OpenDone");
	set_cmt	(0X6447,	"[SI+fcb_sfn] ; assign with this",	0);
	create_insn	(0X6447);
	set_name	(0X6447,	"OpenFound");
	set_cmt	(0X644A,	"inc word [ES:DI+SF_ENTRY.sf_ref_count]",	0);
	set_cmt	(0X6450,	"update LRU counts",	0);
	set_cmt	(0X6454,	"[es:di+sf_LRU]",	0);
	set_cmt	(0X645E,	"dec word [ES:DI+SF_ENTRY.sf_ref_count]\nfree the newly allocated SFT",	0);
	create_insn	(x=0X646B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X646B,	"$FCB_CREATE");
	set_cmt	(0X646E,	"attributes to create",	0);
	set_cmt	(0X6470,	"get extended FCB",	0);
	set_cmt	(0X6473,	"not an extended FCB",	0);
	set_cmt	(0X6475,	"get attributes",	0);
	set_name	(0X6478,	"DoAccessJ");
	create_insn	(0X647B);
	set_name	(0X647B,	"$DIR_SEARCH_FIRST");
	set_cmt	(0X648C,	"point to drive select byte",	0);
	set_cmt	(0X648F,	"save original drive byte",	0);
	set_name	(0X648F,	"NORMFCB4");
	create_insn	(x=0X6495);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6498,	"convert the FCB, set SATTRIB EXTFCB",	0);
	set_name	(0X649E,	"dcf_errj");
	create_insn	(0X64A1);
	set_name	(0X64A1,	"SearchIt");
	create_insn	(x=0X64AB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X64B5,	"SEARCH_FASTOPEN",	0);
	create_insn	(x=0X64B5);
	op_hex		(x,	1);
	create_insn	(x=0X64CB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X64CB,	"SearchSet");
	create_insn	(x=0X64D2);
	op_hex		(x,	1);
	set_cmt	(0X64D9,	"point past the extension",	0);
	set_cmt	(0X64DC,	"get original drive byte",	0);
	set_name	(0X64DC,	"NORMFCB1");
	set_name	(0X64E7,	"SearchDrv");
	set_cmt	(0X64EB,	"20/2",	0);
	create_insn	(x=0X64EB);
	op_dec		(x,	1);
	create_insn	(x=0X64F7);
	op_hex		(x,	1);
	set_cmt	(0X650C,	"User Drive byte",	0);
	set_name	(0X650C,	"NORMFCB2");
	set_cmt	(0X650F,	"32 / 2 words of dir entry",	0);
	create_insn	(x=0X650F);
	op_dec		(x,	1);
	set_cmt	(0X6514,	"FCB_RET_OK",	0);
	create_insn	(0X6517);
	set_name	(0X6517,	"$DIR_SEARCH_NEXT");
	create_insn	(x=0X652F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X6546,	"NORMFCB6");
	create_insn	(x=0X6548);
	op_dec		(x,	1);
	set_cmt	(0X654C,	"20/2",	0);
	create_insn	(x=0X654C);
	op_dec		(x,	1);
	create_insn	(x=0X655B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X657A);
	set_name	(0X657A,	"SearchNoMore");
	create_insn	(x=0X657E);
	op_hex		(x,	1);
	set_cmt	(0X6585,	"point past the extension",	0);
	set_name	(0X6588,	"NORMFCB8");
	set_cmt	(0X658F,	"error_path_not_found",	0);
	create_insn	(0X658F);
	set_name	(0X658F,	"FindError");
	set_cmt	(0X6591,	"error and map into one",	0);
	set_name	(0X6591,	"FF_errj");
	create_insn	(0X6594);
	set_name	(0X6594,	"$FIND_FIRST");
	set_cmt	(0X6596,	"Search attribute",	0);
	create_insn	(x=0X659B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X659E,	"convert the path",	0);
	set_name	(0X65A3,	"Find_it");
	create_insn	(x=0X65AD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X65B7,	"SEARCH_FASTOPEN",	0);
	create_insn	(x=0X65B7);
	op_hex		(x,	1);
	set_cmt	(0X65BD,	"Find it",	0);
	create_insn	(x=0X65CA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X65CA,	"FindSet");
	create_insn	(x=0X65D1);
	op_dec		(x,	1);
	set_cmt	(0X65D7,	"Save pointer to start of entry",	0);
	set_cmt	(0X65D8,	"[SI+dir_entry.dir_attr]",	0);
	create_insn	(x=0X65D8);
	op_dec		(x,	1);
	set_cmt	(0X65DC,	"dir_entry.dir_time",	0);
	create_insn	(x=0X65DC);
	op_dec		(x,	1);
	set_cmt	(0X65DF,	"dir_time",	0);
	set_cmt	(0X65E0,	"dir_date",	0);
	set_cmt	(0X65E1,	"Skip dir_first",	0);
	set_cmt	(0X65E3,	"dir_size (2 words)",	0);
	set_cmt	(0X65E5,	"Point back to dir_name",	0);
	create_insn	(0X65EC);
	set_name	(0X65EC,	"$FIND_NEXT");
	create_insn	(x=0X65F0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X65F8);
	op_dec		(x,	1);
	create_insn	(x=0X6608);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6617,	"Find it",	0);
	set_cmt	(0X6622,	"No error, set info",	0);
	set_cmt	(0X6627,	"Convert file names from FCB to ASCIZ format",	0);
	create_insn	(0X6627);
	set_name	(0X6627,	"PackName");
	set_cmt	(0X6633,	"Back up over trailing space",	0);
	set_cmt	(0X663E,	"Some chars in extension",	0);
	set_cmt	(0X6644,	"No extension",	0);
	set_cmt	(0X6652,	"Back up over trailing space",	0);
	set_cmt	(0X6655,	"NUL terminate",	0);
	create_insn	(0X6655);
	set_cmt	(0X6659,	"\nSEARCH_FASTOPEN",	0);
	create_insn	(x=0X6659);
	op_hex		(x,	1);
	set_name	(0X6659,	"GET_FAST_SEARCH");
	create_insn	(0X6664);
	set_name	(0X6664,	"$CURRENT_DIR");
	set_cmt	(0X6667,	"get drive number (0=def, 1=A)",	0);
	set_name	(0X666E,	"CurdirErr");
	create_insn	(x=0X6677);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X667B,	"curdir_errj");
	create_insn	(0X667E);
	set_name	(0X667E,	"CurrentValidate");
	create_insn	(x=0X6685);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X668A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X668A,	"DoCheck");
	set_cmt	(0X6698,	"[SI+curdir.end]",	0);
	set_cmt	(0X669B,	"root or subdirs present?",	0);
	set_name	(0X66A1,	"CurrentCopy");
	set_cmt	(0X66A2,	"get char",	0);
	set_cmt	(0X66AD,	"get char",	0);
	create_insn	(0X66AD);
	set_name	(0X66AD,	"FCPYNEXT");
	set_cmt	(0X66AE,	"beginning of directory ?",	0);
	set_name	(0X66AE,	"FFF");
	set_cmt	(0X66B0,	"no",	0);
	set_cmt	(0X66B4,	"1st char of dir is 05?",	0);
	set_cmt	(0X66B6,	"no",	0);
	set_cmt	(0X66B8,	"make it E5",	0);
	set_name	(0X66B8,	"FCHANGE");
	set_cmt	(0X66BA,	"put into user's buffer",	0);
	set_name	(0X66BA,	"FOK");
	set_cmt	(0X66BB,	"final char",	0);
	set_cmt	(0X66BD,	"no",	0);
	set_cmt	(0X66C0,	"MZ 19 Jan 84",	0);
	set_cmt	(0X66C5,	"no more, bye!",	0);
	set_cmt	(0X66C8,	"Save ptr to name",	0);
	create_insn	(0X66C8);
	set_name	(0X66C8,	"$RMDIR");
	create_insn	(x=0X66CC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X66D0,	"Translate the name",	0);
	set_cmt	(0X66D8,	"error_path_not_found",	0);
	set_name	(0X66DA,	"rmdir_chdir_errj");
	create_insn	(0X66DC);
	set_name	(0X66DC,	"rmlset");
	set_cmt	(0X66E6,	"al = 0 , ie drive a:",	0);
	set_cmt	(0X66E8,	"Get curdir for drive in al",	0);
	set_name	(0X66E8,	"rmloop");
	set_cmt	(0X66EB,	"If error, exit loop & cont normally",	0);
	set_cmt	(0X66ED,	"[SI+curdir.flags],curdir_inuse",	0);
	create_insn	(x=0X66ED);
	op_hex		(x,	1);
	set_cmt	(0X66F4,	"Are the 2 paths the same?",	0);
	set_cmt	(0X66F7,	"Yes, report error.",	0);
	set_cmt	(0X66F9,	"Go check next drive.",	0);
	set_name	(0X66F9,	"rmdir_nxt");
	create_insn	(0X66FD);
	set_name	(0X66FD,	"rmerr");
	set_cmt	(0X66FF,	"error_current_directory",	0);
	set_name	(0X6701,	"rmdir_chdir_errj2");
	create_insn	(0X6703);
	set_name	(0X6703,	"rmcont");
	set_cmt	(0X6704,	"Restore ptr the name",	0);
	create_insn	(x=0X6705);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X670B,	"DIRSTRLEN",	0);
	create_insn	(x=0X670B);
	op_dec		(x,	1);
	set_cmt	(0X670E,	"local directory",	0);
	create_insn	(x=0X6710);
	op_dec		(x,	1);
	set_name	(0X6713,	"rmcont2");
	set_cmt	(0X671B,	"DIRSTRLEN",	0);
	create_insn	(x=0X671B);
	op_dec		(x,	1);
	set_name	(0X671B,	"$CHDIR");
	create_insn	(x=0X6722);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6727,	"go munge the path and get real CDS",	0);
	set_cmt	(0X672A,	"no errors, try path",	0);
	set_cmt	(0X672C,	"error_path_not_found",	0);
	set_name	(0X672C,	"ChDirErrP");
	set_name	(0X672E,	"chdir_errj");
	set_cmt	(0X6730,	"No meta chars allowed.",	0);
	create_insn	(x=0X6730);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X6730,	"ChDirCrack");
	create_insn	(x=0X6737);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X673B,	"if (ThisCDS == NULL)",	0);
	set_cmt	(0X673E,	"    error ();",	0);
	set_cmt	(0X6740,	"Find out if the directory exists.",	0);
	set_cmt	(0X6745,	"Get back CDS to see if a join as seen.",	0);
	create_insn	(x=0X6745);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6749,	"\n[ES:DI+curdir.flags],curdir_splice",	0);
	create_insn	(x=0X6749);
	op_hex		(x,	1);
	create_insn	(x=0X674F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6755,	"The CDS was joined.",	0);
	set_cmt	(0X6756,	"Let's go back and grab the logical CDS.",	0);
	set_cmt	(0X6759,	"get original text",	0);
	set_cmt	(0X675C,	"[SI+user_env.user_DX]",	0);
	set_cmt	(0X675F,	"[SI+user_env.user_DS]",	0);
	create_insn	(x=0X6762);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6767,	"do no splicing",	0);
	set_cmt	(0X676A,	"Munge path",	0);
	set_cmt	(0X676E,	"get new CDS",	0);
	create_insn	(x=0X676E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6772,	"[es:di+curdir.ID],-1",	0);
	set_cmt	(0X6778,	"[es:di+curdir.ID+2],-1",	0);
	set_name	(0X6782,	"GotCDS");
	set_cmt	(0X6787,	"\n[ES:DI+curdir.flags],curdir_isnet",	0);
	create_insn	(x=0X6787);
	op_hex		(x,	1);
	set_cmt	(0X678F,	"for Join and Subst\n[ES:DI+curdir.flags],curdir_splice",	0);
	create_insn	(x=0X678F);
	op_hex		(x,	1);
	set_cmt	(0X6797,	"-1",	0);
	set_cmt	(0X679C,	"[ES:DI+curdir.ID]",	0);
	set_name	(0X679C,	"setdirclus");
	set_cmt	(0X67A0,	"[ES:DI+curdir.ID+2]",	0);
	set_cmt	(0X67A4,	"get logical CDS",	0);
	create_insn	(x=0X67A4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X67A8,	"SkipRecency");
	set_name	(0X67AD,	"mkdir_ok");
	set_cmt	(0X67B0,	"DIRSTRLEN",	0);
	create_insn	(x=0X67B0);
	op_dec		(x,	1);
	set_name	(0X67B0,	"$MKDIR");
	create_insn	(x=0X67B7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X67B7,	"mkdir_x");
	create_insn	(x=0X67BA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X67BA,	"DoDirCall");
	set_cmt	(0X67BE,	"get source",	0);
	set_cmt	(0X67C0,	"go munge the path",	0);
	set_cmt	(0X67C4,	"no errors, try path",	0);
	set_cmt	(0X67C6,	"error_path_not_found",	0);
	set_name	(0X67C6,	"MkErrP");
	set_name	(0X67C8,	"MkErr");
	set_cmt	(0X67CB,	"-1",	0);
	create_insn	(0X67CB);
	set_name	(0X67CB,	"MkDirCrack");
	set_cmt	(0X67D4,	"check path len > [PATNAMELEN]\n> 67 or 128",	0);
	set_cmt	(0X67DA,	"error_access_denied",	0);
	set_cmt	(0X67DE,	"go get file",	0);
	create_insn	(0X67DE);
	set_name	(0X67DE,	"pathok");
	set_cmt	(0X67E0,	"error",	0);
	set_cmt	(0X67E2,	"ok",	0);
	create_insn	(0X67E4);
	set_name	(0X67E4,	"Check_PathLen");
	create_insn	(0X67E9);
	set_name	(0X67E9,	"Check_PathLen2");
	create_word	(x=0X67F7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X67F7,	"IOCTLJMPTABLE");
	set_cmt	(0X67F9,	"1",	0);
	create_word	(x=0X67F9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X67FB,	"2",	0);
	create_word	(x=0X67FB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X67FD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X67FF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6801,	"5",	0);
	create_word	(x=0X6801);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_2(void) {
        auto x;
#define id x

	create_word	(x=0X6803);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X6805);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X6807);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6809,	"9",	0);
	create_word	(x=0X6809);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X680B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X680D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X680F,	"0Ch",	0);
	create_word	(x=0X680F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6811,	"0Dh",	0);
	create_word	(x=0X6811);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X6813);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_word	(x=0X6815);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6817,	"query_handle_support",	0);
	create_word	(x=0X6817);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6819,	"query_device_support ; 11h",	0);
	create_word	(x=0X6819);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X681B,	"Stash DS for calls 2,3,4 and 5",	0);
	create_insn	(0X681B);
	set_name	(0X681B,	"$IOCTL");
	set_cmt	(0X681F,	"al must be between 0 & 11h",	0);
	create_insn	(x=0X6825);
	op_hex		(x,	1);
	create_insn	(x=0X682B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X6830);
	create_insn	(0X6833);
	set_name	(0X6833,	"ioctl_getset_data");
	set_cmt	(0X6836,	"have valid handle",	0);
	set_cmt	(0X6838,	"error_invalid_handle",	0);
	create_insn	(0X683D);
	set_cmt	(0X683F,	"[ES:DI+SF_ENTRY.sf_flags]",	0);
	set_cmt	(0X6849,	"error_invalid_data ; no DH <> 0",	0);
	set_cmt	(0X684D,	"devid_device  ; can I set this handle?",	0);
	create_insn	(x=0X684D);
	op_hex		(x,	1);
	set_cmt	(0X6851,	"devid_device\nMake sure user doesn't\nturn off the device bit!!",	0);
	create_insn	(x=0X6851);
	op_hex		(x,	1);
	set_cmt	(0X6857,	"[ES:DI+SF_ENTRY.sf_flags]",	0);
	create_insn	(0X685E);
	set_cmt	(0X6863,	"devid_device",	0);
	create_insn	(x=0X6863);
	op_hex		(x,	1);
	set_cmt	(0X686A,	"[ES:DI+SF_ENTRY.sf_devptr] \nGet device pointer",	0);
	set_cmt	(0X686E,	"[ES:DI+SYSDEV.ATT+1] ; Get high byte",	0);
	set_cmt	(0X6877,	"[SI+user_env.user_DX]",	0);
	create_insn	(0X687C);
	set_name	(0X687C,	"ioctl_control_string");
	set_cmt	(0X6881,	"[ES:DI+SF_ENTRY.sf_flags],\ndevid_device",	0);
	create_insn	(x=0X6881);
	op_hex		(x,	1);
	set_cmt	(0X688B,	"[ES:DI+SF_ENTRY.sf_devptr]",	0);
	create_insn	(0X6894);
	set_name	(0X6894,	"ioctl_status");
	set_cmt	(0X6896,	"6=0,7=1",	0);
	set_cmt	(0X68A3,	"invalid SFT",	0);
	create_insn	(0X68A5);
	create_insn	(0X68B2);
	set_name	(0X68B2,	"Set_Retry_Parameters");
	create_insn	(0X68C0);
	set_name	(0X68C0,	"GENERICIOCTLHANDLE");
	set_cmt	(0X68C5,	"[ES:DI+SF_ENTRY.sf_flags+1],\n(sf_isnet>>8)",	0);
	create_insn	(x=0X68C5);
	op_hex		(x,	1);
	set_cmt	(0X68CF,	"[es:di+SF_ENTRY.sf_devptr]",	0);
	set_cmt	(0X68D3,	"invalidate drive number\n(for extended -lock/unlock- functions)",	0);
	create_insn	(0X68DA);
	set_name	(0X68DA,	"GENERICIOCTL");
	set_cmt	(0X68DD,	"category (extended, disk lock/unlock)",	0);
	create_insn	(x=0X68DD);
	op_hex		(x,	1);
	set_cmt	(0X68E0,	"extended (MSDOS/PCDOS 7)",	0);
	set_cmt	(0X68E2,	"IOC_DC ; category (disk control, normal)",	0);
	set_cmt	(0X68E5,	"Only disk devices are allowed to use\nGeneric IOCTL",	0);
	set_cmt	(0X68E7,	"no handles with Generic IOCTL",	0);
	set_cmt	(0X68EA,	"drive number",	0);
	create_insn	(x=0X68EA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X68F3,	"category code 48h for FAT32",	0);
	create_insn	(x=0X68F3);
	op_hex		(x,	1);
	set_cmt	(0X68F6,	"MSDOS/PCDOS 7 functions\n(lock/unlock)",	0);
	set_cmt	(0X68F8,	"disk control (for FAT12/16)",	0);
	set_cmt	(0X68FD,	"UNLOCK LOGICAL VOLUME",	0);
	create_insn	(x=0X68FD);
	op_hex		(x,	1);
	set_cmt	(0X6902,	"LOCK LOGICAL VOLUME",	0);
	create_insn	(x=0X6902);
	op_hex		(x,	1);
	set_cmt	(0X6907,	"LOCK LOGICAL VOLUME",	0);
	create_insn	(x=0X6907);
	op_hex		(x,	1);
	set_cmt	(0X690C,	"lock level (0-4)",	0);
	set_cmt	(0X6915,	"drive number (1=A:, 2=B: ..)",	0);
	set_cmt	(0X691C,	"logical disk number limit",	0);
	create_insn	(x=0X691C);
	op_dec		(x,	1);
	set_cmt	(0X6921,	"UNLOCK LOGICAL VOLUME",	0);
	create_insn	(x=0X6921);
	op_hex		(x,	1);
	set_cmt	(0X6926,	"UNLOCK",	0);
	create_insn	(x=0X6926);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X692D,	"LOCK",	0);
	create_insn	(x=0X692D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X6935,	"[ES:DI+SYSDEV.ATT],DEV320",	0);
	create_insn	(x=0X6935);
	op_hex		(x,	1);
	set_cmt	(0X693C,	"[IOCALL_REQFUNC],GENIOCTL ; 19",	0);
	set_cmt	(0X6941,	"IOCTL_QUERY_HANDLE",	0);
	set_cmt	(0X6945,	"byte [ES:DI+SYSDEV.ATT],IOQUERY",	0);
	create_insn	(x=0X6945);
	op_hex		(x,	1);
	set_cmt	(0X694A,	"No support for query",	0);
	set_cmt	(0X694C,	"IOCTL_QUERY",	0);
	set_cmt	(0X6953,	"IOCTL_REQ.size ; 23",	0);
	set_cmt	(0X695C,	"[IOCALL+IOCTL_REQ.MAJORFUNCTION]",	0);
	set_cmt	(0X6960,	"[IOCALL+IOCTL_REQ.MINORFUNCTION]",	0);
	set_cmt	(0X6964,	"[IOCALL+IOCTL_REQ.REG_SI]",	0);
	set_cmt	(0X6968,	"[IOCALL+IOCTL_REQ.REG_DI]",	0);
	set_cmt	(0X696C,	"[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET]",	0);
	set_cmt	(0X6970,	"[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2]",	0);
	create_insn	(x=0X6974);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X697E,	"error_invalid_function",	0);
	create_insn	(0X697E);
	create_insn	(0X6983);
	create_insn	(0X6986);
	set_name	(0X6986,	"ioctl_rem_media");
	set_cmt	(0X698B,	"[es:di+SYSDEV.ATT+1],(DEVOPCL>>8)",	0);
	create_insn	(x=0X698B);
	op_hex		(x,	1);
	set_cmt	(0X6992,	"DEVRMD",	0);
	set_cmt	(0X6998,	"REMHL",	0);
	set_cmt	(0X699C,	"[SS:IOCALL_REQLEN]",	0);
	create_insn	(x=0X69AC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X69BA,	"STBUI>>8",	0);
	create_insn	(x=0X69BA);
	op_hex		(x,	1);
	create_insn	(0X69C4);
	set_name	(0X69C4,	"ioctl_drive_attr");
	set_cmt	(0X69CE,	"drive not valid",	0);
	set_cmt	(0X69D0,	"0942h -> Attribute word\nbit 11 - open/close/remmedia calls supported \nbit 8 - (new type driver) \nbit 6 - Generic IOCTL call supported\nbit 1 - driver supports 32-bit sector addressing",	0);
	set_cmt	(0X69D3,	"NET device",	0);
	set_cmt	(0X69D5,	"[es:di+SYSDEV.ATT]  \nget device attribute word",	0);
	set_cmt	(0X69D9,	"drive number (A=0)",	0);
	set_cmt	(0X69DB,	"NOTE: PCDOS 7.1 has bug here,\nds must be same with ss here...\nbecause there is 'les di, [ds:THISCDS]' in\nGet_Driver_BL\nand a second 'test byte ptr es:[ di+44h],80h'\nis not necessary; also its result (jnz)\noverwrites DS. /// Erdogan Tan - 30/01/2024",	0);
	set_cmt	(0X69E0,	"[ES:DI+curdir.flags+1],\n(curdir_isnet>>8)",	0);
	create_insn	(x=0X69E0);
	op_hex		(x,	1);
	set_cmt	(0X69E7,	"remote device (bit 12)",	0);
	create_insn	(x=0X69EC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X69FD,	"Microsoft Networks - CHECK DIRECT I/O\nDS:SI -> ASCIZ disk device name (may be full path or only drive\nspecifier--must include the colon)\nReturn: CF clear if absolute disk access allowed",	0);
	create_insn	(x=0X69FD);
	op_hex		(x,	0);
	set_cmt	(0X6A01,	"Shared, bit 9",	0);
	create_insn	(x=0X6A01);
	op_hex		(x,	1);
	set_cmt	(0X6A05,	"[ES:DI+curdir.flags+1],(curdir_local>>8)",	0);
	create_insn	(x=0X6A05);
	op_hex		(x,	1);
	create_insn	(x=0X6A0C);
	op_hex		(x,	1);
	set_cmt	(0X6A18,	"error_invalid_drive",	0);
	create_insn	(0X6A18);
	set_name	(0X6A18,	"ioctl_drv_err");
	set_cmt	(0X6A1D,	"ES:DI -> SFT",	0);
	create_insn	(0X6A1D);
	set_name	(0X6A1D,	"ioctl_handle_redir");
	set_cmt	(0X6A20,	"have valid handle",	0);
	set_cmt	(0X6A25,	"[ES:DI+SF_ENTRY.sf_flags] ; Get flags",	0);
	create_insn	(0X6A25);
	create_insn	(0X6A2B);
	create_insn	(0X6A2E);
	set_name	(0X6A2E,	"ioctl_get_dev");
	set_cmt	(0X6A33,	"[ES:DI+SYSDEV.ATT+1],(DEVIOCTL>>8)",	0);
	create_insn	(x=0X6A33);
	op_hex		(x,	1);
	set_cmt	(0X6A3A,	"DEVRDIOCTL ; IOCTL read",	0);
	create_insn	(x=0X6A3F);
	op_hex		(x,	1);
	set_cmt	(0X6A43,	"DEVWRIOCTL ; IOCTL write",	0);
	set_cmt	(0X6A48,	"It is 22 in \nMSDOS 6.22 MSDOS.SYS and Windows ME IO.SYS",	0);
	create_insn	(x=0X6A48);
	op_dec		(x,	1);
	set_cmt	(0X6A4C,	"[IOCALL_REQLEN]",	0);
	set_cmt	(0X6A51,	"[IOCALL_REQSTAT]",	0);
	create_insn	(x=0X6A69);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6A6F,	"(STERR>>8)",	0);
	create_insn	(x=0X6A6F);
	op_hex		(x,	1);
	create_insn	(0X6A7D);
	set_cmt	(0X6A82,	"STECODE",	0);
	create_insn	(x=0X6A82);
	op_hex		(x,	1);
	create_insn	(0X6A91);
	set_name	(0X6A91,	"Get_Driver_BL");
	set_cmt	(0X6A92,	"drive number (0=default)",	0);
	set_cmt	(0X6A9B,	"errLOC_Net",	0);
	create_insn	(x=0X6A9B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6AA0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6AA4,	"[ES:DI+curdir.flags+1],\n(curdir_isnet>>8)",	0);
	create_insn	(x=0X6AA4);
	op_hex		(x,	1);
	set_cmt	(0X6AA9,	"[ES:DI+curdir.devptr]",	0);
	set_cmt	(0X6AAD,	"Is net",	0);
	set_cmt	(0X6AAF,	"mov byte [EXTERR_LOCUS],errLOC_Disk ; 2",	0);
	set_cmt	(0X6AB2,	"[ES:DI+DPB.UNIT] ; Unit number",	0);
	set_cmt	(0X6AB6,	"[ES:DI+DPB.DRIVER_ADDR] ; Driver addr",	0);
	create_insn	(0X6ABD);
	set_name	(0X6ABD,	"Check_If_Net");
	set_cmt	(0X6AC0,	"invalid drive letter",	0);
	set_cmt	(0X6AC2,	"ZF = 1 if not a net device",	0);
	create_insn	(0X6AC3);
	create_insn	(0X6AC7);
	create_insn	(0X6ACA);
	create_insn	(0X6ACC);
	set_name	(0X6ACC,	"ioctl_drive_owner");
	set_cmt	(0X6AD1,	"[ES:DI+SYSDEV.ATT],DEV320",	0);
	create_insn	(x=0X6AD1);
	op_hex		(x,	1);
	set_cmt	(0X6AD8,	"DEVGETOWN ; default to get owner",	0);
	create_insn	(x=0X6AD8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_dec		(x,	1);
	set_cmt	(0X6ADD,	"Get Owner ?",	0);
	set_cmt	(0X6AE1,	"DEVSETOWN",	0);
	create_insn	(x=0X6AE1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_dec		(x,	1);
	set_cmt	(0X6AE6,	"OWNHL",	0);
	set_cmt	(0X6AE8,	"Unit number",	0);
	set_cmt	(0X6AEA,	"[IOCALL_REQLEN]",	0);
	create_insn	(x=0X6AEA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6AEF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6AF4,	"DS:SI -> driver",	0);
	set_cmt	(0X6AF8,	"ES:BX -> Call header",	0);
	create_insn	(x=0X6AF8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6B02,	"(STERR>>8)",	0);
	create_insn	(x=0X6B02);
	op_hex		(x,	1);
	set_cmt	(0X6B0A,	"Get owner returned by device\nowner returned is 1-based.",	0);
	create_insn	(0X6B11);
	set_name	(0X6B11,	"DOS_DELETE");
	set_cmt	(0X6B19,	"Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE\nSS = DS = DOS CS, SDA first filename pointer -> fully-qualified filename in DOS CS\nSDA CDS pointer -> current directory structure for drive with file\nReturn: CF set on error",	0);
	create_insn	(x=0X6B19);
	op_hex		(x,	0);
	set_cmt	(0X6B1C,	"No files found and no files deleted",	0);
	create_insn	(x=0X6B1C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6B24,	"DIRFREE*256+0 ; Assume not del *.*",	0);
	create_insn	(x=0X6B24);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6B2A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6B31,	"go to end",	0);
	set_cmt	(0X6B33,	"Back over possible \"*.*\"",	0);
	set_cmt	(0X6B36,	"\"*.\"",	0);
	set_cmt	(0X6B42,	"Back over possible \"????????.???\"",	0);
	set_cmt	(0X6B49,	"'??'",	0);
	set_cmt	(0X6B4C,	"four sets of \"??\"",	0);
	set_cmt	(0X6B56,	"\".?\"",	0);
	set_cmt	(0X6B5C,	"3F3Fh",	0);
	create_insn	(x=0X6B5C);
	op_chr		(x,	1);
	create_insn	(x=0X6B61);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6B64,	"attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only\nLook only at hidden bits",	0);
	create_insn	(x=0X6B64);
	op_hex		(x,	1);
	set_cmt	(0X6B6A,	"DEL *.* - flag deleting all",	0);
	create_insn	(x=0X6B6A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6B6F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6B77,	"[CURBUF+2]:SI = First Cluster field in dir entry\n[CURBUF+2]:BX = Directory entry",	0);
	set_cmt	(0X6B7F,	"error_file_not_found",	0);
	set_cmt	(0X6B86,	"error_path_not_found",	0);
	create_insn	(0X6B86);
	set_cmt	(0X6B8B,	"Check for dir specified",	0);
	create_insn	(0X6B8B);
	set_cmt	(0X6B8D,	"DelAll = 0 allows delete of dir.",	0);
	create_insn	(x=0X6B8D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6B99,	"Check if device name",	0);
	create_insn	(0X6B99);
	set_cmt	(0X6B9B,	"Can't delete I/O devices",	0);
	set_cmt	(0X6B9D,	"FILEFOUND ; file found, not deleted yet",	0);
	create_insn	(x=0X6B9D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X6BA3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6BA7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6BAB,	"attr_read_only ; are we deleting RO files too?",	0);
	create_insn	(x=0X6BAB);
	op_hex		(x,	1);
	set_cmt	(0X6BB3,	"[BX+dir_entry.dir_attr],attr_read_only",	0);
	create_insn	(x=0X6BB3);
	op_hex		(x,	1);
	set_cmt	(0X6BB7,	"not read only",	0);
	set_cmt	(0X6BBA,	"Skip it (Note ES:BP not set)",	0);
	set_cmt	(0X6BBC,	"Sets ES:BP = [THISDPB]",	0);
	create_insn	(0X6BBC);
	set_cmt	(0X6BC1,	"\n[DI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0X6BC1);
	op_hex		(x,	1);
	set_name	(0X6BC1,	"DEL_SHARE_OK");
	set_cmt	(0X6BCA,	"[DI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0X6BCA);
	op_hex		(x,	1);
	set_cmt	(0X6BCE,	"[BX+dir_entry.dir_name],AH ; Put in E5h or 0",	0);
	set_cmt	(0X6BD6,	"not FAT32",	0);
	set_cmt	(0X6BD8,	"high word of the first cluster (FAT32)",	0);
	set_cmt	(0X6BE3,	"FILEDELETED",	0);
	create_insn	(x=0X6BE3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X6BE8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6BF2,	"File has invalid FIRCLUS (too small)",	0);
	set_cmt	(0X6BF4,	"[es:bp+DPB.FAT_SIZE]",	0);
	create_insn	(x=0X6BFC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6C0D,	"[ES:BP+DPB.MAX_CLUSTER]",	0);
	create_insn	(0X6C0D);
	set_cmt	(0X6C11,	"File has invalid FIRCLUS (too big)",	0);
	set_cmt	(0X6C13,	"Free file data",	0);
	create_insn	(x=0X6C1B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6C1F,	"Registers need to be reset",	0);
	create_insn	(x=0X6C2C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6C33,	"[ES:BP+DPB.DRIVE]",	0);
	set_cmt	(0X6C3C,	"FILEDELETE",	0);
	create_insn	(x=0X6C3C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X6C43,	"attr_volume_id",	0);
	create_insn	(x=0X6C43);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X6C4D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6C53,	"Get drive",	0);
	set_cmt	(0X6C56,	"Convert to 0-based",	0);
	create_insn	(x=0X6C56);
	op_chr		(x,	1);
	create_insn	(x=0X6C59);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6C60,	"force media check",	0);
	set_cmt	(0X6C6A,	"FILEFOUND ; not deleted. Did we find file?",	0);
	create_insn	(x=0X6C6A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X6C6F,	"yes. Access denied",	0);
	set_cmt	(0X6C71,	"Nope",	0);
	create_insn	(0X6C74);
	set_cmt	(0X6C77,	"check for access for rename and delete",	0);
	create_insn	(0X6C77);
	set_name	(0X6C77,	"REN_DEL_Check");
	set_cmt	(0X6C7E,	"points to name",	0);
	set_cmt	(0X6C8A,	"Set backup limit for skipback",	0);
	set_cmt	(0X6C8C,	"Skip over d: to point to leading '\\'",	0);
	set_cmt	(0X6C8E,	"CX is length of ES:DI including NUL",	0);
	set_cmt	(0X6C91,	"Don't include nul in count",	0);
	set_cmt	(0X6C92,	"Point to NUL at end of string",	0);
	set_cmt	(0X6C94,	"Back up one element",	0);
	set_cmt	(0X6C97,	"Point to start of last element",	0);
	set_cmt	(0X6C98,	"save for DOS_RENAME",	0);
	set_cmt	(0X6C9D,	"Transfer name from entry to ASCIZ tail.",	0);
	set_cmt	(0X6CA0,	"Get back entry pointers",	0);
	set_cmt	(0X6CA3,	"Back on stack",	0);
	set_cmt	(0X6CA6,	"(not necessary) ; 31/01/2024",	0);
	set_cmt	(0X6CA8,	"Call far [JShare+(13*4)] ; 13 = ShCloseFile",	0);
	create_insn	(0X6CBD);
	set_cmt	(0X6CC1,	"AUXSTACK-SF_ENTRY.size\nRENAMEDMA+(384-59)",	0);
	set_cmt	(0X6CC9,	"Indicate file to DOOPEN (high bit off)",	0);
	set_cmt	(0X6CCB,	"Fill in SFT for share check",	0);
	set_cmt	(0X6CD2,	"[ES:DI+SF_ENTRY.sf_mode],SHARING_DENY_BOTH\nrequires exclusive access",	0);
	set_cmt	(0X6CD8,	"[ES:DI+SF_ENTRY.sf_ref_count],1 ; Pretend open",	0);
	set_cmt	(0X6CE6,	"[ES:DI+SF_ENTRY.sf_ref_count]\nPretend closed and free",	0);
	set_cmt	(0X6CEB,	"Tell sharer we're done with THISSFT",	0);
	create_insn	(0X6CF9);
	set_name	(0X6CF9,	"FastOpen_Delete");
	set_cmt	(0X6CFE,	"ds:si points to path name",	0);
	set_cmt	(0X6D03,	"FONC_delete",	0);
	create_insn	(0X6D07);
	set_name	(0X6D07,	"FastOpen_Rename");
	set_cmt	(0X6D0C,	"ds:si-->Path name addrs",	0);
	set_cmt	(0X6D11,	"FONC_Rename",	0);
	create_insn	(x=0X6D11);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6D16);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X6D16,	"fastinvoke");
	create_insn	(0X6D21);
	set_name	(0X6D21,	"FastOpen_Update");
	set_cmt	(0X6D26,	"FONC_update",	0);
	create_insn	(x=0X6D2A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X6D2A,	"Fast_Dispatch");
	set_cmt	(0X6D2D,	"CALL far [SS:SI]",	0);
	create_insn	(0X6D31);
	set_name	(0X6D31,	"DOS_RENAME");
	set_cmt	(0X6D39,	"Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE\nSS = DS = DOS CS, SDA first filename pointer = offset of fully-qualified old name\nSDA CDS pointer -> current directory\nReturn: CF set on error",	0);
	create_insn	(x=0X6D39);
	op_hex		(x,	0);
	create_insn	(0X6D3C);
	create_insn	(x=0X6D3F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6D43);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6D4B,	"Lower case",	0);
	create_insn	(x=0X6D4B);
	op_hex		(x,	1);
	set_cmt	(0X6D52,	"error_not_same_device",	0);
	create_insn	(x=0X6D57);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6D5B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6D5F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6D63);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6D69,	"Rename fails on DEVS, assume not a dev",	0);
	create_insn	(x=0X6D69);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6D71,	"Sets [NoSetDir] to 1,\n[CURBUF+2]:BX points to entry",	0);
	set_cmt	(0X6D76,	"error_no_more_files",	0);
	set_cmt	(0X6D7B,	"error_file_not_found",	0);
	create_insn	(x=0X6D7F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6D83);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6D8B,	"error_access_denied",	0);
	create_insn	(0X6D8B);
	set_cmt	(0X6D8F,	"check if source a dir",	0);
	create_insn	(x=0X6D8F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6D93,	"find_buf.attr",	0);
	create_insn	(x=0X6D93);
	op_dec		(x,	1);
	set_cmt	(0X6D96,	"[SI+dir_entry.dir_attr],attr_directory",	0);
	create_insn	(x=0X6D96);
	op_hex		(x,	1);
	set_cmt	(0X6D9C,	"if yes",	0);
	create_insn	(x=0X6D9C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6DA0,	"make sure path length < PATHNAMELEN (67)",	0);
	create_insn	(x=0X6DA6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6DAF,	"dir_entry.dir_first",	0);
	create_insn	(x=0X6DAF);
	op_dec		(x,	1);
	set_cmt	(0X6DB7,	"error_sharing_violation",	0);
	create_insn	(x=0X6DB7);
	op_hex		(x,	1);
	create_insn	(x=0X6DBC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6DC0,	"find_buf.attr",	0);
	create_insn	(x=0X6DC0);
	op_dec		(x,	1);
	set_cmt	(0X6DC3,	"[SI+dir_entry.dir_attr],attr_directory",	0);
	create_insn	(x=0X6DC3);
	op_hex		(x,	1);
	set_cmt	(0X6DC9,	"delete dir info in fastopen",	0);
	set_cmt	(0X6DCC,	"Swap source and destination",	0);
	create_insn	(x=0X6DCC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6DCF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6DD3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6DD7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6DDA,	"-1 ; No current dir on dest",	0);
	create_insn	(x=0X6DDA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6DE0,	"DIRFREE*256+0FFh\nCreating, not DEL *.*",	0);
	create_insn	(x=0X6DE0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6DEB,	"Device?",	0);
	set_cmt	(0X6DED,	"No, continue",	0);
	set_cmt	(0X6DEF,	"error_access_denied",	0);
	create_insn	(x=0X6DF5);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6DFC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6E03);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X6E0D);
	set_cmt	(0X6E0E,	"error_path_not_foun",	0);
	create_insn	(0X6E14);
	create_insn	(x=0X6E16);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6E1B,	"Search for dest failed",	0);
	create_insn	(0X6E27);
	create_insn	(x=0X6E29);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6E2C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6E2F);
	op_dec		(x,	1);
	set_cmt	(0X6E32,	"Save dest with metas at NAME2",	0);
	create_insn	(x=0X6E34);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6E37);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6E3A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6E3D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6E41,	"needed due to JMP BUILDDEST below",	0);
	set_cmt	(0X6E42,	"Source of replace chars",	0);
	create_insn	(x=0X6E42);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6E45,	"Real dest name goes here",	0);
	create_insn	(x=0X6E45);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6E48,	"Raw dest",	0);
	create_insn	(x=0X6E48);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6E4B);
	op_dec		(x,	1);
	set_cmt	(0X6E4E,	"replace ? chars",	0);
	set_cmt	(0X6E51,	"attr_all\nStop duplicates with any attributes",	0);
	create_insn	(x=0X6E51);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6E56);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6E5B,	"Check if we built a device name",	0);
	create_insn	(x=0X6E60);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6E64);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6E68);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6E6C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6E70,	"Reset search to start of dir",	0);
	set_cmt	(0X6E73,	"Screw up",	0);
	set_cmt	(0X6E75,	"See if new name already exists",	0);
	set_cmt	(0X6E78,	"Error if found",	0);
	create_insn	(x=0X6E7A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6E7F,	"Find failed because user FAILed to I 24",	0);
	set_cmt	(0X6E81,	"DIRSTART of dest",	0);
	create_insn	(x=0X6E81);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6E84);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6E88);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6E8C,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0X6E91,	"not FAT32",	0);
	create_insn	(x=0X6E93);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6E99,	"DIRSTART_HW of source",	0);
	create_insn	(x=0X6E99);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6E9D,	"If =, just give new name",	0);
	set_cmt	(0X6E9F,	"RENAMEDMA+21+dir_entry.dir_attr]",	0);
	create_insn	(x=0X6E9F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6EA2,	"attr_directory",	0);
	create_insn	(x=0X6EA2);
	op_hex		(x,	1);
	set_cmt	(0X6EA4,	"Can only do a simple rename on dirs,\notherwise the . and .. entries get wiped.",	0);
	create_insn	(x=0X6EA6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X6EA9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6EAD,	"AUXSTACK-SF_ENTRY.size \nRENAMEDMA+325",	0);
	create_insn	(x=0X6EAD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6EB0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6EB4,	"[SI+SF_ENTRY.sf_mode],\nSHARING_COMPAT+open_for_both",	0);
	set_cmt	(0X6EB9,	"Set \"device ID\" for call into makenode",	0);
	set_cmt	(0X6EBB,	"This is in mknode",	0);
	create_insn	(0X6EC3);
	set_cmt	(0X6EC4,	"RENAME_MAKE entered this into sharing",	0);
	create_insn	(x=0X6EC4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6EC8,	"we need to remove it.",	0);
	create_insn	(x=0X6ECC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6ED5,	"dir_entry.dir_attr ; skip name",	0);
	create_insn	(x=0X6ED5);
	op_dec		(x,	1);
	set_cmt	(0X6ED8,	"RENAMEDMA+21+dir_entry.dir_attr",	0);
	create_insn	(x=0X6ED8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6EDB,	"dir_entry.size-dir_entry.dir_attr",	1);
	create_insn	(x=0X6EDB);
	op_dec		(x,	1);
	create_insn	(x=0X6EE7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6EEB,	"DIRFREE",	0);
	create_insn	(0X6EF0);
	create_insn	(x=0X6EF7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6EFB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6EFE);
	op_dec		(x,	1);
	create_insn	(x=0X6F03);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X6F0B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6F0F,	"find_buf.attr",	0);
	create_insn	(x=0X6F0F);
	op_dec		(x,	1);
	set_cmt	(0X6F12,	"[SI+dir_entry.dir_attr],\nattr_directory",	0);
	create_insn	(x=0X6F12);
	op_hex		(x,	1);
	create_insn	(x=0X6F1C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6F22,	"Correct setting for search",	0);
	create_insn	(x=0X6F22);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6F2C,	"[BX+dir_entry.dir_first]",	0);
	set_cmt	(0X6F34,	"error_sharing_violation",	0);
	create_insn	(x=0X6F34);
	op_hex		(x,	1);
	set_cmt	(0X6F3A,	"[RENAMEDMA+21+dir_entry.dir_attr]",	0);
	create_insn	(x=0X6F3A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6F3D,	"attr_directory",	0);
	create_insn	(x=0X6F3D);
	op_hex		(x,	1);
	create_insn	(0X6F47);
	create_insn	(0X6F4C);
	create_insn	(x=0X6F4F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X6F4F,	"GET_SOURCE");
	set_cmt	(0X6F55,	"DPB.FAT_SIZE > 0 ?",	0);
	set_cmt	(0X6F59,	"yes, it is not FAT32",	0);
	set_cmt	(0X6F5B,	"DirStart+2",	0);
	create_insn	(x=0X6F5B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6F5F,	"hw of cluster number",	0);
	create_insn	(x=0X6F5F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6F63,	"DirStart",	0);
	create_insn	(x=0X6F63);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6F6F,	"Lastent",	0);
	create_insn	(x=0X6F6F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X6F76);
	set_name	(0X6F76,	"NEW_RENAME");
	set_cmt	(0X6F77,	"3Fh",	0);
	create_insn	(x=0X6F77);
	op_chr		(x,	1);
	set_cmt	(0X6F7B,	"Get replace char",	0);
	set_cmt	(0X6F7E,	"Next replace char",	0);
	create_insn	(0X6F82);
	set_name	(0X6F82,	"GET_FILE_INFO");
	set_cmt	(0X6F8A,	"Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES\nSS = DOS CS, SDA first filename pointer -> fully-qualified name of file\nSDA CDS pointer -> current directory\nReturn: CF set on error, AX = file attributes",	0);
	create_insn	(x=0X6F8A);
	op_hex		(x,	0);
	create_insn	(0X6F8D);
	set_cmt	(0X6F90,	"if we find a dir, don't change to it",	0);
	create_insn	(x=0X6F90);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X6F9A,	"NO_PATH");
	set_cmt	(0X6FA0,	"error_file_not_found",	0);
	set_name	(0X6FA0,	"info_no_file");
	set_cmt	(0X6FA8,	"error_path_not_found",	0);
	create_insn	(0X6FA8);
	create_insn	(0X6FAD);
	set_cmt	(0X6FAF,	"device",	0);
	set_cmt	(0X6FB1,	"-1 ; is it a root dir?",	0);
	create_insn	(x=0X6FB1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6FB6,	"no, CurBuf ptr is valid",	0);
	set_cmt	(0X6FBA,	"attr_directory",	0);
	create_insn	(0X6FBF);
	create_insn	(x=0X6FC0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X6FC6,	"Assume size=0 (dir)",	0);
	set_cmt	(0X6FCA,	"[SI+dir_entry.dir_time]",	0);
	set_cmt	(0X6FCD,	"[SI+dir_entry.dir_date]",	0);
	set_cmt	(0X6FD2,	"[SI+dir_entry.dir_attr]",	0);
	set_cmt	(0X6FD5,	"attr_directory",	0);
	create_insn	(x=0X6FD5);
	op_hex		(x,	1);
	set_cmt	(0X6FD9,	"[SI+dir_entry.dir_size_l]",	0);
	set_cmt	(0X6FDC,	"[SI+dir_entry.dir_size_h]",	0);
	set_name	(0X6FE1,	"OK_BYE");
	set_cmt	(0X6FE3,	"~attr_changeable",	0);
	create_insn	(x=0X6FE3);
	op_hex		(x,	1);
	set_name	(0X6FE3,	"SET_FILE_ATTRIBUTE");
	set_cmt	(0X6FEB,	"errCLASS_Apperr",	0);
	create_insn	(x=0X6FEB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6FF0,	"errACT_Abort",	0);
	create_insn	(x=0X6FF0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X6FF5,	"error_access_denied",	0);
	create_insn	(0X6FFA);
	set_cmt	(0X7003,	"Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES\nSS = DOS CS, SDA first filename pointer -> fully-qualified name of file\nSDA CDS pointer -> current directory\nSTACK: WORD new file attributes\nReturn: CF set on error",	0);
	create_insn	(x=0X7003);
	op_hex		(x,	0);
	create_insn	(0X7007);
	set_cmt	(0X700A,	"Save new attributes",	0);
	set_cmt	(0X700B,	"if we find a dir, don't change to it",	0);
	create_insn	(x=0X700B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7015,	"Clean stack (don't zap AX)",	0);
	create_insn	(0X7018);
	set_cmt	(0X7020,	"device",	0);
	set_cmt	(0X7022,	"Get new attributes",	0);
	create_insn	(0X7022);
	set_cmt	(0X7023,	"-1 ; is this the root dir",	0);
	create_insn	(x=0X7023);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7028,	"return error",	0);
	set_cmt	(0X702F,	"error_sharing_violation",	0);
	create_insn	(x=0X702F);
	op_hex		(x,	1);
	set_cmt	(0X7034,	"error_access_denied",	0);
	create_insn	(0X7034);
	create_insn	(x=0X703A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X703E,	"[ES:BX+dir_entry.dir_attr],\n~attr_changeable",	0);
	create_insn	(x=0X703E);
	op_hex		(x,	1);
	create_insn	(x=0X704A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X704F,	"dir entry update",	0);
	set_cmt	(0X7051,	"drive number A=0,B=1,,",	0);
	set_cmt	(0X7062,	"FastOpen_Set",	0);
	create_insn	(x=0X7062);
	op_hex		(x,	1);
	set_name	(0X7062,	"GET_FAST_PATH");
	set_cmt	(0X706C,	"Fast_yes",	0);
	create_insn	(x=0X706C);
	op_hex		(x,	1);
	create_insn	(0X7074);
	set_name	(0X7074,	"DOS_DUP");
	create_insn	(x=0X7079);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X707E,	"DOS_Dup_Direct");
	set_cmt	(0X7086,	"[ES:DI+SF_ENTRY.sf_ref_count]",	0);
	set_cmt	(0X708A,	"0 ; Truncate is OK",	0);
	create_insn	(0X708A);
	set_name	(0X708A,	"DOS_CREATE");
	set_cmt	(0X708C,	"~(attr_all+attr_ignore+attr_volume_id)",	0);
	create_insn	(x=0X708C);
	op_hex		(x,	1);
	set_name	(0X708C,	"Create_inter");
	set_cmt	(0X7090,	"attr_volume_id",	0);
	create_insn	(x=0X7090);
	op_hex		(x,	1);
	set_cmt	(0X7094,	"DBCS_VOLID",	0);
	create_insn	(x=0X7094);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X7099,	"attr_volume_id",	0);
	set_cmt	(0X709B,	"attr_archive ; File changed",	0);
	create_insn	(x=0X709B);
	op_hex		(x,	1);
	set_name	(0X709B,	"NoReset");
	set_cmt	(0X709D,	"attr_directory+attr_device",	0);
	create_insn	(x=0X709D);
	op_hex		(x,	1);
	set_cmt	(0X70A1,	"Attribute problem",	0);
	set_name	(0X70A1,	"AttErr");
	set_cmt	(0X70A4,	"MOV byte [EXTERR_LOCUS],errLOC_Unk ; 1",	0);
	set_cmt	(0X70A7,	"Gotta use MKDIR to make dirs,\nNEVER allow attr_device to be set",	0);
	create_insn	(x=0X70A9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X70A9,	"ATT_OK");
	create_insn	(x=0X70AE);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X70B2,	"-1",	0);
	set_cmt	(0X70B8,	"EXT_OPEN_ON  ; extended open ?",	0);
	create_insn	(x=0X70B8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X70BD,	"no, do normal",	0);
	set_name	(0X70BF,	"IFS_extopen");
	set_cmt	(0X70C0,	"(MultNET SHL 8) OR 46",	0);
	set_cmt	(0X70C3,	"Multiplex - DOS 4 IFSFUNC.EXE - ???\nSS = DS = DOS CS, STACK: WORD ??? low byte = ???\nReturn: CF set on error\nCF clear if successful",	0);
	create_insn	(x=0X70C3);
	op_hex		(x,	0);
	set_name	(0X70C3,	"NOEXTOP2");
	set_cmt	(0X70C5,	"(BX is trashed anyway)",	0);
	create_insn	(x=0X70C6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X70CC);
	set_name	(0X70CC,	"NOEXTOP");
	set_cmt	(0X70CD,	"Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE\nES:DI -> uninitialized SFT, SS = DOS CS\nSDA first filename pointer -> fully-qualified name of file\nSTACK: WORD file creation mode???",	0);
	set_cmt	(0X70D2,	"[ES:SI+curdir.flags+1],curdir_isnet>>8",	0);
	create_insn	(x=0X70D2);
	op_hex		(x,	1);
	set_name	(0X70D2,	"TEST_RE_NET");
	set_cmt	(0X70DF,	"[ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both",	0);
	create_insn	(x=0X70DF);
	op_hex		(x,	1);
	set_cmt	(0X70E4,	"EXT_OPEN_ON",	0);
	create_insn	(x=0X70E4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0X70E4,	"dochk");
	set_cmt	(0X70EC,	"Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE\nES:DI -> uninitialized SFT, SS = DOS CS\nSDA first filename pointer -> fully-qualified name of file to open\nSDA CDS pointer -> current directory\nReturn: CF set on error",	0);
	create_insn	(0X70F1);
	set_name	(0X70F1,	"LOCAL_CREATE");
	set_cmt	(0X70F6,	"[ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both",	0);
	create_insn	(x=0X70F6);
	op_hex		(x,	1);
	set_name	(0X70FB,	"setdone");
	set_cmt	(0X7103,	"-1",	0);
	create_insn	(x=0X7103);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X710B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X710B,	"SET_MKND_ERR");
	create_byte	(0X7112);
	set_name	(0X7112,	"CRTERRTAB");
	set_cmt	(0X7113,	"error_access_denied ; MakeNode error 1",	0);
	create_byte	(0X7113);
	set_cmt	(0X7114,	"error_cannot_make",	0);
	create_byte	(x=0X7114);
	op_hex		(x,	0);
	set_cmt	(0X7115,	"error_file_exists",	0);
	create_byte	(0X7115);
	set_cmt	(0X7116,	"error_path_not_found",	0);
	create_byte	(0X7116);
	set_cmt	(0X7117,	"error_access_denied",	0);
	create_byte	(0X7117);
	set_cmt	(0X7118,	"error_sharing_violation ; MakeNode error 6",	0);
	create_byte	(0X7118);
	set_cmt	(0X7119,	"error_file_not_found ; MakeNode error 7",	0);
	create_byte	(0X7119);
	create_insn	(0X711A);
	set_name	(0X711A,	"Create_ok");
	create_insn	(x=0X711D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7120,	"attr_volume_id",	0);
	create_insn	(x=0X7120);
	op_hex		(x,	1);
	create_insn	(x=0X7124);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7128,	"[ES:DI+curdir.text] ; get drive letter",	0);
	set_cmt	(0X712B,	"convert to drive number",	0);
	set_cmt	(0X712E,	"Set flag to indicate volid change",	0);
	create_insn	(x=0X712E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7132,	"set volume id to boot record",	0);
	set_cmt	(0X713A,	"force a media check",	0);
	set_name	(0X7140,	"NoVolLabel");
	create_insn	(x=0X7143);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7147,	"call far [JShare+(14*4)] ; 14 = ShSU",	0);
	create_insn	(x=0X7147);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X7151);
	set_name	(0X7151,	"DOS_Create_New");
	create_insn	(0X7156);
	set_name	(0X7156,	"Set_Media_ID");
	set_cmt	(0X715D,	"generic IOCTL",	0);
	set_cmt	(0X715F,	"ch = FAT32 disk drive (CATEGORY CODE)\ncl = minor code,\n     get volume serial number (and name)",	0);
	set_cmt	(0X7162,	"Packet_Temp",	0);
	create_insn	(x=0X7162);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7172,	"is it FAT32 disk drive request?",	0);
	create_insn	(x=0X7172);
	op_hex		(x,	1);
	set_cmt	(0X7176,	"(ch=8 request failed!)",	0);
	set_cmt	(0X7178,	"set category code for (old) FAT disk drive\n(except FAT32)",	0);
	set_cmt	(0X717A,	"and try again",	0);
	create_insn	(0X717C);
	create_insn	(x=0X7180);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X7185);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X718A,	"MEDIA_ID_INFO.MEDIA_Label",	0);
	create_insn	(x=0X7192);
	op_dec		(x,	1);
	set_cmt	(0X7198,	"set volume serial number (and name)",	0);
	create_insn	(x=0X7198);
	op_hex		(x,	1);
	set_cmt	(0X719A,	"generic IOCTL",	0);
	set_cmt	(0X71A7,	"EXT_OPEN_ON ; from extended open",	0);
	create_insn	(x=0X71A7);
	op_hex		(x,	1);
	set_name	(0X71A7,	"Set_EXT_mode");
	set_cmt	(0X71AD,	"no, do normal",	0);
	set_cmt	(0X71B4,	"[ES:DI+SF_ENTRY.sf_mode]",	0);
	create_insn	(0X71BB);
	set_name	(0X71BB,	"DOS_OPEN");
	set_cmt	(0X71CB,	"[ES:DI+SF_ENTRY.sf_mode]",	0);
	set_cmt	(0X71D4,	"-1",	0);
	set_cmt	(0X71DA,	"EXT_OPEN_ON",	0);
	create_insn	(x=0X71DA);
	op_hex		(x,	1);
	set_cmt	(0X71DF,	"do normal",	0);
	set_name	(0X71E1,	"_IFS_extopen");
	set_cmt	(0X71E4,	"pass create attr to IFS",	0);
	set_cmt	(0X71E5,	"(MultNET*256)+46",	0);
	set_cmt	(0X71E8,	"Multiplex - DOS 4 IFSFUNC.EXE - ???\nSS = DS = DOS CS, STACK: WORD ??? low byte = ???\nReturn: CF set on error\nCF clear if successful",	0);
	create_insn	(x=0X71E8);
	op_hex		(x,	0);
	set_cmt	(0X71EA,	"trash bx",	0);
	set_name	(0X71EB,	"do_ret_label");
	set_cmt	(0X71EC,	"EXECOPEN",	0);
	create_insn	(x=0X71EC);
	op_hex		(x,	1);
	set_name	(0X71EC,	"_NOEXTOP");
	set_cmt	(0X71F3,	"(EXEC_AWARE_REDIR>>8)",	0);
	create_insn	(x=0X71F3);
	op_hex		(x,	1);
	set_cmt	(0X71FA,	"SHARING_DENY_WRITE+EXEC_OPEN",	0);
	create_insn	(x=0X71FA);
	op_hex		(x,	1);
	set_name	(0X71FC,	"not_exec_open");
	set_cmt	(0X7200,	"Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE\nES:DI -> uninitialized SFT, SS = DOS CS\nSDA first filename pointer -> fully-qualified name of file to open\nSTACK: WORD file open mode\nReturn: CF set on error",	0);
	create_insn	(x=0X7200);
	op_hex		(x,	0);
	set_cmt	(0X7204,	"[ES:SI+curdir.flags],curdir_isnet",	0);
	create_insn	(x=0X7204);
	op_hex		(x,	1);
	set_name	(0X7204,	"TEST_RE_NET1");
	set_cmt	(0X720D,	"EXT_OPEN_ON",	0);
	create_insn	(x=0X720D);
	op_hex		(x,	1);
	set_cmt	(0X7214,	"do_net_int2f",	0);
	create_insn	(0X7216);
	set_name	(0X7216,	"LOCAL_OPEN");
	set_cmt	(0X7219,	"FastOpen_Set+Special_Fill_Set",	0);
	create_insn	(x=0X7219);
	op_hex		(x,	1);
	set_cmt	(0X7229,	"error_file_not_found",	0);
	create_insn	(x=0X722C);
	op_hex		(x,	1);
	set_name	(0X722C,	"OpenBadRet");
	set_cmt	(0X7236,	"(retn)",	0);
	set_cmt	(0X7239,	"error_path_not_found",	0);
	create_insn	(0X7239);
	set_name	(0X7239,	"bad_path2");
	set_cmt	(0X723E,	"error_access_denied",	0);
	create_insn	(0X723E);
	set_name	(0X723E,	"Open_Bad_Access");
	create_insn	(0X7243);
	set_name	(0X7243,	"Open_found");
	set_cmt	(0X7247,	"Devices don't have attributes",	0);
	set_cmt	(0X7249,	"get buffer location",	0);
	set_cmt	(0X724D,	"[ES:BX+dir_entry.dir_attr]",	0);
	set_cmt	(0X7251,	"attr_volume_id",	0);
	create_insn	(x=0X7251);
	op_hex		(x,	1);
	set_cmt	(0X7253,	"can't open volume ids",	0);
	set_cmt	(0X7255,	"attr_read_only ; check write on read only",	0);
	create_insn	(x=0X7255);
	op_hex		(x,	1);
	set_cmt	(0X725F,	"[SI+SF_ENTRY.sf_mode]",	0);
	set_cmt	(0X7262,	"sf_isFCB ; is it FCB?",	0);
	create_insn	(x=0X7262);
	op_hex		(x,	1);
	set_cmt	(0X7266,	"yes, reset the access",	0);
	set_cmt	(0X726A,	"SHARING_MASK",	0);
	create_insn	(x=0X726A);
	op_hex		(x,	1);
	set_cmt	(0X726D,	"SHARING_NET_FCB ; is it net FCB?",	0);
	create_insn	(x=0X726D);
	op_hex		(x,	1);
	set_cmt	(0X7270,	"no",	0);
	set_cmt	(0X7272,	"~3 ; ~open_mode_mask ; clear access",	0);
	create_insn	(x=0X7272);
	op_hex		(x,	1);
	set_name	(0X7272,	"ResetAccess");
	set_cmt	(0X7275,	"[SI+SF_ENTRY.sf_mode]",	0);
	set_cmt	(0X727A,	"it was 'and cl,0Fh' in MSDOS 6.22 \n(and cl,access_mask)\nthis may be open_mode_mask",	0);
	create_insn	(x=0X727A);
	op_hex		(x,	1);
	set_name	(0X727A,	"NormalOpen");
	set_cmt	(0X727D,	"open_for_read ; is it open for read?",	0);
	set_cmt	(0X7280,	"yes",	0);
	create_insn	(0X7286);
	set_name	(0X7286,	"FillSFT");
	set_cmt	(0X7288,	"Fill in SFT",	0);
	set_name	(0X7288,	"open_ok");
	set_cmt	(0X728B,	"Fast_yes",	0);
	create_insn	(x=0X728B);
	op_hex		(x,	1);
	set_cmt	(0X7299,	"(retn)",	0);
	create_insn	(0X729B);
	set_name	(0X729B,	"SHARE_OK");
	create_insn	(x=0X729E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X72A2,	"call far [JShare+(14*4)] ; 14 = ShSU",	0);
	create_insn	(x=0X72A2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X72A9,	"Finish SFT initialization for new reference",	0);
	create_insn	(x=0X72A9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X72A9,	"SET_SFT_MODE");
	set_cmt	(0X72B0,	"[ES:DI+SF_ENTRY.sf_mode],sf_isFCB",	0);
	create_insn	(x=0X72B0);
	op_hex		(x,	1);
	set_cmt	(0X72B6,	"sf_mode correct",	0);
	create_insn	(x=0X72B8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X72BB,	"[ES:DI+SF_ENTRY.sf_PID]\nFor FCB sf_PID=PDB",	0);
	set_name	(0X72BF,	"Clear_FastOpen");
	set_cmt	(0X72C0,	"[ES:DI+SF_ENTRY.sf_mode],sf_isFCB",	0);
	create_insn	(x=0X72C0);
	op_hex		(x,	1);
	set_name	(0X72C0,	"SHARE_ERROR");
	set_cmt	(0X72C8,	"[ES:DI+SF_ENTRY.sf_mode]",	0);
	set_cmt	(0X72CC,	"SHARING_MASK",	0);
	create_insn	(x=0X72CC);
	op_hex		(x,	1);
	set_cmt	(0X72D7,	"User wants retry",	0);
	create_insn	(x=0X72D9);
	op_hex		(x,	1);
	set_cmt	(0X72DE,	"enter critical section",	0);
	create_insn	(0X72DE);
	set_name	(0X72DE,	"DO_SHARE_CHECK");
	create_insn	(x=0X72E1);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X72E5,	"Save number left to do",	0);
	set_cmt	(0X72E6,	"Final Check",	0);
	set_cmt	(0X72E9,	"CX = # left",	0);
	set_cmt	(0X72EA,	"No problem with access",	0);
	set_cmt	(0X72EF,	"One more retry used up",	0);
	create_insn	(x=0X72F1);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X72F8,	"User wants more retry",	0);
	set_cmt	(0X72FA,	"leave critical section",	0);
	set_cmt	(0X72FE,	"Sharing Mode (bit 4 to 7)\nAccess Mode (bit 0 to 3)",	0);
	create_insn	(x=0X72FE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X72FE,	"Check_Access_AX");
	set_cmt	(0X7304,	"SHARING_MASK",	0);
	create_insn	(x=0X7304);
	op_hex		(x,	1);
	create_insn	(x=0X7307);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X730C,	"not through server call, must be ok",	0);
	set_cmt	(0X730E,	"SHARING_NET_FCB",	0);
	create_insn	(x=0X730E);
	op_hex		(x,	1);
	set_cmt	(0X7311,	"we have an FCB",	0);
	set_cmt	(0X7313,	"is this a good sharing mode?",	0);
	create_insn	(x=0X7313);
	op_hex		(x,	1);
	set_cmt	(0X731A,	"access_mask = 0Fh",	0);
	create_insn	(x=0X731A);
	op_hex		(x,	1);
	set_cmt	(0X7325,	"error_invalid_access",	0);
	create_insn	(x=0X7325);
	op_hex		(x,	1);
	create_insn	(0X732B);
	set_name	(0X732B,	"DISK_INFO");
	set_cmt	(0X7330,	"free cluster count hw = 0",	0);
	set_cmt	(0X7332,	"number of clusters hw = 0",	0);
	set_cmt	(0X7337,	"Multiplex - NETWORK REDIRECTOR - GET DISK SPACE\nES:DI -> current directory\nReturn: AL = sectors per cluster, BX = total clusters\nCX = bytes per sector, DX = number of available clusters",	0);
	create_insn	(x=0X7337);
	op_hex		(x,	0);
	set_cmt	(0X7348,	"mov byte [EXTERR_LOCUS],errLOC_Disk",	0);
	create_insn	(0X7348);
	set_cmt	(0X734E,	"perform media check",	0);
	set_cmt	(0X7355,	"clear high word of cluster number",	0);
	create_insn	(x=0X7355);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7358,	"Get first FAT sector into CURBUF",	0);
	create_insn	(x=0X7363);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7367,	"[SI+BUFINSIZ] ; get FAT ID BYTE",	0);
	create_insn	(x=0X7367);
	op_dec		(x,	1);
	set_cmt	(0X7370,	"[ES:BP+DPB.FREE_CNT] ; get free count",	0);
	set_cmt	(0X7374,	"FAT32 (16 bit FAT size = 0) ?",	0);
	set_cmt	(0X7378,	"yes",	0);
	set_cmt	(0X737A,	"[ES:BP+DPB.MAX_CLUSTER]",	0);
	set_cmt	(0X737E,	"zf=0, si=di=0",	0);
	set_cmt	(0X7380,	"DPB.LAST_CLUSTER+2",	0);
	create_insn	(0X7380);
	set_cmt	(0X7384,	"DPB.LAST_CLUSTER",	0);
	set_cmt	(0X7388,	"DPB.FREE_CNT_HW ; hw of free cluster count",	0);
	set_cmt	(0X738C,	"same (zero) ?",	0);
	set_cmt	(0X738E,	"not same (not zero)",	0);
	set_cmt	(0X7391,	"0FFFFh -> 0 (free count is invalid/initial)\nfree count calculation is needed",	0);
	set_cmt	(0X7394,	"same hw ?",	0);
	set_cmt	(0X7396,	"no",	0);
	set_cmt	(0X7398,	"same lw ?",	0);
	set_cmt	(0X739A,	"free cluster count < last cluster number",	0);
	set_cmt	(0X739C,	"0",	0);
	set_cmt	(0X739E,	"0",	0);
	set_cmt	(0X73A0,	"last cluster number - 1 = number of clusters",	0);
	set_cmt	(0X73A5,	"DPB.FIRST_ACCESS ; set first access",	0);
	create_insn	(x=0X73A5);
	op_hex		(x,	1);
	set_cmt	(0X73BD,	"a free one",	0);
	set_cmt	(0X73C0,	"increase hw of free cluster count",	0);
	set_cmt	(0X73C1,	"next cluster",	0);
	set_cmt	(0X73C4,	"increase hw of (next) cluster number",	0);
	set_cmt	(0X73C8,	"decrease remain cluster count for calculation",	0);
	set_cmt	(0X73D0,	"calculation completed",	0);
	create_insn	(0X73D4);
	set_cmt	(0X73DB,	"di:bx = last cluster number",	0);
	set_cmt	(0X73E3,	"di:bx = number of clusters",	0);
	set_cmt	(0X73E5,	"[ES:BP+DPB.CLUSTER_MASK] ; spc - 1",	0);
	set_cmt	(0X73E9,	"sectors per cluster",	0);
	set_cmt	(0X73EB,	"[ES:BP+DPB.FREE_CNT] ; free cluster count, lw",	0);
	set_cmt	(0X73EF,	"FAT32 (16 bit FAT size = 0) ?",	0);
	set_cmt	(0X73F3,	"no",	0);
	set_cmt	(0X73F5,	"DPB.FREE_CNT_HW ; hw of free cluster count",	0);
	set_cmt	(0X73FC,	"[ES:BP+DPB.SECTOR_SIZE] ; bytes per sector",	0);
	create_insn	(0X7405);
	set_cmt	(0X7409,	"ax = sectors per cluster",	0);
	create_insn	(0X7409);
	set_name	(0X7409,	"modify_spc");
	set_cmt	(0X740B,	"bytes per sector",	0);
	set_cmt	(0X7412,	"16 kilobytes (per cluster)\n***\nactual disk size limit \nwithout invalidating cluster counts is\n2 GB (512K clusters * 8 sectors per cluster)\n     (128K clusters * 32 sectors per cluster)",	0);
	create_insn	(x=0X7412);
	op_dec		(x,	1);
	set_name	(0X7415,	"mspc_1");
	set_cmt	(0X7417,	"bytes per cluster <= 16 KB\n***\nbytes per cluster > 16 KB",	0);
	set_cmt	(0X7419,	"0",	0);
	set_cmt	(0X741B,	"(invalidated)",	0);
	set_cmt	(0X741E,	"hw of free cluster count",	0);
	set_cmt	(0X7420,	"si = 0",	0);
	set_cmt	(0X7422,	"si = 0",	0);
	set_cmt	(0X7424,	"dx = bx = 0FFFEh (invalidated)",	0);
	set_name	(0X7426,	"mspc_2");
	set_cmt	(0X7427,	"sectors per clust = sectors per clust * 2\n(ax <= 32768)",	0);
	create_insn	(x=0X7427);
	op_hex		(x,	1);
	set_name	(0X7427,	"mspc_3");
	set_cmt	(0X7429,	"cluster count = cluster count /2\ndi:bx = modified value of total clusters",	0);
	create_insn	(x=0X7429);
	op_hex		(x,	1);
	create_insn	(x=0X742B);
	op_hex		(x,	1);
	set_name	(0X742B,	"mspc_4");
	set_cmt	(0X742D,	"free clusters = free clusters / 2",	0);
	create_insn	(x=0X742D);
	op_hex		(x,	1);
	set_cmt	(0X742F,	"si:dx = modified value of free clusters",	0);
	create_insn	(x=0X742F);
	op_hex		(x,	1);
	set_cmt	(0X7431,	"hw of cluster count",	0);
	set_name	(0X7431,	"modify_cluster_count");
	create_insn	(0X7436);
	set_name	(0X7436,	"update_fat32_fsinfo");
	set_cmt	(0X743A,	"DPB.FSINFO_SECTOR",	0);
	set_cmt	(0X743E,	"DPB.FAT_SIZE\n(16bit FAT size field = 0 for FAT32 fs)",	0);
	set_cmt	(0X7444,	"-1",	0);
	set_cmt	(0X744B,	"clear bit 0,1 and 3\nbit 0 - FSINFO update (dirty) bit\nbit 1 - BPB_RootClus update bit\nbit 3 - BPB_ExtFlags update bit",	0);
	create_insn	(x=0X744B);
	op_hex		(x,	1);
	create_insn	(0X7451);
	set_cmt	(0X7456,	"is buffers in HMA?",	0);
	set_cmt	(0X745C,	"no",	0);
	set_cmt	(0X745E,	"read it into scratch buffer",	0);
	set_cmt	(0X7463,	"BUFINSIZ ; space for buffer header\n(buffer header size = 24)",	0);
	create_insn	(x=0X7463);
	op_dec		(x,	1);
	create_insn	(0X7469);
	set_cmt	(0X746B,	"ds:di = first buffer in queue",	0);
	set_cmt	(0X746F,	"BufWrite writes a buffer to the disk,\n if it's dirty.",	0);
	set_cmt	(0X7479,	"buffer data address",	0);
	create_insn	(x=0X7479);
	op_dec		(x,	1);
	set_cmt	(0X747C,	"Allowed_FAIL+Allowed_RETRY",	0);
	set_cmt	(0X7482,	"0",	0);
	set_cmt	(0X7487,	"cx = sector count\nes:bp = DPB",	0);
	set_cmt	(0X7488,	"ds:bx = buffer (data) address",	0);
	set_cmt	(0X7489,	"HIGH_SECTOR:dx = disk sector address",	0);
	set_cmt	(0X748A,	"read fs info sector",	0);
	set_cmt	(0X7491,	"'RR'",	0);
	set_cmt	(0X7497,	"'aA' ; (NASM syntax)",	0);
	set_cmt	(0X749E,	"'rr' at offset 484",	0);
	set_cmt	(0X74A6,	"'Aa' at offset 486",	0);
	set_cmt	(0X74AE,	"boot signature at offset 510",	0);
	set_cmt	(0X74B6,	"DPB.FREE_CNT",	0);
	set_cmt	(0X74BA,	"FSINFO.Free_Count at offset 488",	0);
	set_cmt	(0X74BE,	"DPB.FREE_CNT+2",	0);
	set_cmt	(0X74C2,	"FSINFO.Free_Count+2",	0);
	set_cmt	(0X74C6,	"DPB.FAT32_NXTFREE",	0);
	set_cmt	(0X74CA,	"FSINFO.Nxt_Free at offset 492",	0);
	set_cmt	(0X74CE,	"DPB.FAT32_NXTFREE+2",	0);
	set_cmt	(0X74D2,	"FSINFO.Nxt_Free+2",	0);
	set_cmt	(0X74D8,	"0",	0);
	set_cmt	(0X74DD,	"1",	0);
	create_insn	(x=0X74E9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X74E9,	"DOS_SEARCH_FIRST");
	set_cmt	(0X74ED,	"-1",	0);
	set_cmt	(0X74F2,	"(MultNET<<8)|25",	0);
	set_cmt	(0X74F5,	"Multiplex - NETWORK REDIRECTOR - ???",	0);
	create_insn	(x=0X74F5);
	op_hex		(x,	0);
	set_cmt	(0X74F8,	"[ES:DI+curdir.flags+1],\ncurdir_isnet>>8",	0);
	create_insn	(x=0X74F8);
	op_hex		(x,	1);
	set_cmt	(0X74FF,	"(MultNET<<8)|27",	0);
	set_cmt	(0X7502,	"Multiplex - NETWORK REDIRECTOR - FINDFIRST\nSS = DS = DOS CS, [DTA] = uninitialized 21-byte findfirst search data\nSDA first filename pointer -> fully-qualified search template\nSDA CDS pointer -> current directory\nReturn: CF set on error",	0);
	create_insn	(x=0X7502);
	op_hex		(x,	0);
	create_insn	(0X7505);
	set_cmt	(0X7508,	"(SEARCH_FASTOPEN>>8)",	0);
	create_insn	(x=0X7508);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X750F,	"FastOpen_Set",	0);
	create_insn	(x=0X750F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X7514,	"if we find a dir, don't change to it",	0);
	create_insn	(x=0X7514);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X7519,	"CHECK_QUESTION");
	set_cmt	(0X751D,	"ds:si -> final path",	0);
	set_cmt	(0X7521,	"get char",	0);
	set_cmt	(0X7522,	"is it null ?",	0);
	set_cmt	(0X7524,	"yes",	0);
	set_cmt	(0X7526,	"is '?'",	0);
	set_cmt	(0X7528,	"no",	0);
	set_cmt	(0X752A,	"Fast_yes ; reset fastopen",	0);
	create_insn	(x=0X752A);
	op_hex		(x,	1);
	set_cmt	(0X753A,	"error_no_more_files",	0);
	set_name	(0X753A,	"find_no_more");
	set_cmt	(0X753D,	"Fast_yes  ; reset fastopen",	0);
	create_insn	(x=0X753D);
	op_hex		(x,	1);
	set_cmt	(0X7548,	"error_path_not_found",	0);
	create_insn	(0X7548);
	create_insn	(0X754D);
	set_cmt	(0X7551,	"Cause DOS_SEARCH_NEXT to fail",	0);
	set_cmt	(0X7557,	"Tell DOS_RENAME we found a device",	0);
	set_cmt	(0X755F,	"get pointer to beginning",	0);
	set_cmt	(0X7564,	"'A'-1  ; logical drive",	0);
	set_cmt	(0X7566,	"High bit not set (local)",	0);
	set_name	(0X7567,	"found_it");
	set_cmt	(0X756D,	"Set_For_Search ; from fastopen",	0);
	create_insn	(x=0X756D);
	op_hex		(x,	1);
	set_cmt	(0X757C,	"find_buf 2 = formatted name",	0);
	create_insn	(x=0X757C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X7592);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7596,	"Save AH device info",	0);
	create_insn	(x=0X7597);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X759B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X759F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X75A6,	"Recover AH device info",	0);
	set_cmt	(0X75A9,	"Device entry is DOSGROUP relative",	0);
	set_cmt	(0X75AB,	"-1",	0);
	create_insn	(x=0X75AB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X75B2,	"Set_For_Search\nfrom fastopen and is good",	0);
	create_insn	(x=0X75B2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X75B9,	"Cause DOS_SEARCH_NEXT to fail\nby stuffing a -1 at Lastent",	0);
	create_insn	(x=0X75C2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X75C6,	"start of entry",	0);
	set_cmt	(0X75C8,	"dir_entry.size>>1",	0);
	create_insn	(x=0X75C8);
	op_dec		(x,	1);
	set_cmt	(0X75CB,	"save the 1st byte addr",	0);
	set_cmt	(0X75CF,	"restore 1st byte addr",	0);
	set_cmt	(0X75D1,	"special char check",	0);
	set_cmt	(0X75D7,	"convert it back to E5",	0);
	set_cmt	(0X75DB,	"Fast_yes",	0);
	create_insn	(x=0X75DB);
	op_hex		(x,	1);
	set_cmt	(0X75E8,	"DOS_SEARCH_NEXT (MSDOS 6.22, Win ME)",	0);
	create_insn	(0X75E8);
	set_name	(0X75E8,	"DOS_SEARCH_NEXT_X");
	create_insn	(0X75EC);
	set_name	(0X75EC,	"DOS_SEARCH_NEXT");
	set_cmt	(0X75EF,	"Test for NET",	0);
	create_insn	(x=0X75EF);
	op_hex		(x,	1);
	set_cmt	(0X75F3,	"(MultNET<<8)|28",	0);
	set_cmt	(0X75F6,	"Multiplex - NETWORK REDIRECTOR - FINDNEXT\nSS = DS = DOS CS, [DTA] = 21-byte findfirst search data\nReturn: CF set on error, AX = DOS error code\nCF clear if successful",	0);
	create_insn	(x=0X75F6);
	op_hex		(x,	0);
	set_cmt	(0X75F9,	"errLOC_Disk",	0);
	create_insn	(0X75F9);
	create_insn	(x=0X7601);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X760B,	"'A' - 1",	0);
	set_cmt	(0X7610,	"Bogus drive letter",	0);
	set_cmt	(0X7612,	"Get CDS pointer",	0);
	set_cmt	(0X7616,	"[ES:DI+curdir.devptr] ; Get DPB pointer",	0);
	set_cmt	(0X7629,	"(DIRFREE*256)+0",	0);
	set_cmt	(0X762F,	"if we find a dir, don't change to it",	0);
	set_cmt	(0X7638,	"Drive Byte",	0);
	create_insn	(0X7639);
	set_name	(0X7639,	"RENAME_NEXT");
	create_insn	(x=0X763D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7640,	"Search name",	0);
	set_cmt	(0X7646,	"Attribute",	0);
	set_cmt	(0X764B,	"LastEnt",	0);
	set_cmt	(0X7650,	"Save LastEnt",	0);
	set_name	(0X7650,	"cont_load");
	set_cmt	(0X7651,	"DirStart",	0);
	set_cmt	(0X7654,	"DIRSTART_HW",	0);
	set_cmt	(0X7659,	"Recover ES:BP",	0);
	set_cmt	(0X765D,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0X7662,	"FAT32 fs",	0);
	set_cmt	(0X7664,	"0",	0);
	set_cmt	(0X7666,	"0 or DIRSTART_HW",	0);
	set_name	(0X766E,	"SEARCH_GOON");
	set_cmt	(0X767C,	"If Search_Next, can't be a DEV",	0);
	set_cmt	(0X7681,	"Clean stack",	0);
	create_insn	(0X7681);
	set_name	(0X7682,	"No_files");
	create_insn	(0X7685);
	set_name	(0X7685,	"DOS_ABORT");
	set_cmt	(0X768A,	"[ES:PDB.JFN_Length] ; Number of JFNs",	0);
	set_cmt	(0X7692,	"get jfn (start with last one)",	0);
	set_cmt	(0X7697,	"and do 'em all",	0);
	set_cmt	(0X769E,	"Multiplex - NETWORK REDIRECTOR - CLOSE ALL REMOTE FILES FOR PROCESS\nDS???, SS = DOS CS",	0);
	create_insn	(x=0X769E);
	op_hex		(x,	0);
	set_cmt	(0X76A0,	"call far [JShare+(4*4)] ; 4 = MFTCloseP",	0);
	set_cmt	(0X76A4,	"(FCB cache) grab the pointer to the table",	0);
	set_cmt	(0X76AD,	"(FCB cache table) not installed",	0);
	set_cmt	(0X76B0,	"[es:di+SFT.SFCount]",	0);
	set_cmt	(0X76B6,	"[DI+SFT.SFTable]",	0);
	set_cmt	(0X76BD,	"[es:di+SF_ENTRY.sf_PID]",	0);
	set_cmt	(0X76C1,	"not one of ours, skip it",	0);
	set_cmt	(0X76C3,	"blast ref count",	0);
	set_cmt	(0X76C6,	"SF_ENTRY.size",	0);
	create_insn	(x=0X76C6);
	op_dec		(x,	1);
	set_cmt	(0X76DE,	"sf_busy ; -1\nIs Sft busy?",	0);
	create_insn	(0X76DE);
	set_cmt	(0X76E2,	"no",	0);
	set_cmt	(0X76E8,	"[es:di+SF_ENTRY.sf_PID]",	0);
	set_cmt	(0X76F2,	"[es:di+SF_ENTRY.sf_UID]",	0);
	create_insn	(0X76FE);
	set_name	(0X76FE,	"DOS_CLOSE");
	set_cmt	(0X7702,	"[ES:DI+SF_ENTRY.sf_flags]",	0);
	set_cmt	(0X7706,	"(sf_isnet>>8)",	0);
	create_insn	(x=0X7706);
	op_hex		(x,	1);
	set_cmt	(0X770E,	"Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE\nES:DI -> SFT\nSFT DPB field -> DPB of drive containing file\nReturn: CF set on error, AX = DOS error code\nCF clear if successful",	0);
	create_insn	(x=0X770E);
	op_hex		(x,	0);
	create_insn	(0X7711);
	set_name	(0X7711,	"LocalClose");
	set_cmt	(0X7717,	"dec ref count or mark as busy",	0);
	set_name	(0X7723,	"CloseEntry");
	set_cmt	(0X7724,	"devid_file_clean+devid_device",	0);
	create_insn	(x=0X7724);
	op_hex		(x,	1);
	create_insn	(0X772D);
	set_name	(0X772D,	"rdir");
	set_cmt	(0X7730,	"error_access_denied",	0);
	set_cmt	(0X7734,	"[SI+SF_ENTRY.sf_mode],\ndevid_device_null ; bit 2 - null device",	0);
	create_insn	(x=0X7734);
	op_hex		(x,	1);
	set_cmt	(0X773D,	"[si+SF_ENTRY.sf_devptr]",	0);
	set_cmt	(0X7740,	"DPB.DRIVE",	0);
	set_cmt	(0X7742,	"0",	0);
	set_cmt	(0X7744,	"bit 2 - last access date/time flag?",	0);
	create_insn	(x=0X7744);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X774B,	"no support for last access date&time",	0);
	set_cmt	(0X7752,	"[es:di+dir_entry.dir_lstaccdate]",	0);
	set_name	(0X7756,	"skip_upd_laccdt");
	set_name	(0X7757,	"clook");
	set_cmt	(0X7759,	"[SI+SF_ENTRY.sf_name]",	0);
	set_cmt	(0X7767,	"Name OK",	0);
	set_name	(0X7769,	"Bye");
	set_cmt	(0X776C,	"ES:DI points to SFT",	0);
	set_cmt	(0X7770,	"error_file_not_found",	0);
	set_name	(0X7772,	"jmp_to_CloseFinish");
	set_cmt	(0X7775,	"[SI+SF_ENTRY.sf_attr]",	0);
	create_insn	(0X7775);
	set_name	(0X7775,	"CLOSE_GO");
	set_cmt	(0X7778,	"[SI+SF_ENTRY.sf_mode],sf_isFCB",	0);
	create_insn	(x=0X7778);
	op_hex		(x,	1);
	set_cmt	(0X777F,	"[ES:DI+dir_entry.dir_attr]",	0);
	set_cmt	(0X7789,	"[ES:DI+dir_entry.dir_attr]",	0);
	create_insn	(0X7789);
	set_name	(0X7789,	"nofcb");
	set_cmt	(0X778D,	"[ES:DI+dir_entry.dir_attr],\nattr_archive",	0);
	create_insn	(x=0X778D);
	op_hex		(x,	1);
	set_name	(0X778D,	"setattr");
	set_cmt	(0X7792,	"[ES:DI+dir_entry.dir_first]",	0);
	set_cmt	(0X7796,	"save old first cluster",	0);
	set_cmt	(0X779A,	"[ES:DI+dir_entry.dir_fclus_hi]",	0);
	set_cmt	(0X77A2,	"[SI+SF_ENTRY.sf_chain]\nfirst cluster (32 bit) low word !?",	0);
	set_cmt	(0X77A5,	"[ES:DI+dir_entry.dir_first]",	0);
	set_cmt	(0X77A9,	"[SI+SF_ENTRY.sf_chain+2]\nfirst cluster (32 bit) high word !?",	0);
	set_cmt	(0X77AC,	"[ES:DI+dir_entry.dir_fclus_hi]",	0);
	set_cmt	(0X77B1,	"[SI+SF_ENTRY.sf_size]",	0);
	set_cmt	(0X77B4,	"[ES:DI+dir_entry.dir_size_l]",	0);
	set_cmt	(0X77B8,	"[ES:DI+dir_entry.dir_size_h]",	0);
	set_cmt	(0X77BE,	"[SI+SF_ENTRY.sf_time]",	0);
	set_cmt	(0X77C1,	"[ES:DI+dir_entry.dir_time]",	0);
	set_cmt	(0X77C5,	"[ES:DI+dir_entry.dir_date]",	0);
	set_cmt	(0X77CA,	"[ES:BX+BUFFINFO.buf_flags],\nbuf_dirty",	0);
	create_insn	(x=0X77CA);
	op_hex		(x,	1);
	set_cmt	(0X77D4,	"[ES:BX+BUFFINFO.buf_flags],\nbuf_dirty",	0);
	create_insn	(x=0X77D4);
	op_hex		(x,	1);
	set_name	(0X77D9,	"yesdirty4");
	set_cmt	(0X77DB,	"[es:di+SF_ENTRY.sf_chain]\nfirst cluster (32 bit) low word !?",	0);
	set_cmt	(0X77E3,	"dir entry update",	0);
	set_cmt	(0X77E8,	"[es:di+SF_ENTRY.sf_chain+2]\nfirst cluster (32 bit) high word !?",	0);
	set_cmt	(0X77F3,	"do a delete cache entry",	0);
	set_cmt	(0X77F5,	"[SI+SF_ENTRY.sf_dirpos]",	0);
	set_cmt	(0X77F8,	"[SI+SF_ENTRY.sf_dirsec]",	0);
	set_cmt	(0X77FB,	"cx:di = dir sector",	0);
	set_cmt	(0X77FF,	"same as old first cluster?",	0);
	create_insn	(0X77FF);
	set_name	(0X77FF,	"do_update2");
	set_cmt	(0X7804,	"no",	0);
	set_cmt	(0X780B,	"yes",	0);
	set_cmt	(0X780D,	"delete the old entry",	0);
	set_name	(0X780D,	"do_update3");
	set_name	(0X7819,	"do_update");
	set_cmt	(0X781D,	"invoke fastopen",	0);
	set_cmt	(0X7824,	"flush all relevant buffers",	0);
	set_cmt	(0X7829,	"error_access_denied",	0);
	set_cmt	(0X782D,	"[ES:DI+SF_ENTRY.sf_flags],\nsf_isnet+devid_device",	0);
	create_insn	(x=0X782D);
	op_hex		(x,	1);
	set_name	(0X782D,	"FREE_SFT_OK");
	set_cmt	(0X7837,	"[ES:DI+SF_ENTRY.sf_devptr]",	0);
	create_insn	(0X7842);
	set_name	(0X7842,	"CloseFinish");
	set_cmt	(0X7844,	"[ES:DI+SF_ENTRY.sf_devptr]",	0);
	set_cmt	(0X7848,	"DPB.DRIVE",	0);
	set_cmt	(0X784A,	"0",	0);
	set_cmt	(0X784C,	"clear bit 2",	0);
	create_insn	(x=0X784C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0X7855,	"CloseFinish2");
	create_insn	(0X7859);
	set_name	(0X7861,	"NoFree");
	create_insn	(0X7866);
	set_name	(0X7866,	"FREE_SFT");
	set_cmt	(0X7867,	"[ES:DI+SF_ENTRY.sf_ref_count]",	0);
	create_insn	(0X7873);
	set_name	(0X7873,	"DirFromSFT");
	set_cmt	(0X7878,	"[ES:DI+SF_ENTRY.sf_dirsec+2]",	0);
	create_insn	(x=0X787C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7881,	"[ES:DI+SF_ENTRY.sf_dirsec]",	0);
	create_insn	(x=0X788A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7892,	"Allowed_FAIL+Allowed_RETRY",	0);
	create_insn	(x=0X7892);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X78A3,	"[ES:DI+BUFFINFO.buf_flags],\nbuf_isDIR",	0);
	create_insn	(x=0X78A3);
	op_hex		(x,	1);
	set_cmt	(0X78AA,	"[DI+BUFINSIZ] ; Point to buffer",	0);
	set_cmt	(0X78AD,	"dir_entry.size",	0);
	create_insn	(x=0X78AD);
	op_dec		(x,	1);
	set_cmt	(0X78AF,	"[SI+SF_ENTRY.sf_dirpos]",	0);
	set_cmt	(0X78B2,	"Point at the entry",	0);
	set_cmt	(0X78B4,	"carry is clear",	0);
	create_insn	(0X78B5);
	set_name	(0X78B7,	"PopDone_retn");
	create_insn	(x=0X78B8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X78B8,	"DOS_COMMIT");
	create_insn	(x=0X78C0);
	op_hex		(x,	1);
	create_insn	(x=0X78C5);
	op_hex		(x,	1);
	set_cmt	(0X78CD,	"Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE\nES:DI -> SFT\nSFT DPB field -> DPB of drive containing file\nReturn: CF set on error, AX = DOS error code\nCF clear if successful",	0);
	create_insn	(x=0X78CD);
	op_hex		(x,	0);
	set_name	(0X78CF,	"localcommit_retn");
	create_insn	(0X78D0);
	create_insn	(0X78DC);
	set_cmt	(0X78E3,	"sf_close_nodate+devid_file_clean+devid_device",	0);
	create_insn	(x=0X78E3);
	op_hex		(x,	1);
	set_name	(0X78E3,	"SetSFTTimes");
	set_cmt	(0X78EB,	"Date/Time to AX/DX",	0);
	set_cmt	(0X78EE,	"[ES:DI+SF_ENTRY.sf_date]",	0);
	set_cmt	(0X78F2,	"[ES:DI+SF_ENTRY.sf_time]",	0);
	set_cmt	(0X78F8,	"call far [JShare+(14*4)] ; 14 = ShSU",	0);
	create_insn	(x=0X78F8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X78FF);
	set_name	(0X78FF,	"DOS_MKDIR");
	set_cmt	(0X7907,	"Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY\nSS = DOS CS\nSDA first filename pointer -> fully-qualified directory name\nSDA CDS pointer -> current directory \nReturn: CF set on error, AX = DOS error code\nCF clear if successful",	0);
	create_insn	(x=0X7907);
	op_hex		(x,	0);
	set_cmt	(0X790A,	"error_access_denied",	0);
	create_insn	(0X790A);
	set_name	(0X790A,	"NODEACCERRJ");
	set_name	(0X790D,	"_BadRet");
	create_insn	(0X7912);
	set_name	(0X7912,	"PATHNFJ");
	create_insn	(0X7918);
	set_name	(0X7918,	"LOCAL_MKDIR");
	create_insn	(x=0X791B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X791F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7925,	"[RENBUF+SF_ENTRY.sf_MFT]\nmake sure SHARER won't complain.",	0);
	create_insn	(x=0X7925);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X792B,	"attr_directory",	0);
	set_cmt	(0X7935,	"Can't make a device into a directory",	0);
	set_cmt	(0X7937,	"Makenode zaps this",	0);
	create_insn	(x=0X7937);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X793B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7941,	"Pointer to dir_first",	0);
	set_cmt	(0X7942,	"[DI+BUFFINFO.buf_sector]",	0);
	set_cmt	(0X794B,	"0",	0);
	set_cmt	(0X794D,	"Null directory",	0);
	set_cmt	(0X7955,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0X795A,	"not FAT32",	0);
	set_cmt	(0X795C,	"[es:bp+DPB.ROOT_CLUSTER]",	0);
	set_cmt	(0X7962,	"[es:bp+DPB.ROOT_CLUSTER+2]",	0);
	set_cmt	(0X796A,	"dx:ax = 0 for root directory",	0);
	set_name	(0X796C,	"LOCAL_MKDIR_cont");
	create_insn	(x=0X797F);
	op_dec		(x,	1);
	set_name	(0X797F,	"yesdirty5");
	set_cmt	(0X7982,	"\". \" ; (NASM syntax)",	0);
	set_cmt	(0X7994,	"\"..\"",	0);
	set_cmt	(0X7997,	"Parent",	0);
	set_cmt	(0X79A3,	"Allowed_FAIL+Allowed_RETRY",	0);
	set_cmt	(0X79A8,	"Entry sector",	0);
	set_cmt	(0X79AF,	"Pre read",	0);
	set_cmt	(0X79BF,	"[DI+BUFFINFO.buf_flags],buf_isDIR",	0);
	create_insn	(x=0X79BF);
	op_hex		(x,	1);
	set_cmt	(0X79C3,	"dir_first pointer",	0);
	set_cmt	(0X79C6,	"dir_entry.dir_first",	0);
	set_cmt	(0X79C8,	"dir_entry.dir_fclus_hi",	0);
	set_cmt	(0X79CD,	"Zero size",	0);
	set_cmt	(0X79D3,	"[DI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0X79D3);
	op_hex		(x,	1);
	set_name	(0X79D3,	"DIRUP");
	set_cmt	(0X79D7,	"already dirty",	0);
	set_cmt	(0X79DC,	"[DI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0X79DC);
	op_hex		(x,	1);
	set_name	(0X79E0,	"yesdirty6");
	set_cmt	(0X79E5,	"[ES:BP+DPB.DRIVE]",	0);
	set_cmt	(0X79EC,	"error_access_denied",	0);
	set_cmt	(0X79F2,	"Parent",	0);
	create_insn	(0X79F2);
	set_name	(0X79F2,	"NODEEXISTSPOPDEL");
	set_cmt	(0X79F4,	"Entry sector",	0);
	set_cmt	(0X79FD,	"Allowed_FAIL+Allowed_RETRY",	0);
	set_cmt	(0X7A04,	"Pre read",	0);
	set_cmt	(0X7A0D,	"[DI+BUFFINFO.buf_flags],buf_isDIR",	0);
	create_insn	(x=0X7A0D);
	op_hex		(x,	1);
	set_cmt	(0X7A11,	"dir_first pointer",	0);
	set_cmt	(0X7A14,	"dir_entry.dir_first\nPoint back to start of dir entry",	0);
	create_insn	(x=0X7A14);
	op_dec		(x,	1);
	set_cmt	(0X7A17,	"Free the entry",	0);
	set_cmt	(0X7A1A,	"Error doesn't matter since erroring anyway",	0);
	set_cmt	(0X7A20,	"Clean stack",	0);
	create_insn	(0X7A20);
	set_name	(0X7A20,	"NODEEXISTSP");
	create_insn	(0X7A23);
	set_name	(0X7A23,	"DOS_CHDIR");
	set_cmt	(0X7A2B,	"Multiplex - NETWORK REDIRECTOR - CHDIR\nSS = DOS CS\nSDA first filename pointer -> fully-qualified directory name\nSDA CDS pointer -> current directory \nReturn: CF set on error, AX = DOS error code\nCF clear if successful",	0);
	create_insn	(x=0X7A2B);
	op_hex		(x,	0);
	create_insn	(0X7A2E);
	set_cmt	(0X7A31,	"[ES:DI+curdir.flags+1],\n(curdir_splice>>8)",	0);
	create_insn	(x=0X7A31);
	op_hex		(x,	1);
	set_cmt	(0X7A38,	"[ES:DI+curdir.ID+2]",	0);
	set_cmt	(0X7A3E,	"[ES:DI+curdir.ID]",	0);
	set_cmt	(0X7A44,	"FALSE",	0);
	create_insn	(x=0X7A44);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7A49,	"attr_directory+attr_system+attr_hidden",	0);
	create_insn	(x=0X7A49);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7A4E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X7A57,	"FastOpen_Set ; set fastopen flag",	0);
	create_insn	(x=0X7A57);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X7A5D,	"error_path_not_found",	0);
	set_cmt	(0X7A62,	"Path not a DIR",	0);
	create_insn	(x=0X7A64);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X7A6B);
	set_name	(0X7A6B,	"DOS_RMDIR");
	set_cmt	(0X7A73,	"Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY\nSS = DOS CS\nSDA first filename pointer -> fully-qualified directory name\nSDA CDS pointer -> current directory \nReturn: CF set on error, AX = DOS error code\nCF clear if successful",	0);
	create_insn	(x=0X7A73);
	op_hex		(x,	0);
	create_insn	(0X7A76);
	create_insn	(x=0X7A79);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7A7E,	"attr_directory+attr_system+attr_hidden",	0);
	create_insn	(x=0X7A7E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7A86,	"Path not found",	0);
	set_cmt	(0X7A88,	"Path not a DIR",	0);
	create_insn	(x=0X7A8A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7A8E,	"Root ?",	0);
	set_cmt	(0X7A90,	"No",	0);
	create_insn	(x=0X7A92);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7A97,	"root directory",	0);
	set_cmt	(0X7A99,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0X7A9E,	"not FAT32",	0);
	set_cmt	(0X7AA0,	"[es:bp+DPB.ROOT_CLUSTER]",	0);
	create_insn	(x=0X7AA6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7AAA,	"[es:bp+DPB.ROOT_CLUSTER+2]",	0);
	set_cmt	(0X7AB2,	"error_path_not_found",	0);
	create_insn	(0X7AB2);
	create_insn	(0X7AB8);
	set_name	(0X7AB8,	"NOTDIRPATHPOP");
	set_name	(0X7ABA,	"NOTDIRPATHPOP2");
	set_name	(0X7ABB,	"NOTDIRPATH");
	create_insn	(x=0X7ABE);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X7ABE,	"rmdir_get_buf");
	set_cmt	(0X7AC2,	"Compute true offset",	0);
	set_cmt	(0X7AC4,	"Save entry pointer",	0);
	set_cmt	(0X7AC5,	"[DI+BUFFINFO.buf_sector]",	0);
	set_cmt	(0X7AC8,	"Save sector number",	0);
	create_insn	(x=0X7ACE);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X7AD4);
	op_dec		(x,	1);
	set_cmt	(0X7AD7,	"al = '?'",	0);
	set_cmt	(0X7AD9,	"ah = 0 ; Nul terminate it",	0);
	set_cmt	(0X7ADA,	"Set search",	0);
	set_cmt	(0X7ADD,	"Get start of directory",	0);
	set_cmt	(0X7AE0,	"Screw up",	0);
	set_cmt	(0X7AE9,	"First entry '.'?",	0);
	set_cmt	(0X7AEC,	"Nope",	0);
	set_cmt	(0X7AEE,	"Next entry",	0);
	create_insn	(x=0X7AEE);
	op_dec		(x,	1);
	set_cmt	(0X7AF2,	"Second entry '..'?",	0);
	set_cmt	(0X7AF5,	"Nope",	0);
	set_cmt	(0X7AF9,	"Skip . and ..",	0);
	set_cmt	(0X7AFF,	"Get next entry",	0);
	set_cmt	(0X7B02,	"Screw up",	0);
	set_cmt	(0X7B04,	"attr_directory+attr_hidden+attr_system",	0);
	set_cmt	(0X7B09,	"Do a search",	0);
	set_cmt	(0X7B13,	"Failure of search due to I 24 FAIL",	0);
	set_cmt	(0X7B25,	"Release data in sub dir",	0);
	set_cmt	(0X7B37,	"Pre read",	0);
	set_cmt	(0X7B39,	"Get sector back",	0);
	create_insn	(0X7B41);
	set_name	(0X7B41,	"rmdir_fde");
	set_cmt	(0X7B45,	"[DI+BUFFINFO.buf_flags],buf_isDIR",	0);
	create_insn	(x=0X7B45);
	op_hex		(x,	1);
	set_cmt	(0X7B49,	"Pointer to start of entry",	0);
	set_cmt	(0X7B4A,	"Corrected",	0);
	set_cmt	(0X7B4C,	"Free the entry",	0);
	create_insn	(x=0X7B59);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X7B59,	"SWAPBACK");
	create_insn	(0X7B5F);
	set_name	(0X7B5F,	"SWAPCON");
	create_insn	(x=0X7B60);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7B63,	"ConSwap = TRUE",	0);
	create_insn	(x=0X7B63);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7B68);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7B6B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X7B6E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X7B73);
	set_name	(0X7B73,	"dos_read_acc_err");
	create_insn	(x=0X7B76);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X7B76,	"DOS_READ");
	set_cmt	(0X7B7E,	"open_mode_mask ? \n(it was 0Fh -access_mask- in MSDOS6.22 MSDOS.SYS)",	0);
	create_insn	(x=0X7B7E);
	op_hex		(x,	1);
	set_cmt	(0X7B80,	"open_for_write",	0);
	set_cmt	(0X7B91,	"Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE\nES:DI -> SFT\nSFT DPB field -> DPB of drive containing file\nCX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer\nReturn: CF set on error, CX = bytes read",	0);
	create_insn	(x=0X7B91);
	op_hex		(x,	0);
	create_insn	(0X7B94);
	set_cmt	(0X7B96,	"[ES:DI+SF_ENTRY.sf_flags],devid_device",	0);
	create_insn	(x=0X7B96);
	op_hex		(x,	1);
	set_cmt	(0X7B9D,	"errLOC_Disk",	0);
	create_insn	(x=0X7B9D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7BAC,	"errLOC_SerDev",	0);
	create_insn	(x=0X7BAC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7BB1,	"[ES:DI+SF_ENTRY.sf_flags]",	0);
	create_insn	(x=0X7BB5);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7BB9,	"devid_device_EOF ; End of file?",	0);
	create_insn	(x=0X7BB9);
	op_hex		(x,	1);
	set_cmt	(0X7BBE,	"devid_device_null ; NUL device?",	0);
	create_insn	(x=0X7BBE);
	op_hex		(x,	1);
	set_cmt	(0X7BC1,	"no",	0);
	set_cmt	(0X7BC3,	"Indicate EOF by setting zero",	0);
	set_cmt	(0X7BC8,	"devid_device_raw ; Raw mode?",	0);
	create_insn	(x=0X7BC8);
	op_hex		(x,	1);
	set_cmt	(0X7BCB,	"Yes, let the device do all local editing",	0);
	set_cmt	(0X7BCD,	"devid_device_con_in ; Is it console device?",	0);
	create_insn	(x=0X7BCD);
	op_hex		(x,	1);
	set_cmt	(0X7BD0,	"no",	0);
	set_cmt	(0X7BD2,	"yes",	0);
	create_insn	(0X7BD5);
	set_cmt	(0X7BD6,	"Xaddr to DS:DI",	0);
	create_insn	(x=0X7BD7);
	op_hex		(x,	1);
	set_cmt	(0X7BDD,	"not present",	0);
	set_cmt	(0X7BDF,	"devid_device_con_in ; is it console device?",	0);
	create_insn	(x=0X7BDF);
	op_hex		(x,	1);
	set_cmt	(0X7BE2,	"no, do normal read",	0);
	set_cmt	(0X7BE4,	"yes, do win386 polling loop",	0);
	set_cmt	(0X7BE7,	"DS:BX transfer addr",	0);
	create_insn	(0X7BE7);
	set_cmt	(0X7BE9,	"Media Byte, unit = 0",	0);
	set_cmt	(0X7BEB,	"Start at 0",	0);
	set_cmt	(0X7BFA,	"Read error",	0);
	set_cmt	(0X7C03,	"no errors",	0);
	set_cmt	(0X7C08,	"DS:DI is Xaddr",	0);
	set_cmt	(0X7C0A,	"[ss:CALLSCNT]",	0);
	set_cmt	(0X7C0F,	"[ss:CALLSCNT]",	0);
	set_cmt	(0X7C16,	"Ignore",	0);
	set_cmt	(0X7C1A,	"fail",	0);
	set_cmt	(0X7C1D,	"Retry",	0);
	set_cmt	(0X7C1F,	"Clean stack",	0);
	create_insn	(0X7C1F);
	set_name	(0X7C1F,	"CRDFERR");
	set_cmt	(0X7C28,	"Chuck saved seg of Xaddr",	0);
	create_insn	(0X7C28);
	set_cmt	(0X7C2B,	"[ss:CALLSCNT] ; Amount transferred",	0);
	create_insn	(0X7C32);
	set_cmt	(0X7C46,	"[SI+SF_ENTRY.sf_devptr]",	0);
	set_cmt	(0X7C4F,	"Save \"count\" done",	0);
	set_cmt	(0X7C5F,	"[SS:CALLSCNT]",	0);
	set_cmt	(0X7C68,	"Retry",	0);
	set_cmt	(0X7C6C,	"FAIL",	0);
	set_cmt	(0X7C6E,	"Ignore, Pick some random character",	0);
	create_insn	(0X7C72);
	set_cmt	(0X7C73,	"[SS:CALLSCNT]",	0);
	set_cmt	(0X7C7C,	"[SS:CALLXAD+2]",	0);
	set_cmt	(0X7C81,	"Get the character we just read",	0);
	set_cmt	(0X7C84,	"[SS:CALLXAD] ; Next character",	0);
	set_cmt	(0X7C90,	"Next character",	0);
	set_cmt	(0X7C91,	"^Z?",	0);
	set_cmt	(0X7C93,	"Yes, done zero set (EOF)",	0);
	set_cmt	(0X7C95,	"c_CR ; CR?",	0);
	set_cmt	(0X7C97,	"Loop if no, else done",	0);
	set_cmt	(0X7C99,	"Resets zero flag so NOT EOF, unless",	0);
	set_cmt	(0X7C9D,	"ds:bx is Xfer address",	0);
	create_insn	(0X7C9D);
	set_cmt	(0X7CA2,	"prepare device packet",	0);
	set_cmt	(0X7CA5,	"DEVRDND ; Change command code",	0);
	set_cmt	(0X7CAB,	"get device header",	0);
	set_cmt	(0X7CB0,	"call device driver",	0);
	set_cmt	(0X7CB4,	"[es:bx+SRHEAD.REQSTAT],\nSTERR ; check if error",	0);
	create_insn	(x=0X7CB4);
	op_hex		(x,	1);
	set_cmt	(0X7CBA,	"no",	0);
	set_cmt	(0X7CBF,	"invoke int 24h handler",	0);
	set_cmt	(0X7CC6,	"ignore by user,assume read is done",	0);
	set_cmt	(0X7CCA,	"user issued a 'fail',indicate error",	0);
	set_cmt	(0X7CCD,	"user issued a retry",	0);
	set_cmt	(0X7CCF,	"[es:bx+SRHEAD.REQSTAT],0200h\nsee if busy bit set",	0);
	create_insn	(x=0X7CCF);
	op_hex		(x,	1);
	set_cmt	(0X7CD7,	"DEVRD ; command code is READ now",	0);
	set_cmt	(0X7CDC,	"change count to 1 character",	0);
	create_insn	(x=0X7CDC);
	op_dec		(x,	0);
	set_cmt	(0X7CED,	"[es:bx+SRHEAD.REQSTAT]\nget returned status",	0);
	set_cmt	(0X7CF3,	"STERR ; was there an error during read?",	0);
	create_insn	(x=0X7CF3);
	op_hex		(x,	1);
	set_cmt	(0X7CF9,	"no,read next character",	0);
	set_name	(0X7CF9,	"next_char");
	set_cmt	(0X7CFC,	"decrement count",	0);
	set_cmt	(0X7CFD,	"all characters read in",	0);
	set_cmt	(0X7CFF,	"update transfer address",	0);
	create_insn	(x=0X7CFF);
	op_dec		(x,	0);
	set_cmt	(0X7D03,	"read next character in",	0);
	set_cmt	(0X7D05,	"discard segment address",	0);
	create_insn	(0X7D05);
	set_cmt	(0X7D0B,	"indicate error",	0);
	create_insn	(0X7D0E);
	set_cmt	(0X7D11,	"Microsoft Networks - KEYBOARD BUSY LOOP\nindicate idle to WIN386",	0);
	create_insn	(x=0X7D11);
	op_hex		(x,	0);
	create_insn	(0X7D16);
	set_cmt	(0X7D17,	"[ss:CALLSCNT]",	0);
	set_cmt	(0X7D1C,	"jump back to normal DOS raw read exit",	0);
	create_insn	(0X7D1F);
	set_cmt	(0X7D21,	"c_CR ; Check for carriage return",	0);
	set_cmt	(0X7D25,	"c_LF",	0);
	set_cmt	(0X7D28,	"c_LF",	0);
	set_cmt	(0X7D2E,	"Cause a new buffer to be read",	0);
	set_cmt	(0X7D30,	"Transmit linefeed",	0);
	set_cmt	(0X7D33,	"Clear zero flag--not end of file",	0);
	create_insn	(x=0X7D33);
	op_hex		(x,	1);
	set_cmt	(0X7D44,	"Zero set if Ctrl-Z found in input",	0);
	set_cmt	(0X7D4A,	"[ES:DI+SF_ENTRY.sf_flags],\n~devid_device_EOF\nMark as no more data available",	0);
	create_insn	(x=0X7D4A);
	op_hex		(x,	1);
	create_insn	(0X7D53);
	set_cmt	(0X7D5E,	"128",	0);
	create_insn	(x=0X7D5E);
	op_hex		(x,	1);
	set_cmt	(0X7D65,	"\nSet up 128-byte buffer with no template",	0);
	create_insn	(x=0X7D6E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7D71,	"Get input buffer",	0);
	create_insn	(x=0X7D76);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7D7A,	"Check for Ctrl-Z in first character",	0);
	set_cmt	(0X7D83,	"c_LF",	0);
	set_cmt	(0X7D85,	"Send linefeed",	0);
	create_insn	(0X7D8C);
	set_name	(0X7D8C,	"BadMode");
	create_insn	(0X7D8F);
	set_name	(0X7D8F,	"DOS_WRITE");
	set_cmt	(0X7D93,	"[ES:DI+SF_ENTRY.sf_mode]",	0);
	set_cmt	(0X7D97,	"open_mode_mask ?",	0);
	create_insn	(x=0X7D97);
	op_hex		(x,	1);
	set_cmt	(0X7D99,	"open_for_read",	0);
	set_cmt	(0X7D9D,	"\n[ES:DI+SF_ENTRY.sf_mode+1],\n(sf_isFCB>>8)",	0);
	create_insn	(x=0X7D9D);
	op_hex		(x,	1);
	set_name	(0X7D9D,	"Check_FCB_RO");
	set_cmt	(0X7DA2,	"Not an FCB",	0);
	set_cmt	(0X7DA4,	"[ES:DI+SF_ENTRY.sf_attr],\nattr_read_only",	0);
	create_insn	(x=0X7DA4);
	op_hex		(x,	1);
	set_cmt	(0X7DA9,	"Can't write to Read_Only files via FCB",	0);
	set_cmt	(0X7DAE,	"call IsSFTNet\n[ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)",	0);
	create_insn	(x=0X7DAE);
	op_hex		(x,	1);
	set_cmt	(0X7DB8,	"Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE\nES:DI -> SFT\nSFT DPB field -> DPB of drive containing file\nCX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer\nReturn: CF set on error, CX = bytes written",	0);
	create_insn	(x=0X7DB8);
	op_hex		(x,	0);
	set_cmt	(0X7DBB,	"[ES:DI+SF_ENTRY.sf_flags],devid_device\nCheck for named device I/O",	0);
	create_insn	(x=0X7DBB);
	op_hex		(x,	1);
	set_cmt	(0X7DC2,	"errLOC_Disk",	0);
	set_cmt	(0X7DD3,	"[ES:DI+SF_ENTRY.sf_mode+1],\n(AUTO_COMMIT_WRITE>>8)",	0);
	create_insn	(x=0X7DD3);
	op_hex		(x,	1);
	set_cmt	(0X7DE3,	"Media Byte, unit = 0",	0);
	create_insn	(0X7DE3);
	set_cmt	(0X7DE8,	"Save seg of transfer",	0);
	set_cmt	(0X7DEE,	"DS:SI -> DEVICE",	0);
	set_cmt	(0X7DF1,	"Offset part of Xaddr saved in DX",	0);
	set_cmt	(0X7E01,	"[ss:CALLSCNT]",	0);
	set_cmt	(0X7E06,	"update ptr & count to reflect\nnumber of chars xferred",	0);
	set_cmt	(0X7E0C,	"Recall transfer addr",	0);
	set_cmt	(0X7E10,	"Ignore",	0);
	set_cmt	(0X7E16,	"Recover saved seg of transfer",	0);
	set_cmt	(0X7E17,	"Try again",	0);
	set_cmt	(0X7E19,	"Chuck saved seg of transfer",	0);
	create_insn	(0X7E19);
	set_cmt	(0X7E1A,	"Will pop one more stack element",	0);
	set_cmt	(0X7E1D,	"Chuck saved seg of transfer",	0);
	create_insn	(0X7E1D);
	set_cmt	(0X7E1F,	"[CALLSCNT]\nGet actual number of bytes transferred",	0);
	create_insn	(x=0X7E1F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X7E22);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7E2C,	"Entire transfer done",	0);
	create_insn	(0X7E2C);
	set_cmt	(0X7E31,	"errLOC_SerDev",	0);
	create_insn	(x=0X7E31);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7E36,	"[ES:DI+SF_ENTRY.sf_flags],\ndevid_device_EOF\nReset EOF for input",	0);
	create_insn	(x=0X7E36);
	op_hex		(x,	1);
	set_cmt	(0X7E3B,	"[ES:DI+SF_ENTRY.sf_flags]",	0);
	set_cmt	(0X7E41,	"problem of creating on a device",	0);
	set_cmt	(0X7E46,	"Xaddr to DS:BX",	0);
	create_insn	(x=0X7E46);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7E4A,	"Xaddr to DS:DI",	0);
	set_cmt	(0X7E4C,	"Set starting point",	0);
	set_cmt	(0X7E4D,	"devid_device_raw",	0);
	create_insn	(x=0X7E4D);
	op_hex		(x,	1);
	set_cmt	(0X7E51,	"\ndevid_device_con_out\nConsole output device?",	0);
	create_insn	(x=0X7E51);
	op_hex		(x,	1);
	set_name	(0X7E51,	"TEST_DEV_CON");
	set_cmt	(0X7E53,	"yes",	0);
	set_cmt	(0X7E55,	"devid_device_null",	0);
	create_insn	(x=0X7E55);
	op_hex		(x,	1);
	set_cmt	(0X7E5B,	"^Z?",	0);
	set_cmt	(0X7E5E,	"Yes, transfer nothing",	0);
	create_insn	(x=0X7E67);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7E6D,	"[SI+SF_ENTRY.sf_devptr]",	0);
	create_insn	(x=0X7E77);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7E86,	"[SS:CALLSCNT]",	0);
	create_insn	(x=0X7E86);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7E8F,	"Retry",	0);
	set_cmt	(0X7E93,	"Ignore",	0);
	set_cmt	(0X7E95,	"Fail, pops one stack element",	0);
	create_insn	(0X7E98);
	set_cmt	(0X7E99,	"[SS:CALLSCNT]",	0);
	create_insn	(x=0X7E99);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7EA2,	"[SS:CALLXAD]",	0);
	create_insn	(x=0X7EA2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7EA9,	"[SS:CALLXAD+2]",	0);
	create_insn	(x=0X7EA9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7EAE,	"^Z?",	0);
	create_insn	(x=0X7EB4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X7EC3);
	set_cmt	(0X7ECE,	"^Z?",	0);
	set_cmt	(0X7ED0,	"yes",	0);
	set_cmt	(0X7ED7,	"Count",	0);
	set_cmt	(0X7ED9,	"Amount actually written",	0);
	set_cmt	(0X7EE1,	"Convert JFN num in BX to sf_entry in DS:SI",	0);
	create_insn	(x=0X7EE1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X7EE1,	"GET_IO_SFT");
	create_insn	(0X7EFB);
	create_insn	(x=0X7F00);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X7F06,	"get_io_sft_retn");
	create_insn	(0X7F07);
	set_name	(0X7F07,	"DIRREAD");
	create_insn	(x=0X7F09);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7F0F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X7F18);
	set_cmt	(0X7F1A,	"[ES:BP+DPB.CLUSTER_SHIFT]",	0);
	set_cmt	(0X7F1E,	"[ES:BP+DPB.CLUSTER_MASK]",	0);
	create_insn	(x=0X7F24);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7F28,	"(CX) = number of clusters to skip.",	0);
	set_cmt	(0X7F2A,	"(AH) = remainder",	0);
	create_insn	(x=0X7F2C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X7F30);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7F34);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7F38);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X7F3C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X7F40);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7F44);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X7F4D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7F52);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7F5D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7F61);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7F65);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7F69);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7F6F,	"test for eof based on fat size",	0);
	create_insn	(x=0X7F76);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7F7A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X7F7E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7F84);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X7F88);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7F91,	"Allowed_RETRY+Allowed_FAIL",	0);
	create_insn	(x=0X7F91);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X7F91,	"FIRSTCLUSTER");
	set_cmt	(0X7F96,	"Indicate pre-read",	0);
	set_name	(0X7F9D,	"SET_BUF_AS_DIR");
	create_insn	(x=0X7F9F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X7FA3,	"[SI+BUFFINFO.buf_flags],buf_isDIR",	0);
	create_insn	(x=0X7FA3);
	op_hex		(x,	1);
	set_name	(0X7FA9,	"dirread_retn");
	set_cmt	(0X7FAA,	"Allowed_RETRY+Allowed_FAIL",	0);
	create_insn	(x=0X7FAA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X7FAA,	"FATSECRD");
	set_cmt	(0X7FB2,	"[ES:BP+DPB.FAT_COUNT]",	0);
	set_cmt	(0X7FB6,	"[ES:BP+DPB.FAT_SIZE]",	0);
	set_cmt	(0X7FBE,	"not FAT32",	0);
	set_cmt	(0X7FC0,	"[ES:BP+DPB.EXT_FLAGS]",	0);
	create_insn	(x=0X7FC0);
	op_hex		(x,	1);
	set_cmt	(0X7FC7,	"only one FAT is active",	0);
	create_insn	(x=0X7FCA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7FD2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X7FDE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X7FE9,	"not FAT32",	0);
	set_cmt	(0X7FEB,	"DPB.FAT32_SIZE",	0);
	set_cmt	(0X7FF0,	"DPB.FAT32_SIZE+2",	0);
	create_insn	(x=0X7FF4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X7FFC);
	create_insn	(x=0X7FFE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8007);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X800E);
	set_name	(0X800E,	"DREAD");
	set_cmt	(0X8013,	"Read",	0);
	create_insn	(x=0X8013);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X801C,	"RETRY",	0);
	set_cmt	(0X8020,	"FAIL",	0);
	set_cmt	(0X8023,	"IGNORE",	0);
	create_insn	(0X8027);
	create_insn	(x=0X8028);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X802E,	"[ES:DI+SF_ENTRY.sf_attr],\nattr_volume_id",	0);
	create_insn	(x=0X802E);
	op_hex		(x,	1);
	set_name	(0X802E,	"CHECK_WRITE_LOCK");
	create_insn	(0X8039);
	set_cmt	(0X803E,	"-1 ; check for lock on whole file",	0);
	set_cmt	(0X803F,	"check write access",	0);
	set_cmt	(0X8041,	"check lock",	0);
	set_cmt	(0X8045,	"lock ok",	0);
	set_cmt	(0X8047,	"issue I24",	0);
	set_cmt	(0X804A,	"retry",	0);
	set_cmt	(0X804D,	"[ES:DI+SF_ENTRY.sf_attr],\nattr_volume_id",	0);
	create_insn	(x=0X804D);
	op_hex		(x,	1);
	set_name	(0X804D,	"CHECK_READ_LOCK");
	set_cmt	(0X8058,	"check read access",	0);
	create_insn	(0X8058);
	set_cmt	(0X805A,	"check lock",	0);
	set_cmt	(0X805D,	"lock ok",	0);
	set_cmt	(0X805F,	"issue I24",	0);
	set_cmt	(0X8062,	"retry",	0);
	set_cmt	(0X8065,	"DS:BX = Transfer address\n[HIGH_SECTOR]:DX = Disk sector address\nCX = Sector count\nES:BP = DPB",	0);
	create_insn	(0X8065);
	set_name	(0X8065,	"DSKREAD");
	set_cmt	(0X8066,	"[ES:BP+DPB.MEDIA]",	0);
	set_cmt	(0X806A,	"[ES:BP+DPB.UNIT]",	0);
	create_insn	(0X8075);
	set_name	(0X8075,	"DWRITE");
	set_cmt	(0X807A,	"Carry clear (retz)",	0);
	set_cmt	(0X807B,	"Write",	0);
	create_insn	(x=0X807B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8084,	"Check for retry",	0);
	set_cmt	(0X8088,	"Check for FAIL",	0);
	set_cmt	(0X808B,	"Ignore",	0);
	set_cmt	(0X808F,	"DS:BX = Transfer address\n[HIGH_SECTOR]:DX = Disk sector address\nCX = Sector count\nES:BP = DPB",	0);
	create_insn	(0X808F);
	set_name	(0X808F,	"DSKWRITE");
	set_cmt	(0X8090,	"[ES:BP+DPB.MEDIA]",	0);
	set_cmt	(0X8094,	"[ES:BP+DPB.UNIT]",	0);
	set_name	(0X809D,	"DODSKOP");
	set_cmt	(0X809F,	"DS:BP points to DPB",	0);
	set_cmt	(0X80A1,	"[ds:BP+DPB.DRIVER_ADDR]",	0);
	set_cmt	(0X80AD,	"[SS:CALLSCNT] ; Number of sectors transferred",	0);
	create_insn	(x=0X80AD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X80B2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X80B8,	"Number of sectors not transferred",	0);
	set_cmt	(0X80BA,	"test ah,(STERR>>8)",	0);
	create_insn	(x=0X80BA);
	op_hex		(x,	1);
	set_cmt	(0X80BE,	"error_I24_wrong_disk",	0);
	create_insn	(0X80BE);
	set_name	(0X80BE,	"HARDERRRW");
	create_insn	(x=0X80C4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X80C9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X80CD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X80D8,	"[ES:DI+SF_ENTRY.sf_devptr]",	0);
	create_insn	(0X80D8);
	set_name	(0X80D8,	"SETUP");
	create_insn	(x=0X80DC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X80E5);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X80E9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X80ED,	"Set NEXTADD to start of Xaddr",	0);
	create_insn	(x=0X80ED);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X80F1,	"No transferes",	0);
	create_insn	(x=0X80F1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X80F6,	"[ES:DI+SF_ENTRY.sf_position]",	0);
	set_cmt	(0X80FA,	"[ES:DI+SF_ENTRY.sf_position+2]",	0);
	create_insn	(x=0X80FE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8101);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8105,	"[ES:DI+SF_ENTRY.sf_flags],\nsf_isnet+devid_device",	0);
	create_insn	(x=0X8105);
	op_hex		(x,	1);
	create_insn	(x=0X810E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8112,	"[ES:BP+DPB.DRIVE]",	0);
	set_cmt	(0X8116,	"SHR32 and DIV32 use CX.",	0);
	create_insn	(x=0X8117);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X811B,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	set_cmt	(0X811F,	"DX:AX/BX = CX:AX + DX (rem)",	0);
	create_insn	(x=0X8122);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8126);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8129);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8131,	"[ES:BP+DPB.CLUSTER_MASK]",	0);
	create_insn	(x=0X8135);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8139,	"(DX:AX SHR dpb_cluster_shift)",	0);
	set_cmt	(0X813C,	"CX = byte count.",	0);
	set_cmt	(0X813D,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0X8142,	"not FAT32",	0);
	set_cmt	(0X8144,	"[ES:BP+DPB.LAST_CLUSTER+2]",	0);
	set_cmt	(0X814A,	"[ES:BP+DPB.LAST_CLUSTER]",	0);
	create_insn	(0X8150);
	set_cmt	(0X8154,	"[ES:BP+DPB.MAX_CLUSTER]",	0);
	create_insn	(x=0X815A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X815D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8162,	"Byte count.",	0);
	set_cmt	(0X8164,	"See if it will fit in one segment",	0);
	create_insn	(x=0X8164);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8168,	"Must be less than 64K",	0);
	create_insn	(x=0X816B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X816E,	"Amount of room left in segment",	0);
	set_cmt	(0X8173,	"Can do this much",	0);
	set_cmt	(0X8175,	"Silly user gave Xaddr of FFFF in segment",	0);
	set_cmt	(0X8178,	"ES:DI point to SFT",	0);
	create_insn	(0X8178);
	set_cmt	(0X8179,	"No bytes read",	0);
	set_cmt	(0X817B,	"Kill return address",	0);
	set_cmt	(0X817D,	"RETURN TO CALLER OF CALLER",	0);
	create_insn	(x=0X817E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X817E,	"BREAKDOWN");
	set_cmt	(0X8185,	"Partial first sector?",	0);
	set_cmt	(0X8187,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	set_cmt	(0X818B,	"Max number of bytes left in first sector",	0);
	set_cmt	(0X818D,	"Subtract from total length",	0);
	set_cmt	(0X8191,	"Don't use all of the rest of the sector",	0);
	set_cmt	(0X8193,	"And no bytes are left",	0);
	create_insn	(x=0X8195);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X819C,	"[ES:BP+DPB.SECTOR_SIZE]\nHow many whole sectors?",	0);
	create_insn	(x=0X81A0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X81A3,	"Bytes remaining for last sector",	0);
	create_insn	(x=0X81A3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X81A7,	"_RET45");
	create_insn	(x=0X81A8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X81A8,	"READ_LOCK_VIOLATION");
	set_cmt	(0X81AD,	"[ES:DI+SF_ENTRY.sf_mode+1],\n(sf_isFCB>>8)",	0);
	create_insn	(x=0X81AD);
	op_hex		(x,	1);
	set_name	(0X81AD,	"ERR_ON_CHECK");
	set_cmt	(0X81B5,	"[ES:DI+SF_ENTRY.sf_mode]",	0);
	set_cmt	(0X81B9,	"SHARING_MASK",	0);
	create_insn	(x=0X81B9);
	op_hex		(x,	1);
	set_cmt	(0X81BC,	"SHARING_COMPAT",	0);
	set_cmt	(0X81C7,	"No bytes transferred",	0);
	set_cmt	(0X81C9,	"error_lock_violation",	0);
	create_insn	(x=0X81C9);
	op_hex		(x,	1);
	set_name	(0X81CD,	"RET3");
	create_insn	(x=0X81CE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X81CE,	"WRITE_LOCK_VIOLATION");
	set_cmt	(0X81D5,	"[ES:DI+SF_ENTRY.sf_size]",	0);
	create_insn	(0X81D5);
	set_name	(0X81D5,	"DISKREAD");
	set_cmt	(0X81D9,	"[ES:DI+SF_ENTRY.sf_size+2]",	0);
	create_insn	(x=0X81DD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X81E1);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X81E5,	"Read starts past EOF",	0);
	set_cmt	(0X81E7,	"More than 64k to EOF",	0);
	set_cmt	(0X81EB,	"Read starts at EOF",	0);
	set_cmt	(0X81EF,	"I/O fits",	0);
	set_cmt	(0X81F1,	"Limit read to up til EOF",	0);
	set_cmt	(0X81F8,	"There are no locks",	0);
	create_insn	(x=0X81F8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X81F8,	"_READ_OK");
	create_insn	(x=0X81FF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8203);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X820A,	"ds=ss",	0);
	create_insn	(x=0X820C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8215,	"read/data/fail",	0);
	create_insn	(0X821A);
	set_name	(0X821A,	"SETSFTJ2");
	set_cmt	(0X821D,	"Clean stack",	0);
	create_insn	(0X821D);
	set_cmt	(0X821F,	"PCDOS 7.1 BUG!?\nI think, this would be 'pop ss:CCONTENT_HW'\nbecause ds<>ss while jumping here.\nErdogan Tan - 09/02/2024",	0);
	create_insn	(x=0X821F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X8223);
	set_name	(0X8223,	"SET_ACC_ERR_DS");
	create_insn	(0X8225);
	set_name	(0X8225,	"SET_ACC_ERR");
	set_cmt	(0X8227,	"error_access_denied",	0);
	create_insn	(x=0X822C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8230);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8234);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8238);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X823C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8246,	"ds=ss",	0);
	create_insn	(x=0X8248);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8254,	"A transfer is taking place",	0);
	create_insn	(x=0X8254);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8259,	"\n(dx/DL = Extent start) ((dh = ?))",	0);
	create_insn	(x=0X8259);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X825D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8261);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8265);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8269);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8270,	"ds=ss",	0);
	set_cmt	(0X8272,	"(Next physical cluster, hw)",	0);
	create_insn	(x=0X8272);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8276,	"DI = Next physical cluster.",	0);
	set_cmt	(0X8277,	"AX = # of sectors remaining.",	0);
	set_cmt	(0X8278,	"[DMAADD+2]:BX = Transfer address.",	0);
	set_cmt	(0X8279,	"Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE",	0);
	create_insn	(x=0X8279);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X827E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8282,	"[HIGH_SECTOR]:DX = phys. sector #.",	0);
	set_cmt	(0X8283,	"CX = # of contiguous sectors to read.",	0);
	set_cmt	(0X8284,	"SET_RQ_SC_PARMS",	0);
	create_insn	(x=0X828C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8291,	"ds<>ss",	0);
	create_insn	(x=0X8293);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X829F,	"# of sectors remaining.",	0);
	set_cmt	(0X82A0,	"Next physical cluster.",	0);
	set_cmt	(0X82A1,	"(Next physical cluster, hw)",	0);
	create_insn	(x=0X82A1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X82A7,	"test for eof on fat size",	0);
	set_cmt	(0X82AE,	"We'll be using next cluster",	0);
	create_insn	(x=0X82AE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X82B3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X82BA);
	set_name	(0X82BA,	"j_SET_ACC_ERR_DS");
	create_insn	(x=0X82BD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X82C4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X82CC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X82D5,	"ds=ss",	0);
	create_insn	(x=0X82D7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X82D7,	"SETSFT");
	create_insn	(x=0X82DB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X82DB,	"SETCLUS");
	set_cmt	(0X82DF,	"Number of bytes transfered",	0);
	create_insn	(x=0X82DF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X82E3,	"[ES:DI+SF_ENTRY.sf_flags],\ndevid_device",	0);
	create_insn	(x=0X82E3);
	op_hex		(x,	1);
	set_cmt	(0X82E8,	"don't set clusters if device",	0);
	create_insn	(x=0X82EA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X82ED,	"[ES:DI+SF_ENTRY.sf_lstclus+2]",	0);
	create_insn	(x=0X82F1);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X82F4,	"[ES:DI+SF_ENTRY.sf_cluspos_hw] ; PCDOS 7.1 & Win ME\n[ES:DI+SF_ENTRY.sf_firclus] ; MSDOS 5.0-6.22",	0);
	create_insn	(x=0X82F8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X82FB,	"[ES:DI+SF_ENTRY.sf_lstclus]",	0);
	create_insn	(x=0X82FF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8302,	"[ES:DI+SF_ENTRY.sf_cluspos]",	0);
	create_insn	(0X8306);
	set_name	(0X8306,	"ADDREC");
	set_cmt	(0X8308,	"[ES:DI+SF_ENTRY.sf_position]\nUpdate current position",	0);
	set_cmt	(0X830C,	"[ES:DI+SF_ENTRY.sf_position+2]",	0);
	set_cmt	(0X8313,	"Any dirty buffers?",	0);
	create_insn	(x=0X8313);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X8313,	"DskRdBufScan");
	set_cmt	(0X8319,	"-no, skip all work.",	0);
	create_insn	(x=0X831B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8327,	"DS:DI -> 1st buf in queue.",	0);
	set_cmt	(0X832A,	"[di+BUFFINFO.buf_prev]",	0);
	create_insn	(x=0X832D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8331,	"[es:bp+DPB.DRIVE]",	0);
	set_cmt	(0X8335,	"[di+BUFFINFO.buf_ID] ; Same drive?",	0);
	set_cmt	(0X8338,	"no",	0);
	set_cmt	(0X833A,	"[di+BUFFINFO.buf_sector+2]",	0);
	set_cmt	(0X833F,	"[di+BUFFINFO.buf_sector]",	0);
	set_cmt	(0X834E,	"Scanned entire buffer queue?",	0);
	create_insn	(x=0X834E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8353,	"[di+BUFFINFO.buf_next]",	0);
	set_cmt	(0X8355,	"-no, do next buffer",	0);
	set_cmt	(0X8357,	"Exit.",	0);
	create_insn	(0X8358);
	set_cmt	(0X8359,	"[di+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0X8359);
	op_hex		(x,	1);
	set_cmt	(0X8366,	"[di+BUFFINFO.buf_sector]",	0);
	set_cmt	(0X836B,	"[es:bp+DPB.SECTOR_SIZE]",	0);
	set_cmt	(0X836F,	"[di+BUFINSIZ]",	0);
	create_insn	(x=0X8374);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X837B);
	op_hex		(x,	1);
	create_insn	(x=0X837D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8383,	"rep movsw\n(skip 32 bit prefix)",	0);
	create_insn	(x=0X8385);
	op_hex		(x,	1);
	create_insn	(x=0X8394);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X839D);
	create_insn	(0X83A0);
	set_name	(0X83A0,	"dskwrt_retj");
	create_insn	(0X83A3);
	set_name	(0X83A3,	"DISKWRITE");
	set_cmt	(0X83A8,	"[ES:DI+SF_ENTRY.sf_flags],\n~(sf_close_nodate|devid_file_clean)",	0);
	create_insn	(x=0X83A8);
	op_hex		(x,	1);
	set_cmt	(0X83AE,	"[ES:DI+SF_ENTRY.sf_size]",	0);
	create_insn	(x=0X83B2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X83B6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_3(void) {
        auto x;
#define id x

	create_insn	(x=0X83B9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X83C0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X83C3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X83C7,	"Make the file length = sf_position",	0);
	set_cmt	(0X83CB,	"DX:AX = last byte to write + 1.",	0);
	set_cmt	(0X83D3,	"[es:di+SF_ENTRY.sf_mode+1],10h",	0);
	create_insn	(x=0X83D3);
	op_hex		(x,	1);
	set_cmt	(0X83D8,	"> 2GB file size (up to 4GB) allowed",	0);
	set_cmt	(0X83DA,	"check for 2GB file size limit",	0);
	set_cmt	(0X83E3,	"error, \nfile position/pointer overs 2GB limit!",	0);
	set_cmt	(0X83E5,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	set_cmt	(0X83E9,	"DX:AX/BX = CX:AX + DX (rem.).",	0);
	create_insn	(x=0X83EE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X83F9,	"DX:AX must be zero base indexed",	0);
	set_cmt	(0X83FF,	"32 bit shift right (dx:ax)",	0);
	set_cmt	(0X8406,	"!*! cx:ax = Last cluster to write",	0);
	set_cmt	(0X8407,	"# of bytes in last sector to write",	0);
	create_insn	(x=0X8408);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X840C,	"DX:AX = current file size (in bytes).",	0);
	create_insn	(x=0X840C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8412);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8416);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8422,	"Round up if any remainder",	0);
	create_insn	(x=0X8425);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X842A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X842F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8432);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8435);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8439,	"# of bytes in last sector to write",	0);
	create_insn	(x=0X843A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8444);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X844A);
	set_cmt	(0X8455,	"[ES:BP+DPB.SECTOR_SIZE]\nBytes of full sector growth",	0);
	create_insn	(x=0X8459);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X845D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8462,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	create_insn	(x=0X8466);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X846B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X846E,	"Take off current \"tail\"",	0);
	set_cmt	(0X8473,	"Add on new \"tail\"",	0);
	create_insn	(x=0X847A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8483);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X848C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8494,	"write/data/fail/abort",	0);
	create_insn	(x=0X8496);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X8496,	"WRTERR22");
	set_cmt	(0X8499,	"No bytes transferred",	0);
	create_insn	(x=0X849B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X84A0,	"dskwrt_retn");
	create_insn	(0X84A1);
	create_insn	(0X84A4);
	create_insn	(x=0X84AA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X84AD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X84B1,	"First cluster accessed",	0);
	create_insn	(x=0X84B1);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X84B5);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X84BD,	"!*! si:ax = Last cluster",	0);
	set_cmt	(0X84BE,	"ds=ss",	0);
	create_insn	(x=0X84C0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X84C4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X84C8,	"Last cluster minus current cluster",	0);
	create_insn	(x=0X84CA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X84CE);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X84D2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X84DC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X84E5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X84E9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X84F2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X84F9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8500);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8508);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X851B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X851F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8522);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8525);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8529);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8530);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8534);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8538);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X853F,	"ds=ss",	0);
	create_insn	(x=0X8541);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X854B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X854F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8557,	"ds=ss",	0);
	set_cmt	(0X8559,	"A transfer is taking place",	0);
	create_insn	(x=0X8559);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X855E,	"DL = Extent start",	0);
	create_insn	(x=0X855E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8562);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8566);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X856A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X856E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8575,	"ds=ss",	0);
	create_insn	(x=0X8577);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X857B,	"CCONTENT_HW:DI = Next physical cluster",	0);
	set_cmt	(0X857C,	"AX = # sectors remaining",	0);
	set_cmt	(0X857D,	"DS trashed.",	0);
	create_insn	(x=0X8580);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8585,	"Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE",	0);
	create_insn	(x=0X8585);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X858E,	"ds<>ss",	0);
	set_cmt	(0X8590,	"error_handle_Disk_Full",	0);
	create_insn	(x=0X8590);
	op_hex		(x,	1);
	create_insn	(x=0X8594);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X859D,	"Check for retry",	0);
	set_cmt	(0X85A1,	"Check for FAIL",	0);
	set_cmt	(0X85A4,	"Ignore",	0);
	set_cmt	(0X85A7,	"CX = # sectors remaining",	0);
	set_cmt	(0X85A9,	"CLUSTNUM_HW:BX = Next physical cluster",	0);
	create_insn	(x=0X85A9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X85B0,	"ds=ss",	0);
	set_cmt	(0X85B6,	"We'll be using next cluster",	0);
	create_insn	(x=0X85B6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X85BB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X85C2);
	set_cmt	(0X85C4,	"unjunk stack",	0);
	create_insn	(x=0X85C6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X85CA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X85D0,	"go to disk full exit",	0);
	create_insn	(0X85D3);
	create_insn	(x=0X85D6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X85DD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X85E5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X85F0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X85F4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X85F7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8601,	"[ES:DI+SF_ENTRY.sf_size]",	0);
	set_cmt	(0X8605,	"[ES:DI+SF_ENTRY.sf_size+2]",	0);
	set_cmt	(0X860C,	"call far [JShare+(14*4)] ; 14 = ShSU",	0);
	create_insn	(x=0X860C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8610,	"ES:DI already points to SFT",	0);
	create_insn	(0X8613);
	set_cmt	(0X861C,	"2GB file size limit",	0);
	create_insn	(0X861C);
	create_insn	(x=0X8628);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X862C,	"[es:di+SF_ENTRY.sf_mode+1],10h",	0);
	create_insn	(x=0X862C);
	op_hex		(x,	1);
	set_cmt	(0X8632,	"> 2GB file size not allowed",	0);
	set_cmt	(0X863B,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	create_insn	(x=0X8645);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8653);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X865C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8662,	"disk full",	0);
	create_insn	(x=0X8664);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8667);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X866B,	"ES:DI+SF_ENTRY.sf_size]",	0);
	create_insn	(x=0X866F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8672,	"ES:DI+SF_ENTRY.sf_size+2]",	0);
	set_cmt	(0X8679,	"call far [JShare+(14*4)] ; 14 = ShSU",	0);
	create_insn	(x=0X8679);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X8682);
	set_cmt	(0X8685,	"Reset Lstclus and cluspos to",	0);
	create_insn	(0X8685);
	set_cmt	(0X8686,	"beginning of file if current",	0);
	create_insn	(x=0X8686);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X868A,	"cluspos is past EOF.",	0);
	create_insn	(x=0X868B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X868E,	"[ES:DI+SF_ENTRY.sf_firclus]\n[ES:DI+SF_ENTRY.sf_cluspos_hw] !?",	0);
	set_cmt	(0X8695,	"[ES:DI+SF_ENTRY.sf_cluspos]",	0);
	set_cmt	(0X869B,	"[ES:DI+SF_ENTRY.sf_chain]\nfirst cluster (32 bit) lw !?",	0);
	set_cmt	(0X86A5,	"[ES:DI+SF_ENTRY.sf_lstclus]",	0);
	set_cmt	(0X86AF,	"[ES:DI+SF_ENTRY.sf_chain]\nfirst cluster (32 bit) hw !?",	0);
	set_cmt	(0X86B3,	"[ES:DI+SF_ENTRY.sf_lstclus+2]",	0);
	set_cmt	(0X86BB,	"0FFFFh",	0);
	create_insn	(x=0X86BB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X86C2,	"ds=ss",	0);
	create_insn	(0X86C6);
	create_insn	(x=0X86C9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X86CD,	"[ES:DI+SF_ENTRY.sf_chain+2]\nfirst cluster (32 bit) hw !?",	0);
	create_insn	(x=0X86D1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X86D5,	"0",	0);
	set_cmt	(0X86D7,	"[ES:DI+SF_ENTRY.sf_firclus]\n[ES:DI+SF_ENTRY.sf_cluspos_hw] !?",	0);
	set_cmt	(0X86DB,	"[ES:DI+SF_ENTRY.sf_lstclus+2]",	0);
	set_cmt	(0X86DF,	"[ES:DI+SF_ENTRY.sf_cluspos]",	0);
	set_cmt	(0X86E3,	"[ES:DI+SF_ENTRY.sf_lstclus]",	0);
	set_cmt	(0X86E7,	"[ES:DI+SF_ENTRY.sf_chain]\nfirst cluster (32 bit) !?",	0);
	create_insn	(x=0X86EC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X86F6,	"since first cluster # is 0",	0);
	set_cmt	(0X86F7,	"we must delete the old cache entry",	0);
	set_cmt	(0X86FA,	"get current DPB",	0);
	create_insn	(x=0X86FA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X86FF,	"get current drive",	0);
	set_cmt	(0X8703,	"first cluster #",	0);
	set_cmt	(0X8705,	"delete cache entry by drive:firclus",	0);
	set_cmt	(0X8707,	"call fastopen",	0);
	create_insn	(0X8714);
	set_name	(0X8714,	"DskWrtBufPurge");
	create_insn	(x=0X8716);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8722,	"[es:bp+DPB.DRIVE]",	0);
	set_cmt	(0X8729,	"[di+BUFFINFO.buf_ID] ; Same drive?",	0);
	set_cmt	(0X872C,	"no",	0);
	set_cmt	(0X872E,	"[di+BUFFINFO.buf_sector+2]",	0);
	set_cmt	(0X8733,	"[di+BUFFINFO.buf_sector]",	0);
	set_cmt	(0X8742,	"[di+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0X8742);
	op_hex		(x,	1);
	set_cmt	(0X874B,	"[di+BUFFINFO.buf_ID],\n((buf_visit<<8)|0FFh)",	0);
	set_cmt	(0X8755,	"[di+BUFFINFO.buf_next]",	0);
	create_insn	(0X8755);
	create_insn	(x=0X8757);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X875C,	"go do next buffer.",	0);
	create_insn	(x=0X8761);
	op_dec		(x,	1);
	set_name	(0X8761,	"DIV32");
	set_cmt	(0X8769,	"CX:AX = Dividend",	0);
	set_cmt	(0X876B,	"DX = Remainder",	0);
	create_insn	(x=0X876B);
	op_hex		(x,	1);
	create_insn	(x=0X8777);
	op_hex		(x,	1);
	create_insn	(x=0X8779);
	op_hex		(x,	1);
	create_insn	(0X877C);
	set_cmt	(0X8782,	"0:AX/BX",	0);
	set_cmt	(0X8785,	"DX:AX/BX",	0);
	set_cmt	(0X8788,	"[ES:BP+DPB.CLUSTER_SHIFT]",	0);
	create_insn	(0X8788);
	set_name	(0X8788,	"SHR32");
	set_cmt	(0X878C,	"ZF=1",	0);
	set_cmt	(0X8790,	"ZF reflects state of DX.",	0);
	create_insn	(x=0X8790);
	op_hex		(x,	1);
	set_cmt	(0X8792,	"ZF not affected.",	0);
	create_insn	(x=0X8792);
	op_hex		(x,	1);
	create_insn	(0X8797);
	set_name	(0X8797,	"FINDENTRY");
	create_insn	(x=0X879A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X879D,	"~attr_ignore",	0);
	create_insn	(x=0X879D);
	op_hex		(x,	1);
	set_cmt	(0X879F,	"attr_volume_id",	0);
	set_cmt	(0X87AD,	"reset long name entry count",	0);
	create_insn	(x=0X87AD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X87AD,	"SRCH");
	set_name	(0X87B3,	"SRCH2");
	create_insn	(x=0X87B4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X87B8,	"[BX+dir_entry.dir_name]",	0);
	set_cmt	(0X87BF,	"[BX+dir_entry.dir_attr]",	0);
	create_insn	(x=0X87C8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X87CF,	"[BX+dir_entry.dir_attr],\nattr_volume_id",	0);
	create_insn	(x=0X87CF);
	op_hex		(x,	1);
	create_insn	(x=0X87D5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X87E0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X87E3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X87EB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X87F7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X87F7,	"NEXTENT");
	set_name	(0X8800,	"SETESRET_j");
	create_insn	(0X8802);
	set_name	(0X8802,	"NEXTENT2");
	set_cmt	(0X8803,	"Long Name entry count",	0);
	create_insn	(x=0X8803);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8807);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X8812);
	set_name	(0X8812,	"FREE");
	create_insn	(x=0X8813);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8817);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X881D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8821);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8827);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X882E);
	set_name	(0X882E,	"FOUND");
	create_insn	(x=0X8831);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8835,	"~attr_ignore",	0);
	create_insn	(x=0X8835);
	op_hex		(x,	1);
	set_cmt	(0X8838,	"[SI+dir_entry.dir_first-dir_entry.dir_attr]",	0);
	set_cmt	(0X883B,	"attr_volume_id",	0);
	create_insn	(x=0X883B);
	op_hex		(x,	1);
	set_cmt	(0X8840,	"attr_volume_id",	0);
	create_insn	(x=0X8840);
	op_hex		(x,	1);
	set_cmt	(0X8849,	"attr_volume_id",	0);
	create_insn	(0X8849);
	set_cmt	(0X8853,	"-1",	0);
	create_insn	(x=0X8853);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X885A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X885E,	"[ES:BP+DPB.DRIVE]",	0);
	create_insn	(x=0X8864);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8868,	"previous ENTLAST",	0);
	create_insn	(x=0X8868);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X886E,	"reset long name entry count",	0);
	create_insn	(x=0X886E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8875);
	op_dec		(x,	1);
	set_name	(0X8875,	"MetaCompare");
	set_cmt	(0X8883,	"Zero set, Match",	0);
	create_insn	(x=0X8884);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X8884,	"NEXTENTRY");
	create_insn	(x=0X8887);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X888E);
	op_dec		(x,	1);
	create_insn	(x=0X8895);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X889C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X88A3,	"[es:bp+DPB.ROOT_ENTRIES]\nNumber of root directory entries",	0);
	create_insn	(x=0X88AB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X88B1);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X88B7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X88BB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X88BF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X88C8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X88D6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X88DA,	"nextentry_retn");
	create_insn	(x=0X88DB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X88DF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X88E3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X88E7,	"[DI+BUFFINFO.buf_sector]",	0);
	create_insn	(x=0X88EA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X88F2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8900);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X8900,	"GETENTRY");
	create_insn	(x=0X8903);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X8903,	"GETENT");
	set_cmt	(0X890C,	"~(32-1)",	0);
	create_insn	(x=0X890C);
	op_hex		(x,	1);
	create_insn	(x=0X890F);
	op_hex		(x,	1);
	set_cmt	(0X8912,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	set_cmt	(0X8916,	"Must be multiple of 32",	0);
	create_insn	(x=0X8916);
	op_hex		(x,	1);
	set_cmt	(0X891B,	"Position within sector\nNOTE: This BX value is not used in DIRREAD\nErdogan Tan - 14/02/2024",	0);
	create_insn	(x=0X8924);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X8924,	"SETENTRY");
	set_cmt	(0X8928,	"BUFINSIZ",	0);
	create_insn	(x=0X8928);
	op_dec		(x,	1);
	set_cmt	(0X892D,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	create_byte	(x=0X8933);
	make_array	(x,	0X14);
	op_dec		(x,	0);
	set_name	(0X8933,	"sft_fcb_table");
	create_word	(0X8947);
	make_array	(0X8947,	0X2);
	set_name	(0X8947,	"sftfcb.cluster");
	create_word	(0X894B);
	set_name	(0X894B,	"sftfcb.direntry");
	set_cmt	(0X894D,	"6*20 = 120 ; entry size = 6 bytes",	0);
	create_byte	(x=0X894D);
	make_array	(x,	0X72);
	op_dec		(x,	0);
	create_word	(0X89BF);
	set_name	(0X89BF,	"SRCH_CLUSTER");
	create_word	(0X89C1);
	set_name	(0X89C1,	"SRCH_CLUSTER_HW");
	create_insn	(x=0X89C3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X89C3,	"SETDIRSRCH");
	create_insn	(x=0X89CE);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X89CE,	"SETDIRSRCH_FAT32");
	create_insn	(x=0X89D1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X89D4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X89D7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X89DB,	"[ES:BP+DPB.CLUSTER_MASK]",	0);
	create_insn	(x=0X89E1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X89E5,	"[FastOpenFlg],Lookup_Success",	0);
	create_insn	(x=0X89E5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X89F3,	"CCONTENT_HW:DI = Contents of FAT\nfor given cluster (from UNPACK)",	0);
	create_insn	(x=0X89F3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X89F7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X89FB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X89FF,	"Directory start cluster number\nfor searching/locating (directory entry)",	0);
	create_insn	(x=0X8A04);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8A11,	"\nCLUSTNUM_HW:DX = Physical cluster number",	0);
	create_insn	(x=0X8A11);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8A18);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8A1C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8A20);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8A27);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X8A27,	"SETROOTSRCH");
	set_cmt	(0X8A2D,	"DPB.FAT_SIZE",	0);
	set_cmt	(0X8A32,	"not FAT32",	0);
	set_cmt	(0X8A34,	"\nDPB.ROOT_CLUSTER+2",	0);
	set_name	(0X8A34,	"SETROOTSRCH_FAT32");
	create_insn	(x=0X8A38);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8A3C,	"DPB.LAST_CLUSTER+2",	0);
	set_cmt	(0X8A40,	"DPB.ROOT_CLUSTER",	0);
	set_cmt	(0X8A46,	"DPB.LAST_CLUSTER",	0);
	create_insn	(x=0X8A4C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X8A5B);
	create_insn	(0X8A5E);
	create_insn	(x=0X8A60);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8A63);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8A66);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8A69,	"search start dir cluster num = 1\n(root directory)",	0);
	set_cmt	(0X8A6E,	"1 ; FAT root directory (<2)",	0);
	set_cmt	(0X8A72,	"0",	0);
	create_insn	(x=0X8A73);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8A76,	"-1",	0);
	create_insn	(x=0X8A77);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8A7A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8A7D,	"[ES:BP+DPB.FIRST_SECTOR]",	0);
	set_cmt	(0X8A81,	"[ES:BP+DPB.DIR_SECTOR]",	0);
	create_insn	(x=0X8A87);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8A8A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8A90,	"set SFT number and entry \nin the new internal table\n(only for FCB calls)",	0);
	create_insn	(0X8A90);
	set_name	(0X8A90,	"set_sftfcb_entry");
	set_cmt	(0X8A96,	"ES:DI = SFT entry",	0);
	set_cmt	(0X8A97,	"\nax = SFT entry index number\n     of the last SFT entry",	0);
	set_cmt	(0X8A9C,	"find empty entry (slot) in the table",	0);
	create_insn	(x=0X8A9C);
	op_dec		(x,	1);
	set_cmt	(0X8A9F,	"[cs:bx+sftfcb.cluster+2]\ndirectory (search) starting cluster, hw",	0);
	create_insn	(x=0X8A9F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8AA7,	"[cs:bx+sftfcb.cluster]\ndirectory (search) starting cluster, lw",	0);
	create_insn	(x=0X8AA7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8AAD,	"not empty (sfcb table) entry",	0);
	set_cmt	(0X8AB0,	"search start dir cluster number",	0);
	set_cmt	(0X8AB5,	"directory start cluster",	0);
	create_insn	(x=0X8AB5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8ABF,	"PCDOS 7.1 BUG! (This would be\n'cs:sftfcb_cluster+2[bx],cx')\nErdogan Tan - 23/01/2024",	0);
	create_insn	(x=0X8ABF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8AC5,	"LAST (found) entry in the directory",	0);
	create_insn	(x=0X8AC5);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8ACA,	"[cs:bx+sftfcb.direntry]\ndirectory entry number",	0);
	create_insn	(x=0X8ACA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8AD2,	"sftfcb table has 6 byte entries",	0);
	set_cmt	(0X8AD8,	"put SFT entry number in SFT-FCB\ntable (offset is FCB index number 0 to 19)",	0);
	create_insn	(x=0X8AD8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X8ADF);
	set_cmt	(0X8AEC,	"es:di = SFT entry",	0);
	create_insn	(0X8AEC);
	set_name	(0X8AEC,	"find_sft_entry_number");
	set_cmt	(0X8AF6,	"address of the first SFT",	0);
	create_insn	(x=0X8AF6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8AFD,	"same SFT segment ?",	0);
	set_cmt	(0X8AFF,	"no",	0);
	set_cmt	(0X8B03,	"ax = entry offset",	0);
	set_cmt	(0X8B05,	"ax = offset from start of the SFT table\nSFT.SFTable",	0);
	set_cmt	(0X8B08,	"SF_ENTRY.size (SFT entry size)",	0);
	create_insn	(x=0X8B08);
	op_dec		(x,	1);
	set_cmt	(0X8B0D,	"ax = SFT entry index in the table",	0);
	set_cmt	(0X8B0F,	"ax = SFT index number (for requested SFT entry)",	0);
	set_cmt	(0X8B13,	"SFT.SFCount ; number of entries in the table",	0);
	create_insn	(0X8B13);
	set_cmt	(0X8B17,	"SFT.SFLink",	0);
	set_cmt	(0X8B1A,	"the last SFT",	0);
	set_cmt	(0X8B1F,	"(not found)",	0);
	set_cmt	(0X8B22,	"Windows95 - FIND SFT ENTRY IN INTERNAL FILE TABLES",	0);
	create_insn	(0X8B22);
	set_name	(0X8B22,	"int_2Fh_1230h");
	set_cmt	(0X8B27,	"ax = SFT enty index number (of the requested SFT entry)",	0);
	set_cmt	(0X8B2B,	"statically allocated with 20 entries,\nand used only for FCB calls",	0);
	create_insn	(x=0X8B2B);
	op_dec		(x,	1);
	set_cmt	(0X8B2E,	"new file system (internal) table\n only for fcb calls",	0);
	create_insn	(x=0X8B2E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8B34,	"not found (cf=1)",	0);
	set_cmt	(0X8B36,	"offset of the entry in the table",	0);
	set_cmt	(0X8B39,	"\nindex into new file system table",	0);
	create_insn	(x=0X8B39);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8B3F,	"2*bx",	0);
	set_cmt	(0X8B41,	"3*bx",	0);
	set_cmt	(0X8B43,	"bx = 6*bx  ; entry size = 6 bytes",	0);
	set_cmt	(0X8B45,	"dir start cluster number, hw",	0);
	create_insn	(x=0X8B45);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8B4A,	"directory entry number",	0);
	create_insn	(x=0X8B4A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8B50,	"dir start cluster number, lw",	0);
	create_insn	(x=0X8B50);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8B62,	"not found (cf=1)",	0);
	set_cmt	(0X8B65,	"clear stack",	0);
	create_insn	(0X8B65);
	set_cmt	(0X8B66,	"found (cf=0)",	0);
	create_insn	(0X8B6D);
	set_name	(0X8B6D,	"SFT_FREE");
	set_cmt	(0X8B74,	"[ES:DI+SF_ENTRY.sf_ref_Count]",	0);
	set_cmt	(0X8B7E,	"clear directory start cluster\n in the new (sftfcb) table",	0);
	create_insn	(x=0X8B7E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8B85,	"((empty entry))",	0);
	create_insn	(x=0X8B85);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8B94);
	op_hex		(x,	1);
	set_name	(0X8B94,	"check_longname");
	set_cmt	(0X8B99,	"DIRFREE*256+0\nNot Creating, not DEL *.*",	0);
	create_insn	(x=0X8B99);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X8B99,	"GETPATH");
	create_insn	(0X8B9F);
	set_name	(0X8B9F,	"GetPathNoSet");
	set_cmt	(0X8BA2,	"-1 ; initial setting",	0);
	create_insn	(x=0X8BA2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8BA8,	"point to the beginning of the name",	0);
	create_insn	(x=0X8BA8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8BAC,	"':\\'",	0);
	set_cmt	(0X8BB6,	"not required ! (15/02/2024)\n(it is written in CHKDEV proc already!)",	0);
	create_insn	(x=0X8BBD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8BC0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8BC8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8BCB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8BD1,	"8 chars in device name",	0);
	set_cmt	(0X8BE0,	"0 ; end of string",	0);
	set_cmt	(0X8BE2,	"Clears carry sets zero",	0);
	set_cmt	(0X8BE5,	"reset zero",	0);
	create_insn	(0X8BE8);
	set_cmt	(0X8BEA,	"attr_directory+attr_system+attr_hidden",	0);
	create_insn	(x=0X8BEA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8BEF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8BF3);
	op_hex		(x,	1);
	set_cmt	(0X8BF6,	"[ES:DI+curdir.ID+2]",	0);
	create_insn	(x=0X8BFA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8BFE,	"[ES:DI+curdir.ID]",	0);
	create_insn	(x=0X8C02);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8C06,	"if Current directory is not part",	0);
	set_cmt	(0X8C08,	"then we must crack from root",	0);
	create_insn	(x=0X8C0A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8C10,	"is the current directory cluster valid",	0);
	set_cmt	(0X8C12,	"no, crack from the root",	0);
	create_insn	(x=0X8C14);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X8C23);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8C2B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8C2F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8C32);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8C35);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8C38,	"FONC_Look_up",	0);
	set_cmt	(0X8C3C,	"call far [BX+fastopen_entry.name_caching]",	0);
	create_insn	(0X8C49);
	create_insn	(x=0X8C4A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8C56,	"crack based on cur dir",	0);
	create_insn	(x=0X8C58);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8C5F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8C65);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8C6E,	"set zero",	0);
	create_insn	(0X8C72);
	set_name	(0X8C72,	"CHKDEV");
	create_insn	(x=0X8C76);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X8C91);
	create_insn	(0X8C9D);
	create_insn	(x=0X8CA5);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8CA8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X8CAE);
	set_cmt	(0X8CB2,	"Get start clus of dir being searched",	0);
	create_insn	(x=0X8CB2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8CB6,	"-1",	0);
	create_insn	(x=0X8CB6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8CBB,	"No current dir part",	0);
	create_insn	(x=0X8CBD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8CC1,	"Not to current dir end yet",	0);
	create_insn	(x=0X8CC3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8CC7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8CCA,	"[ES:DI+curdir.ID+2]\nSet current directory cluster",	0);
	set_cmt	(0X8CCE,	"[ES:DI+curdir.ID]",	0);
	create_insn	(x=0X8CD4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8CE0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8CE5,	"not required ! (15/02/2024)",	0);
	create_insn	(x=0X8CF8);
	op_hex		(x,	1);
	create_insn	(x=0X8CFE);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8D0E);
	op_hex		(x,	1);
	create_insn	(0X8D14);
	create_insn	(0X8D17);
	set_cmt	(0X8D18,	"0 or 1",	0);
	create_insn	(x=0X8D1A);
	op_hex		(x,	1);
	set_cmt	(0X8D1D,	"Start of this element",	0);
	set_cmt	(0X8D1E,	"Restore ES:BP",	0);
	set_cmt	(0X8D21,	"NUL parse (two delims most likely)",	0);
	set_name	(0X8D23,	"check_device");
	create_insn	(x=0X8D2A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8D2E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8D39,	"Not a device",	0);
	set_cmt	(0X8D3B,	"Test next char again",	0);
	set_cmt	(0X8D3D,	"Device name in middle of path",	0);
	create_insn	(0X8D43);
	create_insn	(x=0X8D46);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8D4D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8D52,	"Start of this element",	0);
	set_cmt	(0X8D54,	"CL return from NameTrans",	0);
	set_cmt	(0X8D55,	"call fastopen to get dir entry",	0);
	set_cmt	(0X8D58,	"found dir entry",	0);
	create_insn	(x=0X8D62);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8D66,	"[BX+dir_entry.dir_attr],attr_directory",	0);
	create_insn	(x=0X8D66);
	op_hex		(x,	1);
	set_cmt	(0X8D6C,	"Error or end of path",	0);
	create_insn	(x=0X8D6F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8D77,	"Save pointer to entry",	0);
	set_cmt	(0X8D7E,	"FastOpen_Set",	0);
	create_insn	(x=0X8D7E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X8D85,	"Lookup_Success",	0);
	create_insn	(x=0X8D85);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X8D8C,	"no need to insert it again",	0);
	create_insn	(x=0X8D8C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X8D98);
	set_cmt	(0X8D9F,	"cmp [es:bp+DPB.FAT_SIZE],0",	0);
	set_cmt	(0X8DA5,	"dir_entry.dir_fclus_hi",	0);
	set_cmt	(0X8DA8,	"0",	0);
	create_insn	(x=0X8DA8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8DAD,	"dir_entry.dir_first",	0);
	set_cmt	(0X8DB2,	"Lookup_Success",	0);
	create_insn	(x=0X8DB2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X8DB7,	"fastopen not in memory\n or path not not found",	0);
	set_cmt	(0X8DBB,	"clusnum was set in LookupPath",	0);
	create_insn	(x=0X8DBB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8DBF,	"save device id (AH)",	0);
	set_cmt	(0X8DC3,	"restore device id (AH)",	0);
	set_cmt	(0X8DC4,	"pop ds in stack",	0);
	create_insn	(x=0X8DC4);
	op_hex		(x,	1);
	set_cmt	(0X8DC9,	"DS = [curbuf + 2]",	0);
	create_insn	(0X8DC9);
	set_cmt	(0X8DCA,	"Offset into sector of start of entry",	0);
	set_cmt	(0X8DCC,	"Offset into sector of dir_first",	0);
	set_cmt	(0X8DD2,	"[DI+BUFFINFO.buf_sector]",	0);
	create_insn	(x=0X8DDE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8DE5,	"Allowed_RETRY+Allowed_FAIL",	0);
	create_insn	(x=0X8DE5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8DEC,	"Get the entry buffer back",	0);
	set_cmt	(0X8DF5,	"Start of next element",	0);
	set_cmt	(0X8DF6,	"Point with SI",	0);
	create_insn	(0X8DFA);
	create_insn	(x=0X8DFD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8E01,	"Get the offsets back",	0);
	set_cmt	(0X8E05,	"Start of next element",	0);
	set_cmt	(0X8E06,	"insert dir entry info",	0);
	set_cmt	(0X8E0D,	"At end",	0);
	set_cmt	(0X8E0F,	"Skip over \"/\"",	0);
	set_cmt	(0X8E10,	"Point with SI",	0);
	set_cmt	(0X8E15,	"oops",	0);
	set_cmt	(0X8E17,	"Next element",	0);
	set_cmt	(0X8E1A,	"Undo above INC to get failure point",	0);
	create_insn	(0X8E1A);
	set_cmt	(0X8E1B,	"Set zero",	0);
	set_cmt	(0X8E1F,	"Start of next element",	0);
	create_insn	(0X8E1F);
	set_cmt	(0X8E22,	"FastOpen_Set",	0);
	create_insn	(x=0X8E22);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X8E29,	"Lookup_Success",	0);
	create_insn	(x=0X8E29);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X8E30);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8E3A,	"insert dir entry info",	0);
	set_cmt	(0X8E3D,	"Reset zero",	0);
	set_cmt	(0X8E40,	"Path too long",	0);
	create_insn	(0X8E40);
	set_cmt	(0X8E44,	"Start of next element",	0);
	create_insn	(0X8E44);
	set_cmt	(0X8E47,	"Start of bad element",	0);
	set_cmt	(0X8E49,	"zero if bad element is last,\nnon-zero if path too long",	0);
	create_insn	(x=0X8E4B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8E4E,	"Make sure return correct",	0);
	create_insn	(x=0X8E4E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8E53);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X8E53,	"STARTSRCH");
	create_insn	(x=0X8E59);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8E5C,	"No volume ID found",	0);
	create_insn	(x=0X8E5C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8E60);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8E63);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X8E67);
	set_name	(0X8E67,	"MatchAttributes");
	create_insn	(x=0X8E68);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8E70,	"attr_all",	0);
	create_insn	(x=0X8E70);
	op_hex		(x,	1);
	create_insn	(0X8E74);
	set_name	(0X8E74,	"DEVNAME");
	create_insn	(x=0X8E78);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8E7C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8E83);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8E88,	"attr_volume_id",	0);
	create_insn	(x=0X8E88);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X8E8F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8E92,	"[SI+SYSDEV.ATT],DEVTYP",	0);
	create_insn	(x=0X8E92);
	op_hex		(x,	1);
	set_cmt	(0X8E97,	"Skip block devices (NET and LOCAL)",	0);
	set_cmt	(0X8E9B,	"SYSDEV.NAME",	0);
	create_insn	(x=0X8E9B);
	op_dec		(x,	1);
	create_insn	(x=0X8E9E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8EA1,	"All devices are 8 letters",	0);
	set_cmt	(0X8EA4,	"Check for name in list",	0);
	set_cmt	(0X8EA7,	"Found it?",	0);
	set_cmt	(0X8EA9,	"Get address of next device",	0);
	set_cmt	(0X8EAB,	"-1 ; At end of list?",	0);
	set_cmt	(0X8EB0,	"Not found",	0);
	create_insn	(x=0X8EB5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8EBE,	"Save pointer to device",	0);
	create_insn	(x=0X8EBE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8EC3,	"[SI+SYSDEV.ATT]",	0);
	create_insn	(x=0X8EC6);
	op_hex		(x,	1);
	set_cmt	(0X8EC9,	"~(020h)",	0);
	create_insn	(x=0X8EC9);
	op_hex		(x,	1);
	create_insn	(x=0X8ECC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X8ED3);
	set_name	(0X8ED3,	"Build_device_ent");
	set_cmt	(0X8ED6,	"DEVFCB+8 ; Point to extent field",	0);
	create_insn	(x=0X8ED6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8EDA,	"Blank out extent field",	0);
	set_cmt	(0X8EDB,	"attr_device",	0);
	create_insn	(x=0X8EDB);
	op_hex		(x,	1);
	set_cmt	(0X8EDD,	"Set attribute field",	0);
	create_insn	(x=0X8EE0);
	op_dec		(x,	1);
	set_cmt	(0X8EE8,	"DEVFCB+dir_entry.dir_time",	0);
	create_insn	(x=0X8EE8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8EEF,	"SI points to dir_first field",	0);
	create_insn	(x=0X8EF1);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8EF4,	"Dir_first points to device",	0);
	create_insn	(x=0X8EF5);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8EF9,	"Put device atts in AH",	0);
	set_cmt	(0X8EFB,	"DEVFCB",	0);
	create_insn	(x=0X8EFB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8EFE,	"Set zero, clear carry",	0);
	create_insn	(0X8F01);
	set_name	(0X8F01,	"ValidateCDS");
	create_insn	(x=0X8F04);
	op_hex		(x,	1);
	create_insn	(x=0X8F07);
	op_stkvar	(x,	0);
	create_insn	(x=0X8F0A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8F0F);
	op_stkvar	(x,	0);
	create_insn	(x=0X8F12);
	op_stkvar	(x,	0);
	set_cmt	(0X8F18,	"[SI+curdir.flags],curdir_isnet",	0);
	create_insn	(x=0X8F18);
	op_hex		(x,	1);
	create_insn	(0X8F22);
	create_insn	(x=0X8F24);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8F2E);
	op_stkvar	(x,	1);
	set_cmt	(0X8F36,	"FatReadCDS (ThisCDS);",	0);
	create_insn	(x=0X8F38);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8F3C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8F47);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8F4B,	"if (ThisCDS->ID == -1) {",	0);
	create_insn	(x=0X8F59);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8F5E);
	op_stkvar	(x,	1);
	create_insn	(x=0X8F63);
	op_stkvar	(x,	1);
	create_insn	(x=0X8F66);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8F70);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8F7A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8F7E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8F82);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X8F86);
	op_stkvar	(x,	1);
	create_insn	(x=0X8F8B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8F90);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8F9C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X8FA1,	"[SI+curdir.flags],curdir_splice",	0);
	create_insn	(x=0X8FA1);
	op_hex		(x,	1);
	set_cmt	(0X8FA8,	"-1",	0);
	create_insn	(x=0X8FAD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X8FB2,	"[SI+curdir.ID+2]",	0);
	set_cmt	(0X8FB5,	"[SI+curdir.ID]",	0);
	create_insn	(x=0X8FB8);
	op_stkvar	(x,	1);
	create_insn	(x=0X8FBB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8FC0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X8FC9);
	op_stkvar	(x,	1);
	create_insn	(0X8FD0);
	set_name	(0X8FD0,	"CheckThisDevice");
	set_cmt	(0X8FD6,	"is it a path char?",	0);
	set_cmt	(0X8FD9,	"no, go attempt to parse device",	0);
	set_cmt	(0X8FDB,	"simulate LODSB",	0);
	create_insn	(x=0X8FDD);
	op_hex		(x,	1);
	set_cmt	(0X8FE0,	"cmp ax,'de' ; (NASM syntax)",	0);
	set_cmt	(0X8FE3,	"assume not device",	0);
	create_insn	(x=0X8FE6);
	op_hex		(x,	1);
	set_cmt	(0X8FE8,	"cmp al,'v'",	0);
	set_cmt	(0X8FEA,	"assume not device",	0);
	set_cmt	(0X8FED,	"do we have the last path separator?",	0);
	set_cmt	(0X8FF0,	"no. go for it.",	0);
	set_cmt	(0X8FF7,	"parse entire string?",	0);
	set_cmt	(0X8FFA,	"simulate a Carry return from DevName",	0);
	set_cmt	(0X8FFB,	"no parse. simulate a file return.",	0);
	create_insn	(x=0X8FFF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9002,	"set Attrib for DevName",	0);
	create_insn	(x=0X9002);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X900B,	"if device then do not reset pointer",	0);
	set_cmt	(0X9010,	"invert carry. Carry => device",	0);
	create_insn	(0X9012);
	set_cmt	(0X9015,	"FastOpen_Set",	0);
	create_insn	(x=0X9015);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0X9015,	"LookupPath");
	set_cmt	(0X901B,	"flg is set in DOSOPEN",	0);
	set_cmt	(0X9020,	"No_Lookup ; no more lookup?",	0);
	create_insn	(x=0X9020);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X9026,	"yes",	0);
	create_insn	(x=0X9028);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X902B,	"si points to path name",	0);
	create_insn	(x=0X902B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9030);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9033);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9036,	"FONC_Look_up",	0);
	set_cmt	(0X903A,	"call far [BX+fastopen_entry.name_caching]",	0);
	set_cmt	(0X903F,	"fastopen not in memory",	0);
	create_insn	(0X9042);
	set_cmt	(0X9045,	"path found ?",	0);
	create_insn	(x=0X9045);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X904A,	"no",	0);
	set_cmt	(0X904C,	"partiallyfound",	0);
	set_cmt	(0X904F,	"is attribute matched ?",	0);
	create_insn	(x=0X9052);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9057);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X905C,	"attrib=sattrib",	0);
	create_insn	(x=0X905C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9061,	"[ES:DI+dir_entry.dir_attr]",	0);
	set_cmt	(0X9069,	"not matched",	0);
	create_insn	(x=0X906B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9078);
	op_hex		(x,	1);
	create_insn	(0X9083);
	set_cmt	(0X9085,	"[bx+FEI.dirstart]",	0);
	create_insn	(x=0X9088);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X908C,	"[bx+FEI.clusnum+2]",	0);
	create_insn	(x=0X908F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9093,	"[bx+FEI.clusnum]",	0);
	create_insn	(x=0X9096);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X909A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X909F,	"[bx+FEI.lastent]",	0);
	create_insn	(x=0X90A2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X90A7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X90AC,	"[ES:BX+DPB.DRIVE]",	0);
	set_cmt	(0X90B0,	"indicate not root dir",	0);
	create_insn	(x=0X90B0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X90B7,	"[curbuf+2].bx points to",	0);
	create_insn	(x=0X90B7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X90BC,	"start of entry",	0);
	set_cmt	(0X90BE,	"[DI+dir_entry.dir_first]\n[curbuf+2]:si points to dir_first field",	0);
	set_cmt	(0X90C1,	"Lookup_Success+Set_For_Search",	0);
	create_insn	(x=0X90C1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X90C8,	"-1  ; not in memory ?",	0);
	create_insn	(0X90C8);
	set_cmt	(0X90CB,	"yes, in memory",	0);
	set_cmt	(0X90CD,	"no more fastopen",	0);
	create_insn	(x=0X90CD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X90D3,	"Special_Fill_Reset",	0);
	create_insn	(x=0X90D3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(0X90DB);
	set_name	(0X90DB,	"InsertPath");
	set_cmt	(0X90DC,	"FastOpen_Set\nonly DOSOPEN can take advantage of",	0);
	create_insn	(x=0X90DC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X90E2,	"the FastOpen",	0);
	set_cmt	(0X90E4,	"Lookup_Success ; Lookup just happened",	0);
	create_insn	(x=0X90E4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X90EA,	"no",	0);
	set_cmt	(0X90EC,	"Lookup_Reset\nwe got dir info from fastopen so",	0);
	create_insn	(x=0X90EC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X90F2,	"no need to insert it again",	0);
	create_insn	(x=0X90F2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X90F9);
	create_insn	(x=0X9100);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9105);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9108,	"[DI+BUFFINFO.buf_sector]\nget directory sector",	0);
	set_cmt	(0X910B,	"[SS:SI+FEI.dirsec]",	0);
	set_cmt	(0X910F,	"[SS:SI+FEI.dirsec+2]",	0);
	set_cmt	(0X9115,	"save next cluster number",	0);
	create_insn	(x=0X9115);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9118,	"[si+FEI.clusnum+2]",	0);
	create_insn	(x=0X911B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X911E,	"[si+FEI.clusnum]",	0);
	set_cmt	(0X9121,	"save lastentry for search first",	0);
	create_insn	(x=0X9121);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9124,	"[si+FEI.lastent]",	0);
	set_cmt	(0X9127,	"save  for search first",	0);
	create_insn	(x=0X9127);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X912A,	"[si+FEI.dirstart]",	0);
	set_cmt	(0X912F,	"BUFINSIZ",	0);
	create_insn	(x=0X912F);
	op_dec		(x,	1);
	set_cmt	(0X9132,	"AX = relative to start of sector",	0);
	set_cmt	(0X9134,	"dir_entry.size",	0);
	create_insn	(x=0X9134);
	op_dec		(x,	1);
	set_cmt	(0X9138,	"mov [si+FEI.dirpos],al\nsave directory entry # in buffer",	0);
	create_insn	(x=0X913C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9142,	"[DI+dir_entry.dir_first]\nnever insert info when file is empty",	0);
	set_cmt	(0X9146,	"newly created file\n\n; 21/02/2024 - Erdogan Tan\n; Note: PCDOS 7.1 IBMDOS.COM code doesn't check high word\n;   of the 1st cluster here\n;;;\n; 21/02/2024 - Retro DOS v5.0\n;jnz    short dont_skip_insert\n;;cmp   word [di+14h],0\n;cmp    word [di+dir_entry.dir_fclus_hi],0\n;jz short SKIP_INSERT\n;dont_skip_insert:  ; Retro DOS v5.0\n;;;",	0);
	set_cmt	(0X914A,	"FONC_insert\ncall fastopen insert operation",	0);
	create_insn	(x=0X914C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X914F,	"call far [ES:SI+fastopen_entry.name_caching]",	0);
	set_cmt	(0X915B,	"No_Lookup",	0);
	create_insn	(x=0X915B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X9163,	"length of packets\nDRDWRHL",	0);
	create_byte	(x=0X9163);
	op_dec		(x,	0);
	set_name	(0X9163,	"LenTab");
	set_cmt	(0X9164,	"DRDNDHL",	0);
	create_byte	(x=0X9164);
	op_dec		(x,	0);
	set_cmt	(0X9165,	"DRDWRHL",	0);
	create_byte	(x=0X9165);
	op_dec		(x,	0);
	set_cmt	(0X9166,	"DSTATHL",	0);
	create_byte	(x=0X9166);
	op_dec		(x,	0);
	set_cmt	(0X9167,	"DFLSHL\n(This was 15 in MSDOS 6.22 MSDOS.SYS & Win ME IO.SYS)",	0);
	create_byte	(x=0X9167);
	op_dec		(x,	0);
	set_cmt	(0X9168,	"DRDNDHL",	0);
	create_byte	(x=0X9168);
	op_dec		(x,	0);
	set_cmt	(0X9169,	"0 input",	0);
	create_byte	(x=0X9169);
	op_hex		(x,	0);
	set_name	(0X9169,	"CmdTab");
	set_cmt	(0X916A,	"DEVRD ; Read",	0);
	create_byte	(0X916A);
	set_cmt	(0X916B,	"1 input status",	0);
	create_byte	(0X916B);
	set_cmt	(0X916C,	"DEVRDND",	0);
	create_byte	(0X916C);
	set_cmt	(0X916D,	"2 output",	0);
	create_byte	(0X916D);
	set_cmt	(0X916E,	"DEVWRT ; Write",	0);
	create_byte	(0X916E);
	set_cmt	(0X916F,	"3 output status",	0);
	create_byte	(0X916F);
	set_cmt	(0X9170,	"DEVOST ; Output status",	0);
	create_byte	(x=0X9170);
	op_dec		(x,	0);
	set_cmt	(0X9171,	"4 input flush",	0);
	create_byte	(0X9171);
	set_cmt	(0X9172,	"DEVIFL ; Input flush",	0);
	create_byte	(0X9172);
	set_cmt	(0X9173,	"5 input status with system WAIT",	0);
	create_byte	(0X9173);
	set_cmt	(0X9174,	"DEVRDND ; Non destructive read no wait (char devs)",	0);
	create_byte	(0X9174);
	create_insn	(x=0X9175);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X9175,	"IOFUNC");
	create_insn	(x=0X917A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9181);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9188);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X918C,	"[SI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)",	0);
	create_insn	(x=0X918C);
	op_hex		(x,	1);
	set_cmt	(0X9195,	"[SI+SF_ENTRY.sf_flags],devid_device",	0);
	create_insn	(x=0X9195);
	op_hex		(x,	1);
	create_insn	(0X919E);
	set_cmt	(0X91AC,	"system wait enabled?",	0);
	set_cmt	(0X91B1,	"Set bit 10 in status word for driver",	0);
	create_insn	(x=0X91B3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X91B9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X91BD,	"get function",	0);
	create_insn	(x=0X91BF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X91C6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X91CB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X91CE,	"[IOCALL_REQLEN]",	0);
	create_insn	(x=0X91CE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X91D2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X91DB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X91E8,	"DEVRDND",	0);
	set_cmt	(0X91ED,	"[IORCHR]",	0);
	create_insn	(x=0X91ED);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X91F0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X91F3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X91F7,	"Zero = busy, not zero = ready",	0);
	set_cmt	(0X91F9,	"STBUI>>8",	0);
	create_insn	(x=0X91F9);
	op_hex		(x,	1);
	set_cmt	(0X9201,	"assume fail error",	0);
	create_insn	(x=0X9201);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9205,	"sign extend to word",	0);
	set_cmt	(0X9206,	"21/02/2024 - Erdogan Tan\nthis may be a BUG\nMSDOS 6.22 MSDOS.SYS & Win ME IO.SYS code is\n cbw\n cmp  ax,-1\n jne  short not_fail_ret\n inc  byte [ss:IoStatFail]\n popf\n retn",	0);
	set_cmt	(0X920A,	"jns ?",	0);
	create_insn	(x=0X920C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9213);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X9219);
	set_cmt	(0X9229,	"[SS:IOCALL_REQSTAT+1],\n~(STBUI>>8)",	0);
	create_insn	(x=0X9229);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X9233,	"set flag indicating fail on I24",	0);
	create_insn	(x=0X9233);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X923A);
	set_cmt	(0X9247,	"[SI+SF_ENTRY.sf_position]",	0);
	create_insn	(0X9247);
	set_cmt	(0X924A,	"[SI+SF_ENTRY.sf_position+2]",	0);
	set_cmt	(0X9250,	"[SI+SF_ENTRY.sf_position+2]",	0);
	create_insn	(0X9250);
	set_cmt	(0X9253,	"[SI+SF_ENTRY.sf_position]",	0);
	create_insn	(0X9257);
	create_insn	(0X9260);
	set_name	(0X9260,	"IOUT_retn");
	create_insn	(0X9261);
	set_name	(0X9261,	"IOIN");
	set_cmt	(0X9264,	"Disable_EOF_I24",	0);
	create_insn	(x=0X9264);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X926D,	"NO_Disable_EOF_I24",	0);
	create_insn	(x=0X926D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X9278,	"Get byte from trans addr",	0);
	create_insn	(x=0X9278);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X927E,	"^Z if no bytes",	0);
	set_cmt	(0X9281,	"[SS:CALLSCNT] ; Return address",	0);
	create_insn	(x=0X9281);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X9281,	"SETXADDR");
	create_insn	(x=0X928A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X928F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9296);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X929B,	"Set byte trans addr",	0);
	create_insn	(x=0X929B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X92A0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X92A9,	"Finish setting SFT pointer",	0);
	create_insn	(x=0X92A9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X92AD,	"ioscnt specifies length of buffer",	0);
	create_insn	(x=0X92AD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X92B1,	"[CALLSCNT]",	0);
	create_insn	(x=0X92B1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X92B5,	"[CALLSCNT] ; Return address",	0);
	create_insn	(x=0X92B5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X92B5,	"RESTXADDR");
	set_cmt	(0X92B9,	"Restore Disk trans addr",	0);
	create_insn	(x=0X92B9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X92BD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X92C5,	"[SS:CALLSCNT] ; Return address",	0);
	create_insn	(x=0X92C5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X92CA);
	set_name	(0X92CA,	"DEV_OPEN_SFT");
	set_cmt	(0X92CE,	"DEVOPN",	0);
	create_insn	(0X92D2);
	set_name	(0X92D2,	"DEV_CLOSE_SFT");
	set_cmt	(0X92D6,	"DEVCLS",	0);
	set_cmt	(0X92D8,	"[es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8)",	0);
	create_insn	(x=0X92D8);
	op_hex		(x,	1);
	set_name	(0X92D8,	"DO_OPCLS");
	set_cmt	(0X92DD,	"NOP on net SFTs",	0);
	set_cmt	(0X92E1,	"[ES:DI+SF_ENTRY.sf_flags],devid_device",	0);
	create_insn	(x=0X92E1);
	op_hex		(x,	1);
	set_cmt	(0X92E6,	"[ES:DI+SF_ENTRY.sf_devptr] ; Get DPB or device",	0);
	create_insn	(x=0X92EC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X92F4,	"[ES:DI+DPB.DRIVE]",	0);
	set_cmt	(0X92F7,	"[ES:DI+DPB.UNIT]",	0);
	set_cmt	(0X92F9,	"[ES:DI+DPB.DRIVER_ADDR]",	0);
	set_cmt	(0X92FD,	"[ES:DI+SYSDEV.ATT+1],(DEVOPCL>>8)",	0);
	create_insn	(x=0X92FD);
	op_hex		(x,	1);
	set_cmt	(0X9306,	"DS:SI -> device",	0);
	set_cmt	(0X930A,	"DEVCALL",	0);
	create_insn	(x=0X930A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9310,	"DOPCLHL",	0);
	set_cmt	(0X9312,	"Length",	0);
	set_cmt	(0X9314,	"Unit",	0);
	set_cmt	(0X9319,	"Status",	0);
	set_cmt	(0X931E,	"Save Unit,Command",	0);
	set_cmt	(0X9322,	"[ES:BX+SRHEAD.REQSTAT]",	0);
	set_cmt	(0X9328,	"No error",	0);
	set_cmt	(0X932A,	"[SI+SYSDEV.ATT+1],(DEVTYP>>8)",	0);
	create_insn	(x=0X932A);
	op_hex		(x,	1);
	set_cmt	(0X9330,	"Read error in data, Char dev",	0);
	set_cmt	(0X9334,	"Drive number",	0);
	create_insn	(0X9334);
	set_cmt	(0X9336,	"Read error in data, Blk dev",	0);
	set_cmt	(0X933D,	"IGNORE or FAIL\nNote that FAIL is essentually IGNORED",	0);
	set_cmt	(0X933F,	"Get back Unit, Command",	0);
	set_cmt	(0X9342,	"Clean stack",	0);
	create_insn	(0X9342);
	set_cmt	(0X9348,	"CALLNEWSC, HIGH_SECTOR & CALLDEVAD\nLDS SI,[SI+SF_ENTRY.sf_devptr]",	0);
	create_insn	(0X9348);
	set_name	(0X9348,	"DEVIOCALL");
	create_insn	(0X934B);
	set_name	(0X934B,	"DEVIOCALL2");
	set_cmt	(0X934E,	"[SI+SYSDEV.ATT+1],(DEVTYP>>8)",	0);
	create_insn	(x=0X934E);
	op_hex		(x,	1);
	set_cmt	(0X9354,	"[ES:BX+SRHEAD.REQFUNC]",	0);
	set_cmt	(0X9358,	"DEVRD",	0);
	set_cmt	(0X935C,	"DEVWRT",	0);
	set_cmt	(0X9360,	"DEVWRTV",	0);
	set_cmt	(0X9364,	"[SI+SYSDEV.ATT],EXTDRVR",	0);
	create_insn	(x=0X9364);
	op_hex		(x,	1);
	set_cmt	(0X936A,	"-1 ; old sector",	0);
	set_cmt	(0X936D,	"make length to 30",	0);
	create_insn	(x=0X9371);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9376);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X937A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X937E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9384,	"if >32mb",	0);
	create_insn	(x=0X9384);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X938A,	"then fake error",	0);
	set_cmt	(0X938C,	"lock (deviocall in progress)",	0);
	create_insn	(x=0X938C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9391,	"[SI+SYSDEV.STRAT]",	0);
	create_insn	(x=0X9394);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9398);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X939D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X93A2,	"[SI+SYSDEV.INT]",	0);
	create_insn	(x=0X93A5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X93A9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X93AE,	"unlock (deviocall completed)",	0);
	create_insn	(x=0X93AE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X93B7,	"[ES:BX+SRHEAD.REQSTAT],\nSTERR+STDON+error_I24_not_DOS_disk",	0);
	create_insn	(0X93B7);
	create_insn	(0X93BF);
	set_name	(0X93BF,	"SETREAD");
	set_cmt	(0X93C2,	"DEVRD",	0);
	set_cmt	(0X93C4,	"DRDWRHL",	0);
	create_insn	(x=0X93C4);
	op_dec		(x,	1);
	set_name	(0X93C4,	"SETCALLHEAD");
	set_cmt	(0X93CA,	"DEVCALL",	0);
	create_insn	(x=0X93CA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X93CD,	"length",	0);
	set_cmt	(0X93CF,	"Unit",	0);
	set_cmt	(0X93D0,	"Command code",	0);
	set_cmt	(0X93D4,	"Status",	0);
	create_insn	(x=0X93D9);
	op_dec		(x,	1);
	set_cmt	(0X93DC,	"Media byte",	0);
	set_cmt	(0X93E2,	"Transfer addr",	0);
	set_cmt	(0X93ED,	"Count",	0);
	set_cmt	(0X93EF,	"Start",	0);
	set_cmt	(0X93F4,	"DEVCALL",	0);
	create_insn	(x=0X93F4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X93F8);
	set_name	(0X93F8,	"SETWRITE");
	set_cmt	(0X93FB,	"DEVWRT",	0);
	create_insn	(x=0X93FD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X9404);
	create_insn	(0X9406);
	create_insn	(0X9408);
	create_insn	(x=0X940A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X940A,	"BUILDDIR");
	create_insn	(x=0X9414);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X941B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9422,	"Can't grow root",	0);
	create_insn	(x=0X9424);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X9424,	"NEWDIR");
	create_insn	(x=0X9428);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X942E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X943B,	"Screw up",	0);
	set_cmt	(0X943F,	"0",	0);
	create_insn	(x=0X943F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9443,	"1",	0);
	create_insn	(x=0X9449);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X944D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9457);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X945B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9464);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X946C);
	create_insn	(x=0X946D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9471);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9475);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9479);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9480);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9487);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X948B,	"(not necessary)",	0);
	create_insn	(x=0X948E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9491);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9494,	"CLUSNUM update",	0);
	set_cmt	(0X9496,	"drive #",	0);
	set_cmt	(0X949A,	"first cluster #",	0);
	create_insn	(x=0X949A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X949E,	"CLUSNUM",	0);
	set_cmt	(0X94A0,	"update CLUSNUM in the fastopen cache",	0);
	set_cmt	(0X94AD,	"[ES:BP+DPB.CLUSTER_MASK]",	0);
	set_cmt	(0X94B5,	"Allowed_FAIL+Allowed_RETRY",	0);
	create_insn	(x=0X94B5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X94C3,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	create_insn	(0X94C3);
	create_insn	(x=0X94C8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X94CC,	"[ES:DI+BUFFINFO.buf_flags],buf_isDIR",	0);
	create_insn	(x=0X94CC);
	op_hex		(x,	1);
	create_insn	(x=0X94D2);
	op_dec		(x,	1);
	create_insn	(x=0X94D7);
	op_hex		(x,	1);
	create_insn	(x=0X94E6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X94ED);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X94F3,	"set up a . or .. directory entry\n for a directory",	0);
	create_insn	(0X94F3);
	set_name	(0X94F3,	"SETDOTENT");
	set_cmt	(0X94FD,	"Set up attribute",	0);
	create_insn	(x=0X9503);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9506,	"Set up first cluster field, hw",	0);
	set_cmt	(0X9507,	"Initialize time and date of creation",	0);
	create_insn	(x=0X9507);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X950B,	"[SI+SF_ENTRY.sf_time]",	0);
	set_cmt	(0X950F,	"[SI+SF_ENTRY.sf_date]",	0);
	set_cmt	(0X9513,	"Set up first cluster field, lw",	0);
	set_cmt	(0X951A,	"DIRFREE*256 + 0FFh\nCreating, not DEL *.*",	0);
	create_insn	(x=0X951A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X951A,	"MakeNode");
	set_cmt	(0X9520,	"Save AH value",	0);
	create_insn	(x=0X9521);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9526);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X952E,	"Device ID to CH",	0);
	set_cmt	(0X952F,	"Get back AH",	0);
	set_cmt	(0X9530,	"File existed",	0);
	set_cmt	(0X9532,	"Path bad",	0);
	set_cmt	(0X9534,	"Check \"CL\" return from GETPATH",	0);
	set_cmt	(0X9537,	"jz short make_type\nName simply not found, and no metas",	0);
	set_cmt	(0X9539,	"case 1 bad path",	0);
	set_name	(0X953B,	"make_err_ret");
	set_cmt	(0X953E,	"make_type:\nEXT_OPEN_ON",	0);
	create_insn	(x=0X953E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0X953E,	"RENAME_MAKE");
	set_cmt	(0X9545,	"EXT_FILE_NOT_EXISTS",	0);
	create_insn	(x=0X9545);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X954A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X9552,	"file not found",	0);
	set_name	(0X9555,	"make_retn");
	create_insn	(x=0X9556);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X955A,	"nothing exists Disk Node",	0);
	set_cmt	(0X955C,	"Not found",	0);
	create_insn	(0X955F);
	set_cmt	(0X9561,	"file exists type 3\n (error or device node)",	0);
	set_cmt	(0X9563,	"attr_volume_id+attr_directory",	0);
	create_insn	(x=0X9563);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X9568,	"Cannot already exist as Disk or Device Node\n if making DIR or Volume ID",	0);
	set_cmt	(0X956C,	"No further checks on attributes if device",	0);
	set_cmt	(0X9570,	"truncating NOT OK (AL = 3)",	0);
	set_cmt	(0X9572,	"Save device ID",	0);
	create_insn	(x=0X9573);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9577,	"[ES:BX+dir_entry.dir_attr]\nGet file attributes",	0);
	set_cmt	(0X957B,	"attr_read_only",	0);
	create_insn	(x=0X957B);
	op_hex		(x,	1);
	set_cmt	(0X957E,	"Cannot create on read only files",	0);
	set_cmt	(0X9583,	"Devid back in CH",	0);
	set_cmt	(0X9584,	"Attributes not ok",	0);
	set_cmt	(0X9586,	"AL = 0, Disk Node",	0);
	set_cmt	(0X958B,	"Device ID to AH",	0);
	set_cmt	(0X958D,	"Fill in SFT for share check",	0);
	create_insn	(x=0X9590);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X95A3,	"Get back device ID",	0);
	create_insn	(0X95A3);
	set_cmt	(0X95A4,	"Attribute mismatch",	0);
	set_cmt	(0X95A8,	"exists as directory, always an error",	0);
	create_insn	(0X95A8);
	create_insn	(0X95AC);
	set_name	(0X95AC,	"make_save");
	set_cmt	(0X95AD,	"Device ID to AH",	0);
	set_cmt	(0X95B2,	"0 if Disk, 3 if File",	0);
	set_cmt	(0X95B5,	"create failed case 2",	0);
	set_name	(0X95B7,	"make_save_retn");
	create_insn	(0X95B8);
	set_cmt	(0X95BB,	"case 2 fail",	0);
	set_cmt	(0X95BD,	"attr_directory",	0);
	create_insn	(x=0X95BD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X95C2,	"Don't \"open\" directories,\nso don't tell the sharer about them",	0);
	create_insn	(x=0X95D0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X95D4,	"DIRFREE ; nuke newly created entry",	0);
	create_insn	(x=0X95DB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X95DF,	"get drive for flush",	0);
	set_cmt	(0X95E3,	"write out buffer",	0);
	set_cmt	(0X95E9,	"grab SFT",	0);
	create_insn	(x=0X95E9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X95EF,	"call ECritSFT",	0);
	set_cmt	(0X95F2,	"[ES:DI+SF_ENTRY.sf_ref_count]",	0);
	set_cmt	(0X95F9,	"remove sharing",	0);
	set_cmt	(0X95FF,	"[ES:DI+SF_ENTRY.sf_ref_count]",	0);
	set_cmt	(0X9602,	"call LCritSFT",	0);
	set_cmt	(0X960C,	"bye if error",	0);
	set_cmt	(0X9612,	"reassert the share access",	0);
	set_name	(0X9619,	"makeendshare_retn");
	create_insn	(x=0X961A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X961A,	"NEWENTRY");
	create_insn	(x=0X9620);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9626,	"User FAILed, node might exist",	0);
	set_cmt	(0X9628,	"Try to build dir",	0);
	set_cmt	(0X962B,	"Failed",	0);
	set_cmt	(0X962D,	"Point at that free entry",	0);
	set_cmt	(0X9630,	"Failed",	0);
	create_insn	(0X9634);
	set_cmt	(0X9636,	"Check if file is I/O device",	0);
	create_insn	(0X9636);
	set_cmt	(0X963A,	"If so, proceed with open",	0);
	set_cmt	(0X963D,	"Free cluster chain",	0);
	create_insn	(0X963D);
	set_cmt	(0X9640,	"Failed",	0);
	set_cmt	(0X9642,	"attr_volume_id",	0);
	create_insn	(x=0X9642);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X9649);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X964E,	"Can't create a second volume ID",	0);
	create_insn	(x=0X9650);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9656);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X965C,	"Move name into dir entry",	0);
	create_insn	(x=0X965F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9662,	"Attributes",	0);
	set_cmt	(0X9667,	"Zero pad",	0);
	set_cmt	(0X966D,	"dir_time",	0);
	set_cmt	(0X966F,	"last access date",	0);
	set_cmt	(0X9673,	"dir_date",	0);
	set_cmt	(0X9676,	"Correct SI input value\n(recomputed for new buffer)",	0);
	set_cmt	(0X9677,	"Zero dir_first and size",	0);
	create_insn	(x=0X967A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X967A,	"updnxt");
	set_cmt	(0X967E,	"[ES:SI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0X967E);
	op_hex		(x,	1);
	set_cmt	(0X9683,	"don't increment dirty count",	0);
	set_cmt	(0X9688,	"ES:SI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0X9688);
	op_hex		(x,	1);
	create_insn	(x=0X968D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9691,	"[ES:BP+DPB.DRIVE]\nSets AH value again (in AL)",	0);
	create_insn	(x=0X9699);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X969D,	"[ES:DI+SF_ENTRY.sf_flags],devid_device",	0);
	create_insn	(x=0X969D);
	op_hex		(x,	1);
	create_insn	(x=0X96A6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X96AA,	"[ES:DI+SF_ENTRY.sf_devptr]",	0);
	set_cmt	(0X96B0,	"[ES:DI+SF_ENTRY.sf_devptr+2]",	0);
	set_cmt	(0X96B5,	"need to use DS for segment later on",	0);
	set_cmt	(0X96BD,	"Get SI input back",	0);
	set_cmt	(0X96BE,	"Get I/O driver number back",	0);
	set_cmt	(0X96C2,	"Failed",	0);
	set_cmt	(0X96C3,	"AH to different place",	0);
	create_insn	(0X96C3);
	set_name	(0X96C3,	"DOOPEN");
	create_insn	(x=0X96CB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X96CF,	"[es:di+DPB.FAT_SIZE]",	0);
	set_cmt	(0X96D4,	"FAT32",	0);
	create_insn	(x=0X96D8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X96DC,	"SF_ENTRY.sf_attr\nSkip ref_count and mode fields",	0);
	create_insn	(x=0X96E5);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X96E9,	"[BX+dir_entry.dir_attr]\nIf file, get attrib from dir entry",	0);
	set_cmt	(0X96EC,	"sf_attr, ES:DI -> sf_flags",	0);
	set_cmt	(0X96F1,	"devid_file_clean",	0);
	create_insn	(x=0X96F1);
	op_hex		(x,	1);
	set_cmt	(0X96F3,	"sf_flags, ES:DI -> sf_devptr",	0);
	set_cmt	(0X96F5,	"[BX+dir_entry.dir_first] ; Assume device",	0);
	set_cmt	(0X96FC,	"Was file",	0);
	create_insn	(x=0X96FC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9701,	"store offset",	0);
	set_cmt	(0X9705,	"store segment, ES:DI -> sf_firclus",	0);
	set_cmt	(0X9707,	"SF_ENTRY.sf_chain ; first cluster (32 bit) !?",	0);
	create_insn	(x=0X9707);
	op_dec		(x,	1);
	set_cmt	(0X970A,	"first cluster, lw",	0);
	set_cmt	(0X970B,	"add si, -8",	0);
	set_cmt	(0X970E,	"first cluster, hw",	0);
	set_cmt	(0X9711,	"FAT32",	0);
	set_cmt	(0X9713,	"clear hw of first cluster (invalid)",	0);
	set_cmt	(0X9716,	"add di, -34",	0);
	set_cmt	(0X9719,	"dir_time -> sf_time",	0);
	set_cmt	(0X971A,	"dir_date -> sf_date",	0);
	set_cmt	(0X971B,	"skip dir_first, DS:SI -> dir_size_l",	0);
	set_cmt	(0X971C,	"dir_size_l in AX, DS:SI -> dir_size_h",	0);
	set_cmt	(0X971D,	"dir_size_l in CX",	0);
	set_cmt	(0X971E,	"dir_size_h (size AX:CX), DS:SI -> ????",	0);
	set_cmt	(0X9723,	"0",	0);
	set_cmt	(0X9725,	"Devices are open ended",	0);
	set_cmt	(0X9728,	"Low word of sf_size",	0);
	set_cmt	(0X972A,	"High word of sf_size, ES:DI -> sf_position",	0);
	set_cmt	(0X972B,	"0",	0);
	set_cmt	(0X972E,	"sf_position = 0, ES:DI -> sf_cluspos",	0);
	set_cmt	(0X9733,	"sf_cluspos ; 19h",	0);
	set_cmt	(0X9734,	"add di, -16",	0);
	set_cmt	(0X9737,	"sf_cluspos_h (sf_firclus in MSDOS 5.0-6.22)",	0);
	set_cmt	(0X9738,	"sf_dirsec ; 27",	0);
	create_insn	(x=0X9738);
	op_dec		(x,	1);
	set_cmt	(0X973B,	"[ES:DI+SF_ENTRY.sf_chain] ; 43\nfirst cluster (32 bit)",	0);
	create_insn	(x=0X973B);
	op_hex		(x,	1);
	set_cmt	(0X973F,	"[ES:DI+SF_ENTRY.sf_lstclus] ; 53",	0);
	create_insn	(x=0X973F);
	op_hex		(x,	0);
	set_cmt	(0X9743,	"[ES:DI+SF_ENTRY.sf_chain+2] ; 45",	0);
	create_insn	(x=0X9743);
	op_hex		(x,	1);
	set_cmt	(0X9747,	"[ES:DI+SF_ENTRY.sf_lstclus+2] ; 55",	0);
	create_insn	(x=0X9747);
	op_hex		(x,	0);
	set_cmt	(0X974E,	"Special_Fill_Set",	0);
	create_insn	(x=0X974E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X9755);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9758,	"FEI.dirsec",	0);
	set_cmt	(0X975B,	"sf_dirsec, lw",	0);
	set_cmt	(0X975C,	"FEI.dirsec+2",	0);
	set_cmt	(0X975F,	"sf_dirsec, hw",	0);
	set_cmt	(0X9760,	"FEI.dirpos",	0);
	set_cmt	(0X9762,	"sf_dirpos ; 31",	0);
	create_insn	(0X9766);
	create_insn	(x=0X9767);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X976C,	"[SI+BUFFINFO.buf_sector]",	0);
	set_cmt	(0X976F,	"sf_dirsec, lw ; 27",	0);
	set_cmt	(0X9770,	"[SI+BUFFINFO.buf_sector+2]",	0);
	set_cmt	(0X9773,	"sf_dirsec, hw ; 29",	0);
	set_cmt	(0X9776,	"BUFINSIZ ; DS:SI-> start of data in buffer",	0);
	create_insn	(x=0X9776);
	op_dec		(x,	1);
	set_cmt	(0X9779,	"AX = BX relative to start of sector",	0);
	set_cmt	(0X977B,	"dir_entry.size",	0);
	create_insn	(x=0X977B);
	op_dec		(x,	1);
	set_cmt	(0X977F,	"sf_dirpos ; 31",	0);
	set_cmt	(0X9782,	"SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos",	0);
	create_insn	(0X9782);
	set_cmt	(0X9785,	"DS:SI points to dir_name",	0);
	create_insn	(x=0X9787);
	op_dec		(x,	1);
	set_cmt	(0X978A,	"sf_name",	0);
	set_cmt	(0X978C,	"recover DS:SI -> dir_first",	0);
	set_name	(0X9790,	"doopen_retn");
	create_insn	(0X9791);
	set_name	(0X9791,	"FREEENT");
	create_insn	(x=0X9792);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9796,	"Get pointer to clusters",	0);
	set_cmt	(0X9798,	"hw of first cluster (dir_first)",	0);
	set_cmt	(0X979B,	"[DI+BUFFINFO.buf_sector+2]",	0);
	create_insn	(x=0X979E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X97A3,	"[DI+BUFFINFO.buf_sector]",	0);
	set_cmt	(0X97A7,	"[ES:BP+DPB.FAT_SIZE]",	0);
	set_cmt	(0X97B6,	"Was 0 length file\n(or mucked Firclus if AX:CX=1)",	0);
	set_cmt	(0X97B8,	"[ES:BP+DPB.LAST_CLUSTER+2]",	0);
	set_cmt	(0X97BE,	"[ES:BP+DPB.LAST_CLUSTER]",	0);
	set_cmt	(0X97C4,	"0",	0);
	create_insn	(0X97C4);
	set_cmt	(0X97C9,	"Was 0 length file (or mucked Firclus if CX=1)",	0);
	set_cmt	(0X97CB,	"[ES:BP+DPB.MAX_CLUSTER]",	0);
	set_cmt	(0X97CF,	"Treat like zero length file (firclus mucked)",	0);
	create_insn	(x=0X97D4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X97DB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X97DE,	"Free any data allocated",	0);
	create_insn	(x=0X97E2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X97E8,	"\nAllowed_RETRY+Allowed_FAIL",	0);
	create_insn	(x=0X97E8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X97E8,	"GET_BUF_BACK");
	create_insn	(x=0X97F8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X97FC,	"[bx+dir_entry.dir_first] ; Get corrected SI",	0);
	set_cmt	(0X9801,	"DX:CX = No. of clusters to skip",	0);
	create_insn	(0X9801);
	set_name	(0X9801,	"FNDCLUS");
	create_insn	(x=0X9802);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9806);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X980A,	" [ES:DI+SF_ENTRY.sf_lstclus+2]",	0);
	create_insn	(x=0X980E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9814,	"[ES:DI+SF_ENTRY.sf_firclus] ; MSDOS 5.0-6.22\n[ES:DI+SF_ENTRY.sf_cluspos_hw] ; PCDOS 7.1",	0);
	create_insn	(x=0X9818);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X981C,	"[ES:DI+SF_ENTRY.sf_lstclus]",	0);
	set_cmt	(0X9820,	"[ES:DI+SF_ENTRY.sf_cluspos]",	0);
	create_insn	(0X982D);
	create_insn	(x=0X9830);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9833);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X983C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9840);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9844,	"0",	0);
	create_insn	(x=0X9846);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X984A,	"[ES:DI+SF_ENTRY.sf_chain+2] ; MSDOS 5.0-6.22\n[ES:DI+SF_ENTRY.sf_fcluster+2] ; PCDOS 7.1",	0);
	create_insn	(x=0X984A);
	op_hex		(x,	1);
	create_insn	(x=0X984E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9852,	"[ES:DI+SF_ENTRY.sf_chain] ; MSDOS 5.0-6.22\n[ES:DI+SF_ENTRY.sf_fcluster] ; PCDOS 7.1",	0);
	create_insn	(x=0X9852);
	op_hex		(x,	1);
	create_insn	(x=0X9857);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X985D,	"cf=0",	0);
	create_insn	(x=0X985F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X985F,	"SKPCLP");
	create_insn	(x=0X9864);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X986D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9872);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9878);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X987F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9883);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X988D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9891,	"cf=0",	0);
	create_insn	(x=0X9893);
	op_hex		(x,	1);
	create_insn	(x=0X9899);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X98A0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X98A5,	"loop",	0);
	set_cmt	(0X98A9,	"loop",	0);
	set_cmt	(0X98AB,	"(not necessary) ; 25/02/2024",	0);
	set_name	(0X98AB,	"RET9");
	create_insn	(0X98AD);
	set_name	(0X98AD,	"NOCLUS");
	set_cmt	(0X98B4,	"CLSKIP_HW:BX = Last cluster skipped to",	0);
	create_insn	(x=0X98B4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X98BB,	"LASTPOS_HW:DX = Position of last cluster",	0);
	create_insn	(x=0X98BB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X98C1,	"fndclus_retn");
	create_insn	(x=0X98C2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X98C2,	"BUFSEC");
	create_insn	(x=0X98C6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X98CA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X98CE);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X98D2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X98D6,	"Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE",	0);
	create_insn	(x=0X98D6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X98E1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X98E7,	"A transfer is taking place",	0);
	create_insn	(x=0X98E7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X98EC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X98F2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X98F8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X98FC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9900,	"[ES:DI+BUFFINFO.buf_flags],\nbuf_isDATA",	0);
	create_insn	(x=0X9900);
	op_hex		(x,	1);
	set_cmt	(0X9905,	"[DI+BUFINSIZ] ; Point to buffer",	0);
	create_insn	(x=0X9905);
	op_dec		(x,	1);
	create_insn	(x=0X9908);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X990C,	"(not necessary!?) ; 25/02/2024",	0);
	set_cmt	(0X990E,	"pre-read sector",	0);
	create_insn	(0X990E);
	set_name	(0X990E,	"BUFRD");
	set_cmt	(0X9914,	"ds=ss",	0);
	set_name	(0X9916,	"BUF_IO_FAIL");
	set_cmt	(0X9917,	"ds=ss",	0);
	create_insn	(0X9919);
	create_insn	(x=0X991B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9923);
	op_hex		(x,	1);
	set_cmt	(0X9925,	"Copy Buffer to Transfer memory.",	0);
	set_cmt	(0X9927,	"CX=1 if odd # of bytes, else CX=0.\n! jnc short EVENRD !\n! movsb !",	0);
	set_cmt	(0X992A,	"Copy last byte.",	0);
	set_cmt	(0X992C,	"25/02/2024 - Erdogan Tan",	0);
	set_name	(0X992C,	"EVENRD");
	create_insn	(x=0X992D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9932,	"[DI+BUFINSIZ]",	0);
	create_insn	(x=0X9932);
	op_dec		(x,	1);
	set_cmt	(0X993A,	"[ES:BP+DPB.SECTOR_SIZE] ; Read Last byte?",	0);
	set_cmt	(0X993E,	"ds<>ss",	0);
	create_insn	(x=0X9940);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9949);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X9949,	"BUFWRT");
	create_insn	(x=0X994E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9953);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9956);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9960);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9963,	"Has sector been written before?",	0);
	create_insn	(x=0X9963);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9967,	"no need to read sector before buffer update",	0);
	set_cmt	(0X9969,	"Skip preread if SECPOS>VALSEC",	0);
	set_cmt	(0X996B,	"pre read is needed",	0);
	set_cmt	(0X9971,	"ds=ss",	0);
	set_cmt	(0X9973,	"\nDS:SI-> Source within Transfer memory block\nES:DI-> Destination within Buffer",	0);
	create_insn	(x=0X9973);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9977,	"CX = # of whole WORDs; CF=1 if odd # of bytes",	0);
	create_insn	(x=0X9977);
	op_hex		(x,	1);
	set_cmt	(0X997B,	"! jnc short EVENWRT !\n! movsb !",	0);
	set_cmt	(0X997F,	"25/02/2024 - Erdogan Tan",	0);
	set_name	(0X997F,	"EVENWRT");
	create_insn	(x=0X9980);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9985,	"[BX+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0X9985);
	op_hex		(x,	1);
	create_insn	(x=0X998B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9990);
	op_hex		(x,	1);
	set_cmt	(0X9994,	"[BX+BUFINSIZ]",	0);
	create_insn	(x=0X9994);
	op_dec		(x,	1);
	set_cmt	(0X9999,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	set_cmt	(0X999D,	"Written last byte?\nNo, leave buf where it is",	0);
	set_cmt	(0X999F,	"Make it prime candidate for\nchucking even though it is MRU.",	0);
	create_insn	(x=0X999F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X99AA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0X99AA,	"NEXTSEC");
	create_insn	(x=0X99B1);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X99BC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X99C0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X99C4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X99D3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X99D7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X99DC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X99E0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X99E5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X99EC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X99F1);
	create_insn	(0X99F3);
	set_name	(0X99F3,	"OPTIMIZE");
	create_insn	(x=0X99F4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X99F9,	"[ES:BP+DPB.CLUSTER_MASK]",	0);
	set_cmt	(0X99FD,	"Number of sectors per cluster",	0);
	set_cmt	(0X9A01,	"AL = Num of sectors left in first cluster",	0);
	set_cmt	(0X9A0A,	"ds=ss",	0);
	set_cmt	(0X9A0C,	"AL has number of sectors available\n in current cluster",	0);
	set_name	(0X9A0C,	"clusgot2");
	set_cmt	(0X9A0E,	"CX has number of sequential sectors\n found so far",	0);
	set_cmt	(0X9A11,	"DX has number of sectors left to transfer",	0);
	set_cmt	(0X9A15,	"AH has number of sectors available\n in next cluster",	0);
	create_insn	(x=0X9A1D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9A21);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9A25);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9A33);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9A39);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9A3D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9A41);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9A45);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9A49,	"Last cluster accessed",	0);
	create_insn	(x=0X9A49);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9A4D,	"Number of sectors still needed",	0);
	set_cmt	(0X9A50,	"CX has number of sequential sectors\n found so far",	0);
	set_cmt	(0X9A52,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	create_insn	(x=0X9A56);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9A5A,	"Adjust by size of transfer",	0);
	create_insn	(x=0X9A5C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9A5F,	"Number of sectors still needed",	0);
	set_cmt	(0X9A60,	"Starting cluster, lw",	0);
	set_cmt	(0X9A61,	"Starting cluster, hw",	0);
	create_insn	(x=0X9A62);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9A66);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9A6A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9A6E,	"BL = sector position within cluster",	0);
	create_insn	(x=0X9A76);
	op_hex		(x,	1);
	set_cmt	(0X9A7B,	"Number of sectors in cluster we don't want",	0);
	create_insn	(0X9A7B);
	set_cmt	(0X9A7D,	"Number of sectors in cluster we accepted",	0);
	set_cmt	(0X9A7F,	"Adjust to mean position within cluster",	0);
	create_insn	(x=0X9A81);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9A85,	"Anyway, make the total equal to the request",	0);
	create_insn	(0X9A89);
	set_name	(0X9A89,	"FIGREC");
	set_cmt	(0X9A8D,	"DPB.CLUSTER_SHIFT",	0);
	create_insn	(x=0X9A91);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9A9E);
	op_hex		(x,	1);
	create_insn	(x=0X9AA0);
	op_hex		(x,	1);
	set_cmt	(0X9AA6,	"DPB.FAT_SIZE",	0);
	set_cmt	(0X9AAB,	"not FAT32",	0);
	set_cmt	(0X9AAD,	"DPB.FCLUS_FSECTOR",	0);
	set_cmt	(0X9AB7,	"DPB.FIRST_SECTOR",	0);
	create_insn	(0X9AB7);
	create_insn	(x=0X9ABE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X9AC4,	"figrec_retn");
	create_insn	(0X9AC5);
	set_name	(0X9AC5,	"callmagic");
	create_insn	(x=0X9AC6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X9ACC);
	set_cmt	(0X9ACF,	"COUNT_HW:CX = Number of clusters to allocate",	0);
	create_insn	(0X9ACF);
	set_name	(0X9ACF,	"ALLOCATE");
	set_name	(0X9AD6,	"Regular_Allocate_Path");
	set_cmt	(0X9AD7,	"0",	0);
	create_insn	(x=0X9AD9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9ADD,	"cluster 0",	0);
	create_insn	(x=0X9ADD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9AE4,	"\nCCONTENT_HW:DI = content of FAT\n (for cluster 0)",	0);
	create_insn	(x=0X9AE4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9AE8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9AEC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9AF0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9AF7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9AFC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9B05,	"[es:bp+DPB.FAT_SIZE]",	0);
	create_insn	(x=0X9B09);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9B0D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9B11,	"[es:bp+DPB.NEXT_FREE]",	0);
	set_cmt	(0X9B17,	"[es:bp+DPB.FAT32_NXTFREE+2]",	0);
	create_insn	(x=0X9B1B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9B22,	"[es:bp+DPB.FAT32_NXTFREE]",	0);
	set_cmt	(0X9B2F,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0X9B35,	"[es:bp+DPB.FAT32_NXTFREE]",	0);
	set_cmt	(0X9B3B,	"[es:bp+DPB.FAT32_NXTFREE+2]",	0);
	set_cmt	(0X9B3F,	"0",	0);
	create_insn	(x=0X9B3F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9B43,	"[es:bp+DPB.NEXT_FREE]",	0);
	set_cmt	(0X9B49,	"1",	0);
	set_cmt	(0X9B4A,	"[es:bp+DPB.FIRST_ACCESS]",	0);
	create_insn	(x=0X9B51);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9B56,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0X9B5B,	"not FAT32",	0);
	create_insn	(x=0X9B5E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9B62,	"[es:bp+DPB.LAST_CLUSTER+2]",	0);
	set_cmt	(0X9B69,	"[es:bp+DPB.LAST_CLUSTER]",	0);
	set_cmt	(0X9B6F,	"[es:bp+DPB.MAX_CLUSTER]",	0);
	create_insn	(0X9B6F);
	create_insn	(0X9B78);
	create_insn	(x=0X9B79);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9B7E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9B83);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9B8A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9B8F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9B94);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X9B9E);
	set_cmt	(0X9BA0,	"[es:bp+DPB.NEXT_FREE]",	0);
	set_cmt	(0X9BA4,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0X9BA9,	"not FAT32",	0);
	create_insn	(x=0X9BAC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9BB0,	"[es:bp+DPB.FAT32_NXTFREE+2]",	0);
	set_cmt	(0X9BB5,	"[es:bp+DPB.FAT32_NXTFREE]",	0);
	set_cmt	(0X9BB9,	"[es:bp+DPB.FIRST_ACCESS]",	0);
	create_insn	(x=0X9BB9);
	op_hex		(x,	1);
	create_insn	(x=0X9BBF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9BC4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9BC9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9BCD,	"0",	0);
	create_insn	(x=0X9BCF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9BD3,	"1 ; mark this free guy as \"1\"",	0);
	set_cmt	(0X9BD4,	"set special \"temporary\" mark",	0);
	create_insn	(x=0X9BD7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9BDC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9BE1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9BEB,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0X9BEF,	"not FAT32",	0);
	set_cmt	(0X9BF2,	"[es:bp+DPB.FREE_CNT+2]",	0);
	set_cmt	(0X9BF8,	"[es:bp+DPB.FREE_CNT]",	0);
	set_cmt	(0X9BFE,	"Reduce free count by 1\n[es:bp+DPB.FREE_CNT]",	0);
	set_cmt	(0X9C02,	"[es:bp+DPB.FREE_CNT+2]",	0);
	set_cmt	(0X9C08,	"0FFFFh ; -1",	0);
	create_insn	(0X9C08);
	set_cmt	(0X9C09,	"[es:bp+DPB.FREE_CNT]",	0);
	set_cmt	(0X9C0D,	"Free count not valid",	0);
	set_cmt	(0X9C0F,	"[es:bp+DPB.FREE_CNT]\nReduce free count by 1",	0);
	create_insn	(x=0X9C15);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9C1A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9C21);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9C26);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9C2D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9C31);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9C3A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9C3F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X9C4A);
	create_insn	(x=0X9C4D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9C55);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9C5A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9C61,	"Get first cluster allocated for return",	0);
	create_insn	(0X9C61);
	set_cmt	(0X9C66,	"Restore correct cluster 0 value",	0);
	create_insn	(x=0X9C6C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9C6F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9C73,	"CLUSTNUM_HW:DI = last cluster in file upon our entry",	0);
	set_cmt	(0X9C78,	"we were extending an existing file",	0);
	set_name	(0X9C7A,	"dofastk");
	create_insn	(x=0X9C7D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9C82);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9C86,	"[es:di+SF_ENTRYT.sf_chain+2] ; 32 bit fclust, hw",	0);
	set_cmt	(0X9C8A,	"[es:di+SF_ENTRYT.sf_lstclus+2] ; 32 bit lclust, hw",	0);
	set_cmt	(0X9C8F,	"[es:di+SF_ENTRYT.sf_chain] ; 32 bit fcluster, lw",	0);
	set_cmt	(0X9C93,	"[es:di+SF_ENTRYT.sf_lstclus] ; 32 bit lcluster, lw",	0);
	set_cmt	(0X9C9B,	"[es:bp+DPB.FAT_SIZE]",	0);
	create_insn	(0X9C9B);
	set_cmt	(0X9CA0,	"FAT32",	0);
	set_cmt	(0X9CA2,	"[es:bp+DPB.NEXT_FREE]",	0);
	set_cmt	(0X9CA9,	"[es:bp+DPB.FAT32_NXTFREE+2]",	0);
	create_insn	(0X9CA9);
	set_cmt	(0X9CB0,	"[es:bp+DPB.FAT32_NXTFREE]",	0);
	set_cmt	(0X9CB7,	"start scan from front of disk",	0);
	create_insn	(0X9CBA);
	set_cmt	(0X9CBB,	"-1",	0);
	create_insn	(x=0X9CBE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9CC2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9CCA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9CD0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9CD8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X9CDF);
	set_name	(0X9CDF,	"RESTFATBYT");
	set_cmt	(0X9CE2,	"0",	0);
	create_insn	(x=0X9CE4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9CE8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9CEC,	"(not necessary ?)",	0);
	create_insn	(x=0X9CEC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9CF0,	"0",	0);
	create_insn	(x=0X9CF0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9CF4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9CF8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9CFC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9D03);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9D07);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9D0B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X9D13);
	set_name	(0X9D13,	"RELEASE");
	set_cmt	(0X9D15,	"(dx = 0, release)",	0);
	create_insn	(x=0X9D15);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X9D19);
	set_name	(0X9D19,	"RELBLKS");
	set_cmt	(0X9D1E,	"CCONTENT_HW:DI= Content of FAT\n for given cluster (next cluster)",	0);
	create_insn	(x=0X9D26);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9D2A,	"next cluster (hw) to be released",	0);
	create_insn	(x=0X9D2A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9D2E,	"next cluster (lw) to be released",	0);
	set_cmt	(0X9D33,	"0 (delete/release) or -1 (EOF)",	0);
	set_cmt	(0X9D35,	"Was putting EOF mark (dx = -1)",	0);
	set_cmt	(0X9D37,	"> 0 ? (delete, release)",	0);
	create_insn	(x=0X9D37);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9D3B,	"no, EOF (allocate, -1), (dx = 0)",	0);
	set_cmt	(0X9D3D,	"[ES:BP+DPB.FREE_CNT],-1\nFree count valid?",	0);
	set_cmt	(0X9D42,	"No (dx = 0)",	0);
	set_cmt	(0X9D44,	"[ES:BP+DPB.FREE_CNT]\nIncrease free count by 1",	0);
	set_cmt	(0X9D4A,	"[ES:BP+DPB.FAT_SIZE]",	0);
	set_cmt	(0X9D4E,	"not FAT32",	0);
	set_cmt	(0X9D50,	"[ES:BP+DPB.FREE_CNT+2]",	0);
	set_cmt	(0X9D56,	"dx is -1 or 0\n (valid 16 bit fat size is another number)",	0);
	create_insn	(0X9D56);
	set_cmt	(0X9D5A,	"FAT (FAT16 or FAT12)\ndx = 0, FAT32",	0);
	set_cmt	(0X9D5C,	"[ES:BP+DPB.FREE_CNT+2]",	0);
	create_insn	(x=0X9D63);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9D6A,	"check for \"1\"",	0);
	set_cmt	(0X9D6B,	"is last cluster of incomplete chain",	0);
	create_insn	(0X9D73);
	set_cmt	(0X9D75,	"CLUSTERS_HW:DI = Cluster Count",	0);
	create_insn	(x=0X9D75);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0X9D7C);
	set_name	(0X9D7C,	"GETEOF");
	set_cmt	(0X9D7E,	"cluster count = 0",	0);
	set_cmt	(0X9D87,	"CCONTENT_HW:DI = next cluster (cluster content)",	0);
	create_insn	(x=0X9D8C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9D90);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9D94);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9D9D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9DA2,	"EOF",	0);
	set_cmt	(0X9DA4,	"not EOF",	0);
	create_insn	(x=0X9DA4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9DA8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9DAE,	"get next cluster",	0);
	set_cmt	(0X9DB0,	"0",	0);
	create_insn	(0X9DB0);
	set_name	(0X9DB0,	"MAKEFCB");
	set_cmt	(0X9DB2,	"Flag--not ambiguous file name",	0);
	create_insn	(x=0X9DB2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9DB7,	"DRVBIT",	0);
	create_insn	(x=0X9DB7);
	op_hex		(x,	1);
	set_cmt	(0X9DBB,	"use default drive",	0);
	set_cmt	(0X9DC2,	"NAMBIT",	0);
	create_insn	(x=0X9DC2);
	op_hex		(x,	1);
	set_cmt	(0X9DC7,	"go fill with blanks",	0);
	set_cmt	(0X9DCB,	"Don't fill any",	0);
	set_cmt	(0X9DD1,	"EXTBIT",	0);
	create_insn	(x=0X9DD1);
	op_hex		(x,	1);
	set_cmt	(0X9DD8,	"0",	0);
	set_cmt	(0X9DDE,	"Initialize two words after to zero",	0);
	set_cmt	(0X9DDF,	"Point back at start",	0);
	create_insn	(x=0X9DDF);
	op_dec		(x,	1);
	set_cmt	(0X9DE2,	"SCANSEPARATOR \nScan off separators if not zero",	0);
	create_insn	(x=0X9DE2);
	op_hex		(x,	1);
	set_cmt	(0X9DE7,	"Peel off blanks and tabs",	0);
	set_cmt	(0X9DEA,	"Is it a one-time-only delimiter?",	0);
	set_cmt	(0X9DEF,	"Skip over the delimiter",	0);
	set_cmt	(0X9DF6,	"Quit if termination character",	0);
	set_cmt	(0X9DF8,	"\nCheck for potential drive specifier",	0);
	set_cmt	(0X9DFD,	"Skip over colon",	0);
	set_cmt	(0X9DFE,	"Convert drive letter to drive number (A=1)",	0);
	set_cmt	(0X9E00,	"Drive letter out of range",	0);
	set_cmt	(0X9E09,	"error_not_DOS_disk",	0);
	create_insn	(x=0X9E09);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9E11,	"-1",	0);
	set_cmt	(0X9E13,	"Put drive specifier in first byte",	0);
	set_cmt	(0X9E15,	"Counteract next two instructions",	0);
	set_cmt	(0X9E16,	"Back up",	0);
	set_cmt	(0X9E17,	"Skip drive byte",	0);
	create_insn	(0X9E18);
	set_name	(0X9E18,	"NORMSCAN");
	set_cmt	(0X9E1B,	"Get 8-letter file name",	0);
	set_cmt	(0X9E23,	"Skip over dot if present",	0);
	set_cmt	(0X9E24,	"Get 3-letter extension",	0);
	set_cmt	(0X9E27,	"(DBCS_VOLID2>>8)",	0);
	create_insn	(x=0X9E27);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X9E36,	"~DBCS_VOLID2",	0);
	create_insn	(x=0X9E36);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(0X9E3E);
	create_insn	(0X9E42);
	set_name	(0X9E42,	"GETWORD");
	create_insn	(0X9E48);
	set_name	(0X9E48,	"MUSTGETWORD");
	create_insn	(x=0X9E4D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0X9E5C,	"Check for ambiguous file specifier",	0);
	set_cmt	(0X9E69,	"Flag ambiguous file name",	0);
	create_insn	(x=0X9E69);
	op_hex		(x,	1);
	create_insn	(0X9E6E);
	create_insn	(0X9E74);
	set_name	(0X9E74,	"SCANB");
	set_name	(0X9E7B,	"scanb_retn");
	create_insn	(x=0X9E7C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X9E7C,	"NameTrans");
	create_insn	(x=0X9E84);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9E8A);
	op_dec		(x,	1);
	set_cmt	(0X9E8D,	"Fill \"FCB\" at NAME1 with spaces",	0);
	create_insn	(x=0X9E96);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9E9E,	"Magic name translation",	0);
	create_insn	(x=0X9E9E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_byte	(0X9EA5);
	make_array	(0X9EA5,	0X3F);
	set_name	(0X9EA5,	"CharType");
	create_insn	(0X9EE4);
	set_name	(0X9EE4,	"GETLET");
	create_insn	(0X9EE5);
	set_name	(0X9EE5,	"UCase");
	set_cmt	(0X9EE6,	"FILE_UCASE_TAB+2",	0);
	create_insn	(x=0X9EE6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9EE9);
	op_chr		(x,	1);
	set_name	(0X9EE9,	"gl_0");
	set_cmt	(0X9EEB,	"Already upper case, go check type",	0);
	create_insn	(x=0X9EED);
	op_chr		(x,	1);
	set_cmt	(0X9EF1,	"Convert to upper case",	0);
	create_insn	(x=0X9EF1);
	op_hex		(x,	1);
	set_cmt	(0X9EF5,	"Not EuroChar, go check type",	0);
	set_cmt	(0X9EF7,	"translate to upper case with this index",	0);
	set_cmt	(0X9EFF,	"ds as file_ucase_tab is in DOSDATA",	0);
	set_cmt	(0X9F02,	"returns type flags in AL",	0);
	set_cmt	(0X9F05,	"FCHK ; test for normal character",	0);
	create_insn	(x=0X9F05);
	op_hex		(x,	1);
	create_insn	(0X9F0A);
	set_name	(0X9F0A,	"GETLET3");
	create_insn	(0X9F0D);
	set_name	(0X9F0D,	"DELIM");
	set_cmt	(0X9F11,	"FDELIM",	0);
	create_insn	(x=0X9F11);
	op_hex		(x,	1);
	create_insn	(0X9F15);
	set_name	(0X9F15,	"SPCHK");
	set_cmt	(0X9F19,	"FSPCHK",	0);
	create_insn	(x=0X9F19);
	op_hex		(x,	1);
	set_cmt	(0X9F1D,	"CharType_last ; beyond end of table?",	0);
	create_insn	(x=0X9F1D);
	op_hex		(x,	1);
	set_name	(0X9F1D,	"GetCharType");
	set_cmt	(0X9F22,	"load lookup table",	0);
	create_insn	(x=0X9F22);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9F25,	"adjust for half-byte table entry size",	0);
	create_insn	(x=0X9F25);
	op_hex		(x,	1);
	set_cmt	(0X9F27,	"get flags",	0);
	set_cmt	(0X9F2A,	"carry clear, no shift needed",	0);
	set_cmt	(0X9F2D,	"we want high nibble, shift it down",	0);
	set_cmt	(0X9F32,	"clear the unused nibble",	0);
	create_insn	(x=0X9F32);
	op_hex		(x,	1);
	set_cmt	(0X9F35,	"set all flags",	0);
	create_insn	(0X9F35);
	create_insn	(0X9F38);
	set_name	(0X9F38,	"PATHCHRCMP");
	create_insn	(0X9F3F);
	create_insn	(0X9F42);
	create_word	(x=0X9F45);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X9F45,	"LowInt23Addr");
	create_word	(0X9F47);
	set_name	(0X9F47,	"LowInt23_SEG");
	create_word	(x=0X9F49);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X9F49,	"LowInt24Addr");
	create_word	(0X9F4B);
	set_name	(0X9F4B,	"LowInt24_SEG");
	create_word	(x=0X9F4D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X9F4D,	"LowInt28Addr");
	create_word	(0X9F4F);
	set_name	(0X9F4F,	"LowInt28_SEG");
	create_insn	(x=0X9F51);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0X9F51,	"DSKSTATCHK");
	create_insn	(0X9F5A);
	set_cmt	(0X9F65,	"DEVRDND",	0);
	create_insn	(x=0X9F65);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9F6A,	"DRDNDHL",	0);
	create_insn	(x=0X9F6A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_dec		(x,	1);
	create_insn	(x=0X9F6F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9F75);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9F78);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0X9F82);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0X9F92);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0X9F95,	"\"C\"-\"@\"",	0);
	set_cmt	(0X9F99,	"DEVRD",	0);
	create_insn	(x=0X9F99);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9F9E,	"DRDWRHL",	0);
	create_insn	(x=0X9F9E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9FA3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9FA7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9FAD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9FB4,	"Eat the ^C",	0);
	set_cmt	(0X9FBF,	"\"P\"-\"@\"",	0);
	create_insn	(x=0X9FBF);
	op_dec		(x,	1);
	set_cmt	(0X9FC3,	"ALT_Q ?",	0);
	create_insn	(x=0X9FC3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9FC9,	"no",	0);
	set_cmt	(0X9FCC,	"\"C\"-\"@\"",	0);
	create_insn	(0X9FCC);
	create_insn	(0X9FD1);
	create_insn	(0X9FD4);
	set_name	(0X9FD4,	"SPOOLINT");
	create_insn	(x=0X9FD5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9FDD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0X9FE5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9FEA,	"Q: is dos running in HMA",	0);
	create_insn	(x=0X9FEA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0X9FF0,	"Y: the int must be done from low mem",	0);
	set_cmt	(0X9FF2,	"DOS 2+ internal - KEYBOARD BUSY LOOP",	0);
	create_insn	(x=0X9FF2);
	op_hex		(x,	0);
	set_cmt	(0X9FF6,	"call far [cs:LowInt28Addr]",	0);
	create_insn	(0X9FF6);
	create_insn	(x=0X9FFB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XA001,	"_RET18");
	set_cmt	(0XA002,	"Allows ^C to be detected under\ninput redirection",	0);
	create_insn	(0XA002);
	set_name	(0XA002,	"STATCHK");
	set_cmt	(0XA015,	"'S'-'@'",	0);
	create_insn	(x=0XA015);
	op_dec		(x,	1);
	set_cmt	(0XA019,	"ALT_R ?",	0);
	create_insn	(x=0XA019);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA01F,	"yes",	0);
	set_cmt	(0XA023,	"Eat Cntrl-S",	0);
	create_insn	(x=0XA028);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA03D,	"[ES:DI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8)",	0);
	create_insn	(x=0XA03D);
	op_hex		(x,	1);
	set_cmt	(0XA042,	"Not redirected, echo is OK",	0);
	set_cmt	(0XA048,	"Multiplex - NETWORK REDIRECTOR - ???\nReturn: CF set on error, AX = error code\nSTACK unchanged",	0);
	create_insn	(x=0XA048);
	op_hex		(x,	0);
	set_cmt	(0XA04B,	"Echo is OK",	0);
	set_cmt	(0XA04D,	"If not allowed, disable echo",	0);
	create_insn	(x=0XA04D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA057,	"Multiplex - NETWORK REDIRECTOR - ???\nES:DI -> SFT, SS = DOS CS",	0);
	create_insn	(x=0XA057);
	op_hex		(x,	0);
	create_insn	(x=0XA05C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XA069);
	create_insn	(0XA06F);
	set_cmt	(0XA087,	"\"P\"-\"@\"",	0);
	set_cmt	(0XA089,	"must be CTRL_P",	0);
	set_cmt	(0XA08B,	"\"C\"-\"@\"",	0);
	set_cmt	(0XA08F,	"(CTRL_BREAK_FLAG>>8)",	0);
	create_insn	(x=0XA08F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0XA08F,	"CNTCHAND");
	set_cmt	(0XA097,	"Display \"^C\"",	0);
	create_insn	(x=0XA0A1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA0AB,	"Prepare to play with stack",	0);
	set_cmt	(0XA0AC,	"User stack now restored",	0);
	create_insn	(x=0XA0AC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA0B0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA0B4,	"User registers now restored",	0);
	set_cmt	(0XA0BE,	"Go to known state",	0);
	create_insn	(x=0XA0BE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA0C3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA0C8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA0CD,	"save his SP",	0);
	create_insn	(x=0XA0CD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA0D1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA0D6,	"Q: is dos running in HMA",	0);
	create_insn	(x=0XA0D6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA0DC,	"Y: the int must be done from low mem",	0);
	set_cmt	(0XA0DF,	"DOS - CONTROL \"C\" EXIT ADDRESS\nReturn: return via RETF 2 with CF set\nDOS will abort program with errorlevel 0\nelse\ninterrupted DOS call continues",	0);
	create_insn	(x=0XA0DF);
	op_hex		(x,	0);
	create_insn	(0XA0E3);
	set_cmt	(0XA0E4,	"call far [cs:LowInt23Addr]",	0);
	create_insn	(x=0XA0F2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA0F6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA0FB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA0FF,	"current SP not the same as saved SP",	0);
	create_insn	(x=0XA101);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA104,	"restore ds and original sp",	0);
	create_insn	(x=0XA104);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA10B,	"f_Carry",	0);
	create_insn	(x=0XA10B);
	op_hex		(x,	1);
	set_cmt	(0XA10D,	"add sp,2",	0);
	create_insn	(x=0XA110);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA114,	"(EXIT*256) + 0",	0);
	set_name	(0XA114,	"ctrlc_abort");
	set_cmt	(0XA11D,	"-1",	0);
	create_insn	(x=0XA11D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA125);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XA125,	"DIVOV");
	set_cmt	(0XA132,	"AUXSTACK",	0);
	set_cmt	(0XA138,	"Use Ctrl-C abort on divide overflow",	0);
	create_insn	(0XA13A);
	set_name	(0XA13A,	"_OUTMES");
	set_cmt	(0XA13E,	"DEVWRT",	0);
	create_insn	(x=0XA13E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA143,	"DRDWRHL",	0);
	create_insn	(x=0XA143);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA148);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA14E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA152);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA155);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA159);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA15D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA164);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA16B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA173,	"Q: are we in the middle of int 24",	0);
	create_insn	(x=0XA173);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XA173,	"CHARHARD");
	set_cmt	(0XA179,	"Y: allow fail",	0);
	set_cmt	(0XA17B,	"Allowed_RETRY ; assume ctrl p",	0);
	create_insn	(x=0XA17B);
	op_hex		(x,	1);
	set_cmt	(0XA17E,	"Q: has ctrl p been pressed",	0);
	create_insn	(x=0XA17E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XA184,	"Y:",	0);
	set_cmt	(0XA186,	"Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL",	0);
	create_insn	(x=0XA186);
	op_hex		(x,	1);
	create_insn	(x=0XA189);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA18E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA193);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA199,	"STECODE",	0);
	create_insn	(x=0XA199);
	op_hex		(x,	1);
	set_cmt	(0XA19D,	"Device pointer is BP:SI",	0);
	set_cmt	(0XA1A4,	"Error code in DI, count in AX",	0);
	create_insn	(0XA1A4);
	set_name	(0XA1A4,	"HARDERR");
	set_cmt	(0XA1A5,	"STECODE",	0);
	create_insn	(x=0XA1A5);
	op_hex		(x,	1);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_4(void) {
        auto x;
#define id x

	set_cmt	(0XA1A9,	"error_I24_write_protect\nWrite Protect Error?",	0);
	set_cmt	(0XA1AF,	"[ES:BP+DPB.DRIVE]",	0);
	set_cmt	(0XA1B3,	"Flag drive with WP error",	0);
	create_insn	(x=0XA1B3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA1B8,	"Number of sectors successfully transferred",	0);
	set_cmt	(0XA1BA,	"First sector number to retry",	0);
	create_insn	(x=0XA1BC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA1C3,	"[ES:BP+DPB.SECTOR_SIZE]\nDX:AX = Number of bytes transferred",	0);
	set_cmt	(0XA1C8,	"First address for retry",	0);
	set_cmt	(0XA1CA,	"Flag disk section in error",	0);
	create_insn	(x=0XA1CC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA1D4,	"[ES:BP+DPB.FIRST_FAT]\nIn reserved area?",	0);
	set_cmt	(0XA1DC,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0XA1E1,	"not FAT32",	0);
	create_insn	(x=0XA1E4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA1E9,	"[es:bp+DPB.FCLUS_FSECTOR+2]",	0);
	set_cmt	(0XA1EE,	"Err in FAT must force recomp of freespace",	0);
	set_cmt	(0XA1F0,	"[es:bp+DPB.FCLUS_FSECTOR]",	0);
	set_cmt	(0XA1F6,	"-1 ; [es:bp+DPB.FREE_CNT]",	0);
	set_cmt	(0XA1FC,	"-1 ; [es:bp+DPB.FREE_CNT+2]",	0);
	create_insn	(0XA204);
	set_cmt	(0XA20A,	"[ES:BP+DPB.DIR_SECTOR]",	0);
	create_insn	(0XA20A);
	set_cmt	(0XA20E,	"not in FAT",	0);
	set_cmt	(0XA210,	"[ES:BP+DPB.FREE_CNT],-1",	0);
	create_insn	(0XA218);
	set_cmt	(0XA21A,	"[ES:BP+DPB.FIRST_SECTOR]",	0);
	set_cmt	(0XA222,	"Make room for read/write bit",	0);
	create_insn	(x=0XA222);
	op_hex		(x,	1);
	create_insn	(x=0XA224);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA229,	"Set the allowed bits",	0);
	create_insn	(x=0XA229);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA22E,	"[ES:BP+DPB.DRIVE]",	0);
	create_insn	(0XA22E);
	set_name	(0XA22E,	"FATAL");
	create_insn	(x=0XA232);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XA232,	"FATAL1");
	set_cmt	(0XA237,	"The only things we preserve",	0);
	create_insn	(x=0XA237);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA23C,	"[ES:BP+DPB.DRIVER_ADDR]",	0);
	set_cmt	(0XA240,	"BP:SI points to the device involved",	0);
	create_insn	(0XA242);
	set_name	(0XA242,	"FATALC");
	set_cmt	(0XA245,	"error_I24_gen_failure",	0);
	set_cmt	(0XA248,	"GOT_RIGHT_CODE",	0);
	set_cmt	(0XA24A,	"Error codes above gen_failure get\nmapped to gen_failure. Real codes\nonly come via GetExtendedError",	0);
	set_cmt	(0XA24D,	"No INT 24s if already INT 24",	0);
	create_insn	(x=0XA24D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XA24D,	"NET_I24_ENTRY");
	create_insn	(x=0XA259);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA260,	"-1",	0);
	create_insn	(x=0XA260);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA26A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA274,	"Prepare to play with stack",	0);
	set_cmt	(0XA275,	"Flag INT 24 in progress",	0);
	create_insn	(x=0XA275);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA27A,	"INT 24 handler might not return",	0);
	create_insn	(x=0XA27A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA27F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA284,	"EXT_OPEN_I24_OFF",	0);
	create_insn	(x=0XA284);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XA28C,	"fake fail",	0);
	create_insn	(x=0XA290);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA295,	"User stack pointer restored",	0);
	create_insn	(x=0XA295);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA29A,	"Q: is dos running in HMA",	0);
	create_insn	(x=0XA29A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA2A0,	"Y: the int must be done from low mem",	0);
	set_cmt	(0XA2A2,	"DOS - FATAL ERROR HANDLER ADDRESS\nAutomatically called upon detection of unrecoverable I/O error.",	0);
	create_insn	(x=0XA2A2);
	op_hex		(x,	0);
	set_cmt	(0XA2A6,	"call far [cs:LowInt24Addr]",	0);
	create_insn	(0XA2A6);
	set_cmt	(0XA2AB,	"restore our stack",	0);
	create_insn	(x=0XA2AB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA2B0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA2B7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA2BC,	"Back in the DOS",	0);
	create_insn	(x=0XA2BC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA2C1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA2C6,	"Back from INT 24",	0);
	create_insn	(x=0XA2C6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA2CD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA2D4,	"0 => ignore",	0);
	set_cmt	(0XA2D6,	"1 => retry",	0);
	set_cmt	(0XA2D8,	"3 => fail",	0);
	set_cmt	(0XA2DA,	"2, invalid => abort",	0);
	set_cmt	(0XA2DC,	"Allowed_FAIL ; Can we?",	0);
	create_insn	(x=0XA2DC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XA2E2,	"No, do abort",	0);
	set_cmt	(0XA2E6,	"EXT_OPEN_I24_OFF",	0);
	create_insn	(x=0XA2E6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XA2EE,	"Tell everybody",	0);
	create_insn	(x=0XA2EE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA2F3,	"-1",	0);
	create_insn	(x=0XA2F3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA2F9,	"-1",	0);
	create_insn	(x=0XA2F9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XA302);
	create_insn	(x=0XA305);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA309);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA314,	"Allowed_IGNORE ; Can we?",	0);
	create_insn	(x=0XA314);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XA31A,	"No, do fail",	0);
	set_cmt	(0XA31E,	"Allowed_RETRY ; Can we?",	0);
	create_insn	(x=0XA31E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XA324,	"No, do fail",	0);
	create_insn	(0XA326);
	create_insn	(x=0XA328);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA332);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA339,	"EXIT_HARD_ERROR",	0);
	create_insn	(x=0XA339);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XA343);
	set_cmt	(0XA346,	"Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7",	0);
	create_insn	(x=0XA346);
	op_hex		(x,	0);
	create_insn	(x=0XA348);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA351,	"Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK\nSS = DOS CS",	0);
	create_insn	(x=0XA351);
	op_hex		(x,	0);
	create_insn	(x=0XA353);
	op_hex		(x,	1);
	create_insn	(x=0XA35B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA362,	"[PDB.PARENT_PID]",	0);
	set_cmt	(0XA367,	"parentPDB = CurrentPDB",	0);
	set_cmt	(0XA36B,	"CurrentPDB <> ThisPDB",	0);
	set_cmt	(0XA36E,	"EXIT_KEEP_PROCESS",	0);
	create_insn	(x=0XA36E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA37C,	"set up process as parent",	0);
	create_insn	(x=0XA37C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA383,	"-1",	0);
	set_cmt	(0XA38F,	"Go to known state",	0);
	create_insn	(x=0XA38F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA394);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA399,	"Forget about WP error",	0);
	create_insn	(x=0XA399);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA39E,	"let aborts occur",	0);
	create_insn	(x=0XA39E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA3A3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA3A7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA3AB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA3AF,	"[PDB.USER_STACK+2]",	0);
	set_cmt	(0XA3B3,	"[PDB.USER_STACK]",	0);
	set_cmt	(0XA3C3,	"Save DS in TEMPSEG, not on stack.",	0);
	create_insn	(x=0XA3C3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA3C7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA3CA,	"suck off CS:IP of interrupt",	0);
	create_insn	(x=0XA3D0);
	op_hex		(x,	1);
	create_insn	(x=0XA3D5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA3D9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA3DD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA3E0,	"restore ds",	0);
	create_insn	(x=0XA3E0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0XA3E5);
	set_name	(0XA3E5,	"SET_I24_EXTENDED_ERROR");
	set_cmt	(0XA3E6,	"ErrMap24End\nsize of ErrMap24",	0);
	create_insn	(x=0XA3E6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA3E9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA3F8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA3FE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA404);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA40C,	"is it FAT32 drive ?",	0);
	create_insn	(0XA40C);
	set_name	(0XA40C,	"IsEOF");
	set_cmt	(0XA40F,	"no, it has 12 or 16 bit FAT",	0);
	set_cmt	(0XA411,	"FAT32",	0);
	create_insn	(x=0XA411);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA418,	"not EOF",	0);
	set_cmt	(0XA41A,	"32 bit compare",	0);
	set_cmt	(0XA41D,	"cf=0 -> EOF, cf=1 -> not EOF",	0);
	set_cmt	(0XA41E,	"[es:bp+DPB.MAX_CLUSTER]\nis this 16 bit fat?",	0);
	create_insn	(0XA41E);
	set_cmt	(0XA424,	"yes, check for eof there",	0);
	set_cmt	(0XA42C,	"do the 12 bit compare",	0);
	set_cmt	(0XA430,	"cf=0 -> EOF, cf=1 -> not EOF",	0);
	set_cmt	(0XA431,	"16 bit compare",	0);
	create_insn	(0XA431);
	set_cmt	(0XA434,	"cf=0 -> EOF, cf=1 -> not EOF",	0);
	set_cmt	(0XA435,	"0",	0);
	create_insn	(x=0XA435);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA43B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA441);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA445);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA44D,	"[CCONTENT_HW]:DI = contents of CL0FATENTRY",	0);
	create_insn	(0XA44E);
	set_name	(0XA44E,	"UNPACK");
	set_cmt	(0XA452,	"[ES:BP+DPB.FAT_SIZE]",	0);
	set_cmt	(0XA457,	"not FAT32",	0);
	set_cmt	(0XA459,	"[ES:BP+DPB.LAST_CLUSTER+2]",	0);
	create_insn	(x=0XA45D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA463,	"[ES:BP+DPB.LAST_CLUSTER]",	0);
	set_cmt	(0XA469,	"[ES:BP+DPB.MAX_CLUSTER]",	0);
	create_insn	(0XA469);
	set_cmt	(0XA46D,	"error (> cluster count)",	0);
	set_cmt	(0XA472,	"(ds<>ss)",	0);
	set_cmt	(0XA474,	"offset CLUSSAVE+2",	0);
	set_cmt	(0XA477,	"high word of cluster number",	0);
	create_insn	(x=0XA477);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA47C,	"offset CLUSSAVE",	0);
	set_cmt	(0XA483,	"FAT32 volume (drive)",	0);
	create_insn	(x=0XA485);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA48C,	"[ES:BP+DPB.MAX_CLUSTER]\nis this 16-bit fat?",	0);
	set_cmt	(0XA490,	"4096-10",	0);
	set_cmt	(0XA494,	"No, go 'AND' off bits",	0);
	set_cmt	(0XA496,	"set zero condition code, clears carry",	0);
	set_cmt	(0XA49E,	"[CCONTENT_HW]:DI = 0 -> zf = 1",	0);
	create_insn	(x=0XA49E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA4A3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA4AA);
	op_hex		(x,	1);
	create_insn	(x=0XA4AC);
	op_hex		(x,	1);
	create_insn	(x=0XA4AE);
	op_hex		(x,	1);
	create_insn	(x=0XA4B0);
	op_hex		(x,	1);
	create_insn	(x=0XA4B2);
	op_hex		(x,	1);
	set_name	(0XA4B6,	"_DoContext");
	create_insn	(0XA4BB);
	set_cmt	(0XA4BF,	"Allowed_FAIL+80h",	0);
	set_cmt	(0XA4C1,	"Allowed_FAIL",	0);
	create_insn	(x=0XA4C1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA4C7,	"(necessary!?)",	0);
	create_insn	(x=0XA4C7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA4CC,	"(necessary!?)",	0);
	set_cmt	(0XA4CD,	"NOTE: DI would be 0FFFFh here (or 0FFFh as in MSDOS 6.?)\nbecause, in SET_I24_EXTENDED_ERROR in FATAL,\nDI is compared with error code\n;\nxor di,di\ndec di ; 0FFFFh\npush di\ncall FATAL\npop word [ss:CCONTENT_HW]\n;\nErdogan Tan - 02/03/2024",	0);
	create_insn	(x=0XA4D1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA4D8,	"0FFFFh",	0);
	create_insn	(x=0XA4D9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA4E1,	"Try to ignore bad FAT",	0);
	set_cmt	(0XA4E3,	"User said FAIL",	0);
	set_name	(0XA4E5,	"hurtfat_retn");
	set_cmt	(0XA4E6,	"0",	0);
	create_insn	(x=0XA4E6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA4ED,	"Cluster Data/Content (High Word)",	0);
	create_insn	(x=0XA4ED);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA4F0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA4F4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA4F9,	"CLUSDATA_HW:DX = cluster data/content\nCLUSTNUM_HW:BX = cluster number (to be updated)\nES:BP = pointer to DPB\n\nare we packing cluster 0 ?",	0);
	create_insn	(0XA4F9);
	set_name	(0XA4F9,	"PACK");
	set_cmt	(0XA4FB,	"place value in CL0FATENTRY",	0);
	set_cmt	(0XA504,	"byte (not nibble) aligned",	0);
	set_cmt	(0XA506,	"move data to upper 12 bits",	0);
	set_cmt	(0XA50E,	"leave in original low 4 bits",	0);
	create_insn	(x=0XA50E);
	op_hex		(x,	1);
	create_insn	(0XA513);
	create_insn	(x=0XA518);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA51D,	"hw of cluster number\noffset CLUSSAVE+2",	0);
	create_insn	(x=0XA520);
	op_hex		(x,	1);
	set_cmt	(0XA52B,	"[ES:BP+DPB.MAX_CLUSTER],4096-10\nis 16 bit FAT ?",	0);
	create_insn	(0XA52B);
	set_cmt	(0XA531,	"yes, go clobber original data",	0);
	set_cmt	(0XA533,	"leave in upper 4 bits of original",	0);
	create_insn	(x=0XA533);
	op_hex		(x,	1);
	set_cmt	(0XA537,	"store only 12 bits",	0);
	create_insn	(x=0XA537);
	op_hex		(x,	1);
	set_cmt	(0XA53C,	"no original data",	0);
	create_insn	(0XA53C);
	create_insn	(x=0XA542);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA547,	"[SI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0XA547);
	op_hex		(x,	1);
	set_cmt	(0XA54B,	"don't increment dirty count",	0);
	create_insn	(x=0XA54D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA552,	"[SI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0XA552);
	op_hex		(x,	1);
	create_insn	(x=0XA556);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA563);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA569);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA56C,	"BUFINSIZ",	0);
	create_insn	(x=0XA56C);
	op_dec		(x,	1);
	create_insn	(x=0XA56F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA575);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA57B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA58F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA593,	"[DI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0XA593);
	op_hex		(x,	1);
	create_insn	(x=0XA599);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA59E,	"[DI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0XA59E);
	op_hex		(x,	1);
	set_cmt	(0XA5A2,	"BUFINSIZ-1",	0);
	create_insn	(x=0XA5A2);
	op_dec		(x,	1);
	set_cmt	(0XA5A5,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	create_insn	(x=0XA5B2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA5B9,	"[es:bp+DPB.FAT_SIZE]",	0);
	create_insn	(0XA5B9);
	set_name	(0XA5B9,	"IsFAT32");
	set_cmt	(0XA5BE,	"not FAT32",	0);
	set_cmt	(0XA5C0,	"[es:bp+DPB.LAST_CLUSTER+2]",	0);
	set_cmt	(0XA5C5,	"FAT32",	0);
	set_cmt	(0XA5C7,	"[es:bp+DPB.LAST_CLUSTER]",	0);
	set_cmt	(0XA5CC,	"cf=1 -> FAT32",	0);
	create_insn	(0XA5CE);
	create_insn	(x=0XA5D7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XA5D7,	"MAPCLUSTER");
	create_insn	(x=0XA5E0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA5E6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA5EF,	"not FAT32",	0);
	create_insn	(x=0XA5F1);
	op_hex		(x,	1);
	create_insn	(x=0XA5F3);
	op_hex		(x,	1);
	create_insn	(x=0XA5F5);
	op_hex		(x,	1);
	create_insn	(x=0XA5F7);
	op_hex		(x,	1);
	create_insn	(x=0XA5F9);
	op_hex		(x,	1);
	set_cmt	(0XA5FB,	"DI:DX:AX = 4*(DX:AX)",	0);
	create_insn	(x=0XA5FB);
	op_hex		(x,	1);
	set_cmt	(0XA5FD,	"32 bit FAT",	0);
	set_cmt	(0XA5FF,	"[ES:BP+DPB.MAX_CLUSTER]",	0);
	create_insn	(0XA5FF);
	set_cmt	(0XA605,	"16 bit FAT",	0);
	create_insn	(x=0XA607);
	op_hex		(x,	1);
	create_insn	(x=0XA609);
	op_hex		(x,	1);
	create_insn	(x=0XA60D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA613,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	create_insn	(x=0XA617);
	op_dec		(x,	1);
	create_insn	(x=0XA61E);
	op_hex		(x,	1);
	create_insn	(x=0XA620);
	op_hex		(x,	1);
	create_insn	(x=0XA622);
	op_hex		(x,	1);
	set_cmt	(0XA624,	"9 bit shift to right",	0);
	create_insn	(x=0XA62C);
	op_hex		(x,	1);
	set_cmt	(0XA630,	"DI:AX = sector contains requested cluster data",	0);
	set_cmt	(0XA633,	"offset in sector",	0);
	create_insn	(x=0XA633);
	op_hex		(x,	1);
	set_cmt	(0XA637,	"[ES:BP+DPB.FIRST_FAT]",	0);
	set_cmt	(0XA63E,	"CX is sector size - 1",	0);
	create_insn	(x=0XA645);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA653,	"CX is sec siz-1, AX is offset in sec",	0);
	set_cmt	(0XA654,	"BX:DX is sector",	0);
	set_cmt	(0XA655,	"(ds=ss)",	0);
	create_insn	(x=0XA657);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA65B,	"[SI+BUFINSIZ]",	0);
	set_cmt	(0XA662,	"ds<>ss",	0);
	create_insn	(x=0XA66A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA66E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA671);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA675,	"0",	0);
	create_insn	(x=0XA67A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA67E,	"adc bx,0",	0);
	create_insn	(x=0XA680);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA68A,	"(ds=ss)",	0);
	create_insn	(x=0XA68C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA690,	"[SI+BUFINSIZ]",	0);
	create_insn	(x=0XA699);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA69C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA69F,	"(ds<>ss)",	0);
	create_insn	(x=0XA69F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA6AE,	"[ES:BP+DPB.MAX_CLUSTER]",	0);
	set_cmt	(0XA6B4,	"16 bit FAT",	0);
	set_cmt	(0XA6B6,	"12 bit FAT",	0);
	set_cmt	(0XA6B8,	"set zero flag if not on boundary",	0);
	create_insn	(x=0XA6B8);
	op_hex		(x,	1);
	set_cmt	(0XA6BC,	"(ds=ss)",	0);
	create_insn	(x=0XA6BC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA6C6,	"[ES:DI+SF_ENTRY.sf_devptr]",	0);
	create_insn	(0XA6C6);
	set_name	(0XA6C6,	"FATREAD_SFT");
	set_cmt	(0XA6CA,	"[ES:BP+DPB.DRIVE]",	0);
	set_name	(0XA6CA,	"fatread_gotdpb");
	create_insn	(x=0XA6CE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA6D1,	"Set THISDPB",	0);
	set_name	(0XA6D7,	"fatread_sft_retn");
	create_insn	(0XA6D8);
	set_name	(0XA6D8,	"FATREAD_CDS");
	set_cmt	(0XA6DA,	"[ES:DI+curdir.devptr]",	0);
	set_cmt	(0XA6E7,	"\n-1",	0);
	set_name	(0XA6E7,	"MED_CHANGE");
	create_insn	(x=0XA6EB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA6EF,	"CX is number of structures",	0);
	set_cmt	(0XA6F1,	"[ES:DI+curdir.devptr]\nFind all CDS with this devptr",	0);
	set_cmt	(0XA6F5,	"(es:di) = CDS pointer",	0);
	create_insn	(x=0XA6F5);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA6FA,	"[ES:DI+curdir.flags+1],\n(curdir_isnet>>8)",	0);
	create_insn	(x=0XA6FA);
	op_hex		(x,	1);
	set_cmt	(0XA701,	"[ES:DI+curdir.devptr]",	0);
	set_cmt	(0XA705,	"no match",	0);
	set_cmt	(0XA709,	"[ES:DI+curdir.devptr+2]",	0);
	set_cmt	(0XA70D,	"CDS not for this drive",	0);
	set_cmt	(0XA70F,	"[ES:DI+curdir.ID]\nIf root (0), leave root",	0);
	set_cmt	(0XA713,	"= 0\nPCDOS 7.1 bug (!?) ; Erdogan Tan - 03/03/2024\ntest dword ptr es:[di+49h],-1 ; Win ME\njz short frcd25",	0);
	set_cmt	(0XA715,	"[ES:DI+curdir.ID+2]",	0);
	set_cmt	(0XA719,	"leave root (= 0)",	0);
	set_cmt	(0XA71B,	"else invalid (-1)",	0);
	set_cmt	(0XA71F,	"-1",	0);
	set_cmt	(0XA723,	"add di,curdir.size\nPoint to next CDS",	0);
	create_insn	(x=0XA723);
	op_dec		(x,	1);
	create_insn	(x=0XA729);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA72F,	"DPB.FAT_SIZE",	0);
	create_insn	(0XA72F);
	set_name	(0XA72F,	"chk_set_first_access");
	set_cmt	(0XA734,	"FAT (FAT12 or FAT16)\nFAT32",	0);
	set_cmt	(0XA736,	"DPB.FREE_CNT_HW",	0);
	set_cmt	(0XA73B,	"High word of free cluster count",	0);
	set_cmt	(0XA743,	"DPB.FREE_CNT",	0);
	set_cmt	(0XA748,	"Count of free clusters, -1 if unknown",	0);
	set_cmt	(0XA750,	"DPB.FIRST_ACCESS",	0);
	create_insn	(x=0XA750);
	op_hex		(x,	1);
	set_cmt	(0XA756,	"Err in FAT must force recalc of freespace",	0);
	create_insn	(0XA756);
	set_cmt	(0XA759,	"STECODE",	0);
	create_insn	(x=0XA759);
	op_hex		(x,	1);
	set_cmt	(0XA75D,	"[ALLOWED],Allowed_FAIL+Allowed_RETRY",	0);
	create_insn	(x=0XA75D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA762,	"2+Allowed_FAIL+Allowed_RETRY\n(While trying to read FAT)",	0);
	set_cmt	(0XA764,	"Tell which drive",	0);
	create_insn	(x=0XA764);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA76A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA770,	"User said retry",	0);
	set_cmt	(0XA772,	"User said FAIL",	0);
	set_cmt	(0XA774,	"SS is DOSDATA",	0);
	create_insn	(0XA774);
	set_name	(0XA774,	"FAT_GOT_DPB");
	create_insn	(x=0XA77C);
	op_dec		(x,	1);
	set_cmt	(0XA77E,	"[ES:BP+DPB.UNIT]",	0);
	set_cmt	(0XA782,	"DEVMDCH",	0);
	create_insn	(x=0XA782);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA787);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA78A,	"[ES:BP+DPB.MEDIA]",	0);
	create_insn	(x=0XA78E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA794,	"[CALLMED]",	0);
	create_insn	(x=0XA794);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA799,	"offset DEVCALL",	0);
	create_insn	(x=0XA799);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA79C,	"[ES:BP+DPB.DRIVER_ADDR]",	0);
	create_insn	(x=0XA7A7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA7AF,	"[ES:BP+DPB.FIRST_ACCESS]",	0);
	set_cmt	(0XA7B3,	"Use physical unit number",	0);
	create_insn	(x=0XA7B3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA7B6,	"izolate (FAT) first access bit",	0);
	create_insn	(x=0XA7B6);
	op_hex		(x,	1);
	set_cmt	(0XA7B9,	"clear first access (FAT) bit 7",	0);
	create_insn	(x=0XA7B9);
	op_hex		(x,	1);
	create_insn	(x=0XA7BE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA7C4,	"-1",	0);
	create_insn	(x=0XA7C4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA7CC,	"[CALLRBYT]",	0);
	create_insn	(x=0XA7CC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA7D5,	"Media not changed (NZ)",	0);
	create_insn	(0XA7D6);
	set_cmt	(0XA7D8,	"[ES:BP+DPB.DRIVER_ADDR]",	0);
	set_cmt	(0XA7DC,	"[es:bp+SYSDEV.ATT+1],(DEVOPCL>>8)",	0);
	create_insn	(x=0XA7DC);
	op_hex		(x,	1);
	set_cmt	(0XA7E9,	"Allowed_FAIL+Allowed_RETRY",	0);
	create_insn	(x=0XA7E9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA7EF,	"Get volume ID pointer",	0);
	create_insn	(x=0XA7EF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XA7F3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA7F8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA7FC,	"error_I24_wrong_disk",	0);
	set_cmt	(0XA7FF,	"Write",	0);
	create_insn	(x=0XA7FF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA80D,	"Retry",	0);
	set_cmt	(0XA810,	"any dirty buffers ?",	0);
	create_insn	(x=0XA810);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA816,	"no, skip the check",	0);
	set_cmt	(0XA818,	"get pointer to first buffer",	0);
	set_cmt	(0XA81B,	"[di+BUFFINFO.buf_ID] ; Unit OK ?",	0);
	set_cmt	(0XA81E,	"no",	0);
	set_cmt	(0XA820,	"is the buffer dirty ?",	0);
	create_insn	(x=0XA820);
	op_hex		(x,	1);
	set_cmt	(0XA824,	"no, go for next buffer",	0);
	create_insn	(0XA82A);
	create_insn	(0XA82E);
	set_cmt	(0XA830,	"[di+BUFFINFO.buf_next] ; get next buffer",	0);
	create_insn	(0XA830);
	set_cmt	(0XA832,	"is this where we started ?",	0);
	create_insn	(x=0XA832);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA837,	"no, check this guy also\nIf no dirty buffers, assume Media changed",	0);
	set_cmt	(0XA839,	"[ES:BP+DPB.FREE_CNT],-1\nMedia changed, must recompute",	0);
	set_cmt	(0XA83F,	"[ES:BP+DPB.FAT_SIZE] = 0 for FAT32 fs",	0);
	set_cmt	(0XA844,	"not FAT32",	0);
	set_cmt	(0XA846,	"[ES:BP+DPB.FREE_CNT_HW],-1",	0);
	set_cmt	(0XA84F,	"[DI+BUFFINFO.buf_ID],al ; This drive ?",	0);
	set_cmt	(0XA854,	"[DI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0XA854);
	op_hex		(x,	1);
	set_cmt	(0XA85A,	"[DI+BUFFINFO.buf_ID],\n(buf_visit*256)+0FFh ; free up",	0);
	set_cmt	(0XA864,	"[di+BUFFINFO.buf_next]",	0);
	create_insn	(0XA864);
	create_insn	(x=0XA866);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA86D,	"look ahead buffers ?",	0);
	create_insn	(x=0XA86D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA873,	"no",	0);
	set_cmt	(0XA875,	"same as changed drive ?",	0);
	create_insn	(x=0XA875);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA87A,	"no",	0);
	set_cmt	(0XA87C,	"invalidate look ahead buffers",	0);
	create_insn	(x=0XA87C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA882,	"[ES:BP+DPB.DRIVER_ADDR]",	0);
	set_cmt	(0XA886,	"[DI+SYSDEV.ATT+1],(ISFATBYDEV>>8)",	0);
	create_insn	(x=0XA886);
	op_hex		(x,	1);
	set_cmt	(0XA88E,	"DPB.SECTOR_SIZE ; bytes per sector",	0);
	set_cmt	(0XA894,	"DPB.FIRST_FAT ; starting sector of FATs",	0);
	set_cmt	(0XA89A,	"DPB.FAT_COUNT ; number of FATs",	0);
	set_cmt	(0XA89F,	"DPB.MAX_CLUSTER ; cluster count + 1",	0);
	set_cmt	(0XA8A5,	"DPB.FAT_SIZE ; FAT sectors (16 bit)",	0);
	set_cmt	(0XA8AB,	"high word of cluster number (for UNPACK)",	0);
	create_insn	(x=0XA8AB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA8B1,	"Read the 1st FAT sector into CURBUF",	0);
	create_insn	(x=0XA8BC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0XA8C2);
	create_insn	(x=0XA8C4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA8C9,	"sub di,BUFINSIZ",	0);
	create_insn	(x=0XA8C9);
	op_dec		(x,	1);
	set_cmt	(0XA8CC,	"0",	0);
	create_insn	(x=0XA8CC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA8D1,	"buffer is in HMA\nuse [LowMemBuff] to transfer at first",	0);
	set_cmt	(0XA8D5,	"0",	0);
	create_insn	(x=0XA8D5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA8E4,	"add di,BUFINSIZ",	0);
	create_insn	(x=0XA8E4);
	op_dec		(x,	1);
	set_cmt	(0XA8E7,	"[SS:CALLXAD+2]",	0);
	create_insn	(x=0XA8E7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA8F0,	"[CALLXAD]",	0);
	create_insn	(x=0XA8F0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA8F4,	"DBPBHL",	0);
	create_insn	(x=0XA8F4);
	op_dec		(x,	1);
	set_cmt	(0XA8F6,	"[ES:BP+DPB.UNIT]",	0);
	set_cmt	(0XA8FA,	"DEVBPB",	0);
	create_insn	(x=0XA8FA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA8FF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA902);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA908,	"[ES:BP+DPB.MEDIA]",	0);
	set_cmt	(0XA90E,	"[CALLMED]",	0);
	create_insn	(x=0XA90E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA911,	"offset DEVCALL",	0);
	create_insn	(x=0XA911);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA914,	"[ES:BP+DPB.DRIVER_ADDR]\nDS:SI Points to device header",	0);
	set_cmt	(0XA918,	"ES:BX Points to call header",	0);
	create_insn	(x=0XA921);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA927,	"\nhave error",	0);
	set_cmt	(0XA929,	"[CALLXAD] ; Buffer (data) address",	0);
	create_insn	(x=0XA929);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA92D,	"byte BUFFINFO.buf_ID = 0FFh ; FREE\nbyte BUFFINFO.buf_flags = 0",	0);
	create_insn	(x=0XA92D);
	op_dec		(x,	0);
	set_cmt	(0XA935,	"Address of the BPB (DEVCALL offset 18)",	0);
	create_insn	(x=0XA935);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA939,	"0",	0);
	set_cmt	(0XA93B,	"[ES:BP+DPB.NEXT_FREE] = 0\nrecycle scanning pointer",	0);
	set_cmt	(0XA93F,	"'RA' ; FAT32 extended BPB/DPB signature",	0);
	set_cmt	(0XA942,	"BPB.fatsecs ; 16 bit FAT size = 0 for FAT32 fs",	0);
	set_cmt	(0XA945,	"not FAT32",	0);
	set_cmt	(0XA947,	"[ES:BP+DPB.FAT32_NXTFREE],0",	0);
	set_cmt	(0XA94B,	"[ES:BP+DPB.FAT32_NXTFREE+2],0",	0);
	set_cmt	(0XA94F,	"-1",	0);
	set_cmt	(0XA950,	"(DPB.FREE_CNT) set free count to -1 (unknown)",	0);
	set_cmt	(0XA958,	"'XE' ; FAT32 extended BPB/DPB signature",	0);
	set_cmt	(0XA95E,	"[SS:CALLXAD] ; Get back buffer pointer",	0);
	create_insn	(x=0XA95E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA963,	"[es:bp+DPB.FSINFO_SECTOR]",	0);
	set_cmt	(0XA967,	"0",	0);
	set_cmt	(0XA969,	"[es:bp+DPB.FAT_SIZE] ; 16 bit FAT size field",	0);
	set_cmt	(0XA96D,	"FAT32 fs",	0);
	set_cmt	(0XA96F,	"FAT fs",	0);
	set_cmt	(0XA972,	"invalid ?",	0);
	create_insn	(0XA972);
	set_cmt	(0XA975,	"no",	0);
	set_cmt	(0XA977,	"skip reading FSINFO sector",	0);
	set_cmt	(0XA97A,	"0",	0);
	create_insn	(x=0XA97A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XA981);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA987,	"buffer is in conventional (<=640KB) memory",	0);
	set_cmt	(0XA989,	"use a buffer in conventional memory",	0);
	create_insn	(x=0XA989);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XA990,	"Allowed_FAIL+Allowed_RETRY",	0);
	create_insn	(x=0XA990);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XA99E,	"\nds:di = (FSINFO sector) buffer\nFSI_HeadSig = 41615252h",	0);
	set_cmt	(0XA9A0,	"'RR' ; check if it is a valid FSINFO sector",	0);
	set_cmt	(0XA9A4,	"not valid",	0);
	set_cmt	(0XA9A6,	"'aA' ; (NASM syntax)",	0);
	create_insn	(x=0XA9A6);
	op_hex		(x,	0);
	set_cmt	(0XA9AD,	"'rr' ; FSI_StrucSig = 61417272h",	0);
	create_insn	(x=0XA9AD);
	op_dec		(x,	0);
	set_cmt	(0XA9B5,	"'Aa'",	0);
	create_insn	(x=0XA9B5);
	op_dec		(x,	0);
	set_cmt	(0XA9BB,	"not valid",	0);
	set_cmt	(0XA9BD,	"valid",	0);
	set_cmt	(0XA9C0,	"[es:bp+DPB.LAST_CLUSTER+2]",	0);
	set_cmt	(0XA9C4,	"[es:bp+DPB.LAST_CLUSTER]",	0);
	set_cmt	(0XA9C8,	"FSI_FreeCount ; bx:cx = number of clusters + 1",	0);
	create_insn	(x=0XA9C8);
	op_dec		(x,	1);
	set_cmt	(0XA9CC,	"FSI_FreeCount+2",	0);
	create_insn	(x=0XA9CC);
	op_dec		(x,	1);
	set_cmt	(0XA9D0,	"is Free Count >= (Number of Clusters + 1) ?",	0);
	set_cmt	(0XA9D2,	"if yes, it is invalid value (must be 0FFFFFFFFh)",	0);
	set_cmt	(0XA9D6,	"yes, invalid value (must be 0FFFFFFFFh)",	0);
	set_cmt	(0XA9D8,	"no, valid free count \nsave free count into [es:bp+DPB.FREE_CNT]",	0);
	set_cmt	(0XA9DC,	"[es:bp+DPB.FREE_CNT+2]",	0);
	set_cmt	(0XA9E0,	"FSI_Nxt_Free",	0);
	create_insn	(x=0XA9E0);
	op_dec		(x,	1);
	create_insn	(x=0XA9E4);
	op_dec		(x,	1);
	set_cmt	(0XA9E8,	"is the next free clust num >= (num of clusters + 1) ?",	0);
	set_cmt	(0XA9EA,	"invalid (if dx > bx)",	0);
	set_cmt	(0XA9EE,	"invalid",	0);
	set_cmt	(0XA9F0,	"save next free (search) cluster number",	0);
	set_cmt	(0XA9F4,	"into [es:bp+DPB.FAT32_NXTFREE]",	0);
	set_cmt	(0XA9F8,	"and into [es:bp+DPB.NEXT_FREE] ; low word",	0);
	set_cmt	(0XA9FF,	"is buffer in HMA ?",	0);
	create_insn	(x=0XA9FF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAA05,	"yes",	0);
	set_cmt	(0XAA07,	"invalidate buffer (set it as free buffer)",	0);
	create_insn	(x=0XAA07);
	op_dec		(x,	0);
	create_insn	(x=0XAA0C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAA14,	"[es:bp+DPB.FIRST_FAT]",	0);
	set_cmt	(0XAA1B,	"invalidate buffer (set it as free buffer)\ndi = buffer header + 4 (BUFFINFO.buf_ID)",	0);
	create_insn	(x=0XAA1B);
	op_dec		(x,	0);
	set_cmt	(0XAA20,	"[es:bp+DPB.FAT_COUNT]",	0);
	set_cmt	(0XAA24,	"BUFFINFO.buf_wrtcnt ; buffer header address + 10",	0);
	create_insn	(x=0XAA24);
	op_dec		(x,	0);
	set_cmt	(0XAA27,	"[es:bp+DPB.FAT_SIZE] ; 16 bit FAT size field",	0);
	set_cmt	(0XAA2D,	"FAT (FAT12 or FAT16) fs\nFAT32 fs",	0);
	set_cmt	(0XAA2F,	"[es:bp+DPB.FAT32_SIZE] ; FAT sectors (per one FAT)",	0);
	set_cmt	(0XAA33,	"BUFFINFO.buf_wrtcntinc ; # sectors between each write",	0);
	create_insn	(x=0XAA33);
	op_dec		(x,	0);
	set_cmt	(0XAA36,	"[es:bp+DPB.FAT32_SIZE+2]",	0);
	set_cmt	(0XAA3C,	"BUFFINFO.buf_wrtcntinc",	0);
	create_insn	(x=0XAA3C);
	op_dec		(x,	0);
	set_cmt	(0XAA3F,	"0",	0);
	set_cmt	(0XAA41,	"BUFFINFO.buf_wrtcntinc+2 ; hw of sectors per FAT\nPCDOS 7.1 BUG !? This would be 'mov [di-11],ax'\nErdogan Tan - 03/03/2024",	0);
	create_insn	(x=0XAA41);
	op_dec		(x,	0);
	set_cmt	(0XAA44,	"SS is DOSDATA",	0);
	set_cmt	(0XAA48,	"Media changed (Z), Carry clear",	0);
	set_cmt	(0XAA4B,	"Pointer to the first buffer",	0);
	create_insn	(x=0XAA4B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XAA4B,	"GETCURHEAD");
	set_cmt	(0XAA50,	"-1 ; invalidate last buffer",	0);
	create_insn	(x=0XAA50);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAA57,	"save first buffer address",	0);
	create_insn	(x=0XAA57);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAA5D,	"[di+BUFFINFO.buf_next]",	0);
	create_insn	(0XAA5D);
	set_name	(0XAA5D,	"SCANPLACE");
	create_insn	(0XAA64);
	set_name	(0XAA64,	"PLACEBUF");
	set_cmt	(0XAA66,	"[DI+BUFFINFO.buf_next]",	0);
	set_cmt	(0XAA68,	"bx = offset of head of list",	0);
	create_insn	(x=0XAA68);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAA6D,	"Buf = last?",	0);
	set_cmt	(0XAA6F,	"Yes, special case",	0);
	set_cmt	(0XAA71,	"Buf = first?",	0);
	set_cmt	(0XAA75,	"Yes, special case",	0);
	create_insn	(x=0XAA75);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAA79,	"Continue with repositioning",	0);
	create_insn	(0XAA7B);
	set_cmt	(0XAA7C,	"[DI+BUFFINFO.buf_prev] ; prior Buf",	0);
	set_cmt	(0XAA7F,	"[SI+BUFFINFO.buf_next]",	0);
	set_cmt	(0XAA82,	"[SI+BUFFINFO.buf_prev]",	0);
	set_cmt	(0XAA85,	"[BX+BUFFINFO.buf_prev] ; last buffer",	0);
	set_cmt	(0XAA88,	"[BX+BUFFINFO.buf_prev]",	0);
	set_cmt	(0XAA8B,	"[SI+BUFFINFO.buf_next] ; Add Buf to end of list",	0);
	set_cmt	(0XAA8D,	"[DI+BUFFINFO.buf_prev] ; Update link in Buf too",	0);
	set_cmt	(0XAA90,	"[DI+BUFFINFO.buf_next]",	0);
	set_cmt	(0XAA95,	"[DI+BUFFINFO.buf_ID],-1 ; Buffer FREE?",	0);
	set_cmt	(0XAA99,	"-no, jump.",	0);
	set_cmt	(0XAA9B,	"-yes, make it LRU.",	0);
	create_insn	(x=0XAA9B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XAAA1);
	set_name	(0XAAA1,	"POINTCOMP");
	set_name	(0XAAAF,	"_ret_label");
	create_insn	(0XAAB0);
	set_name	(0XAAB0,	"GETBUFFR");
	create_insn	(x=0XAAB2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XAAB2,	"GETBUFFRB");
	set_cmt	(0XAABE,	"not FAT32",	0);
	set_cmt	(0XAAC0,	"[es:bp+DPB.EXT_FLAGS]",	0);
	set_cmt	(0XAAC4,	"bit 7 -- 1 means only one FAT is active",	0);
	create_insn	(x=0XAAC4);
	op_hex		(x,	1);
	set_cmt	(0XAAC8,	"Active FAT is the one referenced in bits 0-3",	0);
	create_insn	(x=0XAAC8);
	op_hex		(x,	1);
	set_cmt	(0XAACE,	"Zero based number of active FAT.\n(Only valid if mirroring is disabled.)",	0);
	set_cmt	(0XAAD0,	"[es:bp+DPB.FAT32_SIZE+2]",	0);
	set_cmt	(0XAAD5,	"[es:bp+DPB.FAT32_SIZE]",	0);
	create_insn	(x=0XAADE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAAE2,	"[ES:BP+DPB.DRIVE]",	0);
	set_cmt	(0XAAE6,	"-1",	0);
	set_cmt	(0XAAE9,	"Get the recency pointer",	0);
	create_insn	(x=0XAAE9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XAAED);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAAF2,	"Recency pointer valid?",	0);
	set_cmt	(0XAAF5,	"No",	0);
	set_cmt	(0XAAF7,	"[DI+BUFFINFO.buf_sector]",	0);
	set_cmt	(0XAAFC,	"[DI+BUFFINFO.buf_sector+2]",	0);
	set_cmt	(0XAB01,	"[DI+BUFFINFO.buf_ID]",	0);
	set_cmt	(0XAB09,	"... CALL GETCURHEAD ...",	0);
	create_insn	(x=0XAB09);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XAB0E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XAB15);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAB1A,	"[DI+BUFFINFO.buf_sector]",	0);
	set_cmt	(0XAB1D,	"wrong sector lo",	0);
	set_cmt	(0XAB1F,	"[DI+BUFFINFO.buf_sector+2]",	0);
	set_cmt	(0XAB22,	"wrong sector hi",	0);
	set_cmt	(0XAB24,	"[DI+BUFFINFO.buf_ID]",	0);
	set_cmt	(0XAB27,	"Found the requested sector",	0);
	set_cmt	(0XAB2C,	"Free buffer ?",	0);
	create_insn	(0XAB2C);
	set_cmt	(0XAB30,	"no",	0);
	set_cmt	(0XAB32,	"save buffer (offset) addr",	0);
	set_cmt	(0XAB34,	"[DI+BUFFINFO.BUF_NEXT]",	0);
	set_cmt	(0XAB36,	"back at the front again?",	0);
	create_insn	(x=0XAB36);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAB3B,	"no, continue looking",	0);
	set_cmt	(0XAB3D,	"-1 ; invalid (not a free buffer addr)",	0);
	set_cmt	(0XAB42,	"restore free buff (header offset) addr",	0);
	create_insn	(0XAB46);
	set_cmt	(0XAB4B,	"Write out the dirty buffer",	0);
	create_insn	(x=0XAB52);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAB57,	"if got hard error",	0);
	set_cmt	(0XAB59,	"initial flags",	0);
	set_cmt	(0XAB5B,	"am to Read in the new sector?",	0);
	create_insn	(x=0XAB5B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAB60,	"no, we're done",	0);
	set_cmt	(0XAB62,	"LEA BX,[DI+BUFINSIZ]",	0);
	create_insn	(x=0XAB62);
	op_dec		(x,	1);
	set_cmt	(0XAB6C,	"is buffers in HMA?",	0);
	create_insn	(x=0XAB6C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAB72,	"no",	0);
	set_cmt	(0XAB76,	"Then let's read it into scratch buff",	0);
	create_insn	(x=0XAB76);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAB7B,	"FAT sector ?",	0);
	set_cmt	(0XAB7D,	"no",	0);
	set_cmt	(0XAB7F,	"yes",	0);
	set_cmt	(0XAB82,	"buf_isFAT",	0);
	set_cmt	(0XAB84,	"Buffer is marked free if read barfs",	0);
	set_cmt	(0XAB86,	"Buffer is marked free if read barfs",	0);
	create_insn	(0XAB86);
	set_cmt	(0XAB89,	"Set buf_flags to no type, DO NOT XOR!",	0);
	set_cmt	(0XAB8D,	"did we read into scratch buff ?",	0);
	create_insn	(x=0XAB8D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAB92,	"no",	0);
	set_cmt	(0XAB94,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	create_insn	(x=0XAB9D);
	op_hex		(x,	1);
	create_insn	(x=0XABA0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XABA6,	"rep movsw (skip 32bit prefix)",	0);
	create_insn	(x=0XABA8);
	op_hex		(x,	1);
	set_cmt	(0XABAA,	"move the contents of scratch buffer",	0);
	set_cmt	(0XABB1,	"Retrieve possible CY from DREAD",	0);
	create_insn	(x=0XABB8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XABBD,	"[ES:BP+DPB.DRIVE]",	0);
	set_cmt	(0XABC1,	"[DI+BUFFINFO.buf_sector]",	0);
	set_cmt	(0XABC4,	"[DI+BUFFINFO.buf_DPB]",	0);
	set_cmt	(0XABC7,	"[DI+BUFFINFO.buf_DPB+2]",	0);
	set_cmt	(0XABCA,	"[DI+BUFFINFO.buf_sector+2]",	0);
	set_cmt	(0XABCD,	"[DI+BUFFINFO.buf_ID]",	0);
	set_cmt	(0XABD0,	"[DI+BUFFINFO.buf_wrtcnt],1\nDefault to not a FAT sector",	0);
	set_cmt	(0XABD9,	"FAT sector ?",	0);
	set_cmt	(0XABDB,	"no",	0);
	set_cmt	(0XABDD,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0XABE2,	"not FAT32",	0);
	set_cmt	(0XABE4,	"[es:bp+DPB.EXT_FLAGS]",	0);
	create_insn	(x=0XABE4);
	op_hex		(x,	1);
	set_cmt	(0XABEA,	"bit 7 -- 1 means only one FAT is active",	0);
	set_cmt	(0XABEC,	"[es:bp+DPB.FAT_COUNT]",	0);
	set_cmt	(0XABF0,	"[di+BUFFINFO.buf_wrtcnt]",	0);
	set_cmt	(0XABF3,	"[es:bp+DPB.FAT32_SIZE+2]",	0);
	set_cmt	(0XABF7,	"[di+BUFFINFO.buf_wrtcntinc+2]",	0);
	set_cmt	(0XABFA,	"[es:bp+DPB.FAT32_SIZE]",	0);
	set_cmt	(0XAC00,	"[es:bp+DPB.FAT_COUNT]",	0);
	create_insn	(0XAC00);
	set_cmt	(0XAC04,	"[di+BUFFINFO.buf_wrtcnt]",	0);
	set_cmt	(0XAC07,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0XAC0B,	"[di+BUFFINFO.buf_wrtcntinc]",	0);
	create_insn	(x=0XAC11);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XAC16);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XAC1B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XAC20);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XAC2A,	"getbuffr_retn");
	set_cmt	(0XAC2B,	"-1",	0);
	create_insn	(0XAC2B);
	set_name	(0XAC2B,	"FLUSHBUF");
	create_insn	(x=0XAC2F);
	op_dec		(x,	1);
	set_cmt	(0XAC32,	"[ss:bx+drive_flags-1],0F7h\nclear bit 3",	0);
	create_insn	(x=0XAC32);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XAC38,	"backward",	0);
	set_cmt	(0XAC3E,	"FROM_DISK_RESET",	0);
	create_insn	(x=0XAC3E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	create_insn	(x=0XAC46);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAC51,	"[DI+BUFFINFO.buf_ID]",	0);
	create_insn	(x=0XAC54);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAC5B,	"FROM_DISK_RESET",	0);
	create_insn	(x=0XAC5B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XAC68,	"[DI+BUFFINFO.buf_next]",	0);
	create_insn	(x=0XAC6A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XAC73);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAC7C,	"-1",	0);
	create_insn	(0XAC7C);
	set_name	(0XAC7C,	"CHECKFLUSH");
	set_cmt	(0XAC7E,	"[DI+BUFFINFO.buf_ID]",	0);
	set_cmt	(0XAC81,	"Skip free buffer, carry clear",	0);
	set_cmt	(0XAC85,	"do this buffer",	0);
	set_cmt	(0XAC87,	"[DI+BUFFINFO.buf_ID]",	0);
	set_cmt	(0XAC8B,	"Buffer not for this unit or SFT",	0);
	set_cmt	(0XAC91,	"bit 3",	0);
	create_insn	(x=0XAC91);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XAC99,	"[DI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0XAC99);
	op_hex		(x,	1);
	set_cmt	(0XACA0,	"[DI+BUFFINFO.buf_ID]",	0);
	set_cmt	(0XACA7,	"Leave buffer marked free (lost)",	0);
	set_cmt	(0XACA9,	"~buf_dirty  ; Buffer is clean, clears carry",	0);
	create_insn	(x=0XACA9);
	op_hex		(x,	1);
	set_cmt	(0XACAC,	"[DI+BUFFINFO.buf_ID]",	0);
	set_name	(0XACB0,	"checkflush_retn");
	create_insn	(0XACB1);
	set_name	(0XACB1,	"BUFWRITE");
	set_cmt	(0XACB4,	"[DI+BUFFINFO.buf_ID]",	0);
	set_cmt	(0XACBB,	"buf_dirty",	0);
	create_insn	(x=0XACBB);
	op_hex		(x,	1);
	create_insn	(x=0XACC3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XACCA,	"[DI+BUFFINFO.buf_sector]",	0);
	set_cmt	(0XACCD,	"[DI+BUFINSIZ]",	0);
	create_insn	(x=0XACCD);
	op_dec		(x,	1);
	set_cmt	(0XACD0,	"[DI+BUFFINFO.buf_wrtcnt]",	0);
	create_insn	(x=0XACD0);
	op_dec		(x,	1);
	create_insn	(x=0XACD5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XACDA,	"[DI+BUFFINFO.buf_DPB]",	0);
	create_insn	(x=0XACDA);
	op_dec		(x,	1);
	set_cmt	(0XACDD,	"Allowed_RETRY+Allowed_FAIL",	0);
	create_insn	(x=0XACDD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XACE3,	"buf_isDATA",	0);
	create_insn	(x=0XACE3);
	op_hex		(x,	1);
	set_cmt	(0XACE8,	"Allowed_IGNORE",	0);
	create_insn	(x=0XACE8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XACEE,	"[DI+BUFFINFO.buf_wrtcntinc+2]",	0);
	create_insn	(x=0XACEE);
	op_dec		(x,	1);
	set_cmt	(0XACF1,	"[DI+BUFFINFO.buf_wrtcntinc]",	0);
	create_insn	(x=0XACF1);
	op_dec		(x,	1);
	set_cmt	(0XACF9,	"SI:AX = FAT size (in sectors)",	0);
	create_insn	(x=0XACFA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XAD08);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAD14,	"[es:bp+DPB.SECTOR_SIZE]",	0);
	create_insn	(x=0XAD18);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XAD1D);
	op_hex		(x,	1);
	create_insn	(x=0XAD22);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAD28,	"rep movsw",	0);
	create_insn	(x=0XAD2A);
	op_hex		(x,	1);
	create_insn	(x=0XAD3C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XAD49);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAD57,	"SET_RQ_SC_PARMS",	0);
	create_insn	(0XAD57);
	set_name	(0XAD57,	"null_sub");
	set_cmt	(0XAD58,	"[ES:DI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0XAD58);
	op_hex		(x,	1);
	set_name	(0XAD58,	"SET_BUF_DIRTY");
	set_cmt	(0XAD5F,	"[ES:DI+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0XAD5F);
	op_hex		(x,	1);
	create_insn	(x=0XAD64);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XAD64,	"INC_DIRTY_COUNT");
	set_name	(0XAD69,	"yesdirty2");
	create_insn	(x=0XAD6A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XAD6A,	"DEC_DIRTY_COUNT");
	create_insn	(x=0XAD72);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XAD78);
	set_name	(0XAD78,	"$WAIT");
	create_insn	(x=0XAD7A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XAD82);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XAD82,	"$EXEC");
	set_cmt	(0XAD88,	"is this ExecReady call ?",	0);
	set_cmt	(0XAD8A,	"no, continue",	0);
	set_cmt	(0XAD8C,	"change ret address to LeaveDOS",	0);
	create_insn	(x=0XAD8D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XAD91,	"Exec_@f");
	create_insn	(x=0XAD94);
	op_dec		(x,	1);
	set_cmt	(0XAD97,	"only 0, 1, 3 or 5 are allowed",	0);
	set_cmt	(0XAD9B,	"mov byte [ss:EXTERR_LOCUS],errLOC_Unk ; 1",	0);
	set_name	(0XAD9B,	"Exec_Bad_Fun");
	set_cmt	(0XAD9E,	"error_invalid_function",	0);
	set_name	(0XADA0,	"Exec_Ret_Err");
	create_insn	(0XADA6);
	set_name	(0XADA6,	"ExecReadyJ");
	set_cmt	(0XADA9,	"do a Leave & xfer sysret_OK",	0);
	create_insn	(0XADAC);
	set_name	(0XADAC,	"Exec_Check_2");
	set_cmt	(0XADB0,	"2 & 4 are not allowed",	0);
	set_cmt	(0XADB6,	"SET EXECUTION STATE",	0);
	set_cmt	(0XADB8,	"Exec_BlkL,BX ; stash args",	0);
	set_cmt	(0XADBB,	"Exec_BlkH,ES",	0);
	set_cmt	(0XADBE,	"Exec_Func,AL",	0);
	set_cmt	(0XADC1,	"Exec_Load_High,0",	0);
	set_cmt	(0XADC5,	"ExecNameL,DX ; set up length of exec name",	0);
	create_insn	(x=0XADC5);
	op_dec		(x,	0);
	set_cmt	(0XADC8,	"ExecNameH,DS",	0);
	create_insn	(x=0XADC8);
	op_dec		(x,	0);
	set_cmt	(0XADCB,	"move pointer to convenient place",	0);
	set_cmt	(0XADD0,	"ExecNameLen,CX ; save length",	0);
	create_insn	(x=0XADD0);
	op_dec		(x,	0);
	set_cmt	(0XADD3,	"save alloc method",	0);
	create_insn	(x=0XADD3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XADD7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XADDB,	"Access mode bits: (0 to 2)\n000  read access\n\nSharing mode bits: (4 to 6)\n010  deny others write access\n\nbit 7 - private",	0);
	set_cmt	(0XADDE,	"EXECOPEN",	0);
	create_insn	(x=0XADDE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0XADF2,	"Exec_Open_Ok");
	set_cmt	(0XADF3,	"~EXECOPEN ; reset flag",	0);
	create_insn	(x=0XADF3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XADFD,	"Exec_FH,AX",	0);
	set_cmt	(0XAE09,	"devid_ISDEV",	0);
	create_insn	(x=0XAE09);
	op_hex		(x,	1);
	set_cmt	(0XAE0E,	"error_file_not_found",	0);
	set_name	(0XAE10,	"Exec_BombJ");
	set_cmt	(0XAE13,	"error_bad_environment",	0);
	create_insn	(0XAE13);
	set_name	(0XAE13,	"BadEnv");
	set_cmt	(0XAE18,	"Exec_Load_Block,0",	0);
	create_insn	(x=0XAE18);
	op_dec		(x,	0);
	set_name	(0XAE18,	"Exec_Check_Environ");
	set_cmt	(0XAE1D,	"Exec_Environ,0",	0);
	create_insn	(x=0XAE1D);
	op_dec		(x,	0);
	set_cmt	(0XAE22,	"Exec_Func,exec_func_overlay",	0);
	create_insn	(x=0XAE22);
	op_hex		(x,	1);
	set_cmt	(0XAE28,	"Exec_Blk ; get block",	0);
	set_cmt	(0XAE2B,	"[SI+EXEC1.ENVIRON] ; address of environ",	0);
	create_insn	(x=0XAE31);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAE36,	"[PDB.ENVIRON]",	0);
	create_insn	(x=0XAE36);
	op_dec		(x,	1);
	set_name	(0XAE3D,	"Exec_Scan_Env");
	set_cmt	(0XAE41,	"at most 32k of environment",	0);
	set_cmt	(0XAE46,	"find that nul byte",	0);
	set_name	(0XAE46,	"Exec_Get_Environ_Len");
	set_cmt	(0XAE4A,	"Dec CX for the next nul byte test",	0);
	set_cmt	(0XAE4B,	"gone beyond the end of the environment",	0);
	set_cmt	(0XAE4D,	"is there another nul byte?",	0);
	set_cmt	(0XAE4E,	"no, scan some more",	0);
	set_cmt	(0XAE51,	"LEA BX,[DI+0Fh+2]",	0);
	set_cmt	(0XAE54,	"ExecNameLen ; BX <- length of environment\nremember argv[0] length\nround up and remember argc",	0);
	create_insn	(x=0XAE54);
	op_dec		(x,	1);
	set_cmt	(0XAE59,	"number of paragraphs needed",	0);
	set_cmt	(0XAE5C,	"can we get the space?",	0);
	set_cmt	(0XAE63,	"nope... cry and sob",	0);
	create_insn	(0XAE65);
	set_name	(0XAE65,	"Exec_Save_Environ");
	set_cmt	(0XAE67,	"Exec_Environ,AX  ; save him for a rainy day",	0);
	create_insn	(x=0XAE67);
	op_dec		(x,	0);
	set_cmt	(0XAE6E,	"copy the environment",	0);
	set_cmt	(0XAE73,	"lds SI,ExecName",	0);
	create_insn	(x=0XAE73);
	op_dec		(x,	1);
	set_cmt	(0XAE76,	"mov CX,ExecNameLen",	0);
	create_insn	(x=0XAE76);
	op_dec		(x,	1);
	set_name	(0XAE7B,	"Exec_Read_Header");
	set_cmt	(0XAE7D,	"exec_header_len ; header size",	0);
	create_insn	(x=0XAE7D);
	op_dec		(x,	1);
	create_insn	(x=0XAE80);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAE90,	"exec_header_len\ndid we read the right number?",	0);
	create_insn	(x=0XAE90);
	op_dec		(x,	1);
	set_cmt	(0XAE93,	"\nyep... continue",	0);
	set_cmt	(0XAE95,	"-1 ; indicate load high?",	0);
	create_insn	(x=0XAE95);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XAE9D,	"mov Exec_Load_High,-1",	0);
	create_insn	(x=0XAEA1);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XAEA1,	"Exec_Check_Sig");
	set_cmt	(0XAEA4,	"'MZ' ; exe_valid_signature",	0);
	set_cmt	(0XAEA7,	"assume com file if no signature",	0);
	set_cmt	(0XAEA9,	"'ZM' ; exe_valid_old_signature",	0);
	set_name	(0XAEAE,	"Exec_Com_Filej");
	set_cmt	(0XAEB1,	"get 512-byte pages",	0);
	create_insn	(x=0XAEB1);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XAEB1,	"Exec_Save_Start");
	set_cmt	(0XAEB4,	"convert to paragraphs",	0);
	set_cmt	(0XAEB8,	"AX = size in paragraphs",	0);
	create_insn	(x=0XAEB8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAEBC,	"mov Exec_Res_Len_Para,AX",	0);
	create_insn	(x=0XAEBC);
	op_dec		(x,	0);
	set_cmt	(0XAEBF,	"test Exec_Func,exec_func_overlay",	0);
	create_insn	(x=0XAEBF);
	op_hex		(x,	1);
	set_cmt	(0XAEC3,	"allocation of space",	0);
	set_cmt	(0XAEC5,	"les DI,Exec_Blk",	0);
	set_cmt	(0XAEC9,	"les ax,[ES:DI+EXEC3.load_addr]",	0);
	set_cmt	(0XAECC,	"mov Exec_DMA,AX",	0);
	create_insn	(x=0XAECC);
	op_dec		(x,	0);
	set_cmt	(0XAECF,	"mov Exec_Rel_Fac,ES",	0);
	create_insn	(x=0XAECF);
	op_dec		(x,	0);
	set_cmt	(0XAED6,	"error_not_enough_memory",	0);
	create_insn	(0XAED6);
	set_name	(0XAED6,	"Exec_No_Mem");
	set_cmt	(0XAEDA,	"error_bad_format",	0);
	create_insn	(0XAEDA);
	set_name	(0XAEDA,	"Exec_Bad_File");
	set_cmt	(0XAEDC,	"mov BX,Exec_FH",	0);
	set_name	(0XAEDC,	"Exec_Bomb");
	set_cmt	(0XAEE2,	"call LCritMEM",	0);
	set_cmt	(0XAEEF,	"save current alloc method in ax",	0);
	create_insn	(x=0XAEEF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XAEEF,	"Exec_Chk_Mem");
	create_insn	(x=0XAEF3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAEF8,	"restore original allocmethod",	0);
	create_insn	(x=0XAEF8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAEFD,	"HIGH_ONLY",	0);
	create_insn	(x=0XAEFD);
	op_hex		(x,	1);
	set_cmt	(0XAF00,	"no space in UMBs. Quit",	0);
	set_cmt	(0XAF02,	"HIGH_ONLY",	0);
	create_insn	(x=0XAF02);
	op_hex		(x,	1);
	set_cmt	(0XAF04,	"no memory",	0);
	create_insn	(x=0XAF06);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAF0A,	"Try again",	0);
	create_insn	(0XAF0C);
	set_name	(0XAF0C,	"Exec_Allocate");
	set_cmt	(0XAF0E,	"mov Exec_NoStack,bl ; 0",	0);
	create_insn	(x=0XAF0E);
	op_dec		(x,	0);
	set_cmt	(0XAF11,	"is there a stack seg ?",	0);
	create_insn	(x=0XAF11);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAF15,	"yes, continue normal processing",	0);
	set_cmt	(0XAF17,	"is there a stack ptr ?",	0);
	create_insn	(x=0XAF17);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAF1B,	"yes, continue normal processing",	0);
	set_cmt	(0XAF1D,	"inc Exec_NoStack",	0);
	create_insn	(x=0XAF1D);
	op_dec		(x,	0);
	set_cmt	(0XAF20,	"1000h-10h ; Q: is this >= 64K-256 bytes",	0);
	set_cmt	(0XAF23,	"Y: don't set Exec_SP",	0);
	set_cmt	(0XAF25,	"add 10h paras to mem requirement",	0);
	set_cmt	(0XAF28,	"HIGH_FIRST\nQ: is the alloc strat high_first",	0);
	create_insn	(x=0XAF28);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0XAF28,	"ea1");
	set_cmt	(0XAF2D,	"N: normal allocate\nY: set high_only bit",	0);
	set_cmt	(0XAF2F,	"HIGH_ONLY",	0);
	create_insn	(x=0XAF2F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XAF34,	"save ax for possible 2nd\nattempt at allocating memory",	0);
	create_insn	(x=0XAF34);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XAF34,	"Exec_Norm_Alloc");
	set_cmt	(0XAF37,	"see how much room in arena",	0);
	set_cmt	(0XAF3B,	"should have carry set and BX has max",	0);
	create_insn	(x=0XAF3F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAF42,	"room for header",	0);
	set_cmt	(0XAF45,	"enough room for a header",	0);
	set_cmt	(0XAF4A,	"is there enough for bare image?",	0);
	set_cmt	(0XAF4E,	"test Exec_Load_High,-1",	0);
	create_insn	(x=0XAF4E);
	op_hex		(x,	1);
	set_cmt	(0XAF52,	"load high, use max",	0);
	set_cmt	(0XAF54,	"go for min allocation",	0);
	create_insn	(x=0XAF54);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAF5A,	"enough space?",	0);
	set_cmt	(0XAF5C,	"nope...",	0);
	create_insn	(x=0XAF5E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAF62,	"go for the MAX",	0);
	create_insn	(x=0XAF62);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XAF6C,	"Exec_BX_Max");
	set_name	(0XAF6E,	"Exec_Got_Block");
	set_cmt	(0XAF71,	"mov Exec_Size,BX",	0);
	set_cmt	(0XAF74,	"get the space",	0);
	create_insn	(x=0XAF7D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XAF7D,	"ea0");
	set_cmt	(0XAF81,	"restore allocmethod",	0);
	create_insn	(x=0XAF81);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAF85,	"cmp Exec_NoStack,0",	0);
	create_insn	(x=0XAF85);
	op_dec		(x,	0);
	set_cmt	(0XAF8B,	"Q: >= 64K memory block",	0);
	set_cmt	(0XAF8F,	"Y: Exec_SP = 0",	0);
	set_cmt	(0XAF93,	"get byte offset",	0);
	set_cmt	(0XAF95,	"take care of PSP",	0);
	set_cmt	(0XAF99,	"Exec_SP = top of block",	0);
	create_insn	(x=0XAF99);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XAF9D,	"mov Exec_Load_Block,AX",	0);
	create_insn	(x=0XAF9D);
	op_dec		(x,	0);
	set_name	(0XAF9D,	"ea2");
	set_cmt	(0XAFA3,	"test Exec_Load_High,-1",	0);
	create_insn	(x=0XAFA3);
	op_hex		(x,	1);
	set_cmt	(0XAFA7,	"use ax for load info",	0);
	set_cmt	(0XAFA9,	"add AX,Exec_Size ; go to end",	0);
	create_insn	(x=0XAFA9);
	op_dec		(x,	1);
	set_cmt	(0XAFAC,	"sub AX,Exec_Res_Len_Para\ndrop off header",	0);
	create_insn	(x=0XAFAC);
	op_dec		(x,	1);
	set_cmt	(0XAFAF,	"drop off pdb",	0);
	set_cmt	(0XAFB2,	"mov Exec_Rel_Fac,AX ; new segment",	0);
	create_insn	(x=0XAFB2);
	op_dec		(x,	0);
	set_name	(0XAFB2,	"Exec_Use_AX");
	set_cmt	(0XAFB5,	"mov Exec_DMA,AX ; beginning of dma",	0);
	create_insn	(x=0XAFB5);
	op_dec		(x,	0);
	set_cmt	(0XAFB8,	"mov DX,Exec_DMA",	0);
	create_insn	(x=0XAFB8);
	op_dec		(x,	1);
	set_name	(0XAFB8,	"Exec_Find_Res");
	set_cmt	(0XAFBB,	"mov Exec_DMA_Save,DX",	0);
	create_insn	(x=0XAFBB);
	op_dec		(x,	0);
	create_insn	(x=0XAFBE);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XAFC5,	"low word of location",	0);
	create_insn	(x=0XAFC8);
	op_dec		(x,	1);
	set_cmt	(0XAFCA,	"high word of location",	0);
	set_cmt	(0XAFCC,	"CX <- high",	0);
	set_cmt	(0XAFCE,	"mov BX,Exec_FH",	0);
	set_cmt	(0XAFD4,	"Seek to resident",	0);
	set_cmt	(0XAFD8,	"Read resident into memory",	0);
	set_cmt	(0XAFDD,	"mov BX,Exec_Res_Len_Para",	0);
	create_insn	(x=0XAFDD);
	op_dec		(x,	1);
	set_name	(0XAFDD,	"Exec_Big_Read");
	set_cmt	(0XAFE0,	"Too many bytes to read?",	0);
	set_cmt	(0XAFE6,	"Max in one chunk FE00 bytes",	0);
	set_cmt	(0XAFE9,	"sub Exec_Res_Len_Para,BX\nWe read (soon) this many",	0);
	create_insn	(x=0XAFE9);
	op_dec		(x,	0);
	set_name	(0XAFE9,	"Exec_Read_OK");
	set_cmt	(0XAFEF,	"Get count in bytes from paras",	0);
	set_cmt	(0XAFF1,	"Count in correct register",	0);
	set_cmt	(0XAFF4,	"mov DS,Exec_DMA ; Set up read buffer",	0);
	create_insn	(x=0XAFF4);
	op_dec		(x,	1);
	set_cmt	(0XAFFD,	"Get old count to verify",	0);
	set_cmt	(0XB001,	"Did we read enough?",	0);
	set_cmt	(0XB003,	"Get paragraph count back",	0);
	set_cmt	(0XB004,	"and do reloc if no more to read",	0);
	create_insn	(x=0XB008);
	op_dec		(x,	1);
	set_cmt	(0XB00C,	"If we are off by 512 bytes or more\nthen the header lied and we have an error",	0);
	set_cmt	(0XB00E,	"add Exec_DMA,BX ; Bump dma address",	0);
	create_insn	(x=0XB00E);
	op_dec		(x,	0);
	set_name	(0XB00E,	"ExecCheckEnd");
	set_cmt	(0XB011,	"test Exec_Res_Len_Para,-1",	0);
	create_insn	(x=0XB011);
	op_dec		(x,	0);
	op_hex		(x,	1);
	set_cmt	(0XB018,	"\nmov CX,Exec_Rel_Fac",	0);
	create_insn	(x=0XB018);
	op_dec		(x,	1);
	set_name	(0XB018,	"exec_do_reloc");
	set_cmt	(0XB01B,	"get initial SS",	0);
	create_insn	(x=0XB01B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB01E,	"and relocate him",	0);
	create_insn	(x=0XB020);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB023);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XB026);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB029);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XB02D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB032,	"relocated...",	0);
	create_insn	(x=0XB034);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB039);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB03D,	"mov BX,Exec_FH",	0);
	set_name	(0XB049,	"Exec_Bad_FileJ");
	set_cmt	(0XB04C,	"Number of entries left",	0);
	create_insn	(x=0XB04C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XB04C,	"exec_get_entries");
	set_name	(0XB050,	"exec_read_reloc");
	create_insn	(x=0XB051);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB054,	"((Exec_Internal_Buffer_Size)/4)*4\n(397>>2)<<2",	0);
	create_insn	(x=0XB054);
	op_dec		(x,	1);
	set_cmt	(0XB05F,	"(Exec_Internal_Buffer_Size)/4\n(397>>2)",	0);
	create_insn	(x=0XB05F);
	op_dec		(x,	1);
	set_cmt	(0XB062,	"mov DI,Exec_Internal_Buffer",	0);
	create_insn	(x=0XB062);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB065,	"mov SI,Exec_Rel_Fac\nRelocate a single address",	0);
	create_insn	(x=0XB065);
	op_dec		(x,	1);
	set_cmt	(0XB068,	"Any more entries?",	0);
	set_name	(0XB068,	"exec_reloc_one");
	set_cmt	(0XB06A,	"no",	0);
	set_cmt	(0XB06C,	"Get ra/sa of entry",	0);
	set_cmt	(0XB06F,	"Relocate address of item",	0);
	set_cmt	(0XB071,	"add AX,Exec_DMA_Save",	0);
	create_insn	(x=0XB071);
	op_dec		(x,	1);
	set_cmt	(0XB07C,	"End of internal buffer?",	0);
	set_cmt	(0XB080,	"Read in the next\npiece of the relocation table",	0);
	set_cmt	(0XB082,	"determine if this is a buggy exe packed file\nand if so patch in the right code",	0);
	create_insn	(0XB082);
	set_name	(0XB082,	"Exec_Set_PDBJ");
	set_cmt	(0XB085,	"mov es,Exec_DMA_Save ; load segment",	0);
	create_insn	(x=0XB085);
	op_dec		(x,	1);
	create_insn	(x=0XB088);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XB08C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XB091);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB096);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XB0A1);
	set_name	(0XB0A1,	"Exec_No_Memj");
	set_cmt	(0XB0A4,	"test Exec_Func,exec_func_overlay",	0);
	create_insn	(x=0XB0A4);
	op_hex		(x,	1);
	set_name	(0XB0A4,	"Exec_Com_File");
	set_cmt	(0XB0AA,	"lds SI,Exec_Blk ; get arg block",	0);
	set_cmt	(0XB0AD,	"get load address",	0);
	set_cmt	(0XB0AE,	"mov Exec_DMA,AX",	0);
	create_insn	(x=0XB0AE);
	op_dec		(x,	0);
	set_cmt	(0XB0B4,	"read it all!",	0);
	set_cmt	(0XB0B6,	"save current alloc method in ax",	0);
	create_insn	(x=0XB0B6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XB0B6,	"Exec_Chk_Com_Mem");
	create_insn	(x=0XB0BA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB0BF,	"restore original allocmethod",	0);
	create_insn	(x=0XB0BF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB0C4,	"HIGH_ONLY\nQ: was the HIGH_ONLY bit already set",	0);
	create_insn	(x=0XB0C4);
	op_hex		(x,	1);
	set_cmt	(0XB0C7,	"Y: no space in UMBs. Quit\nN: continue",	0);
	set_cmt	(0XB0C9,	"HIGH_ONLY\nQ: did we set the HIGH_ONLY bit",	0);
	create_insn	(x=0XB0C9);
	op_hex		(x,	1);
	set_cmt	(0XB0CB,	"N: no memory",	0);
	set_cmt	(0XB0CD,	"mov ax,Exec_Load_Block\nax = block we just allocated",	0);
	create_insn	(x=0XB0CD);
	op_dec		(x,	1);
	set_cmt	(0XB0D0,	"bx => free arena",	0);
	set_cmt	(0XB0D2,	"free this block",	0);
	set_cmt	(0XB0D7,	"HIGH_FIRST\nQ: is the alloc strat high_first",	0);
	create_insn	(x=0XB0D7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0XB0D7,	"Exec_Alloc_Com_File");
	set_cmt	(0XB0DD,	"N: normal allocate\nY: set high_only bit",	0);
	set_cmt	(0XB0DF,	"HIGH_ONLY",	0);
	create_insn	(x=0XB0DF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0XB0E5,	"Exec_Norm_Com_Alloc");
	set_cmt	(0XB0E8,	"largest piece available as error",	0);
	set_cmt	(0XB0EF,	"mov Exec_Size,BX\nsave size of allocation block",	0);
	create_insn	(x=0XB0EF);
	op_dec		(x,	0);
	set_cmt	(0XB0F3,	"largest piece available",	0);
	set_cmt	(0XB0F6,	"get size of block...",	0);
	set_cmt	(0XB0F7,	"mov Exec_Load_Block,AX",	0);
	create_insn	(x=0XB0F7);
	op_dec		(x,	0);
	set_cmt	(0XB0FA,	"increment for header",	0);
	set_cmt	(0XB0FD,	"mov Exec_DMA,AX",	0);
	create_insn	(x=0XB0FD);
	op_dec		(x,	0);
	set_cmt	(0XB100,	"presume 64K read...",	0);
	set_cmt	(0XB102,	"64k or more in block?",	0);
	set_cmt	(0XB106,	"yes, read only 64k",	0);
	set_cmt	(0XB108,	"convert size to bytes",	0);
	set_cmt	(0XB10E,	"enough memory for PSP and stack?",	0);
	set_cmt	(0XB111,	"jump if not",	0);
	set_cmt	(0XB113,	"size of the block is < 64K\nreserve 256 bytes for stack",	0);
	set_cmt	(0XB116,	"remember size of psp",	0);
	set_name	(0XB116,	"Exec_Read_Com");
	set_cmt	(0XB119,	"save number to read",	0);
	set_name	(0XB119,	"Exec_Read_Block");
	set_cmt	(0XB11A,	"mov BX,Exec_FH ; of com file",	0);
	set_cmt	(0XB11D,	"but seek to 0:0",	0);
	set_cmt	(0XB11F,	"seek relative to beginning",	0);
	set_cmt	(0XB122,	"back to beginning of file",	0);
	set_cmt	(0XB125,	"number to read",	0);
	set_cmt	(0XB126,	"mov DS,Exec_DMA",	0);
	create_insn	(x=0XB126);
	op_dec		(x,	1);
	set_cmt	(0XB12F,	"get number of bytes to read",	0);
	set_cmt	(0XB135,	"did we read them all?",	0);
	create_insn	(0XB135);
	set_name	(0XB135,	"OkRead");
	set_cmt	(0XB137,	"no",	0);
	create_insn	(x=0XB13C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XB13C,	"OkRead2");
	set_cmt	(0XB141,	"restore alloc method",	0);
	create_insn	(x=0XB141);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB146,	"test Exec_Func,exec_func_overlay",	0);
	create_insn	(x=0XB146);
	op_hex		(x,	1);
	set_cmt	(0XB14A,	"no starto, chumo!",	0);
	set_cmt	(0XB14C,	"mov AX,Exec_DMA",	0);
	create_insn	(x=0XB14C);
	op_dec		(x,	1);
	create_insn	(x=0XB152);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB156,	"initial IP is 100h",	0);
	create_insn	(x=0XB156);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB15D,	"SI is AT MOST FF00h. \nAdd FE to account for PSP\nword of 0 on stack.",	0);
	set_cmt	(0XB161,	"Q: was there >= 64K available",	0);
	set_cmt	(0XB164,	"Y: stack is fine",	0);
	set_cmt	(0XB166,	"N: add the xtra 100h for stack",	0);
	set_cmt	(0XB16A,	"max value for read is also SP!",	0);
	create_insn	(x=0XB16A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB16A,	"Exec_St_Ok");
	create_insn	(x=0XB16F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB175,	"0 for return",	0);
	set_cmt	(0XB179,	"We now determine if this is a Copy Protected App.\nIf so the A20OFF_COUNT is set to 6.\nNote that ChkCopyProt will point to a ret if\nDOS is loaded low. Also DS contains the load segment.",	0);
	create_insn	(x=0XB179);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB17E,	"mov BX,Exec_FH ; we are finished with the file.",	0);
	set_name	(0XB17E,	"Exec_Set_PDB");
	set_cmt	(0XB185,	"release the jfn",	0);
	set_cmt	(0XB18C,	"test Exec_Func,exec_func_overlay",	0);
	create_insn	(x=0XB18C);
	op_hex		(x,	1);
	set_cmt	(0XB198,	"was Sysinit processing done?",	0);
	create_insn	(x=0XB198);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB19E,	"yes, no special handling",	0);
	set_cmt	(0XB1A2,	"get ptr to BIOS data block",	0);
	create_insn	(x=0XB1A2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB1A7,	"in Sysinit?",	0);
	set_cmt	(0XB1AB,	"no, Sysinit is finished",	0);
	set_cmt	(0XB1AD,	"es = current PSP (Sysinit PSP)",	0);
	create_insn	(x=0XB1AD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XB1B2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB1B7,	"[es:PDB.Version] ; store lie version in Sysinit PSP",	0);
	set_cmt	(0XB1BE,	"Sysinit done,special handling off",	0);
	create_insn	(x=0XB1BE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB1BE,	"sysinit_done");
	set_name	(0XB1C4,	"setver_done");
	set_name	(0XB1C6,	"norm_ovl");
	set_cmt	(0XB1C9,	"overlay load -> done",	0);
	set_cmt	(0XB1CC,	"mov DX,Exec_Load_Block",	0);
	create_insn	(x=0XB1CC);
	op_dec		(x,	1);
	set_name	(0XB1CC,	"Exec_Build_Header");
	set_cmt	(0XB1CF,	"ARENA.OWNER ; pointer to owner field",	0);
	set_cmt	(0XB1D2,	"mov AX,Exec_Environ ; get environ pointer",	0);
	create_insn	(x=0XB1D2);
	op_dec		(x,	1);
	set_cmt	(0XB1D7,	"no environment",	0);
	set_cmt	(0XB1D9,	"point to header",	0);
	set_cmt	(0XB1DC,	"assign ownership",	0);
	set_cmt	(0XB1DE,	"mov ax,Exec_Load_Block\nget load block pointer",	0);
	create_insn	(x=0XB1DE);
	op_dec		(x,	1);
	set_name	(0XB1DE,	"No_Owner");
	set_cmt	(0XB1E2,	"point to header",	0);
	set_cmt	(0XB1E4,	"assign ownership",	0);
	set_cmt	(0XB1E8,	"ARENA.NAME ; ES:DI points to destination",	0);
	set_cmt	(0XB1EB,	"parse execname\nds:si->name, cx=name length",	0);
	set_cmt	(0XB1EE,	"save for fake version",	0);
	set_cmt	(0XB1EF,	"save for fake version",	0);
	set_cmt	(0XB1F0,	"get char",	0);
	set_name	(0XB1F0,	"MoveName");
	set_cmt	(0XB1F1,	"is '.', may be name.exe",	0);
	set_cmt	(0XB1F3,	"no, move to header",	0);
	set_cmt	(0XB1F5,	"move char",	0);
	set_cmt	(0XB1F6,	"ARENAHEADERSIZE ; end of mem arena block?",	0);
	create_insn	(x=0XB1F6);
	op_dec		(x,	1);
	set_cmt	(0XB1F9,	"jump if so",	0);
	set_cmt	(0XB1FB,	"continue",	0);
	set_cmt	(0XB1FD,	"make ASCIIZ",	0);
	set_name	(0XB1FD,	"Mem_Done");
	set_cmt	(0XB1FF,	"ARENAHEADERSIZE ; if not all filled",	0);
	create_insn	(x=0XB1FF);
	op_dec		(x,	1);
	set_cmt	(0XB205,	"ds:si -> file name",	0);
	set_name	(0XB205,	"Fill8");
	set_cmt	(0XB20B,	"mov SI,Exec_Size",	0);
	create_insn	(x=0XB20B);
	op_dec		(x,	1);
	set_cmt	(0XB210,	"ES is now PDB",	0);
	set_cmt	(0XB214,	"push Exec_Environ",	0);
	create_insn	(x=0XB214);
	op_dec		(x,	0);
	set_cmt	(0XB217,	"pop word [ES:PDB.ENVIRON]",	0);
	set_cmt	(0XB21C,	"Set the DOS version number to ..",	0);
	create_insn	(x=0XB21C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB221,	"pop word [ES:PDB.Version]\n.. to be used for this application",	0);
	set_cmt	(0XB226,	"lds SI,Exec_Blk ; get the block",	0);
	set_cmt	(0XB22B,	"lds SI,[SI+EXEC0.5C_FCB] ; get the 5c fcb",	0);
	set_cmt	(0XB22E,	"copy drive, name and ext",	0);
	create_insn	(x=0XB22E);
	op_dec		(x,	1);
	create_insn	(x=0XB232);
	op_hex		(x,	1);
	set_cmt	(0XB237,	"DI = 5Ch + 12 = 5Ch + 0Ch = 68h",	0);
	set_cmt	(0XB239,	"zero extent, etc for CPM",	0);
	set_cmt	(0XB23C,	"get block",	0);
	set_cmt	(0XB23F,	"save (again)",	0);
	set_cmt	(0XB241,	"lds SI,[SI+EXEC0.6C_FCB] ; get 6C FCB",	0);
	set_cmt	(0XB244,	"do same as above",	0);
	set_cmt	(0XB24A,	"get block (last time)",	0);
	set_cmt	(0XB24C,	"lds SI,[SI+EXEC0.COM_LINE] ; command line",	0);
	create_insn	(x=0XB24F);
	op_hex		(x,	1);
	set_cmt	(0XB254,	"Wham!",	0);
	set_cmt	(0XB256,	"get 0FFh in CL",	0);
	set_name	(0XB263,	"Exec_BL");
	set_cmt	(0XB26E,	"get his return address",	0);
	set_name	(0XB26E,	"Exec_Set_Return");
	set_cmt	(0XB274,	"suck out the CS and IP",	0);
	set_cmt	(0XB276,	"[ES:PDB.EXIT]",	0);
	set_cmt	(0XB27A,	"[ES:PDB.EXIT+2]",	0);
	set_cmt	(0XB281,	"save them where we can get them\nlater when the child exits.",	0);
	set_cmt	(0XB283,	"22h*4",	0);
	create_insn	(x=0XB283);
	set_cmt	(0XB287,	"(22h*4)+2",	0);
	create_insn	(x=0XB287);
	create_insn	(x=0XB28B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB292);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XB297);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB29C,	"test Exec_Func,exec_func_no_execute",	0);
	create_insn	(x=0XB29C);
	op_hex		(x,	1);
	set_cmt	(0XB2A2,	"get stack",	0);
	create_insn	(x=0XB2A2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB2A7,	"les DI,Exec_Blk ; and block for return",	0);
	set_cmt	(0XB2AA,	"mov [ES:DI+EXEC1.SS],DS\nreturn SS",	0);
	set_cmt	(0XB2AE,	"'push' default AX",	0);
	set_cmt	(0XB2B0,	"save default AX reg",	0);
	set_cmt	(0XB2B2,	"mov [ES:DI+EXEC1.SP],SI ; return 'SP'",	0);
	create_insn	(x=0XB2B6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB2BB,	"mov [ES:DI+EXEC1.CS],DS\ninitial entry stuff",	0);
	set_cmt	(0XB2BF,	"mov [ES:DI+EXEC1.IP],AX",	0);
	set_cmt	(0XB2C9,	"get entry point",	0);
	create_insn	(x=0XB2C9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XB2C9,	"exec_go");
	set_cmt	(0XB2CE,	"new stack",	0);
	create_insn	(x=0XB2CE);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB2D5,	"Q: is dos in HMA",	0);
	create_insn	(x=0XB2D5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB2DB,	"N: transfer control to user",	0);
	set_cmt	(0XB2DD,	"Y: control must go to low mem stub",	0);
	set_cmt	(0XB2DE,	"where we disable a20\nand Xfer control to user",	0);
	set_cmt	(0XB2E3,	"Set bit to signal int 21h\nah = 25h & ah= 49h",	0);
	create_insn	(x=0XB2E3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XB2E8,	"set the PSP for which A20 is\ngoing to be turned OFF.",	0);
	create_insn	(x=0XB2E8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB2EC,	"segment of low mem stub",	0);
	set_cmt	(0XB2EF,	"ret far into the low mem stub",	0);
	create_insn	(x=0XB2F0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB2F4,	"restore ax",	0);
	set_cmt	(0XB2F7,	"DS:SI points to entry point\nAX:DI points to initial stack\nDX has PDB pointer\nBX has initial AX value",	0);
	create_insn	(0XB2F7);
	set_name	(0XB2F7,	"Xfer_To_User");
	create_insn	(x=0XB2F8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB2FE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB304,	"set up user's stack",	0);
	set_cmt	(0XB306,	"and SP",	0);
	set_cmt	(0XB309,	"fake long call to entry",	0);
	set_cmt	(0XB30B,	"set up proper seg registers",	0);
	set_cmt	(0XB30F,	"set up proper AX",	0);
	create_insn	(0XB312);
	set_name	(0XB312,	"ExecRead");
	set_cmt	(0XB315,	"MOV bx,Exec_FH",	0);
	create_insn	(0XB321);
	set_name	(0XB321,	"Exec_Dealloc");
	set_cmt	(0XB322,	"(bx) = ARENA_OWNER_SYSTEM",	0);
	create_insn	(0XB32C);
	set_name	(0XB32C,	"Exec_Alloc");
	create_insn	(x=0XB32D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB335,	"call LCritMEM",	0);
	create_insn	(0XB33A);
	set_name	(0XB33A,	"ChangeOwners");
	set_cmt	(0XB33C,	"mov AX,Exec_Environ",	0);
	create_insn	(x=0XB33C);
	op_dec		(x,	1);
	set_cmt	(0XB342,	"mov AX,Exec_Load_Block",	0);
	create_insn	(x=0XB342);
	op_dec		(x,	1);
	set_name	(0XB34A,	"chgown_retn");
	set_cmt	(0XB34B,	"is area allocated?",	0);
	create_insn	(0XB34B);
	set_name	(0XB34B,	"ChangeOwner");
	set_cmt	(0XB34D,	"no, do nothing",	0);
	set_cmt	(0XB353,	"mov [ARENA.OWNER],BX",	0);
	set_cmt	(0XB359,	"lds SI,ExecName ; DS:SI points to name",	0);
	create_insn	(x=0XB359);
	op_dec		(x,	1);
	set_name	(0XB359,	"Scan_Execname");
	set_cmt	(0XB35C,	"CX= starting addr",	0);
	set_name	(0XB35C,	"Scan_Execname1");
	set_cmt	(0XB35E,	"get char",	0);
	set_cmt	(0XB35F,	"is ':' , may be A:name",	0);
	set_cmt	(0XB361,	"yes, save si",	0);
	set_cmt	(0XB363,	"is '\\', may be A:\\name",	0);
	set_cmt	(0XB365,	"yes, save si",	0);
	set_cmt	(0XB367,	"is end of name",	0);
	set_cmt	(0XB369,	"no, continue scanning",	0);
	set_cmt	(0XB36B,	"get name's length",	0);
	set_cmt	(0XB36D,	"cx= length, si= starting addr",	0);
	create_insn	(0XB370);
	set_name	(0XB370,	"Scan_Special_Entries");
	set_cmt	(0XB371,	"(MINOR_VERSION<<8)+MAJOR_VERSION",	0);
	create_insn	(x=0XB371);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB378,	"ES:DI --> Table in SETVER.SYS",	0);
	create_insn	(x=0XB378);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB381,	"If ZR then no table",	0);
	set_cmt	(0XB383,	"end of list",	0);
	set_cmt	(0XB388,	"yes",	0);
	set_cmt	(0XB38A,	"save di",	0);
	create_insn	(x=0XB38A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB38F,	"same length ?",	0);
	set_cmt	(0XB391,	"no",	0);
	set_cmt	(0XB393,	"es:di -> special name",	0);
	set_cmt	(0XB394,	"save length and name addr",	0);
	set_cmt	(0XB396,	"save len",	0);
	set_cmt	(0XB3A0,	"get special version",	0);
	set_cmt	(0XB3A3,	"save it",	0);
	create_insn	(x=0XB3A3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB3A7,	"take len off the stack",	0);
	set_cmt	(0XB3AB,	"get len from stack",	0);
	create_insn	(0XB3AB);
	set_cmt	(0XB3AC,	"restore si,cx",	0);
	set_cmt	(0XB3AE,	"restore old di",	0);
	create_insn	(x=0XB3AE);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB3B3,	"position to next entry",	0);
	set_cmt	(0XB3B7,	"DI -> next entry length",	0);
	set_cmt	(0XB3BC,	"Terminate and stay resident handler",	0);
	create_insn	(0XB3BC);
	set_name	(0XB3BC,	"$KEEP_PROCESS");
	set_cmt	(0XB3BD,	"EXIT_KEEP_PROCESS",	0);
	create_insn	(x=0XB3BD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB3C3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB3C8,	"keep enough space around for system info",	0);
	set_name	(0XB3D0,	"Keep_Shrink");
	set_cmt	(0XB3D9,	"failed on modification",	0);
	set_cmt	(0XB3DF,	"[PDB.BLOCK_LEN]",	0);
	set_name	(0XB3E2,	"Keep_Done");
	set_cmt	(0XB3E3,	"let abort take care of the rest",	0);
	set_cmt	(0XB3E5,	"(KEEP_PROCESS<<8)+0\nLower part is return code",	0);
	create_insn	(0XB3E5);
	set_name	(0XB3E5,	"stay_resident");
	create_insn	(x=0XB3E8);
	op_dec		(x,	1);
	create_insn	(x=0XB3EB);
	op_hex		(x,	1);
	set_cmt	(0XB3F4,	"return to parent process",	0);
	create_insn	(0XB3F4);
	set_name	(0XB3F4,	"$EXIT");
	create_insn	(x=0XB3F6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB3FD,	"EXIT_TERMINATE",	0);
	create_insn	(x=0XB3FD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB405,	"EXIT_CTRL_C",	0);
	create_insn	(x=0XB405);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB40B,	"exit_inner");
	create_insn	(x=0XB40E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB413,	"[SI+user_env.user_CS]",	0);
	set_cmt	(0XB418,	"Terminate a process",	0);
	create_insn	(0XB418);
	set_name	(0XB418,	"$ABORT");
	set_cmt	(0XB41A,	"EXIT_ABORT",	0);
	create_insn	(x=0XB41A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB420);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XB425);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB42C,	"[SI+user_env.user_CS]\nset up old interrupts",	0);
	set_cmt	(0XB433,	"SAVEXIT",	0);
	create_insn	(x=0XB433);
	op_hex		(x,	1);
	set_cmt	(0XB436,	"addr_int_terminate",	0);
	create_insn	(x=0XB436);
	op_hex		(x,	1);
	create_insn	(0XB442);
	set_name	(0XB442,	"RetExePatch");
	set_cmt	(0XB443,	"LINKSTATE  ; Q: are umb's linked",	0);
	create_insn	(x=0XB443);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0XB443,	"test_umb_flag");
	set_cmt	(0XB449,	"ZF=1 -> N: scan from arena_head\nZF=0 -> Y: start_arena = umb_head",	0);
	create_insn	(x=0XB44A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XB44A,	"arena_free_process");
	set_cmt	(0XB44E,	"ARENA.SIGNATURE",	0);
	set_cmt	(0XB454,	"AFP_RETN",	0);
	set_cmt	(0XB458,	"[ARENA.OWNER] ; is block owned by pid?",	0);
	create_insn	(x=0XB458);
	set_cmt	(0XB45C,	"no, skip to next",	0);
	set_cmt	(0XB45E,	"[ARENA.OWNER] ; yes... free him",	0);
	create_insn	(x=0XB45E);
	set_cmt	(0XB462,	"arena_signature_end\nend of road, Jack?",	0);
	set_cmt	(0XB465,	"never come back no more",	0);
	set_cmt	(0XB467,	"next item in ES/AX carry set if trash",	0);
	create_insn	(x=0XB46C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB470,	"Q: is umb_head initialized",	0);
	set_cmt	(0XB473,	"N: we're done",	0);
	set_cmt	(0XB477,	"Q: is last arena above umb_head",	0);
	set_cmt	(0XB47B,	"Y: we've scanned umbs also. done.",	0);
	set_cmt	(0XB47C,	"AX <- current block",	0);
	create_insn	(0XB47C);
	set_name	(0XB47C,	"arena_next");
	set_cmt	(0XB47E,	"[ARENA.SIZE] ; + current block length",	0);
	create_insn	(x=0XB47E);
	set_cmt	(0XB482,	"remember that header!",	0);
	create_insn	(0XB483);
	set_name	(0XB483,	"check_signature");
	set_cmt	(0XB485,	"arena_signature_normal",	0);
	set_cmt	(0XB48B,	"arena_signature_end",	0);
	set_name	(0XB492,	"check_signature_ok");
	set_cmt	(0XB493,	"arena_signature_end",	0);
	create_insn	(0XB493);
	set_name	(0XB493,	"Coalesce");
	set_cmt	(0XB49B,	"IF next block isnt free THEN return",	0);
	set_cmt	(0XB49D,	"[ES:ARENA.OWNER]",	0);
	set_cmt	(0XB4A4,	"[ES:ARENA.SIZE] ; next block size",	0);
	set_cmt	(0XB4A9,	"+ 1 (for header size)",	0);
	set_cmt	(0XB4AA,	"[ARENA.SIZE]",	0);
	create_insn	(x=0XB4AA);
	set_cmt	(0XB4AE,	"move up signature",	0);
	set_cmt	(0XB4B3,	"try again",	0);
	set_cmt	(0XB4B5,	"call ECritMEM",	0);
	create_insn	(0XB4B5);
	set_name	(0XB4B5,	"$ALLOC");
	create_insn	(x=0XB4B8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB4BC,	"HIGH_FIRST+HIGH_ONLY",	0);
	create_insn	(x=0XB4BC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XB4C2,	"assume LOW_FIRST",	0);
	create_insn	(x=0XB4C2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB4CD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB4D1,	"start_arena = umb_head",	0);
	create_insn	(x=0XB4D1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB4D5,	"0",	0);
	set_cmt	(0XB4D9,	"0 ; init the options",	0);
	create_insn	(x=0XB4D9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB4DD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB4E1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB4E5,	"alloc_max = 0",	0);
	set_cmt	(0XB4E6,	"beginning of arena",	0);
	create_insn	(x=0XB4E6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XB4E6,	"start_scan");
	set_cmt	(0XB4F1,	"[ARENA.OWNER]",	0);
	set_cmt	(0XB4F5,	"IF current block is free THEN examine",	0);
	set_cmt	(0XB4FC,	"HIGH_FIRST\nQ: is alloc strategy high_first",	0);
	create_insn	(x=0XB4FC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XB502,	"N: see if we reached last arena",	0);
	create_insn	(x=0XB504);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB508,	" Q: did we start scan from arena_head",	0);
	create_insn	(x=0XB508);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB50D,	"N: see if we reached last arena",	0);
	set_cmt	(0XB50F,	"ax = current block",	0);
	set_cmt	(0XB511,	"Q: check against umb_head",	0);
	create_insn	(x=0XB511);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB518,	"arena_signature_end\nIF current block is last THEN",	0);
	create_insn	(0XB518);
	set_cmt	(0XB51B,	"GOTO end",	0);
	set_cmt	(0XB51D,	"AX, ES <- next block, Carry set if error",	0);
	set_cmt	(0XB520,	"IF no error THEN GOTO scan",	0);
	set_cmt	(0XB523,	"call LCritMEM",	0);
	set_name	(0XB523,	"alloc_trashed");
	set_cmt	(0XB526,	"error_arena_trashed",	0);
	set_name	(0XB526,	"alloc_trashed2");
	create_insn	(x=0XB52B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB536);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB53A,	"Q: started scanning from arena_head",	0);
	create_insn	(x=0XB53A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB53F,	"Y: not enough memory",	0);
	set_cmt	(0XB541,	"HIGH_ONLY\nQ: is the alloc strat HIGH_ONLY",	0);
	create_insn	(x=0XB541);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XB547,	"Y: return size of largest UMB",	0);
	set_cmt	(0XB549,	"N: start scanning from arena_head",	0);
	create_insn	(x=0XB549);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XB54F);
	set_name	(0XB54F,	"alloc_fail");
	set_cmt	(0XB553,	"[SI+user_env.user_BX]",	0);
	set_cmt	(0XB556,	"call LCritMEM",	0);
	set_cmt	(0XB559,	"error_not_enough_memory",	0);
	set_cmt	(0XB55D,	"add following free block to current",	0);
	create_insn	(0XB55D);
	set_cmt	(0XB562,	"[ARENA.SIZE]",	0);
	set_cmt	(0XB567,	"check for max found size",	0);
	create_insn	(x=0XB572);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB57A,	"save first one found",	0);
	create_insn	(x=0XB57A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB57F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB585,	"initial best",	0);
	create_insn	(x=0XB588);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB58D,	"[ES:ARENA.SIZE]\nis size of best larger than found?",	0);
	set_cmt	(0XB595,	"assign best",	0);
	create_insn	(x=0XB595);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB59A,	"assign last",	0);
	create_insn	(x=0XB59A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB5A2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB5A7,	"[ARENA.SIZE]",	0);
	set_cmt	(0XB5AF,	"sizes are equal, no split",	0);
	set_cmt	(0XB5B1,	"point to next block",	0);
	set_cmt	(0XB5B3,	"no decrement!",	0);
	set_cmt	(0XB5B6,	"bx has size of lower block",	0);
	set_cmt	(0XB5B8,	"cx has upper (requested) size",	0);
	create_insn	(x=0XB5BA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XB5BA,	"alloc_do_split");
	set_cmt	(0XB5BF,	"mask off bit 7",	0);
	create_insn	(x=0XB5BF);
	op_hex		(x,	1);
	set_cmt	(0XB5C2,	"BEST_FIT",	0);
	create_insn	(x=0XB5C7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XB5CE);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB5D3,	"[ARENA.SIZE]",	0);
	set_name	(0XB5D3,	"alloc_get_size");
	set_cmt	(0XB5D9,	"get room left over",	0);
	set_cmt	(0XB5DD,	"IF BX = size THEN (don't split)",	0);
	set_cmt	(0XB5E1,	"remember the header",	0);
	set_cmt	(0XB5E2,	"ES <- DS + BX (new header location)",	0);
	set_cmt	(0XB5E4,	"CX <- size of split block",	0);
	set_cmt	(0XB5E5,	"[ARENA.SIZE]",	0);
	set_name	(0XB5E5,	"alloc_set_sizes");
	set_cmt	(0XB5E9,	"arena_signature_normal",	0);
	set_cmt	(0XB5EB,	"split size",	0);
	set_cmt	(0XB5F0,	"current signature",	0);
	set_cmt	(0XB5F2,	"[ES:ARENA.OWNER]",	0);
	set_cmt	(0XB5F7,	"new block sig <- old block sig",	0);
	set_name	(0XB5FA,	"alloc_set_owner");
	create_insn	(x=0XB5FC);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB600,	"[ARENA.OWNER]",	0);
	set_cmt	(0XB607,	"call LCritMEM",	0);
	set_name	(0XB60A,	"alloc_ok");
	set_cmt	(0XB60D,	"call ECritMEM",	0);
	create_insn	(0XB60D);
	set_name	(0XB60D,	"$SETBLOCK");
	set_cmt	(0XB610,	"ARENA.SIGNATURE",	0);
	set_name	(0XB61B,	"setblock_bad");
	create_insn	(0XB61E);
	set_name	(0XB61E,	"setblock_grab");
	set_cmt	(0XB625,	"[ARENA.SIZE]",	0);
	set_cmt	(0XB631,	"call ECritMEM",	0);
	create_insn	(0XB631);
	set_name	(0XB631,	"$DEALLOC");
	set_cmt	(0XB634,	"EXECA20OFF",	0);
	create_insn	(x=0XB634);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XB63A,	"Q: was the previous call an int 21h\n exec call\nN: continue",	0);
	create_insn	(x=0XB63C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB644);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB649,	"ARENA.SIGNATURE",	0);
	set_cmt	(0XB654,	"[ES:ARENA.OWNER]",	0);
	set_cmt	(0XB659,	"call LCritMEM",	0);
	set_name	(0XB65C,	"dealloc_ok");
	create_insn	(0XB65E);
	set_cmt	(0XB661,	"error_invalid_block",	0);
	set_name	(0XB663,	"AllocOperErrj");
	set_cmt	(0XB666,	"get/set allocation mechanism",	0);
	create_insn	(0XB666);
	set_name	(0XB666,	"$ALLOCOPER");
	set_name	(0XB676,	"AllocOperError");
	create_insn	(x=0XB67D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XB67D,	"AllocGetStrat");
	set_name	(0XB683,	"AllocOperOk");
	create_insn	(0XB685);
	set_name	(0XB685,	"AllocSetStrat");
	set_cmt	(0XB686,	"STRAT_MASK ; mask off bit 6 & 7",	0);
	create_insn	(x=0XB686);
	op_hex		(x,	1);
	set_cmt	(0XB68C,	"BX must be 0-2",	0);
	create_insn	(x=0XB68F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB696,	"return link state in al",	0);
	create_insn	(x=0XB696);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XB696,	"AllocGetLink");
	set_cmt	(0XB69A,	"LINKSTATE",	0);
	create_insn	(x=0XB69A);
	op_hex		(x,	1);
	create_insn	(x=0XB69E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XB69E,	"AllocSetLink");
	set_cmt	(0XB6A3,	"Q: has umb_head been initialized",	0);
	set_cmt	(0XB6A4,	"-1 ; N: error",	0);
	set_cmt	(0XB6AF,	"test byte [ss:UMBFLAG],LINKSTATE\nQ: umbs unlinked?",	0);
	create_insn	(0XB6AF);
	set_name	(0XB6AF,	"UnlinkUmbs");
	set_cmt	(0XB6B2,	"Y: return",	0);
	set_cmt	(0XB6B4,	"get arena before umb_head in DS",	0);
	set_cmt	(0XB6B7,	"arena_signature_end",	0);
	set_cmt	(0XB6BC,	"~LINKSTATE\nindicate unlink'd state in umbflag",	0);
	create_insn	(x=0XB6BC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0XB6C2,	"unlinked");
	set_cmt	(0XB6C4,	"Q: umbs linked?",	0);
	create_insn	(0XB6C4);
	set_name	(0XB6C4,	"LinkUmbs");
	set_cmt	(0XB6C7,	"Y: return",	0);
	set_cmt	(0XB6C9,	"get arena before umb_head",	0);
	set_cmt	(0XB6CC,	"arena_signature_normal",	0);
	set_cmt	(0XB6D1,	"LINKSTATE\nindicate link'd state in umbflag",	0);
	create_insn	(x=0XB6D1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0XB6D7,	"linked");
	create_insn	(0XB6D9);
	set_name	(0XB6D9,	"GetLastArena");
	create_insn	(x=0XB6DA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB6E2,	"arena_signature_end\nQ: is this the last arena",	0);
	set_cmt	(0XB6E6,	"Y: return last arena in ES",	0);
	set_cmt	(0XB6EA,	"ax, es -> next arena",	0);
	set_cmt	(0XB6EF,	"Q: are UMBs linked",	0);
	set_cmt	(0XB6F2,	"Y: terminating condition is umb_head",	0);
	set_cmt	(0XB6F4,	"Q: is this the last arena",	0);
	set_cmt	(0XB6FA,	"Q: is this umb_head",	0);
	create_insn	(0XB6FA);
	set_cmt	(0XB6FC,	"N: get next arena",	0);
	create_insn	(0XB711);
	set_cmt	(0XB713,	"return address to _$ALLOCOPER (the caller)",	0);
	set_cmt	(0XB717,	"(error return from _$ALLOCOPER)",	0);
	create_word	(x=0XB71A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB71A,	"SERVERTAB");
	create_word	(x=0XB71C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB71C,	"SERVERLEAVE");
	set_cmt	(0XB71E,	"(SERVER_DISP_END-SERVER_DISP-1)/2 = 11",	0);
	create_byte	(x=0XB71E);
	op_dec		(x,	0);
	set_name	(0XB71E,	"SERVER_DISP");
	set_cmt	(0XB71F,	"0",	0);
	create_word	(x=0XB71F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB721,	"1",	0);
	create_word	(x=0XB721);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB723,	"2",	0);
	create_word	(x=0XB723);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB725,	"3",	0);
	create_word	(x=0XB725);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB727,	"4",	0);
	create_word	(x=0XB727);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB729,	"5",	0);
	create_word	(x=0XB729);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB72B,	"6",	0);
	create_word	(x=0XB72B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB72D,	"7",	0);
	create_word	(x=0XB72D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB72F,	"8",	0);
	create_word	(x=0XB72F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB731,	"9",	0);
	create_word	(x=0XB731);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB733,	"10\nSERVER_DISP_END",	0);
	create_word	(x=0XB733);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XB735);
	set_name	(0XB735,	"$ServerCall");
	set_cmt	(0XB73B,	"No DPL on calls 7,8,9",	0);
	set_cmt	(0XB73D,	"Point to DPL with DS:SI",	0);
	set_name	(0XB73D,	"SET_STUFF");
	set_cmt	(0XB73F,	"[SI+DPL.UID]",	0);
	create_insn	(x=0XB742);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XB74A,	"Set UID",	0);
	create_insn	(x=0XB74A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB74F,	"[SI+DPL.PID]",	0);
	set_name	(0XB74F,	"skip_win386");
	set_cmt	(0XB752,	"Set process ID",	0);
	create_insn	(x=0XB752);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB757,	"NO_SET_ID");
	set_cmt	(0XB765,	"Extended Error Locus",	0);
	set_cmt	(0XB768,	"error_invalid_function",	0);
	set_name	(0XB76A,	"servercall_error");
	create_insn	(0XB76D);
	set_name	(0XB76D,	"SERVERRETURN");
	create_insn	(0XB76E);
	set_name	(0XB76E,	"COMMIT_ALL");
	set_cmt	(0XB772,	"call ECritSFT",	0);
	set_cmt	(0XB775,	"scan SFT cache",	0);
	set_name	(0XB775,	"CommitLoop");
	set_cmt	(0XB77B,	"[ES:DI+SF_ENTRY.sf_Ref_Count]",	0);
	set_cmt	(0XB781,	"[ES:DI+SF_ENTRY.sf_Ref_Count],sf_busy",	0);
	set_cmt	(0XB787,	"[ES:DI+SF_ENTRY.sf_flags],sf_isnet",	0);
	create_insn	(x=0XB787);
	op_hex		(x,	1);
	create_insn	(x=0XB78F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB793);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB79A,	"CommitNext");
	set_cmt	(0XB79E,	"call LCritSFT",	0);
	create_insn	(0XB79E);
	set_name	(0XB79E,	"CommitDone");
	set_name	(0XB7A2,	"Commit_Ok");
	set_cmt	(0XB7A5,	"Call far [SS:JShare+(5*4)] ; 5 = MFTcloN",	0);
	create_insn	(x=0XB7A5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB7A5,	"CLOSE_NAME");
	set_name	(0XB7AA,	"CheckReturns");
	set_name	(0XB7AC,	"func_err");
	set_cmt	(0XB7AE,	"Call far [SS:JShare+(3*4)] ; 3 = MTFTclu",	0);
	create_insn	(x=0XB7AE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB7AE,	"CLOSE_UID");
	set_cmt	(0XB7B5,	"Call far [SS:JShare+(4*4)] ; 4 = MFTCloseP",	0);
	create_insn	(x=0XB7B5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB7B5,	"CLOSE_UID_PID");
	set_cmt	(0XB7BC,	"Call far [SS:JShare+(9*4)] ; 9 = MFT_get",	0);
	create_insn	(x=0XB7BC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XB7BC,	"GET_LIST");
	set_cmt	(0XB7C6,	"[SI+user_env.user_BX]",	0);
	set_cmt	(0XB7C9,	"[SI+user_env.user_DI]",	0);
	create_insn	(x=0XB7C9);
	op_dec		(x,	0);
	set_cmt	(0XB7CC,	"[SI+user_env.user_ES]",	0);
	create_insn	(x=0XB7CC);
	op_dec		(x,	0);
	set_cmt	(0XB7CF,	"[SI+user_env.user_CX]",	0);
	set_name	(0XB7CF,	"SetCXOK");
	set_name	(0XB7D2,	"Commit_Okj2");
	set_cmt	(0XB7D4,	"get rid of call to $srvcall",	0);
	create_insn	(0XB7D4);
	set_name	(0XB7D4,	"SRV_CALL");
	set_cmt	(0XB7DB,	"DS:SI point to stack\nES:DI point to DPL",	0);
	set_cmt	(0XB7DF,	"DS:SI point to DPL\nES:DI point to stack",	0);
	set_cmt	(0XB7E0,	"copy the registers from DPL",	0);
	set_cmt	(0XB7E3,	"Put in AX,BX,CX,DX,SI,DI",	0);
	set_cmt	(0XB7E6,	"Skip user_BP",	0);
	set_cmt	(0XB7E7,	"DS",	0);
	set_cmt	(0XB7E8,	"ES",	0);
	set_cmt	(0XB7E9,	"DS:SI -> DPL",	0);
	set_cmt	(0XB7EA,	"[SI+DPL.AX]",	0);
	set_cmt	(0XB7EC,	"[SI+DPL.BX]",	0);
	set_cmt	(0XB7EF,	"[SI+DPL.CX]",	0);
	set_cmt	(0XB7F2,	"[SI+DPL.DX]",	0);
	set_cmt	(0XB7F5,	"[SI+DPL.DI]",	0);
	create_insn	(x=0XB7F5);
	op_dec		(x,	1);
	set_cmt	(0XB7F8,	"[SI+DPL.ES]",	0);
	create_insn	(x=0XB7F8);
	op_dec		(x,	1);
	set_cmt	(0XB7FB,	"[SI+DPL.SI]",	0);
	set_cmt	(0XB7FE,	"[SI+DPL.DS]",	0);
	create_insn	(x=0XB7FE);
	op_dec		(x,	1);
	create_insn	(x=0XB802);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB807);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB80C,	"-1 ; set no redirect flag",	0);
	create_insn	(x=0XB80C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XB815);
	set_name	(0XB815,	"GET_DOS_DATA");
	set_cmt	(0XB817,	"offset SWAP_START",	0);
	create_insn	(x=0XB817);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB81A,	"offset SWAP_END",	0);
	create_insn	(x=0XB81A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB81D,	"offset SWAP_ALWAYS",	0);
	create_insn	(x=0XB81D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB824,	"div by 2, remainder in carry",	0);
	create_insn	(x=0XB824);
	op_hex		(x,	1);
	set_cmt	(0XB826,	"div by 2 + round up",	0);
	set_cmt	(0XB829,	"round up to 2 boundary",	0);
	set_cmt	(0XB82E,	"[SI+user_env.user_DS]",	0);
	create_insn	(x=0XB82E);
	op_dec		(x,	0);
	set_cmt	(0XB831,	"[SI+user_env.user_SI]",	0);
	set_cmt	(0XB834,	"[SI+user_env.user_DX]",	0);
	create_insn	(0XB839);
	set_name	(0XB839,	"SPOOL_OPER");
	set_cmt	(0XB83D,	"Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE\nSTACK: WORD subfunction\nReturn: CF set on error, AX = error code\nSTACK unchanged",	0);
	create_insn	(x=0XB83D);
	op_hex		(x,	0);
	set_cmt	(0XB845,	"[SI+DPL.AX]",	0);
	create_insn	(0XB845);
	set_name	(0XB845,	"_$SetExtendedError");
	create_insn	(x=0XB847);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB84B,	"[SI+DPL.DI]",	0);
	create_insn	(x=0XB84B);
	op_dec		(x,	1);
	create_insn	(x=0XB84E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB852,	"[SI+DPL.ES]",	0);
	create_insn	(x=0XB852);
	op_dec		(x,	1);
	create_insn	(x=0XB855);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB859,	"[SI+DPL.BX]",	0);
	create_insn	(x=0XB85C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB860,	"[SI+DPL.CX]",	0);
	create_insn	(x=0XB863);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB869,	"es -> dosdata",	0);
	create_insn	(0XB869);
	set_name	(0XB869,	"pJFNFromHandle");
	set_cmt	(0XB86E,	"get user process data block",	0);
	create_insn	(x=0XB86E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB873,	"[ES:PDB.JFN_Length]\nis handle greater than allocated ?",	0);
	set_cmt	(0XB878,	"yes",	0);
	set_cmt	(0XB87A,	"[ES:PDB.JFN_Pointer]\nget pointer to beginning of table",	0);
	set_cmt	(0XB87F,	"add in offset, clear 'C'",	0);
	set_cmt	(0XB882,	"error_invalid_handle",	0);
	create_insn	(0XB882);
	set_name	(0XB884,	"ReturnCarry");
	set_name	(0XB885,	"pJFNFromHandle_error");
	set_cmt	(0XB886,	"get jfn pointer",	0);
	create_insn	(0XB886);
	set_name	(0XB886,	"SFFromHandle");
	set_cmt	(0XB88B,	"-1 ; unused handle",	0);
	set_cmt	(0XB891,	"save handle",	0);
	set_cmt	(0XB892,	"get SFN",	0);
	set_cmt	(0XB895,	"ignore upper half",	0);
	set_cmt	(0XB897,	"get real sf spot",	0);
	set_cmt	(0XB89A,	"restore",	0);
	set_cmt	(0XB89C,	"error_invalid_handle",	0);
	create_insn	(0XB89C);
	set_cmt	(0XB8A0,	"es -> dosdata",	0);
	create_insn	(0XB8A0);
	set_name	(0XB8A0,	"SFFromSFN");
	set_cmt	(0XB8A5,	"(es:di) = start of SFT table",	0);
	create_insn	(x=0XB8A5);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB8AA,	"[ES:DI+SFT.SFCount]\nis handle in this table?",	0);
	set_cmt	(0XB8AE,	"yes, go grab it",	0);
	set_cmt	(0XB8B0,	"[ES:DI+SFT.SFCount]",	0);
	set_cmt	(0XB8B4,	"[ES:DI+SFT.SFLink]\nget next table segment",	0);
	set_cmt	(0XB8B7,	"-1 ; end of tables?",	0);
	set_cmt	(0XB8BA,	"no, try again",	0);
	set_cmt	(0XB8BD,	"return with error, not found",	0);
	create_insn	(0XB8BE);
	set_cmt	(0XB8BF,	"SF_ENTRY.size",	0);
	create_insn	(x=0XB8BF);
	op_dec		(x,	1);
	set_cmt	(0XB8C2,	"(ax) = offset into this SF block",	0);
	set_cmt	(0XB8C4,	"add base of SF block",	0);
	set_cmt	(0XB8C7,	"SFT.SFTable  ; offset into structure",	0);
	set_cmt	(0XB8CA,	"return with 'C' clear",	0);
	set_cmt	(0XB8CB,	"(bx) = initial JFN to try = 0",	0);
	create_insn	(0XB8CB);
	set_name	(0XB8CB,	"JFNFree");
	set_cmt	(0XB8CD,	"get the appropriate handle",	0);
	set_cmt	(0XB8D0,	"no more handles",	0);
	set_cmt	(0XB8D2,	"-1 ; free?",	0);
	set_cmt	(0XB8D6,	"yes, carry is clear",	0);
	set_cmt	(0XB8D8,	"no, next handle",	0);
	set_cmt	(0XB8D9,	"and try again",	0);
	set_cmt	(0XB8DB,	"error_too_many_open_files",	0);
	create_insn	(0XB8DB);
	set_name	(0XB8DB,	"jfnf5");
	set_cmt	(0XB8DE,	"Allocate a Free SFN/SFT",	0);
	create_insn	(0XB8DE);
	set_name	(0XB8DE,	"SFNFree");
	set_cmt	(0XB8DF,	"0",	0);
	set_cmt	(0XB8E1,	"(bx) = SFN to consider",	0);
	set_cmt	(0XB8E2,	"get the potential handle",	0);
	set_cmt	(0XB8E6,	"no more free SFNs",	0);
	set_cmt	(0XB8E8,	"[ES:DI+SF_ENTRY.sf_Ref_Count] ; free?",	0);
	set_cmt	(0XB8EC,	"yep, got one",	0);
	set_cmt	(0XB8EE,	"[ES:DI+SF_ENTRY.sf_ref_count],sf_busy",	0);
	set_cmt	(0XB8F2,	"special busy mark",	0);
	set_cmt	(0XB8F4,	"try the next one",	0);
	create_insn	(x=0XB8F7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB8FB,	"[ES:DI+SF_ENTRY.sf_UID]",	0);
	set_cmt	(0XB8FF,	"not ours",	0);
	create_insn	(x=0XB901);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB905,	"[ES:DI+SF_ENTRY.sf_PID]",	0);
	set_cmt	(0XB909,	"can't use this one, try the next",	0);
	set_cmt	(0XB90B,	"[ES:DI+SF_ENTRY.sf_ref_count],sf_busy",	0);
	create_insn	(x=0XB910);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB914,	"[ES:DI+SF_ENTRY.sf_UID]",	0);
	create_insn	(x=0XB918);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB91C,	"[ES:DI+SF_ENTRY.sf_PID]",	0);
	set_cmt	(0XB922,	"return with no error",	0);
	create_insn	(0XB923);
	set_cmt	(0XB924,	"return with 'C' and error",	0);
	set_cmt	(0XB926,	"get system file entry",	0);
	create_insn	(0XB926);
	set_name	(0XB926,	"$CLOSE");
	create_insn	(x=0XB92D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB931,	"DS:SI point to JFN table entry\nES:DI point to SFT",	0);
	create_insn	(x=0XB931);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB935,	"[ES:DI+SF_ENTRY.sf_ref_count]\nwill the SFT become free?",	0);
	set_cmt	(0XB939,	"yes, free JFN anyway.",	0);
	set_cmt	(0XB93B,	"[ES:DI+SF_ENTRY.sf_mode]",	0);
	set_cmt	(0XB93F,	"SHARING_MASK",	0);
	create_insn	(x=0XB93F);
	op_hex		(x,	1);
	set_cmt	(0XB941,	"SHARING_NET_FCB",	0);
	create_insn	(x=0XB941);
	op_hex		(x,	1);
	set_cmt	(0XB943,	"70-mode and big ref count => free it",	0);
	set_cmt	(0XB948,	"release the JFN",	0);
	set_cmt	(0XB951,	"CLOSE ; Bogus multiplan fix",	0);
	create_insn	(x=0XB951);
	op_hex		(x,	1);
	set_name	(0XB953,	"CloseOk");
	create_insn	(0XB956);
	set_name	(0XB956,	"CloseError");
	set_cmt	(0XB959,	"get system file entry",	0);
	create_insn	(0XB959);
	set_name	(0XB959,	"$COMMIT");
	create_insn	(x=0XB960);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XB964);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XB96D,	"COMMIT",	0);
	create_insn	(x=0XB96D);
	op_hex		(x,	1);
	create_insn	(0XB971);
	set_name	(0XB971,	"CommitError");
	set_cmt	(0XB973,	"0: enlarge  1: shrink  2:psp",	0);
	create_insn	(0XB973);
	set_name	(0XB973,	"$ExtHandle");
	set_cmt	(0XB975,	"FILPERPROC",	0);
	create_insn	(x=0XB975);
	op_dec		(x,	1);
	set_cmt	(0XB978,	"Don't set less than FilPerProc no",	0);
	create_insn	(x=0XB97A);
	op_dec		(x,	1);
	create_insn	(x=0XB97D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XB97D,	"exth2");
	set_cmt	(0XB982,	"[ES:PDB.JFN_Length]\nget number of handle allowed",	0);
	create_insn	(x=0XB982);
	set_cmt	(0XB987,	"the requested == current",	0);
	set_cmt	(0XB989,	"yes and exit",	0);
	set_cmt	(0XB98B,	"go allocate new table",	0);
	set_cmt	(0XB98D,	"bp = 1 ; shrink",	0);
	set_cmt	(0XB98E,	"[ES:PDB.JFN_Pointer+2]",	0);
	create_insn	(x=0XB98E);
	set_cmt	(0XB995,	"get difference",	0);
	set_cmt	(0XB997,	"-1 ; scan through handles to ensure",	0);
	set_name	(0XB997,	"chck_handles");
	set_cmt	(0XB99A,	"close status",	0);
	set_cmt	(0XB99F,	"FILPERPROC",	0);
	create_insn	(x=0XB99F);
	op_dec		(x,	1);
	set_cmt	(0XB9A4,	"bp = 2 ; psp",	0);
	set_cmt	(0XB9A5,	"PDB.JFN_TABLE",	0);
	create_insn	(x=0XB9A5);
	op_dec		(x,	1);
	create_insn	(0XB9AB);
	set_name	(0XB9AB,	"larger");
	set_cmt	(0XB9AC,	"65535 is not allowed",	0);
	set_cmt	(0XB9B1,	"adjust to paragraph boundary",	0);
	set_cmt	(0XB9B8,	"clear most 3 bits",	0);
	create_insn	(x=0XB9B8);
	op_hex		(x,	1);
	set_cmt	(0XB9BC,	"allocate memory",	0);
	set_cmt	(0XB9C0,	"not enough memory",	0);
	set_cmt	(0XB9C4,	"es:di points to new table memory",	0);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_5(void) {
        auto x;
#define id x

	create_insn	(x=0XB9C6);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XB9C6,	"movhandl");
	set_cmt	(0XB9CB,	"enlarge ?",	0);
	create_insn	(x=0XB9CB);
	op_hex		(x,	1);
	set_cmt	(0XB9CF,	"yes",	0);
	set_cmt	(0XB9D1,	"cx = the amount you shrink",	0);
	set_cmt	(0XB9D5,	"error_too_many_open_files",	0);
	create_insn	(0XB9D5);
	set_name	(0XB9D5,	"too_many_files");
	set_name	(0XB9D7,	"CommitErrorj");
	set_cmt	(0XB9D9,	"[PDB.JFN_Length]\nget number of old handles",	0);
	create_insn	(0XB9D9);
	set_name	(0XB9D9,	"enlarge");
	set_name	(0XB9DD,	"copy_hand");
	set_cmt	(0XB9DF,	"[PDB.JFN_Pointer]\nget old table pointer",	0);
	set_cmt	(0XB9E3,	"copy infomation to new table",	0);
	set_cmt	(0XB9E5,	"get new number of handles",	0);
	set_cmt	(0XB9E7,	"get the difference",	0);
	set_cmt	(0XB9E9,	"-1 ; set availability to handles",	0);
	create_insn	(x=0XB9ED);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XB9F2,	"[PDB.JFN_Pointer]\ncheck if original table pointer",	0);
	set_cmt	(0XB9F7,	"yes, go update PDB entries",	0);
	set_cmt	(0XB9FC,	"[PDB.JFN_Pointer+2]\nget old table segment",	0);
	set_cmt	(0XBA00,	"deallocate old table memory",	0);
	set_cmt	(0XBA06,	"psp?",	0);
	create_insn	(x=0XBA06);
	op_hex		(x,	1);
	set_name	(0XBA06,	"update_info");
	set_cmt	(0XBA0A,	"no",	0);
	set_cmt	(0XBA0C,	"[PDB.JFN_Pointer],PDB.JFN_TABLE\nrestore",	0);
	set_cmt	(0XBA14,	"[PDB.JFN_Pointer]\nnew table pointer offset always 0",	0);
	create_insn	(0XBA14);
	set_name	(0XBA14,	"non_psp");
	set_cmt	(0XBA1A,	"[PDB.JFN_Pointer+2]\nnew table segment",	0);
	set_name	(0XBA1A,	"final");
	set_cmt	(0XBA1E,	"[PDB.JFN_Length]\nrestore new number of handles",	0);
	set_cmt	(0XBA25,	"clean stack",	0);
	create_insn	(0XBA25);
	set_name	(0XBA25,	"no_memory");
	set_cmt	(0XBA26,	"error_not_enough_memory",	0);
	set_cmt	(0XBA2A,	"error_invalid_function",	0);
	create_insn	(0XBA2A);
	set_name	(0XBA2A,	"invalid_func");
	create_insn	(x=0XBA2E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XBA2E,	"$READ");
	set_name	(0XBA31,	"ReadDO");
	set_cmt	(0XBA39,	"get the handle",	0);
	create_insn	(x=0XBA3E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XBA43);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBA48,	"[ES:DI+SF_ENTRY.sf_mode+1],(INT_24_ERROR>>8)\nneed i24",	0);
	create_insn	(x=0XBA48);
	op_hex		(x,	1);
	set_cmt	(0XBA4D,	"yes",	0);
	set_cmt	(0XBA4F,	"EXT_OPEN_I24_OFF ; set it off",	0);
	create_insn	(x=0XBA4F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XBA55,	"original segment",	0);
	create_insn	(x=0XBA57);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XBA60);
	op_hex		(x,	1);
	create_insn	(x=0XBA62);
	op_hex		(x,	1);
	create_insn	(x=0XBA64);
	op_hex		(x,	1);
	create_insn	(x=0XBA66);
	op_hex		(x,	1);
	set_cmt	(0XBA68,	"new segment",	0);
	set_cmt	(0XBA6A,	"normalize offset",	0);
	create_insn	(x=0XBA6A);
	op_hex		(x,	1);
	create_insn	(x=0XBA6D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XBA72);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBA7A,	"indirect call to operation",	0);
	create_insn	(x=0XBA7C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XBA80);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBA86,	"get correct return in correct reg",	0);
	set_cmt	(0XBA88,	"successful return",	0);
	set_name	(0XBA88,	"Read_Ok");
	create_insn	(0XBA8A);
	set_name	(0XBA8A,	"ReadError");
	create_insn	(x=0XBA8C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XBA8C,	"$WRITE");
	set_cmt	(0XBA91,	"get system file entry",	0);
	create_insn	(0XBA91);
	set_name	(0XBA91,	"$LSEEK");
	set_name	(0XBA94,	"LSeekError");
	set_cmt	(0XBA96,	"\nis the seek value correct?",	0);
	set_name	(0XBA96,	"CHKOWN_OK");
	set_cmt	(0XBA98,	"no",	0);
	set_cmt	(0XBA9A,	"yes, go dispatch\nbest way to dispatch; check middle",	0);
	set_name	(0XBA9A,	"LSeekDisp");
	set_cmt	(0XBA9C,	"just store CX:DX",	0);
	set_cmt	(0XBA9E,	"seek from end of file",	0);
	set_cmt	(0XBAA0,	"[ES:DI+SF_ENTRY.sf_position]",	0);
	set_cmt	(0XBAA4,	"[ES:DI+SF_ENTRY.sf_position+2]",	0);
	set_cmt	(0XBAAA,	"DX:AX is the correct value",	0);
	set_cmt	(0XBAAB,	"[ES:DI+SF_ENTRY.sf_position]",	0);
	set_cmt	(0XBAAF,	"[ES:DI+SF_ENTRY.sf_position+2]",	0);
	set_cmt	(0XBAB6,	"[SI+user_env.user_DX] ; return DX:AX",	0);
	set_cmt	(0XBAB9,	"successful return",	0);
	set_cmt	(0XBABB,	"[ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)",	0);
	create_insn	(x=0XBABB);
	op_hex		(x,	1);
	set_cmt	(0XBAC0,	"is net",	0);
	set_cmt	(0XBAC2,	"[ES:DI+SF_ENTRY.sf_size]",	0);
	set_cmt	(0XBAC6,	"[ES:DI+SF_ENTRY.sf_size+2]",	0);
	set_cmt	(0XBACA,	"go and set the position",	0);
	set_cmt	(0XBACC,	"[ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)",	0);
	create_insn	(x=0XBACC);
	op_hex		(x,	1);
	set_cmt	(0XBAD1,	"FCB treated like local file",	0);
	set_cmt	(0XBAD3,	"ES:DI+SF_ENTRY.sf_mode]",	0);
	set_cmt	(0XBAD7,	"SHARING_MASK",	0);
	create_insn	(x=0XBAD7);
	op_hex		(x,	1);
	set_cmt	(0XBADA,	"SHARING_DENY_NONE",	0);
	create_insn	(x=0XBADA);
	op_hex		(x,	1);
	set_cmt	(0XBADD,	"LSEEK exported in this mode",	0);
	set_cmt	(0XBADF,	"SHARING_DENY_READ",	0);
	create_insn	(x=0XBADF);
	op_hex		(x,	1);
	set_cmt	(0XBAE2,	"Treated like local Lseek",	0);
	set_cmt	(0XBAE7,	"Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE\nCX:DX = offset (in bytes) from end\nES:DI -> SFT, SFT DPB field -> DPB of drive with file\nSS = DOS CS\nReturn: CF set on error\nCF clear if successful, DX:AX = new file position",	0);
	create_insn	(x=0XBAE7);
	op_hex		(x,	0);
	set_name	(0XBAEB,	"LSeekError3");
	set_cmt	(0XBAED,	"Extended Error Locus",	0);
	create_insn	(0XBAED);
	set_name	(0XBAED,	"LSeekError1");
	set_cmt	(0XBAF0,	"error_invalid_function",	0);
	set_name	(0XBAF2,	"LSeekError2");
	set_cmt	(0XBAF5,	"SET CREATION DATE AND TIME\n6 = GET CREATION DATE AND TIME\n5 = SET LAST ACCESS DATE AND TIME",	0);
	create_insn	(0XBAF5);
	set_name	(0XBAF5,	"$FILE_TIMES");
	set_cmt	(0XBAF9,	"GET LAST ACCESS DATE AND TIME",	0);
	set_cmt	(0XBAFD,	"0 = GET FILE'S LAST-WRITTEN DATE AND TIME\n1 = SET FILE'S LAST-WRITTEN DATE AND TIME",	0);
	set_cmt	(0XBAFF,	"2,3 -> invalid",	0);
	set_cmt	(0XBB01,	"get sft",	0);
	set_name	(0XBB01,	"ft1");
	set_cmt	(0XBB04,	"bad handle",	0);
	set_cmt	(0XBB08,	"PCDOS 7.1 (MSDOS 7) sub function",	0);
	set_cmt	(0XBB0A,	"get time/date ?",	0);
	set_cmt	(0XBB0C,	"no, set",	0);
	set_cmt	(0XBB0E,	"[es:di+SF_ENTRY.sf_time]\nget the time",	0);
	set_cmt	(0XBB12,	"& date ; [es:di+SF_ENTRY.sf_date]",	0);
	set_cmt	(0XBB17,	"[si+user_env.user_CX]",	0);
	set_cmt	(0XBB1A,	"[si+user_env.user_DX]",	0);
	set_cmt	(0XBB1F,	"call ECritSFT",	0);
	create_insn	(0XBB1F);
	set_name	(0XBB1F,	"ft_set_time");
	set_cmt	(0XBB22,	"[es:di+SF_ENTRY.sf_time] ; drop in new time",	0);
	set_cmt	(0XBB26,	"[es:di+SF_ENTRY.sf_date] ; and date",	0);
	set_cmt	(0XBB2C,	"call far [ss:JShare+(14*4)] ; 14 = ShSU",	0);
	create_insn	(x=0XBB2C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBB31,	"[es:di+SF_ENTRY.sf_flags],~devid_file_clean",	0);
	create_insn	(x=0XBB31);
	op_hex		(x,	1);
	set_cmt	(0XBB36,	"[es:di+SF_ENTRY.sf_flags],sf_close_nodate",	0);
	create_insn	(x=0XBB36);
	op_hex		(x,	1);
	set_cmt	(0XBB3C,	"call LCritSFT",	0);
	set_name	(0XBB3F,	"ft_ok");
	set_cmt	(0XBB42,	"[es:di+SF_ENTRY.sf_flags],devid_device",	0);
	create_insn	(x=0XBB42);
	op_hex		(x,	1);
	set_name	(0XBB42,	"ft2");
	set_cmt	(0XBB47,	"device",	0);
	set_cmt	(0XBB4C,	"local file",	0);
	set_name	(0XBB4C,	"ft3");
	set_cmt	(0XBB4E,	"0 = GET, 1 = SET",	0);
	create_insn	(x=0XBB4E);
	op_hex		(x,	1);
	set_cmt	(0XBB50,	"SET",	0);
	set_cmt	(0XBB52,	"[es:di+SF_ENTRY.sf_date]\n(sub cx,cx ; Windows ME IO.SYS BIOSCODE:A348h)",	0);
	set_name	(0XBB56,	"ft4");
	set_cmt	(0XBB59,	"[si+user_env.user_CX] ; time",	0);
	set_cmt	(0XBB5C,	"[si+user_env.user_DX] ; date",	0);
	set_name	(0XBB5F,	"ft_okj");
	set_cmt	(0XBB61,	"Retrieve the directory entry for the file",	0);
	create_insn	(0XBB61);
	set_name	(0XBB61,	"ft5");
	set_cmt	(0XBB65,	"ES:DI point to SFT",	0);
	set_cmt	(0XBB66,	"locate a directory entry given an SFT",	0);
	set_cmt	(0XBB6B,	"ES:DI point to entry\n(DS:SI point to SFT)\n(ES:BX point to buffer header)",	0);
	set_name	(0XBB6E,	"ft_error");
	create_insn	(0XBB70);
	set_name	(0XBB70,	"ft6");
	set_cmt	(0XBB71,	"SET ?",	0);
	create_insn	(x=0XBB71);
	op_hex		(x,	1);
	set_cmt	(0XBB73,	"yes",	0);
	set_cmt	(0XBB75,	"(always) last access time = 0",	0);
	set_cmt	(0XBB77,	"[es:di+dir_entry.dir_lstaccdate]",	0);
	set_cmt	(0XBB7B,	"GET CREATION DATE AND TIME ?",	0);
	set_cmt	(0XBB7D,	"no, GET LAST ACCESS DATE AND TIME",	0);
	set_cmt	(0XBB7F,	"[es:di+dir_entry.dir_crttime]",	0);
	set_cmt	(0XBB83,	"[es:di+dir_entry.dir_crtdate]",	0);
	set_name	(0XBB87,	"ft7");
	set_cmt	(0XBB89,	"check date (set) values\nDAY (1 to 31) > 0 ?",	0);
	create_insn	(x=0XBB89);
	op_hex		(x,	1);
	set_name	(0XBB89,	"ft8");
	set_cmt	(0XBB8C,	"yes, valid",	0);
	set_cmt	(0XBB8E,	"error_invalid_data",	0);
	set_name	(0XBB8E,	"ft_err_invd");
	set_name	(0XBB90,	"ft_errj");
	set_cmt	(0XBB92,	"MONTH (1 to 12) > 0 ?",	0);
	create_insn	(x=0XBB92);
	op_hex		(x,	1);
	set_name	(0XBB92,	"ft9");
	set_cmt	(0XBB96,	"no, invalid",	0);
	set_cmt	(0XBB99,	"isolate MONTH",	0);
	create_insn	(x=0XBB99);
	op_hex		(x,	1);
	set_cmt	(0XBB9D,	"> 12 ?",	0);
	set_cmt	(0XBBA2,	"yes, invalid",	0);
	set_cmt	(0XBBA4,	"SET LAST ACCESS DATE AND TIME ?",	0);
	set_cmt	(0XBBA6,	"no, SET CREATION DATE AND TIME",	0);
	set_cmt	(0XBBA8,	"[es:di+dir_entry.dir_lstaccdate]",	0);
	set_cmt	(0XBBAE,	"check time (set) values",	0);
	create_insn	(0XBBAE);
	set_name	(0XBBAE,	"ft10");
	set_cmt	(0XBBB0,	"isolate seconds/2 and hour",	0);
	create_insn	(x=0XBBB0);
	op_hex		(x,	1);
	set_cmt	(0XBBB3,	"HOUR > 23 ?",	0);
	set_cmt	(0XBBB6,	"yes, invalid",	0);
	set_cmt	(0XBBB8,	"SECONDS/2 > 29 (count of 2 seconds)",	0);
	set_cmt	(0XBBBA,	"yes, invalid",	0);
	set_cmt	(0XBBBE,	"isolate MINUTE",	0);
	create_insn	(x=0XBBBE);
	op_hex		(x,	1);
	set_cmt	(0XBBC1,	"MINUTE > 59 ?",	0);
	set_cmt	(0XBBC4,	"yes, invalid",	0);
	set_cmt	(0XBBC6,	"[es:di+dir_entry.dir_crtdate]",	0);
	set_cmt	(0XBBCA,	"[es:di+dir_entry.dir_crttime]",	0);
	set_cmt	(0XBBCE,	"[es:bx+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0XBBCE);
	op_hex		(x,	1);
	set_name	(0XBBCE,	"ft11");
	set_cmt	(0XBBD8,	"[es:bx+BUFFINFO.buf_flags],buf_dirty",	0);
	create_insn	(x=0XBBD8);
	op_hex		(x,	1);
	set_name	(0XBBDD,	"ft12");
	set_cmt	(0XBBDF,	"DS:DI - pointer to buffer",	0);
	set_cmt	(0XBBE1,	"Drive number, -1 means do not check for drive",	0);
	set_name	(0XBBE8,	"ok_ret");
	set_cmt	(0XBBEB,	"duplicate a jfn, bx = file handle",	0);
	create_insn	(0XBBEB);
	set_name	(0XBBEB,	"$DUP");
	set_cmt	(0XBBF0,	"free handle addr in ES:DI, new in BX",	0);
	set_name	(0XBBF0,	"DupErrorCheck");
	set_cmt	(0XBBF2,	"nope, bye",	0);
	create_insn	(0XBBF5);
	set_name	(0XBBF5,	"dupjfn_1");
	set_cmt	(0XBBF8,	"ds:si = (free) jfn address",	0);
	set_cmt	(0XBBF9,	"get back old handle",	0);
	set_cmt	(0XBBFA,	"get sft in ES:DI",	0);
	set_cmt	(0XBBFF,	"errors go home",	0);
	create_insn	(0XBC01);
	set_name	(0XBC01,	"dupjfn_2");
	set_cmt	(0XBC04,	"get pointer",	0);
	set_cmt	(0XBC07,	"get SFT number",	0);
	set_cmt	(0XBC0A,	"stuff in new SFT",	0);
	set_cmt	(0XBC0C,	"and go home",	0);
	set_cmt	(0XBC0E,	"force a dup on a particular jfn",	0);
	create_insn	(0XBC0E);
	set_name	(0XBC0E,	"$DUP2");
	set_cmt	(0XBC0F,	"bx = file handle, cx = new file handle",	0);
	set_cmt	(0XBC12,	"close destination handle",	0);
	set_cmt	(0XBC16,	"old in AX, new in BX",	0);
	set_cmt	(0XBC1A,	"check error and do dup",	0);
	create_insn	(0XBC1C);
	set_name	(0XBC1C,	"CheckOwner");
	create_insn	(x=0XBC22);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XBC28,	"win386 is not present",	0);
	set_cmt	(0XBC2A,	"set the zero flag",	0);
	create_insn	(0XBC30);
	create_insn	(x=0XBC32);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XBC36,	"[es:di+SF_ENTRY.sf_UID]",	0);
	set_cmt	(0XBC3D,	"error_invalid_handle",	0);
	set_cmt	(0XBC41,	"set in_use ?",	0);
	create_insn	(0XBC41);
	set_name	(0XBC41,	"$AssignOper");
	set_cmt	(0XBC43,	"no",	0);
	set_name	(0XBC45,	"srinuse");
	set_cmt	(0XBC46,	"AL= drive id",	0);
	set_cmt	(0XBC48,	"ds:si -> cds",	0);
	set_cmt	(0XBC4C,	"bad drive",	0);
	set_cmt	(0XBC4E,	"[SI+curdir.devptr]",	0);
	set_cmt	(0XBC54,	"set ?",	0);
	set_cmt	(0XBC56,	"no",	0);
	set_cmt	(0XBC58,	"[SI+curdir.flags+1],(curdir_inuse>>8)",	0);
	create_insn	(x=0XBC58);
	op_hex		(x,	1);
	set_cmt	(0XBC5E,	"[SI+curdir.flags+1],(~curdir_inuse)>>8",	0);
	create_insn	(x=0XBC5E);
	op_hex		(x,	1);
	set_name	(0XBC5E,	"resetdrv");
	set_cmt	(0XBC64,	"error_invalid_drive",	0);
	create_insn	(0XBC64);
	set_name	(0XBC64,	"baddrv");
	set_cmt	(0XBC69,	"reset inuse ?",	0);
	create_insn	(0XBC69);
	set_name	(0XBC69,	"chk08");
	set_cmt	(0XBC6B,	"yes",	0);
	set_cmt	(0XBC71,	"Multiplex - NETWORK REDIRECTOR - DO REDIRECTION\nSS = DOS CS\nSTACK: WORD function to execute\nReturn: CF set on error, AX = error code\nSTACK unchanged",	0);
	create_insn	(x=0XBC71);
	op_hex		(x,	0);
	set_name	(0XBC76,	"okdone");
	create_insn	(0XBC79);
	set_name	(0XBC79,	"ASS_ERR");
	set_cmt	(0XBC7C,	"Find a DPB from a drive number",	0);
	create_insn	(x=0XBC7C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XBC7C,	"FIND_DPB");
	set_cmt	(0XBC81,	"-1",	0);
	set_cmt	(0XBC86,	"[SI+DPB.DRIVE]",	0);
	set_cmt	(0XBC88,	"Carry clear (retz)",	0);
	set_cmt	(0XBC8A,	"[SI+DPB.NEXT_DPB]",	0);
	create_insn	(0XBC8F);
	set_cmt	(0XBC91,	"set up an empty CDS\nAL has uppercase drive letter",	0);
	create_insn	(0XBC91);
	set_name	(0XBC91,	"InitCDS");
	create_insn	(x=0XBC92);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XBC97,	"[ES:DI+curdir.flags] ; \"free\" CDS",	0);
	set_cmt	(0XBC9D,	"\"A\"-1  ; A = 1",	0);
	create_insn	(x=0XBC9F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBCA4,	"Drive does not map a physical drive",	0);
	set_cmt	(0XBCA6,	"(AL) = 0 if A, 1 if B, etc.",	0);
	create_insn	(x=0XBCA8);
	op_chr		(x,	1);
	create_insn	(x=0XBCAA);
	op_chr		(x,	1);
	set_cmt	(0XBCAC,	"[ES:DI+curdir.text] ; set \"x:\"",	0);
	set_cmt	(0XBCAF,	"[ES:DI+curdir.text+2],\"\\\"\nNUL terminate",	0);
	set_cmt	(0XBCB5,	"[ES:DI+curdir.flags+1],\n(curdir_inuse>>8)",	0);
	create_insn	(x=0XBCB5);
	op_hex		(x,	1);
	set_cmt	(0XBCBC,	"[ES:DI+curdir.ID],0",	0);
	set_cmt	(0XBCC0,	"[ES:DI+curdir.ID+2],0",	0);
	set_cmt	(0XBCC6,	"[ES:DI+curdir.end],2",	0);
	set_cmt	(0XBCCA,	"(al) = drive number",	0);
	set_cmt	(0XBCD0,	"OOOOPPPPPSSSS!!!!",	0);
	set_cmt	(0XBCD2,	"[ES:DI+curdir.devptr]",	0);
	set_cmt	(0XBCD6,	"[ES:DI+curdir.devptr+2]",	0);
	set_name	(0XBCDD,	"RET45");
	set_cmt	(0XBCDE,	"get/set current user ID (for net)\nAL has function type",	0);
	create_insn	(0XBCDE);
	set_name	(0XBCDE,	"$UserOper");
	set_cmt	(0XBCE0,	"0-get",	0);
	set_cmt	(0XBCE2,	"1-set",	0);
	set_cmt	(0XBCE4,	"5-printer-get-flags",	0);
	set_cmt	(0XBCE6,	"2-printer-set\n3-printer-get\n4-printer-set-flags",	0);
	set_cmt	(0XBCEB,	"error_invalid_function",	0);
	set_name	(0XBCED,	"useroper_error");
	set_cmt	(0XBCEF,	"return to user the string",	0);
	create_insn	(0XBCEF);
	set_name	(0XBCEF,	"UserGet");
	set_cmt	(0XBCF1,	"destination",	0);
	set_cmt	(0XBCF3,	"Get number",	0);
	create_insn	(x=0XBCF3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XBCFB,	"[SI+user_env.user_CX]\nSet number return",	0);
	set_cmt	(0XBD00,	"point source to user string",	0);
	create_insn	(x=0XBD00);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XBD03);
	op_dec		(x,	1);
	set_name	(0XBD03,	"UserMove");
	set_cmt	(0XBD08,	"16th byte is 0",	0);
	set_name	(0XBD0B,	"UserBye");
	set_cmt	(0XBD0E,	"set the current user",	0);
	create_insn	(x=0XBD0E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XBD0E,	"UserSet");
	set_cmt	(0XBD13,	"user space has source",	0);
	set_cmt	(0XBD17,	"point dest to user string",	0);
	create_insn	(x=0XBD17);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XBD1A,	"signal change",	0);
	create_insn	(x=0XBD1A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XBD21);
	set_name	(0XBD21,	"UserPrint");
	set_cmt	(0XBD25,	"Multiplex - NETWORK REDIRECTOR - PRINTER SETUP\nSTACK: WORD function\nReturn: CF set on error, AX = error code\nSTACK unchanged",	0);
	create_insn	(x=0XBD25);
	op_hex		(x,	0);
	set_cmt	(0XBD2C,	"correctly map non-spliced inuse drives\nget inuse drive",	0);
	create_insn	(0XBD2C);
	set_name	(0XBD2C,	"GetVisDrv");
	create_insn	(x=0XBD33);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XBD38,	"[SI+curdir.flags+1],(curdir_splice>>8)",	0);
	create_insn	(x=0XBD38);
	op_hex		(x,	1);
	set_cmt	(0XBD3E,	"if not spliced, return OK",	0);
	set_cmt	(0XBD40,	"error_invalid_drive",	0);
	create_insn	(x=0XBD40);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBD48,	"are we using default drive?",	0);
	create_insn	(0XBD48);
	set_name	(0XBD48,	"GETTHISDRV");
	set_cmt	(0XBD4A,	"no, go get the CDS pointers",	0);
	set_cmt	(0XBD4C,	"get the current drive",	0);
	create_insn	(x=0XBD4C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XBD50,	"Counteract next instruction",	0);
	set_cmt	(0XBD51,	"0 = A",	0);
	set_cmt	(0XBD57,	"Logical or Physical?",	0);
	create_insn	(x=0XBD57);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBD5D,	"Logical",	0);
	create_insn	(x=0XBD62);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XBD69);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XBD6E);
	op_chr		(x,	1);
	set_cmt	(0XBD73,	"[ES:DI+curdir.flags+1],\n(curdir_inuse>>8)",	0);
	create_insn	(x=0XBD73);
	op_hex		(x,	1);
	set_cmt	(0XBD7D,	"carry clear",	0);
	create_insn	(0XBD7F);
	set_cmt	(0XBD82,	"Unassigned CDS -> return error already set",	0);
	set_cmt	(0XBD84,	"[SI+curdir.flags+1],(curdir_inuse>>8)",	0);
	create_insn	(x=0XBD84);
	op_hex		(x,	1);
	set_cmt	(0XBD8A,	"error_invalid_drive ; invalid FAT drive",	0);
	set_cmt	(0XBD8C,	"save this for IOCTL",	0);
	create_insn	(x=0XBD8C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBD90,	"[ss:EXTERR_LOCUS],errLOC_Unk",	0);
	set_cmt	(0XBD97,	"is this a valid designator ?",	0);
	create_insn	(x=0XBD97);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XBD97,	"GetCDSFromDrv");
	set_cmt	(0XBD9C,	"error",	0);
	set_cmt	(0XBD9E,	"yes, get the macro",	0);
	set_name	(0XBD9E,	"GetCDS");
	set_cmt	(0XBDA0,	"get pointer to table",	0);
	create_insn	(x=0XBDA0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XBDA5,	"curdir.size",	0);
	create_insn	(x=0XBDA5);
	op_dec		(x,	1);
	set_cmt	(0XBDA7,	"get net offset",	0);
	set_cmt	(0XBDA9,	"convert to true pointer",	0);
	create_insn	(x=0XBDAB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XBDB0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBDB7,	"no error",	0);
	set_cmt	(0XBDB9,	"signal error",	0);
	create_insn	(0XBDB9);
	create_insn	(0XBDBB);
	set_name	(0XBDBB,	"TransFCB");
	create_insn	(x=0XBDBE);
	op_hex		(x,	1);
	set_cmt	(0XBDC5,	"point to FCB temp area",	0);
	create_insn	(x=0XBDC5);
	op_stkvar	(x,	1);
	set_cmt	(0XBDC8,	"no extended FCB found",	0);
	create_insn	(x=0XBDC8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBDCE,	"default search attributes",	0);
	create_insn	(x=0XBDCE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBDD4,	"get FCB, extended or not",	0);
	set_cmt	(0XBDD7,	"not an extended FCB, get drive",	0);
	set_cmt	(0XBDD9,	"get attributes",	0);
	set_cmt	(0XBDDC,	"store search attributes",	0);
	create_insn	(x=0XBDDC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBDE0,	"-1 ; signal extended FCB",	0);
	create_insn	(x=0XBDE0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBDE6,	"get drive byte",	0);
	set_cmt	(0XBDEC,	"convert 0-based drive to text",	0);
	create_insn	(x=0XBDEF);
	op_dec		(x,	1);
	set_cmt	(0XBDF2,	"back over name, ext",	0);
	set_cmt	(0XBDF3,	"get a byte",	0);
	set_cmt	(0XBDF4,	"get flags",	0);
	set_cmt	(0XBDF7,	"FFCB",	0);
	create_insn	(x=0XBDF7);
	op_hex		(x,	1);
	set_cmt	(0XBE00,	"crunch the path",	0);
	set_cmt	(0XBE03,	"get original destination",	0);
	set_cmt	(0XBE07,	"lea si,[bp-16] ; point at new pathname",	0);
	create_insn	(x=0XBE07);
	op_stkvar	(x,	1);
	set_cmt	(0XBE10,	"convert the path",	0);
	set_cmt	(0XBE17,	"error_path_not_found",	0);
	set_name	(0XBE1C,	"TransPath_retn");
	set_cmt	(0XBE1D,	"0",	0);
	create_insn	(0XBE1D);
	set_name	(0XBE1D,	"TransPath");
	set_cmt	(0XBE21,	"-1",	0);
	create_insn	(0XBE21);
	set_name	(0XBE21,	"TransPathSet");
	set_cmt	(0XBE23,	"NoSetDir = !fExact",	0);
	create_insn	(x=0XBE23);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XBE23,	"SetSplice");
	set_cmt	(0XBE27,	"-1",	0);
	set_cmt	(0XBE29,	"fSplice = TRUE",	0);
	create_insn	(x=0XBE29);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XBE29,	"TransPathNoSet");
	set_cmt	(0XBE2D,	"-1",	0);
	create_insn	(x=0XBE2D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XBE33);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBE38,	"-1 ; crack from start",	0);
	create_insn	(x=0XBE38);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBE3F,	"DS:SI - point to ASCIZ string path\nDI - point to buffer in DOSDATA",	0);
	set_cmt	(0XBE41,	"[DI+TEMPLEN] ; end of buffer",	0);
	create_insn	(x=0XBE41);
	op_dec		(x,	1);
	set_cmt	(0XBE45,	"if no sharing",	0);
	create_insn	(x=0XBE45);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBE4B,	"skip to UNC check\nES:DI point to buffer",	0);
	set_cmt	(0XBE4D,	"get drive and advance DS:SI",	0);
	set_cmt	(0XBE50,	"Set ThisCDS and convert to 0-based",	0);
	set_cmt	(0XBE55,	"drop in new",	0);
	set_cmt	(0XBE58,	"backup limit",	0);
	set_cmt	(0XBE5B,	"copy and canonicalize",	0);
	set_cmt	(0XBE5E,	"errors",	0);
	set_cmt	(0XBE62,	"point to name",	0);
	create_insn	(x=0XBE62);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XBE66);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XBE72,	"for FATREAD",	0);
	create_insn	(x=0XBE72);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XBE7F,	"error_path_not_found\n(Set up for possible bad path error)",	0);
	set_cmt	(0XBE81,	"(any errors are in Carry flag)",	0);
	set_cmt	(0XBE82,	"-1 ; NULL thisCDS",	0);
	create_insn	(x=0XBE82);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBE89,	"NetSpoolCheck",	0);
	set_cmt	(0XBE8C,	"Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME\nDS:SI -> ASCIZ filename to canonicalize\nES:DI -> 128-byte buffer for qualified name\nReturn: CF set if not resolved",	0);
	create_insn	(x=0XBE8C);
	op_hex		(x,	0);
	set_cmt	(0XBE90,	"eat drive letter",	0);
	set_cmt	(0XBE94,	"get first two bytes of path",	0);
	set_cmt	(0XBE96,	"convert to normal form",	0);
	set_cmt	(0XBE99,	"swap for second byte",	0);
	set_cmt	(0XBE9B,	"convert to normal form",	0);
	set_cmt	(0XBE9E,	"not a path char",	0);
	set_cmt	(0XBEA0,	"are they same?",	0);
	set_cmt	(0XBEA2,	"nope",	0);
	set_cmt	(0XBEA4,	"We have a UNC request\n(prefixed with two leading \\\\s)",	0);
	set_cmt	(0XBEA5,	"get the lead \\\\.",	0);
	set_cmt	(0XBEA6,	"get a byte",	0);
	set_cmt	(0XBEA7,	"convert the char",	0);
	set_cmt	(0XBEAC,	"end of string. All done.",	0);
	set_cmt	(0XBEAE,	"is it a path char?",	0);
	set_cmt	(0XBEB1,	"backup position",	0);
	set_cmt	(0XBEB4,	"no, go copy",	0);
	set_cmt	(0XBEB6,	"wham (and set cMeta)",	0);
	set_cmt	(0XBEBB,	"(return error code)",	0);
	create_insn	(0XBEBC);
	set_cmt	(0XBEBF,	"retrieve drive info",	0);
	create_insn	(0XBEBF);
	set_cmt	(0XBEC0,	"check for null file",	0);
	set_cmt	(0XBEC5,	"error_file_not_found",	0);
	create_insn	(0XBEC9);
	set_cmt	(0XBECA,	"save drive number",	0);
	set_cmt	(0XBED2,	"-1 ; simulate sharing dos call",	0);
	create_insn	(x=0XBED2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBED8,	"set ThisCDS and init DUMMYCDS",	0);
	create_insn	(x=0XBEDB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBEE4,	"path separator",	0);
	set_cmt	(0XBEE7,	"move remainder of string",	0);
	set_cmt	(0XBEEA,	"everything OK.",	0);
	set_cmt	(0XBEEE,	"snoop for device",	0);
	create_insn	(0XBEEE);
	set_name	(0XBEEE,	"no5Dshere");
	set_cmt	(0XBEF1,	"get proper CDS",	0);
	create_insn	(0XBEF1);
	set_cmt	(0XBEF4,	"error_path_not_found",	0);
	set_cmt	(0XBEF6,	"CARRY set -> bogus drive/spliced",	0);
	set_cmt	(0XBEFC,	"poke CDS and make everything OK",	0);
	set_cmt	(0XBF03,	"error_path_not_found",	0);
	set_cmt	(0XBF09,	"point to CDS",	0);
	create_insn	(x=0XBF09);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XBF0E,	"point to destination",	0);
	set_cmt	(0XBF10,	"[SI+curdir.end] ; point to backup limit",	0);
	set_cmt	(0XBF13,	"[DI+TEMPLEN] ; regenerate end of buffer",	0);
	create_insn	(x=0XBF13);
	op_dec		(x,	1);
	set_cmt	(0XBF1B,	"Make sure that there is a path char at end.",	0);
	set_cmt	(0XBF21,	"get original string",	0);
	set_cmt	(0XBF24,	"point to path char",	0);
	set_cmt	(0XBF27,	"is DS:SI a path sep?",	0);
	set_cmt	(0XBF2A,	"no, DI is correct. Assure a path char",	0);
	set_cmt	(0XBF2C,	"end of string?",	0);
	set_cmt	(0XBF2E,	"yes, skip.",	0);
	set_cmt	(0XBF30,	"back up to root point.",	0);
	set_cmt	(0XBF3D,	"DS:SI start at some file name.\nES:DI points at some path char.",	0);
	set_cmt	(0XBF40,	"ES:DI point to the correct spot\n     for canonicalization to begin.\nBP is the max extent to advance DI\nBX is the backup limit for",	0);
	set_cmt	(0XBF43,	"badly formatted path",	0);
	set_cmt	(0XBF45,	"The string has been moved to ES:DI.",	0);
	set_cmt	(0XBF47,	"DS:SI point to string",	0);
	create_insn	(x=0XBF47);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XBF4B,	"point to CDS",	0);
	create_insn	(x=0XBF4B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XBF4F,	"is there a prefix?",	0);
	set_cmt	(0XBF52,	"no, do splice\nyes, we have a match",	0);
	set_cmt	(0XBF54,	"last char to match",	0);
	set_cmt	(0XBF57,	"did we end on a path char? (root)",	0);
	set_cmt	(0XBF5A,	"yes, no current dir here.",	0);
	set_cmt	(0XBF5C,	"end at NUL?",	0);
	set_cmt	(0XBF60,	"yes",	0);
	set_cmt	(0XBF62,	"point to after current path char",	0);
	create_insn	(x=0XBF63);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XBF68,	"Splice the result.",	0);
	set_cmt	(0XBF69,	"back to DOSDATA",	0);
	set_cmt	(0XBF6A,	"point to beginning of string",	0);
	create_insn	(x=0XBF6A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XBF70,	"-1",	0);
	create_insn	(x=0XBF70);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XBF77,	"replaces in place.",	0);
	set_cmt	(0XBF7C,	"point to correct drive",	0);
	create_insn	(x=0XBF7C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XBF80,	"[ES:DI+curdir.flags],\ncurdir_isnet",	0);
	create_insn	(x=0XBF80);
	op_hex		(x,	1);
	set_cmt	(0XBF86,	"net, no fatread necessary (retnz)",	0);
	set_cmt	(0XBF93,	"error_path_not_found\n(Set up for possible bad path error)",	0);
	set_cmt	(0XBF95,	"(any errors in carry flag)",	0);
	set_cmt	(0XBF96,	"copy a path and remove . and .. entries\n; DS:SI - point to ASCIZ string path\n; ES:DI - point to buffer\n; BX - backup limit (offset from ES)\n;      points to slash\n; BP - end of buffer",	0);
	create_insn	(0XBF96);
	set_name	(0XBF96,	"Canonicalize");
	set_cmt	(0XBF97,	"while (PathChr (*s))",	0);
	set_cmt	(0XBF9C,	"if (d > dlim)",	0);
	set_cmt	(0XBF9E,	"goto error;",	0);
	set_cmt	(0XBFA1,	"*d++ = *s++;",	0);
	create_insn	(0XBFA3);
	set_cmt	(0XBFA4,	"0",	0);
	set_cmt	(0XBFA6,	"if (*s == 0) {",	0);
	set_cmt	(0XBFAA,	" if (d[-1] == ':')",	0);
	set_cmt	(0XBFB1,	"*d++ = '\\';",	0);
	set_cmt	(0XBFB6,	"*d++ = 0;",	0);
	set_cmt	(0XBFB7,	"return (0);",	0);
	set_cmt	(0XBFB9,	"check for path chars in rest of string",	0);
	create_insn	(0XBFB9);
	set_cmt	(0XBFBC,	"error_path_not_found\n(Set up for bad path error)",	0);
	set_cmt	(0XBFBE,	"path character encountered in string",	0);
	set_cmt	(0XBFC0,	"error_file_not_found\n(Set bad file error)",	0);
	set_name	(0XBFC3,	"CanonBad_retn");
	set_cmt	(0XBFC4,	"if (!CopyComponent (s, d))",	0);
	create_insn	(0XBFC4);
	set_cmt	(0XBFC7,	"return (-1);",	0);
	set_cmt	(0XBFC9,	"'.' + (0 SHL 8)",	0);
	set_cmt	(0XBFCF,	"'..'",	0);
	set_cmt	(0XBFD6,	"d--;",	0);
	set_cmt	(0XBFD7,	"SkipBack ();",	0);
	set_cmt	(0XBFDA,	"error_path_not_found",	0);
	set_cmt	(0XBFE0,	"else\n   d += ct;",	0);
	create_insn	(0XBFE0);
	set_cmt	(0XBFE5,	"something else...",	0);
	set_cmt	(0XBFE7,	"get the char",	0);
	set_cmt	(0XBFE8,	"is it path char?",	0);
	set_cmt	(0XBFEB,	"no, go test for nul",	0);
	set_cmt	(0XBFED,	"beyond buffer end?",	0);
	set_cmt	(0XBFEF,	"yep, error.",	0);
	set_cmt	(0XBFF1,	"copy the one byte",	0);
	set_cmt	(0XBFF2,	"get next byte",	0);
	set_cmt	(0XBFF3,	"path char again?",	0);
	set_cmt	(0XBFF6,	"yep, grab another",	0);
	set_cmt	(0XBFF8,	"back up",	0);
	set_cmt	(0XBFF9,	"go copy component",	0);
	set_cmt	(0XBFFB,	"determine if char is a path separator",	0);
	create_insn	(0XBFFB);
	set_name	(0XBFFB,	"PathSep");
	set_cmt	(0XBFFD,	"test for zero",	0);
	create_insn	(0XBFFD);
	set_name	(0XBFFD,	"PathSepGotCh");
	set_cmt	(0XBFFF,	"return if equal to zero (NUL)",	0);
	set_cmt	(0XC001,	"check for path character",	0);
	set_cmt	(0XC004,	"and return HIS determination",	0);
	set_cmt	(0XC005,	"while (TRUE) {",	0);
	create_insn	(0XC005);
	set_name	(0XC005,	"SkipBack");
	set_cmt	(0XC007,	"if (d < dlim)",	0);
	set_cmt	(0XC009,	"goto err;",	0);
	set_cmt	(0XC00A,	"if (pathchr (*--d))",	0);
	set_cmt	(0XC00D,	"break;",	0);
	set_cmt	(0XC012,	"return (0);",	0);
	set_cmt	(0XC014,	"error_path_not_found ; bad path error",	0);
	create_insn	(0XC014);
	set_cmt	(0XC016,	"return (-1);",	0);
	set_cmt	(0XC018,	"room for temp buffer",	0);
	create_insn	(x=0XC018);
	op_dec		(x,	1);
	set_name	(0XC018,	"CopyComponent");
	set_cmt	(0XC026,	"if ((*d++=*s++) == '.') {",	0);
	set_cmt	(0XC02A,	"if (!pathsep(*s))",	0);
	set_cmt	(0XC02F,	"if ((*d++=*s++) != '.'",	0);
	set_cmt	(0XC038,	"|| !pathsep (*s))\nreturn -1;",	0);
	set_cmt	(0XC03A,	"*d++ = 0;",	0);
	set_name	(0XC03A,	"NulTerm");
	set_cmt	(0XC03D,	"CopySoff",	0);
	set_cmt	(0XC040,	"    }",	0);
	set_cmt	(0XC042,	"CopySoff\nelse {",	0);
	create_insn	(0XC042);
	set_name	(0XC042,	"NormalComp");
	set_cmt	(0XC045,	"s = NameTrans (s, Name1);",	0);
	set_cmt	(0XC048,	"CopySoff",	0);
	set_cmt	(0XC04B,	"if (s == CopySOff)\n   return (-1);",	0);
	set_cmt	(0XC04D,	"if (!fSharing) {",	0);
	create_insn	(x=0XC04D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC055);
	op_hex		(x,	1);
	set_cmt	(0XC058,	"cMeta += fMeta;",	0);
	create_insn	(x=0XC058);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC05D,	"if (cMeta > 0)\n  return (-1);",	0);
	set_cmt	(0XC061,	"else\n  if (cMeta == 0 && fMeta == 0",	0);
	set_cmt	(0XC063,	"return (-1);",	0);
	set_cmt	(0XC065,	"CopySoff",	0);
	set_name	(0XC065,	"DoPack");
	create_insn	(x=0XC06A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC06D,	"CopyTemp",	0);
	create_insn	(x=0XC06D);
	op_dec		(x,	1);
	set_cmt	(0XC071,	"PackName (Name1, temp);",	0);
	set_cmt	(0XC075,	"if (strlen(temp)+d > bp)",	0);
	set_cmt	(0XC079,	"CopyDoff",	0);
	set_cmt	(0XC07C,	"CopyB",	0);
	create_insn	(x=0XC07C);
	set_cmt	(0XC07F,	"return (-1);",	0);
	set_cmt	(0XC081,	"strcpy (d, temp);",	0);
	set_cmt	(0XC083,	"CopyD",	0);
	set_cmt	(0XC086,	"  }",	0);
	set_name	(0XC089,	"_GoodRet");
	set_cmt	(0XC08A,	"return 0;",	0);
	create_insn	(0XC08C);
	set_name	(0XC08C,	"CopyBad");
	set_cmt	(0XC08D,	"check for path chars in rest of string",	0);
	set_cmt	(0XC090,	"error_file_not_found",	0);
	set_name	(0XC094,	"CopyBadPath");
	set_cmt	(0XC095,	"error_path_not_found",	0);
	set_name	(0XC097,	"CopyEnd");
	set_cmt	(0XC09D,	"reclaim temp buffer",	0);
	create_insn	(x=0XC09D);
	op_dec		(x,	1);
	set_cmt	(0XC0A6,	"pseudo mount by string substitution",	0);
	create_insn	(x=0XC0A6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0XC0A6,	"Splice");
	create_insn	(x=0XC0AE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC0B3,	"TmpCDS = ThisCDS",	0);
	create_insn	(x=0XC0B3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC0BC,	"for (i=1; s = GetCDSFromDrv (i); i++)",	0);
	set_cmt	(0XC0C5,	"[SI+curdir.flags],curdir_splice",	0);
	create_insn	(x=0XC0C5);
	op_hex		(x,	1);
	set_cmt	(0XC0CC,	"if ( Spliced (i) ) {",	0);
	set_cmt	(0XC0CD,	"if (!PathPref (s, d))",	0);
	set_cmt	(0XC0D3,	"continue;",	0);
	set_cmt	(0XC0D5,	"if (*s || NoSetDir) {",	0);
	create_insn	(0XC0D5);
	create_insn	(x=0XC0DB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XC0E3,	"p = src + strlen (p);",	0);
	set_cmt	(0XC0E8,	"src = TextFromDrive1(src,i);",	0);
	create_insn	(x=0XC0EB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC0F3,	"curdirend += src-p;",	0);
	create_insn	(x=0XC0F7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC0FB,	"if (*p)",	0);
	set_cmt	(0XC0FE,	"*src++ = '\\\\';",	0);
	set_cmt	(0XC103,	"strcpy (src, p);",	0);
	set_cmt	(0XC106,	"throw away saved stuff",	0);
	create_insn	(x=0XC106);
	op_hex		(x,	1);
	set_cmt	(0XC109,	"signal splice done.",	0);
	create_insn	(x=0XC109);
	op_hex		(x,	1);
	set_cmt	(0XC10C,	"return;",	0);
	set_cmt	(0XC10E,	" }",	0);
	create_insn	(x=0XC10E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC113,	"ThisCDS = TmpCDS;",	0);
	create_insn	(x=0XC113);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC11A,	"ThisDPB = ThisCDS->devptr;",	0);
	create_insn	(x=0XC11A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC11F,	"[SI+curdir.devptr]",	0);
	create_insn	(x=0XC122);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC127);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC12C,	"Splice_retn");
	set_cmt	(0XC12D,	"partially process a name",	0);
	create_insn	(0XC12D);
	set_name	(0XC12D,	"$NameTrans");
	set_cmt	(0XC130,	"DS:SI - source string for translation\nES:DI - pointer to buffer",	0);
	set_cmt	(0XC134,	"attr_hidden+attr_system+attr_directory",	0);
	create_insn	(x=0XC137);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC13A,	"to translation (everything)",	0);
	create_insn	(x=0XC147);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XC147,	"TransOK");
	set_cmt	(0XC152,	"0 ; return drive number from a text string",	0);
	create_insn	(0XC152);
	set_name	(0XC152,	"DriveFromText");
	set_cmt	(0XC160,	"convert to lowercase",	0);
	create_insn	(x=0XC160);
	op_hex		(x,	1);
	set_cmt	(0XC162,	"'a'-1",	0);
	create_insn	(x=0XC162);
	op_hex		(x,	1);
	set_cmt	(0XC164,	"al = drv number",	0);
	set_cmt	(0XC166,	"nuke AL...",	0);
	set_cmt	(0XC168,	"AL has drive number",	0);
	set_cmt	(0XC169,	"convert a drive number to a text string",	0);
	create_insn	(0XC169);
	set_name	(0XC169,	"TextFromDrive");
	set_cmt	(0XC16B,	"'A'-1 ; *d++ = drive-1+'A';",	0);
	set_name	(0XC16B,	"TextFromDrive1");
	set_cmt	(0XC16D,	"strcat (d, \":\");",	0);
	set_name	(0XC170,	"PathPref_retn");
	set_cmt	(0XC171,	"see if one path is a prefix of another",	0);
	create_insn	(0XC171);
	set_name	(0XC171,	"PathPref");
	set_cmt	(0XC174,	"get length\ndo not include nul byte",	0);
	set_cmt	(0XC175,	"compare",	0);
	set_cmt	(0XC177,	"return NZ",	0);
	set_cmt	(0XC17A,	"get last byte to match",	0);
	set_cmt	(0XC17D,	"is it a path char (Root!)",	0);
	set_cmt	(0XC180,	"yes, match root (I hope)",	0);
	set_cmt	(0XC182,	"get next char to match",	0);
	set_cmt	(0XC185,	"was it a pathchar?",	0);
	set_cmt	(0XC189,	"(if) Zero flag set => prefix found",	0);
	set_cmt	(0XC18A,	"fetch a character",	0);
	create_insn	(0XC18A);
	set_name	(0XC18A,	"ScanPathChar");
	set_cmt	(0XC18E,	"not \\, / or NUL => go back for more",	0);
	set_cmt	(0XC190,	"path separator?",	0);
	set_cmt	(0XC194,	"General file open/create code",	0);
	create_insn	(0XC194);
	set_name	(0XC194,	"$OPEN");
	set_cmt	(0XC196,	"attr_hidden+attr_system+attr_directory",	0);
	set_name	(0XC196,	"$Open2");
	create_insn	(x=0XC19B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC19F,	"call ECritSFT",	0);
	set_name	(0XC19F,	"AccessFile");
	set_cmt	(0XC1A2,	"get a free sfn",	0);
	set_cmt	(0XC1A5,	"call LCritSFT",	0);
	set_cmt	(0XC1A8,	"oops, no free sft's",	0);
	create_insn	(x=0XC1AA);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC1AF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC1B4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC1B9,	"get a free jfn",	0);
	set_name	(0XC1BC,	"OpenFailJ");
	set_cmt	(0XC1BE,	"there were free JFNs... try SFN",	0);
	create_insn	(x=0XC1BE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC1BE,	"SaveJFN");
	create_insn	(x=0XC1C3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC1C8);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC1CD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC1D2,	"get name in appropriate place",	0);
	set_cmt	(0XC1D4,	"assign the JFN",	0);
	create_insn	(x=0XC1D7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC1DB,	"convert the path",	0);
	create_insn	(x=0XC1DF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XC1E6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC1EC,	"no error, go and open file",	0);
	set_cmt	(0XC1EE,	"error_file_not_found\nno meta chars allowed",	0);
	create_insn	(0XC1F2);
	set_cmt	(0XC1F3,	"Clean stack",	0);
	set_cmt	(0XC1F6,	"Mode (Open), Attributes (Create)",	0);
	create_insn	(0XC1F6);
	set_cmt	(0XC1F7,	"0",	0);
	create_insn	(x=0XC1F9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC1FD,	"[SI+SF_ENTRY.sf_mode],0\ninitialize mode field to 0",	0);
	set_cmt	(0XC200,	"[SI+SF_ENTRY.sf_MFT],0\nclean out sharing info",	0);
	set_cmt	(0XC205,	"SHARING_NO_INHERIT",	0);
	create_insn	(x=0XC205);
	op_hex		(x,	1);
	set_cmt	(0XC209,	"mask off inherit bit",	0);
	create_insn	(x=0XC209);
	op_hex		(x,	1);
	set_cmt	(0XC20B,	"sf_no_inherit",	0);
	set_cmt	(0XC213,	"(es:di) = SFT address",	0);
	set_cmt	(0XC21C,	"DOS_OPEN (or DOS_CREATE)",	0);
	create_insn	(x=0XC21F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC223,	"check extended open hooks first",	0);
	set_cmt	(0XC225,	"SF_ENTRY.sf_ref_count",	0);
	set_cmt	(0XC229,	"SF_ENTRY.sf_flags",	0);
	set_cmt	(0XC230,	"set SFT-FCB entry \nin the internal (SFT_FCB) table\n(used for FCB calls only!)",	0);
	create_insn	(x=0XC233);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC237,	"Call far [ss:JShare+(12*4)] ; 12 = ShCol",	0);
	create_insn	(x=0XC237);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC23C,	"-1 ; clear out sfn pointer",	0);
	create_insn	(x=0XC23C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC243,	"bye with no errors",	0);
	set_cmt	(0XC246,	"error_invalid_parameter\n(Extended Open hooks check)",	0);
	create_insn	(x=0XC246);
	op_dec		(x,	1);
	set_cmt	(0XC249,	"(not IFS extended open)",	0);
	set_cmt	(0XC24B,	"keep handle",	0);
	set_cmt	(0XC24D,	"clean off stack",	0);
	create_insn	(0XC24D);
	set_cmt	(0XC24E,	"[SI+SF_ENTRY.sf_ref_count],0\nrelease SFT",	0);
	create_insn	(x=0XC252);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC257,	"free the SFN...",	0);
	set_cmt	(0XC25A,	"-1 ; remove mark.",	0);
	create_insn	(x=0XC25A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC261,	"error_Code_Page_Mismatched",	0);
	create_insn	(x=0XC261);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_dec		(x,	1);
	create_insn	(0XC26C);
	set_name	(0XC26C,	"NORERR");
	set_cmt	(0XC26F,	"create a new file and open him for input",	0);
	create_insn	(0XC26F);
	set_name	(0XC26F,	"$CREAT");
	create_insn	(x=0XC270);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC273,	"attr_hidden+attr_system",	0);
	create_insn	(x=0XC273);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC27C,	"MS-DOS 7.20 (Win98) - EXTENDED-LENGTH FILENAME OPERATIONS\nAX = 43FFh\nBP = 5053h ('PS')\nCL = function\n39h \"mkdir\" create directory\nDS:DX -> ASCIZ pathname\n56h rename file\nDS:DX -> ASCIZ filename of existing file (no wildcards)\nES:DI -> ASCIZ new filename (no wildcards)\n\nref: Ralf Brown's Interrupt List",	0);
	create_insn	(0XC27C);
	set_name	(0XC27C,	"$CHMOD");
	set_cmt	(0XC288,	"((mov byte [ss:PATHNAMELEN],128)) ; Retro DOS v5.0",	0);
	create_insn	(x=0XC288);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_dec		(x,	1);
	create_insn	(x=0XC28F);
	op_hex		(x,	1);
	create_insn	(x=0XC297);
	op_hex		(x,	1);
	set_name	(0XC297,	"chmod_x_1");
	set_name	(0XC29C,	"chmod_x_2");
	create_insn	(x=0XC2A0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XC2A0,	"std_chmod");
	set_cmt	(0XC2A7,	"get correct path",	0);
	set_cmt	(0XC2AE,	"ChModErr",	0);
	set_cmt	(0XC2B0,	"-1",	0);
	create_insn	(x=0XC2B0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC2B7,	"attr_hidden+attr_system+attr_directory",	0);
	create_insn	(x=0XC2B7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC2BC,	"fast way to discriminate",	0);
	set_cmt	(0XC2BE,	"0 -> go get value",	0);
	set_cmt	(0XC2C0,	"1 -> go set value",	0);
	set_cmt	(0XC2C5,	"error_invalid_function ; bad value",	0);
	set_name	(0XC2C7,	"chmod_errj");
	set_cmt	(0XC2C9,	"suck out the ol' info",	0);
	create_insn	(0XC2C9);
	set_name	(0XC2C9,	"ChModGet");
	set_cmt	(0XC2CC,	"error codes are already set for ret",	0);
	set_cmt	(0XC2D1,	"[SI+user_env.user_CX]\nreturn the attributes",	0);
	set_name	(0XC2D4,	"OpenOkj");
	set_cmt	(0XC2D7,	"get attrs in position",	0);
	create_insn	(0XC2D7);
	set_name	(0XC2D7,	"ChModSet");
	set_cmt	(0XC2E0,	"error_path_not_found",	0);
	create_insn	(0XC2E0);
	set_name	(0XC2E0,	"NotFound");
	set_name	(0XC2E2,	"ChModE");
	set_cmt	(0XC2E4,	"Delete a File",	0);
	create_insn	(0XC2E4);
	set_name	(0XC2E4,	"$UNLINK");
	set_cmt	(0XC2E5,	"Point at input string",	0);
	set_cmt	(0XC2E7,	"temp spot for path",	0);
	create_insn	(x=0XC2E7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC2EA,	"go get normalized path",	0);
	set_cmt	(0XC2ED,	"search attributes",	0);
	set_cmt	(0XC2EE,	"badly formed path",	0);
	set_cmt	(0XC2F0,	"-1 ; meta chars?",	0);
	create_insn	(x=0XC2F0);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC2FA,	"attr_hidden+attr_system\nunlink appropriate files",	0);
	set_cmt	(0XC2FF,	"remove that file",	0);
	set_name	(0XC302,	"UnlinkE");
	set_name	(0XC304,	"UnLinkOK");
	create_insn	(x=0XC306);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_dec		(x,	1);
	set_name	(0XC306,	"$RENAME");
	set_cmt	(0XC30D,	"cx = search attributes",	0);
	set_name	(0XC30D,	"rename_x");
	set_cmt	(0XC30F,	"DS:DX = source",	0);
	set_cmt	(0XC311,	"ES:DI = destination",	0);
	set_cmt	(0XC312,	"move dest to source",	0);
	create_insn	(x=0XC314);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC317,	"munge the paths",	0);
	set_cmt	(0XC31A,	"get pointer",	0);
	create_insn	(x=0XC31A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC31F,	"stash it",	0);
	create_insn	(x=0XC31F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC327,	"get old error",	0);
	set_name	(0XC327,	"epjc2");
	set_cmt	(0XC329,	"-1",	0);
	create_insn	(x=0XC329);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC332,	"appropriate buffer",	0);
	create_insn	(x=0XC332);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC33D,	"-1",	0);
	create_insn	(x=0XC33D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC344);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XC34A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC34E,	"es:di-> source",	0);
	set_cmt	(0XC34F,	"scan all CDS",	0);
	set_name	(0XC351,	"rnloop");
	set_cmt	(0XC354,	"end of CDS",	0);
	set_cmt	(0XC356,	"current dir ?",	0);
	set_cmt	(0XC359,	"yes",	0);
	set_cmt	(0XC35B,	"next",	0);
	set_cmt	(0XC35F,	"ADD SP,4",	0);
	create_insn	(0XC35F);
	set_name	(0XC35F,	"rnerr");
	set_cmt	(0XC361,	"error_current_directory",	0);
	create_insn	(x=0XC361);
	op_dec		(x,	1);
	create_insn	(x=0XC366);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC366,	"dorn");
	create_insn	(x=0XC36B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC372,	"attr_directory+attr_hidden+attr_system",	0);
	set_cmt	(0XC377,	"do the deed",	0);
	set_cmt	(0XC37E,	"Save attributes on stack",	0);
	create_insn	(0XC37E);
	set_name	(0XC37E,	"$CreateNewFile");
	set_cmt	(0XC37F,	"routine to call",	0);
	create_insn	(x=0XC37F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC382,	"use good ol' open",	0);
	set_cmt	(0XC385,	"convert a number to a string\n(in order to generate temp file names)\nax = value",	0);
	create_insn	(0XC385);
	set_name	(0XC385,	"BinToAscii");
	set_cmt	(0XC388,	"AH = AL / 16 and AL = remainder",	0);
	set_cmt	(0XC38A,	"'AA'",	0);
	set_cmt	(0XC38F,	"db 0D4h,10h",	0);
	set_cmt	(0XC391,	"add ax,'AA'",	0);
	set_cmt	(0XC396,	"create a unique name",	0);
	create_insn	(0XC396);
	set_name	(0XC396,	"$CreateTempFile");
	create_insn	(x=0XC399);
	op_dec		(x,	1);
	set_cmt	(0XC39C,	"~attr_changeable",	0);
	create_insn	(x=0XC39C);
	op_hex		(x,	1);
	set_cmt	(0XC3A0,	"Ok if no non-changeable bits set",	0);
	set_cmt	(0XC3A2,	"error_access_denied",	0);
	set_cmt	(0XC3A7,	"attr",	0);
	create_insn	(x=0XC3A7);
	op_dec		(x,	0);
	set_name	(0XC3A7,	"OKatts");
	set_cmt	(0XC3AA,	"FilPtrL ; pointer to file",	0);
	set_cmt	(0XC3AD,	"FilPtrH",	0);
	set_cmt	(0XC3B0,	"EndPtrH ; seg pointer to end of dir",	0);
	set_cmt	(0XC3B4,	"destination for nul search",	0);
	set_cmt	(0XC3B9,	"number of bytes remaining in segment",	0);
	set_cmt	(0XC3BF,	"-1",	0);
	set_name	(0XC3C0,	"okok");
	set_cmt	(0XC3C4,	"point back to the null",	0);
	set_cmt	(0XC3C5,	"Get char before the NUL",	0);
	set_cmt	(0XC3C9,	"Is it a path separator?",	0);
	set_cmt	(0XC3CC,	"Yes",	0);
	set_cmt	(0XC3D0,	"Add a path separator (and INC DI)",	0);
	set_cmt	(0XC3D1,	"EndPtrL ; pointer to the tail",	0);
	set_name	(0XC3D1,	"SETENDPTR");
	set_cmt	(0XC3D4,	"let ReadTime see variables",	0);
	set_name	(0XC3D4,	"CreateLoop");
	set_cmt	(0XC3D7,	"go get time",	0);
	set_cmt	(0XC3DB,	"EndPtr ; point to the string",	0);
	set_cmt	(0XC3E0,	"store upper word",	0);
	set_cmt	(0XC3E5,	"store lower word",	0);
	set_cmt	(0XC3EA,	"nul terminate",	0);
	set_cmt	(0XC3EB,	"FilPtr ; get name",	0);
	set_cmt	(0XC3EE,	"Attr ; get attr",	0);
	create_insn	(x=0XC3EE);
	op_dec		(x,	1);
	set_cmt	(0XC3F2,	"try to create a new file",	0);
	set_cmt	(0XC3F6,	"failed, go try again",	0);
	set_cmt	(0XC3F8,	"error_file_exists",	0);
	create_insn	(x=0XC3F8);
	op_hex		(x,	1);
	set_cmt	(0XC3FC,	"error_access_denied",	0);
	create_insn	(x=0XC400);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC404,	"error_net_access_denied",	0);
	create_insn	(x=0XC404);
	op_hex		(x,	1);
	set_cmt	(0XC408,	"error_FAIL_I24",	0);
	create_insn	(x=0XC408);
	op_hex		(x,	1);
	set_cmt	(0XC40C,	"error_file_exists",	0);
	create_insn	(x=0XC40C);
	op_hex		(x,	1);
	create_insn	(x=0XC410);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XC41A);
	op_hex		(x,	1);
	set_name	(0XC422,	"SETTMPERR");
	set_name	(0XC423,	"CreateDone");
	set_cmt	(0XC428,	"success!",	0);
	create_insn	(0XC42B);
	set_name	(0XC42B,	"CreateFail");
	set_cmt	(0XC42E,	"fSharing == FALSE => set sattrib to CH\nfSharing == TRUE => set sattrib to CL",	0);
	create_insn	(x=0XC42E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC42E,	"SetAttrib");
	create_insn	(x=0XC438);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC43E,	"save ext. open flag",	0);
	create_insn	(x=0XC43E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC43E,	"$Extended_Open");
	set_cmt	(0XC443,	"initialize IO mode",	0);
	create_insn	(x=0XC443);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC44A,	"RESERVED_BITS_MASK>>8\nreserved bits 0 ?",	0);
	create_insn	(x=0XC44A);
	op_hex		(x,	1);
	set_cmt	(0XC44D,	"no",	0);
	set_cmt	(0XC451,	"all fail ?",	0);
	set_cmt	(0XC454,	"yes, error",	0);
	set_cmt	(0XC456,	"EXISTS_MASK ; get exists action byte",	0);
	create_insn	(x=0XC456);
	op_hex		(x,	1);
	set_cmt	(0XC45E,	"NOT_EXISTS_MASK ; get no exists action byte",	0);
	create_insn	(x=0XC45E);
	op_hex		(x,	1);
	set_cmt	(0XC466,	"save API parms",	0);
	create_insn	(x=0XC466);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC46B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC470);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC475);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC47A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC47F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC484);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC489);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC48E,	"ds:dx points to file name",	0);
	set_cmt	(0XC490,	"ax= mode",	0);
	set_cmt	(0XC494,	"error_invalid_function ; invalid function",	0);
	create_insn	(0XC494);
	set_name	(0XC494,	"ext_inval2");
	set_cmt	(0XC498,	"INT_24_ERROR>>8",	0);
	create_insn	(x=0XC498);
	op_hex		(x,	1);
	set_name	(0XC498,	"goopen2");
	set_cmt	(0XC49D,	"EXT_OPEN_I24_OFF ; set bit to disable",	0);
	create_insn	(x=0XC49D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XC4A3,	"EXT_OPEN_ON ; set Extended Open active",	0);
	create_insn	(x=0XC4A3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0XC4A3,	"goopen");
	create_insn	(x=0XC4A9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC4AF,	"EXT_EXISTS_FAIL+EXT_NEXISTS_CREATE",	0);
	create_insn	(x=0XC4AF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC4BC);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC4C4,	"ACTION_CREATED_OPENED",	0);
	create_insn	(x=0XC4C4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XC4CE);
	set_name	(0XC4CE,	"ok_return2");
	set_cmt	(0XC4D1,	"EXT_EXISTS_OPEN",	0);
	create_insn	(x=0XC4D1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0XC4D1,	"chknext");
	set_cmt	(0XC4D7,	"must be replace open",	0);
	create_insn	(x=0XC4DE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC4E6,	"ACTION_CREATED_OPENED",	0);
	create_insn	(x=0XC4E6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC4ED,	"EXT_FILE_NOT_EXISTS",	0);
	create_insn	(x=0XC4ED);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XC4F5,	"ACTION_REPLACED_OPENED",	0);
	create_insn	(x=0XC4F5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XC4FE);
	set_name	(0XC4FE,	"error_return2");
	set_name	(0XC4FF,	"error_return");
	set_cmt	(0XC500,	"server doscall?",	0);
	create_insn	(x=0XC500);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC500,	"exist_open");
	set_cmt	(0XC506,	"no",	0);
	set_cmt	(0XC508,	"cl=search attribute",	0);
	set_name	(0XC50A,	"noserver");
	create_insn	(x=0XC50F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC517,	"error_file_not_found",	0);
	set_cmt	(0XC51C,	"EXT_NEXISTS_CREATE",	0);
	create_insn	(x=0XC51C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_name	(0XC525,	"extexit");
	set_cmt	(0XC528,	"get ds:dx for file name",	0);
	create_insn	(x=0XC528);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XC528,	"do_creat");
	set_cmt	(0XC52D,	"cx = attribute;",	0);
	create_insn	(x=0XC52D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC534,	"do create",	0);
	set_cmt	(0XC539,	"ACTION_CREATED_OPENED",	0);
	create_insn	(x=0XC539);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC540,	"set XAs",	0);
	set_cmt	(0XC542,	"IFS call ?",	0);
	create_insn	(x=0XC542);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC542,	"ext_ok");
	set_cmt	(0XC548,	"yes",	0);
	set_cmt	(0XC54A,	"ACTION_OPENED",	0);
	create_insn	(x=0XC54A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC551,	"setXAttr");
	create_insn	(x=0XC555);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC559,	"[SI+user_env.user_CX] ; set action code for cx",	0);
	set_cmt	(0XC55D,	"[SI+user_env.user_AX] ; set handle for ax",	0);
	set_name	(0XC55F,	"ok_return");
	set_cmt	(0XC562,	"Lock Calls",	0);
	create_insn	(0XC562);
	set_name	(0XC562,	"$LockOper");
	set_cmt	(0XC56D,	"error_invalid_handle",	0);
	set_name	(0XC56F,	"lockoperr");
	set_cmt	(0XC572,	"mov byte [SS:EXTERR_LOCUS],errLOC_Unk",	0);
	create_insn	(0XC572);
	set_name	(0XC572,	"lock_bad_func");
	set_cmt	(0XC575,	"error_invalid_function",	0);
	set_name	(0XC577,	"lockoperrj");
	create_insn	(0XC579);
	set_name	(0XC579,	"lock_do");
	create_insn	(x=0XC57B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC57E,	"[bp+LockBuf.Lock_position] ; set low offset",	0);
	set_cmt	(0XC581,	"[bp+LockBuf.Lock_position+2] ; set high offset",	0);
	set_cmt	(0XC584,	"[bp+LockBuf.Lock_length] ; set low length",	0);
	set_cmt	(0XC587,	"[bp+LockBuf.Lock_length+2] ; set high length",	0);
	set_cmt	(0XC58A,	"one range",	0);
	set_cmt	(0XC591,	"UNLOCK_ALL ; function 1 ?",	0);
	create_insn	(x=0XC591);
	op_hex		(x,	1);
	set_cmt	(0XC593,	"yes",	0);
	set_cmt	(0XC595,	"function 0",	0);
	set_cmt	(0XC597,	"[ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)",	0);
	create_insn	(x=0XC597);
	op_hex		(x,	1);
	set_name	(0XC597,	"DOS_Unlock");
	set_cmt	(0XC5A1,	"Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE\nBX = file handle, CX:DX = starting offset, SI = high word of size\nSTACK: WORD low word of size, ES:DI -> SFT\nSFT DPB field -> DPB of drive containing file, SS = DOS CS\nReturn: CF set error",	0);
	create_insn	(x=0XC5A1);
	op_hex		(x,	0);
	set_cmt	(0XC5A5,	"Call far [JShare+(7*4)] ; 7 = clr_block",	0);
	create_insn	(x=0XC5A5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC5A5,	"LOCAL_UNLOCK");
	set_name	(0XC5A9,	"ValChk");
	create_insn	(x=0XC5AD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XC5AD,	"Lock_OK");
	set_cmt	(0XC5B3,	"[ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)",	0);
	create_insn	(x=0XC5B3);
	op_hex		(x,	1);
	set_name	(0XC5B3,	"DOS_Lock");
	set_cmt	(0XC5BD,	"Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE\nBX = file handle, CX:DX = starting offset, SI = high word of size\nSTACK: WORD low word of size, ES:DI -> SFT\nSFT DPB field -> DPB of drive containing file, SS = DOS CS\nReturn: CF set error",	0);
	create_insn	(x=0XC5BD);
	op_hex		(x,	0);
	set_cmt	(0XC5C1,	"Call far [JShare+(6*4)] ; 6 = Set_Block",	0);
	create_insn	(x=0XC5C1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC5C1,	"LOCAL_LOCK");
	set_cmt	(0XC5C7,	"Number retries",	0);
	create_insn	(x=0XC5C7);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XC5C7,	"LOCK_CHECK");
	set_cmt	(0XC5CD,	"call far [JShare+(8*4)] ; 8 = chk_block",	0);
	create_insn	(x=0XC5CD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC5D3,	"There are no locks (retnc)",	0);
	set_cmt	(0XC5D5,	"wait a while",	0);
	set_cmt	(0XC5D8,	"remember a retry",	0);
	set_cmt	(0XC5D9,	"more retries left...",	0);
	set_name	(0XC5DC,	"lc_ret_label");
	create_insn	(0XC5DD);
	set_name	(0XC5DD,	"LOCK_VIOLATION");
	set_cmt	(0XC5E1,	"error_lock_violation",	0);
	create_insn	(x=0XC5E1);
	op_hex		(x,	1);
	set_cmt	(0XC5E4,	"Allowed_FAIL+Allowed_RETRY",	0);
	create_insn	(x=0XC5E4);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC5E9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC5ED,	"Fake some registers",	0);
	set_cmt	(0XC5F2,	"0",	0);
	set_cmt	(0XC5F4,	"cmp [es:bp+DPB.FAT_SIZE],dx",	0);
	set_cmt	(0XC5F8,	"not FAT32",	0);
	set_cmt	(0XC5FA,	"[es:bp+DPB.FCLUS_FSECTOR+2]",	0);
	create_insn	(x=0XC5FE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC602,	"[es:bp+DPB.FCLUS_FSECTOR]",	0);
	set_cmt	(0XC608,	"0",	0);
	create_insn	(x=0XC608);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC60C,	"[ES:BP+DPB.FIRST_SECTOR]",	0);
	set_cmt	(0XC619,	"1 = retry, carry clear",	0);
	create_insn	(0XC61D);
	set_name	(0XC61D,	"CheckShare");
	create_insn	(x=0XC623);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC62A,	"call far [JShare+(1*4)] ; 1 = MFT_Enter",	0);
	create_insn	(x=0XC62A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC62A,	"SHARE_CHECK");
	set_name	(0XC62E,	"shchk_retn");
	create_insn	(0XC62F);
	set_name	(0XC62F,	"SHARE_VIOLATION");
	set_cmt	(0XC632,	"All share errors are reading",	0);
	create_insn	(x=0XC632);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC637,	"Allowed_FAIL+Allowed_RETRY",	0);
	create_insn	(x=0XC637);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC63C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC640,	"Fake some registers",	0);
	set_cmt	(0XC645,	"[es:bp+DPB.FAT_SIZE]",	0);
	set_cmt	(0XC64A,	"FAT32",	0);
	create_insn	(x=0XC64C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC652,	"[ES:BP+DPB.DIR_SECTOR]",	0);
	set_cmt	(0XC658,	"[es:bp+DPB.FCLUS_FSECTOR+2]",	0);
	create_insn	(0XC658);
	create_insn	(x=0XC65C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC660,	"[es:bp+DPB.FCLUS_FSECTOR]",	0);
	set_cmt	(0XC66C,	"1 = retry, carry clear",	0);
	set_cmt	(0XC670,	"call far [JShare+(2*4)] ; 2 = MFTClose",	0);
	create_insn	(x=0XC670);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC670,	"ShareEnd");
	create_insn	(0XC675);
	set_name	(0XC675,	"ShareEnter");
	create_insn	(x=0XC676);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XC67A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC681,	"[ES:DI+SF_ENTRY.sf_MFT],0 ; indicate free SFT",	0);
	set_cmt	(0XC685,	"attempt to enter into the sharing set",	0);
	set_cmt	(0XC689,	"success, let the user see this",	0);
	set_cmt	(0XC68B,	"wait a while",	0);
	set_cmt	(0XC68E,	"go back for another attempt",	0);
	set_cmt	(0XC690,	"signal the problem to the user",	0);
	set_cmt	(0XC693,	"user said to retry, go do it",	0);
	create_insn	(0XC697);
	set_name	(0XC697,	"ExecReady");
	set_cmt	(0XC699,	"[si+ERStruc.ER_Flags],ER_EXE",	0);
	create_insn	(x=0XC699);
	op_hex		(x,	1);
	set_cmt	(0XC6A0,	"[si+ERStruc.ER_PSP]",	0);
	set_cmt	(0XC6A8,	"[si+ERStruc.ER_StartAddr]",	0);
	set_cmt	(0XC6AB,	"[si+ERStruc.ER_StartAddr+2]",	0);
	create_insn	(x=0XC6AE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XC6B3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC6B8,	"[si+ERStruc.ER_Flags],ER_OVERLAY",	0);
	create_insn	(x=0XC6B8);
	op_hex		(x,	1);
	set_cmt	(0XC6BD,	"Y: set A20OFF_COUNT if DOS high\nN: set up lie version first",	0);
	set_cmt	(0XC6C1,	"[si+ERStruc.ER_ProgName]",	0);
	set_cmt	(0XC6CC,	"[si+ERStruc.ER_PSP]",	0);
	create_insn	(x=0XC6CF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC6D3,	"[es:PDB.Version]",	0);
	create_insn	(x=0XC6D7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC6DF,	"[si+ERStruc.ER_PSP] ; ax = PSP",	0);
	set_cmt	(0XC6E2,	"EXECA20OFF",	0);
	create_insn	(x=0XC6E2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_hex		(x,	1);
	set_cmt	(0XC6E8,	"[si+ERStruc.ER_Flags],ER_EXE\nQ: COM file",	0);
	create_insn	(x=0XC6E8);
	op_hex		(x,	1);
	set_cmt	(0XC6ED,	"N: inc a20off_count,\nset a20off_psp and ret",	0);
	set_cmt	(0XC6F0,	"DS = load segment of com file",	0);
	set_cmt	(0XC6F2,	"check if copy protected",	0);
	create_insn	(x=0XC6F6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC6FB,	"set the PSP for which A20 is to be\nturned OFF.",	0);
	create_insn	(x=0XC6FB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC702,	"cli\nin  al, 21h\npusha\nxor ax, ax\nout 43h, al\nmov dx, ...",	0);
	create_byte	(0XC702);
	make_array	(0XC702,	0XA);
	set_name	(0XC702,	"rpFind1");
	set_cmt	(0XC70C,	"mov al, 0Eh\nout 37h, al\nxor ax, ax\nout 0F2h, al",	0);
	create_byte	(0XC70C);
	make_array	(0XC70C,	0X8);
	set_name	(0XC70C,	"rpFind1a");
	set_cmt	(0XC714,	"mov eax, cr0",	0);
	create_byte	(0XC714);
	make_array	(0XC714,	0X3);
	set_name	(0XC714,	"rpFind2");
	set_cmt	(0XC717,	"mov cr0, eax\njmp far ptr xxx \nmov ss, bx",	0);
	create_byte	(0XC717);
	make_array	(0XC717,	0X4);
	set_name	(0XC717,	"rpFind3");
	set_cmt	(0XC71B,	"push eax\npush cx\nmov eax, cr0",	0);
	create_byte	(0XC71B);
	make_array	(0XC71B,	0X6);
	set_name	(0XC71B,	"rpRepl2");
	set_cmt	(0XC721,	"mov ss, bx\npop cx\npop eax",	0);
	create_byte	(0XC721);
	make_array	(0XC721,	0X5);
	set_name	(0XC721,	"rpRepl3");
	set_cmt	(0XC726,	"xchg bx, ax\npop ax\nmov cx, sp",	0);
	create_byte	(0XC726);
	make_array	(0XC726,	0X4);
	set_name	(0XC726,	"rpFind4");
	set_cmt	(0XC72A,	"mov ax, DE0Ch\nint 67h\nmov sp, cx\njmp bx",	0);
	create_byte	(0XC72A);
	make_array	(0XC72A,	0X9);
	set_name	(0XC72A,	"rpFind5");
	create_byte	(0XC733);
	make_array	(0XC733,	0X4);
	set_name	(0XC733,	"rpRepl4");
	create_byte	(0XC737);
	make_array	(0XC737,	0X3);
	create_byte	(0XC73A);
	make_array	(0XC73A,	0X2);
	create_byte	(0XC73C);
	make_array	(0XC73C,	0X4);
	set_cmt	(0XC740,	"xchg bx, ax\npop ax\nmov cx, sp\nmov dword ptr cs:[xxxx], eax\nmov dword ptr cs:[xxxx], esi",	0);
	create_byte	(0XC740);
	make_array	(0XC740,	0X2);
	create_byte	(0XC742);
	make_array	(0XC742,	0X2);
	set_name	(0XC742,	"rpRepl5");
	create_byte	(0XC744);
	make_array	(0XC744,	0X3);
	create_byte	(0XC747);
	make_array	(0XC747,	0X2);
	create_byte	(0XC749);
	make_array	(0XC749,	0X4);
	create_byte	(0XC74D);
	make_array	(0XC74D,	0X2);
	set_cmt	(0XC74F,	"mov sp, cx\nmov eax, dword ptr cs:[xxxx]\nmov esi, dword ptr cs:[xxxx]\njmp bx",	0);
	create_byte	(0XC74F);
	make_array	(0XC74F,	0X2);
	set_cmt	(0XC751,	"cli\npush dx\npush cx",	0);
	create_byte	(0XC751);
	make_array	(0XC751,	0X3);
	set_name	(0XC751,	"rpFind6");
	set_cmt	(0XC754,	"mov ax, 0DE0Ch\ncall fword ptr es:[xxxx]",	0);
	create_byte	(0XC754);
	make_array	(0XC754,	0X7);
	set_name	(0XC754,	"rpFind7a");
	set_cmt	(0XC75B,	"pop cx\npop dx\npop bx",	0);
	create_byte	(0XC75B);
	make_array	(0XC75B,	0X3);
	set_name	(0XC75B,	"rpFind7b");
	set_cmt	(0XC75E,	"cli\npush eax\npush ebx\npush ecx\npush edx",	0);
	create_byte	(0XC75E);
	make_array	(0XC75E,	0X9);
	set_name	(0XC75E,	"rpRepl6");
	set_cmt	(0XC767,	"pop edx\npop ecx\npop ebx\npop eax\npop bx",	0);
	create_byte	(0XC767);
	make_array	(0XC767,	0X9);
	set_name	(0XC767,	"rpRepl7");
	set_cmt	(0XC770,	"pusha\npush es\npush ds\nmov ax, dgroup ; jump back to here from replace8\nmov ds, ax",	0);
	create_byte	(0XC770);
	make_array	(0XC770,	0X8);
	set_name	(0XC770,	"rpFind8");
	set_cmt	(0XC778,	"pop ds\npop es\npopa",	0);
	create_byte	(0XC778);
	make_array	(0XC778,	0X3);
	set_name	(0XC778,	"rpFind9");
	set_cmt	(0XC77B,	"pushad\npush es\npush ds",	0);
	create_byte	(0XC77B);
	make_array	(0XC77B,	0X4);
	set_name	(0XC77B,	"rpRepl8");
	set_cmt	(0XC77F,	"pop ds\npop es\npopad\nretn ; no need to jmp back to main-line",	0);
	create_byte	(0XC77F);
	make_array	(0XC77F,	0X5);
	set_name	(0XC77F,	"rpRepl9");
	create_word	(x=0XC784);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC784,	"rpBug1Strs");
	set_cmt	(0XC786,	"rpFind2Len",	0);
	create_word	(0XC786);
	create_word	(x=0XC788);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC78A,	"rpFind3Len",	0);
	create_word	(0XC78A);
	create_word	(0XC78C);
	create_word	(x=0XC78E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC78E,	"rpBug2Strs");
	set_cmt	(0XC790,	"rpFind4Len",	0);
	create_word	(0XC790);
	create_word	(x=0XC792);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC794,	"rpFind5Len",	0);
	create_word	(0XC794);
	create_word	(0XC796);
	create_word	(x=0XC798);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC798,	"rpBug3Strs");
	set_cmt	(0XC79A,	"rpFind6Len",	0);
	create_word	(0XC79A);
	create_word	(x=0XC79C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC79E,	"rpFind7aLen",	0);
	create_word	(0XC79E);
	create_word	(0XC7A0);
	create_word	(x=0XC7A2);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XC7A2,	"rpBug4Strs");
	set_cmt	(0XC7A4,	"rpRepl8Len",	0);
	create_word	(0XC7A4);
	create_word	(x=0XC7A6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XC7A8,	"rpFind9Len",	0);
	create_word	(0XC7A8);
	create_word	(0XC7AA);
	set_cmt	(0XC7AC,	"version number goes here - versions",	0);
	create_insn	(x=0XC7AC);
	op_dec		(x,	1);
	set_name	(0XC7AC,	"Rational386Patch");
	set_cmt	(0XC7B3,	"3.95+ don't need patching",	0);
	set_cmt	(0XC7B5,	" always has this value here",	0);
	set_cmt	(0XC7BE,	"extender has 18h at",	0);
	set_cmt	(0XC7C1,	"offsets 24, 28, & 36",	0);
	create_insn	(x=0XC7C1);
	op_dec		(x,	0);
	create_insn	(x=0XC7C8);
	op_dec		(x,	0);
	create_insn	(x=0XC7CF);
	op_dec		(x,	0);
	set_name	(0XC7D6,	"rp3QO_ax");
	set_name	(0XC7D7,	"rp3QuickOut");
	create_insn	(0XC7D8);
	set_name	(0XC7D8,	"rp3Maybe");
	set_cmt	(0XC7DC,	"StackVars.size ; make space for stack variables",	0);
	create_insn	(x=0XC7DC);
	op_hex		(x,	1);
	set_cmt	(0XC7E7,	"[bp+StackVars.sv_wVersion]",	0);
	set_cmt	(0XC7EA,	"check that binary version # matches\nascii string",	0);
	set_cmt	(0XC7EF,	"force search len to 4700h\n(searches start at offset 200h)",	0);
	set_cmt	(0XC7F2,	"[bp+StackVars.sv_cbCodeSeg]",	0);
	set_cmt	(0XC7F5,	"es=code segment",	0);
	set_cmt	(0XC7FA,	"string to find",	0);
	create_insn	(x=0XC7FA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC7FD,	"rpFind1Len ; length to match",	0);
	create_insn	(x=0XC7FD);
	op_dec		(x,	1);
	set_cmt	(0XC800,	"look for code seq",	0);
	create_insn	(x=0XC805);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC808,	"rpFind1Len",	0);
	set_name	(0XC810,	"rp3Exit_j");
	set_cmt	(0XC813,	"[bp-StackVars.sv_pPatch] ; save patch pointer",	0);
	create_insn	(0XC813);
	set_name	(0XC813,	"rpGotPatch");
	set_cmt	(0XC816,	"BUG 1, [bp+StackVars.sv_wVersion],381 \nonly need bug 1 if version",	0);
	create_insn	(x=0XC816);
	op_dec		(x,	1);
	set_cmt	(0XC81B,	"< 3.81",	0);
	set_cmt	(0XC81D,	"locate find2 & find3 code",	0);
	create_insn	(x=0XC81D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC825,	"rpFind3 offset",	0);
	set_cmt	(0XC826,	"rpFind2 offset",	0);
	set_cmt	(0XC828,	"rpFind2Len",	0);
	set_cmt	(0XC82B,	"find2 preceeded by push cx?",	0);
	create_insn	(x=0XC82B);
	op_hex		(x,	1);
	set_cmt	(0XC832,	"yes, gobble up push cx too",	0);
	set_cmt	(0XC834,	"patch out find2 sequence",	0);
	create_insn	(x=0XC834);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XC834,	"rp_no_cx");
	set_cmt	(0XC837,	"rpRepl2Len",	0);
	set_cmt	(0XC83D,	"rpFind3 offset",	0);
	set_cmt	(0XC83E,	"find3 preceeded by pop cx?",	0);
	create_insn	(x=0XC83E);
	op_hex		(x,	1);
	set_cmt	(0XC845,	"yes, no-op it",	0);
	set_cmt	(0XC84A,	"[bp+StackVars.sv_pPatch] ; change offset of far jmp",	0);
	set_name	(0XC84A,	"rp_no_cx2");
	set_cmt	(0XC84D,	"[es:di+rpFind3Len] ; to go to patch code",	0);
	set_cmt	(0XC852,	"copy repl3 to patch area",	0);
	create_insn	(x=0XC852);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC855,	"rpRepl3Len",	0);
	set_cmt	(0XC85C,	"rpFind3Len+4 ; skip over find3 and far jmp",	0);
	set_cmt	(0XC85F,	"jmp back from patch area",	0);
	set_cmt	(0XC862,	"[bp+StackVars.sv_pPatch]\nto main-line, update patch area pointer",	0);
	set_cmt	(0XC865,	"BUG 2, locate find4 & find5 code",	0);
	create_insn	(x=0XC865);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XC865,	"rpBug2");
	set_cmt	(0XC86D,	"[bp+StackVars.sv_pPatch] ; save current patch pointer",	0);
	set_cmt	(0XC870,	"save find5 offset",	0);
	set_cmt	(0XC871,	"rpFind4 offset",	0);
	set_cmt	(0XC873,	"rpFind4Len",	0);
	create_insn	(x=0XC876);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC879,	"rpRepl4Len",	0);
	create_insn	(x=0XC879);
	op_dec		(x,	1);
	set_cmt	(0XC87C,	"patch out find4 code",	0);
	set_cmt	(0XC87F,	"find5 offset",	0);
	set_cmt	(0XC880,	"keep 5 bytes of find5 code",	0);
	set_cmt	(0XC883,	"[bp+StackVars.sv_pPatch] ; jump to patch area",	0);
	set_cmt	(0XC886,	"save repl5 location",	0);
	set_cmt	(0XC88A,	"copy repl5 code to patch",	0);
	create_insn	(x=0XC88A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC88D,	"rpRepl5Len ; area -- it has a jmp bx",	0);
	create_insn	(x=0XC88D);
	op_dec		(x,	1);
	set_cmt	(0XC890,	"so no need to jmp back to\nmain-line code",	0);
	set_cmt	(0XC893,	"repl5 location",	0);
	set_cmt	(0XC894,	"repl4 location",	0);
	set_cmt	(0XC895,	"[bp+StackVars.sv_pPatch] ; (where dwords go)",	0);
	set_cmt	(0XC898,	"[es:si+rpRepl4o1Len] ; offset for EAX",	0);
	set_cmt	(0XC89C,	"[es:di+rpRepl5o1Len]",	0);
	set_cmt	(0XC8A3,	"[es:si+rpRepl4o2Len] ; offset for ESI",	0);
	set_cmt	(0XC8A7,	"[es:di+rpRepl5o2Len]",	0);
	set_cmt	(0XC8AB,	"[bp+StackVars.sv_pPatch]\nreserve space for 2 dwords in patch area",	0);
	set_cmt	(0XC8AF,	"BUG 3, locate find6 & find7a code",	0);
	create_insn	(x=0XC8AF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XC8AF,	"rpBug3");
	set_cmt	(0XC8B7,	"rpFind7aLen + 2 ; skip over offset in find7a",	0);
	set_cmt	(0XC8BA,	"code and locate find7b sequence",	0);
	create_insn	(x=0XC8BB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC8BE,	"rpFind7bLen",	0);
	set_cmt	(0XC8C7,	"save find7b code offset",	0);
	set_cmt	(0XC8CA,	"rpFind6Len",	0);
	create_insn	(x=0XC8CD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC8D0,	"rpRepl6Len",	0);
	set_cmt	(0XC8D3,	"patch out find6 code",	0);
	set_cmt	(0XC8D7,	"rpFind7bLen",	0);
	create_insn	(x=0XC8DA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC8DD,	"rpRepl7Len",	0);
	set_cmt	(0XC8E0,	"patch out find7b code",	0);
	set_cmt	(0XC8E3,	"BUG 4, only applies if version > 3.60",	0);
	create_insn	(x=0XC8E3);
	op_dec		(x,	1);
	set_name	(0XC8E3,	"rpBug4");
	set_cmt	(0XC8E8,	"and < 3.95",	0);
	set_cmt	(0XC8EA,	"locate find8 & find9 code",	0);
	create_insn	(x=0XC8EA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC8F2,	"save find9 code offset",	0);
	create_insn	(x=0XC8F8);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC8FB,	"rpRepl8Len",	0);
	set_cmt	(0XC8FE,	"patch out find8 code",	0);
	set_cmt	(0XC902,	"[bp+StackVars.sv_pPatch] \npatch find9 to jmp to patch area",	0);
	set_cmt	(0XC908,	"copy replacement code to patch area",	0);
	create_insn	(x=0XC908);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XC90B,	"rpRepl9Len",	0);
	set_cmt	(0XC90E,	"--it does a RET, so no jmp back to main-line",	0);
	set_cmt	(0XC911,	"StackVars.size",	0);
	create_insn	(x=0XC911);
	op_hex		(x,	1);
	set_name	(0XC911,	"rp3Exit");
	set_cmt	(0XC919,	"[bp+StackVars.sv_cbCodeSeg] ; search length",	0);
	create_insn	(0XC919);
	set_name	(0XC919,	"FindBadCode");
	set_cmt	(0XC91C,	"[bx+Searchpair.sp_off1] ; ds:si -> search string",	0);
	set_cmt	(0XC91E,	"[bx+SearchPair.sp_len1] ; dx = search len",	0);
	set_cmt	(0XC924,	"done if 1st not found",	0);
	set_cmt	(0XC926,	"save 1st string offset",	0);
	set_cmt	(0XC927,	"[bx+SearchPair.sp_off2]",	0);
	set_cmt	(0XC92A,	"[bx+SearchPair.sp_len2]",	0);
	set_cmt	(0XC92D,	"don't change flags after this!",	0);
	set_cmt	(0XC930,	"restore 1st string offset",	0);
	set_cmt	(0XC935,	"sanity check that",	0);
	set_cmt	(0XC937,	"si < di && di - si <= allowed diff",	0);
	set_cmt	(0XC939,	"[bx+SearchPair.sp_diff]",	0);
	create_insn	(0XC940);
	set_name	(0XC940,	"fbc_error");
	set_cmt	(0XC942,	"save offset of buggy code",	0);
	create_insn	(0XC942);
	set_name	(0XC942,	"GenPatch");
	set_cmt	(0XC943,	"[bp+StackVars.sv_pPatch]",	0);
	set_cmt	(0XC946,	"jump from buggy code to patch area",	0);
	set_cmt	(0XC949,	"copy replacement code to patch area",	0);
	set_cmt	(0XC94C,	"offset of buggy code + buggy code length",	0);
	set_cmt	(0XC94D,	"= return from patch offset",	0);
	set_cmt	(0XC94F,	"jump from patch area back to main-line code,",	0);
	set_cmt	(0XC952,	"[bp+StackVars.sv_pPatch] ; update patch pointer",	0);
	create_insn	(0XC956);
	set_name	(0XC956,	"CopyPatch");
	set_cmt	(0XC957,	"[bp+StackVars.sv_pPatch]\npatch pointer is the dest offset",	0);
	set_cmt	(0XC95E,	"[bp+StackVars.sv_pPatch]\nupdate net pointer location",	0);
	set_cmt	(0XC962,	"jmp rel16 opcode",	0);
	create_insn	(x=0XC962);
	op_hex		(x,	1);
	set_name	(0XC962,	"GenJump");
	set_cmt	(0XC965,	"calc offset to 'to' location",	0);
	set_cmt	(0XC96C,	"output offset",	0);
	set_cmt	(0XC96E,	"Looks for a pattern pointed to by DS:SI\n& len DX in ES:200 to ES:200+CX-1",	0);
	create_insn	(x=0XC96E);
	op_hex		(x,	1);
	set_name	(0XC96E,	"ScanCodeSeq");
	set_name	(0XC971,	"ScanCodeSeq_di");
	set_cmt	(0XC986,	"offset of version number in ascii",	0);
	create_insn	(0XC986);
	set_name	(0XC986,	"VerifyVersion");
	create_insn	(x=0XC98B);
	op_dec		(x,	1);
	set_cmt	(0XC98D,	"point to last digit",	0);
	create_insn	(0XC9A5);
	set_name	(0XC9A5,	"VVDigit");
	set_cmt	(0XC9A7,	"30h",	0);
	create_insn	(x=0XC9A7);
	op_chr		(x,	1);
	set_cmt	(0XC9AF,	"do not xor or sub we need Z",	0);
	create_byte	(x=0XC9B2);
	op_hex		(x,	0);
	set_name	(0XC9B2,	"exepatch_start");
	create_byte	(0XC9B3);
	make_array	(0XC9B3,	0X2);
	create_byte	(0XC9B5);
	make_array	(0XC9B5,	0X2);
	create_byte	(0XC9B7);
	make_array	(0XC9B7,	0X2);
	create_byte	(0XC9B9);
	make_array	(0XC9B9,	0X2);
	create_byte	(0XC9BB);
	make_array	(0XC9BB,	0X3);
	create_byte	(0XC9BE);
	create_byte	(0XC9BF);
	make_array	(0XC9BF,	0X3);
	create_byte	(0XC9C2);
	make_array	(0XC9C2,	0X2);
	create_byte	(0XC9C4);
	make_array	(0XC9C4,	0X2);
	create_byte	(0XC9C6);
	create_byte	(0XC9C7);
	make_array	(0XC9C7,	0X2);
	create_byte	(0XC9C9);
	create_byte	(0XC9CA);
	create_byte	(0XC9CB);
	make_array	(0XC9CB,	0X2);
	create_byte	(0XC9CD);
	make_array	(0XC9CD,	0X2);
	create_byte	(0XC9CF);
	make_array	(0XC9CF,	0X3);
	create_byte	(0XC9D2);
	make_array	(0XC9D2,	0X2);
	create_byte	(0XC9D4);
	make_array	(0XC9D4,	0X2);
	create_byte	(0XC9D6);
	make_array	(0XC9D6,	0X2);
	create_byte	(0XC9D8);
	make_array	(0XC9D8,	0X2);
	create_byte	(0XC9DA);
	make_array	(0XC9DA,	0X2);
	create_byte	(0XC9DC);
	make_array	(0XC9DC,	0X3);
	create_byte	(0XC9DF);
	make_array	(0XC9DF,	0X2);
	create_byte	(0XC9E1);
	make_array	(0XC9E1,	0X2);
	create_byte	(0XC9E3);
	make_array	(0XC9E3,	0X2);
	create_byte	(0XC9E5);
	make_array	(0XC9E5,	0X2);
	create_byte	(0XC9E7);
	make_array	(0XC9E7,	0X2);
	create_byte	(0XC9E9);
	make_array	(0XC9E9,	0X2);
	create_byte	(0XC9EB);
	make_array	(0XC9EB,	0X2);
	create_byte	(0XC9ED);
	make_array	(0XC9ED,	0X2);
	create_byte	(0XC9EF);
	create_byte	(0XC9F0);
	create_byte	(0XC9F1);
	create_byte	(0XC9F2);
	create_byte	(0XC9F3);
	make_array	(0XC9F3,	0X2);
	create_byte	(0XC9F5);
	make_array	(0XC9F5,	0X2);
	create_byte	(0XC9F7);
	create_byte	(0XC9F8);
	create_byte	(0XC9F9);
	create_byte	(0XC9FA);
	create_byte	(0XC9FB);
	make_array	(0XC9FB,	0X2);
	create_byte	(0XC9FD);
	create_byte	(0XC9FE);
	make_array	(0XC9FE,	0X2);
	create_byte	(0XCA00);
	make_array	(0XCA00,	0X2);
	create_byte	(0XCA02);
	make_array	(0XCA02,	0X2);
	create_byte	(0XCA04);
	make_array	(0XCA04,	0X2);
	create_byte	(0XCA06);
	create_byte	(0XCA07);
	make_array	(0XCA07,	0X2);
	create_byte	(0XCA09);
	make_array	(0XCA09,	0X2);
	create_byte	(0XCA0B);
	make_array	(0XCA0B,	0X2);
	create_byte	(0XCA0D);
	make_array	(0XCA0D,	0X2);
	create_byte	(0XCA0F);
	make_array	(0XCA0F,	0X2);
	create_byte	(0XCA11);
	create_byte	(0XCA12);
	make_array	(0XCA12,	0X2);
	create_byte	(0XCA14);
	make_array	(0XCA14,	0X2);
	create_byte	(0XCA16);
	make_array	(0XCA16,	0X2);
	create_byte	(0XCA18);
	make_array	(0XCA18,	0X2);
	set_name	(0XCA18,	"scan_patch1");
	create_byte	(0XCA1A);
	make_array	(0XCA1A,	0X2);
	create_byte	(0XCA1C);
	make_array	(0XCA1C,	0X2);
	create_byte	(0XCA1E);
	make_array	(0XCA1E,	0X2);
	create_byte	(0XCA20);
	make_array	(0XCA20,	0X2);
	create_byte	(0XCA22);
	make_array	(0XCA22,	0X3);
	create_byte	(0XCA25);
	make_array	(0XCA25,	0X3);
	create_byte	(0XCA28);
	make_array	(0XCA28,	0X2);
	create_byte	(0XCA2A);
	make_array	(0XCA2A,	0X2);
	create_byte	(0XCA2C);
	create_byte	(0XCA2D);
	make_array	(0XCA2D,	0X2);
	create_byte	(0XCA2F);
	make_array	(0XCA2F,	0X2);
	create_byte	(0XCA31);
	make_array	(0XCA31,	0X2);
	create_byte	(0XCA33);
	make_array	(0XCA33,	0X2);
	create_byte	(0XCA35);
	make_array	(0XCA35,	0X3);
	create_byte	(0XCA38);
	make_array	(0XCA38,	0X2);
	create_byte	(0XCA3A);
	make_array	(0XCA3A,	0X2);
	create_byte	(0XCA3C);
	make_array	(0XCA3C,	0X2);
	create_byte	(0XCA3E);
	make_array	(0XCA3E,	0X2);
	create_byte	(0XCA40);
	make_array	(0XCA40,	0X2);
	create_byte	(0XCA42);
	make_array	(0XCA42,	0X2);
	create_byte	(0XCA44);
	make_array	(0XCA44,	0X2);
	create_byte	(0XCA46);
	make_array	(0XCA46,	0X2);
	create_byte	(0XCA48);
	make_array	(0XCA48,	0X3);
	create_byte	(0XCA4B);
	make_array	(0XCA4B,	0X2);
	create_byte	(0XCA4D);
	make_array	(0XCA4D,	0X2);
	create_byte	(0XCA4F);
	make_array	(0XCA4F,	0X2);
	create_byte	(0XCA51);
	make_array	(0XCA51,	0X2);
	create_byte	(0XCA53);
	make_array	(0XCA53,	0X2);
	create_byte	(0XCA55);
	make_array	(0XCA55,	0X2);
	create_byte	(0XCA57);
	make_array	(0XCA57,	0X2);
	create_byte	(0XCA59);
	make_array	(0XCA59,	0X3);
	create_byte	(0XCA5C);
	make_array	(0XCA5C,	0X2);
	set_name	(0XCA5C,	"scan_patch2");
	create_byte	(0XCA5E);
	make_array	(0XCA5E,	0X2);
	create_byte	(0XCA60);
	create_byte	(0XCA61);
	make_array	(0XCA61,	0X2);
	create_byte	(0XCA63);
	make_array	(0XCA63,	0X2);
	create_byte	(0XCA65);
	make_array	(0XCA65,	0X3);
	create_byte	(0XCA68);
	make_array	(0XCA68,	0X3);
	create_byte	(0XCA6B);
	make_array	(0XCA6B,	0X2);
	create_byte	(0XCA6D);
	make_array	(0XCA6D,	0X2);
	create_byte	(0XCA6F);
	create_byte	(0XCA70);
	make_array	(0XCA70,	0X2);
	create_byte	(0XCA72);
	make_array	(0XCA72,	0X2);
	create_byte	(0XCA74);
	create_byte	(0XCA75);
	make_array	(0XCA75,	0X2);
	create_byte	(0XCA77);
	make_array	(0XCA77,	0X3);
	create_byte	(0XCA7A);
	make_array	(0XCA7A,	0X2);
	create_byte	(0XCA7C);
	make_array	(0XCA7C,	0X2);
	create_byte	(0XCA7E);
	make_array	(0XCA7E,	0X2);
	create_byte	(0XCA80);
	make_array	(0XCA80,	0X2);
	create_byte	(0XCA82);
	make_array	(0XCA82,	0X2);
	create_byte	(0XCA84);
	make_array	(0XCA84,	0X2);
	create_byte	(0XCA86);
	make_array	(0XCA86,	0X2);
	create_byte	(0XCA88);
	make_array	(0XCA88,	0X2);
	create_byte	(0XCA8A);
	make_array	(0XCA8A,	0X4);
	create_byte	(0XCA8E);
	make_array	(0XCA8E,	0X2);
	create_byte	(0XCA90);
	make_array	(0XCA90,	0X2);
	create_byte	(0XCA92);
	make_array	(0XCA92,	0X2);
	create_byte	(0XCA94);
	make_array	(0XCA94,	0X2);
	create_byte	(0XCA96);
	make_array	(0XCA96,	0X2);
	create_byte	(0XCA98);
	make_array	(0XCA98,	0X2);
	create_byte	(0XCA9A);
	make_array	(0XCA9A,	0X2);
	create_byte	(0XCA9C);
	make_array	(0XCA9C,	0X4);
	create_byte	(0XCAA0);
	make_array	(0XCAA0,	0X2);
	set_name	(0XCAA0,	"scan_patch3");
	create_byte	(0XCAA2);
	make_array	(0XCAA2,	0X2);
	create_byte	(0XCAA4);
	create_byte	(0XCAA5);
	make_array	(0XCAA5,	0X2);
	create_byte	(0XCAA7);
	make_array	(0XCAA7,	0X2);
	create_byte	(0XCAA9);
	make_array	(0XCAA9,	0X3);
	create_byte	(0XCAAC);
	make_array	(0XCAAC,	0X3);
	create_byte	(0XCAAF);
	make_array	(0XCAAF,	0X2);
	create_byte	(0XCAB1);
	make_array	(0XCAB1,	0X2);
	create_byte	(0XCAB3);
	create_byte	(0XCAB4);
	make_array	(0XCAB4,	0X2);
	create_byte	(0XCAB6);
	make_array	(0XCAB6,	0X2);
	create_byte	(0XCAB8);
	create_byte	(0XCAB9);
	make_array	(0XCAB9,	0X2);
	create_byte	(0XCABB);
	make_array	(0XCABB,	0X3);
	create_byte	(0XCABE);
	make_array	(0XCABE,	0X2);
	create_byte	(0XCAC0);
	make_array	(0XCAC0,	0X2);
	create_byte	(0XCAC2);
	make_array	(0XCAC2,	0X2);
	create_byte	(0XCAC4);
	make_array	(0XCAC4,	0X2);
	create_byte	(0XCAC6);
	make_array	(0XCAC6,	0X2);
	create_byte	(0XCAC8);
	make_array	(0XCAC8,	0X2);
	create_byte	(0XCACA);
	make_array	(0XCACA,	0X2);
	create_byte	(0XCACC);
	make_array	(0XCACC,	0X2);
	create_byte	(0XCACE);
	make_array	(0XCACE,	0X3);
	create_byte	(0XCAD1);
	make_array	(0XCAD1,	0X2);
	create_byte	(0XCAD3);
	make_array	(0XCAD3,	0X2);
	create_byte	(0XCAD5);
	make_array	(0XCAD5,	0X2);
	create_byte	(0XCAD7);
	make_array	(0XCAD7,	0X2);
	create_byte	(0XCAD9);
	make_array	(0XCAD9,	0X2);
	create_byte	(0XCADB);
	make_array	(0XCADB,	0X2);
	create_byte	(0XCADD);
	make_array	(0XCADD,	0X2);
	create_byte	(0XCADF);
	make_array	(0XCADF,	0X3);
	create_byte	(0XCAE2);
	set_name	(0XCAE2,	"scan_com");
	create_byte	(0XCAE3);
	make_array	(0XCAE3,	0X2);
	create_byte	(0XCAE5);
	create_byte	(0XCAE6);
	create_byte	(0XCAE7);
	make_array	(0XCAE7,	0X2);
	create_byte	(0XCAE9);
	create_byte	(0XCAEA);
	make_array	(0XCAEA,	0X2);
	create_byte	(0XCAEC);
	make_array	(0XCAEC,	0X2);
	create_byte	(0XCAEE);
	make_array	(0XCAEE,	0X2);
	create_byte	(0XCAF0);
	make_array	(0XCAF0,	0X2);
	create_byte	(0XCAF2);
	create_byte	(0XCAF3);
	make_array	(0XCAF3,	0X2);
	create_byte	(0XCAF5);
	make_array	(0XCAF5,	0X3);
	create_byte	(0XCAF8);
	make_array	(0XCAF8,	0X2);
	create_byte	(0XCAFA);
	make_array	(0XCAFA,	0X2);
	create_byte	(0XCAFC);
	make_array	(0XCAFC,	0X2);
	create_byte	(0XCAFE);
	make_array	(0XCAFE,	0X2);
	create_byte	(0XCB00);
	make_array	(0XCB00,	0X2);
	create_insn	(0XCB02);
	set_name	(0XCB02,	"ExePatch");
	create_insn	(x=0XCB05);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XCB0B);
	set_name	(0XCB0B,	"ExePackPatch");
	set_cmt	(0XCB0C,	"bx has load segment",	0);
	set_cmt	(0XCB0E,	"Q: is the load segment > 64K",	0);
	set_cmt	(0XCB12,	"N:",	0);
	set_cmt	(0XCB14,	"Y: no need to patch",	0);
	create_insn	(0XCB16);
	set_cmt	(0XCB1C,	"Q: is IP >=2",	0);
	set_cmt	(0XCB1F,	"N: exit",	0);
	set_cmt	(0XCB21,	"ax:cx now points to location of\n'RB' if this is an exepacked file.",	0);
	create_insn	(0XCB24);
	set_cmt	(0XCB28,	"save pointer to 'RB' in unpack_offset",	0);
	create_insn	(x=0XCB28);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCB2D,	"'RB'",	0);
	create_insn	(0XCB37);
	set_cmt	(0XCB39,	"PATCH1_COM_OFFSET\nes:di -> points to place in packed file\nwhere we hope to find scan string.",	0);
	create_insn	(x=0XCB39);
	op_hex		(x,	1);
	set_cmt	(0XCB3C,	"check for match",	0);
	set_cmt	(0XCB3F,	"Q: does the patch match\nN: check at patch2_offset\nY: check for rest of patch string",	0);
	set_cmt	(0XCB41,	"ds:si -> scan string",	0);
	create_insn	(x=0XCB41);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCB44,	"restore di to point to 'RB'",	0);
	create_insn	(x=0XCB44);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCB49,	"PATCH1_OFFSET\nes:di -> points to place in packed file\nwhere we hope to find scan string.",	0);
	create_insn	(x=0XCB49);
	op_hex		(x,	1);
	set_cmt	(0XCB4C,	"size_scan_patch1",	0);
	create_insn	(x=0XCB4C);
	op_dec		(x,	1);
	set_cmt	(0XCB4E,	"CHKSUM1_LEN",	0);
	create_insn	(x=0XCB4E);
	op_dec		(x,	1);
	set_cmt	(0XCB51,	"PATCH1_CHKSUM",	0);
	set_cmt	(0XCB54,	"check if patch and chk sum compare",	0);
	set_cmt	(0XCB57,	"Q: did we pass the test\nN: exit\nY: overlay code with new",	0);
	set_cmt	(0XCB59,	"str1",	0);
	create_insn	(x=0XCB59);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCB5C,	"size_str1",	0);
	create_insn	(x=0XCB5C);
	op_dec		(x,	1);
	set_cmt	(0XCB60,	"ep_done",	0);
	create_insn	(0XCB62);
	set_cmt	(0XCB63,	"PATCH2_COM_OFFSET\nes:di -> possible location of patch\nin another version of unpack",	0);
	create_insn	(x=0XCB63);
	op_hex		(x,	1);
	set_cmt	(0XCB66,	"check for match",	0);
	set_cmt	(0XCB69,	"Q: does the patch match\nN: check for patch3_offset\nY: check for rest of patch string",	0);
	set_cmt	(0XCB6B,	"ds:si -> scan string",	0);
	create_insn	(x=0XCB6B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCB6E,	"PATCH2_OFFSET\nes:di -> points to place in packed file\nwhere we hope to find scan string.",	1);
	create_insn	(x=0XCB6E);
	op_hex		(x,	1);
	set_cmt	(0XCB71,	"size_scan_patch2",	0);
	create_insn	(x=0XCB71);
	op_dec		(x,	1);
	set_cmt	(0XCB73,	"CHKSUM2_LEN",	0);
	create_insn	(x=0XCB73);
	op_dec		(x,	1);
	set_cmt	(0XCB76,	"PATCH2_CHKSUM",	0);
	set_cmt	(0XCB79,	"check if patch and chk sum compare",	0);
	set_cmt	(0XCB7C,	"Q: did we pass the test\nY: overlay code with new \nN: try with a different chksum",	0);
	set_cmt	(0XCB7E,	"ds:si -> scan string",	0);
	create_insn	(x=0XCB7E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCB81,	"size_scan_patch2",	0);
	create_insn	(x=0XCB81);
	op_dec		(x,	1);
	set_cmt	(0XCB83,	"CHKSUM2A_LEN",	0);
	create_insn	(x=0XCB83);
	op_dec		(x,	1);
	set_cmt	(0XCB86,	"PATCH2A_CHKSUM",	0);
	set_cmt	(0XCB89,	"check if patch and chk sum compare",	0);
	set_cmt	(0XCB8E,	"str1",	0);
	create_insn	(x=0XCB8E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCB91,	"first_stop",	0);
	set_cmt	(0XCB95,	"ax = opcodes for dec ax, nop",	0);
	set_cmt	(0XCB9B,	"second_stop",	0);
	create_insn	(x=0XCB9B);
	op_dec		(x,	1);
	set_cmt	(0XCB9F,	"put in dec ax and nop",	0);
	create_insn	(x=0XCBA2);
	op_dec		(x,	1);
	set_cmt	(0XCBA6,	"ep_done",	0);
	set_cmt	(0XCBA8,	"PATCH3_COM_OFFSET\nes:di -> possible location of patch\nin another version of unpack",	0);
	create_insn	(x=0XCBA8);
	op_hex		(x,	1);
	set_cmt	(0XCBAB,	"check for match",	0);
	set_cmt	(0XCBAE,	"Q: does the patch match\nN: exit\nY: check for rest of patch string",	0);
	set_cmt	(0XCBB0,	"ds:si -> scan string",	0);
	create_insn	(x=0XCBB0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCBB3,	"PATCH3_OFFSET\nes:di -> points to place in packed file\nwhere we hope to find scan string.",	0);
	create_insn	(x=0XCBB3);
	op_hex		(x,	1);
	set_cmt	(0XCBB6,	"size_scan_patch3",	0);
	create_insn	(x=0XCBB6);
	op_dec		(x,	1);
	set_cmt	(0XCBB8,	"CHKSUM3_LEN",	0);
	create_insn	(x=0XCBB8);
	op_dec		(x,	1);
	set_cmt	(0XCBBB,	"PATCH3_CHKSUM",	0);
	set_cmt	(0XCBBE,	"check if patch and chk sum compare",	0);
	set_cmt	(0XCBC1,	"Q: did we pass the test\nN: exit\nY: overlay code with new",	0);
	set_cmt	(0XCBC3,	"str1",	0);
	create_insn	(x=0XCBC3);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCBC6,	"first_stop",	0);
	set_cmt	(0XCBCA,	"al = opcode for dec ax",	0);
	create_insn	(x=0XCBCA);
	op_hex		(x,	1);
	set_cmt	(0XCBCD,	"add si,2",	0);
	set_cmt	(0XCBCF,	"second_stop",	0);
	create_insn	(x=0XCBCF);
	op_dec		(x,	1);
	set_cmt	(0XCBD3,	"put in dec ax",	0);
	set_cmt	(0XCBD6,	"last_stop",	0);
	create_insn	(x=0XCBD6);
	op_dec		(x,	1);
	create_insn	(x=0XCBE2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XCBE2,	"chk_common_str");
	set_cmt	(0XCBE5,	"size_scan_com",	0);
	create_insn	(x=0XCBE5);
	op_dec		(x,	1);
	create_insn	(x=0XCBEC);
	op_hex		(x,	1);
	set_name	(0XCBF5,	"ccs_done");
	create_insn	(0XCBF6);
	set_name	(0XCBF6,	"chk_patchsum");
	set_cmt	(0XCBF9,	"Q: does the patch match\nN: exit\nY:",	0);
	set_cmt	(0XCBFB,	"di -> start of unpack code",	0);
	create_insn	(x=0XCBFB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCC00,	"cx = length of check sum",	0);
	set_cmt	(0XCC02,	"save check sum passed to us in bx",	0);
	set_cmt	(0XCC0E,	"Q: does the check sum match",	0);
	set_cmt	(0XCC10,	"N: exit\nY:",	0);
	create_insn	(0XCC14);
	create_byte	(0XCC16);
	make_array	(0XCC16,	0X8);
	set_name	(0XCC16,	"RScanPattern1");
	create_byte	(0XCC1E);
	make_array	(0XCC1E,	0X2);
	create_byte	(0XCC20);
	make_array	(0XCC20,	0X8);
	set_name	(0XCC20,	"RScanPattern2");
	create_byte	(0XCC28);
	make_array	(0XCC28,	0X7);
	set_name	(0XCC28,	"RScanPattern3");
	create_insn	(0XCC2F);
	set_name	(0XCC2F,	"RationalPatch");
	set_cmt	(0XCC33,	"look for pat1 at offset 0Ah",	0);
	create_insn	(x=0XCC38);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XCC3B);
	op_dec		(x,	1);
	set_cmt	(0XCC3E,	"do we have the pattern ?",	0);
	set_cmt	(0XCC40,	"no",	0);
	set_cmt	(0XCC46,	"is it a buggy version ?",	0);
	create_insn	(x=0XCC46);
	op_dec		(x,	1);
	set_cmt	(0XCC4B,	"is it a buggy version ?",	0);
	create_insn	(x=0XCC4B);
	op_dec		(x,	1);
	set_cmt	(0XCC55,	"Length of buggy code seg",	0);
	set_cmt	(0XCC5A,	"Length we search\n(we start at offset 200h)",	0);
	set_cmt	(0XCC5E,	"es=buggy code segment",	0);
	create_insn	(x=0XCC63);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCC66,	"RLen2",	0);
	set_cmt	(0XCC69,	"look for code seq with nop",	0);
	create_insn	(x=0XCC6E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCC71,	"RLen3",	0);
	create_insn	(x=0XCC71);
	op_dec		(x,	1);
	set_cmt	(0XCC74,	"look for code seq w/o nop",	0);
	set_cmt	(0XCC79,	"far call opcode",	0);
	set_name	(0XCC79,	"rpfound");
	create_insn	(x=0XCC7C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCC85,	"filler (with NOPs)",	0);
	set_name	(0XCC8C,	"rpexit");
	create_byte	(0XCC90);
	make_array	(0XCC90,	0X4);
	set_name	(0XCC90,	"CPScanPattern");
	create_byte	(0XCC94);
	make_array	(0XCC94,	0X4);
	create_byte	(0XCC98);
	make_array	(0XCC98,	0X6);
	create_byte	(0XCC9E);
	make_array	(0XCC9E,	0X4);
	create_byte	(0XCCA2);
	make_array	(0XCCA2,	0X3);
	create_byte	(0XCCA5);
	make_array	(0XCCA5,	0X3);
	set_cmt	(0XCCA8,	"cmp word [CPID1Offset],ID1",	0);
	create_insn	(0XCCA8);
	set_name	(0XCCA8,	"IsCopyProt");
	set_cmt	(0XCCB0,	"cmp word [CPID2Offset],ID2",	0);
	set_cmt	(0XCCB8,	"cmp word [CPID3Offset],ID3",	0);
	set_cmt	(0XCCC0,	"cmp word [CPID4Offset],ID4",	0);
	create_insn	(x=0XCCCA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCCCD,	"CPStartOffset",	0);
	set_cmt	(0XCCD0,	"CPSPlen",	0);
	create_insn	(x=0XCCD0);
	op_dec		(x,	1);
	create_insn	(x=0XCCD7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XCCDD,	"CP_done");
	create_insn	(0XCCDE);
	set_name	(0XCCDE,	"initiret");
	create_word	(0XCCDF);
	set_name	(0XCCDF,	"InitBioDataSeg");
	create_insn	(0XCCE1);
	set_name	(0XCCE1,	"ParaRound");
	create_insn	(x=0XCCE4);
	op_hex		(x,	1);
	create_insn	(x=0XCCE6);
	op_hex		(x,	1);
	create_insn	(x=0XCCE8);
	op_hex		(x,	1);
	create_insn	(x=0XCCEA);
	op_hex		(x,	1);
	create_insn	(0XCCED);
	set_name	(0XCCED,	"WhatCPUType");
	set_cmt	(0XCCEF,	"0",	0);
	set_cmt	(0XCCF1,	"0",	0);
	set_cmt	(0XCCF3,	"AX = 0 ; put it on the stack",	0);
	set_cmt	(0XCCF4,	"shove it into the flags",	0);
	set_cmt	(0XCCF5,	"it back out of the flags",	0);
	set_cmt	(0XCCF6,	"and into ax",	0);
	set_cmt	(0XCCF7,	"mask off high four bits",	0);
	create_insn	(x=0XCCF7);
	op_hex		(x,	1);
	set_cmt	(0XCCFA,	"was it all 1's?",	0);
	set_cmt	(0XCCFD,	"yes ; it's an 8086 or 8088",	0);
	set_cmt	(0XCCFF,	"now try to set the high four bit",	0);
	set_cmt	(0XCD05,	"and see what happens",	0);
	set_cmt	(0XCD06,	"any high bits set ?",	0);
	create_insn	(x=0XCD06);
	op_hex		(x,	1);
	set_cmt	(0XCD09,	"no ; it's an 80286",	0);
	set_name	(0XCD0B,	"cpu_386");
	set_cmt	(0XCD0D,	"AX = 0 if 8086 or 8088\n   = 1 if 80286\n   = 2 if 80386",	0);
	create_insn	(0XCD12);
	set_name	(0XCD12,	"DOSINIT");
	set_cmt	(0XCD14,	"top of memory (memory size in paragraphs)",	0);
	set_cmt	(0XCD15,	"0",	0);
	set_cmt	(0XCD16,	"IBMDOS.SYS loading segment",	0);
	set_cmt	(0XCD17,	"0",	0);
	set_cmt	(0XCD18,	"CURRENT_DOS_LOCATION (segment)",	0);
	set_cmt	(0XCD1A,	"MEMSTRT ; get offset of end of init code",	0);
	set_cmt	(0XCD1D,	"round up",	0);
	create_insn	(x=0XCD20);
	op_hex		(x,	1);
	set_cmt	(0XCD23,	"DOSDATA segment offset in IBMDOS.SYS",	0);
	set_cmt	(0XCD26,	"DOSCODE segment",	0);
	set_cmt	(0XCD27,	"BIOSDATA segment (always 0070h)",	0);
	set_cmt	(0XCD2C,	"DOSDATA segment ptr",	0);
	set_cmt	(0XCD31,	"offset 0",	0);
	set_cmt	(0XCD33,	"DOSDATA size (4934 bytes)",	0);
	create_insn	(x=0XCD33);
	op_hex		(x,	1);
	set_cmt	(0XCD40,	"CURRENT_DOS_LOCATION (offset = 0)",	0);
	create_insn	(x=0XCD40);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCD44,	"CURRENT_DOS_LOCATION (segment)",	0);
	create_insn	(x=0XCD44);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XCD5C);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XCD60);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XCD64);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XCD6A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XCD6D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XCD70);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XCD73);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XCD76);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCD79,	"get cpu type (0 < 286,1==286,2 >= 386)",	0);
	set_cmt	(0XCD7C,	"386 or later?",	0);
	set_cmt	(0XCD7E,	"yes",	0);
	create_insn	(x=0XCD7E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCD83,	"< 386, don't need this patch",	0);
	create_insn	(x=0XCD83);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XCD86);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XCD86,	"di_set_patch");
	create_insn	(x=0XCD8B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XCD8E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XCD92);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCD96,	"[Win386_Info+14+2]\n[Win386_Info+Win386_SIS.Instance_Data_Ptr+2]",	0);
	create_insn	(x=0XCD96);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCD9E,	"Instance_Table+2",	0);
	create_insn	(x=0XCD9E);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCDA1,	"set offset in instance entry",	0);
	set_name	(0XCDA1,	"Instance_init_loop");
	set_cmt	(0XCDA3,	"size_of_Win386_IIS ; move on to next entry",	0);
	set_cmt	(0XCDA8,	"five entries in the instance table",	0);
	set_cmt	(0XCDAB,	"OldInstanceJunk+6",	0);
	create_insn	(x=0XCDAB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCDAE,	"set offset in instance entry",	0);
	set_name	(0XCDAE,	"OldInstance_init_loop");
	set_cmt	(0XCDB0,	"move on to next entry",	0);
	set_cmt	(0XCDB5,	"restore pointer to device chain",	0);
	set_cmt	(0XCDB9,	"0",	0);
	set_cmt	(0XCDBB,	"point DS to int vector table",	0);
	create_insn	(x=0XCDBD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCDC0,	"[2Ah*4]",	0);
	create_insn	(x=0XCDC0);
	set_cmt	(0XCDC5,	"[(2Ah*4)+2]",	0);
	create_insn	(x=0XCDC5);
	set_cmt	(0XCDC8,	"restore segment of device chain",	0);
	set_cmt	(0XCDC9,	"initialize console driver",	0);
	set_cmt	(0XCDCC,	"save pointer to header",	0);
	set_cmt	(0XCDCD,	"move pointer to dos data...",	0);
	set_cmt	(0XCDCF,	"SFTABL+SFT.SFTable ; Point to sft 0",	0);
	create_insn	(x=0XCDCF);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCDD2,	"Refcount",	0);
	set_cmt	(0XCDD5,	"SF_ENTRY.sf_ref_count",	0);
	set_cmt	(0XCDD6,	"ax = 2 ; Access rd/wr, compatibility",	0);
	set_cmt	(0XCDD8,	".sf_mode",	0);
	set_cmt	(0XCDD9,	"0",	0);
	set_cmt	(0XCDDB,	".sf_attr",	0);
	set_cmt	(0XCDDC,	"devid_device_EOF|devid_device|ISCIN|ISCOUT",	0);
	set_cmt	(0XCDDE,	".sf_flags",	0);
	set_cmt	(0XCDDF,	"device pointer in devptr",	0);
	set_cmt	(0XCDE1,	".sf_devptr",	0);
	set_cmt	(0XCDE4,	"SFT0_SFTable + 9 ; .sf_devptr_hw",	0);
	set_cmt	(0XCDE5,	"0",	0);
	set_cmt	(0XCDE7,	"SFTABL+SFT.SFTable + 43",	0);
	create_insn	(x=0XCDE7);
	op_dec		(x,	1);
	set_cmt	(0XCDEA,	"SFT0_SFTable + 43 ; SF_ENTRY.sf_fclus32",	0);
	set_cmt	(0XCDEB,	".sf_fclus32 + 2",	0);
	set_cmt	(0XCDEC,	"0FFDEh ; SFTABL+SFT.SFTable + 13",	0);
	create_insn	(x=0XCDEC);
	toggle_sign		(x,	1);
	op_dec		(x,	1);
	set_cmt	(0XCDEF,	"SFT0_SFTable + 13 ; SF_ENTRY.sf_time",	0);
	set_cmt	(0XCDF0,	".sf_date",	0);
	set_cmt	(0XCDF1,	"-1",	0);
	set_cmt	(0XCDF2,	"SFT0_SFTable + 17 ; .sf_size",	0);
	set_cmt	(0XCDF3,	".sf_size + 2",	0);
	set_cmt	(0XCDF4,	"0",	0);
	set_cmt	(0XCDF5,	"SFT0_SFTable + 21 ; .sf_position",	0);
	set_cmt	(0XCDF6,	".sf_position + 2",	0);
	set_cmt	(0XCDF7,	"SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos\nSFT0_SFTable + 32",	0);
	set_cmt	(0XCDFA,	"SYSDEV.NAME",	0);
	create_insn	(x=0XCDFA);
	op_dec		(x,	1);
	set_cmt	(0XCE00,	"name",	0);
	set_cmt	(0XCE04,	"extension",	0);
	set_cmt	(0XCE06,	"SFT0_SFTable + 40",	0);
	set_cmt	(0XCE08,	"get back pointer to header",	0);
	set_cmt	(0XCE09,	"ISCIN|ISCOUT",	0);
	create_insn	(x=0XCE09);
	op_hex		(x,	1);
	create_insn	(x=0XCE0D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XCE12);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCE17,	"AUX device",	0);
	set_name	(0XCE17,	"CHAR_INIT_LOOP");
	set_cmt	(0XCE1C,	"[SI+SYSDEV.ATT],ISCLOCK",	0);
	create_insn	(x=0XCE1C);
	op_hex		(x,	1);
	create_insn	(x=0XCE22);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XCE27);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCE2C,	"MSDAT001E ; ES:BP points to DPB",	0);
	set_cmt	(0XCE2F,	"pointer to DPB's",	0);
	create_insn	(x=0XCE2F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XCE34);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCE39,	"[SI+SYSDEV.NEXT] ; Next device",	0);
	set_name	(0XCE39,	"PERDRV");
	set_cmt	(0XCE3B,	"-1",	0);
	create_insn	(0XCE43);
	set_name	(0XCE43,	"PERDRV2");
	set_cmt	(0XCE46,	"[SI+SYSDEV.ATT],DEVTYP",	0);
	create_insn	(x=0XCE46);
	op_hex		(x,	1);
	set_cmt	(0XCE4B,	"Skip any other character devs",	0);
	create_insn	(x=0XCE4D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCE54,	"[si+SYSDEV.NAME]",	0);
	create_insn	(x=0XCE54);
	op_dec		(x,	0);
	create_insn	(x=0XCE57);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCE5C,	"0",	0);
	create_insn	(x=0XCE5E);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XCE65);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCE6A,	"DS:SI Points to BPB",	0);
	set_name	(0XCE6A,	"PERUNIT");
	set_cmt	(0XCE6D,	"On to next BPB",	0);
	set_cmt	(0XCE6E,	"DPB.DRIVE",	0);
	set_cmt	(0XCE72,	"DPB.UNIT",	0);
	set_cmt	(0XCE79,	"'RA'",	0);
	set_cmt	(0XCE7C,	"0",	0);
	set_cmt	(0XCE7E,	"[es:bp+DPB.NEXT_FREE]",	0);
	create_insn	(x=0XCE7E);
	op_dec		(x,	0);
	set_cmt	(0XCE82,	"BPB_FATSz16 ; [si+A_BPB.SECTORSPERFAT]",	0);
	create_insn	(x=0XCE82);
	op_dec		(x,	0);
	set_cmt	(0XCE85,	"FAT (FAT12 or FAT16) -old DPB-\nFAT32 -new- DPB",	0);
	set_cmt	(0XCE87,	"[es:bp+DPB.FAT32_NXTFREE]",	0);
	create_insn	(x=0XCE87);
	op_dec		(x,	0);
	set_cmt	(0XCE8B,	"[es:bp+DPB.FAT32_NXTFREE+2]",	0);
	create_insn	(x=0XCE8B);
	op_dec		(x,	0);
	set_cmt	(0XCE8F,	"0FFFFh  ; -1",	0);
	set_cmt	(0XCE90,	"[es:bp+DPB.FREE_CNT]",	0);
	create_insn	(x=0XCE90);
	op_dec		(x,	0);
	set_cmt	(0XCE94,	"[es:bp+DPB.FREE_CNT_HW]",	0);
	create_insn	(x=0XCE94);
	op_dec		(x,	0);
	set_cmt	(0XCE98,	"'XE'",	0);
	set_cmt	(0XCE9B,	"build DPB!",	0);
	set_name	(0XCE9B,	"PERUNIT2");
	set_cmt	(0XCE9E,	"[ES:BP+DPB.SECTOR_SIZE]",	0);
	set_cmt	(0XCEA2,	"Q:is this the largest sector so far",	0);
	create_insn	(x=0XCEA2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCEA7,	"N:",	0);
	set_cmt	(0XCEA9,	"Y: save it in maxsec",	0);
	create_insn	(x=0XCEA9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XCEAD,	"NOTMAX");
	set_cmt	(0XCEAF,	"next DPB (PCDOS 7.1 DPB size = 61)",	0);
	create_insn	(x=0XCEAF);
	op_dec		(x,	1);
	set_cmt	(0XCEB2,	"DPB.NEXT_DPB offset",	0);
	create_insn	(x=0XCEB2);
	op_dec		(x,	0);
	set_cmt	(0XCEB6,	"DPB.NEXT_DPB segment",	0);
	create_insn	(x=0XCEB6);
	op_dec		(x,	0);
	set_cmt	(0XCEBA,	"DPB.FIRST_ACCESS = -1",	0);
	create_insn	(x=0XCEBA);
	op_dec		(x,	0);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_6(void) {
        auto x;
#define id x

	set_cmt	(0XCEC2,	"save segment of bpb array",	0);
	set_cmt	(0XCEC6,	"DPB.DRIVER_ADDR offset",	0);
	create_insn	(x=0XCEC6);
	op_dec		(x,	0);
	set_cmt	(0XCECA,	"DPB.DRIVER_ADDR segment",	0);
	create_insn	(x=0XCECA);
	op_dec		(x,	0);
	set_cmt	(0XCED6,	"DPBSIZ",	0);
	create_insn	(x=0XCED6);
	op_dec		(x,	1);
	set_cmt	(0XCEDB,	"restore pointer to device header",	0);
	set_cmt	(0XCEE0,	"sub bp,DPBSIZ ; back up to last dpb",	0);
	create_insn	(x=0XCEE0);
	op_dec		(x,	1);
	set_name	(0XCEE0,	"CONTINIT");
	set_cmt	(0XCEE6,	"[bp+DPB.NEXT_DPB],-1",	0);
	create_insn	(x=0XCEE6);
	op_dec		(x,	0);
	set_cmt	(0XCEE9,	"[bp+DPB.NEXT_DPB+2],-1",	0);
	create_insn	(x=0XCEE9);
	op_dec		(x,	0);
	set_cmt	(0XCEEC,	"DPBSIZ ; advance to free memory again\nthe DPB chain is done.",	0);
	create_insn	(x=0XCEEC);
	op_dec		(x,	1);
	set_cmt	(0XCEF3,	"round up to segment",	0);
	set_cmt	(0XCEF6,	"dx = dosdata segment",	0);
	set_cmt	(0XCEF8,	"dx = ds+ax first free segment",	0);
	create_insn	(x=0XCEFD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCF01,	"[DSKCHRET+3]",	0);
	create_insn	(x=0XCF01);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCF05,	"preserve first free segment",	0);
	set_cmt	(0XCF06,	"ax = segment to patch in",	0);
	create_insn	(x=0XCF06);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCF09,	"es = segment of DOS",	0);
	set_cmt	(0XCF0B,	"-1 means first call to patch_misc_segments",	0);
	create_insn	(x=0XCF0B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCF11,	"uses AX as doscode segment",	0);
	set_cmt	(0XCF14,	"patch in segments for sharer and\nother tables with seg in ES.",	0);
	set_cmt	(0XCF17,	"put back segment of dos code",	0);
	create_insn	(x=0XCF17);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCF1B,	"restore first free segment",	0);
	set_cmt	(0XCF1E,	"0",	0);
	set_cmt	(0XCF20,	"0",	0);
	set_cmt	(0XCF22,	"INT 24h vector\naddr_int_fatal_abort",	0);
	create_insn	(x=0XCF25);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCF29,	"segment",	0);
	set_cmt	(0XCF2C,	"INTBASE+2",	0);
	create_insn	(x=0XCF2F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCF35,	"INTBASE",	0);
	create_insn	(x=0XCF38);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCF3B,	"sets offsets for ints 20h-28h",	0);
	set_name	(0XCF3E,	"iset1");
	set_cmt	(0XCF43,	"skip vector 29h",	0);
	set_cmt	(0XCF46,	"sets offsets for ints 2Ah-2Fh",	0);
	set_name	(0XCF49,	"iset2");
	set_cmt	(0XCF4E,	"skip vector 30h & 31h",	0);
	set_cmt	(0XCF51,	"sets offsets for ints 32h-3Fh",	0);
	create_insn	(x=0XCF51);
	op_dec		(x,	1);
	set_name	(0XCF54,	"iset3");
	set_cmt	(0XCF59,	"mov word [02Fh*4],INT2F",	0);
	create_insn	(x=0XCF59);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XCF5F);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XCF63);
	set_cmt	(0XCF66,	"mov byte [ENTRYPOINT],mi_long_jmp",	0);
	create_insn	(x=0XCF66);
	set_cmt	(0XCF6B,	"mov word [ENTRYPOINT+1],CALL_ENTRY",	0);
	create_insn	(x=0XCF6B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCF71,	"mov word [addr_int_abort],QUIT",	0);
	create_insn	(x=0XCF71);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCF77,	"mov word [addr_int_command],COMMAND",	0);
	create_insn	(x=0XCF77);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCF7D,	"mov word [addr_int_terminate],100h",	0);
	create_insn	(x=0XCF7D);
	set_cmt	(0XCF83,	"mov word [addr_int_terminate+2],dx",	0);
	create_insn	(x=0XCF83);
	set_cmt	(0XCF87,	"mov word [addr_int_disk_read],ABSDRD",	0);
	create_insn	(x=0XCF87);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCF8D,	"mov word [addr_int_disk_write],ABSDWRT",	0);
	create_insn	(x=0XCF8D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCF93,	"mov word [addr_int_keep_process],STAY_RESIDENT",	0);
	create_insn	(x=0XCF93);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCF9D,	"remember address of arena",	0);
	set_cmt	(0XCF9E,	"leave room for arena header",	0);
	set_cmt	(0XCF9F,	"set current pdb",	0);
	create_insn	(x=0XCF9F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCFA3,	"0",	0);
	set_cmt	(0XCFA5,	"point es:di at end of memory where psp will be",	0);
	set_cmt	(0XCFA9,	"psp is 128 words",	0);
	create_insn	(x=0XCFA9);
	op_dec		(x,	1);
	set_cmt	(0XCFAC,	"zero out psp area",	0);
	create_insn	(x=0XCFAE);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCFB1,	"build psp at dx; ax is memory size",	0);
	set_cmt	(0XCFB6,	"PDB.JFN_TABLE",	0);
	create_insn	(x=0XCFB6);
	op_dec		(x,	1);
	set_cmt	(0XCFB9,	"es:di -> pdb_jfn_table in psp",	0);
	set_cmt	(0XCFBB,	"0",	0);
	set_cmt	(0XCFBC,	"0,1 and 2 are con device",	0);
	set_cmt	(0XCFBF,	"FILPERPROC-3",	0);
	create_insn	(x=0XCFBF);
	op_dec		(x,	1);
	set_cmt	(0XCFC2,	"rest are unused",	0);
	create_insn	(x=0XCFC6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCFCA,	"Fill in the segment addresses of sysinitvar\nand country_cdpg in sysinittable",	0);
	create_insn	(x=0XCFCA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XCFCD,	"[es:si+SYSI_EXT.Country_Tab+2]",	0);
	set_cmt	(0XCFD1,	"[es:si+SYSI_EXT.SysInitVars+2]",	0);
	create_insn	(x=0XCFD5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCFDA,	"HASHINITVAR",	0);
	create_insn	(x=0XCFDA);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XCFDD);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCFE2,	"restore address of arena",	0);
	create_insn	(x=0XCFE3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XCFE7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XCFEE,	"[ARENA.SIGNATURE],arena_signature_end",	0);
	set_cmt	(0XCFF3,	"[ARENA.OWNER],arena_owner_system",	0);
	create_insn	(x=0XCFF9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD000,	"[ARENA.SIZE]",	0);
	set_cmt	(0XD003,	"SFTABL+SFT.SFTable",	0);
	create_insn	(x=0XD003);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD009,	"adjust refcount",	0);
	create_insn	(x=0XD00A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD00D,	"advance dx from arena to psp",	0);
	set_cmt	(0XD00E,	"point ds to psp",	0);
	create_insn	(x=0XD010);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XD013);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD016,	"sub cx, 3F10h\ncx = (doscode - exepatch) - dosinit",	0);
	create_insn	(x=0XD016);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD01A,	"SYSBUF",	0);
	create_insn	(x=0XD01A);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD01D,	"sub ax, 3F10h\nax = size of doscode - dosinit",	0);
	create_insn	(x=0XD01D);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XD020);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XD025);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD02B,	"19h",	0);
	create_insn	(x=0XD02B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_dec		(x,	1);
	set_name	(0XD02B,	"CHARINIT");
	create_insn	(x=0XD031);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XD037);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XD03D);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XD047,	"offset DEVCALL",	0);
	create_insn	(x=0XD047);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0XD053);
	set_name	(0XD053,	"check_XMM");
	set_cmt	(0XD057,	"- Multiplex - XMS - INSTALLATION CHECK\nReturn: AL = 80h XMS driver installed\nAL <> 80h no driver",	0);
	create_insn	(x=0XD057);
	op_hex		(x,	0);
	set_cmt	(0XD064,	"- Multiplex - XMS - GET DRIVER ADDRESS\nReturn: ES:BX -> driver entry point",	0);
	create_insn	(x=0XD064);
	op_hex		(x,	0);
	create_insn	(x=0XD06B);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(x=0XD06F);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XD073,	"cXMMexit");
	create_insn	(0XD07A);
	create_byte	(0XD07D);
	set_name	(0XD07D,	"num_entry");
	create_insn	(0XD07E);
	set_name	(0XD07E,	"_seg_reinit");
	set_cmt	(0XD084,	"patch in segments for sharer and \nother tables with seg in ES.",	0);
	set_cmt	(0XD089,	"patch vectors with segment in es",	0);
	set_cmt	(0XD08B,	"Q: is it the first call to this",	0);
	set_cmt	(0XD090,	"N: just patch the stub with segment in ES\nY: patch the vectors with stub",	0);
	set_cmt	(0XD094,	"patch the segment of vectors",	0);
	set_cmt	(0XD097,	"patch the offsets of vectors",	0);
	set_cmt	(0XD09A,	"patch the stub with segment in es",	0);
	set_name	(0XD09A,	"second_entry");
	create_insn	(x=0XD09C);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0XD0A4,	"dosinttabloop");
	set_cmt	(0XD0A9,	"Q: is the DOS running in the HMA",	0);
	set_cmt	(0XD0AC,	"N: done",	0);
	set_cmt	(0XD0AE,	"Y: set up the XMS entry point",	0);
	set_cmt	(0XD0B1,	"failed to set up XMS do not do\nA20 toggling in the stub.",	0);
	set_cmt	(0XD0B3,	"enable the stub to check A20 state",	0);
	set_cmt	(0XD0B6,	"set flag telling DOS control of HMA",	0);
	create_insn	(x=0XD0B6);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XD0BB,	"set pointer to the routine that \npatches buggy exepacked code.",	0);
	create_insn	(x=0XD0BB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD0C1,	"set pointer to the routine \nthat detects copy protected apps",	0);
	create_insn	(x=0XD0C1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD0CC,	"we need Rational Patch only on 286 systems",	0);
	create_insn	(x=0XD0CE);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD0D6,	"patch vectors with segment in es",	0);
	create_insn	(0XD0D6);
	set_name	(0XD0D6,	"patch_vec_seg");
	set_cmt	(0XD0D8,	"patch in DOSCODE for the segments",	0);
	set_name	(0XD0DB,	"sr_done");
	set_cmt	(0XD0E2,	"! far return !",	0);
	create_insn	(0XD0E3);
	set_name	(0XD0E3,	"patch_vec_segments");
	set_cmt	(0XD0E8,	"INTBASE+2 ; di -> segment of int 20h vector",	0);
	set_cmt	(0XD0EB,	"segment of default divide trap handler",	0);
	create_insn	(x=0XD0EB);
	set_cmt	(0XD0F0,	"cx = 2",	0);
	set_cmt	(0XD0F6,	"skip int 22h vector",	0);
	set_cmt	(0XD0F9,	"set int 23h",	0);
	set_cmt	(0XD0FA,	"skip int 24h",	0);
	set_cmt	(0XD0FD,	"set vectors 25h-28h",	0);
	set_cmt	(0XD105,	"skip int 29h",	0);
	set_cmt	(0XD108,	"set vectors 2Ah-2Fh",	0);
	set_cmt	(0XD110,	"skip vector 30h & 31h",	0);
	set_cmt	(0XD113,	"sets segs for ints 32h-3Fh",	0);
	create_insn	(x=0XD113);
	op_dec		(x,	1);
	set_cmt	(0XD11B,	"[es:0C3h]",	0);
	create_insn	(x=0XD11B);
	create_insn	(0XD121);
	set_name	(0XD121,	"patch_misc_segments");
	set_cmt	(0XD124,	"ax - > DOS segment",	0);
	set_cmt	(0XD127,	"es -> DOSDATA",	0);
	set_cmt	(0XD128,	"initialize the jump table for the sharer",	0);
	create_insn	(x=0XD128);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD12B,	"bx = location to which the share\ntable was patched during the first\ncall to this routine",	0);
	create_insn	(x=0XD12B);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(x=0XD12F);
	op_dec		(x,	1);
	set_cmt	(0XD133,	"skip offset",	0);
	set_cmt	(0XD134,	"Q: is this called for the 1st time",	0);
	set_cmt	(0XD137,	"Y: patch in sharer table\nN:",	0);
	set_cmt	(0XD139,	"Q: has share been installed",	0);
	set_cmt	(0XD13C,	"Y: don't patch in sharer table",	0);
	set_cmt	(0XD13E,	"drop in segment",	0);
	create_insn	(x=0XD141);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD144,	"[si+DOS_CCDPG.ccUcase_ptr+2]",	0);
	set_cmt	(0XD147,	"[si+DOS_CCDPG.ccFileUcase_ptr+2]",	0);
	set_cmt	(0XD14A,	"[si+DOS_CCDPG.ccFileChar_ptr+2]",	0);
	set_cmt	(0XD14D,	"[si+DOS_CCDPG.ccCollate_ptr+2]",	0);
	set_cmt	(0XD150,	"[si+DOS_CCDPG.ccMono_ptr+2]",	0);
	set_cmt	(0XD154,	"[si+DOS_CCDPG.ccDBCS_ptr+2]",	0);
	set_cmt	(0XD157,	"fastopen routines are in doscode\nso patch with doscode seg in ax",	0);
	create_insn	(x=0XD157);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD15A,	"Q: first time",	0);
	create_insn	(x=0XD15A);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XD15F,	"Y: patch segment",	0);
	set_cmt	(0XD161,	"Q: has fastopen patched in it's segment",	0);
	create_insn	(x=0XD161);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD165,	"[si+fastopen_entry.name_caching+2]",	0);
	set_cmt	(0XD168,	"Y: don't patch in doscode seg",	0);
	set_cmt	(0XD16A,	"[si+fastopen_entry.name_caching+2]",	0);
	create_insn	(0XD171);
	set_name	(0XD171,	"patch_offset");
	set_cmt	(0XD172,	"0",	0);
	set_cmt	(0XD174,	"set default divide trap address",	0);
	create_insn	(x=0XD176);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD17D,	"INTBASE ; di-> offset of int 20 handler",	0);
	create_insn	(x=0XD180);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD183,	"set vectors 20h & 21h to point to iret",	0);
	set_cmt	(0XD18B,	"skip vector 22h",	0);
	set_cmt	(0XD18E,	"set offset of 23h",	0);
	set_cmt	(0XD18F,	"skip 24h",	0);
	set_cmt	(0XD192,	"sets offsets for ints 25h-28h",	0);
	set_cmt	(0XD19A,	"skip vector 29h",	0);
	set_cmt	(0XD19D,	"sets offsets for ints 2Ah-2Fh",	0);
	set_cmt	(0XD1A5,	"skip vector 30h & 31h",	0);
	set_cmt	(0XD1A8,	"sets offsets for ints 32h-3Fh",	0);
	create_insn	(x=0XD1A8);
	op_dec		(x,	1);
	set_cmt	(0XD1B0,	"INT 2Fh",	0);
	create_insn	(x=0XD1B0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD1B7,	"[es:ENTRYPOINT],mi_long_jmp",	0);
	create_insn	(x=0XD1B7);
	op_hex		(x,	1);
	set_cmt	(0XD1BD,	"[es:ENTRYPOINT+1],lcall_entry",	0);
	create_insn	(x=0XD1BD);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD1C4,	"[es:addr_int_abort] ; INT 20h",	0);
	create_insn	(x=0XD1C4);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD1CB,	"[es:addr_int_command] ; INT 21h",	0);
	create_insn	(x=0XD1CB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD1D2,	"[es:addr_int_disk_read] ; INT 25h",	0);
	create_insn	(x=0XD1D2);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD1D9,	"[es:addr_int_disk_write] ; INT 26h",	0);
	create_insn	(x=0XD1D9);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD1E0,	"[es:addr_int_keep_process] ; INT 27h",	0);
	create_insn	(x=0XD1E0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_cmt	(0XD1E9,	"i0patch",	0);
	create_word	(x=0XD1E9);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_name	(0XD1E9,	"patch_table");
	set_cmt	(0XD1EB,	"i20patch",	0);
	create_word	(x=0XD1EB);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XD1ED,	"i21patch",	0);
	create_word	(x=0XD1ED);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XD1EF,	"i25patch",	0);
	create_word	(x=0XD1EF);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XD1F1,	"i26patch",	0);
	create_word	(x=0XD1F1);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XD1F3,	"i27patch",	0);
	create_word	(x=0XD1F3);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XD1F5,	"i2fpatch",	0);
	create_word	(x=0XD1F5);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	set_cmt	(0XD1F7,	"cpmpatch",	0);
	create_word	(x=0XD1F7);
	op_plain_offset	(x,	0,	0);
	op_plain_offset	(x,	128,	0);
	create_insn	(0XD1F9);
	set_name	(0XD1F9,	"patch_in_nops");
	create_insn	(x=0XD1FB);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
}

static Functions_0(void) {

	add_func    (0X106F,0X107B);
	set_func_flags(0X106F,0x4400);
	set_frame_size(0X106F, 0X2, 0, 0);
	add_func    (0X1085,0X10FC);
	set_func_flags(0X1085,0x4400);
	set_frame_size(0X1085, 0, 0, 0);
	set_name(0X10A0, "EA20_RET", SN_LOCAL);
	set_name(0X10A7, "EA20_OFF", SN_LOCAL);
	set_name(0X10D3, "XMMerror", SN_LOCAL);
	set_name(0X10E0, "XMMcont", SN_LOCAL);
	set_name(0X10EB, "XMMprnt", SN_LOCAL);
	set_name(0X10F9, "XMMStall", SN_LOCAL);
	add_func    (0X431F,0X4336);
	set_func_flags(0X431F,0x400);
	set_frame_size(0X431F, 0, 0, 0);
	add_func    (0X4336,0X4355);
	set_func_flags(0X4336,0x4400);
	set_frame_size(0X4336, 0, 0, 0);
	add_func    (0X4355,0X435F);
	set_func_flags(0X4355,0x4400);
	set_frame_size(0X4355, 0, 0, 0);
	add_func    (0X436B,0X43C4);
	set_func_flags(0X436B,0x400);
	set_frame_size(0X436B, 0, 0, 0);
	set_name(0X437E, "AbsSetup1", SN_LOCAL);
	set_name(0X43C3, "AbsSetup_retn", SN_LOCAL);
	add_func    (0X447C,0X44C7);
	set_func_flags(0X447C,0x4402);
	set_frame_size(0X447C, 0, 0, 0);
	set_name(0X43CA, "absdrd_1", SN_LOCAL);
	set_name(0X43DE, "absdrd_2", SN_LOCAL);
	set_name(0X43E0, "absdrd_3", SN_LOCAL);
	set_name(0X43F2, "absdrd_4", SN_LOCAL);
	set_name(0X4400, "absdrd_5", SN_LOCAL);
	set_name(0X4427, "TLEAVE", SN_LOCAL);
	set_name(0X446F, "ILEAVE_EXTD", SN_LOCAL);
	set_name(0X4497, "absdwrt_1", SN_LOCAL);
	set_name(0X44A0, "absdrwt_2", SN_LOCAL);
	set_name(0X44A5, "absdrwt_3", SN_LOCAL);
	add_func    (0X44C7,0X4505);
	set_func_flags(0X44C7,0x4400);
	set_frame_size(0X44C7, 0, 0, 0);
	set_name(0X44E2, "SKIPGET", SN_LOCAL);
	set_name(0X44E6, "GETBP_@f", SN_LOCAL);
	set_name(0X44F1, "GETBP_err", SN_LOCAL);
	set_name(0X44F9, "GETBP_CDS", SN_LOCAL);
	add_func    (0X4505,0X450E);
	set_func_flags(0X4505,0x4400);
	set_frame_size(0X4505, 0, 0, 0);
	add_func    (0X452D,0X4539);
	set_func_flags(0X452D,0x4400);
	set_frame_size(0X452D, 0, 0, 0);
	add_func    (0X4539,0X4551);
	set_func_flags(0X4539,0x4400);
	set_frame_size(0X4539, 0X2, 0, 0);
	set_name(0X454C, "EXTENDED_NORMAL", SN_LOCAL);
	add_func    (0X4551,0X4588);
	set_func_flags(0X4551,0x4400);
	set_frame_size(0X4551, 0, 0, 0);
	set_name(0X455D, "TABLK1", SN_LOCAL);
	set_name(0X456B, "GOT_VALS", SN_LOCAL);
	set_name(0X4575, "NO_SET_ACT", SN_LOCAL);
	set_name(0X457C, "NO_SET_CLS", SN_LOCAL);
	set_name(0X4584, "NO_SET_LOC", SN_LOCAL);
	add_func    (0X4588,0X45C3);
	set_func_flags(0X4588,0x4000);
	set_frame_size(0X4588, 0, 0, 0);
	set_name(0X459A, "TABLK2", SN_LOCAL);
	set_name(0X45AC, "NOT_IN_TABLE", SN_LOCAL);
	set_name(0X45B0, "GOT_CALL", SN_LOCAL);
	set_name(0X45B4, "CHECK_CODE", SN_LOCAL);
	set_name(0X45BC, "NO_MAP", SN_LOCAL);
	add_func    (0X45C3,0X45D4);
	set_func_flags(0X45C3,0x4400);
	set_frame_size(0X45C3, 0, 0, 0);
	add_func    (0X45D4,0X45D8);
	set_func_flags(0X45D4,0x4402);
	set_frame_size(0X45D4, 0, 0, 0);
	add_func    (0X45D8,0X45DA);
	set_func_flags(0X45D8,0x4402);
	set_frame_size(0X45D8, 0, 0, 0);
	add_func    (0X47B8,0X47C5);
	set_func_flags(0X47B8,0x4400);
	set_frame_size(0X47B8, 0, 0, 0);
	add_func    (0X4863,0X48A3);
	set_func_flags(0X4863,0x4400);
	set_frame_size(0X4863, 0, 0, 0);
	set_name(0X4885, "letold", SN_LOCAL);
	set_name(0X4889, "rw32_conv_err", SN_LOCAL);
	set_name(0X488B, "new32format", SN_LOCAL);
	set_name(0X48A1, "old_style", SN_LOCAL);
	add_func    (0X48A3,0X48C3);
	set_func_flags(0X48A3,0x4400);
	set_frame_size(0X48A3, 0X4, 0, 0);
	set_name(0X48BF, "nofast", SN_LOCAL);
	add_func    (0X4980,0X499D);
	set_func_flags(0X4980,0x4400);
	set_frame_size(0X4980, 0, 0, 0);
	add_func    (0X499D,0X49BD);
	set_func_flags(0X499D,0x4400);
	set_frame_size(0X499D, 0, 0, 0);
	add_func    (0X49BD,0X49CE);
	set_func_flags(0X49BD,0x4400);
	set_frame_size(0X49BD, 0, 0, 0);
	add_func    (0X49CE,0X4A13);
	set_func_flags(0X49CE,0x4400);
	set_frame_size(0X49CE, 0, 0, 0);
	add_func    (0X4A13,0X4A3D);
	set_func_flags(0X4A13,0x4400);
	set_frame_size(0X4A13, 0, 0, 0);
	add_func    (0X4A3D,0X4AB0);
	set_func_flags(0X4A3D,0x4400);
	set_frame_size(0X4A3D, 0X4, 0, 0);
	set_name(0X4A95, "SK", SN_LOCAL);
	add_func    (0X4AB0,0X4ABC);
	set_func_flags(0X4AB0,0x400);
	set_name(0X4AB2, "DSLIDE1", SN_LOCAL);
	add_func    (0X4ABC,0X4AD2);
	set_func_flags(0X4ABC,0x4400);
	set_frame_size(0X4ABC, 0, 0, 0);
	set_name(0X4ACE, "SAVFEB", SN_LOCAL);
	add_func    (0X4AD2,0X4B55);
	set_func_flags(0X4AD2,0x400);
	set_frame_size(0X4AD2, 0, 0, 0);
	add_func    (0X4B55,0X4B5F);
	set_func_flags(0X4B55,0x4400);
	set_frame_size(0X4B55, 0, 0, 0);
	set_name(0X4B59, "DSUM1", SN_LOCAL);
	set_name(0X4B5E, "DSUM9", SN_LOCAL);
	add_func    (0X4B5F,0X4B81);
	set_func_flags(0X4B5F,0x4400);
	set_frame_size(0X4B5F, 0, 0, 0);
	add_func    (0X4B8D,0X4BB8);
	set_func_flags(0X4B8D,0x400);
	add_func    (0X4BB8,0X4BE2);
	set_func_flags(0X4BB8,0x4400);
	set_frame_size(0X4BB8, 0, 0, 0);
	set_name(0X4BD6, "stcdpg", SN_LOCAL);
	set_name(0X4BDC, "setcarry", SN_LOCAL);
	set_name(0X4BDE, "interr", SN_LOCAL);
	add_func    (0X4C4A,0X4D73);
	set_func_flags(0X4C4A,0x400);
	set_name(0X4D45, "setsize2", SN_LOCAL);
	set_name(0X4D62, "NLSNXT", SN_LOCAL);
	add_func    (0X4D73,0X4DC4);
	set_func_flags(0X4D73,0x400);
	add_func    (0X4E2A,0X4E39);
	set_func_flags(0X4E2A,0x400);
	add_func    (0X4E5D,0X4E68);
	set_func_flags(0X4E5D,0x4400);
	set_frame_size(0X4E5D, 0, 0, 0);
	add_func    (0X51CA,0X51D3);
	set_func_flags(0X51CA,0x4400);
	set_frame_size(0X51CA, 0, 0, 0);
	add_func    (0X51D3,0X51D8);
	set_func_flags(0X51D3,0x4400);
	set_frame_size(0X51D3, 0, 0, 0);
	add_func    (0X51D8,0X51DD);
	set_func_flags(0X51D8,0x4400);
	set_frame_size(0X51D8, 0, 0, 0);
	add_func    (0X51DD,0X51E2);
	set_func_flags(0X51DD,0x4400);
	set_frame_size(0X51DD, 0, 0, 0);
	add_func    (0X5369,0X554F);
	set_func_flags(0X5369,0x4400);
	set_frame_size(0X5369, 0, 0, 0);
	set_name(0X537B, "not_fat32_extension", SN_LOCAL);
	set_name(0X537D, "chk_fat32_conditions", SN_LOCAL);
	set_name(0X5390, "nofat", SN_LOCAL);
	set_name(0X53A3, "yesfat", SN_LOCAL);
	set_name(0X53B1, "LOG2LOOP", SN_LOCAL);
	set_name(0X53BB, "SAVLOG", SN_LOCAL);
	set_name(0X53F2, "savlog1", SN_LOCAL);
	set_name(0X5411, "savlog2", SN_LOCAL);
	set_name(0X542E, "savlog3", SN_LOCAL);
	set_name(0X5449, "rott", SN_LOCAL);
	set_name(0X5450, "norot", SN_LOCAL);
	set_name(0X5454, "normal_dpb", SN_LOCAL);
	set_name(0X545E, "setend", SN_LOCAL);
	set_name(0X547A, "setend1", SN_LOCAL);
	set_name(0X5492, "setend2", SN_LOCAL);
	set_name(0X549B, "setend3", SN_LOCAL);
	set_name(0X54A7, "setend4", SN_LOCAL);
	set_name(0X54AB, "setend5", SN_LOCAL);
	set_name(0X54B4, "setend_fat12", SN_LOCAL);
	set_name(0X54C2, "setend_fat16", SN_LOCAL);
	set_name(0X54D0, "setend_faterr", SN_LOCAL);
	set_name(0X54D4, "setend_fat32", SN_LOCAL);
	set_name(0X54E9, "setend6", SN_LOCAL);
	set_name(0X54ED, "setend7", SN_LOCAL);
	set_name(0X5512, "setend8", SN_LOCAL);
	set_name(0X5515, "setend9", SN_LOCAL);
	set_name(0X551F, "setend10", SN_LOCAL);
	set_name(0X5522, "setend11", SN_LOCAL);
	set_name(0X5536, "setend12", SN_LOCAL);
	set_name(0X5543, "setend_fat", SN_LOCAL);
	add_func    (0X554F,0X55E9);
	set_func_flags(0X554F,0x4400);
	set_frame_size(0X554F, 0X2, 0, 0);
	set_name(0X556A, "CreateCopy", SN_LOCAL);
	set_name(0X5599, "Create_dup_jfn", SN_LOCAL);
	set_name(0X55C5, "CreateStash", SN_LOCAL);
	set_name(0X55DC, "Create_PDB_cont", SN_LOCAL);
	add_func    (0X55E9,0X5667);
	set_func_flags(0X55E9,0x4400);
	set_frame_size(0X55E9, 0, 0, 0);
	set_name(0X5607, "HAVDIF", SN_LOCAL);
	set_name(0X562D, "addr_ok", SN_LOCAL);
	add_func    (0X56B6,0X56D8);
	set_func_flags(0X56B6,0x4400);
	set_frame_size(0X56B6, 0X4, 0, 0);
	set_name(0X56B9, "Cmplp", SN_LOCAL);
	set_name(0X56D4, "PopRet", SN_LOCAL);
	add_func    (0X56D8,0X56E7);
	set_func_flags(0X56D8,0x4400);
	set_frame_size(0X56D8, 0, 0, 0);
	set_name(0X56D9, "CPYLoop", SN_LOCAL);
	add_func    (0X56E7,0X56F0);
	set_func_flags(0X56E7,0x4400);
	set_frame_size(0X56E7, 0, 0, 0);
	set_name(0X56E8, "FCPYLoop", SN_LOCAL);
	add_func    (0X56F0,0X56FE);
	set_func_flags(0X56F0,0x4400);
	set_frame_size(0X56F0, 0X2, 0, 0);
	add_func    (0X56FE,0X5708);
	set_func_flags(0X56FE,0x4400);
	set_frame_size(0X56FE, 0, 0, 0);
	add_func    (0X5708,0X570F);
	set_func_flags(0X5708,0x4400);
	set_frame_size(0X5708, 0, 0, 0);
	add_func    (0X570F,0X5729);
	set_func_flags(0X570F,0x4400);
	set_frame_size(0X570F, 0, 0, 0);
	set_name(0X571F, "Idle1", SN_LOCAL);
	set_name(0X5722, "Idle2", SN_LOCAL);
	set_name(0X5727, "Idle3", SN_LOCAL);
	add_func    (0X5729,0X5754);
	set_func_flags(0X5729,0x4410);
	set_frame_size(0X5729, 0X2, 2, 0);
	define_local_var(0X5729, 0X5754, "[bp+0X4]", "TFrame.Index");
	define_local_var(0X5729, 0X5754, "[bp+0X6]", "TFrame.Tab");
	set_name(0X574F, "TableError", SN_LOCAL);
	add_func    (0X5754,0X576D);
	set_func_flags(0X5754,0x4400);
	set_frame_size(0X5754, 0, 0, 0);
	set_name(0X576B, "CMCRet", SN_LOCAL);
	add_func    (0X576D,0X5773);
	set_func_flags(0X576D,0x4400);
	set_frame_size(0X576D, 0, 0, 0);
	add_func    (0X57D4,0X57E3);
	set_func_flags(0X57D4,0x4400);
	set_frame_size(0X57D4, 0, 0, 0);
	add_func    (0X580D,0X583D);
	set_func_flags(0X580D,0x4400);
	set_frame_size(0X580D, 0, 0, 0);
	add_func    (0X583D,0X584E);
	set_func_flags(0X583D,0x400);
	add_func    (0X584E,0X585F);
	set_func_flags(0X584E,0x4400);
	set_frame_size(0X584E, 0, 0, 0);
	add_func    (0X585F,0X5870);
	set_func_flags(0X585F,0x400);
	add_func    (0X5870,0X58C8);
	set_func_flags(0X5870,0x4400);
	set_frame_size(0X5870, 0, 0, 0);
	set_name(0X5872, "INTEST", SN_LOCAL);
	set_name(0X5884, "no_sys_wait", SN_LOCAL);
	set_name(0X58AA, "NoUpdate", SN_LOCAL);
	set_name(0X58B1, "GET", SN_LOCAL);
	add_func    (0X58D4,0X58F1);
	set_func_flags(0X58D4,0x400);
	set_name(0X58EC, "NOEDIT", SN_LOCAL);
	set_name(0X58EE, "EDITON", SN_LOCAL);
	add_func    (0X5993,0X59F2);
	set_func_flags(0X5993,0x4400);
	set_frame_size(0X5993, 0, 0, 0);
	add_func    (0X59F2,0X59F5);
	set_func_flags(0X59F2,0x400);
	add_func    (0X59F5,0X5A04);
	set_func_flags(0X59F5,0x400);
	add_func    (0X5A46,0X5A95);
	set_func_flags(0X5A46,0x4400);
	set_frame_size(0X5A46, 0, 0, 0);
	set_name(0X4967, "OEMFunctionKey", SN_LOCAL);
	set_name(0X58F1, "NEWLIN", SN_LOCAL);
	set_name(0X5910, "GOTCH", SN_LOCAL);
	set_name(0X5932, "SAVCH", SN_LOCAL);
	set_name(0X594D, "BUFFUL", SN_LOCAL);
	set_name(0X5954, "ESCAPE", SN_LOCAL);
	set_name(0X5957, "ENDLIN", SN_LOCAL);
	set_name(0X596D, "PHYCRLF", SN_LOCAL);
	set_name(0X5970, "GETCH_j", SN_LOCAL);
	set_name(0X5981, "PUTNEW", SN_LOCAL);
	set_name(0X5A18, "COPYEACH", SN_LOCAL);
	set_name(0X5A55, "FINDSETUP", SN_LOCAL);
	set_name(0X5A72, "NOTFND", SN_LOCAL);
	set_name(0X5A73, "GETCH2_j", SN_LOCAL);
	add_func    (0X5A95,0X5A9F);
	set_func_flags(0X5A95,0x400);
	add_func    (0X5AE7,0X5B1B);
	set_func_flags(0X5AE7,0x4400);
	set_frame_size(0X5AE7, 0X2, 0, 0);
	set_name(0X5B13, "RAWRET", SN_LOCAL);
	set_name(0X5B14, "RAWRET1", SN_LOCAL);
	set_name(0X5B16, "RAWNORM", SN_LOCAL);
	add_func    (0X5B1B,0X5B20);
	set_func_flags(0X5B1B,0x400);
	add_func    (0X5B20,0X5B42);
	set_func_flags(0X5B20,0x4400);
	set_frame_size(0X5B20, 0, 0, 0);
	set_name(0X5B23, "ROLP", SN_LOCAL);
	set_name(0X5B30, "RAWOSTRT", SN_LOCAL);
	set_name(0X5B40, "nosend", SN_LOCAL);
	add_func    (0X5B42,0X5B60);
	set_func_flags(0X5B42,0x4400);
	set_frame_size(0X5B42, 0, 0, 0);
	set_name(0X5B52, "save_packet", SN_LOCAL);
	add_func    (0X5B72,0X5BE1);
	set_func_flags(0X5B72,0x400);
	set_name(0X5B69, "outch2", SN_LOCAL);
	set_name(0X5B7F, "OUTCH", SN_LOCAL);
	set_name(0X5B8E, "OUTSKIP", SN_LOCAL);
	set_name(0X5BC7, "TRIPOPJ", SN_LOCAL);
	set_name(0X5BCA, "LISSTRT2J", SN_LOCAL);
	set_name(0X5BCD, "CTRLOUT", SN_LOCAL);
	set_name(0X5BF1, "ZERPOS", SN_LOCAL);
	set_name(0X5BFC, "BACKPOS", SN_LOCAL);
	set_name(0X5C51, "LISSTRT2", SN_LOCAL);
	set_name(0X5C54, "TRIPOP", SN_LOCAL);
	add_func    (0X5BE1,0X5BF1);
	set_func_flags(0X5BE1,0x4400);
	set_frame_size(0X5BE1, 0, 0, 0);
	set_name(0X5BE8, "TABLP", SN_LOCAL);
	set_name(0X5BEF, "POPTAB", SN_LOCAL);
	add_func    (0X5C04,0X5C21);
	set_func_flags(0X5C04,0x4400);
	set_frame_size(0X5C04, 0, 0, 0);
	set_name(0X5C1D, "CTRLU", SN_LOCAL);
	add_func    (0X5DAE,0X5E58);
	set_func_flags(0X5DAE,0x4400);
	set_frame_size(0X5DAE, 0, 0, 0);
	set_name(0X5DC3, "SaveLocal", SN_LOCAL);
	set_name(0X5DFE, "SetFCBBits", SN_LOCAL);
	set_name(0X5E11, "SaveNoShareDev", SN_LOCAL);
	set_name(0X5E21, "SaveShare", SN_LOCAL);
	set_name(0X5E26, "SaveSFN", SN_LOCAL);
	set_name(0X5E37, "SaveNoSFN", SN_LOCAL);
	set_name(0X5E53, "SimpleStuff", SN_LOCAL);
	add_func    (0X5E58,0X5E7C);
	set_func_flags(0X5E58,0x4400);
	set_frame_size(0X5E58, 0, 0, 0);
	set_name(0X5E69, "ovScan", SN_LOCAL);
	set_name(0X5E71, "ovLoop", SN_LOCAL);
	add_func    (0X5E7C,0X5F62);
	set_func_flags(0X5E7C,0x4400);
	set_frame_size(0X5E7C, 0, 0, 0);
	set_name(0X5E93, "gotlocalSFT", SN_LOCAL);
	set_name(0X5E9F, "lru1", SN_LOCAL);
	set_name(0X5EB3, "findSFT", SN_LOCAL);
	set_name(0X5ECC, "hackpoint", SN_LOCAL);
	set_name(0X5EE4, "lru4", SN_LOCAL);
	set_name(0X5EF8, "lru5", SN_LOCAL);
	set_name(0X5F06, "gotSFT", SN_LOCAL);
	set_name(0X5F20, "notinvalid", SN_LOCAL);
	set_name(0X5F23, "gotnetSFT", SN_LOCAL);
	set_name(0X5F2F, "closenet", SN_LOCAL);
	set_name(0X5F37, "LRUClose", SN_LOCAL);
	set_name(0X5F46, "errorbadSFT", SN_LOCAL);
	set_name(0X5F49, "LRUDone", SN_LOCAL);
	set_name(0X5F4E, "LRUDead", SN_LOCAL);
	set_name(0X5F5F, "LruFCB_err", SN_LOCAL);
	add_func    (0X5F62,0X5F6A);
	set_func_flags(0X5F62,0x4400);
	set_frame_size(0X5F62, 0, 0, 0);
	add_func    (0X5F6A,0X5FF2);
	set_func_flags(0X5F6A,0x400);
	set_frame_size(0X5F6A, 0, 0, 0);
	set_name(0X5F7F, "RegenFail", SN_LOCAL);
	set_name(0X5F8B, "RegenDead", SN_LOCAL);
	set_name(0X5F8C, "FCBRegen_retn", SN_LOCAL);
	set_name(0X5F8D, "RegenNoSharing", SN_LOCAL);
	set_name(0X5FFB, "RegenDeadJ", SN_LOCAL);
	set_name(0X5FFD, "RegenFileNoSharing", SN_LOCAL);
	add_func    (0X5FF2,0X5FFB);
	set_func_flags(0X5FF2,0x4400);
	set_frame_size(0X5FF2, 0, 0, 0);
	add_func    (0X6065,0X607E);
	set_func_flags(0X6065,0x4400);
	set_frame_size(0X6065, 0, 0, 0);
	add_func    (0X607E,0X60EC);
	set_func_flags(0X607E,0x4400);
	set_frame_size(0X607E, 0, 0, 0);
	set_name(0X60BE, "CheckD", SN_LOCAL);
	set_name(0X60CC, "BadSFT", SN_LOCAL);
	set_name(0X60CE, "CheckNet", SN_LOCAL);
	set_name(0X60D8, "CheckNoShare", SN_LOCAL);
	add_func    (0X60EC,0X6122);
	set_func_flags(0X60EC,0x4400);
	set_frame_size(0X60EC, 0X4, 0, 0);
	set_name(0X6113, "Set_SFT", SN_LOCAL);
	add_func    (0X6122,0X615F);
	set_func_flags(0X6122,0x4400);
	set_frame_size(0X6122, 0, 0, 0);
	set_name(0X614D, "fcbharderr_fat32", SN_LOCAL);
	set_name(0X615A, "fcbharderr_fat", SN_LOCAL);
	add_func    (0X615F,0X616A);
	set_func_flags(0X615F,0x400);
	add_func    (0X616D,0X617F);
	set_func_flags(0X616D,0x400);
	set_name(0X616A, "GetExtent_bye", SN_LOCAL);
	add_func    (0X617F,0X6199);
	set_func_flags(0X617F,0x4400);
	set_frame_size(0X617F, 0, 0, 0);
	add_func    (0X6199,0X61A6);
	set_func_flags(0X6199,0x4400);
	set_frame_size(0X6199, 0, 0, 0);
	set_name(0X61A3, "GetBye", SN_LOCAL);
	add_func    (0X61A6,0X61B3);
	set_func_flags(0X61A6,0x4400);
	set_frame_size(0X61A6, 0, 0, 0);
	add_func    (0X6627,0X6659);
	set_func_flags(0X6627,0x4400);
	set_frame_size(0X6627, 0, 0, 0);
	set_name(0X662C, "main_kill_tail", SN_LOCAL);
	set_name(0X663A, "find_check_dot", SN_LOCAL);
	set_name(0X6646, "got_ext", SN_LOCAL);
	set_name(0X664B, "ext_kill_tail", SN_LOCAL);
	set_name(0X6655, "find_done", SN_LOCAL);
	add_func    (0X6664,0X66C8);
	set_func_flags(0X6664,0x400);
	add_func    (0X67E4,0X67E9);
	set_func_flags(0X67E4,0x4400);
	set_frame_size(0X67E4, 0, 0, 0);
	add_func    (0X67E9,0X67F7);
	set_func_flags(0X67E9,0x4400);
	set_frame_size(0X67E9, 0, 0, 0);
	add_func    (0X681B,0X6A91);
	set_func_flags(0X681B,0x400);
	set_frame_size(0X681B, 0, 0, 0);
	set_name(0X4515, "DO_RET", SN_LOCAL);
	set_name(0X6830, "ioctl_bad_funj2", SN_LOCAL);
	set_name(0X6838, "ioctl_bad_handle", SN_LOCAL);
	set_name(0X683A, "ioctl_error", SN_LOCAL);
	set_name(0X683D, "ioctl_check_permissions", SN_LOCAL);
	set_name(0X684D, "ioctl_check_device", SN_LOCAL);
	set_name(0X685B, "ioctl_ok", SN_LOCAL);
	set_name(0X685E, "ioctl_read", SN_LOCAL);
	set_name(0X6872, "ioctl_no_high", SN_LOCAL);
	set_name(0X687A, "ioctl_ok_j", SN_LOCAL);
	set_name(0X6886, "ioctl_bad_funj", SN_LOCAL);
	set_name(0X689C, "ioctl_get_status", SN_LOCAL);
	set_name(0X68A3, "ioctl_bad_handle_j", SN_LOCAL);
	set_name(0X68A5, "DO_IOFUNC", SN_LOCAL);
	set_name(0X68B0, "ioctl_status_ret", SN_LOCAL);
	set_name(0X68E7, "ioctl_bad_funj3", SN_LOCAL);
	set_name(0X68EA, "GenIOCTL_chk_net", SN_LOCAL);
	set_name(0X68F3, "Do_GenIOCTL", SN_LOCAL);
	set_name(0X68FD, "GenioCTL_extended", SN_LOCAL);
	set_name(0X6907, "GenIOCTL_chk_lock", SN_LOCAL);
	set_name(0X6915, "GenIOCTL_lock_unlock", SN_LOCAL);
	set_name(0X692D, "GenIOCTL_lock", SN_LOCAL);
	set_name(0X6932, "GenIOCTL_OK", SN_LOCAL);
	set_name(0X6935, "GenIOCTL_normal", SN_LOCAL);
	set_name(0X6951, "SetIOCtlBlock", SN_LOCAL);
	set_name(0X697E, "ioctl_bad_fun", SN_LOCAL);
	set_name(0X69C1, "ioctl_da_ok_j", SN_LOCAL);
	set_name(0X69D9, "ioctl_drive_attr2", SN_LOCAL);
	set_name(0X69EA, "IOCTLShare", SN_LOCAL);
	set_name(0X6A05, "IOCTLLocal", SN_LOCAL);
	set_name(0X6A10, "ioctl_set_DX", SN_LOCAL);
	set_name(0X6A16, "ioctl_gd_ok_j", SN_LOCAL);
	set_name(0X6A1A, "ioctl_gd_err_j", SN_LOCAL);
	set_name(0X6A25, "ioctl_got_sft", SN_LOCAL);
	set_name(0X6A2B, "ioctl_bad_funj5", SN_LOCAL);
	set_name(0X6A33, "ioctl_do_string", SN_LOCAL);
	set_name(0X6A48, "ioctl_control_call", SN_LOCAL);
	set_name(0X6A6C, "ioctl_do_IO", SN_LOCAL);
	set_name(0X6A7D, "ioctl_string_err", SN_LOCAL);
	set_name(0X6AC7, "ioctl_bad_funj4", SN_LOCAL);
	set_name(0X6ACA, "ioctl_string_errj", SN_LOCAL);
	set_name(0X6AE6, "GetOwner", SN_LOCAL);
	add_func    (0X6A91,0X6ABD);
	set_func_flags(0X6A91,0x4400);
	set_frame_size(0X6A91, 0, 0, 0);
	set_name(0X6ABA, "got_dev_ptr", SN_LOCAL);
	set_name(0X6ABB, "ioctl_bad_drv", SN_LOCAL);
	add_func    (0X6ABD,0X6AC7);
	set_func_flags(0X6ABD,0x4400);
	set_frame_size(0X6ABD, 0, 0, 0);
	set_name(0X6AC3, "ioctl_drv_err_pop", SN_LOCAL);
	add_func    (0X6B11,0X6C77);
	set_func_flags(0X6B11,0x4400);
	set_frame_size(0X6B11, 0, 0, 0);
	set_name(0X6B1C, "LOCAL_DELETE", SN_LOCAL);
	set_name(0X6B2E, "SKPNUL", SN_LOCAL);
	set_name(0X6B42, "TEST_QUEST", SN_LOCAL);
	set_name(0X6B61, "CHECK_ATTS", SN_LOCAL);
	set_name(0X6B6F, "NOT_ALL", SN_LOCAL);
	set_name(0X6B7F, "No_file", SN_LOCAL);
	set_name(0X6B82, "ErrorReturn", SN_LOCAL);
	set_name(0X6B86, "_bad_path", SN_LOCAL);
	set_name(0X6B8B, "Del_found", SN_LOCAL);
	set_name(0X6B94, "Del_access_err", SN_LOCAL);
	set_name(0X6B99, "NOT_DIR", SN_LOCAL);
	set_name(0X6B9D, "DELFILE", SN_LOCAL);
	set_name(0X6BB9, "Skip_it", SN_LOCAL);
	set_name(0X6BBC, "DoDelete", SN_LOCAL);
	set_name(0X6BCE, "yesdirty", SN_LOCAL);
	set_name(0X6BDB, "yesdirty_fc_1", SN_LOCAL);
	set_name(0X6BF2, "yesdirty_fc_2", SN_LOCAL);
	set_name(0X6C0D, "yesdirty_fc_3", SN_LOCAL);
	set_name(0X6C11, "yesdirty_fc_4", SN_LOCAL);
	set_name(0X6C1B, "DELNXT", SN_LOCAL);
	set_name(0X6C2C, "DELNXT2", SN_LOCAL);
	set_name(0X6C66, "No_Set_Flag", SN_LOCAL);
	set_name(0X6C6A, "DelError", SN_LOCAL);
	set_name(0X6C71, "No_fileJ", SN_LOCAL);
	set_name(0X6C74, "Del_access_errJ", SN_LOCAL);
	add_func    (0X6C77,0X6CF9);
	set_func_flags(0X6C77,0x4400);
	set_frame_size(0X6C77, 0, 0, 0);
	set_name(0X6CBD, "rdc_1", SN_LOCAL);
	set_name(0X6CC7, "rdc_2", SN_LOCAL);
	set_name(0X6CEF, "CheckDone", SN_LOCAL);
	add_func    (0X6CF9,0X6D07);
	set_func_flags(0X6CF9,0);
	add_func    (0X6D21,0X6D2A);
	set_func_flags(0X6D21,0x400);
	add_func    (0X6D2A,0X6D31);
	set_func_flags(0X6D2A,0x4400);
	set_frame_size(0X6D2A, 0, 0, 0);
	add_func    (0X6D31,0X6F4F);
	set_func_flags(0X6D31,0x4400);
	set_frame_size(0X6D31, 0, 0, 0);
	set_name(0X6D3C, "LOCAL_RENAME", SN_LOCAL);
	set_name(0X6D57, "SAMEDRV", SN_LOCAL);
	set_name(0X6D7E, "GOTERR", SN_LOCAL);
	set_name(0X6D7F, "RENAME_POP", SN_LOCAL);
	set_name(0X6D8B, "Check_Dev", SN_LOCAL);
	set_name(0X6DA3, "notdir", SN_LOCAL);
	set_name(0X6DBA, "RENAME_POPJ", SN_LOCAL);
	set_name(0X6DBC, "REN_OK1", SN_LOCAL);
	set_name(0X6DCC, "SWAP_SOURCE", SN_LOCAL);
	set_name(0X6DEF, "BAD_ACC", SN_LOCAL);
	set_name(0X6DF3, "RENAME_CLEAN", SN_LOCAL);
	set_name(0X6E0D, "BAD_ERR", SN_LOCAL);
	set_name(0X6E14, "NODEST", SN_LOCAL);
	set_name(0X6E21, "BAD_PATH", SN_LOCAL);
	set_name(0X6E27, "SAVEDEST", SN_LOCAL);
	set_name(0X6E40, "BUILDDEST", SN_LOCAL);
	set_name(0X6E99, "builddst_1", SN_LOCAL);
	set_name(0X6E9F, "builddst_2", SN_LOCAL);
	set_name(0X6EC0, "BAD_ACCJ", SN_LOCAL);
	set_name(0X6EC3, "GOT_DEST", SN_LOCAL);
	set_name(0X6EF0, "SIMPLE_RENAME", SN_LOCAL);
	set_name(0X6F03, "DIRTY_IT", SN_LOCAL);
	set_name(0X6F1B, "NOT_DIR2", SN_LOCAL);
	set_name(0X6F37, "jmp_to_rename_clean", SN_LOCAL);
	set_name(0X6F3A, "REN_OK2", SN_LOCAL);
	set_name(0X6F44, "jmp_to_builddest", SN_LOCAL);
	set_name(0X6F47, "Ren_Directory", SN_LOCAL);
	set_name(0X6F4C, "RENAME_OVER", SN_LOCAL);
	add_func    (0X6F4F,0X6F76);
	set_func_flags(0X6F4F,0x4400);
	set_frame_size(0X6F4F, 0, 0, 0);
	set_name(0X6F5F, "gs_cont", SN_LOCAL);
	set_name(0X6F75, "gs_ret_label", SN_LOCAL);
	add_func    (0X6F76,0X6F82);
	set_func_flags(0X6F76,0x4400);
	set_frame_size(0X6F76, 0, 0, 0);
	set_name(0X6F7D, "NOCHG", SN_LOCAL);
	add_func    (0X6F82,0X6FE3);
	set_func_flags(0X6F82,0x4400);
	set_frame_size(0X6F82, 0, 0, 0);
	set_name(0X6F8D, "LOCAL_INFO", SN_LOCAL);
	set_name(0X6FA3, "BadRet", SN_LOCAL);
	set_name(0X6FA4, "JustRet", SN_LOCAL);
	set_name(0X6FA8, "bad_path1", SN_LOCAL);
	set_name(0X6FAD, "info_check_dev", SN_LOCAL);
	set_name(0X6FBF, "not_root", SN_LOCAL);
	set_name(0X6FDF, "NO_SIZE", SN_LOCAL);
	add_func    (0X6FE3,0X7062);
	set_func_flags(0X6FE3,0x4400);
	set_frame_size(0X6FE3, 0, 0, 0);
	set_name(0X6FE8, "_BAD_ACC", SN_LOCAL);
	set_name(0X6FFA, "set_look", SN_LOCAL);
	set_name(0X7007, "LOCAL_SET", SN_LOCAL);
	set_name(0X7018, "set_check_device", SN_LOCAL);
	set_name(0X7022, "set_check_share", SN_LOCAL);
	set_name(0X7032, "jmp_to_OK_BYE", SN_LOCAL);
	set_name(0X7034, "cannot_set_root", SN_LOCAL);
	set_name(0X703A, "set_do", SN_LOCAL);
	add_func    (0X7062,0X7074);
	set_func_flags(0X7062,0x4400);
	set_frame_size(0X7062, 0, 0, 0);
	add_func    (0X7074,0X708A);
	set_func_flags(0X7074,0x4400);
	set_frame_size(0X7074, 0, 0, 0);
	set_name(0X7086, "DO_INC", SN_LOCAL);
	add_func    (0X7156,0X71A7);
	set_func_flags(0X7156,0x4400);
	set_frame_size(0X7156, 0X6, 0, 0);
	set_name(0X7165, "Set_Media_ID_1", SN_LOCAL);
	set_name(0X717C, "Set_Media_ID_2", SN_LOCAL);
	set_name(0X7185, "NoName", SN_LOCAL);
	set_name(0X7188, "doset", SN_LOCAL);
	set_name(0X71A1, "geterr", SN_LOCAL);
	add_func    (0X71A7,0X71BB);
	set_func_flags(0X71A7,0x4400);
	set_frame_size(0X71A7, 0, 0, 0);
	set_name(0X71BA, "NOTEX", SN_LOCAL);
	add_func    (0X72C0,0X72DE);
	set_func_flags(0X72C0,0x4400);
	set_frame_size(0X72C0, 0, 0, 0);
	set_name(0X72D4, "_HARD_ERR", SN_LOCAL);
	set_name(0X72D9, "_NO_HARD_ERR", SN_LOCAL);
	add_func    (0X72DE,0X72FE);
	set_func_flags(0X72DE,0x4400);
	set_frame_size(0X72DE, 0, 0, 0);
	set_name(0X72E1, "OPN_RETRY", SN_LOCAL);
	set_name(0X72E5, "OpenShareRetry", SN_LOCAL);
	set_name(0X72FA, "Share_Ok2", SN_LOCAL);
	add_func    (0X72FE,0X732B);
	set_func_flags(0X72FE,0x4400);
	set_frame_size(0X72FE, 0X2, 0, 0);
	set_name(0X7313, "CheckShareMode", SN_LOCAL);
	set_name(0X7318, "CheckAccessMode", SN_LOCAL);
	set_name(0X7325, "Make_Bad_Access", SN_LOCAL);
	add_func    (0X732B,0X7409);
	set_func_flags(0X732B,0x4400);
	set_frame_size(0X732B, 0, 0, 0);
	set_name(0X7340, "dsk_info_1", SN_LOCAL);
	set_name(0X7347, "disk_info_retn", SN_LOCAL);
	set_name(0X7348, "LOCAL_DSK_INFO", SN_LOCAL);
	set_name(0X735E, "dsk_info_2", SN_LOCAL);
	set_name(0X7363, "dsk_info_3", SN_LOCAL);
	set_name(0X7380, "dsk_info_4", SN_LOCAL);
	set_name(0X738E, "dsk_info_5", SN_LOCAL);
	set_name(0X7394, "dsk_info_6", SN_LOCAL);
	set_name(0X739A, "dsk_info_7", SN_LOCAL);
	set_name(0X739E, "dsk_info_8", SN_LOCAL);
	set_name(0X73AA, "SCANFREE", SN_LOCAL);
	set_name(0X73C1, "NOTFREECLUS", SN_LOCAL);
	set_name(0X73C8, "NOTFREECLUS2", SN_LOCAL);
	set_name(0X73D4, "NOTFREECLUS3", SN_LOCAL);
	set_name(0X73DE, "ReturnVals", SN_LOCAL);
	set_name(0X73FC, "ReturnVals2", SN_LOCAL);
	set_name(0X7401, "CRIT_LEAVE", SN_LOCAL);
	set_name(0X7405, "GotVal", SN_LOCAL);
	add_func    (0X7436,0X74E9);
	set_func_flags(0X7436,0x4400);
	set_frame_size(0X7436, 0, 0, 0);
	set_name(0X7449, "u_fat32_inf_1", SN_LOCAL);
	set_name(0X7451, "u_fat32_inf_2", SN_LOCAL);
	set_name(0X7469, "u_fat32_inf_3", SN_LOCAL);
	set_name(0X7475, "u_fat32_inf_4", SN_LOCAL);
	set_name(0X74E1, "u_fat32_inf_5", SN_LOCAL);
	add_func    (0X74E9,0X75E8);
	set_func_flags(0X74E9,0x4400);
	set_frame_size(0X74E9, 0, 0, 0);
	set_name(0X74F8, "TEST_RE_NET2", SN_LOCAL);
	set_name(0X7505, "LOCAL_SEARCH_FIRST", SN_LOCAL);
	set_name(0X7514, "NOFN", SN_LOCAL);
	set_name(0X7521, "getnext", SN_LOCAL);
	set_name(0X752F, "NO_Question", SN_LOCAL);
	set_name(0X753D, "BadBye", SN_LOCAL);
	set_name(0X7548, "bad_path3", SN_LOCAL);
	set_name(0X754D, "find_check_dev", SN_LOCAL);
	set_name(0X755B, "found_entry", SN_LOCAL);
	set_name(0X757C, "notfast", SN_LOCAL);
	set_name(0X757F, "movmov", SN_LOCAL);
	set_name(0X758C, "NOTKANJB", SN_LOCAL);
	set_name(0X75C2, "OKSTORE", SN_LOCAL);
	set_name(0X75C6, "DOSREL", SN_LOCAL);
	set_name(0X75DB, "NO05", SN_LOCAL);
	add_func    (0X75EC,0X7639);
	set_func_flags(0X75EC,0x4400);
	set_frame_size(0X75EC, 0, 0, 0);
	set_name(0X75F9, "LOCAL_SEARCH_NEXT", SN_LOCAL);
	add_func    (0X7639,0X7685);
	set_func_flags(0X7639,0x4400);
	set_frame_size(0X7639, 0, 0, 0);
	set_name(0X7666, "cont_load2", SN_LOCAL);
	set_name(0X7681, "No_files_pop", SN_LOCAL);
	add_func    (0X7685,0X76FE);
	set_func_flags(0X7685,0x4400);
	set_frame_size(0X7685, 0, 0, 0);
	set_name(0X768F, "reset_free_jfn", SN_LOCAL);
	set_name(0X76A9, "SFTFCB_check", SN_LOCAL);
	set_name(0X76BD, "FCBTest", SN_LOCAL);
	set_name(0X76C6, "FCBNext", SN_LOCAL);
	set_name(0X76CB, "SFTFCB_check2", SN_LOCAL);
	set_name(0X76D4, "FCBScanDone", SN_LOCAL);
	set_name(0X76D6, "Scan", SN_LOCAL);
	set_name(0X76DE, "Scan1", SN_LOCAL);
	set_name(0X76FB, "scan_next", SN_LOCAL);
	add_func    (0X76FE,0X7723);
	set_func_flags(0X76FE,0x4400);
	set_frame_size(0X76FE, 0, 0, 0);
	add_func    (0X7866,0X7873);
	set_func_flags(0X7866,0x4400);
	set_frame_size(0X7866, 0, 0, 0);
	set_name(0X786E, "SetCount", SN_LOCAL);
	add_func    (0X7873,0X78B8);
	set_func_flags(0X7873,0x4400);
	set_frame_size(0X7873, 0, 0, 0);
	set_name(0X78B5, "PopDone", SN_LOCAL);
	add_func    (0X78B8,0X78E3);
	set_func_flags(0X78B8,0x400);
	set_frame_size(0X78B8, 0, 0, 0);
	set_name(0X78D0, "LOCAL_COMMIT", SN_LOCAL);
	add_func    (0X78E3,0X78FF);
	set_func_flags(0X78E3,0x4400);
	set_frame_size(0X78E3, 0, 0, 0);
	add_func    (0X78FF,0X790A);
	set_func_flags(0X78FF,0x4400);
	set_frame_size(0X78FF, 0, 0, 0);
	set_name(0X7A1D, "NODEEXISTS", SN_LOCAL);
	add_func    (0X7A23,0X7A6B);
	set_func_flags(0X7A23,0x400);
	set_frame_size(0X7A23, 0, 0, 0);
	set_name(0X790E, "chdir_mkdir_done", SN_LOCAL);
	set_name(0X79EF, "lmd_cd_done", SN_LOCAL);
	set_name(0X7A2E, "LOCAL_CHDIR", SN_LOCAL);
	set_name(0X7A44, "nojoin", SN_LOCAL);
	set_name(0X7A69, "ChDirDone", SN_LOCAL);
	add_func    (0X7A6B,0X7ABB);
	set_func_flags(0X7A6B,0x4000);
	set_frame_size(0X7A6B, 0, 0, 0);
	set_name(0X7A76, "LOCAL_RMDIR", SN_LOCAL);
	set_name(0X7A99, "LOCAL_RMDIR_cont", SN_LOCAL);
	set_name(0X7AB2, "NOPATH", SN_LOCAL);
	add_func    (0X7B59,0X7B5F);
	set_func_flags(0X7B59,0x4400);
	set_frame_size(0X7B59, 0, 0, 0);
	add_func    (0X7B5F,0X7B73);
	set_func_flags(0X7B5F,0x4400);
	set_frame_size(0X7B5F, 0, 0, 0);
	add_func    (0X7B76,0X7D8C);
	set_func_flags(0X7B76,0x4400);
	set_frame_size(0X7B76, 0, 0, 0);
	set_name(0X7B94, "NoIORet", SN_LOCAL);
	set_name(0X7B96, "LOCAL_READ", SN_LOCAL);
	set_name(0X7BAC, "READDEV", SN_LOCAL);
	set_name(0X7BC5, "ENDRDDEVJ3", SN_LOCAL);
	set_name(0X7BC8, "TESTRAW", SN_LOCAL);
	set_name(0X7BD5, "DVRDRAW", SN_LOCAL);
	set_name(0X7BE7, "ReadRawRetry", SN_LOCAL);
	set_name(0X7C20, "DEVIOFERR", SN_LOCAL);
	set_name(0X7C28, "CRDROK", SN_LOCAL);
	set_name(0X7C32, "NOTRDCON", SN_LOCAL);
	set_name(0X7C49, "DVRDLP", SN_LOCAL);
	set_name(0X7C72, "CRDOK", SN_LOCAL);
	set_name(0X7C84, "DVRDIGN", SN_LOCAL);
	set_name(0X7C9A, "ENDRDDEVJ", SN_LOCAL);
	set_name(0X7C9D, "do_polling", SN_LOCAL);
	set_name(0X7CA5, "do_io", SN_LOCAL);
	set_name(0X7CBF, "invoke_charhard", SN_LOCAL);
	set_name(0X7CCF, "check_busy", SN_LOCAL);
	set_name(0X7D05, "devrderr", SN_LOCAL);
	set_name(0X7D0E, "no_char", SN_LOCAL);
	set_name(0X7D16, "pop_done_read", SN_LOCAL);
	set_name(0X7D17, "done_read", SN_LOCAL);
	set_name(0X7D1F, "TRANBUF", SN_LOCAL);
	set_name(0X7D28, "NORMCH", SN_LOCAL);
	set_name(0X7D35, "ENDRDCON", SN_LOCAL);
	set_name(0X7D3E, "ENDRDDEV", SN_LOCAL);
	set_name(0X7D4F, "SETSFTC", SN_LOCAL);
	set_name(0X7D53, "READCON", SN_LOCAL);
	set_name(0X7D6B, "GETBUF", SN_LOCAL);
	add_func    (0X7D8C,0X7D8F);
	set_func_flags(0X7D8C,0x4480);
	set_frame_size(0X7D8C, 0, 0, 0);
	add_func    (0X7D8F,0X7EE1);
	set_func_flags(0X7D8F,0x4400);
	set_frame_size(0X7D8F, 0, 0, 0);
	set_name(0X7DAB, "WRITE_NO_MODE", SN_LOCAL);
	set_name(0X7DBB, "LOCAL_WRITE", SN_LOCAL);
	set_name(0X7DDF, "nocommit", SN_LOCAL);
	set_name(0X7DE3, "DVWRTRAW", SN_LOCAL);
	set_name(0X7E19, "CWRFERR", SN_LOCAL);
	set_name(0X7E1D, "CWRTROK", SN_LOCAL);
	set_name(0X7E22, "ENDWRDEV", SN_LOCAL);
	set_name(0X7E2C, "WRTNUL", SN_LOCAL);
	set_name(0X7E2E, "WRTCOOKJ", SN_LOCAL);
	set_name(0X7E31, "WRTDEV", SN_LOCAL);
	set_name(0X7E70, "DVWRTLP", SN_LOCAL);
	set_name(0X7E98, "CWROK", SN_LOCAL);
	set_name(0X7EA1, "DVWRTIGN", SN_LOCAL);
	set_name(0X7EBD, "WRTCOOKDONE", SN_LOCAL);
	set_name(0X7EC3, "WRITECON", SN_LOCAL);
	set_name(0X7ECD, "WRCONLP", SN_LOCAL);
	set_name(0X7ED7, "CONEOF", SN_LOCAL);
	add_func    (0X7EE1,0X7F07);
	set_func_flags(0X7EE1,0x4400);
	set_frame_size(0X7EE1, 0, 0, 0);
	set_name(0X7EE9, "GetNormal", SN_LOCAL);
	set_name(0X7EF8, "RET44P", SN_LOCAL);
	set_name(0X7EFB, "GetRedir", SN_LOCAL);
	add_func    (0X7F07,0X7FAA);
	set_func_flags(0X7F07,0x400);
	set_frame_size(0X7F07, 0, 0, 0);
	set_name(0X7F18, "SubDir", SN_LOCAL);
	set_name(0X7F24, "DoRead", SN_LOCAL);
	set_name(0X7F58, "SKPCLLP", SN_LOCAL);
	set_name(0X7F5B, "dirread_cont", SN_LOCAL);
	set_name(0X7F76, "HAVESKIPPED", SN_LOCAL);
	add_func    (0X7FAA,0X800E);
	set_func_flags(0X7FAA,0x400);
	set_name(0X7FCA, "FATSECRD_cont", SN_LOCAL);
	set_name(0X7FD0, "NXTFAT", SN_LOCAL);
	set_name(0X7FFC, "NXTFAT2", SN_LOCAL);
	set_name(0X8004, "NXTFAT3", SN_LOCAL);
	set_name(0X8027, "RET41P", SN_LOCAL);
	add_func    (0X800E,0X8027);
	set_func_flags(0X800E,0x4400);
	set_frame_size(0X800E, 0, 0, 0);
	set_name(0X8026, "NO_CAR", SN_LOCAL);
	add_func    (0X802E,0X804D);
	set_func_flags(0X802E,0x4400);
	set_frame_size(0X802E, 0, 0, 0);
	set_name(0X8039, "write_cont", SN_LOCAL);
	set_name(0X803F, "Not_Truncate", SN_LOCAL);
	set_name(0X804C, "WRITE_OK", SN_LOCAL);
	add_func    (0X804D,0X8065);
	set_func_flags(0X804D,0x4400);
	set_frame_size(0X804D, 0, 0, 0);
	set_name(0X8058, "do_retry", SN_LOCAL);
	set_name(0X8064, "READLOCK_OK", SN_LOCAL);
	add_func    (0X8065,0X8075);
	set_func_flags(0X8065,0x400);
	set_frame_size(0X8065, 0X4, 0, 0);
	add_func    (0X8075,0X808F);
	set_func_flags(0X8075,0x4400);
	set_frame_size(0X8075, 0, 0, 0);
	set_name(0X807B, "dwrite1", SN_LOCAL);
	set_name(0X808E, "NO_CAR2", SN_LOCAL);
	add_func    (0X808F,0X80BE);
	set_func_flags(0X808F,0x4400);
	set_frame_size(0X808F, 0X4, 0, 0);
	add_func    (0X80BE,0X80D8);
	set_func_flags(0X80BE,0x4400);
	set_frame_size(0X80BE, 0, 0, 0);
	set_name(0X80D4, "DO_ERR", SN_LOCAL);
	add_func    (0X80D8,0X817E);
	set_func_flags(0X80D8,0x4400);
	set_frame_size(0X80D8, 0, 0, 0);
	set_name(0X8150, "setup_1", SN_LOCAL);
	set_name(0X8158, "setup_2", SN_LOCAL);
	set_name(0X8162, "NOSETSTUFF", SN_LOCAL);
	set_name(0X816B, "setup_3", SN_LOCAL);
	set_name(0X8173, "NoDec", SN_LOCAL);
	set_name(0X8178, "EOFERR", SN_LOCAL);
	set_name(0X817B, "NOROOM", SN_LOCAL);
	add_func    (0X817E,0X81A8);
	set_func_flags(0X817E,0x4400);
	set_frame_size(0X817E, 0, 0, 0);
	set_name(0X8195, "SAVFIR", SN_LOCAL);
	add_func    (0X81A8,0X81CE);
	set_func_flags(0X81A8,0x4400);
	set_frame_size(0X81A8, 0, 0, 0);
	set_name(0X81C2, "HARD_ERR", SN_LOCAL);
	set_name(0X81C7, "NO_HARD_ERR", SN_LOCAL);
	add_func    (0X81CE,0X81D5);
	set_func_flags(0X81CE,0x4400);
	set_frame_size(0X81CE, 0, 0, 0);
	add_func    (0X81D5,0X821A);
	set_func_flags(0X81D5,0x400);
	set_name(0X81F3, "ENUF", SN_LOCAL);
	set_name(0X8215, "RDERR", SN_LOCAL);
	set_name(0X821D, "CANOT_READ", SN_LOCAL);
	set_name(0X822C, "SKIPERR", SN_LOCAL);
	set_name(0X8248, "RDMID", SN_LOCAL);
	set_name(0X826D, "RDLP", SN_LOCAL);
	set_name(0X82BD, "RDLAST", SN_LOCAL);
	add_func    (0X821A,0X821D);
	set_func_flags(0X821A,0x480);
	add_func    (0X8223,0X8225);
	set_func_flags(0X8223,0x400);
	add_func    (0X8225,0X822C);
	set_func_flags(0X8225,0x4400);
	set_frame_size(0X8225, 0, 0, 0);
	add_func    (0X82BA,0X82BD);
	set_func_flags(0X82BA,0x480);
	add_func    (0X82D7,0X8306);
	set_func_flags(0X82D7,0x400);
	add_func    (0X8306,0X8313);
	set_func_flags(0X8306,0x4400);
	set_frame_size(0X8306, 0, 0, 0);
	set_name(0X8311, "RET28", SN_LOCAL);
	add_func    (0X8313,0X839D);
	set_func_flags(0X8313,0x4400);
	set_frame_size(0X8313, 0, 0, 0);
	set_name(0X8335, "bufq", SN_LOCAL);
	set_name(0X8342, "bufq01", SN_LOCAL);
	set_name(0X834C, "bufq02", SN_LOCAL);
	set_name(0X834E, "bufq1", SN_LOCAL);
	set_name(0X8357, "bufx", SN_LOCAL);
	set_name(0X8358, "bufq2", SN_LOCAL);
	set_name(0X8387, "bufq03", SN_LOCAL);
	set_name(0X838F, "bufq3", SN_LOCAL);
	add_func    (0X83A0,0X83A3);
	set_func_flags(0X83A0,0x4400);
	set_frame_size(0X83A0, 0, 0, 0);
	add_func    (0X83A3,0X8714);
	set_func_flags(0X83A3,0x4400);
	set_frame_size(0X83A3, 0, 0, 0);
	set_name(0X839D, "WRTEOFJ", SN_LOCAL);
	set_name(0X83D0, "ACC_ERRWJ2", SN_LOCAL);
	set_name(0X83D3, "dskwrt_1", SN_LOCAL);
	set_name(0X83E3, "dskwrt_2", SN_LOCAL);
	set_name(0X83E5, "dskwrt_3", SN_LOCAL);
	set_name(0X83FF, "CALCLUS", SN_LOCAL);
	set_name(0X842A, "NORND", SN_LOCAL);
	set_name(0X844A, "lowsec", SN_LOCAL);
	set_name(0X8452, "yesgrow", SN_LOCAL);
	set_name(0X847A, "HAVSTART", SN_LOCAL);
	set_name(0X848C, "HAVSTART_cont", SN_LOCAL);
	set_name(0X8494, "WRTERR", SN_LOCAL);
	set_name(0X84A1, "DOWRTJ", SN_LOCAL);
	set_name(0X84A4, "TESTTAIL", SN_LOCAL);
	set_name(0X84AA, "SETGRW", SN_LOCAL);
	set_name(0X84B1, "NOGROW", SN_LOCAL);
	set_name(0X84DC, "NOGROW2", SN_LOCAL);
	set_name(0X84E4, "dskwrt_4", SN_LOCAL);
	set_name(0X8511, "dskwrt_5", SN_LOCAL);
	set_name(0X8518, "ACC_ERRWJ", SN_LOCAL);
	set_name(0X851B, "NOSKIP", SN_LOCAL);
	set_name(0X8529, "DOWRT", SN_LOCAL);
	set_name(0X8541, "WRTMID", SN_LOCAL);
	set_name(0X854B, "WRTMID2", SN_LOCAL);
	set_name(0X8572, "WRTLP", SN_LOCAL);
	set_name(0X858B, "DWRITE_LUP", SN_LOCAL);
	set_name(0X85A7, "DWRITE_OKAY", SN_LOCAL);
	set_name(0X85C2, "DWRITE_DISK_FULL", SN_LOCAL);
	set_name(0X85D3, "SET_ACC_ERRW", SN_LOCAL);
	set_name(0X85D6, "WRTLAST", SN_LOCAL);
	set_name(0X85EE, "SET_ACC_ERRWJ", SN_LOCAL);
	set_name(0X85F0, "FINWRT", SN_LOCAL);
	set_name(0X8601, "UPDATE_size", SN_LOCAL);
	set_name(0X8610, "SAMSIZ", SN_LOCAL);
	set_name(0X8613, "WRTEOF", SN_LOCAL);
	set_name(0X861C, "WRTEOF1", SN_LOCAL);
	set_name(0X8625, "WRTEOF2", SN_LOCAL);
	set_name(0X8634, "WRTEOF3", SN_LOCAL);
	set_name(0X8651, "SET_ACC_ERRWJ2", SN_LOCAL);
	set_name(0X865C, "dskwrt_6", SN_LOCAL);
	set_name(0X8664, "UPDATE", SN_LOCAL);
	set_name(0X8682, "WRTERRJ", SN_LOCAL);
	set_name(0X8685, "RELFILE", SN_LOCAL);
	set_name(0X8699, "dskwrt_7", SN_LOCAL);
	set_name(0X86B7, "SKIPRESET", SN_LOCAL);
	set_name(0X86C2, "dskwrt_8", SN_LOCAL);
	set_name(0X86C4, "UPDATEJ", SN_LOCAL);
	set_name(0X86C6, "KILLFIL", SN_LOCAL);
	set_name(0X86F4, "dskwrt_9", SN_LOCAL);
	add_func    (0X8714,0X8761);
	set_func_flags(0X8714,0x4400);
	set_frame_size(0X8714, 0X2, 0, 0);
	set_name(0X8729, "_bufq", SN_LOCAL);
	set_name(0X8736, "bufq04", SN_LOCAL);
	set_name(0X8740, "bufq05", SN_LOCAL);
	set_name(0X874B, "bufq4", SN_LOCAL);
	set_name(0X8755, "bufq5", SN_LOCAL);
	set_name(0X8757, "bufq6", SN_LOCAL);
	add_func    (0X8761,0X8788);
	set_func_flags(0X8761,0x4400);
	set_frame_size(0X8761, 0, 0, 0);
	set_name(0X877C, "div5", SN_LOCAL);
	add_func    (0X8788,0X8797);
	set_func_flags(0X8788,0x4400);
	set_frame_size(0X8788, 0, 0, 0);
	set_name(0X8790, "rotashft2", SN_LOCAL);
	set_name(0X8796, "norota", SN_LOCAL);
	add_func    (0X8797,0X87F7);
	set_func_flags(0X8797,0x400);
	set_name(0X87A6, "NOTVOLSRCH", SN_LOCAL);
	set_name(0X87DA, "CHKFNAM", SN_LOCAL);
	set_name(0X87F1, "NO_E5", SN_LOCAL);
	add_func    (0X87F7,0X8875);
	set_func_flags(0X87F7,0x4400);
	set_frame_size(0X87F7, 0, 0, 0);
	set_name(0X8807, "NEXTENT3", SN_LOCAL);
	set_name(0X8821, "TSTALL", SN_LOCAL);
	set_name(0X8849, "check_one_volume_id", SN_LOCAL);
	set_name(0X885A, "RETFF", SN_LOCAL);
	set_name(0X8862, "SETESRET", SN_LOCAL);
	set_name(0X8874, "SETESRETN", SN_LOCAL);
	add_func    (0X8875,0X8884);
	set_func_flags(0X8875,0x4400);
	set_frame_size(0X8875, 0, 0, 0);
	set_name(0X8878, "WILDCRD", SN_LOCAL);
	set_name(0X8883, "MetaRet", SN_LOCAL);
	add_func    (0X8884,0X8900);
	set_func_flags(0X8884,0x4400);
	set_frame_size(0X8884, 0, 0, 0);
	set_name(0X88AB, "nextentry_cont", SN_LOCAL);
	set_name(0X88D4, "NONE", SN_LOCAL);
	set_name(0X88D6, "HAVIT", SN_LOCAL);
	set_name(0X88DB, "SAMECLUS", SN_LOCAL);
	add_func    (0X8900,0X8933);
	set_func_flags(0X8900,0x4400);
	set_frame_size(0X8900, 0, 0, 0);
	add_func    (0X89C3,0X8A27);
	set_func_flags(0X89C3,0x4400);
	set_frame_size(0X89C3, 0, 0, 0);
	set_name(0X89F3, "UNP_OK", SN_LOCAL);
	add_func    (0X8A27,0X8A90);
	set_func_flags(0X8A27,0x4400);
	set_frame_size(0X8A27, 0, 0, 0);
	set_name(0X8A4A, "sdsrch_fat32_1", SN_LOCAL);
	set_name(0X8A58, "sdsrch_fat32_2", SN_LOCAL);
	set_name(0X8A5B, "sdsrch_fat32_3", SN_LOCAL);
	set_name(0X8A5E, "SETROOTSRCH_FAT", SN_LOCAL);
	set_name(0X8A8F, "setdirsrch_retn", SN_LOCAL);
	add_func    (0X8A90,0X8AEC);
	set_func_flags(0X8A90,0x4400);
	set_frame_size(0X8A90, 0XE, 0, 0);
	set_name(0X8A9F, "set_sftfcbe_1", SN_LOCAL);
	set_name(0X8AAD, "set_sftfcbe_2", SN_LOCAL);
	set_name(0X8ADF, "set_sftfcbe_3", SN_LOCAL);
	set_name(0X8AE4, "set_setfcbe_4", SN_LOCAL);
	add_func    (0X8AEC,0X8B22);
	set_func_flags(0X8AEC,0x4400);
	set_frame_size(0X8AEC, 0, 0, 0);
	set_name(0X8AFB, "f_sfte_1", SN_LOCAL);
	set_name(0X8B13, "f_sfte_2", SN_LOCAL);
	add_func    (0X8B22,0X8B6D);
	set_func_flags(0X8B22,0x4400);
	set_frame_size(0X8B22, 0, 0, 0);
	set_name(0X8B31, "scan_next_sftfcb", SN_LOCAL);
	set_name(0X8B65, "sfte_i_found", SN_LOCAL);
	set_name(0X8B67, "sfte_i_notfound", SN_LOCAL);
	set_name(0X8B69, "find_sfte_i_error", SN_LOCAL);
	add_func    (0X8B6D,0X8B94);
	set_func_flags(0X8B6D,0x4400);
	set_frame_size(0X8B6D, 0XE, 0, 0);
	set_name(0X8B8C, "sftf_1", SN_LOCAL);
	add_func    (0X8B94,0X8B99);
	set_func_flags(0X8B94,0x4400);
	set_frame_size(0X8B94, 0, 0, 0);
	add_func    (0X8B99,0X8B9F);
	set_func_flags(0X8B99,0x400);
	add_func    (0X8B9F,0X8C72);
	set_func_flags(0X8B9F,0x4400);
	set_frame_size(0X8B9F, 0, 0, 0);
	set_name(0X8BBD, "Build_devJ", SN_LOCAL);
	set_name(0X8BD4, "MoveLoop", SN_LOCAL);
	set_name(0X8BDC, "NoSave", SN_LOCAL);
	set_name(0X8BE8, "InternalError", SN_LOCAL);
	set_name(0X8BEA, "CrackIt", SN_LOCAL);
	set_name(0X8C12, "CrackIt2", SN_LOCAL);
	set_name(0X8C49, "GO_Chk_end1", SN_LOCAL);
	set_name(0X8C4A, "GO_Chk_end", SN_LOCAL);
	set_name(0X8C58, "NO_CURR_D", SN_LOCAL);
	set_name(0X8C65, "GOT_SEARCH_CLUSTER", SN_LOCAL);
	set_name(0X8C9D, "ROOTPATH", SN_LOCAL);
	set_name(0X8CAE, "FINDPATH", SN_LOCAL);
	set_name(0X8CD2, "NOIDS", SN_LOCAL);
	set_name(0X8CE5, "GetNam", SN_LOCAL);
	set_name(0X8CFB, "StoNam", SN_LOCAL);
	set_name(0X8CFE, "_SetExt", SN_LOCAL);
	set_name(0X8D01, "GetExt", SN_LOCAL);
	set_name(0X8D11, "StoExt", SN_LOCAL);
	set_name(0X8D14, "_BADPATH_j", SN_LOCAL);
	set_name(0X8D17, "_GetDone", SN_LOCAL);
	set_name(0X8D32, "NOT_LAST", SN_LOCAL);
	set_name(0X8D43, "BADPATHPOP_j", SN_LOCAL);
	set_name(0X8D46, "FindFile", SN_LOCAL);
	set_name(0X8D52, "NOE5", SN_LOCAL);
	set_name(0X8D5D, "DIR_FOUND", SN_LOCAL);
	set_name(0X8D6C, "FILEINPATH_j", SN_LOCAL);
	set_name(0X8D6F, "GO_NEXT", SN_LOCAL);
	set_name(0X8D90, "_nofast", SN_LOCAL);
	set_name(0X8D98, "NEXT_ONE", SN_LOCAL);
	set_name(0X8D9D, "SetDir", SN_LOCAL);
	set_name(0X8DA8, "SetDir2", SN_LOCAL);
	set_name(0X8DC9, "DO_NORMAL", SN_LOCAL);
	set_name(0X8DEF, "SKIP_GETB", SN_LOCAL);
	set_name(0X8DFA, "SET_THE_BUF", SN_LOCAL);
	set_name(0X8E05, "FAST_OPEN_SKIP", SN_LOCAL);
	set_name(0X8E1A, "find_bad_name", SN_LOCAL);
	set_name(0X8E1B, "_BADPATH", SN_LOCAL);
	set_name(0X8E1F, "FILEINPATH", SN_LOCAL);
	set_name(0X8E34, "NO_FAST", SN_LOCAL);
	set_name(0X8E3F, "_SETRET", SN_LOCAL);
	set_name(0X8E40, "NO_FAST2", SN_LOCAL);
	set_name(0X8E44, "BADPATHPOP", SN_LOCAL);
	set_name(0X8E4B, "BADPRET", SN_LOCAL);
	add_func    (0X8C72,0X8C9D);
	set_func_flags(0X8C72,0x4400);
	set_frame_size(0X8C72, 0, 0, 0);
	set_name(0X8C7C, "TESTLOOP", SN_LOCAL);
	set_name(0X8C8F, "NOTDEV", SN_LOCAL);
	set_name(0X8C91, "TESTDEVICE", SN_LOCAL);
	add_func    (0X8E53,0X8E67);
	set_func_flags(0X8E53,0x4400);
	set_frame_size(0X8E53, 0, 0, 0);
	add_func    (0X8E67,0X8E74);
	set_func_flags(0X8E67,0x4400);
	set_frame_size(0X8E67, 0, 0, 0);
	add_func    (0X8E74,0X8ED3);
	set_func_flags(0X8E74,0x4400);
	set_frame_size(0X8E74, 0X4, 0, 0);
	set_name(0X8E88, "NOKTR", SN_LOCAL);
	set_name(0X8E92, "LOOKIO", SN_LOCAL);
	set_name(0X8EA9, "SKIPDEV", SN_LOCAL);
	set_name(0X8EB0, "RET31", SN_LOCAL);
	set_name(0X8EB1, "RETNV", SN_LOCAL);
	set_name(0X8EBE, "IOCHK", SN_LOCAL);
	add_func    (0X8ED3,0X8F01);
	set_func_flags(0X8ED3,0x4400);
	set_frame_size(0X8ED3, 0, 0, 0);
	add_func    (0X8F01,0X8FD0);
	set_func_flags(0X8F01,0x4410);
	set_frame_size(0X8F01, 0X6, 2, 0);
	define_local_var(0X8F01, 0X8FD0, "[bp-0X6]", "SaveCDS");
	define_local_var(0X8F01, 0X8FD0, "[bp-0X2]", "Temp");
	set_name(0X8F22, "_DoSplice", SN_LOCAL);
	set_name(0X8F55, "_DoSplice2", SN_LOCAL);
	set_name(0X8F6E, "DoChdir", SN_LOCAL);
	set_name(0X8F9C, "SetCluster", SN_LOCAL);
	set_name(0X8FAD, "_setdirclus", SN_LOCAL);
	set_name(0X8FB8, "RestoreCDS", SN_LOCAL);
	set_name(0X8FC6, "FatFail", SN_LOCAL);
	add_func    (0X8FD0,0X9015);
	set_func_flags(0X8FD0,0x4400);
	set_frame_size(0X8FD0, 0X4, 0, 0);
	set_name(0X8FF2, "ParseDev", SN_LOCAL);
	set_name(0X9008, "SkipSearch", SN_LOCAL);
	set_name(0X900A, "CheckReturn", SN_LOCAL);
	set_name(0X900F, "Check_Done", SN_LOCAL);
	set_name(0X9012, "NotDevice", SN_LOCAL);
	add_func    (0X9015,0X90DB);
	set_func_flags(0X9015,0x4400);
	set_frame_size(0X9015, 0, 0, 0);
	set_name(0X901D, "NOLOOK", SN_LOCAL);
	set_name(0X9020, "FASTINST", SN_LOCAL);
	set_name(0X9042, "FASTINST2", SN_LOCAL);
	set_name(0X9083, "parfnd", SN_LOCAL);
	set_name(0X909A, "parfnd2", SN_LOCAL);
	set_name(0X90C8, "NOTFOUND", SN_LOCAL);
	set_name(0X90D3, "Partial_Success", SN_LOCAL);
	set_name(0X90D9, "NOLOOKUP", SN_LOCAL);
	add_func    (0X90DB,0X9163);
	set_func_flags(0X90DB,0x4400);
	set_frame_size(0X90DB, 0, 0, 0);
	set_name(0X90F9, "INSERT_DIR_INFO", SN_LOCAL);
	set_name(0X9154, "SKIP_INSERT", SN_LOCAL);
	set_name(0X915B, "GET_NEXT2", SN_LOCAL);
	set_name(0X9161, "GET_NEXT_ELEMENT", SN_LOCAL);
	add_func    (0X9175,0X9261);
	set_func_flags(0X9175,0x400);
	set_frame_size(0X9175, 0, 0, 0);
	set_name(0X9195, "IOTO22", SN_LOCAL);
	set_name(0X919E, "IOTO33", SN_LOCAL);
	set_name(0X91B3, "_no_sys_wait", SN_LOCAL);
	set_name(0X91E4, "OKDevIO", SN_LOCAL);
	set_name(0X91F3, "DNODRD", SN_LOCAL);
	set_name(0X9213, "not_fail_ret", SN_LOCAL);
	set_name(0X9219, "DevErr", SN_LOCAL);
	set_name(0X9229, "NO_RETRY", SN_LOCAL);
	set_name(0X9238, "not_fail", SN_LOCAL);
	set_name(0X923A, "IOTOFILE", SN_LOCAL);
	set_name(0X9247, "IOIST", SN_LOCAL);
	set_name(0X9257, "IOUT", SN_LOCAL);
	add_func    (0X9261,0X9281);
	set_func_flags(0X9261,0x401);
	set_frame_size(0X9261, 0, 0, 0);
	add_func    (0X9281,0X92B5);
	set_func_flags(0X9281,0x400);
	add_func    (0X92B5,0X92C4);
	set_func_flags(0X92B5,0x401);
	add_func    (0X92CA,0X92D2);
	set_func_flags(0X92CA,0x400);
	add_func    (0X92D2,0X9348);
	set_func_flags(0X92D2,0x4000);
	set_frame_size(0X92D2, 0, 0, 0);
	set_name(0X92FD, "GOT_DEV_ADDR", SN_LOCAL);
	set_name(0X9308, "OPCLS_RETRY", SN_LOCAL);
	set_name(0X9334, "BLKDEV", SN_LOCAL);
	set_name(0X9338, "HRDERR", SN_LOCAL);
	set_name(0X9342, "OPCLS_DONEP", SN_LOCAL);
	set_name(0X9343, "OPCLS_DONE", SN_LOCAL);
	add_func    (0X9348,0X934B);
	set_func_flags(0X9348,0x4400);
	set_frame_size(0X9348, 0, 0, 0);
	add_func    (0X934B,0X93BF);
	set_func_flags(0X934B,0x4400);
	set_frame_size(0X934B, 0, 0, 0);
	set_name(0X9364, "chkext", SN_LOCAL);
	set_name(0X9384, "chksector", SN_LOCAL);
	set_name(0X938C, "chardev2", SN_LOCAL);
	set_name(0X93B3, "dev_exit", SN_LOCAL);
	set_name(0X93B7, "chardev3", SN_LOCAL);
	add_func    (0X93BF,0X93F8);
	set_func_flags(0X93BF,0x4400);
	set_frame_size(0X93BF, 0X2, 0, 0);
	add_func    (0X93F8,0X9404);
	set_func_flags(0X93F8,0x4400);
	set_frame_size(0X93F8, 0X2, 0, 0);
	add_func    (0X940A,0X94F3);
	set_func_flags(0X940A,0x4400);
	set_frame_size(0X940A, 0, 0, 0);
	set_name(0X9414, "CHECK_IF_ROOT", SN_LOCAL);
	set_name(0X9423, "builddir_retn", SN_LOCAL);
	set_name(0X9438, "NEWDIR2", SN_LOCAL);
	set_name(0X943D, "NULLDIR", SN_LOCAL);
	set_name(0X946C, "ADDINGDIR", SN_LOCAL);
	set_name(0X94A6, "NOTFIRSTGROW", SN_LOCAL);
	set_name(0X94AD, "GOTDIRREC", SN_LOCAL);
	set_name(0X94B4, "ZERODIR", SN_LOCAL);
	set_name(0X94C3, "GET_SSIZE", SN_LOCAL);
	set_name(0X94DE, "EVENZ", SN_LOCAL);
	add_func    (0X94F3,0X951A);
	set_func_flags(0X94F3,0x4400);
	set_frame_size(0X94F3, 0, 0, 0);
	add_func    (0X951A,0X953B);
	set_func_flags(0X951A,0x400);
	set_name(0X9539, "make_err_4", SN_LOCAL);
	set_name(0X955F, "make_exists", SN_LOCAL);
	set_name(0X9588, "make_share", SN_LOCAL);
	set_name(0X95A3, "make_err_ret_5P", SN_LOCAL);
	set_name(0X95A4, "make_err_ret_5", SN_LOCAL);
	set_name(0X95A8, "make_exists_dir", SN_LOCAL);
	set_name(0X95E9, "MakeEndShare", SN_LOCAL);
	add_func    (0X953E,0X955F);
	set_func_flags(0X953E,0x4400);
	set_frame_size(0X953E, 0, 0, 0);
	set_name(0X9556, "make_type2", SN_LOCAL);
	set_name(0X959F, "Make_Share_ret", SN_LOCAL);
	set_name(0X95B8, "make_new", SN_LOCAL);
	add_func    (0X95AC,0X95B8);
	set_func_flags(0X95AC,0x4400);
	set_frame_size(0X95AC, 0, 0, 0);
	add_func    (0X961A,0X96C3);
	set_func_flags(0X961A,0x4400);
	set_frame_size(0X961A, 0, 0, 0);
	set_name(0X9634, "ERRRET3", SN_LOCAL);
	set_name(0X9635, "newentry_retn", SN_LOCAL);
	set_name(0X9636, "EXISTENT", SN_LOCAL);
	set_name(0X963D, "NOT_DEV1", SN_LOCAL);
	set_name(0X9642, "FREESPOT", SN_LOCAL);
	set_name(0X9650, "NOTVOLID", SN_LOCAL);
	set_name(0X968D, "yesdirty9", SN_LOCAL);
	set_name(0X96B6, "GotADevice", SN_LOCAL);
	add_func    (0X96C3,0X9791);
	set_func_flags(0X96C3,0x4400);
	set_frame_size(0X96C3, 0, 0, 0);
	set_name(0X96D8, "DEV_SFT0", SN_LOCAL);
	set_name(0X96EC, "DEV_SFT1", SN_LOCAL);
	set_name(0X9701, "DEV_SFT2", SN_LOCAL);
	set_name(0X9715, "FILE_SFT0", SN_LOCAL);
	set_name(0X9727, "FILE_SFT1", SN_LOCAL);
	set_name(0X9766, "Not_FastOpen", SN_LOCAL);
	set_name(0X9780, "Next_Name", SN_LOCAL);
	set_name(0X9782, "DEV_SFT3", SN_LOCAL);
	set_name(0X9785, "FILE_SFT2", SN_LOCAL);
	add_func    (0X9791,0X9801);
	set_func_flags(0X9791,0x4400);
	set_frame_size(0X9791, 0, 0, 0);
	set_name(0X97B6, "freeent1", SN_LOCAL);
	set_name(0X97C4, "freeent2", SN_LOCAL);
	set_name(0X97CF, "freeent3", SN_LOCAL);
	set_name(0X97F2, "freeent4", SN_LOCAL);
	set_name(0X97FF, "RET1", SN_LOCAL);
	add_func    (0X9801,0X985F);
	set_func_flags(0X9801,0x400);
	set_name(0X982D, "fndclus_1", SN_LOCAL);
	set_name(0X9856, "FINDIT", SN_LOCAL);
	add_func    (0X985F,0X98C2);
	set_func_flags(0X985F,0x4400);
	set_frame_size(0X985F, 0, 0, 0);
	set_name(0X9893, "SKPCLP2", SN_LOCAL);
	set_name(0X989D, "SKPCLP3", SN_LOCAL);
	add_func    (0X98C2,0X990E);
	set_func_flags(0X98C2,0x4400);
	set_frame_size(0X98C2, 0, 0, 0);
	add_func    (0X990E,0X9949);
	set_func_flags(0X990E,0x4400);
	set_frame_size(0X990E, 0, 0, 0);
	set_name(0X9919, "BUF_OK", SN_LOCAL);
	set_name(0X9945, "RBUFPLACEDC", SN_LOCAL);
	set_name(0X9946, "RBUFPLACED", SN_LOCAL);
	add_func    (0X9949,0X99AA);
	set_func_flags(0X9949,0x4400);
	set_frame_size(0X9949, 0, 0, 0);
	set_name(0X996B, "_doread", SN_LOCAL);
	set_name(0X996D, "NOREAD", SN_LOCAL);
	set_name(0X9994, "yesdirty10", SN_LOCAL);
	set_name(0X99A4, "WBUFPLACED", SN_LOCAL);
	add_func    (0X99AA,0X99F3);
	set_func_flags(0X99AA,0x4400);
	set_frame_size(0X99AA, 0, 0, 0);
	set_name(0X99EC, "SAVPOS", SN_LOCAL);
	set_name(0X99EF, "CLRET", SN_LOCAL);
	set_name(0X99F1, "NONEXT", SN_LOCAL);
	add_func    (0X99F3,0X9A89);
	set_func_flags(0X99F3,0x4400);
	set_frame_size(0X99F3, 0, 0, 0);
	set_name(0X9A07, "OPTCLUS", SN_LOCAL);
	set_name(0X9A30, "clusgot3", SN_LOCAL);
	set_name(0X9A38, "FINCLUS", SN_LOCAL);
	set_name(0X9A76, "OP_ERR", SN_LOCAL);
	set_name(0X9A7B, "BLKDON", SN_LOCAL);
	add_func    (0X9A89,0X9AC5);
	set_func_flags(0X9A89,0x4400);
	set_frame_size(0X9A89, 0, 0, 0);
	set_name(0X9A9D, "rotleft", SN_LOCAL);
	set_name(0X9AA4, "noshift", SN_LOCAL);
	set_name(0X9AB7, "noshift1", SN_LOCAL);
	set_name(0X9ABE, "noshift2", SN_LOCAL);
	add_func    (0X9AC5,0X9ACC);
	set_func_flags(0X9AC5,0x420);
	set_frame_size(0X9AC5, 0, 0, 0);
	add_func    (0X9ACF,0X9CDF);
	set_func_flags(0X9ACF,0x4400);
	set_frame_size(0X9ACF, 0, 0, 0);
	set_name(0X9ACC, "alloc_disk_full", SN_LOCAL);
	set_name(0X9B28, "ads0", SN_LOCAL);
	set_name(0X9B2B, "ads1", SN_LOCAL);
	set_name(0X9B2D, "ads2", SN_LOCAL);
	set_name(0X9B3F, "ads3", SN_LOCAL);
	set_name(0X9B4E, "FINDFRE", SN_LOCAL);
	set_name(0X9B6F, "ads4", SN_LOCAL);
	set_name(0X9B73, "ads5", SN_LOCAL);
	set_name(0X9B78, "ads6", SN_LOCAL);
	set_name(0X9B9E, "ads7", SN_LOCAL);
	set_name(0X9BB9, "ads8", SN_LOCAL);
	set_name(0X9BFC, "ads9", SN_LOCAL);
	set_name(0X9C08, "ads10", SN_LOCAL);
	set_name(0X9C13, "NO_ALLOC", SN_LOCAL);
	set_name(0X9C47, "ads11", SN_LOCAL);
	set_name(0X9C4A, "ads12", SN_LOCAL);
	set_name(0X9C54, "ads13", SN_LOCAL);
	set_name(0X9C60, "ads_ret", SN_LOCAL);
	set_name(0X9C61, "ads14", SN_LOCAL);
	set_name(0X9C9B, "ads15", SN_LOCAL);
	set_name(0X9CA9, "ads16", SN_LOCAL);
	set_name(0X9CB5, "ads17", SN_LOCAL);
	set_name(0X9CBA, "ads18", SN_LOCAL);
	set_name(0X9CD8, "Disk_Full_Return", SN_LOCAL);
	add_func    (0X9CDF,0X9D13);
	set_func_flags(0X9CDF,0x4400);
	set_frame_size(0X9CDF, 0X2, 0, 0);
	add_func    (0X9D13,0X9D19);
	set_func_flags(0X9D13,0x400);
	add_func    (0X9D19,0X9D73);
	set_func_flags(0X9D19,0x4400);
	set_frame_size(0X9D19, 0, 0, 0);
	set_name(0X9D44, "relblks_ifc", SN_LOCAL);
	set_name(0X9D56, "NO_DEALLOC", SN_LOCAL);
	set_name(0X9D63, "NO_DEALLOC2", SN_LOCAL);
	set_name(0X9D6D, "NO_DEALLOC3", SN_LOCAL);
	set_name(0X9D72, "RET12", SN_LOCAL);
	add_func    (0X9D7C,0X9DB0);
	set_func_flags(0X9D7C,0x400);
	set_name(0X9D73, "GETEOF1", SN_LOCAL);
	set_name(0X9D82, "GETEOF2", SN_LOCAL);
	set_name(0X9D8B, "GETEOF3", SN_LOCAL);
	add_func    (0X9DB0,0X9E18);
	set_func_flags(0X9DB0,0x4400);
	set_frame_size(0X9DB0, 0, 0, 0);
	set_name(0X9DBE, "DEFDRV", SN_LOCAL);
	set_name(0X9DCD, "FILLB", SN_LOCAL);
	set_name(0X9DDA, "FILLB2", SN_LOCAL);
	set_name(0X9DF0, "SKPSPC", SN_LOCAL);
	set_name(0X9DF3, "NOSCAN", SN_LOCAL);
	set_name(0X9E11, "BADDRV", SN_LOCAL);
	set_name(0X9E13, "HAVDRV", SN_LOCAL);
	set_name(0X9E16, "NODRV", SN_LOCAL);
	add_func    (0X9E18,0X9E3E);
	set_func_flags(0X9E18,0x4400);
	set_frame_size(0X9E18, 0, 0, 0);
	set_name(0X9E31, "VOLOK", SN_LOCAL);
	set_name(0X9E34, "NODOT", SN_LOCAL);
	add_func    (0X9E42,0X9E48);
	set_func_flags(0X9E42,0x400);
	set_name(0X9E3E, "NONAM", SN_LOCAL);
	add_func    (0X9E48,0X9E74);
	set_func_flags(0X9E48,0x4400);
	set_frame_size(0X9E48, 0, 0, 0);
	set_name(0X9E59, "MustCheckCX", SN_LOCAL);
	set_name(0X9E64, "NOSTAR", SN_LOCAL);
	set_name(0X9E6E, "FILLNAM", SN_LOCAL);
	add_func    (0X9E74,0X9E7C);
	set_func_flags(0X9E74,0x400);
	set_frame_size(0X9E74, 0, 0, 0);
	add_func    (0X9E7C,0X9EA5);
	set_func_flags(0X9E7C,0x4400);
	set_frame_size(0X9E7C, 0, 0, 0);
	add_func    (0X9EE4,0X9EE5);
	set_func_flags(0X9EE4,0x4400);
	set_frame_size(0X9EE4, 0, 0, 0);
	add_func    (0X9EE5,0X9F0A);
	set_func_flags(0X9EE5,0x4400);
	set_frame_size(0X9EE5, 0X2, 0, 0);
	set_name(0X9EF3, "gl_1", SN_LOCAL);
	set_name(0X9F01, "gl_2", SN_LOCAL);
	add_func    (0X9F0A,0X9F0D);
	set_func_flags(0X9F0A,0x4400);
	set_frame_size(0X9F0A, 0X2, 0, 0);
	add_func    (0X9F0D,0X9F15);
	set_func_flags(0X9F0D,0x4400);
	set_frame_size(0X9F0D, 0, 0, 0);
	add_func    (0X9F15,0X9F1D);
	set_func_flags(0X9F15,0x4400);
	set_frame_size(0X9F15, 0, 0, 0);
	add_func    (0X9F1D,0X9F38);
	set_func_flags(0X9F1D,0x4400);
	set_frame_size(0X9F1D, 0, 0, 0);
	set_name(0X9F32, "gct_80", SN_LOCAL);
	set_name(0X9F35, "gct_90", SN_LOCAL);
	add_func    (0X9F38,0X9F45);
	set_func_flags(0X9F38,0x4400);
	set_frame_size(0X9F38, 0, 0, 0);
	set_name(0X9F3F, "GotFor", SN_LOCAL);
	set_name(0X9F42, "PathRet", SN_LOCAL);
	add_func    (0X9F51,0X9FBF);
	set_func_flags(0X9F51,0x420);
	set_frame_size(0X9F51, 0, 0, 0);
	set_name(0X9F5A, "dskstatchk1", SN_LOCAL);
	set_name(0X9F8B, "RET36", SN_LOCAL);
	set_name(0X9F92, "_GotCh", SN_LOCAL);
	add_func    (0X9FD4,0XA002);
	set_func_flags(0X9FD4,0x4400);
	set_frame_size(0X9FD4, 0, 0, 0);
	set_name(0X9FF6, "do_low_int28", SN_LOCAL);
	set_name(0X9FFB, "spool_ret_addr", SN_LOCAL);
	set_name(0XA000, "POPFRET", SN_LOCAL);
	add_func    (0XA002,0XA125);
	set_func_flags(0XA002,0x4402);
	set_frame_size(0XA002, 0, 0, 0);
	set_name(0X412A, "scct_1", SN_LOCAL);
	set_name(0X413F, "scct_2", SN_LOCAL);
	set_name(0X4149, "scct_3", SN_LOCAL);
	set_name(0X4153, "scct_4", SN_LOCAL);
	set_name(0X415D, "scct_5", SN_LOCAL);
	set_name(0X4173, "scct_6", SN_LOCAL);
	set_name(0X4182, "scct_9s", SN_LOCAL);
	set_name(0X4186, "SetCtrlShortEntry", SN_LOCAL);
	set_name(0X41FA, "SaveAllRegs", SN_LOCAL);
	set_name(0X422C, "set_indos_flag", SN_LOCAL);
	set_name(0X4294, "DSKROUT", SN_LOCAL);
	set_name(0X42BC, "DISPCALL", SN_LOCAL);
	set_name(0X42E1, "LeaveA20On", SN_LOCAL);
	set_name(0X430B, "disa20", SN_LOCAL);
	set_name(0X9FBF, "NOSTOP", SN_LOCAL);
	set_name(0X9FCC, "check_next", SN_LOCAL);
	set_name(0X9FD0, "check_end", SN_LOCAL);
	set_name(0X9FD1, "INCHKJ", SN_LOCAL);
	set_name(0XA028, "PRINT_ON_OFF", SN_LOCAL);
	set_name(0XA05C, "NORM_PR", SN_LOCAL);
	set_name(0XA069, "PRNOPN", SN_LOCAL);
	set_name(0XA06C, "RETP6", SN_LOCAL);
	set_name(0XA06E, "STATCHK_RETN", SN_LOCAL);
	set_name(0XA06F, "PAUSOLP", SN_LOCAL);
	set_name(0XA072, "PAUSOSTRT", SN_LOCAL);
	set_name(0XA079, "INCHK", SN_LOCAL);
	set_name(0XA09F, "around_deadlock", SN_LOCAL);
	set_name(0XA0AB, "NOSWAP", SN_LOCAL);
	set_name(0XA0E3, "do_low_int23", SN_LOCAL);
	set_name(0XA0E9, "ctrlc_ret_addr", SN_LOCAL);
	set_name(0XA101, "ctrlc_repeat", SN_LOCAL);
	set_name(0XA108, "COMMANDJ", SN_LOCAL);
	set_name(0XA10B, "ctrlc_try_new", SN_LOCAL);
	add_func    (0XA13A,0XA173);
	set_func_flags(0XA13A,0x4400);
	set_frame_size(0XA13A, 0, 0, 0);
	add_func    (0XA173,0XA1A4);
	set_func_flags(0XA173,0x4400);
	set_frame_size(0XA173, 0, 0, 0);
	set_name(0XA186, "chard1", SN_LOCAL);
	set_name(0XA189, "ctrlp", SN_LOCAL);
	add_func    (0XA1A4,0XA22E);
	set_func_flags(0XA1A4,0x400);
	set_name(0XA1B8, "NOSETWRPERR", SN_LOCAL);
	set_name(0XA1DA, "TESTDIR", SN_LOCAL);
	set_name(0XA1F4, "TESTDIR1", SN_LOCAL);
	set_name(0XA204, "TESTDIR2", SN_LOCAL);
	set_name(0XA20A, "TESTDIR3", SN_LOCAL);
	set_name(0XA218, "TESTDIR4", SN_LOCAL);
	set_name(0XA222, "ERRINT", SN_LOCAL);
	add_func    (0XA22E,0XA232);
	set_func_flags(0XA22E,0x400);
	add_func    (0XA232,0XA242);
	set_func_flags(0XA232,0x400);
	add_func    (0XA242,0XA3BA);
	set_func_flags(0XA242,0x402);
	set_frame_size(0XA242, 0, 0, 0);
	set_name(0XA259, "NoSetFail", SN_LOCAL);
	set_name(0XA274, "_NoFree", SN_LOCAL);
	set_name(0XA290, "i24yes", SN_LOCAL);
	set_name(0XA2A6, "do_low_int24", SN_LOCAL);
	set_name(0XA2AB, "criterr_ret_addr", SN_LOCAL);
	set_name(0XA2B7, "passi24", SN_LOCAL);
	set_name(0XA2CD, "FailRet", SN_LOCAL);
	set_name(0XA2E4, "DoFail", SN_LOCAL);
	set_name(0XA2F3, "CleanUp", SN_LOCAL);
	set_name(0XA302, "CleanUp2", SN_LOCAL);
	set_name(0XA314, "CheckIgnore", SN_LOCAL);
	set_name(0XA31A, "CheckRI", SN_LOCAL);
	set_name(0XA31E, "CheckRetry", SN_LOCAL);
	set_name(0XA326, "DoAbort", SN_LOCAL);
	set_name(0XA332, "NOSWAP2", SN_LOCAL);
	set_name(0XA343, "reset_environment", SN_LOCAL);
	set_name(0XA37C, "reset_to_parent", SN_LOCAL);
	set_name(0XA381, "reset_return", SN_LOCAL);
	set_name(0XB420, "abort_inner", SN_LOCAL);
	add_func    (0XA3E5,0XA40C);
	set_func_flags(0XA3E5,0x4400);
	set_frame_size(0XA3E5, 0, 0, 0);
	set_name(0XA3FE, "NoTrans", SN_LOCAL);
	add_func    (0XA40C,0XA435);
	set_func_flags(0XA40C,0x4400);
	set_frame_size(0XA40C, 0, 0, 0);
	set_name(0XA41D, "IsEOF_other1", SN_LOCAL);
	set_name(0XA41E, "IsEOF_FAT", SN_LOCAL);
	set_name(0XA430, "IsEOF_other", SN_LOCAL);
	set_name(0XA431, "EOF16", SN_LOCAL);
	add_func    (0XA44E,0XA4E6);
	set_func_flags(0XA44E,0x4400);
	set_frame_size(0XA44E, 0, 0, 0);
	set_name(0XA435, "up_1", SN_LOCAL);
	set_name(0XA44D, "unpack_retn", SN_LOCAL);
	set_name(0XA452, "up_cont", SN_LOCAL);
	set_name(0XA469, "up_fat", SN_LOCAL);
	set_name(0XA46D, "up_2", SN_LOCAL);
	set_name(0XA496, "up_fat32", SN_LOCAL);
	set_name(0XA4A2, "up_retn", SN_LOCAL);
	set_name(0XA4A3, "High12", SN_LOCAL);
	set_name(0XA4B2, "Unpack12", SN_LOCAL);
	set_name(0XA4BB, "HURTFAT", SN_LOCAL);
	set_name(0XA4E4, "OKU_RET", SN_LOCAL);
	add_func    (0XA4F9,0XA5B9);
	set_func_flags(0XA4F9,0x4400);
	set_frame_size(0XA4F9, 0, 0, 0);
	set_name(0XA4E6, "p_clust_0", SN_LOCAL);
	set_name(0XA4FD, "p_cont", SN_LOCAL);
	set_name(0XA513, "ALIGNED", SN_LOCAL);
	set_name(0XA52B, "p_fat", SN_LOCAL);
	set_name(0XA53C, "Pack16", SN_LOCAL);
	set_name(0XA53E, "PACKIN", SN_LOCAL);
	set_name(0XA542, "PACKIN2", SN_LOCAL);
	set_name(0XA556, "yesdirty11", SN_LOCAL);
	set_name(0XA5A2, "yesdirty12", SN_LOCAL);
	set_name(0XA5AC, "POPP_RET", SN_LOCAL);
	add_func    (0XA5B9,0XA5CE);
	set_func_flags(0XA5B9,0x4400);
	set_frame_size(0XA5B9, 0, 0, 0);
	set_name(0XA5CC, "isfat32eof_1", SN_LOCAL);
	set_name(0XA5CD, "isfat32eof_2", SN_LOCAL);
	add_func    (0XA5D7,0XA6C6);
	set_func_flags(0XA5D7,0x4400);
	set_frame_size(0XA5D7, 0X4, 0, 0);
	set_name(0XA5CE, "_DoDiv", SN_LOCAL);
	set_name(0XA5FF, "mapcl1", SN_LOCAL);
	set_name(0XA60B, "mapcl2", SN_LOCAL);
	set_name(0XA613, "Map16", SN_LOCAL);
	set_name(0XA637, "DivDone", SN_LOCAL);
	set_name(0XA69F, "MAPRET", SN_LOCAL);
	set_name(0XA6B8, "MapSet", SN_LOCAL);
	set_name(0XA6BC, "MAP_POP", SN_LOCAL);
	add_func    (0XA6C6,0XA6D8);
	set_func_flags(0XA6C6,0x4400);
	set_frame_size(0XA6C6, 0, 0, 0);
	add_func    (0XA6D8,0XA72F);
	set_func_flags(0XA6D8,0x4400);
	set_frame_size(0XA6D8, 0, 0, 0);
	set_name(0XA6FA, "frcd20", SN_LOCAL);
	set_name(0XA723, "frcd25", SN_LOCAL);
	set_name(0XA729, "NO_CHANGE", SN_LOCAL);
	add_func    (0XA72F,0XA756);
	set_func_flags(0XA72F,0x4400);
	set_frame_size(0XA72F, 0, 0, 0);
	set_name(0XA743, "chk_set_fa_1", SN_LOCAL);
	set_name(0XA748, "chk_set_fa_2", SN_LOCAL);
	set_name(0XA755, "chk_set_fa_3", SN_LOCAL);
	add_func    (0XA774,0XAA4B);
	set_func_flags(0XA774,0x4400);
	set_frame_size(0XA774, 0, 0, 0);
	set_name(0XA756, "FATERR", SN_LOCAL);
	set_name(0XA772, "FATERR_fail", SN_LOCAL);
	set_name(0XA7CC, "CHECK_BYT", SN_LOCAL);
	set_name(0XA7D6, "DISK_CHNG_ERR", SN_LOCAL);
	set_name(0XA80B, "FAIL_OPJ2", SN_LOCAL);
	set_name(0XA810, "CHKBUFFDIRT", SN_LOCAL);
	set_name(0XA81B, "nbuffer", SN_LOCAL);
	set_name(0XA82A, "FAIL_OP", SN_LOCAL);
	set_name(0XA82E, "jmp_to_DISK_CHNG_ERR", SN_LOCAL);
	set_name(0XA830, "lfnxt", SN_LOCAL);
	set_name(0XA839, "NEWDSK", SN_LOCAL);
	set_name(0XA84C, "newdsk2", SN_LOCAL);
	set_name(0XA84F, "nxbuffer", SN_LOCAL);
	set_name(0XA864, "lfnxt2", SN_LOCAL);
	set_name(0XA866, "skpbuff", SN_LOCAL);
	set_name(0XA882, "GOGETBPB", SN_LOCAL);
	set_name(0XA8B7, "FAIL_OPJ", SN_LOCAL);
	set_name(0XA8BC, "unpack_ok", SN_LOCAL);
	set_name(0XA8C2, "GETFREEBUF", SN_LOCAL);
	set_name(0XA8E4, "GOTGETBUF", SN_LOCAL);
	set_name(0XA935, "gotgetbuf2", SN_LOCAL);
	set_name(0XA95B, "gotgetbuf3", SN_LOCAL);
	set_name(0XA972, "gotgetbuf4", SN_LOCAL);
	set_name(0XA97A, "gotgetbuf5", SN_LOCAL);
	set_name(0XA990, "gotgetbuf6", SN_LOCAL);
	set_name(0XA9D6, "gotgetbuf7", SN_LOCAL);
	set_name(0XA9E0, "gotgetbuf8", SN_LOCAL);
	set_name(0XA9EE, "gotgetbuf9", SN_LOCAL);
	set_name(0XA9FC, "gotgetbuf10", SN_LOCAL);
	set_name(0XA9FF, "gotgetbuf11", SN_LOCAL);
	set_name(0XAA0C, "gotgetbuf12", SN_LOCAL);
	set_name(0XAA20, "gotgetbuf13", SN_LOCAL);
	set_name(0XAA3C, "gotgetbuf14", SN_LOCAL);
	set_name(0XAA41, "gotgetbuf15", SN_LOCAL);
	set_name(0XAA44, "gotgetbuf16", SN_LOCAL);
	add_func    (0XAA4B,0XAA5D);
	set_func_flags(0XAA4B,0x4400);
	set_frame_size(0XAA4B, 0, 0, 0);
	add_func    (0XAA5D,0XAA64);
	set_func_flags(0XAA5D,0x4400);
	set_frame_size(0XAA5D, 0, 0, 0);
	add_func    (0XAA64,0XAAA1);
	set_func_flags(0XAA64,0x4400);
	set_frame_size(0XAA64, 0X4, 0, 0);
	set_name(0XAA7B, "not_first", SN_LOCAL);
	set_name(0XAA93, "nret", SN_LOCAL);
	set_name(0XAAA0, "pbx", SN_LOCAL);
	add_func    (0XAAB0,0XAC2B);
	set_func_flags(0XAAB0,0x400);
	set_frame_size(0XAAB0, 0, 0, 0);
	set_name(0XAAE2, "getb1", SN_LOCAL);
	set_name(0XAB09, "getb5", SN_LOCAL);
	set_name(0XAB1A, "getb10", SN_LOCAL);
	set_name(0XAB2C, "getb11", SN_LOCAL);
	set_name(0XAB34, "getb12", SN_LOCAL);
	set_name(0XAB46, "getb12x", SN_LOCAL);
	set_name(0XAB59, "getb13", SN_LOCAL);
	set_name(0XAB7B, "getb14", SN_LOCAL);
	set_name(0XAB86, "getb15", SN_LOCAL);
	set_name(0XAB8B, "getb17", SN_LOCAL);
	set_name(0XABAA, "getb18", SN_LOCAL);
	set_name(0XABB2, "getb19", SN_LOCAL);
	set_name(0XABB6, "getb19x", SN_LOCAL);
	set_name(0XABB8, "getb20", SN_LOCAL);
	set_name(0XABD0, "getb25", SN_LOCAL);
	set_name(0XABF3, "getb26", SN_LOCAL);
	set_name(0XAC00, "getb27", SN_LOCAL);
	set_name(0XAC0B, "getb30", SN_LOCAL);
	set_name(0XAC1B, "getb35", SN_LOCAL);
	set_name(0XAC26, "getbx", SN_LOCAL);
	add_func    (0XAC2B,0XAC7C);
	set_func_flags(0XAC2B,0x4400);
	set_frame_size(0XAC2B, 0, 0, 0);
	set_name(0XAC32, "flshbuf_1", SN_LOCAL);
	set_name(0XAC3B, "flshbuf_2", SN_LOCAL);
	set_name(0XAC4E, "scan_buf_queue", SN_LOCAL);
	set_name(0XAC63, "free_the_buf", SN_LOCAL);
	set_name(0XAC68, "dont_free_the_buf", SN_LOCAL);
	set_name(0XAC71, "end_scan", SN_LOCAL);
	set_name(0XAC7B, "flushbuf_retn", SN_LOCAL);
	add_func    (0XAC7C,0XACB1);
	set_func_flags(0XAC7C,0x4400);
	set_frame_size(0XAC7C, 0, 0, 0);
	set_name(0XAC99, "DOBUFFER", SN_LOCAL);
	set_name(0XACAF, "LEAVE_BUF", SN_LOCAL);
	add_func    (0XACB1,0XAD57);
	set_func_flags(0XACB1,0x4400);
	set_frame_size(0XACB1, 0, 0, 0);
	set_name(0XACEE, "NO_IGNORE", SN_LOCAL);
	set_name(0XACF9, "WRTAGAIN", SN_LOCAL);
	set_name(0XAD2C, "bufwr_movsd", SN_LOCAL);
	set_name(0XAD33, "NBUFFINHMA", SN_LOCAL);
	set_name(0XAD47, "NOSET", SN_LOCAL);
	add_func    (0XAD57,0XAD58);
	set_func_flags(0XAD57,0x4400);
	set_frame_size(0XAD57, 0, 0, 0);
	add_func    (0XAD58,0XAD64);
	set_func_flags(0XAD58,0x4400);
	set_frame_size(0XAD58, 0, 0, 0);
	add_func    (0XAD64,0XAD6A);
	set_func_flags(0XAD64,0x4400);
	set_frame_size(0XAD64, 0, 0, 0);
	add_func    (0XAD6A,0XAD78);
	set_func_flags(0XAD6A,0x4400);
	set_frame_size(0XAD6A, 0, 0, 0);
	set_name(0XAD77, "ddcx", SN_LOCAL);
	add_func    (0XB312,0XB321);
	set_func_flags(0XB312,0x4400);
	set_frame_size(0XB312, 0, 0, 0);
	add_func    (0XB321,0XB32C);
	set_func_flags(0XB321,0x4400);
	set_frame_size(0XB321, 0X2, 0, 0);
	add_func    (0XB32C,0XB33A);
	set_func_flags(0XB32C,0x4400);
	set_frame_size(0XB32C, 0X2, 0, 0);
	add_func    (0XB33A,0XB34B);
	set_func_flags(0XB33A,0x4400);
	set_frame_size(0XB33A, 0, 0, 0);
	add_func    (0XB34B,0XB359);
	set_func_flags(0XB34B,0x4400);
	set_frame_size(0XB34B, 0, 0, 0);
	add_func    (0XB359,0XB370);
	set_func_flags(0XB359,0x400);
	set_frame_size(0XB359, 0, 0, 0);
	set_name(0XB35E, "Scan0", SN_LOCAL);
	add_func    (0XB370,0XB3BC);
	set_func_flags(0XB370,0x4400);
	set_frame_size(0XB370, 0, 0, 0);
	set_name(0XB383, "GetEntries", SN_LOCAL);
	set_name(0XB397, "sse_next_char", SN_LOCAL);
	set_name(0XB3AA, "End_List", SN_LOCAL);
	set_name(0XB3AB, "Not_Matched", SN_LOCAL);
	set_name(0XB3AE, "SkipOne", SN_LOCAL);
	add_func    (0XB443,0XB44A);
	set_func_flags(0XB443,0x4400);
	set_frame_size(0XB443, 0, 0, 0);
	add_func    (0XB44A,0XB47C);
	set_func_flags(0XB44A,0x4400);
	set_frame_size(0XB44A, 0, 0, 0);
	set_name(0XB44E, "arena_free_process_start", SN_LOCAL);
	set_name(0XB454, "arena_free_process_loop", SN_LOCAL);
	set_name(0XB462, "arena_free_next", SN_LOCAL);
	set_name(0XB46C, "arena_chk_umbs", SN_LOCAL);
	add_func    (0XB47C,0XB483);
	set_func_flags(0XB47C,0x400);
	add_func    (0XB483,0XB493);
	set_func_flags(0XB483,0x4400);
	set_frame_size(0XB483, 0, 0, 0);
	add_func    (0XB493,0XB4B5);
	set_func_flags(0XB493,0x400);
	add_func    (0XB4B5,0XB523);
	set_func_flags(0XB4B5,0x400);
	set_name(0XB4D5, "norm_alloc", SN_LOCAL);
	set_name(0XB4EF, "alloc_scan", SN_LOCAL);
	set_name(0XB4F7, "alloc_next", SN_LOCAL);
	set_name(0XB518, "norm_strat", SN_LOCAL);
	set_name(0XB51B, "alloc_chk_end", SN_LOCAL);
	set_name(0XB522, "alloc_err", SN_LOCAL);
	set_name(0XB528, "alloc_errj", SN_LOCAL);
	set_name(0XB52B, "alloc_end", SN_LOCAL);
	set_name(0XB536, "alloc_chk", SN_LOCAL);
	set_name(0XB55D, "alloc_free", SN_LOCAL);
	set_name(0XB56D, "alloc_test", SN_LOCAL);
	set_name(0XB57F, "alloc_best", SN_LOCAL);
	set_name(0XB595, "alloc_make_best", SN_LOCAL);
	set_name(0XB59A, "alloc_last", SN_LOCAL);
	set_name(0XB5A2, "alloc_do_split_high", SN_LOCAL);
	add_func    (0XB60D,0XB631);
	set_func_flags(0XB60D,0x400);
	add_func    (0XB631,0XB666);
	set_func_flags(0XB631,0x400);
	set_name(0XB649, "deallocate", SN_LOCAL);
	set_name(0XB65E, "dealloc_err", SN_LOCAL);
	add_func    (0XB6D9,0XB71A);
	set_func_flags(0XB6D9,0x4400);
	set_frame_size(0XB6D9, 0, 0, 0);
	set_name(0XB6E8, "GLA_next", SN_LOCAL);
	set_name(0XB6FA, "GLA_chkumb", SN_LOCAL);
	set_name(0XB6FC, "GLA_@f", SN_LOCAL);
	set_name(0XB6FE, "GLA_done", SN_LOCAL);
	set_name(0XB70E, "GLA_ret", SN_LOCAL);
	set_name(0XB711, "GLA_err", SN_LOCAL);
	add_func    (0XB869,0XB886);
	set_func_flags(0XB869,0x4400);
	set_frame_size(0XB869, 0, 0, 0);
	set_name(0XB882, "ReturnCarry_inv_hndl", SN_LOCAL);
	add_func    (0XB886,0XB8A0);
	set_func_flags(0XB886,0x4400);
	set_frame_size(0XB886, 0, 0, 0);
	set_name(0XB89C, "ReturnCarry_inv_hndl2", SN_LOCAL);
	add_func    (0XB8A0,0XB8CB);
	set_func_flags(0XB8A0,0x4400);
	set_frame_size(0XB8A0, 0, 0, 0);
	set_name(0XB8AA, "sfsfn5", SN_LOCAL);
	set_name(0XB8BE, "sfsfn7", SN_LOCAL);
	add_func    (0XB8CB,0XB8DE);
	set_func_flags(0XB8CB,0x4400);
	set_frame_size(0XB8CB, 0, 0, 0);
	set_name(0XB8CD, "jfnf1", SN_LOCAL);
	set_name(0XB8DD, "jfnfx", SN_LOCAL);
	add_func    (0XB8DE,0XB926);
	set_func_flags(0XB8DE,0x4400);
	set_frame_size(0XB8DE, 0, 0, 0);
	set_name(0XB8E1, "sfnf5", SN_LOCAL);
	set_name(0XB8F4, "sfnf7", SN_LOCAL);
	set_name(0XB8F7, "sfnf10", SN_LOCAL);
	set_name(0XB90B, "sfnf20", SN_LOCAL);
	set_name(0XB923, "sfnf95", SN_LOCAL);
	add_func    (0XB926,0XB959);
	set_func_flags(0XB926,0x400);
	set_name(0XB945, "FreeJFN", SN_LOCAL);
	set_name(0XB94C, "PostFree", SN_LOCAL);
	add_func    (0XBA2E,0XBA8C);
	set_func_flags(0XBA2E,0x400);
	set_name(0XBA22, "ok_done", SN_LOCAL);
	set_name(0XBA2C, "CommitErrorj3", SN_LOCAL);
	set_name(0XBA55, "needi24", SN_LOCAL);
	add_func    (0XBA91,0XBAF5);
	set_func_flags(0XBA91,0x400);
	set_name(0XBAA8, "LSeekStore", SN_LOCAL);
	set_name(0XBAAB, "LSeekSetpos", SN_LOCAL);
	set_name(0XBABB, "LSeekEOF", SN_LOCAL);
	set_name(0XBAC2, "LOCAL_LSeek", SN_LOCAL);
	set_name(0XBACC, "Check_LSeek_Mode", SN_LOCAL);
	set_name(0XBAE4, "NET_LSEEK", SN_LOCAL);
	add_func    (0XBC1C,0XBC41);
	set_func_flags(0XBC1C,0x4400);
	set_frame_size(0XBC1C, 0, 0, 0);
	set_name(0XBC2F, "CheckOwner_retn", SN_LOCAL);
	set_name(0XBC30, "_skip_win386", SN_LOCAL);
	set_name(0XBC32, "no_win386", SN_LOCAL);
	set_name(0XBC3D, "CheckOwner_err", SN_LOCAL);
	set_name(0XBC40, "co_ret_label", SN_LOCAL);
	add_func    (0XBC7C,0XBC91);
	set_func_flags(0XBC7C,0x4400);
	set_frame_size(0XBC7C, 0, 0, 0);
	set_name(0XBC81, "fdpb5", SN_LOCAL);
	set_name(0XBC8F, "fdpb10", SN_LOCAL);
	set_name(0XBC90, "ret_label15", SN_LOCAL);
	add_func    (0XBC91,0XBCDE);
	set_func_flags(0XBC91,0x4400);
	set_frame_size(0XBC91, 0, 0, 0);
	set_name(0XBCDA, "icds5", SN_LOCAL);
	set_name(0XBCDC, "icdsx", SN_LOCAL);
	add_func    (0XBD2C,0XBD48);
	set_func_flags(0XBD2C,0x4400);
	set_frame_size(0XBD2C, 0, 0, 0);
	add_func    (0XBD48,0XBD97);
	set_func_flags(0XBD48,0x4400);
	set_frame_size(0XBD48, 0, 0, 0);
	set_name(0XBD51, "GTD10", SN_LOCAL);
	set_name(0XBD7F, "GTD20", SN_LOCAL);
	set_name(0XBD8A, "GTD30", SN_LOCAL);
	set_name(0XBD94, "GTDX", SN_LOCAL);
	add_func    (0XBD97,0XBDBB);
	set_func_flags(0XBD97,0x4400);
	set_frame_size(0XBD97, 0, 0, 0);
	set_name(0XBDB9, "GetCDS_err", SN_LOCAL);
	add_func    (0XBDBB,0XBE1D);
	set_func_flags(0XBDBB,0x4410);
	set_frame_size(0XBDBB, 0X10, 2, 0);
	define_local_var(0XBDBB, 0XBE1D, "[bp-0X10]", "FCBTmp");
	set_name(0XBDE6, "GetDrive", SN_LOCAL);
	set_name(0XBDF3, "FCBScan", SN_LOCAL);
	set_name(0XBE16, "BadPack", SN_LOCAL);
	set_name(0XBE19, "FCBRet", SN_LOCAL);
	add_func    (0XBE1D,0XBE21);
	set_func_flags(0XBE1D,0x4400);
	set_frame_size(0XBE1D, 0, 0, 0);
	add_func    (0XBE21,0XBEEE);
	set_func_flags(0XBE21,0x4400);
	set_frame_size(0XBE21, 0, 0, 0);
	set_name(0XBE70, "NoServerSplice", SN_LOCAL);
	set_name(0XBE7F, "NoPath", SN_LOCAL);
	set_name(0XBE82, "CheckUNC", SN_LOCAL);
	set_name(0XBEA6, "UNCCpy", SN_LOCAL);
	set_name(0XBEB9, "UNCDone", SN_LOCAL);
	set_name(0XBEBC, "UNCTerm", SN_LOCAL);
	set_name(0XBEBF, "CheckDevice", SN_LOCAL);
	set_name(0XBEC9, "CheckPath", SN_LOCAL);
	set_name(0XBEED, "DoFile_retn", SN_LOCAL);
	set_name(0XBEF1, "DoFile", SN_LOCAL);
	set_name(0XBF24, "GetOrig", SN_LOCAL);
	set_name(0XBF32, "SkipPath", SN_LOCAL);
	set_name(0XBF3D, "PathAssure", SN_LOCAL);
	set_name(0XBF40, "DoCanon", SN_LOCAL);
	set_name(0XBF68, "DoSplice", SN_LOCAL);
	set_name(0XBF7A, "SkipSplice", SN_LOCAL);
	set_name(0XBF95, "Done", SN_LOCAL);
	add_func    (0XBF96,0XBFFB);
	set_func_flags(0XBF96,0x4400);
	set_frame_size(0XBF96, 0, 0, 0);
	set_name(0XBFA3, "CanonDec", SN_LOCAL);
	set_name(0XBFA4, "CanonLoop", SN_LOCAL);
	set_name(0XBFB6, "DoTerminate", SN_LOCAL);
	set_name(0XBFB9, "CanonBad", SN_LOCAL);
	set_name(0XBFC2, "PathEnc", SN_LOCAL);
	set_name(0XBFC4, "DoComponent", SN_LOCAL);
	set_name(0XBFD7, "Skip1", SN_LOCAL);
	set_name(0XBFE0, "CanonNormal", SN_LOCAL);
	set_name(0XBFE2, "CanonPath", SN_LOCAL);
	set_name(0XBFF2, "CanonPathLoop", SN_LOCAL);
	add_func    (0XBFFB,0XBFFD);
	set_func_flags(0XBFFB,0x400);
	add_func    (0XBFFD,0XC005);
	set_func_flags(0XBFFD,0x4400);
	set_frame_size(0XBFFD, 0, 0, 0);
	add_func    (0XC005,0XC018);
	set_func_flags(0XC005,0x4400);
	set_frame_size(0XC005, 0, 0, 0);
	set_name(0XC014, "SkipBad", SN_LOCAL);
	add_func    (0XC018,0XC0A6);
	set_func_flags(0XC018,0x4400);
	set_frame_size(0XC018, 0XE, 0, 0);
	add_func    (0XC0A6,0XC12D);
	set_func_flags(0XC0A6,0x400);
	set_frame_size(0XC0A6, 0, 0, 0);
	set_name(0XC0BE, "SpliceScan", SN_LOCAL);
	set_name(0XC0D2, "SpliceSkip", SN_LOCAL);
	set_name(0XC0D5, "SpliceFound", SN_LOCAL);
	set_name(0XC0E3, "SpliceDo", SN_LOCAL);
	set_name(0XC0FB, "NoPoke", SN_LOCAL);
	set_name(0XC103, "SpliceCopy", SN_LOCAL);
	set_name(0XC10E, "SpliceDone", SN_LOCAL);
	set_name(0XC118, "AllDone", SN_LOCAL);
	set_name(0XC11A, "DoSet", SN_LOCAL);
	add_func    (0XC152,0XC169);
	set_func_flags(0XC152,0x4400);
	set_frame_size(0XC152, 0, 0, 0);
	add_func    (0XC169,0XC171);
	set_func_flags(0XC169,0x400);
	set_frame_size(0XC169, 0, 0, 0);
	add_func    (0XC171,0XC18A);
	set_func_flags(0XC171,0x4400);
	set_frame_size(0XC171, 0, 0, 0);
	set_name(0XC188, "Prefix", SN_LOCAL);
	add_func    (0XC18A,0XC194);
	set_func_flags(0XC18A,0x4400);
	set_frame_size(0XC18A, 0, 0, 0);
	add_func    (0XC194,0XC26F);
	set_func_flags(0XC194,0x400);
	set_name(0XC1F2, "OpenFail", SN_LOCAL);
	set_name(0XC1F6, "SetSearch", SN_LOCAL);
	set_name(0XC20E, "_DoOper", SN_LOCAL);
	set_name(0XC246, "OpenE2", SN_LOCAL);
	set_name(0XC24D, "OpenClean", SN_LOCAL);
	set_name(0XC24E, "OpenE", SN_LOCAL);
	set_name(0XC25A, "OpenCritLeave", SN_LOCAL);
	add_func    (0XC26F,0XC273);
	set_func_flags(0XC26F,0x400);
	add_func    (0XC37E,0XC385);
	set_func_flags(0XC37E,0x400);
	set_name(0XC273, "AccessSet", SN_LOCAL);
	add_func    (0XC385,0XC396);
	set_func_flags(0XC385,0x4400);
	set_frame_size(0XC385, 0, 0, 0);
	add_func    (0XC42E,0XC43E);
	set_func_flags(0XC42E,0x4400);
	set_frame_size(0XC42E, 0, 0, 0);
	set_name(0XC438, "Set", SN_LOCAL);
	add_func    (0XC5C7,0XC5DD);
	set_func_flags(0XC5C7,0x4400);
	set_frame_size(0XC5C7, 0, 0, 0);
	set_name(0XC5CB, "LockRetry", SN_LOCAL);
	add_func    (0XC5DD,0XC61D);
	set_func_flags(0XC5DD,0x4400);
	set_frame_size(0XC5DD, 0, 0, 0);
	set_name(0XC608, "lockv_1", SN_LOCAL);
	set_name(0XC610, "lockv_2", SN_LOCAL);
	add_func    (0XC61D,0XC62A);
	set_func_flags(0XC61D,0x4400);
	set_frame_size(0XC61D, 0, 0, 0);
	add_func    (0XC62A,0XC62F);
	set_func_flags(0XC62A,0x4400);
	set_frame_size(0XC62A, 0, 0, 0);
	add_func    (0XC62F,0XC670);
	set_func_flags(0XC62F,0x4400);
	set_frame_size(0XC62F, 0, 0, 0);
	set_name(0XC658, "sharev_1", SN_LOCAL);
	set_name(0XC664, "sharev_2", SN_LOCAL);
	add_func    (0XC670,0XC675);
	set_func_flags(0XC670,0x4400);
	set_frame_size(0XC670, 0, 0, 0);
	add_func    (0XC675,0XC697);
	set_func_flags(0XC675,0x4400);
	set_frame_size(0XC675, 0, 0, 0);
	set_name(0XC676, "retry", SN_LOCAL);
	set_name(0XC67A, "attempt", SN_LOCAL);
	set_name(0XC695, "done", SN_LOCAL);
	add_func    (0XC697,0XC702);
	set_func_flags(0XC697,0x4400);
	set_frame_size(0XC697, 0, 0, 0);
	set_name(0XC6B8, "er_setver", SN_LOCAL);
	set_name(0XC6D7, "er_chkdoshi", SN_LOCAL);
	set_name(0XC6F6, "er_setA2", SN_LOCAL);
	set_name(0XC6FF, "er_done", SN_LOCAL);
	add_func    (0XC919,0XC942);
	set_func_flags(0XC919,0x4400);
	set_frame_size(0XC919, 0, 0, 0);
	add_func    (0XC942,0XC956);
	set_func_flags(0XC942,0x4400);
	set_frame_size(0XC942, 0, 0, 0);
	add_func    (0XC956,0XC962);
	set_func_flags(0XC956,0x4400);
	set_frame_size(0XC956, 0, 0, 0);
	add_func    (0XC962,0XC96E);
	set_func_flags(0XC962,0x4400);
	set_frame_size(0XC962, 0, 0, 0);
	add_func    (0XC96E,0XC986);
	set_func_flags(0XC96E,0x4400);
	set_frame_size(0XC96E, 0, 0, 0);
	set_name(0XC975, "scsagain", SN_LOCAL);
	set_name(0XC984, "scsfound", SN_LOCAL);
	add_func    (0XC986,0XC9A5);
	set_func_flags(0XC986,0x400);
	set_frame_size(0XC986, 0, 0, 0);
	set_name(0XC9A4, "vvexit", SN_LOCAL);
	add_func    (0XC9A5,0XC9B2);
	set_func_flags(0XC9A5,0x4400);
	set_frame_size(0XC9A5, 0, 0, 0);
	add_func    (0XCB0B,0XCBE2);
	set_func_flags(0XCB0B,0x4400);
	set_frame_size(0XCB0B, 0X2, 0, 0);
	set_name(0XCB16, "ep_contep_cont", SN_LOCAL);
	set_name(0XCB24, "epp_1", SN_LOCAL);
	set_name(0XCB37, "epp_2", SN_LOCAL);
	set_name(0XCB60, "ep_done1", SN_LOCAL);
	set_name(0XCB63, "ep_chkpatch2", SN_LOCAL);
	set_name(0XCB8E, "ep_patchcode2", SN_LOCAL);
	set_name(0XCBA8, "ep_chkpatch3", SN_LOCAL);
	set_name(0XCBDA, "ep_notpacked", SN_LOCAL);
	add_func    (0XCBE2,0XCBF6);
	set_func_flags(0XCBE2,0x4400);
	set_frame_size(0XCBE2, 0, 0, 0);
	add_func    (0XCBF6,0XCC16);
	set_func_flags(0XCBF6,0x4400);
	set_frame_size(0XCBF6, 0X2, 0, 0);
	set_name(0XCC06, "ep_chksum", SN_LOCAL);
	set_name(0XCC14, "cp_fail", SN_LOCAL);
	add_func    (0XCCA8,0XCCDE);
	set_func_flags(0XCCA8,0x4400);
	set_frame_size(0XCCA8, 0, 0, 0);
	add_func    (0XCCE1,0XCCED);
	set_func_flags(0XCCE1,0x4400);
	set_frame_size(0XCCE1, 0, 0, 0);
	add_func    (0XCCED,0XCD12);
	set_func_flags(0XCCED,0x4400);
	set_frame_size(0XCCED, 0, 0, 0);
	set_name(0XCD0C, "cpu_286", SN_LOCAL);
	set_name(0XCD0D, "cpu_8086", SN_LOCAL);
	add_func    (0XD02B,0XD053);
	set_func_flags(0XD02B,0x4400);
	set_frame_size(0XD02B, 0, 0, 0);
	add_func    (0XD053,0XD07D);
	set_func_flags(0XD053,0x4400);
	set_frame_size(0XD053, 0, 0, 0);
	set_name(0XD07A, "cXMM_no_driver", SN_LOCAL);
	add_func    (0XD0E3,0XD121);
	set_func_flags(0XD0E3,0x4400);
	set_frame_size(0XD0E3, 0, 0, 0);
	set_name(0XD0F1, "ps_set1", SN_LOCAL);
	set_name(0XD100, "ps_set2", SN_LOCAL);
	set_name(0XD10B, "ps_set3", SN_LOCAL);
	set_name(0XD116, "ps_set4", SN_LOCAL);
	add_func    (0XD121,0XD171);
	set_func_flags(0XD121,0x4400);
	set_frame_size(0XD121, 0X2, 0, 0);
	set_name(0XD132, "jumptabloop", SN_LOCAL);
	set_name(0XD13E, "share_patch", SN_LOCAL);
	set_name(0XD13F, "no_share_patch", SN_LOCAL);
	set_name(0XD16A, "fast_patch", SN_LOCAL);
	set_name(0XD16D, "no_fast_patch", SN_LOCAL);
	add_func    (0XD171,0XD1E9);
	set_func_flags(0XD171,0x4400);
	set_frame_size(0XD171, 0, 0, 0);
	set_name(0XD186, "po_iset1", SN_LOCAL);
	set_name(0XD195, "po_iset2", SN_LOCAL);
	set_name(0XD1A0, "po_iset3", SN_LOCAL);
	set_name(0XD1AB, "po_iset4", SN_LOCAL);
	add_func    (0XD1F9,0XD20F);
	set_func_flags(0XD1F9,0x4400);
	set_frame_size(0XD1F9, 0X4, 0, 0);
	set_name(0XD204, "pin_loop", SN_LOCAL);
}

//------------------------------------------------------------------------
// Information about functions

static Functions(void) {

	Functions_0();
}

//------------------------------------------------------------------------
// Information about segment registers

static SegRegs(void) {
	split_sreg_range(0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X103D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X105E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X106E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X1095,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X10A4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3F10,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X42FA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X430A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4324,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X433B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4353,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X442C,"es",0,3);
	split_sreg_range(0X443D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4443,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4447,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4462,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X446D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4475,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X44EA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X44FD,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4636,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X464B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4681,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X469C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4716,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4734,"es",0XFFFF,3);
	split_sreg_range(0X473E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X475A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4779,"es",0XFFFFFFFFFFFFFFFE,3);
	split_sreg_range(0X478B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4797,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X47BF,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X47D8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X47F7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X480D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4973,"es",0,3);
	split_sreg_range(0X4976,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A1E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4B97,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4C19,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4C2C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4C47,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4E30,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4E61,"es",0,3);
	split_sreg_range(0X4E85,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4EAE,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4EB2,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4FBA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X505A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5116,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5181,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5256,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5299,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X533A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5346,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X556C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X55C6,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X55EF,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X570C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5759,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X575E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5779,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X57AC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5831,"es",0,3);
	split_sreg_range(0X5838,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X58D6,"es",0,3);
	split_sreg_range(0X5965,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5A61,"es",0,3);
	split_sreg_range(0X5A69,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5A83,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5AAA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5B56,"es",0,3);
	split_sreg_range(0X5B5E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5D51,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5DB3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5E16,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5E1D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5E62,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5E78,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5E8D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5EA3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5F52,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5F57,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5F5C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5FCA,"es",0,3);
	split_sreg_range(0X5FE0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6089,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X610D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6118,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6127,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6135,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X62B8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X62BF,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X630C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X639E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X63E0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X63E7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6411,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6418,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X641D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6424,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X642E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X645E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6495,"es",0,3);
	split_sreg_range(0X64A9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X64D2,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X64F7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X652F,"es",0,3);
	split_sreg_range(0X6559,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X656A,"es",0,3);
	split_sreg_range(0X657E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X65AB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X65D1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X65F0,"es",0,3);
	split_sreg_range(0X6606,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6617,"es",0,3);
	split_sreg_range(0X6696,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X66E6,"es",0,3);
	split_sreg_range(0X673B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6749,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6772,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6782,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X67A8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X686E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X688F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X68D3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6979,"es",0,3);
	split_sreg_range(0X69AC,"es",0,3);
	split_sreg_range(0X69E0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6A69,"es",0,3);
	split_sreg_range(0X6AA4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6AAD,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6ABA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6AF8,"es",0,3);
	split_sreg_range(0X6B49,"es",0,3);
	split_sreg_range(0X6C1F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C30,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C51,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C65,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C7E,"es",0,3);
	split_sreg_range(0X6CC9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6CD2,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6CE6,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6CF3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6DF9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6E29,"es",0,3);
	split_sreg_range(0X6E42,"es",0,3);
	split_sreg_range(0X6E70,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6E8C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6EC8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6ED0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6EEB,"es",0,3);
	split_sreg_range(0X6EFB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6F53,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X703E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7079,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X707E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X70AD,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X70B2,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X70B8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X70D8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7128,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7147,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7191,"es",0,3);
	split_sreg_range(0X71A5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X71C9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X71D4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X71DA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X720B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X724D,"es",0,3);
	split_sreg_range(0X72A2,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X72AD,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X72F5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7475,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X74ED,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X755F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X756B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X75EC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7616,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X761A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X763D,"es",0,3);
	split_sreg_range(0X765D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X768A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X76A9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X76CF,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7702,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X776D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7829,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X783B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7840,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X78A3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X78B7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X78BC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X793B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X797C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X79A3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X79FD,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7AC8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7ACE,"es",0,3);
	split_sreg_range(0X7B19,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7B7A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7BB9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7C25,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7D0B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7D4A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7D76,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7D93,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7DD3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7E20,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7E26,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7EFA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X80AB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X80C9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X80D3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8112,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8162,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8179,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X81FC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X82DB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8379,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X838B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X83B2,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X83BD,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X849F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X85F4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X862C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8632,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X866B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X868A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X86B8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X86CD,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X86EC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X86FE,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X870F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X87DE,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X87FB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X880B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X885E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8864,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8AF6,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8AFB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B12,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B1A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B21,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B2B,"es",0,3);
	split_sreg_range(0X8B69,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8BC8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8BF3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8C3C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8C56,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8C63,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8C69,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8C76,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8CC7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8CD4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8D1F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8D35,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8D39,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8D5F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8E57,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8F2B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8F40,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8F59,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8FBB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8FCC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X903A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X90AC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X90B0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X913C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X915A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X91AA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9200,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9226,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X92C5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X92EA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X92FD,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X930A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9347,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X93CA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X94CC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X94E3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X955A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9577,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9594,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X95D4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X95DF,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X95ED,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X95FE,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X961E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9654,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9691,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X969D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X96B8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X96CF,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X96DC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9806,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9857,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X98AE,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9900,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9917,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X991F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X992D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9980,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9C81,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9C99,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9E84,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9F63,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9F90,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9FBB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA03B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA06E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA0B8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA13C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA240,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA260,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA2D2,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA3BB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA6CA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA6DE,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA6E3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA6FA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA72D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA76E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA7A1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA7A7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA7DC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA7E3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA7F3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA7F8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA8E2,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA919,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA91D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAB4F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAB9C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XABB3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XACCD,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XACDD,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAD1D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAD32,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAE3F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAE67,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAE8A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAEC8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAECC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAED3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB02D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB05C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB088,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB09E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB1A7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB1B2,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB1C5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB1E8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB2AA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB2D3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB30D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB37D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB3C8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB433,"es",0,3);
	split_sreg_range(0XB485,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB58D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB593,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB5B5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB5E4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB6E0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB7DC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB7FB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB817,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB86E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB873,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB87F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB8A5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB8AA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB8B7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB982,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB9C4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBA00,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBA04,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBC97,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBCF1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBD17,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBD7A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBDC3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBE05,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBE41,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBE76,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBF01,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBF80,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC086,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC09A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC0BC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC122,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC140,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC212,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC218,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC22E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC348,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC34F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC3B5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC3DE,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC415,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC5ED,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC616,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC640,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC669,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC67E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC6A8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC6CF,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC7FA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC916,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCB28,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCBDF,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCC63,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCC8E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCCCA,"es",0,3);
	split_sreg_range(0XCD2C,"es",0X70,3);
	split_sreg_range(0XCD31,"es",0,3);
	split_sreg_range(0XCD3F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCDCF,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCF0B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCF22,"es",0,3);
	split_sreg_range(0XCF9D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCFA7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCFC6,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD04C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD052,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD075,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD0A4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD0E8,"es",0,3);
	split_sreg_range(0XD120,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD128,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD16F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD176,"es",0,3);
	split_sreg_range(0XD1E8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X1036,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X1051,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X10B7,"ss",0,3);
	split_sreg_range(0X10CA,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3F10,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4253,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X42ED,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X43EF,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4467,"ss",0,3);
	split_sreg_range(0X7E20,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA0B0,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA132,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA295,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA2B7,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA3B3,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB306,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCD6A,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD02A,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD78,"ds",0,3);
	split_sreg_range(0XD7B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X103F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X106D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X108F,"ds",0,3);
	split_sreg_range(0X10A5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X10EA,"ds",0,3);
	split_sreg_range(0X3F10,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4130,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4185,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X418E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4193,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X419A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X419F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X41A6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X41AA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X41B8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X41CE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X420A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4244,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X425B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X42C9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X42DA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4309,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4331,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X435A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X435E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4383,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4387,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X439D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X43B3,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X43D2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X43F6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4487,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4498,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X44C1,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4559,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4587,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X458E,"ds",0,3);
	split_sreg_range(0X45C2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X45CC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X45D2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4614,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4683,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X469D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X46D5,"ds",0,3);
	split_sreg_range(0X46E4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X47B3,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X47B5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X47CF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X47DA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X480E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4817,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4841,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X485F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4894,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4899,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X48A1,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X48AC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X48B2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4982,"ds",0,3);
	split_sreg_range(0X49B9,"ds",0,3);
	split_sreg_range(0X49BF,"ds",0,3);
	split_sreg_range(0X49E8,"ds",0,3);
	split_sreg_range(0X49FA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X49FE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A0E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A18,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A56,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A5A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4AC1,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4B2B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4B2F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4B3C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4B40,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4B64,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4B68,"ds",0,3);
	split_sreg_range(0X4B72,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4B9B,"ds",0,3);
	split_sreg_range(0X4BEF,"ds",0,3);
	split_sreg_range(0X4BF2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4C32,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4CBF,"ds",0,3);
	split_sreg_range(0X4D75,"ds",0,3);
	split_sreg_range(0X4DC6,"ds",0,3);
	split_sreg_range(0X4E7E,"ds",0,3);
	split_sreg_range(0X4F94,"ds",0,3);
	split_sreg_range(0X505F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5114,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X51E6,"ds",0,3);
	split_sreg_range(0X5234,"ds",0,3);
	split_sreg_range(0X52A1,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5326,"ds",0,3);
	split_sreg_range(0X5554,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X555D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5566,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5580,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5583,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5588,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5594,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X55DC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X55E2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X55E8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X55ED,"ds",0,3);
	split_sreg_range(0X5615,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X566E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5671,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5688,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X56AB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X570B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X57EB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X57ED,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5897,"ds",0,3);
	split_sreg_range(0X58A6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X58B8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5964,"ds",0,3);
	split_sreg_range(0X5A82,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5B01,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5B06,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5B0D,"ds",0,3);
	split_sreg_range(0X5B13,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5B54,"ds",0,3);
	split_sreg_range(0X5B5F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5B93,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5C56,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5CB0,"ds",0,3);
	split_sreg_range(0X5CC5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5CCB,"ds",0,3);
	split_sreg_range(0X5CD0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5D2E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5D37,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5D3A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5D4A,"ds",0,3);
	split_sreg_range(0X5D89,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5E85,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5FD6,"ds",0,3);
	split_sreg_range(0X5FE2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5FF2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X600E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6269,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6274,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6277,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6294,"ds",0,3);
	split_sreg_range(0X6298,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6346,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6376,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6394,"ds",0,3);
	split_sreg_range(0X6399,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X645A,"ds",0,3);
	split_sreg_range(0X64A5,"ds",0,3);
	split_sreg_range(0X6555,"ds",0,3);
	split_sreg_range(0X65A7,"ds",0,3);
	split_sreg_range(0X65F8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6602,"ds",0,3);
	split_sreg_range(0X6677,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X667B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6685,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6694,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X66D7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X66FE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6704,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6762,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X67EB,"ds",0,3);
	split_sreg_range(0X681F,"ds",0,3);
	split_sreg_range(0X697B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X69A8,"ds",0,3);
	split_sreg_range(0X69B6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X69EC,"ds",0,3);
	split_sreg_range(0X6A65,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6AF4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6B02,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6BAB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6BBA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6BE3,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C8A,"ds",0,3);
	split_sreg_range(0X6CA6,"ds",0,3);
	split_sreg_range(0X6CF8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6D93,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6DA4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6DC0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6F0F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6FC4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6FE0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X718F,"ds",0,3);
	split_sreg_range(0X71A3,"ds",0,3);
	split_sreg_range(0X725F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7284,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7288,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7367,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X736C,"ds",0,3);
	split_sreg_range(0X7463,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X74E2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X751D,"ds",0,3);
	split_sreg_range(0X757A,"ds",0,3);
	split_sreg_range(0X7592,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X75C6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X75E3,"ds",0,3);
	split_sreg_range(0X7638,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7659,"ds",0,3);
	split_sreg_range(0X769B,"ds",0,3);
	split_sreg_range(0X771C,"ds",0,3);
	split_sreg_range(0X7740,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X774E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7757,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X776F,"ds",0,3);
	split_sreg_range(0X77B4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X77BD,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X77C1,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X77CA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X77FB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X781B,"ds",0,3);
	split_sreg_range(0X7848,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7854,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X789E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X793F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7945,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7949,"ds",0,3);
	split_sreg_range(0X79BF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X79E2,"ds",0,3);
	split_sreg_range(0X7A0D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7AC2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7ACC,"ds",0,3);
	split_sreg_range(0X7AE6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7AF9,"ds",0,3);
	split_sreg_range(0X7B45,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7B52,"ds",0,3);
	split_sreg_range(0X7B56,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7BD7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7BF5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7C1D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7C34,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7C46,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7C49,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7C81,"ds",0,3);
	split_sreg_range(0X7C84,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7CB0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7CB4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7CCD,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7CE8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7CFA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7D17,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7D37,"ds",0,3);
	split_sreg_range(0X7D40,"ds",0,3);
	split_sreg_range(0X7DEE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7E17,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7E1F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7E20,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7E4A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7E6C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7E70,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7EAE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7EB2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7EC0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7EC6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7ECA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7ED9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7EEB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7EF6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7F05,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7FA3,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7FA9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X80A0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X80A5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X80AA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X80DC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X80E5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8225,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8282,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X829F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8585,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X85B0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X85C4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X87B8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X87F7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8803,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8813,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8831,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X88E7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X88EA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X88F9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8C99,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8D66,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8D7D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8D9D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8DB2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8DCA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8DD5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8DDB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8E22,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8EAB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8EB5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8F0F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8F33,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8F38,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8F4B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8F70,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8F89,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8FA1,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8FFF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X900A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9105,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X910B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9115,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9140,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X915B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X91A8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X91D8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X91E8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9294,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X929B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X92A9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9306,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X934B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X96AA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X96B6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X96E9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X96F8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9701,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9705,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X974E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9764,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9767,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X978F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9796,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X97A7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9921,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9932,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9948,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9977,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9985,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X99A9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9EFF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9F01,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9F65,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9F7C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9F82,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9F8E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9FB4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9FB9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA0A1,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA0BE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA0DC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA0F2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA108,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA114,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA11D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA123,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA13E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA161,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA26F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA274,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA30E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA313,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA328,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA362,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA383,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA3AF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA3C3,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA3E4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA3F2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA402,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA49C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA4BA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA547,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA560,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA573,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA57A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA584,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA593,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA5B0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA65B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA66A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA690,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA699,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA6F5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA729,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA776,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA7A0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA7A6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA7E9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA809,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA829,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA82D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA886,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA88E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA8C0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA8C9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA8F0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA918,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA921,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA92D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA939,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA963,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA98E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAA48,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAA50,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAAED,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAB0E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAB7B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XABB1,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAC2A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAC73,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAD31,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAD37,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAD52,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XADEB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAE2B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAE36,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAE60,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAE76,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAE7D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAE89,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAF3F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAF78,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAFD8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAFF7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XAFFF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB047,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB06F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB076,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB080,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB0AD,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB129,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB175,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB1DC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB1E4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB229,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB22E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB23F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB244,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB24C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB24F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB274,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB283,"ds",0,3);
	split_sreg_range(0XB297,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB2A7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB2BB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB2CE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB2E3,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB2EF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB30F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB353,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB358,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB35C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB3D8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB42F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB458,"ds",0,3);
	split_sreg_range(0XB4F1,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB5A7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB5CC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB5D3,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB5FC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB620,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB6EA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB705,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB772,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB801,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB92D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB960,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB993,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB9CB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB9E3,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XB9F2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBA05,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBA5C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBA7A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBB12,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBB63,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBBDF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBBF9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBC81,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBC8D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBCDC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBD00,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBD38,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBD3E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBD96,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBDA5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBE07,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBE62,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBE72,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBEBB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBEED,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBF03,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBF0E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBF27,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBF47,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBF4F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBF6A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XBF7C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC06A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC09C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC0E7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC11F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC142,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC14C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC1E4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC21B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC223,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC257,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC2B0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC2FA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC312,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC326,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC33D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC372,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC3D6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC3EE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC532,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC58F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC617,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC623,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC629,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC66A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC6C4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC6CC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC6F2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC6F6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC7E3,"ds",0,3);
	split_sreg_range(0XC915,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCB39,"ds",0,3);
	split_sreg_range(0XCBE0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCC38,"ds",0,3);
	split_sreg_range(0XCC8D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCD27,"ds",0,3);
	split_sreg_range(0XCD3A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCD40,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCDB8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCDBD,"ds",0,3);
	split_sreg_range(0XCDC9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCE19,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCE3B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCE6A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCEC6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCED6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCEDD,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCEF1,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCF20,"ds",0,3);
	split_sreg_range(0XCF9B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCFB6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCFEE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD010,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD06B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD076,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD084,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD0E2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0,"fs",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3F10,"fs",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7E20,"fs",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0,"gs",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3F10,"gs",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7E20,"gs",0XFFFFFFFFFFFFFFFF,3);
}

//------------------------------------------------------------------------
// Information about all patched bytes:

static Patches(void) {
}

//------------------------------------------------------------------------
// Call all byte feature functions:

static Bytes(void) {
	Bytes_0();
	Bytes_1();
	Bytes_2();
	Bytes_3();
	Bytes_4();
	Bytes_5();
	Bytes_6();
        end_type_updating(UTP_STRUCT);
}

// End of file.
