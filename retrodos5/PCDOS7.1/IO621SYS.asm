

;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 Licensed to: Freeware version			    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	2CC640D7136F5626F0CD56F6A03C7A92

; ---------------------------------------------------------------------------
; File Name   :	C:\Users\erdogan.tan\Desktop\IO621SYS.BIN
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 98D0h Loaded length: 98D0h

		.386
		.model flat

; ===========================================================================

; Segment type:	Regular
BIOSDATA	segment	byte public 'BIOSDATA' use16
		assume cs:BIOSDATA
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

BData_start:				; ...
		jmp	init
; ---------------------------------------------------------------------------
DosDataSg	dw 0			; ...
bios_i2f	db 0EAh			; far jump to int_2f (segment may not be at 70h)
		dw offset int_2f
		dw 70h
romstartaddr	dw 0			; The start address for	the romfind routines
altah		db 0			; ...
					; special key handling
inHMA		db 0			; ...
					; flag indicates we're running from HMA
xms		dd 0			; ...
					; entry	point to xms if	above is true
ptrsav		dd 0			; ...
					; pointer save
					; This variable	holds the pointer to
					; the Request Header passed by a program wishing
					; to use a device driver. When the strategy routine
					; is called it puts the	address	of the Request header
					; in this variable and returns.
auxbuf		db 4 dup(0)		; ...
					; set of 1 byte	buffers	for com	1,2,3, and 4
zeroseg		dw 0			; ...
					; easy way to load segment registers with zero
i13_ds		dw 0			; ...
					; ds register for int 13h call through
prevoper	dw 0			; ...
					; holds	int 13h	request	(i.e. register ax).
number_of_sec	db 0			; ...
					; holds	number of secs.	to read	on an ecc error
auxnum		dw 0			; ...
					; which	aux device was requested
res_dev_list	dw offset auxdev2	; ...
					; CONHeader ;  Device Header for the CON Device	Driver
		dw 70h
		dw 8013h
		dw offset strategy
		dw offset con_entry
		db 'CON     '
auxdev2		dw offset prndev2	; ...
		dw 70h
		dw 8000h
		dw offset strategy
		dw offset aux0_entry
asc_3F		db 'AUX     '           ; ...
prndev2		dw offset timdev	; ...
		dw 70h
		dw 0A0C0h		; ...
		dw offset strategy
		dw offset prn0_entry	; ...
		db 'PRN     '           ; ...
timdev		dw offset dskdev	; ...
		dw 70h			; ...
		dw 8008h
		dw offset strategy
		dw offset tim_entry
		db 'CLOCK$  '           ; ...
dskdev		dw offset com1dev	; ...
		dw 70h
		dw 8C2h
		dw offset strategy
		dw offset dsk_entry
drvmax		db 4			; ...
					; maximum number of drives
step_drv	db 0FEh			; ...
					; -2 ; last drive accessed
fhave96		db 0			; ...
					; flag to indicate presence of 96tpi support
single		db 0			; ...
					; used to detect single	drive systems
fhavek09	db 0			; ...
					; indicates if this is a k09 or	not
					;  used	by console driver.
fsetowner	db 0			; ...
					; = 1 if we are	setting	the owner of a drive.
					;  (examined by	checksingle).
com1dev		dw offset lpt1dev	; ...
					; Device Header	for device "COM1"
		dw 70h
		dw 8000h
		dw offset strategy
		dw offset aux0_entry	; ...
		db 'COM1    '
lpt1dev		dw offset lpt2dev	; ...
		dw 70h
		dw 0A0C0h
		dw offset strategy
		dw offset prn1_entry
		db 'LPT1    '
lpt2dev		dw offset lpt3dev	; ...
		dw 70h
		dw 0A0C0h		; ...
		dw offset strategy
		dw offset prn2_entry
		db 'LPT2    '
		db 0, 0, 0
Orig13		dd 0			; ...
					; Orig13 needs to be at	offset 0B4h
					;  for the CMS floppy driver to	work.
lpt3dev		dw offset com2dev	; ...
					; Device Header	for device LPT3
		dw 70h
word_BC		dw 0A0C0h		; ...
		dw offset strategy
		dw offset prn3_entry
		db 'LPT3    '
com2dev		dw offset com3dev	; ...
		dw 70h
		dw 8000h
		dw offset strategy
		dw offset aux1_entry
		db 'COM2    '
com3dev		dw offset com4dev	; ...
		dw 70h
		dw 8000h
		dw offset strategy
		dw offset aux2_entry
		db 'COM3    '
com4dev		dw 0FFFFh		; ...
		dw 70h
		dw 8000h
		dw offset strategy
		dw offset aux3_entry
		db 'COM4    '
RomVectors	db 10h			; ...
Old10		dd 0
		db 13h
Old13		dd 0			; ...
		db 15h
Old15		dd 0			; ...
		db 19h
Old19		dd 0
		db 1Bh
Old1B		dd 0
start_bds	dw offset bds1		; ...
					; Start	of linked list of BDS's
		dw 70h			; KERNEL_SEGMENT (BIOSDATA segment)
accesscount	db 0			; ...
tim_drv		db 0FFh			; ...
medbyt		db 0			; ...
rflag		db 2			; ...
					; 2 for	read, 3	for write
verify		db 0			; 1 if verify after write
seccnt		dw 0			; ...
		db 0			; -- pad where hardnum was
dsktnum		db 1			; ...
					; number of diskette drives
motorstartup	db 0			; ...
					; value	from table
settlecurrent	db 0			; ...
					; value	from table
settleslow	db 0			; ...
					; slow settle value
nextspeed	db 0			; value	of speed to be used
save_head_sttl	db 0			; ...
					; used by read_sector routine
save_eot	db 0			; ...
					; saved	eot from the default DPT
eot		db 9			; ...
dpt		dd 0			; ...
					; pointer to Disk Parameter Table
cursec		db 0			; ...
					; current sector
curhd		db 0			; ...
					; current head
curtrk		dw 0			; ...
					; current track
spsav		dw 0			; ...
					; save the stack pointer
formt_eot	db 8			; ...
					; eot used for format
hdnum		db 0			; ...
					; head number
trknum		dw 0			; ...
					; track	being manipulated
gap_patch	db 50h			; ...
					; format gap patched into dpt
errin		db 0CCh			; ...
					; disk errors returned from the	IBM rom
					; write	fault
		db 80h			; no response
		db 40h			; seek failure
		db 10h			; bad crc
		db 8			; dma overrun
		db 6			; media	change
		db 4			; sector not found
		db 3			; write	attempt	to write-protect disk
lsterr		db 0			; ...
					; all other errors
errout		db 10			; returned error codes corresponding to	above
					;  write  fault	error
		db 2			; no response
		db 6			; seek failure
		db 4			; bad crc
		db 4			; dma overrun
		db 15			; invalid media	change
		db 8			; sector not found
		db 0			; write	attempt	to write-protect disk
		db 12			; general error
disksector	db 512 dup(0)		; ...
					; read in boot sector here
bds1		dw offset bds2		; ...
					; dword	link to	next structure
		dw 70h
		db 0			; int 13h drive	number
		db 0			; logical drive	letter
fdrive1		dw 512			; ...
					; physical sector size in bytes
		db 0FFh			; sectors/allocation unit
		dw 1			; reserved sectors for dos
		db 2			; no of	file allocation	tables
		dw 64			; number of root directory entries
		dw 360			; number of sectors (at	512 bytes each)
		db 0			; media	descriptor, initially 0
		dw 2			; number of fat	sectors
		dw 9			; sector limit (sectors	per track)
		dw 1			; head limit (number of	heads -	1)
		dd 0			; hidden sector	count
		dd 0			; number of sectors (32	bit)
fatsiz		db 0			; true => large	fats (BDS.fatsiz)
opcnt1		dw 0			; open ref. count
		db 3			; form factor
flags1		dw 20h			; various flags
		dw 40			; number of cylinders
recbpb1		dw 512			; recommended bps for this drive
		db 1
		dw 1
		db 2
		dw 224			; number of root directory entries
		dw 360
		db 0F0h			; media	descriptor, initially 0F0h
		dw 2
		dw 9
		dw 2
		dd 0
		dd 0
		db 6 dup(0)
		db 0FFh			; last track accessed on this drive
		dw 0FFFFh		; keep these two contiguous (?)
		dw 0FFFFh
		db 'NO NAME    ',0      ; volume id for this disk
		dd 0			; current volume serial	from boot record
		db 'FAT12   ',0         ; current file system id from boot record
bds2		dw offset bds3		; ...
		dw 70h
		db 0
		db 1
fdrive2		db 0, 2, 0FFh, 1, 0, 2,	40h, 0 ; ...
		db 68h,	1, 0, 2, 0, 9, 0, 1
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 3, 20h, 0, 28h
		db 0, 0, 2, 1, 1, 0, 2,	0E0h
		db 0, 68h, 1, 0F0h, 2, 0, 9, 0
		db 2, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 4Eh, 4Fh, 20h
		db 4Eh,	41h, 4Dh, 45h, 20h, 20h, 20h, 20h
		db 0, 0, 0, 0, 0, 46h, 41h, 54h
		db 31h,	32h, 20h, 20h, 20h, 0
bds3		dw offset bds4		; ...
		dw 70h
		db 0
		db 0
fdrive3		db 0, 2, 0FFh, 1, 0, 2,	40h, 0 ; ...
		db 68h,	1, 0, 2, 0, 9, 0, 1
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 3, 20h, 0, 28h
		db 0, 0, 2, 1, 1, 0, 2,	0E0h
		db 0, 68h, 1, 0F0h, 2, 0, 9, 0
		db 2, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 4Eh, 4Fh, 20h
		db 4Eh,	41h, 4Dh, 45h, 20h, 20h, 20h, 20h
		db 0, 0, 0, 0, 0, 46h, 41h, 54h
		db 31h,	32h, 20h, 20h, 20h, 0
bds4		dw 0FFFFh		; ...
		dw 70h
		db 0
		db 0
fdrive4		db 0, 2, 0FFh, 1, 0, 2,	40h, 0 ; ...
		db 68h,	1, 0, 2, 0, 9, 0, 1
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 3, 20h, 0, 28h
		db 0, 0, 2, 1, 1, 0, 2,	0E0h
		db 0, 68h, 1, 0F0h, 2, 0, 9, 0
		db 2, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 4Eh, 4Fh, 20h
		db 4Eh,	41h, 4Dh, 45h, 20h, 20h, 20h, 20h
		db 0, 0, 0, 0, 0, 46h, 41h, 54h
		db 31h,	32h, 20h, 20h, 20h, 0
sm92		db 3, 9, 112, 160, 5, 2, 2 ; ...
keyrd_func	db 0			; ...
keysts_func	db 1			; ...
printdev	db 0			; ...
					; printer device index
wait_count	dw 50h			; ...
					; retry	counts for printers
		dw 50h
		dw 50h
		dw 50h
daycnt		dw 0			; ...
t_switch	db 0			; ...
					; flag for updating daycnt
havecmoscloc	db 0			; ...
base_century	db 19			; ...
base_year	db 80			; ...
month_tab	db 31, 28, 31, 30, 31, 30, 2 dup(31), 30, 31, 30, 31 ; ...
bintobcd	dw offset bin_to_bcd	; ...
		dw 70h
daycnttoday	dw offset daycnt_to_day	; ...
		dw 70h
set_id_flag	db 0			; ...
					; flag for getbp routine
fat_12_id	db 'FAT12   ',0         ; ...
fat_16_id	db 'FAT16   ',0         ; ...
vol_no_name	db 'NO NAME    ',0      ; ...
temp_h		dw 0			; ...
					; temporary for	32 bit calculation
start_sec_h	dw 0			; ...
					; starting sector number high word
saved_word	dw 0			; ...
					; tempory saving place for a word
multrk_flag	dw 0			; ...
ec35_flag	db 0			; ...
					; flags	for 3.5	inch disk drives
vretry_cnt	dw 0			; ...
soft_ecc_cnt	dw 0			; ...
multitrk_format_flag db	0		; ...
					; multi	track format request flag
xfer_seg	dw 0			; ...
					; temp for transfer segment
sectorspertrack	dw 36			; ...
tracktable	db 0, 0, 1, 2		; ...
		db 0, 0, 2, 2
		db 0, 0, 3, 2
		db 0, 0, 4, 2
		db 0, 0, 5, 2
		db 0, 0, 6, 2
		db 0, 0, 7, 2
		db 0, 0, 8, 2
		db 0, 0, 9, 2
		db 0, 0, 10, 2
		db 0, 0, 11, 2
		db 0, 0, 12, 2
		db 0, 0, 13, 2
		db 0, 0, 14, 2
		db 0, 0, 15, 2
		db 0, 0, 16, 2
		db 0, 0, 17, 2
		db 0, 0, 18, 2
		db 0, 0, 19, 2
		db 0, 0, 20, 2
		db 0, 0, 21, 2
		db 0, 0, 22, 2
		db 0, 0, 23, 2
		db 0, 0, 24, 2
		db 0, 0, 25, 2
		db 0, 0, 26, 2
		db 0, 0, 27, 2
		db 0, 0, 28, 2
		db 0, 0, 29, 2
		db 0, 0, 30, 2
		db 0, 0, 31, 2
		db 0, 0, 32, 2
		db 0, 0, 33, 2
		db 0, 0, 34, 2
		db 0, 0, 35, 2
		db 0, 0, 36, 2
		db 108 dup(0)
mediatype	db 0			; ...
media_set_for_format db	0		; ...
					; 1 if we have done an int 13h
					; set media type for format call
had_format_error db 0			; ...
					; 1 if the previous format operation failed.
tempdpt		dd 0FFFFFFFFh		; ...
					; -1 ; temp disk base table
model_byte	db 0FFh			; ...
					; model	byte set at init time
secondary_model_byte db	0		; ...
int19sem	db 0			; ...
					; indicate that	all int	19h
					; initialization is complete
i19_lst		db 2			; ...
					; original hardware int. vectors for int 19h
int19old02	dd 0FFFFFFFFh		; ...
		db 8
int19old08	dd 0FFFFFFFFh		; ...
		db 9
int19old09	dd 0FFFFFFFFh		; ...
		db 0Ah
int19old0A	dd 0FFFFFFFFh		; ...
		db 0Bh
int19old0B	dd 0FFFFFFFFh		; ...
		db 0Ch
int19old0C	dd 0FFFFFFFFh		; ...
		db 0Dh
int19old0D	dd 0FFFFFFFFh		; ...
		db 0Eh
int19old0E	dd 0FFFFFFFFh		; ...
		db 70h
int19old70	dd 0FFFFFFFFh		; ...
		db 72h
int19old72	dd 0FFFFFFFFh		; ...
		db 73h
int19old73	dd 0FFFFFFFFh		; ...
		db 74h
int19old74	dd 0FFFFFFFFh		; ...
		db 76h
int19old76	dd 0FFFFFFFFh		; ...
		db 77h
int19old77	dd 0FFFFFFFFh		; ...
dskdrvs		dw offset fdrive1	; ...
		dw offset fdrive2
		dw offset fdrive3
		dw offset fdrive4
		dw 22 dup(0)		; up to	26 drives for mini disks
int6c_ret_addr	dd 0			; ...
bin_date_time	db 4 dup(0)		; ...
					; century, year, month,	  day
month_table	dw 0, 31, 59, 90, 120, 151, 181, 212, 243, 273,	304, 334 ; ...
daycnt2		dw 0			; ...
feb29		db 0			; february 29 in a leap	  year flag
cdev		dw offset chardev_entry	; ...
cdev_2		dw 2CCh			; ...
					; BIOSCODE segment
ttticks		dw offset time_to_ticks	; ...
		dw 2CCh
bcode_i2f	dw offset i2f_handler	; ...
		dw 2CCh
i13x		dw offset i13z		; ...
		dw 2CCh
; ---------------------------------------------------------------------------

cbreak:					; ...
		mov	cs:altah, 3	; indicate break key set

intret:					; ...
		iret
; ---------------------------------------------------------------------------

strategy:				; ...
		mov	word ptr cs:ptrsav, bx ; store es:bx (device driver request packet)
					;      away at [ptrsav]	for next driver	function call
		mov	word ptr cs:ptrsav+2, es
		retf
; ---------------------------------------------------------------------------

con_entry:				; ...
		call	cdev_entry
		in	al, 0		; 2C7h:0E4h = BIOSCODE:0E4h = 70h:2654h

prn0_entry:				; ...
		call	cdev_entry
		sti
; ---------------------------------------------------------------------------
		db    0
		db 2 dup(0)
; ---------------------------------------------------------------------------

prn1_entry:				; ...
		call	cdev_entry
		sti
; ---------------------------------------------------------------------------
		db    0
		db 0, 1
; ---------------------------------------------------------------------------

prn2_entry:				; ...
		call	cdev_entry
		sti			;  2C7h:0FBh = BIOSCODE:0FBh = 70h:266Bh
		add	[bx+di], al
; ---------------------------------------------------------------------------
		db    2
; ---------------------------------------------------------------------------

prn3_entry:				; ...
		call	cdev_entry
		sti
		add	[bp+si], al
; ---------------------------------------------------------------------------
		db    3
; ---------------------------------------------------------------------------

aux0_entry:				; ...
		call	cdev_entry
		xor	[bx+di], al
; ---------------------------------------------------------------------------
		db 0
; ---------------------------------------------------------------------------

aux1_entry:				; ...
		call	cdev_entry
		xor	[bx+di], al	; 2C7h:130h = BIOSCODE:130h = 70h:26A0h
; ---------------------------------------------------------------------------
		db 1
; ---------------------------------------------------------------------------

aux2_entry:				; ...
		call	cdev_entry
		xor	[bx+di], al
; ---------------------------------------------------------------------------
		db 2
; ---------------------------------------------------------------------------

aux3_entry:				; ...
		call	cdev_entry
		xor	[bx+di], al
; ---------------------------------------------------------------------------
		db 3
; ---------------------------------------------------------------------------

tim_entry:				; ...
		call	cdev_entry
		inc	di		; 2C7h:147h = BIOSCODE:147h = 70h:26B7h
; ---------------------------------------------------------------------------
		db    1
; ---------------------------------------------------------------------------

dsk_entry:				; ...
		call	cdev_entry
; ---------------------------------------------------------------------------
		dw offset DSKTBL	; 2C7h:4A2h = BIOSCODE:4A2h = 70h:2A12h

; =============== S U B	R O U T	I N E =======================================


cdev_entry	proc near		; ...
		cmp	cs:inHMA, 0
		jz	short ce_enter_codeseg
		push	ax		; optimized for	DOS in HMA
		mov	ax, cs:DosDataSg
		cmp	word ptr cs:ptrsav+2, ax
		pop	ax
		jnz	short not_from_dos ; jump is coded this	way to fall thru
					; in 99.99% of the cases

ce_enter_codeseg:			; ...
		jmp	dword ptr cs:cdev
; ---------------------------------------------------------------------------

not_from_dos:				; ...
		call	EnsureA20On
		jmp	short ce_enter_codeseg
cdev_entry	endp


; =============== S U B	R O U T	I N E =======================================


outchr		proc far		; ...
		push	ax		; int 29h handler
		push	si
		push	di
		push	bp
		push	bx
		mov	ah, 0Eh
		mov	bx, 7
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		pop	bx
		pop	bp
		pop	di
		pop	si
		pop	ax
		iret
outchr		endp


; =============== S U B	R O U T	I N E =======================================


block13		proc far		; ...
		cmp	cs:inHMA, 0
		jz	short skipa20
		call	IsA20off	; A20 Off?
		jnz	short skipa20
		call	EnableA20	; assure a20 enabled

skipa20:				; ...
		mov	cs:i13_ds, ds	; save caller's ds for call-through
		pushf			; fake interrupt
		call	dword ptr cs:i13x ; call through Bios_Code entry table
		mov	ds, cs:i13_ds
		retf	2
block13		endp


; =============== S U B	R O U T	I N E =======================================


call_orig13	proc far
		mov	ds, ds:i13_ds	; get caller's ds register
		pushf
		call	cs:Orig13
		mov	cs:i13_ds, ds
		push	cs
		pop	ds		; restore ds ->	Bios_Data before return
		pushf
		cmp	cs:inHMA, 0
		jz	short c_o13_1
		call	IsA20off
; ---------------------------------------------------------------------------
		dw 375h
		dw 10E8h
		db    0
; ---------------------------------------------------------------------------

c_o13_1:				; ...
		popf
		retf
call_orig13	endp

; ---------------------------------------------------------------------------
HiMem		dd 0FFFF0090h		; ...
LoMem		dd 80h			; ...

; =============== S U B	R O U T	I N E =======================================


EnsureA20On	proc near		; ...
		call	IsA20off
		jz	short EnableA20
		retn
; ---------------------------------------------------------------------------

EnableA20:				; ...
		push	ax
		push	bx
		mov	ah, 5		; local	enable A20
		call	cs:xms
		pop	bx
		pop	ax
		retn
EnsureA20On	endp


; =============== S U B	R O U T	I N E =======================================


IsA20off	proc near		; ...
		push	ds
		push	es
		push	cx
		push	si
		push	di
		lds	si, cs:HiMem
		les	di, cs:LoMem
		mov	cx, 8
		repe cmpsw
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ds
		retn
IsA20off	endp

; ---------------------------------------------------------------------------

DisableA20:
		push	ax
		push	bx
		mov	ah, 6		; local	disable	A20
		call	cs:xms		; call far [cs:xms]
		pop	bx
		pop	ax
		retn
; ---------------------------------------------------------------------------

int19:					; ...
		push	cs
		pop	ds
		mov	es, ds:zeroseg
		assume es:nothing
		mov	cx, 5
		mov	si, offset RomVectors

_next_int:				; ...
		lodsb			; get int number
		cbw			; assume < 128
		shl	ax, 1
		shl	ax, 1		; int *	4
		mov	di, ax
		lodsw			; install the saved vector
		stosw
		lodsw
		stosw
		loop	_next_int
		cmp	ds:int19sem, 0
		jz	short doint19
		mov	si, offset i19_lst ; stacks code has changed these hardware interrupt vectors
					; stkinit in sysinit1 will initialize int19oldxx values
		mov	cx, 14

i19_restore_loop:			; ...
		lodsb			; get interrupt	number
		cbw			; assume < 128
		mov	di, ax
		lodsw			; get original vector offset
		mov	bx, ax		; save it
		lodsw
		cmp	bx, 0FFFFh	; check	for 0ffffh (unlikely segment)
		jz	short i19_restor_1 ; opt no need to check selector too
		cmp	ax, 0FFFFh
		jz	short i19_restor_1
		add	di, di
		add	di, di
		xchg	ax, bx
; ---------------------------------------------------------------------------
		dw 93ABh
		db 0ABh	; «
; ---------------------------------------------------------------------------

i19_restor_1:				; ...
		loop	i19_restore_loop

doint19:				; ...
		cmp	ds:inHMA, 0	; Is dos running from HMA ?
		jz	short SkipVDisk	; no
		call	EraseVDiskHead	; Then erase our VDISK header at 1MB boundary
					; Some m/c's (AST 386 & HP QS/16 do not clear
					; the memory above 1MB during a	warm boot.

SkipVDisk:				; ...
		int	19h		; DISK BOOT
					; causes reboot	of disk	system

Int15:					; ...
		cmp	ax, 4F53h	; del keystroke	? (4F00h+DELKEY)
		jz	short int15_1
		jmp	cs:Old15
; ---------------------------------------------------------------------------

int15_1:				; ...
		push	ds
		push	ax
		mov	ax, 40h		; ROMBIOS data segment
		mov	ds, ax
		assume ds:nothing
		mov	al, ds:17h	; [KBFLAG]
		and	al, 0Ch		; (CTRLSTATE | ALTSTATE)
		cmp	al, 0Ch		; (CTRLSTATE | ALTSTATE)
		jnz	short int15_2
		push	cs
		pop	ds
		assume ds:nothing
		cmp	ds:inHMA, 0	; is DOS running from HMA ?
		jz	short int15_2	; no
		call	EraseVDiskHead

int15_2:				; ...
		pop	ax
		pop	ds
		stc
		jmp	cs:Old15

; =============== S U B	R O U T	I N E =======================================


EraseVDiskHead	proc near		; ...
		push	ax
		push	cx
		push	di
		push	es
		call	EnsureA20On
		mov	ax, 0FFFFh	; HMA seg
		mov	es, ax
		assume es:nothing
		mov	di, 10h		; point	to VDISK header
		mov	cx, 16		; size of vdisk	header
		xor	ax, ax
		rep stosw		; clear	it
		pop	es
		assume es:nothing
		pop	di
		pop	cx
		pop	ax
		retn
EraseVDiskHead	endp

; ---------------------------------------------------------------------------

int_2f:					; ...
		jmp	dword ptr cs:bcode_i2f
; ---------------------------------------------------------------------------
		jmp	dsk_entry
; ---------------------------------------------------------------------------

re_init:
		retf
; ---------------------------------------------------------------------------
Win386_SI	db 3, 0			; ...
SI_Next		dd 0			; ...
		dd 0
		dd 0
		dw offset Instance_Table
		dw 70h			; BIOSDATA segment
Instance_Table	dw 0			; ...
		dw 50h			; print	screen status...
		dw 2			; 2 bytes
		dw 0Eh			; ROM Basic data
		dw 50h
		dw 14h
		dw offset altah		; a con	device buffer
		dw 70h			; BIOSDATA segment
		dw 1
NextStack	dw 2 dup(0)		; ...
					; pointer to next stack	to be used
		dw 2			; 2 bytes
IT_StackLoc	dd 0			; ...
					; location of hardware stacks
IT_StackSize	dw 0			; ...
					; size of hardware stacks
		dd 0			; terminate the	instance table
IsWin386	db 0			; ...
					; Flag to indicate whether
					; Win386 is running or not

; =============== S U B	R O U T	I N E =======================================


V86_Crit_SetFocus proc far
		push	di
		push	es
		push	bx
		push	ax
		xor	di, di
		mov	es, di
		assume es:nothing
		mov	bx, 15h
		mov	ax, 1684h
		int	2Fh		; - Multiplex -	MS WINDOWS - GET DEVICE	API ENTRY POINT
					; BX = virtual device (VxD) ID,	ES:DI =	0000h:0000h
					; Return: ES:DI	-> VxD API entry point,	or 0:0 if the VxD does not support an API
		mov	ax, es
		or	ax, di
		jz	short Skip
		push	cs
		mov	ax, offset Skip
		push	ax
		push	es
		push	di
		mov	ax, 1
		retf
; ---------------------------------------------------------------------------

Skip:					; ...
		pop	ax
		pop	bx
		pop	es
		assume es:nothing
		pop	di
		retf
V86_Crit_SetFocus endp

; ---------------------------------------------------------------------------
FreeHMAPtr	dw 0FFFFh		; ...
MoveDOSIntoHMA	dw offset FTryToMovDOSHi ; ...
MoveDOSIntoHMA_2 dw 473h		; ...
					; SYSINIT segment
SysinitPresent	db 0			; ...
endfloppy	db 0			; ...
		db 0
nul_vid		db 'NO NAME    ',0      ; ...
tmp_vid		db 'NO NAME    ',0      ; ...
harddrv		db 80h			; ...
bdss		dw 0FFFFh		; ...
					; max_mini_dsk_num equ 23
					; BDS_STRUC (2+max_mini_dsk_num) dup (<>)
					; currently max. 25
					; (MSDOS 6 BDS structure size =	100 bytes)
		dw 0
		db 80
		db 3
		dw 512
		db 1
		dw 1
		db 2
		dw 16
		dw 0
		db 0F8h
		dw 1
		dw 0
		dw 0
		dd 0
		dd 0
		db 0
		dw 0
		db 3
		dw 20h
		dw 40
		db 31 dup(0)
		db 255
		dw 1
		dw 0
		db 'NO NAME    ',0
		dd 0
		db 'FAT12   ',0
bdss_1		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
bdss_2		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
bdss_3		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
bdss_4		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1 ; ...
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
bdss_24		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h, 1
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 3, 20h, 0, 28h, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0FFh, 1,	0, 0, 0, 4Eh, 4Fh, 20h,	4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h, 32h, 20h, 20h
		db 20h,	0
		db 0
; ---------------------------------------------------------------------------

ibm_disk_io:				; ...
		cmp	dl, 80h		; main routine,	fixes at rom bug
					; pass through floppy disk calls
		jb	short atd1
		cmp	ah, 2
		jz	short atd2	; intercept call 02h (read sectors)
		cmp	ah, 0Ah		; and call 0Ah (read long)
		jz	short atd2

atd1:					; ...
		jmp	cs:Old13	; use rom int 13h handler
; ---------------------------------------------------------------------------

atd2:					; ...
		push	bx
		push	cx
		push	dx
		push	di
		push	ds
		push	es
		push	ax
		mov	ax, 40h		; rombios data segment
		mov	ds, ax
		assume ds:nothing
		mov	byte ptr ds:74h, 0 ; [disk_status1]
					; initially no error code
		and	dl, 7Fh		; mask to hard disk number
		cmp	dl, ds:75h	; [hf_num] ; 40h:75h
		jb	short atd3	; disk number in ranger
		mov	byte ptr ds:74h, 1 ; [disk_status1]
		jmp	short atd4	; disk number out of range error, return
; ---------------------------------------------------------------------------

atd3:					; ...
		push	bx
		mov	ax, es
		shr	bx, 4		; make es:bx to	seg:000x form
		add	ax, bx
		mov	es, ax
		pop	bx
		and	bx, 0Fh
		push	cs
		call	check_dma
		jb	short atd4	; abort	if dma across segment boundary
		pop	ax
		push	ax
		call	setcmd		; set up command block for disk	op
		mov	dx, 3F6h	; hf_reg_port
		out	dx, al		; AT only. Fixed disk register
		call	docmd		; carry	out command

atd4:					; ...
		pop	ax
		mov	ah, ds:74h	; [disk_status1]
		or	ah, ah
		jz	short atd5
		stc

atd5:					; ...
		pop	es
		pop	ds
		assume ds:nothing
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retf	2

; =============== S U B	R O U T	I N E =======================================


setcmd		proc near		; ...
		mov	byte ptr ds:asc_3F+4, al ; [cmd_block+sec_cnt]
		mov	byte ptr ds:prndev2+1, 20h
		cmp	ah, 2		; cmd_reg = 20h	if function 02h	(read)
		jz	short setc1
		mov	byte ptr ds:prndev2+1, 22h ; [cmd_block+cmd_reg]
					; cmd_reg = 22h	if function 0Ah	(read long)

setc1:					; ...
		mov	al, cl
		and	al, 3Fh		; mask sector number
		mov	byte ptr ds:asc_3F+5, al ; [cmd_block+sec_num]
		mov	byte ptr ds:asc_3F+6, ch ; [cmd_block+cyl_low]
		mov	al, cl
		shr	al, 6		; get two high bits of cylinder	number
		mov	byte ptr ds:asc_3F+7, al ; [cmd_block+cyl_high]
		mov	ax, dx
		shl	al, 4		; drive	number
		and	ah, 0Fh
		or	al, ah		; head number
		or	al, 0A0h	; set ecc and 512 bytes	per sector
		mov	byte ptr ds:prndev2, al	; [cmd_block+drv_head]
		push	es
		push	bx
		push	cs
		call	get_vec
		mov	ax, es:[bx+5]	; [es:bx+fdp_precomp]
					; write	pre-comp from disk parameters
		shr	ax, 2
		mov	byte ptr ds:asc_3F+3, al ; [cmd_block+pre_comp]
		mov	al, es:[bx+8]	; [es:bx+fdp_control]
					; control byte modifier
		pop	bx
		pop	es
		mov	ah, ds:step_drv	; [control_byte]
		and	ah, 0C0h	; keep disable retry bits
		or	ah, al
		mov	ds:step_drv, ah
		retn
setcmd		endp


; =============== S U B	R O U T	I N E =======================================


docmd		proc near		; ...
		mov	di, bx
		push	cs
		call	command
		jnz	short doc3

doc1:					; ...
		push	cs
		call	waitt		; wait for controller to complete read
		jnz	short doc3
		mov	cx, 256
		mov	dx, 1F0h	; hf_port
		cld
		cli

rsct_loop:				; ...
		insw			; read in sector
		loop	rsct_loop
		sti
		test	byte ptr ds:prndev2+1, 2 ; [cmd_block+cmd_reg]
		jz	short doc2
		push	cs
		call	wait_drq
		jb	short doc3
		mov	cx, 4		; 4 bytes of ecc
		mov	dx, 1F0h
		cli
		rep insb		; read in ecc
		sti

doc2:					; ...
		push	cs
		call	check_status
		jnz	short doc3
		dec	byte ptr ds:asc_3F+4 ; [cmd_block+sec_cnt]
		jnz	short doc1

doc3:					; ...
		retn
docmd		endp


; =============== S U B	R O U T	I N E =======================================


get_vec		proc near		; ...
		push	0FF65h		; get pointer to hard disk parameters
		jmp	far ptr	0F000h:2F8Eh
get_vec		endp


; =============== S U B	R O U T	I N E =======================================


command		proc near		; ...
		push	0FF65h		; send contents	of cmd_block to	disk controller
		jmp	far ptr	0F000h:2E1Eh
command		endp


; =============== S U B	R O U T	I N E =======================================


waitt		proc near		; ...
		push	0FF65h		; wait for disk	interrupt
		jmp	far ptr	0F000h:2E7Fh
waitt		endp


; =============== S U B	R O U T	I N E =======================================


wait_drq	proc near		; ...
		push	0FF65h		; wait for data	request
		jmp	far ptr	0F000h:2EE2h
wait_drq	endp


; =============== S U B	R O U T	I N E =======================================


check_status	proc near		; ...
		push	0FF65h		; check	hard disk status
		jmp	far ptr	0F000h:2EF8h
check_status	endp


; =============== S U B	R O U T	I N E =======================================


check_dma	proc near		; ...
		push	0FF65h		; check	for dma	overrun	64k segment
		jmp	far ptr	0F000h:2F69h
check_dma	endp

; ---------------------------------------------------------------------------

endatrom:				; ...
		cmp	ah, 15h
		ja	short mebbe_hookit

no_hookit:				; ...
		jmp	cs:Old13
; ---------------------------------------------------------------------------

mebbe_hookit:				; ...
		cmp	dl, 80h
		jb	short no_hookit
		push	ds
		push	ax
		mov	ax, 40h
		mov	ds, ax
		assume ds:nothing
		pop	ax
		pushf
		call	cs:Old13
		pop	ds
		assume ds:nothing
		retf	2
; ---------------------------------------------------------------------------
end_compaq_i13hook db 0			; ...
; ---------------------------------------------------------------------------

daycnt_to_day:				; ...
		push	cs:daycnt	; entry: [daycnt] = number of days since 1-1-80
					; return: ch - century in bcd
					;	  cl - year in bcd
					;	  dh - month in	bcd
					;	  dl - day in bcd
		cmp	cs:daycnt, 7305	; (365*20+(20/4))
					; # days from 1-1-1980 to 1-1-2000
		jnb	short century20
		mov	cs:base_century, 19
		mov	cs:base_year, 80
		jmp	short years
; ---------------------------------------------------------------------------

century20:				; ...
		mov	cs:base_century, 20
		mov	cs:base_year, 0
		sub	cs:daycnt, 7305	; 365*20+(20/4))
					; adjust daycnt

years:					; ...
		xor	dx, dx
		mov	ax, cs:daycnt
		mov	bx, 1461	; 366+365*3)
					; # of days in a Leap year block
		div	bx		; ax = # of leap block,	dx = daycnt
		mov	cs:daycnt, dx	; save daycnt left
		mov	bl, 4
		mul	bl
		add	cs:base_year, al ; ax =	# of years. Less than 100
		inc	cs:daycnt
		cmp	cs:daycnt, 366	; daycnt = remainder of	leap year block
					; within 366+355+355+355 days
		jbe	short leapyear
		inc	cs:base_year	; if daycnt <= 366, then leap year
					; else daycnt -= 366, base_year++
		sub	cs:daycnt, 366
		mov	cx, 3		; And next three years are normal

regularyear:				; ...
		cmp	cs:daycnt, 365	; for(i=1; i>3 or daycnt <=365;	i++)
		jbe	short yeardone	; {if (daycnt >	365)
		inc	cs:base_year	; { daycnt -= 365
		sub	cs:daycnt, 365	; }
		loop	regularyear	; }
					; should never fall through loop

leapyear:				; ...
		mov	cs:month_tab+1,	29 ; leap year.
					; change month table.

yeardone:				; ...
		xor	bx, bx
		xor	dx, dx
		mov	ax, cs:daycnt
		mov	si, offset month_tab
		mov	cx, 12

months:					; ...
		inc	bl
		mov	dl, [si]
		cmp	ax, dx		; cmp daycnt for each month till fit
					; dh=0
		jbe	short month_done
		inc	si		; next month
		sub	ax, dx		; adjust daycnt
		loop	months		;
					; should never fall through loop

month_done:				; ...
		mov	cs:month_tab+1,	28 ; restore month table value
		mov	dl, bl
		mov	dh, cs:base_year
		mov	cl, cs:base_century ; al=day,dl=month,dh=year,cl=cntry
		call	dword ptr cs:bintobcd ;	call far [cs:bintobcd]
					; convert "day"	to bcd
					; dl = bcd day,	al = month
		xchg	dl, al
		call	dword ptr cs:bintobcd ;	dh = bcd month,	al = year
		xchg	dh, al
		call	dword ptr cs:bintobcd ;	cl = bcd year, al = century
		xchg	cl, al
		call	dword ptr cs:bintobcd ;	ch = bcd century
		mov	ch, al
		pop	cs:daycnt	; restore original value
		retf
; ---------------------------------------------------------------------------

bin_to_bcd:				; ...
		push	cx		; convert a binary input in al
					; (less	than 63h or 99 decimal)
					; into a bcd value in al. ah destroyed
		aam			; AH = AL/10, AL = AL MOD 10
		mov	cl, 4
		shl	ah, cl
		or	al, ah		; AL = (AH*10h)+AL
		pop	cx
		retf
; ---------------------------------------------------------------------------

int6c:					; ...
		push	cs		; The K09 requires the routines	for reading the	clock
					; because of the suspend/resume	facility.
		pop	ds
		pop	word ptr ds:int6c_ret_addr
		pop	word ptr ds:int6c_ret_addr+2
		popf
		call	read_real_date	; get the date from the	clock
		cli
		mov	ds:daycnt, si	; update dos copy of date
		sti
		call	read_real_time	; get the time from the	  rtc
		cli
		mov	ah, 1
		int	1Ah		; CLOCK	- SET TIME OF DAY
					; CX:DX	= clock	count
					; Return: time of day set
		sti
		jmp	ds:int6c_ret_addr ; jmp	far [int6c_ret_addr] ; long jump

; =============== S U B	R O U T	I N E =======================================


read_real_date	proc near		; ...
		push	ax
		push	cx
		push	dx
		xor	ah, ah		; throw	away clock roll	over
		int	1Ah		; CLOCK	- GET TIME OF DAY
					; Return: CX:DX	= clock	count
					; AL = 00h if clock was	read or	written	(via AH=0,1) since the previous
					; midnight
					; Otherwise, AL	> 0
		pop	dx
		pop	cx
		pop	ax
		push	ax
		push	bx
		push	cx
		push	dx
		mov	cs:daycnt2, 1
		mov	ah, 4
		int	1Ah		; CLOCK	- READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
					; Return: DL = day in BCD
					; DH = month in	BCD
					; CL = year in BCD
					; CH = century (19h or 20h)
		jnb	short read_ok
		jmp	r_d_ret
; ---------------------------------------------------------------------------

read_ok:				; ...
		mov	ds:bin_date_time, ch
		mov	ds:bin_date_time+1, cl
		mov	ds:bin_date_time+2, dh
		mov	ds:bin_date_time+3, dl
		mov	cs:daycnt2, 2	; READ OF R-T CLOCK SUCCESSFUL
		call	bcd_verify	; verify bcd values in range
		jb	short r_d_ret	; some value out of range
		mov	cs:daycnt2, 3
		call	date_verify
		jb	short r_d_ret
		mov	cs:daycnt2, 0
		call	in_bin
		mov	al, ds:bin_date_time+1
		cbw
		cmp	ds:bin_date_time, 20 ; 20th century?
		jnz	short century_19
		add	ax, 100		; add in a century

century_19:				; ...
		sub	ax, 80		; subtract off 1-1-80
		mov	cl, 4		; leap year every 4
		div	cl		; al= #	leap year blocks, ah= remainder
		mov	bl, ah		; save odd years
		cbw			; zero ah
		mov	cx, 1461	; 366+(3*365)
					; # of days in leap year blocks
		mul	cx
		mov	cs:daycnt2, ax	; SAVE COUNT OF	DAYS
		mov	al, bl		; get odd years	count
		cbw
		or	ax, ax
		jz	short leap_year
		mov	cx, 365		; days in year
		mul	cx
		add	cs:daycnt2, ax	; ADD ON DAYS IN ODD YEARS
		jmp	short leap_adjustment ;	account	for leap year
					; possibly account for a leap day
; ---------------------------------------------------------------------------

leap_year:				; ...
		cmp	ds:bin_date_time+2, 2 ;	is month february?
		jbe	short no_leap_adjustment ; jan or feb. no leap day yet

leap_adjustment:			; ...
		inc	cs:daycnt2	; account for leap day

no_leap_adjustment:			; ...
		mov	cl, ds:bin_date_time+3 ; get days of month
		xor	ch, ch
		dec	cx		; because of offset from day 1,	not day	0
		add	cs:daycnt2, cx	; GET DAYS IN MONTHS PRECEEDING
		mov	cl, ds:bin_date_time+2 ; get month
		xor	ch, ch
		dec	cx		; january starts at offset 0
		shl	cx, 1		; word offset
		mov	si, offset month_table
		add	si, cx
		mov	ax, [si]
		add	cs:daycnt2, ax

r_d_ret:				; ...
		mov	si, cs:daycnt2
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
read_real_date	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR read_real_time

r_t_retj:				; ...
		xor	cx, cx
		xor	dx, dx
		jmp	short r_t_ret
; END OF FUNCTION CHUNK	FOR read_real_time

; =============== S U B	R O U T	I N E =======================================


read_real_time	proc near		; ...

; FUNCTION CHUNK AT 15E6 SIZE 00000006 BYTES

		mov	ah, 2
		int	1Ah		; CLOCK	- READ REAL TIME CLOCK (AT,XT286,CONV,PS)
					; Return: CH = hours in	BCD
					; CL = minutes in BCD
					; DH = seconds in BCD
		jb	short r_t_retj

oktime:
		mov	ds:bin_date_time, ch
		mov	ds:bin_date_time+1, cl
		mov	ds:bin_date_time+2, dh
		mov	ds:bin_date_time+3, 0
		call	bcd_verify
		jb	short r_t_retj
		call	time_verify
		jb	short r_t_retj
		call	in_bin
		mov	ch, ds:bin_date_time
		mov	cl, ds:bin_date_time+1
		mov	dh, ds:bin_date_time+2
		mov	dl, ds:bin_date_time+3
		call	dword ptr ds:ttticks ; call far	[ttticks]
					; note:	indirect far call
					; cx:dx	= number of ticks
					; (at 18.2 ticks per sec.)

r_t_ret:				; ...
		retn
read_real_time	endp


; =============== S U B	R O U T	I N E =======================================


in_bin		proc near		; ...
		mov	al, ds:bin_date_time ; century or hours
		call	bcd_to_bin
		mov	ds:bin_date_time, al
		mov	al, ds:bin_date_time+1 ; years or minutes
		call	bcd_to_bin
		mov	ds:bin_date_time+1, al
		mov	al, ds:bin_date_time+2 ; months	or seconds
		call	bcd_to_bin
		mov	ds:bin_date_time+2, al
		mov	al, ds:bin_date_time+3 ; days (not used	for time)
		call	bcd_to_bin
		mov	ds:bin_date_time+3, al
		retn
in_bin		endp


; =============== S U B	R O U T	I N E =======================================


bcd_to_bin	proc near		; ...
		mov	ah, al		; bcd_to_bin converts two bcd nibbles in al
					; (value <= 99.) to a binary representation in al
		and	al, 0Fh
		mov	cl, 4
		shr	ah, cl
		aad
		retn
bcd_to_bin	endp


; =============== S U B	R O U T	I N E =======================================


date_verify	proc near		; ...
		cmp	ds:bin_date_time, 20h ;	century	check
		ja	short date_error
		jz	short century_20 ; jmp in 21th century
		cmp	ds:bin_date_time, 19h ;	century	check
		jb	short date_error
		cmp	ds:bin_date_time+1, 80h	; year check
		jb	short date_error

century_20:				; ...
		cmp	ds:bin_date_time+1, 99h	; year check
		ja	short date_error
		cmp	ds:bin_date_time+2, 12h	; month	check
		ja	short date_error
		cmp	ds:bin_date_time+2, 0
		jbe	short date_error
		cmp	ds:bin_date_time+3, 31h	; day check
		ja	short date_error
		cmp	ds:bin_date_time+3, 0
		jbe	short date_error
		clc
		retn
; ---------------------------------------------------------------------------

date_error:				; ...
		stc
		retn
date_verify	endp


; =============== S U B	R O U T	I N E =======================================


time_verify	proc near		; ...
		cmp	ds:bin_date_time, 24h ;	hour check
		ja	short time_error
		cmp	ds:bin_date_time+1, 59h	; minute check
		ja	short time_error
		cmp	ds:bin_date_time+2, 59h	; second check
		ja	short time_error
		clc
		retn
; ---------------------------------------------------------------------------

time_error:				; ...
		stc
		retn
time_verify	endp


; =============== S U B	R O U T	I N E =======================================


bcd_verify	proc near		; ...
		mov	cx, 4		; 4 bytes to check
		mov	bx, offset bin_date_time

bv_loop:				; ...
		mov	al, [bx]	; get a	bcd number (0..99)
		mov	ah, al
		and	ax, 0F00Fh	; 10's place in high ah, 1's in al
					; is 1's place in range?
		cmp	al, 10
		ja	short bv_error	; jmp out of range
		shr	ah, 1
		shr	ah, 1
		shr	ah, 1
		shr	ah, 1
		and	ah, 0Fh		; get rid of any erroneous bits
		cmp	ah, 10		; is 10's place in range
		ja	short bv_error	; jmp out of range
		inc	bx
		dec	cx
		jnz	short bv_loop
		clc			; set success flag
		retn
; ---------------------------------------------------------------------------

bv_error:				; ...
		stc			; set error flag
		retn
bcd_verify	endp

; ---------------------------------------------------------------------------
		db 90h
drvfat		dw 0			; ...
bios_l		dw 0			; ...
bios_h		dw 0			; ...
doscnt		dw 0			; ...
fbigfat		db 0			; ...
fatloc		dw 0			; ...
init_bootseg	dw 0			; ...
rom_drv_num	db 80h			; ...
md_sectorsize	dw 512			; ...
temp_cluster	dw 0			; ...
last_fat_secnum	dw 65535		; ...
num_heads	db 2			; ...
sec_trk		db 9			; ...
num_cyln	db 40			; ...
fakefloppydrv	db 0			; ...
disktable	dw 512,	256, 64, 0	;
		dw 2048, 513, 112, 0	; warning !!! old values
		dw 8192, 1026, 256, 0	; default disktable under
		dw 32680, 2051,	512, 0	; the assumption of total fat size <= 128 kb,
		dw 65535, 4100,	1024, 0	; and the maximum size of fat entry = 16 bit.
disktable2	dw 0, 32680, 2051, 512,	0 ; ...
		dw 4, 0, 1026, 512, 64	; fbig = 64 ; covers upto 134 mb media.
		dw 8, 0, 2051, 512, 64	; upto 268 mb
		dw 16, 0, 4100,	512, 64	; upto 536 mb
		dw 32, 0, 8197,	512, 64	; upto 1072 mb
		dw 64, 0, 16390, 512, 64 ; upto	2144 mb
		dw 128,	0, 32775, 512, 64 ; upto 4288 mb...
rom_minidisk_num db 0			; ...
					; temp variable	for phys unit
hnum		db 0			; ...
					; real number of hardfiles
last_dskdrv_table dw offset dskdrvs	; ...
					; index	into dskdrv table
end_of_bdss	dw offset bdss		; ...
					; offset value of the ending address of	bds table.
					; needed to figure out the dosdatasg address.
mini_hdlim	dw 0			; ...
mini_seclim	dw 0			; ...
bios_date	db '01/10/84',0         ; ...
					; used for checking at rom bios	  date.
		db 90h			; align	2
bpb48t		dw 512			; ...
					; 48 tpi diskettes ; physical sector size in bytes
		db 2
		dw 1
		db 2
		dw 112
		dw 720
		db 0FDh
		dw 2
		dw 9
		dw 2
		dw 0
		dw 0
		dd 0
		db 90h
bpb96t		dw 512			; ...
					; 96 tpi diskettes ; physical sector size in bytes
		db 1
		dw 1
		db 2
		dw 224
		dw 2400
		db 0F9h
		dw 7
		dw 15
		dw 2
		dw 0
		dw 0
		db 0
		db 0
		db 0
		db 0
		db 90h
bpb35		dw 512			; ...
					; 3.5" diskettes ; physical sector size	in bytes
		db 2			; sectors/allocation unit
		dw 1			; reserved sectors for dos
		db 2			; number of allocation tables
		dw 112			; number of directory entries
		dw 1440			; number of sectors (at	512 bytes each)
		db 0F9h			; media	descriptor
		dw 3			; number of fat	sectors
		dw 9			; sectors per track
		dw 2			; heads
		dw 0			; hidden sector	count (low word)
		dw 0			; hidden sector	(high)
		dd 0			; number of sectors
		db 90h
bpb288		dw 512			; ...
					; 3.5" diskettes - 2.88	MB ; physical sector size in bytes
		db 2
		dw 1
		db 2
		dw 240
		dw 5760
		db 0F0h	; ð
		dw 9
		dw 36
		dw 2
		dw 0
		dw 0
		dd 0
		db 90h
bpbtable	dw offset bpb48t	; ...
					; 48tpi	drives
		dw offset bpb96t	; 96tpi	drives
		dw offset bpb35		; 3.5" drives
		dw offset bpb35		; unused 8" diskette
		dw offset bpb35		; unused 8" diskette
		dw offset bpb35		; used for hard	disk
		dw offset bpb35		; used for tape	drive
		dw offset bpb35		; FFOTHER
		dw offset bpb35		; ERIMO
		dw offset bpb288	; 2.88MB drive
addr_of_bcretf	dw offset bc_retf	; ...

; =============== S U B	R O U T	I N E =======================================


call_bios_code	proc far		; ...
		push	cs:addr_of_bcretf ; set	up near	return to far return
		push	cs:cdev_2	; push Bios_Code segment
		push	bp		; save offset of utility function
		retf			; far jump to (DOS)BIOS	code
call_bios_code	endp

; ---------------------------------------------------------------------------
flp_drvs	db 0			; ...
; ---------------------------------------------------------------------------

init:					; ...
		cli			; entry	from boot sector. the register contents	are:
					;
					; dl = int 13 drive number we booted from
					; ch = media byte
					; bx = first data sector on disk.
					; ax = first data sector (high)
					; di = sectors/fat for the boot	media.
		push	ax
		xor	ax, ax
		mov	ds, ax
		pop	ax
		mov	cs:bios_h, ax
		mov	cs:bios_l, bx
		push	cs
		pop	es
		assume es:nothing
		push	cx
		push	di
		push	ds
		mov	ax, 473h	; SYSINIT segment
		mov	ds, ax
		assume ds:nothing
		mov	si, offset StartMsg ; "Starting	MS-DOS...\r\n\n"

startmsg_nxt_chr:			; ...
		lodsb
		or	al, al
		jz	short startmsg_ok
		mov	ah, 0Eh
		mov	bx, 7
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		jmp	short startmsg_nxt_chr
; ---------------------------------------------------------------------------

startmsg_ok:				; ...
		pop	ds
		assume ds:nothing
		mov	cx, 5
		mov	si, offset RomVectors

next_int:				; ...
		lods	byte ptr cs:[si]
		cbw
		shl	ax, 1
		shl	ax, 1
		mov	di, ax
		xchg	si, di
		lodsw
		stosw
		lodsw
		stosw
		xchg	si, di
		loop	next_int
		pop	di
		pop	cx
		mov	ax, word ptr cs:Old13
		mov	word ptr cs:Orig13, ax
		mov	ax, word ptr cs:Old13+2
		mov	word ptr cs:Orig13+2, ax
		mov	ds:004Ch, offset block13 ; Int 13h vector
		mov	ds:004Eh, cs
		mov	word ptr ds:0054h, offset Int15	; Int 15h vector
		mov	word ptr ds:0056h, cs
		mov	word ptr ds:0064h, offset int19	; Int 19h vector
		mov	word ptr ds:0066h, cs
		sti
		int	11h		; EQUIPMENT DETERMINATION
					; Return: AX = equipment flag bits
		test	ax, 1		; floppy drives	present	?
		jnz	short normalfloppydrv ;	yes
		push	ax
		push	bx
		push	cx
		push	dx
		push	di
		push	es
		mov	ah, 8
		mov	dl, 0
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		jb	short _gdskp_error
		mov	cs:flp_drvs, dl

_gdskp_error:				; ...
		pop	es
		assume es:nothing
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jb	short normalfloppydrv ;	if error it is an old ROM BIOS
					; so, lets assume that ROM BIOS	lied
		cmp	cs:flp_drvs, 0
		jz	short _set_fake_flpdrv
		mov	al, cs:flp_drvs
		dec	al
		jmp	short got_num_flp_drvs
; ---------------------------------------------------------------------------

_set_fake_flpdrv:			; ...
		mov	cs:fakefloppydrv, 1 ; we don't have any floppy drives.
		mov	ax, 1
		jmp	short settwodrive ; well then set it for two drives!
; ---------------------------------------------------------------------------

normalfloppydrv:			; ...
		rol	al, 1		; there	exist floppy drives.
					; put bits 6 & 7 into bits 0 & 1
		rol	al, 1

got_num_flp_drvs:			; ...
		and	ax, 3		; only look at bits 0 &	1
		jnz	short notsingle	; zero means single drive system
		inc	ax		; pretend it's a two drive system
					; set this to two fakedrives

settwodrive:				; ...
		inc	cs:single

notsingle:				; ...
		inc	ax		; ax has number	of drives
		mov	cl, al
		test	dl, 80h		; determine whether we booted from floppy or hard disk..
		jnz	short gothrd	; hard disk
		xor	ax, ax		; indicate boot	from drive A

gothrd:					; ...
		xor	dx, dx		; ax = 0-based drive we	booted from
					; bios_l, bios_h set.
					; cl = number of floppies including fake one
					; ch = media byte
		cli
		mov	ss, dx
		mov	sp, 700h
		sti
		push	cx
		mov	ah, ch
		push	ax		; save boot drive number and media byte
		mov	ah, 0C0h
		int	15h		; SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
		jb	short no_rom_system_conf
		cmp	ah, 0
		jnz	short no_rom_system_conf
		mov	al, es:[bx+2]	; [es:bx+ROMBIOS_DESC.bios_sd_modelbyte]
		mov	cs:model_byte, al
		mov	al, es:[bx+3]	; [es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]
		mov	cs:secondary_model_byte, al
		jmp	short turn_timer_on
; ---------------------------------------------------------------------------

no_rom_system_conf:			; ...
		mov	si, 0FFFFh
		mov	es, si
		assume es:nothing
		mov	al, es:0Eh	; get model byte (from 0FFFFh:0Eh)
		mov	cs:model_byte, al

turn_timer_on:				; ...
		mov	al, 20h		; turn on the timer
		out	20h, al		; Interrupt controller,	8259A.
		cmp	cs:model_byte, 0 ; Olivetti m24	check
		jnz	short not_olivetti_m24
		in	al, 66h		; inhibit the normal aux port initialization
		test	al, 20h
		jz	short not_olivetti_m24
		mov	al, 0Fh		; double check
		out	50h, al
		in	al, 50h
		test	al, 1		; this test was	copied from olivetti
		jz	short skip_aux_port_init ; take	this branch if 8530 installed

not_olivetti_m24:			; ...
		mov	al, 3		; init com4
		call	aux_init
		mov	al, 2		; init com3
		call	aux_init
		mov	al, 1		; init com2
		call	aux_init
		xor	al, al		; init com1
		call	aux_init

skip_aux_port_init:			; ...
		mov	al, 2		; init lpt3
		call	print_init
		mov	al, 1		; init lpt2
		call	print_init
		xor	al, al		; init lpt1
		call	print_init
		xor	dx, dx
		mov	ds, dx		; to initialize	print screen vector
		mov	es, dx
		assume es:nothing
		xor	ax, ax		; 0
		mov	di, 534h	; INITSPOT
		stosw			; IBM wants 4 zeros here
		stosw
		mov	ax, cs		; fetch	segment
		mov	ds:006Ch, offset cbreak
		mov	ds:006Eh, ax	; [BRKADR]
		mov	ds:00A4h, offset outchr	; [CHROUT*4]
		mov	ds:00A6h, ax
		mov	di, 4
		mov	bx, offset intret
		xchg	ax, bx
		stosw			; location 4
		xchg	ax, bx
		stosw			; cs:
		add	di, 4
		xchg	ax, bx
		stosw			; location 12
		xchg	ax, bx
		stosw			; cs:
		xchg	ax, bx
		stosw			; location 16
		xchg	ax, bx
		stosw			; cs:
		mov	word ptr ds:0500h, dx ;	0  ; Print screen status byte (not active)
		mov	ds:0504h, dx	; 0 ; DOS single diskette mode flag, 0=A:, 1=B:
		mov	al, byte ptr ds:052Ch ;	[SEC9+DISK_PARMS.DISK_MOTOR_STRT]
		mov	cs:motorstartup, al
		cmp	cs:model_byte, 0FDh ; is this an old rom?
		jb	short no_diddle	; no
		mov	ds:052Bh, 20Fh	; [SEC9+DISK_PARMS.DISK_HEAD_STTL], 0200h+NORMSETTLE
		mov	byte ptr ds:0522h, 0DFh	; [SEC9+DISK_PARMS.DISK_SPECIFY_1]
					; set 1st specify byte on pc-1 pc-2 pc-xt hal0

no_diddle:				; ...
		int	12h		; MEMORY SIZE -
					; Return: AX = number of contiguous 1K blocks of memory
		mov	cl, 6
		shl	ax, cl		; convert memory size to 16-byte blocks	(segment no.)
		pop	cx
		mov	cs:drvfat, cx
		push	ax		; save real top	of memory
		push	ds
		push	bx
		xor	bx, bx
		mov	ds, bx
		mov	bx, ds:00BCh	; [2Fh*4]
		mov	ds, ds:00BEh
		cmp	word ptr [bx+3], 5052h ; 'RPL'
		jnz	short SkipRPL
		cmp	byte ptr [bx+5], 4Ch ; 'L'
		jnz	short SkipRPL
		mov	dx, ax		; get TOM into DX
		mov	ax, 4A06h	; (multMULT shl	8) + multMULTRPLTOM
		int	2Fh		; Get new TOM from any RPL
		mov	ax, dx

SkipRPL:				; ...
		pop	bx
		pop	ds
		sub	ax, 40h		; room for fatloc segment. (1 kb buffer)
		mov	cs:fatloc, ax	; location to read fat
		sub	ax, 40h
		mov	cs:init_bootseg, ax
		pop	ax
		mov	dx, 473h	; SYSINIT segment
		mov	ds, dx
		assume ds:nothing
		mov	word ptr ds:DEVICE_LIST, offset	res_dev_list
		mov	word ptr ds:DEVICE_LIST+2, cs
		mov	ds:MEMORY_SIZE,	ax
		inc	cl
		mov	ds:DEFAULT_DRIVE, cl
		mov	ds:CURRENT_DOS_LOCATION, 9FDh ;	DOSLOADSEG
		mov	ax, 473h	; SYSINIT segment
		mov	es, ax
		assume es:nothing
		xor	ax, ax		; some old ibm hardware	generates spurious int 0F's
					; due to bogus printer cards.
					; we initialize	this value to point to an iret
					; only if
					;    1)	the original segment points to
					;	storage	inside valid ram.
					;    2)	the original segment is	0F000:xxxx
		mov	ds, ax		; 0
		assume ds:nothing
		mov	ax, ds:3Eh	; segment for INT 0Fh
		cmp	ax, es:MEMORY_SIZE ; es:294h
					; (condition 1)
		jbe	short resetintf
		cmp	ax, 0F000h	; (condition 2)
		jnz	short keepintf

resetintf:				; ...
		mov	ds:3Ch,	offset intret ;	[0Fh*4]
		mov	ds:3Eh,	cs

keepintf:				; ...
		xor	cx, cx
		mov	ds, cx
		mov	cl, ds:0496h	; get keyboard flag
		test	cl, 10h		; extended keyboard ?
		jz	short org_key	; no, original keyboard
					; change for extended keyboard functions
		mov	cs:keyrd_func, 10h
		mov	cs:keysts_func,	11h

org_key:				; ...
		push	cs
		pop	ds
		push	cs
		pop	es
		assume es:nothing
		call	cmos_clock_read	; If cmos clock	exists,
					; then set the system time according to	that.
					; also,	reset the cmos clock rate.
		mov	word ptr ds:BData_start, offset	harddrv	; hdrv_pat
					; set up pointer to hdrive
		pop	ax		; number of floppies and FAT ID
		xor	ah, ah		; chuck	fat id byte
		mov	ds:drvmax, al	; remember which drive is hard disk
		mov	ds:dsktnum, al	; and set initial number of drives
		shl	ax, 1
		add	ds:last_dskdrv_table, ax
		push	ds
		mov	ax, 0F000h	; point	to ROM BIOS
		mov	ds, ax
		assume ds:nothing
		cmp	word ptr ds:0FFEAh, 4F43h ; 'OC' ; look for COMPAQ
		jnz	short skip_mode2
		cmp	word ptr ds:0FFECh, 504Dh ; 'PM'
		jnz	short skip_mode2
		cmp	word ptr ds:0FFEEh, 5141h ; 'QA'
		jnz	short skip_mode2
		mov	ax, 0E400h
		int	15h		; OS HOOK - DEVICE OPEN	(AT,XT2,XT286,PS)
					; BX = device ID, CX = process type
					; Return: CF set on error, AH =	status
					; CF clear if successful, AH = 00h
		jb	short skip_mode2
		or	bx, 40h		; enable mode 2
					; (dual	hard disk controllers on Compaq	systems)
		mov	ax, 0E480h
		int	15h		; OS HOOK - DEVICE OPEN	(AT,XT2,XT286,PS)
					; BX = device ID, CX = process type
					; Return: CF set on error, AH =	status
					; CF clear if successful, AH = 00h

skip_mode2:				; ...
		pop	ds
		assume ds:nothing
		mov	dl, 80h
		mov	ah, 8
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		jb	short enddrv
		mov	ds:hnum, dl

enddrv:					; ...
		xor	dl, dl		; scan the list	of drives to determine their type.
					; we have three	flavors	of diskette drives:
					;
					; 48tpi	drives	we do nothing special for them
					; 96tpi	drives	mark the fact that they	have changeline	support.
					; 3.5"	drives	mark changeline	support	and small.
					;
					; the following	code uses registers for	certain	values:
					;
					;    dl	- physical drive
					;    ds:di - points to current bds
					;    cx	- flag bits for	bds
					;    dh	- form factor for the drive
					;	 (1 - 48tpi, 2 - 96tpi,	3 - 3.5" medium)
		push	cs
		pop	ds
		mov	ds:eot,	9
		mov	di, offset start_bds
		cmp	ds:fakefloppydrv, 1
		jnz	short loop_drive
		mov	di, [di]	; [di+BDS.link]	; di <-	first bds link
		mov	di, [di]	; [di+BDS.link]	; di <-	second bds link
		mov	word ptr [di], 0FFFFh ;	-1 ; set end of	link
		jmp	dohard		; allocate/initialise bds for harddrives
; ---------------------------------------------------------------------------

loop_drive:				; ...
		cmp	dl, ds:drvmax
		jb	short got_more
		jmp	done_drives
; ---------------------------------------------------------------------------

got_more:				; ...
		xor	cx, cx		; zero all flags
		mov	di, [di]	; mov di,[di+BDS.link] ; get next bds
		mov	dh, 0		; ff48tpi ; set	form factor to 48 tpi
		mov	ds:num_cyln, 40
		push	ds
		push	di
		push	dx
		push	cx
		push	es
		mov	ah, 8
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		jb	short noparmsfromrom
		cmp	ch, 0		; if ch=0, then	cl,dh=0	too.
		jnz	short pfr_ok
		mov	ch, 39		; rom gave wrong info.
		mov	cl, 9		; let's default to 360k.
		mov	dh, 1

pfr_ok:					; ...
		inc	dh		; make number of heads 1-based
		inc	ch		; make number of cylinders 1-based
		mov	ds:num_heads, dh ; save	parms returned by rom
		and	cl, 3Fh		; extract sectors/track
		mov	ds:sec_trk, cl
		mov	ds:num_cyln, ch	; assume less than 256 cylinders!!
		cmp	cl, ds:eot	; make sure that eot contains the max number of	sec/trk
					;  in system of	floppies
		jbe	short eot_ok
		mov	ds:eot,	cl

eot_ok:					; ...
		pop	es
		assume es:nothing
		pop	cx
		pop	dx
		pop	di
		pop	ds
		mov	ah, 15h		; set command to get dasd type
		int	13h		; DISK - DISK -	GET TYPE (AT,XT2,XT286,CONV,PS)
					; DL = drive ID
					; Return: CF set on error, AH =	disk type (3 = hard drive)
					; CX:DX	= number of sectors on the media
		jb	short changeline_done
		cmp	ah, 2		; check	for presence of	changeline
		jnz	short changeline_done
		or	cl, 2		; fchangeline ;	signal type
		mov	ds:fhave96, 1	; remember that	we have	96tpi disks

changeline_done:			; ...
		cmp	ds:num_cyln, 40	; we have a "strange" medium
		jnz	short try_80
		cmp	ds:sec_trk, 9
		jbe	short nextdrive

gotother:				; ...
		mov	dh, 7
		jmp	short nextdrive	;
					; 80 cylinders and 9 sectors/track => 720 kb device
					; 80 cylinders and 15 sec/trk => 96 tpi	medium
; ---------------------------------------------------------------------------

try_80:					; ...
		cmp	ds:num_cyln, 80
		jnz	short gotother
		mov	dh, 9		; ff288	; assume 2.88 MB drive
		cmp	ds:sec_trk, 36	; is it	?
		jz	short nextdrive	; yes, go update
		cmp	ds:sec_trk, 15
		jz	short got96
		cmp	ds:sec_trk, 9
		jnz	short gotother
		mov	dh, 2		; ffsmall
		jmp	short nextdrive
; ---------------------------------------------------------------------------

got96:					; ...
		mov	dh, 1		; ff96tpi
		jmp	short nextdrive
; ---------------------------------------------------------------------------

noparmsfromrom:				; ...
		pop	es
		pop	cx
		pop	dx
		pop	di
		pop	ds
		mov	ah, 15h		; set command to get dasd type
		int	13h		; DISK - DISK -	GET TYPE (AT,XT2,XT286,CONV,PS)
					; DL = drive ID
					; Return: CF set on error, AH =	disk type (3 = hard drive)
					; CX:DX	= number of sectors on the media
		jb	short nextdrive
		cmp	ah, 2		; is there changeline?
		jnz	short nextdrive
		or	cl, 2
		mov	ds:fhave96, 1	; remember that	we have	96tpi drives
		mov	ds:num_cyln, 80
		mov	dh, 1
		mov	al, 15		; set eot if necessary
		cmp	al, ds:eot
		jbe	short nextdrive
		mov	ds:eot,	al

nextdrive:				; ...
		or	cl, 20h		; fi_own_physical ; set	this true for all drives
		mov	bh, dl		; save int 13h drive number
		cmp	ds:single, 2
		jnz	short not_special
		dec	bh		; int 13h drive	number same for	logical	drive
		xor	cl, 20h		; fi_own_physical ; reset ownership flag for logical drive

not_special:				; ...
		xor	ax, ax		; fill BDS for drive
		mov	al, ds:num_heads
		mov	[di+54], ax	; [di+BDS.rheads]
		mov	al, ds:sec_trk
		mov	[di+52], ax	; [di+BDS.rsecpertrack]
		mov	[di+35], cx	; [di+BDS.flags]
		mov	[di+34], dh	; [di+BDS.formfactor]
		mov	[di+5],	dl	; [di+BDS.drivelet]
		mov	[di+4],	bh	; [di+BDS.drivenum]
		mov	bl, ds:num_cyln
		mov	[di+37], bl	; [di+BDS.cylinders]
		cmp	ds:single, 1	; Special case for single drive	system
		jnz	short no_single
		mov	ds:single, 2	; Don't forget we have single drive system
		or	cx, 10h		; fi_am_mult
					; set that this	is one of several drives
		or	[di+35], cx	; [di+BDS.flags] ; save	flags
		mov	di, [di]	; [di+BDS.link]	; move to next BDS in list
		inc	dl		; add a	number
		jmp	short nextdrive	; Use same info	for BDS	as previous
; ---------------------------------------------------------------------------

no_single:				; ...
		inc	dl
		jmp	loop_drive
; ---------------------------------------------------------------------------

done_drives:				; ...
		mov	word ptr [di], 0FFFFh ;	[di+BDS.link],-1 ; set link to null

dohard:					; ...
		mov	dh, ds:hnum
		or	dh, dh		; done if no hardfiles
		jz	short static_configure
		mov	dl, 80h

dohard1:				; ...
		push	dx
		mov	di, ds:end_of_bdss
		mov	bl, ds:drvmax
		mov	bh, 0		; first	primary	partition (or active)
		call	sethard
		jb	short hardfile_err
		call	dmax_check	; error	if already 26 drives
		jnb	short hardfile_err
		call	xinstall_bds	; insert new bds into linked list

hardfile_err:				; ...
		pop	dx
		inc	dl		; next hard drive
		dec	dh
		jnz	short dohard1	;
					; end of physical drive	  initialization
					;
					; *** do not change the	position of the	following statement.
					; *** domini routine will use [drvmax] value for the start of the logical
					; *** drive number of mini disk(s).
		call	domini		; for setting up mini disks, if	found
		mov	dh, ds:hnum	; we already know this is >0
		mov	dl, 80h

dohardx1:				; ...
		mov	bh, 1		; do all subsequent primary partitions

dohardx2:				; ...
		push	dx
		push	bx
		mov	di, ds:end_of_bdss
		mov	bl, ds:drvmax
		call	sethard
		jb	short dohardx4	; move to next hardfile	if error
		call	dmax_check	; make sure <=26 drives
		jnb	short dohardx4	; skip if error
		call	xinstall_bds	; insert new bds into linked list
		pop	bx		; get partition	number
		pop	dx		; restore physical drive counts
		inc	bh
		jmp	short dohardx2	; keep looping until we	fail
; ---------------------------------------------------------------------------

dohardx4:				; ...
		pop	bx		; unjunk partition number from stack
		pop	dx		; restore physical drive counts
		inc	dl		; next hard drive
		dec	dh
		jnz	short dohardx1
		cmp	ds:dsktnum, 2	; >2 diskette drives
		jbe	short static_configure ; no - no need for remapping
		call	remap		; remap	bds chain to adjust driver letters
					; ...
					; End of drive initialization.

static_configure:			; ...
		mov	di, ds:end_of_bdss
		cmp	di, offset bdss	; did we allocate any hard drive bdss?
		jnz	short dynamic_configure	; that's the end, then
		mov	di, offset harddrv ; end96tpi
					; keep everything up to	end96tpi
		cmp	ds:fhave96, 0
		jnz	short dynamic_configure
		mov	di, offset endfloppy

dynamic_configure:			; ...
		push	cs
		pop	es
		assume es:nothing
		cld			; clear	direction
		cmp	ds:model_byte, 0FCh ; AT ?
		jnz	short checkcompaqbug
		cmp	ds:hnum, 0	; No hard file?
		jz	short checkcompaqbug
		xchg	ax, di		; save allocation pointer in ax
		mov	si, 0F000h
		mov	es, si		; ES ->	ROM BIOS segment
		assume es:nothing
		mov	si, offset bios_date ; "01/10/84"
		mov	di, 0FFF5h	; ROM BIOS string is at	  F000:FFF5
		mov	cx, 9		; bdate_l ; Only patch ROM for bios 01/10/84
		repe cmpsb		; check	for date + zero	on end
		xchg	ax, di		; restore allocation pointer
		jnz	short checkcompaqbug
		mov	cx, offset endatrom
		mov	si, offset ibm_disk_io
		jmp	short install_int13_patch
; ---------------------------------------------------------------------------

checkcompaqbug:				; ...
		mov	ax, 0F000h
		mov	es, ax
		cmp	word ptr es:0FFEAh, 'OC' ; look for COMPAQ
		jnz	short not_compaq_patch
		cmp	word ptr es:0FFECh, 'PM'
		jnz	short not_compaq_patch
		cmp	word ptr es:0FFEEh, 'QA'
		jnz	short not_compaq_patch
		mov	ax, es:0FFFBh	; get year
		xchg	ah, al
		cmp	ax, '86'        ; 3836h ; is it 86?
		ja	short not_compaq_patch
		jb	short do_compaq_patch
		mov	ax, es:0FFF5h	; get month
		xchg	ah, al
		cmp	ax, '08'        ; 3038h ; is it 08?
		ja	short not_compaq_patch
		jb	short do_compaq_patch
		mov	ax, es:0FFF8h	; get day
		xchg	ah, al
		cmp	ax, '04'        ; 3034h ; is it 04?
		jnb	short not_compaq_patch

do_compaq_patch:			; ...
		mov	cx, offset end_compaq_i13hook
		mov	si, offset endatrom

install_int13_patch:			; ...
		push	cs
		pop	es
		assume es:nothing
		mov	word ptr ds:Orig13, di ; set new rom bios int 13 vector
		mov	word ptr ds:Orig13+2, cs
		sub	cx, si		; size of rom fix module
		rep movsb		; relocate it

not_compaq_patch:			; ...
		push	cs
		pop	es
		cmp	ds:havecmoscloc, 1 ; cmos clock	exists?
		jnz	short checkk09	; no
		mov	ds:daycnttoday,	di ; set the address for mschar
		mov	cx, 209		; enddaycnttoday - daycnt_to_day
		mov	si, offset daycnt_to_day
		rep movsb
		mov	ds:bintobcd, di	; set the address for msclock
					; let original segment stay
		mov	cx, 11		; endcmosclockset - bin_to_bcd
		mov	si, offset bin_to_bcd
		rep movsb

checkk09:				; ...
		push	di
		mov	ax, 4101h	; wait for bh=es:[di]
		mov	bl, 1		; wait for 1 clock tick
		mov	bh, es:[di]
		stc
		int	15h		; SYSTEM - WAIT	ON EXTERNAL EVENT (CONVERTIBLE)
					; AL = condition type, BH = condition compare or mask value
					; BL = timeout value times 55 milliseconds, 00h	means no timeout
					; DX = I/O port	address	if AL bit 4 set
		pop	di
		jb	short configdone
		mov	ds:fhavek09, 1	; remember we have a k09 type
		push	ds
		xor	ax, ax
		mov	ds, ax
		mov	word ptr ds:disksector+62h, di ; [6Ch*4]
					; new int 6ch handler
		mov	word ptr ds:disksector+64h, cs
		pop	ds
		mov	si, offset int6c
		mov	cx, 459		; endk09-int6c (size of	k09 routine)
		rep movsb

configdone:				; ...
		push	cs		; di is	final ending address of	msbio.
		pop	ds
		add	di, 15		; round	(up) to	paragraph
		shr	di, 1
		shr	di, 1
		shr	di, 1
		shr	di, 1
		add	di, 70h
		mov	ds:DosDataSg, di ; where the dos data segment will be
		mov	ax, ds:drvfat	; get drive and	fat id
		mov	bp, offset SetDrive ; Note: SETDRIVES uses AL (drive number) only
		push	cs		; simulate far call
		call	near ptr call_bios_code	; get bds for drive
		mov	bp, offset GetBp ; ensure valid	bpb is present
		push	cs
		call	near ptr call_bios_code
		push	es		; copy bds to ds:di
		pop	ds
		xor	di, di
		mov	al, es:[di]	; get fat id byte
		mov	byte ptr es:drvfat+1, al ; save	fat byte
		mov	ax, es:drvfat
		push	es
		push	ds		; copy bds to es:di
		pop	es
		push	cs		; copy Bios_Data to ds
		pop	ds
		mov	bp, offset SetDrive
		push	cs		; simulate far call
		call	near ptr call_bios_code	; get correct bds for this drive
		push	es
		pop	ds
		pop	es
		assume es:nothing
		mov	bx, [di+6]	; [di+BDS.BDS_BPB.BPB_BYTESPERSECTOR]
		mov	cs:md_sectorsize, bx ; used by get_fat_sector proc.
		mov	bl, [di+31]	; [di+BDS.fatsiz]
					; get size of fat on media
		mov	es:fbigfat, bl
		mov	cl, [di+8]
		mov	ax, [di+23]	; [di+BDS.BDS_BPB.BPB_HIDDENSECTORS]
		sub	es:bios_l, ax	; subtract hidden sectors since	we
					; need a logical sector	number that will
					; be used by getclus(diskrd procedure)
		mov	ax, [di+25]	; [di+BDS.BDS_BPB.BPB_HIDDENSECTORS+2]
		sbb	es:bios_h, ax	; subtract upper 16 bits of sector num
		xor	ch, ch		; cx = sectors/cluster
		push	ds
		xor	di, di		; 0
		mov	ds, di
		mov	bx, ds:053Ah	; clus=*53Ah
					; (First cluster field of 2nd dir entry
					; of root directory in the buffer at 500h)
		pop	ds

loadit:					; ...
		mov	ax, 473h	; SYSINIT segment (SYSINITSEG)
		mov	es, ax
		assume es:nothing
		mov	es, es:CURRENT_DOS_LOCATION
		assume es:nothing
		call	getclus		; read cluster at ES:DI	(DI is updated)
		test	cs:fbigfat, 40h	; fbig
		jnz	short eofbig
		cmp	bx, 0FF7h
		jmp	short iseofx
; ---------------------------------------------------------------------------

eofbig:					; ...
		cmp	bx, 0FFF7h

iseofx:					; ...
		jb	short loadit	; keep loading until cluster = eof
		call	setdrvparms
		jmp	far ptr	473h:269h ; SYSINIT:_SYSINIT

; =============== S U B	R O U T	I N E =======================================


remap		proc near		; ...
		mov	di, cs:start_bds ; get first bds

drive_loop:				; ...
		cmp	byte ptr [di+4], 80h ; [di+BDS.drivenum] ; first hard disk??
		jz	short fdrv_found ; yes,	continue
		mov	di, [di]	; [di+BDS.link]	; get next bds,	assume segment
		cmp	di, -1		; last bds?
		jnz	short drive_loop ; loop	if not
		jmp	short rmap_exit	; yes, no hard drive on	  system
; ---------------------------------------------------------------------------

fdrv_found:				; ...
		mov	al, 2		; start	with logical drv num=2

fdrv_loop:				; ...
		mov	[di+5],	al	; [di+BDS.drivelet] ; found ??
		mov	di, [di]	; [di+BDS.link]	; ds:di--> next	bds
		inc	al		; set num for next drive
		cmp	di, -1		; last hard drive ??
		jnz	short fdrv_loop	; no - assign more disk	  drives
		mov	di, cs:start_bds ; get first bds
		mov	di, [di]	; [di+BDS.link]	; ds:di-->bds2
		mov	ah, cs:dsktnum	; get number of	floppies to remap
		sub	ah, 2		; adjust for a:	& b:

remap_loop1:				; ...
		mov	di, [di]	; [di+BDS.link]	; set new num to next floppy
		mov	[di+5],	al	; [di+BDS.drivelet]
		inc	al		; new number for next floppy
		dec	ah		; count	down extra floppies
		jnz	short remap_loop1 ;
					; now we've got to adjust the boot drive
					; if we	reassigned it
		mov	al, byte ptr cs:drvfat
		cmp	al, 2		; is it	a: or b: ?
		jb	short rmap_exit
		sub	al, cs:dsktnum	; is it	one of the other floppies?
		jb	short remap_boot_flop ;	brif so
		add	al, 2		; bootdrv -= (dsktnum-2)
		jmp	short remap_change_boot_drv
; ---------------------------------------------------------------------------

remap_boot_flop:			; ...
		add	al, cs:drvmax	; bootdrv += (drvmax-dsktnum)

remap_change_boot_drv:			; ...
		mov	byte ptr cs:drvfat, al ; alter msdos.sys load drive
		inc	al
		push	ds
		mov	di, 473h	; SYSINIT segment
		mov	ds, di
		assume ds:nothing
		mov	ds:DEFAULT_DRIVE, al ; [SYSINIT+DEFAULT_DRIVE]
					; pass it to sysinit as	well
		pop	ds
		assume ds:nothing

rmap_exit:				; ...
		retn
remap		endp


; =============== S U B	R O U T	I N E =======================================


getboot		proc near		; ...
		mov	ax, cs:init_bootseg
		mov	es, ax
		mov	bx, 200h	; bootbias
					; load BX, ES:BX is where sector goes
		mov	ax, 201h
		xor	dh, dh
		mov	cx, 1
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		jb	short erret
		cmp	word ptr es:3FEh, 0AA55h ; [es:bootbias+1FEh]
					; Dave Litton magic word?
		jz	short norm_ret	; yes

erret:					; ...
		stc

norm_ret:				; ...
		retn
getboot		endp


; =============== S U B	R O U T	I N E =======================================


sethard		proc near		; ...
		push	di		; generate bpb for a variable sized hard file
		push	bx
		push	ds
		push	es
		mov	[di+5],	bl	; [di+BDS.drivelet]
		mov	[di+4],	dl	; [di+BDS.drivenum]
		or	byte ptr [di+35], 1 ; [di+BDS.flags] ; fnon_removable
		mov	byte ptr [di+34], 5 ; [di+BDS.formfactor] ; ffHardFile
		mov	ds:fbigfat, 0	; assume 12 bit	FAT
		mov	dh, bh		; partition number
		push	dx
		mov	ah, 8
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		inc	dh
		mov	[di+15h], dh	; [di+BDS.heads] ; get number of heads
		pop	dx
		jb	short setret	; error	  if no	hard disk
		and	cl, 3Fh
		mov	[di+13h], cl	; [di+BDS.secpertrack]
		push	dx		; save partition number
		call	getboot
		pop	dx		; restore partition number
		jb	short setret
		mov	bx, 3C2h	; 1C2h+bootbias

act_part:				; ...
		test	byte ptr es:[bx-4], 80h	; is the partition active?
		jz	short not_act	; no
		cmp	byte ptr es:[bx], 1 ; reject if	partitiontype != 1, 4 or 6
		jz	short got_good_act
		cmp	byte ptr es:[bx], 4
		jz	short got_good_act
		cmp	byte ptr es:[bx], 6
		jnz	short not_act

got_good_act:				; ...
		or	dh, dh		; is this our target partition #?
		jz	short set2	; WE GOT THE ONE WANTED!
		dec	dh		; count	down

not_act:				; ...
		add	bx, 16
		cmp	bx, 402h	; 202h+bootbias
					; last entry done?
		jnz	short act_part	; no, process next entry
		mov	bx, 3C2h	; 1C2h+bootbias
					; restore original value of bx

get_primary:				; ...
		test	byte ptr es:[bx-4], 80h	; Now scan the non-active partitions
		jnz	short not_prim	; we've already scanned the ACTIVE ones
		cmp	byte ptr es:[bx], 1 ; see if partitiontype == 1, 4 or 6
		jz	short got_prim
		cmp	byte ptr es:[bx], 4
		jz	short got_prim
		cmp	byte ptr es:[bx], 6
		jnz	short not_prim

got_prim:				; ...
		or	dh, dh		; is this our target partition?
		jz	short set2
		dec	dh

not_prim:				; ...
		add	bx, 16
		cmp	bx, 402h	; 202h+bootbias
		jnz	short get_primary ; loop till we've gone through table

setret:					; ...
		stc			; error	return
		jmp	ret_hard
; ---------------------------------------------------------------------------

set2:					; ...
		mov	cs:rom_drv_num,	dl ; save the rom bios drive number
		mov	ax, es:[bx+4]	; hidden sectors (start	sector)
		mov	dx, es:[bx+6]
		sub	ax, 1		; decrement the	sector count by	1 to make it zero based.
					; exactly 64k sectors should be	allowed
		sbb	dx, 0
		add	ax, es:[bx+8]	; sectors in partition
		adc	dx, es:[bx+10]
		jnb	short okdrive
		or	ds:fbigfat, 80h	; ftoobig

okdrive:				; ...
		mov	ax, es:[bx+4]
		mov	[di+23], ax	; [di+BDS.hiddensecs]
					; BPB_HIDDENSECTORS = p->partitionbegin
		mov	ax, es:[bx+6]
		mov	[di+25], ax	; [di+BDS.hiddensecs+2]
		mov	dx, es:[bx+10]	; # of sectors (high)
		mov	ax, es:[bx+8]	; # of sectors (low)
		mov	[di+29], dx	; [di+BDS.totalsecs32+2]
		mov	[di+27], ax	; [di+BDS.totalsecs32]
					; bpb->maxsec =	p->partitionlength
		cmp	dx, 0
		ja	short okdrive_cont
		cmp	ax, 64		; if (p->partitionlength < 64)
		jb	short setret	; return -1;

okdrive_cont:				; ...
		mov	dx, [di+25]	; [di+BDS.hiddensecs+2]
		mov	ax, [di+23]	; [di+BDS.hiddensecs]
		xor	bx, bx		; boot sector number - for mini	disk
					; usually equal	to the # of sec/trk.
		mov	bl, [di+19]	; [di+BDS.secpertrack]
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	bx
		mov	cs:temp_h, ax
		pop	ax
		div	bx		; (sectors)dx:ax / (BDS.secpertrack)bx =
					; (track)temp_h:ax + (sector)dx
		mov	cl, dl
		inc	cl
		xor	bx, bx
		mov	bl, [di+21]	; [di+BDS.heads]
		push	ax
		xor	dx, dx
		mov	ax, cs:temp_h
		div	bx		; dl is	head, ax is cylinder
		mov	cs:temp_h, ax
		pop	ax
		div	bx
		cmp	cs:temp_h, 0
		ja	short setret_brdg ; exceeds the	limit of int 13h
		cmp	ax, 1024
		ja	short setret_brdg ; exceeds the	limit of int 13h
					; Retro	DOS v3.2 note by Erdogan Tan - 28/07/2019
					; **MSDOS code accepts if ax = 1024 but	it is nonsense here
					; ('ja' must be 'jnb')
		cmp	word ptr [di+71], 1 ; [di+BDS.bdsm_ismini]
					; check	for mini disk
		jnz	short oknotmini	; not mini disk.
		add	ax, [di+73]	; [di+BDS.bdsm_hidden_trks]
					; set the physical track number

oknotmini:				; ...
		ror	ah, 1		; move high two	bits of	cyl to high
		ror	ah, 1		; two bits of upper byte
		and	ah, 0C0h	; turn off remainder of	bits
		or	cl, ah		; move two bits	to correct spot
		mov	ch, al		; ch is	cylinder (low 8	bits)
					; cl is	sector + 2 high	bits of	cylinder
		mov	dh, dl		; dh is	head
		mov	dl, cs:rom_drv_num ; dl	is drive number
		push	cs
		pop	es
		assume es:nothing
		mov	bx, offset disksector
		mov	ax, 201h
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		mov	bx, offset disksector
		push	bx
		push	ax
		cmp	byte ptr cs:[bx], 0E9h ; is it a near jump?
		jz	short check_1_ok ; yes
		cmp	byte ptr cs:[bx], 0EBh ; is it a short jump?
		jnz	short invalid_boot_record ; no
		cmp	byte ptr cs:[bx+2], 90h	; yes, is the next one a nop?
		jnz	short invalid_boot_record

check_1_ok:				; ...
		mov	bx, 159h	; disksector+EXT_BOOT.BPB
					; point	to the bpb in the boot record
		mov	al, cs:[bx+10]	; [bx+EBPB.MEDIADESCRIPTOR]
					; get the mediadescriptor byte
		and	al, 0F0h	; mask off low nibble
		cmp	al, 0F0h ; 'ð'  ; is high nibble = 0Fh?
		jnz	short invalid_boot_record ; no,	invalid	boot record
		cmp	word ptr cs:[bx], 512 ;	[bx+EBPB.BYTESPERSECTOR]
		jnz	short invalid_boot_record ; invalidate non 512 byte sectors

check_2_ok:				; yes, mediadescriptor ok.
		mov	al, cs:[bx+2]	; now make sure	that the sectorspercluster is a	power of 2
					; [bx+EBPB.SECTORSPERCLUSTER]
					; get the sectorspercluster
		or	al, al		; is it	zero?
		jz	short invalid_boot_record ; yes, invalid boot record

ck_power_of_two:			; ...
		shr	al, 1		; shift	until first bit	emerges
		jnb	short ck_power_of_two
		jz	short valid_boot_record

invalid_boot_record:			; ...
		pop	ax
		pop	bx
		jmp	unknown		; jump to invalid boot record
					; unformatted or illegal media.
; ---------------------------------------------------------------------------

valid_boot_record:			; ...
		pop	ax
		pop	bx		; Signature found. Now check version.
		cmp	word ptr cs:[bx+8], '.2' ; '2.' (NASM syntax)
		jnz	short try5
		cmp	byte ptr cs:[bx+10], '0'
		jnz	short try5
		jmp	short copybpb
; ---------------------------------------------------------------------------

setret_brdg:				; ...
		jmp	setret
; ---------------------------------------------------------------------------

unknown3_0_j:				; ...
		jmp	unknown3_0	; legally formatted media,
					; although, content might be bad.
; ---------------------------------------------------------------------------

try5:					; ...
		call	cover_fdisk_bug
		cmp	word ptr cs:[bx+8], '.0' ; '0.' (NASM syntax)
		jnz	short no_os2
		mov	al, cs:[bx+7]
		sub	al, '1'
		and	al, 0FEh
		jz	short copybpb	; accept either	'1' or '2'
		jmp	unknown
; ---------------------------------------------------------------------------

no_os2:					; ...
		cmp	word ptr cs:[bx+8], '.3' ; '3.' (NASM syntax)
		jb	short unknown3_0_j ; must be 2.1 boot record.
					; do not trust it, but still legal.
		jnz	short copybpb	; honor	os2 boot record	or dos 4.0 version
		cmp	byte ptr cs:[bx+10], '1' ; if version >= 3.1, then o.k.
		jb	short unknown3_0_j

copybpb:				; ...
		cmp	cs:disksector+26h, 29h ; [disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
		jnz	short copybpb_fat ; conventional fat system
		cmp	cs:disksector+10h, 0
		jnz	short copybpb_fat ; a fat system.
		push	di		; non fat based	media.
		push	ds
		push	ds
		pop	es
		push	cs
		pop	ds
		mov	si, (offset disksector+0Bh) ; disksector+EXT_BOOT.BPB
		add	di, 6		; add di,BDS.BPB
		cmp	word ptr cs:[si+8], 0 ;	[cs:si+EBPB.TOTALSECTORS]
		jnz	short already_nonz
		cmp	word ptr cs:[si+21], 0 ; [cs:si+EBPB.BIGTOTALSECTORS]
		jnz	short already_nonz
		cmp	word ptr cs:[si+23], 0 ; [cs:si+EBPB.BIGTOTALSECTORS+2]
		jnz	short already_nonz
		mov	ax, [di+8]	; [di+BDS.totalsecs16]
		mov	cs:[si+8], ax	; [cs:si+EBPB.TOTALSECTORS]
		mov	ax, [di+21]	; [di+BDS.totalsecs32]
		mov	cs:[si+21], ax	; [cs:si+EBPB.BIGTOTALSECTORS]
		mov	ax, [di+23]	; [di+BDS.totalsecs32+2]
		mov	cs:[si+23], ax	; [cs:si+EBPB.BIGTOTALSECTORS+2]

already_nonz:				; ...
		mov	cx, 25		; A_BPB.size - 6 ; Use SMALL version!
		rep movsb
		pop	ds
		pop	di
		push	es
		push	ds
		pop	es
		push	cs
		pop	ds
		mov	bp, offset mov_media_ids
		push	cs		; simulate far call
		call	near ptr call_bios_code
		push	es
		pop	ds
		pop	es
		assume es:nothing
		jmp	goodret
; ---------------------------------------------------------------------------

copybpb_fat:				; ...
		mov	si, (offset disksector+0Bh) ; disksector+EXT_BOOT.BPB
					; cs:si	-> bpb in boot
		xor	dx, dx
		mov	ax, cs:[si+8]	; [cs:si+EBPB.TOTALSECTORS]
					; get totsec from boot sec
		or	ax, ax
		jnz	short copy_totsec ; if non zero, use that
		mov	ax, cs:[si+21]	; [cs:si+EBPB.BIGTOTALSECTORS]
					; get the big version (32 bit total sectors)
		mov	dx, cs:[si+23]	; [cs:si+EBPB.BIGTOTALSECTORS+2]
		mov	cx, dx		; see if it is a big zero
					; 10/12/2022
					; mov bx,ax
					; or bx,ax
		or	cx, ax
		jz	short totsec_already_set

copy_totsec:				; ...
		mov	[di+27], ax	; [di+BDS.totalsecs32]
					; make DPB match boot sec
		mov	[di+29], dx	; [di+BDS.totalsecs32+2]

totsec_already_set:			; ...
		mov	ax, [di+27]	; [di+BDS.totalsecs32]
		mov	dx, [di+29]	; [di+BDS.totalsecs32+2]
		mov	bx, cs:[si+3]	; [cs:si+EBPB.RESERVEDSECTORS]
					; get #reserved_sectors	from BPB
		mov	[di+9],	bx	; [di+BDS.resectors] ; update BDS field
		sub	ax, bx
		sbb	dx, 0		; update the count
		mov	bx, cs:[si+11]	; [cs:si+EBPB.SECTORSPERFAT] ; bx = sectors/fat
		mov	[di+17], bx	; [di+BDS.fatsecs] ; set in bds	bpb
		shl	bx, 1		; always 2 fats	(may be	1 fat!?)
					; 10/12/2022
					; (number of FATs optimization)
					; CL = number of FATs (2 or 1)
					; dec cx
					; shl bx, cl
		sub	ax, bx		; sub #	fat sectors
		sbb	dx, 0
		mov	bx, cs:[si+6]	; [cs:si+EBPB.ROOTENTRIES]
					; # root entries
		mov	[di+12], bx	; [di+BDS.direntries]
					; set in bds bpb
		mov	cl, 4
		shr	bx, cl		; div by 16 ents/sector
		sub	ax, bx		; sub #	dir sectors
		sbb	dx, 0		; dx:ax	now contains the # of data sectors
		xor	cx, cx
		mov	cl, cs:[si+2]	; [cs:si+EBPB.SECTORSPERCLUSTER]
					; sectors per cluster
		mov	[di+8],	cl	; [di+BDS.secperclus]
					; set in bios bpb
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	cx		; cx = sectors per cluster
		mov	cs:temp_h, ax	; [temp_h]:ax now contains the # clusters.
		pop	ax
		div	cx
		cmp	cs:temp_h, 0
		ja	short toobig_ret ; too big cluster number
		cmp	ax, 0FF6h	; 4096-10
					; is this 16-bit fat?
		jb	short copymediaid ; no,	small fat
		or	ds:fbigfat, 40h	; fbig ; 16 bit	fat

copymediaid:				; ...
		push	es
		push	ds
		pop	es
		assume es:nothing
		push	cs
		pop	ds
		mov	bp, offset mov_media_ids
		push	cs		; simulate far call
		call	near ptr call_bios_code
		push	es
		pop	ds
		pop	es
		assume es:nothing
		jmp	massage_bpb	; now final check for bpb info and return.
; ---------------------------------------------------------------------------

toobig_ret:				; ...
		or	cs:fbigfat, 80h
		jmp	goodret		; still	drive letter is	  assigned but useless.
					; to big for current pc	dos fat	file system
; ---------------------------------------------------------------------------

unknown:				; ...
		or	word ptr [di+35], 200h ; unformatted_media
					; Set unformatted media	flag.

unknown3_0:				; ...
		mov	dx, [di+29]	; skip setting unformatted_media bit
					; [di+BDS.totalsecs32+2]
		mov	ax, [di+27]	; [di+BDS.totalsecs32]
		mov	si, offset disktable2

scan:					; ...
		cmp	dx, cs:[si]
		jb	short gotparm
		ja	short scan_next
		cmp	ax, cs:[si+2]
		jbe	short gotparm

scan_next:				; ...
		add	si, 10		; 5*2
		jmp	short scan	; covers upto 512 mb media
; ---------------------------------------------------------------------------

gotparm:				; ...
		mov	cl, [si+8]	; fat size for fbigfat flag
		or	ds:fbigfat, cl
		mov	cx, cs:[si+4]	; ch = number of sectors per cluster
					; cl = log base	2 of ch
		mov	dx, cs:[si+6]	; dx = number of root dir entries
		mov	[di+12], dx	; [di+BDS.direntries]
					; save number of (root)	dir entries
		mov	dx, [di+29]	; [di+BDS.totalsecs32+2]
		mov	ax, [di+27]	; [di+BDS.totalsecs32]
		mov	[di+8],	ch	; [di+BDS.secperclus]
					; save sectors per cluster
		test	ds:fbigfat, 40h	; fbig
					; if (fbigfat)
		jnz	short dobig	; go to	dobig (16 bit fat)
		xor	bx, bx		; (12 bit fat)
		mov	bl, ch
		dec	bx
		add	bx, ax		; dx=0
		shr	bx, cl		; bx = 1+(bpb->maxsec+BDS.secperclus-1)/
		inc	bx		; BDS.secperclus
		and	bl, 0FEh	; bx &=	~1; (=number of	clusters)
		mov	si, bx
		shr	bx, 1
		add	bx, si
		add	bx, 511		; bx +=	511 + bx/2
		shr	bh, 1		; bh >>= 1; (=bx/512)
		mov	[di+17], bh	; [di+BDS.fatsecs]
					; save number of fat sectors
		jmp	short massage_bpb
; ---------------------------------------------------------------------------

dobig:					; ...
		mov	cl, 4		; 16 (2^4) directory entries per sector
		push	dx		; save total sectors (high)
		mov	dx, [di+12]	; [di+BDS.direntries]
		shr	dx, cl		; root dir sectors = BDS.direntries / 16;
		sub	ax, dx
		pop	dx
		sbb	dx, 0		; dx:ax	= total	sectors	- root dir sectors
		sub	ax, 1
		sbb	dx, 0		; dx:ax	= t - r	- d
					; total	secs - reserved	secs - root dir	secs
		mov	bl, 2
		mov	bh, [di+8]	; [di+BDS.secperclus]
					; bx = 256 * BDS.secperclus + 2
		add	ax, bx		; ax = t-r-d+256*spc+2
		adc	dx, 0
		sub	ax, 1		; ax = t-r-d+256*spc+1
		sbb	dx, 0
		div	bx		; BDS.fatsecs =
					; ceil((total-dir-res)/(256*BDS.secperclus+2))
		mov	[di+17], ax	; [di+BDS.fatsecs]
					; number of fat	sectors
		mov	bl, ds:fbigfat
		mov	[di+31], bl	; [di+BDS.fatsiz] ; fat	size flag
		push	ds
		push	ds
		pop	es
		assume es:nothing
		push	cs
		pop	ds
		mov	bp, offset clear_ids
		push	cs
		call	near ptr call_bios_code
		pop	ds

massage_bpb:				; ...
		mov	dx, [di+29]	; [di+BDS.totalsecs32+2]
		mov	ax, [di+27]	; [di+BDS.totalsecs32]
		cmp	dx, 0		; double word total sectors?
		ja	short goodret	; don't have to change it.
		cmp	word ptr [di+25], 0 ; [di+BDS.hiddensecs+2]
		ja	short goodret	; don't have to change it.
		add	ax, [di+23]	; [di+BDS.hiddensecs]
		jb	short goodret
		mov	ax, [di+27]	; [di+BDS.totalsecs32]
		mov	[di+14], ax	; [di+BDS.totalsecs16]
		mov	word ptr [di+27], 0 ; [di+BDS.totalsecs32]

goodret:				; ...
		mov	bl, ds:fbigfat
		mov	[di+31], bl	; [di+BDS.fatsiz]
					; set size of fat on media
		clc

ret_hard:				; ...
		pop	es
		assume es:nothing
		pop	ds
		pop	bx
		pop	di
		retn
sethard		endp


; =============== S U B	R O U T	I N E =======================================


cover_fdisk_bug	proc near		; ...
		push	ax
		push	dx
		push	si
		cmp	cs:disksector+26h, 29h ; disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
		jz	short cfb_retit	; if extended bpb, then	>= pc dos 4.00
		cmp	word ptr cs:[bx+7], '01' ; '10' (NASM syntax) ; os2 1.0 = ibm 10.0
		jnz	short cfb_chk_BPB_TOTALSECTORS
		cmp	byte ptr cs:[bx+0Ah], '0'
		jnz	short cfb_retit

cfb_chk_BPB_TOTALSECTORS:		; ...
		mov	si, (offset disksector+0Bh) ; disksector+EXT_BOOT.BPB
		cmp	word ptr cs:[si+8], 0 ;	[cs:si+EBPB.TOTALSECTORS]
					; just to make sure.
		jz	short cfb_retit
		mov	ax, cs:[si+8]	; [cs:si+EBPB.TOTALSECTORS]
		add	ax, cs:[si+11h]	; [cs:si+EBPB.HIDDENSECTORS]
		jnb	short cfb_retit
		jnz	short cfb_retit	;
					; if carry set and ax=0
		dec	word ptr cs:[si+8] ; 0 -> 0FFFFh
					; decrease BPB_TOTALSECTORS by 1
		sub	word ptr [di+1Bh], 1 ; [di+BDS.totalsecs32]
		sbb	word ptr [di+1Dh], 0 ; [di+BDS.totalsecs32+2]

cfb_retit:				; ...
		pop	si
		pop	dx
		pop	ax
		retn
cover_fdisk_bug	endp

; ---------------------------------------------------------------------------
word2		dw 2			; ...
word3		dw 3			; ...
word512		dw 512			; ...

; =============== S U B	R O U T	I N E =======================================


setdrvparms	proc near		; ...
		xor	bx, bx
		les	di, dword ptr ds:start_bds ; get first bds in list

next_bds:				; ...
		push	es
		push	di
		mov	bl, es:[di+34]	; [es:di+BDS.formfactor]
		cmp	bl, 5		; ffHardFile
		jnz	short nothardff
		xor	dx, dx
		mov	ax, es:[di+14]	; [es:di+BDS.totalsecs16]
		or	ax, ax
		jnz	short get_ccyl
		mov	dx, es:[di+29]	; [es:di+BDS.totalsecs32+2]
		mov	ax, es:[di+27]	; [es:di+BDS.totalsecs32]

get_ccyl:				; ...
		push	dx
		push	ax
		mov	ax, es:[di+21]	; [es:di+BDS.heads]
		mul	word ptr es:[di+19] ; [es:di+BDS.secpertrack]
					; assume sectors per cyl. < 64k.
		mov	cx, ax		; cx has # sectors per cylinder
		pop	ax
		pop	dx		; dx:ax	= total	sectors
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	cx
		mov	cs:temp_h, ax
		pop	ax
		div	cx		; div #sec by sec/cyl to get # cyl.
		or	dx, dx
		jz	short no_cyl_rnd ; came	out even
		inc	ax		; round	up

no_cyl_rnd:				; ...
		mov	es:[di+37], ax	; [es:di+BDS.cylinders]
		push	es
		pop	ds
		assume ds:nothing
		lea	si, [di+6]	; [di+BDS.bytespersec]
					; ds:si	-> bpb for hard	file
		jmp	short set_recbpb
; ---------------------------------------------------------------------------

nothardff:				; ...
		push	cs
		pop	ds
		assume ds:nothing
		cmp	cs:fakefloppydrv, 1
		jz	short go_to_next_bds
		cmp	bl, 7		; ffother
					; special case "other" type of medium
		jnz	short not_process_other

process_other:
		xor	dx, dx
		mov	ax, [di+37]	; [di+BDS.cylinders]
		mul	word ptr [di+54] ; [di+BDS.rheads]
		mul	word ptr [di+52] ; [di+BDS.rsecpertrack]
		mov	[di+47], ax	; [di+BDS.rtotalsecs16]
					; have the total number	of sectors
		dec	ax
		mov	dl, 1

again:					; ...
		cmp	ax, 0FF6h	; 4096-10
		jb	short _@@
		shr	ax, 1
		shl	dl, 1
		jmp	short again
; ---------------------------------------------------------------------------

_@@:					; ...
		cmp	dl, 1		; is it	a small	disk ?
		jz	short __@@	; yes, 224 root	entries	is enuf
		mov	word ptr [di+45], 240 ;	[di+BDS.rdirentries]

__@@:					; ...
		mov	[di+41], dl	; [di+BDS.rsecperclus]
		mul	cs:word3	; * 3
		div	cs:word2	; / 2
		xor	dx, dx
		div	cs:word512	; / 512
		inc	ax		; + 1

no_round_up:				; [di+BDS.rfatsecs]
		mov	[di+50], ax
		jmp	short go_to_next_bds
; ---------------------------------------------------------------------------

not_process_other:			; ...
		shl	bx, 1		; bx is	word index into	table of bpbs
		mov	si, offset bpbtable
		mov	si, [bx+si]	; get address of bpb

set_recbpb:				; ...
		lea	di, [di+39]	; [di+BDS.R_BPB]
					; es:di	-> recbpb
		mov	cx, 25		; bpbx.size
		rep movsb		; move (size bpbx) bytes

go_to_next_bds:				; ...
		pop	di
		pop	es		; restore pointer to bds
		les	di, es:[di]	; [es:di+BDS.link]
		cmp	di, -1		; -1
		jz	short got_end_of_bds_chain
		jmp	next_bds
; ---------------------------------------------------------------------------

got_end_of_bds_chain:			; ...
		retn
setdrvparms	endp


; =============== S U B	R O U T	I N E =======================================


print_init	proc near		; ...
		cbw
		mov	dx, ax		; AL = device number
		mov	ah, 1
		int	17h		; PRINTER - INITIALIZE
					; DX = printer port (0-3)
					; Return: AH = status
		retn
print_init	endp


; =============== S U B	R O U T	I N E =======================================


aux_init	proc near		; ...
		cbw
		mov	dx, ax
		mov	al, 0A3h	; RSINIT ; 2400,n,1,8 (msequ.inc)
		mov	ah, 0
		int	14h		; SERIAL I/O - INITIALIZE USART
					; AL = initializing parameters,	DX = port number (0-3)
					; Return: AH = RS-232 status code bits,	AL = modem status bits
		retn
aux_init	endp


; =============== S U B	R O U T	I N E =======================================


domini		proc near		; ...
		mov	dh, ds:hnum	; get number of	hardfiles
		cmp	dh, 0
		jz	short dominiret	; no hard file?	then exit.
		mov	dl, 80h		; start	with hardfile 80h

domini_loop:				; ...
		push	dx
		mov	ds:rom_minidisk_num, dl
		mov	ah, 8
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		inc	dh
		xor	ax, ax
		mov	al, dh
		mov	ds:mini_hdlim, ax ; # of heads
		and	cl, 3Fh
		mov	al, cl
		mov	ds:mini_seclim,	ax ; # of sectors/track
		push	es
		mov	dl, ds:rom_minidisk_num
		call	getboot		; read master boot record into
					; initbootsegment:bootbias
		jb	short domininext
		call	find_mini_partition

domininext:				; ...
		pop	es
		pop	dx
		inc	dl		; next hard file
		dec	dh
		jnz	short domini_loop

dominiret:				; ...
		retn
domini		endp


; =============== S U B	R O U T	I N E =======================================


find_mini_partition proc near		; ...
		add	bx, 1C2h	; bx ->	file system id

fmpnext:				; ...
		cmp	byte ptr es:[bx], 5 ; extended partition id. = 5
		jz	short fmpgot
		add	bx, 16
		cmp	bx, 402h	; 202h+bootbias
		jnz	short fmpnext
		jmp	short fmpret	; extended partition not found
; ---------------------------------------------------------------------------

fmpgot:					; ...
		call	dmax_check	; found	my partition.
					; check	for drvmax already 26
		jnb	short fmpret	; done if too many
		mov	di, ds:end_of_bdss ; get next free bds
		mov	word ptr [di+71], 1 ; [di+BDS.bdsm_ismini]
		or	word ptr [di+35], 1 ; or byte [di+BDS.flags],fNon_Removable
		mov	byte ptr [di+34], 5 ; mov byte [di+BDS.formfactor],ffHardFile
		mov	ds:fbigfat, 0	; assume 12 bit	fat.
		mov	ax, ds:mini_hdlim
		mov	[di+15h], ax	; [di+BDS.heads]
		mov	ax, ds:mini_seclim
		mov	[di+13h], ax	; [di+BDS.secpertrack]
		mov	al, ds:rom_minidisk_num
		mov	[di+4],	al	; [di+BDS.drivenum]
					; set physical number
		mov	al, ds:drvmax
		mov	[di+5],	al	; [di+BDS.drivelet]
					; set logical number
		cmp	word ptr es:[bx+10], 0
		ja	short fmpgot_cont
		cmp	word ptr es:[bx+8], 64 ; with current bpb,
					; only lower word is meaningful.
		jb	short fmpret	; should be bigger than	64 sectors at least

fmpgot_cont:				; ...
		sub	bx, 4		; let bx point to the start of the entry
		mov	dh, es:[bx+2]	; cylinder
		and	dh, 0C0h	; get higher bits of cyl
		rol	dh, 1
		rol	dh, 1
		mov	dl, es:[bx+3]	; cyl byte
		mov	[di+73], dx	; [di+BDS.bdsm_hidden_trks]
					; set hidden trks
		mov	cx, es:[bx+2]	; cylinder,cylinder/sector
		mov	dh, es:[bx+1]	; head
		mov	dl, ds:rom_minidisk_num
		mov	bx, 200h	; bootbias
		mov	ax, 201h
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		jb	short fmpret
		mov	bx, 3C2h	; 1C2h+bootbias
		push	es
		call	setmini		; install a mini disk.
					; bx value saved.
		pop	es
		jb	short fmpnextchain
		call	xinstall_bds	; -- install the bdsm into table

fmpnextchain:				; ...
		jmp	fmpnext		; let's find out if we have any chained partition
; ---------------------------------------------------------------------------

fmpret:					; ...
		retn
find_mini_partition endp


; =============== S U B	R O U T	I N E =======================================


setmini		proc near		; ...
		push	di
		push	bx
		push	ds
		push	es

setmini_1:				; ...
		cmp	byte ptr es:[bx], 1 ; FAT12 partition
		jz	short setmini_2
		cmp	byte ptr es:[bx], 4 ; FAT16 partition
		jz	short setmini_2
		cmp	byte ptr es:[bx], 6 ; FAT16 BIG	partition
		jz	short setmini_2
		add	bx, 16
		cmp	bx, 402h	; 202h+bootbias
		jnz	short setmini_1
		stc
		pop	es
		pop	ds
		pop	bx
		pop	di
		retn
; ---------------------------------------------------------------------------

setmini_2:				; ...
		jmp	set2
setmini		endp


; =============== S U B	R O U T	I N E =======================================


dmax_check	proc near		; ...
		cmp	ds:drvmax, 26	; checks for drvmax < 26
		jb	short dmax_ok	; return with carry if okay
		push	es
		mov	ax, 473h	; SYSINIT segment (SYSINITSEG)
		mov	es, ax
		assume es:nothing
		mov	es:toomanydrivesflag, 1	; SYSINITSEG:TOOMANYDRIVESFLAG
		pop	es
		assume es:nothing

dmax_ok:				; ...
		retn			; cf = 0 -> error (too many drives), cf	= 1 -> ok
dmax_check	endp


; =============== S U B	R O U T	I N E =======================================


xinstall_bds	proc near		; ...
		push	si
		push	bx
		mov	si, ds:start_bds ; get first bds

xinstall_bds_1:				; ...
		cmp	word ptr [si], 0FFFFh ;	-1 ; is	this the last one?
		jz	short xinstall_bds_2 ; skip ahead if so
		mov	si, [si]	; [si+BDS.link]	; chain	through	list
		jmp	short xinstall_bds_1
; ---------------------------------------------------------------------------

xinstall_bds_2:				; ...
		mov	[si], di	; [si+BDS.link]
		mov	word ptr [si+2], ds ; [si+BDS.link+2]
		mov	word ptr [di], 0FFFFh ;	[di+BDS.link],-1
					; make sure it is a null ptr.
		mov	word ptr [di+2], ds ; might as well plug segment
		lea	bx, [di+6]
		mov	si, ds:last_dskdrv_table
		mov	[si], bx
		add	ds:last_dskdrv_table, 2
		inc	ds:drvmax
		add	ds:end_of_bdss,	100 ; BDS.size = 100
		pop	bx
		pop	si
		retn
xinstall_bds	endp


; =============== S U B	R O U T	I N E =======================================


cmos_clock_read	proc near		; ...
		push	ax
		push	cx
		push	dx
		push	bp
		xor	bp, bp

loop_clock:				; ...
		xor	cx, cx
		xor	dx, dx
		mov	ah, 2
		int	1Ah		; CLOCK	- READ REAL TIME CLOCK (AT,XT286,CONV,PS)
					; Return: CH = hours in	BCD
					; CL = minutes in BCD
					; DH = seconds in BCD
		cmp	cx, 0
		jnz	short clock_present
		cmp	dx, 0
		jnz	short clock_present
		cmp	bp, 1		; read again after a slight delay, in case clock
		jz	short no_readdate ; was	at zero	setting.
		inc	bp		; only perform delay once.
		mov	cx, 4000h	; 16384

delay:					; ...
		loop	delay
		jmp	short loop_clock
; ---------------------------------------------------------------------------

clock_present:				; ...
		mov	cs:havecmoscloc, 1 ; set the flag for cmos clock
		call	cmosck		; reset	cmos clock rate	that may be
					; possibly destroyed by	cp dos and
					; post routine did not restore that.
		push	si
		call	read_real_date	; read real-time clock for date
		cli
		mov	ds:daycnt, si	; set system date
		sti
		pop	si

no_readdate:				; ...
		pop	bp
		pop	dx
		pop	cx
		pop	ax
		retn
cmos_clock_read	endp


; =============== S U B	R O U T	I N E =======================================


cmosck		proc near		; ...
		push	ax
		cmp	cs:model_byte, 0FCh ; Exit if not an AT	model
		jnz	short cmosck9
		cmp	cs:secondary_model_byte, 6 ; Is	it 06 for the industral	AT ?
		jz	short cmosck4	; Go reset CMOS	periodic rate if 06
		cmp	cs:secondary_model_byte, 4 ; Is	it 00, 01, 02, or 03 ?
		jnb	short cmosck9	; EXIT if problem fixed	by POST
					; Also,Secondary_model_byte = 0

cmosck4:				; ...
		mov	al, 8Ah		; cmos_reg_a|nmi
					; NMI disabled on return
		mov	ah, 26h		; 00100110b ; Set divider & rate selection
		call	cmos_write
		mov	al, 8Bh		; cmos_reg_b|nmi
					; NMI disabled on return
		call	cmos_read
		and	al, 7		; 00000111b ; clear SET,PIE,AIE,UIE,SQWE
		mov	ah, al
		mov	al, 0Bh		; cmos_reg_b ; NMI enabled on return
		call	cmos_write

cmosck9:				; ...
		pop	ax
		retn
cmosck		endp


; =============== S U B	R O U T	I N E =======================================


cmos_read	proc near		; ...
		pushf
		cli
		push	bx
		push	ax		; AL = cmos table address to be	read
		or	al, 80h
		out	70h, al		; CMOS Memory/RTC Index	Register: RTC Seconds
		nop			; (undocumented	delay needed)
		in	al, 71h		; CMOS Memory/RTC Data Register
		mov	bx, ax
		pop	ax
		and	al, 80h
		or	al, 0Fh
		out	70h, al		; CMOS Memory/RTC Index	Register: RTC Seconds
		nop
		in	al, 71h		; CMOS Memory/RTC Data Register
		mov	ax, bx
		pop	bx
		push	cs		; *place code segment in stack and
					; *handle popf for b- level 80286
		call	near ptr cmod_popf
		retn			; return with flags restored
cmos_read	endp


; =============== S U B	R O U T	I N E =======================================


cmod_popf	proc far		; ...
		iret			; popf for level b- parts
cmod_popf	endp			; return far and restore flags


; =============== S U B	R O U T	I N E =======================================


cmos_write	proc near		; ...
		pushf			; write	(ah) to	location (al)
		push	ax
		cli
		push	ax		; save user nmi	state
		or	al, 80h		; disable nmi for us
		out	70h, al		; CMOS Memory/RTC Index	Register: RTC Seconds
		nop
		mov	al, ah
		out	71h, al		; CMOS Memory/RTC Data Register
		pop	ax		; get user nmi
		and	al, 80h
		or	al, 0Fh
		out	70h, al		; CMOS Memory/RTC Index	Register: RTC Seconds
		nop
		in	al, 71h		; CMOS Memory/RTC Data Register
		pop	ax
		push	cs		; *place code segment in stack and
		call	near ptr cmod_popf ; *handle popf for b- level 80286
		retn
cmos_write	endp


; =============== S U B	R O U T	I N E =======================================


getclus		proc near		; ...
		push	cx		; bx = cluster to read
					; cx = sectors per cluster
					; es:di	= load location
		push	di
		mov	cs:doscnt, cx
		mov	ax, bx
		dec	ax
		dec	ax
		mul	cx		; convert to logical sector
					; dx:ax	= matching logical sector number
					; starting from	the data sector
		add	ax, cs:bios_l
		adc	dx, cs:bios_h	; dx:ax	= first	logical	sector to read

unpack:					; ...
		push	ds
		push	ax
		push	bx
		mov	si, cs:fatloc
		mov	ds, si
		mov	si, bx		; next cluster
		test	cs:fbigfat, 40h	; fbig
					; 16 bit fat?
		jnz	short unpack16	; yes

unpack12:
		shr	si, 1
		add	si, bx		; 12 bit fat. si=si/2
					; si = clus + clus/2
					; (si =	byte offset of the cluster in the FAT)
		push	dx
		xor	dx, dx
		call	get_fat_sector
		pop	dx
		mov	ax, [bx]	; save cluster number into ax
		jnz	short even_odd	; if not a splitted fat, check even-odd
		mov	al, [bx]	; (not needed!)	Erdogan	Tan - 2023
		mov	byte ptr cs:temp_cluster, al ; splitted	fat
		inc	si		; (next	byte)
		push	dx
		xor	dx, dx
		call	get_fat_sector
		pop	dx
		mov	al, byte ptr ds:0
		mov	byte ptr cs:temp_cluster+1, al
		mov	ax, cs:temp_cluster

even_odd:				; ...
		pop	bx		; restore old fat entry	value
		push	bx
		shr	bx, 1		; was it even or odd?
		jnb	short havclus	; it was even
		shr	ax, 1		; odd. massage fat value and keep
					; the highest 12 bits.
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1

havclus:				; ...
		mov	bx, ax		; now bx = new fat entry
		and	bx, 0FFFh	; keep low 12 bits
		jmp	short unpackx
; ---------------------------------------------------------------------------

unpack16:				; ...
		push	dx
		xor	dx, dx		; extend to 32 bit offset
		shl	si, 1		; cluster number * 2
		adc	dx, 0
		call	get_fat_sector
		pop	dx
		mov	bx, [bx]	; bx = new fat entry

unpackx:				; ...
		pop	si
		pop	ax
		pop	ds
		sub	si, bx		; previous - current (or current - new)
		cmp	si, -1		; one apart? (current =	previous+1)
		jnz	short getcl2
		add	cs:doscnt, cx	; consequental cluster read, +1	cluster	sectors
					; (cx =	sectors	per cluster)
		jmp	short unpack
; ---------------------------------------------------------------------------

getcl2:					; ...
		push	bx
		push	dx		; sector to read (high)
		push	ax		; sector to read (low)
		mov	ax, cs:drvfat	; get drive and	fat spec
		mov	cx, cs:doscnt
		pop	dx		; sector to read for diskrd (low)
		pop	cs:start_sec_h	; sector to read for diskrd (high)
		push	ds
		push	cs
		pop	ds
		push	cs		; simulate far call
		mov	bp, offset DISKRD ; BIOSCODE:8E5h ; 2C7h:8E5h
		call	near ptr call_bios_code
		pop	ds
		pop	bx
		pop	di
		mov	ax, cs:doscnt	; sector count
		xchg	ah, al
		shl	ax, 1		; ax = ax * 512	; byte count
		add	di, ax		; update load location
		pop	cx
		retn
getclus		endp


; =============== S U B	R O U T	I N E =======================================


get_fat_sector	proc near		; ...
		push	ax		; dx:si	= offset value (starting from fat entry	0)
					;	  of fat entry to find
		push	cx
		push	di
		push	si
		push	es
		push	ds
		mov	ax, si
		mov	cx, cs:md_sectorsize ; 512
		div	cx
		nop			; ax = sector number, dx = offset
		push	es
		push	ds
		push	di
		push	ax
		push	cs
		pop	ds
		mov	ax, cs:drvfat	; get drive # and FAT id
		mov	bp, offset SetDrive ; BIOSCODE:04D7h
		push	cs
		call	near ptr call_bios_code	; get bds for drive
		pop	ax		; (sector number -without reserved and hidden sectors-)
		add	ax, es:[di+9]	; [es:di+BDS.resectors]
					; add #reserved_sectors
		pop	di
		pop	ds
		pop	es
		cmp	ax, cs:last_fat_secnum
		jz	short gfs_split_chk ; don't need to read it again
		mov	cs:last_fat_secnum, ax ; sector	number
					; (in the partition, without hidden sectors)
		push	dx
		mov	cs:start_sec_h,	0 ; prepare to read the	fat sector
					; start_sec_h is always	0 for fat sector
		mov	dx, ax
		mov	cx, 1		; 1 sector read
		mov	ax, cs:drvfat
		push	ds
		pop	es
		assume es:nothing
		xor	di, di		; es:di	-> fatloc segment:0
		push	ds
		push	cs
		pop	ds
		push	cs		; simulate far call
		mov	bp, offset DISKRD ; BIOSCODE:08E5h ; 2C7h:8E5h
		call	near ptr call_bios_code
		pop	ds
		pop	dx
		mov	cx, cs:md_sectorsize ; 512

gfs_split_chk:				; ...
		dec	cx		; 511
		cmp	dx, cx		; if offset points to the last byte of this sector,
					; then splitted	entry.
		mov	bx, dx		; offset value from fatloc segment
		pop	ds
		pop	es
		assume es:nothing
		pop	si
		pop	di
		pop	cx
		pop	ax
		retn
get_fat_sector	endp

; ---------------------------------------------------------------------------
		db 14 dup(0)
BIOSDATA	ends

; ===========================================================================

; Segment type:	Regular
BIOSCODE	segment	byte public 'BIOSCODE' use16
		assume cs:BIOSCODE
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
BCode_start	db 30h dup(0)
Bios_Data_Word	dw 70h			; ...
					; BIOSDATA segment
; ---------------------------------------------------------------------------

_seg_reinit:				; ...
		mov	es, cs:Bios_Data_Word
		assume es:nothing
		mov	di, offset cdev_2 ; (offset cdev+2)
		mov	cx, 4

_seg_reinit_1:				; ...
		stosw			; ax = new code	(BIOSCODE) segment value
		inc	di
		inc	di
		loop	_seg_reinit_1
		retf
; ---------------------------------------------------------------------------

chardev_entry:				; ...
		push	si
		push	ax
		push	cx
		push	dx
		push	di
		push	bp
		push	ds
		push	es
		push	bx
		mov	bp, sp
		mov	si, [bp+18]	; get return address (dispatch table)
		mov	ds, cs:Bios_Data_Word ;	BIOSDATA segment
		assume ds:nothing
		mov	ax, [si+2]	; get the device number	if present
		mov	byte ptr ds:auxnum, al
		mov	ds:printdev, ah
		mov	si, [si]	; point	to the device dispatch table
		les	bx, ds:ptrsav	; get pointer to i/o packet
		assume es:nothing
		mov	al, es:[bx+1]	; [es:bx+unit] ; al = unit code
		mov	ah, es:[bx+13]	; [es:bx+media]	; ah = media descrip
		mov	cx, es:[bx+18]	; [es:bx+count]	; cx = count
		mov	dx, es:[bx+20]	; [es:bx+start]	; dx = start sector
		cmp	si, offset DSKTBL ; BIOSCODE:4A2h
		jnz	short no_sector32_mapping
		mov	ds:start_sec_h,	0
		cmp	dx, 0FFFFh
		jnz	short no_sector32_mapping
		mov	dx, es:[bx+28]	; [es:bx+start_h]
					; 32 bit dsk req
		mov	ds:start_sec_h,	dx ; start_sec_h = packet.start_h
		mov	dx, es:[bx+26]	; [es:bx+start_l]
					; dx = packet.start_l

no_sector32_mapping:			; ...
		xchg	ax, di
		mov	al, es:[bx+2]	; [es:bx+cmd]
		cmp	al, cs:[si]
		jnb	short command_error
		cbw			; note that al <= 15 means ok
		shl	ax, 1
		add	si, ax
		xchg	ax, di
		les	di, es:[bx+14]	; [es:bx+trans]
		cld
		call	word ptr cs:[si+1]
		jb	short already_got_ah_status
		mov	ah, 1

already_got_ah_status:			; ...
		mov	ds, cs:Bios_Data_Word
		lds	bx, ds:ptrsav
		assume ds:nothing
		mov	[bx+3],	ax	; [bx+status]
					; mark operation complete
		pop	bx
		pop	es
		pop	ds
		pop	bp
		pop	di
		pop	dx
		pop	cx
		pop	ax
		pop	si
		add	sp, 2		; get rid of fake return address

bc_retf:				; ...
		retf
; ---------------------------------------------------------------------------

command_error:				; ...
		call	bc_cmderr
		jmp	short already_got_ah_status
; ---------------------------------------------------------------------------
		dw 0
_offset_D0h	db 5 dup(0)		; 5 bytes from 0:C0h will be copied onto here
					; which	is the CP/M call 5 entry point

; =============== S U B	R O U T	I N E =======================================


bc_cmderr	proc near		; ...
		mov	al, 3		; unknown command error

bc_err_cnt:				; ...
		les	bx, ds:ptrsav
		sub	es:[bx+18], cx
		mov	ah, 81h		; mark error return
		stc			; indicate abnormal end
		retn
bc_cmderr	endp

; ---------------------------------------------------------------------------
		db 0
con_table	db 11			; ((con_table_end - con_table)-1)/2 = 11
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_cmderr
		dw offset con_read
		dw offset con_rdnd
		dw offset bc_exvec
		dw offset con_flush
		dw offset con_writ
		dw offset con_writ
		dw offset bc_exvec
prn_table	db 26			; ((prn_table_end - prn_table)-1)/2 = 26
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_cmderr
		dw offset prn_input
		dw offset z_bus_exit
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset prn_writ
		dw offset prn_writ
		dw offset prn_stat
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset prn_tilbusy
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset prn_genioctl
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset prn_ioctl_query
aux_table	db 11			; ((aux_table_end - aux_table)-1)/2 = 11
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_cmderr
		dw offset aux_read
		dw offset aux_rdnd
		dw offset bc_exvec
		dw offset aux_flsh
		dw offset aux_writ
		dw offset aux_writ
		dw offset aux_wrst
tim_table	db 10			; ((tim_table_end - tim_table)-1)/2 = 10
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset bc_cmderr
		dw offset tim_read
		dw offset z_bus_exit
		dw offset bc_exvec
		dw offset bc_exvec
		dw offset tim_writ
		dw offset tim_writ

; =============== S U B	R O U T	I N E =======================================


con_read	proc near		; ...
		jcxz	short con_exit	; read cx bytes	from keyboard into buffer

con_loop:				; ...
		call	chrin		; get char in al
		stosb			; store	char at	es:di
		loop	con_loop

con_exit:				; ...
		clc
		retn
con_read	endp


; =============== S U B	R O U T	I N E =======================================


chrin		proc near		; ...
		mov	ah, ds:keyrd_func ; set	by msinit. 0 or	10h
		xor	al, al
		xchg	al, ds:altah	; get character	& zero altah
		or	al, al
		jnz	short keyret
		int	16h		; KEYBOARD -

alt10:
		or	ax, ax
		jz	short chrin
		cmp	ax, 7200h	; check	for ctrl-prtsc
		jnz	short alt_ext_chk
		mov	al, 10h
		jmp	short keyret
; ---------------------------------------------------------------------------

alt_ext_chk:				; ...
		cmp	ds:keyrd_func, 0
		jz	short not_ext
		cmp	al, 0E0h
		jnz	short not_ext
		or	ah, ah
		jz	short keyret
		xor	al, al
		jmp	short alt_save
; ---------------------------------------------------------------------------

not_ext:				; ...
		or	al, al		; special case?
		jnz	short keyret

alt_save:				; ...
		mov	ds:altah, ah	; store	special	key

keyret:					; ...
		retn
chrin		endp


; =============== S U B	R O U T	I N E =======================================


con_rdnd	proc near		; ...
		mov	al, ds:altah	; keyboard non destructive read, no wait
		or	al, al
		jnz	short rdexit
		mov	ah, ds:keysts_func
		int	16h		; KEYBOARD -
		jnz	short gotchr
		cmp	ds:fhavek09, 0
		jz	short z_bus_exit
		les	bx, ds:ptrsav
		test	word ptr es:[bx+3], 400h ; [es:bx+status]
		jz	short z_bus_exit
		mov	ax, 4100h
		xor	bl, bl
		int	15h		; SYSTEM - WAIT	ON EXTERNAL EVENT (CONVERTIBLE)
					; AL = condition type, BH = condition compare or mask value
					; BL = timeout value times 55 milliseconds, 00h	means no timeout
					; DX = I/O port	address	if AL bit 4 set

z_bus_exit:				; ...
		stc
		mov	ah, 3		; indicate busy	status
		retn
; ---------------------------------------------------------------------------

gotchr:					; ...
		or	ax, ax
		jnz	short notbrk	; check	for null after break
		mov	ah, ds:keyrd_func ; issue keyboard read	function
		int	16h		; KEYBOARD -
		jmp	short con_rdnd	; get a	real status
; ---------------------------------------------------------------------------

notbrk:					; ...
		cmp	ax, 7200h	; check	for ctrl-prtsc
		jnz	short rd_ext_chk
		mov	al, 10h		; ('P' & 1Fh) ; return control p
		jmp	short rdexit
; ---------------------------------------------------------------------------

rd_ext_chk:				; ...
		cmp	ds:keyrd_func, 0 ; extended keyboard function?
		jz	short rdexit
		cmp	al, 0E0h	; extended key value or	greek alpha?
		jnz	short rdexit
		cmp	ah, 0		; scan code exist?
		jz	short rdexit	; yes. greek alpha char.
		mov	al, 0		; no. extended key stroke.
					; change it for	compatibility

rdexit:					; ...
		les	bx, ds:ptrsav
		mov	es:[bx+13], al	; [es:bx+media]
					;  return keyboard character here

bc_exvec:				; ...
		clc			; indicate normal termination
		retn
con_rdnd	endp


; =============== S U B	R O U T	I N E =======================================


con_writ	proc near		; ...
		jcxz	short bc_exvec	; console write	routine

con_lp:					; ...
		mov	al, es:[di]
		inc	di
		int	29h		; DOS 2+ internal - FAST PUTCHAR
					; AL = character to display
		loop	con_lp
con_writ	endp

; START	OF FUNCTION CHUNK FOR con_flush

cc_ret:					; ...
		clc
		retn
; END OF FUNCTION CHUNK	FOR con_flush

; =============== S U B	R O U T	I N E =======================================


con_flush	proc near		; ...

; FUNCTION CHUNK AT 0207 SIZE 00000002 BYTES

		mov	ds:altah, 0	; flush	out keyboard queue
					; clear	out holding buffer

flloop:					; ...
		mov	ah, 1		; while	(charavail()) charread();
		int	16h		; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
					; Return: ZF clear if character	in buffer
					; AH = scan code, AL = character
					; ZF set if no character in buffer
		jz	short cc_ret
		xor	ah, ah
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character
		jmp	short flloop
con_flush	endp

; ---------------------------------------------------------------------------

prn_input:				; ...
		call	bc_err_cnt	; reset	count to zero
					; (sub reqpkt.count,cx)
		clc			; but return with carry	  reset	for no error
		retn
; ---------------------------------------------------------------------------

prn_writ:				; ...
		jcxz	short prn_done	; write	cx bytes from es:di to printer device

prn_loop:				; ...
		mov	bx, 2		; retry	count

prn_out:				; ...
		call	prnstat		; get status
		jnz	short TestPrnError
		mov	al, es:[di]	; get character	to print
		xor	ah, ah
		call	prnop		; print	to printer
		jz	short prn_con	; no error - continue
		cmp	ah, 0FFh	; MODE_CTRLBRK
		jnz	short _prnwf
		mov	al, 0Ch		; error_I24_gen_failure
		mov	ds:altah, 0
		jmp	short pmessg
; ---------------------------------------------------------------------------

_prnwf:					; ...
		test	ah, 1		; timeoutstatus
		jz	short prn_con

TestPrnError:				; ...
		dec	bx		; retry	until count is exhausted
		jnz	short prn_out

pmessg:					; ...
		jmp	bc_err_cnt
; ---------------------------------------------------------------------------

prn_con:				; ...
		inc	di		; point	to next	char and continue
		loop	prn_loop

prn_done:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

prn_stat:				; ...
		call	prnstat		; device in dx
		jnz	short pmessg
		test	ah, 80h		; notbusystatus
		jnz	short prn_done
		jmp	z_bus_exit

; =============== S U B	R O U T	I N E =======================================


prnstat		proc near		; ...
		mov	ah, 2		; PRINTER - GET	STATUS
prnstat		endp			; set command for get status
					; DX = printer port (0-3)
					; Return: AH = status

; =============== S U B	R O U T	I N E =======================================


prnop		proc near		; ...
		mov	dx, ds:auxnum	; get printer number
		int	17h		; PRINTER - GET	STATUS
					; DX = printer port (0-3)
					; Return: AH = status
		push	ax
		and	ah, 30h
		cmp	ah, 30h		; noprinter error
		pop	ax
		jnz	short NextTest
		and	ah, 0DFh	; ~nopaperstatus
		or	ah, 8		; ioerrstatus

NextTest:				; ...
		test	ah, 28h		; (ioerrstatus+nopaperstatus)
					; i/o error?
		jz	short checknotready ; no, try not ready
		mov	al, 9		; error_I24_out_of_paper
					; first, assume	out of paper
		test	ah, 20h		; out of paper set?
		jnz	short ret1	; yes, error is	set
		inc	al		; return al=10 (i/o error)

ret1:					; ...
		retn
; ---------------------------------------------------------------------------

checknotready:				; ...
		mov	al, 2		; assume not-ready
		test	ah, 1
		retn
prnop		endp

; ---------------------------------------------------------------------------

prn_tilbusy:				; ...
		mov	si, di

prn_tilbloop:				; ...
		push	cx
		push	bx
		xor	bh, bh
		mov	bl, ds:printdev
		shl	bx, 1
		mov	cx, ds:wait_count[bx] ;	wait count times to come ready
		pop	bx

prn_getstat:				; ...
		call	prnstat		; get status
		jnz	short prn_bperr	; error
		test	ah, 80h		; ready	yet?
		loope	prn_getstat	; no, go for more
		pop	cx		; get original count
		jz	short prn_berr	; still	not ready => done
		lods	byte ptr es:[si]
		xor	ah, ah
		call	prnop
		jnz	short prn_berr
		loop	prn_tilbloop
		clc			; normal no-error return
		retn
; ---------------------------------------------------------------------------

prn_bperr:				; ...
		pop	cx

prn_berr:				; ...
		jmp	bc_err_cnt
; ---------------------------------------------------------------------------

prn_genioctl:				; ...
		les	di, ds:ptrsav
		cmp	byte ptr es:[di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
					; ioc_pc
		jz	short prnfunc_ok

prnfuncerr:				; ...
		jmp	bc_cmderr
; ---------------------------------------------------------------------------

prnfunc_ok:				; ...
		mov	al, es:[di+14]	; [es:di+IOCTL_REQ.MINORFUNCTION]
		les	di, es:[di+19]	; [es:di+IOCTL_REQ.GENERICIOCTL_PACKET]
		xor	bh, bh
		mov	bl, ds:printdev
		shl	bx, 1
		mov	cx, ds:wait_count[bx] ;	pull out retry count for device
		cmp	al, 65h		; get_retry_count
		jz	short prngetcount
		cmp	al, 45h		; set_retry_count
		jnz	short prnfuncerr
		mov	cx, es:[di]

prngetcount:				; ...
		mov	ds:wait_count[bx], cx
		mov	es:[di], cx	; [es:di+A_RETRYCOUNT.RC_COUNT]
					; return current retry count
		clc
		retn
; ---------------------------------------------------------------------------

prn_ioctl_query:			; ...
		les	di, ds:ptrsav
		cmp	byte ptr es:[di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
					; ioc_pc
		jnz	short prn_query_err
		mov	al, es:[di+14]	; [es:di+IOCTL_REQ.MINORFUNCTION]
		cmp	al, 65h		; GET_RETRY_COUNT
		jz	short IOCtlSupported
		cmp	al, 45h		; SET_RETRY_COUNT
		jnz	short prn_query_err

IOCtlSupported:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

prn_query_err:				; ...
		stc
		jmp	bc_cmderr
; ---------------------------------------------------------------------------

aux_read:				; ...
		jcxz	short exvec2
		call	getbx		; put address of auxbuf	in bx
		xor	al, al
		xchg	al, [bx]
		or	al, al
		jnz	short aux2

aux1:					; ...
		call	auxin		; get character	from port
					; won't return if error

aux2:					; ...
		stosb
		loop	aux1		; if more characters, go around	again

exvec2:					; ...
		clc			; all done, successful exit
		retn

; =============== S U B	R O U T	I N E =======================================


auxin		proc near		; ...
		mov	ah, 2
		call	auxop
		test	ah, 0Eh		; flag_frame|flag_parity|flag_overrun
		jnz	short arbad
		retn
; ---------------------------------------------------------------------------

arbad:					; ...
		pop	ax
		xor	al, al
		or	al, 0B0h	; flag_rec_sig|flag_dsr|flag_cts
		jmp	bc_err_cnt
auxin		endp

; ---------------------------------------------------------------------------

aux_rdnd:				; ...
		call	getbx		; non-destructive aux port read
		mov	al, [bx]
		or	al, al
		jnz	short auxrdx	; if al	is non-zero (char in buffer)
					; then return character
		call	auxstat		; if not, get status of	  aux device
		test	ah, 1		; flag_data_ready - test data ready
		jz	short auxbus	; then device is busy (not ready)
		test	al, 20h		; flag_dsr - test data set ready
		jz	short auxbus	; then device is busy (not ready)
		call	auxin		; else aux is ready, get character
		mov	[bx], al

auxrdx:					; ...
		jmp	rdexit		; return busy status
; ---------------------------------------------------------------------------

auxbus:					; ...
		jmp	z_bus_exit
; ---------------------------------------------------------------------------

aux_wrst:				; ...
		call	auxstat		; return aux port write	status
		test	al, 20h		; test data set	ready
		jz	short auxbus	; then device is busy (not ready)
		test	ah, 20h		; flag_tranhol_emp - test transmit hold	reg
		jz	short auxbus	; then device is busy (not ready)
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


auxstat		proc near		; ...
		mov	ah, 3		; auxfunc_status
auxstat		endp


; =============== S U B	R O U T	I N E =======================================


auxop		proc near		; ...
		mov	dx, ds:auxnum	; ah=function code
					; 0=init, 1=send, 2=receive, 3=status
					; get port number
		int	14h		; SERIAL I/O - GET USART STATUS
					; DX = port number (0-3)
					; Return: AX = port status code
		retn
auxop		endp

; ---------------------------------------------------------------------------

aux_flsh:				; ...
		call	getbx		; flush	aux input buffer
					; get bx to point to auxbuf
					; zero out buffer
					; all done, successful return
		mov	byte ptr [bx], 0
		clc
		retn
; ---------------------------------------------------------------------------

aux_writ:				; ...
		jcxz	short exvec2	; write	to aux device (if cx > 0)

aux_loop:				; ...
		mov	al, es:[di]	; get character	to be written
		inc	di		; move di pointer to next character
		mov	ah, 1		; auxfunc_send - indicates a write
		call	auxop		; send character over aux port
		test	ah, 80h		; check	for error
		jz	short awok	; then no error
		mov	al, 10		; else indicate	write fault
		jmp	bc_err_cnt	; call error routines
; ---------------------------------------------------------------------------

awok:					; ...
		loop	aux_loop	; return bx -> single byte input buffer
					; for selected aux port	([auxnum])
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


getbx		proc near		; ...
		mov	bx, ds:auxnum
		add	bx, offset auxbuf
		retn
getbx		endp

; ---------------------------------------------------------------------------

time_to_ticks:				; ...
		mov	al, 60		; convert time to ticks
					; input	: time in cx and dx
					; output: ticks	returned in cx:dx
					;
					; the clock ticks at the rate of:
					; 1193180/65536	ticks/second
					; (about 18.2 ticks per	second)
		mul	ch		; hours	to minutes ///
					; first	convert	from hour,min,sec,hund.	to
					; total	number of 100th	of seconds
		mov	ch, 0
		add	ax, cx		; total	minutes
		mov	cx, 6000	; 60*100
		mov	bx, dx
		mul	cx		; convert to 1/100 sec
		mov	cx, ax
		mov	al, 100
		mul	bh		; convert seconds to 1/100 sec
		add	cx, ax		; combine seconds with hours and min
		adc	dx, 0
		mov	bh, 0
		add	cx, bx		; combine 1/100	sec
		adc	dx, 0		; dx:cx	is time	in 1/100 sec
		xchg	ax, dx
		xchg	ax, cx		; now time is in cx:ax
		mov	bx, 59659
		mul	bx		; multiply low half
		xchg	dx, cx
		xchg	ax, dx		; cx->ax, ax->dx, dx->cx
		mul	bx		; multiply high	half
		add	ax, cx		; combine overlapping products
		adc	dx, 0
		xchg	ax, dx		; ax:dx=time*59659
		mov	bx, 5
		div	bl		; divide high half by 5
		mov	cl, al
		mov	ch, 0
		mov	al, ah		; remainder of divide-by-5
		cbw
		xchg	ax, dx		; use it to extend low half
		div	bx		; divide low half by 5
		mov	dx, ax		; cx:dx	is now number of ticks in time
		retf
; ---------------------------------------------------------------------------

tim_writ:				; ...
		mov	ax, es:[di]	; sets the current time
		push	ax		; daycnt. we need to set this at the very
					; end to avoid tick windows
		cmp	ds:havecmoscloc, 0
		jz	short no_cmos_1
		mov	al, es:[di+3]	; get binary hours
					; convert to bcd
		call	dword ptr ds:bintobcd
		mov	ch, al		; ch = bcd hours
		mov	al, es:[di+2]	; get binary minutes
		call	dword ptr ds:bintobcd
		mov	cl, al		; cl = bcd minutes
		mov	al, es:[di+5]	; get binary seconds
		call	dword ptr ds:bintobcd
		mov	dh, al		; dh = bcd seconds
		mov	dl, 0		; dl = 0 (st) or 1 (dst)
		cli
		mov	ah, 3
		int	1Ah		; CLOCK	- SET REAL TIME	CLOCK (AT,XT286,CONV,PS)
					; CH = hours in	BCD, CL	= minutes in BCD
					;  DH =	seconds	in BCD,DL = 01h	if daylight savings, 00h if standard time
					; Return: CMOS clock set
		sti

no_cmos_1:				; ...
		mov	cx, es:[di+2]
		mov	dx, es:[di+4]
		call	dword ptr ds:ttticks ; convert time to ticks
					; cx:dx	now has	time in	ticks
		cli
		mov	ah, 1
		int	1Ah		; CLOCK	- SET TIME OF DAY
					; CX:DX	= clock	count
					; Return: time of day set
		pop	ds:daycnt
		sti
		cmp	ds:havecmoscloc, 0
		jz	short no_cmos_2
		call	dword ptr ds:daycnttoday
		cli
		mov	ah, 5
		int	1Ah		; CLOCK	- SET DATE IN REAL TIME	CLOCK (AT,XT286,CONV,PS)
					; DL = day in BCD, DH =	month in BCD, CL = year	in BCD
					; CH = century (19h or 20h)
					; Return: CMOS clock set
		sti

no_cmos_2:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

tim_read:				; ...
		call	GetTickCnt	; gettime reads	date and time
					;
					; 65,536 seconds = 1,193,180 ticks
					;
					; time in 100th	of seconds
					;    = ticks from clock	 * 65,536 * 100	/ 1,193,180
					;    = ticks from clock	* 5 * 65,536 / 59,659
		mov	si, ds:daycnt
		mov	ax, cx
		mov	bx, dx		; start	with ticks in cx:dx
					; multiply by 5
		shl	dx, 1
		rcl	cx, 1
		shl	dx, 1
		rcl	cx, 1
		add	dx, bx
		adc	ax, cx
		xchg	ax, dx
		mov	cx, 59659	; multiply by 65536 and	divide by 59659
		div	cx		; dx has remainder
					; ax has high word of final quotient
		mov	bx, ax		; put high word	in safe	place
		xor	ax, ax		; multiply by 65536
		div	cx		; bx:ax	has time in 100th of seconds
		mov	dx, bx
		mov	cx, 200		; division by 200 is necessary
					; to ensure no overflow--max result
					; is number of seconds in a day/2 = 43200.
		div	cx
		cmp	dl, 100		; remainder over 100?
		jb	short noadj
		sub	dl, 100		; keep 1/100's less than 100

noadj:					; ...
		cmc			; if we	subtracted 100,	carry is now set
		mov	bl, dl		; save 1/100's
		rcl	ax, 1		; multiply by two
		mov	dl, 0
		rcl	dx, 1
		mov	cx, 60		; divide out seconds
		div	cx
		mov	bh, dl		; save the seconds
		div	cl		; break	into hours and minutes
		xchg	al, ah
		push	ax
		mov	ax, si
		stosw
		pop	ax		; al = hours, ah = minutes
		stosw
		mov	ax, bx
		stosw
		clc			; [es:di] = count of days since	1-1-80
					;    [es:di+2] = hours
					;    [es:di+3] = minutes
					;    [es:di+4] = seconds
					;    [es:di+5] = hundredths of seconds
		retn

; =============== S U B	R O U T	I N E =======================================


GetTickCnt	proc near		; ...
		xor	ah, ah		; Returns the tick count in cx:dx
					; Takes	care of	DayCnt in case of rollover
					; if ( rollover	) {
					;     if ( t_switch )
					;	     daycnt++ ;
					;     else
					;	     daycnt += rollover	;
					;     }
		int	1Ah		; CLOCK	- GET TIME OF DAY
					; Return: CX:DX	= clock	count
					; AL = 00h if clock was	read or	written	(via AH=0,1) since the previous
					; midnight
					; Otherwise, AL	> 0
		cmp	ds:t_switch, 0	; use old method ? (>0 is yes)
		jnz	short inc_case	; old method assumes that Int 1Ah returns rollover flag
		xor	ah, ah		; new method assumes that Int 1Ah returns roll over count
					; and not flag
		add	ds:daycnt, ax
		retn
; ---------------------------------------------------------------------------

inc_case:				; ...
		or	al, al
		jz	short no_rollover
		inc	ds:daycnt

no_rollover:				; ...
		retn
GetTickCnt	endp

; ---------------------------------------------------------------------------
		db 0
DSKTBL		db 26			; ...
		dw offset dsk_init
		dw offset media_chk
		dw offset get_bpb
		dw offset bc_cmderr
		dw offset dsk_read
		dw offset x_bus_exit
		dw offset ret_carry_clear
		dw offset ret_carry_clear
		dw offset dsk_writ
		dw offset dsk_writv
		dw offset ret_carry_clear
		dw offset ret_carry_clear
		dw offset bc_cmderr
		dw offset dsk_open
		dw offset dsk_close
		dw offset dsk_rem
		dw offset ret_carry_clear
		dw offset ret_carry_clear
		dw offset ret_carry_clear
		dw offset Do_Generic_IOCtl
		dw offset ret_carry_clear
		dw offset ret_carry_clear
		dw offset ret_carry_clear
		dw offset ioctl_getown
		dw offset ioctl_setown
		dw offset ioctl_support_query

; =============== S U B	R O U T	I N E =======================================


SetDrive	proc near		; ...
		les	di, dword ptr ds:start_bds ; Point es:di to first bds

X_Scan_Loop:				; ...
		cmp	es:[di+5], al	; logical drive	number (BDS.drivelet)
		jz	short X_SetDrv
		les	di, es:[di]	; [es:di+BDS.link] ; Go	to next	bds
		cmp	di, 0FFFFh
		jnz	short X_Scan_Loop
		stc

X_SetDrv:				; ...
		retn
SetDrive	endp

; ---------------------------------------------------------------------------

media_chk:				; ...
		call	SetDrive
		mov	si, 1
		test	byte ptr es:[di+24h], 1	; [es:di+BDS.flags+1], fchanged_by_format
		jz	short WeAreNotFakingIt
		and	word ptr es:[di+23h], 0FEFFh ; [es:di+BDS.flags],
					; ~fchanged_by_format ;	reset flag
		mov	ds:tim_drv, 0FFh ; -1
					; Ensure that we ask the rom if	media has changed
		test	byte ptr es:[di+23h], 1
		jz	short WeHaveaFloppy
		mov	si, 0FFFFh	; -1
		jmp	short Media_Done
; ---------------------------------------------------------------------------

WeAreNotFakingIt:			; ...
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags], fnon_removable
		jnz	short Media_Done

WeHaveaFloppy:				; ...
		xor	si, si		; 0 ; Presume "I don't know"
		cmp	ds:fhave96, 0	; Do we	have changeline	support?
		jz	short mChk_NoChangeLine	; Brif not
		call	MediaCheck	; Call into removable routine
		jb	short Err_Exitj
		call	HasChange
		jnz	short Media_Done

mChk_NoChangeLine:			; ...
		mov	si, 1		; Presume no change
		mov	al, ds:tim_drv	; Last drive accessed

loc_2AEF:				; [es:di+BDS.drivenum]
		cmp	al, es:[di+4]	; Is drive of last access the same?
		jnz	short Media_Unk	; No, then "i don't know"
		call	Check_Time_Of_Access
		jmp	short Media_Done
; ---------------------------------------------------------------------------

Media_Unk:				; ...
		dec	si		; 0 ; Return "I	don't know"

Media_Done:				; ...
		push	es
		les	bx, ds:ptrsav
		mov	es:[bx+14], si	; [es:bx+trans]
		pop	es
		or	si, si
		jns	short ret_carry_clear ;	volidok
		cmp	ds:fhave96, 0
		jz	short mChk1_NoChangeLine
		call	Media_Set_vId

mChk1_NoChangeLine:			; ...
		mov	ds:tim_drv, -1

ret_carry_clear:			; ...
		clc			; volidok
		retn
; ---------------------------------------------------------------------------

Err_Exitj:				; ...
		call	maperror	; guaranteed to	set carry
; START	OF FUNCTION CHUNK FOR get_bpb

ret81:					; ...
		mov	ah, 81h		; return error status
		retn			; return with carry set
; END OF FUNCTION CHUNK	FOR get_bpb

; =============== S U B	R O U T	I N E =======================================


Check_Time_Of_Access proc near		; ...
		mov	si, 1		; presume no change
		call	GetTickCnt	; cx:dx	is the elapsed time
		mov	ax, es:[di+47h]	; [es:di+BDS.tim_lo]
					; get stored time
		sub	dx, ax
		mov	ax, es:[di+49h]	; [es:di+BDS.tim_hi]
		sbb	cx, ax
		jnz	short timecheck_unk ; cx<>0 => >1 hour
		or	dx, dx		; time must pass
		jnz	short timepassed ; yes,	examine	max value
		inc	ds:accesscount
		cmp	ds:accesscount,	5
		jb	short timecheck_ret ; if count is less than threshold, ok
		dec	ds:accesscount
		jmp	short timecheck_unk
; ---------------------------------------------------------------------------

timepassed:				; ...
		cmp	dx, 36		; 18*2 ; 18.2 tics per second.
					; min elapsed time? (2 seconds)
		jbe	short timecheck_ret

timecheck_unk:				; ...
		dec	si		; presume i don't know

timecheck_ret:				; ...
		retn
Check_Time_Of_Access endp

; ---------------------------------------------------------------------------

Err_Exitj2:
		jmp	short Err_Exitj

; =============== S U B	R O U T	I N E =======================================


get_bpb		proc near		; ...

; FUNCTION CHUNK AT 055D SIZE 00000003 BYTES

		mov	ah, es:[di]	; Build	a valid	bpb for	the disk in the	drive.
					; get fat id byte read by dos
		call	SetDrive
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags], fnon_removable
		jnz	short already_gotbpb ; no need to build	for fixed disks
		call	clear_ids
		mov	ds:set_id_flag,	1 ; indicate to	set system id in bds
		call	GetBp		; build	a bpb if necessary
		jb	short ret81
		cmp	ds:set_id_flag,	2 ; already, volume_label set from boot
		mov	ds:set_id_flag,	0 ; record to bds table?
		jz	short already_gotbpb ; do not set it again from	root dir
					; otherwise, conventional boot record
		cmp	ds:fhave96, 0	; do we	have changeline	support?
		jz	short already_gotbpb ; brif not
		call	set_volume_id

already_gotbpb:				; ...
		add	di, 6		; BDS.BPB (BDS offset 6)

SetPtrSav:				; ...
		mov	cx, es		; return point for dsk_init
		les	bx, ds:ptrsav
		mov	es:[bx+13], ah	; [es:bx+media]
		mov	es:[bx+18], di	; [es:bx+count]
		mov	es:[bx+20], cx	; [es:bx+count+2]
		clc
		retn
get_bpb		endp


; =============== S U B	R O U T	I N E =======================================


clear_ids	proc near		; ...
		push	di
		xor	cx, cx		; 0
		mov	es:[di+57h], cx	; [es:di+BDS.vol_serial]
		mov	es:[di+59h], cx	; [es:di+BDS.vol_serial+2]
		mov	cx, 11
		mov	si, offset vol_no_name ; "NO NAME    "
		add	di, 75		; BDS.volid
		rep movsb
		test	byte ptr es:[di+31], 40h ; (here, es:di	points to the BDS offset +136)
					; [es:di+BDS.fatsiz], fbig
					;
					; ! NOTE - 26/06/2023 -	Erdogan	Tan
					; Microsoft code has a bug here	because	the BDS's
					; .volid and .filesys_id fields	will be	reset
					; (to their default text) according to 'BDS.fatsiz' flags
					; at the BDS offset 31 but current (this) code checks flags
					; at ES:DI+31 while DI points the BDS offset 86!?
					;
					; Correct Code:
					; test byte [ES:DI+31-86],40h or
					; DI_POSITION equ BDS.volid + size_of_EXT_BOOT_VOL_LABEL
					; test byte [ES:DI:BDS.fatsiz-DI_POSITION],40h ; fbig
					;
					; (Why this bug	did not	affect MSDOS applications:
					; 'clear_ids' is used for floppy disks only and the default
					; option of 'clear_ids' is FAT12 volid and filesys_id text
					; when the flag	bit has	wrong value for	FAT16/40h.)
		mov	si, offset fat_16_id ; "FAT16	"
		jnz	short ci_bigfat
		mov	si, offset fat_12_id ; "FAT12	"

ci_bigfat:				; ...
		mov	cx, 8		; size_of_EXT_SYSTEM_ID
		add	di, 5		; BDS.filesys_id (BDS offset 91)
		rep movsb
		pop	di		; restore bds pointer

getbp_retn:				; 26/06/2023
		retn
clear_ids	endp


; =============== S U B	R O U T	I N E =======================================


GetBp		proc near		; ...
		test	byte ptr es:[di+23h], 5	; return_fake_bpb|fnon_removable
		jz	short getbp1
		jmp	getret_exit	; 26/06/2023 - (useless	far jump to 'retn'!)
					;
					; Correct code here:
					; retn ; (instead of jmp getret_exit)
					; ;or
					; jnz short getbp_retn ; (short	jump to	'retn')
; ---------------------------------------------------------------------------

getbp1:					; ...
		push	cx
		push	dx
		push	bx
		call	readbootsec
		jb	short getbp_err_ret_brdg
		or	bx, bx		; bx is	0 if boot sector is valid
		jnz	short dofatbpb
		call	movbpb
		jmp	short Has1
; ---------------------------------------------------------------------------

getbp_err_ret_brdg:			; ...
		jmp	getbp_err_ret
; ---------------------------------------------------------------------------

dofatbpb:				; ...
		call	readfat		; puts media descriptor	byte in	ah
		jb	short getbp_err_ret_brdg
		cmp	ds:fhave96, 0	; changeline support available?
		jz	short bpb_nochangeline ; brif not
		call	hidensity

bpb_nochangeline:			; ...
		cmp	byte ptr es:[di+22h], 2	; [es:di+BDS.formfactor], ffSmall
		jnz	short is_floppy
		cmp	ah, 0F9h	; is it	a valid	fat id byte for	3.5" ?
		jnz	short got_unknown_medium ; no

Has720K:				; ...
		mov	bx, offset sm92	; pointer to correct bpb
		mov	al, [bx+0]	; bpbtype.sbf =	3
		mov	cx, [bx+3]	; bpbtype.csec = 1440
		mov	dx, [bx+5]	; dl = bpbtype.spau = 2
					; dh = bpbtype.chead = 2
		mov	bx, [bx+1]	; bl = bpbtype.spt = 9
					; bh = bpbtype.dire = 112
		jmp	short Has1
; ---------------------------------------------------------------------------

is_floppy:				; ...
		cmp	ah, 0F8h
		jb	short got_unknown_medium
		mov	al, 1		; pbtype.sbf = 1
		mov	bx, 4008h	; bl = bpbtype.spt = 8
					; bh = bpbtype.dire = 64
		mov	cx, 320		; bpbtype.csec = 1440
		mov	dx, 101h	; dl = bpbtype.spau = 1
					; dh = bpbtype.chead = 1
		test	ah, 2
		jnz	short has8
		inc	al		; bpbtype.sbf =	2
		inc	bl		; bpbtype.spt =	9
		add	cx, 40		; 180K (360 sectors)

has8:					; ...
		test	ah, 1		; bpbtype.sbf =	1
		jz	short Has1
		add	cx, cx
		mov	bh, 112		; bh = bpbtype.dire = 112
		inc	dh
		inc	dl

Has1:					; ...
		mov	es:[di+8], dh	; [es:di+BDS.secperclus]
		mov	es:[di+0Ch], bh	; [es:di+BDS.direntries]
		mov	es:[di+0Eh], cx	; [es:di+BDS.totalsecs16]
		mov	es:[di+10h], ah	; [es:di+BDS.media]
		mov	es:[di+11h], al	; [es:di+BDS.fatsecs]
		mov	es:[di+13h], bl	; [es:di+BDS.secpertrack]
		mov	es:[di+15h], dl	; [es:di+BDS.heads]
		mov	word ptr es:[di+19h], 0	; [es:di+BDS.hiddensecs+2]
		mov	word ptr es:[di+17h], 0	; [es:di+BDS.hiddensecs]
		mov	word ptr es:[di+1Dh], 0	; [es:di+BDS.totalsecs32+2]

getret:					; ...
		pop	bx
		pop	dx
		pop	cx

getret_exit:				; ...
		retn
; ---------------------------------------------------------------------------

getbp_err_ret:				; ...
		mov	ds:set_id_flag,	0
		call	maperror
		jmp	short getret
; ---------------------------------------------------------------------------

got_unknown_medium:			; ...
		mov	ds:set_id_flag,	0
		mov	al, 7
		stc
		jmp	short getret
GetBp		endp


; =============== S U B	R O U T	I N E =======================================


readbootsec	proc near		; ...
		mov	dh, 0		; head 0
		mov	cx, 1		; cylinder 0, sector 1
		call	read_sector
		jb	short err_ret
		xor	bx, bx		; bx = 0
		cmp	ds:disksector, 69h ; is	it a direct jump?
		jz	short check_bpb_mediabyte ; don't need to find a nop
		cmp	ds:disksector, 0E9h ; dos 2.0 jump?
		jz	short check_bpb_mediabyte ; no need for	nop
		cmp	ds:disksector, 0EBh ; how about	a short	jump?
		jnz	short invalidbootsec
		cmp	ds:disksector+2, 90h ; is next one a nop?
		jnz	short invalidbootsec

check_bpb_mediabyte:			; ...
		mov	al, ds:disksector+15h ;
					; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
		and	al, 0F0h
		cmp	al, 0F0h	; allow	for strange media
		jnz	short invalidbootsec

checksinglesided:
		mov	al, ds:disksector+15h
		cmp	al, 0F0h
		jz	short gooddsk
		test	al, 1
		jnz	short gooddsk
		cmp	word ptr ds:disksector+8, '.3' ; 2E33h ; '3.'
		jnz	short mustbeearlier
		cmp	ds:disksector+0Ah, '2' ; 32h
		jnb	short gooddsk

mustbeearlier:				; ...
		mov	ds:disksector+0Dh, 1 ; we must have a pre-3.20 diskette.
					; set the sec/clus field to 1
					; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]
		jmp	short gooddsk
; ---------------------------------------------------------------------------

invalidbootsec:				; ...
		inc	bx		; indicate that	boot sector invalid (bx	= 1)

gooddsk:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

err_ret:				; ...
		retn
readbootsec	endp


; =============== S U B	R O U T	I N E =======================================


movbpb		proc near		; ...
		mov	dh, ds:disksector+0Dh ;	sectors	per unit (cluster)
		mov	bh, ds:disksector+11h ;	number of directory entries
		mov	cx, word ptr ds:disksector+13h ; size of drive (volume)
		mov	ah, ds:disksector+15h ;	media descriptor
		mov	al, ds:disksector+16h ;	number of fat sectors
		mov	bl, ds:disksector+18h ;	sectors	per track
		mov	dl, ds:disksector+1Ah ;	number of heads
		cmp	ds:set_id_flag,	1 ; called by get_bpb?
		jnz	short movbpb_ret
		call	mov_media_ids
		jb	short movbpb_conv ; conventional boot record?
		mov	ds:set_id_flag,	2 ; signals that volume	id is set

movbpb_conv:				; ...
		cmp	ds:fhave96, 1
		jnz	short movbpb_ret
		call	resetchanged	; reset	flags in bds to	not fchanged

movbpb_ret:				; ...
		clc
		retn
movbpb		endp


; =============== S U B	R O U T	I N E =======================================


mov_media_ids	proc near		; ...
		cmp	ds:disksector+26h, 29h ; [disksector+EXT_BOOT.SIG],
					;	       EXT_BOOT_SIGNATURE
		jnz	short mmi_not_ext
		push	cx
		mov	cx, word ptr ds:disksector+27h ;
					; [disksector+EXT_BOOT.SERIAL]
		mov	es:[di+57h], cx
		mov	cx, word ptr ds:disksector+29h ;
					; [disksector+EXT_BOOT.SERIAL+2]
		mov	es:[di+59h], cx	; [es:di+BDS.vol_serial+2]
		push	di
		push	si
		mov	cx, 11		; size_of_EXT_BOOT_VOL_LABEL
		mov	si, (offset disksector+2Bh) ;
					; disksector+EXT_BOOT.VOL_LABEL
		add	di, 75		; BDS.volid
		rep movsb
		mov	cx, 8		; size_of_EXT_SYSTEM_ID
		mov	si, (offset disksector+36h) ;
					; disksector+EXT_BOOT.SYSTEM_ID
		add	di, 5		;
					; (BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
		rep movsb
		pop	si
		pop	di
		pop	cx
		clc			; this clc is not required (16/06/2019 - Erdogan Tan)
					; (20/09/2022 -	27/06/2023)
		retn
; ---------------------------------------------------------------------------

mmi_not_ext:				; ...
		stc
		retn
mov_media_ids	endp


; =============== S U B	R O U T	I N E =======================================


readfat		proc near		; ...
		mov	dh, 0		; head 0
		mov	cx, 2		; cylinder 0, sector 2
		call	read_sector
		jb	short bad_fat_ret
		mov	ah, [bx]	; media	byte

bad_fat_ret:				; ...
		retn
readfat		endp


; =============== S U B	R O U T	I N E =======================================


read_sector	proc near		; ...
		push	bp
		mov	bp, 3		; make 3 attempts
		mov	dl, es:[di+4]	; [es:di+BDS.drivenum]
		mov	bx, offset disksector ;	BIOSDATA:014Eh

rd_ret:					; ...
		push	es
		push	ds
		pop	es
		mov	ax, 201h
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		pop	es
		jnb	short okret2

rd_rty:					; ...
		call	again		; reset	disk, decrement	bp
		jz	short err_rd_ret
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags], fnon_removable
					; (BDS offset 35)
		jnz	short rd_ret
		cmp	ds:media_set_for_format, 0
		jnz	short rd_skip1_dpt
		push	ax
		push	ds		; for retry, set the head settle time to 0Fh
		lds	si, ds:dpt
		mov	al, [si+9]	; [si+DISK_PARMS.DISK_HEAD_STTL]
		mov	byte ptr [si+9], 15 ; NORMSETTLE
		pop	ds
		mov	ds:save_head_sttl, al
		pop	ax

rd_skip1_dpt:				; ...
		push	es
		push	ds
		pop	es
		mov	ax, 201h
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		pop	es
		pushf
		cmp	ds:media_set_for_format, 0
		jnz	short rd_skip2_dpt
		push	ax
		mov	al, ds:save_head_sttl
		push	ds
		lds	si, ds:dpt
		mov	[si+9],	al	; [si+DISK_PARMS.DISK_HEAD_STTL]
		pop	ds
		pop	ax

rd_skip2_dpt:				; ...
		popf
		jnb	short okret2
		jmp	short rd_rty
; ---------------------------------------------------------------------------

err_rd_ret:				; ...
		mov	dl, 0FFh
		stc

okret2:					; ...
		mov	ds:step_drv, dl
		mov	ds:tim_drv, dl
		mov	es:[di+46h], ch	; [es:di+BDS.track]
					; (BDS offset 70)
					; save last track accessed on this drive
		pushf
		call	set_tim
		popf			; restore flags
		pop	bp
		retn
read_sector	endp


; =============== S U B	R O U T	I N E =======================================


dsk_open	proc near		; ...
		cmp	ds:fhave96, 0
		jz	short dsk_open_exit
		call	SetDrive
		inc	word ptr es:[di+20h] ; [es:di+BDS.opcnt]
					; (BDS offset 32)

dsk_open_exit:				; ...
		clc			; CF is	already	ZERO here - Erdogan Tan
		retn
dsk_open	endp


; =============== S U B	R O U T	I N E =======================================


dsk_close	proc near		; ...
		cmp	ds:fhave96, 0
		jz	short exitjx	; done if no changeline	support
		call	SetDrive	; get bds for drive
		cmp	word ptr es:[di+20h], 0	; [es:di+BDS.opcnt]
		jz	short exitjx	; watch	out for	wrap
		dec	word ptr es:[di+20h]

exitjx:					; ...
		clc			; CF is	already	ZERO here - Erdogan Tan
		retn
dsk_close	endp


; =============== S U B	R O U T	I N E =======================================


dsk_rem		proc near		; ...
		call	SetDrive
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags], fnon_removable
		jnz	short x_bus_exit
		clc			; CF is	already	ZERO here - Erdogan Tan
		retn
; ---------------------------------------------------------------------------

x_bus_exit:				; ...
		mov	ah, 3		; non_rem
					; return busy status
		stc

dsk_ret:				; ...
		retn
dsk_rem		endp

; ---------------------------------------------------------------------------

dsk_writv:				; ...
		mov	word ptr ds:rflag, 103h	; write	and verify
		jmp	short dsk_cl
; ---------------------------------------------------------------------------

dsk_writ:				; ...
		mov	word ptr ds:rflag, 3 ; romwrite

dsk_cl:					; ...
		call	diskio		; prepare for rombios read/write

dsk_io:					; ...
		jnb	short dsk_ret
		jmp	bc_err_cnt
; ---------------------------------------------------------------------------

dsk_read:				; ...
		call	DISKRD
		jmp	short dsk_io

; =============== S U B	R O U T	I N E =======================================


checksingle	proc near		; ...
		push	ax
		push	bx
		mov	bx, es:[di+23h]	; [es:di+BDS.flags]
		test	bl, 21h		; fnon_removable|fi_own_physical
		jnz	short singleret
		test	bl, 10h		; fi_am_mult
					; is there a drive sharing this	physical drive?
		jz	short singleret
		mov	al, es:[di+4]	; [es:di+BDS.drivenum]
					; get physical drive number
		push	es		; preserve pointer to current bds
		push	di
		les	di, dword ptr ds:start_bds ; get first bds

scan_list:				; ...
		cmp	es:[di+4], al
		jnz	short scan_skip	; Not our drive. Try next bds.
		mov	bl, 20h		; fi_own_physical ; test ownership flag
		test	es:[di+23h], bl
		jz	short scan_skip	; he doesn't own it either. continue
		xor	es:[di+23h], bl	; reset	ownership flag
		pop	di
		pop	es
		or	es:[di+23h], bl
		cmp	ds:fsetowner, 1
		jnz	short not_fsetowner
		cmp	byte ptr es:[di+4], 0 ;	are we handling	drive number 0 ?
		jnz	short singleret
		mov	al, es:[di+5]	; [es:di+BDS.drivelet]
					; get the DOS drive letter
		push	es
		mov	es, ds:zeroseg
		assume es:nothing
		mov	byte ptr es:0504h, al ;	[es:LSTDRV]
					; set up sdsb
		pop	es		; restore bds pointer
		assume es:nothing
		jmp	short singleret
; ---------------------------------------------------------------------------

not_fsetowner:				; ...
		cmp	ds:single, 2	; if (single_drive_system)
		jnz	short ignore_sdsb
		push	ax
		mov	al, es:[di+5]	; if (curr_drv == req_drv)
		mov	ah, al
		push	es
		mov	es, ds:zeroseg
		assume es:nothing
		xchg	al, byte ptr es:0504h ;	[es:LSTDRV]
					; then swap(curr_drv,req_drv)
		pop	es
		assume es:nothing
		cmp	ah, al		; else
		pop	ax		; swap(curr_drv,req_drv)
		jz	short singleret	; issue	swap_dsk_msg

ignore_sdsb:				; ...
		call	swpdsk
		jmp	short singleret
; ---------------------------------------------------------------------------

scan_skip:				; ...
		les	di, es:[di]
		cmp	di, 0FFFFh	; -1 ; end of list?
		jnz	short scan_list	; continue until hit end of list
		stc
		pop	di		; restore current bds
		pop	es

singleret:				; ...
		pop	bx
		pop	ax
		retn
checksingle	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR diskio

baddrive:				; ...
		mov	al, 8		; sector not found
		jmp	short baddrive_ret
; ---------------------------------------------------------------------------

unformatteddrive:			; ...
		mov	al, 7		; unknown media

baddrive_ret:				; ...
		stc
; END OF FUNCTION CHUNK	FOR diskio

ioret:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


DISKRD		proc near		; ...
		mov	ds:rflag, 2	; romread
DISKRD		endp


; =============== S U B	R O U T	I N E =======================================


diskio		proc near		; ...

; FUNCTION CHUNK AT 08DD SIZE 00000007 BYTES

		mov	bx, di		; al = drive number
					; cx = sector count
					; dx = first sector (low)
					; [start_sec_h]	= first	sector (high)
					;
					; es:bx	= transfer address
		mov	ds:xfer_seg, es	; save transfer	segment
		call	SetDrive
		mov	al, es:[di+10h]	; [es:di+BDS.media]
		mov	ds:medbyt, al
		jcxz	short ioret
		test	byte ptr es:[di+24h], 2	; [es:di+BDS.flags+1],
					;  unformatted_media
		jnz	short unformatteddrive
		mov	ds:seccnt, cx	; save sector count
		mov	ds:spsav, sp	; save sp
		mov	ax, dx
		xor	si, si
		add	dx, cx
		adc	si, 0
		cmp	word ptr es:[di+0Eh], 0	; [es:di+BDS.totalsecs16]
					; > 32 bit sector ?
		jz	short sanity32
		cmp	si, 0
		jnz	short baddrive
		cmp	dx, es:[di+0Eh]	; [es:di+BDS.totalsecs16]
		ja	short baddrive
		jmp	short sanityok
; ---------------------------------------------------------------------------

sanity32:				; ...
		add	si, ds:start_sec_h
		cmp	si, es:[di+1Dh]	; [es:di+BDS.totalsecs32+2]
		jb	short sanityok
		ja	short baddrive
		cmp	dx, es:[di+1Bh]	; [es:di+BDS.totalsecs32]
		ja	short baddrive

sanityok:				; ...
		mov	dx, ds:start_sec_h
		add	ax, es:[di+17h]	; [es:di+BDS.hiddensecs]
		adc	dx, es:[di+19h]	; [es:di+BDS.hiddensecs+2]
		mov	ds:saved_word, ax ; save the sector number (low)
		push	es
		mov	es, ds:zeroseg	; 0
		assume es:nothing
		les	si, dword ptr es:single	; [es:DSKADR] ;	INT 1Eh	vector
					; current disk parm table
		assume es:nothing
		mov	word ptr ds:dpt, si
		mov	word ptr ds:dpt+2, es
		pop	es
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags],
					; fnon_removable
		jnz	short skip_setup
		call	checksingle
		cmp	ds:fhave96, 0	; do we	have changeline	support?
		jz	short diskio_nochangeline ; brif not
		call	checklatchio	; will do a sneaky pop stack return
					; if a disk error occurs

diskio_nochangeline:			; ...
		call	iosetup		; set up tables	and variables for i/o

skip_setup:				; ...
		mov	ax, dx
		xor	dx, dx
		div	word ptr es:[di+13h] ; [es:di+BDS.secpertrack]
					; divide by sec	per track
		mov	ds:temp_h, ax
		mov	ax, ds:saved_word
		div	word ptr es:[di+13h] ; [es:di+BDS.secpertrack]
					; now, [temp_h]:ax = track #, dx = sector
					; sector number	is 1 based.
		inc	dl
		mov	ds:cursec, dl	; save current sector
		mov	cx, es:[di+15h]	; [es:di+BDS.heads]
					; get number of	heads
		push	ax
		xor	dx, dx
		mov	ax, ds:temp_h	; divide tracks	by heads per cylinder
		div	cx
		mov	ds:temp_h, ax
		pop	ax
		div	cx		; now, [temp_h]:ax = cylinder #, dx = head
		cmp	ds:temp_h, 0
		ja	short baddrive_brdg
		cmp	ax, 1024	; 2^10 currently maxium	for track #.
		ja	short baddrive_brdg
		mov	ds:curhd, dl	; save current head
		mov	ds:curtrk, ax	; save current track
		mov	ax, ds:seccnt
		call	block
		call	done
		retn
; ---------------------------------------------------------------------------

baddrive_brdg:				; ...
		jmp	baddrive
diskio		endp


; =============== S U B	R O U T	I N E =======================================


iosetup		proc near		; ...
		mov	al, es:[di+4]	; [es:di+BDS.drivenum]
		mov	ds:tim_drv, al	; save drive letter
		cmp	ds:media_set_for_format, 0
		jnz	short skip_dpt_setting
		mov	al, ds:eot	; fetch	up eot before changing ds
		push	ds
		lds	si, ds:dpt	; get pointer to disk base table
		mov	[si+4],	al
		mov	al, [si+10]	; [si+DISK_PARMS.DISK_MOTOR_STRT]
		mov	ah, [si+4]	; [si+DISK_PARMS.DISK_EOT]
		pop	ds
		mov	ds:motorstartup, al
		mov	ds:save_eot, ah
		push	ds
		lds	si, ds:dpt
		cmp	byte ptr es:[di+34], 2 ; [es:di+BDS.formfactor], ffSmall
		jnz	short motor_start_ok
		mov	al, 4
		xchg	al, [si+10]	; [si+DISK_PARMS.DISK_MOTOR_STRT]

motor_start_ok:				; ...
		xor	al, al
		inc	al		; ibm wants fast settle	to be 1
		xchg	al, [si+9]	; [si+DISK_PARMS.DISK_HEAD_STTL]
					; get settle and set up	for fast
		pop	ds
		mov	ds:settlecurrent, al
		mov	al, 15		; NORMSETTLE
					; someone has diddled the settle
		mov	ds:settleslow, al

skip_dpt_setting:			; ...
		retn
iosetup		endp


; =============== S U B	R O U T	I N E =======================================


done		proc near		; ...
		test	byte ptr es:[di+23h], 1
		jnz	short ddbx	; do not set for non-removable media
		call	set_tim

diddle_back:				; ...
		pushf
		cmp	ds:media_set_for_format, 0
		jnz	short nodiddleback
		push	ax
		push	es
		les	si, ds:dpt
		mov	al, ds:save_eot
		mov	es:[si+4], al	; [es:si+DISK_PARMS.DISK_EOT]
		mov	al, ds:settlecurrent
		mov	ah, ds:motorstartup
		mov	es:[si+9], al	; [es:si+DISK_PARMS.DISK_HEAD_STTL]
		mov	byte ptr es:[si+3], 2 ;	[es:si+DISK_PARMS.DISK_SECTOR_SIZ]
		mov	es:[si+0Ah], ah	; [es:si+DISK_PARMS.DISK_MOTOR_STRT]
		pop	es
		pop	ax

nodiddleback:				; ...
		popf

ddbx:					; ...
		retn
done		endp


; =============== S U B	R O U T	I N E =======================================


block		proc near		; ...
		or	ax, ax
		jz	short ddbx
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags], fnon_removable
		jz	short block_floppy
		test	byte ptr ds:multrk_flag, 80h ; multrk_on
		jz	short block_floppy
		call	disk
		xor	ax, ax
		retn
; ---------------------------------------------------------------------------

block_floppy:				; ...
		mov	cl, es:[di+19]
		inc	cl
		sub	cl, ds:cursec
		xor	ch, ch
		cmp	ax, cx
		jnb	short gotmin
		mov	cx, ax

gotmin:					; ...
		push	ax
		push	cx
		mov	ax, cx
		call	disk
		pop	cx
		pop	ax
		sub	ax, cx		; reduce sectors-remaining by last i/o
		shl	cl, 1
		add	bh, cl		; adjust transfer address
		jmp	short block
block		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR disk

dskerr_brdg:				; ...
		jmp	dskerr
; END OF FUNCTION CHUNK	FOR disk

; =============== S U B	R O U T	I N E =======================================


disk		proc near		; ...

; FUNCTION CHUNK AT 0A78 SIZE 00000003 BYTES

		mov	bp, 5		; al = number of sectors (1-8, all on one track)
					; es:di	point to drive parameters
					; xfer_seg:bx =	transfer address
					;      (must not cross a 64k physical boundary)
					; [rflag] = 2 if read, 3 if write
					; [verify] = 0 for normal, 1 for verify	after write
					;
					; bp = MAXERR
					;      retry_count
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags], fnon_removable
		jz	short GetRdWrInd
		cmp	ah, 4		; romverify ; Is this a	track verify?
		jz	short GetRdWrInd
		mov	bp, 2		; This is not verify so	only 1 retry

GetRdWrInd:				; ...
		mov	ds:vretry_cnt, bp ; verify op. retry cnt for write-verify
		mov	ds:soft_ecc_cnt, bp ; soft ecc error retry count
		mov	ah, ds:rflag	; get read/write indicator

_retry:					; ...
		push	ax
		mov	dx, ds:curtrk
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.bdsm_ismini]
					; is this a mini disk? ((logical dos partition))
		jz	short disk_not_mini ; no. continue to next
		cmp	word ptr es:[di+47h], 1
		jnz	short disk_not_mini
		add	dx, es:[di+49h]	; [es:di+BDS.bdsm_hidden_trks]
					; add hidden tracks

disk_not_mini:				; ...
		ror	dh, 1
		ror	dh, 1
		or	dh, ds:cursec
		mov	cx, dx
		xchg	ch, cl		; cl = sector, ch = cylinder
		mov	dh, ds:curhd	; load current head number and
		mov	dl, es:[di+4]	; physical drive number
					; [es:di+BDS.drivenum]
		cmp	byte ptr es:[di+22h], 5	; [es:di+BDS.formfactor], ffHardFile
		jz	short do_fast	; hard files use fast speed
		cmp	ds:step_drv, 0FFh ; -1
		jz	short do_writej
		cmp	ah, 2		; romread
		jz	short do_fast
		cmp	ah, 4		; romverify
		jz	short do_fast

do_writej:				; ...
		jmp	short do_write
; ---------------------------------------------------------------------------

do_fast:				; ...
		call	fastspeed	; change settle	mode

testerr:				; ...
		jb	short dskerr_brdg
		mov	ds:step_drv, dl
		mov	es:[di+46h], ch	; [es:di+BDS.track]
		cmp	word ptr ds:rflag, 103h
		jz	short doverify

noverify:				; ...
		pop	ax
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags], fnon_removable
		jz	short its_removable
		test	byte ptr ds:multrk_flag, 80h ; multrk_on
		jnz	short disk_ret

its_removable:				; ...
		and	cl, 3Fh		; eliminate cylinder bits from sector
		xor	ah, ah
		sub	ds:seccnt, ax	; reduce count of sectors to go	next sector
		add	cl, al
		mov	ds:cursec, cl
		cmp	cl, es:[di+13h]	; [es:di+BDS.secpertrack]
					; see if sector/track limit reached
		jbe	short disk_ret
		mov	ds:cursec, 1
		mov	dh, ds:curhd
		inc	dh
		cmp	dh, es:[di+15h]
		jb	short noxor
		xor	dh, dh		; head 0
		inc	ds:curtrk	; next track

noxor:					; ...
		mov	ds:curhd, dh

disk_ret:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

do_write:				; ...
		cmp	dl, ds:step_drv
		jnz	short do_norm
		cmp	ch, es:[di+46h]
		jz	short do_fast

do_norm:				; ...
		call	normspeed
		jmp	short testerr
; ---------------------------------------------------------------------------

doverify:				; ...
		pop	ax
		push	ax
		mov	ah, 4
		call	fastspeed
		jnb	short noverify
		cmp	ah, 11h		; soft ecc error ?
		jnz	short not_softecc_err
		dec	ds:soft_ecc_cnt
		jz	short noverify	; no more retry
		call	resetdisk
		jmp	short dskerr1	; retry
; ---------------------------------------------------------------------------

not_softecc_err:			; ...
		call	resetdisk
		dec	ds:vretry_cnt
		jmp	short dskerr0
; ---------------------------------------------------------------------------

loc_3127:				; ...
dskerr:					; do we	have changeline	support?
		cmp	ds:fhave96, 0
		jz	short dskerr_nochangeline ; brif not
		call	checkio

dskerr_nochangeline:			; ...
		cmp	ds:multitrk_format_flag, 1 ; multi trk format request?
		jnz	short dochkagain ; no more retry
		mov	bp, 1
		mov	ds:multitrk_format_flag, 0 ; clear the flag

dochkagain:				; ...
		call	again

dskerr0:				; ...
		jz	short harderr
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags], fnon_removable
		jnz	short skip_timeout_chk
		cmp	ah, 80h		; timeout?
		jz	short harderr

skip_timeout_chk:			; ...
		cmp	ah, 0CCh	; write	fault error?
		jz	short write_fault_err ;	then, don't retry.
		mov	ds:soft_ecc_cnt, 5 ; MAXERR
					; set soft_ecc_cnt back	  to maxerr

dskerr1:				; ...
		pop	ax		; estore sector	count
		jmp	_retry
; ---------------------------------------------------------------------------

write_fault_err:			; ...
		mov	bp, 1		; just retry only once
					; for write fault error
		jmp	short dskerr1
; ---------------------------------------------------------------------------

harderr:				; ...
		call	maperror

harderr2:				; ...
		mov	ds:tim_drv, 0FFh ; force a media check through rom
		mov	cx, ds:seccnt	; get count of sectors to go
		mov	sp, ds:spsav	; recover entry	stack pointer
		jmp	diddle_back
disk		endp


; =============== S U B	R O U T	I N E =======================================


normspeed	proc near		; ...
		cmp	ds:media_set_for_format, 0
		jnz	short fastspeed
		push	es
		push	ax
		mov	al, ds:settleslow
		les	si, ds:dpt	; current disk parm table
		mov	es:[si+9], al	; [es:si+DISK_PARMS.DISK_HEAD_STTL]
		pop	ax
		pop	es
		call	fastspeed
		push	es
		les	si, ds:dpt
		mov	byte ptr es:[si+9], 1 ;	[es:si+DISK_PARMS.DISK_HEAD_STTL]
					; 1 is fast settle value
		pop	es
		retn
normspeed	endp


; =============== S U B	R O U T	I N E =======================================


fastspeed	proc near		; ...
		test	byte ptr es:[di+1Fh], 80h ; [es:di+BDS.fatsiz],	ftoobig
		jnz	short notready
		push	es
		mov	es, ds:xfer_seg
		int	13h		; DISK -
		mov	ds:xfer_seg, es
		pop	es
		retn
; ---------------------------------------------------------------------------

notready:				; ...
		stc
		mov	ah, 80h
		retn
fastspeed	endp


; =============== S U B	R O U T	I N E =======================================


maperror	proc near		; ...
		push	cx
		push	es
		push	ds
		pop	es		; set es=Bios_Data
		mov	al, ah
		mov	ds:lsterr, al	; terminate list with error code
		mov	cx, 9		; numerr (= errout-errin)
					; number of possible error conditions
		mov	di, offset errin
		repne scasb
		mov	al, [di+8]	; [di+numerr-1]
					; get translation
		pop	es
		pop	cx
		stc			; flag error condition
		retn
maperror	endp


; =============== S U B	R O U T	I N E =======================================


set_tim		proc near		; ...
		push	ax		; set the time of last access for this drive.
					; this is done only for	removable media.
					; es:di	-> bds
		call	GetTickCnt	; Does INT 1A ah=0 & updates daycnt
		cmp	dx, es:[di+47h]	; [es:di+BDS.tim_lo]
		jnz	short setaccess
		cmp	cx, es:[di+49h]
		jz	short done_set

setaccess:				; ...
		mov	ds:accesscount,	0 ; the	time has passed
					; reset	the threshold counter
		mov	es:[di+47h], dx
		mov	es:[di+49h], cx

done_set:				; ...
		clc
		pop	ax
		retn
set_tim		endp


; =============== S U B	R O U T	I N E =======================================


again		proc near		; ...
		call	resetdisk
		cmp	ah, 6		; If it	is a media change error
					; do not decrement retry count
		jz	short dont_dec_retry_count
		dec	bp		; decrement retry count
		retn
; ---------------------------------------------------------------------------

dont_dec_retry_count:			; ...
		or	ah, ah
		retn
again		endp

; ---------------------------------------------------------------------------
		db 0
IoReadJumpTable	db 8			; ...
		dw offset GetDeviceParameters ;	60h
		dw offset ReadTrack	; 61h
		dw offset VerifyTrack	; 62h
		dw offset Cmd_Error_Proc ; 63h
		dw offset Cmd_Error_Proc ; 64h
		dw offset Cmd_Error_Proc ; 65h
		dw offset GetMediaId	; 66h
		dw offset GetAccessFlag	; 67h
		dw offset SenseMediaType ; 68h
IoWriteJumpTable db 7			; ...
		dw offset SetDeviceParameters ;	40h
		dw offset WriteTrack	; 41h
		dw offset FormatTrack	; 42h
		dw offset Cmd_Error_Proc ; 43h
		dw offset Cmd_Error_Proc ; 44h
		dw offset Cmd_Error_Proc ; 45h
		dw offset SetMediaId	; 46h
		dw offset SetAccessFlag	; 47h
IOC_DC_Table	db 60h,	40h, 61h, 41h, 62h, 42h, 66h, 46h, 67h,	47h, 68h ; ...
; ---------------------------------------------------------------------------

Do_Generic_IOCtl:			; ...
		call	SetDrive	; es:di	points to bds for drive
		push	es
		les	bx, ds:18	; es:bx	points to request header
		cmp	byte ptr es:[bx+0Dh], 8	; [es:bx+IOCTL_REQ.MAJORFUNCTION],
					; RAWIO
		mov	al, es:[bx+0Eh]
		pop	es
		jnz	short IoctlFuncErr
		mov	si, offset IoReadJumpTable
		test	al, 20h		; GEN_IOCTL_FN_TST ; test of req. function
		jnz	short NotGenericWrite
		mov	si, offset IoWriteJumpTable

NotGenericWrite:			; ...
		and	al, 0DFh	; ~GEN_IOCTL_FN_TST ; get rid of read/write bit
		sub	al, 40h		; offset for base function
		cmp	al, cs:[si]
		ja	short IoctlFuncErr
		cbw
		shl	ax, 1
		inc	si
		add	si, ax
		call	word ptr cs:[si]
		mov	ds, cs:Bios_Data_Word
		assume ds:nothing
		mov	ah, 81h		; Return this status in	case of	carry
		retn
; ---------------------------------------------------------------------------

Cmd_Error_Proc:				; ...
		pop	dx

IoctlFuncErr:				; ...
		jmp	bc_cmderr
; ---------------------------------------------------------------------------

GetDeviceParameters:			; ...
		lds	bx, ds:ptrsav	; ds:bx	points to request header
		assume ds:nothing
		lds	bx, [bx+13h]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
					; (ds:bx) = return buffer
		mov	al, es:[di+22h]	; [es:di+BDS.formfactor]
		mov	[bx+1],	al	; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
		mov	ax, es:[di+23h]	; [es:di+BDS.flags]
		and	ax, 3		; fnon_removable+fchangeline
					; Mask off other bits
		mov	[bx+2],	ax	; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
		mov	ax, es:[di+25h]	; [es:di+BDS.cylinders]
		mov	[bx+4],	ax	; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
		xor	al, al		; Set media type to default
		mov	[bx+6],	al	; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
		lea	si, [di+27h]	; [di+BDS.rbytespersec]	= [di+BDS.R_BPB]
					; (copy	recommended bpb)
		test	byte ptr [bx], 1 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
					; BUILD_DEVICE_BPB
		jz	short UseBpbPresent ; Point back to BIOSDATA
		push	ds
		mov	ds, cs:Bios_Data_Word ;	Point back to BIOSDATA
		assume ds:nothing
		call	checksingle
		call	GetBp		; Build	the bpb	from scratch
		pop	ds
		assume ds:nothing
		jb	short GetParmRet
		lea	si, [di+6]	; [di+BDS.bytespersec] = [di+BSD.DP_BPB]
					; Use this subfield of bds instead

UseBpbPresent:				; ...
		lea	di, [bx+7]	; [bx+A_DEVICEPARAMETERS.DP_BPB]
					; This is where	the result goes
		mov	cx, 25		; A_BPB.size - 6
					; For now use 'small' bpb
		push	ds		; reverse segments for copy
		push	es
		pop	ds
		pop	es
		rep movsb
		clc

GetParmRet:				; ...
		retn
; ---------------------------------------------------------------------------

SetDeviceParameters:			; ...
		lds	bx, ds:ptrsav	; ds:bx	points to request header
		lds	bx, [bx+13h]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		or	word ptr es:[di+23h], 140h ; [es:di+BDS.flags],
					;  fchanged_by_format|fchanged
		test	byte ptr [bx], 2 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
					;  ONLY_SET_TRACKLAYOUT
		jnz	short setTrackTable
		mov	al, [bx+1]	; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
		mov	es:[di+22h], al	; [es:di+BDS.formfactor]
		mov	ax, [bx+4]	; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
		mov	es:[di+25h], ax	; [es:di+BDS.cylinders]
		mov	ax, [bx+2]	; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
		push	ds
		mov	ds, cs:Bios_Data_Word ;	BIOSDATA segment
		assume ds:nothing
		cmp	ds:fhave96, 0
		pop	ds
		assume ds:nothing
		jnz	short HaveChange ; we have changeline support
		and	ax, 0FFFDh

HaveChange:				; ...
		and	ax, 3		; Ignore all bits except non_removable and changeline
					; fnon_removable|fchangeline
		mov	cx, es:[di+23h]	; [es:di+BDS.flags]
		and	cx, 0FDF4h	; ~(fnon_removable|fchangeline|good_tracklayout|unformatted_media)
		or	ax, cx
		mov	es:[di+23h], ax	; [es:di+BDS.flags]
		mov	al, [bx+6]	; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
					; Set media type
		push	ds
		mov	ds, cs:Bios_Data_Word
		assume ds:nothing
		mov	ds:mediatype, al
		pop	ds
		assume ds:nothing
		or	word ptr es:[di+23h], 80h ; [es:di+BDS.flags]
					; set_dasd_true	(the next time we format a track)
		push	di
		test	byte ptr [bx], 1 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
					;  INSTALL_FAKE_BPB
		jnz	short InstallFakeBpb
		test	word ptr es:[di+23h], 4	; [es:di+BDS.flags], return_fake_bpb
					; were we returning a fake bpb when asked to build a bpb?
		jz	short InstallRecommendedBpb
		and	word ptr es:[di+23h], 0FFFBh ; [es:di+BDS.flags], ~return_fake_bpb
					; we were returning a fake bpb but we can stop now

InstallRecommendedBpb:			; ...
		mov	cx, 31		; A_BPB.size
		lea	di, [di+27h]	; [di+BDS.R_BPB] = [di+BDS.rbytespersec]
		jmp	short CopyTheBpb
; ---------------------------------------------------------------------------

InstallFakeBpb:				; ...
		or	word ptr es:[di+23h], 4
		mov	cx, 25		; A_BPB.size - 6
		lea	di, [di+6]	; [es:di+BDS.BPB] = [es:di+BDS.bytespersec]

CopyTheBpb:				; ...
		lea	si, [bx+7]	; [bx+A_DEVICEPARAMETERS.DP_BPB]
		rep movsb
		push	ds		; Save packet segment
		mov	ds, cs:Bios_Data_Word ;	BIOSDATA segment
		assume ds:nothing
		call	RestoreOldDpt
		pop	ds
		assume ds:nothing
		pop	di

setTrackTable:				; ...
		mov	cx, [bx+26h]	; [bx+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
					; offset 31+7 (A_BPB.size+7)
		push	ds
		mov	ds, cs:Bios_Data_Word
		assume ds:nothing
		mov	ds:sectorspertrack, cx
		pop	ds
		assume ds:nothing
		and	word ptr es:[di+23h], 0FFF7h ; [es:di+BDS.flags], ~good_tracklayout
		test	byte ptr [bx], 4 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
					;  TRACKLAYOUT_IS_GOOD
		jz	short UglyTrackLayOut
		or	word ptr es:[di+23h], 8	; [es:di+BDS.flags], good_tracklayout

UglyTrackLayOut:			; ...
		cmp	cx, 63		; MAX_SECTORS_IN_TRACK
		ja	short TooManyPerTrack
		jcxz	short SectorInfoSaved
		mov	di, offset tracktable
		lea	si, [bx+28h]	; [bx+A_DEVICEPARAMETERS.DP_SECTORTABLE]
					; offset 31+9 (A_BPB.size+9)
		mov	es, cs:Bios_Data_Word ;	BIOSDATA segment
					; Trash	our bds	pointer
		assume es:nothing

StoreSectorInfo:			; ...
		inc	di
		inc	di		; Skip over cylinder and head
		lodsw			; Get sector id
		stosb			; Copy it
		lodsw			; Get sector size
		call	SectSizeToSectIndex ; SectSizeToSectIndex:
					;      Input:  ax contains sector size in bytes
					;      Output: al contains index
		stosb
		loop	StoreSectorInfo

SectorInfoSaved:			; ...
		clc
		retn
; ---------------------------------------------------------------------------

TooManyPerTrack:			; ...
		mov	al, 0Ch
		stc
		retn
; ---------------------------------------------------------------------------

FormatTrack:				; ...
		lds	bx, ds:ptrsav
		lds	bx, [bx+13h]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		test	byte ptr [bx], 1 ; bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
					;  STATUS_FOR_FORMAT
		jz	short DoFormatTrack
		push	ds
		mov	ds, cs:Bios_Data_Word
		assume ds:nothing
		call	SetMediaForFormat ; Also moves current Dpt to TempDpt
		pop	ds
		assume ds:nothing
		mov	[bx], al	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
		clc
		retn
; ---------------------------------------------------------------------------

DoFormatTrack:				; ...
		cmp	byte ptr es:[di+22h], 5	; [es:di+BDS.formfactor], DEV_HARDDISK
		jnz	short DoFormatDiskette
		mov	ds, cs:Bios_Data_Word
		assume ds:nothing
		jmp	VerifyTrack
; ---------------------------------------------------------------------------

DoFormatDiskette:			; ...
		mov	cx, [bx+1]	; [bx+A_FORMATPACKET.FP_HEAD]
		mov	dx, [bx+3]	; [bx+A_FORMATPACKET.FP_CYLINDER]
		test	byte ptr [bx], 2 ; [bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]
					;     FP_TRACKCOUNT is only meaningful
					;     when FP_SPECIALFUNCTIONS bit 1 = 1
		mov	ds, cs:Bios_Data_Word
		jz	short DoFormatDiskette_1
		jmp	VerifyTrack_Err
; ---------------------------------------------------------------------------

DoFormatDiskette_1:			; ...
		call	SetMediaForFormat ; Also moves current Dpt to TempDpt
		cmp	al, 1
		jz	short NeedToSetDasd ; Old rom
		cmp	al, 3		; Time out error?
		jnz	short NoSetDasd	; No,fine. (at this point, don't care
					; about	the illegal combination)
		jmp	short FormatFailed
; ---------------------------------------------------------------------------

NeedToSetDasd:				; ...
		push	dx
		call	SetDasd		; INT 13h, ah=17h
		pop	dx

NoSetDasd:				; ...
		call	checksingle	; Do any needed	diskette swapping
		mov	ax, dx		; Get track from packet
		mov	ds:trknum, ax
		mov	ds:hdnum, cl
		mov	ah, cl
		mov	bx, offset tracktable
		mov	cx, ds:sectorspertrack

StoreCylinderHead:			; ...
		mov	[bx], ax	; Store	into TrackTable
		add	bx, 4		; Skip to next sector field
		loop	StoreCylinderHead
		mov	cx, 5		; MAXERR - Set up retry	count

FormatRetry:				; ...
		push	cx		; Now verify the sectors just formatted.
					; NOTE:	because	of bug in some BIOSes
					;	we have	to set ES:BX to	00:00
		mov	bx, offset tracktable
		mov	al, byte ptr ds:sectorspertrack
		mov	ah, 5
		mov	ds:xfer_seg, ds
		call	ToRom
		pop	cx
		jb	short FormatError
		push	cx
		push	bx
		xor	bx, bx
		mov	ds:xfer_seg, bx
		mov	al, byte ptr ds:sectorspertrack
		mov	ah, 4
		mov	cl, 1
		call	ToRom
		pop	bx
		pop	cx
		jnb	short FormatOk

FormatError:				; ...
		call	resetdisk
		mov	ds:had_format_error, 1
		push	ax
		push	cx
		push	dx
		call	SetMediaForFormat
		cmp	al, 1
		jnz	short WhileErr
		call	SetDasd

WhileErr:				; ...
		pop	dx
		pop	cx
		pop	ax
		loop	FormatRetry

FormatFailed:				; ...
		mov	ds:had_format_error, 1
		cmp	ah, 6		; DSK_CHANGELINE_ERR
					; convert change line error to time out	error
		jnz	short DoMapIt
		mov	ah, 80h		; DSK_TIMEOUT_ERR

DoMapIt:				; ...
		jmp	maperror
; ---------------------------------------------------------------------------

FormatOk:				; ...
		mov	ds:had_format_error, 0 ; reset the format error	flag
		retn
; ---------------------------------------------------------------------------

VerifyTrack:				; ...
		push	ds
		lds	bx, ds:ptrsav	; ds:bx	points to request header.
		assume ds:nothing
		lds	bx, [bx+13h]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		mov	cx, [bx+3]	; [bx+A_VERIFYPACKET.VP_CYLINDER]
		mov	ax, [bx+1]	; [bx+A_VERIFYPACKET.VP_HEAD]
		mov	dx, [bx+5]	; [bx+A_FORMATPACKET.FP_TRACKCOUNT]
		mov	bl, [bx]	; [bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]
		pop	ds
		mov	ds:rflag, 4	; romverify
		mov	ds:curtrk, cx
		mov	ds:curhd, al	; assume heads < 256
		mov	cx, ds:sectorspertrack
		test	bl, 2		; DO_FAST_FORMAT
		jz	short NormVerifyTrack
		mov	ax, dx		; Get ax = number of trks to verify
		or	ah, ah
		jnz	short VerifyTrack_Err ;	#tracks	> 255
		mul	cl
		or	ah, ah
		jnz	short VerifyTrack_Err
		mov	cx, ax
		test	word ptr es:[di+23h], 1	; [es:di+BDS.flags], fnon_removable
		jz	short NormVerifyTrack
		test	ds:multrk_flag,	80h ; MULTI_TRK_ON
		jz	short NormVerifyTrack
		mov	ds:multitrk_format_flag, 1

NormVerifyTrack:			; ...
		xor	ax, ax		; 1st sector
		xor	bx, bx
		mov	ds:xfer_seg, bx	; Use 0:0 as the transfer address for verify
		call	TrackIo
		mov	ds:multitrk_format_flag, 0
		retn
; ---------------------------------------------------------------------------

VerifyTrack_Err:			; ...
		mov	ah, 1
		jmp	maperror
; ---------------------------------------------------------------------------

ReadTrack:				; ...
		mov	ds:rflag, 2	; romread
		jmp	short ReadWriteTrack
; ---------------------------------------------------------------------------

WriteTrack:				; ...
		mov	ds:rflag, 3

ReadWriteTrack:				; ...
		push	es
		les	bx, ds:ptrsav	; es:bx	-> to request header
		assume es:nothing
		les	bx, es:[bx+13h]	; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		mov	ax, es:[bx+3]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]
		mov	ds:curtrk, ax
		mov	ax, es:[bx+1]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]
		mov	ds:curhd, al	; Assume heads < 256 !
		mov	ax, es:[bx+5]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]
		mov	cx, es:[bx+7]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]
		les	bx, es:[bx+9]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]
					; Get transfer address
		mov	ds:xfer_seg, es	; Pass transfer	segment
		pop	es

; =============== S U B	R O U T	I N E =======================================


TrackIo		proc near		; ...
		mov	ds:spsav, sp	; performs track read/write/verify
					;
					;  input:
					;   rFlag - 2 =	read
					;	    3 =	write
					;	    4 =	verify
					;   ax - Index into track table	of first sector	to io
					;   cx - Number	of sectors to io
					;   Xfer_Seg:bx	- Transfer address
					;   es:di - Pointer to bds
					;   CurTrk - Current cylinder
					;   CurHd - Current head
		call	checksingle
		cmp	ds:media_set_for_format, 1 ; See if we have already set	disk
		jz	short Dptalreadyset
		push	ax		; set up tables	and variables for i/o
		push	cx
		call	iosetup
		pop	cx
		pop	ax

Dptalreadyset:				; ...
		mov	si, offset tracktable ;	Point si at the	table entry of the
					; first	sector to be io'd
		shl	ax, 1
		shl	ax, 1
		add	si, ax
		mov	dx, 1
		test	word ptr es:[di+23h], 8	; [es:di+BDS.flags], good_tracklayout
		jz	short IoNextSector
		xchg	dx, cx		; We can read all secs in one blow

IoNextSector:				; ...
		push	cx
		push	dx
		inc	si
		inc	si		; Skip over the	cylinder and head in
					; the track table
		lodsb			; Get sector ID	from track table
		mov	ds:cursec, al
		test	word ptr es:[di+23h], 1	; [es:di+BDS.flags], fnon_removable
					; Fixed	disk?
		jz	short IoRemovable ; No
		test	ds:multrk_flag,	80h ; MULTI_TRK_ON
		jz	short IoRemovable ; No,don't do that.
		mov	ds:seccnt, dx
		mov	ax, dx
		call	disk
		pop	dx
		pop	cx
		clc
		retn
; ---------------------------------------------------------------------------

IoRemovable:				; ...
		lodsb			; Get sector size index	from track
					; table	and save it
		push	ax
		push	si
		push	ds		; Save BIOSDATA
		push	ax
		mov	ah, ds:eot	; Preserve whatever might be in	ah
					; Fetch	EOT while ds-> BIOSDATA
		lds	si, ds:dpt
		mov	[si+3],	al	; [si+DISK_PARMS.DISK_SECTOR_SIZ]
		mov	[si+4],	ah	; [si+DISK_PARMS.DISK_EOT]
		pop	ax
		pop	ds
		mov	al, dl
		mov	ds:seccnt, ax
		call	disk
		pop	si		; Advance buffer pointer by adding
					; sector size
		pop	ax
		call	SectorSizeIndexToSectorSize
		add	bx, ax
		pop	dx
		pop	cx
		loop	IoNextSector
		cmp	ds:media_set_for_format, 1
		jz	short NoNeedDone
		call	done

NoNeedDone:				; ...
		clc
		retn
TrackIo		endp


; =============== S U B	R O U T	I N E =======================================


SectSizeToSectIndex proc near		; ...
		cmp	ah, 2		; (0=>128,1=>256,2=>512,3=>1024)
					;  examine upper byte only
		ja	short OneK
		mov	al, ah		; value	in ah is the index!
		retn
; ---------------------------------------------------------------------------

OneK:					; ...
		mov	al, 3
		retn
SectSizeToSectIndex endp


; =============== S U B	R O U T	I N E =======================================


SectorSizeIndexToSectorSize proc near	; ...
		mov	cl, al
		mov	ax, 80h
		shl	ax, cl
		retn
SectorSizeIndexToSectorSize endp


; =============== S U B	R O U T	I N E =======================================


SetDasd		proc near		; ...
		cmp	ds:had_format_error, 1 ; See if	we've previously set dasd type
		jz	short DoSetDasd
		test	word ptr es:[di+23h], 80h ; [es:di+BDS.flags], set_dasd_true
		jz	short DasdHasBeenSet
		and	word ptr es:[di+23h], 0FF7Fh ; [es:di+BDS.flags], ~set_dasd_true

DoSetDasd:				; ...
		mov	ds:had_format_error, 0 ; Reset it
		mov	ds:gap_patch, 50h ; Format gap for 48tpi disks
		mov	al, 4
		cmp	byte ptr es:[di+22h], 2	; [es:di+BDS.formfactor], DEV_3INCH720KB
		jz	short DoSet
		cmp	byte ptr es:[di+22h], 1	; [es:di+BDS.formfactor], DEV_5INCH96TPI
		jz	short GotBig
		mov	al, 1
		jmp	short DoSet
; ---------------------------------------------------------------------------

GotBig:					; ...
		mov	al, 2		; 160/320k in a	1.2 meg	drive
		cmp	ds:mediatype, 0
		jnz	short DoSet
		mov	al, 3		; 1.2meg in a 1.2meg drive
		mov	ds:gap_patch, 54h ; Format gap for 96 tpi, 1.2MB diskette

DoSet:					; ...
		push	ds
		push	si
		mov	ds, ds:zeroseg
		assume ds:nothing
		lds	si, dword ptr ds:78h ; [DSKADR]	(Int 1Eh)
		assume ds:nothing
		mov	byte ptr [si+9], 0Fh ; [si+DISK_PARMS.DISK_HEAD_STTL]
		pop	si
		pop	ds
		mov	ah, 17h
		mov	dl, es:[di+4]
		int	13h		; DISK - SET TYPE (AT,XT2,XT286,CONV,PS
					; AL = disk type

DasdHasBeenSet:				; ...
		mov	ah, es:[di+13h]	; [es:di+BDS.secpertrack]
		mov	ds:formt_eot, ah
		retn
SetDasd		endp


; =============== S U B	R O U T	I N E =======================================


SetMediaForFormat proc near		; ...
		push	cx
		push	dx
		cmp	ds:had_format_error, 1
		jz	short SkipSaveDskAdr
		xor	al, al		; If already done return 0
		cmp	ds:media_set_for_format, 1
		jnz	short DoSetMediaForFormat
		jmp	SetMediaRet	; Media	already	set
; ---------------------------------------------------------------------------

DoSetMediaForFormat:			; ...
		push	es
		push	si
		mov	es, ds:zeroseg	; 0 ; Point to interrupt vectors
		assume es:nothing
		les	si, dword ptr es:78h ; [es:DSKADR]
					; Get pointer to disk base table
		assume es:nothing
		mov	word ptr ds:dpt, si
		mov	word ptr ds:dpt+2, es
		mov	byte ptr es:[si+9], 0Fh	; [es:si+DISK_PARMS.DISK_HEAD_STTL]
		pop	si
		pop	es

SkipSaveDskAdr:				; ...
		mov	cx, es:[di+25h]	; [es:di+BDS.cylinders]
		dec	cx
		and	ch, 3
		ror	ch, 1
		ror	ch, 1
		xchg	ch, cl
		or	cl, es:[di+13h]	; [es:di+BDS.secpertrack]
		mov	dl, es:[di+4]	; [es:di+BDS.drivenum]
		push	es
		push	ds
		push	si
		push	di
		mov	ah, 18h
		int	13h		; DISK - SET MEDIA TYPE	FOR FORMAT (AT model 3x9,XT2,XT286,PS)
					; DL = drive number, CH	= lower	8 bits of number of tracks,
					; CL = sectors per track
		jb	short FormaStatErr
		cmp	ds:had_format_error, 1
		jz	short skip_disk_base_setting
		push	es
		mov	es, ds:zeroseg	; 0
		assume es:nothing
		les	si, dword ptr es:78h ; [es:DSKADR] (Int	1Eh)
					; Get current disk base	table
		assume es:nothing
		mov	word ptr ds:tempdpt, si
		mov	word ptr ds:tempdpt+2, es ; Save it
		mov	es, ds:zeroseg	; 0
		assume es:nothing
		mov	word ptr es:78h, di
		pop	word ptr es:fsetowner
		mov	ds:media_set_for_format, 1

skip_disk_base_setting:			; ...
		xor	al, al		; Legal	combination + rom support code
		mov	ds:had_format_error, al	; Reset	the flag
		jmp	short PopStatRet
; ---------------------------------------------------------------------------

FormaStatErr:				; ...
		cmp	ah, 0Ch		; DSK_ILLEGAL_COMBINATION
					; Illegal combination =	0Ch
		jz	short FormatStatIllegalComb
		cmp	ah, 80h		; DSK_TIMEOUT_ERR
		jz	short FormatStatTimeOut
		mov	al, 1		; Function not supported.
		jmp	short PopStatRet
; ---------------------------------------------------------------------------

FormatStatIllegalComb:			; ...
		mov	al, 2		; Function supported, but
					; Illegal sect/trk,trk combination.
		jmp	short PopStatRet
; ---------------------------------------------------------------------------

FormatStatTimeOut:			; ...
		mov	al, 3		; Function supported, but
					; Media	not present

PopStatRet:				; ...
		pop	di
		pop	si
		pop	ds
		pop	es
		assume es:nothing

SetMediaRet:				; ...
		pop	dx
		pop	cx
		retn
SetMediaForFormat endp


; =============== S U B	R O U T	I N E =======================================


resetdisk	proc near		; ...
		push	ax
		cmp	ds:media_set_for_format, 1 ; Reset while formatting?
		jnz	short ResetDisk_cont
		mov	ds:had_format_error, 1 ; Then verify operation in "fmt & vrfy"
					; Might	have failed.
					; So signals that we had a format error.

ResetDisk_cont:				; ...
		xor	ah, ah
		int	13h		; DISK - RESET DISK SYSTEM
					; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
		mov	ds:step_drv, 0FFh ; -1
					; Zap up the speed
		pop	ax
		retn
resetdisk	endp


; =============== S U B	R O U T	I N E =======================================


ToRom		proc near		; ...
		push	bx
		push	si
		test	ds:media_set_for_format, 1
		jnz	short GotValidDpt
		push	ax
		push	es		; Save bds segment
		cmp	byte ptr es:[di+22h], 2	; [es:di+BDS.formfactor], ffSmall
					; is it	a 3.5" drive?
		pushf
		mov	es, ds:zeroseg	; 0
		assume es:nothing
		les	si, dword ptr es:78h ; Get pointer to disk base	table
		assume es:nothing
		mov	word ptr ds:dpt, si ; Save pointer to table
		mov	word ptr ds:dpt+2, es
		mov	al, ds:formt_eot
		mov	es:[si+4], al	; [es:si+DISK_PARMS.DISK_EOT]
		mov	al, ds:gap_patch
		mov	es:[si+7], al	; [es:si+DISK_PARMS.DISK_FORMT_GAP]
					; Important for	format
		mov	byte ptr es:[si+9], 0Fh	; [es:si+DISK_PARMS.DISK_HEAD_STTL]
					; Assume we are	doing a	seek operation
					; Setup	motor start correctly for 3.5" drives
		popf
		jnz	short MotorStrtOK
		mov	byte ptr es:[si+0Ah], 4	; [es:si+DISK_PARMS.DISK_MOTOR_STRT]

MotorStrtOK:				; ...
		pop	es		; Restore bds segment
		pop	ax

GotValidDpt:				; ...
		mov	dx, ds:trknum	; Set track number
		mov	ch, dl		; Set low 8 bits in ch
		mov	dl, es:[di+4]	; Set drive number
		mov	dh, ds:hdnum	; Set head number
		push	es		; Save bds segment
		mov	es, word ptr ds:537h
		int	13h		; DISK -
		pop	es		; Restore bds segment
		pop	si
		pop	bx
		retn
ToRom		endp


; =============== S U B	R O U T	I N E =======================================


ioctl_getown	proc near		; ...
		call	SetDrive
		mov	al, es:[di+4]	; [es:di+BDS.drivenum]
					; Get physical drive number
		les	di, dword ptr ds:start_bds ; Get start of bds chain

OwnLoop:				; ...
		cmp	es:[di+4], al	; [es:di+BDS.drivenum]
		jnz	short getnextBDS
		test	word ptr es:[di+23h], 20h ; [es:di+BDS.flags], fi_own_physical
		jnz	short ExitOwn

getnextBDS:				; ...
		les	di, es:[di]	; [es:di+BDS.link]
		jmp	short OwnLoop
; ---------------------------------------------------------------------------

ioctl_setown:				; ...
		call	SetDrive
		mov	ds:fsetowner, 1	; set flag for CheckSingle to look at.
		call	checksingle
		mov	ds:fsetowner, 0	; set ownership	of drive reset flag

ExitOwn:				; ...
		xor	cl, cl
		test	word ptr es:[di+23h], 10h ; [es:di+BDS.flags], fi_am_mult
		jz	short ExitNoMult
		mov	cl, es:[di+5]	; [es:di+BDS.drivelet]
					; Get logical drive number
		inc	cl		; Get it 1-based

ExitNoMult:				; ...
		lds	bx, ds:ptrsav
		mov	[bx+1],	cl	; [bx+unit]
					; Exit normal termination
		clc
		retn
ioctl_getown	endp


; =============== S U B	R O U T	I N E =======================================


RestoreOldDpt	proc near		; ...
		push	ax
		xor	al, al
		mov	ds:had_format_error, al	; Reset	flag and
		xchg	al, ds:media_set_for_format ; get current flag setting
		or	al, al
		jz	short DontRestore
		push	si
		push	ds
		push	es
		lds	si, ds:tempdpt
		mov	es, cs:Bios_Data_Word
		assume es:nothing
		mov	es, es:zeroseg	; es = 0
		assume es:nothing
		mov	word ptr es:78h, si ; [es:DSKADR] (Int 1Eh)
		mov	word ptr es:78h+2, ds ;	[es:DSKADR+2]
		pop	es
		assume es:nothing
		pop	ds
		pop	si

DontRestore:				; ...
		pop	ax
		clc
		retn
RestoreOldDpt	endp


; =============== S U B	R O U T	I N E =======================================


GetMediaId	proc near		; ...
		call	ChangeLineChk
		mov	al, es:[di+5]	; [es:di+BDS.drivelet] ; Logical drive number
		mov	ds:rflag, 2	; Read operation
		call	BootIo		; Read boot sector into	DiskSector
		jb	short IOCtl_If1
		cmp	ds:disksector+15h, 0F0h	; Valid? (0F0h-0FFh?)
		jb	short IOCtl_If2	; brif not valid (0F0h - 0FFh)
		cmp	ds:disksector+26h, 29h ; disksector+EXT_BOOT.SIG
					; BS_BootSig
		jnz	short IOCtl_If2
		les	di, ds:ptrsav
		les	di, es:[bx+19]	; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		mov	si, (offset disksector+27h) ; BS_VolID
		add	di, 2		; A_MEDIA_ID_INFO.MI_SERIAL
		mov	cx, 23		; +size_of_EXT_BOOT_VOL_LABEL
					; +size_of_EXT_SYSTEM_ID
		rep movsb
		clc
		retn
; ---------------------------------------------------------------------------

IOCtl_If2:				; ...
		mov	al, 7
		stc

IOCtl_If1:				; ...
		retn
GetMediaId	endp

; ---------------------------------------------------------------------------

SetMediaId:				; ...
		call	ChangeLineChk
		mov	al, es:[di+5]	; [es:di+BDS.drivelet]
					; Logical drive	number
		mov	dl, al
		mov	ds:rflag, 2	; romread
		push	dx
		call	BootIo		; Read boot sector to BIOSDATA:DiskSector
		pop	dx
		jb	short IOCtl_If6
		cmp	ds:disksector+15h, 0F0h	; Valid? (0F0h-0FFh?)
					; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
		jb	short IOCtl_If7
		cmp	ds:disksector+26h, 29h
		jnz	short IOCtl_If7
		push	es
		push	di
		push	ds
		pop	es
		mov	di, (offset disksector+27h) ; disksector+EXT_BOOT.SERIAL
		lds	si, ds:ptrsav
		lds	si, [si+13h]
		add	si, 2
		mov	cx, 23		; copy volume serial, label and	system id
					; cx = 23 = size_of_EXT_BOOT_SERIAL
					;	  + size_of_EXT_BOOT_VOL_LABEL
					;	  + size_of_EXT_SYSTEM_ID
		rep movsb
		push	es		; point	ds back	to BIOSDATA
		pop	ds
		pop	di		; restore bds pointer
		pop	es
		call	mov_media_ids	; update the bds media id info.
		mov	al, dl
		mov	ds:rflag, 3	; romwrite
		call	BootIo		; write	it back
		mov	ds:tim_drv, 0FFh ; make	sure chk_media check the driver
					; return with error code from BootIo
		retn
; ---------------------------------------------------------------------------

IOCtl_If7:				; ...
		mov	al, 7		; error_unknown_media
		stc

IOCtl_If6:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


BootIo		proc near		; ...
		push	es
		push	di
		push	bx
		push	ds
		pop	es
		mov	di, offset disksector ;	es:di -> transfer address
		xor	dx, dx		; First	sector (h) -> 0
		mov	ds:start_sec_h,	dx ; Start sector (h) -> 0
		mov	cx, 1
		call	diskio
		pop	bx
		pop	di
		pop	es
		retn
BootIo		endp


; =============== S U B	R O U T	I N E =======================================


ChangeLineChk	proc near		; ...
		mov	dl, es:[di+4]	; [es:di+BDS.drivenum]
		or	dl, dl		; Fixed	disk?
		js	short ChangeLnChkRet
		test	word ptr es:[di+23h], 4	; [es:di+BDS.flags], return_fake_bpb
		jnz	short ChangeLnChkRet
		cmp	ds:fhave96, 1	; This rom support change line?
		jnz	short ChangeLnChkRet ; no
		call	HasChange	; This drive support change line?
		jz	short ChangeLnChkRet ; Do nothing
		mov	ah, 16h
		int	13h		; DISK -
		jnb	short ChangeLnChkRet
		push	bx
		mov	bx, 40h		; fchanged
					; Update flag in BDS for this physical drive
		call	Set_Changed_DL
		pop	bx

ChangeLnChkRet:				; ...
		retn
ChangeLineChk	endp

; ---------------------------------------------------------------------------

GetAccessFlag:				; ...
		lds	bx, ds:ptrsav	; ds:bx	points to request header
		lds	bx, [bx+13h]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		mov	al, 0		; Assume result	is unformatted
		test	word ptr es:[di+23h], 200h ; [es:di+BDS.flags],	unformatted_media
		jnz	short GafDone	; Done if unformatted
		inc	al		; Return true for formatted

GafDone:				; ...
		mov	[bx+1],	al	; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
		retn
; ---------------------------------------------------------------------------

SetAccessFlag:				; ...
		lds	bx, ds:12h	; ds:bx	points to request header
		lds	bx, [bx+13h]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		and	word ptr es:[di+23h], 0FDFFh ; [es:di+BDS.flags], ~unformatted_media
		cmp	byte ptr [bx+1], 0 ; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
		jnz	short saf_Done
		or	word ptr es:[di+23h], 200h ; [es:di+BDS.flags],	unformatted_media

saf_Done:				; ...
		retn
; ---------------------------------------------------------------------------

ioctl_support_query:			; ...
		push	es
		les	bx, ds:ptrsav	; es:bx	points to request header.
		mov	ax, es:[bx+0Dh]	; [es:bx+IOCTL_REQ.MAJORFUNCTION]
					; al ==	Major, ah == Minor
		cmp	al, 8		; IOC_DC
		jnz	short NoSupport
		push	cs
		pop	es
		assume es:BIOSCODE
		mov	cx, 11		; IOC_DC_TABLE_LEN
		mov	di, offset IOC_DC_Table
		xchg	al, ah
		repne scasb
		jnz	short NoSupport
		mov	ax, 100h
		jmp	short $+2
; ---------------------------------------------------------------------------

ioctl_support:				; ...
		pop	es
		assume es:nothing
		clc
		retn
; ---------------------------------------------------------------------------

NoSupport:				; ...
		pop	es
		jmp	bc_cmderr
; ---------------------------------------------------------------------------

SenseMediaType:				; ...
		lds	bx, ds:ptrsav	; s:bx points to request header.
		lds	bx, [bx+13h]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		mov	word ptr [bx], 0 ; 0 ; Initialize the 2	packet bytes
					; invalidate drive type	(byte 1)
					; and default type flag	(byte 0)
		mov	dl, es:[di+4]	; [es:di+BDS.drivenum]
		xor	dh, dh
		mov	ah, 20h
		int	13h		; Compaq, ATAPI	Removable Media	Device
					; GET CURRENT MEDIA FORMAT
					;   AH = 20h
					;   DL = drive number (00h,01h)
					; Return: CF clear if successful
					;   AL = media type
					;   AH = 00h
					;   CF set on error
					;      AH = error code
					;
					; (Ref:	Ralf Interrupt List, INTERRUP.B)
		jb	short MediaSenseErr
		inc	byte ptr [bx]	; [bx+A_MEDIA_SENSE.MS_ISDEFAULT]
					; 1 = default media type

DetermineMediaType:			; ...
		dec	al		; 3 -> 2, 4 -> 3, 6 -> 5
		cmp	al, 2		; 3.5 inch, 720	KB
		jz	short GotMediaType
		add	al, 4		; 3 -> 6, 4 -> 7, 6 -> 9
		cmp	al, 7		; 3.5 inch, 1.44 MB
		jz	short GotMediaType
		cmp	al, 9		; 3.5 inch, 2.88 MB
		jnz	short UnknownMediaType ; Just didn't recognize media type

GotMediaType:				; ...
		mov	[bx+1],	al	; [bx+A_MEDIA_SENSE.MS_DEVICETYPE]
		clc
		retn
; ---------------------------------------------------------------------------

MediaSenseErr:				; ...
		cmp	ah, 32h		; non-default media /
					; drive	does not support media type
		jz	short DetermineMediaType
		mov	al, 2		; function supported but, drive	not ready
		cmp	ah, 31h		; no such drive	/ media	not present
		jz	short SenseErrExit

UnknownMediaType:			; ...
		mov	al, 7		; error_unknown_media

SenseErrExit:				; ...
		mov	ah, 81h		; Return this status in	case of	carry
		stc
		retn
; ---------------------------------------------------------------------------
		db    0
; ---------------------------------------------------------------------------

i2f_handler:				; ...
		cmp	ah, 13h
		jz	short int2f_replace_int13
		cmp	ah, 8
		jz	short mine
		cmp	ah, 16h
		jz	short win386call
		cmp	ah, 4Ah
		jnz	short i2f_handler_iret
		jmp	handle_multmult
; ---------------------------------------------------------------------------

i2f_handler_iret:			; ...
		iret
; ---------------------------------------------------------------------------

int2f_replace_int13:			; ...
		push	ax
		mov	ax, ds
		mov	ds, cs:Bios_Data_Word
		assume ds:nothing
		push	word ptr ds:Orig13
		push	word ptr ds:Orig13+2
		push	word ptr ds:Old13
		push	word ptr ds:Old13+2
		mov	word ptr ds:Orig13, dx
		mov	word ptr ds:Orig13+2, ax
		mov	word ptr ds:Old13, bx
		mov	word ptr ds:Old13+2, es
		pop	es
		pop	bx
		pop	ds
		assume ds:nothing
		pop	dx
		pop	ax

i2f_iret:				; ...
		iret
; ---------------------------------------------------------------------------

mine:					; ...
		cmp	al, 0F8h	; iret on reserved functions
		jnb	short i2f_iret
		or	al, al		; a get	installed state	request?
		jnz	short disp_func
		mov	al, 0FFh
		jmp	short i2f_iret
; ---------------------------------------------------------------------------

disp_func:				; ...
		cmp	al, 1		; request for installing bds?
		jz	short do_subfun_01
		cmp	al, 3		; get bds vector?
		jz	short do_get_bds_vector
		push	ds
		mov	ds, cs:Bios_Data_Word
		assume ds:nothing
		mov	word ptr ds:ptrsav, bx
		mov	word ptr ds:ptrsav+2, es
		pop	ds
		assume ds:nothing
		jmp	far ptr	70h:898h ; BIOSDATA:dsk_entry
					;
					; NOTE:	jump to	a FAR function,	not an
					; IRET type function. Callers of
					; this int2f subfunction will have
					; to be	careful	to do a	popf
; ---------------------------------------------------------------------------

do_subfun_01:				; ...
		push	es
		push	ds
		push	ds
		pop	es
		mov	ds, cs:Bios_Data_Word ;	BIOSDATA segment
		assume ds:nothing
		call	install_bds
		pop	ds
		assume ds:nothing
		pop	es
		jmp	short i2f_iret
; ---------------------------------------------------------------------------

do_get_bds_vector:			; ...
		mov	ds, cs:Bios_Data_Word
		assume ds:nothing
		lds	di, dword ptr ds:start_bds
		assume ds:nothing

ii2f_iret:				; ...
		jmp	short i2f_iret
; ---------------------------------------------------------------------------

win386call:				; ...
		push	ds
		mov	ds, cs:Bios_Data_Word ;	BIOSDATA segment
		assume ds:nothing
		cmp	al, 5		; Win386_Init
					; is it	win386 initializing?
		jz	short Win386Init
		cmp	al, 6		; Win386_Exit
					; is it	win386 exiting?
		jnz	short win_iret
		test	dx, 1		; is it	win386 or win286 dos extender?
		jnz	short win_iret	; if not win386, then continue
		and	ds:IsWin386, 0	; indicate that	win386 is not present
		jmp	short win_iret
; ---------------------------------------------------------------------------

Win386Init:				; ...
		test	dx, 1		; is it	win386 or win286 dos extender?
		jnz	short win_iret	; if not win386, then continue
		or	ds:IsWin386, 1
		mov	word ptr ds:SI_Next, bx
		mov	word ptr ds:SI_Next+2, es ; Hook our structure into chain
		mov	bx, offset Win386_SI ; point es:bx to Win386_SI
		push	ds
		pop	es
		assume es:nothing

win_iret:				; ...
		pop	ds
		assume ds:nothing
		jmp	short i2f_iret	; return back up the chain
; ---------------------------------------------------------------------------

handle_multmult:			; ...
		cmp	al, 1
		jnz	short try_2
		push	ds
		call	HMAPtr		; get offset of	free HMA
		mov	bx, 0FFFFh
		mov	es, bx		; seg of HMA
		assume es:nothing
		mov	bx, di
		not	bx
		or	bx, bx
		jz	short try_1
		inc	bx

try_1:					; ...
		pop	ds
		jmp	short ii2f_iret
; ---------------------------------------------------------------------------

try_2:					; ...
		cmp	al, 2		; multMULTALLOCHMA
		jnz	short try_3
		push	ds
		mov	di, 0FFFFh	; assume not enough space
		mov	es, di
		call	HMAPtr		; get offset of	free HMA
		cmp	di, 0FFFFh
		jz	short InsuffHMA
		neg	di		; free space in	HMA
		cmp	bx, di
		jbe	short try_4
		mov	di, 0FFFFh
		jmp	short InsuffHMA
; ---------------------------------------------------------------------------

try_4:					; ...
		mov	di, ds:FreeHMAPtr
		add	bx, 15
		and	bx, 0FFF0h
		add	ds:FreeHMAPtr, bx ; update the free pointer
		jnz	short InsuffHMA
		mov	ds:FreeHMAPtr, 0FFFFh ;	-1
					; no more HMA if we have wrapped

InsuffHMA:				; ...
		pop	ds
		jmp	ii2f_iret
; ---------------------------------------------------------------------------

try_3:					; ...
		jmp	ii2f_iret

; =============== S U B	R O U T	I N E =======================================


HMAPtr		proc near		; ...
		mov	ds, cs:Bios_Data_Word
		assume ds:nothing
		mov	di, ds:FreeHMAPtr
		cmp	di, 0FFFFh
		jnz	short HMAPtr_retn_
		cmp	ds:SysinitPresent, 0
		jz	short HMAPtr_retn_
		call	dword ptr ds:MoveDOSIntoHMA ; call far [MoveDOSIntoHMA]

loc_39EC:
		mov	di, ds:FreeHMAPtr

HMAPtr_retn_:				; ...
		retn
HMAPtr		endp


; =============== S U B	R O U T	I N E =======================================


move_sector	proc near		; ...
		cld
		push	cx
		mov	cx, 256
		cmp	si, 0FE00h
		ja	short movsec_bytes
		cmp	di, 0FE00h
		ja	short movsec_bytes
		rep movsw
		pop	cx
		retn
; ---------------------------------------------------------------------------

movsec_bytes:				; ...
		shl	cx, 1
		rep movsb
		pop	cx
		retn
move_sector	endp


; =============== S U B	R O U T	I N E =======================================


check_wrap	proc near		; ...
		push	ax
		push	bx
		push	es
		push	di
		call	find_bds	; get pointer to bds for drive in dl
		jb	short no_wrap	; finished if DOS doesn't use it
		test	word ptr es:[di+23h], 1	; [es:di+BDS.flags],fnon_removable
		jz	short no_wrap	; no wrapping for removable media
		mov	bx, es:[di+13h]	; [es:di+BDS.secpertrack]
		mov	ax, cx
		and	ax, 3Fh		; extract sector number
		cmp	ax, bx		; are we going to wrap?
		jbe	short no_wrap
		div	bl		; ah=new sector	#, al=#	of head	wraps
		or	ah, ah
		jnz	short not_on_bound
		mov	ah, bl		; set sector=BDS_BPB.BPB_SECTORSPERTRACK
		dec	al		; if on	boundary
					; also decrement # of head wrap

not_on_bound:				; ...
		and	cl, 0C0h	; zero out sector #
		or	cl, ah		; or in	new sector #
		xor	ah, ah		; ax = # of head wraps
		inc	ax
		add	al, dh		; add in starting head #
		adc	ah, 0		; catch	any carry
		cmp	ax, es:[di+15h]	; [es:di+BDS.heads]
					; are we going to wrap around a	head?
		jbe	short no_wrap_head
		push	dx		; preserve drive number	and head number
		xor	dx, dx
		mov	bx, es:[di+15h]	; [es:di+BDS.heads]
					; dx = new head	#, ax =	# of cylinder wraps
		div	bx
		or	dx, dx		; if new head #	is 0, then we are on the last head
		jnz	short no_head_bound
		mov	dx, bx		; on boundary. set to BDS_BPB.BPB_HEADS
		or	ax, ax		; if we	had some cylinder wraps,
					; we need to reduce them by on
		jz	short no_head_bound
		dec	ax		; reduce number	of cylinder wraps

no_head_bound:				; ...
		mov	bh, dl		; bh has new head number
		pop	dx		; restore drive	number and head	number
		dec	bh
		mov	dh, bh
		mov	bh, cl
		and	bh, 3Fh		; preserve sector number
		mov	bl, 6
		xchg	cl, bl
		shr	bl, cl		; get ms cylinder bits to ls end
		add	ch, al		; add in cylinder wrap
		adc	bl, ah		; add in high byte
		shl	bl, cl		; move up to ms	end
		xchg	bl, cl		; restore cylinder bits	into cl
		or	cl, bh		; or in	sector number

no_wrap:				; ...
		clc
		pop	di
		pop	es
		assume es:nothing
		pop	bx
		pop	ax
		retn
; ---------------------------------------------------------------------------

no_wrap_head:				; ...
		mov	dh, al		; do not lose new head number
		dec	dh		; get it 0-based
		jmp	short no_wrap
check_wrap	endp


; =============== S U B	R O U T	I N E =======================================


find_bds	proc near		; ...
		les	di, dword ptr ds:start_bds ; point es:di to first bds

fbds_1:					; ...
		cmp	es:[di+4], dl	; [es:di+BDS.drivenum]
		jz	short fbds_2
		les	di, es:[di]	; [es:di+BDS.link]
					; go to	next bds
		cmp	di, 0FFFFh
		jnz	short fbds_1
		stc

fbds_2:					; ...
		retn
find_bds	endp


; =============== S U B	R O U T	I N E =======================================


doint		proc near		; ...
		mov	dl, [bp+8]	; [bp+INT13FRAME.olddx]
					; get physical drive number
		xor	ah, ah
		or	al, al
		jz	short dointdone	; if zero sectors, return ax=0
		mov	ah, [bp+3]	; [bp+INT13FRAME.oldax+1]
					; get request code
		push	word ptr [bp+10h] ; [bp+INT13FRAME.oldf]
		popf
		call	far ptr	70h:797h ; call	BIOSDATA:call_orig13
					; call DOSBIOSSEG:call_orig13
		pushf
		pop	word ptr [bp+10h] ; [bp+INT13FRAME.oldf]

dointdone:				; ...
		retn
doint		endp

; ---------------------------------------------------------------------------
dtype_array	dd 400090h		; ...
					; 40h:90h is drive type	array
; ---------------------------------------------------------------------------

format_special_stuff:			; ...
		cmp	ds:fhave96, 0	; do we	have changeline	support?

loc_3ABE:				; brif not
		jz	short format_special_stuff_done
		push	bx
		mov	bx, 140h	; fchanged_by_format+fchanged
		call	Set_Changed_DL	; indicate that	media changed by format
		pop	bx
		jmp	short format_special_stuff_done
; ---------------------------------------------------------------------------

ec35_special_stuff:			; ...
		test	dl, dl		; floppy or hard disk?
		js	short ec35_special_stuff_done ;	if hard	drive, we're done
		push	ax		; see if this PARTICULAR drive is ec35
		push	cx
		mov	cl, dl		; turn drive number into bit map
		mov	al, 1		; assume drive 0
		shl	al, cl		; shift	over correct number of times
		test	ds:ec35_flag, al ; electrically	compatible 3.5 incher?
		pop	cx
		pop	ax
		jz	short ec35_special_stuff_done ;	done if	this floppy is not an ec35
		push	bx		; free up a far	pointer	(es:bx)
		push	es
		les	bx, cs:dtype_array
		add	bl, dl
		adc	bh, 0		; find entry for this drive
		mov	byte ptr es:[bx], 93h ;	establish drive	type as:
					; (360k	disk in	360k drive,
					; no double-stepping, 250 kbs transfer rate)
		pop	es
		pop	bx
		jmp	short ec35_special_stuff_done
; ---------------------------------------------------------------------------

ps2_special_stuff:			; ...
		cmp	ds:prevoper, 8	; (ps2_30)
					; read driver parm?
		jz	short ps2_30_problem
		cmp	ds:prevoper, 15h ; apparently function 15h fails, too
		jnz	short ps2_special_stuff_done

ps2_30_problem:				; ...
		push	ax
		mov	ah, 1
		call	far ptr	70h:797h ; call	BIOSDATA:call_orig13
		pop	ax
		jmp	short ps2_special_stuff_done
; ---------------------------------------------------------------------------

i13z:					; ...
		push	ds
		mov	ds, cs:Bios_Data_Word
		mov	ds:prevoper, ax	; save request
		cmp	ah, 5		; romformat
		jz	short format_special_stuff

format_special_stuff_done:		; ...
		cmp	ds:ec35_flag, 0	; any electrically compat 3.5 inchers?
		jnz	short ec35_special_stuff ; go handle it	out of line if so

ec35_special_stuff_done:		; ...
		call	far ptr	70h:797h ; call	BIOSDATA:call_orig13
		pushf
		cmp	ds:model_byte, 0FAh ; is this a	ps2/30?
					; mdl_ps2_30
		jz	short ps2_special_stuff	; exit mainline	to address special

ps2_special_stuff_done:			; ...
		popf
		jb	short goterr13	; error	on original orig13 call-thru?

ret_from_i13:				; ...
		pop	ds
		assume ds:nothing
		retf	2		; restore ds & iret w/flags
; ---------------------------------------------------------------------------

i13ret_ck_chglinerr:			; ...
		jnb	short ret_from_i13 ; done if not an error termination

i13_ret_error:				; ...
		cmp	ah, 6		; did i	see a change event?
		jnz	short int13b	; skip if wrong	error
		or	dl, dl		; is this for the hard disk?
		js	short int13b	; yes, ignore
		cmp	ds:fhave96, 0
		jz	short int13b	; just in case ROM returned this
					; error	even though it told us it
					; never	would
		push	bx
		mov	bx, 40h		; fchanged
		call	Set_Changed_DL
		pop	bx

int13b:					; ...
		stc			; now return the error
		jmp	short ret_from_i13
; ---------------------------------------------------------------------------

goterr13:				; ...
		cmp	ah, 9		; dma error?
		jz	short gotdmaerr

goterr13_xxxx:				; ...
		cmp	ah, 11h		; ecc error?
		jnz	short i13_ret_error ; other error. just	return back.
		cmp	ds:media_set_for_format, 1 ; formatting?
		jz	short i13_ret_error
		cmp	byte ptr ds:prevoper+1,	2 ; ecc-corrected error
					; (2 = romread)
					; ECC correction only applies to reads
		jnz	short i13_ret_error
		xor	ah, ah
		call	far ptr	70h:797h ; call	BIOSDATA:call_orig13
					; call DOSBIOSSEG:call_orig13
		mov	ax, ds:prevoper
		xor	ah, ah		; return code =	no error
		cmp	al, 1		; if request for one sector, assume ok
		jz	short ret_from_i13 ; return with carry clear
		push	bx
		push	cx
		push	dx
		mov	ds:number_of_sec, al

loop_ecc:				; ...
		mov	ax, 201h	; read one sector
		call	check_wrap	; get correct parameters for int 13
		call	far ptr	70h:797h ; call	BIOSDATA:call_orig13
					; call DOSBIOSSEG:call_orig13
		jnb	short ok11_op
		cmp	ah, 9		; DMA error during ECC read?
		jz	short handle_dma_during_ecc
		cmp	ah, 11h		; only allow ecc errors
		jnz	short ok11_exit_err
		mov	ah, 0
		xor	ax, ax		; ecc error. reset the system again.
					; clear	the error code so that if this
					; was the last sector, no error	code
					; will be returned for the corrected read.
					; (clear carry too.)

ok11_op:				; ...
		dec	ds:number_of_sec
		jz	short ok11_exit	; all done?
		inc	cl		; advance sector number
					; add 200h to address
		inc	bh
		inc	bh
		jmp	short loop_ecc
; ---------------------------------------------------------------------------

ok11_exit_err:				; ...
		stc			; set carry bit	again.

ok11_exit:				; ...
		pop	dx
		pop	cx
		pop	bx
		jmp	short i13ret_ck_chglinerr
; ---------------------------------------------------------------------------

handle_dma_during_ecc:			; ...
		push	es
		push	bx
		mov	bx, offset disksector ;	BIOSDATA:014Eh
		push	ds
		pop	es		; point	es:bx to buffer
		mov	ax, 201h	; read one sector
		call	far ptr	70h:797h ; call	BIOSDATA:call_orig13
		pop	bx
		pop	es
		jnb	short handle_dma_during_ecc_noerr
		cmp	ah, 11h
		jnz	short ok11_exit_err

handle_dma_during_ecc_noerr:		; ...
		push	si
		push	di
		mov	di, bx
		mov	si, offset disksector
		call	move_sector
		pop	di
		pop	si
		jmp	short ok11_op
; ---------------------------------------------------------------------------

gotdmaerr:				; ...
		mov	ax, ds:prevoper
		sti
		cmp	ah, 2		; romread
		jb	short i13_done_dmaerr
		cmp	ah, 4		; romverify
		jz	short intverify
		cmp	ah, 5		; romformat
		jz	short intformat
		ja	short i13_done_dmaerr
		push	dx		; set up stack frame here!
		push	cx
		push	bx
		push	ax
		push	bp
		mov	bp, sp
		mov	dx, es		; check	for 64k	boundary error
		shl	dx, 1
		shl	dx, 1
		shl	dx, 1
		shl	dx, 1		; dx = dx*16
		add	dx, bx
		add	dx, 511
		jnb	short no_skip_first
		jmp	bufferx		; restore dh=head & do buffer
; ---------------------------------------------------------------------------

no_skip_first:				; ...
		shr	dh, 1		; dh = number of sectors before	address
		mov	ah, 128		; ah = max number of sectors in	segment
		sub	ah, dh
		cmp	ah, al		; can we fit it	in?
		jb	short doblock	; no, perform blocking.
					; yes, the request fits. let it	happe
		mov	dh, [bp+9]	; [bp+INT13FRAME.olddx+1]
					; set up head number
		call	doint
		jmp	bad13		; and return from this place
; ---------------------------------------------------------------------------

i13_done_dmaerr:			; ...
		mov	ah, 9		; pass dma error thru to caller
		stc
		jmp	ret_from_i13	; return with error,
					; we know it's not a changeline error
; ---------------------------------------------------------------------------

intverify:				; ...
		push	es		; save caller's dma address
		push	bx
		push	ds
		pop	es

dosimple:				; ...
		mov	bx, offset disksector ;	es:bx -> BIOSDATA:disksector
		call	far ptr	70h:797h ; call	DOSBIOSSEG:call_orig13
					; call BIOSDATA:call_orig13
		pop	bx
		pop	es
		jmp	i13ret_ck_chglinerr
; ---------------------------------------------------------------------------

intformat:				; ...
		push	es
		push	bx
		push	si
		push	di
		push	ds
		push	es
		push	ds
		pop	es
		pop	ds
		mov	si, bx
		mov	di, offset disksector ;	user's data into BIOSDATA:disksector
		call	move_sector
		pop	ds
		pop	di
		pop	si		; do the i/o from
		jmp	short dosimple	; BIOSDATA:disksector
; ---------------------------------------------------------------------------

doblock:				; ...
		mov	dx, [bp+8]	; [bp+INT13FRAME.olddx]
					; get head #, drive #
		push	cx
		push	es
		push	di		; ah - # of sectors before dma boundary
					; al - requested # of sectors for i/o.
		call	find_bds
		mov	cx, es:[di+13h]	; [es:di+BDS.secpertrack]
		test	word ptr es:[di+23h], 1	; [es:di+BDS.flags], fnon_removable
		pop	di
		pop	es
		mov	al, ah		; set al=ah for	floppies
		jz	short doblockflop ; they are track by track operation
		mov	ah, 63		; ah = 63-secpt	(# safe	sectors??)
		sub	ah, cl		; al - # of sectors before dma boundary

doblockflop:				; ...
		pop	cx

doblockcontinue:			; ...
		cmp	ah, al		; if safe_# >= #_of_sectors_to_go_before dma,
		jnb	short doblocklast ; then #_of_sectors_to_go as it is for doint.
		push	ax
		mov	al, ah		; otherwise, set al to ah to operate.
		jmp	short doblockdoint
; ---------------------------------------------------------------------------

doblocklast:				; ...
		mov	ah, al
		push	ax

doblockdoint:				; ...
		call	doint
		jb	short bad13
		pop	ax
		sub	[bp+2],	ah
		add	cl, ah
		add	bh, ah
		add	bh, ah
		cmp	ah, al
		jz	short buffer
		sub	al, ah
		call	check_wrap
		jmp	short doblockcontinue
; ---------------------------------------------------------------------------

bufferx:				; ...
		mov	dh, [bp+9]	; [bp+INT13FRAME.olddx+1]
					; set up head number

buffer:					; ...
		push	bx
		mov	ah, [bp+3]	; [bp+INT13FRAME.oldax+1]
		cmp	ah, 3		; romwrite
		jnz	short doread
		push	es
		push	ds
		push	si
		push	di
		push	ds
		push	es
		pop	ds
		pop	es
		mov	di, offset disksector ;	where to move
		push	di		; save it
		mov	si, bx		; source
		call	move_sector	; move sector into local buffer
		pop	bx		; new transfer address
					; (es:bx = BIOSDATA:disksector)
		pop	di		; restore caller's di & si
		pop	si
		pop	ds		; restore BIOSDATA
		mov	al, 1
		mov	dl, [bp+8]	; [bp+INT13FRAME.olddx]
					; get drive number
		call	check_wrap	; sets up registers if wrap-around
					;
					; ah is	function
					; al is	1 for single sector transfer
					; es:bx	is local transfer addres
					; cx is	track/sector number
					; dx is	head/drive number
					; si, di unchanged
		call	doint
		pop	es		; restore caller's dma segment
		jb	short bad13	; go clean up
		jmp	short dotail
; ---------------------------------------------------------------------------

doread:					; ...
		push	es
		push	bx
		push	ds
		pop	es		; es = BIOSCODE	segment
		mov	bx, offset disksector
		mov	al, 1
		mov	dl, [bp+8]	; [bp+INT13FRAME.olddx]
					; get drive number
		call	check_wrap	; ah = function
					; al = 1 for single sector
					; es:bx	points to local	  buffer
					; cx, dx are track/sector, head/drive
		call	doint
		pop	bx
		pop	es
		jb	short bad13
		push	si
		push	di
		mov	di, bx
		mov	si, offset disksector
		call	move_sector
		pop	di
		pop	si

dotail:					; ...
		pop	bx		; retrieve new dma area
		add	bh, 2		; advance over sector
		inc	cx
		mov	al, [bp+2]	; [bp+INT13FRAME.oldax]
		clc
		dec	al
		jz	short bad13	; no more i/o
		mov	dl, [bp+8]	; [bp+INT13FRAME.olddx]
		call	check_wrap
		call	doint

bad13:					; ...
		mov	sp, bp
		pop	bp
		pop	bx
		pop	bx
		pop	cx
		pop	dx
		jb	short xgoterr13_xxxx ; go handle ECC errors
		jmp	ret_from_i13	; non-error exit
; ---------------------------------------------------------------------------

xgoterr13_xxxx:				; ...
		jmp	goterr13_xxxx
; ---------------------------------------------------------------------------
		db    0

; =============== S U B	R O U T	I N E =======================================


dsk_init	proc near		; ...
		mov	ah, ds:drvmax
		mov	di, offset dskdrvs ; pass result in es:di
		push	ds
		pop	es
		jmp	SetPtrSav
dsk_init	endp


; =============== S U B	R O U T	I N E =======================================


install_bds	proc near		; ...
		push	ds		; save Bios_Data (BIOSDATA) segment
		mov	si, offset start_bds ; beginning of chain

loop_next_bds:				; ...
		lds	si, [si]	; [si+BDS.link]
					; fetch	next bds
		mov	al, es:[di+4]	; [es:di+BDS.drivenum]
		cmp	[si+4],	al	; does this one	share a	physical
					; drive	with new one?
		jnz	short next_bds
		mov	bl, 10h		; fi_am_mult
		or	es:[di+23h], bl	; [es:di+BDS.flags]
					; set both of them to i_am_mult	if so
		or	[si+23h], bl	; [si+BDS.flags]
		and	byte ptr es:[di+23h], 0DFh ; [es:di+BDS.flags],~fi_own_physical
					; we don't own it
		mov	bl, [si+23h]	; [si+BDS.flags]
					; determine if changeline available
		and	bl, 2		; fchangeline
		or	es:[di+23h], bl	; [es:di+BDS.flags]

next_bds:				; ...
		cmp	word ptr [si], 0FFFFh ;	[si+BDS.link],-1
					; are we at end	of list?
		jnz	short loop_next_bds
		mov	word ptr [si+2], es ; [si+BDS.link+2], es
					; install bds
		mov	[si], di
		mov	word ptr es:[di], 0FFFFh ; [es:di+BDS.link],-1
					; set next pointer to null
		pop	ds
		mov	al, es:[di+34h]	; [es:di+BDS.rsecpertrack]
		cmp	al, ds:eot
		jbe	short _eot_ok
		mov	ds:eot,	al

_eot_ok:				; ...
		retn
install_bds	endp


; =============== S U B	R O U T	I N E =======================================


swpdsk		proc near		; ...
		test	ds:IsWin386, 1	; Is win386 present?
		jz	short no_win386	; no, skip SetFocus
		call	far ptr	70h:8D1h ; call	DOSBIOSSEG:V86_Crit_SetFocus
					; call BIOSDATA:V86_Crit_SetFocus

no_win386:				; ...
		push	cx
		push	dx
		mov	dl, es:[di+5]	; [es:di+BDS.drivelet]
					; get the drive	letter
		mov	dh, dl
		xor	dh, 1
		sub	cx, cx		; nobody has handled swap disk
		mov	ax, 4A00h	; multMULT<<8)|multMULTSWPDSK
					; broadcast code for swap disk
					; Broadcast it
		int	2Fh
		inc	cx
		jz	short swpdsk9
		add	dl, 'A'
		mov	byte ptr cs:drvlet, dl ; "A: and press any key when ready\r\n\n"
		mov	si, offset sngmsg ; "\r\nInsert	diskette for drive "
		push	bx
		lods	byte ptr cs:[si] ; get the next	character of the message

wrmsg_loop:				; ...
		int	29h		; DOS 2+ internal - FAST PUTCHAR
					; AL = character to display
		lods	byte ptr cs:[si] ; get the next	character of the message
		or	al, al
		jnz	short wrmsg_loop
		call	con_flush	; flush	out keyboard queue
					; call rom-bios
		xor	ah, ah
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character
		pop	bx

swpdsk9:				; ...
		pop	dx
		pop	cx
		retn
swpdsk		endp

; ---------------------------------------------------------------------------
sngmsg		db 0Dh,0Ah		; ...
		db 'Insert diskette for drive '
drvlet		db 'A: and press any key when ready',0Dh,0Ah ; ...
		db 0Ah,0

; =============== S U B	R O U T	I N E =======================================


chkopcnt	proc near		; ...
		cmp	word ptr es:[di+20h], 0	; [es:di+BDS.opcnt]
		retn
chkopcnt	endp


; =============== S U B	R O U T	I N E =======================================


MediaCheck	proc near		; ...
		call	checksingle	; make sure correct disk is in place
		xor	si, si
		call	HasChange
		jz	short mediaret
		call	checkromchange	; [es:di+BDS.flags], fchanged ;	40h
					; (BDS offset 63)
		jnz	short mediadovolid
		push	ax
		push	dx
		mov	dl, es:[di+4]	; [es:di+BDS.drivenum]
		mov	ah, 16h
		int	13h		; DISK - FLOPPY	DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
					; DL = drive to	check
					; Return: AH = disk change status

loc_3DF3:
		pop	dx
		pop	ax
		jb	short mediadovolid

loc_3DF7:
		mov	si, 1
		mov	bl, ds:tim_drv	; get last drive accessed
		cmp	es:[di+4], bl	; [es:di+BDS.drivenum]
					; (If the last drive accessed is not current drive
					; media	change status may be incorrect.	So,
					; "I don't now" will be returned even if it is indicated
					; as media is not changed.)
		jz	short mediaret	; (same	drive, media changeline	indication is reliable)
		push	ax
		push	cx
		push	dx
		call	Check_Time_Of_Access
		pop	dx
		pop	cx
		pop	ax
		or	si, si
		jz	short mediadovolid ; check_time	says ">= 2 secs	passed"
					; (volume id will be checked)
		xor	si, si		; return "i don't know"

mediaret:				; ...
		retn
; ---------------------------------------------------------------------------

mediadovolid:				; ...
		call	GetBp		; build	a new bpb in current bds
		jb	short mediaret
		call	check_vid
		jnb	short mediaret
		jmp	maperror	; fix up al for	return to dos
MediaCheck	endp


; =============== S U B	R O U T	I N E =======================================


checklatchio	proc near		; ...
		call	chkopcnt	;  [es:di+BDS.opcnt] > 0
		jz	short checkret	; done if zero
		call	checkromchange	; test [es:di+BDS.flags], fchanged ; 40h
		jz	short checkret	; not changed
		call	GetBp
		jb	short ret_no_error_map
		call	check_vid
		jb	short checklatchret
		or	si, si		; is changed for sure?
		jns	short checkret	; no
		call	returnvid	; yes

checklatchret:				; ...
		call	maperror	; fix up al for	return to dos

ret_no_error_map:			; ...
		stc
		pop	si		; pop off return address

checkret:				; ...
		retn
checklatchio	endp


; =============== S U B	R O U T	I N E =======================================


checkfatvid	proc near		; ...
		call	fat_check	; check	the fat	and the	vid
		or	si, si
		js	short changed_drv ; fall into check_vid
checkfatvid	endp


; =============== S U B	R O U T	I N E =======================================


check_vid	proc near		; ...
		cmp	ds:disksector+26h, 29h ; BS_FAT_BootSig	; BS_BootSig
					; [disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
		jz	short do_ext_check_id
		call	HasChange
		jz	short checkret
		xor	si, si
		cmp	ds:disksector+10h, 0 ; BPB_NumFATs
					; [disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]
		jz	short checkfatret ; don't read vol id if not fat system
		call	read_volume_id
		jb	short checkfatret
		call	check_volume_id
		mov	si, 0FFFFh	; -1
					; definitely changed
		jnz	short changed_drv
		inc	si

vid_no_changed:				; ...
		call	resetchanged
		clc

checkfatret:				; ...
		retn
; ---------------------------------------------------------------------------

changed_drv:				; ...
		clc			; cas -- return	no error
		mov	ds:tim_drv, 0FFh ; ensure that we ask rom for media
					;  check next time round
		retn
; ---------------------------------------------------------------------------

do_ext_check_id:			; ...
		push	ax
		mov	ax, word ptr ds:disksector+27h ; [DiskSector+EXT_BOOT.SERIAL]
		cmp	ax, es:[di+57h]	; [DiskSector+EXT_BOOT.SERIAL] = [di+BDS.vol_serial] ?
		jnz	short ext_changed ; no
		mov	ax, word ptr ds:disksector+29h
		cmp	ax, es:[di+59h]	; [DiskSector+EXT_BOOT.SERIAL+2] = [di+BDS.vol_serial+2] ?
		jnz	short ext_changed ; no
		xor	si, si		; don't know
		pop	ax
		jmp	short vid_no_changed ; reset the flag
; ---------------------------------------------------------------------------

ext_changed:				; ...
		pop	ax
		mov	si, 0FFFFh	; -1
					; disk changed!
		clc
		jmp	short changed_drv
check_vid	endp


; =============== S U B	R O U T	I N E =======================================


checkio		proc near		; ...
		cmp	ah, 6
		jnz	short checkfatret
		call	chkopcnt	; [es:di+BDS.opcnt] > 0	?
		jz	short checkfatret ; no
		call	GetBp
		jb	short no_error_map
		call	checkfatvid
		jb	short checkioret ; disk	error trying to	read in.
		or	si, si		; is changed for sure?
		js	short checkioerr ; yes changed
		inc	bp		; allow	a retry
		retn
; ---------------------------------------------------------------------------

checkioerr:				; ...
		call	returnvid

checkioret:				; ...
		stc			; make sure carry gets passed through
		jmp	harderr
; ---------------------------------------------------------------------------

no_error_map:				; ...
		jmp	harderr2
checkio		endp


; =============== S U B	R O U T	I N E =======================================


returnvid	proc near		; ...
		mov	si, 22		; trans+8
					; offset into pointer to return	value
		call	vid_into_packet
		mov	ah, 6
		stc
		retn
returnvid	endp


; =============== S U B	R O U T	I N E =======================================


Media_Set_vId	proc near		; ...
		mov	si, 15		; trans+1

vid_into_packet:			; ...
		push	ds
		lds	bx, ds:ptrsav
		add	di, 75		; BDS.volid (BDS offset	75)
		mov	[bx+si], di
		sub	di, 75		; BDS start (BDS offset	0)
		mov	word ptr [bx+si+2], es
		pop	ds
		retn
Media_Set_vId	endp


; =============== S U B	R O U T	I N E =======================================


hidensity	proc near		; ...
		test	word ptr es:[di+23h], 2	; check	for correct drive
					; is it	special?
					; [es:di+BDS.flags], fchangeline
		jz	short dofloppy	; no, do normal	floppy test
		cmp	byte ptr es:[di+22h], 2	; is it	single-media?
		jz	short dofloppy	; [es:di+BDS.formfactor], ffSmall
					; yes, use fatid.
		cmp	ah, 0F9h
		jnz	short dofloppy
		cmp	byte ptr es:[di+22h], 7	; [es:di+BDS.formfactor], ffOther
		jz	short Is720K
		cmp	byte ptr es:[di+22h], 9	; [es:di+BDS.formfactor], ff288
		jz	short Is720K
		mov	al, 7		; seven	sectors	/ fat
		mov	bx, 0E00Fh	; 224*256+0Fh (57359)
					; 224 root dir entries & 0Fh sector max
		mov	cx, 2400	; 80*15*2
					; 80 tracks, 15	sectors/track, 2 sides
		mov	dx, 258		; 1*256+2
					; sectors/allocation unit & head max
		add	sp, 2		; pop off return address
		jmp	Has1		; return to tail of getbp
; ---------------------------------------------------------------------------

Is720K:					; ...
		add	sp, 2		; pop off return address
		jmp	Has720K		; return to 720K code
; ---------------------------------------------------------------------------

dofloppy:				; ...
		retn
hidensity	endp


; =============== S U B	R O U T	I N E =======================================


Set_Changed_DL	proc near		; ...
		push	es
		push	di
		les	di, dword ptr ds:start_bds

scan_bds:				; ...
		cmp	es:[di+4], dl	; [es:di+BDS.drivenum]
		jnz	short get_next_bds
		or	es:[di+23h], bx	; [es:di+BDS.flags]
					; signal change	on other drive

get_next_bds:				; ...
		les	di, es:[di]	; [es:di+BDS.link]
					; go to	next bds
		cmp	di, 0FFFFh	; loop unless end of chain
		jnz	short scan_bds
		pop	di
		pop	es
		retn
Set_Changed_DL	endp


; =============== S U B	R O U T	I N E =======================================


checkromchange	proc near		; ...
		test	word ptr es:[di+23h], 40h ; [es:di+BDS.flags], fchanged
		retn
checkromchange	endp


; =============== S U B	R O U T	I N E =======================================


resetchanged	proc near		; ...
		and	word ptr es:[di+23h], 0FFBFh ; [es:di+BDS.flags], ~fchanged
		retn
resetchanged	endp


; =============== S U B	R O U T	I N E =======================================


HasChange	proc near		; ...
		test	word ptr es:[di+23h], 2	; [es:di+BDS.flags], fchangeline
		retn
HasChange	endp


; =============== S U B	R O U T	I N E =======================================


set_volume_id	proc near		; ...
		push	dx
		push	ax
		call	HasChange	; does drive have changeline support?
		jz	short setvret	; no, get out
		call	read_volume_id
		jb	short seterr
		call	transfer_volume_id ; copy the volume id	to special drive
		call	resetchanged

setvret:				; ...
		clc
		pop	ax
		pop	dx
		retn
; ---------------------------------------------------------------------------

seterr:					; ...
		pop	dx		; pop stack but	don't overwrite ax
		pop	dx
		retn
set_volume_id	endp

; ---------------------------------------------------------------------------
root_sec	dw 0			; ...

; =============== S U B	R O U T	I N E =======================================


read_volume_id	proc near		; ...
		push	dx
		push	cx
		push	bx
		push	ax
		push	es		; stack	the bds	last
		push	di
		push	ds		; point	es to Bios_Data	(BIOSDATA)
		pop	es
		mov	di, offset tmp_vid ; "NO NAME	 "
		mov	si, offset nul_vid ; "NO NAME	 "
		mov	cx, 12		; initialize tmp_vid to	null vi_id
		rep movsb
		pop	di
		pop	es
		mov	al, es:[di+0Bh]	; [es:di+BDS.fats]
					; # of fats
		mov	cx, es:[di+11h]	; [es:di+BDS.fatsecs]
					; sectors / fat
		mul	cl
		add	ax, es:[di+9]	; [es:di+BDS.resectors]
					; add on reserved sectors
					; now, ax is sector # (0 based)
		mov	cs:root_sec, ax
		mov	ax, es:[di+0Ch]	; [es:di+BDS.direntries]
					; # root dir entries
		mov	cl, 4		; 16 entries/sector
		shr	ax, cl		; divide by 16
		mov	cx, ax		; cx is	# of sectors to	scan

next_sec:				; ...
		push	cx		; save outer loop counter
		mov	ax, cs:root_sec	; get sector #
		mov	cx, es:[di+13h]	; [es:di+BDS.secpertrack]
					; sectors / track
		xor	dx, dx
		div	cx
		inc	dx		; dx = sectors into track
					; ax = track count from	0
		mov	cl, dl		; sector to read
		xor	dx, dx
		div	word ptr es:[di+15h] ; [es:di+BDS.heads]
					; # heads on this disc
		mov	dh, dl		; head number
		mov	ch, al		; track	#
		call	read_sector	; get first sector of the root directory,
					; ds:bx	-> directory sector
		jb	short readviderr
		mov	cx, 16		; # of dir entries in a	block of root
		mov	al, 8		; volume label bit

fvid_loop:				; ...
		cmp	byte ptr [bx], 0 ; end of dir?
		jz	short no_vid	; yes, no vol id
		cmp	byte ptr [bx], 0E5h ; empty entry?
		jz	short ent_loop	; yes, skip
		test	[bx+11], al	; is volume label bit set in fcb?
		jnz	short found_vid	; yes

ent_loop:				; ...
		add	bx, 32		; add length of	directory entry
		loop	fvid_loop
		pop	cx		; outer	loop
		inc	cs:root_sec	; inc word [root_sec]
					; next sector
		loop	next_sec	; continue

notfound:				; ...
		xor	si, si
		jmp	short fvid_ret
; ---------------------------------------------------------------------------

found_vid:				; ...
		pop	cx		; clean	stack of outer loop counter
		mov	si, bx		; point	to volume_id
		push	es		; preserve current bds
		push	di
		push	ds		; point	es to Bios_Data	(BIOSDATA)
		pop	es
		mov	di, offset tmp_vid ; "NO NAME	 "
		mov	cx, 11		; VOLID_SIZ-1
					; length of string minus nul
		rep movsb
		xor	al, al
		stosb			; null terminate
		xor	si, si
		pop	di		; restore current bds
		pop	es

fvid_ret:				; ...
		pop	ax
		clc

rvidret:				; ...
		pop	bx
		pop	cx
		pop	dx
		retn
; ---------------------------------------------------------------------------

no_vid:					; ...
		pop	cx
		jmp	short notfound
; ---------------------------------------------------------------------------

readviderr:				; ...
		pop	si
		pop	si
		jmp	short rvidret
read_volume_id	endp


; =============== S U B	R O U T	I N E =======================================


transfer_volume_id proc	near		; ...
		push	di
		push	si
		push	cx
		mov	si, offset tmp_vid ; "NO NAME	 "
		add	di, 75		; BDS.volid
		mov	cx, 12		; VOLID_SIZ
		cld
		rep movsb
		pop	cx
		pop	si
		pop	di
		retn
transfer_volume_id endp


; =============== S U B	R O U T	I N E =======================================


check_volume_id	proc near		; ...
		push	di
		push	cx
		mov	si, offset tmp_vid ; "NO NAME	 "
		add	di, 75		; BDS.volid
		mov	cx, 12		; VOLID_SIZ
		cld
		repe cmpsb
		pop	cx
		pop	di
		retn
check_volume_id	endp


; =============== S U B	R O U T	I N E =======================================


fat_check	proc near		; ...
		push	ax
		xor	si, si		; say fat id's are same.
		mov	al, ds:medbyt
		cmp	al, es:[di+10h]	; [es:di+BDS.media]
					; compare it with the bds medbyte
		jz	short okret1
		dec	si

okret1:					; ...
		pop	ax
		retn
fat_check	endp

; ---------------------------------------------------------------------------
		db 7 dup(0)
BIOSCODE	ends

; ===========================================================================

; Segment type:	Regular
SYSINIT		segment	byte public 'SYSINIT' use16
		assume cs:SYSINIT
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
SYSINIT$	dw 0
stackcount	dw 0			; ...
stackat		dw 0			; ...
stacksize	dw 0			; ...
stacks		dw 2 dup(0)		; ...
firstentry	dw offset stacks	; ...
					; stacks+(defaultcount*entrysize)-entrysize
lastentry	dw 48h			; ...
					; stacks+(defaultcount*entrysize)-entrysize
nextentry	dw 48h			; ...
old02		dd 0			; ...
; ---------------------------------------------------------------------------

int02:					; ...
		push	ax
		push	es
		mov	ax, 0F000h
		mov	es, ax
		assume es:nothing
		cmp	byte ptr es:0FFFEh, 0F9h ; mdl_convert ; check if convertible
		pop	es
		assume es:nothing
		jnz	short normal02
		in	al, 62h		; PC/XT	PPI port C. Bits:
					; 0-3: values of DIP switches
					; 5: 1=Timer 2 channel out
					; 6: 1=I/O channel check
					; 7: 1=RAM parity check	error occurred.
		test	al, 80h
		jz	short normal02
		pop	ax
		jmp	cs:old02
; ---------------------------------------------------------------------------

normal02:				; ...
		pop	ax
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old02
old08		dd 0			; ...
; ---------------------------------------------------------------------------

int08:					; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old08
old09		dd 0			; ...
; ---------------------------------------------------------------------------

int09:					; ...
		jmp	short keyboard_lbl
; ---------------------------------------------------------------------------
		nop
; ---------------------------------------------------------------------------
		db 0
; ---------------------------------------------------------------------------

keyboard_lbl:				; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old09
old70		dd 0			; ...
; ---------------------------------------------------------------------------

int70:					; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old70
; ---------------------------------------------------------------------------

int0A:					; ...
		jmp	short entry_int0A_stk
; ---------------------------------------------------------------------------
old0A		dd 0			; ...
		dw 424Bh
firstflag0A	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_0A
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int0A_stk:			; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old0A
; ---------------------------------------------------------------------------

intret_0A:				; ...
		iret
; ---------------------------------------------------------------------------

int0B:					; ...
		jmp	short entry_int0B_stk
; ---------------------------------------------------------------------------
old0B		dd 0			; ...
		dw 424Bh
		db 0
; ---------------------------------------------------------------------------
		jmp	short intret_0B
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int0B_stk:			; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old0B
; ---------------------------------------------------------------------------

intret_0B:				; ...
		iret
; ---------------------------------------------------------------------------

int0C:					; ...
		jmp	short entry_int0C_stk
; ---------------------------------------------------------------------------
old0C		dd 0			; ...
		dw 424Bh
firstflag0C	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_0C
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int0C_stk:			; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old0C
; ---------------------------------------------------------------------------

intret_0C:				; ...
		iret
; ---------------------------------------------------------------------------

int0D:					; ...
		jmp	short int0D_stk
; ---------------------------------------------------------------------------
old0D		dd 0			; ...
		dw 424Bh
firstflag0D	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_0D
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

int0D_stk:				; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old0D
; ---------------------------------------------------------------------------

intret_0D:				; ...
		iret
; ---------------------------------------------------------------------------

int0Eh:					; ...
		jmp	short entry_int0E_stk
; ---------------------------------------------------------------------------
old0E		dd 0			; ...
		dw 424Bh
firstflag0E	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_0E
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int0E_stk:			; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old0E
; ---------------------------------------------------------------------------

intret_0E:				; ...
		iret
; ---------------------------------------------------------------------------

int72:					; ...
		jmp	short entry_int72_stk
; ---------------------------------------------------------------------------
old72		dd 0			; ...
		dw 424Bh
firstflag72	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_72
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int72_stk:			; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old72
; ---------------------------------------------------------------------------

intret_72:				; ...
		iret
; ---------------------------------------------------------------------------

int73:					; ...
		jmp	short entry_int73_stk
; ---------------------------------------------------------------------------
old73		dd 0			; ...
		dw 424Bh
firstflag73	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_73
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int73_stk:			; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old73
; ---------------------------------------------------------------------------

intret_73:				; ...
		iret
; ---------------------------------------------------------------------------

int74:					; ...
		jmp	short entry_int74_stk
; ---------------------------------------------------------------------------
old74		dd 0			; ...
		dw 424Bh
firstflag74	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_74
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int74_stk:			; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old74
; ---------------------------------------------------------------------------

intret_74:				; ...
		iret
; ---------------------------------------------------------------------------

int76:					; ...
		jmp	short entry_int76_stk
; ---------------------------------------------------------------------------
old76		dd 0			; ...
		dw 424Bh
firstflag76	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_76
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int76_stk:			; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old76
; ---------------------------------------------------------------------------

intret_76:				; ...
		iret
; ---------------------------------------------------------------------------

int77:					; ...
		jmp	short entry_int77_stk
; ---------------------------------------------------------------------------
old77		dd 0			; ...
		dw 424Bh
firstflag77	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_77
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int77_stk:			; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old77
; ---------------------------------------------------------------------------

intret_77:				; ...
		iret

; =============== S U B	R O U T	I N E =======================================


do_int_stacks	proc far		; ...
		push	ax
		push	bp
		push	es
		mov	es, cs:stacks+2	; Get segment of stacks
		assume es:nothing
		mov	bp, cs:nextentry ; get most likely candidate
		mov	al, 1		; allocated
		xchg	al, es:[bp+0]	; grab the entry
		cmp	al, 0		; free ; still avail?
		jnz	short notfree02
		sub	cs:nextentry, 8	; entrysize ; set for next interrupt

fopund02:				; ...
		mov	es:[bp+2], sp	; [es:bp+savedsp],sp ; save sp value
		mov	word ptr es:[bp+4], ss ; [es:bp+savedss],ss ; save ss also
		mov	ax, bp		; temp save of table offset
		mov	bp, es:[bp+6]	; [es:bp+newsp]	; get new SP value
		cmp	es:[bp+0], ax	; check	for offset into	table
		jnz	short foundbad02
		mov	ax, es		; point	ss,sp to the new stack
		mov	es, bp
		assume es:nothing
		mov	bp, sp
		mov	bp, [bp+6]
		mov	ss, ax
		assume ss:nothing
		mov	sp, es
		mov	es, ax
		assume es:nothing
		mov	bp, cs:[bp+0]
		pushf			; go execute the real interrupt	handler
		call	dword ptr cs:[bp+0] ; which will iret back to here
					; call far [cs:bp]
		mov	bp, sp		; retrieve the table offset for	us
		mov	bp, es:[bp+0]	; but leave it on the stack
		mov	ss, word ptr es:[bp+4] ; [es:bp+savedss] ; get old stack back
		assume ss:nothing
		mov	sp, es:[bp+2]	; [es:bp+savedsp]
		mov	byte ptr es:[bp+0], 0 ;	[es:bp+allocbyte],free ; free the entry
		mov	cs:nextentry, bp ; setup to use	next time
		pop	es		; saved	on entry
		assume es:nothing
		pop	bp		; saved	on entry
		pop	ax		; saved	on entry
		add	sp, 2		; (skip	near call return addr)
		iret			; done with this interrupt
; ---------------------------------------------------------------------------

notfree02:				; ...
		cmp	al, 1		; allocated ; error flag
		jz	short findnext02 ; no, continue
		xchg	al, es:[bp+0]	; [es:bp+allocbyte] ; yes, restore error value

findnext02:				; ...
		call	longpath
		jmp	short fopund02
; ---------------------------------------------------------------------------

foundbad02:				; ...
		cmp	bp, cs:firstentry
		jb	short findnext02
		mov	bp, ax		; flag this entry
		mov	byte ptr es:[bp+0], 3 ;	clobbered
		jmp	short findnext02 ; keep	looking
do_int_stacks	endp


; =============== S U B	R O U T	I N E =======================================


longpath	proc near		; ...
		mov	bp, cs:lastentry

lploopp:				; ...
		cmp	byte ptr es:[bp+0], 0 ;	free ?
		jnz	short inuse	; no, try next one
		mov	al, 1
		xchg	al, es:[bp+0]	; [es:bp+allocbyte] ; allocate entry
		cmp	al, 0		; is it	still free?
		jz	short found	; yes, go use it
		cmp	al, 1		; allocated ?
					; is it	other than Allocated or	Free?
		jz	short inuse	; no, check the	next one
		mov	es:[bp+0], al	; yes, put back	the error state

inuse:					; ...
		cmp	bp, cs:firstentry
		jz	short fatal
		sub	bp, 8
		jmp	short lploopp
; ---------------------------------------------------------------------------

found:					; ...
		retn
; ---------------------------------------------------------------------------

fatal:					; ...
		push	ds
		mov	ax, 0F000h	; look at the model byte
		mov	ds, ax
		assume ds:nothing
		cmp	byte ptr ds:0FFFEh, 0F9h ; mdl_convert ; convertible?
		pop	ds
		assume ds:nothing
		jnz	short skip_nmis
		mov	al, 7		; disable pc convertible nmis
		out	72h, al		; CMOS Memory/RTC Index	Register (Extended RAM)

skip_nmis:				; ...
		cli			; disable and mask
		mov	al, 0FFh	; all other ints
		out	21h, al		; Interrupt controller,	8259A.
		out	0A1h, al	; Interrupt Controller #2, 8259A
		mov	si, cs
		mov	ds, si
		assume ds:SYSINIT
		mov	si, offset fatal_msg ; 'Internal stack overflow'
					;      'System halted
		push	ax
		push	ds
		mov	ax, 70h		; DOSBIODATASEG	(BIOSDATA segment)
		mov	ds, ax
		assume ds:nothing
		test	ds:IsWin386, 1	; BIOSDATA:08D0h
		pop	ds
		assume ds:nothing
		pop	ax
		jz	short fatal_loop
		call	far ptr	70h:8D1h ; call	DOSBIODATASEG:V86_Crit_SetFocus

fatal_loop:				; ...
		lodsb
		cmp	al, 24h	; '$'
		jz	short fatal_done
		mov	bl, 7
		mov	ah, 0Eh
		int	10h		; (whoops, this	enables	ints)
					; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		jmp	short fatal_loop
; ---------------------------------------------------------------------------

fatal_done:				; ...
		jmp	short fatal_done
longpath	endp

; ---------------------------------------------------------------------------
fatal_msg	db 0Dh			; ...
		db 0Ah
		db 7,0Dh,0Ah
		db 'Internal stack overflow',0Dh,0Ah
		db 'System halted',0Dh,0Ah,'$'
; ---------------------------------------------------------------------------

_SYSINIT:				; ...
		jmp	goinit
; ---------------------------------------------------------------------------
runhigh		db 0			; ...
DOSINFO		dd 0			; ...
					; address of the DOS Sysini Variables
dosinit		dw 0			; ...
CURRENT_DOS_LOCATION dw	0		; ...
DEVICE_LIST	dd 0			; ...
sysi_country	dd 0			; ...
					; pointer to country table in dos
dos_segreinit	dd 0			; ...
					; room for dword
lo_doscod_size	dw 0			; ...
					; dos code size	when in	low mem
hi_doscod_size	dw 0			; ...
					; dos code size	when in	HMA
def_php		dw 0			; ...
_seg_reinit_ptr	dw offset _seg_reinit	; ...
					; BIOSCODE:0032h
temp_bcode_seg	dw 2CCh			; ...
					; DOSBIOCODESEG	(BIOSCODE)
fake_floppy_drv	db 0			; ...
					; set to 1 if this machine
					; does not have	any floppies!!!
stack_count	dw 9			; ...
					; defaultcount ; 9
stack_size	dw 128			; ...
					; defaultsize  ; 128
stack_addr	dw 2 dup(0)		; ...
MEMORY_SIZE	dw 1			; ...
RPLMemTop	dw 0			; ...
DEFAULT_DRIVE	db 0			; ...
					; initialized by ibminit
buffers		dw 0FFFFh		; ...
					; initialized during buffer allocation
h_buffers	dw 0			; ...
					; # of the heuristic buffers. initially	0.
singlebuffersize dw 0			; ...
					; maximum sector size +	buffer head
FILES		db 8			; ...
					; enough files for pipe
FCBS		db 4			; ...
					; performance for recycling
KEEP		db 0			; ...
					; keep original	set
NUM_CDS		db 5			; ...
					; 5 net	drives
CONFBOT		dw 0			; ...
ALLOCLIM	dw 0			; ...
top_of_cdss	dw 0			; ...
DirStrng	db 'A:\',0              ; ...
					; string for the root directory	of a drive
ZERO		db 0			; ...
sepchr		db 0			; ...
linecount	dw 0			; ...
					; line count in	config.sys
showcount	db '     ',0Dh,0Ah,'$'  ; ...
					; used to convert linecount to ascii.
buffer_linenum	dw 0			; ...
sys_model_byte	db 0FFh			; ...
					; model	byte used in sysinit
sys_scnd_model_byte db 0		; ...
					; secondary model byte used in sysinit
buf_prev_off	dw 0			; ...
EXEC0_ENVIRON	dw 0			; ...
					; COMEXE ; seg addr of environment
EXEC0_COM_LINE	dw offset command_line	; pointer to asciz command line
		dw 473h			; SYSINIT segment
EXEC0_5C_FCB	dw offset DEFAULT_DRIVE
		dw 473h			; SYSINIT segment
EXEC0_6C_FCB	dw offset ZERO
		dw 473h			; SYSINIT segment
multi_pass_id	db 0			; ...
					; parameter passed to multi_pass
					; indicating the pass number
					;  0 - do scan for DOS=HIGH/LOW
					;  1 - load device drivers
					;  2 - was to load IFS
					;      now it is unused
					;  3 - do install=
					; >3 - nop
install_flag	dw 0			; ...
					; bit 0	- config.sys has install= commands
					; bit 1	- sysinit_base installed
config_size	dw 0			; ...
					; size of config.sys file
sysinit_base_ptr dd 0			; ...
					; pointer to sysinit_base
sysinit_ptr	dw 2 dup(0)		; ...
					; returning address from sysinit_base
checksum	dw 0			; ...
ldexec_fcb	db 14h dup(20h)		; ...
					; db 20	dup (' ') ; big enough
ldexec_line	db 0			; ...
					; # of parm characters
ldexec_start	db ' '                  ; ...
ldexec_parm	db 80 dup(0)		; ...
					; times	80 db 0
iexec_environ	dw 0			; ...
					; instexe ; seg	addr of	environment
iexec_ldexec_line dw offset ldexec_line	; pointer to asciiz command line
iexec_ldexec_line_seg dw 473h		; ...
iexec_ldexec_5c_fcb dw offset ldexec_fcb ; default fcb at 5Ch
iexec_ldexec_5c_fcb_seg	dw 473h		; ...
iexec_ldexec_6c_fcb dw offset ldexec_fcb ; default fcb at 6Ch
iexec_ldexec_6c_fcb_seg	dw 473h		; ...
com_level	db 0			; ...
					; level	of " " in command line
cmmt		db 0			; ...
					; length of comment string token
cmmt1		db 0			; ...
					; token
cmmt2		db 0			; ...
					; token
cmd_indicator	db 0			; ...
donotshownum	db 0			; ...
count		dw 0			; ...
org_count	dw 0			; ...
chrptr		dw 0			; ...
cntryfilehandle	dw 0			; ...
old_area	dw 0			; ...
impossible_owner_size dw 0		; ...
					; paragraph
memlo		dw 0			; ...
					; bufptr, bucketptr (dword)
memhi		dw 0			; ...
					; prmblk (word)
ldoff		dw 0
area		dw 0			; ...
packet		db 24			; ...
					; was 22
		db 0
		db 0			; initialize code
		dw 0
		db 8 dup(0)
unitcount	db 0			; ...
break_addr	dw 2 dup(0)		; ...
bpb_addr	dd 0			; ...
devdrivenum	db 0			; ...
configmsgflag	db 0			; ...
					; used to control "error in config.sys line #" message
					; (configmsgflag is the	last word of the 25 byte packet)
					; ((default value is 0,	device driver init may change? it))
		db 0
drivenumber	db 0			; ...
toomanydrivesflag db 0			; ...
					; >24 fixed disk partitions flag
BCodeSeg	dw 2CCh			; ...
					; DOSBIOCODESEG	(BIOSCODE segment)
Magicbackdoor	dd 0			; ...
; ---------------------------------------------------------------------------

NullBackdoor:				; ...
		retf
; ---------------------------------------------------------------------------
_timer_lw_	dw 0			; ...
BiosComBlock	dw offset SysinitPresent ; ...
					; BIOSDATA:08FDh
		dw 70h			; BIOSDATA segment
tempstack	db 128 dup(0)
; ---------------------------------------------------------------------------

goinit:					; ...
		mov	ah, 0C0h
		int	15h		; SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
		jb	short no_rom_config
		cmp	ah, 0
		jnz	short no_rom_config
		mov	al, es:[bx+2]	; [es:bx+ROMBIOS_DESC.bios_sd_modelbyte]
		mov	cs:sys_model_byte, al
		mov	al, es:[bx+3]	; [es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]
		mov	cs:sys_scnd_model_byte,	al
		jmp	short move_myself
; ---------------------------------------------------------------------------

no_rom_config:				; ...
		mov	ax, 0F000h
		mov	ds, ax
		assume ds:nothing
		mov	al, ds:0FFFEh
		mov	cs:sys_model_byte, al
		int	11h		; EQUIPMENT DETERMINATION
					; Return: AX = equipment flag bits
		test	ax, 1		; have any floppies?
		jnz	short move_myself ; yes,normal system
		push	es
		xor	cl, cl
		mov	ah, 8		; get disk parameters
		mov	dl, 0
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		pop	es
		jb	short move_myself ; if error lets assume that the ROM BIOS lied
		cmp	cl, 0		; double check (max sec	no cannot be 0)
		jz	short move_myself
		or	dl, dl		; number of flp	drvs ==	0?
		jnz	short move_myself
		mov	cs:fake_floppy_drv, 1 ;	set fake flag

move_myself:				; ...
		cld			; set up move
		xor	si, si
		mov	di, si
		mov	cx, cs:MEMORY_SIZE
		push	cs
		pop	ds
		assume ds:SYSINIT
		dec	cx
		xor	bx, bx
		mov	es, bx		; 0
		assume es:nothing
		mov	bx, es:0BCh	; Int 2Fh vector (4*2Fh)
		mov	es, es:0BEh
		assume es:nothing
		cmp	word ptr es:[bx+3], 5052h ; 'RP'
		jnz	short NoRPL
		cmp	byte ptr es:[bx+5], 4Ch	; 'L'
		jnz	short NoRPL
		mov	dx, cx		; get TOM into DX
		push	dx
		mov	ax, 4A06h	; (multMULT<<8)+multMULTRPLTOM
		int	2Fh		; Get new TOM from any RPL
		pop	ax
		mov	cx, dx
		cmp	dx, ax
		jz	short NoRPL
		mov	cs:RPLMemTop, dx
		dec	cx

NoRPL:					; ...
		mov	ax, 58A0h	; SI_end ; need	this much room for sysinit
					; (SI_end == sysinit code size)
		call	_off_to_para
		sub	cx, ax
		sub	cx, 0A00h	; DOSSIZE/16 (2560)
					; leave	this much room for DOS
		mov	ax, 1A70h	; BCODE_END
		call	_off_to_para	; leave	this much room for BIOS	code
		sub	cx, ax
		mov	es, cx		; offset where sysinit will be located
		mov	cx, 58A0h	; SI_end ; (sysinit code size)
		shr	cx, 1		; divide by 2 to get words
		rep movsw		; relocate sysinit
		push	es		; push relocated segment
		mov	ax, offset SYSIN ; SYSINIT:048Fh
		push	ax		; push relocated entry point
		retf			; far jump to relocated	sysinit
; ---------------------------------------------------------------------------

SYSIN:					; ...
		mov	ax, 70h
		mov	ds, ax
		assume ds:nothing
		mov	ds:MoveDOSIntoHMA_2, cs	; set seg of routine to	move DOS
					; update SYSINITSEG field
					; MoveDOSIntoHMA+2
		mov	ds:SysinitPresent, 1 ; flag that MoveDOSIntoHMA	can be called
		mov	ax, 58A0h	; SI_end ; how big is sysinitseg?
		call	_off_to_para
		mov	cx, cs		; pick a buffer	for msdos above	us
		add	ax, cx
		mov	es, ax
		xor	si, si
		mov	di, si
		mov	ds, cs:CURRENT_DOS_LOCATION ; where it is (set by msinit)
		assume ds:nothing
		mov	cx, 5000h	; DOSSIZE/2 (20480)
		rep movsw
		mov	cs:CURRENT_DOS_LOCATION, es
		mov	ax, ds:3	; get offset of	dos
					; ax = 3DE0h for MSDOS 6.21 kernel
					;  (MSDOS.SYS, offset 3)
		mov	cs:dosinit, ax
		call	_off_to_para	; subtract this	much from segment
		sub	cs:CURRENT_DOS_LOCATION, ax ; FINAL_DOS_LOCATION
		mov	ax, es
		add	ax, 0A00h	; DOSSIZE/16 ; DOSSIZE = 0A000h	= 40960
		mov	es, ax
		assume es:nothing
		xchg	ax, cs:temp_bcode_seg ;	swap with original home	of Bios_Code
		mov	ds, ax		; point	to loaded image	of Bios_Code
		mov	si, offset Bios_Data_Word ; BCODESTART (= BiosDataWord)
					; BIOSCODE:BCODESTART (BIOSCODE:0030h)
		mov	di, si
		mov	cx, 1A70h	; BCODE_END = (SYSINITSEG-DOSBIOCODESEG)*16
					; (473h-2CCh)*10h = 1A70h (for MSDOS 6.21 IO.SYS)
		sub	cx, si
		shr	cx, 1
		rep movsw		; move Bios_Code into place
		mov	ax, es		; tell it what segment it's in
		call	dword ptr cs:_seg_reinit_ptr
		les	di, dword ptr cs:BiosComBlock
		assume es:nothing
		lds	si, cs:DEVICE_LIST
		mov	dx, cs:MEMORY_SIZE
		cli
		mov	ax, cs
		mov	ss, ax
		assume ss:SYSINIT

locstack:				; ...
		mov	sp, offset locstack ; set stack
					; mov sp, 532h ; mov sp, locstack
					; %define locstack ($ -	SYSINIT$) & 0FFFEh
					; locstack = $ & 0FFFEh	(SYSINIT:SYSINIT=473h:0)
		sti
		call	dword ptr cs:dosinit ; call dosinit
					; es:di	-> sysinitvars_ext
		mov	cs:def_php, ds	; save pointer to PSP
		mov	cs:hi_doscod_size, ax ;	size of	doscode	(including exepatch)
		mov	cs:lo_doscod_size, cx ;	(as exepatch excluded)
		mov	word ptr cs:dos_segreinit, dx ;	save offset of segreinit
		mov	ax, es:[di]	; [es:di+SysInitVars_Ext.SYSI_InitVars]
		mov	word ptr cs:DOSINFO, ax
		mov	ax, es:[di+2]	; [es:di+SysInitVars_Ext.SYSI_InitVars+2]
		mov	word ptr cs:DOSINFO+2, ax
		mov	ax, es:[di+4]	; [es:di+SysInitVars_Ext.SYSI_Country_Tab]
		mov	word ptr cs:sysi_country, ax
		mov	ax, es:[di+6]	; [es:di+SysInitVars_Ext.SYSI_Country_Tab+2]
		mov	word ptr cs:sysi_country+2, ax
		mov	es, cs:CURRENT_DOS_LOCATION ; =	[FINAL_DOS_LOCATION]
		mov	word ptr cs:dos_segreinit+2, es
		cmp	cs:RPLMemTop, 0
		jz	short NoRPLArena
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	es, ax
		push	es		; resize upto RPL mem
		sub	ax, cs:RPLMemTop
		neg	ax
		dec	ax
		mov	bx, ax
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		dec	ax
		mov	es, ax
		mov	word ptr es:1, 8 ; [es:arena_owner]
		mov	word ptr es:8, 5052h ; [es:arena_name],'RP'
		mov	word ptr es:0Ah, 4Ch ; [es:arena_name+2],'L'
		mov	word ptr es:0Ch, 0 ; [es:arena_name+4]
		mov	word ptr es:0Eh, 0 ; [es:arena_name+6]
		pop	es
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed

NoRPLArena:				; ...
		les	di, cs:DOSINFO
		clc
		mov	ah, 88h
		int	15h		; EXTENDED MEMORY - GET	MEMORY SIZE (AT,XT286,PS)
					; Return: AX = memory size in K
		jb	short no_ext_memory
		mov	es:[di+45h], ax	; [es:di+SYSI_EXT_MEM],ax
					; save extended	memory size
		or	ax, ax
		jz	short no_ext_memory
		call	ClrVDISKHeader

no_ext_memory:				; ...
		mov	ax, es:[di+10h]	; [es:di+SYSI_MAXSEC] ;	get the	sector size
		add	ax, 20		; bufinsiz ; size of buffer header
		mov	cs:singlebuffersize, ax
		mov	al, cs:DEFAULT_DRIVE
		mov	es:[di+43h], al	; [es:di+SYSI_BOOT_DRIVE]

_get_cpu_type_:
		pushf
		push	bx
		xor	bx, bx
		xor	ax, ax
		push	ax
		popf
		pushf
		pop	ax
		and	ax, 0F000h
		cmp	ax, 0F000h
		jz	short _cpu_8086
		mov	ax, 0F000h
		push	ax
		popf
		pushf
		pop	ax
		and	ax, 0F000h
		jz	short _cpu_286

_cpu_386:
		inc	bx

_cpu_286:				; ...
		inc	bx

_cpu_8086:				; ...
		mov	ax, bx
		pop	bx
		popf
		cmp	ax, 2
		jnz	short _not_386_cpu
		mov	byte ptr es:[di+44h], 1	; [es:di+SYSI_DWMOVE],1
					; set doubleword moving	flag

_not_386_cpu:				; ...
		mov	al, es:[di+20h]	; [es:di+SYSI_NUMIO]
		mov	cs:drivenumber,	al ; save start	of installable block drvs
		mov	ax, cs
		sub	ax, 11h		; room for PSP we will copy shortly
		mov	cx, cs:singlebuffersize	; temporary single buffer area
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1		; divide size by 16..
					; ...to	get paragraphs...
		inc	cx		; ... and round	up
		sub	ax, cx
		mov	cs:top_of_cdss,	ax ; temp "unsafe" location
		push	es
		push	di
		mov	cx, ax		; save pointer for buffer
		sub	ax, 143		; sub ax,((26 *(curdirlen))+15)/16
					; (curdirlen=88)
		mov	cs:ALLOCLIM, ax
		mov	cs:CONFBOT, ax
		les	di, es:[di+12h]	; [es:di+SYSI_BUF]
		mov	word ptr es:[di+4], 0 ;	[es:di+BUFFINF.Dirty_Buff_Count]
		mov	word ptr es:[di], 0 ; [es:di+BUFFINF.Buff_Queue]
		mov	es:[di+2], cx	; [es:di+BUFFINF.Buff_Queue+2]
					; cx = [top_of_cdss]
		mov	es, cx
		xor	ax, ax
		mov	di, ax
		mov	es:[di], ax	; [es:di+buffinfo.buf_next],0
		mov	es:[di+2], ax	; [es:di+buffinfo.buf_prev],0
		mov	word ptr es:[di+4], 0FFh ; [es:di+buffinfo.buf_ID],00FFh
					; free buffer,clear flag
		mov	word ptr es:[di+6], 0 ;	[es:di+buffinfo.buf_sector]
		mov	word ptr es:[di+8], 0 ;	[es:di+buffinfo.buf_sector+2]
		pop	di
		pop	es
		push	cs
		pop	ds
		assume ds:SYSINIT
		call	TempCDS		; set up cdss so re_init and sysinit
					; can make disk	system calls
					; tempcds trashes ds
		mov	ds, cs:def_php	; retrieve pointer to PSP returned by DOSINIT
		assume ds:nothing
		call	far ptr	70h:89Bh ; call	DOSBIODATASEG:re_init
		sti
		cld
		mov	bx, cs
		sub	bx, 10h
		mov	es, bx
		assume es:nothing
		xor	si, si
		mov	di, si
		mov	cx, 128
		rep movsw
		mov	word ptr es:36h, es ; [es:PDB.JFN_POINTER+2],es	; Relocate
		mov	ah, 50h
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	dx, offset int24 ; set up int 24h handler
		mov	ax, 2524h
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		cmp	toomanydrivesflag, 0
		jz	short no_err
		mov	dx, offset TooManyDrivesMsg ; "WARNING!	Logical	drives past Z: exist a"...
		call	print

no_err:					; ...
		pop	ds
		assume ds:nothing
		mov	dl, cs:DEFAULT_DRIVE
		or	dl, dl
		jz	short nodrvset
		dec	dl
		mov	ah, 0Eh
		int	21h		; DOS -	SELECT DISK
					; DL = new default drive number	(0 = A,	1 = B, etc.)
					; Return: AL = number of logical drives

nodrvset:				; ...
		push	ds
		sub	ax, ax
		mov	ds, ax		; 0 ; ROMBIOS data area
		assume ds:nothing
		mov	ax, ds:46Ch	; Counter for Interrupt	1Ah
					; timer	tick count (18.2 ticks per second)
		pop	ds
		assume ds:nothing
		mov	cs:_timer_lw_, ax
		mov	word ptr cs:Magicbackdoor, offset NullBackdoor
		mov	word ptr cs:Magicbackdoor+2, cs
		call	AllocFreeMem	; get the largest free block from DOS
		call	MagicPreload	; **** PRE-LOAD	MAGICDRV!!! ****
		or	ax, ax
		jnz	short PreloadFailed
		mov	es, cs:area
		assume es:nothing
		mov	bx, cs:memhi
		sub	bx, cs:area
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		mov	ax, es
		dec	ax
		mov	es, ax
		assume es:nothing
		mov	word ptr es:1, 8 ; [es:arena_owner], 8 ; set impossible	owner
		mov	word ptr es:8, 4453h ; [es:arena_name],'SD' ; System Data
		mov	ax, es		; get Magicdrv arena
		add	ax, es:3	; get MCB length
		inc	ax		; get addr of next MCB
		les	si, cs:DOSINFO	; get to arena header
		assume es:nothing
		mov	es:[si-2], ax	; store	that
		jmp	short ProcessConfig
; ---------------------------------------------------------------------------

PreloadFailed:				; ...
		mov	ah, 49h		; Dealloc ; free the block if no load
		mov	es, cs:area
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed

ProcessConfig:				; ...
		call	doconf
		cmp	cs:runhigh, 0
		jz	short dont_install_stub
		mov	es, cs:CURRENT_DOS_LOCATION
		xor	ax, ax
		call	cs:dos_segreinit
		jmp	short do_multi_pass
; ---------------------------------------------------------------------------

dont_install_stub:			; ...
		xor	bx, bx
		call	MovDOSLo
		mov	ax, 1
		mov	es, cs:CURRENT_DOS_LOCATION
		call	cs:dos_segreinit

do_multi_pass:				; ...
		call	AllocFreeMem
		mov	bx, 0		; magic	backdoor to place int hooks
		call	cs:Magicbackdoor
		inc	cs:multi_pass_id
		call	multi_pass
		call	ShrinkUMB
		call	UnlinkUMB
		inc	cs:multi_pass_id
		call	multi_pass
		call	MagicPostload
		call	endfile
		call	MagicSetCdss
		mov	ax, 70h
		mov	es, ax
		assume es:nothing
		mov	es:SysinitPresent, 0
		test	cs:install_flag, 1
		jz	short dolast
		inc	cs:multi_pass_id
		call	multi_pass

dolast:					; ...
		cmp	cs:runhigh, 0FFh
		jnz	short _@@_
		call	LoadDOSHiOrLo

_@@_:					; ...
		cmp	cs:runhigh, 0
		jz	short ConfigDone
		call	CPMHack

ConfigDone:				; ...
		mov	cs:donotshownum, 1
		mov	es, cs:area
		assume es:nothing
		mov	ah, 49h		; DEALLOC ; free allocated memory for command.com
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		test	cs:install_flag, 2 ; has_installed
		jz	short skip_free_sysinitbase ; no
		push	es
		push	bx
		mov	es, cs:old_area
		mov	bx, cs:impossible_owner_size
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		mov	ax, es
		dec	ax
		mov	es, ax		; point	to arena
		assume es:nothing
		mov	word ptr es:1, 8 ; [es:ARENA.OWNER],8 ;	set impossible owner
		mov	word ptr es:8, 4453h ; [es:ARENA.NAME],'SD' ; System Data
		pop	bx
		pop	es
		assume es:nothing

skip_free_sysinitbase:			; ...
		cmp	cs:runhigh, 0
		jz	short _@@@_
		call	InstVDiskHeader	; Install VDISK	header (allocates some mem from	DOS)

_@@@_:					; ...
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	config_cmd, 0	; set special code for query_user
		call	query_user	; to issue the AUTOEXEC	prompt
		jnb	short process_autoexec ; we should process autoexec normally
		or	bQueryOpt, 4	; set "skip all" flag
		call	disable_autoexec ; no, we should disable it

process_autoexec:			; ...
		call	CheckQueryOpt
		mov	cl, byte ptr command_line ; "\x02/P"
		mov	ch, 0
		inc	cx
		mov	si, offset command_line	; "\x02/P"
		add	si, cx
		mov	byte ptr [si], 0Dh ; cr-terminate command line

retry:					; ...
		mov	dx, offset commnd ; "\\COMMAND.COM"
		push	dx		; save pointer to file name
		mov	bx, 0FFFFh	; get biggest piece (second time gets it)
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short memerrjx	; oooops!
		mov	es, ax
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	bp, bx
		mov	bx, MEMORY_SIZE	; get location of end of memory
		mov	ax, cs		; get location of beginning of sysinit
		mov	cx, config_envlen
		jcxz	short no_env	; use config_wrkseg only if there's env data
		mov	ax, config_wrkseg

no_env:					; ...
		sub	bx, ax
		add	bx, 11h		; add the sysinit php
		sub	bp, bx		; sub sysinit size from	amount of free memory
		jb	short memerrjx	; if there isn't even this much memory, give up
		mov	ax, 3D00h
		stc
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short comerr
		mov	bx, ax
		cmp	newcmd,	0	; was a	new shell selected?
		jnz	short skip_validation ;	yes
		mov	dx, offset retry-4 ; SYSINIT:0835h
		mov	cx, 4
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		cmp	byte ptr retry-4, 0E9h
		jnz	short comerr
		cmp	byte ptr retry-1, 64h ;	COMMAND.COM Version 6.20  (not 6.21!)
					; ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
		jnz	short comerr

skip_validation:			; ...
		xor	cx, cx
		xor	dx, dx
		mov	ax, 4202h
		stc
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		jb	short comerr
		add	ax, 0Fh		; convert size in dx:ax	to para	in ax
		adc	dx, 0		; round	up size	for conversion to para
		call	_off_to_para
		mov	cl, 12
		shl	dx, cl		; low nibble of	dx to high nibble
		or	ax, dx		; ax is	now # of para for file
		add	ax, 10h		; 100h byte php
		cmp	ax, bp		; will command fit in available	mem?
		jb	short okld	; jump if yes.

memerrjx:				; ...
		mov	dx, offset badmem ; "\r\nConfiguration too large for memory\"...
		call	print
		jmp	short continue
; ---------------------------------------------------------------------------

okld:					; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		push	cs
		pop	es
		assume es:SYSINIT
		mov	bx, offset EXEC0_ENVIRON ; offset COMEXE
					; point	to exec	block
		pop	dx
		mov	cx, config_envlen
		jcxz	short no_envdata
		mov	cx, config_wrkseg

no_envdata:				; ...
		mov	[bx], cx	; set segments
					; [bx+EXEC0.ENVIRON],cx
		mov	word ptr [bx+4], cs ; [bx+EXEC0.COM_LINE+2],cs
		mov	word ptr [bx+8], cs ; [bx+EXEC0.5C_FCB+2],cs
		mov	word ptr [bx+0Ch], cs ;	[bx+EXEC0.6C_FCB+2],cs
		mov	ax, 4B00h	; (EXEC<<8)
		stc
		int	21h		; DOS -	2+ - LOAD OR EXECUTE (EXEC)
					; DS:DX	-> ASCIZ filename
					; ES:BX	-> parameter block
					; AL = subfunc:	load & execute program
		push	cs
		pop	ds
		push	dx

comerr:					; ...
		cmp	byte ptr commnd4, 0 ; "\\DOS\\COMMAND.COM"
		jz	short comerr2	; all defaults exhausted, print	err msg
		cmp	newcmd,	0
		jz	short continue	; don't print err msg for defaults just yet

comerr2:				; ...
		mov	dx, offset badcom ; "Command Interpreter"
		call	badfil

continue:				; ...
		pop	dx
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		add	al, 'A'
		mov	dl, al		; dl ==	default	drive letter
		mov	si, offset commnd2 ; "\\COMMAND.COM"
		cmp	newcmd,	0	; if a SHELL= was given
		jnz	short do_def2	; then try the 2nd alternate;
		mov	byte ptr [si], 0 ; otherwise, the default SHELL= was tried,
		jmp	short do_def3	; which	is the same as our 2nd alt, so skip it
; ---------------------------------------------------------------------------

do_def2:				; ...
		cmp	byte ptr [si], 0 ; has 2nd alternate been tried?
		jnz	short do_alt	; no

do_def3:				; ...
		mov	si, offset commnd3 ; "\\MSDOS\\COMMAND.COM"
		cmp	byte ptr [si], 0 ; has 3rd alternate been tried?
		jnz	short do_alt	; no
		mov	si, offset commnd4 ; "\\DOS\\COMMAND.COM"
		cmp	byte ptr [si], 0 ; has 4th alternate been tried?
		jnz	short do_alt	; no
		push	dx
		mov	dx, offset badcomprmpt ; "Enter	correct	name of	Command	Interpret"...
		call	print
		pop	dx		; recover default drive	letter in dl

request_input:				; ...
		mov	ah, 2		; STD_CON_OUTPUT
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		push	dx
		mov	dl, '>'         ; 3Eh
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		mov	bl, tmplate+1	; [tmplate] = max. chars buffer	can hold = 64
		mov	bh, 0
		mov	byte ptr commnd[bx], 0Dh ; "\\COMMAND.COM"
		mov	dx, offset tmplate
		mov	ah, 0Ah		; STD_CON_STRING_INPUT
		int	21h		; DOS -	BUFFERED KEYBOARD INPUT
					; DS:DX	-> buffer
		mov	dx, offset crlfm ; "\r\n$"
		call	print
		pop	dx
		mov	bl, tmplate+1
		or	bl, bl		; was anything typed?
		jz	short request_input
		mov	newcmd,	1	; disable validation for user-specified	binaries
		mov	byte ptr commnd[bx], 0 ; NULL-terminate	it before execing it
		mov	word ptr command_line, 0D00h ; "\x02/P"
		jmp	short do_exec	; ...
; ---------------------------------------------------------------------------

do_alt:					; ...
		push	ds
		pop	es
		mov	newcmd,	0	; force	validation for alternate binaries
		mov	di, offset commnd ; "\\COMMAND.COM"

do_alt1:				; ...
		lodsb			; copy the alternate, zapping it as we go
		mov	byte ptr [si-1], 0 ; so	that we	know it's been tried
		stosb
		or	al, al
		jnz	short do_alt1
		mov	di, offset command_line	; "\x02/P"
		cmp	byte ptr [si+2], ':'
		jnz	short do_alt2
		mov	[si+1],	dl	; stuff	default	drive into alt.	command	line

do_alt2:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short do_alt2
		mov	byte ptr [di-1], 0Dh ; cr
		mov	dae_flag, 0
		call	disable_autoexec
		call	CheckQueryOpt

do_exec:				; ...
		jmp	retry

; =============== S U B	R O U T	I N E =======================================


AllocFreeMem	proc near		; ...
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	cs:area, ax
		mov	cs:memhi, ax
		retn
AllocFreeMem	endp

; ---------------------------------------------------------------------------
DOSLOMSG	db 'HMA not available: Loading DOS low',0Dh,0Ah,'$' ; ...
FEmsg		db 'Fatal Error: Cannot allocate Memory for DOS',0Dh,0Ah,'$' ; ...

; =============== S U B	R O U T	I N E =======================================


LoadDOSHiOrLo	proc near		; ...
		call	TryToMovDOSHi	; Try moving it	into HMA
		jb	short LdngLo	; If that don't work...
		retn
; ---------------------------------------------------------------------------

LdngLo:					; ...
		push	cs
		pop	ds
		mov	ah, 9
		mov	dx, offset DOSLOMSG ; "HMA not available: Loading DOS low\r\n$"
		int	21h		; DOS -	PRINT STRING
					; DS:DX	-> string terminated by	"$"
		mov	bx, 1		; use int 21 alloc for mem
		call	MovDOSLo
		mov	es, cs:CURRENT_DOS_LOCATION ; give dos its temporary loc.
		assume es:nothing
		xor	ax, ax
		call	cs:dos_segreinit
		mov	cs:runhigh, 0	; mark that we are running lo
		retn
LoadDOSHiOrLo	endp


; =============== S U B	R O U T	I N E =======================================


TryToMovDOSHi	proc near		; ...
		call	MovDOSHi
		jb	short ttldhx
		mov	es, cs:CURRENT_DOS_LOCATION ; give dos its temporary loc.
		xor	ax, ax		; ax = 0 --> install stub
		call	cs:dos_segreinit
		mov	cs:runhigh, 1
		clc

ttldhx:					; ...
		retn
TryToMovDOSHi	endp


; =============== S U B	R O U T	I N E =======================================


MovDOSHi	proc near		; ...
		call	AllocHMA	; did we get HMA?
		jb	short mdhx	; no
		mov	ax, 0FFFFh	; yes, HMA seg = 0ffffh
		mov	es, ax
		assume es:nothing
		call	MovBIOS		; First	move BIOS into HMA
		mov	cx, cs:hi_doscod_size ;	when it	is in HMA
		call	MovDOS		; and move it
		call	SaveFreeHMAPtr
		clc

mdhx:					; ...
		retn
MovDOSHi	endp


; =============== S U B	R O U T	I N E =======================================


MovDOSLo	proc near		; ...
		call	AllocMemForDOS	; incestuosly!
		mov	es, ax		; pass the segment to MovBIOS
		assume es:nothing
		call	MovBIOS
		mov	cx, cs:lo_doscod_size ;	DOS code size when loaded
		call	MovDOS
		retn
MovDOSLo	endp


; =============== S U B	R O U T	I N E =======================================


MovBIOS		proc near		; ...
		mov	ds, cs:temp_bcode_seg
		assume ds:nothing
		mov	si, 30h		; BCODE_START
		mov	di, si
		mov	cx, 1A70h	; BCODE_END
		sub	cx, si		; size of BIOS
		shr	cx, 1		; Both the labels are para aligned
		rep movsw
		push	es
		push	di		; save end of BIOS
		mov	ax, es
		mov	cs:BCodeSeg, ax	; save it for later use
		call	dword ptr cs:_seg_reinit_ptr ; far call	to seg_reinit
					; call far [cs:seg_reinit_ptr]
		pop	di		; get back end of BIOS
		pop	es
		retn
MovBIOS		endp


; =============== S U B	R O U T	I N E =======================================


MovDOS		proc near		; ...
		push	es
		push	di
		lds	si, dword ptr cs:dosinit
		rep movsb
		pop	bx		; get back offset into which DOS was moved
		mov	ax, cs:dosinit	; get the offset at which DOS wants to run
		sub	ax, bx
		call	_off_to_para
		pop	bx		; get the segment at which we moved DOS	into
		sub	bx, ax		; Adjust segment
		mov	cs:CURRENT_DOS_LOCATION, bx ; and save it
		retn
MovDOS		endp


; =============== S U B	R O U T	I N E =======================================


AllocMemForDOS	proc near		; ...

; FUNCTION CHUNK AT 12BD SIZE 00000001 BYTES

		mov	ax, 1A70h	; BCODE_END
		sub	ax, 30h		; BCODE_START
					; BCODE_END-BCODE_START	= BIOS code size
		add	ax, cs:lo_doscod_size
		add	ax, 0Fh
		call	_off_to_para	; convert to para
		or	bx, bx		; can we use int 21h for alloc ?
		mov	bx, ax
		jz	short update_arena ; no
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short FatalErr
		sub	ax, 3		; Take care ORG	30h of BIOS code
		mov	es, ax
		mov	word ptr es:21h, 8 ; [es:20h+ARENA.OWNER],08h
		mov	word ptr es:28h, 4353h ; 'SC' ; mark it as system code area
		retn
; ---------------------------------------------------------------------------

update_arena:				; ...
		push	ds
		push	di
		push	cx
		push	dx
		lds	di, cs:DOSINFO	; get ptr to DOS var
		dec	di
		dec	di		; Arena	head is	immediately before sysvar
		mov	es, word ptr [di] ; es = arena head
		mov	cx, es:3	; [es:ARENA.SIZE] ; total low mem size
		cmp	cx, bx		; is it	sufficient ?
		jb	short FatalErr	; no, fatal error
		mov	dl, es:0	; [es:ARENA.SIGNATURE]
		mov	ax, es
		add	ax, bx		; ax = new arena head
		mov	[di], ax	; store	it in DOS data area
		mov	ds, ax
		mov	ds:0, dl	; [ARENA.SIGNATURE] ; type of arena
		mov	word ptr ds:1, 0 ; [ARENA.OWNER],0 ; free
		sub	cx, bx		; size of the new block
		mov	ds:3, cx	; [ARENA.SIZE],cx ; store it in	the arena
		mov	ax, es		; return seg to	the caller
		sub	ax, 3		; Take care ORG	30h of BIOS code
		pop	dx
		pop	cx
		pop	di
		pop	ds
		retn
; ---------------------------------------------------------------------------

FatalErr:				; ...
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	dx, offset FEmsg ; "Fatal Error: Cannot	allocate Memory	for"...
		mov	ah, 9
		int	21h		; DOS -	PRINT STRING
					; DS:DX	-> string terminated by	"$"
		jmp	stall
AllocMemForDOS	endp


; =============== S U B	R O U T	I N E =======================================


AllocHMA	proc near		; ...
		push	ds
		mov	ax, 70h		; DOSBIODATASEG	; BIOSDATA segment
		mov	ds, ax
		assume ds:nothing
		call	IsXMSLoaded
		jnz	short grabhma_error
		mov	ax, 4310h
		int	2Fh		; - Multiplex -	XMS - GET DRIVER ADDRESS
					; Return: ES:BX	-> driver entry	point
		mov	word ptr ds:xms, bx
		mov	word ptr ds:xms+2, es
		mov	ah, 1		; request HMA
		mov	dx, 0FFFFh
		call	ds:xms		; call far [xms]
		dec	ax
		jz	short allocHMA_1 ; error if not	able to	allocate HMA
		mov	ah, 88h
		int	15h		; Get Extended Memory Size
					; Return: CF clear on success
					; AX = size of memory above 1M in K
		cmp	ax, 64		; less than 64 K of hma	?
		jb	short grabhma_error

allocHMA_1:				; ...
		mov	ah, 5		; localenableA20
		call	ds:xms
		dec	ax
		jnz	short grabhma_error ; error if couldn't enable A20
		call	IsVDiskInstalled
		jz	short grabhma_error ; yes, we cant use HMA
		mov	ax, 0FFFFh
		mov	es, ax
		assume es:nothing
		mov	word ptr es:10h, 1234h ; see if	we can really read/write there
		cmp	word ptr es:10h, 1234h
		jnz	short grabhma_error ; don't try to load there if XMS lied
		clc
		pop	ds
		assume ds:nothing
		retn
; ---------------------------------------------------------------------------

grabhma_error:				; ...
		stc
		pop	ds
		retn
AllocHMA	endp


; =============== S U B	R O U T	I N E =======================================


IsXMSLoaded	proc near		; ...
		mov	ax, 4300h
		int	2Fh		; - Multiplex -	XMS - INSTALLATION CHECK
					; Return: AL = 80h XMS driver installed
					; AL <>	80h no driver
		cmp	al, 80h		; XMS installed?
		retn
IsXMSLoaded	endp

; ---------------------------------------------------------------------------

FTryToMovDOSHi:				; ...
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	ds
		push	es
		cmp	cs:runhigh, 0FFh
		jnz	short _ftymdh_1
		call	TryToMovDOSHi

_ftymdh_1:				; ...
		pop	es
		assume es:nothing
		pop	ds
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retf
; ---------------------------------------------------------------------------
StartVDHead	dd 0			; ...
					; link to next device driver
		dw 8000h		; device attribute
		dw 0			; strategy routine offset
		dw 0			; interrupt routine offset
		db 1			; number of units
		db 7 dup(0)		; reserved area
VDiskSig1	db 'VDISK'              ; ...
		db '  V3.3'             ; vdisk label ; VLEN1 equ ($-VDiskSig1)
		db 15 dup(0)		; pad
		dw 0			; bits 0-15 of free HMA
		db 11h			; bits 16-23 of	free HMA (1M + 64K)
VDInt19		db 0EAh			; jmp to old vector
OldVDInt19	dw 2 dup(0)		; ...
VDiskHMAHead	db 0, 0, 0		; ...
					; EndVDHead
					; non-bootable disk
VDiskSig2	db 'VDISK'              ; ...
		db '3.3'                ; VLEN2 equ ($-VDiskSig2)
					; OEM -	signature
		dw 128			; number of bytes/sector
		db 1			; sectors/cluster
		dw 1			; reserved sectors
		db 1			; number of FAT	copies
		dw 64			; number of root dir entries
		dw 512			; number of sectors
		db 0FEh			; media	descriptor
		dw 6			; number of sectors/FAT
		dw 8			; sectors per track
		dw 1			; number of heads
		dw 0			; number of hidden sectors
		dw 440h			; Start	of free	HMA in K (1M+64K)

; =============== S U B	R O U T	I N E =======================================


InstVDiskHeader	proc near		; ...
		xor	ax, ax		; EndVDiskHMAHead (SYSINIT:0BFCh)
		mov	ds, ax		; seg of int vect table
		assume ds:nothing
		mov	ax, word ptr ds:64h ; [19h*4]
		mov	cs:OldVDInt19, ax
		mov	ax, word ptr ds:66h ; [19h*4+2]
		mov	cs:OldVDInt19+2, ax
		mov	ah, 48h
		mov	bx, 4
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		dec	ax
		mov	es, ax
		mov	word ptr es:1, 8 ; [es:ARENA.OWNER],8 ;	owner =	System
		mov	word ptr es:8, 4353h ; [es:ARENA.NAME],'SC' ; System Code
		inc	ax
		mov	es, ax		; get back to allocated	memory
		cli			; no reboots at	this time
					; install new int 19 vector
		mov	word ptr ds:64h, 47 ; (VDInt19-StartVDHead)
					; 0BD7h-0BA8h =	2Fh = 47
		mov	word ptr ds:66h, ax
		mov	cx, 52		; (EndVDHead-StartVDHead)
		mov	si, offset StartVDHead ; SYSINIT:0BA8h
		xor	di, di
		push	cs
		pop	ds
		assume ds:SYSINIT
		cld
		rep movsb
		sti			; mov the HMA VDisk head into HMA
		push	di
		push	es
		mov	ax, 0FFFFh
		mov	es, ax
		assume es:nothing
		mov	di, 10h
		mov	cx, 32		; (EndVDiskHMAHead-VDiskHMAHead)
		mov	si, offset VDiskHMAHead	; SYSINIT:0BDCh
		rep movsb
		pop	di
		pop	es
		assume es:nothing
		retn
InstVDiskHeader	endp

; ---------------------------------------------------------------------------
dummy		db 8 dup(0)		; ...
					; bmove
gdt		db 8 dup(0)		; times	desc.size db 0
src_desc	dw 0FFFFh		; des <0ffffh,0,0,93h,0>
desc_lo_word	dw 0			; ...
desc_hi_byte	db 0			; ...
		db 93h
		dw 0
tgt_desc	dw 0FFFFh		; desc <0ffffh,0,10h,93h,0>  ; 1MB
					; desc.seg_lim
		dw 0			; desc.lo_word
		db 10h			; desc.hi_byte
		db 93h			; desc.acc_rights
		dw 0			; desc.reserved
rombios_code	db 8 dup(0)		; times	desc.size db 0
temp_stack	db 8 dup(0)		; times	desc.size db 0
ClrdVDISKHead	db 32 dup(0)		; ...

; =============== S U B	R O U T	I N E =======================================


ClrVDISKHeader	proc near		; ...
		in	al, 64h		; 8042 keyboard	controller status register
					; 7:  PERR    1=parity error in	data received from keyboard
					;    +----------- AT Mode ----------+------------ PS/2 Mode ------------+
					; 6: |RxTO    receive (Rx) timeout  | TO      general timeout (Rx or Tx)|
					; 5: |TxTO    transmit (Tx) timeout | MOBF    mouse output buffer full	|
					;    +------------------------------+-----------------------------------+
					; 4:  INH     0=keyboard communications	inhibited
					; 3:  A2      0=60h was	the port last written to, 1=64h	was last
					; 2:  SYS     distinguishes reset types: 0=cold	reboot,	1=warm reboot
					; 1:  IBF     1=input buffer full (keyboard can't accept data)
					; 0:  OBF     1=output buffer full (data from keyboard is available)
		test	al, 10h		; test bit 4 - Is keyboard inhibited?
		jnz	short ClrVDISKok ; no, go do block move
		cmp	word ptr cs:sys_model_byte, 19F8h ; check for TORTUGA models
		jz	short ClrVDISKno ; do not use INT 15h block move code
					; (while 8042 is disabled)
		cmp	word ptr cs:sys_model_byte, 9FCh ; Check for PS/2 30-286 model
		jnz	short ClrVDISKok

ClrVDISKno:				; ...
		retn
; ---------------------------------------------------------------------------

ClrVDISKok:				; ...
		push	es
		mov	ax, cs
		mov	dx, ax
		mov	cl, 12
		shr	dx, cl		; dx = higher 4	bits of	the segment number
					;    = segment number /	4096 (=	byte address / 65536)
		mov	cl, 4
		shl	ax, cl		; ax = (lower 12 bits of the segment number)*16
		add	ax, offset ClrdVDISKHead
		adc	dl, 0		; dl:ax	= 24 bit linear	address
		mov	cs:desc_lo_word, ax
		mov	cs:desc_hi_byte, dl
		mov	cx, 16		; 16 words
		push	cs
		pop	es
		assume es:SYSINIT
		mov	si, offset dummy ; offset bmove
		mov	ah, 87h
		int	15h		; EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)
					; CX = number of words to move,	ES:SI -> global	descriptor table
					; Return: CF set on error, AH =	status
		pop	es
		assume es:nothing
		retn
ClrVDISKHeader	endp


; =============== S U B	R O U T	I N E =======================================


SaveFreeHMAPtr	proc near		; ...
		mov	bx, es
		mov	ax, 0FFFFh	; HMA segment
		sub	ax, bx
		add	di, 15		; para round
		and	di, 0FFF0h
		mov	cl, 4
		shl	ax, cl
		sub	di, ax
		push	ds
		mov	ax, 70h		; DOSBIODATASEG	; BIOSDATA segment
		mov	ds, ax
		assume ds:nothing
		mov	ds:FreeHMAPtr, di ; BIOSDATA:08F7h
		mov	ds:inHMA, 0FFh	; BIOSDATA:000Dh
		pop	ds
		assume ds:nothing
		retn
SaveFreeHMAPtr	endp


; =============== S U B	R O U T	I N E =======================================


IsVDiskInstalled proc near		; ...
		xor	ax, ax
		mov	ds, ax
		assume ds:nothing
		mov	ds, ds:4Eh	; [13h*4+2]
		assume ds:nothing
		mov	si, 12h		; VDiskSig1-StartVDHead
		mov	cx, 5		; VLEN1
		push	cs
		pop	es
		assume es:SYSINIT
		mov	di, offset VDiskSig1 ; "VDISK"
		repe cmpsb
		jz	short ivdins_retn
		mov	ax, 0FFFFh
		mov	ds, ax
		assume ds:nothing
		mov	si, 13h		; 10h+(VDiskSig2-VDiskHMAHead)
		mov	di, offset VDiskSig2 ; "VDISK"
		mov	cx, 5
		repe cmpsb

ivdins_retn:				; ...
		retn
IsVDiskInstalled endp


; =============== S U B	R O U T	I N E =======================================


CPMHack		proc near		; ...
		push	ds
		mov	cx, 0FFFFh
		mov	es, cx
		assume es:nothing
		xor	cx, cx
		mov	ds, cx
		assume ds:nothing
		mov	si, 0C0h
		mov	di, 0D0h
		mov	cx, 5
		cld
		rep movsb		; move 5 bytes from 0:C0h to FFFFh:D0h
		pop	ds
		assume ds:nothing
		retn
CPMHack		endp


; =============== S U B	R O U T	I N E =======================================


_off_to_para	proc near		; ...
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
		retn
_off_to_para	endp


; =============== S U B	R O U T	I N E =======================================


TempCDS		proc near		; ...
		les	di, ds:DOSINFO
		assume es:nothing
		mov	cl, es:[di+20h]	; [es:di+SYSI_NUMIO]
		xor	ch, ch		; (cx) = # of block devices
		mov	es:[di+21h], cl	; [es:di+SYSI_NCDS] ; one CDS per device
		mov	al, cl
		mov	ah, 88		; curdirlen ; curdir_list.size
		mul	ah
		call	ParaRound
		mov	si, ds:top_of_cdss
		sub	si, ax
		mov	es:[di+18h], si	; [es:di+SYSI_CDS+2]
		mov	ax, si
		mov	word ptr es:[di+16h], 0	; [es:di+SYSI_CDS]
					; set address of CDS list
		lds	si, es:[di]	; lds si,[es:di+SYSI_DPB]
					; (ds:si) = address of first DPB
		mov	es, ax
		xor	di, di		; (es:di) = address of 1st CDS
TempCDS		endp


; =============== S U B	R O U T	I N E =======================================


fooset		proc near		; ...
		mov	ax, word ptr cs:DirStrng ; "A:\"
		stosw			; setup	the root as the	curdir
		call	get_dpb_for_drive_al ; get dpb for drive in dpb
					; (ds:si) = address of DPB
					;    (si) = -1 if no drive
		mov	ax, word ptr cs:DirStrng+2 ; "\",0
		stosw
		inc	byte ptr cs:DirStrng ; "A:\"
		xor	ax, ax
		push	cx
		mov	cx, 63		; curdir_list.cdir_flags - 4
		rep stosb		; zero out rest	of CURDIR_TEXTs
					; (ax) = 0
					; (es:di) = CURDIR_FLAGS in the	CDS records
					; (ds:si) = Next DPB (-1 if none)
		cmp	si, 0FFFFh	; -1
		jz	short fooset_zero ; don't have any physical drive.
		cmp	cs:fake_floppy_drv, 1
		jnz	short normcds	; machine has floppy drives
		cmp	byte ptr [si], 1 ; cmp [si+DPB.drive],1
					; if dpb_drive = 0 (A) or 1 (B).
		ja	short normcds
		mov	cl, 3		; the next dbp pointer
		rep stosw		; ax should be zero here
		pop	cx
		jmp	short get_next_dpb
; ---------------------------------------------------------------------------

fooset_zero:				; ...
		mov	cl, 3
		rep stosw
		pop	cx
		jmp	short get_next_dpb ; jmp short fincds
; ---------------------------------------------------------------------------

normcds:				; ...
		pop	cx
		cmp	byte ptr [si+8], 0 ; [si+DPB.FAT_COUNT]	; non fat system?
		jz	short etnormcds	; yes. set curdir_flags	to 0. ax = 0 now.
		mov	ax, 4000h	; curdir_inuse ; else,fat system.
					; set the flag to curdir_inuse.

etnormcds:				; ...
		stosw			; curdir_flags
		mov	ax, si
		stosw			; curdir_devptr
		mov	ax, ds
		stosw

get_next_dpb:				; ...
		mov	ax, 0FFFFh	; entry	point for fake_fooset_zero
					; mov ax,-1
		stosw			; curdir_id
		stosw			; curdir_id
		stosw			; curdir_user_word
		mov	ax, 2		; curdir_end
		stosw
		mov	al, 0		; clear	out 7 bytes (curdir_type,
		stosb
		stosw			; curdir_ifs_hdr,curdir_fsda)
		stosw
		stosw
		loop	fooset
		mov	byte ptr cs:DirStrng, 'A' ; "A:\",0
		retn
fooset		endp


; =============== S U B	R O U T	I N E =======================================


get_dpb_for_drive_al proc near		; ...
		lds	si, cs:DOSINFO	; point	to first DPB
		lds	si, [si]	; (ds:si) = address of first DPB
		sub	al, 'A'

get_dpb_for_drive_1:			; ...
		cmp	al, [si]	; cmp al,[si+DPB.DRIVE]	; match?
		jz	short got_dpb_for_drive
		lds	si, [si+19h]	; lds si,[si+DPB.NEXT_DPB]
		cmp	si, 0FFFFh
		jnz	short get_dpb_for_drive_1 ; loop until hit end of DPBs

got_dpb_for_drive:			; ...
		retn
get_dpb_for_drive_al endp


; =============== S U B	R O U T	I N E =======================================


endfile		proc near		; ...
		push	ds		; Build	DOS structures
		mov	ax, 70h		; DOSBIODATASEG
		mov	ds, ax
		assume ds:nothing
		cmp	ds:multrk_flag,	0 ; multrk_off1
					; multrack= command entered?
		jnz	short multrk_flag_done
		or	ds:multrk_flag,	80h ; or [multrk_flag],multrk_on

multrk_flag_done:			; ...
		pop	ds
		assume ds:nothing
		mov	ax, cs:CONFBOT
		mov	cs:ALLOCLIM, ax
		push	cs
		pop	ds
		assume ds:SYSINIT
		call	round
		mov	al, cs:FILES
		sub	al, 5
		jbe	short dofcbs
		push	ax
		mov	al, 'F'         ; devmark_files
		call	setdevmark	; set devmark for sfts (files)
		pop	ax
		xor	ah, ah		; do not use cbw instruction!
					; it does sign extend.
		mov	bx, cs:memlo
		mov	dx, cs:memhi
		lds	di, cs:DOSINFO	; get pointer to dos data
		assume ds:nothing
		lds	di, [di+4]	; lds di,[di+SYSI_SFT] ; ds:di points to sft
		mov	[di], bx	; [di+SF.SFLink],bx
		mov	[di+2],	dx	; [di+SF.SFLink+2],dx ;	set pointer to new sft
		push	cs
		pop	ds
		assume ds:SYSINIT
		les	di, dword ptr cs:memlo ; point to new sft
		mov	word ptr es:[di], 0FFFFh ; mov word [es:di+SF.SFLink],-1
		mov	es:[di+4], ax	; mov [es:di+SF.SFCount],ax
		mov	bl, 59		; SF_ENTRY.size
		mul	bl
		mov	cx, ax		; ax = number of bytes to clear
		add	cs:memlo, ax	; allocate memory
		mov	ax, 6
		add	cs:memlo, ax	; remember the header too
		or	cs:setdevmarkflag, 2 ; for_devmark
		call	round		; check	for mem	error before the stosb
		add	di, ax		; ax = 6
		xor	ax, ax
		rep stosb		; clean	out the	stuff

dofcbs:					; ...
		push	cs
		pop	ds
		call	round
		mov	al, 'X'         ; devmark_fcbs
		call	setdevmark
		mov	al, cs:FCBS
		xor	ah, ah		; do not use cbw instruction!
					; it does sign extend.
		mov	bx, cs:memlo
		mov	dx, cs:memhi
		lds	di, cs:DOSINFO	; get pointer to dos data
		assume ds:nothing
		mov	[di+1Ah], bx	; [di+SYSI_FCB]
		mov	[di+1Ch], dx	; [di+SYSI_FCB+2] ; set	pointer	to new table
		mov	bl, cs:KEEP
		xor	bh, bh
		mov	[di+1Eh], bx	; [di+SYSI_KEEP]
		push	cs
		pop	ds
		assume ds:SYSINIT
		les	di, dword ptr memlo ; point to new table
		mov	word ptr es:[di], 0FFFFh ; [es:di+SF.SFLink],-1
		mov	es:[di+4], ax	; [es:di+SF.SFCount]
		mov	bl, 59		; SF_ENTRY.size
		mov	cx, ax
		mul	bl
		add	memlo, ax	; ax = number of bytes to clear
		mov	ax, 6		; SF.size-2
		add	memlo, ax	; remember the header too
		or	setdevmarkflag,	2 ; for_devmark
		call	round		; check	for mem	error before the stosb
		add	di, ax		; skip over header
		mov	al, 'A'

fillloop:				; ...
		push	cx		; save count
		mov	cx, 59		; number of bytes to fill
		cld
		rep stosb		; filled
		mov	word ptr es:[di-3Bh], 0	; [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_ref_count]
		mov	word ptr es:[di-26h], 0	; [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position]
		mov	word ptr es:[di-24h], 0	; [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position+2]
		pop	cx
		loop	fillloop
		cmp	buffers, 0FFFFh	; -1 ; has buffers been	already	set?
		jz	short dodefaultbuff
		jmp	dobuff		; the user entered the buffers=.
; ---------------------------------------------------------------------------

dodefaultbuff:				; ...
		mov	h_buffers, 0	; default is no	heuristic buffers.
		mov	buffers, 2	; default to 2 buffers
		push	ax
		push	ds
		les	bp, cs:DOSINFO	; search through the dpb's
		les	bp, es:[bp+0]	; [es:bp+SYSI_DPB] ; get first dpb
		push	cs
		pop	ds

nextdpb:				; ...
		mov	bl, es:[bp+0]	; [es:bp+DPB.drive]
		inc	bl
		mov	ax, 4408h	; (IOCTL<<8)|8
		int	21h		; DOS -	2+ - IOCTL -
		or	ax, ax		; 0 = removable	disk, 1	= fixed	disk
		jnz	short nosetbuf	; ax is	nonzero	if disk	is nonremoveable
		xor	bx, bx		; get parameters of (removable)	drive
		mov	bl, es:[bp+0]	; [es:bp+DPB.drive]
		inc	bl
		mov	dx, offset devp_specialfunc
		mov	ax, 440Dh	; (IOCTL<<8)|GENERIC_IOCTL
		mov	cx, 860h	; (RAWIO<<8)|GET_DEVICE_PARAMETERS
		int	21h		; DOS -	2+ - IOCTL -
		jb	short nosetbuf	; get next dpb if driver doesn't support
					; generic ioctl
		mov	bx, devp_totalsecs ; [deviceparameters+15]
					; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
		mov	ax, devp_bps	; [deviceparameters+7]
					; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_BYTESPERSECTOR]
		xor	dx, dx
		mov	cx, 512		; scale	sector size in factor of 512 bytes
		div	cx
		mul	bx		; ax = #sectors	* size factor
		or	dx, dx		; just in case of large	floppies
		jnz	short setbuf
		cmp	ax, 720		; 720 sectors *	size factor of 1
		jbe	short nosetbuf

setbuf:					; ...
		mov	buffers, 3
		jmp	short chk_memsize_for_buffers ;	now check the memory size
					; for default buffer count
; ---------------------------------------------------------------------------

nosetbuf:				; ...
		cmp	word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB],-1
		jz	short chk_memsize_for_buffers
		les	bp, es:[bp+19h]	; les bp,[es:bp+DPB.NEXT_DPB]
		jmp	short nextdpb
; ---------------------------------------------------------------------------

chk_memsize_for_buffers:		; ...
		cmp	MEMORY_SIZE, 2000h ; 128kb
		jbe	short bufset
		mov	buffers, 5
		cmp	MEMORY_SIZE, 4000h ; 256kb
		jbe	short bufset
		mov	buffers, 10
		cmp	MEMORY_SIZE, 8000h ; 512kb
		jbe	short bufset
		mov	buffers, 15

bufset:					; ...
		pop	ds
		assume ds:nothing
		pop	ax

dobuff:					; ...
		lds	bx, cs:DOSINFO	; ds:bx	-> sysinitvar
		mov	ax, cs:buffers
		mov	[bx+3Fh], ax	; [bx+SYSI_BUFFERS] ; set sysi_buffers
		mov	ax, cs:h_buffers
		mov	[bx+41h], ax	; [bx+SYSI_BUFFERS+2]
		lds	bx, [bx+12h]	; [bx+SYSI_BUF]	; now, ds:bx ->	buffinfo
		call	round		; get [memhi]:[memlo]
		mov	al, 'B'         ; devmark_buf
		call	setdevmark
		push	ds		; save buffer info. ptr.
		push	bx
		call	set_buffer
		pop	bx		; restore buffer info. ptr.
		pop	ds
		cmp	cs:h_buffers, 0	; set the secondary buffer if specified
		jz	short xif16
		call	round
		mov	cx, cs:memlo
		mov	[bx+6],	cx	; [bx+BUFFINF.Cache_ptr]
		mov	cx, cs:memhi
		mov	[bx+8],	cx	; [bx+BUFFINF.Cache_ptr+2]
		mov	cx, cs:h_buffers
		mov	[bx+10], cx	; [bx+BUFFINF.Cache_count]
		mov	ax, 512		; 512 bytes
		mul	cx
		mov	cs:memlo, ax
		or	cs:setdevmarkflag, 2 ; for_devmark
		call	round

xif16:					; ...
		call	round		; buf1
		push	ax
		mov	ax, 'L'         ; devmark_cds
		call	setdevmark
		pop	ax
		les	di, cs:DOSINFO
		mov	cl, es:[di+20h]	; [es:di+SYSI_NUMIO]
		cmp	cl, cs:NUM_CDS
		jnb	short gotncds	; user setting must be at least	numio
		mov	cl, cs:NUM_CDS

gotncds:				; ...
		xor	ch, ch
		mov	es:[di+21h], cl	; [es:di+SYSI_NCDS]
		mov	ax, cs:memhi
		mov	es:[di+18h], ax	; [es:di+SYSI_CDS+2]
		mov	ax, cs:memlo
		mov	es:[di+16h], ax	; [es:di+SYSI_CDS]
		mov	al, cl
		mov	ah, 88		; curdirlen ; curdir_list.size
		mul	ah
		call	ParaRound
		add	cs:memhi, ax
		or	cs:setdevmarkflag, 2 ; for_devmark
		call	round		; check	for mem	error before initializing
		lds	si, es:[di]	; lds si,[es:di+SYSI_DPB] ; [es:di+0]
		les	di, es:[di+16h]	; les di,[es:di+SYSI_CDS] ; [es:di+22]
		call	fooset
		push	cs
		pop	ds
		assume ds:SYSINIT
		cmp	stack_addr, 0FFFFh ; -1	; has the user entered "stacks=" command?
		jz	short doinstallstack ; then install as specified by the	user
		cmp	sys_scnd_model_byte, 0 ; pc1,xt	has the	secondary model	byte = 0
		jnz	short doinstallstack ; other model should have default stack of	9,128
		cmp	sys_model_byte,	0FEh ; pc1, pc/xt or pc	portable ?
		jnb	short skipstack

doinstallstack:				; ...
		mov	ax, stack_count	; stack_count =	0?
		or	ax, ax		; then,	stack size must	be 0 too.
		jz	short skipstack	; don't install stack.
		call	round		; dynamic relocation of	stack code.
					; [memhi] = seg. for stack code
					; [memlo] = 0
		mov	al, 'S'         ; devmark_stk
		call	setdevmark
		mov	ax, memhi
		mov	es, ax		; es ->	seg. the stack code is going to	move.
		push	cs
		pop	ds
		xor	si, si		; ! we know that stack code is at the beginning	of sysinit.
		xor	di, di
		mov	cx, offset _SYSINIT ; offset endstackcode = offset _SYSINIT
					; SYSINIT:0269h
		mov	memlo, cx
		call	round		; have enough space for	relocation?
		rep movsb
		push	ds
		mov	ax, 70h		; DOSBIODATASEG
		mov	ds, ax
		assume ds:nothing
		mov	ds:NextStack, offset nextentry ; [BIOSDATA:NextStack],
					;  offset SYSINIT:nextentry (SYSINIT:0010h)
		mov	ds:NextStack+2,	es
		mov	ax, cs:memlo
		mov	cs:stack_addr, ax ; set	for stack area initialization
		mov	word ptr ds:IT_StackLoc, ax ; pass it as Instance Data,	too
		mov	ax, cs:memhi	; this will be used by stack_init routine.
		mov	cs:stack_addr+2, ax
		mov	word ptr ds:IT_StackLoc+2, ax
		mov	ax, 8		; entrysize
		add	ax, cs:stack_size
		mul	cs:stack_count
		mov	ds:IT_StackSize, ax ; pass through to Instance Table
		pop	ds
		assume ds:nothing
		call	ParaRound
		add	cs:memhi, ax
		or	cs:setdevmarkflag, 2 ; for_devmark
					; to set the devmark_size for stack by round routine.
		call	round		; check	for memory error before	continuing
		call	stackinit	; initialize hardware stack.
					; cs=ds=sysinitseg,es=relocated	stack code & data

skipstack:				; ...
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	al, FILES
		xor	ah, ah		; do not use cbw instruction!
					; it does sign extend.
		mov	cx, ax
		xor	bx, bx		; close	standard input
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	bx, 2		; close	everybody but standard output
					; need output so we can	print message
					;  in case we can't get new one open.

rcclloop:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		inc	bx
		loop	rcclloop
		mov	dx, offset condev ; "CON"
		mov	al, 2
		mov	ah, 3Dh		; open con for read/write
		stc			; set for possible int 24
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 2 - read & write
		jnb	short goaux
		call	badfil
		jmp	short goaux2
; ---------------------------------------------------------------------------

goaux:					; ...
		push	ax
		mov	bx, 1		; close	standard output
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	ax
		mov	bx, ax		; new device handle
		mov	ah, 45h		; XDUP ; dup to	1, stdout
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 45h		; XDUP ; dup to	2, stderr
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate

goaux2:					; ...
		mov	dx, offset auxdev ; "AUX"
		mov	al, 2		; read/write access
		call	open_dev
		mov	dx, offset prndev ; "PRN"
		mov	al, 1		; write	only
		call	open_dev
		push	ax
		push	bx
		push	dx
		push	es
		mov	al, 0FFh	; reset	h/w by writing to port
		mov	dx, 2F2h	; get starting address
		out	dx, al		; out 02f2h,0ffh
		inc	dx
		out	dx, al
		inc	dx
		out	dx, al
		inc	dx
		out	dx, al
		inc	dx
		out	dx, al
		inc	dx
		out	dx, al		; out 02f7h,0ffh
		mov	ax, 0F000h	; get machine type
		mov	es, ax
		assume es:nothing
		cmp	byte ptr es:0FFFEh, 0FCh ; is it a at type machine
		jz	short startrearm ; *if AT no need to check
		mov	ah, 0C0h
		int	15h		; SYSTEM - GET CONFIGURATION
					; (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
		jb	short finishrearm ; *jmp if old	rom
		test	byte ptr es:[bx+5], 40h	; [es:bx+ROMBIOS_DESC.bios_sd_featurebyte1],
					; ScndIntController
		jz	short finishrearm

startrearm:				; ...
		mov	al, 0FFh	; write	any pattern to port
		mov	dx, 6F2h	; get starting address
		out	dx, al
		inc	dx
		out	dx, al		; out 06f3h,0ffh
		inc	dx
		out	dx, al		; out 06f4h,0ffh
		inc	dx
		inc	dx
		out	dx, al		; out 06f6h,0ffh
		inc	dx
		out	dx, al		; out 06f7h,0ffh

finishrearm:				; ...
		pop	es
		assume es:nothing
		pop	dx
		pop	bx
		pop	ax

set_sysinit_base:			; sysinit_base will be established
		push	ax		; in the secure	area of	lower memory
					; when it handles the first install= command.
					; if sysinit module (in	high memory) has been broken,
					; then "memory error..." message is displayed
					; by sysinit_base
		mov	ax, memhi
		sub	ax, area
		mov	impossible_owner_size, ax
		mov	al, 'T'
		call	setdevmark
		pop	ax
		mov	di, memhi
		mov	es, di
		mov	word ptr sysinit_base_ptr+2, di	; save this entry for the next use.
		xor	di, di
		mov	word ptr sysinit_base_ptr, di ;	es:di -> destination.
		mov	si, offset sysinit_base	; ds:si	-> source code to be relocated.
		mov	cx, 129		; end_sysinit_base-sysinit_base	; 129
		add	memlo, cx
		or	cs:setdevmarkflag, 2 ; for_devmark
		call	round
		rep movsb
		mov	sysinit_ptr, offset sysinitptr ; returning address from
					; sysinit_base back to sysinit
		mov	sysinit_ptr+2, cs
		or	install_flag, 2	; for_devmark
		call	round
		mov	bx, memhi
		mov	ax, area
		mov	old_area, ax	; save [area]
		mov	es, ax		; calc what we needed
		sub	bx, ax
		mov	ah, 4Ah		; SETBLOCK
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		push	es
		mov	ax, es
		dec	ax
		mov	es, ax		; point	to arena
		assume es:nothing
		mov	word ptr es:1, 8 ; [es:ARENA.OWNER],8 ;	set impossible owner
		mov	word ptr es:8, 4453h ; [es:ARENA.NAME],'SD' ; System Data
		pop	es
		assume es:nothing
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h		; allocate the rest of the memory
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	memhi, ax	; start	of the allocated memory
		mov	memlo, 0	; to be	used next.
		mov	es, ax
		assume es:nothing
		mov	bx, CONFBOT
		sub	bx, ax		; confbot - memhi
		dec	bx		; make a room for the memory block id.
		dec	bx		; make sure!
		mov	ah, 4Ah		; this will free (confbot to top of memory)
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h		; allocate (confbot to top of memory)
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	area, ax	; save allocated memory	segment.
					; need this to free this area for command.com.
		mov	es, memhi
		assume es:nothing
		mov	ah, 49h		; free allocated memory
					; free (memhi to confbot(=area))
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		retn
endfile		endp


; =============== S U B	R O U T	I N E =======================================


do_install_exec	proc near		; ...
		push	si		; EXEC a program being loaded via the
					; "install=" mechanism in config.sys
		push	es
		push	ds
		pop	es
		assume es:SYSINIT
		pop	ds		; es->sysinitseg,ds->confbot seg
		assume ds:nothing
		mov	dx, si		; ds:dx->file name,0 in	config.sys image.
		xor	cx, cx
		cld
		mov	cs:ldexec_start, 20h ; ' ' ; clear out the parm area
		mov	di, offset ldexec_parm

installfilename:			; ...
		lodsb			; skip the file	name
					; al = ds:si; si++
		cmp	al, 0
		jz	short got_installparm
		jmp	short installfilename
; ---------------------------------------------------------------------------

got_installparm:			; ...
		lodsb			; copy the parameters to ldexec_parm
		mov	es:[di], al
		cmp	al, 0Ah		; lf ; line feed?
		jz	short done_installparm
		inc	cl		; # of char. in	the parm.
		inc	di
		jmp	short got_installparm
; ---------------------------------------------------------------------------

done_installparm:			; ...
		mov	cs:ldexec_line,	cl ; length of the parm.
		cmp	cl, 0		; if no	parm,then
		jnz	short install_seg_set ;	let the	parm area
		mov	cs:ldexec_start, 0Dh ; cr ; starts with	cr.

install_seg_set:			; ...
		mov	cs:0, 0		; make a null environment segment
		mov	ax, cs		; by overlap jmp instruction of	sysinitseg.
		mov	cx, ax
		cmp	cs:config_envlen, 0
		jz	short no_envdata2
		mov	cx, cs:config_wrkseg

no_envdata2:				; ...
		mov	cs:iexec_environ, cx ; [cs:instexe.exec0_environ]
					; set the environment seg.
		mov	cs:iexec_ldexec_line_seg, ax ; [cs:instexe.exec0_com_line+2]
					; set the seg.
		mov	cs:iexec_ldexec_5c_fcb_seg, ax ; [cs:instexe.exec0_5c_fcb+2]
		mov	cs:iexec_ldexec_6c_fcb_seg, ax ; [cs:instexe.exec0_6c_fcb+2]
		call	sum_up
		mov	es:checksum, ax	; save the value of the	sum
		xor	ax, ax
		mov	ah, 4Bh		; EXEC ; load/exec
		mov	bx, offset iexec_environ ; instexe ; es:bx -> parm block.
		push	es		; save es,ds for load/exec
		push	ds		; these	registers will be restored in sysinit_base.
		jmp	cs:sysinit_base_ptr ; jmp to sysinit_base to execute
do_install_exec	endp			; load/exec function and check sum.

; ---------------------------------------------------------------------------

sysinitptr:				; ...
		pop	si		; returning far	address	from sysinit_base
					; restore si for config.sys file.
		push	es
		push	ds
		pop	es
		assume es:nothing
		pop	ds		; now ds - sysinitseg, es - confbot
		jnb	short install_exit_ret
		push	si		; error	in loading the file for	install=.
		call	badload		; es:si-> path,filename,0.
		pop	si

install_exit_ret:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================


ParaRound	proc near		; ...
		add	ax, 15		; round	up length in paragraphs
					; 0Fh
		rcr	ax, 1
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
		retn
ParaRound	endp

; ---------------------------------------------------------------------------

sysinit_base:				; ...
		mov	word ptr cs:sysinit_base_ss, ss	; sysinit_base module
		mov	word ptr cs:sysinit_base_sp, sp
		int	21h		; load/exec dos	call
		mov	ss, word ptr cs:sysinit_base_ss
		assume ss:nothing
		mov	sp, word ptr cs:sysinit_base_sp
		pop	ds
		pop	es
		jb	short sysinit_base_end
		call	sum_up
		cmp	es:checksum, ax
		jz	short sysinit_base_end
		mov	ah, 9		; memory broken.
					; show "memory allocation error" message and stall.
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	dx, 102		; mem_alloc_err_msgx-sysinit_base ; 66h
		int	21h		; DOS -	PRINT STRING
					; DS:DX	-> string terminated by	"$"
; START	OF FUNCTION CHUNK FOR AllocMemForDOS

stall:					; ...
		hlt			; use HLT to minimize energy consumption
; END OF FUNCTION CHUNK	FOR AllocMemForDOS
; ---------------------------------------------------------------------------
		jmp	short stall
; ---------------------------------------------------------------------------

sysinit_base_end:			; ...
		jmp	dword ptr es:sysinit_ptr ; return back to sysinit module

; =============== S U B	R O U T	I N E =======================================


sum_up		proc near		; ...
		push	ds
		mov	ax, es:CONFBOT
		mov	ds, ax
		assume ds:nothing
		xor	si, si
		xor	ax, ax
		mov	cx, es:config_size ; if	config_size has	been broken, then this
					; whole	test better fail.
		shr	cx, 1		; make it a word count
		jz	short sum_sys_code ; when config.sys file not exist.

sum1:					; ...
		add	ax, [si]
		inc	si
		inc	si
		loop	sum1

sum_sys_code:				; ...
		mov	si, offset locstack ; 532h
					; starting after the stack.
					; this does not	cover the possible stack code!
		mov	cx, 58A0h	; SI_end (22688)
					; SI_end is the	label at the end of sysinit
					; from after_checksum to SI_end
		sub	cx, si
		shr	cx, 1

sum2:					; ...
		add	ax, es:[si]
		inc	si
		inc	si
		loop	sum2
		pop	ds
		retn
sum_up		endp

; ---------------------------------------------------------------------------
sysinit_base_ssx dw 0			; sysinit_base_ss equ $-sysinit_base ; 62
sysinit_base_spx dw 0			; sysinit_base_sp equ $-sysinit_base ; 64
mem_alloc_err_msgx db 0Dh,0Ah
		db 'Memory allocation error $'

; =============== S U B	R O U T	I N E =======================================


set_buffer	proc near		; ...
		xor	dl, dl		; input:
					;   ds:bx -> buffinfo.
					;   [memhi]:[memlo=0] =	available space	for the	hash bucket.
					;   singlebuffersize = buff header size	+ sector size
					; output:
					;   buffers Queue established.
					;   [memhi]:[memlo] = addr of the next available free space.
					;
					; assume buffers not in	HMA
		call	GetBufferAddr
		jz	short set_buff_1
		mov	dl, 1		; buffers in HMA

set_buff_1:				; ...
		mov	[bx], di	; [bx+BUFFINF.Buff_Queue] ; head of Buff Q
		mov	word ptr [bx+2], es ; [bx+BUFFINF.Buff_Queue+2]
		mov	word ptr [bx+4], 0 ; [bx+BUFFINF.Dirty_Buff_Count] ; set dirty_count to	0.
		mov	ax, di
		mov	cx, cs:buffers
		push	di		; remember first buffer

nxt_buff:				; ...
		call	set_buffer_info	; set buf_link,buf_id...
		mov	di, ax
		loop	nxt_buff
		sub	di, cs:singlebuffersize	; point	to last	buffer
		pop	cx		; get first buffer
		mov	es:[di], cx	; [es:di+buffinfo.buf_next] ; last->next = first
		xchg	cx, di
		mov	es:[di+2], cx	; [es:di+buffinfo.buf_prev] ; first->prev = last
		or	dl, dl		; In HMa ?
		jz	short set_buff_2 ; no
		mov	byte ptr [bx+0Ch], 1 ; mov byte	[bx+BUFFINF.Buff_In_HMA],1
		mov	ax, cs:memhi	; seg of scratch buff
		mov	word ptr [bx+0Dh], 0 ; [bx+BUFFINF.Lo_Mem_Buff]	; offset of scratch buff is 0
		mov	[bx+0Fh], ax	; mov [bx+BUFFINF.Lo_Mem_Buff+2],ax
		mov	ax, cs:singlebuffersize	; size of scratch buff
		sub	ax, 20		; bufinsiz ; buffer head not required

set_buff_2:				; ...
		add	cs:memlo, ax
		or	cs:setdevmarkflag, 2
		call	round
		retn
set_buffer	endp


; =============== S U B	R O U T	I N E =======================================


GetBufferAddr	proc near		; ...
		push	bx
		push	dx
		mov	ax, cs:singlebuffersize
		mul	cs:buffers
		add	ax, 0Fh		; 15
		and	ax, 0FFF0h	; ~15 ;	not 0Fh
		mov	bx, ax
		mov	ax, 4A02h	; ((multMULT<<8)+multMULTALLOCHMA)
		int	2Fh		; DOS 5+ - ALLOCATE HMA	SPACE
					;     AX = 4A02h
					;     BX = number of bytes
					; Return:
					;     ES:DI -> start of	allocated HMA block or FFFFh:FFFFh
					;     BX = number of bytes actually allocated (rounded up to next
					;	   paragraph for DOS 5.0 and 6.0)
					; Notes:
					;     this call	is not valid unless DOS	is loaded in the HMA (DOS=HIGH)
					;
					;     called by	Windows	3.1 DOSX.EXE
					;     supported	by Novell DOS 7
		cmp	di, 0FFFFh
		jnz	short got_hma
		mov	di, 0		; dont xor di,di Z flag	needed
		mov	es, cs:memhi

got_hma:				; ...
		pop	dx
		pop	bx
		retn
GetBufferAddr	endp


; =============== S U B	R O U T	I N E =======================================


set_buffer_info	proc near		; ...
		push	cs:buf_prev_off	; es:di	-> buffer header to be set.
					; ax = di
		pop	word ptr es:[di+2] ; [es:di+buffinfo.buf_prev]
		mov	cs:buf_prev_off, ax
		add	ax, cs:singlebuffersize	; adjust ax
		mov	es:[di], ax	; [es:di+buffinfo.buf_next]
		mov	word ptr es:[di+4], 0FFh ; [es:di+buffinfo.buf_ID]
					; new buffer free
		mov	word ptr es:[di+6], 0 ;	[es:di+buffinfo.buf_sector]
		mov	word ptr es:[di+8], 0 ;	[es:di+buffinfo.buf_sector+2]
		retn
set_buffer_info	endp


; =============== S U B	R O U T	I N E =======================================


stackinit	proc near		; ...
		push	ax		; ibmstack initialization routine
					; in - cs, ds -> sysinitseg,
					;      es -> relocated stack code & data.
		push	ds
		push	es
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		push	bp
		mov	ax, cs:stack_count
		mov	es:stackcount, ax
		mov	ax, ds:stack_size
		mov	es:stacksize, ax
		mov	ax, cs:stack_addr ; offset
		mov	es:stacks, ax
		mov	ax, cs:stack_addr+2
		mov	es:stacks+2, ax	; segment
		mov	bp, es:stacks	; "firstentry" will always be at stacks
					; the stacks will always immediately follow the	table entries
		mov	es:firstentry, bp
		mov	ax, 8		; entrysize
		mov	cx, es:stackcount
		mul	cx
		add	ax, bp
		mov	es:stackat, ax
		mov	bx, ax
		sub	bx, 2
		mov	di, es:stackat	; zero the entire stack	area to	start with
		mov	ax, es:stacksize
		mul	cx
		mov	cx, ax
		xor	ax, ax		; 0
		push	es
		pop	ds		; ds = relocated stack code seg.
		mov	es, ds:stacks+2	; get segment of stack area.
		cld
		rep stosb
		mov	cx, ds:stackcount ; loop for "count" times, building a table entry
					; cs = sysinitseg, ds =	relocated stack	code seg,
					; es = segment of stack	space
					; cx = number of entries
					; es:bp	=> base	of stacks - 2
					; es:bx	=> first table entry

buildloop:				; ...
		mov	byte ptr es:[bp+0], 0 ;	[es:bp+allocbyte],free
		mov	es:[bp+1], al	; [es:bp+intlevel]
					; ax = 0
		mov	es:[bp+2], ax	; [es:bp+savedsp]
		mov	es:[bp+4], ax	; [es:bp+savedss]
		add	bx, ds:stacksize
		mov	es:[bp+6], bx	; [es:bp+newsp]
		mov	es:[bx], bp
		add	bp, 8		; entrysize
		loop	buildloop
		sub	bp, 8		; entrysize
		mov	ds:lastentry, bp
		mov	ds:nextentry, bp
		push	ds
		mov	ax, 0F000h	; look at the model byte
		mov	ds, ax
		assume ds:nothing
		cmp	byte ptr ds:0FFFEh, 0F9h ; mdl_convert ; convertible?
		pop	ds
		assume ds:nothing
		jnz	short skip_disablenmis
		mov	al, 7		; disable convertible nmis
		out	72h, al		; CMOS Memory/RTC Index	Register (Extended RAM)

skip_disablenmis:			; ...
		xor	ax, ax
		mov	es, ax
		assume es:nothing
		cli

stkinit_02:				; Int 02h vector table offset
		mov	si, 8
		mov	di, offset int19old02
		mov	bx, offset old02
		mov	dx, offset int02
		call	new_init_loop

stkinit_08:				; Int 08h vector table offset
		mov	si, 20h
		mov	di, offset int19old08
		mov	bx, offset old08
		mov	dx, offset int08
		call	new_init_loop

stkinit_09:				; Int 09h vector table offset
		mov	si, 24h
		mov	di, offset int19old09
		mov	bx, offset old09
		mov	dx, offset int09
		call	new_init_loop

stkinit_70:				; Int 70h vector table offset
		mov	si, 1C0h
		mov	di, offset int19old70
		mov	bx, offset old70
		mov	dx, offset int70
		call	new_init_loop

stkinit_0A:				; 0Ah*4	; 40
		mov	si, 28h		; Int 0Ah vector table offset
		push	ds		; save relocated stack code segment
		lds	bx, es:[si]	; ds:bx	-> original interrupt handler
		push	ds
		pop	dx		; dx = segment value
		cmp	dx, 0
		jz	short int_0A_first
		cmp	byte ptr [bx], 0CFh ; does vector point	to an iret?
		jz	short int_0A_first
		cmp	word ptr [bx+6], 424Bh ; magic offset (see int&aa, msstack.inc)
		jz	short int_0A_not_first
		cmp	dx, 0F000h	; rom bios segment
		jnz	short int_0A_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_0A_first

int_0A_not_first:			; ...
		pop	ds		; not the first. we are	going to hook vector.
		mov	di, offset int19old0A ;	we have	to set old&aa for int19	handler	too.
		mov	bx, offset old0A ; pass	where to save original owner pointer
		mov	dx, offset int0A ; pass	where new handler is
		call	new_init_loop	; adjust the vector to new handler,
					; saving pointer to original owner.
		jmp	short stkinit_0B
; ---------------------------------------------------------------------------

int_0A_first:				; ...
		pop	ds		; the first. don't have to hook stack code.

stkinit_0B:				; ...
		mov	si, 2Ch		; Int 0Bh vector table offset
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_0B_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_0B_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_0B_not_first
		cmp	dx, 0F000h
		jnz	short int_0B_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_0B_first

int_0B_not_first:			; ...
		pop	ds
		mov	di, offset int19old0B
		mov	bx, offset old0B
		mov	dx, offset int0B
		call	new_init_loop
		jmp	short stkinit_0C
; ---------------------------------------------------------------------------

int_0B_first:				; ...
		pop	ds

stkinit_0C:				; ...
		mov	si, 30h		; Int 0Ch vector table offset
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_0C_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_0C_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_0C_not_first
		cmp	dx, 0F000h
		jnz	short int_0C_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_0C_first

int_0C_not_first:			; ...
		pop	ds
		mov	di, offset int19old0C
		mov	bx, offset old0C
		mov	dx, offset int0C
		call	new_init_loop
		jmp	short stkinit_0D
; ---------------------------------------------------------------------------

int_0C_first:				; ...
		pop	ds

stkinit_0D:				; ...
		mov	si, 34h		; Int 0Dh vector table offset
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_0D_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_0D_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_0D_not_first
		cmp	dx, 0F000h
		jnz	short int_0D_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_0D_first

int_0D_not_first:			; ...
		pop	ds
		mov	di, offset int19old0D
		mov	bx, offset old0D
		mov	dx, offset int0D
		call	new_init_loop
		jmp	short stkinit_0E
; ---------------------------------------------------------------------------

int_0D_first:				; ...
		pop	ds

stkinit_0E:				; ...
		mov	si, 38h		; 0Eh*4	; Int 0Eh vector table offset
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_0E_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_0E_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_0E_not_first
		cmp	dx, 0F000h
		jnz	short int_0E_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_0E_first

int_0E_not_first:			; ...
		pop	ds
		mov	di, offset int19old0E
		mov	bx, offset old0E
		mov	dx, offset int0Eh
		call	new_init_loop
		jmp	short stkinit_72
; ---------------------------------------------------------------------------

int_0E_first:				; ...
		pop	ds

stkinit_72:				; ...
		mov	si, 1C8h	; 72h*4	; 456
					; Int 72h vector table offset
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_72_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_72_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_72_not_first
		cmp	dx, 0F000h
		jnz	short int_72_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_72_first

int_72_not_first:			; ...
		pop	ds
		mov	di, offset int19old72
		mov	bx, offset old72
		mov	dx, offset int72
		call	new_init_loop
		jmp	short stkinit_73
; ---------------------------------------------------------------------------

int_72_first:				; ...
		pop	ds

stkinit_73:				; ...
		mov	si, 1CCh	; 73h*4	; 460
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_73_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_73_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_73_not_first
		cmp	dx, 0F000h
		jnz	short int_73_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_73_first

int_73_not_first:			; ...
		pop	ds
		mov	di, offset int19old73
		mov	bx, offset old73
		mov	dx, offset int73
		call	new_init_loop
		jmp	short stkinit_74
; ---------------------------------------------------------------------------

int_73_first:				; ...
		pop	ds

stkinit_74:				; ...
		mov	si, 1D0h	; 74h*4	; 464
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_74_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_74_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_74_not_first
		cmp	dx, 0F000h
		jnz	short int_74_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_74_first

int_74_not_first:			; ...
		pop	ds
		mov	di, offset int19old74
		mov	bx, offset old74
		mov	dx, offset int74
		call	new_init_loop
		jmp	short stkinit_76
; ---------------------------------------------------------------------------

int_74_first:				; ...
		pop	ds

stkinit_76:				; ...
		mov	si, 1D8h	; 76h*4	; 472
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_76_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_76_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_76_not_first
		cmp	dx, 0F000h
		jnz	short int_76_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_76_first

int_76_not_first:			; ...
		pop	ds
		mov	di, offset int19old76
		mov	bx, offset old76
		mov	dx, offset int76
		call	new_init_loop
		jmp	short stkinit_77
; ---------------------------------------------------------------------------

int_76_first:				; ...
		pop	ds

stkinit_77:				; ...
		mov	si, 1DCh	; mov si,77h*4 ; 476
					; Int 77h vector table offset
		push	ds		; save relocated stack code segment
		lds	bx, es:[si]	; ds:bx	-> original interrupt handler
		push	ds
		pop	dx		; dx = segment value
		cmp	dx, 0
		jz	short int_77_first
		cmp	byte ptr [bx], 0CFh ; does vector point	to an iret?
		jz	short int_77_first
		cmp	word ptr [bx+6], 424Bh ; magic offset (see int&aa, msstack.inc)
		jz	short int_77_not_first
		cmp	dx, 0F000h	; rom bios segment
		jnz	short int_77_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_77_first

int_77_not_first:			; ...
		pop	ds		; not the first. we are	going to hook vector.
		mov	di, offset int19old77 ;	we have	to set old&aa for int19	handler	too.
		mov	bx, offset old77 ; pass	where to save original owner pointer
		mov	dx, offset int77 ; pass	where new handler is
		call	new_init_loop	; adjust the vector to new handler,
					; saving pointer to original owner.
		jmp	short int_77_end
; ---------------------------------------------------------------------------

int_77_first:				; ...
		pop	ds		; the first. don't have to hook stack code.

int_77_end:				; ...
		push	ds
		mov	ax, 0F000h
		mov	ds, ax
		assume ds:nothing
		cmp	byte ptr ds:0FFFEh, 0F9h ; mdl_convert ; pc convertible?
		pop	ds
		assume ds:nothing
		jnz	short skip_enablenmis
		mov	al, 27h		; enable convertible nmis
		out	72h, al		; CMOS Memory/RTC Index	Register (Extended RAM)

skip_enablenmis:			; ...
		sti
		mov	ax, 70h		; DOSBIODATASEG
		mov	ds, ax
		assume ds:nothing
		mov	ds:int19sem, 1	; indicate that	int 19h
					; initialization is complete
		pop	bp
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	es
		pop	ds
		assume ds:nothing
		pop	ax
		retn
stackinit	endp


; =============== S U B	R O U T	I N E =======================================


new_init_loop	proc near		; ...
		mov	ax, es:[si]	; new stack initialization
					; (dx =	new handler offset,
					;  bx =	original handler saving	addr,
					;  si =	int vector table offset
					;  di =	int19old?? field offset
					;		  -in DOSBIOSDATASEG-
					;  es =	zero, segid of vector table
					;  ds =	relocated stack	code segment)
		mov	[bx], ax
		mov	ax, es:[si+2]
		mov	[bx+2],	ax
		push	ds
		mov	ax, 70h		; DOSBIODATASEG
		mov	ds, ax
		assume ds:nothing
		mov	ax, es:[si]
		mov	[di], ax
		mov	ax, es:[si+2]
		mov	[di+2],	ax
		pop	ds
		assume ds:nothing
		mov	es:[si], dx
		mov	word ptr es:[si+2], ds
		retn
new_init_loop	endp


; =============== S U B	R O U T	I N E =======================================


setdevmark	proc near		; ...
		push	es		; set the devmark for mem command.
					; in:
					;   [memhi] - the address to place devmark
					;   [memlo] = 0
					;   al = id for	devmark_id
					; out:
					;   devmark established.
					;   the	address	saved in cs:[devmark_addr]
					;   [memhi] increase by	1.
		push	cx
		mov	cx, cs:memhi
		mov	cs:devmark_addr, cx
		mov	es, cx
		mov	es:0, al
		inc	cx
		mov	es:1, cx
		pop	cx
		pop	es
		inc	cs:memhi
		retn
setdevmark	endp

; ---------------------------------------------------------------------------
config_envlen	dw 0			; ...
					; when config_wrkseg is	being used as
					; a scratch env, this is its length
config_wrkseg	dw 0			; ...
					; config work area (above confbot)
					; segment of work area
config_cmd	db 0			; ...
					; current config cmd
					; (with	CONFIG_OPTION_QUERY bit	intact)
config_multi	db 0			; ...
					; non-zero if multi-config config.sys
multdeviceflag	db 0			; ...
devmark_addr	dw 0			; ...
					; segment address for devmark.
setdevmarkflag	db 0			; ...
					; flag used for	devmark
driver_units	db 0			; ...
					; total	unitcount for driver
ems_stub_installed db 0			; (not used)
badparm_ptr	dd 0			; ...
					; badparm_off equ badparm_ptr
					; badparm_seg equ badparm_ptr+2
_$P_ORDINAL	dw 0			; ...
					; Operand ordinal save area
_$P_RC		dw 0			; ...
					; Return code from parser
_$P_SI_Save	dw 0			; ...
					; Pointer of command buffer
_$P_DX		dw 0			; ...
					; Return result	buffer address
_$P_Terminator	db 0			; ...
					; Terminator code (ASCII)
_$P_DBCSEV_OFF	dw 0			; ...
					; Offset of DBCS EV
_$P_DBCSEV_SEG	dw 0			; ...
					; Segment of DBCS EV
_$P_Flags	db 0			; ...
					; Parser internal flags
					; %define _$P_Flags1 _$P_Flags
					;	  to reference 1st byte	flags
					; %define _$P_Flags2 _$P_Flags+1
					;	  to reference 2nd byte	flags only
_$P_Flags2	db 0			; ...
_$P_SaveSI_Cmpx	dw 0			; ...
					; save si for later use	by complex
_$P_KEYorSW_Ptr	dw 0			; ...
					; points next to "=" or	":" code
_$P_Save_EOB	dw 0			; ...
					; save pointer to EOB
_$P_Found_SYNONYM dw 0			; ...
					; es:@ points to found synonym
_$P_STRING_BUF	db 128 dup(0)		; ...
					; Pick a operand from command line
_$P_Char_CAP_Ptr db 0FFh		; ...
					; info id
		dw 0			; offset of char case map table
		dw 0			; segment of char case map table
_$P_FileSp_Char	db '[]|<>+=;"'          ; ...
					; delimitters of file spec
					; _$P_FileSp_Len equ $-_$P_FileSp_Char
_$P_err_flag	db 0			; ...
					; flag set if filespec parsing error
					; was detected

; =============== S U B	R O U T	I N E =======================================


SysParse	proc near		; ...
		mov	word ptr cs:_$P_Flags, 0 ; Clear all internal flags
		cld			; confirm forward direction
		mov	cs:_$P_ORDINAL,	cx ; save operand ordinal
		mov	cs:_$P_RC, 0	; _$P_No_Error ; assume	no error
		mov	cs:_$P_Found_SYNONYM, 0	; initalize synonym pointer
		mov	cs:_$P_DX, 0	; The table of special chars _$P_FileSp_Char
					; should be initialized	on every entry to SysParse
		mov	word ptr cs:_$P_FileSp_Char, 5D5Bh ; "[]|<>+=;\""
		mov	word ptr cs:_$P_FileSp_Char+2, 3C7Ch
		mov	word ptr cs:_$P_FileSp_Char+4, 2B3Eh
		mov	word ptr cs:_$P_FileSp_Char+6, 3B3Dh
		call	_$P_Skip_Delim	; Move si to 1st non white space
		jnb	short _$P_Start	; If EOL is not	encountered, do	parse
		mov	ax, 0FFFFh	; _$P_RC_EOL  ;	set exit code to -1
		push	bx
		mov	bx, es:[di]	; [es:di+_$P_PARMS_Blk.PARMSX_Address]
					; Get the PARMSX address to
		cmp	cl, es:[bx]	; [es:bx+_$P_PARMSX_Blk.MinP]
					; check	ORDINAL	to see if the minimum
		jnb	short _$P_Fin	; positional found.
		mov	ax, 2		; $P_Op_Missing	; If no, set exit code to missing operand

_$P_Fin:				; ...
		pop	bx
		jmp	_$P_Single_Exit	; return to the	caller
; ---------------------------------------------------------------------------

_$P_Start:				; ...
		mov	cs:_$P_SaveSI_Cmpx, si ; save ptr to command line for later use
					; by complex quoted string or file spec.
		push	bx
		push	di
		push	bp
		lea	bx, _$P_STRING_BUF ; set buffer	to copy	from command string
		test	cs:_$P_Flags2, 20h ; _$P_Extra ; 3/9 extra delimiter encountered ?
		jnz	short _$P_Pack_End ; 3/9 if yes, no need to copy

_$P_Pack_Loop:				; ...
		lodsb			; Pick a operand from buffer
		call	_$P_Chk_Switch	; Check	switch character
		jb	short _$P_Pack_End_BY_EOL ; if carry set found delimiter type slash,
					; need backup si, else continue
		call	_$P_Chk_EOL	; Check	EOL character
		jz	short _$P_Pack_End_BY_EOL ; need backup	si
		call	_$P_Chk_Delim	; Check	delimiter
		jnz	short _$P_PL01	; If no, process next byte
		test	cs:_$P_Flags2, 20h ; _$P_Extra ; 3/9 If	yes and	white spec,
		jnz	short _$P_Pack_End_backup_si ; 3/9 then
		call	_$P_Skip_Delim	; skip subsequent white	space,too
		jmp	short _$P_Pack_End ; finish copy by placing NUL	at end
; ---------------------------------------------------------------------------

_$P_Pack_End_backup_si:			; ...
		test	cs:_$P_Flags2, 41h ; _$P_SW+_$P_equ
		jz	short _$P_Pack_End
		dec	si
		jmp	short _$P_Pack_End
; ---------------------------------------------------------------------------

_$P_PL01:				; ...
		mov	cs:[bx], al	; move byte to STRING_BUF
		cmp	al, 3Dh	; '='   ; _$P_Keyword ; if it is equal character,
		jnz	short _$P_PL00	; then
		or	cs:_$P_Flags2, 1 ; _$P_equ ; remember it in flag

_$P_PL00:				; ...
		inc	bx		; ready	to see next byte
		call	_$P_Chk_DBCS	; was it 1st byte of DBCS ?
		jnb	short _$P_Pack_Loop ; if no, process to	next byte
		lodsb
		mov	cs:[bx], al	; if yes, store	2nd byte of DBCS
		inc	bx		; update pointer
		jmp	short _$P_Pack_Loop ; process to next byte
; ---------------------------------------------------------------------------

_$P_Pack_End_BY_EOL:			; ...
		dec	si		; backup si pointer

_$P_Pack_End:				; ...
		mov	cs:_$P_SI_Save,	si ; save next pointer,	SI
		mov	byte ptr cs:[bx], 0 ; _$P_NULL ; put NULL at the end
		mov	cs:_$P_Save_EOB, bx ; keep the address for later use of	complex
		mov	bx, es:[di]	; [es:di+_$P_PARMS_Blk.PARMSX_Address]
					; get PARMSX address
		lea	si, _$P_STRING_BUF
		cmp	byte ptr cs:[si], 2Fh ;	'/' ; the operand begins w/ switch char ?
					; _$P_Switch
		jz	short _$P_SW_Manager ; if yes, process as switch
		cmp	byte ptr cs:[si], 22h ;	'"' ; _$P_DQuote  ; is it a string?
		jz	short _$P_Positional_Manager ; if so, process as one!
		test	cs:_$P_Flags2, 1 ; $P_equ ; the	operand	includes equal
		jnz	short _$P_Key_Manager ;	if yes,	process	as keyword

_$P_Positional_Manager:			; ...
		mov	al, es:[bx+1]	; else process as positional
					; get maxp
		xor	ah, ah		; ax = maxp
		cmp	cs:_$P_ORDINAL,	ax ; too many positional ?
		jnb	short _$P_Too_Many_Error ; if yes, set exit code to too	many
		mov	ax, cs:_$P_ORDINAL ; see what the current ordinal
		shl	ax, 1		; ax = ax*2
		inc	bx
		inc	bx		; add '2' to bx reg
					; now bx points	to 1st CONTROL
		add	bx, ax		; now bx points	to specified CONTROL address
		mov	bx, es:[bx]	; now bx points	to specified CONTROL itself
		call	_$P_Chk_Pos_Control ; Do process for positional
		jmp	short _$P_Return_to_Caller ; and return	to the caller
; ---------------------------------------------------------------------------

_$P_Too_Many_Error:			; ...
		mov	cs:_$P_RC, 1	; set exit code
		jmp	short _$P_Return_to_Caller ; and return	to the caller
; ---------------------------------------------------------------------------

_$P_SW_Manager:				; ...
		mov	al, es:[bx+1]	; [es:bx+_$P_PARMSX_Blk.MaxP] ;	get maxp
		xor	ah, ah		; ax = maxp
		inc	ax
		shl	ax, 1		; ax = (ax+1)*2
		add	bx, ax		; now bx points	to maxs
		mov	cl, es:[bx]
		xor	ch, ch		; cx = maxs
		or	cx, cx		; at least one switch ?
		jz	short _$P_SW_Not_Found ; no
		inc	bx		; now bx points	to 1st CONTROL address

_$P_SW_Mgr_Loop:			; ...
		push	bx
		mov	bx, es:[bx]	; bx points to Switch CONTROL itself
		call	_$P_Chk_SW_Control ; do	process	for switch
		pop	bx
		jnb	short _$P_Return_to_Caller ;
					; if the CONTROL is for	the switch, exit
		inc	bx
		inc	bx		;    add '2' to bx reg
					; else bx points to the	next CONTROL
		loop	_$P_SW_Mgr_Loop	; and loop

_$P_SW_Not_Found:			; ...
		mov	cs:_$P_RC, 3	; _$P_Not_In_SW
					; here no CONTROL for the switch has
		jmp	short _$P_Return_to_Caller
; ---------------------------------------------------------------------------

_$P_Key_Manager:			; ...
		mov	al, es:[bx+1]	; [es:bx+_$P_PARMSX_Blk.MaxP] ;	get maxp
		xor	ah, ah		; ax = maxp
		inc	ax
		shl	ax, 1		; ax = (ax+1)*2
		add	bx, ax		; now bx points	to maxs
		mov	al, es:[bx]
		xor	ah, ah		; ax = maxs
		shl	ax, 1
		inc	ax		; ax = ax*2+1
		add	bx, ax		; now bx points	to maxk
		mov	cl, es:[bx]
		xor	ch, ch		; cx = maxk
		or	cx, cx		; at least one keyword ?
		jz	short _$P_Key_Not_Found	; no
		inc	bx		; now bx points	to 1st CONTROL

_$P_Key_Mgr_Loop:			; ...
		push	bx
		mov	bx, es:[bx]	; bx points to keyword CONTROL itself
		call	_$P_Chk_Key_Control ; do process for keyword
		pop	bx
		jnb	short _$P_Return_to_Caller ;
					; if the CONTROL is for	the keyword, exit
		inc	bx
		inc	bx		;    add '2' to bx reg
					; else bx points to the	next CONTROL
		loop	_$P_Key_Mgr_Loop ; and loop

_$P_Key_Not_Found:			; ...
		mov	cs:_$P_RC, 4	; _$P_Not_In_Key
					; here no CONTROL for the keyword has

_$P_Return_to_Caller:			; ...
		pop	bp
		pop	di
		pop	bx
		mov	cx, cs:_$P_ORDINAL ; return next ordinal
		mov	ax, cs:_$P_RC	; return exit code
		mov	si, cs:_$P_SI_Save ; return next operand pointer
		mov	dx, cs:_$P_DX	; return result	buffer address
		mov	bl, cs:_$P_Terminator ;	return delimiter code found

_$P_Single_Exit:			; ...
		clc
		retn
SysParse	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_Pos_Control proc near		; ...
		push	ax
		mov	ax, es:[bx]	; [es:bx+_$P_Control_Blk.Match_Flag]
		test	ax, 2		; $P_Repeat ; repeat allowed ?
		jnz	short _$P_CPC00	; then do not increment	ORDINAL
		inc	cs:_$P_ORDINAL	; update the ordinal

_$P_CPC00:				; ...
		cmp	byte ptr cs:[si], 0 ; _$P_NULL ; no data ?
		jnz	short _$P_CPC01
		test	ax, 1		; _$P_Optional ; yes, then is it optional ?
		jnz	short _$P_CPC02
		mov	cs:_$P_RC, 2	; _$P_Op_Missing ; no, then error
		jmp	short _$P_CPC_Exit
; ---------------------------------------------------------------------------

_$P_CPC02:				; ...
		push	ax
		mov	al, 3		; _$P_String
		mov	ah, 0FFh	; _$P_No_Tag
					; if it	is optional return NULL
					; no item tag indication
		call	_$P_Fill_Result
		pop	ax
		jmp	short _$P_CPC_Exit
; ---------------------------------------------------------------------------

_$P_CPC01:				; ...
		call	_$P_Check_Match_Flags

_$P_CPC_Exit:				; ...
		pop	ax
		retn
_$P_Chk_Pos_Control endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_Key_Control proc near		; ...
		stc			; this logic works
					; when the KeySW is reset.
		retn
_$P_Chk_Key_Control endp


; =============== S U B	R O U T	I N E =======================================


_$P_Search_KEYorSW proc	near		; ...
		push	bp
		push	cx
		mov	cl, es:[bx+8]	; [es:bx+_$P_Control_Blk.nid] ;	Get synonym count
		xor	ch, ch		; and set it to	cx
		or	cx, cx		; No synonyms specified	?
		jz	short _$P_KEYorSW_Not_Found ; then indicate not	found by CY
		lea	bp, [bx+9]	; [bx+_$P_Control_Blk.KEYorSW]

_$P_KEYorSW_Loop:			; ...
		call	_$P_String_Comp	; compare string in buffer w/ the synonym
		jnb	short _$P_KEYorSW_Found	; If match, set	it to synonym pointer
		call	_$P_MoveBP_NUL	; else,	bp points to the next string
		loop	_$P_KEYorSW_Loop ; loop	nid times

_$P_KEYorSW_Not_Found:			; ...
		stc			; indicate not found in	synonym	list
		jmp	short _$P_KEYorSW_Exit ; and exit
; ---------------------------------------------------------------------------

_$P_KEYorSW_Found:			; ...
		mov	cs:_$P_Found_SYNONYM, bp ; set synonym pointer
		clc			; indicate found

_$P_KEYorSW_Exit:			; ...
		pop	cx
		pop	bp
		retn
_$P_Search_KEYorSW endp


; =============== S U B	R O U T	I N E =======================================


_$P_MoveBP_NUL	proc near		; ...
		cmp	byte ptr es:[bp+0], 0 ;	_$P_NULL
					; Increment BP that points
		jz	short _$P_MBP_Exit ; to	the synomym list
		inc	bp		; until
		jmp	short _$P_MoveBP_NUL ; NULL encountered.
					; _$P_MBP_Loop
; ---------------------------------------------------------------------------

_$P_MBP_Exit:				; ...
		inc	bp		; bp points to next to NULL
		retn
_$P_MoveBP_NUL	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_SW_Control proc	near		; ...
		or	cs:_$P_Flags2, 10h ; (Check if switch is supported)
					; _$P_SW_Cmp
					; Indicate switch for later string comparison
		call	_$P_Search_KEYorSW ; Search the	switch in the CONTROL block
		jb	short _$P_Chk_SW_Err0 ;	not found, then	try next CONTROL
		and	cs:_$P_Flags2, 0EFh ; and byte [cs:_$P_Flags2],0FFh-_$P_SW_Cmp
					; reset	the indicator previously set /switch
		push	ax
		mov	ax, cs:_$P_KEYorSW_Ptr
		sub	ax, si		; [si] = KEY or	SW
		add	cs:_$P_SaveSI_Cmpx, ax ; update	for complex list
		pop	ax
		mov	si, cs:_$P_KEYorSW_Ptr ; set si	at the end or colon
		cmp	byte ptr cs:[si], 0 ; _$P_NULL ; any data after	colon ?
		jnz	short _$P_CSW00	; if yes, process match	flags
		cmp	byte ptr cs:[si-1], ':' ; _$P_Colon
					; if no, the switch terminated by colon	?
		jnz	short _$P_Chk_if_data_required ;
					; if yes,
		mov	cs:_$P_RC, 9	; _$P_Syntax ; return syntax error
		jmp	short _$P_Chk_SW_Exit
; ---------------------------------------------------------------------------

_$P_Chk_if_data_required:		; ...
		cmp	word ptr es:[bx], 0 ; [es:bx+_$P_Control_Blk.Match_Flag]
					; should have data?
					; zero match flag means	switch followed	by nothing is OK
		jz	short _$P_Chk_SW_Exit ;	match flags not	zero so
					; should have something	if optional bit	is not on
		test	word ptr es:[bx], 1 ; _$P_Optional ; see if no value is	valid
		jnz	short _$P_Chk_SW_Exit ;	if so, then leave, else	yell
		mov	cs:_$P_RC, 2	; _$P_Op_Missing
					; return required operand missing
		jmp	short _$P_Chk_SW_Exit
; ---------------------------------------------------------------------------

_$P_CSW00:				; ...
		call	_$P_Check_Match_Flags ;	process	match flag
		clc			; indicate match
		jmp	short _$P_Chk_SW_Single_Exit
; ---------------------------------------------------------------------------

_$P_Chk_SW_Err0:			; ...
		stc			; not found in switch synonym list
		jmp	short _$P_Chk_SW_Single_Exit
; ---------------------------------------------------------------------------

_$P_Chk_SW_Exit:			; ...
		push	ax
		mov	al, 3		; _$P_String
		mov	ah, 0FFh	; _$ P_No_Tag
		call	_$P_Fill_Result	; set result buffer
		pop	ax
		clc

_$P_Chk_SW_Single_Exit:			; ...
		retn
_$P_Chk_SW_Control endp


; =============== S U B	R O U T	I N E =======================================


_$P_Fill_Result	proc near		; ...
		push	di
		mov	di, es:[bx+4]	; [es:bx+_$P_Control_Blk.Result_Buf]
					; di points to result buffer
		mov	cs:_$P_DX, di	; set returned result address
		mov	es:[di], al	; [es:di+_$P_Result_Blk.Type] ;	store type
		mov	es:[di+1], ah	; [es:di+_$P_Result_Blk.Item_Tag] ; store item tag
		push	ax
		mov	ax, cs:_$P_Found_SYNONYM
		mov	es:[di+2], ax	; [es:di+_$P_Result_Blk.SYNONYM_Ptr]
		pop	ax

_$P_RLT04:				;
		cmp	al, 1		; _$P_Number ; if number
		jnz	short _$P_RLT00	;
					; then store 32	bit

_$P_RLT02:				; ...
		mov	es:[di+4], dx	; [es:di+_$P_Result_Blk.Picked_Val]
		mov	es:[di+6], cx	; [es:di+_$P_Result_Blk.Picked_Val+2]
		jmp	short _$P_RLT_Exit
; ---------------------------------------------------------------------------

_$P_RLT00:				; ...
		cmp	al, 2		; _$P_List_Idx ; if list index
		jnz	short _$P_RLT01	;
					; then store list index
		mov	es:[di+4], dx	; [es:di+_$P_Result_Blk.Picked_Val]
		jmp	short _$P_RLT_Exit
; ---------------------------------------------------------------------------

_$P_RLT01:				; ...
		cmp	al, 7		; _$P_Date_F ; Date format ?
		jz	short _$P_RLT02
		cmp	al, 8		; _$P_Time_F ; Time format ?
		jz	short _$P_RLT02
		cmp	al, 6		; _$P_Drive ; drive format ?
		jnz	short _$P_RLT03
		mov	es:[di+4], dl	; [es:di+_$P_Result_Blk.Picked_Val]
					; store	drive number
		jmp	short _$P_RLT_Exit
; ---------------------------------------------------------------------------

_$P_RLT03:				; ...
		cmp	al, 4		; _$P_Complex ;	complex	format ?
		jnz	short _$P_RLT05
		mov	ax, cs:_$P_SaveSI_Cmpx ;
					; then get pointer in command buffer
		inc	ax		; skip left Parentheses
		mov	es:[di+4], ax	; [es:di+_$P_Result_Blk.Picked_Val]
					; store	offset
		mov	word ptr es:[di+6], ds ; [es:di+_$P_Result_Blk.Picked_Val+2]
					; store	segment
		jmp	short _$P_RLT_Exit
; ---------------------------------------------------------------------------

_$P_RLT05:				; ...
		mov	es:[di+4], si	; AL = 3, 5, or	9
					; [es:di+_$P_Result_Blk.Picked_Val]
					; store	offset of STRING_BUF
		mov	word ptr es:[di+6], cs ; [es:di+_$P_Result_Blk.Picked_Val+2]
					; store	segment	of STRING_BUF
		push	ax
		test	byte ptr es:[bx+2], 1 ;	[es:bx+_$P_Control_Blk.Function_Flag],
					; _$P_CAP_File
					; need CAPS by file table?
		jz	short _$P_RLT_CAP00
		mov	al, 4		; _$P_DOSTBL_File ; use	file upper case	table
		jmp	short _$P_RLT_CAP02
; ---------------------------------------------------------------------------

_$P_RLT_CAP00:				; ...
		test	byte ptr es:[bx+2], 2 ;	[es:bx+_$P_Control_Blk.Function_Flag],
					; _$P_CAP_Char
					; need CAPS by char table
		jz	short _$P_RLT_CAP01
		mov	al, 2		; _$P_DOSTBL_Char
					; use character	upper case table

_$P_RLT_CAP02:				; ...
		call	_$P_Do_CAPS_String ; process CAPS along	the table

_$P_RLT_CAP01:				; ...
		pop	ax
		test	byte ptr es:[bx+2], 10h	; [es:bx+_$P_Control_Blk.Function_Flag],
					; _$P_Rm_Colon
					; removing colon at end	?
		jz	short _$P_RLT_Exit
		call	_$P_Remove_Colon ; then	process	it.

_$P_RLT_Exit:				; ...
		pop	di
		retn
_$P_Fill_Result	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Check_Match_Flags proc near		; ...
		mov	cs:_$P_err_flag, 0 ; _$P_NULL ;	clear filespec error flag.
		push	ax
		mov	ax, es:[bx]	; [es:bx+_$P_Control_Blk.Match_Flag]
					; load match flag (16bit) to ax
		or	ax, ax		; test ax for zero
		jnz	short _$P_Mat
		push	ax
		push	bx
		push	dx
		push	di
		mov	cs:_$P_RC, 9	; _$P_Syntax
		mov	ah, 0FFh	; _$P_No_Tag
		mov	al, 3		; _$P_String
		call	_$P_Fill_Result
		pop	di
		pop	dx
		pop	bx
		pop	ax
		jmp	short _$P_Bridge
; ---------------------------------------------------------------------------

_$P_Mat:				; ...
		jmp	short _$P_Match03
; ---------------------------------------------------------------------------

_$P_Bridge:				; ...
		jmp	short _$P_Match_Exit
; ---------------------------------------------------------------------------
		nop			; 90h

_$P_Match03:				; ...
		test	ax, 8000h	; _$P_Num_Val ;	Numeric	value
		jz	short _$P_Match04
		mov	cs:_$P_RC, 0	; _$P_No_Error ; assume	no error
		call	_$P_Value	; do process
		cmp	cs:_$P_RC, 9	; _$P_Syntax ; if error, examine the next type
		jnz	short _$P_Match_Exit

_$P_Match04:				; ...
		test	ax, 4000h	; _$P_SNum_Val ; Signed	numeric	value
		jz	short _$P_Match05
		mov	cs:_$P_RC, 0	; _$P_No_Error ; assume	no error
		call	_$P_SValue	; do process
		cmp	cs:_$P_RC, 9	; _$P_Syntax ; if error, examine the next type
		jnz	short _$P_Match_Exit

_$P_Match05:				; ...
		test	ax, 100h	; _$P_Drv_Only ; Drive only
		jz	short _$P_Match06
		mov	cs:_$P_RC, 0	; _$P_No_Error ; assume	no error
		call	_$P_File_Format	; 1st, call file format
		call	_$P_Drive_Format ; check drive format, next
		cmp	cs:_$P_RC, 9	; _$P_Syntax ; if error, examine the next type
		jnz	short _$P_Match_Exit

_$P_Match06:				; ...
		test	ax, 200h	; _$P_File_Spc ; File spec
		jz	short _$P_Match07
		mov	cs:_$P_RC, 0	; _$P_No_Error ; assume	no error
		call	_$P_File_Format	; do process
		cmp	cs:_$P_RC, 9	; _$P_Syntax ; if error, examine the next type
		jnz	short _$P_Match_Exit

_$P_Match07:				; ...
		test	ax, 2000h	; _$P_Simple_S ; Simple	string
		jz	short _$P_Match_Exit
		mov	cs:_$P_RC, 0	; _$P_No_Error ; assume	no error
		call	_$P_Simple_String ; do process

_$P_Match_Exit:				; ...
		cmp	cs:_$P_err_flag, 1 ; _$P_error_filespec	; bad filespec ?
		jnz	short _$P_Match2_Exit ;	no, continue
		cmp	cs:_$P_RC, 0	; _$P_No_Error ; check for other errors	?
		jnz	short _$P_Match2_Exit ;	no, continue
		mov	cs:_$P_RC, 9	; _$P_Syntax ; set error flag

_$P_Match2_Exit:			; ...
		pop	ax
		retn
_$P_Check_Match_Flags endp


; =============== S U B	R O U T	I N E =======================================


_$P_Remove_Colon proc near		; ...
		push	ax
		push	si

_$P_RCOL_Loop:				; ...
		mov	al, cs:[si]	; get character
		or	al, al		; end of string	?
		jz	short _$P_RCOL_Exit ; if yes, just exit
		cmp	al, ':'         ; _$P_Colon ; is it colon ?
		jnz	short _$P_RCOL00
		cmp	byte ptr cs:[si+1], 0 ;	_$P_NULL
					; if so, next is NULL ?
		jnz	short _$P_RCOL00
		mov	byte ptr cs:[si], 0 ; _$P_NULL ; yes, remove colon
		jmp	short _$P_RCOL_Exit ; and exit.
; ---------------------------------------------------------------------------

_$P_RCOL00:				; ...
		call	_$P_Chk_DBCS	; if not colon,	then check if
					; DBCS leading byte.
		jnb	short _$P_RCOL01
		inc	si		; if yes, skip trailing	byte

_$P_RCOL01:				; ...
		inc	si		; si points to next byte
		jmp	short _$P_RCOL_Loop ; loop until NULL encountered
; ---------------------------------------------------------------------------

_$P_RCOL_Exit:				; ...
		pop	si
		pop	ax
		retn
_$P_Remove_Colon endp


; =============== S U B	R O U T	I N E =======================================


_$P_Do_CAPS_String proc	near		; ...
		push	si
		push	dx
		mov	dl, al		; save info id

_$P_DCS_Loop:				; ...
		mov	al, cs:[si]	; load charater	and
		call	_$P_Chk_DBCS	; check	if DBCS	leading	byte
		jb	short _$P_DCS00	; if yes, do not need CAPS
		or	al, al		; end of string	?
		jz	short _$P_DCS_Exit ; then exit.
		call	_$P_Do_CAPS_Char ; Here	a SBCS char need to be CAPS
		mov	cs:[si], al	; stored upper case char to buffer
		jmp	short _$P_DCS01	; process next
; ---------------------------------------------------------------------------

_$P_DCS00:				; ...
		inc	si		; skip DBCS leading and	trailing byte

_$P_DCS01:				; ...
		inc	si		; si points to next byte
		jmp	short _$P_DCS_Loop ; loop until	NULL encountered
; ---------------------------------------------------------------------------

_$P_DCS_Exit:				; ...
		pop	dx
		pop	si
		retn
_$P_Do_CAPS_String endp


; =============== S U B	R O U T	I N E =======================================


_$P_Do_CAPS_Char proc near		; ...
		cmp	al, 80h		; _$P_ASCII80 ;	need upper case	table ?
		jnb	short _$P_DCC_Go ; no
		cmp	al, 'a'         ; check if  "a" <= AL <= "z"
		jb	short _$P_CAPS_Ret
		cmp	al, 'z'
		ja	short _$P_CAPS_Ret
		and	al, 0DFh	; _$P_Make_Upper ; make	CAPS
		jmp	short _$P_CAPS_Ret
; ---------------------------------------------------------------------------

_$P_DCC_Go:				; ...
		push	bx
		push	es
		push	di
		lea	di, _$P_Char_CAP_Ptr ; or use char CAPS	table ?
		cmp	cs:[di], dl	; already got table address ?
		jz	short _$P_DCC01	; no
		push	ax
		push	cx
		push	dx
		push	cs
		pop	es
		assume es:SYSINIT
		mov	ah, 65h		; _$P_DOS_Get_TBL
		mov	al, dl		; function
		mov	bx, 0FFFFh	; _$P_DOSTBL_Def = -1
		mov	cx, 5		; _$P_DOSTBL_BL
		mov	dx, 0FFFFh	; _$P_DOSTBL_Def
		int	21h		; DOS -	4.x internal
					; COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
					;
					; DI already set to point to buffer
		pop	dx
		pop	cx
		pop	ax

_$P_DCC01:				; ...
		mov	bx, cs:[di+1]	; [cs:di+_$P_DOS_TBL.Off]
					; get offset of	table
		mov	es, word ptr cs:[di+3] ; [cs:di+_$P_DOS_TBL.Seg]
					; get segment of table
		assume es:nothing
		inc	bx
		inc	bx		; add 2	to bx reg
		sub	al, 80h		; _$P_ASCII80 ;	make char to index
		xlat	byte ptr es:[bx] ; perform case	map
		pop	di
		pop	es
		pop	bx

_$P_CAPS_Ret:				; ...
		retn
_$P_Do_CAPS_Char endp


; =============== S U B	R O U T	I N E =======================================


_$P_SValue	proc near		; ...
		push	ax
		or	cs:_$P_Flags2, 80h ; _$P_Signed	; indicate a signed numeric
		and	cs:_$P_Flags2, 0FDh ; 0FFh-_$P_Neg ; assume positive value
					; and byte [cs:$_Flags2],~_$P_Neg ; ~2
		mov	al, cs:[si]	; get sign
		cmp	al, '+'         ; _$P_Plus
		jz	short _$P_SVal00
		cmp	al, '-'         ; _$P_Minus
		jnz	short _$P_Sval01
		or	cs:_$P_Flags2, 2 ; _$P_Neg
					; set this is negative value

_$P_SVal00:				; ...
		inc	si		; skip sign char

_$P_Sval01:				; ...
		call	_$P_Value	; and process value
		pop	ax
		retn
_$P_SValue	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Value	proc near		; ...
		push	ax
		push	cx
		push	dx
		push	si
		xor	cx, cx		; cx = higher 16 bits
		xor	dx, dx		; dx = lower 16	bits
		push	bx

_$P_Value_Loop:				; ...
		mov	al, cs:[si]	; get character
		or	al, al		; end of line ?
		jz	short _$P_Value00
		call	_$P_0099	; make asc(0..9) to bin(0..9)
		jb	short _$P_Value_Err0 ; then error, exit
		xor	ah, ah
		mov	bp, ax		; save binary number
		shl	dx, 1		; to have 2*x
		rcl	cx, 1		; shift	left w/	carry
		call	_$P_Check_OVF	; Overflow occurred ?
		jb	short _$P_Value_Err0 ; then error, exit
		mov	bx, dx		; save low(2*x)
		mov	ax, cx		; save high(2*x)
		shl	dx, 1		; to have 4*x
		rcl	cx, 1		; shift	left w/	carry
		call	_$P_Check_OVF	; Overflow occurred ?
		jb	short _$P_Value_Err0 ; then error, exit
		shl	dx, 1		; to have 8*x
		rcl	cx, 1		; shift	left w/	carry
		call	_$P_Check_OVF
		jb	short _$P_Value_Err0
		add	dx, bx		; now have 10*x
		adc	cx, ax		; 32bit	ADD
		call	_$P_Check_OVF	; Overflow occurred ?
		jb	short _$P_Value_Err0 ; then error, exit
		add	dx, bp		; Add the current one degree decimal
		adc	cx, 0		; if carry, add	1 to high 16bit
		call	_$P_Check_OVF	; Overflow occurred ?
		jb	short _$P_Value_Err0 ; then error, exit
		inc	si		; update pointer
		jmp	short _$P_Value_Loop ; loop until NULL encountered
; ---------------------------------------------------------------------------

_$P_Value_Err0:				; ...
		pop	bx
		jmp	_$P_Value_Err	; bridge
; ---------------------------------------------------------------------------

_$P_Value00:				; ...
		pop	bx		; restore control pointer
					; here cx,dx = 32bit value
		test	cs:_$P_Flags2, 2 ; _$P_Neg ; was it negative ?
		jz	short _$P_Value01
		not	cx		; | Make 2's complement
		not	dx		; |
		add	dx, 1		; |
		adc	cx, 0		; |

_$P_Value01:				; ...
		mov	si, es:[bx+6]	; [es:bx+_$P_Control_Blk.Value_List]
					; si points to value list
		mov	al, es:[si]	; get nval
		cmp	al, 0		; _$P_nval_None	; no value list	?
		jnz	short _$P_Value02
		mov	al, 1		; _$P_Number ; Set type
		mov	ah, 0FFh	; _$P_No_Tag ; No ITEM_TAG set
		jmp	short _$P_Value_Exit
; ---------------------------------------------------------------------------
		nop			; 90h

_$P_Value02:				; ...
		inc	si
		mov	al, es:[si]	; al = number of range
		cmp	al, 0		; _$P_No_nrng
		jz	short _$P_Value_Err ; _$P_Value03
		inc	si		; si points to 1st item_tag

_$P_Val02_Loop:				; ...
		test	cs:_$P_Flags2, 80h ; _$P_Signed
		jnz	short _$P_Val02_Sign
		cmp	cx, es:[si+3]	; [es:si+_$P_Val_List.Val_XH]
					; comp cx with XH
		jb	short _$P_Val02_Next
		ja	short _$P_Val_In
		cmp	dx, es:[si+1]	; [es:si+_$P_Val_List.Val_XL]
					; comp dx with XL
		jb	short _$P_Val02_Next

_$P_Val_In:				; ...
		cmp	cx, es:[si+7]	; [es:si+_$P_Val_List.Val_YH]
					; comp cx with YH
		ja	short _$P_Val02_Next
		jb	short _$P_Val_Found
		cmp	dx, es:[si+5]	; [es:si+_$P_Val_List.Val_YL]
					; comp dx with YL
		ja	short _$P_Val02_Next
		jmp	short _$P_Val_Found
; ---------------------------------------------------------------------------

_$P_Val02_Sign:				; ...
		cmp	cx, es:[si+3]	; [es:si+_$P_Val_List.Val_XH]
					; comp cx with XH
		jl	short _$P_Val02_Next
		jg	short _$P_SVal_In
		cmp	dx, es:[si+1]	; [es:si+_$P_Val_List.Val_XL]
					; comp dx with XL
		jl	short _$P_Val02_Next

_$P_SVal_In:				; ...
		cmp	cx, es:[si+7]	; [es:si+_$P_Val_List.Val_YH]
					; comp cx with YH
		jg	short _$P_Val02_Next
		jl	short _$P_Val_Found
		cmp	dx, es:[si+5]	; [es:si+_$P_Val_List.Val_YL]
					; comp dx with YL
		jg	short _$P_Val02_Next
		jmp	short _$P_Val_Found
; ---------------------------------------------------------------------------

_$P_Val02_Next:				; ...
		add	si, 9		; _$P_Len_Range
		dec	al		; loop nrng times in AL
		jnz	short _$P_Val02_Loop
		mov	cs:_$P_RC, 6	; _$P_Out_Of_Range
		mov	al, 1		; _$P_Number
		mov	ah, 0FFh	; _$P_No_Tag
		jmp	short _$P_Value_Exit
; ---------------------------------------------------------------------------

_$P_Val_Found:				; ...
		mov	al, 1		; _$P_Number
		mov	ah, es:[si]	; found	ITEM_TAG set
		jmp	short _$P_Value_Exit
; ---------------------------------------------------------------------------

_$P_Value_Err:				; ...
		mov	cs:_$P_RC, 9	; _$P_Syntax
		mov	al, 3		; _$P_String ; Set type
		mov	ah, 0FFh	; _$P_No_Tag ; No ITEM_TAG set

_$P_Value_Exit:				; ...
		call	_$P_Fill_Result
		pop	si
		pop	dx
		pop	cx
		pop	ax
		retn
_$P_Value	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Check_OVF	proc near		; ...
		pushf
		test	cs:_$P_Flags2, 2 ; _$P_Neg ; is	it negative value ?
		jnz	short _$P_COVF
		popf			; if no, check overflow	by the CY bit
		retn
; ---------------------------------------------------------------------------

_$P_COVF:				; ...
		popf			; else,	check overflow by the OF
		jo	short _$P_COVF00
		clc			; indicate it with CY bit
					; CY=0 means no	overflow
		retn
; ---------------------------------------------------------------------------

_$P_COVF00:				; ...
		stc			; and CY=1 means overflow
		retn
_$P_Check_OVF	endp


; =============== S U B	R O U T	I N E =======================================


_$P_0099	proc near		; ...
		cmp	al, '0'         ; must be 0 =< al =< 9
		jb	short _$P_0099Err
		cmp	al, '9'
		ja	short _$P_0099Err
		sub	al, '0'         ; sub al,30h ; make char -> bin
		clc			; indicate no error
					; (clc is not required here, cf=0)
		retn
; ---------------------------------------------------------------------------

_$P_0099Err:				; ...
		stc
		retn
_$P_0099	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Simple_String proc near		; ...
		push	ax
		push	bx
		push	dx
		push	di
		mov	di, es:[bx+6]	; [es:bx+_$P_Control_Blk.Value_List]
					; di points to value list
		mov	al, es:[di]	; get nval
		or	al, al		; no value list	?
		jnz	short _$P_Sim00
		mov	ah, 0FFh	; _$P_No_Tag ; then, No	ITEM_TAG set
		jmp	short _$P_Sim_Exit ; and set result buffer
; ---------------------------------------------------------------------------

_$P_Sim00:				; ...
		cmp	al, 3		; Check	if keyword or value list id #3 is supported
					; _$P_nval_String ; String choice list provided	?
		jnz	short _$P_Sim01	; if no, syntax	error
		inc	di
		mov	al, es:[di]	; al = nrng
		mov	ah, 9		; _$P_Len_Range
		mul	ah		; Skip nrng field
		inc	ax		; ax = (nrng*9)+1
		add	di, ax		; di points to nnval
		mov	al, es:[di]	; get nnval
		mov	ah, 5		; _$P_Len_Value
		mul	ah		; skip nnval field
		inc	ax		; ax = (nnval*5)+1
		add	di, ax		; di points to nstrval
		mov	al, es:[di]	; get nstrval c
		inc	di
		inc	di		; add '2' to di reg
					; di points to 1st string in list

_$P_Sim_Loop:				; ...
		mov	bp, es:[di]	; get string pointer
		call	_$P_String_Comp	; compare it with operand
		jnb	short _$P_Sim_Found ; found on list
		add	di, 3		; _$P_Len_String ; if no, point	to next	choice
		dec	al		; loop nstval times in AL
		jnz	short _$P_Sim_Loop
		mov	cs:_$P_RC, 8	; / Not	found ;	_$P_Not_In_Str
		mov	ah, 0FFh	; _$P_No_Tag  ;	No ITEM_TAG set
		jmp	short _$P_Sim_Exit
; ---------------------------------------------------------------------------

_$P_Sim_Found:				; ...
		mov	ah, es:[di-1]	; set item_tag
		mov	al, 2		; _$P_List_Idx
		mov	dx, es:[di]	; get address of STRING
		jmp	short _$P_Sim_Exit0
; ---------------------------------------------------------------------------

_$P_Sim01:				; ...
		mov	cs:_$P_RC, 9	; _$P_Syntax
		mov	ah, 0FFh	; _$P_No_Tag

_$P_Sim_Exit:				; ...
		mov	al, 3		; _$P_String ; Set type

_$P_Sim_Exit0:				; ...
		call	_$P_Fill_Result
		pop	di
		pop	dx
		pop	bx
		pop	ax
		retn
_$P_Simple_String endp


; =============== S U B	R O U T	I N E =======================================


_$P_String_Comp	proc near		; ...
		push	ax
		push	bp
		push	dx
		push	si
		mov	dl, 2		; _$P_DOSTBL_Char ; use	character case map table

_$P_SCOM_Loop:				; ...
		mov	al, cs:[si]	; get command character
		call	_$P_Chk_DBCS	; DBCS ?
		jb	short _$P_SCOM00 ; yes
		call	_$P_Do_CAPS_Char ; else, upper case map	before comparison
		test	cs:_$P_Flags2, 8 ; Check if keyword or switch is supported
					; _$P_Key_Cmp ;	keyword	search ?
		jz	short _$P_SCOM04
		cmp	al, '='         ; _$P_Keyword  ; "=" is delimiter
		jnz	short _$P_SCOM03 ; IF "=" on command line AND
					; (bp+1=> char after the "=" in	synonym	list)
		cmp	byte ptr es:[bp+1], 0 ;	_$P_NULL ; at end of keyword string
					;		   in the control block	THEN
		jnz	short _$P_SCOM_Differ
		jmp	short _$P_SCOM05 ; keyword found in synonym list
; ---------------------------------------------------------------------------

_$P_SCOM04:				; ...
		test	cs:_$P_Flags2, 10h ; _$P_SW_Cmp	; switch search	?
		jz	short _$P_SCOM03
		cmp	al, ':'         ; _$P_Colon ; ":" is delimiter,
					;	     at	end of switch on command line
		jnz	short _$P_SCOM03
		cmp	byte ptr es:[bp+0], 0 ;	_$P_NULL
					; IF at	end of switch on command AND
		jnz	short _$P_SCOM_Differ ;
					; at end of switch string
					; in the control block THEN

_$P_SCOM05:				; ...
		inc	si		; found	a match
					; si points to just after "=" or ":"
		jmp	short _$P_SCOM_Same ; exit
; ---------------------------------------------------------------------------

_$P_SCOM03:				; ...
		cmp	al, es:[bp+0]	; compare operand w/ a synonym
		jnz	short _$P_SCOM_Differ0 ; if different,
					; check	ignore colon option
		or	al, al		; end of line ?
		jz	short _$P_SCOM_Same ; if so, exit
		inc	si		; update operand pointer
		inc	bp		; and synonym pointer
		jmp	short _$P_SCOM01 ; loop	until NULL or "=" or ":"
					;  found in case
; ---------------------------------------------------------------------------

_$P_SCOM00:				; ...
		cmp	al, es:[bp+0]	; Here al is DBCS leading byte
					; compare leading byte
		jnz	short _$P_SCOM_Differ ;	if not match, say different
		inc	si		; else,	load next byte
		mov	al, cs:[si]
		inc	bp
		cmp	al, es:[bp+0]	; and compare 2nd byte
		jnz	short _$P_SCOM_Differ ;	if not match, say different, too
		inc	si		; else update operand pointer
		inc	bp		; and synonym pointer

_$P_SCOM01:				; ...
		jmp	short _$P_SCOM_Loop ; loop until NULL or "="
					; or "/" found in case
; ---------------------------------------------------------------------------

_$P_SCOM_Differ0:			; ...
		test	cs:_$P_Flags2, 40h ; _$P_SW
		jz	short _$P_not_applicable
		test	word ptr es:[bx+2], 20h	; [es:bx+_$P_Control_Blk.Function_Flag],
					; _$P_colon_is_not_necessary
		jz	short _$P_not_applicable
		cmp	byte ptr es:[bp+0], 0 ;	_$P_NULL
		jz	short _$P_SCOM_Same

_$P_not_applicable:			; ...
		test	word ptr es:[bx], 10h ;	[es:bx+_$P_Control_Blk.Match_Flag],
					; _$P_Ig_Colon
					; ignore colon option specified	?
		jz	short _$P_SCOM_Differ
		cmp	al, ':'         ; _$P_Colon ; End up with ":" and subseqently
		jnz	short _$P_SCOM02
		cmp	byte ptr es:[bp+0], 0 ;	_$P_NULL ; null	?
		jnz	short _$P_SCOM_Differ ;	if no, say different
		jmp	short _$P_SCOM_Same ; else, say	same
; ---------------------------------------------------------------------------

_$P_SCOM02:				; ...
		cmp	al, 0		; _$P_NULL ; end up NULL and :
		jnz	short _$P_SCOM_Differ
		cmp	byte ptr es:[bp+0], ':' ; $P_Colon ; if no, say different
		jz	short _$P_SCOM_Same ; else, say	same

_$P_SCOM_Differ:			; ...
		stc			; indicate not found
		jmp	short _$P_SCOM_Exit
; ---------------------------------------------------------------------------

_$P_SCOM_Same:				; ...
		mov	cs:_$P_KEYorSW_Ptr, si ; for later use by keyword or switch
		clc			; indicate found
					; (cf is already 0 here.. clc is not needed)

_$P_SCOM_Exit:				; ...
		pop	si
		pop	dx
		pop	bp
		pop	ax
		retn
_$P_String_Comp	endp


; =============== S U B	R O U T	I N E =======================================


_$P_File_Format	proc near		; ...
		push	ax
		push	di
		push	si
		mov	di, cs:_$P_SaveSI_Cmpx ; get user buffer address

_$P_FileF_Loop0:			; / skip special characters
		mov	al, cs:[si]	; load character
		or	al, al		; end of line ?
		jz	short _$P_FileF_Err ; if yes, error exit
		call	_$P_FileSp_Chk	; else,	check if file special character
		jnz	short _$P_FileF03
		mov	cs:_$P_err_flag, 1 ; $P_error_filespec
					; set error flag - bad char.
		pop	si
		mov	byte ptr cs:[si], 0 ; _$P_NULL
		pop	di
		jmp	short _$P_FileF02
; ---------------------------------------------------------------------------

_$P_FileF_Err:				; ...
		pop	si
		mov	byte ptr cs:[si], 0 ; _$P_NULL
		pop	di
		test	word ptr es:[bx], 1 ; [es:bx+_$P_Control_Blk.Match_Flag],
					; _$P_Optional
		jnz	short _$P_FileF02
		mov	cs:_$P_RC, 2	; _$P_Op_Missing
		jmp	short _$P_FileF02
; ---------------------------------------------------------------------------

_$P_FileF03:				; ...
		pop	ax		; discard si on	top of stack
		push	si		; save new si

_$P_FileF_Loop1:			; ...
		mov	al, cs:[si]	; load character (not special char)
		or	al, al		; end of line ?
		jz	short _$P_FileF_RLT
		call	_$P_FileSp_Chk	; File special character ?
		jz	short _$P_FileF00
		call	_$P_Chk_DBCS	; no, then DBCS	?
		jnb	short _$P_FileF01
		inc	di
		inc	si

_$P_FileF01:				; ...
		inc	di		; if yes, skip next byte
		inc	si
		jmp	short _$P_FileF_Loop1
; ---------------------------------------------------------------------------

_$P_FileF00:				; ...
		mov	cs:_$P_Terminator, al
		mov	byte ptr cs:[si], 0 ; _$P_NULL ; update	end of string
		inc	di
		mov	cs:_$P_SI_Save,	di ; update next pointer in command line

_$P_FileF_RLT:				; ...
		pop	si
		pop	di

_$P_FileF02:				; ...
		pop	ax
		test	ax, 200h	; _$P_File_Spc
		jz	short _$P_Drv_Only_Exit
		push	ax
		mov	ah, 0FFh	; _$P_No_Tag
		mov	al, 5		; _$P_File_Spec
		call	_$P_Fill_Result	; set result buffer to file spec
		pop	ax

_$P_Drv_Only_Exit:			; ...
		retn
_$P_File_Format	endp


; =============== S U B	R O U T	I N E =======================================


_$P_FileSp_Chk	proc near		; ...
		push	bx
		push	cx
		lea	bx, _$P_FileSp_Char ; "[]|<>+=;\""
		mov	cx, 9		; _$P_FileSp_Len
					; load length of special character table
					; at SYSINIT:1838h (for	MSDOS 6.21 IO.SYS)

_$P_FileSp_Loop:			; ...
		cmp	al, cs:[bx]	; is it	one of special character ?
		jz	short _$P_FileSp_Exit
		inc	bx
		loop	_$P_FileSp_Loop
		inc	cx		; reset	ZF

_$P_FileSp_Exit:			; ...
		pop	cx
		pop	bx
		retn
_$P_FileSp_Chk	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Drive_Format proc near		; ...
		push	ax
		push	dx
		mov	al, cs:[si]
		or	al, al		; if null string
		jz	short _$P_Drv_Exit ; do	nothing
		call	_$P_Chk_DBCS	; is it	leading	byte ?
		jb	short _$P_Drv_Err ; yes, error
		cmp	word ptr cs:[si+1], 3Ah	; ':' ; _$P_Colon
					; "d", ":", 0 ?
		jz	short _$P_DrvF00
		test	word ptr es:[bx], 10h ;	[es:bx+_$P_Control_Blk.Match_Flag],
					; _$P_Ig_Colon
					; colon	can be ignored?
		jz	short _$P_Drv_Err
		cmp	byte ptr cs:[si+1], 0 ;	_$P_NULL ; "d",	0 ?
		jnz	short _$P_Drv_Err

_$P_DrvF00:				; ...
		or	al, 20h		; _$P_Make_Lower ; lower case
		cmp	al, 61h	; 'a'   ; drive letter must
		jb	short _$P_Drv_Err ; in range of
		cmp	al, 7Ah	; 'z'   ; "a"-"z"
		ja	short _$P_Drv_Err ; if no, error
		sub	al, 60h		; "a"-1	; make text drive to binary drive
		mov	dl, al
		mov	ah, 0FFh	; _$P_No_Tag
		mov	al, 6		; _$P_Drive
		call	_$P_Fill_Result	; set result buffer to drive
		jmp	short _$P_Drv_Exit
; ---------------------------------------------------------------------------

_$P_Drv_Err:				; ...
		mov	cs:_$P_RC, 9	; _$P_Syntax

_$P_Drv_Exit:				; ...
		pop	dx
		pop	ax
		retn
_$P_Drive_Format endp


; =============== S U B	R O U T	I N E =======================================


_$P_Skip_Delim	proc near		; ...
		lodsb
		call	_$P_Chk_EOL	; is it	EOL character ?
		jz	short _$P_Skip_Delim_CY	; if yes, exit w/ CY on
		call	_$P_Chk_Delim	; is it	one of delimiters ?
		jnz	short _$P_Skip_Delim_NCY ; if no, exit w/ CY off
		test	cs:_$P_Flags2, 20h ; _$P_Extra ; extra delim or	comma found
		jz	short _$P_Skip_Delim ; _$P_Skip_Delim_Loop
					; if no, loop
		test	cs:_$P_Flags2, 41h ; _$P_SW+_$P_equ ; /x , or xxx=zzz ,
		jz	short _$P_Exit_At_Extra	; no switch, no	keyword
		dec	si
		jmp	short _$P_Exit_At_Extra
; ---------------------------------------------------------------------------

_$P_Skip_Delim_CY:			; ...
		stc			; indicate EOL
		jmp	short _$P_Skip_Delim_Exit
; ---------------------------------------------------------------------------

_$P_Skip_Delim_NCY:			; ...
		clc			; indicate non delim

_$P_Skip_Delim_Exit:			; ...
		dec	si		; in this case,	need backup index pointer
		retn
; ---------------------------------------------------------------------------

_$P_Exit_At_Extra:			; ...
		clc			; indicate extra delim
		retn
_$P_Skip_Delim	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_EOL	proc near		; ...
		push	bx
		push	cx
		cmp	al, 0Dh		; _$P_CR ; Carriage return ?
		jz	short _$P_Chk_EOL_Exit
		cmp	al, 0		; _$P_NULL ; zero ?
		jz	short _$P_Chk_EOL_Exit
		cmp	al, 0Ah		; _$P_LF ; Line	feed ?
		jz	short _$P_Chk_EOL_Exit
		cmp	byte ptr es:[di+2], 2 ;	[es:di+_$P_PARMS_Blk.Num_Extra],
					; _$P_I_Have_EOL
		jb	short _$P_Chk_EOL_Exit
		xor	bx, bx
		mov	bl, es:[di+3]	; [es:di+_$P_PARMS_Blk.Len_Extra_Delim]
					; get length of	delimiter list
		add	bx, 4		; _$P_Len_PARMS	; skip it
		cmp	byte ptr es:[bx+di], 0 ; _$P_I_Use_Default
					; No extra EOL character ?
		jz	short _$P_Chk_EOL_NZ
		xor	cx, cx		; Get number of	extra character
		mov	cl, es:[bx+di]

_$P_Chk_EOL_Loop:			; ...
		inc	bx
		cmp	al, es:[bx+di]	; Check	extra EOL character
		jz	short _$P_Chk_EOL_Exit
		loop	_$P_Chk_EOL_Loop

_$P_Chk_EOL_NZ:				; ...
		cmp	al, 0Dh		; _$P_CR ; reset ZF

_$P_Chk_EOL_Exit:			; ...
		pop	cx
		pop	bx
		retn
_$P_Chk_EOL	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_Delim	proc near		; ...
		push	bx
		push	cx
		mov	cs:_$P_Terminator, 20h ; ' ' ; _$P_Space
					; assume terminated by space
		and	cs:_$P_Flags2, 0DFh ; 0FFh-_$P_Extra ; ~$P_Extra ; ~20h
		cmp	al, 20h	; ' '   ; _$P_Space ; Space ?
		jz	short _$P_Chk_Delim_Exit
		cmp	al, 9		; _$P_TAB ; TAB	?
		jz	short _$P_Chk_Delim_Exit
		cmp	al, 2Ch	; ','   ; _$P_Comma ; Comma ?
		jz	short _$P_Chk_Delim_Exit0

_$P_Chk_Delim00:			; Note:	_$P_Chk_Delim00	part of	code is	nonsense
		cmp	al, 20h	; ' '   ;       here because _$P_Space = _$P_DBSP1 = 20h
					;	Erdogan	Tan - 08/07/2023
					;
					; _$P_DBSP1 ; 1st byte of DBCS Space ?
		jnz	short $P_Chk_Delim01
		cmp	byte ptr [si], 20h ; ' ' ; _$P_DBSP2 ; 2nd byte of DBCS Space ?
		jnz	short $P_Chk_Delim01
		mov	al, 20h	; ' '   ; _$P_Space
		inc	si		; make si point	to next	character
		cmp	al, al		; Set ZF
		jmp	short _$P_Chk_Delim_Exit
; ---------------------------------------------------------------------------

$P_Chk_Delim01:				; ...
		cmp	byte ptr es:[di+2], 1 ;	[es:di-_$P_PARMS_Blk.Num_Extra],
					; _$P_I_Have_Delim
					; delimiter character specified	?
		jb	short _$P_Chk_Delim_Exit ; no
		xor	cx, cx
		mov	cl, es:[di+3]	; [es:di+_$P_PARMS_Blk.Len_Extra_Delim]
					; get length of	delimiter list
		or	cx, cx
		jz	short _$P_Chk_Delim_NZ ; no extra delim	character
		mov	bx, 3		; _$P_Len_PARMS-1
					; set bx to 1st	extra delimiter

_$P_Chk_Delim_Loop:			; ...
		inc	bx
		cmp	al, es:[bx+di]	; check	extra delim character
		jz	short _$P_Chk_Delim_Exit0
		loop	_$P_Chk_Delim_Loop ; examine all extra delimiter

_$P_Chk_Delim_NZ:			; ...
		cmp	al, 20h	; ' '   ; _$P_Space ; reset ZF

_$P_Chk_Delim_Exit:			; ...
		pop	cx
		pop	bx
		retn
; ---------------------------------------------------------------------------

_$P_Chk_Delim_Exit0:			; ...
		mov	cs:_$P_Terminator, al ;	keep terminated	delimiter
		test	cs:_$P_Flags2, 1 ; _$P_equ ; if	terminating a key=
		jnz	short _$P_No_Set_Extra ; then do not set the EXTRA bit
		or	cs:_$P_Flags2, 20h ; _$P_Extra
					; flag terminated extra	delim or comma

_$P_No_Set_Extra:			; ...
		cmp	al, al		; set ZF
		jmp	short _$P_Chk_Delim_Exit
_$P_Chk_Delim	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_Switch	proc near		; ...
		lea	bp, _$P_STRING_BUF ; BP	= Offset of _$P_String_Buf
					; (mov bp, offset _$P_STRING_BUF)
		cmp	bx, bp		; IF not first char THEN
		jz	short _$P_STRUC_L2
		cmp	al, 2Fh	; '/'   ; _$P_Switch ; see if a slash
		jnz	short _$P_STRUC_L5
		stc			; not in first position	and is slash
		jmp	short _$P_STRUC_L1
; ---------------------------------------------------------------------------

_$P_STRUC_L5:				; ...
		clc
		jmp	short _$P_STRUC_L1
; ---------------------------------------------------------------------------

_$P_STRUC_L2:				; ...
		cmp	al, 2Fh	; '/'   ; _$P_Switch
		jnz	short _$P_STRUC_L12 ; not a slash
		or	cs:_$P_Flags2, 40h ; _$P_SW
					; could	be valid switch,
					; first	char and is slash

_$P_STRUC_L12:				; ...
		clc			; is first char	in the buffer, ZF=0
					; (CF=0	indicating first char)

_$P_STRUC_L1:				; ...
		retn
_$P_Chk_Switch	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_DBCS	proc near		; ...
		push	ds
		push	si
		push	bx
		cmp	cs:_$P_DBCSEV_SEG, 0 ; already set ?
		jnz	short _$P_DBCS00 ; yes
		push	ax
		push	ds
		push	cx
		push	dx
		push	di
		push	bp
		push	es
		xor	si, si
		mov	ds, si
		assume ds:nothing
		mov	ax, 6300h	; _$P_DOS_GetEV	; GET DBCS EV CALL
		int	21h		; DOS -	3.2+ only
					; GET DOUBLE BYTE CHARACTER SET	LEAD TABLE
		mov	bx, ds
		or	bx, bx
		pop	es
		pop	bp
		pop	di
		pop	dx
		pop	cx
		pop	ds
		assume ds:nothing
		pop	ax
		jz	short _$P_NON_DBCS
		mov	cs:_$P_DBCSEV_OFF, si ;	save EV	offset
		mov	cs:_$P_DBCSEV_SEG, bx ;	save EV	segment

_$P_DBCS00:				; ...
		mov	si, cs:_$P_DBCSEV_OFF ;	load EV	offset and segment
		mov	ds, cs:_$P_DBCSEV_SEG

_$P_DBCS_LOOP:				; ...
		cmp	word ptr [si], 0 ; zero	vector ?
		jz	short _$P_NON_DBCS ; then exit
		cmp	al, [si]	; Check	if AL is in range of the vector
		jb	short $P_DBCS01
		cmp	al, [si+1]
		ja	short $P_DBCS01
		stc			; if yes, indicate DBCS	and exit
		jmp	short _$P_DBCS_EXIT
; ---------------------------------------------------------------------------

$P_DBCS01:				; ...
		inc	si		; add 2	to si reg
		inc	si		; get next vector
		jmp	short _$P_DBCS_LOOP ; loop until zero vector found
; ---------------------------------------------------------------------------

_$P_NON_DBCS:				; ...
		clc			; indicate SBCS
					; (note: cf is already 0 here)

_$P_DBCS_EXIT:				; ...
		pop	bx
		pop	si
		pop	ds
		retn
_$P_Chk_DBCS	endp

; ---------------------------------------------------------------------------
buf_parms	dw offset buf_parmsx	; ...
					; buffer = [n |	n,m] {/e}
		db 1			; an extra delimiter list
		db 1			; length is 1
		db ';'                  ; delimiter
buf_parmsx	db 1			; ...
		db 2			; min 1, max 2 positionals
		dw offset buf_pos1
		dw offset buf_pos2
		db 1			; one switch
		dw offset sw_x_ctrl
		db 0			; no keywords
					;
					; buf_pos1 p_pos <8000h,0,result_val,buf_range_1>
					; numeric
buf_pos1	dw 8000h		; ...
					; match_flags -	numeric	value
		dw 0			; function flags
		dw offset result_val	; result value buffer
		dw offset buf_range_1	; value	list
		db 0			; no switches/keywords
buf_range_1	db 1			; ...
					; range	definition
		db 1			; 1 definition of range
		db 1			; item tag for this range
		dd 1			; numeric min
		dd 99			; numeric max
					;
					; buf_pos2 p_pos <8001h,0,result_val,buf_range_2>
					; optional num.
buf_pos2	dw 8001h		; ...
		dw 0
		dw offset result_val
		dw offset buf_range_2
		db 0			;
					; buf_range_2 p_range <,,,0,8>
buf_range_2	db 1			; ...
		db 1
		db 1
		dd 0
		dd 8			;
					; sw_x_ctrl p_pos <0,0,result_val,noval,1>
					; followed by one switch
sw_x_ctrl	dw 0			; ...
		dw 0
		dw offset result_val
		dw offset noval
		db 1			; 1 switch
switch_x	db '/X',0               ; ...
p_buffers	dw 0			; ...
p_h_buffers	dw 0			; ...
p_buffer_slash_x db 0			; ...
					;
					; common definitions
noval		db 0			; ...
result_val	db 0			; ...
					; type returned
result_val_itag	db 0			; ...
					; item tag returned
result_val_swoff dw 0			; ...
					; es:offset of the switch defined
rv_dword	dd 0			; ...
					; rv_byte
					; value	if number, or seg:offset to string.
					; ;;
brk_parms	dw offset brk_parmsx	; ...
					; break	= [ on | off ]
		db 1			; an extra delimiter list
		db 1			; length is 1
		db ';'                  ; delimiter
brk_parmsx	db 1			; ...
		db 1			; min,max = 1 positional
		dw offset brk_pos
		db 0			; no switches
		db 0			; no keywords
					;
					; brk_pos p_pos	<2000h,0,result_val,on_off_string>
					; simple string
brk_pos		dw 2000h		; ...
		dw 0
		dw offset result_val
		dw offset on_off_string
		db 0
on_off_string	db 3			; ...
					; signals that there is	a string choice
		db 0			; no range definition
		db 0			; no numeric values choice
		db 2			; 2 strings for	choice
		db 1			; the 1st string tag
		dw offset _on_string	; "ON"
		db 2			; the 2nd string tag
		dw offset _off_string	; "OFF"
_on_string	db 'ON',0               ; ...
_off_string	db 'OFF',0              ; ...
p_ctrl_break	db 0			; ...
					; local	variable
					; ;;
cntry_parms	dw offset cntry_parmsx	; ...
					; country = n {m {path}}
					; or country = n,,path
		db 1
		db 1
		db ';'
cntry_parmsx	db 1			; ...
					; min 1, max 3 pos.
		db 3
		dw offset cntry_pos1
		dw offset cntry_pos2
		dw offset cntry_pos3
		db 0			; no switches
		db 0			; no keywords
cntry_pos1	dw 8000h		; ...
					; cntry_pos1 p_pos <8000h,0,result_val,cc_range>
					; numeric value
		dw 0
		dw offset result_val
		dw offset cc_range
		db 0
cc_range	db 1			; ...
					; cc_range p_range <,,,1,999>
		db 1
		db 1
		dd 1
		dd 999
cntry_pos2	dw 8001h		; ...
					; cntry_pos2 p_pos <8001h,0,result_val,cc_range>
					; optional num.
		dw 0
		dw offset result_val
		dw offset cc_range
		db 0
cntry_pos3	dw 201h			; ...
					; cntry_pos3 p_pos <201h,0,result_val,noval>
					; optional filespec
		dw 0
		dw offset result_val
		dw offset noval
		db 0
p_cntry_code	dw 0			; ...
					; local	variable
p_code_page	dw 0			; ...
					; local	variable
					; ;;
files_parms	dw offset files_parmsx	; ...
					; files	= n
		db 1
		db 1
		db ';'
files_parmsx	db 1			; ...
		db 1			; min,max 1 positional
		dw offset files_pos
		db 0			; no switches
		db 0			; no keywords
files_pos	dw 8000h		; ...
					; files_pos p_pos <8000h,0,result_val,files_range,0>
					; numeric value
		dw 0
		dw offset result_val
		dw offset files_range
		db 0
files_range	db 1			; ...
					; files_range p_range <,,,8,255>
		db 1
		db 1
		dd 8
		dd 255
p_files		db 0			; ...
					; local	variable
					; ;;
fcbs_parms	dw offset fcbs_parmsx	; fcbs = n,m
		db 1
		db 1
		db ';'
fcbs_parmsx	db 1			; ...
		db 2
		dw offset fcbs_pos_1
		dw offset fcbs_pos_2
		db 0			; no switches
		db 0			; no keywords
fcbs_pos_1	dw 8000h		; ...
					; fcbs_pos_1 p_pos <8000h,0,result_val,fcbs_range>
					; numeric value
		dw 0
		dw offset result_val
		dw offset fcbs_range
		db 0
fcbs_range	db 1			; ...
					; fcbs_range p_range <,,,1,255>
		db 1
		db 1
		dd 1
		dd 255
fcbs_pos_2	dw 8000h		; ...
					; fcbs_pos_2 p_pos <8000h,0,result_val,fcbs_keep_range>
					; numeric value
		dw 0
		dw offset result_val
		dw offset fcbs_keep_range
		db 0
fcbs_keep_range	db 1			; ...
					; fcbs_keep_range p_range <,,,0,255>
		db 1
		db 1
		dd 0
		dd 255
p_fcbs		db 0			; ...
					; local	variable
p_keep		db 0			; ...
					; local	variable
					; ;;
ldrv_parms	dw offset ldrv_parmsx	; ...
					; lastdrive = x
		db 1
		db 1
		db ';'
ldrv_parmsx	db 1			; ...
		db 1			; min,max = 1 positional
		dw offset ldrv_pos
		db 0			; no switches
		db 0			; no keywords
ldrv_pos	dw 110h			; ...
					; ldrv_pos p_pos <110h,10h,result_val,noval>
					; drive	only, ignore colon at end
		dw 10h
		dw offset result_val
		dw offset noval
		db 0
p_ldrv		db 0			; ...
					; local	variable
					; ;;
stks_parms	dw offset stks_parmsx	; ...
					; stacks = n,m
		db 1
		db 1
		db ';'
stks_parmsx	db 2			; ...
		db 2			; min,max = 2 positionals
		dw offset stks_pos_1
		dw offset stks_pos_2
		db 0			; no switches
		db 0			; no keywords
stks_pos_1	dw 8000h		; ...
					; stks_pos_1 p_pos <8000h,0,result_val,stks_range>
					; numeric value
		dw 0
		dw offset result_val
		dw offset stks_range
		db 0
stks_range	db 1			; ...
					; stks_range p_range <,,,0,64>
		db 1
		db 1
		dd 0
		dd 64
stks_pos_2	dw 8000h		; ...
					; stks_pos_2 p_pos <8000h,0,result_val,stk_size_range>
					; numeric value
		dw 0
		dw offset result_val
		dw offset stk_size_range
		db 0
stk_size_range	db 1			; ...
					; stk_size_range p_range <,,,0,512>
		db 1
		db 1
		dd 0
		dd 512
p_stack_count	dw 0			; ...
					; local	variable
p_stack_size	dw 0			; ...
					; local	variable
					; ;;
mtrk_parms	dw offset mtrk_parmsx	; ...
					; multitrack = [ on | off ]
		db 1
		db 1
		db ';'
mtrk_parmsx	db 1			; ...
					; min,max = 1 positional
		db 1
		dw offset mtrk_pos
		db 0			; no switches
		db 0			; no keywords
mtrk_pos	dw 2000h		; ...
					; mtrk_pos p_pos <2000h,0,result_val,on_off_string>
					; simple string
		dw 0
		dw offset result_val
		dw offset on_off_string
		db 0
p_mtrk		db 0			; ...
					; local	variable
					; ;;
swit_parms	dw offset swit_parmsx	; ...
					; switches=/k
		db 1
		db 1
		db ';'
swit_parmsx	dw 0			; ...
					; no positionals
		db 5			; # of switches
		dw offset swit_k_ctrl	; /k control
		dw offset swit_n_ctrl	; /n control (for MULTI_CONFIG only)
		dw offset swit_f_ctrl	; /f control (for MULTI_CONFIG only)
		dw offset swit_t_ctrl	; /t control
		dw offset swit_w_ctrl	; /w control
		db 0			; no keywords
swit_k_ctrl	dw 0			; ...
					; swit_k_ctrl p_pos <0,0,result_val,noval,1>
					; switch string	follows
		dw 0
		dw offset result_val
		dw offset noval
		db 1
swit_k		db '/K',0               ; ...
swit_n_ctrl	dw 0			; ...
					; swit_n_ctrl p_pos <0,0,result_val,noval,1>
					; switch string	follows
		dw 0
		dw offset result_val
		dw offset noval
		db 1
swit_n		db '/N',0               ; ...
swit_f_ctrl	dw 0			; ...
					; swit_f_ctrl p_pos <0,0,result_val,noval,1>
					; switch string	follows
		dw 0
		dw offset result_val
		dw offset noval
		db 1
swit_f		db '/F',0               ; ...
swit_t_ctrl	dw 0			; ...
					; swit_t_ctrl p_pos <0,0,result_val,noval,1>
					; switch string	follows
		dw 0
		dw offset result_val
		dw offset noval
		db 1
swit_t		db '/T',0               ; ...
swit_w_ctrl	dw 0			; ...
					; swit_w_ctrl p_pos <0,0,result_val,noval,1>
					; switch string	follows
		dw 0
		dw offset result_val
		dw offset noval
		db 1
swit_w		db '/W',0               ; ...
p_swit_k	db 0			; ...
					; local	variable
p_swit_t	db 0			; ...
					; local	variable
p_swit_w	db 0			; ...
					; local	variable
					; ;;
dos_parms	dw offset dos_parmsx	; ...
					; DOS =	[ high | low ]
					; DOS =	HIGH|LOW[,UMB|,NOUMB]
		db 1
		db 1
		db ';'
dos_parmsx	db 1			; ...
					; min parameters
		db 2
		dw offset dos_pos
		dw offset dos_pos
		db    0			; no switches
		db    0			; no keywords
dos_pos		dw 2000h		; ...
					; dos_pos p_pos	<2000h,0,result_val,dos_strings>
					; simple string
		dw 0
		dw offset result_val
		dw offset dos_strings
		db 0
dos_pos2	dw 2000h		; dos_pos p_pos	<2000h,0,result_val,dos_strings>
					; simple string
					; (this	is not needed) - E.TAN - 08/07/2023
		dw 0
		dw offset result_val
		dw offset dos_strings
		db 0
dos_strings	db 3			; ...
					; signals that there is	a string choice
		db 0			; no range definition
		db 0			; no numeric values choice
		db 4			; 4 strings for	choice
		db 1			; the 1st string tag
		dw offset hi_string	; "HIGH"
		db 2			; the 2nd string tag
		dw offset lo_string	; "LOW"
		db 3
		dw offset umb_string	; "UMB"
		db 4
		dw offset noumb_string	; "NOUMB"
hi_string	db 'HIGH',0             ; ...
lo_string	db 'LOW',0              ; ...
umb_string	db 'UMB',0              ; ...
noumb_string	db 'NOUMB',0            ; ...
p_dos_hi	db 0			; local	variable (parser does not use this)
					;
					; for LoadHigh and DeviceHigh:
					;    fInHigh  -	Is set to 1 during HideUMBs(), and back	to zero	in
					;		UnHideUMBs().
					;    fUmbTiny -	Is set to 1 iff	the user has specified /S on the
					;		command	line.
					;    SegLoad  -	Segment	address	for first UMB specified; set
					;		automatically.
					;    UmbLoad  -	The load UMB number; for example, this is 3 if the
					;		user has given a command-line like "/L:3,500;4"
					;    fm_umb   -	Set to the old UMB link-state (0x80 or 0x00)
					;    fm_strat -	Set to the old memory-allocation strategy (0$00000???)
					;    fm_argc  -	Number of arguments received by	ParseVar()
fInHigh		db 0			; ...
fUmbTiny	db 0			; ...
SegLoad		dw 0			; ...
UmbLoad		db 0			; ...
					; UmbUsed - An array of	characters, each of which is 1 if the UMB
					;	    matching its index number was specified on the
					;	    command line;
					;	 for example, after "/L:3,500;4;7", UmbUsed[3],[4] & [7]
					;	 will be set to	1. All others will be set to 0.
					; UmbSize - An array of	words, each of which is	interpereted as	a
					;	    size specified by the user for a UMB (in the above
					;	    example, all elements would	be zero	save UmbSize[3],
					;	    which would	be 500.
UmbUsed		db 16 dup(0)		; ...
					; times	MAXUMB db 0
UmbSize		dw 16 dup(0)		; ...
					; times	MAXUMB dw 0
fm_umb		db 0			; ...
fm_strat	db 0
fm_argc		db 0			; ...
DevSize		dw 0			; ...
					; size of the device driver being loaded (paras)
DevLoadAddr	dw 0			; ...
					; Mem addr where the device driver is 2	b loaded
DevLoadEnd	dw 0			; ...
					; MaxAddr to which device can be loaded
DevEntry	dd 0			; ...
					; Entry	point to the device driver
DevBrkAddr	dd 0			; ...
					; Break	address	of the device driver
ConvLoad	db 0			; ...
					; Use conventional (dos	5 style) InitDevLoad?
DevUMB		db 0			; ...
					; byte indicating whether to load DDs in UMBs
DevUMBAddr	dw 0			; ...
					; current UMB used for loading devices (paras)
DevUMBSize	dw 0			; ...
					; Size of the current UMB being	used (paras)
DevUMBFree	dw 0			; ...
					; Start	of free	mem blk	in the current UMB (paras)
DevXMSAddr	dd 0			; ...
DevExecAddr	dw 0			; ...
					; Device load address parameter	to Exec	call
DevExecReloc	dw 0			; ...
					; Device load relocation factor
DeviceHi	db 0			; ...
					; Flag indicating whether the current device
					; is being loaded into UMB
DevSizeOption	dw 0			; ...
					; SIZE=	option
Int12Lied	db 0			; ...
					; did we trap int 12h ?
OldInt12Mem	dw 0			; ...
					; value	in 40:13h (int 12h ram)
ThreeComName	db 'PROTMAN$'           ; ...
					; 3Com Device name
FirstUMBLinked	db 0			; ...
DevDOSData	dw 0			; ...
					; segment of DOS Data
DevCmdLine	dd 0			; ...
					; Current Command line
DevSavedDelim	db 0			; ...
					; The delimiter	which was replaced with	null
					; to use the file name in the command line
MagicHomeFlag	db 0			; ...
					; set non-zero when MagicDrv is	final placed

; =============== S U B	R O U T	I N E =======================================


doconf		proc near		; ...
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	ax, 3700h
		int	21h		; DOS -	2+ internal - GET SWITCHAR/AVAILDEV
					; Return: AL = FFh unsupported subfunction
					; DL = current switch character
		mov	byte ptr command_line+1, dl
		mov	def_swchr, dl	; save default switchchar
		mov	dx, offset config ; "\\CONFIG.SYS"
		mov	ax, 3D00h	; OPEN<<8
		stc			; (in case of int 24h)
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jnb	short noprob	; brif opened okay
					;
					; config.sys file open error
		call	kbd_read	; we still want	to give	the guy
					; a chance to select clean boot!
					; (ie, no autoexec.bat processing)
		mov	multi_pass_id, 11 ; set	it to unreasonable number
		retn
; ---------------------------------------------------------------------------

noprob:					; ...
		mov	bx, ax		; get file size	(note <	64k!!)
					; File handle
		xor	cx, cx
		xor	dx, dx
		mov	ax, 4202h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		mov	count, ax
		xor	dx, dx		; reset	pointer	to beginning of	file
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		mov	dx, ALLOCLIM	; use current alloclim value
		mov	ax, count
		mov	config_size, ax	; save the size	of config.sys file.
		call	ParaRound
		sub	dx, ax
		dec	dx		; reserve 1 additional paragraph
		mov	config_wrkseg, dx ; this is the	segment	to be used for
		sub	dx, ax		; rebuilding the config.sys memory image
		sub	dx, 11h		; room for header
		mov	ALLOCLIM, dx	; config starts	here. new alloclim value.
		mov	CONFBOT, dx
		mov	ds, dx
		assume ds:nothing
		mov	es, dx
		xor	dx, dx
		mov	cx, cs:count
		mov	ah, 3Fh
		stc			; (in case of int 24h)
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		pushf
		push	ax		; find the eof mark in the file.
					; if present,then trim length.
		push	di
		push	cx
		mov	al, 1Ah		; eof mark
		mov	di, dx		; point	to buffer
		jcxz	short puteol	; no chars
		repne scasb		; find end
		jnz	short puteol	; none found and count exhausted
		dec	di		; backup past 1Ah

puteol:					; ...
		mov	al, 0Dh		; cr,lf
		stosb
		mov	al, 0Ah
		stosb
		sub	di, dx		; difference moved
		mov	cs:count, di	; new count
		pop	cx
		pop	di
		pop	ax
		push	cs
		pop	ds
		assume ds:SYSINIT
		push	ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	ax
		popf
		jb	short conferr	; we've got a problem
		cmp	cx, ax
		jz	short getcom	; if ax	<(>) cx
					; couldn't read the file

conferr:				; ...
		mov	dx, offset config ; "\\CONFIG.SYS"
		call	badfil

endconv:				; ...
		retn
doconf		endp


; =============== S U B	R O U T	I N E =======================================


multi_pass	proc near		; ...

; FUNCTION CHUNK AT 2968 SIZE 0000012A BYTES
; FUNCTION CHUNK AT 2AA6 SIZE 000002B7 BYTES
; FUNCTION CHUNK AT 2DAB SIZE 0000000C BYTES

		push	cs
		pop	ds
		cmp	multi_pass_id, 10 ; do nothing.	just return.

jae_endconv:				; ...
		jnb	short endconv
		push	CONFBOT
		pop	es		; es = [confbot] (CONFIG.SYS image seg)
		mov	si, org_count	; set count
		mov	count, si
		xor	si, si		; 0
		mov	chrptr,	si	; reset	chrptr
		mov	linecount, si	; reset	linecount
		call	getchr
		jmp	short conflp
; ---------------------------------------------------------------------------

getcom:					; ...
		call	organize	; organize the file
		call	getchr

conflp:					; ...
		jb	short endconv
		inc	linecount	; increase linecount
		mov	multdeviceflag,	0 ; reset multdeviceflag.
		mov	setdevmarkflag,	0 ; reset setdevmarkflag.
		cmp	al, 0Ah		; lf ; linefeed?
		jz	short blank_line ; then	ignore this line.
					;
					; If this is a genuine CONFIG.SYS command,
					; then there should be a line number
					; immediately following	it
		mov	config_cmd, al	; save original	command	code
		and	al, 7Fh		; ~CONFIG_OPTION_QUERY
		cmp	config_multi, 0	; is this a multi-config config.sys?
		jz	short not_final	; no, line number is not embedded
		push	ax
		call	getchr		; ignore end-of-image errors
		mov	ah, al		; because if there's an error
		call	getchr		; fetching the line number that's
		xchg	al, ah		; supposed to be there,	the next
		mov	linecount, ax	; getchr call will get the same	error
		pop	ax
		cmp	multi_pass_id, 2 ; final pass?
		jb	short not_final	; no
		test	install_flag, 1	; have_install_cmd
					; are there install commands?
		jz	short final	; no install cmds, yes it is
		cmp	multi_pass_id, 3 ; final pass?
		jb	short not_final	; no

final:					; ...
		mov	es:[si], al	; save backward-compatible command code

not_final:				; ...
		mov	ah, al
		call	getchr
		jnb	short tryi
		cmp	multi_pass_id, 2
		jnb	short jae_endconv ; it would be	'jnb short endconv'
					; (E.TAN - 09/07/2023)
					; do not show badop again for multi_pass.
		jmp	badop
; ---------------------------------------------------------------------------

coff:					; ...
		push	cs
		pop	ds
		call	newline
		jmp	short conflp
; ---------------------------------------------------------------------------

blank_line:				; ...
		call	getchr
		jmp	short conflp
; ---------------------------------------------------------------------------
		push	cs
		pop	ds

tryi:					; ...
		cmp	multi_pass_id, 0 ; the initial pass for	DOS=HI
		jnz	short not_init_pass
		jmp	multi_try_doshi
; ---------------------------------------------------------------------------

not_init_pass:				; ...
		cmp	multi_pass_id, 2 ; the second pass was for ifs=
		jz	short multi_pass_coff2 ; now it	is NOPs
					;
					; This pass can	be made	use of if
					; we want do some config.sys process
					; after	device drivers are loaded and
					; before install= commands are processed
		cmp	multi_pass_id, 3 ; the third pass for install= ?
		jz	short multi_try_i
		cmp	ah, 48h	; 'H'   ; CONFIG_DOS
		jz	short multi_pass_coff2
		cmp	ah, 49h	; 'I'   ; CONFIG_INSTALL ; install= command?
		jnz	short precheck_installhigh ;
					; the first pass is for	normal operation.
		or	install_flag, 1	; have_install_cmd ; set the flag

multi_pass_coff2:			; ...
		jmp	short coff	; and handles the next command
; ---------------------------------------------------------------------------

precheck_installhigh:			; ...
		cmp	ah, 57h	; 'W'   ; CONFIG_INSTALLHIGH ; signifier for INSTALLHIGH
		jnz	short tryb	; carry	on with	normal processing
		or	install_flag, 1	; have_install_cmd
		jmp	short coff
; ---------------------------------------------------------------------------

multi_try_i:				; ...
		cmp	ah, 49h	; 'I'   ; CONFIG_INSTALL ; install= command?
		jnz	short multi_try_n ; no,	check for installhigh
		call	query_user	; query	the user if config_cmd
		jb	short multi_pass_filter	; has the CONFIG_OPTION_QUERY bit set
		call	do_install_exec	; install it.
		jmp	short coff	; to handle next install= command.
; ---------------------------------------------------------------------------

multi_try_n:				; ...
		cmp	ah, 57h	; 'W'   ; CONFIG_INSTALLHIGH ; installhigh= command?
		jnz	short multi_pass_filter
		call	query_user	; query	the user if config_cmd
		jb	short multi_pass_filter	; has the CONFIG_OPTION_QUERY bit set
		mov	ax, 5800h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: get allocation strategy
		mov	bx, ax
		push	bx		; save for the return
		or	bx, 80h		; HIGH_FIRST ; set alloc to HighFirst
		mov	ax, 5801h	; (ALLOCOPER<<8)|1
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	ax, 5802h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) get UMB link state
		xor	ah, ah
		push	ax		; save for the return
		mov	ax, 5803h	; (ALLOCOPER<<8)|3
		mov	bx, 1		; link in UMBs
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		call	do_install_exec	; install it.
		mov	ax, 5803h
		pop	bx		; recover original link	state
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		pop	bx		; recover original alloc strategy
		mov	ax, 5801h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		jmp	coff		; to handle next install= commands.
; ---------------------------------------------------------------------------

multi_pass_filter:			; ...
		cmp	ah, 59h	; 'Y'   ; CONFIG_COMMENT ; comment?
		jz	short multi_pass_adjust
		cmp	ah, 5Ah	; 'Z'   ; CONFIG_UNKNOWN ; bad command?
		jz	short multi_pass_adjust
		cmp	ah, 30h	; '0'   ; CONFIG_REM ; rem?
		jnz	short multi_pass_coff ;	ignore the rest	of the commands.

multi_pass_adjust:			; ...
		dec	chrptr		; these	commands need to
					; adjust chrptr,count
		inc	count		; for newline proc.

multi_pass_coff:			; ...
		jmp	coff		; to handle next install= commands.
; ---------------------------------------------------------------------------

tryb:					; ...
		cmp	ah, 42h	; 'B'   ; CONFIG_BUFFERS
		jnz	short tryc
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short tryc
		mov	p_buffer_slash_x, 0
		mov	di, offset buf_parms
		xor	cx, cx
		mov	dx, cx

do7:					; ...
		call	sysinit_parse
		jnb	short if7	;
					; parse	error,
					; and show messages and	end the	search
		call	badparm_p
		jmp	short sr7
; ---------------------------------------------------------------------------

if7:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL ; end of line?
		jz	short en7	; then jmp to $endloop for semantic check
		cmp	result_val_swoff, offset switch_x ; (/X	switch)
					; [result_val+_$P_Result_Blk.SYNONYM_Ptr]
		jnz	short if11
		jmp	short en11
; ---------------------------------------------------------------------------

if11:					; ...
		mov	ax, word ptr rv_dword ;	[result_val+_$P_Result_Blk.Picked_Val]
		cmp	cx, 1
		jnz	short if13
		mov	p_buffers, ax
		jmp	short en11
; ---------------------------------------------------------------------------

if13:					; ...
		mov	p_h_buffers, ax

en11:					; ...
		jmp	short do7
; ---------------------------------------------------------------------------

en7:					; ...
		cmp	p_buffers, 99
		jbe	short if18
		call	badparm_p
		mov	p_h_buffers, 0
		jmp	short sr7
; ---------------------------------------------------------------------------

if18:					; ...
		mov	ax, p_buffers	; we don't have any problem.
		mov	buffers, ax	; now,let's set it really.
		mov	ax, p_h_buffers
		mov	h_buffers, ax
		mov	ax, linecount
		mov	buffer_linenum,	ax ; save the line number
					; for the future use

sr7:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

tryc:					; ...
		cmp	ah, 43h	; 'C'   ; CONFIG_BREAK
		jnz	short trym
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short trym
		mov	di, offset brk_parms
		xor	cx, cx
		mov	dx, cx

do22:					; ...
		call	sysinit_parse
		jnb	short if22	;
					; parse	error
		call	badparm_p
		jmp	short sr22
; ---------------------------------------------------------------------------

if22:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL ; end of line?
		jz	short en22	; then end the $endloop
		cmp	result_val_itag, 1 ; [result_val+_$P_Result_Blk.Item_Tag]
		jnz	short if26
		mov	p_ctrl_break, 1	; turn it on
		jmp	short en26
; ---------------------------------------------------------------------------

if26:					; ...
		mov	p_ctrl_break, 0	; turn it off

en26:					; ...
		jmp	short do22	; we actually set the ctrl break
; ---------------------------------------------------------------------------

en22:					; ...
		mov	ah, 33h		; SET_CTRL_C_TRAPPING
					; if we	don't have any parse error.
		mov	al, 1
		mov	dl, p_ctrl_break
		int	21h		; DOS -	EXTENDED CONTROL-BREAK CHECKING
					; AL = 00h get state / 01h set state / 02h set AND get
					; DL = 00h for OFF or 01h for ON

sr22:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

trym:					; ...
		cmp	ah, 4Dh	; 'M'   ; CONFIG_MULTITRACK
		jnz	short tryu
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short tryu
		mov	di, offset mtrk_parms
		xor	cx, cx
		mov	dx, cx

do31:					; ...
		call	sysinit_parse
		jnb	short if31	;
					; parse_error
		call	badparm_p	; show message and end the search loop.
		jmp	short sr31
; ---------------------------------------------------------------------------

if31:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL ; end of line?
		jz	short en31
		cmp	result_val_itag, 1 ; [result_val+_$P_Result_Blk.Item_Tag]
		jnz	short if35
		mov	p_mtrk,	1	; turn it on temporarily.
		jmp	short en35
; ---------------------------------------------------------------------------

if35:					; ...
		mov	p_mtrk,	0	; turn it off temporarily.

en35:					; ...
		jmp	short do31	; we actually set the multrk_flag here
; ---------------------------------------------------------------------------

en31:					; ...
		push	ds
		mov	ax, 70h		; DOSBIODATASEG	; BIOSDATA segment
		mov	ds, ax
		assume ds:nothing
		cmp	cs:p_mtrk, 0
		jnz	short if39
		mov	ds:multrk_flag,	1 ; multrk_off2
		jmp	short en39
; ---------------------------------------------------------------------------

if39:					; ...
		mov	ds:multrk_flag,	80h ; multrk_on

en39:					; ...
		pop	ds
		assume ds:nothing

sr31:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

multi_try_doshi:			; ...
		cmp	ah, 48h	; 'H'   ; CONFIG_DOS
		jz	short it_is_h

skip_it:				; ...
		jmp	multi_pass_filter
; ---------------------------------------------------------------------------

it_is_h:				; ...
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short skip_it
		mov	di, offset dos_parms
		xor	cx, cx
		mov	dx, cx

h_do_parse:				; ...
		call	sysinit_parse
		jnb	short h_parse_ok

h_badparm:				; parse	error
		call	badparm_p	; show message and end the search loop.
		jmp	short h_end
; ---------------------------------------------------------------------------

h_parse_ok:				; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL ; end of line?
		jz	short h_end	; then end the $endloop
		call	ProcDOS
		jmp	short h_do_parse
; ---------------------------------------------------------------------------

h_end:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

tryu:					; ...
		cmp	ah, 55h	; 'U'   ; CONFIG_DEVICEHIGH
		jnz	short tryd
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short tryd
		call	InitVar
		call	ParseSize	; process the size= option
		jnb	short tryu_1	;
					; stash	it there in case of an error
		mov	word ptr cs:badparm_ptr, si
		mov	word ptr cs:badparm_ptr+2, es
		call	badparm_p
		jmp	coff
; ---------------------------------------------------------------------------

tryu_1:					; ...
		mov	ax, cs:DevSizeOption
		or	ax, ax
		jnz	short tryu_2
		call	ParseVar
		jnb	short tryu_2
		mov	word ptr cs:badparm_ptr, si ;
					; If ParseVar up there failed, then
					; ES:SI	points to its problem area..
		mov	word ptr cs:badparm_ptr+2, es
		call	badparm_p	; so all we have to do is choke	and
					; die, rather verbosely.
		jmp	coff
; ---------------------------------------------------------------------------

tryu_2:					; ...
		push	si
		push	es

tryu_3:					; ...
		mov	al, es:[si]
		cmp	al, 0Dh		; cr
		jz	short tryu_4
		cmp	al, 0Ah		; lf
		jz	short tryu_4
		call	delim
		jz	short tryu_4
		inc	si
		jmp	short tryu_3
; ---------------------------------------------------------------------------

tryu_4:					; ...
		mov	cs:DevSavedDelim, al ; Save the	delimiter
					; before replacing it with null
		mov	byte ptr es:[si], 0
		pop	es
		pop	si
		call	UmbTest		; See if UMBs are around...
		jnb	short NrmTst	; yep. So do that normal thang.
		mov	cs:DeviceHi, 0	; nope... so load low.
		jmp	short LoadDevice
; ---------------------------------------------------------------------------

NrmTst:					; ...
		mov	cs:DeviceHi, 0
		cmp	cs:DevUMB, 0	; do we	support	UMBs ?
		jz	short LoadDevice ; no, we don't
		mov	cs:DeviceHi, 1
		jmp	short LoadDevice
; ---------------------------------------------------------------------------

tryd:					; ...
		cmp	ah, 44h	; 'D'   ; CONFIG_DEVICE
		jz	short gotd

skip_it2:				; ...
		jmp	tryq
; ---------------------------------------------------------------------------

gotd:					; ...
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short skip_it2
		mov	cs:DeviceHi, 0	; not to be loaded in UMB
		mov	cs:DevSizeOption, 0
		mov	cs:DevSavedDelim, 20h ;	' ' ; In case of DEVICE=
					; the null has to be replaced with a ' '

LoadDevice:				; ...
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	word ptr bpb_addr, si ;
					; pass the command line	to the device
		mov	word ptr bpb_addr+2, es
		mov	word ptr DevCmdLine, si	; save it for ourself
		mov	word ptr DevCmdLine+2, es
		mov	driver_units, 0	; clear	total block units for driver
		call	round
		call	SizeDevice
		jb	short BadFile
		mov	ConvLoad, 1	; Doesn't matter if DeviceHi==0
		mov	al, DeviceHi	; If not using upper memory,
					; ('mov al, [DeviceHi]' is not needed here
					;  because al value is not used	after here)
		or	DeviceHi, 0	; (or al, al) -	Erdogan	Tan - 10/07/2023
		jz	short DevConvLoad ; Skip all this and go on
					; to the actual	load.
		call	GetLoadUMB	; ('mov al, [UmbLoad]' would be better here)
		cmp	al, 0FFh	; -1 ; If umb0 not specified, it's old style
		jz	short DevConvLoad ; so load high even if SIZE= is smaller
		dec	ConvLoad	; 0 ; They specified /L, so use	new loader
		call	GetLoadSize	; Returns size of first	UMB specified
		or	ax, ax
		jz	short tryd_1	; If size is not specified..
		cmp	ax, DevSize	; /L:...,Size <	DevSize?
		jge	short DevConvLoad

tryd_1:					; ...
		mov	ax, DevSize	; Size < DevSize, so write DevSize as
		call	StoLoadSize	; minsize for load UMB.

DevConvLoad:				; ...
		call	InitDevLoad
		mov	ax, DevLoadAddr
		add	ax, DevSize
		jb	short NoMem
		cmp	DevLoadEnd, ax
		jnb	short LoadDev

NoMem:					; ...
		jmp	mem_err
; ---------------------------------------------------------------------------

BadFile:				; ...
		call	RetFromUM	; Does nothing if didn't call HideUMBs
		cmp	byte ptr es:[si], 20h ;	' ' ; blank/space
		jnb	short tryd_2
		jmp	badop
; ---------------------------------------------------------------------------

tryd_2:					; ...
		call	badload
		jmp	coff
; ---------------------------------------------------------------------------

LoadDev:				; ...
		push	es
		pop	ds
		assume ds:nothing
		mov	dx, si		; ds:dx	points to file name
		call	ExecDev		; load device driver using exec	call
		push	ds
		pop	es		; es:si	back to	config.sys
		push	cs
		pop	ds		; ds back to sysinit
		assume ds:SYSINIT
		jb	short BadFile

goodld:					; ...
		push	es
		push	si
		call	RemoveNull
		push	es
		push	si
		push	cs
		pop	es
		assume es:SYSINIT
		push	ds
		push	si
		lds	si, cs:DevEntry
		assume ds:nothing
		test	word ptr [si+4], 8000h ; [si+SYSDEV.ATT],DEVTYP
					; block	device driver?
		jnz	short got_device_com_cont ; no.
		lds	si, cs:DOSINFO	; ds:si	-> sys_var
		cmp	byte ptr [si+20h], 26 ;	[si+SYSI_NUMIO]
					; no more than 26 drive	number
		jb	short got_device_com_cont
		pop	si
		pop	ds
		pop	si		; clear	the stack
		pop	es
		assume es:nothing
		call	RetFromUM	; Do this before we leave
		jmp	badnumblock
; ---------------------------------------------------------------------------

got_device_com_cont:			; ...
		pop	si
		pop	ds
		call	LieInt12Mem
		call	UpdatePDB	; update the PSP:2 value
		cmp	cs:multdeviceflag, 0 ; Pass limit only for
					; the 1st device driver	in the file
		jnz	short skip_pass_limit
		mov	cs:break_addr, 0 ; pass	the limit to the DD
		mov	bx, cs:DevLoadEnd
		mov	cs:break_addr+2, bx

skip_pass_limit:			; ...
		push	ds
		lds	bx, cs:DOSINFO	; ds:bx	-> sys_var
		mov	al, cs:drivenumber ; temporarily use this next drv value
		mov	cs:devdrivenum,	al ; pass drive	number in packet to driver
		mov	ah, al
		xchg	ax, [bx+20h]	; [bx+SYSI_NUMIO]
					; swap with existing values
		pop	ds
		push	ax		; save real sysi_numio/ncds in ax
					;
					; mov word ptr cs:configmsgflag, 0
					; PCDOS	7.1 IBMBIO.COM - SYSINIT:2C5Fh
					; (disable "error in config.sys	line #"	msg)
					; ((before loading -next- device driver))
					; E.TAN	- 10/07/2023
					; ;
		mov	bx, 6		; SYSDEV.STRAT
		call	calldev		; calldev (sdevstrat);
		mov	bx, 8		; SYSDEV.INT
		call	calldev		; calldev (sdevint);
		pop	ax		; get real sysi_numio value
		push	ds
		lds	bx, cs:DOSINFO	; ds:bx	-> sys_var
		mov	[bx+20h], ax	; [bx+SYSI_NUMIO]
					; restore previous/real	value
		pop	ds
		call	TrueInt12Mem
		mov	ax, cs:break_addr ; move break addr from the req packet
		mov	word ptr cs:DevBrkAddr,	ax
		mov	ax, cs:break_addr+2
		mov	word ptr cs:DevBrkAddr+2, ax
		call	RetFromUM	; There	we go... all done.
		cmp	cs:DevUMB, 0
		jz	short tryd_3
		call	AllocUMB

tryd_3:					; ...
		cmp	cs:runhigh, 0FFh
		jnz	short tryd_4
		call	TryToMovDOSHi	; move DOS into	HMA if requsted

tryd_4:					; ...
		pop	si
		pop	ds
		mov	byte ptr [si], 0 ; *p =	0;
		push	cs
		pop	ds
		assume ds:SYSINIT
		jmp	short was_device_com
; ---------------------------------------------------------------------------

badnumblock:				; ...
		push	cs
		pop	ds
		mov	dx, offset badblock ; "\r\nToo many block devices\r\n$"
		call	print

erase_dev_do:				; ...
		call	CheckDoubleSpace ; (Note: 'call CheckDoubleSpace'
					; has been removed at 'erase_dev_do:' pos
					; in PCDOS 7.1 IBMBIO.COM - SYSINIT:2CBAh)
					; Erdogan Tan -	10/07/2023
		pop	si
		pop	es
		push	cs
		pop	ds
		cmp	word ptr cs:configmsgflag, 0 ; is error_line msg disabled ?
		jz	short no_error_line_msg	; yes
		call	error_line	; show "error in config.sys ..." message.
		mov	word ptr cs:configmsgflag, 0 ; set the default value again.

no_error_line_msg:			; ...
		jmp	coff
; ---------------------------------------------------------------------------

was_device_com:				; ...
		mov	ax, word ptr cs:DevBrkAddr+2
		cmp	ax, cs:DevLoadEnd
		jbe	short breakok
		pop	si
		pop	es
		jmp	BadFile
; ---------------------------------------------------------------------------

breakok:				; ...
		lds	dx, cs:DevEntry	; set ds:dx to header
		assume ds:nothing
		mov	si, dx
		les	di, cs:DOSINFO	; es:di	point to dos info
		mov	ax, [si+4]	; [si+SYSDEV.ATT] ; get	attributes
		test	ax, 8000h	; DEVTYP ; test	if block dev
		jz	short isblock
		or	cs:setdevmarkflag, 2 ; for_devmark
		call	DevSetBreak	; go ahead and alloc mem for device

jc_edd:					; ...
		jb	short erase_dev_do ; device driver's init routine failed.
		test	ax, 1		; ISCIN	; is it	a console in?
		jz	short tryclk
		mov	es:[di+0Ch], dx	; [es:di+SYSI_CON]
		mov	word ptr es:[di+0Eh], ds ; [es:di+SYSI_CON+2]

tryclk:					; ...
		test	ax, 8		; ISCLOCK ; is it a clock device?
		jz	short golink
		mov	es:[di+8], dx	; [es:di+SYSI_CLOCK]
		mov	word ptr es:[di+0Ah], ds ; [es:di+SYSI_CLOCK]

golink:					; ...
		jmp	linkit
; ---------------------------------------------------------------------------

isblock:				; ...
		mov	al, cs:unitcount
		or	al, al		; if no	units found, erase the device
		jz	short erase_dev_do
		mov	[si+0Ah], al	; [si+SYSDEV.NAME]
					; number of units in name field
		add	cs:driver_units, al ; keep total for all drivers in file

perdrv:					; warning no device > 127 units
		cbw
		mov	cx, ax
		mov	dh, ah
		mov	dl, es:[di+20h]	; [es:di+SYSI_NUMIO]
					; get number of	devices
		mov	ah, dl
		add	ah, al		; check	for too	many devices
		cmp	ah, 26		; 'A' - 'Z' is 26 devices
		jbe	short ok_block
		jmp	badnumblock
; ---------------------------------------------------------------------------

ok_block:				; ...
		or	cs:setdevmarkflag, 2 ; for_devmark
		call	DevSetBreak	; alloc	the device
		jb	short jc_edd
		add	es:[di+20h], al	; [es:di+SYSI_NUMIO]
					; update the amount
		add	cs:drivenumber,	al ; remember amount for next device
		lds	bx, cs:bpb_addr	; point	to bpb array

perunit:				; ...
		les	bp, cs:DOSINFO
		les	bp, es:[bp+0]	; [es:bp+SYSI_DPB] ; get first dpb

scandpb:				; ...
		cmp	word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB],-1
		jz	short founddpb
		les	bp, es:[bp+19h]	; [es:bp+DPB.NEXT_DPB] ; [es:bp+25]
		jmp	short scandpb
; ---------------------------------------------------------------------------

founddpb:				; ...
		mov	ax, word ptr cs:DevBrkAddr
		mov	es:[bp+19h], ax	; [es:bp+DPB.NEXT_DPB]
		mov	ax, word ptr cs:DevBrkAddr+2
		mov	es:[bp+1Bh], ax	; [es:bp+DPB.NEXT_DPB+2]
		les	bp, cs:DevBrkAddr
		add	word ptr cs:DevBrkAddr,	33 ; DPBSIZ = 33
					; (61 in PCDOS 7.1 IBMBIO.COM)
		call	RoundBreakAddr
		mov	word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB],-1
		mov	byte ptr es:[bp+18h], 0FFh ; [es:bp+DPB.FIRST_ACCESS],-1 ; byte
		mov	si, [bx]	; ds:si	points to bpb
		inc	bx
		inc	bx		; point	to next	bpb
		mov	es:[bp+0], dx	; [es:bp+DPB.DRIVE]
		mov	ah, 53h		; SETDPB ; hidden system call
		int	21h		; DOS -	2+ internal - TRANSLATE	BIOS PARAMETER BLOCK
					; DS:SI	-> BPB (BIOS Parameter Block)
					; ES:BP	-> buffer for DOS Drive	Parameter Block
		mov	ax, es:[bp+2]	; [es:bp+DPB.SECTOR_SIZE]
		push	es
		les	di, cs:DOSINFO	; es:di	point to dos info
		cmp	ax, es:[di+10h]	; [es:di+SYSI_MAXSEC]
		pop	es
		jbe	short iblk_1
		jmp	bad_bpb_size_sector
; ---------------------------------------------------------------------------

iblk_1:					; ...
		push	ds
		push	dx
		lds	dx, cs:DevEntry
		mov	es:[bp+13h], dx	; [es:bp+DPB.DRIVER_ADDR]
		mov	word ptr es:[bp+15h], ds ; [es:bp+DPB.DRIVER_ADDR+2]
		pop	dx
		pop	ds
		inc	dx
		inc	dh
		loop	perunit		; cx = cx - 1
					; cx = remain count from [cs:unitcount]
					; loop until cx	is 0
		push	cs
		pop	ds
		assume ds:SYSINIT
		call	TempCDS

linkit:					; ...
		les	di, cs:DOSINFO	; es:di	= dos table
		mov	cx, es:[di+22h]	; [es:di+SYSI_DEV] ; dx:cx = head of list
		mov	dx, es:[di+24h]	; [es:di+SYSI_DEV+2]
		lds	si, cs:DevEntry	; ds:si	= device location
		assume ds:nothing
		mov	es:[di+22h], si	; set head of list in dos
					; [es:di+SYSI_DEV]
		mov	word ptr es:[di+24h], ds ; [es:di+SYSI_DEV+2]
		mov	ax, [si]	; get pointer to next device
		mov	word ptr cs:DevEntry, ax ; and save it
		mov	[si], cx	; link in the driver
		mov	[si+2],	dx
		pop	si
		pop	es
		inc	ax		; ax = 0FFFFh (no more devs if yes)?
		jz	short coffj3
		inc	cs:multdeviceflag ; possibly multiple device driver.
		call	DevBreak
		jmp	goodld		; otherwise pretend we loaded it in
; ---------------------------------------------------------------------------

coffj3:					; ...
		mov	cs:multdeviceflag, 0 ; reset the flag
		call	DevBreak
		call	CheckProtmanArena ; adjust alloclim if Protman$	just
					; created a bogus arena	to try
					; to protect some of its resident-
					; init code.
		call	CheckDoubleSpace ;
					; inquire of MagicDrv whether it is present,
					; and final located
		jmp	coff
multi_pass	endp


; =============== S U B	R O U T	I N E =======================================


CheckDoubleSpace proc near		; ...
		cmp	cs:MagicHomeFlag, 0 ; already home?
		jnz	short no_more_magic_calls ; nothing more to do if so
		mov	ax, 4A11h	; multMagicdrv
		mov	bx, 0		; MD_VERSION
		int	2Fh		;  ch =	number of MagicDrv drive letters
		or	ax, ax		; is it	there?
		jnz	short no_more_magic_calls ; done if not
		test	dx, 8000h	; is it	final placed?
		jnz	short magic_not_yet_home ; skip	if not
		mov	cs:MagicHomeFlag, 0FFh ; set the flag!
		add	cs:drivenumber,	ch ; add number	of MagicDrv volumes to
					; the drive number we'll pass to the
					; next loadable	block device.
		jmp	short no_more_magic_calls ; and	finished.
					; (retn)
; ---------------------------------------------------------------------------

magic_not_yet_home:			; ...
		push	es
		push	si
		mov	cx, cs:memhi	; pass it a work buffer
		mov	dx, cs:ALLOCLIM	; address in cx	(segment)
		sub	dx, cx		; for len dx (paragraphs)
		mov	bx, 2
		mov	al, cs:driver_units ; shuffle magicdrives and new drives
					; by this many units
		mov	ah, 55h		; backdoor won't shuffle unless it
					; sees this, to	prevent	bad things
					; from happening if people run the
					; new driver with an old (dos) BIOS
		call	cs:Magicbackdoor
		pop	si
		pop	es

no_more_magic_calls:			; ...
		retn
CheckDoubleSpace endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR multi_pass

bad_bpb_size_sector:			; ...
		pop	si
		pop	es
		mov	dx, offset badsiz_pre ;	"\r\nSector size too large in file $"
		mov	bx, offset crlfm ; "\r\n$"
		call	prnerr
		jmp	coff
; ---------------------------------------------------------------------------

tryq:					; ...
		cmp	ah, 51h	; 'Q'   ; CONFIG_COUNTRY
		jz	short tryq_cont

skip_it3:				; ...
		jmp	tryf
; ---------------------------------------------------------------------------

tryq_cont:				; ...
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short skip_it3
		mov	byte ptr cs:cntry_drv, 0 ;
					; reset	the drive,path to default value.
		mov	cs:p_code_page,	0
		mov	di, offset cntry_parms
		xor	cx, cx
		mov	dx, cx

do52:					; ...
		call	sysinit_parse
		jnb	short if52	; parse	error,check error code and
		call	cntry_error	; show message and end the search loop.
		mov	cs:p_cntry_code, 0FFFFh	; -1 ; signals that parse error.
		jmp	short sr52
; ---------------------------------------------------------------------------

if52:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL ; end of line?
		jz	short sr52
		cmp	cs:result_val, 1 ; _$P_Number
		jnz	short if56
		mov	ax, word ptr cs:rv_dword ;
					; [cs:result_val+_$P_Result_Blk.Picked_Val]
		cmp	cx, 1
		jnz	short if57
		mov	cs:p_cntry_code, ax
		jmp	short en57
; ---------------------------------------------------------------------------

if57:					; ...
		mov	cs:p_code_page,	ax

en57:					; ...
		jmp	short en56	; path entered
; ---------------------------------------------------------------------------

if56:					; ...
		push	ds
		push	es
		push	si
		push	di
		push	cs
		pop	es
		assume es:SYSINIT
		lds	si, cs:rv_dword	; move the path	to known place.
		mov	di, offset cntry_drv ; "A:"
		call	move_asciiz
		pop	di
		pop	si
		pop	es
		assume es:nothing
		pop	ds

en56:					; ...
		jmp	short do52
; ---------------------------------------------------------------------------

sr52:					; ...
		cmp	cs:p_cntry_code, 0FFFFh	; -1 ; had a parse error?
		jnz	short tryq_open
		jmp	coff
; ---------------------------------------------------------------------------

tryqbad:				; ...
		stc
		mov	dx, offset badcountry ;	"\r\nInvalid country code or code page\r"...
		jmp	tryqchkerr
; ---------------------------------------------------------------------------

tryq_open:				; ...
		cmp	byte ptr cs:cntry_drv, 0 ; "A:"
		jz	short tryq_def
		mov	dx, offset cntry_drv ; "A:"
		jmp	short tryq_openit
; ---------------------------------------------------------------------------

tryq_def:				; ...
		mov	dx, offset cntry_root

tryq_openit:				; ...
		mov	ax, 3D00h	; open a file
		stc
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short tryqfilebad
		mov	cs:cntryfilehandle, ax ; save file handle
		mov	bx, ax
		mov	ax, cs:p_cntry_code
		mov	dx, cs:p_code_page ; ax=country	id, bx=filehandle
		mov	cx, cs:memhi
		add	cx, 384		; need 6k buffer to handle country.sys
					; (384*16 bytes)
		cmp	cx, cs:ALLOCLIM
		ja	short tryqmemory ; cannot allocate the buffer for country.sys
		mov	si, offset cntry_drv ; "A:"
		cmp	byte ptr [si], 0 ; default path?
		jnz	short tryq_set_for_dos ; no
		inc	si
		inc	si		; ds:si	-> cntry_root

tryq_set_for_dos:			; ...
		les	di, cs:sysi_country ; es:di -> country info tab	in dos
		push	di		; save di
		add	di, 8		; country_cdpg_info.ccPath_CountrySys
		call	move_asciiz	; set the path to country.sys in dos.
		pop	di		; es:di	-> country info	tab again.
		mov	cx, cs:memhi
		mov	ds, cx
		xor	si, si		; ds:si	-> 2k buffer to	be used.
		call	setdoscountryinfo ; now	do the job!
		jnb	short tryqchkerr ; read	error or could not find	country,
					; code page combination
		cmp	cx, 0FFFFh	; -1
					; could	not find matching country_id, code page?
		jz	short tryqbad	; then "invalid	country	code or	code page"

tryqfilebad:				; ...
		push	cs
		pop	es
		assume es:SYSINIT
		cmp	byte ptr cs:cntry_drv, 0 ; is the default file used?
		jz	short tryqdefbad
		mov	si, offset cntry_drv ; "A:"
		jmp	short tryqbadload
; ---------------------------------------------------------------------------

tryqdefbad:				; ...
		mov	si, offset cntry_root ;	default	file has been used.
					; es:si	-> \country.sys	in sysinit_seg

tryqbadload:				; ...
		call	badload
		mov	cx, cs:CONFBOT
		mov	es, cx		; restore es ->	confbot.
		assume es:nothing
		jmp	short coffj4
; ---------------------------------------------------------------------------

tryqmemory:				; ...
		mov	dx, offset insufmemory ; "\r\nInsufficient memory for COUNTRY.SYS"...

tryqchkerr:				; ...
		mov	cx, cs:CONFBOT
		mov	es, cx		; restore es ->	confbot	seg
		push	cs
		pop	ds		; restore ds to	sysinit_seg
		assume ds:SYSINIT
		jnb	short coffj4	; if no	error,then exit
		call	print		; else show error message
		call	error_line

coffj4:					; ...
		mov	bx, cs:cntryfilehandle ; close a file.
					; don't care even if it fails.
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	coff
; END OF FUNCTION CHUNK	FOR multi_pass

; =============== S U B	R O U T	I N E =======================================


cntry_error	proc near		; ...
		cmp	ax, 6		; _$P_Out_Of_Range
		jnz	short if64
		mov	dx, offset badcountry ;	"\r\nInvalid country code or code page\r"...
		jmp	short en64
; ---------------------------------------------------------------------------

if64:					; ...
		mov	dx, offset badcountrycom ; "\r\nError in COUNTRY command\r\n$"

en64:					; ...
		call	print
		call	error_line
		retn
cntry_error	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR multi_pass

tryf:					; ...
		cmp	ah, 46h	; 'F'   ; CONFIG_FILES
		jnz	short tryl
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short tryl
		mov	di, offset files_parms
		xor	cx, cx
		mov	dx, cx

do67:					; ...
		call	sysinit_parse
		jnb	short if67	;
					; parse	error
					; show messages	and end	the search loop.
		call	badparm_p
		jmp	short sr67
; ---------------------------------------------------------------------------

if67:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL ; end of line?
		jz	short en67	; then end the $endloop
		mov	al, byte ptr cs:rv_dword ;
					; [result_val+_$P_Result_Blk.Picked_Val]
		mov	cs:p_files, al	; save it temporarily
		jmp	short do67
; ---------------------------------------------------------------------------

en67:					; ...
		mov	al, cs:p_files
		mov	cs:FILES, al	; no error. really set the value now.

sr67:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

tryl:					; ...
		cmp	ah, 4Ch	; 'L'   ; CONFIG_LASTDRIVE
		jnz	short tryp
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short tryp
		mov	di, offset ldrv_parms
		xor	cx, cx
		mov	dx, cx

do73:					; ...
		call	sysinit_parse
		jnb	short if73	;
					; parse	error
					; show messages	and end	the search loop.
		call	badparm_p
		jmp	short badparm_p_coff
; ---------------------------------------------------------------------------

if73:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL ; end of line?
		jz	short en73	; then end the $endloop
		mov	al, byte ptr cs:rv_dword ; [rv_byte]
					; pick up the drive number
		mov	cs:p_ldrv, al	; save it temporarily
		jmp	short do73
; ---------------------------------------------------------------------------

en73:					; ...
		mov	al, cs:p_ldrv
		mov	cs:NUM_CDS, al	; no error.
					; really set the value now.

badparm_p_coff:				; ...
		jmp	coff
; ---------------------------------------------------------------------------

tryp:					; ...
		cmp	ah, 50h	; 'P'   ; CONFIG_DRIVPARM
		jnz	short tryk
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short tryk
		call	parseline
		jb	short trypbad
		call	setparms
		call	diddleback
		jmp	coff
; ---------------------------------------------------------------------------

trypbad:				; ...
		jmp	badop
; ---------------------------------------------------------------------------

tryk:					; ...
		cmp	ah, 4Bh	; 'K'   ; CONFIG_STACKS
		jz	short do_tryk

skip_it4:				; ...
		jmp	trys
; ---------------------------------------------------------------------------

do_tryk:				; ...
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short skip_it4
		mov	di, offset stks_parms
		xor	cx, cx
		mov	dx, cx

do79:					; ...
		call	sysinit_parse
		jnb	short if79	; parse	error
		mov	dx, offset badstack ; "\r\nInvalid STACK parameters\r\n$"
		call	print		; show messages	and end	the search loop.
		call	error_line
		jmp	sr79		; (jmp coff)
; ---------------------------------------------------------------------------

if79:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL ; end of line?
		jz	short en79	; then end the $endloop
		mov	ax, word ptr cs:rv_dword ;
					; [cs:result_val+_$P_Result_Blk.Picked_Val]
		cmp	cx, 1
		jnz	short if83
		mov	cs:p_stack_count, ax
		jmp	short en83
; ---------------------------------------------------------------------------

if83:					; ...
		mov	cs:p_stack_size, ax

en83:					; ...
		jmp	short do79
; ---------------------------------------------------------------------------

en79:					; ...
		cmp	cs:p_stack_count, 0
		jz	short if87
		cmp	cs:p_stack_count, 8 ; mincount
		jb	short ll88
		cmp	cs:p_stack_size, 32 ; minsize
		jnb	short if88

ll88:					; ...
		mov	cs:p_stack_count, 0FFFFh

if88:					; ...
		jmp	short en87
; ---------------------------------------------------------------------------

if87:					; ...
		cmp	cs:p_stack_size, 0
		jz	short en87
		mov	cs:p_stack_count, 0FFFFh ; -1 ;	invalid

en87:					; ...
		cmp	cs:p_stack_count, 0FFFFh ; -1 ;	invalid?
		jnz	short if94
		mov	cs:stack_count,	9 ; defaultcount
					; reset	to default value.
		mov	cs:stack_size, 128 ; defaultsize
		mov	cs:stack_addr, 0 ; stacks= been	accepted.
		mov	dx, offset badstack ; "\r\nInvalid STACK parameters\r\n$"
		call	print
		call	error_line
		jmp	short sr79
; ---------------------------------------------------------------------------

if94:					; ...
		mov	ax, cs:p_stack_count
		mov	cs:stack_count,	ax
		mov	ax, cs:p_stack_size
		mov	cs:stack_size, ax
		mov	cs:stack_addr, 0FFFFh ;	-1 ; stacks= been accepted.

sr79:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

trys:					; ...
		cmp	ah, 53h	; 'S'   ; CONFIG_SHELL
		jnz	short tryx
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short tryx
		mov	cs:newcmd, 1
		mov	word ptr cs:command_line, 0 ;
					; zap length,first byte	of command-line
		mov	di, (offset commnd+1) ;	we already have	the first char
		mov	[di-1],	al	; of the new shell in AL, save it now

storeshell:				; ...
		call	getchr
		or	al, al		; this is the normal case: "organize"
		jz	short getshparms ; put a ZERO right after the filename
		cmp	al, 20h	; ' '   ; this may happen if there are no args
		jb	short endofshell ; I suppose...
		mov	[di], al
		inc	di
		cmp	di, offset commnd_63 ; commnd+63
					; this makes sure we don't overflow
					; commnd (the filename)
		jb	short storeshell
		jmp	short endofshell
; ---------------------------------------------------------------------------

getshparms:				; ...
		mov	byte ptr [di], 0 ; zero-terminate the filename
		mov	di, (offset command_line+1) ;
					; prepare to process the command-line

parmloop:				; ...
		call	getchr
		cmp	al, 20h	; ' '
		jb	short endofparms
		mov	[di], al
		inc	di
		cmp	di, offset command_line_126 ; command_line+126
		jb	short parmloop

endofparms:				; ...
		mov	cx, di
		sub	cx, (offset command_line+1)
		mov	byte ptr cs:command_line, cl ; "\x02/P"

endofshell:				; ...
		mov	byte ptr [di], 0 ; zero-terminate the filename
					; (or the command-line as the case may be)

skipline:				; ...
		cmp	al, 0Ah		; lf ; the safest way to eat the rest of
		jz	short endofline	; the line: watch for ever-present LF
		call	getchr
		jnb	short skipline

endofline:				; ...
		jmp	conflp
; ---------------------------------------------------------------------------

tryx:					; ...
		cmp	ah, 58h	; 'X'   ; CONFIG_FCBS
		jnz	short try1
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short try1
		mov	di, 2153h
		xor	cx, cx
		mov	dx, cx

do98:					; ...
		call	sysinit_parse
		jnb	short if98
		call	badparm_p	; parse	error
					; show messages	and end	the search loop.
		jmp	short sr98
; ---------------------------------------------------------------------------

if98:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL ; end of line?
		jz	short en98	; then end the $endloop
		mov	al, byte ptr cs:rv_dword ;
					; [cs:result_val+_$P_Result_Blk.Picked_Val]
		cmp	cx, 1		; the first positional?
		jnz	short if102
		mov	cs:p_fcbs, al
		jmp	short en102
; ---------------------------------------------------------------------------

if102:					; ...
		mov	cs:p_keep, al

en102:					; ...
		jmp	short do98
; ---------------------------------------------------------------------------

en98:					; ...
		mov	al, cs:p_fcbs
		mov	cs:FCBS, al
		mov	cs:KEEP, 0

sr98:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

try1:					; ...
		cmp	ah, 31h	; '1'   ; CONFIG_SWITCHES
					; switches= command entered?
		jz	short do_try1	; yes

skip_it5:				; ...
		jmp	tryv
; ---------------------------------------------------------------------------

do_try1:				; ...
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short skip_it5
		mov	di, offset swit_parms
		xor	cx, cx
		mov	dx, cx

do110:					; ...
		call	sysinit_parse
		jnb	short if110	;
					; parse	error
					; show messages	and end	the search loop.
		call	badparm_p
		jmp	short sr110
; ---------------------------------------------------------------------------

if110:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL ; end of line?
		jz	short en110	; then jmp to $endloop for semantic check
		cmp	cs:result_val_swoff, offset swit_k ; offset "/K"
					; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
		jnz	short if115
		mov	cs:p_swit_k, 1	; set the flag
		jmp	short do110
; ---------------------------------------------------------------------------

if115:					; ...
		cmp	cs:result_val_swoff, offset swit_t ; offset "/T"
					; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
		jnz	short if116
		mov	cs:p_swit_t, 1	; set the flag
		jmp	short do110
; ---------------------------------------------------------------------------

if116:					; ...
		cmp	cs:result_val_swoff, offset swit_w ; "/W"
		jnz	short do110
		mov	cs:p_swit_w, 1	; set the flag
		jmp	short do110
; ---------------------------------------------------------------------------

en110:					; ...
		cmp	cs:p_swit_k, 1	; if /k	entered,
		push	ds
		mov	ax, 70h		; DOSBIODATASEG	; BIOSDATA segment
		mov	ds, ax
		assume ds:nothing
		jnz	short if117
		mov	ds:keyrd_func, 0 ; BIOSDATA:04E5h
					; use the conventional keyboard	functions
		mov	ds:keysts_func,	1 ; BIOSDATA:04E6h

if117:					; ...
		mov	al, cs:p_swit_t
		mov	ds:t_switch, al
		cmp	cs:p_swit_w, 0
		jz	short skip_dos_flag
		push	es
		push	bx
		mov	ah, 52h		; GET_IN_VARS
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		or	byte ptr es:86h, 2 ; [es:DOS_FLAG_OFFSET], SUPPRESS_WINA20
		pop	bx
		pop	es

skip_dos_flag:				; ...
		pop	ds
		assume ds:nothing

sr110:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

tryv:					; ...
		cmp	ah, 56h	; 'V'   ; CONFIG_SET ; set var=value<cr/lf>
		jnz	short tryn
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short tryn
		call	copy_envvar	; copy var at ES:SI to "config_wrkseg"
		jnb	short sr110	; no error

err:					; ...
		call	error_line	; whoops, display error	in line	XXX
		jmp	short sr110	; jump to coff (to skip	to next	line)
; ---------------------------------------------------------------------------

tryn:					; ...
		cmp	ah, 4Eh	; 'N'   ; CONFIG_NUMLOCK ; numlock=on|off
		jnz	short tryy
		call	query_user	; query	the user if config_cmd
					; has the CONFIG_OPTION_QUERY bit set
		jb	short tryy
		call	set_numlock
		jb	short err
		jmp	short sr110	; all done
; ---------------------------------------------------------------------------

tryy:					; ...
		cmp	ah, 59h	; 'Y'   ; CONFIG_COMMENT
					; (do nothing with this	line.)
		jnz	short try0

donothing:				; ...
		dec	ds:chrptr
		inc	ds:count
		jmp	coff
; ---------------------------------------------------------------------------

try0:					; ...
		cmp	ah, 30h	; '0'   ; CONFIG_REM
					; (do nothing with this	line.)
		jz	short donothing
		cmp	ah, 0FFh	; null/bogus command?
		jz	short donothing
		dec	ds:chrptr
		inc	ds:count
		jmp	short badop
; END OF FUNCTION CHUNK	FOR multi_pass

; =============== S U B	R O U T	I N E =======================================


CheckProtmanArena proc near		; ...
		push	es		; adjusts alloclim if Protman$
					; reduced our arena through a manual hack
		mov	ax, cs:area	; get our arena	header
		dec	ax
		mov	es, ax
		add	ax, es:3	; [es:ARENA.SIZE] ; find end of	arena
		inc	ax
		cmp	ax, cs:ALLOCLIM	; is it	less than alloclim?
		ja	short CheckProtmanDone
		mov	cs:ALLOCLIM, ax	; reduce alloclim then

CheckProtmanDone:			; ...
		pop	es
		retn
CheckProtmanArena endp


; =============== S U B	R O U T	I N E =======================================


sysinit_parse	proc near		; ...
		push	es		; set up registers for sysparse
					; in:
					;    es:si -> command line in confbot
					;	di -> offset of	the parse control definition.
					; out:
					;    calls sysparse.
					;    carry will	set if parse error.
					;    *** the caller should check the eol condition by looking at ax
					;    *** after each call.
					;    *** if no parameters are found,then ax will contain a error code.
					;    *** if the	caller needs to	look at	the synomym@ of	the result,
					;    *** the caller should use cs:@ instead of es:@.
					;    cx	should be set to 0 at the 1st time the caller calls this proc.
					;    ax	- exit code
					;    bl	- terminated delimeter code
					;    cx	- new positional ordinal
					;    si	- set to pase scanned operand
					;    dx	- selected result buffer
		push	ds
		push	es		; now ds:si -> command line
		pop	ds
		push	cs
		pop	es		; now es:di -> control definition
		assume es:SYSINIT
		mov	word ptr cs:badparm_ptr+2, ds ;	save the pointer to the	parm
		mov	word ptr cs:badparm_ptr, si ; we are about to parse for	badparm	msg.
		mov	dx, 0
		call	SysParse
		cmp	ax, 0		; _$P_No_Error ; no error
		jz	short ll4	; cf=0
		cmp	ax, 0FFFFh	; _$P_RC_EOL ; end of line?
		jnz	short if4	; or the end of	line?

ll4:					; ...
		clc
		jmp	short en4
; ---------------------------------------------------------------------------

if4:					; ...
		stc

en4:					; ...
		pop	ds
		pop	es
		assume es:nothing
		retn
sysinit_parse	endp

; ---------------------------------------------------------------------------

badop_p:				; 'badop_p' is not used in
		push	cs		; MSDOS	6.21 IO.SYS and	PCDOS 7.1 IBMBIO.COM
					; (but it was/is not removed)
					; Erdogan Tan -	11/07/2023
		pop	ds
		assume ds:SYSINIT
		mov	dx, offset badopm ; "\r\nUnrecognized command in CONFIG.SYS"
		call	print
		call	error_line
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR multi_pass

badop:					; ...
		mov	dx, offset badopm ; "\r\nUnrecognized command in CONFIG.SYS"
		call	print
		call	error_line
		jmp	coff
; END OF FUNCTION CHUNK	FOR multi_pass

; =============== S U B	R O U T	I N E =======================================


badparm_p	proc near		; ...
		push	ds
		push	dx
		push	si
		push	cs
		pop	ds
		mov	dx, offset badparm ; "\r\nBad command or parameters - $"
		call	print
		lds	si, badparm_ptr
		assume ds:nothing

do1:					; ...
		mov	dl, [si]	; print	"xxxx" until cr.
		cmp	dl, 0Dh		; cr ?
		jz	short en1	; yes
		mov	ah, 2		; display character
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		inc	si
		jmp	short do1
; ---------------------------------------------------------------------------

en1:					; ...
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	dx, offset crlfm ; "\r\n$"
		call	print
		call	error_line
		pop	si
		pop	dx
		pop	ds
		assume ds:nothing
		retn
badparm_p	endp


; =============== S U B	R O U T	I N E =======================================


getchr		proc near		; ...
		push	cx
		mov	cx, ds:count
		jcxz	short nochar
		mov	si, ds:chrptr
		mov	al, es:[si]
		dec	ds:count
		inc	ds:chrptr
		clc

get_ret:				; ...
		pop	cx
		retn
; ---------------------------------------------------------------------------

nochar:					; ...
		stc
		jmp	short get_ret
getchr		endp

; ---------------------------------------------------------------------------

incorrect_order:			; 'incorrect_order' is not used in
		mov	dx, offset badorder ; MSDOS 6.21 IO.SYS	and PCDOS 7.1 IBMBIO.COM
					; (but it was/is not removed)
					; Erdogan Tan -	11/07/2023
		call	print
		call	showlinenum
		retn

; =============== S U B	R O U T	I N E =======================================


error_line	proc near		; ...
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	dx, offset errorcmd ; "Error in	CONFIG.SYS line	$"
		call	print
		call	showlinenum
		retn
error_line	endp


; =============== S U B	R O U T	I N E =======================================


showlinenum	proc near		; ...
		push	es
		push	ds
		push	di
		push	cs
		pop	es
		assume es:SYSINIT
		push	cs
		pop	ds
		mov	di, (offset showcount+4) ;
					; di ->	the least significant decimal field.
		mov	cx, 10
		mov	ax, cs:linecount

sln_loop:				; ...
		cmp	ax, 10		; < 10 ?
		jb	short sln_last	; yes
		xor	dx, dx
		div	cx		; cx = 10
		or	dl, 30h		; convert to ascii numeric char	("0" to	"9")
		mov	[di], dl
		dec	di
		jmp	short sln_loop
; ---------------------------------------------------------------------------

sln_last:				; ...
		or	al, 30h		; convert to ascii numeric char	("0" to	"9")
		mov	[di], al
		mov	dx, di
		call	print		; show it
		pop	di
		pop	ds
		assume ds:nothing
		pop	es
		assume es:nothing
		retn
showlinenum	endp


; =============== S U B	R O U T	I N E =======================================


ProcDOS		proc near		; ...
		xor	ah, ah
		mov	al, cs:result_val_itag ;
					; [cs:result_val+_$P_Result_Blk.Item_Tag]
					;
					; result_val._$P_item_tag
					;	   = 1 for DOS=HIGH
					;	   = 2 for DOS=LOW
					;	   = 3 for DOS=UMB
					;	   = 4 for DOS=NOUMB
		dec	ax
		jz	short pd_hi
		dec	ax
		jz	short pd_lo
		dec	ax
		jz	short pd_umb
		mov	cs:DevUMB, 0
		retn
; ---------------------------------------------------------------------------

pd_umb:					; ...
		mov	cs:DevUMB, 0FFh
		retn
; ---------------------------------------------------------------------------

pd_lo:					; ...
		mov	cs:runhigh, 0
		retn
; ---------------------------------------------------------------------------

pd_hi:					; ...
		mov	cs:runhigh, 0FFh
		retn
ProcDOS		endp


; =============== S U B	R O U T	I N E =======================================


LieInt12Mem	proc near		; ...
		mov	ax, cs:ALLOCLIM	; lie INT 12h as alloclim
					; assuming that	it is 3Com
		call	IsIt3Com	; Is it	3Com driver?
		jz	short lim_set	; yes, lie to him differently
		cmp	cs:DeviceHi, 0	; Is the DD being loaded in UMB
		jz	short limx	; no, don't lie
		mov	ax, cs:DevLoadEnd ; lie	INT 12h	as end of UMB

lim_set:				; ...
		call	SetInt12Mem

limx:					; ...
		retn
LieInt12Mem	endp


; =============== S U B	R O U T	I N E =======================================


SetInt12Mem	proc near		; ...
		push	ds
		mov	bx, 40h		; ROMBIOS data area segment
		mov	ds, bx
		assume ds:nothing
		mov	bx, ds:13h	; memory size (KB)
		mov	cs:OldInt12Mem,	bx
		mov	cl, 6		; 16*64	= 1024
		shr	ax, cl		; convert paragraphs to	kilobyte
		mov	ds:13h,	ax
		mov	cs:Int12Lied, 0FFh ; mark that we are lying
		pop	ds
		assume ds:nothing
		retn
SetInt12Mem	endp


; =============== S U B	R O U T	I N E =======================================


TrueInt12Mem	proc near		; ...
		cmp	cs:Int12Lied, 0	; were we lying	so far?
		mov	cs:Int12Lied, 0
		jz	short timx	; yes
					; no, we weren't
		push	ds
		mov	ax, 40h
		mov	ds, ax
		assume ds:nothing
		mov	ax, cs:OldInt12Mem
		mov	ds:13h,	ax	; restore INT 12h memory
		pop	ds
		assume ds:nothing

timx:					; ...
		retn
TrueInt12Mem	endp


; =============== S U B	R O U T	I N E =======================================


IsIt3Com	proc near		; ...
		push	ds
		push	es
		push	si
		lds	si, cs:DevEntry	; ptr to device	header
		add	si, 10		; SYSDEV.NAME ;	ptr device name
		push	cs
		pop	es
		assume es:SYSINIT
		mov	di, offset ThreeComName	; "PROTMAN$"
		mov	cx, 8		; name length
		repe cmpsb
		pop	si
		pop	es
		assume es:nothing
		pop	ds
		retn
IsIt3Com	endp


; =============== S U B	R O U T	I N E =======================================


UpdatePDB	proc near		; ...
		push	ds
		mov	ah, 62h
		int	21h		; DOS -	3+ - GET PSP ADDRESS
		mov	ds, bx
		mov	bx, cs:ALLOCLIM
		mov	ds:2, bx	; [PDB.BLOCK_LEN]
		pop	ds
		retn
UpdatePDB	endp


; =============== S U B	R O U T	I N E =======================================


InitVar		proc near		; ...
		push	ax
		push	cx
		push	di
		push	es
		push	cs
		pop	es
		assume es:SYSINIT
		xor	ax, ax		; 0
		mov	es:fUmbTiny, al	; Shrink UMBs? (made 1 if /S given)
		mov	es:fInHigh, al	; Set to 1 when	DH/LH has been called
		mov	es:SegLoad, ax	; Load Address (seg), used for DH only
		mov	es:UmbLoad, 0FFh ; UNSPECIFIED
					; Later	is the # of the	1st spec'd UMB
		mov	es:fm_argc, al	; Start	with zero args having been read
		cld
		mov	cx, 16		; MAXUMB
		mov	di, offset UmbUsed ;
					; For each entry on the	UmbUsed	array,
		rep stosb		; Store	0
		mov	cx, 16		; MAXUMB
		mov	di, offset UmbSize ; Okay...
					; for each entry on the	UmbSize	array,
		rep stosw		; Store	0
		pop	es
		assume es:nothing
		pop	di
		pop	cx
		pop	ax
		retn
InitVar		endp


; =============== S U B	R O U T	I N E =======================================


FixMem		proc near		; ...
		push	ax		; scans	the upper memory chain
					; and concatenates adjacent free MCBs
		push	bx
		push	cx
		push	dx
		push	es
		call	fm_link		; Link in UMBs
		call	UmbHead		; Get first upper-memory MCB address (0x9FFF)
		jb	short fmX	; (if couldn't get it, leave now).
		mov	es, ax		; It returns in	AX, so move it to ES.
		xor	dx, dx		; We're keeping the address of the last MCB
		mov	cx, dx		; in CX... and the last	owner
		inc	dx		; in dx	as we go through the loop

fm10:					; ...
		mov	al, es:0	; [es:ARENA.SIGNATURE]
					; if 'Z', don't repeat loop
		mov	bx, es:1	; [es:ARENA.OWNER] ; if	not zero, do nothing
		or	bx, dx		; dx was owner of previous MCB
		jnz	short fm30	; If not both zero, don't cat.

fm20:					; [es:ARENA.SIZE]
		mov	bx, es:3	; Grab this block's Size,
		mov	es, cx		; Go back to prev MCB's address
		assume es:nothing
		mov	byte ptr es:0, al ; [es:ARENA.SIGNATURE]
					; & move the SECOND sig	here
		add	bx, es:3	; [es:ARENA.SIZE]
					; Size += first	MCB's size
		add	bx, 1		; And add one for the header
		mov	es:3, bx	; [es:ARENA.SIZE] ; Write the size

fm30:					; ...
		mov	cx, es		; Save MCB address
		mov	dx, word ptr es:1 ; [es:ARENA.OWNER] ; And remember its	owner
		mov	bx, es		; Move to the next MCB
		add	bx, es:DosDataSg
		inc	bx
		mov	es, bx
		assume es:nothing
		cmp	al, 5Ah	; 'Z'   ; arena_signature_end
		jnz	short fm10	; If signature != 'Z', there are more.

fmX:					; ...
		call	fm_unlink	; Unlink UMBs
		pop	es
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
FixMem		endp


; =============== S U B	R O U T	I N E =======================================


fm_link		proc near		; ...
		mov	ax, 5802h	; DOS_CHECK_UMBLINK
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) get UMB link state
		push	es
		push	cs
		pop	es
		assume es:SYSINIT
		mov	es:fm_umb, al	; store	current	link-state (to use/set later)
		pop	es
		assume es:nothing
		mov	ax, 5803h
		mov	bx, 1
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		retn
fm_link		endp


; =============== S U B	R O U T	I N E =======================================


fm_unlink	proc near		; ...
		xor	bx, bx
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	bl, fm_umb	; old link-state (to set again)
		pop	ds
		assume ds:nothing
		mov	ax, 5803h	; DOS_SET_UMBLINK
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		retn
fm_unlink	endp


; =============== S U B	R O U T	I N E =======================================


ParseVar	proc near		; ...
		push	di		; parses [/S][/L:umb[,size][;umb[,size]]*]
					;   and	builds the table laid out in highvar.inc
					; ENTRY:
					;   ES:SI points to command tail of LoadHigh/DeviceHigh
					;	(whitespace ok)
					; EXIT:
					;   ES:SI points to first character in child program name
		push	ds
		push	es
		push	es		; Make DS:SI point to it, as well as ES:SI
		pop	ds		; (regardless if we're in devhigh or loadhigh)
		cld

pv10:					; ...
		lodsb			; here,	ES:SI=="  /L..."--must eat whitespace
		call	isWhite
		jz	short pv10	; ES:SI==" /L..."--keep	eating.
		cmp	al, 2Fh	; '/'   ; SWTCH ; ES:SI=="/L..."--go process a switch
		jz	short pv20
		dec	si		; Backup--it's now "odule options", and we need
		clc			; that "m" we just read	(or whatever it	is).
		jmp	short pvX	; Then return with carry clear == we're done.
; ---------------------------------------------------------------------------

pv20:					; ...
		lodsb			; Just read 'S' or 'L', hopefully
		and	al, 0DFh	; So we	make it	upper-case, and...
		cmp	al, 53h	; 'S'   ; just read 'S'?
		jnz	short pv30
		call	incArgc		; If it's /S, it's another arg for LH to skip.
					;
					; Note:	'inc byte [cs:fm_argc]' would be enough here
					; Erdogan Tan -	19/04/2019 (Retro DOS v4) - 11/07/2023
		push	es
		push	cs
		pop	es
		assume es:SYSINIT
		mov	es:fUmbTiny, 1	; /S, so ES:SI=="  /L..." or " module opts", or
		pop	es
		assume es:nothing
		jmp	short pv10	; possibly even	"/L...".
; ---------------------------------------------------------------------------

pv30:					; ...
		cmp	al, 4Ch	; 'L'   ; If it's not 'L' either, then it's a bad switch!
		jnz	short pvE1
		call	incArgc
		call	parseL		; If no	carry, go back and look	for more
		jnb	short pv10
		dec	si		; Else,	back up	and exit.
		jmp	short pvErr	; AX has already been set by parseL
; ---------------------------------------------------------------------------

pvE1:					; ...
		mov	ax, 3		; PV_InvSwt ; Unrecognized switch passed

pvErr:					; ...
		dec	si
		dec	si
		stc

pvX:					; ...
		pop	es
		pop	ds
		pop	di
		retn
ParseVar	endp


; =============== S U B	R O U T	I N E =======================================


parseL		proc near		; ...
		lodsb
		cmp	al, 3Ah	; ':'   ; Make sure they did /L:
		jnz	short plE1	; If they didn't, return with carry set.

pl10:					; ...
		call	GetXNum		; After	this, it's ",size" or ";umb" or " mod"
		jb	short plE2	; And error if it's a bad number.
		call	convUMB		; Convert any address to a UMB number
		mov	cl, al		; Remember the UMB number
		call	stowUMB		; Mark this UMB	# as used;
		jb	short plE2	; If it	was already marked, it'll error
		call	incArgc		; Each UMB number is another arg for LH	to skip
					; ('inc byte [cs:fm_argc]' would be enough)
					; Erdogan Tan -	08/04/2019 (Retro DOS v4) - 11/07/2023
		lodsb
		cmp	al, 3Bh	; ';'   ; Did "umb;" ?
		jz	short pl10	; Yep: go back and get another UMB.
		call	isWhite		; Did "umb " ?
		jz	short plX	; Yep: return (it'll go back to whitespace)
		call	isEOL		; Did "umb" ?
		jz	short plSwX	; If so, backup	and exit like everything's ok
		cmp	al, 2Fh	; '/'   ; Did "umb/" ? (as in, "/L:1,100;2/S")
		jz	short plSwX	; If so, back up ES:SI one character and return
		cmp	al, 2Ch	; ','   ; Did "umb," ?
		jnz	short plE1	; Just what the	heck DID they do? Return error.
		call	GetXNum		; Stop on "size;" or "size " or	anything else
		jb	short plE1	; And error if it's a bad size.
		call	toPara		; Convert from bytes to	paragraphs
		call	stowSiz		; CL still has the UMB number for this routine
		call	incArgc		; Each UMB size	is another arg for LH to skip
					; ('inc byte [cs:fm_argc]')
		lodsb
		cmp	al, 3Bh	; ';'   ; They did "umb,size;", so get another UMB.
		jz	short pl10
		call	isWhite		; Did it end with whitespace?
		jz	short plX	; If so, we're done here--go back.
		call	isEOL		; Did they do "umb,size" and end??? (stupid)
		jz	short plSwX	; If so, backup	and exit like everything's ok
		cmp	al, 2Fh	; '/'   ; SWTCH ; Did they do "umb,size/" ?
		jz	short plSwX	; If so, again,	we're done here.

plE1:					; ...
		mov	ax, 1		; PV_InvArg ; If not, we don't know WHAT they did.
		dec	si
		stc
		retn
; ---------------------------------------------------------------------------

plE2:					; ...
		mov	ax, 2		; In this case,	they've specified a UMB twice
		stc
		retn
; ---------------------------------------------------------------------------

plSwX:					; ...
		dec	si		; If we	hit a '/' character, back up one char
					; so the whitespace checker will see it	too.

plX:					; ...
		clc			; Then just return with	carry clear, so
					; ParseVar will	go about its business.
		retn
parseL		endp


; =============== S U B	R O U T	I N E =======================================


incArgc		proc near		; ...
		push	ax		; increments fm_argc,
					; for use with LoadHigh	command-line parsing
					; ***
					; ('inc byte [cs:fm_argc]' would be enough)
					; Erdogan Tan -	11/07/2023
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	al, fm_argc	; Obtain previous value	of fm_argc,
		pop	ds
		assume ds:nothing
		inc	al		; Increment it,
		push	es
		push	cs
		pop	es
		assume es:SYSINIT
		mov	es:fm_argc, al	; And store it right back.
		pop	es
		assume es:nothing
		pop	ax
		retn
incArgc		endp


; =============== S U B	R O U T	I N E =======================================


isEOL		proc near		; ...
		cmp	al, 0		; Null-terminator
		jz	short ieX
		cmp	al, 0Dh		; CR ; Carriage	Return
		jz	short ieX
		cmp	al, 0Ah		; LF ; LineFeed

ieX:					; ...
		retn			; zf=1 if AL contains EOL character
isEOL		endp


; =============== S U B	R O U T	I N E =======================================


isWhite		proc near		; ...
		cmp	al, 20h	; ' '   ; Space
		jz	short iwX
		cmp	al, 3Dh	; '='   ; Equals (treat as whitespace)
		jz	short iwX
		cmp	al, 9		; Tab

iwX:					; ...
		retn			; zf=1 if AL contains space,
isWhite		endp			;	  tab or equals	character


; =============== S U B	R O U T	I N E =======================================


unMarkUMB	proc near		; ...
		push	ax		; marks	a given	UMB as unused
					; AL contains UMB number
		push	bx
		push	di
		push	es
		push	cs
		pop	es
		assume es:SYSINIT
		xor	ah, ah
		mov	bx, ax
		mov	es:UmbUsed[bx],	0
		cmp	es:UmbLoad, al
		jnz	short umu10	; If unmarked the load UMB,
					; load into convent.
		mov	es:UmbLoad, 0

umu10:					; ...
		pop	es
		assume es:nothing
		pop	di
		pop	bx
		pop	ax
		retn
unMarkUMB	endp


; =============== S U B	R O U T	I N E =======================================


stowUMB		proc near		; ...
		cmp	al, 16		; MAXUMB
		jb	short su10
		stc			; Ooops-- UMB #	>= MAXUMB
		retn
; ---------------------------------------------------------------------------

su10:					; ...
		push	bx
		push	di
		push	si
		push	ds
		push	es
		push	cs
		pop	es
		assume es:SYSINIT
		push	cs
		pop	ds
		assume ds:SYSINIT
		cmp	UmbLoad, 0FFh	; UNSPECIFIED
					; If this, we haven't been here before
		jnz	short su20
		mov	UmbLoad, al	; So remember this UMB as the load UMB slot.

su20:					; ...
		or	al, al		; If they gave UMB 0, there's really nothing
		jz	short su30	; that we should do here.
		mov	bl, al
		xor	bh, bh
		mov	ax, 1		; Now, AX = 1, and BX =	UMB Number
		xchg	al, es:UmbUsed[bx]
		or	al, al		; If it	was already 1,
					; then al==1...	and that means an error.
		jz	short su30
		stc			; OOOPS! This one's been used before. :(

su30:					; ...
		pop	es
		assume es:nothing
		pop	ds
		assume ds:nothing
		pop	si
		pop	di
		pop	bx
		retn
stowUMB		endp


; =============== S U B	R O U T	I N E =======================================


stowSiz		proc near		; ...
		push	bx
		push	di
		push	es
		push	cs
		pop	es
		assume es:SYSINIT
		mov	bl, cl		; Now bl==UMB number, AX==size
		mov	bh, 0		; bx==UMB number, AX==size
		shl	bl, 1		; bx==offset into array, AX=size
		mov	es:UmbSize[bx],	ax ; Store the size
		pop	es
		assume es:nothing
		pop	di
		pop	bx
		retn
stowSiz		endp

; ---------------------------------------------------------------------------
gnradix		dw 0			; ...
					; Must be a word--16x16	multiplication

; =============== S U B	R O U T	I N E =======================================


toDigit		proc near		; ...
		cmp	cs:gnradix, 10h
		jnz	short td10	; Don't check hex digits if radix isn't 16
		cmp	cl, 61h	; 'a'
		jb	short td20
		cmp	cl, 66h	; 'f'
		ja	short tdE	; Nothing valid	above 'f' at all...
		sub	cl, 57h		; 'a'-10 ; 87 ; Make 'a'==10 and return.
		retn
; ---------------------------------------------------------------------------

td20:					; ...
		cmp	cl, 41h	; 'A'   ; Below 'A'? Not a letter...
		jb	short td10
		cmp	cl, 46h	; 'F'   ; Above 'F'? Not a digit.
		ja	short tdE
		sub	cl, 37h		; 'A'-10 ; 55 ; Make 'A'==10 and return.
		retn
; ---------------------------------------------------------------------------

td10:					; ...
		cmp	cl, 30h	; '0'   ; If less than zero,
		jb	short tdE	; Done.
		cmp	cl, 39h	; '9'   ; Or, if greater than nine,
		ja	short tdE	; Done.
		sub	cl, 30h	; '0'   ; Okay--make '0'==0 and return.
		retn
; ---------------------------------------------------------------------------

tdE:					; ...
		stc
		retn
toDigit		endp


; =============== S U B	R O U T	I N E =======================================


GetXNum		proc near		; ...
		push	bx		; reads	a 32-bit ASCII number at ES:SI
					; and returns it in DX:AX
		push	cx
		push	ds
		cld
		xor	ax, ax
		xor	bx, bx
		xor	cx, cx
		xor	dx, dx		; Start	with 0 (makes sense)
		mov	cs:gnradix, 0Ah	; And default to a radix of 10 (dec)
		mov	cl, es:[si]
		call	toDigit
		jb	short gxnE	; If it's not a digit, leave now.
		or	cl, cl
		jnz	short gxn20	; Doesn't have '0x'
		mov	cl, es:[si+1]
		cmp	cl, 'x'         ; Either 'x'...
		jz	short gxn10
		cmp	cl, 'X'
		jnz	short gxn20

gxn10:					; ...
		mov	cs:gnradix, 16
		inc	si		; Since	we read	"0x", march over it.
		inc	si

gxn20:					; ...
		mov	cl, es:[si]	; Now DX:AX=current total, CH=0/CL=char
		inc	si
		call	toDigit		;  Accepts only	valid digits, A-F -> 10-16
		jb	short gxnQ	; <- Ah... wasn't a digit. Stop.
		call	mul32
		jb	short gxnX
		add	ax, cx
		adc	dx, bx
		jb	short gxnX
		jmp	short gxn20
; ---------------------------------------------------------------------------

gxnE:					; ...
		stc
		jmp	short gxnX
; ---------------------------------------------------------------------------

gxnQ:					; ...
		dec	si
		clc

gxnX:					; ...
		pop	ds
		pop	cx
		pop	bx
		retn
GetXNum		endp


; =============== S U B	R O U T	I N E =======================================


mul32		proc near		; ...
		push	ax		; multiplies the number	in DX:AX by gnradix
					; DX=old:hi, AX=old:lo,	TOS=old:lo, BX=0
		mov	ax, dx
		mul	cs:gnradix	; DX=?,	AX=new:hi, TOS=old:lo, BX=0
		jb	short m32E	; Too big?
		mov	dx, ax		; DX=new:hi, AX=new:hi,	TOS=old:lo, BX=0
		pop	ax		; DX=new:hi, AX=old:lo,	TOS=orig, BX=0
		xchg	dx, bx		; DX=0,	AX=old:lo, TOS=orig, BX=new:hi
		mul	cs:gnradix	; DX=carry, AX=new:lo, TOS=orig, BX=new:hi
		xchg	dx, bx
		add	dx, bx		; DX=new:hi, AX=new:lo,	TOS=orig, BX=carry
		xor	bx, bx		; BX=0
		retn
; ---------------------------------------------------------------------------

m32E:					; ...
		pop	ax
		retn
mul32		endp


; =============== S U B	R O U T	I N E =======================================


toPara		proc near		; ...
		push	cx		; divides DX:AX	by 16; result in AX only
		mov	cl, 4		; DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll llll
		shr	ax, cl		; DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll llll
		xchg	ax, dx		; DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh hhhh
		mov	cl, 12
		shl	ax, cl		; DX:AX=0000 LLLL llll llll:hhhh 0000 0000 0000
		or	ax, dx		; AX=hhhh LLLL llll llll
		pop	cx
		retn
toPara		endp


; =============== S U B	R O U T	I N E =======================================


UmbHead		proc near		; ...
		push	si
		push	ds
		push	es
		mov	ah, 52h		; GET_IN_VARS
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		mov	ax, es:8Ch	; [es:DOS_UMB_HEAD]
		cmp	ax, 0FFFFh
		jz	short uhE
		clc
		jmp	short uhX
; ---------------------------------------------------------------------------

uhE:					; ...
		stc

uhX:					; ...
		pop	es
		pop	ds
		pop	si
		retn
UmbHead		endp


; =============== S U B	R O U T	I N E =======================================


isSysMCB	proc near		; ...
		push	ax		; sets ZF if ES	points to an MCB owned by "SC"
		mov	ax, es:1	; [es:ARENA.OWNER]
		cmp	ax, 8		; SystemPSPOwner ; 8 (for US or	Japan) is valid
		jz	short ism10
		cmp	ax, 9		; JapanPSPOwner	; 9 (for Japan)	is valid
		jz	short ism10
		jmp	short ismX
; ---------------------------------------------------------------------------

ism10:					; ...
		mov	ax, es:8	; [es:ARENA.NAME]
		cmp	ax, 4353h	; 'SC'

ismX:					; ...
		pop	ax
		retn
isSysMCB	endp


; =============== S U B	R O U T	I N E =======================================


AddrToUmb	proc near		; ...
		push	cx		; converts a segment address in	AX
					; to its appropriate UMB number
		push	dx
		push	es
		mov	dx, ax		; DX = address to search for
		call	UmbHead		; AX = first segment
		jb	short atuE	; If it	couldn't get it, error out
		mov	es, ax
		xor	cx, cx		; 0

atu10:					; ...
		mov	ax, es
		cmp	ax, dx		; Present segment >= given segment?
		jnb	short atuX	; yes, done.
		call	isSysMCB	; Returns with ZF set if this is a system MCB
		jnz	short atu20
		inc	cx		; If it	_was_ a	system MCB, we're in a new UMB.

atu20:					; ...
		mov	al, es:0	; [es:ARENA.SIGNATURE]
		cmp	al, 5Ah	; 'Z'
		jz	short atu30	; 'Z' means this was the last MCB... that's it.
		mov	ax, es
		add	ax, es:3	; [es:ARENA.SIZE]
		inc	ax
		mov	es, ax
		jmp	short atu10
; ---------------------------------------------------------------------------

atu30:					; ...
		mov	ax, es
		add	ax, es:3	; [es:ARENA.SIZE]
		cmp	ax, dx		; Present >= given?
		jnb	short atuX	; Yep! It _was_	inside.

atuE:					; ...
		xor	cx, cx
		dec	cx		; Address is above UM Range,
					; AX will return as 0FFFFh.

atuX:					; ...
		mov	ax, cx		; Return the UMB number	in AX (0==conv)
		pop	es
		pop	dx
		pop	cx
		retn
AddrToUmb	endp


; =============== S U B	R O U T	I N E =======================================


convUMB		proc near		; ...
		cmp	cs:gnradix, 10h	; convert address to UMB number	after GetXNum
					; (GetXNum has read a hex number)
		jnz	short cu10	; GetXNum didn't read in hex, it is not an addr
		call	AddrToUmb	; convert the address to a UMB number
		cmp	ax, 0FFFFh
		jnz	short cu10
		inc	ax		; If too high, ignore it (make it conventional)

cu10:					; ...
		retn
convUMB		endp


; =============== S U B	R O U T	I N E =======================================


setUMBs		proc near		; ...
		push	ax
		push	bx
		call	fm_link
		pop	bx
		pop	ax
		retn
setUMBs		endp

; ---------------------------------------------------------------------------

loadLow:				; loadLow subroutine is	not used
		push	ds		; anywhere of MSDOS 6.21 (& 5.0) IO.SYS
					; Erdogan Tan -	18/07/2023
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	al, UmbLoad
		cmp	al, 0FFh	; UNSPECIFIED ;	-1
		jnz	short ll10
		mov	al, 1
		stc
		jmp	short llx
; ---------------------------------------------------------------------------

ll10:					; ...
		or	al, al
		jz	short llx
		mov	al, 1
		clc

llx:					; ...
		pop	ds
		assume ds:nothing
		retn

; =============== S U B	R O U T	I N E =======================================


HideUMBs	proc near		; ...
		push	ax		; links	UMBs and hides upper-memory as appropriate
		push	cx
		push	ds
		push	es
		call	UmbTest		; cf=0 if UMBs are available
		jb	short husX	; there	is nothing to do.
		call	FixMem		; Concatenate adjacent free MCBs in upper mem
		call	setUMBs		; Link UMBs and	set memory-allocation strategy
		push	es
		push	cs
		pop	es
		assume es:SYSINIT
		mov	es:fInHigh, 1	; Remember that	we're now running high
		pop	es
		assume es:nothing
		call	GetLoadUMB	; See if they gave us a	list to	leave free
		cmp	al, 0FFh	; UNSPECIFIED ;	If they	didn't,
		jz	short husX
		xor	cx, cx		; 0

hus10:					; ...
		inc	cx		; +1 for each UMB
		cmp	cx, 16		; MAXUMB
		jnb	short hus20
		mov	al, cl
		push	es
		call	findUMB		; ES:0 points to first MCB in UMB
					; Carry	set if couldn't reach UMB
		pop	es
		jb	short hus20	; outside of the valid range of	UMBs
		call	_hideUMB_	; hide what we need to hide.
		jmp	short hus10
; ---------------------------------------------------------------------------

hus20:					; ...
		call	GetLoadUMB	; mov al,[cs:UmbLoad]
		or	al, al		; or byte [cs:UmbLoad],0
					; Is the load UMB 0? (-1==unspecified)
		jnz	short husX	; no, done.
		call	hl_unlink	; fix UMBs and strategy.

husX:					; ...
		pop	es
		pop	ds
		pop	cx
		pop	ax
		retn
HideUMBs	endp


; =============== S U B	R O U T	I N E =======================================


GetLoadUMB	proc near		; ...
		push	ds		; Instead of calling this subroutine
					; "or byte [cs:UmbLoad],0" then	"jz/jnz	.."
					; would	be enough. Erdogan Tan - 18/07/2023
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	al, UmbLoad
		pop	ds
		assume ds:nothing
		retn
GetLoadUMB	endp


; =============== S U B	R O U T	I N E =======================================


GetLoadSize	proc near		; ...
		push	bx
		push	si
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	al, UmbLoad
		xor	ah, ah
		mov	bx, offset UmbSize ; array
		shl	al, 1
		add	ax, bx
		mov	si, ax
		lodsw			; ax==size
		pop	ds
		assume ds:nothing
		pop	si
		pop	bx
		retn
GetLoadSize	endp


; =============== S U B	R O U T	I N E =======================================


GetSize		proc near		; ...
		push	bx		; Returns the UMB in AL's minimum size
					;  (0 if not specified)
		push	si
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		xor	ah, ah
		mov	bx, offset UmbSize ; array
		shl	al, 1
		add	ax, bx
		mov	si, ax
		lodsw			; ax==size
		pop	ds
		assume ds:nothing
		pop	si
		pop	bx
		retn
GetSize		endp

; ---------------------------------------------------------------------------

StoLoadUMB:				; StoLoadUMB subroutine	is not used
		push	es		; anywhere of MSDOS 6.21 (& 5.0) IO.SYS
					; Erdogan Tan -	18/07/2023
		push	cs
		pop	es
		assume es:SYSINIT
		mov	es:UmbLoad, al	; Overrides the	load UMB number	with what's in AL
		pop	es
		assume es:nothing
		retn

; =============== S U B	R O U T	I N E =======================================


StoLoadSize	proc near		; ...
		push	dx		; Overrides the	load UMB min. size with	what's in AX
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	dl, UmbLoad	; Put UMB# in DL
					;
					; BUG !	CL would be used here instead of DL (*)
					; 18/07/2023
		pop	ds
		assume ds:nothing
		cmp	dl, 0FFh	; UNSPECIFIED
		jz	short sls10
		call	stowSiz		; We've got a function to do just this
					;
					; BUG !	stowSiz	uses CL	instead	of DL !
					; (CL is set in	ParseL which calls stowSiz)
					; (This	BUG existing in	PCDOS 7.1 IBMBIO.COM also)
					; Erdogan Tan -	18/07/2023

sls10:					; ...
		pop	dx
		retn
StoLoadSize	endp


; =============== S U B	R O U T	I N E =======================================


hideUMB		proc near		; ...
		push	ax		; marks	as HIDDEN all FREE elements in UMB passed as AL
		push	es
		call	findUMB		; Returns with carry if	err, else ES ==	MCB
		jb	short huX

hu10:					; ...
		call	isSysMCB	; Returns with ZF set if owner is SYSTEM
		jz	short huX
		call	isFreeMCB	; or word [es:ARENA.OWNER],0
		jnz	short hu20
		call	hideMCB

hu20:					; ...
		mov	al, es:0	; [es:ARENA.SIGNATURE]
		cmp	al, 5Ah	; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
		jz	short huX
		mov	ax, es		; Go on	forward.
		add	ax, es:3	; [es:ARENA.SIZE]
		inc	ax
		mov	es, ax
		jmp	short hu10
; ---------------------------------------------------------------------------

huX:					; ...
		pop	es
		pop	ax
		retn
hideUMB		endp


; =============== S U B	R O U T	I N E =======================================


isTiny		proc near		; ...
		push	ax		; returns with ZF set if user didn't specify /S
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	al, fUmbTiny
		pop	ds
		assume ds:nothing
		or	al, al
		pop	ax
		retn
isTiny		endp


; =============== S U B	R O U T	I N E =======================================


isFreeMCB	proc near		; ...
		or	word ptr es:1, 0 ; or word [es:ARENA.OWNER],0
		retn
isFreeMCB	endp


; =============== S U B	R O U T	I N E =======================================


hideMCB		proc near		; ...
		mov	word ptr es:1, 8 ; marks as HIDDEN the MCB at ES:0
		mov	word ptr es:8, 4948h ; 'HI'
		mov	word ptr es:0Ah, 4444h ; 'DD'
		mov	word ptr es:0Ch, 4E45h ; 'EN'
		mov	word ptr es:0Eh, 2020h ; '  '
		retn
hideMCB		endp


; =============== S U B	R O U T	I N E =======================================


unHideMCB	proc near		; ...
		push	ax		; marks	as FREE	the MCB	at ES:0
		mov	word ptr es:1, 0 ; [es:ARENA.OWNER],FreePSPOwner
		mov	ax, 2020h	; '  '
		mov	es:8, ax	; [es:ARENA.NAME+0]
		mov	es:0Ah,	ax	; [es:ARENA.NAME+2]
		mov	es:0Ch,	ax	; [es:ARENA.NAME+4]
		mov	es:0Eh,	ax	; [es:ARENA.NAME+6]
		pop	ax
		retn
unHideMCB	endp


; =============== S U B	R O U T	I N E =======================================


findUMB		proc near		; ...
		push	ax		; makes	ES:0 point to the first	MCB in UMB given as AL
		push	cx
		push	dx
		xor	ah, ah
		mov	dx, ax		; Store	the to-be-found	UMB number in DX
		call	UmbHead		; Returns first	UMB segment in AX
		mov	es, ax
		xor	cx, cx		; Pretend we're on UMB 0 for now...

fu10:					; ...
		cmp	cx, dx		; If CX==DX, the UMB is	found
		jz	short fuX
		call	isSysMCB	; Returns with ZF set if owner is SYSTEM
		jnz	short fu20
		inc	cx

fu20:					; ...
		mov	al, es:0
		cmp	al, 5Ah	; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
		jz	short fuE	; 'Z' means this was the last MCB
		mov	ax, es		; Go on	forward.
		add	ax, es:3	; [es:ARENA.SIZE]
		inc	ax
		mov	es, ax
		jmp	short fu10
; ---------------------------------------------------------------------------

fuE:					; ...
		stc

fuX:					; ...
		pop	dx
		pop	cx
		pop	ax		; The address is already in ES.
		retn
findUMB		endp


; =============== S U B	R O U T	I N E =======================================


BigFree		proc near		; ...
		push	bx		; makes	ES:0 point to the largest free MCB
					; in UMB given as AL
		push	cx
		call	findUMB		; Returns with CF if err, else ES==MCB
		jb	short bfX
		xor	bx, bx		; Segment address of largest free MCB
		xor	cx, cx		; Size of largest free MCB

bf10:					; ...
		call	isSysMCB	; If we've left the MCB, we're done.
		jz	short bf30
		call	isFreeMCB	; or word [es:ARENA.OWNER],0
		jnz	short bf20
		cmp	cx, es:3	; [es:ARENA.SIZE] ; Compare sizes..
		jg	short bf20
		mov	bx, es		; Unless we're bigger,
		mov	cx, es:3	; Store	this new element's addr and size.

bf20:					; ...
		mov	al, es:0
		cmp	al, 5Ah	; 'Z'   ; [es:ARENA.SIGNATURE],arena_signature_end
		jz	short bf30
		mov	ax, es		; NextMCB es,ax	; (macro) ; Go on forward.
		add	ax, es:3	; es:ARENA.SIZE]
		inc	ax
		mov	es, ax
		jmp	short bf10
; ---------------------------------------------------------------------------

bf30:					; ...
		mov	es, bx		; Return the address
		mov	ax, cx		; Return the size
		or	bx, bx
		jnz	short bfX
		stc			; (if size==0, there's nothing free)

bfX:					; ...
		pop	cx
		pop	bx
		retn
BigFree		endp


; =============== S U B	R O U T	I N E =======================================


isSpecified	proc near		; ...
		push	ax		; sets ZF if UMB in AL wasn't specified in DH/LH line.
		xor	bh, bh
		mov	bl, al
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	al, UmbUsed[bx]
		pop	ds
		assume ds:nothing
		or	al, al		; ets ZF if al==0 (ie, if unspecified)
		pop	ax
		retn
isSpecified	endp


; =============== S U B	R O U T	I N E =======================================


shrinkMCB	proc near		; ...
		push	bx		; breaks an MCB	into two pieces, the lowest one's size==AX
					; AX ==	new size, ES:0 == current MCB
		push	cx
		push	es
		mov	bx, ax		; requested size (lowest one)
		mov	ax, es
		mov	cx, es:3	; [es:ARENA.SIZE]
		sub	cx, 32		; MIN_SPLIT_SIZE = 32
		cmp	bx, cx		; {New size} vs	{Current Size-20h}
		ja	short smE	; if wanted_size > cur-20h, abort.
		mov	dl, es:0	; [es:ARENA.SIGNATURE]
		mov	cx, es:3
		mov	es:3, bx	; [es:ARENA.SIZE]
		mov	byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],'M'
		add	ax, bx
		inc	ax
		mov	es, ax		; Move to new arena area
		mov	ax, cx
		sub	ax, bx
		dec	ax		; And prepare the new size
		mov	es:0, dl	; [es:ARENA.SIGNATURE],dl
		mov	word ptr es:1, 0 ; [es:ARENA.OWNER]
		mov	es:3, ax	; [es:ARENA.SIZE]
		mov	ax, 2020h	; '  '
		mov	es:8, ax	; [es:ARENA.NAME+0]
		mov	es:0Ah,	ax	; [es:ARENA.NAME+2]
		mov	es:0Ch,	ax	; [es:ARENA.NAME+4]
		mov	es:0Eh,	ax	; [es:ARENA.NAME+6]
		clc
		jmp	short smX
; ---------------------------------------------------------------------------

smE:					; ...
		stc

smX:					; ...
		pop	es
		pop	cx
		pop	bx
		retn
shrinkMCB	endp


; =============== S U B	R O U T	I N E =======================================


_hideUMB_	proc near		; ...
		push	bx		; hides	as appropriate the UMB in CL
		push	dx
		push	es
		mov	al, cl
		call	isSpecified	; Returns ZF set if al's umb was NOT specified
		jz	short hu_20
		mov	al, cl
		call	BigFree		; Retrieve the size of the largest free	element
					; in AX, put its address in ES.
		jb	short hu_20
		push	ax		; TOS==size of BigFree in UMB
		mov	al, cl		; Retrieve the user's specified
		call	GetSize		; minimum size for this	umb (into AX)
		pop	bx		; BX==BigFree, AX==Specified Size
		or	ax, ax		; If they didn't specify one,
					; skip over all	this.
		jz	short hu_20
		cmp	ax, bx		; if (specified	> max free)
		jbe	short hu_10
		mov	al, cl		; then mark that UMB as	unused.
		call	unMarkUMB
		jmp	short hu_20
; ---------------------------------------------------------------------------

hu_10:					; ...
		call	isTiny		; or byte [cs:fUmbTiny],0
		jz	short hu_20
		call	shrinkMCB	; They specified /S, so	shrink the MCB to AX
		jb	short hu_20
		mov	dx, es
		jmp	short hu_30	; Skip the spec	check..	we wanna hide this one.
; ---------------------------------------------------------------------------

hu_20:					; ...
		mov	ax, cx
		call	isSpecified	; If they specified this UMB, we're done.
		jnz	short hu_X	; so leave.
		xor	dx, dx		; 0

hu_30:					; ...
		mov	al, cl
		call	hideUMB		; Hides	everything in UMB #al
		or	dx, dx		; Did we shrink	a UMB? If not, DX==0,
		jz	short hu_X	; So we	should leave.
		mov	es, dx		; Ah, but if it	isn't, DX==the MCB's address;
		call	unHideMCB	; Un-hides the lower portion of	that MCB.

hu_X:					; ...
		pop	es
		pop	dx
		pop	bx
		retn
_hideUMB_	endp


; =============== S U B	R O U T	I N E =======================================


UnFreeze	proc near		; ...
		push	ax		; Marks	FROZEN elements	as FREE
		push	es
		call	UmbHead		; Returns with carry if	err, else ES ==	MCB
		jb	short ufX
		mov	es, ax

uf10:					; ...
		call	isFrozMCB	; Returns with ZF set if MCB is	FROZEN
		jnz	short uf20
		call	unHideMCB

uf20:					; ...
		mov	al, es:0
		cmp	al, 5Ah	; 'Z'
		jz	short ufX
		mov	ax, es
		add	ax, es:3	; [es:ARENA.SIZE]
		inc	ax
		mov	es, ax
		jmp	short uf10
; ---------------------------------------------------------------------------

ufX:					; ...
		pop	es
		pop	ax
		retn
UnFreeze	endp


; =============== S U B	R O U T	I N E =======================================


isFrozMCB	proc near		; ...
		push	ax
		mov	ax, es:1	; [es:ARENA.OWNER] ; Check the owner..
		cmp	ax, 8		; 8 (for US OR Japan) is valid
		jnz	short ifmX
		mov	ax, es:8	; [es:ARENA.NAME+0]
		cmp	ax, 5246h	; 'FR'
		jnz	short ifmX
		mov	ax, es:0Ah	; [es:ARENA.NAME+2]
		cmp	ax, 5A4Fh	; 'OZ'
		jnz	short ifmX
		mov	ax, es:0Ch	; [es:ARENA.NAME+4]
		cmp	ax, 4E45h	; 'EN'
		jnz	short ifmX
		mov	ax, es:0Eh	; [es:ARENA.NAME+6]
		cmp	ax, 2020h	; '  '

ifmX:					; ...
		pop	ax
		retn
isFrozMCB	endp


; =============== S U B	R O U T	I N E =======================================


frezMCB		proc near		; ...
		mov	word ptr es:1, 8 ; marks as 8+FROZEN the MCB at	ES:0
					; mov word [es:ARENA.OWNER],SystemPSPOwner
		mov	word ptr es:8, 5246h ; [es:ARENA.NAME+0],'FR'
		mov	word ptr es:0Ah, 5A4Fh ; [es:ARENA.NAME+2],'OZ'
		mov	word ptr es:0Ch, 4E45h ; [es:ARENA.NAME+4],'EN'
		mov	word ptr es:0Eh, 2020h ; [es:ARENA.NAME+6],'  '
		retn
frezMCB		endp


; =============== S U B	R O U T	I N E =======================================


FreezeUM	proc near		; ...
		push	ax		; Marks	FROZEN all UM elements now FREE,
					; save those in	load UMB
		push	cx
		push	dx
		push	es
		call	GetLoadUMB	; mov al,[cs:UmbLoad]
		xor	ah, ah		; 0
		mov	dx, ax		; Store	the load UMB in	DX, so we can skip it
		call	UmbHead		; Returns first	UMB segment in AX
		mov	es, ax
		xor	cx, cx		; Pretend we're on UMB 0 for now..

fum10:					; ...
		call	isSysMCB	; Returns with ZF set if owner is SYSTEM
		jnz	short fum20
		inc	cx		; If it	_was_ SYSTEM, we're in a new UMB.

fum20:					; ...
		cmp	cx, dx		; DX - UMB number to skip (load	UMB)
					;
					; If this is the load UMB, we don't want to
					; freeze anything.. so skip that section.
		jz	short fum30
		call	isFreeMCB	; or word [es:ARENA.OWNER],0
					; If it's not free, we can't freeze it
		jnz	short fum30
		call	frezMCB

fum30:					; ...
		mov	al, es:0
		cmp	al, 5Ah	; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
		jz	short fumX
		mov	ax, es		; NextMCB es, ax (macro) ; Go on forward.
		add	ax, es:3	; [es:ARENA.SIZE]
		inc	ax
		mov	es, ax
		jmp	short fum10
; ---------------------------------------------------------------------------

fumX:					; ...
		pop	es
		pop	dx
		pop	cx
		pop	ax
		retn
FreezeUM	endp


; =============== S U B	R O U T	I N E =======================================


UmbTest		proc near		; ...
		push	ax		; returns with carry set if UMBs are not available,
					;  else	CF==false
		push	bx
		push	ds
		push	es
		call	fm_link		; Link in UMBs (if not already linked)
		call	WalkMem		; Check	to see if they're really linked
		pushf			; And remember what we found out
		call	fm_unlink	; Unlink UMBs (if we have linked 'em)
		popf			; And restore what we found out.
		pop	es
		pop	ds
		pop	bx
		pop	ax
		retn
UmbTest		endp


; =============== S U B	R O U T	I N E =======================================


WalkMem		proc near		; ...
		push	ax		; WalkMem - travels memory chain and
					; returns carry	clear if UMBs are linked
		push	bx
		push	es
		mov	ah, 52h
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		mov	ax, es:[bx-2]
		mov	es, ax		; ES = Current MCB pointer

um10:					; ...
		mov	al, es:0
		cmp	al, 5Ah	; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end ; 'Z'
		jz	short um20
		mov	bx, es		; Move to the next MCB
		add	bx, es:3	; [es:ARENA.SIZE]
		inc	bx
		mov	es, bx
		jmp	short um10
; ---------------------------------------------------------------------------

um20:					; ...
		mov	ax, es
		cmp	ax, 9FFFh	; This sets CF if ax < 9FFFh.
		pop	es
		pop	bx
		pop	ax
		retn
WalkMem		endp


; =============== S U B	R O U T	I N E =======================================


hl_unlink	proc near		; ...
		xor	bh, bh		; unlinks UMBs if fm_umb is set	to 0;
					;  restores strategy too
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	bl, fm_umb
		pop	ds
		assume ds:nothing
		mov	ax, 5803h	; DOS_SET_UMBLINK
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		retn
hl_unlink	endp


; =============== S U B	R O U T	I N E =======================================


UnHideUMBs	proc near		; ...
		push	ax		; Marks	HIDDEN elements	as FREE
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	al, fInHigh	; mov al,[cs:fInHigh]
		pop	ds
		assume ds:nothing
		or	al, al
		jnz	short uhu10	; If didn't call loadhigh/devicehigh earlier,
		pop	ax		; then there's nothing to do here.
		stc
		retn
; ---------------------------------------------------------------------------

uhu10:					; ...
		call	linkumb		; Make sure UMBs are linked in.
		call	FreeUMBs
		push	es
		push	cs
		pop	es
		assume es:SYSINIT
		mov	es:fInHigh, 0	; We're leaving, so update fInHigh.
		pop	es
		assume es:nothing
		call	he_unlink	; Unlink UMBs
		pop	ax
		clc
		retn
UnHideUMBs	endp


; =============== S U B	R O U T	I N E =======================================


he_unlink	proc near		; ...
		xor	bh, bh		; unlinks UMBs if fm_umb is set	to 0
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	bl, fm_umb
		pop	ds
		assume ds:nothing
		mov	ax, 5803h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		retn
he_unlink	endp


; =============== S U B	R O U T	I N E =======================================


FreeUMBs	proc near		; ...
		push	ax		; frees	all HIDDEN memory elements in upper-memory
		push	es
		call	HeadUmb		; Returns with carry if	err, else ES ==	MCB
		jb	short fusX
		mov	es, ax		; Prepare for the loop;	ES = current MCB addr.

fus10:					; ...
		call	isHideMCB	; Returns with ZF set if owner is 0
		jnz	short fus20
		call	freeMCB

fus20:					; ...
		mov	al, es:0
		cmp	al, 5Ah	; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
		jz	short fusX
		mov	ax, es
		add	ax, es:3	; [es:ARENA.SIZE]
		inc	ax
		mov	es, ax
		jmp	short fus10	; Go on	forward.
; ---------------------------------------------------------------------------

fusX:					; ...
		pop	es
		pop	ax
		retn
FreeUMBs	endp


; =============== S U B	R O U T	I N E =======================================


isHideMCB	proc near		; ...
		push	ax		; returns with ZF set if current MCB (ES:0) is HIDDEN
		cmp	word ptr es:1, 8 ; [es:ARENA.OWNER],SystemPSPOwner
					; If the owner's SYSTEM then check for HIDDEN
		jnz	short ihm_x
		mov	ax, es:8
		cmp	ax, 4948h	; cmp word [es:ARENA.NAME+0],'HI'
		jnz	short ihm_x
		mov	ax, es:0Ah
		cmp	ax, 4444h	; cmp word [es:ARENA.NAME+2],'DD'
		jnz	short ihm_x
		mov	ax, es:0Ch
		cmp	ax, 4E45h	; cmp word [es:ARENA.NAME+4],'EN'
		jnz	short ihm_x
		mov	ax, es:0Eh
		cmp	ax, 2020h	; [es:ARENA.NAME+4],'  '

ihm_x:					; ...
		pop	ax
		retn
isHideMCB	endp


; =============== S U B	R O U T	I N E =======================================


freeMCB		proc near		; ...
		mov	word ptr es:1, 0 ; marks as free the MCB at ES:0
		mov	ax, 2020h	; '  '
		mov	es:8, ax	; mov word [es:ARENA.NAME+0],'  '
		mov	es:0Ah,	ax
		mov	es:0Ch,	ax
		mov	es:0Eh,	ax	; [es:ARENA.NAME+6]
		retn
freeMCB		endp


; =============== S U B	R O U T	I N E =======================================


HeadUmb		proc near		; ...
		push	si		; returns in AX	the addr of the	1st UMB	block (0x9FFF)
		push	ds
		push	es
		mov	ah, 52h
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		mov	ax, es:8Ch	; [es:UMB_HeadIdx]
		cmp	ax, 0FFFFh
		jz	short xhu_e	; If it's 0xFFFF, it's an error...
		clc			; AX contains 0x9FFF for most systems
		jmp	short xhu_x
; ---------------------------------------------------------------------------

xhu_e:					; ...
		stc			; error

xhu_x:					; ...
		pop	es
		pop	ds
		pop	si
		retn
HeadUmb		endp


; =============== S U B	R O U T	I N E =======================================


linkumb		proc near		; ...
		mov	ax, 5802h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) get UMB link state
		or	al, al
		jnz	short lumbX
		mov	ax, 5803h
		mov	bx, 1
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state

lumbX:					; ...
		retn
linkumb		endp


; =============== S U B	R O U T	I N E =======================================


InitDevLoad	proc near		; ...
		cmp	cs:DeviceHi, 0	; Are we loading in UMB	?
		jz	short InitForLo	; no, init for lo mem
		cmp	cs:ConvLoad, 1	; Are we loading as per	Dos 5?
		jz	short InitForConv
		call	ShrinkUMB	; Stop using the old device arena
		call	HideUMBs	; Mark up the UM area as we see	fit
		call	FreezeUM	; Hide everything BUT the load area
		call	GetUMBForDev	; And grab that	load area as needed
		pushf
		call	UnFreeze	; Then unhide everything frozen
		popf
		jb	short InitForLo	; (if carry, it's loading low)
		jmp	short InitForHi
; ---------------------------------------------------------------------------

InitForConv:				; ...
		call	SpaceInUMB	; Do we	have space left	in the current UMB ?
		jnb	short InitForHi	; yes, we have
		call	ShrinkUMB	; shrink the current UMB in use
		call	GetUMBForDev	; else try to allocate new UMB
		jb	short InitForLo	; we didn't succeed, so load in low memory

InitForHi:				; ...
		mov	ax, cs:DevUMBFree ; get	Para addr of free mem
		mov	dx, cs:DevUMBAddr ; UMB	start addr
		add	dx, cs:DevUMBSize ; dx = UMB End addr
		jmp	short idl1
; ---------------------------------------------------------------------------

InitForLo:				; ...
		mov	cs:DeviceHi, 0	; in case we failed to load into UMB
					; indicate that	we are loading low
		mov	ax, cs:memhi	; start	of Low memory
		mov	dx, cs:ALLOCLIM	; end of Low memory

idl1:					; ...
		call	DevSetMark	; setup	a sub-arena for	DD
		mov	cs:DevLoadAddr,	ax ; init the Device load address
		mov	cs:DevLoadEnd, dx ; init the limit of the block
		mov	word ptr cs:DevEntry, 0	; init Entry point to DD
		mov	word ptr cs:DevEntry+2,	ax
		retn
InitDevLoad	endp


; =============== S U B	R O U T	I N E =======================================


SpaceInUMB	proc near		; ...
		mov	ax, cs:DevUMBSize
		add	ax, cs:DevUMBAddr ; End	of UMB
		sub	ax, cs:DevUMBFree ; - Free = Remaining space
		or	ax, ax		; Nospace ?
		jnz	short spcinumb1
		stc
		retn
; ---------------------------------------------------------------------------

spcinumb1:				; ...
		dec	ax		; space	for sub-arena
		cmp	ax, cs:DevSize	; do we	have space ?
		retn
SpaceInUMB	endp


; =============== S U B	R O U T	I N E =======================================


PrepareMark	proc near		; ...
		push	ds
		mov	ds, ax
		mov	word ptr ds:1, 8 ; [ARENA.OWNER]
		mov	word ptr ds:8, 4453h ; [ARENA.NAME],'SD'
		pop	ds
		inc	ax
		mov	cs:DevUMBAddr, ax
		mov	cs:DevUMBFree, ax
		mov	cs:DevUMBSize, bx ; update the UMB Variables
		retn
PrepareMark	endp


; =============== S U B	R O U T	I N E =======================================


GetUMBForDev	proc near		; ...
		mov	bx, 0FFFFh
		mov	ax, 4800h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		or	bx, bx
		jz	short gufd_err
		dec	bx
		cmp	cs:DevSize, bx
		ja	short gufd_err
		inc	bx
		mov	ax, 4800h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short gufd_err
		dec	ax
		call	PrepareMark
		clc
		retn
; ---------------------------------------------------------------------------

gufd_err:				; ...
		xor	ax, ax		; 0
		mov	cs:DevUMBSize, ax ; erase the previous values
		mov	cs:DevUMBAddr, ax
		mov	cs:DevUMBFree, ax
		stc
		retn
GetUMBForDev	endp


; =============== S U B	R O U T	I N E =======================================


DevSetMark	proc near		; ...
		push	es		; Input	:
					; AX - Free segment were device	is going to be loaded
					; Output :
					; AX - Segment at which	device can be loaded (AX=AX+1)
					;
					; Creates a sub-arena for the device driver
					; puts 'D' marker in the sub-arena
		push	di
		push	ds
		push	si
		mov	es, ax
		mov	byte ptr es:0, 44h ; 'D' ; [es:devmark.id],devmark_device ; 'D'
		inc	ax
		mov	es:1, ax	; [es:devmark.seg]
		push	ax		; save load address
		lds	si, cs:bpb_addr	; command line is still	there
		mov	di, si
		cld

dsm_again:				; ...
		lodsb
		cmp	al, 3Ah	; ':'
		jnz	short isit_slash
		mov	di, si
		jmp	short dsm_again
; ---------------------------------------------------------------------------

isit_slash:				; ...
		cmp	al, 5Ch	; '\'
		jnz	short isit_null
		mov	di, si
		jmp	short dsm_again
; ---------------------------------------------------------------------------

isit_null:				; ...
		or	al, al
		jnz	short dsm_again
		mov	si, di
		mov	di, 8		; devmark.filename ; 8
		mov	cx, 8		; maximum 8 characters

dsm_next_char:				; ...
		lodsb
		or	al, al
		jz	short blankout
		cmp	al, 2Eh	; '.'
		jz	short blankout
		stosb
		loop	dsm_next_char

blankout:				; ...
		jcxz	short dsm_exit
		mov	al, 20h	; ' '
		rep stosb		; blank	out the	rest

dsm_exit:				; ...
		pop	ax		; restore load address
		pop	si
		pop	ds
		pop	di
		pop	es
		retn
DevSetMark	endp


; =============== S U B	R O U T	I N E =======================================


SizeDevice	proc near		; ...
		push	ds		; Calculates the size of the device file in paras
					; and stores it	in DevSize
		push	es
		pop	ds
		mov	dx, si
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short sd_err
		mov	bx, ax		; BX - file handle
		mov	ax, 4202h
		xor	cx, cx
		mov	dx, cx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		jb	short sd_close
		add	ax, 0Fh
		adc	dx, 0
		test	dx, 0FFF0h	; size > 0ffffh	paras ?
		jz	short szdev1	; no
		mov	cs:DevSize, 0FFFFh ; invalid device size
					;  assuming that we fail later
		jmp	short sd_close
; ---------------------------------------------------------------------------

szdev1:					; ...
		mov	cl, 4		; convert it to	paras
		shr	ax, cl
		mov	cl, 0Ch
		shl	dx, cl
		or	ax, dx
		mov	cs:DevSize, ax	; save file size (in paragraphs)
		clc			; CLC is not needed here
					; (OR instruction clears CF) - E.TAN 22/07/2023

sd_close:				; ...
		pushf			; save carry flag
		mov	ax, 3E00h
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		popf			; restore carry	flag
					; (we are not checking for 'close file' err)

sd_err:					; ...
		pop	ds
		retn
SizeDevice	endp


; =============== S U B	R O U T	I N E =======================================


ExecDev		proc near		; ...
		mov	bx, cs:DevLoadAddr
		mov	cs:DevExecAddr,	bx ; Load the parameter	block
		mov	cs:DevExecReloc, bx ; block for	exec with  load	address
		mov	bx, cs
		mov	es, bx
		assume es:SYSINIT
		mov	bx, offset DevExecAddr ; es:bx points to parameters
		mov	al, 3		; (load	program	only)
		mov	ah, 4Bh		; load in the device driver
		int	21h		; DOS -	2+ - LOAD OR EXECUTE (EXEC)
					; DS:DX	-> ASCIZ filename
					; ES:BX	-> parameter block
					; AL = subfunc:	called by MSC spawn(P_NOWAIT,...) when running DOS 4.x.
		retn
ExecDev		endp


; =============== S U B	R O U T	I N E =======================================


RetFromUM	proc near		; ...
		pushf
		mov	cs:ConvLoad, 1	; ConvLoad set if didn't previously call HideUMBs
		call	UnHideUMBs
		jb	short rfUM1
		mov	cs:ConvLoad, 0	; ConvLoad clear if did.

rfUM1:					; ...
		popf
		retn
RetFromUM	endp


; =============== S U B	R O U T	I N E =======================================


RemoveNull	proc near		; ...
		mov	bl, es:[si]
		or	bl, bl		; null ?
		jz	short rn_gotnull
		inc	si		; advance the pointer
		jmp	short RemoveNull
; ---------------------------------------------------------------------------

rn_gotnull:				; ...
		mov	bl, cs:DevSavedDelim
		mov	es:[si], bl	; replace null with blank
		retn
RemoveNull	endp


; =============== S U B	R O U T	I N E =======================================


RoundBreakAddr	proc near		; ...
		mov	ax, word ptr cs:DevBrkAddr ; Rounds DevBrkAddr to a para addr
					; so that it is	of the form xxxx:0
		call	ParaRound
		add	word ptr cs:DevBrkAddr+2, ax
		mov	word ptr cs:DevBrkAddr,	0
		mov	ax, cs:DevLoadEnd
		cmp	word ptr cs:DevBrkAddr+2, ax
		jbe	short rba_ok
		jmp	mem_err
; ---------------------------------------------------------------------------

rba_ok:					; ...
		retn
RoundBreakAddr	endp


; =============== S U B	R O U T	I N E =======================================


DevSetBreak	proc near		; ...
		push	ax
		mov	ax, word ptr cs:DevBrkAddr+2 ; remove the init code
		cmp	cs:multdeviceflag, 0
		jnz	short set_break_continue ; do not check	it.
		cmp	ax, cs:DevLoadAddr
		jnz	short set_break_continue ; if not same,	then o.k.
		cmp	word ptr cs:DevBrkAddr,	0
		jz	short break_failed ; [DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0

set_break_continue:			; ...
		call	RoundBreakAddr
		pop	ax
		clc
		retn
; ---------------------------------------------------------------------------

break_failed:				; ...
		pop	ax
		stc
		retn
DevSetBreak	endp


; =============== S U B	R O U T	I N E =======================================


DevBreak	proc near		; ...
		push	ds		; Marks	a succesful install of a device	driver
					; Sets device size field in sub-arena &
					; Updates Free ptr in UMB or adjusts memhi
		mov	ax, cs:DevLoadAddr
		mov	bx, word ptr cs:DevBrkAddr+2
		dec	ax		; seg of sub-arena
		mov	ds, ax
		inc	ax		; Back to Device segment
		sub	ax, bx
		neg	ax		; size of device in paras
		mov	ds:3, ax	; [devmark.size]
					; store	it in sub-arena
		cmp	cs:DeviceHi, 0
		jz	short db_lo
		mov	cs:DevUMBFree, bx ; update Free	ptr in UMB
		jmp	short db_exit
; ---------------------------------------------------------------------------

db_lo:					; ...
		mov	cs:memhi, bx
		mov	cs:memlo, 0

db_exit:				; ...
		pop	ds
		retn
DevBreak	endp


; =============== S U B	R O U T	I N E =======================================


ParseSize	proc near		; ...
		push	bx		; Parses the command line for SIZE= command
		mov	bx, si
		mov	cs:DevSizeOption, 0 ; init the value
		mov	word ptr cs:DevCmdLine,	si
		mov	word ptr cs:DevCmdLine+2, es
		call	SkipDelim
		cmp	word ptr es:[si], 4953h	; 'SI'
		jnz	short ps_no_size
		cmp	word ptr es:[si+2], 455Ah ; 'ZE'
		jnz	short ps_no_size
		mov	al, es:[si+4]
		call	delim
		jnz	short ps_no_size ; cf=0	here
		add	si, 5
		call	GetHexNum
		jb	short ps_err
		mov	cs:DevSizeOption, ax
		call	SkipDelim
		mov	bx, si		; cf=0 here

ps_no_size:				; ...
		mov	si, bx
		pop	bx
		clc			; cf=0 here (clc is not	needed)
					; 22/07/2023 - Erdogan Tan
		retn
; ---------------------------------------------------------------------------

ps_err:					; ...
		pop	bx
		stc
		retn
ParseSize	endp


; =============== S U B	R O U T	I N E =======================================


SkipDelim	proc near		; ...
		mov	al, es:[si]	; Skips	delimiters in the string pointed to by ES:SI
					; Returns ptr to first non-delimiter character in ES:SI
		call	delim
		jnz	short sd_ret
		inc	si
		jmp	short SkipDelim
; ---------------------------------------------------------------------------

sd_ret:					; ...
		retn
SkipDelim	endp


; =============== S U B	R O U T	I N E =======================================


GetHexNum	proc near		; ...
		xor	ax, ax		; Converts an ascii string
					; terminated by	a delimiter into binary.
					; Assumes that the ES:SI
					; points to a Hexadecimal string
		xor	dx, dx

ghn_next:				; ...
		mov	bl, es:[si]
		cmp	bl, 0Dh		; cr
		jz	short ghn_err
		cmp	bl, 0Ah		; lf
		jz	short ghn_err
		push	ax
		mov	al, bl
		call	delim
		pop	ax
		jz	short ghn_into_paras
		call	GetNibble
		jb	short ghn_err
		mov	cx, 4

ghn_shift1:				; ...
		shl	ax, 1
		rcl	dx, 1
		loop	ghn_shift1
		or	al, bl
		inc	si
		jmp	short ghn_next
; ---------------------------------------------------------------------------

ghn_into_paras:				; ...
		add	ax, 15
		adc	dx, 0
		test	dx, 0FFF0h
		jnz	short ghn_err
		mov	cx, 4

ghn_shift2:				; ...
		clc
		rcr	dx, 1
		rcr	ax, 1
		loop	ghn_shift2
		clc			; AX = number of paras equivalent to the
					; hex number of	bytes specified
					; by the hexadecimal string.
		retn
; ---------------------------------------------------------------------------

ghn_err:				; ...
		stc			; encountered a	non-hex	character or crlf
		retn
GetHexNum	endp


; =============== S U B	R O U T	I N E =======================================


GetNibble	proc near		; ...
		cmp	bl, 30h	; '0'   ; Convert one nibble (hex digit) in BL into binary
		jb	short gnib_err
		cmp	bl, 39h	; '9'
		ja	short is_it_hex
		sub	bl, 30h	; '0'
		retn
; ---------------------------------------------------------------------------

is_it_hex:				; ...
		cmp	bl, 41h	; 'A'
		jb	short gnib_err
		cmp	bl, 46h	; 'F'
		ja	short gnib_err
		sub	bl, 37h	; '7'
		retn
; ---------------------------------------------------------------------------

gnib_err:				; ...
		stc
		retn
GetNibble	endp


; =============== S U B	R O U T	I N E =======================================


AllocUMB	proc near		; ...
		call	InitAllocUMB	; Allocate all UMBs and	link it	to DOS arena chain
					; link in the first UMB
		jb	short au_exit	; quit on error

au_next:				; ...
		call	umb_allocate	; allocate
		jb	short au_coalesce
		call	umb_insert	; & insert till	no UMBs
		jmp	short au_next
; ---------------------------------------------------------------------------

au_coalesce:				; ...
		call	umb_coalesce	; coalesce all UMBs

au_exit:				; ...
		retn
AllocUMB	endp


; =============== S U B	R O U T	I N E =======================================


InitAllocUMB	proc near		; ...
		call	IsXMSLoaded
		jnz	short iau_err	; quit on no XMS driver
		mov	ah, 52h
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		mov	cs:DevDOSData, es ; save dos data segment
		mov	ax, 4310h
		int	2Fh		; - Multiplex -	XMS - GET DRIVER ADDRESS
					; Return: ES:BX	-> driver entry	point
		mov	word ptr cs:DevXMSAddr,	bx ; get XMS driver address
		mov	word ptr cs:DevXMSAddr+2, es
		cmp	cs:FirstUMBLinked, 0 ; have we already linked a	UMB?
		jnz	short ia_1	; quit if we already did it
		call	LinkFirstUMB	; else link the	first UMB
		jb	short iau_err
		mov	cs:FirstUMBLinked, 0FFh	; mark that 1st	UMB linked

ia_1:					; ...
		clc			; (cf is already zero here)
					; Erdogan tan -	27/07/2023
		retn
; ---------------------------------------------------------------------------

iau_err:				; ...
		stc
		retn
InitAllocUMB	endp


; =============== S U B	R O U T	I N E =======================================


umb_allocate	proc near		; ...
		push	ax
		mov	ah, 16		; XMM_REQUEST_UMB
		mov	dx, 0FFFFh	; try to allocate largest possible
		call	cs:DevXMSAddr
		or	dx, dx
		jz	short ua_err
		mov	ah, 16
		call	cs:DevXMSAddr
		cmp	ax, 1		; Q: was the reqst successful
		jnz	short ua_err	; N: error
		clc

ua_done:				; ...
		pop	ax
		retn
; ---------------------------------------------------------------------------

ua_err:					; ...
		stc
		jmp	short ua_done
umb_allocate	endp


; =============== S U B	R O U T	I N E =======================================


umb_insert	proc near		; ...
		push	ds		; links	the UMB	into the arena chain
		mov	ds, cs:DevDOSData
		mov	ds, word ptr ds:8Ch ; [UMB_ARENA]  ; ds	= UMB_HEAD
		mov	ax, ds
		mov	es, ax
		assume es:nothing

ui_next:				; ...
		cmp	ax, bx		; BX = seg address of UMB to be	linked in
		ja	short ui_insert	; current block	above new block, insert	it
		cmp	byte ptr es:0, 5Ah ; 'Z' ; [es:ARENA.SIGNATURE],arena_signature_end
		jz	short ui_append	; if current block is the last,
					; append new block to chain
		mov	ds, ax
		call	get_next
		jmp	short ui_next	; ax = es = next block
; ---------------------------------------------------------------------------

ui_insert:				; ...
		mov	cx, ds		; ds = previous	arena
		inc	cx		; top of previous block
		sub	cx, bx
		neg	cx		; cx = size of used block
		mov	byte ptr ds:0, 4Dh ; 'M' ; [ARENA.SIGNATURE],arena_signature_normal
		mov	word ptr ds:1, 8 ; [ARENA.OWNER],8 ; mark as system owned
		mov	ds:3, cx	; [ARENA.SIZE],cx
		mov	word ptr ds:8, 4353h ; [ARENA.NAME],'SC'
		mov	es, bx		; prepare the arena at start of	new block
		mov	byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
		mov	word ptr es:1, 0 ; [es:ARENA.OWNER],arena_owner_system ; mark as free
		sub	dx, 2		; DX = size of UMB to be linked	in paras
					; make room for	arena at start & end of	new block
		mov	es:3, dx	; [es:ARENA.SIZE],dx
		add	bx, dx		; prepare arena	at end of new block
		inc	bx
		mov	es, bx		; es = arena at	top of new block
		inc	bx		; bx = top of new block
		sub	ax, bx		; ax contains arena just above this block
					; result: ax = size of used block
		mov	byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
		mov	word ptr es:1, 8 ; [es:ARENA.OWNER],8 ;	mark as	system owned
		mov	es:3, ax	; [es:ARENA.SIZE],ax
		mov	word ptr es:8, 4353h ; [es:ARENA.NAME],'SC'
		jmp	short ui_done
; ---------------------------------------------------------------------------

ui_append:				; ...
		add	ax, es:3	; es = arena of	last block
					; [es:ARENA.SIZE] ; ax=top of last block-1 para
		sub	word ptr es:3, 1 ; reserve space on top	of this
					; block	for the	next arena.
		mov	byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
		mov	cx, ax		; cx = top of prev block-1
		inc	ax
		sub	ax, bx		; ax = top of prev block - seg.	addr of	new block
		neg	ax
		mov	es, cx		; ds = arena of	unused block
		mov	byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
		mov	word ptr es:1, 8 ; [es:ARENA.OWNER],8 ;	mark as	system owned
		mov	es:3, ax	; mov [es:ARENA.SIZE],ax
		mov	word ptr es:8, 4353h ; mov word	[es:ARENA.NAME],'SC'
		mov	es, bx		; prepare the arena at start of	new block
		mov	byte ptr es:0, 5Ah ; 'Z' ; [es:ARENA.SIGNATURE],arena_signature_end
		mov	word ptr es:1, 0 ; [es:ARENA.OWNER],arena_owner_system
					; mark as free
		dec	dx		; make room for	arena
		mov	es:3, dx	; mov [es:ARENA.SIZE],dx

ui_done:				; ...
		pop	ds
		retn
umb_insert	endp


; =============== S U B	R O U T	I N E =======================================


umb_coalesce	proc near		; ...
		xor	di, di		; Combine free blocks ahead with current block
		mov	es, cs:DevDOSData
		mov	es, word ptr es:8Ch ; [es:UMB_ARENA] ; es = UMB_HEAD

uc_nextfree:				; ...
		mov	ax, es
		mov	ds, ax
		cmp	es:1, di	; [es:ARENA.OWNER],di
					; Q: is	current	arena free
		jz	short uc_again	; Y: try to coalesce with next block
					; N: get next arena
		call	get_next	; es, ax = next	arena
		jb	short uc_done
		jmp	short uc_nextfree
; ---------------------------------------------------------------------------

uc_again:				; ...
		call	get_next	; es, ax = next	arena
		jb	short uc_done
		cmp	es:1, di	; [es:ARENA.OWNER],di
					; Q: is	arena free
		jnz	short uc_nextfree ; N: get next	free arena
					; Y: coalesce
		mov	cx, es:3	; [es:ARENA.SIZE]
					; cx = next block size
		inc	cx		; cx = cx + 1 (for header size)
		add	ds:3, cx	; [ARENA.SIZE],cx
					; current size = current size +	cx
		mov	cl, es:[di]	; move up signature
		mov	[di], cl
		jmp	short uc_again	; try again
; ---------------------------------------------------------------------------

uc_done:				; ...
		retn
umb_coalesce	endp


; =============== S U B	R O U T	I N E =======================================


get_next	proc near		; ...
		cmp	byte ptr ds:0, 5Ah ; 'Z' ; Find Next item in Arena
					; cmp byte [ARENA.SIGNATURE],arena_signature_end
		jz	short gn_err
		mov	ax, ds		; ax = current block
		add	ax, ds:3	; add ax,[ARENA.SIZE]
					; ax = ax + current block length
		inc	ax		; remember that	header!
		mov	es, ax
		clc
		retn
; ---------------------------------------------------------------------------

gn_err:					; ...
		stc
		retn
get_next	endp


; =============== S U B	R O U T	I N E =======================================


LinkFirstUMB	proc near		; ...
		call	umb_allocate
		jb	short lfu_er
		int	12h		; MEMORY SIZE -
					; Return: AX = number of contiguous 1K blocks of memory
		mov	cl, 6
		shl	ax, cl		; ax = size in paragraphs
		mov	cx, ax
		sub	ax, bx		; bx = segment of allocated UMB
					; ax = - size of unused	block
		neg	ax
		sub	cx, 1		; cx = first umb_arena
		mov	es, cx		; es = first umb_arena
		mov	byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
		mov	word ptr es:1, 8 ; [es:ARENA.OWNER],8 ;	mark as	system owned
		mov	es:3, ax	; mov [es:ARENA.SIZE],ax
		mov	word ptr es:8, 4353h ; [es:ARENA.NAME],'SC'
		mov	es, bx		; put in the arena for the first UMB
					; es has first free umb	seg
		mov	byte ptr es:0, 5Ah ; 'Z' ; [es:ARENA.SIGNATURE],arena_signature_end
		mov	word ptr es:1, 0 ; es:ARENA.OWNER],arena_owner_system
					; mark as free
		dec	dx		; dx = size of UMB
					; make room for	arena
		mov	es:3, dx	; [es:ARENA.SIZE],dx
		mov	es, cs:DevDOSData
		mov	di, 8Ch		; UMB_ARENA
		mov	es:[di], cx	; initialize umb_head in DOS data segment
					; with the arena just below Top	of Memory
					;
					; we must now scan the arena chain and
					; update the size of the last arena
		mov	di, 24h		; DOS_ARENA
		mov	es, word ptr es:[di] ; es = start arena
		xor	di, di

scannext:				; ...
		cmp	byte ptr es:[di], 5Ah ;	'Z' ; arena_signature_end
		jz	short got_last
		mov	ax, es
		add	ax, es:3	; [es:ARENA.SIZE]
		inc	ax
		mov	es, ax
		jmp	short scannext
; ---------------------------------------------------------------------------

got_last:				; ...
		sub	word ptr es:3, 1 ; sub word [es:ARENA.SIZE],1
		mov	byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
		clc
		retn
; ---------------------------------------------------------------------------

lfu_er:					; ...
		stc
		retn
LinkFirstUMB	endp


; =============== S U B	R O U T	I N E =======================================


ShrinkUMB	proc near		; ...
		cmp	cs:DevUMBAddr, 0 ; Shrinks the current UMB in use,
					; so that the unused portions of the UMB
					; is given back	to the DOS free	mem pool
		jz	short su_exit
		push	es
		push	bx
		mov	bx, cs:DevUMBFree
		sub	bx, cs:DevUMBAddr
		mov	es, cs:DevUMBAddr
		mov	ax, 4A00h
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		mov	ax, es
		dec	ax
		mov	es, ax
		assume es:nothing
		mov	word ptr es:1, 8 ; [es:ARENA.OWNER]
		pop	bx
		pop	es
		assume es:nothing

su_exit:				; ...
		retn
ShrinkUMB	endp


; =============== S U B	R O U T	I N E =======================================


UnlinkUMB	proc near		; ...
		push	ds		; Unlinks the UMBs from	the DOS	arena chain
		push	es
		cmp	cs:FirstUMBLinked, 0
		jz	short ulu_x	; nothing to unlink
		mov	es, cs:DevDOSData ; get	DOS data seg
		mov	ds, word ptr es:24h ; [es:DOS_ARENA]
		mov	di, es:8Ch	; [es:UMB_ARENA]

ulu_next:				; ...
		call	get_next
		jb	short ulu_x
		cmp	di, ax		; is the next one UMB ?
		jz	short ulu_found
		mov	ds, ax
		jmp	short ulu_next
; ---------------------------------------------------------------------------

ulu_found:				; ...
		mov	byte ptr ds:0, 5Ah ; 'Z' ; [ARENA.SIGNATURE],arena_signature_end

ulu_x:					; ...
		pop	es
		pop	ds
		retn
UnlinkUMB	endp

; ---------------------------------------------------------------------------
MagicDDName	db '\DBLSPACE.BIN',0    ; ...

; =============== S U B	R O U T	I N E =======================================


MagicPreload	proc near		; ...
		mov	cs:DeviceHi, 0	; not to be loaded in UMB
		mov	cs:DevSizeOption, 0
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	si, offset MagicDDName ; "\\DBLSPACE.BIN"
		mov	word ptr cs:bpb_addr, si ; pass	the command line to the	device
		mov	word ptr cs:bpb_addr+2,	cs
		mov	word ptr cs:DevCmdLine,	si ; save it for error reporting
		mov	word ptr cs:DevCmdLine+2, cs
		call	round		; normalize memhi:memlo	(first free memory)
		push	cs
		pop	es
		assume es:SYSINIT
		call	SizeDevice	; get size of device file into DevSize
		mov	ax, 40h		; SYSPRE_BADFILE_ERROR
		jb	short pre_exit1
		mov	cs:ConvLoad, 1	; Doesn't matter if DeviceHi==0
		call	InitDevLoad	; set up sub-arena, DevLoadAddr,
					; DevLoadEnd, and DevEntry
					; gets arena name from bpb_addr
		mov	ax, cs:DevLoadAddr
		add	ax, cs:DevSize	; calculate seg	after DD load
		jb	short pre_exit_memory_err1 ; choke if overflows	address	space
		cmp	cs:DevLoadEnd, ax ; does it overflow available space?
		jnb	short _LoadDev	; we're golden if not

pre_exit_memory_err1:			; ...
		mov	ax, 42h		; SYSPRE_MEMORY_ERROR

pre_exit1:				; ...
		jmp	pre_exit
; ---------------------------------------------------------------------------

_LoadDev:				; ...
		lds	dx, cs:DevCmdLine ; get	the load file name
		assume ds:nothing
		call	ExecDev		; load device driver using exec	call
		mov	ax, 41h		; SYSPRE_EXEC_FAIL_ERROR
		jb	short pre_exit1
		mov	cs:break_addr, 0 ; pass	the limit to the DD
		mov	ax, cs:DevLoadEnd
		mov	cs:break_addr+2, ax
		les	bx, cs:DevEntry	; point	to the Magic DD	header
		assume es:nothing
		cmp	word ptr es:[bx+12h], 2E2Ch ; '.,' ; is it our stamp?
					; (',.' in NASM syntax)
		mov	ax, 46h		; SYSPRE_NOT_MAGIC
		jnz	short pre_exit3	; abort	if not MagicDrv!
		mov	word ptr cs:Magicbackdoor, 14h ; save the backdoor entry
		mov	word ptr cs:Magicbackdoor+2, es
		mov	al, cs:drivenumber ; pass drive	number to DBLSPACE as if
		mov	cs:devdrivenum,	al ; it	is a normal block device driver
		push	cs
		pop	es		; calldev needs	packet segment in es
		assume es:SYSINIT
		mov	bx, offset packet
		mov	ax, 10		; DS_INTERNAL_REVISION
					; tell it what revision	we expect
		call	cs:Magicbackdoor ; first time call is init entry point
					; with a standard device driver
					; init packet at es:bx
		jnb	short no_driver_version_fail
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	dx, offset baddblspace ; "Wrong	DBLSPACE.BIN version\r\n$"
		mov	ah, 9		; display the message
		int	21h		; DOS -	PRINT STRING
					; DS:DX	-> string terminated by	"$"
		jmp	short fail_driver_load
; ---------------------------------------------------------------------------

no_driver_version_fail:			; ...
		or	ax, ax		; error	code returned?
		jz	short magic_is_resident	; skip if no error

fail_driver_load:			; ...
		mov	word ptr cs:Magicbackdoor, offset NullBackdoor ;
					; point	backdoor call back to safe far return
		mov	word ptr cs:Magicbackdoor+2, cs
		mov	ax, 47h		; SYSPRE_DRIVER_FAILED ; error code

pre_exit3:				; ...
		jmp	short pre_exit_2
; ---------------------------------------------------------------------------

magic_is_resident:			; ...
		mov	ax, cs:break_addr
		add	ax, 15
		rcr	ax, 1
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1		; convert to paragraphs
		add	ax, cs:break_addr+2 ; add to terminate segment
		mov	word ptr cs:DevBrkAddr+2, ax
		mov	word ptr cs:DevBrkAddr,	0 ; store normalized end here
		mov	bx, 4		; inquire how many paragraphs it wants
		call	cs:Magicbackdoor
		mov	bx, cs:ALLOCLIM	; get top of free memory
		sub	bx, ax		; see how much we'll lower it
		cmp	bx, word ptr cs:DevBrkAddr+2 ; is there	that much room free?
		jb	short cant_move_driver ; if not, just leave it low
		sub	cs:ALLOCLIM, ax	; allocate space!
		mov	es, cs:ALLOCLIM
		assume es:nothing
		mov	bx, 6		; tell the driver to move itself
		call	cs:Magicbackdoor
		mov	word ptr cs:DevBrkAddr+2, ax ; save end	of low stub

cant_move_driver:			; ...
		mov	ax, word ptr cs:DevBrkAddr+2 ; get terminate segment
		cmp	ax, cs:DevLoadEnd ; terminate size TOO big?
		mov	ax, 42h		; SYSPRE_MEMORY_ERROR
		ja	short pre_exit2	; error	out if so
		lds	si, cs:DevEntry	; set ds:si to header
		assume ds:nothing
		les	di, cs:DOSINFO	; es:di	point to dos info
		jmp	short _isblock
; ---------------------------------------------------------------------------

pre_exit_memory_err:			; ...
		mov	ax, 42h		; SYSPRE_MEMORY_ERROR

pre_exit_2:				; ...
		jmp	pre_exit
; ---------------------------------------------------------------------------

_isblock:				; ...
		mov	al, cs:unitcount ; if no units found, erase the	device
		or	al, al
		jz	short pre_exit_no_units_err
		mov	[si+10], al	; mov [si+SYSDEV.NAME],al
					; number of units in name field
					; device drivers are *supposed*
					; to do	this for themselves.
		xor	ah, ah
		mov	cx, ax
		mov	dh, ah
		mov	dl, es:[di+20h]	; [es:di+SYSI_NUMIO]
					; get number of	devices
		mov	ah, dl
		add	ah, al		; check	for too	many devices
		cmp	ah, 26		; 'A' - 'Z' is 26 devices
		ja	short pre_exit_too_many_units_err
		call	DevSetBreak
		jb	short pre_exit_memory_err

_ok_block:				; [es:di+SYSI_NUMIO] ; update the amount
		add	es:[di+20h], al
		lds	bx, cs:bpb_addr	; point	to bpb array (*)

_perunit:				; ...
		les	bp, cs:DOSINFO
		les	bp, es:[bp+0]	; es:[bp.sysi_dpb]
					; get first dpb
					; [es:bp+SysInitvars.SYSI_DPB] ; [es:bp+0]

_scandpb:				; ...
		cmp	word ptr es:[bp+19h], 0FFFFh ; -1 ; es:[bp.dpb_next_dpb]
		jz	short _foundpb
		les	bp, es:[bp+19h]	; les bp,es:[bp.dpb_next_dpb]
					; [es:bp+DPB.NEXT_DPB]
		jmp	short _scandpb
; ---------------------------------------------------------------------------

pre_exit_too_many_units_err:		; ...
		mov	ax, 44h		; SYSPRE_TOO_MANY_UNITS_ERROR
		jmp	short pre_exit2
; ---------------------------------------------------------------------------

pre_exit_no_units_err:			; ...
		mov	ax, 43h		; SYSPRE_NO_UNITS_ERROR

pre_exit2:				; ...
		jmp	pre_exit
; ---------------------------------------------------------------------------

_foundpb:				; ...
		mov	ax, word ptr cs:DevBrkAddr
		mov	es:[bp+19h], ax	; es:[bp.dpb_next_dpb] ; DPB.NEXT_DPB
		mov	ax, word ptr cs:DevBrkAddr+2
		mov	es:[bp+1Bh], ax	; es:[bp.dpb_next_dpb+2] ; DPB.NEXT_DPB+2
		les	bp, cs:DevBrkAddr
		add	word ptr cs:DevBrkAddr,	33 ; DPBSIZ ; 21h
		call	RoundBreakAddr
		mov	word ptr es:[bp+19h], 0FFFFh ; -1
		mov	byte ptr es:[bp+18h], 0FFh ; es:[bp.dpb_first_access],-1
					; DPB.FIRST_ACCESS
		mov	si, [bx]	; ds:si	points to bpb (*)
					; (mov si,[bx] ..and then.. add	bx,2)
					; Note:	If unit	count >	1, bx points to	a BPB in the BPB array,
					; the array address is in [bpb_addr] (*) -I don't understand how and
					; what for but DBLSPACE.BIN code may set this- (bx=bx+2	for next)
					; Erdogan Tan -	07/07/2023
		inc	bx
		inc	bx		; point	to next	BPB
					; (in the BPB array) (*) -add bx,2-
		mov	es:[bp+0], dx	; mov word ptr es:[bp.dpb_drive],dx
					; [es:bp+DPB.DRIVE],dl ; [es:bp+DPB.UNIT],dh
		mov	ah, 53h		; SETDPB ; hidden system call
		int	21h		; DOS -	2+ internal - TRANSLATE	BIOS PARAMETER BLOCK
					; DS:SI	-> BPB (BIOS Parameter Block)
					; ES:BP	-> buffer for DOS Drive	Parameter Block
		mov	ax, es:[bp+2]	; es:[bp.dpb_sector_size]  ; [es:bp+DPB.SECTOR_SIZE]
		push	es
		les	di, cs:DOSINFO
		cmp	ax, es:[di+10h]	; es:[di.sysi_maxsec] ;	[es:di+SysInitvars.SYSI_MAXSEC]
		pop	es
		mov	ax, 45h		; SYSPRE_BAD_SECTOR_SIZE_ERROR
		ja	short pre_exit
		push	ds
		lds	ax, cs:DevEntry
		mov	es:[bp+13h], ax	; [es:bp+DPB.DRIVER_ADDR]
		mov	word ptr es:[bp+15h], ds ; [es:bp+DPB.DRIVER_ADDR+2]
		pop	ds
		inc	dl		; increment drive number
		inc	dh		; increment unix number
		loop	_perunit
		push	cs
		pop	ds
		assume ds:SYSINIT
		call	TempCDS		; set cds for new drives
		les	di, cs:DOSINFO	; es:di	= dos table (SysInitVars)
		mov	cx, es:[di+22h]	; [es:di+SYSI_DEV] ; dx:cx = head of list
		mov	dx, es:[di+24h]	; [es:di+SYSI_DEV+2]
		lds	si, cs:DevEntry	; ds:si	= device location
		assume ds:nothing
		mov	es:[di+22h], si	; [es:di+SYSI_DEV] ; set head of list in dos
		mov	word ptr es:[di+24h], ds ; [es:di+SYSI_DEV+2]
		mov	[si], cx	; link in the driver
		mov	[si+2],	dx
		call	DevBreak
		mov	cx, word ptr cs:DevBrkAddr+2 ; pass it a work buffer
		mov	dx, cs:ALLOCLIM	; address in cx	(segment)
		sub	dx, cx		; for len dx (paragraphs)
		mov	ax, 5500h	; we're shuffle aware, but don't move
					; any drives at	this point.
		mov	bx, 2		; switch what we can now
		call	cs:Magicbackdoor
		xor	ax, ax		; no errors!
					; zf=1

pre_exit:				; ...
		or	ax, ax		; reset	zero flag if error
		retn
MagicPreload	endp


; =============== S U B	R O U T	I N E =======================================


MagicPostload	proc near		; ...
		mov	ax, 4A11h	; multMagicdrv
					; DBLSPACE.BIN - "GetVersion" -
					;		INSTALLATION CHECK
					; (BX =	0)
		mov	bx, 0		; MD_VERSION
		int	2Fh
		or	ax, ax		; ax = 0 (successful, zf=1)
					; is it	there?
		jnz	short no_magic	; done if not
		test	dx, 8000h	; is it	already	permanent?
		jz	short no_magic	; no, done if so (not in final position)
		mov	bx, 0FFFFh	; -1 ; how much	space does it want?
		mov	ax, 4A11h	; multMagicdrv
					; DBLSPACE.BIN - GET RELOCATION	SIZE
		int	2Fh		; get paragraphs into ax
		add	ax, 2		; extra	2 paragraphs for the stub
					; add ax,((tiny_stub_end-tiny_stub_start)+15)/16
					; (18+15)/16 = 2
		mov	cs:DevSize, ax	; store	that (**)
		mov	cs:DeviceHi, 0	; not to be loaded in UMB
		mov	cs:DevSizeOption, 0
		mov	cs:ConvLoad, 1	; conventional (memory)	load
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	word ptr cs:bpb_addr, offset MagicDDName ; "\\DBLSPACE.BIN"
		mov	word ptr cs:bpb_addr+2,	cs ; pass name so that
					; arena	header can be set
		call	round		; normalize memhi:memlo
		call	InitDevLoad	; set up sub-arena, DevLoadAddr,
					; DevLoadEnd, and DevEntry
					; gets arena name from bpb_addr
		mov	ax, cs:DevLoadAddr ; (**) (InitDevload sets this)
		add	ax, cs:DevSize	; calculate seg	after DD load
		mov	word ptr cs:DevBrkAddr+2, ax ; save as ending address!
		mov	word ptr cs:DevBrkAddr,	0
		mov	es, cs:DevLoadAddr
		mov	si, offset tiny_stub_start
		xor	di, di		; move a little	header in place
					; so that this looks to	the mem	command
					; like a legitimate driver load
		mov	cx, 18		; (tiny_stub_end-tiny_stub_start)
		rep movsb		; move it!
		mov	ax, es		; advance es appropriately
		add	ax, 2		; add ax,((tiny_stub_end-tiny_stub_start)+15)/16
		mov	es, ax
		assume es:BIOSDATA
		mov	ax, 4A11h	; multMagicdrv
		mov	bx, 0FFFEh	; -2 ; final placement!
		int	2Fh		; DBLSPACE.BIN - RELOCATE
					; es = segment to which	to relocate DBLSPACE.BIN
		call	DevSetBreak	; go ahead and alloc mem for device
		call	DevBreak

no_magic:				; ...
		retn
MagicPostload	endp


; =============== S U B	R O U T	I N E =======================================


MagicSetCdss	proc near		; ...
		mov	ax, 4A11h	; multMagicdrv
					; DBLSPACE.BIN - "GetVersion" -
					;		INSTALLATION CHECK
					; (BX =	0)
		mov	bx, 0		; MD_VERSION
		int	2Fh
		or	ax, ax		; ax = 0 (successful, zf=1)
					; is it	there?
		jnz	short magic_set_exit ; done if not
		mov	al, cl		; get first DblSpace drive letter
		sub	al, 'A'         ; make it zero based.
		mov	dl, al		; and save for drive testing loop
		les	si, cs:DOSINFO	; point	to DOS data area (SysInitVars)
		assume es:nothing
		les	si, es:[si+16h]	; les si,es:[si].sysi_cds ; fetch CDSs
					; [es:si+SYSI_CDS]
		mov	ah, 88		; curdirLen
		mul	ah		; find first DblSpace CDS
		add	si, ax		; cds pointer
		mov	cl, ch		; get DblSpace drive count into	cx
		xor	ch, ch

magic_set_cdss_1:			; ...
		push	si
		push	es
		push	cx
		push	dx
		mov	ax, 4A11h	; multMagicdrv
		mov	bx, 1		; MD_DRIVE_MAP ; inquire drive map
		int	2Fh		; DBLSPACE.BIN - "GetDriveMapping"
					; see if this is an unused DblSpace drive
		pop	dx
		pop	cx
		pop	es
		pop	si
		cmp	bl, dl		; if mapped to itself, it is vacant
		jnz	short magic_set_cdss_2 ; skip if used
		and	word ptr es:[si+43h], 0BFFFh ; reset the bit in	flags (curdir_inuse bit)
					; [si+curdir_list.cdir_flags],~curdir_inuse ; word
					; (.. [si+1+curdir_list.cdir_flags],0BFh ; byte)

magic_set_cdss_2:			; ...
		add	si, 88		; curdirLen
		inc	dl		; next drive
		loop	magic_set_cdss_1

magic_set_exit:				; ...
		retn
MagicSetCdss	endp

; ---------------------------------------------------------------------------
tiny_stub_start	dw 0FFFFh		; ...
					; phony	device driver link
		dw 0FFFFh		; dw -1, -1
		dw 8000h		; mark as character device for MEM display
		dw 2 dup(0)		; strat	and irpt
		db 'DBLSBIN$'           ; magic default load
					; (tiny_stub_end-tiny_stub_start = 18)
insert_blank	db 0			; ...
					; tiny_stub_end	equ $

; =============== S U B	R O U T	I N E =======================================


setparms	proc near		; ...
		push	ds
		push	ax
		push	bx
		push	cx
		push	dx
		push	cs
		pop	ds
		xor	bx, bx
		mov	bl, drive
		inc	bl		; get it correct for ioctl call
					; (1=A,2=A...)
		mov	dx, offset devp_specialfunc ; offset deviceparameters
		mov	ah, 44h		; IOCTL
		mov	al, 0Dh		; GENERIC_IOCTL
		mov	ch, 8		; RAWIO
		mov	cl, 40h		; SET_DEVICE_PARAMETERS
		int	21h		; DOS -	2+ - IOCTL -
		mov	ax, 70h		; DOSBIODATASEG	; BIOSDATA segment
		mov	ds, ax
		assume ds:nothing
		test	cs:switches, 4	; flagec35
		jz	short not_ec35
		mov	cl, cs:drive	; which	drive was this for?
		mov	al, 1		; assume drive 0
		shl	al, cl		; set proper bit depending on drive
		or	ds:ec35_flag, al ; set the bit in the permanent	flags

not_ec35:				; ...
		mov	al, byte ptr cs:devp_spt ; mov al,[cs:deviceparameters+20]
					; [cs:deviceparameters+A_DEVICEPARAMETERS.DP_BPB
					; +A_BPB.BPB_SECTORSPERTRACK]
		cmp	al, ds:eot
		jbe	short eot_ok
		mov	ds:eot,	al

eot_ok:					; ...
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		pop	ds
		assume ds:nothing
		retn
setparms	endp


; =============== S U B	R O U T	I N E =======================================


diddleback	proc near		; ...
		push	ds		; replace default values for further drivparm commands
		push	cs
		pop	ds
		assume ds:SYSINIT
		mov	devp_cylinders,	80 ; [deviceparameters+4],80
					; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],80
		mov	devp_devtype, 2	; [deviceparameters+1],2
					; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_3INCH720KB
		mov	devp_devattr, 0	; [deviceparameters+2],0
					; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],0
		mov	switches, 0	; zero all switches
		pop	ds
		assume ds:nothing
		retn
diddleback	endp


; =============== S U B	R O U T	I N E =======================================


parseline	proc near		; ...
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT

nextswtch:				; ...
		cmp	al, 0Dh		; al contains the first	character in command line.
		jz	short done_line	; cr
		cmp	al, 0Ah
		jz	short put_back	; lf ; put it back and done
		cmp	al, 20h	; ' '
		jbe	short getnext	; skip over space
		cmp	al, 2Fh	; '/'
		jz	short getparm
		stc			; mark error invalid-character-in-input
		jmp	short exitpl
; ---------------------------------------------------------------------------

getparm:				; ...
		call	check_switch
		mov	switches, bx	; save switches	read so	far
		jb	short swterr

getnext:				; ...
		call	getchr
		jb	short done_line
		jmp	short nextswtch
; ---------------------------------------------------------------------------

swterr:					; ...
		jmp	short exitpl	; exit if error
; ---------------------------------------------------------------------------

done_line:				; ...
		test	switches, 8	; flagdrive ; see if drive specified
		jnz	short okay
		stc			; mark error no-drive-specified
		jmp	short exitpl
; ---------------------------------------------------------------------------

okay:					; ...
		mov	ax, switches
		and	ax, 3		; get flag bits	for changeline and non-rem
		mov	devp_devattr, ax ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
		mov	devp_trktblents, 0 ; [deviceparameters+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
		clc			; everything is	fine
		call	setdeviceparameters

exitpl:					; ...
		pop	ds
		assume ds:nothing
		retn
; ---------------------------------------------------------------------------

put_back:				; ...
		inc	ds:count	; one more char	to scan
		dec	ds:chrptr	; back up over linefeed
		jmp	short done_line
parseline	endp


; =============== S U B	R O U T	I N E =======================================


check_switch	proc near		; ...
		call	getchr
		jb	short err_chk
		and	al, 0DFh	; convert it to	upper case
		cmp	al, 41h	; 'A'
		jb	short err_chk
		cmp	al, 5Ah	; 'Z'
		ja	short err_chk
		push	es
		push	cs
		pop	es
		assume es:SYSINIT
		mov	cl, byte ptr ds:switchlist ; get number	of valid switches
		mov	ch, 0
		mov	di, (offset switchlist+1) ; point to string of valid switches
		repne scasb
		pop	es
		assume es:nothing
		jnz	short err_chk
		mov	ax, 1
		shl	ax, cl		; set bit to indicate switch
		mov	bx, ds:switches	; get switches so far
		or	bx, ax		; save this with other switches
		mov	cx, ax
		test	ax, 0F8h	; switchnum ; 0F8h
					; test against switches	that require number to follow
		jz	short done_swtch
		call	getchr
		jb	short err_swtch
		cmp	al, ':'
		jnz	short err_swtch
		call	getchr
		push	bx		; preserve switches
		mov	cs:sepchr, 20h ; ' ' ; allow space separators
		call	getnum
		mov	cs:sepchr, 0
		pop	bx		; restore switches
		call	process_num

done_swtch:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

err_swtch:				; ...
		xor	bx, cx		; remove this switch from the records

err_chk:				; ...
		stc
		retn
check_switch	endp


; =============== S U B	R O U T	I N E =======================================


process_num	proc near		; ...
		test	ds:switches, cx	; if this switch has been done before,
		jnz	short done_ret	; ignore this one.
		test	cx, 8		; flagdrive
		jz	short try_f
		mov	ds:drive, al
		jmp	short done_ret
; ---------------------------------------------------------------------------

try_f:					; ...
		test	cx, 80h		; flagff
		jz	short try_t
		mov	ds:530Dh, al
		jmp	short done_ret
; ---------------------------------------------------------------------------

try_t:					; ...
		or	ax, ax		; if number entered was	0, assume default value
		jz	short done_ret
		test	cx, 10h		; flagcyln
		jz	short try_s
		mov	ds:devp_cylinders, ax ;	[deviceparameters+4],ax
					; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
		jmp	short done_ret
; ---------------------------------------------------------------------------

try_s:					; ...
		test	cx, 20h		; flagseclim
		jz	short try_h	; must be for number of	heads
		mov	ds:slim, ax
		jmp	short done_ret
; ---------------------------------------------------------------------------

try_h:					; ...
		mov	ds:hlim, ax

done_ret:				; ...
		clc			; (test	instruction resets cf)
		retn
process_num	endp


; =============== S U B	R O U T	I N E =======================================


setdeviceparameters proc near		; ...
		push	es
		push	cs
		pop	es
		assume es:SYSINIT
		xor	bx, bx
		mov	bl, ds:devp_devtype ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE]
		cmp	bl, 0		; DEV_5INCH
		jnz	short got_80
		mov	ds:devp_cylinders, 40 ;	[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
					; 48 tpi = 40 cyl

got_80:					; ...
		shl	bx, 1		; get index into bpb table
		mov	si, ds:_bpbtable[bx] ; get address of bpb
		mov	di, offset devp_bps ; deviceparameters+7
					; deviceparameters+A_DEVICEPARAMETERS.DP_BPB
					; es:di	-> bpb
		mov	cx, 31		; A_BPB.size
		cld
		rep movsb
		pop	es
		assume es:nothing
		test	ds:switches, 20h ; flagseclim
		jz	short see_heads
		mov	ax, ds:slim
		mov	ds:devp_spt, ax	; [deviceparameters+20]
					; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
					;  +A_BPB.BPB_SECTORSPERTRACK]

see_heads:				; ...
		test	ds:switches, 40h ; flagheads
		jz	short heads_not_altered
		mov	ax, ds:hlim
		mov	ds:devp_heads, ax ; [deviceparameters+22]
					; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]

heads_not_altered:			; ...
		mov	ds:devp_secperclus, 2 ;	[deviceparameters+9],2
					; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
					;  +A_BPB.BPB_SECTORSPERCLUSTER]
		mov	bl, 0F0h ; 'ð'  ; get default mediabyte
		mov	bh, ds:devp_mediaid ; [deviceparameters+17]
					; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]
		cmp	ds:devp_heads, 2
		ja	short got_correct_mediaid ; just use default if	heads>2
		jnz	short only_one_head ; one head,	do one head stuff
		mov	bl, bh
		cmp	ds:devp_spt, 18	; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
					;  +A_BPB.BPB_SECTORSPERTRACK]
		jnz	short not_144m
		cmp	ds:devp_cylinders, 80 ;	[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
		jnz	short not_144m
		jmp	short got_one_secperclus_drive ; cyl=80, heads=2, secpertrack=18.
					;  Set cluster size to 1.
; ---------------------------------------------------------------------------

not_144m:				; ...
		cmp	ds:devp_cylinders, 40
		jnz	short got_correct_mediaid
		cmp	ds:devp_spt, 8
		jnz	short got_correct_mediaid
		mov	bl, 0FCh
		jmp	short got_correct_mediaid
; ---------------------------------------------------------------------------

only_one_head:				; ...
		cmp	ds:devp_devtype, 0 ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_5INCH
		jnz	short got_one_secperclus_drive
		mov	bl, 0FCh
		cmp	ds:devp_spt, 8	; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
					;  +A_BPB.BPB_SECTORSPERTRACK],8
		jnz	short got_one_secperclus_drive ; okay if anything besides 8
		mov	bl, 0FEh	; 160K mediaid

got_one_secperclus_drive:		; ...
		mov	ds:devp_secperclus, 1 ;	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB
					;  +A_BPB.BPB_SECTORSPERCLUSTER],1

got_correct_mediaid:			; ...
		mov	ds:devp_mediaid, bl ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
					;  +A_BPB.BPB_MEDIADESCRIPTOR],bl
		mov	ax, ds:devp_cylinders ;	[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
		mul	ds:devp_heads	; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]
		mul	ds:devp_spt	; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
		mov	ds:devp_totalsecs, ax ;	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
		clc
		retn
setdeviceparameters endp


; =============== S U B	R O U T	I N E =======================================


organize	proc near		; ...
		mov	cx, cs:count
		jcxz	short nochar1
		xor	si, si
		mov	di, si
		xor	ax, ax
		mov	cs:com_level, 0

org1:					; ...
		call	skip_comment
		jz	short end_commd_line ; found a comment string and skipped.
		call	get2		; not a	comment	string.	then get a char.
		cmp	al, 0Ah		; lf
		jz	short end_commd_line ; starts with a blank line.
		cmp	al, 20h	; ' '
		jbe	short org1	; skip leading control characters
		jmp	short findit
; ---------------------------------------------------------------------------

end_commd_line:				; ...
		stosb			; store	line feed char in buffer for the linecount.
		mov	cs:com_level, 0	; reset	the command level.
		jmp	short org1
; ---------------------------------------------------------------------------

nochar1:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

findit:					; ...
		push	cx		; prepare to search command table
		push	si
		push	di
		mov	bp, si
		dec	bp
		mov	si, offset comtab ; "\x01[["
		mov	ch, 0

findcom:				; ...
		mov	di, bp
		mov	cl, [si]
		inc	si
		jcxz	short nocom
		cmp	byte ptr es:[di], 3Bh ;	';' ; CONFIG_SEMICOLON
		jz	short semicolon

loopcom:				; ...
		mov	al, es:[di]
		inc	di
		and	al, 0DFh	; ~20h ; force upper case
		inc	si
		cmp	al, [si-1]	; compare to byte @es:di
		loope	loopcom
		lahf
		add	si, cx		; bump to next position	without	affecting flags
		sahf
		lodsb			; get indicator	letter
		jnz	short findcom
		cmp	byte ptr es:[di], 0Dh ;	the next char might be cr,lf
		jz	short gotcom0
		cmp	byte ptr es:[di], 0Ah ;	such as	in "rem",cr,lf case.
		jz	short gotcom0
		cmp	al, 5Bh	; '['   ; CONFIG_BEGIN
		jz	short gotcom0
		push	ax
		mov	al, es:[di]	; now the next char. should be a delim.
		cmp	al, 3Fh	; '?'   ; explicit interactive command?
		jnz	short no_query	; no
		pop	ax		; yes, so retrieve the original	code
		or	al, 80h		; CONFIG_OPTION_QUERY ;	and set	the QUERY bit
		jmp	short gotcom0
; ---------------------------------------------------------------------------

semicolon:				; ...
		mov	al, 30h	; '0'   ; CONFIG_REM
		jmp	short gotcom0
; ---------------------------------------------------------------------------

no_query:				; ...
		call	delim
		pop	ax
		jnz	short findcom

gotcom0:				; ...
		pop	di
		pop	si
		pop	cx
		jmp	short gotcom
; ---------------------------------------------------------------------------

nocom:					; ...
		pop	di
		pop	si
		pop	cx
		mov	al, 5Ah	; 'Z'   ; CONFIG_UNKNOWN
		stosb			; save indicator char.

_skipline:				; ...
		call	get2
		cmp	al, 0Ah		; lf ; skip this bad command line
		jnz	short _skipline
		jmp	short end_commd_line
; ---------------------------------------------------------------------------

gotcom:					; ...
		stosb			; save indicator char in buffer
		and	al, 7Fh		; ~CONFIG_OPTION_QUERY
		mov	cs:cmd_indicator, al ; save it for the future use.
		cmp	al, 5Bh	; '['   ; CONFIG_BEGIN
		jz	short org31
		cmp	al, 4Fh	; 'O'   ; CONFIG_SUBMENU
		jz	short org2
		cmp	al, 45h	; 'E'   ; CONFIG_MENUITEM
		jz	short org2
		cmp	al, 41h	; 'A'   ; CONFIG_MENUDEFAULT
		jz	short org2
		cmp	al, 4Ah	; 'J'   ; CONFIG_INCLUDE
		jz	short org2
		call	mapcase		; map case of rest of line to UPPER

org2:					; ...
		call	get2		; skip the command name	until delimiter
		cmp	al, 0Ah		; lf
		jz	short org21
		cmp	al, 0Dh		; cr
		jz	short org21
		cmp	al, 2Fh	; '/'   ; Added to allow DEVHIGH/L:...
		jz	short org21	; to be	parsed properly
		call	delim
		jnz	short org2
		jmp	short org3
; ---------------------------------------------------------------------------

org21:					; ...
		dec	si		; if cr	or lf then
		inc	cx		; undo si, cx register and continue

org3:					; ...
		cmp	cs:cmd_indicator, 59h ;	'Y' ; CONFIG_COMMENT
		jz	short get_cmt_token
		cmp	cs:cmd_indicator, 44h ;	'D' ; CONFIG_DEVICE
		jz	short org_file
		cmp	cs:cmd_indicator, 49h ;	'I' ; CONFIG_INSTALL
		jz	short org_file
		cmp	cs:cmd_indicator, 57h ;	'W' ; CONFIG_INSTALLHIGH
		jz	short org_file
		cmp	cs:cmd_indicator, 53h ;	'S' ; CONFIG_SHELL
		jz	short org_file
		cmp	cs:cmd_indicator, 31h ;	'1' ; CONFIG_SWITCHES
		jz	short org_switch

org31:					; ...
		jmp	org4
; ---------------------------------------------------------------------------

org_switch:				; ...
		call	skip_comment
		jz	short end_commd_line_brdg
		call	get2
		call	org_delim
		jz	short org_switch
		stosb
		jmp	org5
; ---------------------------------------------------------------------------

org_file:				; ...
		call	skip_comment	; get the filename and put 0 at	end
		jz	short org_put_zero
		call	get2		; not a	comment
		call	delim
		jz	short org_file	; skip the possible delimiters
		stosb			; copy the first non delim char	found in buffer

org_copy_file:				; ...
		call	skip_comment	; comment char in the filename?
		jz	short org_put_zero ; then stop copying filename	at that	point
		call	get2
		cmp	al, 2Fh	; '/'   ; a switch char? (device=filename/xxx)
		jz	short end_file_slash ; this will be the	special	case.
		stosb			; save the char. in buffer
		call	delim
		jz	short end_copy_file
		cmp	al, 20h	; ' '
		ja	short org_copy_file ; keep copying
		jmp	short end_copy_file ; otherwise, assume	end of the filename.
; ---------------------------------------------------------------------------

get_cmt_token:				; ...
		call	get2		; get the token. just max. 2 char.
		cmp	al, 20h	; ' '   ; skip white spaces or "=" char.
		jz	short get_cmt_token ; (we are allowing the other special
		cmp	al, 9		; characters can used for comment id.
		jz	short get_cmt_token ; character.)
		cmp	al, 3Dh	; '='   ;  = is special in this case.
		jz	short get_cmt_token
		cmp	al, 0Dh
		jz	short get_cmt_end ; cannot accept the carriage return
		cmp	al, 0Ah
		jz	short get_cmt_end
		mov	cs:cmmt1, al	; store	it
		mov	cs:cmmt, 1	; 1 char. so far.
		call	get2
		cmp	al, 20h	; ' '
		jz	short get_cmt_end
		cmp	al, 9		; tab
		jz	short get_cmt_end
		cmp	al, 0Dh		; cr
		jz	short get_cmt_end
		cmp	al, 0Ah		; lf
		jz	short end_commd_line_brdg
		mov	cs:cmmt2, al
		inc	cs:cmmt

get_cmt_end:				; ...
		call	get2
		cmp	al, 0Ah		; lf
		jnz	short get_cmt_end ; skip it.

end_commd_line_brdg:			; ...
		jmp	end_commd_line	; else jmp to end_commd_line
; ---------------------------------------------------------------------------

org_put_zero:				; ...
		mov	byte ptr es:[di], 0 ; make the filename	in front of
					; the comment string to	be an asciiz.
		inc	di
		jmp	end_commd_line	; (maybe null if device=/*)
; ---------------------------------------------------------------------------

end_file_slash:				; ...
		mov	byte ptr es:[di], 0 ; al = "/" option char.
					; make a filename an asciiz
		inc	di		; and
		stosb			; store	"/" after that.
		jmp	short org5	; continue with	the rest of the	line
; ---------------------------------------------------------------------------

end_copy_file:				; ...
		mov	byte ptr es:[di-1], 0 ;	make it	an asciiz and handle the next char.
		cmp	al, 0Ah		; lf
		jz	short end_commd_line_brdg
		jmp	short org5
; ---------------------------------------------------------------------------

org4:					; ...
		call	skip_comment	; org4 skips all delimiters
					; after	the command name except	for '/'
		jz	short end_commd_line_brdg
		call	get2
		call	org_delim	; skip delimiters except '/'
		jz	short org4
		jmp	short org51
; ---------------------------------------------------------------------------

org5:					; ...
		call	skip_comment	; rest of the line is
		jz	short end_commd_line_brdg ; comment.
		call	get2		; not a	comment.

org51:					; ...
		stosb			; copy the character
		cmp	al, 22h	; '"'   ; a quote ?
		jz	short at_quote
		cmp	al, 20h	; ' '
		ja	short org5
		cmp	cs:cmd_indicator, 'U' ; CONFIG_DEVICEHIGH
					; Q: is	this devicehigh
		jnz	short not_dh	; N:
		cmp	al, 0Ah		; Q: is	this line feed
		jz	short org_dhlf	; Y: stuff a blank before the lf
		cmp	al, 0Dh		; Q: is	this a cr
		jnz	short org5	; N:
		mov	byte ptr es:[di-1], 20h	; ' ' ; overwrite cr with blank
		stosb			; put cr after blank
		inc	cs:insert_blank	; indicate that	blank has been inserted
		jmp	short org5
; ---------------------------------------------------------------------------

not_dh:					; ...
		cmp	al, 0Ah		; lf ; line feed?
		jz	short org1_brdg	; handles the next command line.
		jmp	short org5	; handles next char in this line.
; ---------------------------------------------------------------------------

org_dhlf:				; ...
		cmp	cs:insert_blank, 1 ; Q:has a blank already been	inserted
		jz	short org1_brdg	; Y:
		mov	byte ptr es:[di-1], 20h	; ' ' ; overwrite lf with blank
		stosb			; put lf after blank

org1_brdg:				; ...
		mov	cs:insert_blank, 0 ; clear blank indicator for devicehigh
		jmp	org1
; ---------------------------------------------------------------------------

at_quote:				; ...
		cmp	cs:com_level, 0
		jz	short up_level
		mov	cs:com_level, 0	; reset	it
		jmp	short org5
; ---------------------------------------------------------------------------

up_level:				; ...
		inc	cs:com_level	; set it
		jmp	short org5
organize	endp

; ---------------------------------------------------------------------------

get2:					; ...
		jcxz	short noget
		lods	byte ptr es:[si]
		dec	cx
		retn
; ---------------------------------------------------------------------------

noget:					; ...
		pop	cx		; This was the rather kludgy way
					; out of procedure "organize",
					; but instead of returning to doconf,
					; we now want to check config.sys BEGIN/END blocks
					; and the new boot menu	stuff
		mov	cs:count, di
		mov	cs:org_count, di
		xor	si, si
		mov	cs:chrptr, si
		mov	cx, di
		jmp	menu_check

; =============== S U B	R O U T	I N E =======================================


skip_comment	proc near		; ...
		jcxz	short noget	; get out of the organize routine.
					; ...
					; skip the commented string until lf,
					; if current es:si-> a comment string.
					; ...
		cmp	cs:com_level, 0	; only check it	if parameter level is 0.
		jnz	short no_commt	; (not inside quotations)
		cmp	cs:cmmt, 1
		jb	short no_commt
		mov	al, es:[si]
		cmp	cs:cmmt1, al
		jnz	short no_commt
		cmp	cs:cmmt, 2
		jnz	short skip_cmmt
		mov	al, es:[si+1]
		cmp	cs:cmmt2, al
		jnz	short no_commt

skip_cmmt:				; ...
		jcxz	short noget	; get out of organize routine.
		mov	al, es:[si]
		inc	si
		dec	cx
		cmp	al, 0Ah		; lf ; line feed ?
		jnz	short skip_cmmt

no_commt:				; ...
		retn
skip_comment	endp


; =============== S U B	R O U T	I N E =======================================


kbd_read	proc near		; ...
		test	ds:bDisableUI, 2 ; wait	for keystroke
		jnz	short kbd_nodelay ;
					; the bios timer tick count is incremented
					; 18.2 times per second;
					; watch	the timer tick count for 37 transitions
					; get initial value
		push	ds
		sub	ax, ax
		mov	ds, ax
		assume ds:nothing

kbd_loop:				; ...
		mov	ah, 1		; peek the keyboard
		int	16h		; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
					; Return: ZF clear if character	in buffer
					; AH = scan code, AL = character
					; ZF set if no character in buffer
		jnz	short kbd_loopdone
		mov	ah, 2
		int	16h		; KEYBOARD - GET SHIFT STATUS
					; AL = shift status bits
		test	al, 3		; either right or left shift key bits set?
		jnz	short kbd_loopdone
		mov	ax, ds:046Ch	; system timer,	lw
		sub	ax, cs:_timer_lw_ ; get	difference
		cmp	ax, 37		; reached limit? ; (2 seconds)
		jb	short kbd_loop

kbd_loopdone:				; ...
		pop	ds		; delay	complete!
		assume ds:nothing

kbd_nodelay:				; ...
		sub	bx, bx		; assume clean boot
		mov	ah, 2		; peek the shift states
		int	16h		; KEYBOARD - GET SHIFT STATUS
					; AL = shift status bits
		test	al, 3		; either right or left shift key bits set?
		jz	short kbd_notshift ; no
		inc	bx		; yes
		inc	bx
		or	ds:bQueryOpt, 4

kbd_notshift:				; ...
		mov	ah, 1		; peek the keyboard
		int	16h		; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
					; Return: ZF clear if character	in buffer
					; AH = scan code, AL = character
					; ZF set if no character in buffer
		jz	short kbd_test	; no key present
		or	al, al		; is it	a function key?
		jnz	short kbd_test	; no
		cmp	ah, 62h		; CTRL F5
		jz	short kbd_cfg_bypass
		cmp	ah, 3Fh		; F5 function key?
		jnz	short kbd_notf5	; no

kbd_cfg_bypass:				; ...
		mov	dx, offset _$CleanMsg ;	"MS-DOS	is bypassing your CONFIG.SYS and"...
		call	print
		or	ds:bQueryOpt, 4
		jmp	short kbd_eat	; yes, clean boot selected
; ---------------------------------------------------------------------------

kbd_notf5:				; ...
		cmp	ah, 65h		; CTRL F8
		jz	short kbd_cfg_confirm
		cmp	ah, 42h		; F8
		jnz	short kbd_exit

kbd_cfg_confirm:			; ...
		mov	dx, offset _$InterMsg ;	"MS-DOS	will prompt you	to confirm each	"...
		call	print
		mov	bl, 1		; yes, interactive-boot	option enabled
		mov	ds:bQueryOpt, bl ; change default setting

kbd_eat:				; ...
		mov	ah, 0		; eat the key we assumed was a signal
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character
		mov	ds:secElapsed, 0FFh ; -1
		or	bx, bx
		jz	short kbd_clean

kbd_test:				; ...
		cmp	bl, 2
		jb	short kbd_exit

kbd_clean:				; ...
		call	disable_autoexec ; yes,	tell COMMAND to	skip autoexec.bat
		stc			; set carry to indicate	abort
		retn
; ---------------------------------------------------------------------------

kbd_exit:				; ...
		clc			; clear	carry to indicate success
		retn
kbd_read	endp


; =============== S U B	R O U T	I N E =======================================


set_numlock	proc near		; ...
		push	ax		; set numlock LED
		push	ds
		sub	ax, ax
		mov	ds, ax
		assume ds:nothing
		mov	ax, es:[si]	; get 1st 2 bytes of value (ON or OF)
		cmp	ax, word ptr cs:OnOff2 ; "OFF"
		jnz	short not_off
		and	byte ptr ds:0417h, 0DFh	; ~20h ; turn it off
		jmp	short set_done
; ---------------------------------------------------------------------------

not_off:				; ...
		cmp	ax, word ptr cs:OnOff ;	"ON"
		stc
		jnz	short set_done
		or	byte ptr ds:0417h, 20h ; turn it on

set_done:				; ...
		pop	ds
		assume ds:nothing
		pop	ax
		retn
set_numlock	endp


; =============== S U B	R O U T	I N E =======================================


menu_check	proc near		; ...
		push	cx		; Search for SWITCHES,
					; determine if /N or /F	are present;
					; if so, then disable clean/interactive	boot options
		push	si
		sub	bx, bx		; remains ZERO until first block

swchk_loop:				; ...
		call	get_char	; get first char of current line
		jb	short swchk_end	; hit eof
		cmp	al, 5Bh	; '['
		jnz	short swchk_next1
		inc	bx		; remember that	we've seen a block
		jmp	short swchk_nextline
; ---------------------------------------------------------------------------

swchk_next1:				; ...
		cmp	al, 4Eh	; 'N'   ; CONFIG_NUMLOCK
		jnz	short swchk_next2
		or	bx, bx		; only do NUMLOCK commands that	exist
		jnz	short swchk_nextline ; before the first	block
		call	set_numlock	; REM it out so	we don't act on it later, too
		mov	byte ptr es:[si-1], 30h	; '0' ; CONFIG_REM
		jmp	short swchk_nextline
; ---------------------------------------------------------------------------

swchk_next2:				; ...
		cmp	al, 31h	; '1'   ; CONFIG_SWITCHES
		jnz	short swchk_nextline ; this line ain't it

swchk_scan:				; ...
		call	get_char	; look for /N or /F

swchk_scan1:				; ...
		cmp	al, 0Ah		; LF ; end of line ?
		jz	short swchk_nextline
		cmp	al, 2Fh	; '/'   ; switch-char?
		jnz	short swchk_scan ; no
		call	get_char
		and	al, 0DFh	; ~20h ; convert to upper case
		cmp	al, byte ptr ds:swit_n+1
		jnz	short swchk_scan2 ; no
		or	ds:bDisableUI, 1
		jmp	short swchk_scan ; continue looking for	switches of interest
; ---------------------------------------------------------------------------

swchk_scan2:				; ...
		cmp	al, byte ptr ds:swit_f+1
		jnz	short swchk_scan1 ; no
		or	ds:bDisableUI, 2
		jmp	short swchk_scan ; continue looking for	switches of interest
; ---------------------------------------------------------------------------

swchk_nextline:				; ...
		call	skip_opt_line
		jmp	short swchk_loop
; ---------------------------------------------------------------------------

swchk_end:				; ...
		pop	si
		pop	cx		;
					; Do the keyboard tests	for clean/interactive boot now,
					; but only if the DisableUI flag is still clear
		test	ds:bDisableUI, 1
		jnz	short menu_search ;
					; Wait for 2 seconds first,
					; UNLESS the /F	bit was	set in bDisableUI, or
					; there	is anything at all in the keyboard buffer
		call	kbd_read
		jnb	short menu_search
		jmp	menu_abort
; ---------------------------------------------------------------------------

menu_search:				; ...
		sub	bx, bx		; Search for MENU block;
					; it is	allowed	to be anywhere in config.sys
		mov	di, offset szMenu ; "MENU"
		call	find_block	; find the MENU	block
					; if no	MENU, default to zero for no_selection
		jnb	short menu_found
		mov	byte ptr ds:szBoot, 0 ;	"CONFIG="
		jmp	no_selection	; not found
; ---------------------------------------------------------------------------

menu_color:				; ...
		push	cx		; Process the requested	menu color(s)
		push	dx
		mov	dx, 7		; default color	setting
		call	get_number	; get first number
		and	bl, 0Fh		; first	# is foreground	color (for low nibble)
		mov	ch, bl		; save it in CH
		and	dl, 0F0h
		or	dl, bl
		call	delim		; did we hit a delimiter
		jnz	short check_color ; no,	all done
		call	get_number	; get next number
		and	bl, 0Fh		; second # is background color (for high nibble)
		mov	dh, bl		; save it in DH
		and	dl, 0Fh
		mov	cl, 4
		shl	bl, cl
		or	dl, bl

check_color:				; ...
		cmp	ch, dh		; are foreground/background the	same?
		jnz	short set_color	; no
		xor	dl, 8		; yes, so modify the fgnd intensity

set_color:				; ...
		mov	ds:bMenuColor, dl
		pop	dx
		pop	cx
		jmp	menu_nextitem
; ---------------------------------------------------------------------------

menu_found:				; ...
		mov	ds:bDefBlock, 1
		mov	ds:offDefBlock,	0
		mov	ds:secTimeOut, 0FFh ; -1
		and	ds:bQueryOpt, 0FDh ; ~2
		call	skip_opt_line	; skip to next line
		sub	dx, dx		; initialize total block count (0 => none yet)

menu_process:				; ...
		call	get_char	; get first char of current line
		jb	short to_menu_getdefault ; could happen	if menu	block at end (rare)
		and	al, 7Fh		; ~CONFIG_OPTION_QUERY
		cmp	al, 5Bh	; '['   ; CONFIG_BEGIN
		jz	short to_menu_getdefault ; BEGIN implies END
		cmp	al, 4Fh	; 'O'   ; CONFIG_SUBMENU
		jz	short menu_item	; go process sub-menu
		cmp	al, 45h	; 'E'   ; CONFIG_MENUITEM
		jz	short menu_item	; go process menu item
		cmp	al, 41h	; 'A'   ; CONFIG_MENUDEFAULT
		jz	short menu_default ; go	process	menu default
		cmp	al, 52h	; 'R'   ; CONFIG_MENUCOLOR
		jz	short menu_color ; go process menu color
		cmp	al, 4Eh	; 'N'   ; CONFIG_NUMLOCK
		jz	short menu_numlock
		cmp	al, 30h	; '0'   ; CONFIG_REM
		jz	short menu_nextitem ; allow remarks in menu block
		call	any_delim	; allow	blank lines and	such
		jz	short menu_nextitem
		stc
		call	print_error	; non-MENU command!
		jmp	short menu_nextitem
; ---------------------------------------------------------------------------

menu_numlock:				; ...
		call	set_numlock
		jmp	short menu_nextitem
; ---------------------------------------------------------------------------

to_menu_getdefault:			; ...
		jmp	short menu_getdefault
; ---------------------------------------------------------------------------

menu_default:				; ...
		mov	ds:offDefBlock,	si ; save address of default block name
		cmp	ds:secElapsed, 0
		jnz	short timeout_skip ; secElapsed	is only	zero for the FIRST menu,
		call	skip_token	; and for subsequent menus IF nothing was typed;
		jb	short menu_nextitem ; secElapsed becomes -1 forever as soon as
		call	skip_delim	; something is typed
		jb	short menu_nextitem
		mov	si, bx
		call	get_number	; get number (of seconds for timeout)
		cmp	bl, 90		; limit	it to a	reasonable number
		jb	short timeout_ok ; (besides, 99	is the largest # my simple
		mov	bl, 90		; display function can handle)

timeout_ok:				; ...
		mov	ds:secTimeOut, bl

timeout_skip:				; ...
		jmp	short menu_nextitem
; ---------------------------------------------------------------------------

menu_item:				; ...
		cmp	dl, 9		; MAX_MULTI_CONFIG
					; have we reached the max # of items yet?
		jnb	short menu_nextitem
		mov	di, si		; DS:DI	-> block name to search	for
		call	srch_block
		jz	short menu_itemfound ; srch_block, having succeeded,
					; returns DI ->	past the token that it just matched,
					; which	in this	case should be a descriptive string;
					; ES:SI	and CX are unmodified
		stc
		call	print_error	; print	error and pause
		jmp	short menu_nextitem ; if not found, ignore this	menu item
; ---------------------------------------------------------------------------

menu_itemfound:				; ...
		inc	dx		; otherwise, increment total block count
		mov	bx, dx		; and use it to	index the arrays of offsets
		mov	ds:abBlockType[bx], al
		add	bx, bx		; of recorded block names and descriptions
		mov	ds:aoffBlockName[bx], si ;
					; There	should be a description	immediately following
					; the block name on MENUITEM line; failing that,
					; we'll just use the block name as the description...
		mov	ds:aoffBlockDesc[bx], si
		mov	di, bx		; skip_delim modifies BX, so stash it in DI
		call	skip_token
		jb	short menu_nextitem ; hit eol/eof
		call	skip_delim
		jb	short menu_nextitem ; hit eol/eof
		xchg	bx, di
		mov	ds:aoffBlockDesc[bx], di

menu_nextitem:				; ...
		call	skip_opt_line
		jmp	menu_process	; go back for more lines
; ---------------------------------------------------------------------------

menu_getdefault:			; ...
		or	dl, dl		; Display menu items now,
					; after	determining which one is default
					;
					; where	there any valid	blocks at all?
		jnz	short menu_valid ; yes
		sub	bx, bx		; no, so force autoselect of 0
		jmp	menu_autoselect	; (meaning: process common blocks only)
; ---------------------------------------------------------------------------

menu_valid:				; ...
		sub	bx, bx
		mov	ds:bMaxBlock, dl ; first, record how many blocks we found
		mov	di, ds:offDefBlock
		or	di, di		;  does	a default block	exist?
		jz	short menu_nodefault ; no
		inc	bx		; yes, walk name table,	looking	for default

menu_chkdefault:			; ...
		push	bx
		add	bx, bx
		mov	si, ds:aoffBlockName[bx]
		mov	cx, 128		; arbitrary maximum length of a	name
		push	ds
		push	es
		pop	ds
		call	comp_names	; is this block	the same as the	default?
		pop	ds
		pop	bx
		jz	short menu_setdefault ;	yes
		inc	bx
		cmp	bl, ds:bMaxBlock ; all done searching?
		jbe	short menu_chkdefault ;	not yet

menu_nodefault:				; ...
		mov	bl, 1		; if no	default, force default to #1

menu_setdefault:			; ...
		mov	ds:bDefBlock, bl ; yes,	this will be the initial current block
					;
					; If the timeout was explicitly	set to 0 (or technically,
					; anything that	failed to resolve to a number, like "NONE"
					; or "EAT POTATOES"), then we're supposed to skip menu display
					; and run with the specified default block; however,
					; if the user hit Enter	prior to boot, thereby requesting fully
					; INTERACTIVE boot, then we shall display the menu block anyway
					; (though still	with no	timeout)
		cmp	ds:secTimeOut, 0 ; is timeout zero? (ie, assume	default)
		jnz	short menu_display ; no
		test	ds:bQueryOpt, 1	; yes, but was INTERACTIVE requested?
		jnz	short menu_display ; yes, so *don't* assume default after all
		jmp	not_topmenu
; ---------------------------------------------------------------------------

menu_display:				; ...
		mov	ah, 0Fh		; Reset	the mode,
					; so that we know screen is clean and cursor is	home
					; ;
		int	10h		; - VIDEO - GET	CURRENT	VIDEO MODE
					; Return: AH = number of columns on screen
					; AL = current video mode
					; BH = current active display page
		mov	ah, 0
		int	10h		; - VIDEO - SET	VIDEO MODE
					; AL = mode
		push	es
		mov	ax, 40h		; reach	down into the ROM BIOS data area
		mov	es, ax		; and save the current (default) video page
		assume es:nothing
		mov	ax, es:4Eh	; start	address	and page #, in case the
		mov	ds:wCRTStart, ax ; undocumented	QUIET option was enabled
		mov	al, es:62h
		mov	ds:bCRTPage, al
		mov	ax, word ptr ds:bMenuPage ; select new page for	menu
		int	10h		; - VIDEO -
		mov	ax, 600h	; clear	entire screen
		mov	bh, ds:bMenuColor ; using this color
		sub	cx, cx		; upper	left row/col
		mov	dl, es:4Ah	; [es:CRT_Cols]
		dec	dl
		mov	dh, es:84h	; [es:CRT_Rows]
		or	dh, dh		; # of rows valid?
		jnz	short menu_clear ; hopefully
		mov	dh, ds:bLastRow	; no, use a default

menu_clear:				; ...
		int	10h		; clear	the screen using the req. attribute
					;
					; - VIDEO - SCROLL PAGE	UP
					; AL = number of lines to scroll window	(0 = blank whole window)
					; BH = attributes to be	used on	blanked	lines
					; CH,CL	= row,column of	upper left corner of window to scroll
					; DH,DL	= row,column of	lower right corner of window
		pop	es
		assume es:nothing
		mov	ds:bLastRow, dh	; save DH
		mov	dx, offset _$MenuHeader	; "\r\n	 MS-DOS	6.2 Startup Menu\r\n"
		call	print		; cursor now on	row 3 (numbered	from 0)
		test	ds:bDisableUI, 1
		jnz	short menu_nostatus
		mov	bh, ds:bMenuPage
		mov	dh, ds:bLastRow	; restore DH
		mov	dl, 0		; print	the status line	on row DH, col 0
		mov	ah, 2		; now that we can trash	the cursor position
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		mov	dx, offset _$StatusLine	; "F5=Bypass startup files F8=Confirm each"...
		call	print
		mov	ah, 3		; get cursor position
		int	10h		; - VIDEO - READ CURSOR	POSITION
					; BH = page number
					; Return: DH,DL	= row,column, CH = cursor start	line, CL = cursor end line
		sub	dl, 2
		mov	ds:bLastCol, dl	; save column where status char	will go

menu_nostatus:				; ...
		mov	bx, 1		; now prepare to display all the menu items

menu_disploop:				; ...
		call	print_item	; print	item #BL
		inc	bx		; why "inc bx"?	because	it's a 1-byte opcode
		cmp	bl, ds:bMaxBlock ; all done?
		jbe	short menu_disploop ; not yet
		mov	dl, 0		; Set cursor position to just below the	menu items
					; column 0
		mov	dh, bl
		add	dh, 4		; select row below menu
		mov	bh, ds:bMenuPage
		mov	ah, 2		; set cursor position beneath the block	list
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		mov	dx, offset _$MenuPrmpt ; "  Enter a choice: $"
		call	print
		call	select_item	; make a selection, return # in	BX
		mov	dx, offset crlfm ; "\r\n$"
		call	print
		push	word ptr ds:bDisableUI
		or	ds:bDisableUI, 1
		call	show_status	; clear	the status line	now
		pop	word ptr ds:bDisableUI ;
					; Now begins the "re-organization" process...

menu_autoselect:			; ...
		cmp	bx, 0FFFFh	; -1 ; clean boot requested?
		jnz	short normal_boot ; no
		call	disable_autoexec

menu_abort:				; ...
		sub	cx, cx
		jmp	menu_exit
; ---------------------------------------------------------------------------

normal_boot:				; ...
		cmp	bx, 0FFFEh	; -2 ; back to top-level menu?
		jnz	short not_topmenu
		mov	cx, ds:count	; yes, start all over
		sub	si, si
		jmp	menu_search
; ---------------------------------------------------------------------------

not_topmenu:				; ...
		cmp	ds:abBlockType[bx], 4Fh	; CONFIG_SUBMENU
		jnz	short not_submenu
		add	bx, bx
		mov	di, ds:aoffBlockName[bx]
		call	srch_block	; THIS CANNOT FAIL!
		mov	si, di
		mov	cx, bx		; ES:SI	and CX are ready for another round
		jmp	menu_found
; ---------------------------------------------------------------------------

not_submenu:				; ...
		add	bx, bx		; get BX -> name of selected block
		mov	bx, ds:aoffBlockName[bx] ;
					; BX should now	either be ZERO
					; (meaning no block has	been selected) or the offset
					; relative to ES of the	block name to be processed
					; (along with all the "common" lines of	course)

no_selection:				; ...
		mov	ds:offDefBlock,	bx ; save selection
		mov	cx, ds:count	; reset	ES:SI and CX for reprocessing
		sub	si, si
		push	ds
		mov	ds, ds:config_wrkseg ; this is where we'll store new config.sys image
		sub	di, di		;
					; ES:SI-> config.sys, DS:DI -> new config.sys workspace
					;
					; Work our way through the config.sys image again, this	time copying
					; all lines that are (A) "common" lines	outside	any block or (B) lines
					; within the requested block. Lines inside INCLUDEd blocks are
					; transparently	copied by copy_block in	a recursive fashion;
					; the amount of	recursion is limited by	the fact INCLUDE statements are
					; REMed	by copy_block as they are processed and	by the number of unique
					; INCLUDE stmts	in config.sys...

copyblock_loop:				; ...
		push	bx		; save selected	block name
		call	copy_block	; process (named or common) block
		pop	bx
		jb	short move_config

copyblock_begin:			; ...
		push	ax		; copy_block can only return for two reasons:
					;  it hit eof or a new block
		push	cx
		push	si
		push	di		; always do "common" blocks
		mov	di, offset szCommon ; "COMMON"
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		call	comp_names
		pop	ds
		assume ds:nothing
		pop	di
		pop	si
		pop	cx
		pop	ax
		jz	short copyblock_check
		or	bx, bx		; is there a block name	to check?
		jz	short copyblock_skip ; no
		push	di
		mov	di, bx		; check	block against given block name
		push	ds
		push	es
		pop	ds
		call	comp_names	; is this the block we really want to do?
		pop	ds
		pop	di

copyblock_check:			; ...
		jb	short move_config ; hit	eof
		jnz	short copyblock_skip
		call	skip_opt_line
		jmp	short copyblock_loop
; ---------------------------------------------------------------------------

copyblock_skip:				; ...
		call	skip_opt_line	; this ain't the block we wanted, so skip it
		call	get_char
		jb	short move_config ; hit	eof
		and	al, 7Fh		; ~CONFIG_OPTION_QUERY
		cmp	al, 5Bh	; '['   ; CONFIG_BEGIN
		jz	short copyblock_begin
		jmp	short copyblock_skip ; anything	else is	just skipped
; ---------------------------------------------------------------------------

move_config:				; ...
		mov	cx, di		; To create as little risk to the rest of SysInit
					; as little as possible, and to	free the workspace
					; at "config_wrkseg" for creating an environment,
					; copy the new config.sys image	to "confbot".
					;
					; now copy workspace at	DS:DI to "confbot"
		push	cx		;
					; But first, copy the CONFIG=<configuration><0>	string
					; to the workspace, since the configuration name only
					; currently exists in the "confbot" area.
					; ;
		mov	cx, 7		; szMenu-szBoot-1
					; first	copy the CONFIG= part
		mov	si, offset szBoot ; "CONFIG="
		inc	di		; skip a byte, in case absolutely nothing
					; was copied to	the workspace, because we always
					; zero the first byte of the workspace (below)

copy_boot:				; ...
		lods	byte ptr cs:[si]
		mov	[di], al
		inc	di
		loop	copy_boot
		push	es		; then copy the	configuration name
		mov	cx, 121		; 128-7	; put an upper limit on	the name, to be	safe
		mov	si, cs:offDefBlock ; ES:SI -> default block name
		or	si, si		; valid?
		jnz	short l1	; yes
		push	cs
		pop	es
		assume es:SYSINIT
		mov	si, offset szCommon ; "COMMON"

l1:					; ...
		mov	al, es:[si]
		call	any_delim
		jz	short l2
		mov	[di], al
		inc	si
		inc	di
		loop	l1

l2:					; ...
		mov	byte ptr [di], 0Ah ; terminate the configuration string
		pop	es
		assume es:nothing
		sub	di, di		; Now we can copy "config_wrkseg" (DS) to "confbot" (ES)
		mov	cs:config_envlen, di
		sub	si, si
		pop	cx		; recover the size of "config_wrkseg"
		push	cx
		rep movsb		; moved!
		pop	cx
		mov	ax, ds
		pop	ds		; Now that the config_wrkseg is	available once again,
					; we shall use it to create an environment. The	first
					; thing	to go in will be the "CONFIG=configuration" thing.
					; It is	also important to zero the first byte of the workspace,
					; so that copy_envvar knows the	buffer is empty.
		push	es
		mov	es, ax
		inc	si		; ES:SI	-> "CONFIG=configuration"
		mov	byte ptr es:0, 0 ; empty the environment block
		call	copy_envvar	; copy envvar at ES:SI to "config_wrkseg"
		pop	es		;
					; Before returning, restore the	default	video page setting
					; but do NOT do	it using INT 10h's Set Active Page function,
					; because if the menu was displayed on a different page,
					; then it's because we don't want to see all the device
					; driver/TSR goop (which goes to the default page)
		cmp	ds:bMenuPage, 0
		jz	short menu_exit
		push	es
		mov	ax, 40h
		mov	es, ax
		assume es:nothing
		mov	ax, ds:wCRTStart
		mov	es:4Eh,	ax
		mov	al, ds:bCRTPage
		mov	es:62h,	al
		pop	es
		assume es:nothing

menu_exit:				; ...
		mov	ds:count, cx
		mov	ds:org_count, cx
		retn
menu_check	endp


; =============== S U B	R O U T	I N E =======================================


copy_envvar	proc near		; ...
		push	cx		; copy the envvar at ES:SI to "config_wrkseg"
					; ES:SI	-> environment variable
					;	   (in the form	"var=string<cr/lf>")
		push	si
		push	ds
		push	es
		push	es
		mov	es, ds:config_wrkseg ; ES:DI to	point to next available	byte
		pop	ds		; DS:SI	to point to envvar
		sub	cx, cx

copy_varlen:				; ...
		lodsb
		or	al, al		; NULL?
		stc
		jz	short copy_envexit ; yes, abort
		cmp	al, 0Dh		; cr
		stc
		jz	short copy_envexit
		cmp	al, 0Ah		; lf
		stc
		jz	short copy_envexit
		inc	cx
		cmp	al, 3Dh	; '='
		jnz	short copy_varlen
		mov	al, 0
		mov	ah, [si]	; save char after '='
		sub	si, cx		; back up to given varname
		dec	cx		; CX ==	# of bytes in varname
		sub	di, di		; start	looking	for DS:SI at ES:0

copy_varsrch:				; ...
		cmp	es:[di], al
		jz	short copy_envprep ; search failed, just copy var
		mov	bx, di		; ES:BX	-> start of this varname
		push	cx
		push	si
		repe cmpsb
		pop	si
		pop	cx
		jnz	short copy_varnext ; no	match, skip to next varname
		cmp	byte ptr es:[di], '='
		jnz	short copy_varnext ; no	match, there's more characters
					;
					; Previous occurrence of variable has been found;
					; determine the	entire length and then destroy it
		mov	cx, 0FFFFh	; -1
		repne scasb		; guaranteed to	get null (since	we put it there)
		push	si
		mov	si, di
		mov	di, bx
		mov	cx, cs:config_envlen
		sub	cx, si		; destroy variable now
		rep movs byte ptr es:[di], byte	ptr es:[si]
		pop	si

copy_envprep:				; ...
		cmp	ah, 0Dh		; if there is nothing after the	'='
		jz	short copy_envdel
		cmp	ah, 0Ah
		jz	short copy_envdel
		jmp	short copy_envloop
; ---------------------------------------------------------------------------

copy_varnext:				; ...
		push	cx
		mov	cx, 0FFFFh	; -1
		repne scasb
		pop	cx
		jmp	short copy_varsrch
; ---------------------------------------------------------------------------

copy_envloop:				; ...
		lodsb
		cmp	al, 0Dh		; cr
		jz	short copy_envdone
		cmp	al, 0Ah		; lf
		jz	short copy_envdone
		stosb
		jmp	short copy_envloop
; ---------------------------------------------------------------------------

copy_envdone:				; ...
		sub	al, al		; do SUB to clear carry	as well
		stosb			; always null-terminate	these puppies

copy_envdel:				; ...
		mov	es:[di], al	; and stick another null to terminate the env.
		mov	cs:config_envlen, di

copy_envexit:				; ...
		pop	es
		pop	ds
		pop	si
		pop	cx
		retn
copy_envvar	endp


; =============== S U B	R O U T	I N E =======================================


copy_block	proc near		; ...
		call	get_char	; copy the current block to the	new config.sys workspace
					;
					; CX ==	remaining bytes	in "organized" config.sys memory image
					; ES:SI	-> remaining bytes in "organized" config.sys memory image
					; DS:DI	-> new config.sys workspace (equal in size to the original
					;	 config.sys image) where the current block is to be copied
					;
					; check	for include
		jb	short copy_done
		and	al, 7Fh		; ~CONFIG_OPTION_QUERY
		cmp	al, 5Bh	; '['   ; CONFIG_BEGIN
					; another BEGIN	implies	END as well
		jz	short copy_done
		cmp	al, 4Ah	; 'J'   ; CONFIG_INCLUDE ; 'J'
		mov	al, ah		; AL ==	the original line code
		jnz	short copy_line	; not an "include" line
					;
					; We have hit an "INCLUDE" line; first,	REM out	the line
					; so that we never try to include the block again
					; (no infinite include loops please), then search for
					; the named block and call copy_block again.
		mov	byte ptr es:[si-1], 30h	; '0' ; CONFIG_REM
		push	di
		mov	di, offset szMenu ; "MENU"
		call	omp_names_safe	; don't allow INCLUDE MENU
		jz	short copy_skip
		mov	di, offset szCommon ; "COMMON"
		call	omp_names_safe	; don't allow INCLUDE COMMON
		jz	short copy_skip
		mov	di, si		; try to find the block
		call	srch_block
		mov	dx, di
		pop	di
		jnz	short copy_error ; no such block
		push	cx
		mov	cx, bx
		push	si
		dec	dx
		mov	si, dx
		call	skip_line	; skip the rest	of the "block name" line
		call	copy_block	; and copy in the rest of that block
		pop	si
		pop	cx
		sub	al, al		; force	skip_opt_line to skip...
		jmp	short copy_nextline
; ---------------------------------------------------------------------------

copy_skip:				; ...
		pop	di

copy_error:				; ...
		clc
		call	print_error	; note that carry is clear, no pause
		jmp	short copy_nextline
; ---------------------------------------------------------------------------

copy_line:				; ...
		mov	[di], al	; Copy the line	at ES:SI
					;  to the current location at DS:DI
		inc	di
		cmp	al, 20h	; ' '   ; is this is a "real" line with a "real" code?
		jb	short copy_nextline ; no
		cmp	cs:config_multi, 0
		jz	short copy_loop	; not a	multi-config config.sys, don't embed #s
		call	get_linenum	; BX ==	line # of line @ES:SI
		mov	[di], bx	; stash	it immediately following the line code
		inc	di
		inc	di
		jmp	short copy_next
; ---------------------------------------------------------------------------

copy_loop:				; ...
		call	get_char
		jb	short copy_done	; end of file
		mov	[di], al
		inc	di

copy_next:				; ...
		cmp	al, 0Ah		; lf ; done with line?
		jnz	short copy_loop	; nope

copy_nextline:				; ...
		call	skip_opt_line
		jmp	short copy_block
; ---------------------------------------------------------------------------

copy_done:				; ...
		retn
copy_block	endp


; =============== S U B	R O U T	I N E =======================================


get_linenum	proc near		; ...
		push	ax		; return line #	(in BX)	of current line	(@ES:SI)
		sub	bx, bx		; BX ==	line # (to be returned)
		push	cx
		mov	dx, si		; DX ==	the offset we're looking for
		push	si
		mov	cx, cs:count
		sub	si, si		; prepare to scan entire file

get_linenum_loop:			; ...
		call	skip_line
		jb	short get_linenum_done
		inc	bx
		cmp	si, dx		; have we exceeded the desired offset yet?
		jb	short get_linenum_loop ; no

get_linenum_done:			; ...
		pop	si
		pop	cx
		pop	ax
		retn
get_linenum	endp


; =============== S U B	R O U T	I N E =======================================


srch_block	proc near		; ...
		push	ax		; searches entire config.sys
					; for block name @ES:DI
		push	cx
		mov	cx, cs:count
		push	si
		sub	si, si
		push	ds
		push	es
		pop	ds
		call	find_block
		mov	di, si		; ES:DI	-> just	past the name in the block heading, if found
		mov	bx, cx		; BX ==	# bytes	remaining from that point, if found
		pop	ds
		pop	si
		pop	cx
		pop	ax
		retn
srch_block	endp


; =============== S U B	R O U T	I N E =======================================


find_block	proc near		; ...
		call	get_char	; searches rest	of config.sys for block	name @DS:DI
					; get line code
		jb	short find_exit	; end of file
		and	al, 7Fh		; ~CONFIG_OPTION_QUERY
		cmp	al, 5Bh	; '['   ; CONFIG_BEGIN ; beginning of a block?
		jz	short check_line ; no
		cmp	al, 4Ah	; 'J'   ; CONFIG_INCLUDE
		jnz	short next_line
		or	cs:config_multi, 1
		jmp	short next_line
; ---------------------------------------------------------------------------

check_line:				; ...
		or	cs:config_multi, 1
		call	comp_names	; compare block	names
		jbe	short find_exit	; end of file, or names	matched

next_line:				; ...
		call	skip_opt_line	; no, so skip to next line
		jmp	short find_block
; ---------------------------------------------------------------------------

find_exit:				; ...
		retn
find_block	endp


; =============== S U B	R O U T	I N E =======================================


comp_names	proc near		; ...
		push	di		; compares keyword @DS:DI
					;  to position in config.sys @ES:SI

comp_loop:				; ...
		call	get_char
		jb	short comp_exit
		call	any_delim	; is next character a delimiter?
		mov	ah, [di]	; (get next character we're supposed to match)
		jz	short comp_almost ; yes, it *could* be a match
		inc	di
		and	ax, 0DFDFh	; ~2020h
		cmp	al, ah		; match?
		jz	short comp_loop	; yes, keep looking at the characters
		clc			; prevent erroneous eof	indication: clear carry

comp_exit:				; ...
		pop	di
		retn
; ---------------------------------------------------------------------------

comp_almost:				; ...
		xchg	al, ah		; we don't know for sure if it's a match
		call	any_delim	; until	we verify that the second string
		xchg	al, ah		; has been exhausted also...
		jmp	short comp_exit	; if we	are, this call to any_delim will tell...
comp_names	endp


; =============== S U B	R O U T	I N E =======================================


omp_names_safe	proc near		; ...
		push	ax
		push	cx
		push	si
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		call	comp_names
		pop	ds
		assume ds:nothing
		pop	si
		pop	cx
		pop	ax
		retn
omp_names_safe	endp


; =============== S U B	R O U T	I N E =======================================


print_item	proc near		; ...
		push	ax		; display menu item #BL
		push	bx
		push	cx
		push	dx
		push	si
		mov	ah, 3		; get cursor position
		mov	bh, ds:bMenuPage ; always page zero
		int	10h		; - VIDEO - READ CURSOR	POSITION
					; BH = page number
					; Return: DH,DL	= row,column, CH = cursor start	line, CL = cursor end line
		push	dx
		mov	ah, 2		; set cursor position for correct row/col
		mov	dh, bl
		add	dh, 3
		mov	dl, 5
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		mov	al, bl
		add	al, 30h	; '0'   ; convert menu item # to ASCII digit
		mov	ah, ds:bMenuColor ; normal attribute
		cmp	bl, ds:bDefBlock ; are we printing the current block?
		jnz	short print_other
		or	ah, 70h		; yes, set bgnd	color to white
		mov	ch, ah
		mov	cl, 4
		rol	ch, cl
		cmp	ch, ah		; are fgnd/bgnd	the same?
		jnz	short print_other ; no
		xor	ah, 8		; yes, so modify the fgnd intensity

print_other:				; ...
		mov	bh, 0
		add	bx, bx
		mov	di, ds:aoffBlockDesc[bx]
		mov	bl, ah		; put the attribute in the correct register now
		mov	bh, ds:bMenuPage
		mov	ah, 9		; write	char/attr
		mov	cx, 1
		int	10h		; - VIDEO - WRITE ATTRIBUTES/CHARACTERS	AT CURSOR POSITION
					; AL = character, BH = display page
					; BL = attributes of character (alpha modes) or	color (graphics	modes)
					; CX = number of times to write	character
		inc	dl
		mov	ah, 2
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		mov	ax, 92Eh
		int	10h		; - VIDEO - WRITE ATTRIBUTES/CHARACTERS	AT CURSOR POSITION
					; AL = character, BH = display page
					; BL = attributes of character (alpha modes) or	color (graphics	modes)
					; CX = number of times to write	character
		inc	dl
		mov	ah, 2
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		mov	ax, 920h
		int	10h		; - VIDEO - WRITE ATTRIBUTES/CHARACTERS	AT CURSOR POSITION
					; AL = character, BH = display page
					; BL = attributes of character (alpha modes) or	color (graphics	modes)
					; CX = number of times to write	character
		inc	dl
		mov	ah, 2
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		push	es

print_loop:				; ...
		mov	al, es:[di]	; get a	character of the description
		inc	di
		cmp	al, 9		; TAB ;	substitute spaces for tabs
		jnz	short print_montab
		mov	al, 20h	; ' '

print_montab:				; ...
		cmp	al, 20h	; ' '
		jb	short print_done ; stop	at the 1st character < space
		cmp	al, 24h	; '$'
		jz	short print_done ; also	stop on	$
		mov	ah, 9
		int	10h		; - VIDEO - WRITE ATTRIBUTES/CHARACTERS	AT CURSOR POSITION
					; AL = character, BH = display page
					; BL = attributes of character (alpha modes) or	color (graphics	modes)
					; CX = number of times to write	character
		inc	dl		; increment column
		cmp	dl, 78		; far enough?
		jnb	short print_done ; yes
		mov	ah, 2
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		jmp	short print_loop
; ---------------------------------------------------------------------------

print_done:				; ...
		pop	es
		pop	dx
		mov	ah, 2		; restore previous row/col
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
print_item	endp


; =============== S U B	R O U T	I N E =======================================


select_item	proc near		; ...
		mov	bl, ds:bDefBlock ; wait	for user to select menu	item, with time-out
					;
					; returns digit	value in BX (trashes AX/CX/DX)
		mov	al, bl		; BL will be the default block #
		call	disp_num
		call	show_status	; display current interactive status
		cmp	ds:secTimeOut, 0FFh ; -1
		jz	short input_key	; no time-out, just go to input
		mov	ah, 2Ch		; GET_TIME
		int	21h		; DOS -	GET CURRENT TIME
					; Return: CH = hours, CL = minutes, DH = seconds
					; DL = hundredths of seconds
					; ;
		mov	bh, dh		; BH = initial # of seconds

check_time:				; ...
		mov	al, ds:secTimeOut
		sub	al, ds:secElapsed
		jnb	short show_time
		or	ds:bQueryOpt, 2	; disable all further prompting
		mov	ds:secElapsed, 0
		jmp	select_done	; time's up!
; ---------------------------------------------------------------------------

show_time:				; ...
		push	bx
		mov	bl, al		; save # in BL
		mov	bh, ds:bMenuPage
		mov	ah, 3
		int	10h		; - VIDEO - READ CURSOR	POSITION
					; BH = page number
					; Return: DH,DL	= row,column, CH = cursor start	line, CL = cursor end line
		push	dx
		add	dl, 8		; move cursor to the right
		mov	ah, 2
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		mov	dx, offset _$TimeOut ; "Time remaining:	$"
		call	print		; print	the "Time remaining: " prompt
		mov	al, bl		; recover # from BL
		cbw			; this works because AL	is always <= 90
		mov	cl, 10
		div	cl		; AL = tens digit, AH =	ones digit
		mov	cl, ah
		add	al, '0'         ; write TTY tens digit
		mov	ah, 0Eh
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		mov	al, cl
		add	al, '0'         ; write TTY ones digit
		mov	ah, 0Eh
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		pop	dx
		mov	ah, 2		; set cursor position back to where it was
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		pop	bx

input_key:				; ...
		mov	ah, 6		; RAW_CON_IO
		mov	dl, 0FFh	; input	request
		int	21h		; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
					; DL = character <> FFh
					;  Return: ZF set = no character
					;   ZF clear = character recieved, AL =	character
		jnz	short got_key
		cmp	ds:secTimeOut, 0FFh ; -1 ; is there a time-out?
		jz	short input_key	; no, just go back to input
		mov	ah, 2Ch		; GET_TIME
		int	21h		; DOS -	GET CURRENT TIME
					; Return: CH = hours, CL = minutes, DH = seconds
					; DL = hundredths of seconds
		mov	ah, dh
		sub	dh, bh		; should generally be zero or one
		mov	bh, ah
		jnb	short got_time
		mov	dh, 1		; it wrapped back to zero, so assume one

got_time:				; ...
		or	dh, dh		; any change?
		jz	short input_key	; no
		add	ds:secElapsed, dh
		jmp	short check_time
; ---------------------------------------------------------------------------

got_key:				; ...
		push	ax
		mov	ax, 0FFFFh	; -1 ; zap both	secTimeOut and secElapsed
		xchg	ax, word ptr ds:secTimeOut
		cmp	al, 0FFh	; -1 ; was time-out already disabled?
		jz	short timeout_disabled ; yes
		push	bx		; let's disable # seconds display
		mov	ax, 0A20h	; write	multiple spaces
		mov	bx, word ptr ds:bMenuColor
		mov	cx, 80		; 80 of	them, to be safe
					; to completely	obliterate # seconds display
		int	10h		; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
					; AL = character, BH = display page - alpha mode
					; BL = color of	character (graphics mode, PCjr only)
					; CX = number of times to write	character
		pop	bx

timeout_disabled:			; ...
		pop	ax
		or	al, al		; extended key pressed?
		jnz	short normal_key ; no
		int	21h		; get the next part of the key then
		jz	short input_key	; what happened	to the second part!?
		cmp	al, 48h		; up arrow?
		jnz	short not_up	; no
		cmp	bl, 1		; are we as up as up can get?
		jbe	short input_key	; yes, ignore it
		dec	ds:bDefBlock
		call	print_item	; re-print the current item
		dec	bl		; and then print the new current item
		jmp	short print1
; ---------------------------------------------------------------------------

not_up:					; ...
		cmp	al, 50h	; 'P'   ; down arrow?
		jnz	short not_down	; no
		cmp	bl, ds:bMaxBlock ; are we as down as down can get?
		jnb	short to_input_key ; yes, ignore it
		inc	ds:bDefBlock
		call	print_item	; re-print the current item
		inc	bx		; and then print the new current item

print1:					; ...
		mov	al, bl

print2:					; ...
		call	print_item
		call	disp_num

to_input_key:				; ...
		jmp	short input_key
; ---------------------------------------------------------------------------

not_down:				; ...
		test	ds:bDisableUI, 1
		jnz	short to_input_key ; don't allow F8 or F5
		cmp	al, 42h		; F8 function key?
		jnz	short not_f8	; no
		xor	ds:bQueryOpt, 1
		call	show_status
		jmp	input_key
; ---------------------------------------------------------------------------

not_f8:					; ...
		cmp	al, 3Fh		; F5 function key?
		jnz	short to_input_key ; no
		or	ds:bQueryOpt, 4	; no more queries
		mov	bx, 0FFFFh	; special return code (-1) indicating clean boot
		mov	al, 20h	; ' '   ; don't want to display anything really;
		jmp	short disp_input
; ---------------------------------------------------------------------------

normal_key:				; ...
		cmp	al, 0Dh		; Enter?
		jz	short select_done ; yes
		cmp	al, 8		; backspace?
		jnz	short not_backspace ; no
		mov	bx, 0FFFEh	; -2 ; yes, special return code
		retn
; ---------------------------------------------------------------------------

not_backspace:				; ...
		sub	al, 30h	; '0'   ; is greater than '0'?
		jbe	short to_input_key ; no
		cmp	al, ds:bMaxBlock ; is less than	or equal to the	maximum	digit?
		ja	short to_input_key ; no
		mov	ds:bDefBlock, al
		call	print_item	; redisplay the	current	selection
		mov	bl, al		; set new selection
		jmp	short print2
; ---------------------------------------------------------------------------

select_done:				; ...
		mov	bh, 0		; return a full	16-bit value (for indexing)
		mov	al, bl
		add	al, 30h	; '0'   ; convert it into a digit, then display it
select_item	endp


; =============== S U B	R O U T	I N E =======================================


disp_input	proc near		; ...
		push	ax		; display a single character + cr/lf
		cmp	al, 20h	; ' '
		jnb	short disp_ok
		mov	al, 20h	; ' '

disp_ok:				; ...
		mov	dl, al
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		mov	dx, offset crlfm ; "\r\n$"
		call	print
		pop	ax
		retn
disp_input	endp


; =============== S U B	R O U T	I N E =======================================


disp_num	proc near		; ...
		push	bx
		add	al, '0'
		mov	ah, 0Ah
		mov	bx, word ptr ds:bMenuColor
		mov	cx, 1
		int	10h		; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
					; AL = character, BH = display page - alpha mode
					; BL = color of	character (graphics mode, PCjr only)
					; CX = number of times to write	character
		pop	bx
		retn
disp_num	endp


; =============== S U B	R O U T	I N E =======================================


show_status	proc near		; ...
		push	bx		; display current interactive mode setting (on/off/none)
		mov	bx, word ptr ds:bMenuColor
		mov	ah, 3
		int	10h		; - VIDEO - READ CURSOR	POSITION
					; BH = page number
					; Return: DH,DL	= row,column, CH = cursor start	line, CL = cursor end line
		push	dx
		mov	ah, 2
		mov	dx, word ptr ds:bLastCol ; set correct row/col
		test	ds:bDisableUI, 1
		jz	short show_onoff ; just	show on/off
		mov	dl, 0
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		mov	ax, 0A20h	; write	multiple spaces
		mov	cx, 80		; 80 of	them, to be exact to obliterate	the status line
		int	10h		; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
					; AL = character, BH = display page - alpha mode
					; BL = color of	character (graphics mode, PCjr only)
					; CX = number of times to write	character
		jmp	short show_done
; ---------------------------------------------------------------------------

show_onoff:				; ...
		int	10h		; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
					; AL = character, BH = display page - alpha mode
					; BL = color of	character (graphics mode, PCjr only)
					; CX = number of times to write	character
		mov	al, byte ptr ds:_$NO ; "NO $"
		cmp	ds:bQueryOpt, 1	; is interactive mode on?
		jnz	short show_noton ; no
		mov	al, byte ptr ds:_$YES ;	"YES$"

show_noton:				; ...
		mov	ah, 0Eh
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)

show_done:				; ...
		pop	dx		; restore original cursor position
		mov	ah, 2
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		pop	bx
		retn
show_status	endp


; =============== S U B	R O U T	I N E =======================================


skip_token	proc near		; ...
		call	get_char	; advances ES:SI/CX past the current token
		jb	short skip_token_done
		call	any_delim
		jnz	short skip_token

skip_check_eol:				; ...
		cmp	al, 0Dh		; CR
		jz	short skip_token_eol
		cmp	al, 0Ah		; LF
		jz	short skip_token_eol
		clc
		jmp	short skip_token_done
; ---------------------------------------------------------------------------

skip_token_eol:				; ...
		stc

skip_token_done:			; ...
		retn
skip_token	endp


; =============== S U B	R O U T	I N E =======================================


skip_delim	proc near		; ...
		call	get_char	; advances ES:SI/CX past the current delimiter
		lea	bx, [si-1]
		jb	short skip_token_done
		call	delim
		jz	short skip_delim
		jmp	short skip_check_eol
skip_delim	endp


; =============== S U B	R O U T	I N E =======================================


skip_opt_line	proc near		; ...
		cmp	al, 0Ah		; LF
		jz	short skip_line_done
skip_opt_line	endp


; =============== S U B	R O U T	I N E =======================================


skip_line	proc near		; ...
		call	get_char
		jb	short skip_line_done
		cmp	al, 0Ah		; LF
		jnz	short skip_line

skip_line_done:				; ...
		retn
skip_line	endp


; =============== S U B	R O U T	I N E =======================================


get_number	proc near		; ...
		sub	bx, bx		; return binary	equivalent of numeric string
					; BX = result

num_loop:				; ...
		call	get_char
		jb	short num_done
		cmp	al, 30h	; '0'   ; convert to value
		jb	short num_done	; no more number
		cmp	al, 39h	; '9'
		ja	short num_done
		push	ax
		mov	ax, 10
		push	dx
		mul	bx
		pop	dx
		mov	bx, ax
		pop	ax
		sub	al, 30h	; '0'
		cbw
		add	bx, ax
		jmp	short num_loop
; ---------------------------------------------------------------------------

num_done:				; ...
		retn
get_number	endp


; =============== S U B	R O U T	I N E =======================================


get_char	proc near		; ...
		sub	cx, 1		; return next character,
					; advance ES:SI, and decrement CX
					; (use SUB to set carry,zero)
		jb	short get_fail
		lods	byte ptr es:[si] ; es
					; lodsb
		mov	ah, al
		retn
; ---------------------------------------------------------------------------

get_fail:				; ...
		mov	cx, 0		; restore CX to	zero
					; leave	carry set, zero	not set

nearby_ret:				; ...
		retn
get_char	endp


; =============== S U B	R O U T	I N E =======================================


query_user	proc near		; ...
		test	ds:bQueryOpt, 4	; ask user whether to execute current config.sys command
					; answer no to everything?
		jz	short qu_1	; no
		jmp	skip_all	; yes
; ---------------------------------------------------------------------------

qu_1:					; ...
		test	ds:bQueryOpt, 2	; answer yes to	everything?
		jnz	short nearby_ret ; yes (and return carry clear!)
		push	ax
		mov	al, ds:config_cmd
		test	ds:bQueryOpt, 1	; query	every command?
		jnz	short query_all	; yes
		test	al, 80h		; CONFIG_OPTION_QUERY
		jnz	short query_all
		jmp	do_cmd
; ---------------------------------------------------------------------------

query_all:				; ...
		push	si		; save pointer to rest of CONFIG.SYS line
		mov	dx, offset _$AutoPrmpt ; "Process AUTOEXEC.BAT [Y,N]?$"
		and	al, 7Fh		; ~CONFIG_OPTION_QUERY
		jz	short generic_prompt ; config_cmd must have been 0
		mov	dh, al		; save config_cmd in DH
		sub	bx, bx		; 0
		mov	di, offset comtab ; "\x01[["

find_match:				; ...
		mov	bl, [di]	; get size of current keyword
		or	bl, bl
		jz	short line_print ; end of table
		inc	di
		cmp	al, [bx+di]	; match?
		jz	short cmd_match	; yes
		lea	di, [bx+di+1]	; otherwise, skip this command code
		jmp	short find_match ; loop
; ---------------------------------------------------------------------------

cmd_match:				; ...
		mov	cl, [di-1]
		mov	ch, 0
		mov	ah, 2		; STD_CON_OUTPUT

cmd_print:				; ...
		mov	al, [di]
		inc	di
		mov	dl, al
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		loop	cmd_print
		mov	dl, '='
		cmp	dh, 'V'         ; CONFIG_SET
		jnz	short cmd_notset
		mov	dl, 20h	; ' '   ; for SET commands, don't display a '='

cmd_notset:				; ...
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output

line_print:				; ...
		lods	byte ptr es:[si]
		or	al, al
		jnz	short non_null
		mov	al, 20h	; ' '

non_null:				; ...
		cmp	al, 20h	; ' '   ; control code?
		jb	short prompt_user ; yes, assume	end of line
		jnz	short non_space
		cmp	byte ptr es:[si], 20h ;	' '
		jb	short prompt_user

non_space:				; ...
		mov	dl, al
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		jmp	short line_print
; ---------------------------------------------------------------------------

prompt_user:				; ...
		mov	dx, offset _$InterPrmpt	; " [Y,N]?$"

generic_prompt:				; ...
		call	print

input_loop:				; ...
		mov	ah, 0
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character
		or	al, al		; is it	a function key?
		jnz	short not_func	; no
		cmp	ah, 3Fh		; F5 function key?
		jnz	short input_loop ; no
		mov	al, ds:57CEh
		or	ds:bQueryOpt, 4	; no more queries
		jmp	short legal_char
; ---------------------------------------------------------------------------

not_func:				; ...
		and	al, 0DFh	; ~20h ; converting to upper case
					; converting to	upper case
					; verify character is legal
		cmp	al, byte ptr ds:_$NO ; "NO $"
		jz	short legal_char
		cmp	al, byte ptr ds:_$YES ;	"YES$"
		jz	short legal_char
		cmp	ds:config_cmd, 0
		jz	short input_loop ; don't allow Esc on this query
		cmp	al, 1Bh		; Esc?
		jnz	short input_loop
		or	ds:bQueryOpt, 2	; no more interactive boot prompts
		mov	al, byte ptr ds:_$YES ;	"YES$"

legal_char:				; ...
		call	disp_input
		pop	si		; restore pointer to rest of CONFIG.SYS	line
					; process line?
		cmp	al, byte ptr ds:_$NO ; "NO $"
		jz	short skip_cmd	; no

do_cmd:					; ...
		pop	ax
		clc			; just do the command
		retn
; ---------------------------------------------------------------------------

skip_cmd:				; ...
		pop	ax

skip_all:				; ...
		mov	ah, 30h	; '0'   ; CONFIG_REM ; fake out the rest of sysinit's processing
		stc
		retn
query_user	endp


; =============== S U B	R O U T	I N E =======================================


print_error	proc near		; ...
		push	ax		; displays multi-config	error conditions
		push	bx
		push	cx
		push	dx
		push	ds
		push	cs
		pop	ds
		assume ds:SYSINIT
		pushf
		call	get_linenum
		mov	linecount, bx
		call	error_line
		popf
		jnb	short pe_ret
		mov	dx, offset _$PauseMsg ;	"Press any key to continue . . .\r\n$"
		call	print
		mov	ax, 0C07h	; flush	input buffer, then wait	for key
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		or	al, al		; extended key?
		jnz	short pe_1	; no
		mov	ah, 7		; yes, eat it too
		int	21h		; DOS -	DIRECT STDIN INPUT, NO ECHO

pe_1:					; ...
		mov	dx, offset crlfm ; "\r\n$"
		call	print

pe_ret:					; ...
		pop	ds
		assume ds:nothing
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
print_error	endp


; =============== S U B	R O U T	I N E =======================================


disable_autoexec proc near		; ...
		test	ds:bQueryOpt, 4	; This function	is very	simple:
					; it merely prepends a "/D" to the command-line	for the	shell;
					; this (undocumented) switch disables AUTOEXEC.BAT processing
					; and the date/time prompt that	is usually displayed
					; when there's no AUTOEXEC.BAT.
		jz	short disable_exit
		test	ds:dae_flag, 1
		jnz	short disable_exit
		or	ds:dae_flag, 1
		or	word ptr ds:bQueryOpt, 102h ; [bDefBlock] = 1
		mov	dx, ' D'        ; 2044h ; 'D ' (NASM syntax)

dae_1:					; ...
		mov	al, ds:def_swchr ; get default switchchar
		or	al, al
		jz	short disable_exit
		mov	bl, byte ptr ds:command_line ; "\x02/P"
		mov	bh, 0		; BX ==	command-line length
		mov	cx, bx
		add	bl, 3
		cmp	bl, 126
		ja	short disable_exit ;
					; update length
		mov	byte ptr ds:command_line, bl ; "\x02/P"
		add	bx, (offset command_line+1) ;
					; make sure we move the	NULL too
		inc	cx		; (just	for consistency	sake)

disable_loop:				; ...
		mov	ah, [bx-3]
		mov	[bx], ah
		dec	bx
		loop	disable_loop
		mov	[bx-2],	al
		mov	[bx-1],	dx	; 'D ' ; /D is stuffed into place now

disable_exit:				; ...
		retn
disable_autoexec endp


; =============== S U B	R O U T	I N E =======================================


CheckQueryOpt	proc near		; ...
		cmp	ds:bQueryOpt, 1
		jnz	short disable_exit
		test	ds:dae_flag, 2
		jnz	short disable_exit
		or	ds:dae_flag, 2
		mov	dx, ' Y'        ; 'Y ' ; 2059h
		jmp	short dae_1
CheckQueryOpt	endp


; =============== S U B	R O U T	I N E =======================================


any_delim	proc near		; ...
		cmp	al, 0Dh		; cr
		jz	short delim_ret
		cmp	al, 0Ah		; lf
		jz	short delim_ret
		cmp	al, '['
		jz	short delim_ret
		cmp	al, ']'
		jz	short delim_ret
any_delim	endp


; =============== S U B	R O U T	I N E =======================================


delim		proc near		; ...
		cmp	al, '/'         ; ibm will assume "/" as an delimeter
		jz	short delim_ret
		cmp	al, 0		; special case for sysinit!
		jz	short delim_ret

org_delim:				; ...
		cmp	al, 20h	; ' '   ; space
		jz	short delim_ret
		cmp	al, 9		; tab
		jz	short delim_ret
		cmp	al, '='
		jz	short delim_ret
		cmp	al, ','
		jz	short delim_ret
		cmp	al, ';'
		clc

delim_ret:				; ...
		retn
delim		endp


; =============== S U B	R O U T	I N E =======================================


newline		proc near		; ...
		call	getchr
		jb	short nl_ret	; no char
		cmp	al, 0Ah		; lf
		jnz	short newline
		call	getchr

nl_ret:					; ...
		retn			; al = first character of next line (if	cf=0)
newline		endp


; =============== S U B	R O U T	I N E =======================================


mapcase		proc near		; ...
		push	cx
		push	si
		push	ds
		push	es
		pop	ds
		mov	bl, al

convloop:				; ...
		lodsb
		cmp	al, 'a'
		jb	short noconv
		cmp	al, 'z'
		ja	short noconv
		sub	al, 20h		; convert to upper-case	(and al,0DFh)
		mov	[si-1],	al

noconv:					; ...
		cmp	bl, 'V'         ; CONFIG_SET ; preserve case for part of the line?
		jnz	short check_eol	; no, just check for end-of-line
		cmp	al, '='         ; separator between SET var and value?
		jz	short convdone	; yes
					; (we don't want to upper-case
					; anything after the "=" in a SET)

check_eol:				; ...
		cmp	al, 0Dh		; cr
		jz	short convdone
		cmp	al, 0Ah		; lf
		jz	short convdone
		loop	convloop

convdone:				; ...
		pop	ds
		pop	si
		pop	cx
		retn
mapcase		endp


; =============== S U B	R O U T	I N E =======================================


round		proc near		; ...
		push	ax		; round	the values in memlo and	memhi
					; to paragraph boundary.
					; perform bounds check.
		mov	ax, cs:memlo
		call	ParaRound	; para round up
		add	cs:memhi, ax
		mov	cs:memlo, 0
		mov	ax, cs:memhi	; ax = new memhi
		cmp	ax, cs:ALLOCLIM	; if new memhi >= alloclim, error
		jnb	short mem_err
		test	cs:setdevmarkflag, 2 ; for_devmark
		jz	short skip_set_devmarksize
		push	es
		push	si
		mov	si, cs:devmark_addr
		mov	es, si
		sub	ax, si
		dec	ax
		mov	es:3, ax	; mov [es:devmark.size],ax ; paragraph
		and	cs:setdevmarkflag, 0FDh	; ~2 ; not 2
					; not_for_devmark
		pop	si
		pop	es

skip_set_devmarksize:			; ...
		pop	ax
		clc
		retn
; ---------------------------------------------------------------------------

mem_err:				; ...
		mov	dx, offset badmem ; "\r\nConfiguration too large for memory\"...
		push	cs
		pop	ds
		assume ds:SYSINIT
		call	print
		jmp	stall
round		endp


; =============== S U B	R O U T	I N E =======================================


calldev		proc near		; ...
		mov	ds, word ptr cs:DevEntry+2
		assume ds:nothing
		add	bx, word ptr cs:DevEntry ; do a	little relocation
		mov	ax, [bx]
		push	word ptr cs:DevEntry
		mov	word ptr cs:DevEntry, ax
		mov	bx, 36Ah
		call	cs:DevEntry
		pop	word ptr cs:DevEntry
		retn
calldev		endp


; =============== S U B	R O U T	I N E =======================================


todigit		proc near		; ...
		sub	al, '0'
		jb	short notdig
		cmp	al, 9
		ja	short notdig
		clc
		retn
; ---------------------------------------------------------------------------

notdig:					; ...
		stc
		retn
todigit		endp


; =============== S U B	R O U T	I N E =======================================


getnum		proc near		; ...
		push	bx		; getnum parses	a decimal number.
					; returns it in	ax, sets zero flag if ax = 0
					; (may be considered an	error),
					; if number is bad carry is set, zero is set, ax=0.
					; ;;
		xor	bx, bx		; running count	is zero

b2:					; ...
		call	todigit		; do we	have a digit ?
		jb	short badnum	; no, bomb
		xchg	ax, bx		; put total in ax
		push	bx		; save digit (0	to 9)
		mov	bx, 10		; base of arithmetic
		mul	bx		; shift	by one decimal digit
		pop	bx		; get back digit (0 to 9)
		add	al, bl		; get total
		adc	ah, 0		; make that 16 bits
		jb	short badnum	; too big a number
		xchg	ax, bx		; stash	total
		call	getchr		; get next digit
		jb	short b1	; no more characters
		cmp	al, ' '         ; space?
		jz	short b15	; then end of digits
		cmp	al, ','         ; ',' is a seperator!!!
		jz	short b15	; then end of digits.
		cmp	al, 9		; tab
		jz	short b15
		cmp	al, cs:sepchr	; allow	0 or special separators
		jz	short b15
		cmp	al, '/'         ; see if another switch follows
		nop			; cas -	remnant	of old bad code
		nop			; (04/08/2023 -	Erdogan	Tan - 'nop,nop' is not neded)
		jz	short b15
		cmp	al, 0Ah		; lf ; line-feed?
		jz	short b15
		cmp	al, 0Dh		; cr ; carriage	return?
		jz	short b15
		or	al, al		; end of line separator?
		jnz	short b2	; no, try as a valid char...

b15:					; ...
		inc	cs:count	; one more character to	s...
		dec	cs:chrptr	; clears carry,	sets zero accordingly

b1:					; ...
		mov	ax, bx
		or	ax, ax
		pop	bx
		retn
; ---------------------------------------------------------------------------

badnum:					; ...
		mov	cs:sepchr, 0
		xor	ax, ax		; set zero flag, and ax	= 0
		pop	bx
		stc			; and carry set
		retn
getnum		endp


; =============== S U B	R O U T	I N E =======================================


setdoscountryinfo proc near		; ...
		push	di		; input:
					;   es:di -> pointer to	dos_country_cdpg_info
					;   ds:0  -> buffer.
					;      si = 0
					;      ax = country id
					;      dx = code page id. (if 0, then use ccsyscodepage	as a default.)
					;      bx = file handle
					;   this routine can handle maximum 438	country_data entries.
					; output:
					;   dos_country_cdpg_info set.
					;   carry set if any file read failure or wrong	information in the file.
					;   carry set and cx = -1 if cannot find the matching country_id,
					;	  codepage_id in the file.
		push	ax
		push	dx
		xor	cx, cx
		xor	dx, dx
		mov	ax, 512		; read 512 bytes
		call	readincontrolbuffer ; read the file header
		jb	short setdosdata_fail
		push	es
		push	si
		push	cs
		pop	es
		assume es:SYSINIT
		mov	di, offset country_file_signature ; db 0FFh,'COUNTRY'
		mov	cx, 8		; length of the	signature
		repe cmpsb
		pop	si
		pop	es
		assume es:nothing
		jnz	short setdosdata_fail ;	signature mismatch
		add	si, 18
		cmp	byte ptr [si], 1 ; si -> county	info type
					; only accept type 1 (currently	only 1 header type)
		jnz	short setdosdata_fail ;	cannot proceed.	error return
		inc	si		; si ->	file offset
		mov	dx, [si]	; get the info file offset.
		mov	cx, [si+2]
		mov	ax, 6144	; read 6144 bytes.
		call	readincontrolbuffer ; read info
		jb	short setdosdata_fail
		mov	cx, [si]	; get the # of country,	codepage combination entries
		cmp	cx, 438		; cannot handle	more than 438 entries.
		ja	short setdosdata_fail
		inc	si
		inc	si		; si ->	entry information packet
		pop	dx		; restore code page id
		pop	ax		; restore country id
		pop	di		; search for desired country_id,codepage_id.

setdoscntry_find:			; ...
		cmp	ax, [si+2]	; compare country_id
		jnz	short setdoscntry_next
		cmp	dx, 0		; no user specified code page ?
		jz	short setdoscntry_any_codepage ; then no need to match code page id.
		cmp	dx, [si+4]	; compare code page id
		jz	short setdoscntry_got_it

setdoscntry_next:			; ...
		add	si, [si]	; next entry
		inc	si
		inc	si		; take a word for size of entry	itself
		loop	setdoscntry_find
		mov	cx, 0FFFFh	; -1 ; signals that bad	country	id entered.

setdoscntry_fail:			; ...
		stc
		retn
; ---------------------------------------------------------------------------

setdosdata_fail:			; ...
		pop	si
		pop	cx
		pop	di
		jmp	short setdoscntry_fail
; ---------------------------------------------------------------------------

setdoscntry_any_codepage:		; ...
		mov	dx, [si+4]	; use the code_page_id of the country_id found.

setdoscntry_got_it:			; ...
		mov	cs:cntrycodepage_id, dx	; save code page id for	this country.
		mov	dx, [si+10]	; get the file offset of country data
		mov	cx, [si+12]
		mov	ax, 512		; read 512 bytes
		call	readincontrolbuffer
		jb	short setdoscntry_fail
		mov	cx, [si]	; get the number of entries to handle.
		inc	si
		inc	si		; si ->	first entry

setdoscntry_data:			; ...
		push	di		; es:di	-> dos_country_cdpg_info
		push	cx		; save # of entry left
		push	si		; si ->	current	entry in control buffer
		mov	al, [si+2]	; get data entry id
		call	getcountrydestination ;	get the	address	of destination in es:di
		jb	short setdoscntry_data_next ; no matching data entry id	in dos
		mov	dx, [si+4]	; get offset of	data
		mov	cx, [si+6]
		mov	ax, 4200h
		stc
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jb	short setdosdata_fail ;
					; read the country.sys data
		mov	dx, 512		; start	of data	buffer
		mov	cx, 20		; read 20 bytes	only. we only need to
		mov	ah, 3Fh		; look at the length of	the data in the	file.
		stc
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jb	short setdosdata_fail ;	read failure
		cmp	ax, cx
		jnz	short setdosdata_fail
		mov	dx, [si+4]	; get offset of	data again.
		mov	cx, [si+6]
		mov	ax, 4200h	; move pointer back again
		stc
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jb	short setdosdata_fail
		push	si
		mov	si, 520		; (512+8) ; get	length of the data from	the file
		mov	cx, [si]
		pop	si
		mov	dx, 512		; start	of data	buffer
		add	cx, 10		; signature + a	word for the length itself
		mov	ah, 3Fh		; read the data	from the file.
		stc
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jb	short setdosdata_fail
		cmp	ax, cx
		jnz	short setdosdata_fail
		mov	al, [si+2]	; save data id for future use.
		mov	si, 520		; (512+8) ; si-> data buffer + id tag field
		mov	cx, [si]	; get the length of the	file
		inc	cx		; take care of a word for lenght of tab	itself.
		inc	cx
		cmp	cx, 1528	; (2048-512-8) ; fit into the buffer?
		ja	short setdosdata_fail
		call	setdbcs_before_copy
		cmp	al, 1		; SetCountryInfo ; is the data for setcountryinfo table?
		jnz	short setdoscntry_mov ;	no, don't worry
		push	word ptr es:[di+24] ;
					; [es:di+country_cdpg_info.ccMono_Ptr
					;  -country_cdpg_info.ccCountryInfoLen]
		push	word ptr es:[di+26] ;
					; [es:di+country_cdpg_info.ccMono_Ptr
					;  -country_cdpg_info.ccCountryInfoLen+2]
					;
					; at this time di -> cccountryinfolen
		push	di
		push	ax
		mov	ax, cs:cntrycodepage_id	; do not use the code page info	in country_info
		mov	[si+4],	ax	; use the saved	one for	this !!!
		pop	ax

setdoscntry_mov:			; ...
		rep movsb		; copy the table into dos
		cmp	al, 1		; SetCountryInfo ; was the ccmono_ptr saved?
		jnz	short setdoscntry_data_next
		pop	di
		pop	word ptr es:[di+26] ;
					; [es:di+country_cdpg_info.ccMono_Ptr
					;  -country_cdpg_info.ccCountryInfoLen+2]
		pop	word ptr es:[di+24] ;
					; [es:di+country_cdpg_info.ccMono_Ptr
					;  -country_cdpg_info.ccCountryInfoLen]

setdoscntry_data_next:			; ...
		pop	si		; restore control buffer pointer
		pop	cx		; restore # of entries left
		pop	di		; restore pointer to dso_country_cdpg
		add	si, [si]	; try to get the next entry
		inc	si
		inc	si		; take a word of entry length itself
		dec	cx
		cmp	cx, 0
		jz	short setdoscntry_ok
		jmp	setdoscntry_data
; ---------------------------------------------------------------------------

setdoscntry_ok:				; ...
		retn
setdoscountryinfo endp


; =============== S U B	R O U T	I N E =======================================


setdbcs_before_copy proc near		; ...
		cmp	al, 7		; SetDBCS ; dbcs vector	set?
		jnz	short sdbcsbc	; jump if not
		cmp	word ptr es:[di], 0 ; zero byte	data block?
		jz	short sdbcsbc	; jump if so
		push	di
		push	ax
		push	cx
		mov	cx, es:[di]	; load block length
		add	di, 2		; points actual	data
		xor	al, al		; fill bytes
		rep stosb		; clear	data block
		pop	cx
		pop	ax
		pop	di

sdbcsbc:				; ...
		retn
setdbcs_before_copy endp


; =============== S U B	R O U T	I N E =======================================


getcountrydestination proc near		; ...
		push	cx		; get the destination address
					;  in the dos country info table.
		add	di, 74		; country_cdpg_info.ccNumber_of_entries
					; skip the reserved area, syscodepage etc.
		mov	cx, es:[di]	; get the number of entries
		inc	di
		inc	di		; si ->	the first start	entry id

getcntrydest:				; ...
		cmp	es:[di], al
		jz	short getcntrydest_ok
		cmp	byte ptr es:[di], 1 ; SetCountryInfo ; was it setcountryinfo entry?
		jz	short getcntrydest_1
		add	di, 5		; next data id
		jmp	short getcntrydest_loop
; ---------------------------------------------------------------------------

getcntrydest_1:				; ...
		add	di, 41		; NEW_COUNTRY_SIZE+3 ; next data id

getcntrydest_loop:			; ...
		loop	getcntrydest
		stc
		jmp	short getcntrydest_exit
; ---------------------------------------------------------------------------

getcntrydest_ok:			; ...
		cmp	al, 1		; SetCountryInfo ; select country info?
		jnz	short getcntrydest_ok1
		inc	di		; now di -> cccountryinfolen
		jmp	short getcntrydest_exit
; ---------------------------------------------------------------------------

getcntrydest_ok1:			; ...
		les	di, es:[di+1]	; get the destination in es:di

getcntrydest_exit:			; ...
		pop	cx
		retn
getcountrydestination endp


; =============== S U B	R O U T	I N E =======================================


readincontrolbuffer proc near		; ...
		push	ax		; # of bytes to	read
		mov	ax, 4200h
		stc
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		pop	cx		; # of bytes to	read
		jb	short ricb_exit
		xor	dx, dx		; ds:dx	-> control buffer
		xor	si, si
		mov	ah, 3Fh		; read into the	buffer
					; should be less than 1024 bytes.
		stc
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer

ricb_exit:				; ...
		retn
readincontrolbuffer endp

; ---------------------------------------------------------------------------

set_country_path:			; ! this procedure is not called from anywhere !
		push	si		; Erdogan Tan -	04/08/2023
		push	ds
		push	es
		pop	ds
		pop	es
		call	chk_drive_letter
		jb	short scp_default_drv
		mov	al, [si]
		inc	si
		inc	si
		jmp	short scp_setdrv
; ---------------------------------------------------------------------------

scp_default_drv:			; ...
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		add	al, 'A'

scp_setdrv:				; ...
		mov	byte ptr cs:cntry_drv, al ; "A:"
		mov	di, offset cntry_path ;	"COUNTRY.SYS"
		mov	al, [si]
		cmp	al, '\'
		jz	short scp_root_dir
		cmp	al, '/'
		jz	short scp_root_dir
		jmp	short scp_path
; ---------------------------------------------------------------------------

scp_root_dir:				; ...
		dec	di

scp_path:				; ...
		call	move_asciiz
		mov	di, offset cntry_drv ; "A:"
		push	ds
		push	es
		pop	ds
		pop	es
		pop	si
		retn

; =============== S U B	R O U T	I N E =======================================


chk_drive_letter proc near		; ...
		push	ax
		cmp	byte ptr [si], 'A'
		jb	short cdletter_no
		cmp	byte ptr [si], 'Z'
		ja	short cdletter_no
		cmp	byte ptr [si+1], ':'
		jnz	short cdletter_no
		jmp	short cdletter_exit
; ---------------------------------------------------------------------------

cdletter_no:				; ...
		stc

cdletter_exit:				; ...
		pop	ax
		retn
chk_drive_letter endp


; =============== S U B	R O U T	I N E =======================================


move_asciiz	proc near		; ...
		movsb
		cmp	byte ptr [si-1], 0 ; was it 0?
		jnz	short move_asciiz
		retn
move_asciiz	endp


; =============== S U B	R O U T	I N E =======================================


badfil		proc near		; ...
		push	cs
		pop	es
		assume es:SYSINIT
		mov	si, dx

badload:				; ...
		mov	dx, offset badld_pre ; "\r\nBad	or missing $"
		mov	bx, offset crlfm ; "\r\n$"
badfil		endp


; =============== S U B	R O U T	I N E =======================================


prnerr		proc near		; ...
		push	cs
		pop	ds
		assume ds:SYSINIT
		call	print

prn1:					; ...
		mov	dl, es:[si]
		or	dl, dl
		jz	short prn2
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		inc	si
		jmp	short prn1
; ---------------------------------------------------------------------------

prn2:					; ...
		mov	dx, bx
		call	print
		cmp	cs:donotshownum, 1
		jz	short prnexit
		call	error_line

prnexit:				; ...
		retn
prnerr		endp


; =============== S U B	R O U T	I N E =======================================


print		proc near		; ...
		mov	ah, 9
		int	21h		; DOS -	PRINT STRING
					; DS:DX	-> string terminated by	"$"
		retn
print		endp


; =============== S U B	R O U T	I N E =======================================


open_dev	proc near		; ...
		call	open_file
		jnb	short open_dev3

open_dev1:				; ...
		mov	dx, offset nuldev ; "NUL"
		call	open_file

of_retn:				; ...
		retn
; ---------------------------------------------------------------------------

open_dev3:				; ...
		mov	bx, ax
		xor	ax, ax
		mov	ah, 44h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jnz	short of_retn
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	short open_dev1
open_dev	endp


; =============== S U B	R O U T	I N E =======================================


open_file	proc near		; ...
		mov	ah, 3Dh		; OPEN
		stc
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		retn
open_file	endp

; ---------------------------------------------------------------------------

int24:					; ...
		mov	al, 3		; fail the system call
		iret			; return back to dos.
; ---------------------------------------------------------------------------
MsDosVersion6Copyr db 'MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp Licensed M'
		db 'aterial - Property of Microsoft All rights reserved '
nuldev		db 'NUL',0              ; ...
condev		db 'CON',0              ; ...
auxdev		db 'AUX',0              ; ...
prndev		db 'PRN',0              ; ...
config		db '\CONFIG.SYS',0      ; ...
cntry_drv	db 'A:'                 ; ...
cntry_root	db '\'                  ; ...
cntry_path	db 'COUNTRY.SYS',0      ; ...
		db 52 dup(0)
country_file_signature db 0FFh		; ...
		db 'COUNTRY'
cntrycodepage_id dw 0			; ...
newcmd		db 0			; ...
					; non-zero if non-std shell specified
tmplate		db 64, 12		; ...
					; must precede commnd
					; size of commnd line (excl. null)
					; 50C4h-5084h =	40h = 64
commnd		db '\COMMAND.COM',0     ; ...
		db 50 dup(0)
commnd_63	db 0			; ...
commnd2		db '\COMMAND.COM',0     ; ...
					; alternate commands to	exec
		db 2,'/P',0             ; followed by their respective alternate command lines
commnd3		db '\MSDOS\COMMAND.COM',0 ; ...
		db 11
		db 'A:\MSDOS /P',0
commnd4		db '\DOS\COMMAND.COM',0 ; ...
		db    9
		db 'A:\DOS /P',0
def_swchr	db 0			; ...
command_line	db 2,'/P'               ; ...
					; default command.com args
		db 123 dup(0)
command_line_126 db 0			; ...
		db 0
pathstring	db 64 dup(0)
dae_flag	db 0			; ...
bMenuColor	db 7			; ...
					; default fgnd/bgnd color
bMenuPage	db 0			; ...
					; menu video page (KEEP	AFTER bMenuColor)
		db 5			; video	page function #	(KEEP AFTER bMenuPage)
bLastCol	db 0			; ...
					; ending column	on status line
bLastRow	db 24			; ...
					; row #	of status line (KEEP AFTER bLastCol)
bDisableUI	db 0			; ...
					; 1=disable clean/interactive
					; 2=disable default 2-second delay
bCRTPage	db 0			; ...
					; value	saved from BIOS	data area
wCRTStart	dw 0			; ...
					; value	saved from BIOS	data area
bQueryOpt	db 0			; ...
					; 0=off, 1=prompt all, 2=prompt	none, 4=skip all
bDefBlock	db 1			; ...
					; default block	#
bMaxBlock	db 0			; ...
					; maximum block	#
offDefBlock	dw 0			; ...
					; offset of name of default block (if any)
secTimeOut	db 0FFh			; ...
					; # of seconds for timeout (-1 == indefinite)
secElapsed	db 0			; ...
					; # of seconds elapsed so far (KEEP AFTER secTimeOut)
abBlockType	db 10 dup(0)		; ...
					; times	MAX_MULTI_CONFIG+1 db 0
					; array	of block types
aoffBlockName	dw 10 dup(0)		; ...
					; times	MAX_MULTI_CONFIG+1 dw 0
					; array	of offsets of block names
aoffBlockDesc	dw 10 dup(0)		; ...
					; times	MAX_MULTI_CONFIG+1 dw 0
					; array	of offsets of block descriptions
szBoot		db 'CONFIG=',0          ; ...
szMenu		db 'MENU',0             ; ...
szCommon	db 'COMMON',0           ; ...
comtab		db 1,'[['               ; ...
					; CONFIG.SYS Command Table
					; CONFIG_BEGIN
aBreak		db 5,'BREAKC'           ; CONFIG_BREAK
aBuffers	db 7,'BUFFERSB'         ; CONFIG_BUFFERS
aComment	db 7,'COMMENTY'         ; CONFIG_COMMENT
aCountry	db 7,'COUNTRYQ'         ; CONFIG_COUNTRY
aDevice		db 6,'DEVICED'          ; CONFIG_DEVICE
aDevicehigh	db 0Ah			; CONFIG_DEVICEHIGH
		db 'DEVICEHIGHU'
aDos		db 3,'DOSH'             ; CONFIG_DOS
aDrivparm	db 8,'DRIVPARMP'        ; CONFIG_DRIVPARM
aFcbs		db 4,'FCBSX'            ; CONFIG_FCBS
aFiles		db 5,'FILESF'           ; CONFIG_FILES
aInclude	db 7,'INCLUDEJ'         ; CONFIG_INCLUDE
aInstall	db 7,'INSTALLI'         ; CONFIG_INSTALL
aInstallhigh	db 0Bh,'INSTALLHIGHW'   ; CONFIG_INSTALLHIGH
aLastdrive	db 9,'LASTDRIVEL'       ; CONFIG_LASTDRIVE
aSubmenu	db 7,'SUBMENUO'         ; CONFIG_SUBMENU
aMenucolor	db 9,'MENUCOLORR'       ; CONFIG_MENUCOLOR
aMenudefault	db 0Bh,'MENUDEFAULTA'   ; CONFIG_MENUDEFAULT
aMenuitem	db 8,'MENUITEME'        ; CONFIG_MENUITEM
aMultitrack	db 0Ah			; CONFIG_MULTITRACK
		db 'MULTITRACKM'
aNumlock	db 7,'NUMLOCKN'         ; CONFIG_NUMLOCK
aRem0Set	db 3,'REM0'             ; CONFIG_REM
aSet		db 3,'SETV'             ; CONFIG_SET
aShell		db 5,'SHELLS'           ; CONFIG_SHELL
aStacks		db 6,'STACKSK'          ; CONFIG_STACKS
aSwitches	db 8,'SWITCHES1'        ; CONFIG_SWITCHES
		db 0			; end of command table
devp_specialfunc db 0			; ...
					; deviceparameters
devp_devtype	db 2			; ...
devp_devattr	dw 0			; ...
devp_cylinders	dw 80			; ...
		db 0
devp_bps	dw 0			; ...
					; A_DEVICEPARAMETERS.DP_BPB
					; bytes	per sectors
devp_secperclus	db 6 dup(0)		; ...
devp_totalsecs	dw 0			; ...
devp_mediaid	db 3 dup(0)		; ...
devp_spt	dw 0			; ...
devp_heads	dw 0			; ...
		db 14 dup(0)
devp_trktblents	dw 0			; ...
		db 252 dup(0)
hlim		dw 2			; ...
slim		dw 9			; ...
drive		db 0			; ...
switches	dw 0			; ...
_bpb48t		dw 512			; ...
					; 48 tpi diskettes
		db 2
		dw 1
		db 2
		dw 112
		dw 720			; 2*9*40
		db 0FDh
		dw 2
		dw 9
		dw 2
		dd 0
		dd 0
_bpb96t		dw 512			; ...
					; 96 tpi diskettes
		db 1
		dw 1
		db 2
		dw 224
		dw 2400			; 2*15*80
		db 0F9h
		dw 7
		dw 15
		dw 2
		dd 0
		dd 0
_bpb35		dw 512			; ...
					; 3 1/2	inch diskette bpb
		db 2
		dw 1
		db 2
		dw 112
		dw 1440			; 2*9*80
		db 0F9h
		dw 3
		dw 9
		dw 2
		dd 0
		dd 0
_bpb35h		dw 512			; ...
		db 1
		dw 1
		db 2
		dw 224
		dw 2880			; 2*18*80
		db 0F0h
		dw 9
		dw 18
		dw 2
		dd 0
		dd 0
_bpb288		dw 512			; ...
		db 2
		dw 1
		db 2
		dw 240
		dw 5760			; 2*36*80
		db 0F0h
		dw 9
		dw 36
		dw 2
		dd 0
		dd 0
_bpbtable	dw offset _bpb48t	; ...
					; 48tpi	drives
		dw offset _bpb96t	; 96tpi	drives
		dw offset _bpb35	; 3.5" drives
		dw offset _bpb35	; not used - 8"	drives - default to 3.5"
		dw offset _bpb35	; not used - 8"	drives - default to 3.5"
		dw offset _bpb35	; not used - hard files	- default to 3.5"
		dw offset _bpb35	; not used - tape drives - default to 3.5"
		dw offset _bpb35h	; 3-1/2" 1.44mb	drive
		dw offset _bpb35	; ERIMO
		dw offset _bpb288	; 2.88 MB diskette drives
switchlist	db 8,'FHSTDICN'         ; ...
					; preserve the positions of n and c
		db 0
badopm		db 0Dh,0Ah		; ...
		db 'Unrecognized command in CONFIG.SYS'
crlfm		db 0Dh,0Ah,'$'          ; ...
badparm		db 0Dh,0Ah		; ...
		db 'Bad command or parameters - $'
badsiz_pre	db 0Dh,0Ah		; ...
		db 'Sector size too large in file $'
badld_pre	db 0Dh,0Ah		; ...
		db 'Bad or missing $'
badcom		db 'Command Interpreter',0 ; ...
badcountry	db 0Dh,0Ah		; ...
		db 'Invalid country code or code page',0Dh,0Ah,'$'
badcountrycom	db 0Dh,0Ah		; ...
		db 'Error in COUNTRY command',0Dh,0Ah,'$'
insufmemory	db 0Dh,0Ah		; ...
		db 'Insufficient memory for COUNTRY.SYS file',0Dh,0Ah,'$'
badmem		db 0Dh,0Ah		; ...
		db 'Configuration too large for memory',0Dh,0Ah,'$'
badblock	db 0Dh,0Ah		; ...
		db 'Too many block devices',0Dh,0Ah,'$'
badstack	db 0Dh,0Ah		; ...
		db 'Invalid STACK parameters',0Dh,0Ah,'$'
badorder	db 0Dh,0Ah		; ...
		db 'Incorrect order in CONFIG.SYS line $'
errorcmd	db 'Error in CONFIG.SYS line $' ; ...
OnOff		db 'ON'                 ; ...
OnOff2		db 'OFF'                ; ...
StartMsg	db 'Starting MS-DOS...',0Dh,0Ah ; ...
		db 0Ah,0
_$PauseMsg	db 'Press any key to continue . . .',0Dh,0Ah,'$' ; ...
_$CleanMsg	db 'MS-DOS is bypassing your CONFIG.SYS and AUTOEXEC.BAT files.',0Dh,0Ah,'$' ; ...
_$InterMsg	db 'MS-DOS will prompt you to confirm each CONFIG.SYS command.',0Dh,0Ah,'$' ; ...
_$MenuHeader	db 0Dh,0Ah		; ...
		db '  MS-DOS 6.2 Startup Menu',0Dh,0Ah
		db '  '
		db 17h dup(0CDh)	; db '=======================' ; ALT 205
		db 0Dh,0Ah,'$'
_$MenuPrmpt	db '  Enter a choice: $' ; ...
_$StatusLine	db 'F5=Bypass startup files F8=Confirm each line of CONFIG.SYS and AU' ; ...
		db 'TOEXEC.BAT [ ]$'
_$InterPrmpt	db ' [Y,N]?$'           ; ...
_$YES		db 'YES$'               ; ...
_$NO		db 'NO $'               ; ...
_$TimeOut	db 'Time remaining: $'  ; ...
badcomprmpt	db 'Enter correct name of Command Interpreter (eg, C:\COMMAND.COM)',0Dh,0Ah ; ...
		db '$'
_$AutoPrmpt	db 'Process AUTOEXEC.BAT [Y,N]?$' ; ...
TooManyDrivesMsg db 'WARNING! Logical drives past Z: exist and will be ignored',0Dh,0Ah,'$' ; ...
baddblspace	db 'Wrong DBLSPACE.BIN version',0Dh,0Ah,'$' ; ...
		db 7 dup(0)
SYSINIT		ends


		end
