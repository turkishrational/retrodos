     1                                  ;*****************************************************************************
     2                                  ; MSDOS6.BIN (MSDOS 6.0 Kernel) - RETRO DOS v4.0 by ERDOGAN TAN - 03/11/2022
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 16/01/2024 - Retro DOS v4.2 ((Previous: 29/09/2023))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 07/07/2018 (Retro DOS 3.0), 22/04/2019 (Retro DOS 4.0)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	   ((nasm msdos6.s -l msdos6.lst -o MSDOS6.BIN -Z error.txt)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Modified from 'msdos3.s' file of Retro DOS 3.0 source code (10/09/2018)
    13                                  ; ----------------------------------------------------------------------------
    14                                  ; Derived from 'msdos2.s' file of Retro DOS 2.0 source code (04/05/2018)
    15                                  ; ----------------------------------------------------------------------------
    16                                  ; Derived from 'MSCODE.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
    17                                  ; by Microsoft, 25/08/1983 (DOSLINK - 'MSDOS.ASM')
    18                                  ;*****************************************************************************
    19                                  ; main file: 'retrodos4.s'
    20                                  ; incbin 'MSDOS5.BIN'
    21                                  ;=============================================================================
    22                                  ; Modified from 'msdos6.s' (modified MSDOS 6.21 kernel src as Retro DOS v4.0)
    23                                  ; 28/07/2019  /// Retro DOS v4.0 (2022) -> Modified MSDOS 5.0 IO.SYS+MSDOS.SYS
    24                                  ;=============================================================================
    25                                  
    26                                  ; 30/12/2022 - Retro DOS v4.2 Kernel ('msdos6.s')
    27                                  ; Modified from 'msdos5.s' (29/12/2022, Retro DOS v4.1 Kernel) file
    28                                  ; as below:
    29                                  ;	1) MS-DOS version has been changed to 6.22 (It was 5.0) 
    30                                  ;	2) Retro DOS version has been changed to 4.2 (It was 4.1)
    31                                  ; (The content has not been changed except kernel version because the kernel
    32                                  ;  code is already compatible with MSDOS 6.x and it is optimized before.
    33                                  ;	(But IO.SYS part of the kernel is not same with Retro DOS v4.1 code.)	
    34                                  
    35                                  ; ----------------------------------------------------------------------------
    36                                  
    37                                  ; 03/11/2022 - Erdogan Tan (Istanbul)
    38                                  
    39                                  ; Note:	This code is a part of Retro DOS 4.0 kernel source code
    40                                  ;	(as included binary, 'MSDOS5.BIN') 
    41                                  ;	Equivalent of MSDOS 5.0 MSDOS.SYS kernel file 
    42                                  ;	
    43                                  ;	((MSDOS 6.0 kernel source code has been modified by using disassembled
    44                                  ;	MSDOS 5.0 MSDOS.SYS)) -- Disassembler: HEX-RAYS IDA Pro --
    45                                  ;	((Disassembly -Reverse engineering- reference: MSDOS 6.0 kernel src))
    46                                        
    47                                  ;------ Retro DOS v2 (v3) boot sector loads RETRODOS.SYS (MSDOS.SYS)
    48                                  ;	at 1000h:0000h and loader (initialization) part of RETRODOS kernel
    49                                  ;	moves IO.SYS (DOSBIOSCODE & DOSBIOSDATA, 'IOSYS5.BIN') to 70h:0000h.
    50                                  ;	Then SYSINIT code to the next segment (4D6h for current version)..
    51                                  ;	SYSINIT code relocates itself and DOSBIOSCODE and MSDOS.SYS
    52                                  ;	(MSDOS5.BIN) according to request/setting in 'config.sys' file.
    53                                  
    54                                  ;=============================================================================
    55                                  ; Most of comments in this file are from the original MSDOS 6.0 source code
    56                                  ;-----------------------------------------------------------------------------
    57                                  
    58                                  ; MSDOS 6.0 Kernel source files:
    59                                  ;	MSDATA.ASM, 
    60                                  ; 		(MSHEAD.ASM, MSCONST.ASM,CONST2.ASM, MS_DATA.ASM,
    61                                  ;		DOSTAB.ASM, LMSTUB.ASM, WPATCH.INC, MPATCH.ASM)
    62                                  ;	MSTABLE.ASM, MSCODE.ASM, MSDOSME.ASM (DOSMES.INC), TIME.ASM,
    63                                  ;	GETSET.ASM, PARSE.ASM, MISC.ASM, MISC2.ASM, CRIT.ASM, CPMIO.ASM,
    64                                  ;	CPMIO2.ASM, FCBIO.ASM, FCBIO2.ASM, SEARCH.ASM, PATH.ASM, IOCTL.ASM,
    65                                  ;	DELETE.ASM, RENAME.ASM, FINFO.ASM, DUP.ASM, CREATE.ASM, OPEN.ASM,
    66                                  ;	DINFO.ASM, ISEARCH.ASM, BUF.ASM, ABORT.ASM,CLOSE.ASM, DIRCALL.ASM,
    67                                  ;	DISK.ASM, DISK2.ASM, DISK3.ASM, DIR.ASM, DIR2.ASM, DEV.ASM,
    68                                  ;	MKNODE.ASM, ROM.ASM, FCB.ASM, MSCTRLC.ASM, FAT.ASM, MSPROC.ASM
    69                                  ;	ALLOC.ASM, SRVCALL.ASM, UTIL.ASM, MACRO.ASM, MACRO2.ASM, HANDLE.ASM
    70                                  ;	FILE.ASM, LOCK.ASM, ROMFIND.ASM, SHARE.ASM, MSINIT.ASM, ORIGIN.ASM
    71                                  ;
    72                                  ; MSDOS 2.0 Kernel source files:
    73                                  ; 	MSDOS.ASM (STDSW.ASM + MSHEAD.ASM + MSDATA.ASM)
    74                                  ;	MSCODE.ASM
    75                                  ;	DOSMES.ASM ... STDIO.ASM, TIME.ASM, XENIX.ASM, XENIX2.ASM
    76                                  
    77                                  ;============================================================================
    78                                  ; DOSLINK
    79                                  ;============================================================================
    80                                  ;msdos mscode dosmes misc getset dircall alloc dev dir +
    81                                  ;disk fat rom stdbuf stdcall stdctrlc stdfcb stdproc +
    82                                  ;stdio time xenix xenix2
    83                                  
    84                                  ;============================================================================
    85                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    86                                  ; output in TASM syntax (July 2018 -> NASM syntax) [ IBMDOS.COM, 17/03/1987 ]
    87                                  ;============================================================================
    88                                  ;
    89                                  ; ###########################################################################
    90                                  ; #	This file is generated by The Interactive Disassembler (IDA)	    #
    91                                  ; #	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    #
    92                                  ; #			 Licensed to: Freeware version			    #
    93                                  ; ###########################################################################
    94                                  ;
    95                                  ; Input	MD5   :	75959BC417C19135B982F7959EE9C92A
    96                                  
    97                                  ; ---------------------------------------------------------------------------
    98                                  ; File Name   :	C:\Documents and Settings\Erdoðan Tan\Desktop\MSDOS621.BIN
    99                                  ; Format      :	Binary file
   100                                  ;============================================================================
   101                                  ; MSDOS621.BIN = MSDOS.SYS, 13/02/1994, 38138 bytes (MSDOS 6.21 kernel) 2019
   102                                  ;----------------------------------------------------------------------------
   103                                  ; MSDOS5.BIN = MSDOS.SYS, 11/11/1991, 37394 bytes (MSDOS 5.0 kernel) 2022
   104                                  
   105                                  ;============================================================================
   106                                  ; MSDOS.ASM
   107                                  ;============================================================================
   108                                  
   109                                  ;TITLE   Standard MSDOS
   110                                  ;NAME    MSDOS_2
   111                                  
   112                                  ; Number of disk I/O buffers
   113                                  
   114                                  ;	INCLUDE STDSW.ASM
   115                                  ;       INCLUDE MSHEAD.ASM
   116                                  ;       INCLUDE MSDATA.ASM
   117                                  
   118                                  ;	END
   119                                  
   120                                  ;============================================================================
   121                                  ; STDSW.ASM
   122                                  ;============================================================================
   123                                  
   124                                  TRUE    EQU     0FFFFH
   125                                  FALSE   EQU     ~TRUE ; NOT TRUE
   126                                  
   127                                  ; Use the switches below to produce the standard Microsoft version or the IBM
   128                                  ; version of the operating system
   129                                  ;MSVER   EQU	false
   130                                  ;IBM     EQU	true
   131                                  ;WANG    EQU	FALSE
   132                                  ;ALTVECT EQU	FALSE
   133                                  
   134                                  ; Set this switch to cause DOS to move itself to the end of memory
   135                                  ;HIGHMEM EQU     FALSE
   136                                  
   137                                  ;	IF      IBM
   138                                  ESCCH    EQU	 0			;character to begin escape seq.
   139                                  CANCEL   EQU	 27			;Cancel with escape
   140                                  TOGLINS  EQU	TRUE			;One key toggles insert mode
   141                                  TOGLPRN  EQU	TRUE			;One key toggles printer echo
   142                                  ZEROEXT  EQU	TRUE
   143                                  ;       ELSE
   144                                  ;       IF      WANG			;Are we assembling for WANG?
   145                                  ;ESCCH	 EQU	1FH			;Yes. Use 1FH for escape character
   146                                  ;       ELSE
   147                                  ;ESCCH	 EQU	1BH
   148                                  ;       ENDIF
   149                                  ;CANCEL  EQU	"X"-"@"			;Cancel with Ctrl-X
   150                                  ;TOGLINS EQU	WANG			;Separate keys for insert mode on
   151                                  					;and off if not WANG
   152                                  ;TOGLPRN EQU	FALSE			;Separate keys for printer echo on
   153                                  					;and off
   154                                  ;ZEROEXT EQU	TRUE
   155                                  ;        ENDIF
   156                                  
   157                                  ;============================================================================
   158                                  ; MSHEAD.ASM
   159                                  ;============================================================================
   160                                  
   161                                  ;--------------------------------------------------------------
   162                                  ; TITLE   MSHEAD.ASM -- MS-DOS DEFINITIONS
   163                                  ;--------------------------------------------------------------
   164                                  
   165                                  ; MS-DOS High-performance operating system for the 8086  version 1.28
   166                                  ;        by Microsoft MSDOS development group:
   167                                  ;           Tim Paterson (Ret.)
   168                                  ;           Aaron Reynolds
   169                                  ;           Nancy Panners (Parenting)
   170                                  ;           Mark Zbikowski
   171                                  ;           Chris Peters (BIOS) (ret.)
   172                                  
   173                                  ; ****************** Revision History *************************
   174                                  ;          >> EVERY change must noted below!! <<
   175                                  ;
   176                                  ; 0.34 12/29/80 General release, updating all past customers
   177                                  ; 0.42 02/25/81 32-byte directory entries added
   178                                  ; 0.56 03/23/81 Variable record and sector sizes
   179                                  ; 0.60 03/27/81 Ctrl-C exit changes, including register save on user stack
   180                                  ; 0.74 04/15/81 Recognize I/O devices with file names
   181                                  ; 0.75 04/17/81 Improve and correct buffer handling
   182                                  ; 0.76 04/23/81 Correct directory size when not 2^N entries
   183                                  ; 0.80 04/27/81 Add console input without echo, Functions 7 & 8
   184                                  ; 1.00 04/28/81 Renumber for general release
   185                                  ; 1.01 05/12/81 Fix bug in `STORE'
   186                                  ; 1.10 07/21/81 Fatal error trapping, NUL device, hidden files, date & time,
   187                                  ;               RENAME fix, general cleanup
   188                                  ; 1.11 09/03/81 Don't set CURRENT BLOCK to 0 on open; fix SET FILE SIZE
   189                                  ; 1.12 10/09/81 Zero high half of CURRENT BLOCK after all (CP/M programs don't)
   190                                  ; 1.13 10/29/81 Fix classic "no write-through" error in buffer handling
   191                                  ; 1.20 12/31/81 Add time to FCB; separate FAT from DPT; Kill SMALLDIR; Add
   192                                  ;               FLUSH and MAPDEV calls; allow disk mapping in DSKCHG; Lots
   193                                  ;               of smaller improvements
   194                                  ; 1.21 01/06/82 HIGHMEM switch to run DOS in high memory
   195                                  ; 1.22 01/12/82 Add VERIFY system call to enable/disable verify after write
   196                                  ; 1.23 02/11/82 Add defaulting to parser; use variable escape character Don't
   197                                  ;               zero extent field in IBM version (back to 1.01!)
   198                                  ; 1.24 03/01/82 Restore fcn. 27 to 1.0 level; add fcn. 28
   199                                  ; 1.25 03/03/82 Put marker (00) at end of directory to speed searches
   200                                  ; 1.26 03/03/82 Directory buffers searched as a circular queue, current buffer
   201                                  ;               is searched first when possible to minimize I/O
   202                                  ;      03/03/82 STORE routine optimized to tack on partial sector tail as
   203                                  ;               full sector write when file is growing
   204                                  ;      03/09/82 Multiple I/O buffers
   205                                  ;      03/29/82 Two bugs:  Delete all case resets search to start at beginning
   206                                  ;               of directory (infinite loop possible otherwise), DSKRESET
   207                                  ;               must invalidate all buffers (disk and directory).
   208                                  ; 1.27 03/31/82 Installable device drivers
   209                                  ;                 Function call 47 - Get pointer to device table list
   210                                  ;                 Function call 48 - Assign CON AUX LIST
   211                                  ;      04/01/82 Spooler interrupt (INT 28) added.
   212                                  ; 1.28 04/15/82 DOS retructured to use ASSUMEs and PROC labels around system
   213                                  ;               call entries.  Most CS relative references changed to SS
   214                                  ;               relative with an eye toward putting a portion of the DOS in
   215                                  ;               ROM.  DOS source also broken into header, data and code pieces
   216                                  ;      04/15/82 GETDMA and GETVECT calls added as 24 and 32.  These calls
   217                                  ;               return the current values.
   218                                  ;      04/15/82 INDOS flag implemented for interrupt processing along with
   219                                  ;               call to return flag location (call 29)
   220                                  ;      04/15/82 Volume ID attribute added
   221                                  ;      04/17/82 Changed ABORT return to user to a long ret from a long jump to
   222                                  ;               avoid a CS relative reference.
   223                                  ;      04/17/82 Put call to STATCHK in dispatcher to catch ^C more often
   224                                  ;      04/20/82 Added INT int_upooler into loop ^S wait
   225                                  ;      04/22/82 Dynamic disk I/O buffer allocation and call to manage them
   226                                  ;               call 49.
   227                                  ;      04/23/82 Added GETDSKPTDL as call 50, similar to GETFATPT(DL), returns
   228                                  ;               address of DPB
   229                                  ;      04/29/82 Mod to WRTDEV to look for ^C or ^S at console input when
   230                                  ;               writting to console device via file I/O.  Added a console
   231                                  ;               output attribute to devices.
   232                                  ;      04/30/82 Call to en/dis able ^C check in dispatcher Call 51
   233                                  ;      04/30/82 Code to allow assignment of func 1-12 to disk files as well
   234                                  ;               as devices....  pipes, redirection now possible
   235                                  ;      04/30/82 Expanded GETLIST call to 2.0 standard
   236                                  ;      05/04/82 Change to INT int_fatal_abort callout int HARDERR.  DOS SS
   237                                  ;               (data segment) stashed in ES, INT int_fatal_abort routines must
   238                                  ;               preserve ES.  This mod so HARDERR can be ROMed.
   239                                  ; 1.29 06/01/82 Installable block and character devices as per 2.0 spec
   240                                  ;      06/04/82 Fixed Bug in CLOSE regarding call to CHKFATWRT.  It got left
   241                                  ;               out back about 1.27 or so (oops).  ARR
   242                                  ; 1.30 06/07/82 Directory sector buffering added to main DOS buffer queue
   243                                  ; 1.40 06/15/82 Tree structured directories.  XENIX Path Parser MKDIR CHDIR
   244                                  ;               RMDIR Xenix calls
   245                                  ; 1.41 06/13/82 Made GETBUFFR call PLACEBUF
   246                                  ; 1.50 06/17/82 FATs cached in buffer pool, get FAT pointer calls disappear
   247                                  ;               Frees up lots of memory.
   248                                  ; 1.51 06/24/82 BREAKDOWN modified to do EXACT one sector read/write through
   249                                  ;               system buffers
   250                                  ; 1.52 06/30/82 OPEN, CLOSE, READ, WRITE, DUP, DUP2, LSEEK implemented
   251                                  ; 1.53 07/01/82 OPEN CLOSE mod for Xenix calls, saves and gets remote dir
   252                                  ; 1.54 07/11/82 Function calls 1-12 make use of new 2.0 PDB. Init code
   253                                  ;               changed to set file handle environment.
   254                                  ; 2.00 08/01/82 Number for IBM release
   255                                  ;      01/19/83 No environ bug in EXEC
   256                                  ;      01/19/83 MS-DOS OEM INT 21 extensions (SET_OEM_HANDLER)
   257                                  ;      01/19/83 Performance bug fix in cooked write to NUL
   258                                  ;      01/27/83 Growcnt fixed for 32-bits
   259                                  ;      01/27/83 Find-first problem after create
   260                                  ; 2.01 02/17/83 International DOS
   261                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   262                                  ;               an IBM PC
   263                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
   264                                  ; (MSHEAD.ASM, MSDOS 6.0, 1991) - mshead.asm 1.1 85/04/10 -
   265                                  ; 2.10 03/09/83 Start of NETWORK support
   266                                  ;		New Buffer structure
   267                                  ;		New Sytem file table structure
   268                                  ;		FCB moved to internal representation
   269                                  ;		DOS re-organized
   270                                  ; 2.11 04/21/83 Continuation of 2.10, preliminary Network
   271                                  ;		device interface.
   272                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   273                                  ;               an IBM PC
   274                                  ; 2.50 09/12/83 More network stuff
   275                                  ;
   276                                  ; *************************************************************
   277                                  
   278                                  ; ----------------------------------------------------------------------------
   279                                  ; EQUATES
   280                                  
   281                                  ; Interrupt Entry Points:
   282                                  
   283                                  ; INTBASE:      ABORT
   284                                  ; INTBASE+4:    COMMAND
   285                                  ; INTBASE+8:    BASE EXIT ADDRESS
   286                                  ; INTBASE+C:    CONTROL-C ABORT
   287                                  ; INTBASE+10H:  FATAL ERROR ABORT
   288                                  ; INTBASE+14H:  BIOS DISK READ
   289                                  ; INTBASE+18H:  BIOS DISK WRITE
   290                                  ; INTBASE+1CH:  END BUT STAY RESIDENT (NOT SET BY DOS)
   291                                  ; INTBASE+20H:  SPOOLER INTERRUPT
   292                                  ; INTBASE+40H:  Long jump to CALL entry point
   293                                  
   294                                  ENTRYPOINTSEG   EQU     0Ch
   295                                  MAXDIF          EQU     0FFFh
   296                                  SAVEXIT         EQU     10
   297                                  ; 06/05/2019
   298                                  WRAPOFFSET	EQU	0FEF0h  ; (MISC.ASM, MSDOS 6.0, 1991)
   299                                  
   300                                         ; INCLUDE DOSSYM.ASM
   301                                         ; INCLUDE DEVSYM.ASM
   302                                  
   303                                  ; SUBTTL ^C, terminate/abort/exit and Hard error actions
   304                                  ; PAGE
   305                                  ; There are three kinds of context resets that can occur during normal DOS
   306                                  ; functioning:  ^C trap, terminate/abort/exit, and Hard-disk error.  These must
   307                                  ; be handles in a clean fashion that allows nested executions along with the
   308                                  ; ability to trap one's own errors.
   309                                  ;
   310                                  ; ^C trap - A process may elect to catch his own ^Cs.  This is achieved by
   311                                  ;           using the $GET_INTERRUPT_VECTOR and $SET_INTERRUPT_VECTOR as
   312                                  ;           follows:
   313                                  ;
   314                                  ;           $GET_INTERRUPT_VECTOR for INT int_ctrl_c
   315                                  ;           Save it in static memory.
   316                                  ;           $SET_INTERRUPT_VECTOR for INT int_ctrl_c
   317                                  ;
   318                                  ;           The interrupt service routine must preserve all registers and
   319                                  ;           return carry set iff the operation is to be aborted (via abort
   320                                  ;           system call), otherwise, carry is reset and the operation is
   321                                  ;           restarted.  ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE
   322                                  ;           RESULTS.
   323                                  ;
   324                                  ;           To restore original ^C processing (done on terminate/abort/exit),
   325                                  ;           restore INT int_ctrl_c from the saved vector.
   326                                  ;
   327                                  ; Hard-disk error -- The interrupt service routine for INT int_fatal_abort must
   328                                  ;           also preserve registers and return one of three values in AL: 0 and
   329                                  ;           1 imply retry and ignore (???)  and 2 indicates an abort.  The user
   330                                  ;           himself is not to issue the abort, rather, the dos will do it for
   331                                  ;           him by simulating a normal abort/exit system call.  ANY DEVIATION
   332                                  ;           FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   333                                  ;
   334                                  ; terminate/abort/exit -- The user may not, under any circumstances trap an
   335                                  ;           abort call.  This is reserved for knowledgeable system programs.
   336                                  ;           ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   337                                  
   338                                  ;SUBTTL SEGMENT DECLARATIONS
   339                                  
   340                                  ; The following are all of the segments used.  They are declared in the order
   341                                  ; that they should be placed in the executable
   342                                  
   343                                  ;
   344                                  ; segment ordering for MSDOS
   345                                  ;
   346                                  
   347                                  ;START           SEGMENT BYTE PUBLIC 'START'
   348                                  ;START           ENDS
   349                                  
   350                                  ;CONSTANTS       SEGMENT BYTE PUBLIC 'CONST'
   351                                  ;CONSTANTS       ENDS
   352                                  
   353                                  ;DATA            SEGMENT WORD PUBLIC 'DATA'
   354                                  ;DATA            ENDS
   355                                  
   356                                  ;CODE            SEGMENT BYTE PUBLIC 'CODE'
   357                                  ;CODE            ENDS
   358                                  
   359                                  ;LAST            SEGMENT BYTE PUBLIC 'LAST'
   360                                  ;LAST            ENDS
   361                                  
   362                                  ;DOSGROUP    GROUP   CODE,CONSTANTS,DATA,LAST
   363                                  
   364                                  ; The following segment is defined such that the data/const classes appear
   365                                  ; before the code class for ROMification
   366                                  
   367                                  ;START		SEGMENT BYTE PUBLIC 'START'
   368                                  ;           	ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
   369                                  ;		JMP     DOSINIT
   370                                  ;START		ENDS
   371                                  
   372                                  ;============================================================================
   373                                  ; BPB.INC, MSDOS 6.0, 1991
   374                                  ;============================================================================
   375                                  ; 09/07/2018 - Retro DOS v3.0
   376                                  
   377                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   378                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   379                                  ;									   ;
   380                                  
   381                                  ;**	BIOS PARAMETER BLOCK DEFINITION
   382                                  ;
   383                                  ;	The BPB contains information about the disk structure. It dates
   384                                  ;	back to the earliest FAT systems and so FAT information is
   385                                  ;	intermingled with physical driver information.
   386                                  ;
   387                                  ;	A boot sector contains a BPB for its device; for other disks
   388                                  ;	the driver creates a BPB. DOS keeps copies of some of this
   389                                  ;	information in the DPB.
   390                                  ;
   391                                  ;	The BDS structure contains a BPB within it. 
   392                                  
   393                                  struc A_BPB
   394 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
   395 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
   396 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
   397 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
   398 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
   399 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
   400 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
   401 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
   402 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
   403 0000000F ????                    .BPB_HEADS:		resw	1
   404 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
   405 00000013 ????                    			resw	1
   406 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
   407 00000017 ????                    			resw	1
   408 00000019 ????????????            			resb	6	; NOTE:  many times these
   409                                  ;					; 	 6 bytes are omitted
   410                                  ;					;	 when BPB manipulations
   411                                  ;					;	 are performed!
   412                                  .size:
   413                                  endstruc
   414                                  
   415                                  ;                                                                          ;
   416                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   417                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   418                                  
   419                                  ;============================================================================
   420                                  ; BUFFER.INC, MSDOS 6.0, 1991
   421                                  ;============================================================================
   422                                  ; 04/05/2019 - Retro DOS v4.0
   423                                  
   424                                  ; <Disk I/O Buffer Header>
   425                                  
   426                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   427                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   428                                  ;									   ;
   429                                  
   430                                  ; Field definition for I/O buffer information
   431                                  
   432                                  struc BUFFINFO
   433 00000000 ????                    .buf_next:	resw 1		; Pointer to next buffer in list
   434 00000002 ????                    .buf_prev:	resw 1		; Pointer to prev buffer in list
   435 00000004 ??                      .buf_ID:	resb 1		; Drive of buffer (bit 7 = 0)
   436                                  				; SFT table index (bit 7 = 1)
   437                                  				; = FFH if buffer free
   438 00000005 ??                      .buf_flags:	resb 1		; Bit 7 = 1 if Remote file buffer
   439                                  				;	= 0 if Local device buffer
   440                                  				; Bit 6 = 1 if buffer dirty
   441                                  				; Bit 5 = Reserved
   442                                  				; Bit 4 = Search bit (bit 7 = 1)
   443                                  				; Bit 3 = 1 if buffer is DATA
   444                                  				; Bit 2 = 1 if buffer is DIR
   445                                  				; Bit 1 = 1 if buffer is FAT
   446                                  				; Bit 0 = Reserved
   447 00000006 ????????                .buf_sector:	resd 1		; Sector number of buffer (flags bit 7 = 0)
   448                                  ; The next two items are often refed as a word (flags bit 7 = 0)
   449 0000000A ??                      .buf_wrtcnt:	resb 1		; For FAT sectors, # times sector written out
   450 0000000B ????                    .buf_wrtcntinc:	resw 1		; "   "     "   , # sectors between each write
   451 0000000D ????????                .buf_DPB:	resd 1		; Pointer to drive parameters
   452 00000011 ????                    .buf_fill:	resw 1		; How full buffer is (flags bit 7 = 1)
   453 00000013 ??                      .buf_reserved:	resb 1		; make DWORD boundary for 386
   454                                  .size:	; 20 bytes
   455                                  endstruc
   456                                  
   457                                  %define buf_offset	BUFFINFO.buf_sector ; 22/07/2019
   458                                  				;For buf_flags bit 7 = 1, this is the byte
   459                                  				;offset of the start of the buffer in
   460                                  				;the file pointed to by buf_ID. Thus
   461                                  				;the buffer starts at location
   462                                  				;buf_offset in the file and contains
   463                                  				;buf_fill bytes.
   464                                  
   465                                  BUFINSIZ        EQU     BUFFINFO.size
   466                                  
   467                                  buf_Free	EQU	0FFh	; buf_id of free buffer
   468                                  
   469                                  ;Flag byte masks
   470                                  buf_isnet	EQU	10000000B
   471                                  buf_dirty	EQU	01000000B
   472                                  ;***
   473                                  buf_visit	EQU	00100000B
   474                                  ;***
   475                                  buf_snbuf	EQU	00010000B
   476                                  
   477                                  buf_isDATA	EQU	00001000B
   478                                  buf_isDIR	EQU	00000100B
   479                                  buf_isFAT	EQU	00000010B
   480                                  buf_type_0	EQU	11110001B	; AND sets type to "none"
   481                                  
   482                                  buf_NetID	EQU	BUFINSIZ
   483                                  
   484                                  ;                                                                          ;
   485                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   486                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   487                                  
   488                                  ;============================================================================
   489                                  ; DOSSSYM.INC, MSDOS 6.0, 1991
   490                                  ;============================================================================
   491                                  ; 04/05/2019 - Retro DOS v4.0
   492                                  
   493                                  ; <Control character definitions>
   494                                  
   495                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   496                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   497                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   498                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   499                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   500                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   501                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   502                                  c_HT	    EQU     09h 	; ^I ASCII tab
   503                                  
   504                                  ; <User stack inside of system call>
   505                                  ; Location of user registers relative user stack pointer
   506                                  
   507                                  struc	user_env   ; user_environ
   508 00000000 ????                    .user_AX: resw 1
   509 00000002 ????                    .user_BX: resw 1
   510 00000004 ????                    .user_CX: resw 1
   511 00000006 ????                    .user_DX: resw 1
   512 00000008 ????                    .user_SI: resw 1
   513 0000000A ????                    .user_DI: resw 1
   514 0000000C ????                    .user_BP: resw 1
   515 0000000E ????                    .user_DS: resw 1
   516 00000010 ????                    .user_ES: resw 1
   517 00000012 ????                    .user_IP: resw 1
   518 00000014 ????                    .user_CS: resw 1
   519 00000016 ????                    .user_F:  resw 1
   520                                  .size:
   521                                  endstruc
   522                                  
   523                                  ; ---- <Disk map> ----
   524                                  
   525                                  ;	MSDOS partitions the disk into 4 sections:
   526                                  ;
   527                                  ;  phys sector 0:   +-------------------+
   528                                  ;	|	    | boot/reserved	|
   529                                  ;	|	    +-------------------+
   530                                  ;	|	    |  File allocation	|
   531                                  ;	v	    |	   table(s)	|
   532                                  ;		    |  (multiple copies |
   533                                  ;		    |	  are kept)	|
   534                                  ;		    +-------------------+
   535                                  ;		    |	  Directory	|
   536                                  ;		    +-------------------+
   537                                  ;		    |	  File space	|
   538                                  ;		    +-------------------+
   539                                  ;		    |	Unaddressable	|
   540                                  ;		    |  (to end of disk) |
   541                                  ;		    +-------------------+
   542                                  ;
   543                                  ; All partition boundaries are sector boundaries.  The size of the FAT is
   544                                  ; adjusted to maximize the file space addressable.
   545                                  
   546                                  ; <File allocation Table information>
   547                                  
   548                                  ; The File Allocation Table uses a 12-bit entry for each allocation unit on
   549                                  ; the disk.  These entries are packed, two for every three bytes.  The contents
   550                                  ; of entry number N is found by 1) multiplying N by 1.5; 2) adding the result
   551                                  ; to the base address of the Allocation Table; 3) fetching the 16-bit word
   552                                  ; at this address; 4) If N was odd (so that N*1.5 was not an integer), shift
   553                                  ; the word right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry
   554                                  ; number zero is used as an end-of-file trap in the OS and is passed to the
   555                                  ; BIOS to help determine disk format.  Entry 1 is reserved for future use.
   556                                  ; The first available allocation unit is assigned entry number two, and even
   557                                  ; though it is the first, is called cluster 2.	Entries greater than 0FF8H
   558                                  ; (12-bit fats) or 0FFF8H (16-bit fats) are end of file marks; entries of zero
   559                                  ; are unallocated.  Otherwise, the contents of a FAT entry is the number of
   560                                  ; the next cluster in the file.
   561                                  ;
   562                                  ; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would
   563                                  ; do because these clusters show as allocated, but are not part of any
   564                                  ; allocation chain and thus will never be allocated to a file.	A particular
   565                                  ; number is selected so that disk checking programs know what to do (ie.  a
   566                                  ; cluster with entry FF7H which is not in a chain is not an error).
   567                                  
   568                                  ;**	Character Type Flags
   569                                  ;
   570                                  ;	These flags are used in a lookup table indexed by the character code.
   571                                  ;	They're used to quickly classify characters when parsing paths.
   572                                  ;	I think that these are only used to parse FCBs - jgl
   573                                  
   574                                  FCHK	equ 1		; I think this means "normal name char, no chks needed" -jgl
   575                                  FDELIM	equ 2		; is a delimiter
   576                                  FSPCHK	equ 4		; set if character is not a space or equivalent
   577                                  FFCB	equ 8		; is valid in an FCB
   578                                  
   579                                  ;** Bit definitions for DOS_FLAG
   580                                  ;
   581                                  ; Bit 0 - this is set when a $open call is made from $exec. This is used in
   582                                  ;	  $open to indicate to the redirector that this open is being made
   583                                  ;	  by an exec call.
   584                                  ;
   585                                  ; Bit 2
   586                                  ;
   587                                  ; M003, M027:
   588                                  ;
   589                                  ; The start up code of MS PASCAL 3.2 programs depend on the 1M address wrap 
   590                                  ; if they load below 64K. This is a likely possiblity in DOS 5.x with DOS in
   591                                  ; the HMA. By default DOS will turn A20 OFF before Xferring control to the
   592                                  ; user program in the case of an Exec call. The next call to DOS will turn
   593                                  ; A20 line ON. It has been observed that MS PASCAL 3.2 start up does an int
   594                                  ; 21 ah=25h call before executing the faulty code. This will turn A20 On. 
   595                                  ; In order to support this we will set Bit 2 of this flag in the DOS exec
   596                                  ; call (msproc.asm) if DOS is running in the HMA. In $set_interrupt_vector in
   597                                  ; getset.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
   598                                  ; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
   599                                  ; is non zero then A20 will be turned OFF before returning to the user. 
   600                                  ; Bit 2 will be unconditionally cleared here.
   601                                  ;
   602                                  ; M009, M027:
   603                                  ;
   604                                  ; Mace utilities MKEYRATE.COM version 1.0 copyright 1987 is an execpacked 
   605                                  ; program converted to a com file. Therefore if DOS is loaded high and if 
   606                                  ; this program is loaded below 64K it will blurt out "packed file is corrupt".
   607                                  ; This program does an int 21 ah=49h before executing the buggy execpacked
   608                                  ; code. This int21 call turns a20 on and hence the problem. In $dealloc
   609                                  ; alloc.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
   610                                  ; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
   611                                  ; is non zero then A20 will be turned OFF before returning to the user. 
   612                                  ; Bit 2 will be unconditionally cleared here.
   613                                  
   614                                  EXECOPEN	EQU	00000001b	; bit 0 of DOS_FLAG
   615                                  SUPPRESS_WINA20	EQU	00000010b	; M025
   616                                  EXECA20OFF	EQU	00000100b	; bit 2 of DOS_FLAG
   617                                  
   618                                  ;============================================================================
   619                                  ; VECTOR.INC, MSDOS 6.0, 1991
   620                                  ;============================================================================
   621                                  ; 04/05/2019 - Retro DOS v4.0
   622                                  
   623                                  ; 09/07/2018 - Retro DOS v3.0 (VECTOR.INC, MSDOS 3.3, 1987)
   624                                  
   625                                  ; <interrupt definitions>
   626                                  
   627                                  INTTAB          EQU     20H
   628                                  INTBASE         EQU     4 * INTTAB
   629                                  ENTRYPOINT      EQU     INTBASE+40H
   630                                  
   631                                  ;	IF      ALTVECT
   632                                  ;ALTTAB  EQU     0F0H
   633                                  ;ALTBASE EQU     4 * ALTTAB
   634                                  ;	ENDIF
   635                                  
   636                                  ;
   637                                  ; interrupt assignments
   638                                  ;
   639                                  ;	IF	NOT ALTVECT
   640                                  int_abort	    EQU     INTTAB	; abort process
   641                                  int_command	    EQU     int_abort+1 ; call MSDOS
   642                                  int_terminate	    EQU     int_abort+2 ; int to terminate address
   643                                  int_ctrl_c	    EQU     int_abort+3 ; ^c trapper
   644                                  int_fatal_abort     EQU     int_abort+4 ; hard disk error
   645                                  int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   646                                  int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   647                                  int_keep_process    EQU     int_abort+7 ; terminate program and stay
   648                                  					; resident
   649                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   650                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   651                                  ;									   ;
   652                                  int_spooler	    EQU     int_abort+8 ; spooler call
   653                                  int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   654                                  int_IBM 	    EQU     int_abort+10; critical section maintenance
   655                                  ;									   ;
   656                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   657                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   658                                  ;	ELSE
   659                                  ;int_abort	    EQU     INTTAB	; abort process
   660                                  ;int_command	    EQU     int_abort+1 ; call MSDOS
   661                                  ;int_terminate	    EQU     ALTTAB	; int to terminate address
   662                                  ;int_ctrl_c	    EQU     int_terminate+1 ; ^c trapper
   663                                  ;int_fatal_abort    EQU     int_terminate+2 ; hard disk error
   664                                  ;int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   665                                  ;int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   666                                  ;int_keep_process   EQU     int_abort+7 ; terminate program and stay resident
   667                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   668                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   669                                  ;									   ;
   670                                  ;int_spooler	    EQU     int_terminate+3 ; spooler call
   671                                  ;int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   672                                  ;									   ;
   673                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   674                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   675                                  ;	ENDIF
   676                                  
   677                                  addr_int_abort		EQU    4 * int_abort
   678                                  addr_int_command	EQU    4 * int_command
   679                                  addr_int_terminate	EQU    4 * int_terminate
   680                                  addr_int_ctrl_c 	EQU    4 * int_ctrl_c
   681                                  addr_int_fatal_abort	EQU    4 * int_fatal_abort
   682                                  addr_int_disk_read	EQU    4 * int_disk_read
   683                                  addr_int_disk_write	EQU    4 * int_disk_write
   684                                  addr_int_keep_process	EQU    4 * int_keep_process
   685                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   686                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   687                                  ;									   ;
   688                                  addr_int_spooler	EQU    4 * int_spooler
   689                                  addr_int_fastcon	EQU    4 * int_fastcon
   690                                  addr_int_ibm		EQU    4 * int_IBM
   691                                  ;									   ;
   692                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   693                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   694                                  
   695                                  ;============================================================================
   696                                  ; DIRENT.INC, MSDOS 6.0, 1991
   697                                  ;============================================================================
   698                                  ; 04/05/2019 - Retro DOS v4.0
   699                                  
   700                                  ; BREAK <Directory entry>
   701                                  
   702                                  ;
   703                                  ;       +---------------------------+
   704                                  ;       |  (12 BYTE) filename/ext   |       0       0
   705                                  ;       +---------------------------+
   706                                  ;       |     (BYTE) attributes     |       11      B
   707                                  ;       +---------------------------+
   708                                  ;       |    (10 BYTE) reserved     |       12      C
   709                                  ;       +---------------------------+
   710                                  ;       | (WORD) time of last write |       22      16
   711                                  ;       +---------------------------+
   712                                  ;       | (WORD) date of last write |       24      18
   713                                  ;       +---------------------------+
   714                                  ;       |   (WORD) First cluster    |       26      1A
   715                                  ;       +---------------------------+
   716                                  ;       |     (DWORD) file size     |       28      1C
   717                                  ;       +---------------------------+
   718                                  ;
   719                                  ;   First byte of filename  = E5 -> free directory entry
   720                                  ;                           = 00 -> end of allocated directory
   721                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   722                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   723                                  ;
   724                                  struc dir_entry
   725 00000000 <res Bh>                .dir_name:	resb 11			; file name
   726 0000000B ??                      .dir_attr:	resb 1			; attribute bits
   727 0000000C ????                    .dir_codepg:	resw 1			; code page DOS 4.00
   728 0000000E ????                    .dir_extcluster: resw 1			; extended attribute starting cluster
   729 00000010 ??                      .dir_attr2:	resb 1			; reserved
   730 00000011 ??????????              .dir_pad:	resb 5			; reserved for expansion
   731 00000016 ????                    .dir_time:	resw 1			; time of last write
   732 00000018 ????                    .dir_date:	resw 1			; date of last write
   733 0000001A ????                    .dir_first:	resw 1			; first allocation unit of file
   734 0000001C ????                    .dir_size_l:	resw 1			; low 16 bits of file size
   735 0000001E ????                    .dir_size_h:	resw 1			; high 16 bits of file size
   736                                  .size:
   737                                  endstruc
   738                                  
   739                                  attr_read_only      EQU      1h
   740                                  attr_hidden         EQU      2h
   741                                  attr_system         EQU      4h
   742                                  attr_volume_id      EQU      8h
   743                                  attr_directory      EQU     10h
   744                                  attr_archive        EQU     20h
   745                                  attr_device	    EQU     40h	; This is a VERY special bit.
   746                                  				;   NO directory entry on a disk EVER
   747                                  				;   has this bit set. It is set non-zero
   748                                  				;   when a device is found by GETPATH
   749                                  
   750                                  attr_all            EQU     attr_hidden+attr_system+attr_directory
   751                                                                          ; OR of hard attributes for FINDENTRY
   752                                  
   753                                  attr_ignore         EQU     attr_read_only+attr_archive
   754                                                                          ; ignore this(ese) attribute(s)
   755                                                                          ; during search first/next
   756                                  
   757                                  attr_changeable     EQU     attr_read_only+attr_hidden+attr_system+attr_archive
   758                                                                          ; changeable via CHMOD
   759                                  
   760                                  DIRFREE		equ	0E5h	; stored in dir_name[0] to indicate free slot
   761                                  
   762                                  ;============================================================================
   763                                  ; DPB.INC, MSDOS 6.0, 1991
   764                                  ;============================================================================
   765                                  ; 24/04/2019 - Retro DOS v4.0
   766                                  
   767                                  ; 19/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 3.3, 1987)
   768                                  ; 07/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 6.0, 1991)
   769                                  
   770                                  ; ---------------------------------------------------------------------------
   771                                  ;**	DPB - Drive Parameter Block
   772                                  ;
   773                                  ;	BUGBUG - this isn't authorative - it's my probably incomplete and
   774                                  ;	possibly inaccurate deductions from code study... - jgl
   775                                  ;
   776                                  ;	The DPB is DOS's main structure for describing block devices.
   777                                  ;	It contains info about the "Drive" intermingled with info about
   778                                  ;	the FAT file system which is presumably on the drive.  I don't know
   779                                  ;	how those fields are used if it's not the FAT file system - BUGBUG
   780                                  ;
   781                                  ;	The DPBs are statically allocated and chained off of DPBHead.
   782                                  ;	Users scan this chain looking for a match on DPB_DRIVE.
   783                                  ;	The DPBs are built at init time from info in the SYSDEV structure.
   784                                  ; ---------------------------------------------------------------------------
   785                                  
   786                                  struc	DPB
   787 00000000 ??                      .DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
   788 00000001 ??                      .UNIT:		resb 1		; Driver unit number of DPB
   789 00000002 ????                    .SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
   790 00000004 ??                      .CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
   791 00000005 ??                      .CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
   792 00000006 ????                    .FIRST_FAT:	resw 1		; Starting record of FATs
   793 00000008 ??                      .FAT_COUNT:	resb 1		; Number of FATs for this drive
   794 00000009 ????                    .ROOT_ENTRIES:	resw 1		; Number of directory entries
   795 0000000B ????                    .FIRST_SECTOR:	resw 1		; First sector of first cluster
   796 0000000D ????                    .MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
   797                                  ; MSDOS 3.3
   798                                  ;.FAT_SIZE:	resb 1		; Number of records occupied by FAT
   799                                  ; MSDOS 6.0
   800 0000000F ????                    .FAT_SIZE:	resw 1		; Number of records occupied by FAT
   801 00000011 ????                    .DIR_SECTOR:	resw 1		; Starting record of directory
   802 00000013 ????????                .DRIVER_ADDR:	resd 1		; Pointer to driver
   803 00000017 ??                      .MEDIA:		resb 1		; Media byte
   804 00000018 ??                      .FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
   805                                  				; check the first time this DPB is used
   806 00000019 ????????                .NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
   807 0000001D ????                    .NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
   808 0000001F ????                    .FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
   809                                  .size:
   810                                  endstruc
   811                                  
   812                                  DPBSIZ  EQU     DPB.size	; Size of the structure in bytes
   813                                  
   814                                  DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)
   815                                  
   816                                  ;                                                                          ;
   817                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   818                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   819                                  
   820                                  ;============================================================================
   821                                  ; SF.INC, MSDOS 6.0, 1991
   822                                  ;============================================================================
   823                                  ; 25/04/2019 - Retro DOS v4.0
   824                                  ; 07/07/2018 - Retro DOS v3.0
   825                                  
   826                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   827                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   828                                  ;                                                                          ;
   829                                  
   830                                  ; ---------------------------------------------------------------------------
   831                                  ;**	SF.INC - System File Table
   832                                  ;
   833                                  ;   AN000   version 4.00   Jan. 1988
   834                                  ;   AN003   PTM 3680 --  make NAME offset the same as before (<=3.30)
   835                                  ;   AN009   PTM 3839	 reorder SFT for MS WINDOWS
   836                                  ; ---------------------------------------------------------------------------
   837                                  ;**	System File Table SuperStructure
   838                                  ;
   839                                  ;	The system file table entries are allocated in contiguous groups.
   840                                  ;	There may be more than one such groups; the SF "superstructure"
   841                                  ;	tracks the groups.
   842                                  ; ---------------------------------------------------------------------------
   843                                  
   844                                  struc	SFT
   845 00000000 ????????                .SFLink:	resd 1
   846 00000004 ????                    .SFCount:	resw 1		; number of entries
   847 00000006 ????                    .SFTable:	resw 1		; beginning of array of the following
   848                                  .size:
   849                                  endstruc
   850                                  
   851                                  ; ---------------------------------------------------------------------------
   852                                  ;**	System file table entry
   853                                  ;
   854                                  ;	These are the structures which are at SFTABLE in the SF structure.
   855                                  ; ---------------------------------------------------------------------------
   856                                  
   857                                  ; 25/04/2019 - Retro DOS v4.0
   858                                  
   859                                  struc SF_ENTRY
   860 00000000 ????                    .sf_ref_count:	resw 1		; number of processes sharing entry
   861                                  				;   if FCB then ref count
   862 00000002 ????                    .sf_mode:	resw 1		; mode of access or high bit on if FCB
   863 00000004 ??                      .sf_attr:	resb 1		; attribute of file
   864 00000005 ????                    .sf_flags:	resw 1		;Bits 8-15
   865                                  				; Bit 15 = 1 if remote file
   866                                  				;	 = 0 if local file or device
   867                                  				; Bit 14 = 1 if date/time is not to be
   868                                  				;   set from clock at CLOSE.  Set by
   869                                  				;   FILETIMES and FCB_CLOSE.  Reset by
   870                                  				;   other reseters of the dirty bit
   871                                  				;   (WRITE)
   872                                  				; Bit 13 = Pipe bit (reserved)
   873                                  				;
   874                                  				; Bits 0-7 (old FCB_devid bits)
   875                                  				; If remote file or local file, bit
   876                                  				; 6=0 if dirty Device ID number, bits
   877                                  				; 0-5 if local file.
   878                                  				; bit 7=0 for local file, bit 7
   879                                  				;      =1 for local I/O device
   880                                  				; If local I/O device, bit 6=0 if EOF (input)
   881                                  				;		Bit 5=1 if Raw mode
   882                                  				;		Bit 0=1 if console input device
   883                                  				;		Bit 1=1 if console output device
   884                                  				;		Bit 2=1 if null device
   885                                  				;		Bit 3=1 if clock device
   886 00000007 ????????                .sf_devptr:	resd	1	; Points to DPB if local file, points
   887                                  				; to device header if local device,
   888                                  				; points to net device header if
   889                                  				; remote
   890 0000000B ????                    .sf_firclus:	resw	1	; First cluster of file (bit 15 = 0)
   891 0000000D ????                    .sf_time:	resw	1	; Time associated with file
   892 0000000F ????                    .sf_date:	resw	1	; Date associated with file
   893 00000011 ????????                .sf_size:	resd 	1	; Size associated with file
   894 00000015 ????????                .sf_position:	resd	1	; Read/Write pointer or LRU count for FCBs
   895                                  
   896                                  ; Starting here, the next 7 bytes may be used by the file system to store
   897                                  ; an ID
   898                                  
   899                                  ; 09/07/2018 - Retro DOS v3.0
   900                                  
   901                                  ; MSDOS 3.3 SF.INC, 1987
   902                                  ;.sf_cluspos:	resw	1	; Position of last cluster accessed
   903                                  ;.sf_lstclus	resw	1	; Last cluster accessed
   904                                  ;.sf_dirsec:	resw	1	; Sector number of directory sector
   905                                  ;				; for this file
   906                                  ;.sf_dirpos:	resb	1	; Offset of this entry in the above
   907                                  
   908                                  ; MSDOS 6.0, SF.INC, 1991
   909 00000019 ????                    .sf_cluspos:	resw	1	; Position of last cluster accessed
   910 0000001B ????????                .sf_dirsec:	resd	1	; Sector number of directory sector
   911                                  				; for this file
   912 0000001F ??                      .sf_dirpos:	resb	1	; Offset of this entry in the above
   913                                  
   914                                  ; End of 7 bytes of file-system specific info.
   915                                  
   916 00000020 <res Bh>                .sf_name:	resb	11	; 11 character name that is in the
   917                                  				; directory entry.  This is used by
   918                                  				; close to detect file deleted and
   919                                  				; disk changed errors.
   920                                  ; SHARING INFO
   921 0000002B ????????                .sf_chain:	resd	1	; link to next SF
   922 0000002F ????                    .sf_UID:	resw	1
   923 00000031 ????                    .sf_PID:	resw	1
   924 00000033 ????                    .sf_MFT:	resw	1
   925                                  
   926                                  ; MSDOS 6.0, SF.INC, 1991
   927 00000035 ????                    .sf_lstclus:	resw	1	;AN009; Last cluster accessed
   928 00000037 ????????                .sf_IFS_HDR:	resd	1
   929                                  
   930                                  .size:
   931                                  endstruc
   932                                  
   933                                  ; 20/07/2018
   934                                  ; MSDOS 3.3, SF.INC, 1987
   935                                  %define sf_netid   SF_ENTRY.sf_cluspos    ; byte
   936                                  %define sf_OpenAge SF_ENTRY.sf_position+2 ; word
   937                                  %define sf_LRU	   SF_ENTRY.sf_position	  ; word
   938                                  ; MSDOS 6.0, SF.INC, 1991
   939                                  %define sf_fsda	     SF_ENTRY.sf_cluspos  ; byte ;DOS 4.00
   940                                  %define sf_serial_ID SF_ENTRY.sf_firclus  ; word ;DOS 4.00
   941                                  
   942                                  ; 19/07/2018
   943                                  ; MSDOS 3.3, SF.INC, 1987
   944                                  
   945                                  sf_default_number  EQU	5
   946                                  
   947                                  ; Note that we need to mark an SFT as being busy for OPEN/CREATE.  This is
   948                                  ; because an INT 24 may prevent us from 'freeing' it.  We mark this as such
   949                                  ; by placing a -1 in the ref_count field.
   950                                  
   951                                  sf_busy EQU -1
   952                                  
   953                                  ; mode mask for FCB detection
   954                                  sf_isFCB		EQU	1000000000000000B
   955                                  
   956                                  ; Flag word masks
   957                                  sf_isnet		EQU	1000000000000000B
   958                                  sf_close_nodate 	EQU	0100000000000000B
   959                                  sf_pipe 		EQU	0010000000000000B
   960                                  sf_no_inherit		EQU	0001000000000000B
   961                                  sf_net_spool		EQU	0000100000000000B
   962                                  
   963                                  ; 25/04/2019
   964                                  sf_entry_size equ SF_ENTRY.size ; 59 (MSDOS 6.0)
   965                                  
   966                                  ; ---------------------------------------------------------------------------
   967                                  ; Local file/device flag masks
   968                                  ; ---------------------------------------------------------------------------
   969                                  
   970                                  devid_file_clean        EQU     40h     ; true if file and not written
   971                                  devid_file_mask_drive   EQU     3Fh     ; mask for drive number
   972                                  
   973                                  devid_device            EQU     80h     ; true if a device
   974                                  devid_device_EOF        EQU     40h     ; true if end of file reached
   975                                  devid_device_raw        EQU     20h     ; true if in raw mode
   976                                  devid_device_special    EQU     10h     ; true if special device
   977                                  devid_device_clock      EQU     08h     ; true if clock device
   978                                  devid_device_null       EQU     04h     ; true if null device
   979                                  devid_device_con_out    EQU     02h     ; true if console output
   980                                  devid_device_con_in     EQU     01h     ; true if consle input
   981                                  
   982                                  ; ---------------------------------------------------------------------------
   983                                  ; structure of devid field as returned by IOCTL is:
   984                                  ;
   985                                  ;       BIT     7   6   5   4   3   2   1   0
   986                                  ;             |---|---|---|---|---|---|---|---|
   987                                  ;             | I | E | R | S | I | I | I | I |
   988                                  ;             | S | O | A | P | S | S | S | S |
   989                                  ;             | D | F | W | E | C | N | C | C |
   990                                  ;             | E |   |   | C | L | U | O | I |
   991                                  ;             | V |   |   | L | K | L | T | N |
   992                                  ;             |---|---|---|---|---|---|---|---|
   993                                  ;       ISDEV = 1 if this channel is a device
   994                                  ;             = 0 if this channel is a disk file
   995                                  ;
   996                                  ;       If ISDEV = 1
   997                                  ;
   998                                  ;             EOF = 0 if End Of File on input
   999                                  ;             RAW = 1 if this device is in Raw mode
  1000                                  ;                 = 0 if this device is cooked
  1001                                  ;             ISCLK = 1 if this device is the clock device
  1002                                  ;             ISNUL = 1 if this device is the null device
  1003                                  ;             ISCOT = 1 if this device is the console output
  1004                                  ;             ISCIN = 1 if this device is the console input
  1005                                  ;
  1006                                  ;       If ISDEV = 0
  1007                                  ;             EOF = 0 if channel has been written
  1008                                  ;             Bits 0-5  are  the  block  device  number  for
  1009                                  ;                 the channel (0 = A, 1 = B, ...)
  1010                                  ; ---------------------------------------------------------------------------
  1011                                  
  1012                                  devid_ISDEV     EQU     80h
  1013                                  devid_EOF       EQU     40h
  1014                                  devid_RAW       EQU     20h
  1015                                  devid_SPECIAL   EQU     10H
  1016                                  devid_ISCLK     EQU     08h
  1017                                  devid_ISNUL     EQU     04h
  1018                                  devid_ISCOT     EQU     02h
  1019                                  devid_ISCIN     EQU     01h
  1020                                  
  1021                                  devid_block_dev EQU     1Fh             ; mask for block device number
  1022                                  
  1023                                  ;============================================================================
  1024                                  ; PDB.INC, MSDOS 6.0, 1991
  1025                                  ;============================================================================
  1026                                  ; 04/05/2019 - Retro DOS v4.0
  1027                                  ; 08/07/2018 - Retro DOS v3.0
  1028                                  
  1029                                  ; ---------------------------------------------------------------------------
  1030                                  ; BREAK <Process data block>
  1031                                  ; ---------------------------------------------------------------------------
  1032                                  ;**	Process data block (otherwise known as program header)
  1033                                  ;
  1034                                  
  1035                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
  1036                                  ;	can be rearranged here, ever. Reserved areas are probably safe
  1037                                  ;	for use.
  1038                                  ; ---------------------------------------------------------------------------
  1039                                  
  1040                                  FILPERPROC	EQU     20
  1041                                  
  1042                                  struc PDB	; Process_data_block
  1043 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
  1044 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
  1045 00000004 ??                                      resb 1
  1046 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
  1047 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
  1048 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
  1049 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
  1050 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
  1051 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
  1052 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
  1053 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
  1054 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
  1055 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
  1056 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
  1057 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
  1058 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
  1059 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
  1060 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
  1061 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
  1062 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
  1063 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
  1064                                  				;  an extended FCB
  1065                                  ;endstruc 	; MSDOS 3.3
  1066                                  	  	; MSDOS 6.0
  1067 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
  1068 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
  1069 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
  1070 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
  1071                                  endstruc
  1072                                  
  1073                                  ;============================================================================
  1074                                  ; EXE.INC, MSDOS 6.0, 1991
  1075                                  ;============================================================================
  1076                                  ; 04/05/2019 - Retro DOS v4.0
  1077                                  
  1078                                  ;**	EXE.INC - Definitions for the EXEC command and EXE files
  1079                                  ; ---------------------------------------------------------------------------
  1080                                  ; The following get used as arguments to the EXEC system call.  They indicate
  1081                                  ; whether or not the program is executed or whether or not a program header
  1082                                  ; gets created.
  1083                                  
  1084                                  exec_func_no_execute EQU 1	; no execute bit
  1085                                  exec_func_overlay    EQU 2	; overlay bit
  1086                                  
  1087                                  struc EXEC0
  1088 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
  1089 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
  1090 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
  1091 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
  1092                                  .size:
  1093                                  endstruc
  1094                                  
  1095                                  struc EXEC1
  1096 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
  1097 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
  1098 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
  1099 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
  1100 0000000E ????                    .SP:		resw 1		; stack pointer of program
  1101 00000010 ????                    .SS:		resw 1		; stack seg register of program
  1102 00000012 ????                    .IP:		resw 1		; entry point IP
  1103 00000014 ????                    .CS:		resw 1		; entry point CS
  1104                                  .size:
  1105                                  endstruc
  1106                                  
  1107                                  struc EXEC3
  1108 00000000 ????                    .load_addr:	resw 1		; seg address of load point
  1109 00000002 ????                    .reloc_fac:	resw 1		; relocation factor
  1110                                  endstruc
  1111                                  
  1112                                  ;**	Exit codes (in upper byte) for terminating programs
  1113                                  
  1114                                  EXIT_TERMINATE		EQU	0
  1115                                  EXIT_ABORT		EQU	0
  1116                                  EXIT_CTRL_C		EQU	1
  1117                                  EXIT_HARD_ERROR 	EQU	2
  1118                                  EXIT_KEEP_PROCESS	EQU	3
  1119                                  
  1120                                  ;**	EXE File Header Description
  1121                                  
  1122                                  struc EXE
  1123 00000000 ????                    .signature:   resw 1		; must contain 4D5A (yay zibo!)
  1124 00000002 ????                    .len_mod_512: resw 1		; low 9 bits of length
  1125 00000004 ????                    .pages:       resw 1		; number of 512b pages in file
  1126 00000006 ????                    .rle_count:   resw 1		; count of reloc entries
  1127 00000008 ????                    .par_dir:     resw 1		; number of paragraphs before image
  1128 0000000A ????                    .min_BSS:     resw 1		; minimum number of para of BSS
  1129 0000000C ????                    .max_BSS:     resw 1		; max number of para of BSS
  1130 0000000E ????                    .SS:          resw 1		; stack of image
  1131 00000010 ????                    .SP:          resw 1		; SP of image
  1132 00000012 ????                    .chksum:      resw 1		; checksum of file (ignored)
  1133 00000014 ????                    .IP:          resw 1		; IP of entry
  1134 00000016 ????                    .CS:          resw 1		; CS of entry
  1135 00000018 ????                    .rle_table:   resw 1		; byte offset of reloc table
  1136 0000001A ????                    .iov:         resw 1		; overlay number (0 for root)
  1137 0000001C ????????                .sym_tab:     resd 1		; offset of symbol table in file
  1138                                  .size:
  1139                                  endstruc
  1140                                  
  1141                                  exe_valid_signature     EQU 5A4Dh
  1142                                  exe_valid_old_signature EQU 4D5Ah
  1143                                  
  1144                                  ;**	EXE file symbol info definitions
  1145                                  
  1146                                  struc symbol_entry
  1147 00000000 ????????                .value:	resd 1
  1148 00000004 ????                    .type:	resw 1
  1149 00000006 ??                      .len:	resb 1
  1150 00000007 <res FFh>               .name:	resb 255
  1151                                  endstruc
  1152                                  
  1153                                  ;**	Data structure passed for ExecReady call
  1154                                  
  1155                                  struc ERStruc
  1156 00000000 ????                     .ER_Reserved:	resw	1	; reserved, should be zero
  1157 00000002 ????                     .ER_Flags:	resw	1
  1158 00000004 ????????                 .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
  1159 00000008 ????                     .ER_PSP:	resw	1	; PSP of the program
  1160 0000000A ????????                 .ER_StartAddr:	resd	1	; Start CS:IP of the program
  1161 0000000E ????????                 .ER_ProgSize:	resd	1	; Program size including PSP
  1162                                   .size:
  1163                                  endstruc
  1164                                  
  1165                                  ;** bit fields in ER_Flags
  1166                                  
  1167                                  ER_EXE		equ	0001h
  1168                                  ER_OVERLAY	equ	0002h
  1169                                  
  1170                                  
  1171                                  ;============================================================================
  1172                                  ; ARENA.INC, MSDOS 6.0, 1991
  1173                                  ;============================================================================
  1174                                  ; 24/04/2019 - Retro DOS v4.0
  1175                                  ; 04/08/2018 - Retro DOS v3.0
  1176                                  
  1177                                  ;BREAK <Memory arena structure>
  1178                                  
  1179                                  ;**	Arena Header
  1180                                  
  1181                                  struc ARENA
  1182 00000000 ??                      .SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
  1183 00000001 ????                    .OWNER:		resw 1		; owner of arena item
  1184 00000003 ????                    .SIZE:		resw 1		; size in paragraphs of item
  1185 00000005 ??????                  .RESERVED:	resb 3		; reserved
  1186 00000008 ????????????????        .NAME:		resb 8		; owner file name
  1187                                  .headersize:			
  1188                                  endstruc
  1189                                  
  1190                                  ; 20/05/2019 - Retro DOS v4.0
  1191                                  ARENAHEADERSIZE equ ARENA.headersize 
  1192                                  
  1193                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
  1194                                  ; and arena_owner_system are all equal to zero and are contained in DI.
  1195                                  ; Change them and change ALLOC.ASM.
  1196                                  
  1197                                  arena_owner_system  EQU 0               ; free block indication
  1198                                  
  1199                                  arena_signature_normal	EQU 4Dh		; valid signature, not end of arena
  1200                                  arena_signature_end     EQU 5Ah         ; valid signature, last block in arena
  1201                                  
  1202                                  FIRST_FIT	EQU	00000000B
  1203                                  BEST_FIT	EQU	00000001B
  1204                                  LAST_FIT	EQU	00000010B
  1205                                  
  1206                                  ; MSDOS 6.0
  1207                                  LOW_FIRST	EQU	00000000B	; M001
  1208                                  HIGH_FIRST	EQU	10000000B	; M001
  1209                                  HIGH_ONLY	EQU	01000000B	; M001
  1210                                  
  1211                                  LINKSTATE	EQU	00000001B	; M002
  1212                                  
  1213                                  HF_MASK		EQU	~HIGH_FIRST	; M001
  1214                                  HO_MASK		EQU	~HIGH_ONLY	; M001
  1215                                  
  1216                                  STRAT_MASK	EQU	HF_MASK & HO_MASK	; M001;
  1217                                  						; M026: used to mask of bits
  1218                                  						; M026: 6 & 7 of AllocMethod
  1219                                  
  1220                                  ;============================================================================
  1221                                  ; MI.INC, MSDOS 6.0, 1991
  1222                                  ;============================================================================
  1223                                  ; 07/07/2018 - Retro DOS v3.0
  1224                                  
  1225                                  ;BREAK <Machine instruction, flag definitions and character types>
  1226                                  
  1227                                  mi_INT		EQU	0CDh
  1228                                  mi_long_jmp	EQU	0EAh
  1229                                  mi_Long_CALL	EQU	09Ah
  1230                                  mi_Long_RET	EQU	0CBh
  1231                                  mi_Near_RET	EQU	0C3h
  1232                                  
  1233                                  ;			xxxxoditszxaxpxc
  1234                                  f_Overflow	EQU	0000100000000000B
  1235                                  f_Direction	EQU	0000010000000000B
  1236                                  f_Interrupt	EQU	0000001000000000B
  1237                                  f_Trace 	EQU	0000000100000000B
  1238                                  f_Sign		EQU	0000000010000000B
  1239                                  f_Zero		EQU	0000000001000000B
  1240                                  f_Aux		EQU	0000000000010000B
  1241                                  f_Parity	EQU	0000000000000100B
  1242                                  f_Carry 	EQU	0000000000000001B
  1243                                  
  1244                                  ;============================================================================
  1245                                  ; FILEMODE.INC, MSDOS 6.0, 1991
  1246                                  ;============================================================================
  1247                                  ; 13/07/2018 - Retro DOS v3.0
  1248                                  ; 29/04/2019 - Retro DOS v4.0
  1249                                  
  1250                                  ;**	Standard I/O file handles
  1251                                  
  1252                                  stdin       EQU     0
  1253                                  stdout      EQU     1
  1254                                  stderr      EQU     2
  1255                                  stdaux      EQU     3
  1256                                  stdprn      EQU     4
  1257                                  
  1258                                  ;**	File Modes
  1259                                  ; <Xenix subfunction assignments>  ; MSDOS 3.3 FILEMODE.INC
  1260                                  
  1261                                  open_for_read   EQU 0
  1262                                  open_for_write  EQU 1
  1263                                  open_for_both   EQU 2
  1264                                  
  1265                                  ; MSDOS 6.0
  1266                                  OPEN_FOR_BOTH	equ 2
  1267                                  EXEC_OPEN	equ 3	; access code of 3 indicates that open was 
  1268                                  				; made from exec
  1269                                  
  1270                                  access_mask	EQU 0Fh ; 09/08/2018
  1271                                  
  1272                                  SHARING_MASK	    equ 0F0h
  1273                                  SHARING_COMPAT	    equ 000h
  1274                                  SHARING_DENY_BOTH   equ 010h
  1275                                  SHARING_DENY_WRITE  equ 020h
  1276                                  SHARING_DENY_READ   equ 030h
  1277                                  SHARING_DENY_NONE   equ 040h
  1278                                  SHARING_NET_FCB     equ 070h
  1279                                  SHARING_NO_INHERIT  equ 080h
  1280                                  
  1281                                  ; 29/04/2019
  1282                                  
  1283                                  ;**	Extended Open Definitions
  1284                                  
  1285                                  RESERVED_BITS_MASK equ 0FE00h	; reserved bits for extended open flags
  1286                                  EXISTS_MASK	   equ 0Fh 	; "file exists" action field
  1287                                  NOT_EXISTS_MASK    equ 0F0h
  1288                                  
  1289                                  ;*	SF_MODE values
  1290                                  
  1291                                  AUTO_COMMIT_WRITE	equ 4000h
  1292                                  INT_24_ERROR		equ 2000h
  1293                                  
  1294                                  ;*	Flags in EXTOPEN_ON
  1295                                  
  1296                                  EXT_OPEN_ON		equ 01h
  1297                                  EXT_FILE_NOT_EXISTS	equ 04h
  1298                                  EXT_OPEN_I24_OFF	equ 02h
  1299                                  
  1300                                  ;*	Flags in EXTOPEN_FLAG
  1301                                  
  1302                                  ACTION_OPENED		equ 01h
  1303                                  ACTION_CREATED_OPENED	equ 02h
  1304                                  ACTION_REPLACED_OPENED	equ 03h
  1305                                  EXT_EXISTS_OPEN 	equ 01h
  1306                                  EXT_EXISTS_FAIL 	equ 00h
  1307                                  EXT_NEXISTS_CREATE	equ 10h
  1308                                  
  1309                                  ;**	Extended Open Structure
  1310                                  
  1311                                  struc EXT_OPEN_PARM
  1312 00000000 ????????                .SET_LIST:	resd 1
  1313 00000004 ????                    .NUM_OF_PARM:	resw 1
  1314                                  endstruc
  1315                                  
  1316                                  ;============================================================================
  1317                                  ; SYSCALL.INC, MSDOS 6.0, 1991
  1318                                  ;============================================================================
  1319                                  ; 29/04/2019 - Retro DOS v4.0
  1320                                  ; 09/07/2018 - Retro DOS v3.0 (SYSCALL.INC, MSDOS 3.3, 1987)
  1321                                  
  1322                                  ; <system call definitions>
  1323                                  
  1324                                  ABORT                           EQU 0   ;  0      0
  1325                                  STD_CON_INPUT                   EQU 1   ;  1      1
  1326                                  STD_CON_OUTPUT                  EQU 2   ;  2      2
  1327                                  STD_AUX_INPUT                   EQU 3   ;  3      3
  1328                                  STD_AUX_OUTPUT                  EQU 4   ;  4      4
  1329                                  STD_PRINTER_OUTPUT              EQU 5   ;  5      5
  1330                                  RAW_CON_IO                      EQU 6   ;  6      6
  1331                                  RAW_CON_INPUT                   EQU 7   ;  7      7
  1332                                  STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
  1333                                  STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
  1334                                  STD_CON_STRING_INPUT            EQU 10  ; 10      A
  1335                                  STD_CON_INPUT_STATUS            EQU 11  ; 11      B
  1336                                  STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
  1337                                  DISK_RESET                      EQU 13  ; 13      D
  1338                                  SET_DEFAULT_DRIVE               EQU 14  ; 14      E
  1339                                  FCB_OPEN                        EQU 15  ; 15      F
  1340                                  FCB_CLOSE                       EQU 16  ; 16     10
  1341                                  DIR_SEARCH_FIRST                EQU 17  ; 17     11
  1342                                  DIR_SEARCH_NEXT                 EQU 18  ; 18     12
  1343                                  FCB_DELETE                      EQU 19  ; 19     13
  1344                                  FCB_SEQ_READ                    EQU 20  ; 20     14
  1345                                  FCB_SEQ_WRITE                   EQU 21  ; 21     15
  1346                                  FCB_CREATE                      EQU 22  ; 22     16
  1347                                  FCB_RENAME                      EQU 23  ; 23     17
  1348                                  GET_DEFAULT_DRIVE               EQU 25  ; 25     19
  1349                                  SET_DMA                         EQU 26  ; 26     1A
  1350                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1351                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1352                                  ;                                                                          ;
  1353                                  GET_DEFAULT_DPB                 EQU 31  ; 31     1F
  1354                                  ;                                                                          ;
  1355                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1356                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1357                                  FCB_RANDOM_READ                 EQU 33  ; 33     21
  1358                                  FCB_RANDOM_WRITE                EQU 34  ; 34     22
  1359                                  GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
  1360                                  GET_FCB_POSITION                EQU 36  ; 36     24
  1361                                  SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
  1362                                  CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
  1363                                  FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
  1364                                  FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
  1365                                  PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
  1366                                  GET_DATE                        EQU 42  ; 42     2A
  1367                                  SET_DATE                        EQU 43  ; 43     2B
  1368                                  GET_TIME                        EQU 44  ; 44     2C
  1369                                  SET_TIME                        EQU 45  ; 45     2D
  1370                                  SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
  1371                                  ; Extended functionality group
  1372                                  GET_DMA                         EQU 47  ; 47     2F
  1373                                  GET_VERSION                     EQU 48  ; 48     30
  1374                                  KEEP_PROCESS                    EQU 49  ; 49     31
  1375                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1376                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1377                                  ;                                                                          ;
  1378                                  GET_DPB                         EQU 50  ; 50     32
  1379                                  ;                                                                          ;
  1380                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1381                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1382                                  SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
  1383                                  GET_INDOS_FLAG                  EQU 52  ; 52     34
  1384                                  GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
  1385                                  GET_DRIVE_FREESPACE             EQU 54  ; 54     36
  1386                                  CHAR_OPER                       EQU 55  ; 55     37
  1387                                  INTERNATIONAL                   EQU 56  ; 56     38
  1388                                  ; XENIX CALLS
  1389                                  ;   Directory Group
  1390                                  MKDIR                           EQU 57  ; 57     39
  1391                                  RMDIR                           EQU 58  ; 58     3A
  1392                                  CHDIR                           EQU 59  ; 59     3B
  1393                                  ;   File Group
  1394                                  CREAT                           EQU 60  ; 60     3C
  1395                                  OPEN                            EQU 61  ; 61     3D
  1396                                  CLOSE                           EQU 62  ; 62     3E
  1397                                  READ                            EQU 63  ; 63     3F
  1398                                  WRITE                           EQU 64  ; 64     40
  1399                                  UNLINK                          EQU 65  ; 65     41
  1400                                  LSEEK                           EQU 66  ; 66     42
  1401                                  CHMOD                           EQU 67  ; 67     43
  1402                                  IOCTL                           EQU 68  ; 68     44
  1403                                  XDUP                            EQU 69  ; 69     45
  1404                                  XDUP2                           EQU 70  ; 70     46
  1405                                  CURRENT_DIR                     EQU 71  ; 71     47
  1406                                  ;    Memory Group
  1407                                  ALLOC                           EQU 72  ; 72     48
  1408                                  DEALLOC                         EQU 73  ; 73     49
  1409                                  SETBLOCK                        EQU 74  ; 74     4A
  1410                                  ;    Process Group
  1411                                  EXEC                            EQU 75  ; 75     4B
  1412                                  EXIT                            EQU 76  ; 76     4C
  1413                                  _WAIT				EQU 77  ; 77     4D
  1414                                  FIND_FIRST                      EQU 78  ; 78     4E
  1415                                  ;   Special Group
  1416                                  FIND_NEXT                       EQU 79  ; 79     4F
  1417                                  ; SPECIAL SYSTEM GROUP
  1418                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1419                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1420                                  ;                                                                          ;
  1421                                  SET_CURRENT_PDB                 EQU 80  ; 80     50
  1422                                  GET_CURRENT_PDB                 EQU 81  ; 81     51
  1423                                  GET_IN_VARS                     EQU 82  ; 82     52
  1424                                  SETDPB                          EQU 83  ; 83     53
  1425                                  ;                                                                          ;
  1426                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1427                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1428                                  GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
  1429                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1430                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1431                                  ;                                                                          ;
  1432                                  DUP_PDB                         EQU 85  ; 85     55
  1433                                  ;                                                                          ;
  1434                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1435                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1436                                  RENAME                          EQU 86  ; 86     56
  1437                                  FILE_TIMES                      EQU 87  ; 87     57
  1438                                  ALLOCOPER			EQU 88	; 88	 58
  1439                                  ; Network extention system calls
  1440                                  GETEXTENDEDERROR		EQU 89	; 89	 59
  1441                                  CREATETEMPFILE			EQU 90	; 90	 5A
  1442                                  CREATENEWFILE			EQU 91	; 91	 5B
  1443                                  LOCKOPER			EQU 92	; 92	 5C Lock and Unlock
  1444                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1445                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1446                                  ;									   ;
  1447                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
  1448                                  					;	    CloseByName, CloseUser,
  1449                                  					;	    CloseUserProcess,
  1450                                  					;	    GetOpenFileList
  1451                                  ;									   ;
  1452                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1453                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1454                                  USEROPER			EQU 94	; 94	 5E Get and Set
  1455                                  ASSINGOPER			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
  1456                                  XNAMETRANS			EQU 96	; 96	 60
  1457                                  PATHPARSE			EQU 97	; 97	 61
  1458                                  GETCURRENTPSP			EQU 98	; 98	 62
  1459                                  HONGEUL 			EQU 99	; 99	 63
  1460                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1461                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1462                                  ;									   ;
  1463                                  SET_PRINTER_FLAG		EQU 100 ; 100	 64
  1464                                  ;									   ;
  1465                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1466                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1467                                  GETEXTCNTRY			EQU 101 ; 101	 65 
  1468                                  GETSETCDPG			EQU 102 ; 102	 66
  1469                                  EXTHANDLE			EQU 103 ; 103	 67
  1470                                  COMMIT				EQU 104 ; 104	 68
  1471                                  
  1472                                  ; 29/04/2019 - Retro DOS v4.0
  1473                                  ; (MSDOS 6.0, SYSCALL.INC, 1987)
  1474                                  
  1475                                  GetSetMediaID			EQU 105 ; 105	 69
  1476                                  IFS_IOCTL			EQU 107 ; 107	 6B
  1477                                  ExtOpen 			EQU 108 ; 108	 6C
  1478                                  
  1479                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1480                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1481                                  ;                                                                          ;
  1482                                  ;ifdef ROMEXEC
  1483                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
  1484                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
  1485                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
  1486                                  ;endif
  1487                                  ;                                                                          ;
  1488                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1489                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1490                                  
  1491                                  SET_OEM_HANDLER			EQU 248 ; 248    F8
  1492                                  ;OEM_C1				EQU 249 ; 249    F9
  1493                                  ;OEM_C2				EQU 250 ; 250    FA
  1494                                  ;OEM_C3				EQU 251 ; 251    FB
  1495                                  ;OEM_C4				EQU 252 ; 252    FC
  1496                                  ;OEM_C5				EQU 253 ; 253    FD
  1497                                  ;OEM_C6				EQU 254 ; 254    FE
  1498                                  ;OEM_C7				EQU 255 ; 255    FF
  1499                                  
  1500                                  ;============================================================================
  1501                                  ; VERSIONA.INC (MSDOS 6.0, 1991)
  1502                                  ;============================================================================
  1503                                  ; 24/04/2019 - Retro DOS 4.0
  1504                                  
  1505                                  ;MAJOR_VERSION	EQU     6
  1506                                  ;;MINOR_VERSION	EQU	00
  1507                                  ;MINOR_VERSION	EQU     21  ; MSDOS 6.21
  1508                                  
  1509                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  1510                                  ;MAJOR_VERSION	EQU     5
  1511                                  ;MINOR_VERSION	EQU     0
  1512                                  
  1513                                  ; 30/12/2022 - Retro DOS v4.2
  1514                                  MAJOR_VERSION	EQU     6
  1515                                  MINOR_VERSION	EQU     22
  1516                                  
  1517                                  ;============================================================================
  1518                                  ; INTNAT.INC, MSDOS 3.3, 1987
  1519                                  ;============================================================================
  1520                                  ; 09/07/2018 - Retro DOS 3.0
  1521                                  
  1522                                  ; Current structure of the data returned by the international call
  1523                                  
  1524                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  1525                                  .Date_tim_format:
  1526 00000000 ????                    		RESW 1		; 0-USA, 1-EUR, 2-JAP
  1527                                  .Currency_sym:
  1528 00000002 ??????????              		RESB 5		; Currency Symbol 5 bytes
  1529                                  .Thous_sep:
  1530 00000007 ????                    		RESB 2		; Thousands separator 2 bytes
  1531                                  .Decimal_sep:
  1532 00000009 ????                    		RESB 2		; Decimal separator 2 bytes
  1533                                  .Date_sep:
  1534 0000000B ????                    		RESB 2		; Date separator 2 bytes
  1535                                  .Time_sep:
  1536 0000000D ????                    		RESB 2		; Time separator 2 bytes
  1537                                  .Bit_field:	
  1538 0000000F ??                      		RESB 1		; Bit values
  1539                                                                     ;   Bit 0 = 0 if currency symbol first
  1540                                                                     ;         = 1 if currency symbol last
  1541                                                                     ;   Bit 1 = 0 if No space after currency symbol
  1542                                                                     ;         = 1 if space after currency symbol
  1543                                  .Currency_cents:
  1544 00000010 ??                      		RESB 	1	; Number of places after currency dec point
  1545                                  .Time_24:
  1546 00000011 ??                      		RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
  1547                                  .Map_call:
  1548 00000012 ????                    		RESW	1	; Address of case mapping call (DWORD)
  1549 00000014 ????                                    RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
  1550                                  				;  in pieces.
  1551                                  .Data_sep:
  1552 00000016 ????                    		RESB	2	; Data list separator character
  1553                                  .size:		
  1554                                  endstruc
  1555                                  
  1556                                  ; Max size of the block returned by the INTERNATIONAL call
  1557                                  
  1558                                  internat_block_max	EQU	32
  1559                                  
  1560                                  ;============================================================================
  1561                                  ; SYSVAR.INC (MSDOS 6.0, 1991)
  1562                                  ;============================================================================
  1563                                  ; 08/07/2018 - Retro DOS v3.0
  1564                                  
  1565                                  ;SysInitVars STRUC
  1566                                  struc SYSI
  1567 00000000 ????????                .DPB:	    resd 1		; DPB chain
  1568 00000004 ????????                .SFT:	    resd 1		; SFT chain
  1569 00000008 ????????                .CLOCK:	    resd 1		; CLOCK device
  1570 0000000C ????????                .CON:	    resd 1		; CON device
  1571 00000010 ????                    .MAXSEC:    resw 1		; maximum sector size
  1572 00000012 ????????                .BUF:	    resd 1		; points to Hashinitvar
  1573 00000016 ????????                .CDS:	    resd 1		; CDS list
  1574 0000001A ????????                .FCB:	    resd 1		; FCB chain
  1575 0000001E ????                    .Keep:	    resw 1		; keep count
  1576 00000020 ??                      .NUMIO:	    resb 1		; Number of block devices
  1577 00000021 ??                      .NCDS:	    resb 1		; number of CDS's
  1578 00000022 ????????                .DEV:	    resd 1		; device list
  1579                                  ; 09/07/2018
  1580                                  ; Above parameters are described in MSDOS 3.3 SYSVAR.INC (85/04/10)
  1581                                  ; Following parameters are used with MSDOS 6.0 (Retro DOS v4.0)
  1582 00000026 ????                    .ATTR:	    resw 1		; null device attribute word
  1583 00000028 ????                    .STRAT:	    resw 1		; null device strategy entry point
  1584 0000002A ????                    .INTER:	    resw 1		; null device interrupt entry point
  1585 0000002C ????????????????        .NAME:	    resb 8		; null device name
  1586 00000034 ??                      .SPLICE:    resb 1		; TRUE -> splicees being done
  1587 00000035 ????                    .IBMDOS_SIZE: resw 1		; DOS size in paragraphs
  1588 00000037 ????????                .IFS_DOSCALL@: resd 1		; IFS DOS service rountine entry
  1589 0000003B ????????                .IFS:	    resd 1		; IFS header chain
  1590 0000003F ????????                .BUFFERS:   resw 2		; BUFFERS= values (m,n)
  1591 00000043 ??                      .BOOT_DRIVE: resb 1		; boot drive A=1 B=2,..
  1592 00000044 ??                      .DWMOVE:    resb 1		; 1 if 386 machine
  1593 00000045 ????                    .EXT_MEM:   resw 1		; Extended memory size in KB.
  1594                                  endstruc
  1595                                  ;SysInitVars ENDS
  1596                                  
  1597                                  ;This is added for more information exchange between DOS, BIOS.
  1598                                  ;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
  1599                                  
  1600                                  ;SysInitVars_Ext struc
  1601                                  struc SYSI_EXT
  1602 00000000 ????????                .SysInitVars:	resd 1		; Points to the above structure.
  1603 00000004 ????????                .Country_Tab:	resd 1		; DOS_Country_cdpg_info
  1604                                  endstruc
  1605                                  ;SysInitVars_Ext ends
  1606                                  
  1607                                  ;============================================================================
  1608                                  ; IOCTL.INC - MSDOS 6.0 - 1991
  1609                                  ;============================================================================
  1610                                  ; 09/07/2018 - Retro DOS v3.0
  1611                                  
  1612                                  ;*** J.K.
  1613                                  ;General Guide -
  1614                                  ;Category Code:
  1615                                  ; 0... .... DOS Defined
  1616                                  ; 1... .... User defined
  1617                                  ; .xxx xxxx Code
  1618                                  
  1619                                  ;Function Code:
  1620                                  ; 0... .... Return error if unsupported
  1621                                  ; 1... .... Ignore if unsupported
  1622                                  ; .0.. .... Intercepted by DOS
  1623                                  ; .1.. .... Passed to driver
  1624                                  ; ..0. .... Sends data/commands to device
  1625                                  ; ..1. .... Quries data/info from device
  1626                                  ; ...x .... Subfunction
  1627                                  ;
  1628                                  ; Note that "Sends/queries" data bit is intended only to regularize the
  1629                                  ; function set.  It plays no critical role; some functions may contain both
  1630                                  ; command and query elements. The convention is that such commands are
  1631                                  ; defined as "sends data".
  1632                                  
  1633                                  ;*****************************;*
  1634                                  ; BLOCK DRIVERS 	      ;*
  1635                                  ;*****************************;*
  1636                                  
  1637                                  ; IOCTL SUB-FUNCTIONS
  1638                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1639                                  IOCTL_GET_DEVICE_INFO	EQU	0
  1640                                  IOCTL_SET_DEVICE_INFO	EQU	1
  1641                                  IOCTL_READ_HANDLE	EQU	2
  1642                                  IOCTL_WRITE_HANDLE	EQU	3
  1643                                  IOCTL_READ_DRIVE	EQU	4
  1644                                  IOCTL_WRITE_DRIVE	EQU	5
  1645                                  IOCTL_GET_INPUT_STATUS	EQU	6
  1646                                  IOCTL_GET_OUTPUT_STATUS EQU	7
  1647                                  IOCTL_CHANGEABLE?	EQU	8
  1648                                  IOCTL_DeviceLocOrRem?	EQU	9
  1649                                  IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
  1650                                  IOCTL_SHARING_RETRY	EQU	0Bh   ;11
  1651                                  GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
  1652                                  GENERIC_IOCTL		EQU	0Dh   ;13
  1653                                  ; (MSDOS 6.0 + MSDOS 3.3)
  1654                                  IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
  1655                                  IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
  1656                                  ; (MSDOS 6.0)
  1657                                  IOCTL_QUERY_HANDLE	EQU	10h   ;16
  1658                                  IOCTL_QUERY_BLOCK	EQU	11h   ;17
  1659                                  
  1660                                  ; GENERIC IOCTL CATEGORY CODES
  1661                                  IOC_OTHER		EQU	0	; Other device control J.K. 4/29/86
  1662                                  IOC_SE			EQU	1	; SERIAL DEVICE CONTROL
  1663                                  IOC_TC			EQU	2	; TERMINAL CONTROL
  1664                                  IOC_SC			EQU	3	; SCREEN CONTROL
  1665                                  IOC_KC			EQU	4	; KEYBOARD CONTROL
  1666                                  IOC_PC			EQU	5	; PRINTER CONTROL
  1667                                  IOC_DC			EQU	8	; DISK CONTROL (SAME AS RAWIO)
  1668                                  
  1669                                  ; GENERIC IOCTL SUB-FUNCTIONS
  1670                                  RAWIO			EQU	8
  1671                                  
  1672                                  ; RAWIO SUB-FUNCTIONS
  1673                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1674                                  GET_DEVICE_PARAMETERS	EQU	60H
  1675                                  SET_DEVICE_PARAMETERS	EQU	40H
  1676                                  READ_TRACK		EQU	61H
  1677                                  WRITE_TRACK		EQU	41H
  1678                                  VERIFY_TRACK		EQU	62H
  1679                                  FORMAT_TRACK		EQU	42H
  1680                                  ; (MSDOS 6.0)
  1681                                  GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
  1682                                  SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
  1683                                  GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
  1684                                  SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
  1685                                  SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00
  1686                                  
  1687                                  ; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
  1688                                  BUILD_DEVICE_BPB	EQU	000000001B
  1689                                  
  1690                                  ; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
  1691                                  INSTALL_FAKE_BPB	EQU	000000001B
  1692                                  ONLY_SET_TRACKLAYOUT	EQU	000000010B
  1693                                  TRACKLAYOUT_IS_GOOD	EQU	000000100B
  1694                                  
  1695                                  ; SPECIAL FUNCTION FOR FORMAT TRACK
  1696                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1697                                  STATUS_FOR_FORMAT	EQU	000000001B
  1698                                  ; (MSDOS 6.0)
  1699                                  DO_FAST_FORMAT		EQU	000000010B ;AN001;
  1700                                  
  1701                                  ; CODES RETURNED FROM FORMAT STATUS CALL
  1702                                  FORMAT_NO_ROM_SUPPORT	EQU	000000001B
  1703                                  FORMAT_COMB_NOT_SUPPORTED EQU	000000010B
  1704                                  
  1705                                  ; DEVICETYPE VALUES
  1706                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1707                                  MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
  1708                                  DEV_5INCH		EQU	0
  1709                                  DEV_5INCH96TPI		EQU	1
  1710                                  DEV_3INCH720KB		EQU	2
  1711                                  DEV_8INCHSS		EQU	3
  1712                                  DEV_8INCHDS		EQU	4
  1713                                  DEV_HARDDISK		EQU	5
  1714                                  DEV_OTHER		EQU	7
  1715                                  ; (MSDOS 6.0)
  1716                                  ;DEV_3INCH1440KB	EQU	7
  1717                                  DEV_3INCH2880KB		EQU	9
  1718                                  ; Retro DOS v2.0 - 26/03/2018
  1719                                  ;;DEV_TAPE		EQU	6
  1720                                  ;;DEV_ERIMO		EQU	8
  1721                                  ;DEV_3INCH2880KB	EQU	9
  1722                                  DEV_3INCH1440KB		EQU	10
  1723                                  
  1724                                  ; (MSDOS 3.3)
  1725                                  ;MAX_DEV_TYPE		EQU	7
  1726                                  
  1727                                  ; (MSDOS 6.0)
  1728                                  MAX_DEV_TYPE		EQU	10	; MAXIMUM DEVICE TYPE THAT WE
  1729                                  					; CURRENTLY SUPPORT.
  1730                                  struc A_SECTORTABLE
  1731 00000000 ????                    .ST_SECTORNUMBER:	resw	1
  1732 00000002 ????                    .ST_SECTORSIZE:		resw	1
  1733                                  .size:
  1734                                  endstruc
  1735                                  
  1736                                  ;============================================================================
  1737                                  ; DEVSYM.INC
  1738                                  ;============================================================================
  1739                                  ; 07/07/2018 - Retro DOS v3.0
  1740                                  ; 30/04/2019 - Retro DOS v4.0 (DEVSYM.INC, MSDOS 6.0, 1991)
  1741                                  
  1742                                  ;**	DevSym.inc - Device Symbols
  1743                                  
  1744                                  ; The device table list has the form:
  1745                                  struc	SYSDEV
  1746 00000000 ????????                .NEXT:		resd 1		;Pointer to next device header
  1747 00000004 ????                    .ATT:		resw 1		;Attributes of the device
  1748 00000006 ????                    .STRAT:		resw 1		;Strategy entry point
  1749 00000008 ????                    .INT:		resw 1		;Interrupt entry point
  1750 0000000A ????????????????        .NAME:		resb 8		;Name of device (only first byte used for block)
  1751                                  .size:
  1752                                  endstruc
  1753                                  
  1754                                  ;
  1755                                  ; ATTRIBUTE BIT MASKS
  1756                                  ;
  1757                                  ; CHARACTER DEVICES:
  1758                                  ;
  1759                                  ; BIT 15 -> MUST BE 1
  1760                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1761                                  ;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
  1762                                  ;     12 -> UNUSED
  1763                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
  1764                                  ;     10 -> MUST BE 0
  1765                                  ;      9 -> MUST BE 0
  1766                                  ;      8 -> UNUSED
  1767                                  ;      7 -> UNUSED
  1768                                  ;      6 -> UNUSED
  1769                                  ;      5 -> UNUSED
  1770                                  ;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
  1771                                  ;      3 -> 1 IF DEVICE IS CLOCK DEVICE
  1772                                  ;      2 -> 1 IF DEVICE IS NULL DEVICE
  1773                                  ;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
  1774                                  ;      0 -> 1 IF DEVICE IS CONSOLE INPUT
  1775                                  ;
  1776                                  ; BLOCK DEVICES:
  1777                                  ;
  1778                                  ; BIT 15 -> MUST BE 0
  1779                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1780                                  ;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
  1781                                  ;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
  1782                                  ;	    THE SAME PLACE.
  1783                                  ;     12 -> UNUSED
  1784                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
  1785                                  ;     10 -> MUST BE 0
  1786                                  ;      9 -> MUST BE 0
  1787                                  ;      8 -> UNUSED
  1788                                  ;      7 -> UNUSED
  1789                                  ;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
  1790                                  ;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
  1791                                  ;      5 -> UNUSED
  1792                                  ;      4 -> UNUSED
  1793                                  ;      3 -> UNUSED
  1794                                  ;      2 -> UNUSED
  1795                                  ;      1 -> UNUSED
  1796                                  ;      0 -> UNUSED
  1797                                  ;
  1798                                  
  1799                                  ;Attribute bit masks
  1800                                  DEVTYP	EQU     8000H           ;Bit 15 - 1 if Char, 0 if block
  1801                                  DEVIOCTL EQU    4000H           ;Bit 14 - CONTROL mode bit
  1802                                  ISFATBYDEV EQU  2000H           ;Bit 13 - Device uses FAT ID bytes, comp media.
  1803                                  
  1804                                  ; 09/07/2018 - Retro DOS (DEVSYM.INC, MSDOS 3.3, 1987) 
  1805                                  
  1806                                  OUTTILBUSY EQU	2000H		; OUTPUT UNTIL BUSY IS ENABLED
  1807                                  ISNET	   EQU	1000H		; BIT 12 - 1 IF A NET DEVICE, 0 IF
  1808                                  				;  NOT.  CURRENTLY BLOCK ONLY.
  1809                                  DEVOPCL    EQU	0800H		; BIT 11 - 1 IF THIS DEVICE HAS
  1810                                  				;  OPEN,CLOSE AND REMOVABLE MEDIA
  1811                                  				;  ENTRY POINTS, 0 IF NOT
  1812                                  
  1813                                  EXTENTBIT  EQU	0400H		; BIT 10 - CURRENTLY 0 ON ALL DEVS
  1814                                  				;  THIS BIT IS RESERVED FOR FUTURE USE
  1815                                  				;  TO EXTEND THE DEVICE HEADER BEYOND
  1816                                  				;  ITS CURRENT FORM.
  1817                                  
  1818                                  ; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
  1819                                  ;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
  1820                                  ;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
  1821                                  ;    MACHINES (FORMAT,CHKDSK,RECOVER,..).
  1822                                  
  1823                                  IOQUERY	EQU	0080H		;Bit 7 - Supports generic IOCtl query
  1824                                  
  1825                                  DEV320	EQU	0040H		;BIT 6 - FOR BLOCK DEVICES, THIS
  1826                                  				;DEVICE SUPPORTS SET/GET MAP OF
  1827                                  				;LOGICAL DRIVES, AND SUPPORTS
  1828                                  				;GENERIC IOCTL CALLS.
  1829                                  				;FOR CHARACTER DEVICES, THIS
  1830                                  				;DEVICE SUPPORTS GENERIC IOCTL.
  1831                                  				;THIS IS A DOS 3.2 DEVICE DRIVER.
  1832                                  
  1833                                  ISSPEC	EQU     0010H		;Bit 4 - This device is special ; 15/03/2018
  1834                                  ;ISIBM	EQU     0010H		;Bit 4 - This device is special
  1835                                  ISCLOCK EQU     0008H           ;Bit 3 - This device is the clock device.
  1836                                  ISNULL  EQU     0004H           ;Bit 2 - This device is the null device.
  1837                                  ISCOUT  EQU     0002H           ;Bit 1 - This device is the console output.
  1838                                  ISCIN   EQU     0001H           ;Bit 0 - This device is the console input.
  1839                                  
  1840                                  EXTDRVR	EQU	0002h		;BIT 1 - BLOCK DEVICE EXTENDED DRIVER
  1841                                  				; (MSDOS 6.0, DEVSYM.INC, 1991) ; 30/04/2019
  1842                                  
  1843                                  ;Static Reguest Header
  1844                                  struc	SRHEAD
  1845 00000000 ??                      .REQLEN:	resb 1		;Length in bytes of request block
  1846 00000001 ??                      .REQUNIT:	resb 1		;Device unit number
  1847 00000002 ??                      .REQFUNC:	resb 1		;Type of request
  1848 00000003 ????                    .REQSTAT:	resw 1		;Status Word
  1849 00000005 ????????????????                	resb 8		;Reserved for queue links
  1850                                  .size:
  1851                                  endstruc
  1852                                  
  1853                                  ;Status word masks
  1854                                  STERR   EQU     8000H           ;Bit 15 - Error
  1855                                  STBUI   EQU     0200H           ;Bit 9 - Buisy
  1856                                  STDON   EQU     0100H           ;Bit 8 - Done
  1857                                  STECODE EQU     00FFH           ;Error code
  1858                                  WRECODE EQU     0
  1859                                  
  1860                                  ;Function codes
  1861                                  DINITHL EQU     26              ;Size of init header
  1862                                  DMEDHL  EQU     15              ;Size of media check header
  1863                                  DBPBHL  EQU     22              ;Size of Get BPB header
  1864                                  DRDWRHL EQU     22              ;Size of RD/WR header
  1865                                  DRDNDHL EQU     14              ;Size of non destructive read header
  1866                                  DSTATHL EQU     13              ;Size of status header
  1867                                  DFLSHL  EQU     15              ;Size of flush header
  1868                                  
  1869                                  DEVINIT EQU     0               ;Initialization
  1870                                  DEVMDCH EQU     1               ;Media check
  1871                                  DEVBPB  EQU     2               ;Get BPB
  1872                                  DEVRDIOCTL EQU  3               ;IOCTL read
  1873                                  DEVRD   EQU     4               ;Read
  1874                                  DEVRDND EQU     5               ;Non destructive read no wait (character devs)
  1875                                  DEVIST  EQU     6               ;Input status
  1876                                  DEVIFL  EQU     7               ;Input flush
  1877                                  DEVWRT  EQU     8               ;Write
  1878                                  DEVWRTV EQU     9               ;Write with verify
  1879                                  DEVOST  EQU     10              ;Output status
  1880                                  DEVOFL  EQU     11              ;Output flush
  1881                                  DEVWRIOCTL EQU  12              ;IOCTL write
  1882                                  
  1883                                  ; 09/07/2018 - Retro DOS v3.0 (DEVSYM.INC, MSDOS 3.3, 1987) 
  1884                                  DEVOPN	EQU	13		;DEVICE OPEN
  1885                                  DEVCLS	EQU	14		;DEVICE CLOSE
  1886                                  DOPCLHL EQU	13		;SIZE OF OPEN/CLOSE HEADER
  1887                                  DEVRMD	EQU	15		;REMOVABLE MEDIA
  1888                                  ; 07/08/2018 - Retro DOS v3.0
  1889                                  REMHL	EQU	13		;SIZE OF REMOVABLE MEDIA HEADER
  1890                                  GENIOCTL EQU	19
  1891                                  
  1892                                  ; THE NEXT THREE ARE USED IN DOS 4.0
  1893                                  ;		     20
  1894                                  ;		     21
  1895                                  ;		     22
  1896                                  
  1897                                  DEVGETOWN      EQU   23		;GET DEVICE OWNER
  1898                                  DEVSETOWN      EQU   24		;SET DEVICE OWNER
  1899                                  ; 18/05/2019 - Retro DOS v4.0
  1900                                  IOCTL_QUERY    EQU   25		;Query generic ioctl support
  1901                                  
  1902                                  OWNHL	       EQU   13		;SIZE OF DEVICE OWNER HEADER
  1903                                  
  1904                                  DEVOUT	       EQU   16		; OUTPUT UNTIL BUSY.
  1905                                  DEVOUTL        EQU   DEVWRT	; LENGTH OF OUTPUT UNTIL BUSY
  1906                                  
  1907                                  ; ADDED FOR DOS 5.00
  1908                                  
  1909                                  ; GENERIC IOCTL REQUEST STRUCTURE
  1910                                  ;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
  1911                                  
  1912                                  struc IOCTL_REQ
  1913 00000000 <res Dh>                .SRHEAD:	resb SRHEAD.size
  1914                                  				; GENERIC IOCTL ADDITION.
  1915 0000000D ??                      .MAJORFUNCTION: resb 1		;FUNCTION CODE
  1916 0000000E ??                      .MINORFUNCTION: resb 1		;FUNCTION CATEGORY
  1917 0000000F ????                    .REG_SI:	resw 1
  1918 00000011 ????                    .REG_DI:	resw 1
  1919 00000013 ????????                .GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
  1920                                  .size: ; 07/08/2018
  1921                                  endstruc
  1922                                  
  1923                                  ; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
  1924                                  GEN_IOCTL_WRT_TRK EQU	40H
  1925                                  GEN_IOCTL_RD_TRK  EQU	60H
  1926                                  GEN_IOCTL_FN_TST  EQU	20H	; USED TO DIFF. BET READS AND WRTS
  1927                                  
  1928                                  ;; 32-bit absolute read/write input list structure
  1929                                  
  1930                                  struc ABS_32RW
  1931 00000000 ????????                .SECTOR_RBA:	resd 1		; relative block address
  1932 00000004 ????                    .ABS_RW_COUNT:	resw 1		; number of sectors to be transferred
  1933 00000006 ????????                .BUFFER_ADDR:	resd 1		; data addrress
  1934                                  .size:
  1935                                  endstruc
  1936                                  
  1937                                  ;; media ID info
  1938                                  
  1939                                  struc MEDIA_ID_INFO
  1940 00000000 ????                    .MEDIA_level:	resw	1	; info level
  1941 00000002 ????????                .MEDIA_Serial:	resd	1	; serial #
  1942 00000006 <res Bh>                .MEDIA_Label:	resb	11	; volume label
  1943 00000011 ????????????????        .MEDIA_System:	resb	8	; system type
  1944                                  .size:
  1945                                  endstruc
  1946                                  
  1947                                  ; equates for DOS34_FLAG
  1948                                  ; (BUGBUG: why are bits 0,1,3 and 4 not defined.)
  1949                                  
  1950                                  FROM_DISK_RESET       EQU   000000000100b   ;from disk reset
  1951                                  Force_I24_Fail	      EQU   000000100000b   ;form IFS CALL BACK
  1952                                  Disable_EOF_I24       EQU   000001000000b   ;disable EOF int24 for input status
  1953                                  DBCS_VOLID	      EQU   000010000000b   ;indicate from volume id
  1954                                  DBCS_VOLID2	      EQU   000100000000b   ;indicate 8th char is DBCS
  1955                                  CTRL_BREAK_FLAG       EQU   001000000000b   ;indicate control break is input
  1956                                  SEARCH_FASTOPEN       EQU   010000000000b   ;set fastopen flag for search
  1957                                  EXEC_AWARE_REDIR      EQU   100000000000b   ;M018: this bit is set by a redir 
  1958                                  					    ;M018: that knows how to handle 
  1959                                  					    ;M018: open for exec
  1960                                  
  1961                                  NO_FROM_DISK_RESET    EQU   ~FROM_DISK_RESET	;not from disk reset
  1962                                  NO_Force_I24_Fail     EQU   ~Force_I24_Fail	;not form IFS CALL BACK
  1963                                  NO_Disable_EOF_I24    EQU   ~Disable_EOF_I24
  1964                                  
  1965                                  ;============================================================================
  1966                                  ; ERROR.INC (MSDOS 6.0, 1991)
  1967                                  ;============================================================================
  1968                                  ; 16/07/2018 - Retro DOS v3.0 
  1969                                  
  1970                                  ;**	ERROR.INC - DOS Error Codes
  1971                                  ;
  1972                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
  1973                                  ;    return error codes through AX. If an error occurred then
  1974                                  ;    the carry bit will be set and the error code is in AX. If no error
  1975                                  ;    occurred then the carry bit is reset and AX contains returned info.
  1976                                  ;
  1977                                  ;    Since the set of error codes is being extended as we extend the operating
  1978                                  ;    system, we have provided a means for applications to ask the system for a
  1979                                  ;    recommended course of action when they receive an error.
  1980                                  ;
  1981                                  ;    The GetExtendedError system call returns a universal error, an error
  1982                                  ;    location and a recommended course of action. The universal error code is
  1983                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
  1984                                  ;    is issued.
  1985                                  
  1986                                  ;	2.0 error codes
  1987                                  
  1988                                  error_invalid_function		EQU	1
  1989                                  error_file_not_found		EQU	2
  1990                                  error_path_not_found		EQU	3
  1991                                  error_too_many_open_files	EQU	4
  1992                                  error_access_denied		EQU	5
  1993                                  error_invalid_handle		EQU	6
  1994                                  error_arena_trashed		EQU	7
  1995                                  error_not_enough_memory 	EQU	8
  1996                                  error_invalid_block		EQU	9
  1997                                  error_bad_environment		EQU	10
  1998                                  error_bad_format		EQU	11
  1999                                  error_invalid_access		EQU	12
  2000                                  error_invalid_data		EQU	13
  2001                                  ;**** reserved			EQU	14	; *****
  2002                                  error_invalid_drive		EQU	15
  2003                                  error_current_directory 	EQU	16
  2004                                  error_not_same_device		EQU	17
  2005                                  error_no_more_files		EQU	18
  2006                                  
  2007                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
  2008                                  
  2009                                  error_write_protect		EQU	19
  2010                                  error_bad_unit			EQU	20
  2011                                  error_not_ready 		EQU	21
  2012                                  error_bad_command		EQU	22
  2013                                  error_CRC			EQU	23
  2014                                  error_bad_length		EQU	24
  2015                                  error_seek			EQU	25
  2016                                  error_not_DOS_disk		EQU	26
  2017                                  error_sector_not_found		EQU	27
  2018                                  error_out_of_paper		EQU	28
  2019                                  error_write_fault		EQU	29
  2020                                  error_read_fault		EQU	30
  2021                                  error_gen_failure		EQU	31
  2022                                  
  2023                                  ;	the new 3.0 error codes reported through INT 24
  2024                                  
  2025                                  error_sharing_violation 	EQU	32
  2026                                  error_lock_violation		EQU	33
  2027                                  error_wrong_disk		EQU	34
  2028                                  error_FCB_unavailable		EQU	35
  2029                                  error_sharing_buffer_exceeded	EQU	36
  2030                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00  ;AN000;
  2031                                  error_handle_EOF		EQU	38    ; DOS 4.00  ;AN000;
  2032                                  error_handle_Disk_Full		EQU	39    ; DOS 4.00  ;AN000;
  2033                                  
  2034                                  ;	New OEM network-related errors are 50-79
  2035                                  
  2036                                  error_not_supported		EQU	50
  2037                                  
  2038                                  error_net_access_denied		EQU	65	;M028
  2039                                  
  2040                                  ;	End of INT 24 reportable errors
  2041                                  
  2042                                  error_file_exists		EQU	80
  2043                                  error_DUP_FCB			EQU	81	; *****
  2044                                  error_cannot_make		EQU	82
  2045                                  error_FAIL_I24			EQU	83
  2046                                  
  2047                                  ;	New 3.0 network related error codes
  2048                                  
  2049                                  error_out_of_structures 	EQU	84
  2050                                  error_already_assigned		EQU	85
  2051                                  error_invalid_password		EQU	86
  2052                                  error_invalid_parameter 	EQU	87
  2053                                  error_NET_write_fault		EQU	88
  2054                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00  ;AN000;
  2055                                  
  2056                                  ;	BREAK <Interrupt 24 error codes>
  2057                                  
  2058                                  ;**	Int24 Error Codes
  2059                                  
  2060                                  error_I24_write_protect 	EQU	0
  2061                                  error_I24_bad_unit		EQU	1
  2062                                  error_I24_not_ready		EQU	2
  2063                                  error_I24_bad_command		EQU	3
  2064                                  error_I24_CRC			EQU	4
  2065                                  error_I24_bad_length		EQU	5
  2066                                  error_I24_Seek			EQU	6
  2067                                  error_I24_not_DOS_disk		EQU	7
  2068                                  error_I24_sector_not_found	EQU	8
  2069                                  error_I24_out_of_paper		EQU	9
  2070                                  error_I24_write_fault		EQU	0Ah
  2071                                  error_I24_read_fault		EQU	0Bh
  2072                                  error_I24_gen_failure		EQU	0Ch
  2073                                  ; NOTE: Code 0DH is used by MT-DOS.
  2074                                  error_I24_wrong_disk		EQU	0Fh
  2075                                  
  2076                                  ;	THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
  2077                                  ;
  2078                                  ;	NOTE: ABORT is ALWAYS allowed
  2079                                  
  2080                                  Allowed_FAIL			EQU	00001000B
  2081                                  Allowed_RETRY			EQU	00010000B
  2082                                  Allowed_IGNORE			EQU	00100000B
  2083                                  
  2084                                  I24_operation			EQU	00000001B  ;Z if READ,NZ if Write
  2085                                  I24_area			EQU	00000110B  ; 00 if DOS
  2086                                  						   ; 01 if FAT
  2087                                  						   ; 10 if root DIR
  2088                                  						   ; 11 if DATA
  2089                                  I24_class			EQU	10000000B  ;Z if DISK, NZ if FAT or char
  2090                                  
  2091                                  ;	BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>
  2092                                  
  2093                                  ;**	The GetExtendedError call takes an error code and returns CLASS,
  2094                                  ;	ACTION and LOCUS codes to help programs determine the proper action
  2095                                  ;	to take for error codes that they don't explicitly understand.
  2096                                  
  2097                                  ;	Values for error CLASS
  2098                                  
  2099                                  errCLASS_OutRes 	EQU	1	; Out of Resource
  2100                                  errCLASS_TempSit	EQU	2	; Temporary Situation
  2101                                  errCLASS_Auth		EQU	3	; Permission problem
  2102                                  errCLASS_Intrn		EQU	4	; Internal System Error
  2103                                  errCLASS_HrdFail	EQU	5	; Hardware Failure
  2104                                  errCLASS_SysFail	EQU	6	; System Failure
  2105                                  errCLASS_Apperr 	EQU	7	; Application Error
  2106                                  errCLASS_NotFnd 	EQU	8	; Not Found
  2107                                  errCLASS_BadFmt 	EQU	9	; Bad Format
  2108                                  errCLASS_Locked 	EQU	10	; Locked
  2109                                  errCLASS_Media		EQU	11	; Media Failure
  2110                                  errCLASS_Already	EQU	12	; Collision with Existing Item
  2111                                  errCLASS_Unk		EQU	13	; Unknown/other
  2112                                  
  2113                                  ;	Values for error ACTION
  2114                                  
  2115                                  errACT_Retry		EQU	1	; Retry
  2116                                  errACT_DlyRet		EQU	2	; Delay Retry, retry after pause
  2117                                  errACT_User		EQU	3	; Ask user to regive info
  2118                                  errACT_Abort		EQU	4	; abort with clean up
  2119                                  errACT_Panic		EQU	5	; abort immediately
  2120                                  errACT_Ignore		EQU	6	; ignore
  2121                                  errACT_IntRet		EQU	7	; Retry after User Intervention
  2122                                  
  2123                                  ;	Values for error LOCUS
  2124                                  
  2125                                  errLOC_Unk		EQU	1	; No appropriate value
  2126                                  errLOC_Disk		EQU	2	; Random Access Mass Storage
  2127                                  errLOC_Net		EQU	3	; Network
  2128                                  errLOC_SerDev		EQU	4	; Serial Device
  2129                                  errLOC_Mem		EQU	5	; Memory
  2130                                  
  2131                                  ;============================================================================
  2132                                  ; INT2A.INC (MSDOS 6.0, 1991)
  2133                                  ;============================================================================
  2134                                  ; 04/05/2019 - Retro DOS v4.0
  2135                                  
  2136                                  ;**	Int 2A functions
  2137                                  ; ---------------------------------------------------------------------------
  2138                                  ;	Int 2A is an interface to the network code; it's also overloaded
  2139                                  ;		as a critical section handler since critical sections
  2140                                  ;		were originally created to support the net.
  2141                                  ; ---------------------------------------------------------------------------
  2142                                  
  2143                                  ; ---------------------------------------------------------------------------
  2144                                  ;**	This table was created by examining the source and may not be
  2145                                  ;	complete or completely accurate - JGL
  2146                                  ;
  2147                                  ;	M010	MD	8/31/90 - Added definition for AH = 5
  2148                                  
  2149                                  ;	(ah) = 0	installation check
  2150                                  ;			   (returns ah !=0 if installed)
  2151                                  ;	(ah) = 1	cooked net bios call
  2152                                  ;	(ah) = 3	query drive shared
  2153                                  ;			   (ds:si) = "n:" asciz string
  2154                                  ;	(ah) = 4	net bios
  2155                                  ;	       (al) = 0	   cooked net bios call
  2156                                  ;	       (al) = 1	   raw net bios call
  2157                                  ;	       (al) = 2	   ???
  2158                                  ;
  2159                                  ;	(ah) = 5	Get Net Adaptor Resources. CX returns the number of
  2160                                  ;			NCBs available/outstanding. DX returns the number of
  2161                                  ;			sessions. Supposedly, this is documented in an old
  2162                                  ;			IBM PC-LAN reference. Lotus Notes uses it. DOS LAN
  2163                                  ;			Manager 2.0 Enhanced responds to it. But it should
  2164                                  ;			not be used, as it is a hack, only to get Lotus
  2165                                  ;			Notes running.
  2166                                  ;
  2167                                  ;	(ah) = 80h	enter critical section
  2168                                  ;	(ah) = 81h	leave critical section
  2169                                  ;	(ah) = 82h	free all critical sections (Leave-all)
  2170                                  ;	(ah) = 84h	entering idle loop (don't understand how this works)
  2171                                  ; ---------------------------------------------------------------------------
  2172                                  
  2173                                  ;**	Critical section definitions
  2174                                  ; ---------------------------------------------------------------------------
  2175                                  ;	Although DOS is not designed to be reentrant there are some hacks
  2176                                  ;	which various programs use to make it so, in a limited fashion.
  2177                                  ;	Both WIN386 and some servers block copy a section of the DOS data
  2178                                  ;	area so that DOS can be reentered on behalf of another thread/program.
  2179                                  ;	DOS's global data structures, such as the memory arena, are not
  2180                                  ;	in this area, so critical section indicators are used to protect
  2181                                  ;	those areas.  DOS flags a critical section by issuing an INT_IBM
  2182                                  ;	(int 2Ah) at each critical section entry and exit.  Some clients
  2183                                  ;	(such as WIN386) just don't "context switch" the DOS when one
  2184                                  ;	of these is in effect, others, such as the IBM server, go ahead
  2185                                  ;	and reenter the DOS and if they get an int 2A to reenter the same
  2186                                  ;	critical section they then switch away from that second thread and
  2187                                  ;	let the first one finish and exit the section.
  2188                                  ; ---------------------------------------------------------------------------
  2189                                  
  2190                                  ; These below are subject to leave-all sections
  2191                                  critDisk    EQU     1			; Disk I/O critical section
  2192                                  critShare   EQU     1			; Sharer I/O critical section
  2193                                  critMem     EQU     1			; memory maintenance critical section
  2194                                  critSFT     EQU     1			; sft table allocation
  2195                                  critDevice  EQU     2			; Device I/O critical section
  2196                                  critNet     EQU     5			; network critical section
  2197                                  critIFS     EQU     6			; ifsfunc critical section
  2198                                  ; These below are not subject to leave-all sections
  2199                                  critASSIGN  EQU     8			; Assign has munged a system call
  2200                                  
  2201                                  ;============================================================================
  2202                                  ; MULT.INC (MSDOS 6.0, 1991)
  2203                                  ;============================================================================
  2204                                  ; 04/05/2019 - Retro DOS v4.0
  2205                                  
  2206                                  ;Break <Multiplex channels>
  2207                                  
  2208                                  ; ---------------------------------------------------------------------------
  2209                                  ; The current set of defined multiplex channels is (* means documented):
  2210                                  ;
  2211                                  ;   Channel(h)  Issuer          Receiver    Function
  2212                                  ;      00       server          PSPRINT     print job control
  2213                                  ;     *01       print/apps      PRINT       Queueing of files
  2214                                  ;      02       BIOS            REDIR       signal open/close of printers
  2215                                  ;
  2216                                  ;      05       command         REDIR       obtain text of net int 24 message
  2217                                  ;     *06       server/assign   ASSIGN      Install check
  2218                                  ;
  2219                                  ;      08       external driver IBMBIO      interface to internal routines
  2220                                  ;
  2221                                  ;      10       sharer/server   Sharer      install check
  2222                                  ;      11       DOS/server      Redir       install check/redirection funcs
  2223                                  ;      12       sharer/redir    DOS         dos functions and structure maint
  2224                                  ;      13       MSNET           MSNET       movement of NCBs
  2225                                  ;      13       external driver IBMBIO      Reset_Int_13, allows installation
  2226                                  ;                                           of alternative INT_13 drivers after
  2227                                  ;                                           boot_up
  2228                                  ;      14 (IBM) DOS             NLSFUNC     down load NLS country info,DOS 3.3
  2229                                  ;      14 (MS)  APPS            POPUP       MSDOS 4 popup screen functions
  2230                                  ;      15       APPS            MSCDEX      CD-ROM extensions interface
  2231                                  ;      16       WIN386          WIN386      Windows communications
  2232                                  ;      17       Clipboard       WINDOWS     Clipboard interface
  2233                                  ;     *18       Applications    MS-Manger   Toggle interface to manager
  2234                                  ;      19       Shell
  2235                                  ;      1A       Ansi.sys
  2236                                  ;      1B       Fastopen,Vdisk   IBMBIO     EMS INT 67H stub handler
  2237                                  ;
  2238                                  ;      40h      OS/2
  2239                                  ;      41h      Lanman
  2240                                  ;      42h      Lanman
  2241                                  ;      43h      Himem
  2242                                  ;                               AL = 20h    reserved for Mach 20 Himem support
  2243                                  ;                               AL = 30h    reserved for Himem external A20 code
  2244                                  ;      44h      Dosextender
  2245                                  ;      45H      Windows profiler
  2246                                  ;      46h      Windows/286 DOS extender
  2247                                  ;      47h      Basic Compiler Vn. 7.0
  2248                                  ;      48h      Doskey
  2249                                  ;      49h      DOS 5.x install 
  2250                                  ;      4Ah      Multi Purpose
  2251                                  ;                multMULTSWPDSK         0 - Swap Disk in drive A (BIOS)
  2252                                  ;                multMULTGETHMAPTR      1 - Get available HMA & ptr
  2253                                  ;                multMULTALLOCHMA       2 - Allocate HMA (bx == no of bytes)
  2254                                  ;                multMULTTASKSHELL      5 - Shell/switcher API
  2255                                  ;                multMULTRPLTOM         6 - Top Of Memory for RPL support
  2256                                  ;
  2257                                  ;                multSmartdrv           10h
  2258                                  ;                multMagicdrv           11h
  2259                                  ;      4Bh      Task Switcher API
  2260                                  ;
  2261                                  ;      4Ch      APPS            APM         Advanced power management
  2262                                  ;      4Dh      Kana Kanji Converter, MSKK
  2263                                  ;
  2264                                  ;      51h      ODI real mode support driver (for Chicago)
  2265                                  ;
  2266                                  ;      53h      POWER.EXE - used for broadcasting APM events    ; M036
  2267                                  ;      54h      POWER.EXE - used for POWER API                  ; M036
  2268                                  ;
  2269                                  ;      55h      COMMAND.COM
  2270                                  ;                multCOMFIRST           0 - API to determine whether 1st
  2271                                  ;                                           instance of command.com
  2272                                  ;                multCOMFIRSTROM        1 - API to determine whether 1st
  2273                                  ;                                           instance of ROM COMMAND
  2274                                  ;      56h      Sewell Development
  2275                                  ;               INTERLNK
  2276                                  ;
  2277                                  ;      57h      Iomega Corp.
  2278                                  ;
  2279                                  ;      ABh      Unspecified IBM use
  2280                                  ;      ACh      Graphics
  2281                                  ;      ADh      NLS (toronto)
  2282                                  ;      AEh
  2283                                  ;      AFh      Mode
  2284                                  ;      B0h      GRAFTABL        GRAFTABL
  2285                                  ;
  2286                                  ;      D7h      Banyan VINES
  2287                                  ; ---------------------------------------------------------------------------
  2288                                  
  2289                                  ;MUX 00-3F reserverd for IBM
  2290                                  ;MUX 80-BF reserverd for IBM
  2291                                  
  2292                                  ;MUX 40-7F reserved for Microsoft
  2293                                  
  2294                                  ;MUX C0-FF users
  2295                                  
  2296                                  MultSHARE   EQU     10h 		; sharer
  2297                                      ;	1   MFT_enter
  2298                                      ;	2   MFTClose
  2299                                      ;	3   MFTclU
  2300                                      ;	4   MFTCloseP
  2301                                      ;	5   MFTCloN
  2302                                      ;	6   set_block
  2303                                      ;	7   clr_block
  2304                                      ;	8   chk_block
  2305                                      ;	9   MFT_get
  2306                                      ;	10  ShSave
  2307                                      ;	11  ShChk
  2308                                      ;	12  ShCol
  2309                                      ;	13  ShCloseFile
  2310                                  
  2311                                  MultNET     EQU     11h 		; Network support
  2312                                  MultIFS     EQU     11h                 ; Network support
  2313                                      ;   1   IFS_RMDIR
  2314                                      ;   2   IFS_SEQ_RMDIR
  2315                                      ;   3   IFS_MKDIR
  2316                                      ;   4   IFS_SEQ_MKDIR
  2317                                      ;   5   IFS_CHDIR
  2318                                      ;   6   IFS_CLOSE
  2319                                      ;   7   IFS_COMMIT
  2320                                      ;   8   IFS_READ
  2321                                      ;   9   IFS_WRITE
  2322                                      ;   10  IFS_LOCK
  2323                                      ;   11  IFS_UNLOCK
  2324                                      ;   12  IFS_DISK_INFO
  2325                                      ;   13  IFS_SET_FILE_ATTRIBUTE
  2326                                      ;   14  IFS_SEQ_SET_FILE_ATTRIBUTE
  2327                                      ;   15  IFS_GET_FILE_INFO
  2328                                      ;   16  IFS_SEQ_GET_FILE_INFO
  2329                                      ;   17  IFS_RENAME
  2330                                      ;   18  IFS_SEQ_RENAME
  2331                                      ;   19  IFS_DELETE
  2332                                      ;   20  IFS_SEQ_DELETE
  2333                                      ;   21  IFS_OPEN
  2334                                      ;   22  IFS_SEQ_OPEN
  2335                                      ;   23  IFS_CREATE
  2336                                      ;   24  IFS_SEQ_CREATE
  2337                                      ;   25  IFS_SEQ_SEARCH_FIRST
  2338                                      ;   26  IFS_SEQ_SEARCH_NEXT
  2339                                      ;   27  IFS_SEARCH_FIRST
  2340                                      ;   28  IFS_SEARCH_NEXT
  2341                                      ;   29  IFS_ABORT
  2342                                      ;   30  IFS_ASSOPER
  2343                                      ;   31  Printer_SET_STRING
  2344                                      ;   32  IFSFlushBuf
  2345                                      ;   33  IFSBufWrite
  2346                                      ;   34  IFSResetEnvironment
  2347                                      ;   35  IFSSpoolCheck
  2348                                      ;   36  IFSSpoolClose
  2349                                      ;   37  IFSDeviceOper
  2350                                      ;   38  IFSSpoolEchoCheck
  2351                                      ;   39      - - -   Unused   - - -
  2352                                      ;   40      - - -   Unused   - - -
  2353                                      ;   41      - - -   Unused   - - -
  2354                                      ;   42  SERVER_DOSCALL_CLOSEFILES_FOR_UID
  2355                                      ;   43  DEVICE_IOCTL
  2356                                      ;   44  IFS_UPDATE_CB
  2357                                      ;   45  IFS_FILE_XATTRIBUTES
  2358                                      ;   46  IFS_XOPEN
  2359                                      ;   47  IFS_DEPENDENT_IOCTL
  2360                                  
  2361                                  MultDOS     EQU     12h 		; DOS call back
  2362                                      ;	1   DOS_CLOSE
  2363                                      ;	2   RECSET
  2364                                      ;	3   Get DOSGROUP
  2365                                      ;	4   PATHCHRCMP
  2366                                      ;	5   OUT
  2367                                      ;	6   NET_I24_ENTRY
  2368                                      ;	7   PLACEBUF
  2369                                      ;	8   FREE_SFT
  2370                                      ;	9   BUFWRITE
  2371                                      ;	10  SHARE_VIOLATION
  2372                                      ;	11  SHARE_ERROR
  2373                                      ;	12  SET_SFT_MODE
  2374                                      ;	13  DATE16
  2375                                      ;	14  SETVISIT
  2376                                      ;	15  SCANPLACE
  2377                                      ;	16  SKIPVISIT
  2378                                      ;	17  StrCpy
  2379                                      ;	18  StrLen
  2380                                      ;	19  UCase
  2381                                      ;	20  POINTCOMP
  2382                                      ;	21  CHECKFLUSH
  2383                                      ;	22  SFFromSFN
  2384                                      ;	23  GetCDSFromDrv
  2385                                      ;	24  Get_User_Stack
  2386                                      ;	25  GetThisDrv
  2387                                      ;	26  DriveFromText
  2388                                      ;	27  SETYEAR
  2389                                      ;	28  DSUM
  2390                                      ;	29  DSLIDE
  2391                                      ;	30  StrCmp
  2392                                      ;	31  initcds
  2393                                      ;	32  pjfnfromhandle
  2394                                      ;	33  $NameTrans
  2395                                      ;	34  CAL_LK
  2396                                      ;	35  DEVNAME
  2397                                      ;	36  Idle
  2398                                      ;   37  DStrLen
  2399                                      ;   38  NLS_OPEN      DOS 3.3
  2400                                      ;   39  $CLOSE        DOS 3.3
  2401                                      ;   40  NLS_LSEEK     DOS 3.3
  2402                                      ;   41  $READ         DOS 3.3
  2403                                      ;   42  FastInit      DOS 4.0
  2404                                      ;   43  NLS_IOCTL     DOS 3.3
  2405                                      ;   44  GetDevList    DOS 3.3
  2406                                      ;   45  NLS_GETEXT    DOS 3.3
  2407                                      ;   46  MSG_RETRIEVAL DOS 4.0
  2408                                      ;   47  FAKE_VERSION  DOS 4.0
  2409                                  
  2410                                  NLSFUNC     EQU     14h 		; NLSFUNC CALL , DOS 3.3
  2411                                      ;	0   NLSInstall
  2412                                      ;	1   ChgCodePage
  2413                                      ;	2   GetExtInfo
  2414                                      ;	3   SetCodePage
  2415                                      ;	4   GetCntry
  2416                                  
  2417                                  multANSI    EQU     1Ah                 ; ANSI multiplex number
  2418                                      ;   0   INSTALL_CHECK               ; install check for ANSI
  2419                                      ;   1   IOCTL_2F                    ; 2F interface to IOCTL
  2420                                      ;   2   DA_INFO_2F                  ; J.K. Information passing to ANSI.
  2421                                  
  2422                                  multMULT        EQU     4Ah
  2423                                  multMAGIC       EQU     256*multMULT + 11h
  2424                                  multMULTRPLTOM  EQU     06h
  2425                                  
  2426                                      ;   0   swap disk function for single floppy drive m/cs
  2427                                      ;       BIOS broadcasts with cx==0, and apps who handle
  2428                                      ;       swap disk messaging set cx == -1. BIOS sets dl == requested
  2429                                      ;       drive
  2430                                      ;
  2431                                      ;   1   Get available HMA & pointer to it. Returns in BX & ES:DI
  2432                                      ;   2   Allocate HMA. BX == number of bytes in HMA to be allocated
  2433                                      ;       returns pointer in ES:DI
  2434                                      ;
  2435                                      ;   3-4 currently used by nobody
  2436                                      ;   5   Switcher API
  2437                                      ;   6   Top of Memory for RPL.
  2438                                      ;           BIOS issues INT 2f AX=4a06 & DX = Top of Mem and any RPL
  2439                                      ;           code present in TOM should respond with a new TOM in DX
  2440                                      ;           to protect itself from MSLOAD & SYSINIT tromping over it.
  2441                                      ;           SYSINIT builds an arena with owner type 8 & name 'RPL' to
  2442                                      ;           protect the RPL code from COMMAND.COM transient protion.
  2443                                      ;           It is the responsibility of RPL program to release the mem.
  2444                                      ;   7   Reserved for PROTMAN support.
  2445                                      ;  10   smartdrv 4.0
  2446                                      ;  11   dblspace api
  2447                                      ;  12   MRCI     api
  2448                                      ;  13   dblspace/mrci stealth packet api
  2449                                  
  2450                                  MultAPM     EQU     4ch             ; Obselete ???
  2451                                      ;       00h     APM_VER_CHK
  2452                                      ;       01h     APM_SUS_SYS_REQ
  2453                                      ;       FFh     APM_SUS_RES_BATT_NOTIFY
  2454                                  
  2455                                  MultPWR_BRDCST  EQU     53h     ; Used by POWER.EXE to broadcast      ; M036
  2456                                  				;  APM events                         ; M036
  2457                                  MultPWR_API     EQU     54h     ; Used for accessing POWER.EXE's API  ; M036
  2458                                  
  2459                                  ;FASTOPEN is not chained through INT 2F   ; DOS 3.3 F.C.
  2460                                  ;	  it calls Multdos 42 to set up an entry routine address
  2461                                      ;	0   Install status  (reserved)
  2462                                      ;	1   Lookup
  2463                                      ;	2   Insert
  2464                                      ;	3   Delete
  2465                                      ;	4   Purge	    (reserved)
  2466                                  
  2467                                  ;============================================================================
  2468                                  ; FIND.INC (MSDOS 6.0, 1991)
  2469                                  ;============================================================================
  2470                                  ; 17/05/2019 - Retro DOS v4.0
  2471                                  ; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)
  2472                                  
  2473                                  ;Break	<find first/next buffer>
  2474                                  
  2475                                  struc find_buf
  2476 00000000 ??                      .drive:	    resb 1		; drive of search
  2477 00000001 <res Bh>                .name:	    resb 11		; formatted name
  2478 0000000C ??                      .sattr:	    resb 1		; attribute of search
  2479 0000000D ????                    .LastEnt:   resw 1		; LastEnt
  2480 0000000F ????                    .DirStart:  resw 1		; DirStart
  2481 00000011 ????????                .NETID:	    resb 4 ; MSDOS 6.0 	; Reserved for NET
  2482 00000015 ??                      .attr:	    resb 1		; attribute found
  2483 00000016 ????                    .time:	    resw 1		; time
  2484 00000018 ????                    .date:	    resw 1		; date
  2485 0000001A ????                    .size_l:    resw 1		; low(size)
  2486 0000001C ????                    .size_h:    resw 1		; high(size)
  2487 0000001E <res Dh>                .pname:	    resb 13		; packed name
  2488                                  .size:
  2489                                  endstruc
  2490                                  
  2491                                  ;============================================================================
  2492                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2493                                  ;============================================================================
  2494                                  ; 29/04/2019 - Retro DOS v4.0
  2495                                  ; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)
  2496                                  
  2497                                  ;Equates for COUNTRY INFORMATION.
  2498                                  SetCountryInfo	EQU	1	;country info
  2499                                  SetUcase	EQU	2	;uppercase table
  2500                                  SetLcase	EQU	3	;lowercase table (Reserved)
  2501                                  SetUcaseFile	EQU	4	;uppercase file spec table
  2502                                  SetFileList	EQU	5	;valid file character list
  2503                                  SetCollate	EQU	6	;collating sequence
  2504                                  SetDBCS 	EQU	7	;double byte character set
  2505                                  SetALL		EQU	-1	;all the entries
  2506                                  
  2507                                  ;DOS country and code page information table structure.
  2508                                  ;Internally, IBMDOS gives a pointer to this table.
  2509                                  ;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
  2510                                  ;this structure.
  2511                                  
  2512                                  struc  DOS_CCDPG	; DOS_country_cdpg_info
  2513 00000000 ????????????????        .ccInfo_reserved: 	resb 8	;reserved for internal use
  2514 00000008 <res 40h>               .ccPath_CountrySys:	resb 64 ;path and filename for country info
  2515 00000048 ????                    .ccSysCodePage:		resw 1	;system code page id
  2516 0000004A ????                    .ccNumber_of_entries:	resw 1  ; (default value = 6)
  2517 0000004C ??                      .ccSetUcase:		resb 1  ; (default value = SetUcase)
  2518 0000004D ????????                .ccUcase_ptr:		resd 1	;pointer to Ucase table
  2519                                  
  2520 00000051 ??                      .ccSetUcaseFile:	resb 1	; (default value = SetUcaseFile)
  2521 00000052 ????????                .ccFileUcase_ptr: 	resd 1	;pointer to File Ucase table
  2522                                  
  2523 00000056 ??                      .ccSetFileList:		resb 1 	; (default value = SetFileList)
  2524 00000057 ????????                .ccFileChar_ptr:	resd 1	;pointer to File char list table
  2525                                  
  2526 0000005B ??                      .ccSetCollate:		resb 1	; (default value = SetCollate)
  2527 0000005C ????????                .ccCollate_ptr:		resd 1	;pointer to collate table
  2528                                  
  2529                                  ; MSDOS 6.0
  2530 00000060 ??                      .ccSetDBCS:		resb 1	; (default value = SetDBCS)
  2531 00000061 ????????                .ccDBCS_ptr:		resd 1	; pointer to DBCS table
  2532                                  
  2533 00000065 ??                      .ccSetCountryInfo:	resb 1  ; (default value = SetCountryInfo)
  2534 00000066 ????                    .ccCountryInfoLen:	resw 1	;length of country info
  2535 00000068 ????                    .ccDosCountry:		resw 1	;system country code id
  2536 0000006A ????                    .ccDosCodePage:		resw 1	;system code page id
  2537 0000006C ????                    .ccDFormat:		resw 1	;date format
  2538 0000006E ??????????              .ccCurSymbol:		resb 5	;5 byte of (currency symbol+0)
  2539 00000073 ????                    .cc1000Sep:		resb 2	;2 byte of (1000 sep. + 0)
  2540 00000075 ????                    .ccDecSep:		resb 2	;2 byte of (Decimal sep. + 0)
  2541 00000077 ????                    .ccDateSep:		resb 2	;2 byte of (date sep. + 0)
  2542 00000079 ????                    .ccTimeSep:		resb 2	;2 byte of (time sep. + 0)
  2543 0000007B ??                      .ccCFormat:		resb 1	;currency format flags
  2544 0000007C ??                      .ccCSigDigits:		resb 1	;# of digits in currency
  2545 0000007D ??                      .ccTFormat:		resb 1	;time format
  2546 0000007E ????????                .ccMono_ptr:		resd 1	;monocase routine entry point
  2547 00000082 ????                    .ccListSep:		resb 2	;data list separator
  2548 00000084 <res Ah>                .ccReserved_area: 	resw 5	;reserved
  2549                                  .size:
  2550                                  endstruc
  2551                                  
  2552                                  ;Ucase table
  2553                                  struc CC_UCASE_TAB
  2554 00000000 ????                    .ccUcase_leng:		resw 1	; (default value = 128)
  2555 00000002 <res 80h>               .ccUcase_data:		resb 128
  2556                                  endstruc
  2557                                  
  2558                                  ;File Ucase table
  2559                                  struc CC_FILE_UCASE_TAB
  2560 00000000 ????                    .ccFileucase_leng:	resw 1	; (default value = 128)
  2561 00000002 <res 80h>               .ccFileucase_data:	resb 128
  2562                                  endstruc
  2563                                  
  2564                                  ;File char list
  2565                                  struc CC_FILE_CHAR_TAB
  2566 00000000 ????                    .ccFilechar_leng:	resw 1
  2567 00000002 <res 2Eh>               .ccFilechar_data:	resb 46
  2568                                  endstruc
  2569                                  
  2570                                  ;collate table
  2571                                  struc CC_COLLATE_TAB
  2572 00000000 ????                    .ccCollate_leng:	resw 1	; (default value = 128)
  2573 00000002 <res 100h>              .ccCollate_data:	resb 256
  2574                                  endstruc
  2575                                  
  2576                                  OLD_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDFormat - 10)
  2577                                  NEW_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDosCountry) ; 38
  2578                                  
  2579                                  ; 06/08/2018
  2580                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2581                                  
  2582                                  ;CAPITALIZATION equates
  2583                                  CAP_ONE_CHAR	equ	20H
  2584                                  CAP_STRING	equ	21H
  2585                                  CAP_ASCIIZ	equ	22H
  2586                                  CHECK_YES_NO	equ	23H
  2587                                  UPPER_TABLE	equ	80H
  2588                                  
  2589                                  ;NLS_YES	equ	59H  ; 'Y'
  2590                                  ;NLS_yes2	equ	79H  ; 'y' 	
  2591                                  ;NLS_NO		equ	4EH  ; 'N'	
  2592                                  ;NLS_no2	equ	6EH  ; 'n'	
  2593                                  
  2594                                  ;============================================================================
  2595                                  ; CURDIR.INC (MSDOS 6.0, 1991)
  2596                                  ;============================================================================
  2597                                  ; 25/04/2019 - Retro DOS v4.0
  2598                                  ; 09/07/2018 - Retro DOS v3.0 (CURDIR.INC, MSDOS 3.3, 1987)
  2599                                  
  2600                                  ;BREAK <Current directory list structure>
  2601                                  
  2602                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2603                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2604                                  ;									   ;
  2605                                  ; CDS items are used bu the internal routines to store cluster numbers and ;
  2606                                  ; network identifiers for each logical name.  The ID field is used dually, ;
  2607                                  ; both as net ID and for a cluster number for local devices.  In the case  ;
  2608                                  ; of local devices, the cluster number will be -1 if there is a potential  ;
  2609                                  ; of the disk being changed or if the path must be recracked.		   ;
  2610                                  ;
  2611                                  ;	Some pathnames have special preambles, such as
  2612                                  ;
  2613                                  ;		\\machine\sharename\...
  2614                                  ;	For these pathnames we can't allow ".." processing to back us
  2615                                  ;	up into the special front part of the name.  The CURDIR_END field
  2616                                  ;	holds the address of the seperator character which marks
  2617                                  ;	the split between the special preamble and the regular
  2618                                  ;	path list; ".." processing isn't allowed to back us up past
  2619                                  ;	(i.e., before) CURDIR_END
  2620                                  ;	For the root, it points at the leading /.  For net
  2621                                  ;	assignments it points at the end (nul) of the initial assignment:
  2622                                  ;	A:/	\\foo\bar	    \\foo\bar\blech\bozo
  2623                                  ;	  ^		 ^		     ^
  2624                                  
  2625                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
  2626                                  TEMPLEN 	EQU	DIRSTRLEN*2
  2627                                  
  2628                                  struc curdir	; curdir_list
  2629 00000000 <res 43h>               .text:		resb DIRSTRLEN		; text of assignment and curdir
  2630 00000043 ????                    .flags:		resw 1			; various flags
  2631 00000045 ????????                .devptr:	resd 1			; local pointer to DPB or net device
  2632 00000049 ????????                .ID:		resw 2			; cluster of current dir (net ID)
  2633 0000004D ????                    .user_word:	resw 1
  2634 0000004F ????                    .end:		resw 1			; index to ".." backup limit - see above
  2635                                  ; MSDOS 6.0
  2636 00000051 ??                      .type:		resb 1			; IFS drive (2=ifs, 4=netuse)
  2637 00000052 ????????                .ifs_hdr:	resd 1			; Ptr to File System Header
  2638 00000056 ????                    .fsda:		resb 2			; File System Dependent Data Area
  2639                                  .size:
  2640                                  endstruc
  2641                                  
  2642                                  curdirLen	EQU curdir.size	; 88	; Needed for screwed up
  2643                                  
  2644                                  %define curdir_netID curdir_ID  ; dword
  2645                                  
  2646                                  ;**	Flag values for CURDIR_FLAGS
  2647                                  
  2648                                  curdir_isnet	EQU	1000000000000000B
  2649                                  CURDIR_isifs	EQU	1000000000000000B ; MSDOS 6.0	
  2650                                  curdir_inuse	EQU	0100000000000000B
  2651                                  curdir_splice	EQU	0010000000000000B
  2652                                  curdir_local	EQU	0001000000000000B
  2653                                  
  2654                                  ;									   ;
  2655                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2656                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2657                                  
  2658                                  ;============================================================================
  2659                                  ; CPMFCB.INC (MSDOS 3.3, 1987)
  2660                                  ;============================================================================
  2661                                  ; 09/07/2018 - Retro DOS v3.0
  2662                                  
  2663                                  ;BREAK <File Control Block definition>
  2664                                  
  2665                                  ;
  2666                                  ; Field definition for FCBs
  2667                                  ; The FCB has the following structure:
  2668                                  ;
  2669                                  ;	+---------------------------+
  2670                                  ;	|   Drive indicator(byte)   |
  2671                                  ;	+---------------------------+
  2672                                  ;	|    Filename (8 chars)     |
  2673                                  ;	+---------------------------+
  2674                                  ;	|    Extension (3 chars)    |
  2675                                  ;	+---------------------------+
  2676                                  ;	|   Current Extent(word)    |
  2677                                  ;	+---------------------------+
  2678                                  ;	|    Record size (word)     |
  2679                                  ;	+---------------------------+
  2680                                  ;	|    File Size (2 words)    |
  2681                                  ;	+---------------------------+
  2682                                  ;	|	Date of write	    |
  2683                                  ;	+---------------------------+
  2684                                  ;	|	Time of write	    |
  2685                                  ;	+---------------------------+
  2686                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2687                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2688                                  ;									   ;
  2689                                  ;	+---------------------------+
  2690                                  ;	|   8 bytes reserved	    |
  2691                                  ;	+---------------------------+
  2692                                  ;									   ;
  2693                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2694                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2695                                  ;	|    next record number     |
  2696                                  ;	+---------------------------+
  2697                                  ;	|   random record number    |
  2698                                  ;	+---------------------------+
  2699                                  ;
  2700                                  
  2701                                  struc	SYS_FCB
  2702 00000000 ??                      .drive:	resb 1
  2703 00000001 ????????????????        .name:	resb 8
  2704 00000009 ??????                  .ext:	resb 3
  2705 0000000C ????                    .EXTENT: resw 1
  2706 0000000E ????                    .RECSIZ: resw 1			; Size of record (user settable)
  2707 00000010 ????                    .FILSIZ: resw 1			; Size of file in bytes; used with the
  2708                                  				; following word
  2709 00000012 ????                    .DRVBP:	resw 1			; BP for SEARCH FIRST and SEARCH NEXT
  2710 00000014 ????                    .FDATE:	resw 1			; Date of last writing
  2711 00000016 ????                    .FTIME:	resw 1			; Time of last writing
  2712                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2713                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2714                                  ;									   ;
  2715 00000018 ????????????????        .reserved: resb 8		; RESERVED
  2716                                  ;									   ;
  2717                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2718                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2719 00000020 ??                      .NR:	resb 1			; Next record
  2720 00000021 ????????                .RR:	resb 4			; Random record
  2721                                  .size:
  2722                                  endstruc
  2723                                  
  2724                                  FILDIRENT EQU SYS_FCB.FILSIZ	; Used only by SEARCH FIRST and SEARCH
  2725                                  				; NEXT
  2726                                  ; 20/07/2018
  2727                                  %define fcb_sfn	SYS_FCB.reserved ; byte
  2728                                  
  2729                                  ; Note that fcb_net_handle, fcb_nsl_drive, fcb_nsld_drive and fcb_l_drive
  2730                                  ; all must point to the same byte.  Otherwise, the FCBRegen will fail.
  2731                                  ; NOTE about this byte (fcb_nsl_drive)
  2732                                  ;   The high two bits of this byte are used as follows to indicate the FCB type
  2733                                  ;	00 means a local file or device with sharing loaded
  2734                                  ;	10 means a remote (network) file
  2735                                  ;	01 means a local file with no sharing loaded
  2736                                  ;	11 means a local device with no sharing loaded
  2737                                  
  2738                                  ; 20/07/2018
  2739                                  
  2740                                  ;
  2741                                  ; Network FCB
  2742                                  ;
  2743                                  
  2744                                  %define fcb_net_drive	SYS_FCB.reserved+1  ; byte
  2745                                  %define fcb_net_handle	SYS_FCB.reserved+2  ; word
  2746                                  %define fcb_netID	SYS_FCB.reserved+4  ; dword		
  2747                                  
  2748                                  ;
  2749                                  ; No sharing local file FCB
  2750                                  ;
  2751                                  
  2752                                  %define fcb_nsl_drive	SYS_FCB.reserved+1  ; byte
  2753                                  %define fcb_nsl_bits	SYS_FCB.reserved+2  ; byte	
  2754                                  %define fcb_nsl_firclus SYS_FCB.reserved+3  ; word	
  2755                                  %define fcb_nsl_dirsec	SYS_FCB.reserved+5  ; word
  2756                                  %define fcb_nsl_dirpos  SYS_FCB.reserved+7  ; byte
  2757                                  
  2758                                  ;
  2759                                  ; No sharing local device FCB
  2760                                  ;
  2761                                  
  2762                                  %define fcb_nsld_drive	SYS_FCB.reserved+1  ; byte	
  2763                                  %define fcb_nsld_drvptr SYS_FCB.reserved+2  ; dword
  2764                                  
  2765                                  ;
  2766                                  ; Sharing local FCB
  2767                                  ;
  2768                                  
  2769                                  %define fcb_l_drive	SYS_FCB.reserved+1  ; byte
  2770                                  %define fcb_l_firclus	SYS_FCB.reserved+2  ; word
  2771                                  %define fcb_l_mfs	SYS_FCB.reserved+4  ; word
  2772                                  %define fcb_l_attr	SYS_FCB.reserved+6  ; byte
  2773                                  
  2774                                  ;
  2775                                  ; Bogusness:  the four cases are:
  2776                                  ;
  2777                                  ;   local file	    00
  2778                                  ;   local device    40
  2779                                  ;   local sharing   C0
  2780                                  ;   network	    80
  2781                                  ;
  2782                                  ; Since sharing and network collide, we cannot use a test instruction for
  2783                                  ; deciding whether a network or a share check in involved
  2784                                  ;
  2785                                  FCBDEVICE   EQU 040h
  2786                                  FCBNETWORK  EQU 080h
  2787                                  FCBSHARE    EQU 0C0h
  2788                                  
  2789                                  ; FCBSPECIAL must be able to mask off both net and share
  2790                                  FCBSPECIAL  EQU 080h
  2791                                  FCBMASK     EQU 0C0h
  2792                                  
  2793                                  ;============================================================================
  2794                                  ; FASTOPEN.INC, MSDOS 6.0, 1991
  2795                                  ;============================================================================
  2796                                  ; 11/07/2018 - Retro DOS v3.0
  2797                                  ; 25/04/2019 - Retro DOS v4.0
  2798                                  
  2799                                  struc FEI	; FASTOPEN_EXTENDED_INFO
  2800 00000000 ??                      .dirpos:	resb 1
  2801 00000001 ????????                .dirsec:	resd 1 ; MSDOS 6.0
  2802                                  ;.dirsec:	resw 1 ; MSDOS 3.3
  2803 00000005 ????                    .clusnum:	resw 1
  2804 00000007 ????                    .lastent:	resw 1	; for search first ; MSDOS 6.0
  2805 00000009 ????                    .dirstart:	resw 1	; for search first ; MSDOS 6.0
  2806                                  .size:
  2807                                  endstruc
  2808                                  
  2809                                  ; 23/07/2018
  2810                                  ;FASTOPEN NAME CACHING Subfunctions
  2811                                  FONC_Look_up	equ	1
  2812                                  FONC_insert	equ	2
  2813                                  FONC_delete	equ	3
  2814                                  FONC_update	equ	4
  2815                                  FONC_purge	equ	5	;reserved for the future use.
  2816                                  FONC_Rename	equ	6	;AN001
  2817                                  
  2818                                  ; 27/07/2018
  2819                                  ;FastOpen Data Structure
  2820                                  struc fastopen_entry	;Fastopen Entry pointer in DOS
  2821 00000000 ????                    .entry_size:	resw 1	; = 4	; size of the following
  2822 00000002 ????????                .name_caching:	resd 1
  2823                                  ; MSDOS 6.0
  2824                                  ;.fatchain_caching: resd 1	;reserved for future use
  2825                                  .size:
  2826                                  endstruc
  2827                                  
  2828                                  ; 27/07/2018
  2829                                  ;Equates used in DOS.
  2830                                  FastOpen_Set	       equ     00000001b
  2831                                  FastOpen_Reset	       equ     11111110b
  2832                                  Lookup_Success	       equ     00000010b
  2833                                  Lookup_Reset	       equ     11111101b
  2834                                  Special_Fill_Set       equ     00000100b
  2835                                  Special_Fill_Reset     equ     11111011b
  2836                                  No_Lookup	       equ     00001000b
  2837                                  Set_For_Search	       equ     00010000b	;DCR 167
  2838                                  
  2839                                  ; 09/08/2018 
  2840                                  ; (FASTXXXX.INC, MSDOS 6.0, 1991)
  2841                                  ; Fastxxx equates
  2842                                  FastOpen_ID	   equ	   1
  2843                                  FastSeek_ID	   equ	   2
  2844                                  Fast_yes	   equ	   10000000B	 ; fastxxx flag
  2845                                  
  2846                                  ;Structure definitions
  2847                                  ;
  2848                                  struc Fasttable_Entry	 ; Fastxxx  Entry pointer in DOS
  2849 00000000 ????                    .Fast_Entry_Num: resw 1	 ; number of entries
  2850 00000002 ????????                .FastOpen_Seek:	 resd 1	 ; fastopen & fastseek entry address
  2851                                  endstruc
  2852                                  
  2853                                  ;============================================================================
  2854                                  ; LOCK.INC, MSDOS 6.0, 1991
  2855                                  ;============================================================================
  2856                                  ; 14/07/2018 - Retro DOS v3.0
  2857                                  
  2858                                  ;**	LOCK.INC - Definitions for Record Locking
  2859                                  
  2860                                  ;**	LOCK functions
  2861                                  
  2862                                  LOCK_ALL	    equ    0
  2863                                  UNLOCK_ALL	    equ    1
  2864                                  LOCK_MUL_RANGE	    equ    2
  2865                                  UNLOCK_MUL_RANGE    equ    3
  2866                                  LOCK_READ	    equ    4
  2867                                  WRITE_UNLOCK	    equ    5
  2868                                  LOCK_ADD	    equ    6
  2869                                  
  2870                                  ;**	Structure for Lock buffer
  2871                                  
  2872                                  struc LockBuf
  2873 00000000 ????????                .Lock_position:	resd 1		; file position for LOCK
  2874 00000004 ????????                .Lock_length:	resd 1		; number of bytes to LOCK
  2875                                  endstruc
  2876                                  
  2877                                  ;============================================================================
  2878                                  ; DPL.ASM, MSDOS 6.0, 1991
  2879                                  ;============================================================================
  2880                                  ; 04/08/2018 - Retro DOS v3.0
  2881                                  
  2882                                  ; (SRVCALL.ASM)
  2883                                  
  2884                                  struc DPL
  2885 00000000 ????                    .AX:	resw	1	; AX register
  2886 00000002 ????                    .BX:	resw	1	; BX register
  2887 00000004 ????                    .CX:	resw	1	; CX register
  2888 00000006 ????                    .DX:	resw	1	; DX register
  2889 00000008 ????                    .SI:	resw	1	; SI register
  2890 0000000A ????                    .DI:	resw	1	; DI register
  2891 0000000C ????                    .DS:	resw	1	; DS register
  2892 0000000E ????                    .ES:	resw	1	; ES register
  2893 00000010 ????                    .rsrvd: resw	1	; Reserved
  2894 00000012 ????                    .UID:	resw	1	; User (Machine) ID (0 = local macine)
  2895 00000014 ????                    .PID:	resw	1	; Process ID (0 = local user PID)
  2896                                  .size:
  2897                                  endstruc
  2898                                   
  2899                                  ;----------------------------------------------------------------------------
  2900                                  ; DOSDATA
  2901                                  ;----------------------------------------------------------------------------
  2902                                  ;============================================================================
  2903                                  ; 24/04/2019 - Retro DOS v4.0
  2904                                  
  2905                                  DosDataSg equ 3 ; DOS Data Segment address (dw in 'retrodos4.s')
  2906                                  		; ((just after resident IO.SYS code&data))
  2907                                  
  2908                                  ;============================================================================
  2909                                  ; WIN386.INC, MSDOS 6.0, 1991
  2910                                  ;============================================================================
  2911                                  ; 24/04/2019 - Retro DOS 4.0
  2912                                  
  2913                                  ;
  2914                                  ;  Symbols and structures relating to WIN386 support.
  2915                                  ;
  2916                                  ;  Used by files in both the DOS and the BIOS.
  2917                                  ;
  2918                                  ;  Created: 7-13-89 by MRW
  2919                                  ;
  2920                                  
  2921                                  ; WIN386 broadcast int 2fh multiplex number and subfunction numbers
  2922                                  
  2923                                  MultWin386		equ     16h	; Int 2f multiplex number
  2924                                  
  2925                                  Win386_Init		equ	05h	; Win386 initialization
  2926                                  Win386_Exit		equ	06h	; Win386 exit
  2927                                  Win386_Devcall		equ	07h	; Win386 device call out
  2928                                  Win386_InitDone		equ	08h	; Win386 initialization is complete
  2929                                  
  2930                                  ; When Win386_Devcall is broadcast, BX is the Device ID. DOS must 
  2931                                  ; answer call outs from the DOSMGR
  2932                                  
  2933                                  Win386_DOSMGR		equ	15H
  2934                                  
  2935                                  ; The following structures are used to communicate instance data to 
  2936                                  ; Win386 from the DOS and the BIOS. See Win386 API documentation
  2937                                  ; (chapter 3, "Call Out Interfaces") for further description.
  2938                                  
  2939                                  struc Win386_SIS	; Startup Info Structure
  2940 00000000 ????                     .Version:		resb	2	; db 3, 0
  2941 00000002 ????????                 .Next_Dev_Ptr:		resd	1	; pointer to next SIS in list
  2942 00000006 ????????                 .Virt_Dev_File_Ptr:	resd	1
  2943 0000000A ????????                 .Reference_Data:	resd	1
  2944 0000000E ????????                 .Instance_Data_Ptr:	resd	1	; pointer to instance data array
  2945                                  endstruc
  2946                                  
  2947                                  size_of_Win386_SIS equ 18 ; 24/04/2019 - Retro DOS v4.0
  2948                                  
  2949                                  struc Win386_IIS	; Instance Item Structure
  2950 00000000 ????????                .Ptr:			resd	1	; pointer to an instance item
  2951 00000004 ????                    .Size:			resw	1	; size of an instance item
  2952                                  endstruc
  2953                                  
  2954                                  size_of_Win386_IIS equ 6 ; 24/04/2019 - Retro DOS v4.0
  2955                                  
  2956                                  ;Win386 DOSMGR function return values to indicate operation done
  2957                                  
  2958                                  WIN_OP_DONE		equ	0B97Ch	; 
  2959                                  DOSMGR_OP_DONE		equ	0A2ABh	;
  2960                                  
  2961                                  ;M021
  2962                                  ; WInoldap callout multiplex number
  2963                                  
  2964                                  WINOLDAP		equ	46h	;
  2965                                  
  2966                                  ;============================================================================
  2967                                  ;----------------------------------------------------------------------------
  2968                                  ; DOSCODE
  2969                                  ;----------------------------------------------------------------------------
  2970                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  2971                                  
  2972                                  ;============================================================================
  2973                                  ; MSHEAD.ASM (MSDOS 6.0, 1991)
  2974                                  ;============================================================================
  2975                                  ; 16/07/2018 - Retro DOS 3.0
  2976                                  ;----------------------------------------------------------------------------
  2977                                  ; 24/04/2019 - Retro DOS 4.0
  2978                                  
  2979                                  ; MSDOS 6.0
  2980                                  ;----------------------------------------------------------------------------
  2981                                  ; FILE : ORIGIN.INC
  2982                                  ;----------------------------------------------------------------------------
  2983                                  ; This is included in origin.asm and mshead.asm. Contains the equate that
  2984                                  ; is used for ORGing the DOS code.
  2985                                  ;
  2986                                  ; Brief Description of the necessacity of this ORG:
  2987                                  ; -------------------------------------------------
  2988                                  ;
  2989                                  ; A special problem exits when running out of the HMA. The HMA starts at 
  2990                                  ; address FFFF:10. There is no place in the HMA with an offset of zero.
  2991                                  ; This means programs running out off the HMA must use non-zero offset base
  2992                                  ; addresses. It also means that if we're running multiple programs from the
  2993                                  ; HMA, the base offset of each segment must atleast be as big as all of the
  2994                                  ; HMA segments that precede it.
  2995                                  ; 
  2996                                  ; One solution to this problem to ORG each module at 64K minus its size.
  2997                                  ; For instance a code segment 1234h bytes in length would org'd at edcbh.
  2998                                  ; This gives max. flexibility regarding it's location in the HMA. By 
  2999                                  ; selecting segment values between f124h and ffffh it could be located 
  3000                                  ; anywhere in the HMA. The problem with this is that programs with such 
  3001                                  ; high ORGs would not be able to run in low RAM.
  3002                                  ;
  3003                                  ; A compromise solution is to set the ORG address somewhere between 0010h
  3004                                  ; and ffffh - their size. In the particular case of the BIOS and the DOS 
  3005                                  ; the following solution has been implemented:
  3006                                  ;
  3007                                  ; The Bios Code segment will have a very small offset and run at the very
  3008                                  ; front of the HMA, after the VDISK header. THE Dos Code segment will have 
  3009                                  ; a base offset of (700+<min. size off RAM based BIOS>+<min. size of the DOS
  3010                                  ; DATA segment when DOS is running low>). This will reflect the lowest 
  3011                                  ; possible physical address at which DOS code will run, while still providing
  3012                                  ; max. possible flexibility in HMA positioning. This offset MUST NOT be 
  3013                                  ; smaller then that 20+size of Bios Code segment when running high. This is 
  3014                                  ; mostly true.
  3015                                  ;
  3016                                  ; Also this ORG'd value must be communicated to the BIOS. This is done by
  3017                                  ; putting this value after the first jmp instruction in the DOS code in
  3018                                  ; mshead.asm. 
  3019                                  ;
  3020                                  ; In order for the stripz utility to know how many zeroes to be stripped 
  3021                                  ; out, this value is placed at the beginning of the binary in origin.asm.
  3022                                  ;
  3023                                  ; Revision History:
  3024                                  ;
  3025                                  ; Currently this is being done manually. Therefore any change in the DOS DATA
  3026                                  ; Size or the BIOS size should be reflected here. --- Feb 90
  3027                                  ;
  3028                                  ; BDSIZE.INC contains the equates for BIODATASIZE, BIOCODESIZ and DOSDATASIZ.
  3029                                  ; A utility called getsize will obtain the corresponding values from msdos
  3030                                  ; and msbio.map and update the values in BDSIZ.INC if they are different. 
  3031                                  ; DOS should now be built using the batch file makedos.bat which invokes this
  3032                                  ; utility. The FORMAT of BDSIZE.INC should not be changed as getsize is 
  3033                                  ; dependant on that.				  --- Apr 3 '90
  3034                                  ;
  3035                                  ; For ROMDOS, however, there is no need to org the doscode to any location
  3036                                  ; other than zero.  Therefore the stripz utility will not need to be used,
  3037                                  ; so the offset will not need to be included at the beginning of the code
  3038                                  ; segment.  Also, the BIOS can just assume that the resident code begins
  3039                                  ; at offset zero within the segment.
  3040                                  ; 
  3041                                  ;
  3042                                  ;--------------------------------------------------------------------------
  3043                                  
  3044                                  BIODATASTART	EQU	00700h
  3045                                  ;include	bdsize.inc	; this sets the values:
  3046                                  				;	BIODATASIZ
  3047                                  				;	BIOCODESIZ
  3048                                  				;	DOSDATASIZ
  3049                                  
  3050                                  ; 05/12/2022
  3051                                  ;BIODATASIZ EQU 00910H	; 0900h for MSDOS 6.21 IO.SYS
  3052                                  			; 0900h for MSDOS 5.0 IO.SYS
  3053                                  ;BIOCODESIZ EQU 01A70H	; 1A70h for MSDOS 6.21 IO.SYS
  3054                                  			; 1A60h for MSDOS 5.0 IO.SYS
  3055                                  ;DOSDATASIZ EQU 01370H	; 1370h for MSDOS 6.21 IO.SYS
  3056                                  			; 1370h for MSDOS 5.0 IO.SYS
  3057                                  ;ifndef ROMDOS
  3058                                  ;
  3059                                  ;BYTSTART	EQU    	BIODATASTART+BIODATASIZ+BIOCODESIZ+DOSDATASIZ
  3060                                  ;PARASTART	EQU	(BYTSTART + 0FH) AND (NOT 0FH)	
  3061                                  ;
  3062                                  ;else
  3063                                  ;
  3064                                  ;BYTSTART	EQU	0
  3065                                  ;PARASTART	EQU	0
  3066                                  ;
  3067                                  ;endif ; ROMDOS
  3068                                  
  3069                                  ; 24/04/2019 - Retro DOS v4.0 - Modification
  3070                                  ; -----------------------------------------------------------------
  3071                                  ;MSDAT001E equ 136Ah ; 4970 ; for MSDOS 6.21	
  3072                                  ;MSDAT001E equ 1370h ; 4976 ; for Retro DOS v4.0 modif. 25/05/2019	
  3073                                  ;DOSDATASIZE equ MSDAT001E
  3074                                  ; 05/12/2022
  3075                                  ;DOSDATASIZE equ $ ; 29/04/2019 ; -only- for RETRO DOS v4.0 :
  3076                                  ;_PARASTART_ equ DOSDATASIZE ; segment value will point to start of
  3077                                  			    ; of DOSDATA (in low memory) while
  3078                                  			    ; dos/kernel code starts just after 
  3079                                  			    ; this data block ((org = DOSDATASIZE))
  3080                                  			    ; (in low memory or in HMA)	
  3081                                  ; -----------------------------------------------------------------
  3082                                  
  3083                                  ; 04/11/2022	
  3084                                  ; -----------------------------------------------------------------	
  3085                                  ; NOTE:
  3086                                  ; Microsoft dos programmers were calling 'IO.SYS' as dos 'BIOS'
  3087                                  ; (Also, they were calling 'ROMBIOS' as 'ROM' only!)
  3088                                  ; -----------------------------------------------------------------
  3089                                  
  3090                                  ; ----------------------------------------------------------------------------
  3091                                  ; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3092                                  ; ----------------------------------------------------------------------------
  3093                                  
  3094                                  ;segment .code vstart=3DD0h ; 06/12/2022
  3095                                  ; 29/09/2023
  3096                                  segment .code vstart=3DE0h ; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22)
  3097                                  								
  3098                                  ; ============================================================================
  3099                                  
  3100                                  
  3101                                  ;[ORG 3DE0h]
  3102                                  
  3103                                  ;[ORG _PARASTART_]     ; [org 136Ah]
  3104                                  
  3105                                  ;[ORG 1370h] ; 25/05/2019 - Retro DOS v4.0
  3106                                  
  3107                                  	; 05/12/2022 - RetroDOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3108                                  	;PARASTART equ 3DD0h ; BIOSDATASTART+BIOSDATASIZE
  3109                                  			     ; +BIOSCODESIZE+DOSDATASIZE (rounded up)
  3110                                  	
  3111                                  	; 29/09/2023 
  3112                                  	; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
  3113                                  	PARASTART equ 3DE0h	; (MSDOS 6.22 MSDOS.SYS)
  3114                                  
  3115                                  	[ORG PARASTART]	
  3116                                  
  3117                                  _$STARTCODE:
  3118                                  
  3119                                  ;PARASTART:
  3120 00000000 E9C476                          JMP     DOSINIT
  3121                                  
  3122                                  	;dw	PARASTART	; PARASTART = 3DE0h for MSDOS 6.0, 6.22
  3123                                  	; 04/11/2022
  3124 00000003 [0000]                  	dw	_$STARTCODE	; PARASTART = 3DD0h for MSDOS 5.0
  3125                                  
  3126                                  BioDataSeg:
  3127 00000005 7000                    	dw	0070h		; Bios data segment fixed at 70h
  3128                                  
  3129                                  ; DosDSeg is a data word in the DOSCODE segment that is loaded with
  3130                                  ; the segment address of DOSDATA. This is purely an optimization, that
  3131                                  ; allows getting the DOS data segment without going through the 
  3132                                  ; BIOS data segment. It is used by the "getdseg" macro.
  3133                                  
  3134                                  DosDSeg:
  3135 00000007 0000                    	dw	0
  3136                                  	
  3137                                  ;============================================================================
  3138                                  ; MSTABLE.ASM (MSDOS 6.0, 1991)
  3139                                  ;============================================================================
  3140                                  ; 16/07/2018 - Retro DOS 3.0
  3141                                  ; 29/04/2019 - Retro DOS 4.0
  3142                                  
  3143                                  	; (MSDOS version)
  3144                                  	; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
  3145                                  	;db	6
  3146                                  	;db	20
  3147                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 
  3148                                  	; DOSCODE:3DD9h (MSDOS 5.0, MSDOS.SYS)
  3149                                  	;db	5
  3150                                  	;db	0	
  3151                                  
  3152                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
  3153                                  MSVERS:				; MS-DOS version in hex for $GET_VERSION
  3154 00000009 06                      MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  3155 0000000A 16                      MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  3156                                  
  3157                                  ;;hkn YRTAB & MONTAB moved to DOSDATA in ms_data.asm
  3158                                  ;	I_am	YRTAB,8,<200,166,200,165,200,165,200,165>   ; [SYSTEM]
  3159                                  ;	I_am	MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> ; [SYSTEM]
  3160                                  
  3161                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
  3162                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
  3163                                  ;
  3164                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
  3165                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 
  3166                                  
  3167                                  ; This is the error code mapping table for INT 21 errors. This table defines
  3168                                  ; those error codes which are "allowed" for each system call. If the error
  3169                                  ; code ABOUT to be returned is not "allowed" for the call, the correct action
  3170                                  ; is to return the "real" error via Extended error, and one of the allowed
  3171                                  ; errors on the actual call.
  3172                                  ;
  3173                                  ; The table is organized as follows:
  3174                                  ;
  3175                                  ;    Each entry in the table is of variable size, but the first
  3176                                  ;       two bytes are always:
  3177                                  ;
  3178                                  ;       Call#,Cnt of bytes following this byte
  3179                                  ;
  3180                                  ; EXAMPLE:
  3181                                  ;       Call 61 (OPEN)
  3182                                  ;
  3183                                  ;       DB      61,5,12,3,2,4,5
  3184                                  ;
  3185                                  ;       61 is the AH INT 21 call value for OPEN.
  3186                                  ;        5 indicates that there are 5 bytes after this byte (12,3,2,4,5).
  3187                                  ;       Next five bytes are those error codes which are "allowed" on OPEN.
  3188                                  ;       The order of these values is not important EXCEPT FOR THE LAST ONE (in
  3189                                  ;       this case 5).  The last value will be the one returned on the call if
  3190                                  ;       the "real" error is not one of the allowed ones.
  3191                                  ;
  3192                                  ; There are a number of calls (for instance all of the FCB calls) for which
  3193                                  ;   there is NO entry.  This means that NO error codes are returned on this
  3194                                  ;   call, so set up an Extended error and leave the current error code alone.
  3195                                  ;
  3196                                  ; The table is terminated by a call value of 0FFh
  3197                                  
  3198                                  ;PUBLIC I21_MAP_E_TAB
  3199                                  	; 10/08/2018
  3200                                  
  3201                                  ; 29/04/2019
  3202                                  ; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
  3203                                  ; 04/11/2022
  3204                                  ; DOSCODE:3DDBh	(MSDOS 5.0 MSDOS.SYS)
  3205                                  
  3206                                  I21_MAP_E_TAB:	; LABEL	BYTE
  3207 0000000B 38020102                    DB  INTERNATIONAL,2,error_invalid_function,error_file_not_found
  3208 0000000F 3903030205                  DB  MKDIR,3,error_path_not_found,error_file_not_found,error_access_denied
  3209 00000014 3A041003                    DB  RMDIR,4,error_current_directory,error_path_not_found
  3210 00000018 0205                        DB          error_file_not_found,error_access_denied
  3211 0000001A 3B020203                    DB  CHDIR,2,error_file_not_found,error_path_not_found
  3212 0000001E 3C040302                    DB  CREAT,4,error_path_not_found,error_file_not_found
  3213 00000022 04                          DB          error_too_many_open_files
  3214 00000023 05                          DB          error_access_denied
  3215                                      ; MSDOS 6.0
  3216 00000024 3D0603020C                  DB	OPEN,6,error_path_not_found,error_file_not_found,error_invalid_access
  3217 00000029 04                          DB          error_too_many_open_files
  3218 0000002A 1A05                        DB          error_not_DOS_disk,error_access_denied
  3219                                      ; MSDOS 3.3
  3220                                      ;DB	OPEN,5,error_path_not_found,error_file_not_found,error_invalid_access
  3221                                      ;DB		error_too_many_open_files,error_access_denied
  3222 0000002C 3E0106                      DB  CLOSE,1,error_invalid_handle
  3223 0000002F 3F020605                    DB  READ,2,error_invalid_handle,error_access_denied
  3224 00000033 40020605                    DB  WRITE,2,error_invalid_handle,error_access_denied
  3225 00000037 4103030205                  DB  UNLINK,3,error_path_not_found,error_file_not_found,error_access_denied
  3226 0000003C 42020601                    DB  LSEEK,2,error_invalid_handle,error_invalid_function
  3227 00000040 4304030201                  DB  CHMOD,4,error_path_not_found,error_file_not_found,error_invalid_function
  3228 00000045 05                          DB          error_access_denied
  3229 00000046 44050F0D01                  DB  IOCTL,5,error_invalid_drive,error_invalid_data,error_invalid_function
  3230 0000004B 0605                        DB          error_invalid_handle,error_access_denied
  3231 0000004D 45020604                    DB  XDUP,2,error_invalid_handle,error_too_many_open_files
  3232 00000051 46020604                    DB  XDUP2,2,error_invalid_handle,error_too_many_open_files
  3233                                      ; MSDOS 6.0	
  3234 00000055 47021A0F                    DB  CURRENT_DIR,2,error_not_DOS_disk,error_invalid_drive
  3235                                      ; MSDOS 3.3	
  3236                                      ;DB  CURRENT_DIR,1,error_invalid_drive
  3237 00000059 48020708                    DB  ALLOC,2,error_arena_trashed,error_not_enough_memory
  3238 0000005D 49020709                    DB  DEALLOC,2,error_arena_trashed,error_invalid_block
  3239 00000061 4A03070908                  DB  SETBLOCK,3,error_arena_trashed,error_invalid_block,error_not_enough_memory
  3240 00000066 4B08030102                  DB  EXEC,8,error_path_not_found,error_invalid_function,error_file_not_found
  3241 0000006B 040B0A                      DB          error_too_many_open_files,error_bad_format,error_bad_environment
  3242 0000006E 0805                        DB          error_not_enough_memory,error_access_denied
  3243 00000070 4E03030212                  DB  FIND_FIRST,3,error_path_not_found,error_file_not_found,error_no_more_files
  3244 00000075 4F0112                      DB  FIND_NEXT,1,error_no_more_files
  3245                                      ; MSDOS 6.0
  3246 00000078 5605110302                  DB  RENAME,5,error_not_same_device,error_path_not_found,error_file_not_found
  3247 0000007D 1005                        DB		error_current_directory,error_access_denied
  3248                                      ; MSDOS 3.3
  3249                                      ;DB  RENAME,4,error_not_same_device,error_path_not_found,error_file_not_found
  3250                                      ;DB		error_access_denied
  3251                                      ; MSDOS 6.0	
  3252 0000007F 57040608                    DB  FILE_TIMES,4,error_invalid_handle,error_not_enough_memory
  3253 00000083 0D01                        DB		error_invalid_data,error_invalid_function
  3254                                      ; MSDOS 3.3	
  3255                                      ;DB  FILE_TIMES,2,error_invalid_handle,error_invalid_function
  3256 00000085 580101                      DB  ALLOCOPER,1,error_invalid_function
  3257 00000088 5A040302                    DB  CREATETEMPFILE,4,error_path_not_found,error_file_not_found
  3258 0000008C 0405                        DB          error_too_many_open_files,error_access_denied
  3259 0000008E 5B055003                    DB  CREATENEWFILE,5,error_file_exists,error_path_not_found
  3260 00000092 020405                      DB          error_file_not_found,error_too_many_open_files,error_access_denied
  3261 00000095 5C040601                    DB  LOCKOPER,4,error_invalid_handle,error_invalid_function
  3262 00000099 2421                        DB          error_sharing_buffer_exceeded,error_lock_violation
  3263 0000009B 65020102                    DB  GETEXTCNTRY,2,error_invalid_function,error_file_not_found	;DOS 3.3
  3264 0000009F 66020102                    DB  GETSETCDPG,2,error_invalid_function,error_file_not_found        ;DOS 3.3
  3265 000000A3 680106                      DB  COMMIT,1,error_invalid_handle                                   ;DOS 3.3
  3266 000000A6 67030408                    DB  EXTHANDLE,3,error_too_many_open_files,error_not_enough_memory
  3267 000000AA 01                          DB              error_invalid_function
  3268                                      ; MSDOS 6.0		
  3269 000000AB 6C0A                        DB	ExtOpen,10
  3270 000000AD 03020C                      DB	  error_path_not_found,error_file_not_found,error_invalid_access
  3271 000000B0 045008                      DB		error_too_many_open_files,error_file_exists,error_not_enough_memory
  3272 000000B3 1A0D                        DB		error_not_DOS_disk,error_invalid_data
  3273 000000B5 0105                        DB		error_invalid_function,error_access_denied
  3274 000000B7 69040F0D                    DB	GetSetMediaID,4,error_invalid_drive,error_invalid_data
  3275 000000BB 0105                        DB		error_invalid_function,error_access_denied
  3276 000000BD FF                          DB  0FFh
  3277                                  
  3278                                  ;19/09/2023
  3279                                  ;22/12/2022
  3280                                  ;04/11/2022	
  3281                                  ;29/04/2019 - Retro DOS v4.0
  3282                                  ;============================================================================
  3283                                  ; 	Retro DOS v4.0
  3284                                  ;============================================================================
  3285 000000BE 00                      	db 	0
  3286                                  RETRODOSMSG:
  3287 000000BF 0D0A                    	db	13,10
  3288                                  	;;;;;db	"Retro DOS v4.0 by Erdogan Tan [2019]"
  3289                                  	;;;;db	"Retro DOS v4.0 by Erdogan Tan [2022]"
  3290                                  	;;;db	"Retro DOS v4.1 by Erdogan Tan [2022]"	; 28/12/2022
  3291                                  	;;db	"Retro DOS v4.2 by Erdogan Tan [2022]"	; 30/12/2022
  3292                                  	;db	"Retro DOS v4.2 by Erdogan Tan [2023]"
  3293 000000C1 526574726F20444F53-     	db	"Retro DOS v4.2 by Erdogan Tan [2024]"	; 05/01/2024
  3293 000000CA 2076342E3220627920-
  3293 000000D3 4572646F67616E2054-
  3293 000000DC 616E205B323032345D 
  3294 000000E5 0D0A2400                	db	13,10,"$", 0 
  3295                                  
  3296                                  ;============================================================================
  3297                                  ; MSTABLE.ASM, MSDOS 6.0, 1991
  3298                                  ;============================================================================
  3299                                  ; 11/07/2018 - Retro DOS v3.0
  3300                                  
  3301                                  	%define short_addr dw  ; 03/03/2018 - Retro DOS v2.0
  3302 000000E9 90                      align 2
  3303                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0E00h
  3304                                  
  3305                                  ; Standard Functions
  3306                                  ;DISPATCH  LABEL WORD
  3307                                  DISPATCH:
  3308                                  	; 16/07/2018 - Retro DOS v3.0
  3309                                  	; (MSDOS 3.3)
  3310                                  
  3311                                  ; 29/04/2019
  3312                                  ; DOSCODE:3E9Eh (MSDOS 6.21, MSDOS.SYS)
  3313                                  
  3314                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3315                                  ; DOSCODE:3E8Eh (MSDOS 5.0, MSDOS.SYS)
  3316                                  
  3317 000000EA [F961]                          short_addr  _$ABORT			    ;  0      0
  3318 000000EC [5616]                          short_addr  _$STD_CON_INPUT		    ;  1      1
  3319 000000EE [5F16]                          short_addr  _$STD_CON_OUTPUT		    ;  2      2
  3320 000000F0 [1117]                          short_addr  _$STD_AUX_INPUT		    ;  3      3
  3321 000000F2 [2C17]                          short_addr  _$STD_AUX_OUTPUT		    ;  4      4
  3322 000000F4 [3217]                          short_addr  _$STD_PRINTER_OUTPUT	    ;  5      5
  3323 000000F6 [9D15]                          short_addr  _$RAW_CON_IO		    ;  6      6
  3324 000000F8 [C915]                          short_addr  _$RAW_CON_INPUT		    ;  7      7
  3325 000000FA [7713]                          short_addr  _$STD_CON_INPUT_NO_ECHO	    ;  8      8
  3326 000000FC [D013]                          short_addr  _$STD_CON_STRING_OUTPUT	    ;  9      9
  3327 000000FE [DC13]                          short_addr  _$STD_CON_STRING_INPUT	    ; 10      A
  3328 00000100 [4617]                          short_addr  _$STD_CON_INPUT_STATUS	    ; 11      B
  3329 00000102 [5017]                          short_addr  _$STD_CON_INPUT_FLUSH	    ; 12      C
  3330 00000104 [9B0F]                          short_addr  _$DISK_RESET		    ; 13      D
  3331 00000106 [820E]                          short_addr  _$SET_DEFAULT_DRIVE		    ; 14      E
  3332 00000108 [211E]                          short_addr  _$FCB_OPEN			    ; 15      F
  3333 0000010A [EF17]                          short_addr  _$FCB_CLOSE			    ; 16     10
  3334 0000010C [331F]                          short_addr  _$DIR_SEARCH_FIRST		    ; 17     11
  3335 0000010E [C51F]                          short_addr  _$DIR_SEARCH_NEXT		    ; 18     12
  3336 00000110 [9517]                          short_addr  _$FCB_DELETE		    ; 19     13
  3337 00000112 [1F1F]                          short_addr  _$FCB_SEQ_READ		    ; 20     14
  3338 00000114 [241F]                          short_addr  _$FCB_SEQ_WRITE	            ; 21     15
  3339 00000116 [051F]                          short_addr  _$FCB_CREATE		    ; 22     16
  3340 00000118 [5B18]                          short_addr  _$FCB_RENAME		    ; 23     17
  3341                                  	; 16/07/2018
  3342                                          ;short_addr _CPMFUNC			    ; 24     18	
  3343 0000011A [5306]                          short_addr  NO_OP			    ; 24     18
  3344 0000011C [7D0E]                          short_addr  _$GET_DEFAULT_DRIVE		    ; 25     19
  3345 0000011E [720E]                          short_addr  _$SET_DMA			    ; 26     1A
  3346                                  
  3347                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3348                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3349                                  ;                                                                          ;
  3350 00000120 [2A0F]                          short_addr  _$SLEAZEFUNC		    ; 27     1B
  3351 00000122 [2C0F]                          short_addr  _$SLEAZEFUNCDL		    ; 28     1C
  3352                                  ;                                                                          ;
  3353                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3354                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3355                                  
  3356                                          ;short_addr  _CPMFUNC			    ; 29     1D
  3357                                          ;short_addr  _CPMFUNC			    ; 30     1E
  3358                                  
  3359                                  ; 08/07/2018 - Retro DOS v3.0
  3360                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3361                                  
  3362 00000124 [5306]                  	short_addr  NO_OP			    ; 29     1D
  3363 00000126 [5306]                  	short_addr  NO_OP			    ; 30     1E
  3364                                  
  3365                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3366                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3367                                  ;                                                                          ;
  3368 00000128 [6B0F]                          short_addr  _$GET_DEFAULT_DPB               ; 31     1F
  3369                                  ;                                                                          ;
  3370                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3371                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3372                                          ;short_addr _CPMFUNC			    ; 32     20
  3373                                  
  3374                                  ; 08/07/2018 - Retro DOS v3.0
  3375                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3376                                  
  3377 0000012A [5306]                  	short_addr  NO_OP			    ; 32     20
  3378                                  
  3379 0000012C [291F]                          short_addr  _$FCB_RANDOM_READ               ; 33     21
  3380 0000012E [2E1F]                          short_addr  _$FCB_RANDOM_WRITE              ; 34     22
  3381 00000130 [A717]                          short_addr  _$GET_FCB_FILE_LENGTH	    ; 35     23
  3382 00000132 [7D17]                          short_addr  _$GET_FCB_POSITION		    ; 36     24
  3383                                  
  3384                                  ;MAXCALL = ($-DISPATCH)/2 - 1
  3385                                  MAXCALL EQU ($-DISPATCH)/2 - 1
  3386                                  
  3387                                  ; Extended Functions
  3388 00000134 [A30E]                          short_addr  _$SET_INTERRUPT_VECTOR	    ; 37     25
  3389                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3390                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3391                                  ;                                                                          ;
  3392 00000136 [A810]                          short_addr  _$CREATE_PROCESS_DATA_BLOCK	    ; 38     26
  3393                                  ;                                                                          ;
  3394                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3395                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3396 00000138 [1A1F]                          short_addr  _$FCB_RANDOM_READ_BLOCK	    ; 39     27
  3397 0000013A [151F]                          short_addr  _$FCB_RANDOM_WRITE_BLOCK        ; 40     28
  3398 0000013C [1F0F]                          short_addr  _$PARSE_FILE_DESCRIPTOR	    ; 41     29
  3399 0000013E [5E0A]                          short_addr  _$GET_DATE                      ; 42     2A
  3400 00000140 [7B0A]                          short_addr  _$SET_DATE                      ; 43     2B
  3401 00000142 [9A0A]                          short_addr  _$GET_TIME                      ; 44     2C
  3402 00000144 [AB0A]                          short_addr  _$SET_TIME                      ; 45     2D
  3403 00000146 [630C]                          short_addr  _$SET_VERIFY_ON_WRITE           ; 46     2E
  3404                                  
  3405                                  ; Extended functionality group
  3406 00000148 [5F0E]                          short_addr  _$GET_DMA                       ; 47     2F
  3407 0000014A [3A0C]                          short_addr  _$GET_VERSION                   ; 48     30
  3408 0000014C [9D61]                          short_addr  _$KEEP_PROCESS		    ; 49     31
  3409                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3410                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3411                                  ;                                                                          ;
  3412 0000014E [6D0F]                          short_addr  _$GET_DPB			    ; 50     32
  3413                                  ;                                                                          ;
  3414                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3415                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3416 00000150 [6702]                          short_addr  _$SET_CTRL_C_TRAPPING           ; 51     33
  3417 00000152 [550F]                          short_addr  _$GET_INDOS_FLAG                ; 52     34
  3418 00000154 [940E]                          short_addr  _$GET_INTERRUPT_VECTOR          ; 53     35
  3419 00000156 [3C0E]                          short_addr  _$GET_DRIVE_FREESPACE           ; 54     36
  3420 00000158 [D00E]                          short_addr  _$CHAR_OPER                     ; 55     37
  3421 0000015A [6A0C]                          short_addr  _$INTERNATIONAL                 ; 56     38
  3422                                  ; XENIX CALLS
  3423                                  ;   Directory Group
  3424 0000015C [1F22]                          short_addr  _$MKDIR			    ; 57     39
  3425 0000015E [6B21]                          short_addr  _$RMDIR			    ; 58     3A
  3426 00000160 [A621]                          short_addr  _$CHDIR			    ; 59     3B
  3427                                  ;   File Group
  3428 00000162 [BB6F]                          short_addr  _$CREAT			    ; 60     3C
  3429 00000164 [E46E]                          short_addr  _$OPEN			    ; 61     3D
  3430 00000166 [1567]                          short_addr  _$CLOSE		 	    ; 62     3E
  3431 00000168 [2668]                          short_addr  _$READ			    ; 63     3F
  3432 0000016A [8C68]                          short_addr  _$WRITE			    ; 64     40
  3433 0000016C [0B70]                          short_addr  _$UNLINK			    ; 65     41
  3434 0000016E [9168]                          short_addr  _$LSEEK			    ; 66     42
  3435 00000170 [C86F]                          short_addr  _$CHMOD			    ; 67     43
  3436 00000172 [8022]                          short_addr  _$IOCTL			    ; 68     44
  3437 00000174 [4669]                          short_addr  _$DUP			    ; 69     45
  3438 00000176 [6469]                          short_addr  _$DUP2			    ; 70     46
  3439 00000178 [FC20]                          short_addr  _$CURRENT_DIR		    ; 71     47
  3440                                  ;   Memory Group
  3441 0000017A [9062]                          short_addr  _$ALLOC			    ; 72     48
  3442 0000017C [0A64]                          short_addr  _$DEALLOC                       ; 73     49
  3443 0000017E [E663]                          short_addr  _$SETBLOCK                      ; 74     4A
  3444                                  ;   Process Group
  3445 00000180 [775B]                          short_addr  _$EXEC			    ; 75     4B
  3446 00000182 [D561]                          short_addr  _$EXIT			    ; 76     4C
  3447 00000184 [6D5B]                          short_addr  _$WAIT			    ; 77     4D
  3448 00000186 [3820]                          short_addr  _$FIND_FIRST		    ; 78     4E
  3449                                  ;   Special Group
  3450 00000188 [8E20]                          short_addr  _$FIND_NEXT			    ; 79     4F
  3451                                  ; SPECIAL SYSTEM GROUP
  3452                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3453                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3454                                  ;                                                                          ;
  3455 0000018A [B902]                          short_addr  _$SET_CURRENT_PDB		    ; 80     50
  3456 0000018C [C502]                          short_addr  _$GET_CURRENT_PDB               ; 81     51
  3457 0000018E [610F]                          short_addr  _$GET_IN_VARS                   ; 82     52
  3458 00000190 [D00F]                          short_addr  _$SETDPB			    ; 83     53
  3459                                  ;                                                                          ;
  3460                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3461                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3462 00000192 [5E0C]                          short_addr  _$GET_VERIFY_ON_WRITE	    ; 84     54
  3463                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3464                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3465                                  ;                                                                          ;
  3466 00000194 [9710]                          short_addr  _$DUP_PDB                       ; 85     55
  3467                                  ;                                                                          ;
  3468                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3469                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3470 00000196 [3170]                          short_addr  _$RENAME			    ; 86     56
  3471 00000198 [F868]                          short_addr  _$FILE_TIMES                    ; 87     57
  3472 0000019A [3F64]                          short_addr  _$ALLOCOPER                     ; 88     58
  3473                                  
  3474                                  ; 08/07/2018 - Retro DOS v3.0
  3475                                  ; -------------------------------------------------------------------------;
  3476                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3477                                  
  3478                                  ; Network extention system calls
  3479 0000019C [E40E]                          short_addr  _$GetExtendedError              ; 89     59
  3480 0000019E [BC70]                          short_addr  _$CreateTempFile                ; 90     5A
  3481 000001A0 [A470]                          short_addr  _$CreateNewFile                 ; 91     5B
  3482 000001A2 [9D72]                          short_addr  _$LockOper                      ; 92     5C
  3483 000001A4 [2565]                          short_addr  _$ServerCall                    ; 93     5D
  3484 000001A6 [2E6A]                          short_addr  _$UserOper                      ; 94     5E
  3485 000001A8 [9369]                          short_addr  _$AssignOper                    ; 95     5F
  3486 000001AA [7F6E]                          short_addr  _$NameTrans                     ; 96     60
  3487 000001AC [5306]                  	short_addr  NO_OP			    ; 97     61
  3488 000001AE [C502]                          short_addr  _$GET_CURRENT_PDB		    ; 98     62
  3489                                  ; the next call is reserved for hangool sys call
  3490                                  	; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
  3491 000001B0 [040F]                  	short_addr  _$ECS_Call			    ; 99     63
  3492                                  	;short_addr  NO_OP  ;  MSDOS 3.3	    ; 99     63
  3493                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3494                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3495                                  ;                                                                          ;
  3496 000001B2 [D102]                          short_addr  _$SET_PRINTER_FLAG              ; 100    64
  3497                                  ;                                                                          ;
  3498                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3499                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3500 000001B4 [ED0C]                          short_addr  _$GetExtCntry                   ; 101    65
  3501 000001B6 [EA0D]                          short_addr  _$GetSetCdPg                    ; 102    66
  3502 000001B8 [6267]                          short_addr  _$ExtHandle                     ; 103    67
  3503 000001BA [4867]                          short_addr  _$COMMIT                        ; 104    68
  3504                                  
  3505                                  ; 08/07/2018
  3506                                  ; Above system calls are valid for Retro DOS v3.0 (MSDOS 3.3) 
  3507                                  ; Following system calls are valid for Retro DOS v4.0 (MSDOS 6.0)
  3508                                  
  3509                                  ; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
  3510 000001BC [9A11]                  	short_addr  _$GSetMediaID                   ; 105    69   ;AN000;
  3511 000001BE [4867]                  	short_addr  _$COMMIT                        ; 106    6A   ;AN000;
  3512 000001C0 [5306]                  	short_addr  NO_OP                           ; 107    6B   
  3513                                  						    ; IFS_IOCTL no longer 
  3514                                  						    ; supported
  3515 000001C2 [5271]                  	short_addr  _$Extended_Open                 ; 108    6C   ;AN000;
  3516                                  
  3517                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3518                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3519                                  ;                                                                          ;
  3520                                  ;ifdef ROMEXEC
  3521                                  ;       short_addr  $ROM_FIND_FIRST	   	    ; 109    6D
  3522                                  ;       short_addr  $ROM_FIND_NEXT	   	    ; 110    6E
  3523                                  ;	short_addr  $ROM_EXCLUDE		    ; 111    6F	  ; M078
  3524                                  ;endif
  3525                                  ;                                                                          ;
  3526                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3527                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3528                                  
  3529                                  ;MAXCOM  = ($-DISPATCH)/2 - 1
  3530                                  
  3531                                  MAXCOM  EQU ($-DISPATCH)/2 - 1
  3532                                  
  3533                                  ; 08/07/2018 - Retro DOS v3.0
  3534                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3535                                  
  3536                                  ;	If 	Installed
  3537                                  
  3538                                  align 2
  3539                                  
  3540                                  ;PUBLIC FOO
  3541                                  
  3542                                  FOO:	; LABEL WORD
  3543 000001C4 [1007]                          short_addr  Leave2F
  3544                                  
  3545 000001C6 [C801]                  DTab:	DW  DOSTable
  3546                                  
  3547                                  	;PUBLIC FOO,DTAB
  3548                                  
  3549                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0ED6h
  3550                                  
  3551                                  ; 29/04/2019
  3552                                  ; DOSCODE:3F7Ch (MSDOS 6.21, MSDOS.SYS)
  3553                                  
  3554                                  
  3555                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3556                                  ; DOSCODE:3F6Ch (MSDOS 5.0, MSDOS.SYS)
  3557                                         
  3558                                  DOSTable:  ; LABEL  WORD
  3559 000001C8 30                              DB      (DOSTableEnd-DOSTable-1)/2 ; db  48
  3560 000001C9 [3509]                          short_addr  DOSInstall          ;   0 install check
  3561 000001CB [3B2F]                          short_addr  DOS_CLOSE           ;   1   DOS_CLOSE
  3562 000001CD [C50E]                          short_addr  RECSET              ;   2   RECSET
  3563 000001CF [2F09]                          short_addr  DosGetGroup         ;   3   Get DOSGROUP
  3564 000001D1 [A250]                          short_addr  PATHCHRCMP          ;   4   PATHCHRCMP
  3565 000001D3 [6116]                          short_addr  OUTT                ;   5   OUT
  3566 000001D5 [7853]                          short_addr  NET_I24_ENTRY       ;   6   NET_I24_ENTRY
  3567 000001D7 [F758]                          short_addr  PLACEBUF            ;   7   PLACEBUF
  3568 000001D9 [3930]                          short_addr  FREE_SFT            ;   8   FREE_SFT
  3569 000001DB [BC5A]                          short_addr  BUFWRITE            ;   9   BUFWRITE
  3570 000001DD [5173]                          short_addr  SHARE_VIOLATION     ;   10  SHARE_VIOLATION
  3571 000001DF [842C]                          short_addr  SHARE_ERROR         ;   11  SHARE_ERROR
  3572 000001E1 [6E2C]                          short_addr  SET_SFT_MODE        ;   12  SET_SFT_MODE
  3573 000001E3 [F00A]                          short_addr  DATE16              ;   13  DATE16
  3574 000001E5 [0612]                          short_addr  Idle		;   14      empty slot
  3575 000001E7 [F058]                          short_addr  SCANPLACE           ;   15  SCANPLACE
  3576 000001E9 [0612]                          short_addr  Idle		;   16      empty slot
  3577 000001EB [D311]                          short_addr  StrCpy              ;   17  StrCpy
  3578 000001ED [EB11]                          short_addr  StrLen              ;   18  StrLen
  3579 000001EF [4D50]                          short_addr  UCase		;   19  UCase
  3580 000001F1 [3459]                          short_addr  POINTCOMP           ;   20  POINTCOMP
  3581 000001F3 [935A]                          short_addr  CHECKFLUSH          ;   21  CHECKFLUSH
  3582 000001F5 [9066]                          short_addr  SFFromSFN           ;   22  SFFromSFN
  3583 000001F7 [F36A]                          short_addr  GetCDSFromDrv       ;   23  GetCDSFromDrv
  3584 000001F9 [8104]                          short_addr  Get_User_Stack      ;   24  Get_User_Stack
  3585 000001FB [9E6A]                          short_addr  GETTHISDRV          ;   25  GetThisDrv
  3586 000001FD [A46E]                          short_addr  DriveFromText       ;   26  DriveFromText
  3587 000001FF [970B]                          short_addr  SETYEAR             ;   27  SETYEAR
  3588 00000201 [300C]                          short_addr  DSUM                ;   28  DSUM
  3589 00000203 [8D0B]                          short_addr  DSLIDE              ;   29  DSLIDE
  3590 00000205 [B111]                          short_addr  StrCmp              ;   30  StrCmp
  3591 00000207 [E169]                          short_addr  InitCDS             ;   31  initcds
  3592 00000209 [5D66]                          short_addr  pJFNFromHandle      ;   32  pJfnFromHandle
  3593 0000020B [7F6E]                          short_addr  _$NameTrans		;   33  $NameTrans
  3594 0000020D [7A06]                          short_addr  CAL_LK              ;   34  CAL_LK
  3595 0000020F [DB41]                          short_addr  DEVNAME             ;   35  DEVNAME
  3596 00000211 [0612]                          short_addr  Idle                ;   36  Idle
  3597 00000213 [F911]                          short_addr  DStrLen             ;   37  DStrLen
  3598 00000215 [A812]                          short_addr  NLS_OPEN            ;   38  NLS_OPEN      DOS 3.3
  3599 00000217 [1567]                          short_addr  _$CLOSE		;   39  $CLOSE        DOS 3.3
  3600 00000219 [AE12]                          short_addr  NLS_LSEEK           ;   40  NLS_LSEEK     DOS 3.3
  3601 0000021B [2668]                          short_addr  _$READ		;   41  $READ         DOS 3.3
  3602 0000021D [6A12]                          short_addr  FastInit            ;   42  FastInit      DOS 3.4  ;AN000;
  3603 0000021F [EB12]                          short_addr  NLS_IOCTL           ;   43  NLS_IOCTL     DOS 3.3
  3604 00000221 [DA12]                          short_addr  GetDevList          ;   44  GetDevList    DOS 3.3
  3605 00000223 [0813]                          short_addr  NLS_GETEXT          ;   45  NLS_GETEXT    DOS 3.3
  3606                                          
  3607                                  	; 29/04/2019 - Retro DOS v4.0
  3608 00000225 [0C13]                  	short_addr  MSG_RETRIEVAL	;   46  MSG_RETRIEVAL DOS 4.0  ;AN000;
  3609                                  
  3610 00000227 [5306]                  	short_addr  NO_OP		;   M006: 47  no longer supported
  3611                                  ;*** 	short_addr  Fake_Version	;   47  Fake_Version  DOS 4.0  ;AN006;
  3612                                  
  3613                                  DOSTableEnd:  ; LABEL BYTE
  3614                                  
  3615                                  	;ENDIF
  3616                                  
  3617                                  ; ----------------------------------------------------------------------------
  3618                                  ; BREAK   <Copyright notice and version>
  3619                                  ; ----------------------------------------------------------------------------
  3620                                  
  3621                                  ;CODSTRT EQU	$
  3622                                  
  3623                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
  3624                                  ; (MSTABLE.ASM, MSDOS 6.0, 1991)
  3625                                  
  3626                                  ; NOTE WARNING: This declaration of HEADER must be THE LAST thing in this
  3627                                  ;       module. The reason is so that the data alignments are the same in
  3628                                  ;       IBM-DOS and MS-DOS up through header.
  3629                                  
  3630                                  	;PUBLIC	HEADER
  3631                                  
  3632                                  HEADER:	; LABEL	BYTE
  3633                                          ;IF	DEBUG
  3634                                          ;DB	13,10,"Debugging DOS version "
  3635                                          ;DB	MAJOR_VERSION + "0"
  3636                                          ;DB	"."
  3637                                          ;DB	(MINOR_VERSION / 10) + "0"
  3638                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  3639                                          ;ENDIF
  3640                                  
  3641                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3642                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
  3643                                  %if 0
  3644                                          ;IF	NOT IBM
  3645                                          DB	13,10,"MS-DOS version "
  3646                                          DB	MAJOR_VERSION + "0"
  3647                                          DB	"."
  3648                                          DB	(MINOR_VERSION / 10) + "0"
  3649                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  3650                                          DB	(MINOR_VERSION % 10) + "0"
  3651                                  
  3652                                          ;IF	HIGHMEM
  3653                                          ;DB	"H"
  3654                                          ;ENDIF
  3655                                  
  3656                                  	;DB	13,10,"Copyright 1981,82,83,84,88 Microsoft Corp.",13,10,"$"
  3657                                  	; 30/04/2019 - Retro DOS v4.0
  3658                                  	DB	13,10,"Copyright 1981-1993 Microsoft Corp.",13,10,"$"	
  3659                                  
  3660                                  	;ENDIF
  3661                                  
  3662                                  %endif
  3663                                  
  3664                                  ;IF DEBUG
  3665                                  ;	DB	13,10,"$"
  3666                                  ;ENDIF
  3667                                  
  3668                                  ;include copyrigh.inc
  3669                                  
  3670                                  ; DOSCODE:3FDDh (MSDOS 6.21, MSDOS.SYS)
  3671                                  
  3672                                  	;DB	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
  3673                                  	;DB	"Licensed Material - Property of Microsoft "
  3674                                  	;DB	"All rights reserved "
  3675                                  
  3676                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3677                                  ; DOSCODE:3FCDh (MSDOS 5.0, MSDOS.SYS)
  3678                                  
  3679                                  ; 28/12/2022 - Retro DOS v4.1
  3680                                  %if 0
  3681                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  3682                                  ms_copyright:
  3683                                  	db	'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp '
  3684                                  	db	'Licensed Material - Property of Microsoft '
  3685                                  	db	'All rights reserved '
  3686                                  
  3687                                  %endif
  3688                                  	;; 28/12/2022 - Retro DOS v4.1
  3689                                  ;ms_copyright:	
  3690                                    	;db	13,10,"MS DOS Version 5.0"
  3691                                  	;db	13,10,"Copyright 1981-1991 Microsoft Corp.",13,10,"$",0	
  3692                                  
  3693                                  ;	; 21/09/2023 - Retro DOS v4.2 MSDOS.SYS
  3694                                  ;	; (MSDOS 6.22 MSDOS.SYS - DOSCODE:3FDDh (File offset: 509))
  3695                                  ;ms_copyright:
  3696                                  ;	db 'MS DOS Version 6 (C)Copyright 1981-1994 Microsoft Corp '
  3697                                  ;	db 'Licensed Material - Property of Microsoft All rights reserved '
  3698                                  
  3699                                  	; 20/09/2023 - Retro DOS v4.2
  3700                                  ms_copyright:	
  3701 00000229 0D0A4D5320444F5320-       	db	13,10,"MS DOS Version 6.22"
  3701 00000232 56657273696F6E2036-
  3701 0000023B 2E3232             
  3702 0000023E 0D0A436F7079726967-     	db	13,10,"Copyright 1981-1994 Microsoft Corp.",13,10,"$",0	
  3702 00000247 687420313938312D31-
  3702 00000250 393934204D6963726F-
  3702 00000259 736F667420436F7270-
  3702 00000262 2E0D0A2400         
  3703                                  
  3704                                  ;============================================================================
  3705                                  ; MSCODE.ASM
  3706                                  ;============================================================================
  3707                                  
  3708                                  ; Retro DOS v2.0 (NASM 2.11) source code modifications by Erdogan Tan
  3709                                  ; 03/03/2018
  3710                                  
  3711                                  ;
  3712                                  ; MSCODE.ASM -- MSDOS code
  3713                                  ;
  3714                                  
  3715                                  ;INCLUDE DOSSEG.ASM
  3716                                  ;INCLUDE STDSW.ASM
  3717                                  
  3718                                  ;CODE    SEGMENT BYTE PUBLIC  'CODE'
  3719                                  ;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  3720                                  
  3721                                  ;.xcref
  3722                                  ;INCLUDE DOSSYM.ASM
  3723                                  ;INCLUDE DEVSYM.ASM
  3724                                  ;.cref
  3725                                  ;.list
  3726                                  
  3727                                  ;IFNDEF  KANJI
  3728                                  ;KANJI   EQU     0       ; FALSE
  3729                                  ;ENDIF
  3730                                  
  3731                                  ;IFNDEF  IBM
  3732                                  ;IBM     EQU     0
  3733                                  ;ENDIF
  3734                                  
  3735                                  ;IFNDEF  HIGHMEM
  3736                                  ;HIGHMEM  EQU     0
  3737                                  ;ENDIF
  3738                                  
  3739                                          ;i_need  USER_SP,WORD
  3740                                          ;i_need  USER_SS,WORD
  3741                                          ;i_need  SAVEDS,WORD
  3742                                          ;i_need  SAVEBX,WORD
  3743                                          ;i_need  INDOS,BYTE
  3744                                          ;i_need  NSP,WORD
  3745                                          ;i_need  NSS,WORD
  3746                                          ;i_need  CURRENTPDB,WORD
  3747                                          ;i_need  AUXSTACK,BYTE
  3748                                          ;i_need  CONSWAP,BYTE
  3749                                          ;i_need  IDLEINT,BYTE
  3750                                          ;i_need  NOSETDIR,BYTE
  3751                                          ;i_need  ERRORMODE,BYTE
  3752                                          ;i_need  IOSTACK,BYTE
  3753                                          ;i_need  WPERR,BYTE
  3754                                          ;i_need  DSKSTACK,BYTE
  3755                                          ;i_need  CNTCFLAG,BYTE
  3756                                          ;i_need  LEAVEADDR,WORD
  3757                                          ;i_need  NULLDEVPT,DWORD
  3758                                  
  3759                                          ;IF NOT IBM
  3760                                          ;i_need  OEM_HANDLER,DWORD
  3761                                          ;ENDIF
  3762                                  
  3763                                          ;EXTRN   DSKSTATCHK:NEAR,GETBP:NEAR,DSKREAD:NEAR,DSKWRITE:NEAR
  3764                                  
  3765                                  ;============================================================================
  3766                                  ; MSDISP.ASM, MSDOS 6.0, 1991
  3767                                  ;============================================================================
  3768                                  ; 11/07/2018 - Retro DOS v3.0
  3769                                  ; 01/05/2019 - Retro DOS v4.0
  3770                                  
  3771                                  ; DosCode SEGMENT
  3772                                  
  3773                                  ; ==========================================================================
  3774                                  ;
  3775                                  ; $Set_CTRL_C_Trapping
  3776                                  ;
  3777                                  ; Function:
  3778                                  ;	Enable disable ^C checking in dispatcher
  3779                                  ;
  3780                                  ; Inputs:
  3781                                  ;		AL = 0 read ^C status
  3782                                  ;		AL = 1 Set ^C status, DL = 0/1 for ^C off/on
  3783                                  ;		AL = 2 Set ^C status to contents of DL.	Output is old state.
  3784                                  ;		AL = 5 get DOS boot drive
  3785                                  ;		AL = 6 Get version number
  3786                                  ;			RETURNS:
  3787                                  ;				BH = Minor version number
  3788                                  ;				BL = Major version number
  3789                                  ;				DL = DOS internal revision
  3790                                  ;				DH = DOS type flags
  3791                                  ;					Bit 3 	- DOS in ROM
  3792                                  ;					Bit 4 	- DOS in HMA
  3793                                  ;					Bit 0-2, 5-7 - Reserved
  3794                                  ; Outputs:
  3795                                  ;		If AL = 0 then DL = 0/1 for ^C off/on
  3796                                  ;
  3797                                  ; History:
  3798                                  ;      removed	AL = 3 Get CPSW state to DL	    DOS 3.4
  3799                                  ;      removed	AL = 4 Set CPSW state from DL	    DOS 3.4
  3800                                  ; ==========================================================================
  3801                                  
  3802                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3803                                  ; DOSCODE:4045h (MSDOS 5.0, MSDOS.SYS)
  3804                                  
  3805                                  ; 01/01/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
  3806                                  ; DOSCODE:4052h (MSDOS 6.21, MSDOS.SYS)
  3807                                  ; DOSCODE:4052h (MSDOS 6.22, MSDOS.SYS)
  3808                                  ; DOSCODE:4123h (PCDOS 7.1, IBMDOS.COM)
  3809                                  
  3810                                  _$SET_CTRL_C_TRAPPING:
  3811                                  	; 01/05/2019 - Retro DOS v4.0
  3812                                  
  3813 00000267 3C06                    	cmp	AL,6			; Is this a valid subfunction?
  3814 00000269 7603                    	jbe	short scct_1		; If yes continue processing
  3815                                  
  3816 0000026B B0FF                    	mov	AL,0FFh			; Else set AL to -1 and
  3817 0000026D CF                      	iret
  3818                                  scct_1:
  3819 0000026E 1E                      	push	DS
  3820                                  
  3821                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3822 0000026F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3823                                  	
  3824 00000274 50                      	push	AX			; DL only register that can change
  3825 00000275 56                      	push	SI
  3826                                  
  3827 00000276 BE[3703]                	mov	SI,CNTCFLAG		; DS:SI --> Ctrl C Status byte
  3828 00000279 30E4                    	xor	AH,AH			; Clear high byte of AX
  3829 0000027B 09C0                    	or	AX,AX			; Check for subfunction 0
  3830 0000027D 7504                    	jnz	short scct_2		; If not 0 jmp to next check
  3831                                  
  3832 0000027F 8A14                    	mov	DL,[SI]			; Else move current ctrl C status
  3833 00000281 EB30                    	jmp	SHORT scct_9s		; into DL and jmp to exit
  3834                                  scct_2:
  3835 00000283 48                      	dec	AX			; Now dec AX and see if it was 1
  3836 00000284 7507                    	jnz	short scct_3		; If not 0 it wasn't 1 so do next chk
  3837                                  
  3838 00000286 80E201                  	and	DL,1			; Else mask off bit 0 of DL and
  3839 00000289 8814                    	mov	[SI],DL			; save it as new Ctrl C status
  3840 0000028B EB26                    	jmp	SHORT scct_9s		; Jmp to exit
  3841                                  scct_3:
  3842 0000028D 48                      	dec	AX			; Dec AX again to see if it was 2
  3843 0000028E 7507                    	jnz	short scct_4		; If not 0 wasn't 2 so go to next chk
  3844                                  
  3845 00000290 80E201                  	and	DL,1			; Else mask off bit 0 of DL and
  3846 00000293 8614                    	xchg	[SI],DL			; Exchange DL with old status byte
  3847 00000295 EB1C                    	jmp	SHORT scct_9s		; Jump to exit (returning old status)
  3848                                  scct_4:
  3849 00000297 3C03                    	cmp	al,3 ; 01/01/2024 (PCDOS 7.1 IBMDOS.COM)
  3850                                  	;cmp	AX,3 			; Test for 5 after it was dec twice
  3851 00000299 7506                    	jne	short scct_5		; If not equal then not get boot drv
  3852 0000029B 8A16[6900]              	mov	DL,[BOOTDRIVE]		; Else return boot drive in DL
  3853 0000029F EB12                    	jmp	SHORT scct_9s		; Jump to exit (returning boot drive)
  3854                                  scct_5:
  3855 000002A1 3C04                    	cmp	al,4 ; 01/01/2024 (PCDOS 7.1 IBMDOS.COM)
  3856                                  	;cmp	AX,4 			; Test for 6 after it was dec twice
  3857 000002A3 750E                    	jne	short scct_9s		; If not equal then not get version
  3858                                  	
  3859                                  	;mov	BX,(Minor_Version SHL 8) + Major_Version
  3860                                  	;mov	bx,1406h	; DOSCODE:4092h (MSDOS 6.21, MSDOS.SYS)
  3861 000002A5 BB0616                  	mov	bx,(MINOR_VERSION<<8)+MAJOR_VERSION
  3862                                  	
  3863                                  	;mov	dl,0
  3864                                  	;mov	DL,DOSREVNM ; 0
  3865                                  
  3866                                  	;xor	dh,dh			; assume vanilla DOS
  3867                                  	; 01/01/2024
  3868 000002A8 BA0000                  	mov	dx,0
  3869 000002AB 3836[F211]              	cmp	byte [DosHasHMA],dh ; 0
  3870                                  	;cmp	byte [DosHasHMA],0	; is DOS in HMA?  (M021)
  3871                                  	;je	short @F
  3872 000002AF 7402                    	je	short scct_6
  3873                                  	; 01/01/2024
  3874 000002B1 B610                    	mov	dh,10h
  3875                                  	;or	dh,10h
  3876                                  	;;or	DH,DOSINHMA ; 10h
  3877                                  ;@@:
  3878                                  scct_6:
  3879                                  
  3880                                  ;ifdef ROMDOS
  3881                                  ;	or	DH,DOSINROM ; 08h
  3882                                  ;endif ; ROMDOS
  3883                                  
  3884                                  scct_9s:
  3885 000002B3 5E                      	pop	SI
  3886 000002B4 58                      	pop	AX
  3887 000002B5 1F                      	pop	DS
  3888                                  scct_9f:
  3889 000002B6 CF                      	iret
  3890                                  
  3891                                  SetCtrlShortEntry:			; This allows a conditional entry
  3892                                  					; from main dispatch code
  3893 000002B7 EBAE                    	jmp	SHORT _$SET_CTRL_C_TRAPPING
  3894                                  
  3895                                  ; ==========================================================================
  3896                                  ;									   
  3897                                  ; The following two routines are dispatched to directly with ints disabled
  3898                                  ; immediately after the int 21h entry.	no DIS state is set.
  3899                                  ;
  3900                                  ; $Set_current_PDB takes BX and sets it to be the current process
  3901                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  3902                                  ;
  3903                                  ; ==========================================================================
  3904                                  
  3905                                  _$SET_CURRENT_PDB:
  3906 000002B9 1E                      	push	DS
  3907                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3908 000002BA 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3909 000002BF 891E[3003]              	mov	[CurrentPDB],BX		; Set new PSP segment from caller's BX
  3910 000002C3 1F                      	pop	DS
  3911 000002C4 CF                      	iret
  3912                                  
  3913                                  ; ==========================================================================
  3914                                  ;
  3915                                  ; $get_current_PDB returns in BX the current process
  3916                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  3917                                  ;
  3918                                  ; ==========================================================================
  3919                                  
  3920                                  _$GET_CURRENT_PDB:
  3921 000002C5 1E                      	push	DS
  3922                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3923 000002C6 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3924 000002CB 8B1E[3003]              	mov	BX,[CurrentPDB]		; Return current PSP segment in BX
  3925 000002CF 1F                      	pop	DS
  3926 000002D0 CF                      	iret
  3927                                  
  3928                                  ; ==========================================================================
  3929                                  ;
  3930                                  ; Sets the Printer Flag to whatever is in AL.
  3931                                  ; NOTE: THIS PROCEDURE IS SUBJECT TO CHANGE!!!
  3932                                  ;
  3933                                  ; ==========================================================================
  3934                                  
  3935                                  _$SET_PRINTER_FLAG:
  3936 000002D1 1E                      	push	ds
  3937                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3938 000002D2 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3939 000002D7 A2[A00A]                	mov	[PRINTER_FLAG],AL 	; Set printer flag from caller's AL
  3940 000002DA 1F                      	pop	ds
  3941 000002DB CF                      	iret
  3942                                  
  3943                                  ; 01/05/2019 - Retro DOS v4.0
  3944                                  ; 08/07/2018 - Retro DOS v3.0
  3945                                  ; (MSDISP.ASM, MSDOS 6.0, 1991)
  3946                                  
  3947                                  ; ----------------------------------------------------------------------------
  3948                                  ; BREAK   <System call entry points and dispatcher>
  3949                                  ; ----------------------------------------------------------------------------
  3950                                  
  3951                                  ; DOSCODE:40CCh (MSDOS 6.21, MSDOS.SYS)
  3952                                  
  3953                                  ; ==========================================================================
  3954                                  ;
  3955                                  ; The Quit entry point is where all INT 20h's come from. These are old- style
  3956                                  ; exit system calls. The CS of the caller indicates which Process is dying.
  3957                                  ; The error code is presumed to be 0. We simulate an ABORT system call.
  3958                                  ;
  3959                                  ; ==========================================================================
  3960                                  
  3961                                  SYSTEM_CALL:    ; PROC NEAR
  3962                                  
  3963                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3964                                  ; DOSCODE:40BFh (MSDOS 5.0, MSDOS.SYS)
  3965                                  
  3966                                  ;entry	QUIT				
  3967                                  QUIT:				; INT 20H entry point	
  3968                                  	;MOV	AH,0
  3969 000002DC 30E4                    	xor	ah,ah ; 08/07/2018
  3970 000002DE EB36                    	JMP     SHORT SAVREGS
  3971                                  
  3972                                  ; ---------------------------------------------------------------------------
  3973                                  
  3974                                  	; The system call in AH is out of the range that we know how
  3975                                  	; to handle. We arbitrarily set the contents of AL to 0 and
  3976                                  	; IRET. Note that we CANNOT set the carry flag to indicate an
  3977                                  	; error as this may break some programs compatability.
  3978                                  
  3979                                  BADCALL:
  3980                                          ;MOV	AL,0
  3981 000002E0 30C0                    	xor	al,al ; 08/07/2018
  3982                                  IRETT:	; 06/05/2019
  3983                                  _IRET:
  3984 000002E2 CF                              IRET
  3985                                  
  3986                                  ; ---------------------------------------------------------------------------
  3987                                  
  3988                                  ; 01/05/2019 - Retro DOS v4.0
  3989                                  ; DOSCODE:40D3h (MSDOS 6.21 MSDOS.SYS)
  3990                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3991                                  ; DOSCODE:40C6h (MSDOS 5.0 MSDOS.SYS)
  3992                                  
  3993                                  	; An alternative method of entering the system is to perform a
  3994                                  	; CALL 5 in the program segment prefix with the contents of CL
  3995                                  	; indicating what system call the user would like. A subset of
  3996                                  	; the possible system calls is allowed here only the
  3997                                  	; CPM-compatible calls may get dispatched.
  3998                                  
  3999                                  		; System call entry point and dispatcher
  4000                                  CALL_ENTRY:
  4001 000002E3 1E                      	push	DS
  4002                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4003 000002E4 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4004 000002E9 8F06[EC05]              	pop	word [SAVEDS]		; Save original DS
  4005                                  
  4006 000002ED 58                              POP     AX                      ; IP from the long call at 5
  4007 000002EE 58                              POP     AX                      ; Segment from the long call at 5
  4008 000002EF 8F06[8405]              	POP	WORD [USER_SP]		; IP from the CALL 5
  4009                                  
  4010                                  		; Re-order the stack to simulate an interrupt 21.
  4011                                  
  4012 000002F3 9C                      	PUSHF				; Start re-ordering the stack
  4013 000002F4 FA                      	CLI
  4014 000002F5 50                              PUSH    AX                      ; Save segment
  4015 000002F6 FF36[8405]                      PUSH	WORD [USER_SP]		; Stack now ordered as if INT had been used
  4016                                  	; 04/11/2022
  4017                                  	; DOSCODE:40EAh (MSDOS 6.21 MSDOS.SYS)
  4018                                  	; DOSCODE:40DDh (MSDOS 5.0 MSDOS.SYS)
  4019 000002FA FF36[EC05]              	push	word [SAVEDS]
  4020 000002FE 1F                      	pop	ds
  4021                                  	;
  4022                                  	;cmp	cl,36
  4023 000002FF 80F924                          CMP     CL,MAXCALL              ; This entry point doesn't get as many calls
  4024 00000302 77DC                            JA      SHORT BADCALL
  4025 00000304 88CC                            MOV     AH,CL
  4026                                  	; 08/07/2018
  4027 00000306 EB0E                    	jmp	short SAVREGS
  4028                                  
  4029                                  ; ---------------------------------------------------------------------------
  4030                                  
  4031                                  ; 01/05/2019 - Retro DOS v4.0
  4032                                  
  4033                                  	; This is the normal INT 21 entry point. We first perform a
  4034                                  	; quick test to see if we need to perform expensive DOS-entry
  4035                                  	; functions. Certain system calls are done without interrupts
  4036                                  	; being enabled.
  4037                                  
  4038                                  	;entry	COMMAND 		; Interrupt call entry point (int 21h)
  4039                                  
  4040                                  ; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
  4041                                  ; 04/11/2022
  4042                                  ; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)
  4043                                  
  4044                                  COMMAND:
  4045                                  	; 22/12/2022
  4046 00000308 FA                      	cli
  4047                                  
  4048                                  	; 01/05/2019 - Retro DOS v4.0
  4049                                  	; 08/07/2018 - Retro DOS v3.0
  4050                                  
  4051                                  ; 22/12/2022
  4052                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4053                                  	;IF	NOT IBM
  4054 00000309 80FCF8                  	CMP	AH,SET_OEM_HANDLER
  4055 0000030C 7203                    	JB	SHORT NOTOEM
  4056 0000030E E97A01                  	JMP	_$SET_OEM_HANDLER
  4057                                  
  4058                                  NOTOEM:
  4059                                  	;ENDIF
  4060                                  
  4061                                  ; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
  4062                                  ; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)
  4063                                  
  4064                                  	; 22/12/2022
  4065                                  	;cli	; 08/07/2018
  4066                                  
  4067                                  _COMMAND: ; MSDOS 3.3 (IBM)
  4068                                  	;cmp	ah,6Ch   ; MSDOS 6.21 ; Max int 21h function call number
  4069                                  	; 04/11/2022
  4070 00000311 80FC6C                  	CMP     AH,MAXCOM  ; 6Ch for MSDOS 6.0 (6.21,6.22) & MSDOS 5.0
  4071                                  	;JBE	SHORT SAVREGS
  4072 00000314 77CA                            JA	SHORT BADCALL ; 08/07/2018
  4073                                  
  4074                                  	; 31/05/2019
  4075                                  
  4076                                  	; The following set of calls are issued by the server at
  4077                                  	; *arbitrary* times and, therefore, must be executed on
  4078                                  	; the user's entry stack and executed with interrupts off.
  4079                                  
  4080                                  SAVREGS:
  4081                                  	; 01/05/2019 - Retro DOS v4.0
  4082                                  	; 10/08/2018
  4083                                  	; 08/07/2018 - Retro DOS v3.0
  4084 00000316 80FC33                  	cmp	ah,33h			; Check Minimum special case #
  4085                                  	;;je	_$SET_CTRL_C_TRAPPING
  4086                                  	;je	short SetCtrlShortEntry ; If equal jmp directly to function
  4087 00000319 7218                    	jb	short SaveAllRegs	; Not special case so continue	
  4088                                  	; 04/11/2022
  4089 0000031B 749A                    	je	short SetCtrlShortEntry ; If equal jmp directly to function
  4090 0000031D 80FC64                  	cmp	ah,64h			; Check Max case number
  4091 00000320 7711                    	ja	short SaveAllRegs	; Not special case so continue
  4092 00000322 74AD                    	je	short _$SET_PRINTER_FLAG ; If equal jmp directly to function
  4093 00000324 80FC51                  	cmp	ah,51h			; Is this a Get PSP call (51h)?
  4094 00000327 749C                    	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
  4095 00000329 80FC62                  	cmp	ah,62h			; Is this a Get PSP call (62h)?
  4096 0000032C 7497                    	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
  4097 0000032E 80FC50                  	cmp     ah,50h			; Is this a Set PSP call (50h) ?
  4098 00000331 7486                    	je	short _$SET_CURRENT_PDB	; Yes, jmp directly to function
  4099                                  
  4100                                  SaveAllRegs:
  4101                                  	; 01/05/2019 - Retro DOS v4.0
  4102                                  
  4103 00000333 06                              push	ES
  4104 00000334 1E                      	push	DS
  4105 00000335 55                      	push	BP
  4106 00000336 57                      	push	DI
  4107 00000337 56                      	push	SI
  4108 00000338 52                      	push	DX
  4109 00000339 51                      	push	CX
  4110 0000033A 53                      	push	BX
  4111 0000033B 50                      	push	AX
  4112                                  
  4113 0000033C 8CD8                    	mov	AX,DS
  4114                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4115 0000033E 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4116 00000343 A3[EC05]                	mov	[SAVEDS],AX		; save caller's DS
  4117 00000346 891E[EA05]              	mov	[SAVEBX],BX
  4118                                  
  4119                                          ;INC     BYTE [INDOS]		; Flag that we're in the DOS
  4120                                  	
  4121                                  	; 08/07/2018 - Retro DOS v3.0        
  4122                                  	;xor     ax,ax
  4123                                  	;mov     [USER_ID],ax
  4124                                  	;mov     ax,[CurrentPDB]
  4125                                  	;mov     [PROC_ID],ax
  4126                                  
  4127                                  	; 01/05/2019
  4128                                  
  4129                                  	; Note: Nsp and Nss have to be unconditionally initialized here 
  4130                                  	; even if InDOS is zero. Programs like CROSSTALK 3.7 depend on
  4131                                  	; this!!!
  4132                                  
  4133 0000034A A1[8405]                	MOV     AX,[USER_SP]
  4134 0000034D A3[F205]                        MOV     [NSP],AX
  4135 00000350 A1[8605]                        MOV     AX,[USER_SS]
  4136 00000353 A3[F005]                        MOV     [NSS],AX
  4137                                  
  4138 00000356 31C0                    	xor	AX,AX ; 0
  4139 00000358 A2[7205]                	mov	[FSHARING],AL		; allow redirection
  4140                                  
  4141 0000035B F606[3010]01            	test	byte [IsWin386],1	; WIN386 patch. Do not update USER_ID
  4142 00000360 7503                    	jnz	short set_indos_flag	; if win386 present
  4143 00000362 A3[3E03]                	mov	[USER_ID],AX
  4144                                  set_indos_flag:
  4145 00000365 FE06[2103]              	INC     BYTE [INDOS]		; Flag that we're in the DOS
  4146                                  
  4147 00000369 8926[8405]                      MOV     [USER_SP],SP
  4148 0000036D 8C16[8605]                      MOV     [USER_SS],SS
  4149                                  
  4150 00000371 A1[3003]                	mov	AX,[CurrentPDB]
  4151 00000374 A3[3C03]                	mov	[PROC_ID],AX
  4152 00000377 8ED8                    	mov	DS,AX
  4153 00000379 58                      	pop	AX
  4154 0000037A 50                      	push	AX
  4155                                  
  4156                                  	; save user stack in his area for later returns (possibly from EXEC)
  4157                                  
  4158 0000037B 89262E00                        MOV     [PDB.USER_STACK],SP
  4159 0000037F 8C163000                        MOV     [PDB.USER_STACK+2],SS
  4160                                  
  4161                                  	; 18/07/2018
  4162                                  	;mov	byte [CS:FSHARING], 0
  4163                                  
  4164                                  	;MOV     BX,CS			; no holes here.
  4165                                  	;MOV     SS,BX
  4166                                  
  4167                                  	;getdseg <ss>			; ss -> dosdat, already flag is CLI
  4168 00000383 2E8E16[0700]            	mov	ss,[cs:DosDSeg]
  4169                                  					;entry	REDISP
  4170                                  REDISP:
  4171 00000388 BC[A007]                        MOV     SP,AUXSTACK		; Enough stack for interrupts
  4172 0000038B FB                              STI                             ; stack is in our space now...
  4173                                  
  4174 0000038C 8CD3                    	mov	bx,ss
  4175 0000038E 8EDB                    	mov	ds,bx
  4176                                  
  4177 00000390 93                      	xchg	ax,bx
  4178                                  
  4179 00000391 31C0                    	xor	ax,ax ; 0
  4180                                  
  4181                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4182                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:416Eh  (from org 3DD0h)
  4183                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:417Bh (from org 3DE0h)
  4184                                  
  4185                                  	; (Note: ss: segment prefix was not needed here! ds=ss ! -04/11/2022-)
  4186                                  
  4187                                  	;mov	[ss:EXTOPEN_ON],al ; 0	; Clear extended open flag
  4188                                  	;;and	word [ss:DOS34_FLAG],EXEC_AWARE_REDIR
  4189                                  	;and	word [ss:DOS34_FLAG],800h ; clear all bits except bit 11
  4190                                  	;mov	[ss:CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
  4191                                  	;mov	[ss:NoSetDir],al ; 0	; set directories on search
  4192                                  	;mov	[ss:FAILERR],al ; 0	; FAIL not in progress
  4193                                  	;inc	ax
  4194                                  	;;inc	AL			; AL = 1
  4195                                  	;mov	[ss:IDLEINT],al		; presume that we can issue INT 28
  4196                                  
  4197                                  	; 15/12/2022
  4198 00000393 A2[F605]                	mov	[EXTOPEN_ON],al ; 0	; Clear extended open flag
  4199                                  	;and	word [DOS34_FLAG],EXEC_AWARE_REDIR
  4200 00000396 8126[1106]0008          	and	word [DOS34_FLAG],800h	; clear all bits except bit 11
  4201 0000039C A2[5703]                	mov	[CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
  4202                                  	;mov	byte [IDLEINT],1
  4203 0000039F A2[4C03]                	mov	[NoSetDir],al ; 0	; set directories on search
  4204 000003A2 A2[4A03]                	mov	[FAILERR],al ; 0	; FAIL not in progress
  4205 000003A5 40                      	inc	ax
  4206                                  	;inc	al			; AL = 1
  4207 000003A6 A2[5803]                	mov	[IDLEINT],al		; presume that we can issue INT 28
  4208                                  
  4209 000003A9 93                      	XCHG	AX,BX			; Restore AX and BX = 1		
  4210                                  
  4211 000003AA 88E3                    	MOV     BL,AH			
  4212 000003AC D1E3                            SHL     BX,1			; 2 bytes per call in table
  4213                                         
  4214 000003AE FC                      	CLD
  4215                                  		; Since the DOS maintains mucho state information across system
  4216                                  		; calls, we must be very careful about which stack we use.
  4217                                  		; First, all abort operations must be on the disk stack. This
  4218                                  		; is due to the fact that we may be hitting the disk (close
  4219                                  		; operations, flushing) and may need to report an INT 24.
  4220                                          
  4221 000003AF 08E4                    	OR      AH,AH
  4222 000003B1 7416                            JZ      SHORT DSKROUT		; ABORT
  4223                                  
  4224                                          ;CMP	AH,12
  4225                                          ;JBE	SHORT IOROUT		; Character I/O
  4226                                          ;CMP	AH,GET_CURRENT_PDB      ; INT 24 needs GET,SET PDB
  4227                                          ;JZ	SHORT IOROUT
  4228                                          ;CMP	AH,SET_CURRENT_PDB
  4229                                          ;JNZ	SHORT DSKROUT
  4230                                  
  4231                                  		; Second, PRINT and PSPRINT and the server issue
  4232                                  		; GetExtendedError calls at INT 28 and INT 24 time.
  4233                                  		; This call MUST, therefore, use the AUXSTACK.
  4234                                  
  4235                                  	; 10/08/2018
  4236 000003B3 80FC59                  	cmp     ah,GETEXTENDEDERROR ; 59h
  4237 000003B6 7434                    	je      short DISPCALL
  4238                                  	
  4239                                  	; 01/05/2019
  4240                                  	
  4241                                  		; Old 1-12 system calls may be either on the IOSTACK (normal
  4242                                  		; operation) or on the AUXSTACK (at INT 24 time).
  4243                                  
  4244 000003B8 80FC0C                  	cmp     ah,12 ; STD_CON_INPUT_FLUSH ; 0Ch
  4245 000003BB 770C                    	ja      short DSKROUT
  4246                                  
  4247                                  IOROUT:
  4248                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4249                                  	; (ss: prefix was not needed here! ds=ss)
  4250                                  	;cmp	byte [ss:ERRORMODE],0	; Are we in an INT 24? 
  4251                                  	; 15/12/2022
  4252 000003BD 803E[2003]00            	cmp     BYTE [ERRORMODE],0	; Are we in an INT 24?
  4253 000003C2 7528                            JNZ     SHORT DISPCALL		; Stay on AUXSTACK if INT 24
  4254 000003C4 BC[A00A]                        MOV     SP,IOSTACK
  4255 000003C7 EB23                            JMP     SHORT DISPCALL
  4256                                  
  4257                                  		; We are on a system call that is classified as "the rest".
  4258                                  		; We place ourselves onto the DSKSTACK and away we go.
  4259                                  		; We know at this point:
  4260                                  		; *  An INT 24 cannot be in progress. Therefore we reset
  4261                                  		;    ErrorMode and WpErr
  4262                                  		; *  That there can be no critical sections in effect.
  4263                                  		;    We signal the server to remove all the resources.
  4264                                  
  4265                                  DSKROUT:
  4266                                  	; 01/01/2024
  4267                                  	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4268                                  	; 08/07/2018 - Retro DOS v3.0
  4269 000003C9 A3[3A03]                	mov     [USER_IN_AX],ax		; Remember what user is doing
  4270                                  	; 01/01/2024
  4271                                  	;mov	byte [EXTERR_LOCUS],1	; errLOC_Unk (Default)
  4272                                  	;MOV	BYTE [WPERR],-1		; error mode, so good place to
  4273                                  	                   		; make sure flags are reset
  4274 000003CC C706[2203]FF01          	mov	word [WPERR],1FFh ; (PCDOS 7.1 IBMDOS.COM))
  4275                                  
  4276                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4277                                  	; (ss: prefix was not needed here! ds=ss)
  4278                                  
  4279                                  	;mov	[ss:USER_IN_AX],ax	; Remember what user is doing
  4280                                  	;mov	byte [ss:EXTERR_LOCUS],1 ; errLOC_Unk (Default)
  4281                                  	;mov	byte [ss:ERRORMODE],0	; Cannot make non 1-12 calls in
  4282                                  	;mov	byte [ss:WPERR],-1	; error mode, so good place to
  4283                                                                          ; make sure flags are reset
  4284 000003D2 50                      	push    ax
  4285 000003D3 B482                    	mov     ah,82h			; Release all resource information
  4286 000003D5 CD2A                    	int     2Ah 		; Microsoft Networks 
  4287                                  				; END DOS CRITICAL SECTIONS 0 THROUGH 7
  4288 000003D7 58                      	pop     ax
  4289                                  
  4290                                  		; Since we are going to be running on the DSKStack and since
  4291                                  		; INT 28 people will use the DSKStack, we must turn OFF the
  4292                                  		; generation of INT 28's.
  4293                                  
  4294                                  	; 15/12/2022
  4295                                  	;mov     byte [ss:IDLEINT],0
  4296                                  	;
  4297                                          ;mov	sp,DSKSTACK
  4298                                  	;test	byte [ss:CNTCFLAG],-1  ; 0FFh
  4299                                          ;jz	short DISPCALL
  4300                                  
  4301 000003D8 C606[5803]00            	mov     byte [IDLEINT],0
  4302                                  
  4303 000003DD BC[2009]                	MOV     SP,DSKSTACK
  4304 000003E0 F606[3703]FF            	TEST    BYTE [CNTCFLAG],-1
  4305 000003E5 7405                    	JZ      SHORT DISPCALL
  4306                                  
  4307 000003E7 50                              PUSH    AX
  4308                                          ;invoke	DSKSTATCHK
  4309 000003E8 E8D04C                          CALL	DSKSTATCHK
  4310 000003EB 58                      	POP     AX
  4311                                  DISPCALL:
  4312                                  	; 01/05/2019 - Retro DOS v4.0
  4313 000003EC 2E8B9F[EA00]            	mov	bx,[CS:BX+DISPATCH]
  4314                                  
  4315                                  	; 15/12/2022
  4316 000003F1 871E[EA05]              	xchg	bx,[SAVEBX]
  4317 000003F5 8E1E[EC05]              	MOV	DS,[SAVEDS]
  4318                                  
  4319                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4320                                  	; (ss: prefix was not needed here! ds=ss)        
  4321                                  	;xchg	bx,[ss:SAVEBX]
  4322                                  	;mov	ds,[ss:SAVEDS]
  4323                                  
  4324 000003F9 36FF16[EA05]            	call	word [SS:SAVEBX] ; near call
  4325                                  
  4326                                  	; The EXEXA20OFF bit of DOS_FLAG will now be unconditionally cleared
  4327                                  	; here. Please see under M003, M009 and M068 tags in dossym.inc
  4328                                  	; for explanation. Also NOTE that a call to ExecReady (ax=4b05) will
  4329                                  	; return to LeaveDos and hence will not clear this bit. This is 
  4330                                  	; because this bit is used to indicate to the next int 21 call that
  4331                                  	; the previous int 21 was an exec.
  4332                                  	;
  4333                                  	; So do not add any code between the call above and the label 
  4334                                  	; LeaveDOS if it needs to be executed even for ax=4b05
  4335                                  
  4336                                  	;and	byte [ss:DOS_FLAG],~EXECA20OFF
  4337 000003FE 368026[8600]FB          	and	byte [ss:DOS_FLAG],0FBh
  4338                                  
  4339                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4340                                  ; DOSCODE:41F7h
  4341                                  
  4342                                  ; 01/01/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
  4343                                  ; DOSCODE:4204h
  4344                                  
  4345                                  ;entry LEAVE
  4346                                  ;;;_LEAVE:				; Exit from a system call
  4347                                  LeaveDOS: ; 18/07/2018 
  4348                                  ;ASSUME	SS:NOTHING			; User routines may misbehave
  4349 00000404 FA                      	CLI
  4350                                  
  4351                                  	; 01/05/2019
  4352                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4353 00000405 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4354 0000040A 803E[8500]00            	cmp	byte [A20OFF_COUNT],0	; M068: Q: is count 0
  4355 0000040F 7526                    	jne	short disa20		; M068: N: dec count and turn a20 off
  4356                                  
  4357                                  LeaveA20On:
  4358 00000411 FE0E[2103]                      DEC     BYTE [INDOS]
  4359                                          ; 04/11/2022
  4360 00000415 8E16[8605]              	mov	ss,[USER_SS]
  4361 00000419 8B26[8405]              	MOV     SP,[USER_SP]
  4362                                  	;MOV	SS,[USER_SS]
  4363 0000041D 89E5                    	MOV     BP,SP
  4364                                  	;MOV	[BP.user_AX],AL	
  4365                                          ; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4366                                  	;;mov	[bp+0],al ; MSDOS 5.0 MSDOS.SYS - DOSCODE:4212h
  4367                                  	;MOV	[BP+user_env.user_AX],AL  ; user_env.user_AX = 0
  4368                                  
  4369                                  	; 15/12/2022
  4370 0000041F 884600                  	MOV	[BP],AL	; mov [bp+0],al
  4371                                  	
  4372                                  	;MOV	AX,[NSP]
  4373                                          ;MOV	[USER_SP],AX
  4374                                          ;MOV	AX,[NSS]
  4375                                          ;MOV	[USER_SS],AX
  4376                                  	; 01/01/2024
  4377 00000422 C406[F005]              	les	ax,[NSS] ; (PCDOS 7.1 IBMDOS.COM)
  4378 00000426 A3[8605]                	mov	[USER_SS],ax
  4379 00000429 8C06[8405]              	mov	[USER_SP],es
  4380                                  
  4381 0000042D 58                      	pop	AX
  4382 0000042E 5B                      	pop	BX
  4383 0000042F 59                      	pop	CX
  4384 00000430 5A                      	pop	DX
  4385 00000431 5E                      	pop	SI
  4386 00000432 5F                      	pop	DI
  4387 00000433 5D                      	pop	BP
  4388 00000434 1F                      	pop	DS
  4389 00000435 07                      	pop	ES
  4390                                  
  4391 00000436 CF                              IRET
  4392                                  
  4393                                  disa20:	   				; M068 - Start
  4394 00000437 8B1E[6300]              	mov	bx,[A20OFF_PSP]		; bx = PSP for which a20 to be off'd
  4395 0000043B 3B1E[3003]              	cmp	bx,[CurrentPDB]		; Q: do the PSP's match
  4396 0000043F 75D0                    	jne	short LeaveA20On	; N: don't clear bit and don't turn 
  4397                                  					;    a20 off
  4398                                  					; Y: turn a20 off and dec a20off_count
  4399 00000441 FE0E[8500]              	dec	byte [A20OFF_COUNT]	; M068 - End
  4400                                   					; Start - M004
  4401 00000445 1E                      	push	ds			; segment of stub
  4402 00000446 BB[1311]                	mov	bx,disa20_iret		; offset in stub
  4403 00000449 53                      	push	bx
  4404 0000044A CB                      	retf	  			; go to stub
  4405                                  					; End - M004
  4406                                  ;SYSTEM_CALL ENDP
  4407                                  
  4408                                  ; DOSCODE:424Ch (MSDOS 6.21, MSDOS.SYS)
  4409                                  ; 04/11/2022
  4410                                  ; DOSCODE:423Fh (MSDOS 5.0, MSDOS.SYS)
  4411                                  
  4412                                  ; ==========================================================================
  4413                                  ;
  4414                                  ; Restore_World restores all registers ('cept SS:SP, CS:IP, flags) from
  4415                                  ; the stack prior to giving the user control
  4416                                  ;
  4417                                  ; ==========================================================================
  4418                                  
  4419                                  ; 01/05/2019 - Retro DOS v4.0
  4420                                  
  4421                                          ;procedure restore_world,NEAR
  4422                                  restore_world:
  4423                                  	;getdseg <es>		; es -> dosdata
  4424 0000044B 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4425                                  
  4426 00000450 268F06[EE05]                    POP	WORD [ES:RESTORE_TMP]
  4427                                  
  4428 00000455 58                              POP     AX
  4429 00000456 5B                              POP     BX
  4430 00000457 59                              POP     CX
  4431 00000458 5A                              POP     DX
  4432 00000459 5E                              POP     SI
  4433 0000045A 5F                              POP     DI
  4434 0000045B 5D                              POP     BP
  4435 0000045C 1F                              POP     DS
  4436                                  
  4437 0000045D 26FF26[EE05]                   	jmp	word [ES:RESTORE_TMP]
  4438                                  
  4439                                  ;restore_world	ENDP
  4440                                  
  4441                                  ; 01/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDISP.ASM, 1991)
  4442                                  
  4443                                  ; DOSCODE:4263h (MSDOS 6.21, MSDOS.SYS)
  4444                                  ; 04/11/2022
  4445                                  ; DOSCODE:4256h (MSDOS 5.0, MSDOS.SYS)
  4446                                  
  4447                                  ; ==========================================================================
  4448                                  ;
  4449                                  ; Save_World saves complete registers on the stack
  4450                                  ;
  4451                                  ; ==========================================================================
  4452                                  
  4453                                          ;procedure save_world,NEAR
  4454                                  save_world:
  4455                                  	;getdseg <es>		; es -> dosdata
  4456 00000462 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4457                                  
  4458 00000467 268F06[EE05]                    POP	WORD [ES:RESTORE_TMP]
  4459                                  
  4460                                  	; 12/05/2019
  4461                                          
  4462 0000046C 1E                      	PUSH    DS
  4463 0000046D 55                              PUSH    BP
  4464 0000046E 57                              PUSH    DI
  4465 0000046F 56                              PUSH    SI
  4466 00000470 52                              PUSH    DX
  4467 00000471 51                              PUSH    CX
  4468 00000472 53                              PUSH    BX
  4469 00000473 50                              PUSH    AX
  4470                                  
  4471 00000474 26FF36[EE05]            	push	word [ES:RESTORE_TMP]
  4472                                  
  4473 00000479 55                      	push	BP		
  4474 0000047A 89E5                    	mov	BP,SP
  4475 0000047C 8E4614                  	mov	ES,[BP+20]	; es was pushed before call
  4476 0000047F 5D                      	pop	BP
  4477                                  	
  4478 00000480 C3                      	retn
  4479                                  
  4480                                  ;save_world	ENDP
  4481                                  
  4482                                  ; 01/05/2019
  4483                                  
  4484                                  ; DOSCODE:4282h (MSDOS 6.21, MSDOS.SYS)
  4485                                  ; 04/11/2022
  4486                                  ; DOSCODE:4275h (MSDOS 5.0, MSDOS.SYS)
  4487                                  
  4488                                  ; ==========================================================================
  4489                                  ;
  4490                                  ; Get_User_Stack returns the user's stack (and hence registers) in DS:SI
  4491                                  ;
  4492                                  ; ==========================================================================
  4493                                  
  4494                                          ;procedure get_user_stack,NEAR
  4495                                  Get_User_Stack:
  4496                                          ;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4497 00000481 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4498 00000486 C536[8405]                      lds	si,[USER_SP]
  4499 0000048A C3                      	retn
  4500                                  
  4501                                  ;get_user_stack  ENDP
  4502                                  
  4503                                  ; 22/12/2022
  4504                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
  4505                                  ;%if 0
  4506                                  
  4507                                  ; ---------------------------------------------------------------------------
  4508                                  ;
  4509                                  ; Set_OEM_Handler -- Set OEM sys call address and handle OEM Calls
  4510                                  ; Inputs:
  4511                                  ;	User registers, User Stack, INTS disabled
  4512                                  ;	If CALL F8, DS:DX is new handler address
  4513                                  ; Function:
  4514                                  ;	Process OEM INT 21 extensions
  4515                                  ; Outputs:
  4516                                  ;	Jumps to OEM_HANDLER if appropriate
  4517                                  ;
  4518                                  ; ---------------------------------------------------------------------------
  4519                                  
  4520                                  ;IF	NOT IBM
  4521                                  
  4522                                  _$SET_OEM_HANDLER:
  4523                                  	; 01/05/2019 - Retro DOS v4.0
  4524                                  	
  4525                                  	;(cmp	ah,SET OEM HANDLER  ; 0F8h)
  4526                                  	;(jb	short NOTOOEM)
  4527                                  
  4528 0000048B 06                      	push	es ; *
  4529                                  	;getdseg <es>			; es -> dosdata
  4530 0000048C 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4531                                  
  4532 00000491 750C                    	jne	short check_trueversion_request ; check Retro DOS true version
  4533                                  						; (message) request	
  4534                                  	; AH = 0F8h = SET OEM HANDLER
  4535                                  
  4536 00000493 268916[1400]            	MOV     [es:OEM_HANDLER],DX	; Set Handler
  4537 00000498 268C1E[1600]            	MOV     [es:OEM_HANDLER+2],DS
  4538                                  
  4539 0000049D 07                      	pop	es ; *
  4540                                  
  4541 0000049E CF                      	IRET                            ; Quick return, Have altered no registers
  4542                                  
  4543                                  check_trueversion_request:
  4544                                  	; 18/07/2019 - Retro DOS v3.0
  4545                                  
  4546                                  	; Retro DOS v2.0 - 20/04/2018
  4547 0000049F 83F8FF                  	CMP	AX,0FFFFh
  4548                                  	; 18/07/2018
  4549 000004A2 7520                    	jne	short DO_OEM_FUNC ; 01/05/2019
  4550                                  
  4551                                  	; 01/05/2019
  4552 000004A4 07                      	pop	es ; *
  4553                                  
  4554 000004A5 B40E                    	mov	ah,0Eh
  4555                                  
  4556                                  	; Retro DOS v4.0 feature only!
  4557 000004A7 81FBA101                	cmp	bx,417  ; Signature to bypass
  4558                                  			; Retro DOS true version message	
  4559 000004AB 7414                    	je	short true_version_iret
  4560                                  
  4561 000004AD 56                      	push	si
  4562 000004AE 53                      	push	bx
  4563                                  
  4564 000004AF BE[BF00]                	mov	si,RETRODOSMSG
  4565                                  wrdosmsg:
  4566                                  	;movb	ah,0Eh
  4567 000004B2 BB0700                  	mov	bx,7
  4568                                  wrdosmsg_nxt:
  4569 000004B5 2EAC                    	cs	lodsb
  4570 000004B7 3C24                    	cmp	al,'$'
  4571 000004B9 7404                    	je	short wrdosmsg_ok		
  4572 000004BB CD10                    	int	10h
  4573 000004BD EBF6                    	jmp	short wrdosmsg_nxt
  4574                                  
  4575                                  wrdosmsg_ok:
  4576 000004BF 5B                      	pop	bx
  4577 000004C0 5E                      	pop	si
  4578                                  
  4579                                  true_version_iret:
  4580                                  	; ah = 0Eh
  4581                                  	;mov	al,40h ; Retro DOS v4.0
  4582                                  	; 
  4583                                  	;mov	al,41h ; Retro DOS v4.1 
  4584                                  	; 30/12/2022
  4585 000004C1 B042                    	mov	al,42h ; Retro DOS v4.2
  4586 000004C3 CF                      	iret
  4587                                  
  4588                                  	; If above F8 try to jump to handler
  4589                                  
  4590                                  DO_OEM_FUNC:
  4591                                  	; 01/05/2019
  4592 000004C4 26833E[1400]FF          	cmp     word [es:OEM_HANDLER],-1
  4593 000004CA 7504                    	JNE     short OEM_JMP
  4594 000004CC 07                      	pop	es ; *
  4595 000004CD E910FE                  	JMP     BADCALL                 ; Handler not initialized
  4596                                  OEM_JMP:
  4597 000004D0 06                      	push	es
  4598 000004D1 1F                      	pop	ds ; DOSDATA segment !
  4599 000004D2 07                      	pop	es ; *
  4600                                  
  4601                                  	; 22/12/2022
  4602 000004D3 FB                      	sti	; (enable interrupts before jumping to private handler)  
  4603                                  
  4604 000004D4 FF2E[1400]              	JMP     FAR [OEM_HANDLER]
  4605                                  
  4606                                  ;       ENDIF
  4607                                  
  4608                                  ; ---------------------------------------------------------------------------
  4609                                  
  4610                                  ;%endif
  4611                                  
  4612                                  ;============================================================================
  4613                                  ; MCODE.ASM, MSDOS 6.0, 1991
  4614                                  ;============================================================================
  4615                                  ; 17/07/2018 - Retro DOS v3.0
  4616                                  
  4617                                  ;	TITLE	MISC DOS ROUTINES - Int 25 and 26 handlers and other
  4618                                  ;	NAME	IBMCODE
  4619                                  
  4620                                  ;BREAK <NullDev -- Driver for null device>
  4621                                  
  4622                                  ; ROMDOS note:
  4623                                  ;	NUL device driver used to be here, but it was removed and placed in
  4624                                  ;	DOSDATA, because the entry points have to be in the segment as the
  4625                                  ;	header, which is also in DOSDATA.
  4626                                  
  4627                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>
  4628                                  
  4629                                  ;----------------------------------------------------------------------------
  4630                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
  4631                                  ;----------------------------------------------------------------------------
  4632                                  ; DOSCODE:428Ch (MSDOS 6.21 MSDOS.SYS)
  4633                                  ; DOSCODE:427Fh (MSDOS 5.0 MSDOS.SYS)
  4634                                  
  4635                                  ;Public MSC001S,MSC001E
  4636                                  ;MSC001S label byte
  4637                                  	;IF	IBM
  4638                                  ; Codes returned by BIOS
  4639                                  ERRIN:
  4640 000004D8 02                      	DB	2			; NO RESPONSE
  4641 000004D9 06                      	DB	6			; SEEK FAILURE
  4642 000004DA 0C                      	DB	12			; GENERAL ERROR
  4643 000004DB 04                      	DB	4			; BAD CRC
  4644 000004DC 08                      	DB	8			; SECTOR NOT FOUND
  4645 000004DD 00                      	DB	0			; WRITE ATTEMPT ON WRITE-PROTECT DISK
  4646                                  ERROUT:
  4647                                  ; DISK ERRORS RETURNED FROM INT 25 and 26
  4648 000004DE 80                      	DB	80H			; NO RESPONSE
  4649 000004DF 40                      	DB	40H			; Seek failure
  4650 000004E0 02                      	DB	2			; Address Mark not found
  4651 000004E1 10                      	DB	10H			; BAD CRC
  4652 000004E2 04                      	DB	4			; SECTOR NOT FOUND
  4653 000004E3 03                      	DB	3			; WRITE ATTEMPT TO WRITE-PROTECT DISK
  4654                                  
  4655                                  NUMERR	EQU	$-ERROUT
  4656                                  	;ENDIF
  4657                                  ;MSC001E label byte
  4658                                  ;----------------------------------------------------------------------------
  4659                                  
  4660                                  ;============================================================================
  4661                                  ; MSCODE.ASM - MSDOS 6.0 - 1991
  4662                                  ;============================================================================
  4663                                  ; 18/07/2018 - Retro DOS v3.0
  4664                                  ; 15/05/2019 - Retro DOS v4.0
  4665                                  
  4666                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>>
  4667                                  
  4668                                  ;   AbsSetup - setup for abs disk functions
  4669                                  ;----------------------------------------------------------------------------
  4670                                  
  4671                                  AbsSetup:
  4672                                  	; 02/01/2024
  4673 000004E4 1E                      	push	ds ; *
  4674 000004E5 16                      	push	ss
  4675 000004E6 1F                      	pop	ds
  4676 000004E7 FE06[2103]              	inc	byte [INDOS]
  4677                                  	;INC	byte [SS:INDOS]		; SS override
  4678 000004EB FB                      	STI
  4679 000004EC FC                      	CLD
  4680                                  	; 02/01/2024
  4681                                  	;PUSH	DS
  4682                                  	;push	ss
  4683                                  	;pop	ds
  4684 000004ED E80901                  	CALL	GETBP
  4685                                  	; 02/01/2024
  4686 000004F0 1F                      	pop	ds ; *
  4687 000004F1 7239                    	JC	short errdriv 		; PM. error drive ;AN000;
  4688                                  	;mov	word [es:bp+1Fh]
  4689 000004F3 26C7461FFFFF            	MOV	WORD [ES:BP+DPB.FREE_CNT],-1 ; do not trust user at all.
  4690                                  
  4691                                  	; 02/01/2024
  4692                                  ;errdriv:
  4693                                  ;	POP	DS
  4694                                  ;	jnc	short AbsSetup2
  4695                                  ;AbsSetup_retn:
  4696                                  ;	retn
  4697                                  
  4698                                  AbsSetup2:
  4699                                  	; 15/05/2019 - Retro DOS v4.0
  4700                                  	; MSDOS 6.0
  4701                                  					; SS override
  4702 000004F9 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0 ;>32mb	from API		;AN000;
  4703 00000500 E83504                  	CALL	RW32_CONVERT		;>32mb convert 32bit format to 16bit ;AN000;
  4704 00000503 7227                    	jc	short AbsSetup_retn
  4705 00000505 E83E56                  	call	SET_RQ_SC_PARMS 	;LB. set up SC parms		;AN000;
  4706                                  
  4707                                  	; MSDOS 3.3 (& MSDOS 6.0)
  4708 00000508 1E                      	PUSH	DS
  4709 00000509 56                      	PUSH	SI
  4710 0000050A 50                      	PUSH	AX
  4711                                  
  4712 0000050B 16                      	push	ss
  4713 0000050C 1F                      	pop	ds
  4714                                  	
  4715 0000050D BE[BE03]                	MOV	SI,OPENBUF
  4716 00000510 8804                    	MOV	[SI],AL
  4717 00000512 800441                  	ADD	BYTE [SI],"A"
  4718 00000515 C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
  4719 0000051A B80003                  	MOV	AX,0300H
  4720 0000051D F8                      	CLC
  4721 0000051E CD2A                    	INT	int_IBM ; int 2Ah	; Will set carry if shared
  4722                                  		
  4723                                  		; 04/11/2022
  4724                                  		; (INT 2Ah - AX = 0300h)
  4725                                  		; Microsoft Networks - CHECK DIRECT I/O
  4726                                  		; DS:SI -> ASCIIZ disk device name (may be full path or
  4727                                  		;    only drive specifier--must include the colon)
  4728                                  		; Return: CF clear if absolute disk access allowed
  4729                                  
  4730 00000520 58                      	POP	AX
  4731 00000521 5E                      	POP	SI
  4732 00000522 1F                      	POP	DS
  4733 00000523 7307                    	jnc	short AbsSetup_retn
  4734                                  
  4735                                  	;mov	word [ss:EXTERR],32h
  4736 00000525 36C706[2403]3200        	MOV	word [ss:EXTERR],error_not_supported
  4737                                  errdriv:	; 02/01/2024
  4738                                  AbsSetup_retn:
  4739 0000052C C3                      	retn
  4740                                  
  4741                                  ;---------------------------------------------------------------------------
  4742                                  ;
  4743                                  ; Procedure Name : ABSDRD
  4744                                  ;
  4745                                  ; Interrupt 25 handler. Performs absolute disk read.
  4746                                  ; Inputs:	AL - 0-based drive number
  4747                                  ;		DS:BX point to destination buffer
  4748                                  ;		CX number of logical sectors to read
  4749                                  ;		DX starting logical sector number (0-based)
  4750                                  ; Outputs:	Original flags still on stack
  4751                                  ;		Carry set
  4752                                  ;		    AH error from BIOS
  4753                                  ;		    AL same as low byte of DI from INT 24
  4754                                  ;
  4755                                  ;---------------------------------------------------------------------------
  4756                                          ;procedure   ABSDRD,FAR
  4757                                  ABSDRD:
  4758                                  	; 15/05/2019 - Retro DOS v4.0
  4759                                  	; MSDOS 6.21 (DOSCODE:42E5h)
  4760                                  	; 04/11/2022
  4761                                  	; MSDOS 5.0 (DOSCODE:42D8h)
  4762                                  	
  4763                                  	; MSDOS 6.0
  4764 0000052D FA                      	CLI
  4765                                  	
  4766                                  ;	set up ds to point to DOSDATA
  4767                                  
  4768 0000052E 50                      	push	ax			; preserve AX value
  4769 0000052F 8CD8                    	mov	ax,ds			; store DS value in AX
  4770                                  	;getdseg <ds>
  4771 00000531 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4772 00000536 A3[0A0D]                	mov	[TEMPSEG],ax		; store DS value in TEMPSEG
  4773 00000539 58                      	pop	ax			; restore AX value
  4774                                  
  4775                                  	; M072:
  4776                                  	; We shall save es on the user stack here. We need to use ES in
  4777                                  	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
  4778                                  	; time in order to restore the user stack.
  4779                                  
  4780 0000053A 06                      	push	es  ; ****		; M072
  4781                                  
  4782 0000053B 8C16[1B06]              	MOV	[AbsRdWr_SS],SS		; M013
  4783 0000053F 8926[1D06]              	MOV	[AbsRdWr_SP],SP		; M013
  4784                                  
  4785                                  ; 	set up ss to point to DOSDATA
  4786                                  ;
  4787                                  ; NOTE! Due to an obscure bug in the 80286, you cannot use the ROMDOS
  4788                                  ; version of the getdseg macro with the SS register! An interrupt will
  4789                                  ; sneak through.
  4790                                  
  4791                                  ;ifndef ROMDOS
  4792                                  	;getdseg <ss>			; cli in entry of routine
  4793 00000543 2E8E16[0700]            	mov     ss,[cs:DosDSeg]
  4794                                  ;else
  4795                                  ;	mov	ds, cs:[BioDataSeg]
  4796                                  ;	assume	ds:bdata
  4797                                  ;
  4798                                  ;	mov	ss, ds:[DosDataSg]
  4799                                  ;	assume	ss:DOSDATA
  4800                                  ;
  4801                                  ;endif ; ROMDOS
  4802                                  
  4803 00000548 BC[2009]                	MOV	SP,DSKSTACK
  4804                                  
  4805 0000054B 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore DS value
  4806                                  
  4807 0000054F 06                      	push	es ; *** (MSDOS 6.21)
  4808 00000550 E80FFF                  	call	save_world		; save all regs
  4809                                  
  4810 00000553 06                      	PUSH	ES ; **
  4811 00000554 E88DFF                  	CALL	AbsSetup
  4812 00000557 723D                    	JC	short ILEAVE
  4813                                  
  4814                                  	; Here is a gross temporary fix to get around a serious design flaw in
  4815                                  	;  the secondary cache. The secondary cache does not check for media
  4816                                  	;  changed (it should). Hence, you can change disks, do an absolute
  4817                                  	;  read, and get data from the previous disk. To get around this,
  4818                                  	;  we just won't use the secondary cache for absolute disk reads.
  4819                                  	;                                                      -mw 8/5/88
  4820                                  
  4821                                  	;EnterCrit critDisk
  4822 00000559 E8B10D                  	call	ECritDisk
  4823 0000055C 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC  ;AN000;
  4824                                  	;LeaveCrit critDisk
  4825 00000562 E8C30D                  	call	LCritDisk
  4826                                  
  4827                                          ;invoke	DSKREAD
  4828 00000565 E8FE31                  	CALL	DSKREAD
  4829 00000568 7513                            jnz	short ERR_LEAVE		;Jump if read unsuccessful.
  4830                                  
  4831 0000056A 89F9                            mov     cx,di
  4832 0000056C 368C1E[0E06]                    mov     [ss:TEMP_VAR2],ds
  4833 00000571 36891E[0C06]                    mov     [ss:TEMP_VAR],bx
  4834                                  
  4835                                  ;       CX = # of contiguous sectors read. (These constitute a block of
  4836                                  ;            sectors, also termed an "Extent".)
  4837                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
  4838                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
  4839                                  ;       ES:BP -> Drive Parameter Block (DPB).
  4840                                  ;
  4841                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
  4842                                  ;	buffers must be "read" into the transfer memory block, so that the
  4843                                  ;       transfer memory reflects the most recent data.
  4844                                  
  4845                                  	;invoke	DskRdBufScan		;This trashes DS, but don't care.
  4846 00000576 E83D34                          call	DskRdBufScan
  4847 00000579 EB1B                    	jmp     short ILEAVE
  4848                                  
  4849                                  TLEAVE:
  4850 0000057B 7419                    	JZ	short ILEAVE
  4851                                  
  4852                                  ERR_LEAVE:				; M039
  4853                                  	; 15/07/2018 - Retro DOS v3.0
  4854                                          ;IF	IBM
  4855                                  ; Translate the error code to ancient 1.1 codes
  4856 0000057D 06                              PUSH    ES ; *
  4857 0000057E 0E                              PUSH    CS
  4858 0000057F 07                              POP     ES
  4859 00000580 30E4                            XOR     AH,AH			; Nul error code
  4860                                  	;mov	cx,6
  4861 00000582 B90600                          MOV     CX,NUMERR		; Number of possible error conditions
  4862 00000585 BF[D804]                        MOV     DI,ERRIN		; Point to error conditions
  4863 00000588 F2AE                            REPNE   SCASB
  4864 0000058A 7504                            JNZ     SHORT LEAVECODE		; Not found
  4865                                  	;mov	ah,[ES:DI+5]
  4866 0000058C 268A6505                        MOV     AH,[ES:DI+NUMERR-1]	; Get translation
  4867                                  LEAVECODE:
  4868 00000590 07                              POP     ES ; *
  4869                                  	; 15/05/2019 - Retro DOS v4.0
  4870 00000591 36A3[B80D]              	mov	[ss:AbsDskErr],ax
  4871                                          ;ENDIF
  4872                                  
  4873 00000595 F9                              STC
  4874                                  ILEAVE:
  4875                                  	; 15/05/2019
  4876 00000596 07                              POP     ES ; **
  4877 00000597 E8B1FE                  	call	restore_world
  4878 0000059A 07                              pop	es ; *** (MSDOS 6.21)
  4879 0000059B FA                      	CLI
  4880 0000059C 36A1[B80D]              	mov     ax,[ss:AbsDskErr]	; restore error
  4881 000005A0 36FE0E[2103]            	DEC	BYTE [SS:INDOS]
  4882 000005A5 16                              push	ss			; M072 - Start
  4883 000005A6 07                      	pop	es			; es - dosdata
  4884 000005A7 268E16[1B06]                    mov	ss,[es:AbsRdWr_SS]	; M013
  4885 000005AC 268B26[1D06]            	mov	sp,[es:AbsRdWr_SP]	; M013
  4886 000005B1 07                      	pop	es  ; ****		; Note es was saved on user
  4887                                  					; stack at entry 
  4888                                  					; M072 - End
  4889 000005B2 FB                              STI
  4890 000005B3 CB                      	RETF   ; ! FAR return !
  4891                                  
  4892                                  ;ABSDRD	ENDP
  4893                                  
  4894                                  ;---------------------------------------------------------------------------
  4895                                  ;
  4896                                  ; Procedure Name : ABSDWRT
  4897                                  ;
  4898                                  ; Interrupt 26 handler. Performs absolute disk write.
  4899                                  ; Inputs:	AL - 0-based drive number
  4900                                  ;		DS:BX point to source buffer
  4901                                  ;		CX number of logical sectors to write
  4902                                  ;		DX starting logical sector number (0-based)
  4903                                  ; Outputs:	Original flags still on stack
  4904                                  ;		Carry set
  4905                                  ;		    AH error from BIOS
  4906                                  ;		    AL same as low byte of DI from INT 24
  4907                                  ;
  4908                                  ;---------------------------------------------------------------------------
  4909                                          ;procedure   ABSDWRT,FAR
  4910                                  ABSDWRT:
  4911                                  	; 15/05/2019 - Retro DOS v4.0
  4912                                  	; MSDOS 6.21 (DOSCODE:436Ch)
  4913                                  	; 04/11/2022
  4914                                  	; MSDOS 5.0 (DOSCODE:435Fh)
  4915                                  
  4916 000005B4 FA                      	CLI
  4917                                  
  4918                                  ;	set up ds to point to DOSDATA
  4919                                  
  4920 000005B5 50                      	push	ax
  4921 000005B6 8CD8                    	mov	ax,ds
  4922                                  	;getdseg <ds>
  4923 000005B8 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4924 000005BD A3[0A0D]                	mov	[TEMPSEG],ax
  4925 000005C0 58                      	pop	ax
  4926                                  
  4927                                  	; M072:
  4928                                  	; We shall save es on the user stack here. We need to use ES in
  4929                                  	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
  4930                                  	; time in order to restore the user stack.
  4931                                  
  4932 000005C1 06                      	push	es ; ****		; M072
  4933                                  
  4934 000005C2 8C16[1B06]              	MOV	[AbsRdWr_SS],SS		; M013
  4935 000005C6 8926[1D06]              	MOV	[AbsRdWr_SP],SP		; M013
  4936                                  
  4937                                  	; set up ss to point to DOSDATA
  4938                                  	;
  4939                                  	; NOTE! Due to an obscure bug in the 80286, you cannot use the 
  4940                                  	; ROMDOS version of the getdseg macro with the SS register!
  4941                                  	; An interrupt will sneak through.
  4942                                  
  4943                                  ;ifndef ROMDOS
  4944                                  	;getdseg <ss>			; cli in entry of routine
  4945 000005CA 2E8E16[0700]            	mov     ss,[cs:DosDSeg]
  4946                                  ;else
  4947                                  ;	mov	ds, cs:[BioDataSeg]
  4948                                  ;	assume	ds:bdata
  4949                                  ;
  4950                                  ;	mov	ss, ds:[DosDataSg]
  4951                                  ;	assume	ss:DOSDATA
  4952                                  ;
  4953                                  ;endif ; ROMDOS
  4954                                  
  4955 000005CF BC[2009]                	MOV	SP,DSKSTACK
  4956                                  		; we are now switched to DOS's disk stack
  4957                                  
  4958 000005D2 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore user's ds
  4959                                  
  4960 000005D6 06                      	push	es ; *** (MSDOS 6.21)
  4961                                  
  4962 000005D7 E888FE                  	call	save_world	      	; save all regs
  4963                                  
  4964 000005DA 06                      	PUSH	ES ; **
  4965 000005DB E806FF                  	CALL	AbsSetup
  4966 000005DE 72B6                    	JC	short ILEAVE
  4967                                  
  4968                                  	;EnterCrit critDisk
  4969 000005E0 E82A0D                  	call	ECritDisk
  4970 000005E3 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC ;AN000;
  4971 000005E9 E89103                  	CALL	Fastxxx_Purge		 ; purge fatopen ;AN000;
  4972                                  	;LeaveCrit critDisk
  4973 000005EC E8390D                  	call	LCritDisk
  4974                                  
  4975                                  ;M039
  4976                                  ;       DS:BX = transfer address (source data address).
  4977                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
  4978                                  ;	     sectors, also termed an "Extent".)
  4979                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
  4980                                  ;       ES:BP -> Drive Parameter Block (DPB).
  4981                                  ;       [CURSC_DRIVE] = -1 (invalid drive).
  4982                                  ;
  4983                                  ;       Free any buffered sectors which are in Extent; they are being over-
  4984                                  ;       written. Note that all the above registers are preserved for
  4985                                  ;       DSKWRITE.
  4986                                  
  4987 000005EF 1E                              push    ds
  4988                                  	;invoke	DskWrtBufPurge          ;This trashes DS.
  4989 000005F0 E8DA36                  	call	DskWrtBufPurge
  4990 000005F3 1F                              pop     ds
  4991                                  ;M039
  4992                                  	;invoke	DSKWRITE
  4993 000005F4 E89831                  	call	DSKWRITE
  4994 000005F7 EB82                    	JMP	short TLEAVE
  4995                                  
  4996                                  ;ABSDWRT ENDP
  4997                                  
  4998                                  ;----------------------------------------------------------------------------
  4999                                  ;
  5000                                  ; Procedure Name : GETBP
  5001                                  ;
  5002                                  ; Inputs:
  5003                                  ;	AL = Logical unit number (A = 0)
  5004                                  ; Function:
  5005                                  ;	Find Drive Parameter Block
  5006                                  ; Outputs:
  5007                                  ;	ES:BP points to DPB
  5008                                  ;	[THISDPB] = ES:BP
  5009                                  ;	Carry set if unit number bad or unit is a NET device.
  5010                                  ;		Later case sets extended error error_I24_not_supported
  5011                                  ; No other registers alteredjjj
  5012                                  ;
  5013                                  ;----------------------------------------------------------------------------
  5014                                  
  5015                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5016                                  GETBP:
  5017                                  	; 15/05/2019 - Retro DOS v4.0
  5018                                  	; 11/07/2018 - Retro DOS v3.0
  5019 000005F9 50                      	PUSH	AX
  5020 000005FA 0401                    	ADD	AL, 1		; No increment; need carry flag
  5021 000005FC 7216                    	JC	SHORT SKIPGET
  5022 000005FE E89D64                  	CALL	GETTHISDRV
  5023                                  	; MSDOS 6.0
  5024 00000601 7311                    	JNC	SHORT SKIPGET		;PM. good drive		;AN000;
  5025 00000603 30E4                    	XOR	AH,AH			;DCR. ax= error code 	;AN000;
  5026 00000605 83F81A                  	CMP	AX,error_not_DOS_disk	;DCR. is unknown media ? ;AN000;
  5027 00000608 740A                    	JZ	SHORT SKIPGET 		;DCR. yes, let it go 	;AN000;
  5028 0000060A F9                      	STC				;DCR.			;AN000;
  5029 0000060B A3[2403]                	MOV	[EXTERR],AX	;PM. invalid drive or Non DOS drive ;AN000;
  5030 0000060E C706[B80D]0102          	MOV	WORD [AbsDskErr],201h
  5031                                  SKIPGET:
  5032 00000614 58                      	POP	AX
  5033 00000615 7212                    	JC	SHORT GETBP_RETN ; 15/12/2022
  5034                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  5035                                  	;jnc	short getbp_t
  5036                                  	;retn
  5037                                  getbp_t:
  5038 00000617 C42E[A205]              	LES	BP,[THISCDS]
  5039                                  	; 15/12/2022
  5040 0000061B 26F6464480              	test	byte [es:bp+curdir.flags+1],curdir_isnet>>8
  5041                                  	; 07/12/2022
  5042                                  	;TEST	WORD [ES:BP+43H],8000H
  5043                                  	;TEST	WORD [ES:BP+curdir.flags],curdir_isnet ; Clears carry
  5044 00000620 7408                    	JZ	SHORT GETBP_CDS
  5045 00000622 C706[2403]3200          	MOV	WORD [EXTERR],error_not_supported  ; 32h
  5046 00000628 F9                      	STC
  5047                                  GETBP_RETN:
  5048 00000629 C3                      	RETN
  5049                                  
  5050                                  GETBP_CDS:
  5051                                  	;LES	BP,[ES:BP+45H]
  5052 0000062A 26C46E45                	LES	BP,[ES:BP+curdir.devptr]
  5053                                  GOTDPB:
  5054                                  	; Load THISDPB from ES:BP
  5055 0000062E 892E[8A05]              	MOV	[THISDPB],BP
  5056 00000632 8C06[8C05]              	MOV	[THISDPB+2],ES
  5057 00000636 C3                      	RETN
  5058                                  
  5059                                  ;BREAK <SYS_RET_OK SYS_RET_ERR CAL_LK ETAB_LK set system call returns>
  5060                                  
  5061                                  ;----------------------------------------------------------------------------
  5062                                  ;
  5063                                  ; Procedure Name : SYS_RETURN
  5064                                  ;
  5065                                  ; These are the general system call exit mechanisms. All internal system
  5066                                  ; calls will transfer (jump) to one of these at the end. Their sole purpose
  5067                                  ; is to set the user's flags and set his AX register for return.
  5068                                  ;
  5069                                  ;----------------------------------------------------------------------------
  5070                                  
  5071                                          ;procedure   SYS_RETURN,NEAR
  5072                                  SYS_RETURN:        
  5073                                          ;entry	SYS_RET_OK
  5074                                  SYS_RET_OK:   
  5075 00000637 E847FE                  	call    Get_User_Stack
  5076                                  		; turn off user's carry flag
  5077                                  SYS_RET_OK_clc: ; 25/06/2019 
  5078                                          ;;and	word [SI+16h],0FFFEh 
  5079                                  	;and	word [SI+user_env.user_F],~f_Carry 
  5080                                          ; 25/06/2019
  5081 0000063A 806416FE                	and	byte [SI+user_env.user_F],~f_Carry ; 0FEh
  5082 0000063E EB10                    	JMP     SHORT DO_RET
  5083                                  
  5084                                          ;entry   SYS_RET_ERR
  5085                                  SYS_RET_ERR:        
  5086 00000640 30E4                    	XOR     AH,AH 		; hack to allow for smaller error rets
  5087 00000642 E86C00                  	call	ETAB_LK 	; Make sure code is OK, EXTERR gets set
  5088 00000645 E81A00                  	CALL	ErrorMap
  5089                                  
  5090                                  	;entry	From_GetSet
  5091                                  From_GetSet:
  5092 00000648 E836FE                          call    Get_User_Stack
  5093                                  		 ; signal carry to user
  5094                                  	;;or	word [SI+16h],1
  5095                                  	;OR	word [SI+user_env.user_F],f_Carry
  5096                                  	; 25/06/2019
  5097 0000064B 804C1601                	or	byte [SI+user_env.user_F],f_Carry
  5098 0000064F F9                      	STC			; also, signal internal error
  5099                                  DO_RET:
  5100                                          ;MOV	[SI+user_env.user_AX],AX ; Really only sets AH
  5101 00000650 8904                    	MOV	[SI],AX
  5102 00000652 C3                      	RETN
  5103                                  
  5104                                  	;entry	FCB_RET_OK
  5105                                  FCB_RET_OK:
  5106                                  	;entry	NO_OP		; obsolete system calls dispatch to here
  5107                                  NO_OP:
  5108 00000653 30C0                    	XOR	AL,AL
  5109 00000655 C3                      	retn
  5110                                  
  5111                                  	;entry	FCB_RET_ERR
  5112                                  FCB_RET_ERR:
  5113 00000656 30E4                    	XOR	AH,AH
  5114 00000658 36A3[2403]              	mov	[ss:EXTERR],AX
  5115 0000065C E80300                  	CALL	ErrorMap
  5116 0000065F B0FF                    	MOV	AL,-1
  5117 00000661 C3                      	retn
  5118                                  
  5119                                  	;entry	ErrorMap
  5120                                  ErrorMap:
  5121 00000662 56                      	PUSH	SI
  5122                                  				; ERR_TABLE_21 is now in DOSDATA
  5123 00000663 BE[DB0D]                	MOV	SI,ERR_TABLE_21
  5124                                  				; SS override for FAILERR and EXTERR
  5125 00000666 36803E[4A03]00          	CMP	byte [SS:FAILERR],0 ; Check for SPECIAL case.
  5126 0000066C 7407                    	JZ	short EXTENDED_NORMAL ; All is OK.
  5127                                  		 ; Ooops, this is the REAL reason
  5128                                  	;mov	word [SS:EXTERR],53h
  5129 0000066E 36C706[2403]5300        	MOV	word [SS:EXTERR],error_FAIL_I24
  5130                                  EXTENDED_NORMAL:
  5131 00000675 E80200                  	call	CAL_LK		; Set CLASS,ACTION,LOCUS for EXTERR
  5132 00000678 5E                      	POP	SI
  5133 00000679 C3                      	retn
  5134                                  
  5135                                  	;EndProc SYS_RETURN
  5136                                  
  5137                                  ;---------------------------------------------------------------------------
  5138                                  ;
  5139                                  ; Procedure Name : CAL_LK
  5140                                  ;
  5141                                  ; Inputs:
  5142                                  ;	SI is OFFSET in DOSDATA of CLASS,ACTION,LOCUS Table to use
  5143                                  ;		(DS NEED not be DOSDATA)
  5144                                  ;	[EXTERR] is set with error
  5145                                  ; Function:
  5146                                  ;	Look up and set CLASS ACTION and LOCUS values for GetExtendedError
  5147                                  ; Outputs:
  5148                                  ;	[EXTERR_CLASS] set
  5149                                  ;	[EXTERR_ACTION] set
  5150                                  ;	[EXTERR_LOCUS] set  (EXCEPT on certain errors as determined by table)
  5151                                  ; Destroys SI, FLAGS
  5152                                  ;
  5153                                  ;---------------------------------------------------------------------------
  5154                                  
  5155                                  	;procedure CAL_LK,NEAR
  5156                                  CAL_LK:
  5157 0000067A 1E                      	PUSH	DS
  5158 0000067B 50                      	PUSH	AX
  5159 0000067C 53                      	PUSH	BX
  5160                                  
  5161                                  ;M048	Context DS		; DS:SI -> Table
  5162                                  ;
  5163                                  ; Since this function can be called thru int 2f we shall not assume that SS
  5164                                  ; is DOSDATA
  5165                                  
  5166                                  	;getdseg  <ds>	; M048: DS:SI -> Table
  5167                                  	; 15/05/2019 - Retro DOS v4.0
  5168 0000067D 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5169                                  
  5170                                  	; 18/07/2018
  5171                                  	;push	ss
  5172                                  	;pop	ds
  5173                                  
  5174 00000682 8B1E[2403]              	MOV	BX,[EXTERR]	; Get error in BL
  5175                                  TABLK1:
  5176 00000686 AC                      	LODSB
  5177                                  
  5178 00000687 3CFF                    	CMP	AL,0FFH
  5179 00000689 7409                    	JZ	short GOT_VALS	; End of table
  5180 0000068B 38D8                    	CMP	AL,BL
  5181 0000068D 7405                    	JZ	short GOT_VALS	; Got entry
  5182 0000068F 83C603                  	ADD	SI,3		; Next table entry
  5183                                  	; 15/08/2018
  5184 00000692 EBF2                    	JMP	short TABLK1
  5185                                  
  5186                                  GOT_VALS:
  5187 00000694 AD                      	LODSW			; AL is CLASS, AH is ACTION
  5188                                  
  5189 00000695 80FCFF                  	CMP	AH,0FFH
  5190 00000698 7404                    	JZ	short NO_SET_ACT
  5191 0000069A 8826[2603]              	MOV	[EXTERR_ACTION],AH ; Set ACTION
  5192                                  NO_SET_ACT:
  5193 0000069E 3CFF                    	CMP	AL,0FFH
  5194 000006A0 7403                    	JZ	short NO_SET_CLS
  5195 000006A2 A2[2703]                	MOV	[EXTERR_CLASS],AL ; Set CLASS
  5196                                  NO_SET_CLS:
  5197 000006A5 AC                      	LODSB			; Get LOCUS
  5198                                  
  5199 000006A6 3CFF                    	CMP	AL,0FFH
  5200 000006A8 7403                    	JZ	short NO_SET_LOC
  5201 000006AA A2[2303]                	MOV	[EXTERR_LOCUS],AL
  5202                                  NO_SET_LOC:
  5203 000006AD 5B                      	POP	BX
  5204 000006AE 58                      	POP	AX
  5205 000006AF 1F                      	POP	DS
  5206 000006B0 C3                      	retn
  5207                                  
  5208                                  	;EndProc CAL_LK
  5209                                  
  5210                                  ;---------------------------------------------------------------------------
  5211                                  ;
  5212                                  ; Procedure Name : ETAB_LK
  5213                                  ;
  5214                                  ; Inputs:
  5215                                  ;	AX is error code
  5216                                  ;	[USER_IN_AX] has AH value of system call involved
  5217                                  ; Function:
  5218                                  ;	Make sure error code is appropriate to this call.
  5219                                  ; Outputs:
  5220                                  ;	AX MAY be mapped error code
  5221                                  ;	[EXTERR] = Input AX
  5222                                  ; Destroys ONLY AX and FLAGS
  5223                                  ;
  5224                                  ;---------------------------------------------------------------------------
  5225                                  
  5226                                  	;procedure ETAB_LK,NEAR
  5227                                  
  5228                                  ETAB_LK: ; 10/08/2018 - Retro DOS v3.0
  5229 000006B1 1E                      	PUSH	DS
  5230 000006B2 56                      	PUSH	SI
  5231 000006B3 51                      	PUSH	CX
  5232 000006B4 53                      	PUSH	BX
  5233                                  
  5234                                  	;Context DS			; SS is DOSDATA
  5235                                  
  5236 000006B5 16                      	push	ss
  5237 000006B6 1F                      	pop	ds
  5238                                  
  5239 000006B7 A3[2403]                	MOV	[EXTERR],AX		; Set EXTERR with "real" error
  5240                                  
  5241                                  					; I21_MAP_E_TAB is now in DOSCODE
  5242 000006BA BE[0B00]                	MOV	SI,I21_MAP_E_TAB
  5243 000006BD 88C7                    	MOV	BH,AL			; Real code to BH
  5244 000006BF 8A1E[3B03]              	MOV	BL,[USER_IN_AX+1]	; Sys call to BL
  5245                                  TABLK2:
  5246                                  	; 15/05/2019 - Retro DOS v4.0
  5247 000006C3 2E                      	cs
  5248 000006C4 AD                      	lodsw	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:447Dh)
  5249                                  	
  5250                                  	; 18/07/2018 - Retro DOS v3.0
  5251                                  	;lodsw		; IBMDOS.COM (MSDOS 3.3) - Offset 16F7h
  5252                                  
  5253 000006C5 3CFF                    	CMP	AL,0FFH 		; End of table?
  5254 000006C7 740C                    	JZ	short NOT_IN_TABLE	; Yes
  5255 000006C9 38D8                    	CMP	AL,BL			; Found call?
  5256 000006CB 740C                    	JZ	short GOT_CALL		; Yes
  5257 000006CD 86E0                    	XCHG	AH,AL			; Count to AL
  5258 000006CF 30E4                    	XOR	AH,AH			; Make word for add
  5259 000006D1 01C6                    	ADD	SI,AX			; Next table entry
  5260 000006D3 EBEE                    	JMP	short TABLK2
  5261                                  
  5262                                  NOT_IN_TABLE:
  5263 000006D5 88F8                    	MOV	AL,BH			; Restore original code
  5264 000006D7 EB0C                    	JMP	SHORT NO_MAP
  5265                                  
  5266                                  GOT_CALL:
  5267 000006D9 88E1                    	MOV	CL,AH
  5268 000006DB 30ED                    	XOR	CH,CH			; Count of valid err codes to CX
  5269                                  CHECK_CODE:
  5270                                  	; 15/05/2019 - Retro DOS v4.0
  5271 000006DD 2E                      	cs
  5272 000006DE AC                      	lodsb	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:4497h)
  5273                                  
  5274                                  	; 18/07/2018
  5275                                  	;lodsb		; IBMDOS.COM (MSDOS 3.3) - Offset 1710h
  5276                                  
  5277 000006DF 38F8                    	CMP	AL,BH			; Code OK?
  5278 000006E1 7402                    	JZ	short NO_MAP		; Yes
  5279 000006E3 E2F8                    	LOOP	CHECK_CODE
  5280                                  NO_MAP:
  5281 000006E5 30E4                    	XOR	AH,AH			; AX is now valid code
  5282 000006E7 5B                      	POP	BX
  5283 000006E8 59                      	POP	CX
  5284 000006E9 5E                      	POP	SI
  5285 000006EA 1F                      	POP	DS
  5286 000006EB C3                      	retn
  5287                                  
  5288                                  	;EndProc ETAB_LK
  5289                                  
  5290                                  ; 18/07/2018 - Retro DOS v3.0
  5291                                  ;---------------------------------------------------------------------------
  5292                                  ; BREAK <DOS 2F Handler and default NET 2F handler>
  5293                                  
  5294                                  ;IF installed ; (*)
  5295                                  
  5296                                  ;---------------------------------------------------------------------------
  5297                                  ;
  5298                                  ; Procedure Name : SetBad
  5299                                  ;
  5300                                  ; SetBad sets up info for bad functions
  5301                                  ;
  5302                                  ;---------------------------------------------------------------------------
  5303                                  
  5304                                  SetBad:
  5305                                  	;mov	ax,1
  5306 000006EC B80100                  	MOV	AX,error_invalid_function ; ALL NET REQUESTS get inv func
  5307                                  
  5308                                  	; MSDOS 3.3
  5309                                  	;;mov	byte [cs:EXTERR_LOCUS],1
  5310                                  	;MOV	byte [CS:EXTERR_LOCUS],errLOC_Unk
  5311                                  
  5312                                  ;	set up ds to point to DOSDATA
  5313                                  
  5314                                  	; 15/05/2019 - Retro DOS v4.0
  5315                                  	; MSDOS 6.0
  5316 000006EF 1E                      	push	ds
  5317                                  
  5318                                  	;getdseg <ds>
  5319 000006F0 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5320                                  
  5321 000006F5 C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1	
  5322                                  
  5323 000006FA 1F                      	pop	ds	  	;hkn; restore ds
  5324                                  
  5325 000006FB F9                      	STC
  5326 000006FC C3                      	retn
  5327                                  
  5328                                  ;--------------------------------------------------------------------------
  5329                                  ;
  5330                                  ; Procedure Name : BadCall
  5331                                  ;
  5332                                  ; BadCall is the initial routine for bad function calls
  5333                                  ;
  5334                                  ;--------------------------------------------------------------------------
  5335                                  
  5336                                  BadCall:
  5337 000006FD E8ECFF                  	call	SetBad
  5338 00000700 CB                      	retf
  5339                                  
  5340                                  ;--------------------------------------------------------------------------
  5341                                  ;
  5342                                  ; OKCall always sets carry to off.
  5343                                  ;
  5344                                  ;-----------------------------------------------------------------------
  5345                                  
  5346                                  OKCall:
  5347 00000701 F8                      	CLC
  5348 00000702 CB                      	retf
  5349                                  
  5350                                  ;---------------------------------------------------------------------------
  5351                                  ;
  5352                                  ; Procedure Name : INT2F
  5353                                  ;
  5354                                  ; INT 2F handler works as follows:
  5355                                  ;   PUSH    AX
  5356                                  ;   MOV     AX,multiplex:function
  5357                                  ;   INT     2F
  5358                                  ;   POP     ...
  5359                                  ; The handler itself needs to make the AX available for the various routines.
  5360                                  ;
  5361                                  ;----------------------------------------------------------------------------
  5362                                  
  5363                                  ; 15/05/2019 - Retro DOS v4.0
  5364                                  
  5365                                  ;KERNEL_SEGMENT equ 70h
  5366                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5367                                  DOSBIODATASEG equ 70h
  5368                                  
  5369                                  ; retrodos4.s - offset in BIOSDATA
  5370                                  bios_i2f equ 5
  5371                                  
  5372                                  ;PUBLIC	Int2F
  5373                                  ;INT2F	PROC	FAR
  5374                                  
  5375                                  ; 15/05/2019
  5376                                  ; DOSCODE:44BDh (MSDOS 6.21, MSDOS.SYS)
  5377                                  
  5378                                  ; 04/11/2022
  5379                                  ; DOSCODE:44B0h (MSDOS 5.0, MSDOS.SYS)
  5380                                  
  5381                                  	; 05/01/2024
  5382                                  	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5383                                  	; 18/07/2018 - Retro DOS v3.0
  5384                                  INT2F:
  5385                                  	; Offset 172Fh in IBMDOS.COM (MSDOS 3.3), 1987
  5386                                  INT2FNT:
  5387                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5388 00000703 FB                      	STI
  5389                                  	;cmp	ah,11h
  5390 00000704 80FC11                  	CMP	AH,MultNET
  5391 00000707 750A                    	JNZ	short INT2FSHR
  5392                                  TestInstall:
  5393 00000709 08C0                    	OR	AL,AL
  5394 0000070B 7403                    	JZ	short Leave2F
  5395                                  BadFunc:
  5396 0000070D E8DCFF                  	CALL	SetBad
  5397                                  
  5398                                  	;entry	Leave2F
  5399                                  Leave2F:
  5400 00000710 CA0200                  	RETF	2			; long return + clear flags off stack
  5401                                  
  5402                                  INT2FSHR:
  5403                                  	;cmp	ah,10h
  5404 00000713 80FC10                  	CMP	AH,MultSHARE		; is this a share request
  5405 00000716 74F1                    	JZ	short TestInstall	; yes, check for installation
  5406                                  INT2FNLS:
  5407                                  	;cmp	ah,14h
  5408 00000718 80FC14                  	CMP	AH,NLSFUNC		; is this a DOS 3.3 NLSFUNC request
  5409 0000071B 74EC                    	JZ	short TestInstall	; yes check for installation
  5410                                  INT2FDOS:
  5411                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5412                                  
  5413                                  	; 18/07/2018
  5414                                  	; MSDOS 3.3
  5415                                  	;;cmp	ah,12h	
  5416                                  	;CMP	AH,MultDOS
  5417                                  	;jz	short DispatchDOS
  5418                                  	;iret
  5419                                  
  5420                                  	; 15/05/2019
  5421                                  	; MSDOS 6.0
  5422                                  	;cmp	ah,12h	; 07/12/2022
  5423 0000071D 80FC12                  	CMP	AH,MultDOS
  5424 00000720 7503                    	JNZ	short check_win		;check if win386 broadcast
  5425 00000722 E9F201                  	jmp	DispatchDOS
  5426                                  
  5427                                  	; .... win386 .... 
  5428                                  
  5429                                  check_win:
  5430                                  	;cmp	ah,16h
  5431 00000725 80FC16                  	cmp	ah,MultWin386		; Is this a broadcast from Win386?
  5432 00000728 7408                    	je	short Win386_Msg
  5433                                  
  5434                                  	; M044
  5435                                  	; Check if the callout is from Winoldap indicating swapping out or in 
  5436                                  	; of Windows. If so, do special action of going and saving last para
  5437                                  	; of the Windows memory arena which Winoldap does not save due to a 
  5438                                  	; bug
  5439                                  
  5440 0000072A 80FC46                  	cmp	ah,WINOLDAP ; 46h	; from Winoldap?
  5441                                  	;jne	short next_i2f		; no, chain on
  5442                                  	; 15/12/2022
  5443                                  	;jmp	winold_swap		; yes, do desired action
  5444 0000072D 7442                    	je	short winold_swap
  5445 0000072F E90501                  	jmp	next_i2f
  5446                                  
  5447                                  	; 15/12/2022
  5448                                  ;next_i2f:
  5449                                  ;	;;;jmp	bios_i2f
  5450                                  ;	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
  5451                                  ;	;jmp	KERNEL_SEGMENT:bios_i2f
  5452                                  ;	; 04/11/2022
  5453                                  ;	jmp	DOSBIODATASEG:bios_i2f
  5454                                  
  5455                                  ;	IRET				; This assume that we are at the head
  5456                                  					; of the list
  5457                                  ;INT2F	ENDP
  5458                                  
  5459                                  ; 15/05/2019 - Retro DOS v4.0
  5460                                  
  5461                                  ; We have received a message from Win386. There are three possible
  5462                                  ; messages we could get from Win386:
  5463                                  ;
  5464                                  ; Init 		- for this, we set the IsWin386 flag and return a pointer
  5465                                  ;		  to the Win386 startup info structure.
  5466                                  ; Exit		- for this, we clear the IsWin386 flag.
  5467                                  ; DOSMGR query 	- for this, we need to indicate that instance data
  5468                                  ;		  has already been handled. this is indicated by setting
  5469                                  ;		  CX to a non-zero value.
  5470                                  
  5471                                  Win386_Msg:
  5472 00000732 1E                      	push	ds
  5473                                  
  5474                                  	;getdseg <DS>			; ds is DOSDATA
  5475 00000733 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5476                                  
  5477                                  	; For WIN386 2.xx instance data
  5478                                  
  5479 00000738 3C03                    	cmp	al,3			; win386 2.xx instance data call?
  5480 0000073A 7503                    	jne	short Win386_Msg_exit
  5481 0000073C E92A01                  	jmp	OldWin386Init		; yes, return instance data
  5482                                  Win386_Msg_exit:
  5483 0000073F 3C06                    	cmp	al,Win386_Exit	 ; 6	; is it an exit call?
  5484 00000741 7503                    	jne	short Win386_Msg_devcall
  5485 00000743 E92C01                  	jmp	Win386_Leaving
  5486                                  Win386_Msg_devcall:
  5487 00000746 3C07                    	cmp	al,Win386_Devcall ; 7	; is it call from DOSMGR?
  5488 00000748 7503                    	jne	short Win386_Msg_init
  5489 0000074A E96001                  	jmp	Win386_Query
  5490                                  Win386_Msg_init:
  5491 0000074D 3C05                    	cmp	al,Win386_Init	; 5	; is it an init call?
  5492 0000074F 7403                    	je	short Win386_Starting
  5493 00000751 E9E200                  	jmp	win_nexti2f		; no, return
  5494                                  Win386_Starting:
  5495                                  	; 17/12/2022
  5496 00000754 F6C201                  	test	dl,1
  5497                                  	;test	dx,1			; is this really win386?
  5498 00000757 7403                    	jz	short Win386_vchk	; YES! go and handle it
  5499 00000759 E9DA00                  	jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
  5500                                  Win386_vchk:
  5501                                  	; M018 -- start of block changes
  5502                                  	; The VxD needs to be loaded only for Win 3.0. If version is greater 
  5503                                  	; than 030Ah, we skip the VxD presence check
  5504                                  
  5505                                  ;M067 -- Begin changes
  5506                                  ; If Win 3.0 is run, the VxD ptr has been initialized. If Win 3.1 is now
  5507                                  ;run, it tries to unnecesarily load the VxD even though it is not needed.
  5508                                  ;So, we null out the VxD ptr before the check.
  5509                                  
  5510                                  	;mov	word [Win386_Info+6],0
  5511 0000075C C706[E80F]0000          	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],0
  5512                                  	;mov	word [Win386_Info+8],0
  5513 00000762 C706[EA0F]0000          	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],0
  5514                                  
  5515                                  ;M067 -- End changes
  5516                                  
  5517                                  ;ifdef JAPAN
  5518                                  ;	cmp	di,0300h		; version >= 300 i.e 3.10 ;M037
  5519                                  ;else
  5520 00000768 81FF0A03                	cmp	di,030Ah		; version >= 30a i.e 3.10 ;M037
  5521                                  ;endif
  5522                                  	;ljae	noVxD31			; yes, VxD not needed 	 ;M037
  5523 0000076C 724E                    	jb	short Win386_vxd
  5524 0000076E E9DD00                  	jmp	noVxD31
  5525                                  
  5526                                  	; 15/12/2022
  5527                                  winold_swap:
  5528 00000771 1E                      	push	ds
  5529 00000772 06                      	push	es
  5530 00000773 56                      	push	si
  5531 00000774 57                      	push	di
  5532 00000775 51                      	push	cx
  5533                                  
  5534                                  	;getdseg <ds>			;ds = DOSDATA
  5535 00000776 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5536                                  
  5537 0000077B 3C01                    	cmp	al,1			;swap Windows out call
  5538 0000077D 751B                    	jne	short swapin		;no, check if Swap in call
  5539 0000077F E88801                  	call	getwinlast
  5540 00000782 1E                      	push	ds
  5541 00000783 07                      	pop	es
  5542 00000784 8EDE                    	mov	ds,si			;ds = memory arena of Windows
  5543 00000786 31F6                    	xor	si,si
  5544 00000788 BF[0600]                	mov	di,WinoldPatch1
  5545 0000078B B90800                  	mov	cx,8
  5546 0000078E FC                      	cld
  5547 0000078F 51                      	push	cx
  5548 00000790 F3A4                    	rep	movsb			;save first 8 bytes
  5549 00000792 59                      	pop	cx
  5550 00000793 BF[CD0D]                	mov	di,WinoldPatch2
  5551 00000796 F3A4                    	rep	movsb			;save next 8 bytes
  5552 00000798 EB1B                    	jmp	short winold_done
  5553                                  swapin:
  5554 0000079A 3C02                    	cmp	al,2			;swap Windows in call?
  5555 0000079C 7517                    	jne	short winold_done	;no, something else, pass it on
  5556 0000079E E86901                  	call	getwinlast
  5557 000007A1 8EC6                    	mov	es,si
  5558 000007A3 31FF                    	xor	di,di
  5559 000007A5 BE[0600]                	mov	si,WinoldPatch1
  5560 000007A8 B90800                  	mov	cx,8
  5561 000007AB FC                      	cld
  5562 000007AC 51                      	push	cx
  5563 000007AD F3A4                    	rep	movsb			;restore first 8 bytes
  5564 000007AF 59                      	pop	cx
  5565 000007B0 BE[CD0D]                	mov	si,WinoldPatch2
  5566 000007B3 F3A4                    	rep	movsb			;restore next 8 bytes
  5567                                  winold_done:
  5568 000007B5 59                      	pop	cx
  5569 000007B6 5F                      	pop	di
  5570 000007B7 5E                      	pop	si
  5571 000007B8 07                      	pop	es
  5572 000007B9 1F                      	pop	ds
  5573 000007BA EB7B                    	jmp	short next_i2f		;chain on
  5574                                  	; 15/12/2022
  5575                                  	;jmp	next_i2f	
  5576                                  
  5577                                  Win386_vxd:
  5578 000007BC 50                      	push	ax
  5579 000007BD 53                      	push	bx
  5580 000007BE 51                      	push	cx
  5581 000007BF 52                      	push	dx
  5582 000007C0 56                      	push	si
  5583 000007C1 57                      	push	di			; save regs !!dont change order!!
  5584                                  
  5585 000007C2 8B1E[8C00]              	mov	bx,[UMB_HEAD]		; M062 - Start
  5586 000007C6 83FBFF                  	cmp	bx,0FFFFh    		; Q: have umbs been initialized
  5587 000007C9 741F                    	je	short Vxd31		; N: continue
  5588                                  					; Y: save arena associated with 
  5589                                  					;    umb_head
  5590                                  
  5591 000007CB C606[DA0D]01            	mov	byte [UmbSaveFlag],1	; indicate that we're saving 
  5592                                  					; umb_arena
  5593 000007D0 1E                      	push	ds
  5594 000007D1 06                      	push	es
  5595                                  
  5596                                  	;mov	ax,ds
  5597                                  	;mov	es,ax			; es - > dosdata
  5598                                  	; 05/01/2024
  5599 000007D2 1E                      	push	ds
  5600 000007D3 07                      	pop	es
  5601                                  
  5602 000007D4 8EDB                    	mov	ds,bx
  5603 000007D6 31F6                    	xor	si,si			; ds:si -> umb_head
  5604                                  
  5605 000007D8 FC                      	cld
  5606                                  
  5607 000007D9 BF[F511]                	mov	di,UmbSave1
  5608 000007DC B90B00                  	mov	cx,11
  5609 000007DF F3A4                    	rep	movsb
  5610                                  
  5611 000007E1 BF[D50D]                	mov	di,UmbSave2
  5612                                  	;mov	cx,5
  5613                                  	; 18/12/2022
  5614 000007E4 B105                    	mov	cl,5
  5615 000007E6 F3A4                    	rep	movsb	
  5616                                  
  5617 000007E8 07                      	pop	es
  5618 000007E9 1F                      	pop	ds			; M062 - End
  5619                                  
  5620                                  Vxd31:
  5621                                  	;test	byte [DOS_FLAG],2
  5622 000007EA F606[8600]02            	test	byte [DOS_FLAG],SUPPRESS_WINA20	; M066
  5623 000007EF 7408                    	jz	short Dont_Supress		; M066
  5624 000007F1 5F                      	pop	di				; M066
  5625 000007F2 5E                      	pop	si				; M066
  5626 000007F3 5A                      	pop	dx				; M066
  5627 000007F4 59                      	pop	cx				; M066
  5628 000007F5 5B                      	pop	bx				; M066
  5629 000007F6 58                      	pop	ax				; M066
  5630 000007F7 EB55                    	jmp	short noVxD31			; M066
  5631                                  
  5632                                  	; We check here if the VxD is available in the root of the boot drive. 
  5633                                  	; We do an extended open to suppress any error messages
  5634                                  	
  5635                                  Dont_Supress:
  5636 000007F9 A0[6900]                	mov	al,[BOOTDRIVE]
  5637 000007FC 0440                    	add	al,'A' - 1		; get drive letter
  5638 000007FE A2[3110]                	mov	[VxDpath],al		; path is root of bootdrive
  5639                                  	;mov	ah,ExtOpen  ;6Ch	; extended open
  5640                                  	;mov	al,0			; no extended attributes
  5641                                  	; 18/12/2022
  5642 00000801 B8006C                  	mov	ax,ExtOpen<<8 ; 6C00h
  5643 00000804 BB8020                  	mov	bx,2080h		; read access, compatibility mode
  5644                                  					; no inherit, suppress crit err
  5645 00000807 B90700                  	mov	cx,7			; hidden,system,read-only attr
  5646 0000080A BA0100                  	mov	dx,1			; fail if file does not exist
  5647 0000080D BE[3110]                	mov	si,VxDpath	
  5648                                  					; path of VxD file
  5649 00000810 BFFFFF                  	mov	di,0FFFFh		; no extended attributes
  5650                                  
  5651 00000813 CD21                    	int	21h			; do extended open
  5652                                  
  5653 00000815 5F                      	pop	di
  5654 00000816 5E                      	pop	si
  5655 00000817 5A                      	pop	dx
  5656 00000818 59                      	pop	cx
  5657                                  
  5658 00000819 7321                    	jnc	short VxDthere		; we found the VxD, go ahead
  5659                                  
  5660                                  	; We could not find the VxD. Cannot let windows load. Return cx != 0 
  5661                                  	; to indicate error to Windows after displaying message to user that 
  5662                                  	; VxD needs to be present to run Windows in enhanced mode.
  5663                                  
  5664 0000081B 52                      	push	dx
  5665 0000081C 1E                      	push	ds
  5666 0000081D 56                      	push	si
  5667 0000081E BE[B209]                	mov	si,NoVxDErrMsg
  5668 00000821 0E                      	push	cs
  5669 00000822 1F                      	pop	ds
  5670 00000823 B96300                  	mov	cx,VxDMesLen ; 99	;
  5671 00000826 B402                    	mov	ah,2			; write char to console
  5672 00000828 FC                      	cld
  5673                                  vxdlp:
  5674 00000829 AC                      	lodsb
  5675 0000082A 86D0                    	xchg	dl,al			; get char in dl
  5676 0000082C CD21                    	int	21h
  5677 0000082E E2F9                    	loop	vxdlp
  5678                                  
  5679 00000830 5E                      	pop	si
  5680 00000831 1F                      	pop	ds
  5681 00000832 5A                      	pop	dx
  5682 00000833 5B                      	pop	bx
  5683 00000834 58                      	pop	ax			;all registers restored
  5684 00000835 41                      	inc	cx			;cx != 0 to indicate error
  5685                                  	; 15/12/22022
  5686                                  	;jmp	win_nexti2f		;chain on
  5687                                  	;jmp	short win_nexti2f
  5688                                  
  5689                                  	; 15/12/2022
  5690                                  win_nexti2f:
  5691 00000836 1F                      	pop	ds
  5692                                  	;jmp	short next_i2f		; go to BIOS i2f handler
  5693                                  	; 15/12/2022
  5694                                  next_i2f:
  5695                                  	;;;jmp	bios_i2f
  5696                                  	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
  5697                                  	;jmp	KERNEL_SEGMENT:bios_i2f
  5698                                  	; 04/11/2022
  5699 00000837 EA05007000              	jmp	DOSBIODATASEG:bios_i2f
  5700                                  
  5701                                  VxDthere:
  5702 0000083C 89C3                    	mov	bx,ax
  5703 0000083E B43E                    	mov	ah,CLOSE ; 3Eh
  5704 00000840 CD21                    	int	21h			;close the file
  5705                                  
  5706                                  	; Update the VxD ptr in the instance data structure with path to VxD
  5707                                  
  5708                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  5709                                  	;mov	bx,Win386_Info
  5710                                  	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
  5711                                  	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr+2],ds
  5712                                  	; 15/12/2022
  5713 00000842 C706[E80F][3110]        	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
  5714 00000848 8C1E[EA0F]              	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],ds
  5715                                  
  5716 0000084C 5B                      	pop	bx
  5717 0000084D 58                      	pop	ax
  5718                                  noVxD31:
  5719                                  	; M018; End of block changes
  5720                                  
  5721 0000084E 800E[3010]01            	or	byte [IsWin386],1 	; Indicate WIN386 present
  5722 00000853 800E[0C0D]01            	or	byte [redir_patch],1	; Enable critical sections; M002
  5723                                  
  5724                                  	; M002;
  5725                                  	; Save the previous es:bx (instance data ptr) into our instance table
  5726                                  
  5727 00000858 52                      	push	dx			; M002
  5728 00000859 89DA                    	mov	dx,bx			; M002
  5729                                  					; point ES:BX to Win386_Info ; M002
  5730 0000085B BB[E20F]                	mov	bx,Win386_Info 
  5731 0000085E 895702                  	mov	[bx+2],dx		; M002
  5732 00000861 8C4704                  	mov	[bx+4],es		; M002
  5733 00000864 5A                      	pop	dx			; M002
  5734 00000865 1E                      	push	ds			; M002
  5735 00000866 07                      	pop	es			; M002
  5736                                  	;jmp	win_nexti2f		; M002
  5737                                  	; 15/12/2022
  5738 00000867 EBCD                    	jmp	short win_nexti2f
  5739                                  
  5740                                  	; 15/12/2022
  5741                                  	; Code to return Win386 2.xx instance table
  5742                                  OldWin386Init:
  5743 00000869 58                      	pop	ax			; discard ds pushed on stack
  5744 0000086A BE[C811]                	mov	si,OldInstanceJunk 
  5745                                  					; ds:si = instance table
  5746 0000086D B84852                  	mov	ax,5248h ; 'HR'		; indicate instance data present
  5747                                  	;jmp	next_i2f
  5748                                  	; 15/12/2022
  5749 00000870 EBC5                    	jmp	short next_i2f
  5750                                  
  5751                                  Win386_Leaving:
  5752                                  	; 15/12/2022
  5753 00000872 F6C201                  	test 	dl,1
  5754                                  	;test	dx,1			; is this really win386?
  5755                                  	;jz	short Win386_Leaving_c
  5756                                  	;jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
  5757                                  	; 15/12/2022
  5758 00000875 75BF                    	jnz	short win_nexti2f	
  5759                                  
  5760                                  Win386_Leaving_c:
  5761                                  					; M062 - Start
  5762 00000877 803E[DA0D]01            	cmp	byte [UmbSaveFlag],1	; Q: was umb_arena saved at win start
  5763                                  					;    up.
  5764 0000087C 7523                    	jne	short noumb		; N: not saved 
  5765 0000087E C606[DA0D]00            	mov	byte [UmbSaveFlag],0	; Y: clear UmbSaveFlag and restore 
  5766                                  					;    previously saved umb_head
  5767                                  	; 05/01/2024
  5768                                  	;push	ax ; (not necessary)
  5769 00000883 06                      	push	es
  5770 00000884 51                      	push	cx
  5771 00000885 56                      	push	si
  5772 00000886 57                      	push	di
  5773                                  
  5774                                  	;mov	ax,[UMB_HEAD]
  5775                                  	;mov	es,ax
  5776                                  	; 05/01/2024
  5777 00000887 8E06[8C00]              	mov	es,[UMB_HEAD]
  5778 0000088B 31FF                    	xor	di,di			; es:di -> umb_head
  5779                                  
  5780 0000088D FC                      	cld
  5781                                  
  5782 0000088E BE[F511]                	mov	si,UmbSave1
  5783 00000891 B90B00                  	mov	cx,11
  5784 00000894 F3A4                    	rep	movsb
  5785 00000896 BE[D50D]                	mov	si,UmbSave2
  5786                                  	;mov	cx,5
  5787                                  	; 18/12/2022
  5788 00000899 B105                    	mov	cl,5
  5789 0000089B F3A4                    	rep	movsb
  5790                                  
  5791 0000089D 5F                      	pop	di
  5792 0000089E 5E                      	pop	si
  5793 0000089F 59                      	pop	cx
  5794 000008A0 07                      	pop	es
  5795                                  	; 05/01/2024
  5796                                  	;pop	ax
  5797                                  noumb:					; M062 - End
  5798 000008A1 8026[3010]00            	and	byte [IsWin386],0	; Win386 is gone
  5799 000008A6 8026[0C0D]00            	and	byte [redir_patch],0	; Disable critical sections ; M002
  5800 000008AB EB89                    	jmp	short win_nexti2f
  5801                                  
  5802                                  ;	; 15/12/2022
  5803                                  ;	; Code to return Win386 2.xx instance table
  5804                                  ;OldWin386Init:
  5805                                  ;	pop	ax			; discard ds pushed on stack
  5806                                  ;	mov	si,OldInstanceJunk 
  5807                                  ;					; ds:si = instance table
  5808                                  ;	mov	ax,5248h ; 'RH'		; indicate instance data present
  5809                                  ;	;jmp	next_i2f
  5810                                  ;	; 15/12/2022
  5811                                  ;	jmp	short _next_i2f
  5812                                  
  5813                                  Win386_Query:
  5814 000008AD 83FB15                  	cmp	bx,Win386_DOSMGR ; 15h	; is this from DOSMGR?
  5815 000008B0 7584                    	jne	short win_nexti2f     	; no, ignore it & chain to next
  5816 000008B2 09C9                    	or	cx,cx			; is it an instance query?
  5817 000008B4 7508                    	jne	short dosmgr_func	; no, some DOSMGR query
  5818 000008B6 41                      	inc	cx			; indicate that data is instanced
  5819                                  ;
  5820                                  ; M001; We were previously returning a null ptr in es:bx. This will not work.
  5821                                  ; M001; WIN386 needs a ptr to a table in es:bx with the following offsets:
  5822                                  ; M001;  
  5823                                  ; M001; OFFSETS STRUC
  5824                                  ; M001; 	Major_version	db	?
  5825                                  ; M001; 	Minor_version	db	?
  5826                                  ; M001; 	SaveDS		dw	?
  5827                                  ; M001; 	SaveBX		dw	?
  5828                                  ; M001; 	Indos		dw	?
  5829                                  ; M001; 	User_id		dw	?
  5830                                  ; M001; 	CritPatch	dw	?
  5831                                  ; M001; OFFSETS	ENDS
  5832                                  ; M001; 
  5833                                  ; M001; User_Id is the only variable really important for proper functioning  
  5834                                  ; M001; of Win386. The other variables are used at init time to patch stuff
  5835                                  ; M001; out. In DOS 5.0, we do the patching ourselves. But we still need to 
  5836                                  ; M001; pass this table because Win386 depends on this table to get the 
  5837                                  ; M001; User_Id offset.
  5838                                  ; M001; 
  5839 000008B7 BB[2210]                	mov	bx,Win386_DOSVars	; M001 
  5840 000008BA 1E                      	push	ds			; M001
  5841 000008BB 07                      	pop	es			; es:bx points at offset table ; M001
  5842 000008BC EB40                    	jmp	short PopIret		; M001
  5843                                  
  5844                                  ; 15/12/2022
  5845                                  ;	; Code to return Win386 2.xx instance table
  5846                                  ;OldWin386Init:
  5847                                  ;	pop	ax			; discard ds pushed on stack
  5848                                  ;	mov	si,OldInstanceJunk 
  5849                                  ;					; ds:si = instance table
  5850                                  ;	mov	ax,5248h ; 'RH'		; indicate instance data present
  5851                                  ;	;jmp	next_i2f
  5852                                  ;	; 15/12/2022
  5853                                  ;	jmp	short _next_i2f
  5854                                  
  5855                                  dosmgr_func:
  5856 000008BE 49                      	dec	cx
  5857 000008BF 7435                    	jz	short win386_patch	; call to patch DOS
  5858 000008C1 49                      	dec	cx
  5859 000008C2 743A                    	jz	short PopIret		; remove DOS patches, ignore
  5860 000008C4 49                      	dec	cx
  5861 000008C5 7439                    	jz	short win386_size	; get size of DOS data structures
  5862 000008C7 49                      	dec	cx
  5863 000008C8 7428                    	jz	short win386_inst	; instance more data
  5864                                  	;dec	cx
  5865                                  	;jnz	short PopIret		; no functions above this
  5866                                  	; 05/01/2024 (PCDOS 7.1 IBMDOS.COM DOSCODE:4771h)
  5867 000008CA E232                    	loop	PopIret
  5868                                  
  5869                                  	; Get DOS device driver size -- es:di points at device driver header
  5870                                  	; In DOS 4.x, the para before the device header contains an arena 
  5871                                  	; header for the driver.
  5872                                  
  5873 000008CC 8CC0                    	mov	ax,es			; ax = device header segment
  5874                                  
  5875                                  	; We check to see if we have a memory arena for this device driver. 
  5876                                  	; The way to do this would be to look at the previous para to see if
  5877                                  	; it has a 'D' marking it as an arena and also see if the owner-field 
  5878                                  	; in the arena is the same as the device header segment. These two 
  5879                                  	; checks together should take care of all cases
  5880                                  
  5881 000008CE 48                      	dec	ax			; get arena header
  5882 000008CF 06                      	push	es
  5883 000008D0 8EC0                    	mov	es,ax			; arena header for device driver
  5884                                  
  5885 000008D2 26803D44                	cmp	byte [es:di],'D'	; is it a device arena?
  5886 000008D6 7517                    	jnz	short cantsize		; no, cant size this driver
  5887 000008D8 40                      	inc	ax			; get back device header segment
  5888 000008D9 26394501                	cmp	[es:di+1],ax		; owner field pointing at driver?
  5889 000008DD 7510                    	jnz	short cantsize		; no, not a proper arena
  5890                                  
  5891 000008DF 268B4503                	mov	ax,[es:di+3]		; get arena size in paras
  5892 000008E3 07                      	pop	es
  5893                                  
  5894                                  	; We have to multiply by 16 to get the number of bytes in (bx:cx)
  5895                                  	; Speed is not critical and so we choose the shortest method 
  5896                                  	; -- use "mul"
  5897                                  
  5898 000008E4 BB1000                  	mov	bx,16
  5899 000008E7 F7E3                    	mul	bx
  5900 000008E9 89C1                    	mov	cx,ax
  5901 000008EB 89D3                    	mov	bx,dx
  5902 000008ED EB09                    	jmp	short win386_done	; return with device driver size
  5903                                  cantsize:
  5904 000008EF 07                      	pop	es
  5905 000008F0 31C0                    	xor	ax,ax
  5906                                  win386_inst:	; 05/01/2024
  5907 000008F2 31D2                    	xor	dx,dx			; ask DOSMGR to use its methods
  5908 000008F4 EB08                    	jmp	short PopIret		; return
  5909                                  
  5910                                  win386_patch:
  5911                                  	; dx contains bits marking the patches to be applied. We return 
  5912                                  	; the field with all bits set to indicate that all patches have been
  5913                                  	; done
  5914                                  
  5915 000008F6 89D3                    	mov	bx,dx			; move patch bitfield to bx
  5916                                   	;jmp	short win386_done	; done, return
  5917                                  	; 15/12/2022
  5918                                  	; 15/12/2022
  5919                                  win386_done:
  5920 000008F8 B87CB9                  	mov	ax,WIN_OP_DONE		; 0B97Ch
  5921 000008FB BAABA2                  	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
  5922                                  PopIret:
  5923 000008FE 1F                      	pop	ds
  5924 000008FF CF                      	iret	
  5925                                  
  5926                                  win386_size:
  5927                                  	; Return the size of DOS data structures -- currently only CDS size
  5928                                  
  5929                                  	; 17/12/2022
  5930 00000900 F6C201                  	test	dl,1
  5931                                  	;test	dx,1			; check for CDS size bit
  5932 00000903 74F9                    	jz	short PopIret		; no, unknown structure -- return
  5933                                  
  5934 00000905 B95800                  	mov	cx,curdirLen	; 88 	; cx = CDS size
  5935 00000908 EBEE                    	jmp	short win386_done	; return with the size
  5936                                  
  5937                                  ; 05/01/2024
  5938                                  %if 0
  5939                                  win386_inst:
  5940                                  	; WIN386 check to see if DOS has identified the CDS,SFT and device
  5941                                  	; chain as instance data. Currently, we let the WIN386 DOSMGR handle
  5942                                  	; this by returning a status of not previously instanced. The basic
  5943                                  	; structure of these things have not changed and so the current
  5944                                  	; DOSMGR code should be able to work it out
  5945                                  
  5946                                  	xor	dx,dx			; make sure dx has a not done value
  5947                                  	jmp	short PopIret		; skip done indication
  5948                                  %endif
  5949                                  
  5950                                  	; 15/12/2022
  5951                                  ;win386_done:
  5952                                  ;	mov	ax,WIN_OP_DONE		; 0B97Ch
  5953                                  ;	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
  5954                                  ;PopIret:
  5955                                  ;	pop	ds
  5956                                  ;	iret				; return back up the chain
  5957                                  
  5958                                  	; 15/12/2022
  5959                                  ;win_nexti2f:
  5960                                  	;pop	ds
  5961                                  	;jmp	next_i2f		; go to BIOS i2f handler
  5962                                  
  5963                                  ;End WIN386 support
  5964                                  
  5965                                  ; 15/05/2019
  5966                                  
  5967                                  ;M044; Start of changes
  5968                                  ; Winoldap has a bug in that its calculations for the Windows memory image
  5969                                  ; to save is off by 1 para. This para can happen to be a Windows arena if the
  5970                                  ; DOS top of memory happens to be at an odd boundary (as is the case when
  5971                                  ; UMBs are present). This is because Windows builds its arenas only at even
  5972                                  ; para boundaries. This arena now gets trashed when Windows is swapped back
  5973                                  ; in leading to a crash. Winoldap issues callouts when it swaps Windows out
  5974                                  ; and back in. We sit on these callouts. On the Windows swapout, we save the
  5975                                  ; last para of the Windows memory block and then restore this para on the
  5976                                  ; Windows swapin callout. 
  5977                                  
  5978                                  getwinlast:
  5979                                  	; 07/12/2022
  5980 0000090A 8B36[3003]              	mov	si,[CurrentPDB]
  5981 0000090E 4E                      	dec	si
  5982 0000090F 8EC6                    	mov	es,si
  5983 00000911 2603360300              	add	si,[es:3]
  5984 00000916 C3                      	retn
  5985                                  
  5986                                  ; 15/12/2022
  5987                                  %if 0
  5988                                  winold_swap:
  5989                                  	push	ds
  5990                                  	push	es
  5991                                  	push	si
  5992                                  	push	di
  5993                                  	push	cx
  5994                                  
  5995                                  	;getdseg <ds>			;ds = DOSDATA
  5996                                  	mov	ds,[cs:DosDSeg]
  5997                                  
  5998                                  	cmp	al,1			;swap Windows out call
  5999                                  	jne	short swapin		;no, check if Swap in call
  6000                                  	call	getwinlast
  6001                                  	push	ds
  6002                                  	pop	es
  6003                                  	mov	ds,si			;ds = memory arena of Windows
  6004                                  	xor	si,si
  6005                                  	mov	di,WinoldPatch1
  6006                                  	mov	cx,8
  6007                                  	cld
  6008                                  	push	cx
  6009                                  	rep	movsb			;save first 8 bytes
  6010                                  	pop	cx
  6011                                  	mov	di,WinoldPatch2
  6012                                  	rep	movsb			;save next 8 bytes
  6013                                  	jmp	short winold_done
  6014                                  swapin:
  6015                                  	cmp	al,2			;swap Windows in call?
  6016                                  	jne	short winold_done	;no, something else, pass it on
  6017                                  	call	getwinlast
  6018                                  	mov	es,si
  6019                                  	xor	di,di
  6020                                  	mov	si,WinoldPatch1
  6021                                  	mov	cx,8
  6022                                  	cld
  6023                                  	push	cx
  6024                                  	rep	movsb			;restore first 8 bytes
  6025                                  	pop	cx
  6026                                  	mov	si,WinoldPatch2
  6027                                  	rep	movsb			;restore next 8 bytes
  6028                                  winold_done:
  6029                                  	pop	cx
  6030                                  	pop	di
  6031                                  	pop	si
  6032                                  	pop	es
  6033                                  	pop	ds
  6034                                  	jmp	next_i2f		;chain on
  6035                                  
  6036                                  %endif
  6037                                  
  6038                                  ;M044; End of changes
  6039                                  
  6040                                  ; 15/05/2019
  6041                                  
  6042                                  DispatchDOS:
  6043 00000917 2EFF36[C401]            	PUSH	word [CS:FOO]		; push return address
  6044 0000091C 2EFF36[C601]            	PUSH	word [CS:DTab]		; push table address
  6045 00000921 50                      	PUSH	AX			; push index
  6046 00000922 55                      	PUSH	BP
  6047 00000923 89E5                    	MOV	BP,SP
  6048                                  		; stack looks like:
  6049                                  		;   0	BP
  6050                                  		;   2	DISPATCH
  6051                                  		;   4	TABLE
  6052                                  		;   6	RETURN
  6053                                  		;   8	LONG-RETURN
  6054                                  		;   C	FLAGS
  6055                                  		;   E	AX
  6056                                  	
  6057 00000925 8B460E                  	MOV	AX,[BP+0Eh]		; get AX value
  6058 00000928 5D                      	POP	BP
  6059 00000929 E8F408                  	call	TableDispatch
  6060 0000092C E9DEFD                  	JMP	BadFunc 		; return indicates invalid function
  6061                                  
  6062                                  INT2F_etcetera:
  6063                                  	;entry	DosGetGroup
  6064                                  DosGetGroup:
  6065                                  	; MSDOS 3.3
  6066                                  	;push	cs
  6067                                  	;pop	ds
  6068                                  	;retn
  6069                                  
  6070                                  	; MSDOS 6.0
  6071                                  ;SR; Cannot use CS now
  6072                                  ;
  6073                                  ;	PUSH	CS
  6074                                  ;	POP	DS
  6075                                  
  6076                                  	; 04/11/2022
  6077                                  	; (MSDOS 5.0 MSDOS.SYS - DOSCODE:46FBh)
  6078                                  
  6079                                  	;getdseg <ds>
  6080 0000092F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6081 00000934 C3                      	retn
  6082                                  
  6083                                  	;entry	DOSInstall
  6084                                  DOSInstall:
  6085 00000935 B0FF                    	MOV	AL,0FFh
  6086 00000937 C3                      	retn
  6087                                  
  6088                                  ;ENDIF ; (*)
  6089                                  
  6090                                  
  6091                                  ; 15/05/2019 - Retro DOS v4.0
  6092                                  
  6093                                  ;------------------------------------------------------------------------
  6094                                  ;
  6095                                  ; Procedure Name : RW32_CONVERT
  6096                                  ;
  6097                                  ;Input: same as ABSDRD and ABSDWRT
  6098                                  ;	 ES:BP -> DPB
  6099                                  ;Functions: convert 32bit absolute RW input parms to 16bit input parms
  6100                                  ;Output: carry set when CX=-1 and drive is less then 32mb
  6101                                  ;	 carry clear, parms ok
  6102                                  ;
  6103                                  ;------------------------------------------------------------------------
  6104                                  
  6105                                  	; 06/01/2024
  6106                                  RW32_CONVERT:
  6107                                  	;inc	cx ; *	; 01 -> 0
  6108 00000938 83F9FF                  	CMP	CX,-1			   ;>32mb  new format ?	;AN000;
  6109 0000093B 7429                    	JZ	short new32format	   ;>32mb  yes		;AN000;
  6110                                  	;dec	cx ; *
  6111 0000093D 50                      	PUSH	AX			   ;>32mb  save ax	;AN000;
  6112 0000093E 52                      	PUSH	DX			   ;>32mb  save dx	;AN000;
  6113                                  	;mov	ax,[es:bp+0Dh]
  6114 0000093F 268B460D                	MOV	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  get max cluster # ;AN000;
  6115                                  	;mov	dl,[es:bp+4]
  6116 00000943 268A5604                	MOV	DL,[ES:BP+DPB.CLUSTER_MASK] ;>32mb		;AN000;
  6117 00000947 80FAFE                  	CMP	DL,0FEh ; 254		;>32mb  removable ?	;AN000;
  6118 0000094A 7407                    	JZ	short letold		;>32mb  yes		;AN000;
  6119                                  	;INC	DL			;>32mb			;AN000;
  6120                                  	; 17/12/2022
  6121 0000094C 42                      	inc	dx
  6122 0000094D 30F6                    	XOR	DH,DH			;>32mb  dx = sector/cluster ;AN000;
  6123 0000094F F7E2                    	MUL	DX			;>32mb  dx:ax= max sector # ;AN000;
  6124 00000951 09D2                    	OR	DX,DX	; (clears CF)	;>32mb  > 32mb ?	;AN000;
  6125                                  letold:
  6126 00000953 5A                      	POP	DX			;>32mb  restore dx	;AN000;
  6127 00000954 58                      	POP	AX			;>32mb  restore ax 	;AN000;
  6128 00000955 7425                    	JZ	short old_style	; cf=0	;>32mb  no 		;AN000;
  6129                                  
  6130 00000957 1E                      	push	ds
  6131                                  	;getdseg <ds>
  6132 00000958 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6133 0000095D C706[B80D]0702          	mov	word [AbsDskErr],207h	;>32mb  bad address mark
  6134 00000963 1F                      	pop	ds
  6135                                  
  6136 00000964 F9                      	STC				;>32mb			;AN000;
  6137 00000965 C3                      	retn				;>32mb			;AN000;
  6138                                  
  6139                                  new32format:
  6140                                  	;mov	dx,[bx+2]
  6141 00000966 8B5702                  	MOV	DX,[BX+ABS_32RW.SECTOR_RBA+2] ;>32mb		;AN000;
  6142                                  
  6143 00000969 1E                      	push	ds			; set up ds to DOSDATA
  6144                                  	;getdseg <ds>
  6145 0000096A 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6146 0000096F 8916[0706]              	MOV	[HIGH_SECTOR],DX	;>32mb			;AN000;
  6147 00000973 1F                      	pop	ds
  6148                                  
  6149 00000974 8B17                    	mov	dx,[bx]
  6150                                  	;MOV	DX,[BX+ABS_32RW.SECTOR_RBA]  ;>32mb		;AN000;
  6151                                  	;mov	cx,[bx+4]
  6152 00000976 8B4F04                  	MOV	CX,[BX+ABS_32RW.ABS_RW_COUNT] ;>32mb		;AN000;
  6153                                  	;lds	bx,[bx+6]
  6154 00000979 C55F06                  	LDS	BX,[BX+ABS_32RW.BUFFER_ADDR] ;>32mb		;AN000;
  6155                                  old_style:				;>32mb			;AN000;
  6156                                  	; 06/01/2024
  6157                                  	; cf=0
  6158                                  	;CLC				;>32mb			;AN000;
  6159 0000097C C3                      	retn				;>32mb			;AN000;
  6160                                  
  6161                                  ;------------------------------------------------------------------------
  6162                                  ;
  6163                                  ; Procedure Name : Fastxxx_Purge
  6164                                  ;
  6165                                  ; Input: None
  6166                                  ; Functions: Purge Fastopen/ Cache Buffers
  6167                                  ; Output: None
  6168                                  ;
  6169                                  ;------------------------------------------------------------------------
  6170                                  
  6171                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6172                                  
  6173                                  Fastxxx_Purge:
  6174 0000097D 50                      	PUSH	AX			; save regs.	;AN000;
  6175 0000097E 56                      	PUSH	SI						;AN000;
  6176 0000097F 52                      	PUSH	DX						;AN000;
  6177                                  topen:
  6178 00000980 1E                      	push	ds			; set up ds to DOSDATA
  6179                                  	;getdseg <ds>
  6180 00000981 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6181                                  
  6182 00000986 F606[3A0D]80            	TEST	byte [FastOpenFlg],Fast_yes ; 80h 
  6183                                  					; fastopen installed ?	;AN000;
  6184 0000098B 1F                      	pop	ds
  6185 0000098C 740B                    	JZ	short nofast		; no			;AN000;
  6186 0000098E B401                    	MOV	AH,FastOpen_ID	; 1				;AN000;
  6187                                  dofast:
  6188 00000990 B005                    	MOV	AL,FONC_purge  ;5	; purge			;AN000;
  6189                                  	;;mov	dl,[es:bp+0]
  6190                                  	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  6191                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; set up drive number	;AN000;
  6192                                  	; 15/12/2022
  6193 00000992 268A5600                	mov	dl,[es:bp]
  6194                                  	;invoke	Fast_Dispatch		; call fastopen/seek	;AN000;
  6195 00000996 E8701D                  	call	Fast_Dispatch
  6196                                  nofast:
  6197 00000999 5A                      	POP	DX						;AN000;
  6198 0000099A 5E                      	POP	SI			; restore regs		;AN000;
  6199 0000099B 58                      	POP	AX			 			;AN000;
  6200 0000099C C3                      	retn				; exit
  6201                                  
  6202                                  ;============================================================================
  6203                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6204                                  ;============================================================================
  6205                                  ; 29/04/2019 - Retro DOS v4.0
  6206                                  
  6207                                  ;include dossym.inc
  6208                                  ;include dosmac.inc
  6209                                  ;include doscntry.inc
  6210                                  
  6211                                  ; DOSCODE Segment
  6212                                  
  6213                                  ; 17/07/2018 - Retro DOS v3.0  [ DOSMES.INC (MSDOS 3.3, 1987) ]
  6214                                  ; ---------------------------------------------------------------------------
  6215                                  ;include divmes.inc
  6216                                  
  6217                                  ; DOSCODE:4778h (MSDOS 6.21, MSDOS.SYS)
  6218                                  ; -------------------------------------
  6219                                  ; DOSCODE:476Bh (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6220                                  
  6221                                  ; THIS IS THE ONLY DOS "MESSAGE". IT DOES NOT NEED A TERMINATOR.
  6222                                  	;PUBLIC	DIVMES
  6223                                  
  6224 0000099D 0D0A44697669646520-     DIVMES:	DB	13,10,"Divide overflow",13,10
  6224 000009A6 6F766572666C6F770D-
  6224 000009AF 0A                 
  6225                                  
  6226                                  	;PUBLIC	DivMesLen
  6227                                  DivMesLen:
  6228 000009B0 1300                    	DW	$-DIVMES  ; 19	; Length of the above message in bytes
  6229                                  
  6230                                  ; DOSCODE:478Dh (MSDOS 6.21, MSDOS.SYS)
  6231                                  ; -------------------------------------
  6232                                  ; DOSCODE:4780h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6233                                  
  6234                                  ; (MSDOS 6.0)
  6235                                  ; VxD not found error message
  6236                                  
  6237                                  NoVxDErrMsg:
  6238 000009B2 596F75206D75737420-     	db  'You must have the file WINA20.386 in the root of your boot drive'
  6238 000009BB 686176652074686520-
  6238 000009C4 66696C652057494E41-
  6238 000009CD 32302E33383620696E-
  6238 000009D6 2074686520726F6F74-
  6238 000009DF 206F6620796F757220-
  6238 000009E8 626F6F742064726976-
  6238 000009F1 65                 
  6239 000009F2 0D0A746F2072756E20-     	db  0Dh,0Ah,'to run Windows in Enhanced Mode',0Dh,0Ah
  6239 000009FB 57696E646F77732069-
  6239 00000A04 6E20456E68616E6365-
  6239 00000A0D 64204D6F64650D0A   
  6240                                  
  6241                                  VxDMesLen equ $ - NoVxDErrMsg  ; 99
  6242                                  
  6243                                  ; 13/05/2019 - Retro DOS v4.0
  6244                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6245                                  
  6246                                  ;include yesno.asm  (MNSDOS 6.0)
  6247                                  ; -------------------------------------
  6248                                  ; DOSCODE:47F0h (MSDOS 6.21, MSDOS.SYS)
  6249                                  ; DOSCODE:47E3h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6250                                  
  6251                                  ; This is for country Yes and No
  6252                                  
  6253 00000A15 59                      NLS_YES:	db 'Y'
  6254 00000A16 4E                      NLS_NO:		db 'N'
  6255 00000A17 79                      NLS_yes2:	db 'y'
  6256 00000A18 6E                      NLS_no2:	db 'n'
  6257                                  
  6258                                  ; ---------------------------------------------------------------------------
  6259                                  
  6260                                  ; DOSCODE:47F4h (MSDOS 6.21, MSDOS.SYS)
  6261                                  ; DOSCODE:47E7h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6262                                  
  6263                                  ;SUBTTL EDIT FUNCTION ASSIGNMENTS AND HEADERS
  6264                                  
  6265                                  ; The following two tables implement the current buffered input editing
  6266                                  ; routines. The tables are pairwise associated in reverse order for ease
  6267                                  ; in indexing. That is; The first entry in ESCTAB corresponds to the last
  6268                                  ; entry in ESCFUNC, and the last entry in ESCTAB to the first entry in ESCFUNC.
  6269                                  
  6270                                  	;PUBLIC	CANCHAR
  6271                                  CANCHAR:
  6272 00000A19 1B                      	DB	CANCEL	; 1Bh	;Cancel line character
  6273                                  	
  6274                                  	;PUBLIC	ESCCHAR
  6275                                  ESCCHAR:
  6276 00000A1A 00                      	DB	ESCCH	; 0	;Lead-in character for escape sequences
  6277                                  	
  6278                                  	;IF	NOT Rainbow
  6279                                  
  6280                                  ESCTAB:	; LABEL BYTE
  6281                                  
  6282                                  	;IF	IBM
  6283 00000A1B 40                      	DB	64		; Ctrl-Z - F6
  6284 00000A1C 4D                      	DB	77		; Copy one char - -->
  6285 00000A1D 3B                      	DB	59		; Copy one char - F1
  6286 00000A1E 53                      	DB	83		; Skip one char - DEL
  6287 00000A1F 3C                      	DB	60		; Copy to char - F2
  6288 00000A20 3E                      	DB	62		; Skip to char - F4
  6289 00000A21 3D                      	DB	61		; Copy line - F3
  6290 00000A22 3D                      	DB	61		; Kill line (no change to template ) - Not used
  6291 00000A23 3F                      	DB	63		; Reedit line (new template) - F5
  6292 00000A24 4B                      	DB	75		; Backspace - <--
  6293 00000A25 52                      	DB	82		; Enter insert mode - INS (toggle)
  6294 00000A26 52                      	DB	82		; Exit insert mode - INS (toggle)
  6295 00000A27 41                      	DB	65		; Escape character - F7
  6296 00000A28 41                      	DB	65		; End of table
  6297                                  	;ENDIF
  6298                                  
  6299                                  ESCEND: ; LABEL BYTE
  6300                                  
  6301                                  ESCTABLEN EQU ESCEND-ESCTAB
  6302                                  
  6303                                  ESCFUNC: ; LABEL WORD
  6304                                  	
  6305 00000A29 [1514]                  	short_addr  GETCH	; Ignore the escape sequence
  6306 00000A2B [9214]                  	short_addr  TWOESC
  6307 00000A2D [8715]                  	short_addr  EXITINS
  6308 00000A2F [8715]                  	short_addr  ENTERINS
  6309 00000A31 [8D14]                  	short_addr  BACKSP
  6310 00000A33 [7315]                  	short_addr  REEDIT
  6311 00000A35 [7A14]                  	short_addr  KILNEW
  6312 00000A37 [0915]                  	short_addr  COPYLIN
  6313 00000A39 [3B15]                  	short_addr  SKIPSTR
  6314 00000A3B [0F15]                  	short_addr  COPYSTR
  6315 00000A3D [3215]                  	short_addr  SKIPONE
  6316 00000A3F [1415]                  	short_addr  COPYONE
  6317 00000A41 [1415]                  	short_addr  COPYONE
  6318 00000A43 [8E15]                  	short_addr  CTRLZ
  6319                                  
  6320                                  	;ENDIF
  6321                                  
  6322                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6323                                  ; ---------------------------------------------------------------------------
  6324                                  ; DOSMES.ASM (MSDOS 2.11, 1983)
  6325                                  
  6326                                  ; OEMFunction key is expected to process a single function
  6327                                  ;   key input from a device and dispatch to the proper
  6328                                  ;   routines leaving all registers UNTOUCHED.
  6329                                  ;
  6330                                  ; Inputs:   CS, SS are DOSGROUP
  6331                                  ; Outputs:  None. This function is expected to JMP to onw of
  6332                                  ;           the following labels:
  6333                                  ;
  6334                                  ;           GetCh       - ignore the sequence
  6335                                  ;           TwoEsc      - insert an ESCChar in the buffer
  6336                                  ;           ExitIns     - toggle insert mode
  6337                                  ;           EnterIns    - toggle insert mode
  6338                                  ;           BackSp      - move backwards one space
  6339                                  ;           ReEdit      - reedit the line with a new template
  6340                                  ;           KilNew      - discard the current line and start from scratch
  6341                                  ;           CopyLin     - copy the rest of the template into the line
  6342                                  ;           SkipStr     - read the next character and skip to it in the template
  6343                                  ;           CopyStr     - read next char and copy from template to line until char
  6344                                  ;           SkipOne     - advance position in template one character
  6345                                  ;           CopyOne     - copy next character in template into line
  6346                                  ;           CtrlZ       - place a ^Z into the template
  6347                                  ; Registers that are allowed to be modified by this function are:
  6348                                  ;           AX, CX, BP
  6349                                  
  6350                                  ; 13/05/2019 - Retro DOS v4.0
  6351                                  ; -------------------------------------
  6352                                  ; DOSCODE:4820h (MSDOS 6.21, MSDOS.SYS)
  6353                                  
  6354                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6355                                  ; -------------------------------------
  6356                                  ; DOSCODE:4813h (MSDOS 5.0, MSDOS.SYS)
  6357                                  
  6358                                  OEMFunctionKey:
  6359 00000A45 E82F09                  	CALL	_$STD_CON_INPUT_NO_ECHO	; Get the second byte of the sequence
  6360 00000A48 B10E                    	MOV     CL,ESCTABLEN ; 14	; length of table for scan
  6361 00000A4A 57                      	PUSH    DI                      ; save DI (cannot change it!)
  6362 00000A4B BF[1B0A]                	MOV     DI,ESCTAB		; offset of second byte table
  6363 00000A4E 06                      	push	es
  6364 00000A4F 0E                      	push	cs
  6365 00000A50 07                      	pop	es
  6366 00000A51 F2AE                    	REPNE   SCASB                   ; Look it up in the table
  6367 00000A53 07                      	pop	es
  6368 00000A54 5F                      	POP     DI                      ; restore DI
  6369 00000A55 D1E1                    	SHL     CX,1                    ; convert byte offset to word
  6370 00000A57 89CD                    	MOV     BP,CX                   ; move to indexable register
  6371                                  	;JMP	word [BP+ESCFUNC]	; Go to the right routine
  6372 00000A59 2EFFA6[290A]            	JMP	word [CS:BP+ESCFUNC]
  6373                                  
  6374                                  ;DOSCODE ENDS
  6375                                  	
  6376                                  ;============================================================================
  6377                                  ; TIME.ASM (MSDOS 6.0, 1991)
  6378                                  ;============================================================================
  6379                                  ; Retro DOS v3.0 - 18/07/2018
  6380                                  
  6381                                  ; SYSCALL.ASM (MSDOS 2.11, 1983)
  6382                                  ;----------------------------------------------------------------------------
  6383                                  ; Retro DOS v2.0 - 13/03/2018
  6384                                  
  6385                                  ;**	TIME.ASM - System Calls and low level routines for DATE and TIME
  6386                                  
  6387                                  	;BREAK <DATE AND TIME - SYSTEM CALLS 42,43,44,45>
  6388                                  
  6389                                  ;**	$GET_DATE - Get Current Date
  6390                                  ;----------------------------------------
  6391                                  ;	ENTRY	none
  6392                                  ;	EXIT	(cx:dx) = current date
  6393                                  ;	USES	all
  6394                                  
  6395                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6396                                  
  6397                                  _$GET_DATE:	;System call 42
  6398                                  
  6399 00000A5E 16                      	PUSH	SS
  6400 00000A5F 1F                      	POP	DS
  6401 00000A60 E8B700                  	CALL	READTIME	;Check for rollover to next day
  6402 00000A63 A1[5203]                	MOV	AX,[YEAR]
  6403                                  
  6404                                  ;	WARNING!!!! DAY and MONTH must be adjacently allocated!
  6405                                  
  6406 00000A66 8B1E[5003]              	MOV	BX,[DAY]	; fetch both day and month
  6407 00000A6A E814FA                  	CALL	Get_User_Stack	;Get pointer to user registers
  6408                                  	;MOV	[SI+6],BX	;DH=month, DL=day
  6409 00000A6D 895C06                  	MOV	[SI+user_env.user_DX],BX
  6410 00000A70 05BC07                  	ADD	AX,1980		;Put bias back
  6411                                  	;MOV	[SI+4],AX	;CX=year
  6412 00000A73 894404                  	MOV	[SI+user_env.user_CX],AX
  6413 00000A76 36A0[5603]              	MOV	AL,[SS:WEEKDAY]	;hkn; SS override
  6414                                  RET20:	; 05/11/2022
  6415                                  RET24:	; 18/12/2022
  6416 00000A7A C3                      	RETN
  6417                                  
  6418                                  ;**	$SET_DATE - Set Current Date
  6419                                  ;----------------------------------------
  6420                                  ;	ENTRY	(cx:dx) = current date
  6421                                  ;	EXIT	(al) = -1 iff bad date
  6422                                  ;		(al) = 0 if ok
  6423                                  ;	USES	all
  6424                                  
  6425                                  _$SET_DATE:	;System call 43
  6426                                  
  6427 00000A7B B0FF                    	MOV	AL,-1		;Be ready to flag error
  6428 00000A7D 81E9BC07                	SUB	CX,1980		;Fix bias in year
  6429                                  	;JC	SHORT RET24	;Error if not big enough
  6430                                  	; 05/11/2022
  6431 00000A81 72F7                    	jc	short RET20
  6432 00000A83 83F977                  	CMP	CX,119		;Year must be less than 2100
  6433 00000A86 77F2                    	JA	SHORT RET24
  6434 00000A88 08F6                    	OR	DH,DH
  6435                                  	;JZ	SHORT RET24
  6436                                   	; 05/11/2022
  6437 00000A8A 74EE                    	jz	short RET20
  6438 00000A8C 08D2                    	OR	DL,DL
  6439                                  	;JZ	SHORT RET24	;Error if either month or day is 0
  6440                                  	; 05/11/2022
  6441 00000A8E 74EA                    	jz	short RET20
  6442 00000A90 80FE0C                  	CMP	DH,12		;Check against max. month
  6443 00000A93 77E5                    	JA	SHORT RET24
  6444 00000A95 16                      	PUSH	SS
  6445 00000A96 1F                      	POP	DS
  6446                                  	;CALL	DODATE
  6447                                  	; 18/12/2022
  6448 00000A97 E91301                  	jmp	DODATE
  6449                                  ;RET24:  
  6450                                  	;RETN
  6451                                  
  6452                                  ;**	$GET_TIME - Get Current Time
  6453                                  ;----------------------------------------
  6454                                  ;	ENTRY	none
  6455                                  ;	EXIT	(cx:dx) = current time
  6456                                  ;	USES	all
  6457                                  
  6458                                  _$GET_TIME:			;System call 44
  6459                                  
  6460 00000A9A 16                      	PUSH	SS
  6461 00000A9B 1F                      	POP	DS
  6462 00000A9C E87B00                  	CALL	READTIME
  6463 00000A9F E8DFF9                  	CALL	Get_User_Stack	;Get pointer to user registers
  6464                                  	;MOV	[SI+6],DX
  6465 00000AA2 895406                  	MOV	[SI+user_env.user_DX],DX
  6466                                  	;MOV	[SI+4],CX
  6467 00000AA5 894C04                  	MOV	[SI+user_env.user_CX],CX
  6468                                  set_time_ok:	; 06/01/2024
  6469 00000AA8 30C0                    	XOR	AL,AL
  6470                                  RET26:  
  6471 00000AAA C3                      	RETN
  6472                                  
  6473                                  ;**	$SET_TIME - Set Current Time
  6474                                  ;----------------------------------------
  6475                                  ;	ENTRY	(cx:dx) = time
  6476                                  ;	EXIT	(al) = 0 if 0k
  6477                                  ;		(al) = -1 if invalid
  6478                                  ;	USES	ALL
  6479                                  
  6480                                  _$SET_TIME:			;System call 45
  6481                                  
  6482 00000AAB B0FF                    	MOV	AL,-1		;Flag in case of error
  6483 00000AAD 80FD18                  	CMP	CH,24		;Check hours
  6484 00000AB0 73F8                    	JAE	SHORT RET26
  6485 00000AB2 80F93C                  	CMP	CL,60		;Check minutes
  6486 00000AB5 73F3                    	JAE	SHORT RET26
  6487 00000AB7 80FE3C                  	CMP	DH,60		;Check seconds
  6488 00000ABA 73EE                    	JAE	SHORT RET26
  6489 00000ABC 80FA64                  	CMP	DL,100		;Check 1/100's
  6490 00000ABF 73E9                    	JAE	SHORT RET26
  6491 00000AC1 51                      	PUSH	CX
  6492 00000AC2 52                      	PUSH	DX
  6493 00000AC3 16                      	PUSH	SS
  6494 00000AC4 1F                      	POP	DS
  6495 00000AC5 BB[B603]                	MOV	BX,TIMEBUF
  6496 00000AC8 B90600                  	MOV	CX,6
  6497                                  	;XOR	DX,DX
  6498                                  	;MOV	AX,DX
  6499 00000ACB 31C0                    	xor	ax,ax
  6500 00000ACD 99                      	cwd	; 06/01/2024
  6501 00000ACE 53                      	PUSH	BX
  6502 00000ACF E81C3C                  	CALL	SETREAD
  6503 00000AD2 1E                      	PUSH	DS
  6504 00000AD3 C536[2E00]              	LDS	SI,[BCLOCK]
  6505 00000AD7 E89E3B                  	CALL	DEVIOCALL2	;Get correct day count
  6506 00000ADA 1F                      	POP	DS
  6507 00000ADB 5B                      	POP	BX
  6508 00000ADC E8423C                  	CALL	SETWRITE
  6509 00000ADF 8F06[BA03]              	POP	WORD [TIMEBUF+4]
  6510 00000AE3 8F06[B803]              	POP	WORD [TIMEBUF+2]
  6511 00000AE7 C536[2E00]              	LDS	SI,[BCLOCK]
  6512 00000AEB E88A3B                  	CALL	DEVIOCALL2	;Set the time
  6513                                  	; 06/01/2024
  6514                                  	;XOR	AL,AL
  6515                                  	;RETN
  6516 00000AEE EBB8                    	jmp	short set_time_ok
  6517                                  
  6518                                  ; 11/07/2018 - Retro DOS v3.0
  6519                                  ; Retro DOS v2.0 - 14/03/2018
  6520                                  
  6521                                  FOURYEARS EQU 3*365 + 366  ; = 1461 
  6522                                  
  6523                                  ;SUBTTL DATE16, READTIME, DODATE -- GUTS OF TIME AND DATE
  6524                                  ;----------------------------------------------------------
  6525                                  ; Date16 returns the current date in AX, current time in DX
  6526                                  ;   AX - YYYYYYYMMMMDDDDD  years months days
  6527                                  ;   DX - HHHHHMMMMMMSSSSS  hours minutes seconds/2
  6528                                  
  6529                                  DATE16:
  6530                                  	
  6531                                  ;M048	Context DS
  6532                                  ;
  6533                                  ; Since this function can be called thru int 2f we shall not assume that SS
  6534                                  ; is DOSDATA
  6535                                  
  6536                                  	;push	ss
  6537                                  	;pop	ds
  6538                                  
  6539                                  	;getdseg <ds>		; M048
  6540                                  
  6541                                  	; 13/05/2019 - Retro DOS v4.0
  6542 00000AF0 2E8E1E[0700]            	mov	ds, [cs:DosDSeg]	
  6543                                  
  6544 00000AF5 51                      	PUSH	CX
  6545 00000AF6 06                      	PUSH	ES
  6546 00000AF7 E82000                  	CALL	READTIME
  6547 00000AFA 07                      	POP	ES
  6548 00000AFB D0E1                    	SHL	CL,1		;Minutes to left part of byte
  6549 00000AFD D0E1                    	SHL	CL,1
  6550 00000AFF D1E1                    	SHL	CX,1		;Push hours and minutes to left end
  6551 00000B01 D1E1                    	SHL	CX,1
  6552 00000B03 D1E1                    	SHL	CX,1
  6553 00000B05 D0EE                    	SHR	DH,1		;Count every two seconds
  6554 00000B07 08F1                    	OR	CL,DH		;Combine seconds with hours and minutes
  6555 00000B09 89CA                    	MOV	DX,CX
  6556                                  
  6557                                  ;	WARNING! MONTH and YEAR must be adjacently allocated
  6558                                  
  6559 00000B0B A1[5103]                	MOV	AX,[MONTH]	;Fetch month and year
  6560 00000B0E B104                    	MOV	CL,4
  6561 00000B10 D2E0                    	SHL	AL,CL		;Push month to left to make room for day
  6562 00000B12 D1E0                    	SHL	AX,1
  6563 00000B14 59                      	POP	CX
  6564 00000B15 0A06[5003]              	OR	AL,[DAY]
  6565                                  RET21:
  6566 00000B19 C3                      	RETN
  6567                                  
  6568                                  ;----------------------------------------------------------
  6569                                  
  6570                                  READTIME:
  6571                                  
  6572                                  ;Gets time in CX:DX. Figures new date if it has changed.
  6573                                  ;Uses AX, CX, DX.
  6574                                  
  6575 00000B1A C706[910D]0000          	MOV	word [DATE_FLAG],0 ; reset date flag for CPMIO
  6576 00000B20 56                      	PUSH	SI
  6577 00000B21 53                      	PUSH	BX
  6578                                  
  6579 00000B22 BB[B603]                	MOV	BX,TIMEBUF
  6580                                  
  6581 00000B25 B90600                  	MOV	CX,6
  6582                                  	;XOR	DX,DX
  6583                                  	;MOV	AX,DX
  6584                                  	; 06/01/2024
  6585 00000B28 31C0                    	xor	ax,ax
  6586 00000B2A 99                      	cwd
  6587 00000B2B E8C03B                  	CALL	SETREAD
  6588 00000B2E 1E                      	PUSH	DS
  6589 00000B2F C536[2E00]              	LDS	SI,[BCLOCK]
  6590 00000B33 E8423B                  	CALL	DEVIOCALL2	;Get correct date and time
  6591 00000B36 1F                      	POP	DS
  6592 00000B37 5B                      	POP	BX
  6593 00000B38 5E                      	POP	SI
  6594 00000B39 A1[B603]                	MOV	AX,[TIMEBUF]
  6595 00000B3C 8B0E[B803]              	MOV	CX,[TIMEBUF+2]
  6596 00000B40 8B16[BA03]              	MOV	DX,[TIMEBUF+4]
  6597 00000B44 3B06[5403]              	CMP	AX,[DAYCNT]	;See if day count is the same
  6598                                  	;JZ	SHORT RET22
  6599 00000B48 74CF                    	JZ	SHORT RET21 ; 18/07/2018
  6600                                  	;cmp	ax,43830
  6601 00000B4A 3D36AB                  	CMP	AX,FOURYEARS*30 ;Number of days in 120 years
  6602 00000B4D 733D                    	JAE	SHORT RET22	;Ignore if too large
  6603 00000B4F A3[5403]                	MOV	[DAYCNT],AX
  6604 00000B52 56                      	PUSH	SI
  6605 00000B53 51                      	PUSH	CX
  6606 00000B54 52                      	PUSH	DX		;Save time
  6607 00000B55 31D2                    	XOR	DX,DX
  6608                                  	;mov	cx,1461
  6609 00000B57 B9B505                  	MOV	CX,FOURYEARS	;Number of days in 4 years
  6610 00000B5A F7F1                    	DIV	CX		;Compute number of 4-year units
  6611 00000B5C D1E0                    	SHL	AX,1
  6612 00000B5E D1E0                    	SHL	AX,1
  6613 00000B60 D1E0                    	SHL	AX,1		;Multiply by 8 (no. of half-years)
  6614 00000B62 89C1                    	MOV	CX,AX		;<240 implies AH=0
  6615                                  
  6616 00000B64 BE[140D]                	MOV	SI,YRTAB	;Table of days in each year
  6617                                  
  6618 00000B67 E82300                  	CALL	DSLIDE		;Find out which of four years we're in
  6619 00000B6A D1E9                    	SHR	CX,1		;Convert half-years to whole years
  6620 00000B6C 7304                    	JNC	SHORT SK	;Extra half-year?
  6621 00000B6E 81C2C800                	ADD	DX,200
  6622                                  SK:
  6623 00000B72 E82200                  	CALL	SETYEAR
  6624 00000B75 B101                    	MOV	CL,1		;At least at first month in year
  6625                                  
  6626 00000B77 BE[1C0D]                	MOV	SI,MONTAB	;Table of days in each month
  6627                                  	
  6628 00000B7A E81000                  	CALL	DSLIDE		;Find out which month we're in
  6629 00000B7D 880E[5103]              	MOV	[MONTH],CL
  6630 00000B81 42                      	INC	DX		;Remainder is day of month (start with one)
  6631 00000B82 8816[5003]              	MOV	[DAY],DL
  6632 00000B86 E89400                  	CALL	WKDAY		;Set day of week
  6633 00000B89 5A                      	POP	DX
  6634 00000B8A 59                      	POP	CX
  6635 00000B8B 5E                      	POP	SI
  6636                                  RET22:  
  6637 00000B8C C3                      	RETN
  6638                                  
  6639                                  ;----------------------------------------------------------
  6640                                  
  6641                                  DSLIDE:
  6642                                  	;MOV	AH,0
  6643                                  	; 06/01/2024
  6644                                  	; (AH=0)
  6645                                  DSLIDE1:
  6646 00000B8D AC                      	LODSB			;Get count of days
  6647 00000B8E 39C2                    	CMP	DX,AX		;See if it will fit
  6648                                  	;JB	SHORT RET23	;If not, done
  6649 00000B90 72FA                    	jb	short RET22 ; 13/05/2019 - Retro DOS v4.0
  6650 00000B92 29C2                    	SUB	DX,AX
  6651 00000B94 41                      	INC	CX		;Count one more month/year
  6652 00000B95 EBF6                    	JMP	SHORT DSLIDE1
  6653                                  
  6654                                  ;----------------------------------------------------------
  6655                                  
  6656                                  SETYEAR:
  6657                                  
  6658                                  ;Set year with value in CX. Adjust length of February for this year.
  6659                                  
  6660                                  ; NOTE: This can also be called thru int 2f. If this is called then it will
  6661                                  ;	  set DS to DOSDATA. Since the only guy calling this should be the DOS
  6662                                  ;	redir, DS will be DOSDATA anyway. It is going to be in-efficient to
  6663                                  ;	preserve DS as CHKYR is also called as a routine.
  6664                                  
  6665                                  	; MSDOS 6.0 (18/07/2018) ; *
  6666                                  
  6667                                  	;GETDSEG DS
  6668                                  
  6669                                  	;PUSH	CS  ; *
  6670                                  	;POP	DS  ; *
  6671                                  
  6672                                  	; 13/05/2019 - Retro DOS v4.0
  6673 00000B97 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6674                                  
  6675                                  	; Offset 18CEh in IBMDOS.COM (MSDOS 3.3), 1987
  6676                                  	; 05/11/2022 
  6677                                  	; DOSCODE:4970h in MSDOS.SYS (MSDOS 5.0), 1991 
  6678                                  
  6679 00000B9C 880E[5203]              	MOV	[YEAR],CL
  6680                                  CHKYR:
  6681 00000BA0 F6C103                  	TEST	CL,3		;Check for leap year
  6682 00000BA3 B01C                    	MOV	AL,28
  6683 00000BA5 7502                    	JNZ	SHORT SAVFEB	;28 days if no leap year
  6684 00000BA7 FEC0                    	INC	AL		;Add leap day
  6685                                  SAVFEB:
  6686 00000BA9 A2[1D0D]                	mov	[february],al
  6687                                  	;MOV	[MONTAB+1],AL	;Store for February
  6688                                  RET23:  
  6689 00000BAC C3                      	RETN
  6690                                  
  6691                                  ;----------------------------------------------------------
  6692                                  
  6693                                  DODATE:
  6694 00000BAD E8F0FF                  	CALL	CHKYR		;Set Feb. up for new year
  6695 00000BB0 88F0                    	MOV	AL,DH
  6696                                  
  6697 00000BB2 BB[1B0D]                	MOV	BX,MONTAB-1	;DOSDATA:0D1Bh for MSDOS 6.21
  6698                                  
  6699 00000BB5 D7                      	XLAT			;Look up days in month
  6700 00000BB6 38D0                    	CMP	AL,DL
  6701 00000BB8 B0FF                    	MOV	AL,-1		;Restore error flag, just in case
  6702                                  	;JB	SHORT RET25	;Error if too many days
  6703 00000BBA 72F0                    	jb	short RET23 ; 18/07/2018
  6704 00000BBC E8D8FF                  	CALL	SETYEAR
  6705                                  ;
  6706                                  ; WARNING! DAY and MONTH must be adjacently allocated
  6707                                  ;
  6708 00000BBF 8916[5003]              	MOV	[DAY],DX	;Set both day and month
  6709 00000BC3 D1E9                    	SHR	CX,1
  6710 00000BC5 D1E9                    	SHR	CX,1
  6711                                  	;mov	ax,1461
  6712 00000BC7 B8B505                  	MOV	AX,FOURYEARS
  6713 00000BCA 89D3                    	MOV	BX,DX
  6714 00000BCC F7E1                    	MUL	CX
  6715 00000BCE 8A0E[5203]              	MOV	CL,[YEAR]
  6716 00000BD2 80E103                  	AND	CL,3
  6717                                  
  6718 00000BD5 BE[140D]                	MOV	SI,YRTAB
  6719                                  
  6720 00000BD8 89C2                    	MOV	DX,AX
  6721 00000BDA D1E1                    	SHL	CX,1		;Two entries per year, so double count
  6722 00000BDC E85100                  	CALL	DSUM		;Add up the days in each year
  6723 00000BDF 88F9                    	MOV	CL,BH		;Month of year
  6724                                  
  6725 00000BE1 BE[1C0D]                	MOV	SI,MONTAB
  6726                                  
  6727 00000BE4 49                      	DEC	CX		;Account for months starting with one
  6728 00000BE5 E84800                  	CALL	DSUM		;Add up days in each month
  6729 00000BE8 88D9                    	MOV	CL,BL		;Day of month
  6730 00000BEA 49                      	DEC	CX		;Account for days starting with one
  6731 00000BEB 01CA                    	ADD	DX,CX		;Add in to day total
  6732 00000BED 92                      	XCHG	AX,DX		;Get day count in AX
  6733 00000BEE A3[5403]                	MOV	[DAYCNT],AX
  6734 00000BF1 56                      	PUSH	SI
  6735 00000BF2 53                      	PUSH	BX
  6736 00000BF3 50                      	PUSH	AX
  6737                                  
  6738 00000BF4 BB[B603]                	MOV	BX,TIMEBUF
  6739                                  
  6740 00000BF7 B90600                  	MOV	CX,6
  6741                                  	;XOR	DX,DX
  6742                                  	;MOV	AX,DX
  6743                                  	; 06/01/2024
  6744 00000BFA 31C0                    	xor	ax,ax
  6745 00000BFC 99                      	cwd
  6746 00000BFD 53                      	PUSH	BX
  6747 00000BFE E8ED3A                  	CALL	SETREAD
  6748                                  
  6749 00000C01 1E                      	PUSH	DS
  6750 00000C02 C536[2E00]              	LDS	SI,[BCLOCK]
  6751 00000C06 E86F3A                  	CALL	DEVIOCALL2	;Get correct date and time
  6752 00000C09 1F                      	POP	DS
  6753 00000C0A 5B                      	POP	BX
  6754 00000C0B E8133B                  	CALL	SETWRITE
  6755 00000C0E 8F06[B603]              	POP	WORD [TIMEBUF]
  6756 00000C12 1E                      	PUSH	DS
  6757 00000C13 C536[2E00]              	LDS	SI,[BCLOCK]
  6758 00000C17 E85E3A                  	CALL	DEVIOCALL2	;Set the date
  6759 00000C1A 1F                      	POP	DS
  6760 00000C1B 5B                      	POP	BX
  6761 00000C1C 5E                      	POP	SI
  6762                                  WKDAY:
  6763 00000C1D A1[5403]                	MOV	AX,[DAYCNT]
  6764 00000C20 31D2                    	XOR	DX,DX
  6765 00000C22 B90700                  	MOV	CX,7
  6766 00000C25 40                      	INC	AX
  6767 00000C26 40                      	INC	AX		;First day was Tuesday
  6768 00000C27 F7F1                    	DIV	CX		;Compute day of week
  6769 00000C29 8816[5603]              	MOV	[WEEKDAY],DL
  6770 00000C2D 30C0                    	XOR	AL,AL		;Flag OK
  6771                                  RET25:
  6772 00000C2F C3                      	RETN
  6773                                  
  6774                                  ;----------------------------------------------------------
  6775                                  
  6776                                  ;**	DSUM - Compute the sum of a string of bytes
  6777                                  ;
  6778                                  ;	ENTRY	(cx) = byte count
  6779                                  ;		(ds:si) = byte address
  6780                                  ;		(dx) = sum register, initialized by caller
  6781                                  ;	EXIT	(dx) updated
  6782                                  ;	USES	ax, cx, dx, si, flags
  6783                                  
  6784                                  DSUM:
  6785 00000C30 B400                    	MOV	AH,0
  6786 00000C32 E305                    	JCXZ	DSUM9 ; 13/05/2019 - Retro DOS v4.0
  6787                                  	;JCXZ	RET25 ; 18/07/2018
  6788                                  DSUM1:
  6789 00000C34 AC                      	LODSB
  6790 00000C35 01C2                    	ADD	DX,AX
  6791 00000C37 E2FB                    	LOOP	DSUM1
  6792                                  DSUM9:
  6793 00000C39 C3                      	RETN
  6794                                  
  6795                                  ;============================================================================
  6796                                  ; GETSET.ASM (MSDOS 6.0, 1991)
  6797                                  ;============================================================================
  6798                                  ; 29/04/2019 - Retro DOS v4.0
  6799                                  ; 18/07/2018 - Retro DOS v3.0 (GETSET.ASM, MSDOS 6.0, 1991)
  6800                                  
  6801                                  ; 12/03/2018 - Retro DOS v2.0 
  6802                                  
  6803                                  ;TITLE	GETSET - GETting and SETting MS-DOS system calls
  6804                                  ;NAME	GETSET
  6805                                  
  6806                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
  6807                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
  6808                                  
  6809                                  ;USERNUM:
  6810                                  ;	DW	0			; 24 bit user number
  6811                                  ;       DB      0
  6812                                  ;;	IF      IBM
  6813                                  ;;OEMNUM: DB    0			; 8 bit OEM number
  6814                                  ;;	ELSE
  6815                                  ;OEMNUM: DB     0FFH			; 8 bit OEM number
  6816                                  ;;	ENDIF
  6817                                  
  6818                                  ;MSVERS:		; MS-DOS version in hex for $GET_VERSION
  6819                                  ;; 08/07/2018 - Retro DOS v3.0
  6820                                  ;MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  6821                                  ;MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  6822                                  
  6823                                  ;BREAK <$Get_Version -- Return MSDOS version number>
  6824                                  ;----------------------------------------------------------------------------
  6825                                  
  6826                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6827                                  ; DOSCODE:4A0Fh (MSDOS 5.0 MSDOS.SYS)
  6828                                  
  6829                                  _$GET_VERSION:
  6830                                  
  6831                                  ; Inputs:
  6832                                  ;       None
  6833                                  ; Function:
  6834                                  ;       Return MS-DOS version number
  6835                                  ; Outputs:
  6836                                  ;       OEM number in BH
  6837                                  ;       User number in BL:CX (24 bits)
  6838                                  ;       Version number as AL.AH in binary
  6839                                  ;       NOTE: On pre 1.28 DOSs AL will be zero
  6840                                  
  6841                                  ; MSDOS 6.0
  6842                                  ;
  6843                                  ;	Fake_Count is used to lie about the version numbers to support
  6844                                  ;	old binarys. See ms_table.asm for more info.
  6845                                  ;
  6846                                  ;		if input al = 00
  6847                                  ;		  (bh) = OEM number			
  6848                                  ;		else if input al = 01
  6849                                  ;		  (bh) = version flags
  6850                                  ;		 
  6851                                  ;		       	 bits 0-2 = DOS internal revision
  6852                                  ;		       	 bits 3-7 = DOS type flags
  6853                                  ;		              bit 3    = DOS is in ROM
  6854                                  ;		              bit 4    = DOS in in HMA
  6855                                  ;		              bits 5-7 = reserved
  6856                                  ;               M007 change - only bit 3 is now valid. Other bits
  6857                                  ;               are 0 when AL = 1
  6858                                  
  6859                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  6860 00000C3A 36C50E[B203]            	lds	cx, [ss:USERNUM]
  6861 00000C3F 8CDB                    	mov	bx, ds
  6862                                  
  6863                                  	; MSDOS 3.3 (IBMDOS.COM, offset 196Dh)
  6864                                  	;--------------------------------------
  6865                                  	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:4A1Ch)
  6866                                  
  6867 00000C41 16                              PUSH    SS
  6868 00000C42 1F                              POP     DS
  6869                                          
  6870                                  	; 06/01/2024
  6871                                  	;MOV	BX,[USERNUM+2]
  6872                                          ;MOV	CX,[USERNUM]
  6873                                  
  6874                                  	; 13/05/2019 - Retro DOS v4.0
  6875                                  
  6876                                  	;If AL == 1, ROMDOS will return BH = dos internal version # &
  6877                                  	;DOS flags
  6878                                  
  6879 00000C43 3C01                    	cmp	AL,1
  6880 00000C45 7502                    	jne	short Norm_Vers
  6881                                  
  6882                                  ;ifdef ROMDOS
  6883                                  ;	mov	BH,DOSINROM 	; Just set the bit for ROM version
  6884                                  ;				(DOSINROM = 8)
  6885                                  ;else
  6886 00000C47 30FF                            xor     bh,bh		; Otherwise return 0
  6887                                  ;endif				;M007 end
  6888                                  
  6889                                  Norm_Vers:
  6890                                  	;MOV	AX,[MSVERS]  ; MSDOS 3.3
  6891                                  
  6892                                          	; MSDOS 6.0	; MSVERS is a label in TABLE segment	
  6893                                  	; 13/05/2019 - Retro DOS v4.0
  6894 00000C49 1E                      	push	ds		; Get the version number from the
  6895 00000C4A 8E1E[3003]              	mov	ds,[CurrentPDB]	; current app's PSP segment
  6896                                  	;mov	ax,[40h]
  6897 00000C4E A14000                  	mov	ax,[PDB.Version] ; AX = DOS version number	
  6898                                  	; 07/12/2022
  6899 00000C51 1F                      	pop	ds
  6900 00000C52 E82CF8                  	call	Get_User_Stack
  6901                                  				; Put values for return registers
  6902                                  				; in the proper place on the user's	 
  6903                                  				; stack addressed by DS:SI
  6904                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  6905                                  gdrvfspc_ret:
  6906                                          ;MOV	[SI+user_env.user_AX],AX
  6907 00000C55 8904                            MOV	[SI],AX
  6908                                          ;MOV	[SI+4],CX
  6909 00000C57 894C04                  	mov	[SI+user_env.user_CX],CX
  6910                                  set_user_bx:
  6911                                  	;MOV	[SI+2],BX
  6912 00000C5A 895C02                  	mov	[SI+user_env.user_BX],BX
  6913                                  
  6914 00000C5D C3                      	RETN
  6915                                  
  6916                                  ; 18/07/2018 - Retro DOS v3.0
  6917                                  
  6918                                  ;BREAK <$Get/Set_Verify_on_Write - return/set verify-after-write flag>
  6919                                  ;----------------------------------------------------------------------------
  6920                                  
  6921                                  ;**	$Get_Verify_On_Write - Get Status of Verify on write flag
  6922                                  ;
  6923                                  ;	ENTRY	none
  6924                                  ;	EXIT	(al) = value of VERIFY flag
  6925                                  ;	USES	all
  6926                                  
  6927                                  
  6928                                  _$GET_VERIFY_ON_WRITE:
  6929                                  
  6930                                  ;hkn; SS override
  6931 00000C5E 36A0[FF02]              	MOV	AL,[SS:VERFLG]	; Retro DOS v2.0 - 12/03/2018
  6932 00000C62 C3                      	retn
  6933                                  
  6934                                  ;**	$Set_Verify_On_Write - Set Status of Verify on write flag
  6935                                  ;
  6936                                  ;	ENTRY	(al) = value of VERIFY flag
  6937                                  ;	EXIT	none
  6938                                  ;	USES	all
  6939                                  
  6940                                  _$SET_VERIFY_ON_WRITE:
  6941                                  
  6942 00000C63 2401                    	AND	AL,1
  6943                                  ;hkn; SS override
  6944 00000C65 36A2[FF02]              	MOV	[SS:VERFLG],AL	; Retro DOS v2.0 - 12/03/2018
  6945                                  RET27:	; 18/07/2018
  6946 00000C69 C3                      	retn
  6947                                  
  6948                                  ; 19/07/2018 - Retro DOS v3.0
  6949                                  
  6950                                  ;BREAK <$International - return country-dependent information>
  6951                                  ;----------------------------------------------------------------------------
  6952                                  ;
  6953                                  ; Procedure Name : $INTERNATIONAL
  6954                                  ;
  6955                                  ; Inputs:
  6956                                  ;	MOV	AH,International
  6957                                  ;	MOV	AL,country	(al = 0 => current country)
  6958                                  ;      [MOV	BX,country]
  6959                                  ;	LDS	DX,block
  6960                                  ;	INT	21
  6961                                  ; Function:
  6962                                  ;	give users an idea of what country the application is running
  6963                                  ; Outputs:
  6964                                  ;	IF DX != -1 on input (get country)
  6965                                  ;	  AL = 0 means return current country table.
  6966                                  ;	  0<AL<0FFH means return country table for country AL
  6967                                  ;	  AL = 0FF means return country table for country BX
  6968                                  ;	  No Carry:
  6969                                  ;	     Register BX will contain the 16-bit country code.
  6970                                  ;	     Register AL will contain the low 8 bits of the country code.
  6971                                  ;	     The block pointed to by DS:DX is filled in with the information
  6972                                  ;	     for the particular country.
  6973                                  ;		BYTE  Size of this table excluding this byte and the next
  6974                                  ;		BYTE  Country code represented by this table
  6975                                  ;			A sequence of n bytes, where n is the number specified
  6976                                  ;			by the first byte above and is not > internat_block_max,
  6977                                  ;			in the correct order for being returned by the
  6978                                  ;			INTERNATIONAL call as follows:
  6979                                  ;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
  6980                                  ;		5 BYTE	Currency symbol null terminated
  6981                                  ;		2 BYTE	thousands separator null terminated
  6982                                  ;		2 BYTE	Decimal point null terminated
  6983                                  ;		2 BYTE	Date separator null terminated
  6984                                  ;		2 BYTE	Time separator null terminated
  6985                                  ;		1 BYTE	Bit field.  Currency format.
  6986                                  ;			Bit 0.	=0 $ before #  =1 $ after #
  6987                                  ;			Bit 1.	no. of spaces between # and $ (0 or 1)
  6988                                  ;		1 BYTE	No. of significant decimal digits in currency
  6989                                  ;		1 BYTE	Bit field.  Time format.
  6990                                  ;			Bit 0.	=0 12 hour clock  =1 24 hour
  6991                                  ;		DWORD	Call address of case conversion routine
  6992                                  ;		2 BYTE	Data list separator null terminated.
  6993                                  ;	  Carry:
  6994                                  ;	     Register AX has the error code.
  6995                                  ;	IF DX = -1 on input (set current country)
  6996                                  ;	  AL = 0 is an error
  6997                                  ;	  0<AL<0FFH means set current country to country AL
  6998                                  ;	  AL = 0FF means set current country to country BX
  6999                                  ;	  No Carry:
  7000                                  ;	    Current country SET
  7001                                  ;	    Register AL will contain the low 8 bits of the country code.
  7002                                  ;	  Carry:
  7003                                  ;	     Register AX has the error code.
  7004                                  ;-----------------------------------------------------------------------------
  7005                                  
  7006                                  ;procedure   $INTERNATIONAL,NEAR   ; DOS 3.3
  7007                                  
  7008                                  ; 13/05/2019 - Retro DOS v4.0
  7009                                  ; DOSCODE:4A4Dh (MSDOS 6.21, MSDOS.SYS)
  7010                                  
  7011                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7012                                  ; DOSCODE:4A40h (MSDOS 5.0, MSDOS.SYS)
  7013                                  
  7014                                  _$INTERNATIONAL:  ; IBMDOS.COM (MSDOS 3.3), offset 1992h
  7015                                  	 
  7016 00000C6A 3CFF                    	CMP	AL,0FFH
  7017 00000C6C 7404                    	JZ	short BX_HAS_CODE	; -1 means country code is in BX
  7018 00000C6E 88C3                    	MOV	BL,AL			; Put AL country code in BX
  7019 00000C70 30FF                    	XOR	BH,BH
  7020                                  BX_HAS_CODE:
  7021 00000C72 1E                      	PUSH	DS
  7022 00000C73 07                      	POP	ES
  7023 00000C74 52                      	PUSH	DX
  7024 00000C75 5F                      	POP	DI			; User buffer to ES:DI
  7025                                  
  7026                                  ;hkn; SS is DOSDATA
  7027                                  ;	context DS
  7028                                  
  7029 00000C76 16                      	push	ss
  7030 00000C77 1F                      	pop	ds
  7031                                  
  7032 00000C78 83FFFF                  	CMP	DI,-1
  7033 00000C7B 745D                    	JZ	short international_set
  7034 00000C7D 09DB                    	OR	BX,BX
  7035 00000C7F 7505                    	JNZ	short international_find
  7036                                  
  7037                                  ;hkn; country_cdpg is in DOSDATA segment.
  7038 00000C81 BE[0012]                	MOV	SI,COUNTRY_CDPG
  7039                                  
  7040 00000C84 EB39                    	JMP	SHORT international_copy
  7041                                  
  7042                                  international_find:
  7043                                  	;MOV	BP,0			 ; flag it for GetCntry only
  7044                                  	; 06/01/2024
  7045 00000C86 31ED                    	xor	bp,bp ; 0
  7046 00000C88 E80A00                  	CALL	international_get
  7047 00000C8B 7255                    	JC	short errtn
  7048                                  	;CMP	BX,0			 ; nlsfunc finished it ?
  7049                                  	; 06/01/2024
  7050 00000C8D 09DB                    	or	bx,bx
  7051 00000C8F 752E                    	JNZ	SHORT international_copy ; no, copy by myself
  7052 00000C91 89D3                    	MOV	BX,DX			 ; put country back
  7053 00000C93 EB3A                    	JMP	SHORT international_ok3
  7054                                  
  7055                                  international_get:
  7056 00000C95 BE[0012]                	MOV	SI,COUNTRY_CDPG
  7057                                  
  7058                                  ;hkn; country_cdpg is in DOSDATA segment.
  7059                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  7060                                  
  7061                                  	; MSDOS 3.3
  7062                                  	;;cmp	bx,[SI+63h]
  7063                                  	;CMP	BX,[SI+DOS_CCDPG.ccDosCountry]
  7064                                  	;jz	short RET27
  7065                                  
  7066                                  	; 13/05/2019 - Retro DOS v4.0
  7067                                  
  7068                                  	; MSDOS 6.0
  7069                                  	;cmp	bx,[ss:si+68h]
  7070 00000C98 363B5C68                	CMP	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
  7071 00000C9C 74CB                    	jz	short RET27			; return if equal
  7072                                  
  7073 00000C9E 89DA                    	MOV	DX,BX
  7074 00000CA0 31DB                    	XOR	BX,BX			; bx = 0, default code page
  7075                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7076 00000CA2 B80014                  	mov	ax,1400h
  7077 00000CA5 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7078                                  			; Return: AL = 00h not installed, OK to install
  7079                                  			; 01h not installed, not OK
  7080                                  			; FFh installed
  7081 00000CA7 3CFF                    	CMP	AL,0FFH
  7082 00000CA9 7510                    	JNZ	short interr		; not in memory
  7083                                  	
  7084                                  	; 06/01/2024
  7085 00000CAB B80314                  	mov	ax,1403h		; set country info
  7086                                  
  7087                                  	;cmp	bp,0
  7088 00000CAE 09ED                    	or	bp,bp			; GetCntry ?
  7089 00000CB0 7501                    	JNZ	short stcdpg
  7090                                  	
  7091                                  	;CallInstall GetCntry,NLSFUNC,4	; get country info
  7092                                  	;mov	ax,1404h
  7093 00000CB2 40                      	inc	ax	; AX = 1404h ; get country info
  7094                                  
  7095                                  	; 06/01/2024
  7096                                  	;int	2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  7097                                  	;		; BX = code page, DX = country code,
  7098                                  	;		; DS:SI -> internal code page structure
  7099                                  	;		; ES:DI -> user buffer
  7100                                  	;		; Return: AL = status
  7101                                  	;
  7102                                  	;JMP	short chkok
  7103                                  	
  7104                                  	;nop
  7105                                  
  7106                                  stcdpg:
  7107                                  	;CallInstall SetCodePage,NLSFUNC,3  ; set country info
  7108                                  	; 06/01/2024
  7109                                  	;mov     ax,1403h
  7110                                  gscdpg:
  7111 00000CB3 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - SET COUNTRY INFO
  7112                                  			; DS:SI -> internal code page structure
  7113                                  			; BX = code page, DX = country code
  7114                                  			; Return: AL = status
  7115                                  chkok:
  7116 00000CB5 08C0                    	or	al,al			; success ?
  7117                                  	;retz				; yes
  7118 00000CB7 74B0                    	jz	short RET27
  7119                                  
  7120                                  setcarry:
  7121 00000CB9 F9                      	STC				; set carry
  7122 00000CBA C3                      	retn
  7123                                  interr:
  7124 00000CBB B0FF                    	MOV	AL,0FFH			; flag nlsfunc error
  7125 00000CBD EBFA                    	JMP	short setcarry
  7126                                  
  7127                                  international_copy:
  7128                                  
  7129                                  ;hkn; country_cdpg is in DOSDATA segment.
  7130                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  7131                                  
  7132                                  	; MSDOS 3.3
  7133                                  	;;mov	bx,[SI+63h]
  7134                                  	;mov	BX,[SI+DOS_CCDPG.ccDosCountry]
  7135                                  	;mov	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; 08/09/2018
  7136                                  
  7137                                  	; 13/05/2019 - Retro DOS v4.0
  7138                                  
  7139                                  	; MSDOS 6.0
  7140                                  	;mov	bx,[ss:si+68h]
  7141 00000CBF 368B5C68                	MOV	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
  7142 00000CC3 BE[6C12]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; COUNTRY_CDPG + 108
  7143                                  
  7144                                  	;mov	cx,24
  7145 00000CC6 B91800                  	MOV	CX,OLD_COUNTRY_SIZE
  7146                                  
  7147                                  	; MSDOS 6.0
  7148                                  
  7149                                  ;hkn;	must set up DS to SS so that international info can be copied
  7150                                  	
  7151 00000CC9 1E                      	push	ds
  7152                                  
  7153 00000CCA 16                      	push	ss			; cs -> ss
  7154 00000CCB 1F                      	pop	ds
  7155                                  
  7156 00000CCC F3A4                    	REP	MOVSB			; copy country info
  7157                                  
  7158                                  	; MSDOS 6.0
  7159                                  
  7160 00000CCE 1F                      	pop	ds	;hkn;	restore ds
  7161                                  
  7162                                  international_ok3:
  7163 00000CCF E8AFF7                  	call	Get_User_Stack
  7164                                  ;ASSUME	DS:NOTHING
  7165                                  	;MOV	[SI+2],BX
  7166 00000CD2 895C02                  	MOV	[SI+user_env.user_BX],BX
  7167                                  international_ok:
  7168 00000CD5 89D8                    	MOV	AX,BX			; Return country code in AX too.
  7169                                  ;SYS_RET_OK_jmp:
  7170                                  	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7171                                  nono:	; 15/12/2022
  7172                                  SYS_RET_OK_jmp:
  7173 00000CD7 E95DF9                  	jmp	SYS_RET_OK
  7174                                  
  7175                                  international_set:
  7176                                  
  7177                                  ;hkn; ASSUME	DS:DOSGROUP
  7178                                  ;ASSUME	DS:DOSDATA
  7179                                  
  7180 00000CDA BD0100                  	MOV	BP,1			; flag it for SetCodePage only
  7181 00000CDD E8B5FF                  	CALL	international_get
  7182 00000CE0 73F3                    	JNC	short international_ok
  7183                                  errtn:
  7184 00000CE2 3CFF                    	CMP	AL,0FFH
  7185 00000CE4 7403                    	JZ	short errtn2
  7186                                  errtn1:
  7187 00000CE6 E957F9                  	jmp	SYS_RET_ERR		; return what we got from NLSFUNC
  7188                                  errtn2:
  7189                                  	;error	error_invalid_function	; NLSFUNC not existent
  7190                                  
  7191                                  	;mov	al,1
  7192 00000CE9 B001                    	mov	al,error_invalid_function 
  7193 00000CEB EBF9                    	jmp	short errtn1 ; 13/05/2019 - Retro DOS v4.0
  7194                                  ;errtn3:
  7195                                  ;	jmp	SYS_RET_ERR
  7196                                  
  7197                                  ;EndProc $INTERNATIONAL
  7198                                  
  7199                                  ; 19/07/2018
  7200                                  
  7201                                  ;BREAK <$GetExtCntry - return extended country-dependent information>
  7202                                  
  7203                                  ;----------------------------------------------------------------------------
  7204                                  ;
  7205                                  ; Procedure Name : $GetExtCntry
  7206                                  ;
  7207                                  ; Inputs:
  7208                                  ;	if AL >= 20H
  7209                                  ;	  AL= 20H    capitalize single char, DL= char
  7210                                  ;	      21H    capitalize string, CX= string length
  7211                                  ;	      22H    capitalize ASCIIZ string
  7212                                  ;	      23H    YES/NO check, DL=1st char DH= 2nd char (DBCS)
  7213                                  ;	      80H bit 0 = use normal upper case table
  7214                                  ;		      1 = use file upper case table
  7215                                  ;	   DS:DX points to string
  7216                                  ;
  7217                                  ;	else
  7218                                  ;
  7219                                  ;	MOV	AH,GetExtCntry	 ; DOS 3.3
  7220                                  ;	MOV	AL,INFO_ID	( info type,-1 selects all )
  7221                                  ;	MOV	BX,CODE_PAGE	( -1 = active code page )
  7222                                  ;	MOV	DX,COUNTRY_ID	( -1 = active country )
  7223                                  ;	MOV	CX,SIZE 	( amount of data to return )
  7224                                  ;	LES	DI,COUNTRY_INFO ( buffer for returned data )
  7225                                  ;	INT	21
  7226                                  ; Function:
  7227                                  ;	give users extended country dependent information
  7228                                  ;	or capitalize chars
  7229                                  ; Outputs:
  7230                                  ;	  No Carry:
  7231                                  ;	     extended country info is succesfully returned
  7232                                  ;	  Carry:
  7233                                  ;	     Register AX has the error code.
  7234                                  ;	     AX=0, NO	 for YES/NO CHECK
  7235                                  ;		1, YES
  7236                                  ;----------------------------------------------------------------------------
  7237                                  
  7238                                  ;procedure   $GetExtCntry,NEAR	; DOS 3.3
  7239                                  
  7240                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7241                                  
  7242                                  	; MSDOS 6.0
  7243                                  _$GetExtCntry:
  7244 00000CED 3C20                    	CMP	AL,CAP_ONE_CHAR 	; < 20H ?
  7245 00000CEF 7269                    	JB	short notcap
  7246                                  capcap: 				;
  7247 00000CF1 A880                    	TEST	AL,UPPER_TABLE	; 80h	; which upper case table
  7248 00000CF3 7505                    	JNZ	short fileupper		; file upper case
  7249                                  
  7250                                  ;hkn; UCASE_TAB in DOSDATA
  7251 00000CF5 BB[AF0A]                	MOV	BX,UCASE_TAB+2		; get normal upper case
  7252 00000CF8 EB05                    	JMP	SHORT capit
  7253                                  
  7254                                  fileupper:
  7255                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM - DOSCODE:4C57h)
  7256                                  	; ((Note: This must be a bugfix, because bit 7 of AX is 1 here!))
  7257                                  	; AL >= 80h
  7258 00000CFA 247F                    	and	al,7Fh 
  7259                                  
  7260                                  ;hkn; FILE_UCASE_TAB in DOSDATA
  7261 00000CFC BB[310B]                	MOV	BX,FILE_UCASE_TAB+2 ; get file upper case
  7262                                  capit:					;
  7263 00000CFF 3C20                    	CMP	AL,CAP_ONE_CHAR 	; cap one char ?
  7264 00000D01 750D                    	JNZ	short chkyes		; no
  7265 00000D03 88D0                    	MOV	AL,DL			; set up AL
  7266 00000D05 E86A43                  	call	GETLET3 		; upper case it
  7267 00000D08 E876F7                  	call	Get_User_Stack		; get user stack
  7268                                  	;mov	[si+6],al
  7269 00000D0B 884406                  	MOV	[SI+user_env.user_DX],AL ; user's DL=AL
  7270 00000D0E EBC7                    	JMP	SHORT nono		; done
  7271                                  chkyes: 				;
  7272 00000D10 3C23                    	CMP	AL,CHECK_YES_NO	; 23h	; check YES or NO ?
  7273 00000D12 7522                    	JNZ	short capstring		; no
  7274                                  
  7275 00000D14 31C0                    	XOR	AX,AX			; presume NO
  7276                                  		      
  7277                                  ;hkn; NLS_YES, NLS_NO, NLS_yes2, NLS_no2 is defined in msdos.cl3 which is
  7278                                  ;hkn; included in yesno.asm in the DOSCODE segment.
  7279                                  
  7280                                  	; 06/08/2018 - Retro DOS v3.0
  7281                                  	; 13/05/2019 - Retro DOS v4.0
  7282                                  	;cmp	dl,'Y'
  7283 00000D16 2E3A16[150A]            	CMP	DL,[cs:NLS_YES]		; is 'Y' ?
  7284 00000D1B 7416                    	JZ	short yesyes		; yes
  7285                                  	;cmp	dl,'y'
  7286 00000D1D 2E3A16[170A]            	CMP	DL,[cs:NLS_yes2]	; is 'y' ?
  7287 00000D22 740F                    	JZ	short yesyes		; yes
  7288                                  	;cmp	dl,'N'
  7289 00000D24 2E3A16[160A]            	CMP	DL,[cs:NLS_NO]		; is  'N'?
  7290 00000D29 74AC                    	JZ	short nono		; no
  7291                                  	;cmp	dl,'n'
  7292 00000D2B 2E3A16[180A]            	CMP	DL,[cs:NLS_no2]		; is 'n' ?
  7293 00000D30 74A5                    	JZ	short nono		; no
  7294                                  ;dbcs_char:				;
  7295 00000D32 40                      	INC	AX			; not YES or NO
  7296                                  yesyes: 				;
  7297 00000D33 40                      	INC	AX			; return 1
  7298                                  	; 15/12/2022
  7299                                  ;nono:	
  7300 00000D34 EBA1                    	jmp	short SYS_RET_OK_jmp	;
  7301                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7302                                  	;jmp	SYS_RET_OK		; done
  7303                                  
  7304                                  capstring:				;
  7305 00000D36 89D6                    	MOV	SI,DX			; si=dx
  7306 00000D38 3C21                    	CMP	AL,CAP_STRING	; 21h	; cap string ?
  7307 00000D3A 750D                    	JNZ	short capascii		; no
  7308                                  	;OR	CX,CX			; check count 0
  7309                                  	;JZ	short nono		; yes finished
  7310                                  	; 06/01/2024
  7311 00000D3C E399                    	jcxz	nono
  7312                                  concap: 				;
  7313 00000D3E AC                      	LODSB				; get char
  7314 00000D3F E83043                  	call	GETLET3 		; upper case it
  7315 00000D42 8844FF                  	MOV	byte [SI-1],AL		; store back
  7316                                  ;next99: 				;
  7317 00000D45 E2F7                    	LOOP	concap			; continue
  7318 00000D47 EB8E                    	JMP	short nono		; done
  7319                                  capascii:				;
  7320 00000D49 3C22                    	CMP	AL,CAP_ASCIIZ	; 22h	; cap ASCIIZ string ?
  7321 00000D4B 7545                    	JNZ	short capinval		; no
  7322                                  concap2:				;
  7323 00000D4D AC                      	LODSB				; get char
  7324 00000D4E 08C0                    	or	al,al			; end of string ?
  7325 00000D50 7485                    	JZ	short nono		; yes
  7326 00000D52 E81D43                  	call	GETLET3 		; upper case it
  7327 00000D55 8844FF                  	MOV	[SI-1],AL		; store back
  7328 00000D58 EBF3                    	JMP	short concap2 		; continue
  7329                                  
  7330                                  	; MSDOS 3.3 (& MSDOS 6.0)
  7331                                  
  7332                                  ; Offset 1A19h in IBMDOS.COM (MSDOS 3.3), 1987 	
  7333                                  ; _$GetExtCntry:
  7334                                  
  7335                                  notcap:
  7336 00000D5A 83F905                  	CMP	CX,5			; minimum size is 5
  7337 00000D5D 7277                    	jb	short sizeerror
  7338                                  
  7339                                  GEC_CONT:
  7340                                  ;hkn; SS is DOSDATA
  7341                                  	;context DS
  7342                                  
  7343 00000D5F 16                      	push	ss
  7344                                  	;pop	es  ; ! (Retro DOS v3.0 BUG) !
  7345 00000D60 1F                      	pop	ds  ; 13/05/2019 - Retro DOS v4.0	
  7346                                  	
  7347                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  7348 00000D61 BE[0012]                	MOV	SI,COUNTRY_CDPG
  7349                                  
  7350 00000D64 83FAFF                  	CMP	DX,-1			; active country ?
  7351 00000D67 7503                    	JNZ	short GETCDPG 		; no
  7352                                  
  7353                                  ;hkn; use DS override to accesss country_cdpg fields
  7354                                  	;;mov	dx,[si+63h] ; MSDOS 3.3
  7355                                  	;mov	dx,[si+68h] ; MSDOS 6.0
  7356 00000D69 8B5468                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]
  7357                                  					; get active country id;smr;use DS
  7358                                  GETCDPG:
  7359 00000D6C 83FBFF                  	CMP	BX,-1			; active code page?
  7360 00000D6F 7503                    	JNZ	short CHKAGAIN		; no, check again
  7361                                  
  7362                                  ;hkn; use DS override to accesss country_cdpg fields
  7363                                  	;;mov	bx,[si+65h] ; MSDOS 3.3	
  7364                                  	;mov	bx,[si+6Ah] ; MSDOS 6.0
  7365 00000D71 8B5C6A                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  7366                                  					; get active code page id;smr;Use DS
  7367                                  CHKAGAIN:
  7368                                  	;cmp	dx,[si+68h] ; MSDOS 6.0
  7369 00000D74 3B5468                  	CMP	DX,[SI+DOS_CCDPG.ccDosCountry]
  7370                                  					; same as active country id?;smr;use DS
  7371 00000D77 7550                    	JNZ	short CHKNLS		; no
  7372                                  	;cmp	bx,[si+6Ah] ; MSDOS 6.0	
  7373 00000D79 3B5C6A                  	CMP	BX,[SI+DOS_CCDPG.ccDosCodePage]	
  7374                                  					; same as active code pg id?;smr;use DS
  7375 00000D7C 754B                    	JNZ	short CHKNLS		; no
  7376                                  CHKTYPE:
  7377                                  	;mov	bx,[si+48h]
  7378 00000D7E 8B5C48                  	MOV	BX,[SI+DOS_CCDPG.ccSysCodePage]	
  7379                                  					; bx = sys code page id;smr;use DS
  7380 00000D81 51                      	PUSH	CX			; save cx
  7381                                  	;mov	cx,[si+4Ah]
  7382 00000D82 8B4C4A                  	MOV	CX,[SI+DOS_CCDPG.ccNumber_of_entries]  ;smr;use DS
  7383                                  	;mov	si,COUNTRY_CDPG+76
  7384 00000D85 BE[4C12]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccSetUcase   ;smr;CDPG in DOSDATA
  7385                                  NXTENTRY:
  7386 00000D88 3A04                    	CMP	AL,[SI] 		; compare info type;smr;use DS
  7387 00000D8A 740B                    	JZ	short FOUNDIT
  7388 00000D8C 83C605                  	ADD	SI,5			; next entry
  7389 00000D8F E2F7                    	LOOP	NXTENTRY
  7390 00000D91 59                      	POP	CX
  7391                                  capinval:
  7392                                  	;error	error_invalid_function	; info type not found
  7393                                  	;mov	al,1
  7394 00000D92 B001                    	mov	al,error_invalid_function
  7395                                  ;SYS_RET_ERR_jmp:
  7396                                  	;jmp	SYS_RET_ERR
  7397                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7398                                  SYS_RET_ERR_jmp:
  7399 00000D94 E9A9F8                  	jmp	SYS_RET_ERR	
  7400                                  
  7401                                  FOUNDIT:
  7402 00000D97 A4                      	MOVSB				; move info id byte
  7403 00000D98 59                      	POP	CX			; restore char count
  7404                                  	;cmp	al,1
  7405 00000D99 3C01                    	CMP	AL,SetCountryInfo	; select country info type ?
  7406 00000D9B 7415                    	JZ	short setsize
  7407 00000D9D B90400                  	MOV	CX,4			; 4 bytes will be moved
  7408 00000DA0 B80500                  	MOV	AX,5			; 5 bytes will be returned in CX
  7409                                  OK_RETN:
  7410 00000DA3 F3A4                    	REP	MOVSB			; copy info
  7411 00000DA5 89C1                    	MOV	CX,AX			; CX = actual length returned
  7412 00000DA7 89D8                    	MOV	AX,BX			; return sys code page in ax
  7413                                  GETDONE:
  7414 00000DA9 E8D5F6                  	call	Get_User_Stack		; return actual length to user's CX
  7415                                  	;mov	[si+4],cx 
  7416 00000DAC 894C04                  	MOV	[SI+user_env.user_CX],CX
  7417                                  	;jmp	SYS_RET_OK
  7418                                  	; 15/12/2022
  7419                                  	; 25/06/2019
  7420 00000DAF E988F8                  	jmp	SYS_RET_OK_clc
  7421                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7422                                  	; 15/12/2022
  7423                                  ;nono_jmp:
  7424                                  	;jmp	short nono
  7425                                  setsize:
  7426 00000DB2 83E903                  	SUB	CX,3			; size after length field
  7427 00000DB5 390C                    	CMP	[SI],CX			; less than table size ;smr;use ds
  7428 00000DB7 7302                    	JAE	short setsize2		; no
  7429 00000DB9 8B0C                    	MOV	CX,[SI]			; truncate to table size ;smr;use ds
  7430                                  setsize2:
  7431 00000DBB 26890D                  	MOV	[ES:DI],CX		; copy actual length to user's
  7432                                  	;ADD	DI,2			; update index
  7433                                  	;ADD	SI,2
  7434                                  	; 06/01/2024
  7435 00000DBE 47                      	inc	di
  7436 00000DBF 47                      	inc	di
  7437 00000DC0 46                      	inc	si
  7438 00000DC1 46                      	inc	si
  7439 00000DC2 89C8                    	MOV	AX,CX
  7440 00000DC4 83C003                  	ADD	AX,3			; AX has the actual length
  7441 00000DC7 EBDA                    	JMP	short OK_RETN 		; go move it
  7442                                  CHKNLS:
  7443 00000DC9 30E4                    	XOR	AH,AH
  7444                                  	;PUSH	AX			; save info type
  7445                                  	;POP	BP			; bp = info type
  7446                                  	; 06/01/2024
  7447 00000DCB 89C5                    	mov	bp,ax
  7448                                  	
  7449                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7450 00000DCD B80014                  	mov     ax,1400h
  7451 00000DD0 CD2F                    	int     2Fh     ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7452                                  			; Return: AL = 00h not installed, OK to install
  7453                                  			; 01h not installed, not OK
  7454                                  			; FFh installed
  7455 00000DD2 3CFF                    	CMP	AL,0FFH
  7456 00000DD4 7404                    	JZ	short NLSNXT		; in memory
  7457                                  
  7458                                  sizeerror:
  7459                                  	;error	error_invalid_function
  7460                                  	;mov	al,1
  7461 00000DD6 B001                    	mov	al,error_invalid_function
  7462                                  	;jmp	SYS_RET_ERR
  7463                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7464                                  sys_ret_err_jmp2:
  7465 00000DD8 EBBA                    	jmp	short SYS_RET_ERR_jmp
  7466                                  
  7467                                  NLSNXT: 
  7468                                  	;CallInstall GetExtInfo,NLSFUNC,2 ;get extended info
  7469 00000DDA B80214                  	mov     ax,1402h
  7470 00000DDD CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  7471                                  			; BP = subfunction, BX = code page
  7472                                  			; DX = country code, DS:SI -> internal code page structure
  7473                                  			; ES:DI -> user buffer, CX = size of user buffer
  7474                                  			; Return: AL = status
  7475                                  			; 00h successful
  7476                                  			; else DOS error code
  7477                                  
  7478 00000DDF 3C00                    	CMP	AL,0			; success ?
  7479 00000DE1 7505                    	JNZ	short NLSERROR
  7480                                  	;mov	ax,[si+48h] ; 13/05/2019
  7481 00000DE3 8B4448                  	MOV	AX,[SI+DOS_CCDPG.ccSysCodePage]
  7482                                  			; ax = sys code page id;smr;use ds;
  7483                                  			;BUGBUG;check whether DS is OK after the above calls
  7484 00000DE6 EBC1                    	JMP	short GETDONE
  7485                                  seterr:
  7486                                  	; 15/12/2022
  7487                                  NLSERROR:
  7488                                  	;jmp	SYS_RET_ERR		; return what is got from NLSFUNC
  7489                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7490                                  	;jmp	short sys_ret_err_jmp2
  7491                                  	; 15/12/2022
  7492 00000DE8 EBAA                    	jmp	short SYS_RET_ERR_jmp
  7493                                  
  7494                                  ;EndProc $GetExtCntry
  7495                                  
  7496                                  ; 13/05/2019 - Retro DOS v4.0
  7497                                  ; DOSCODE:4BD6h (MSDOS 6.21, MSDOS.SYS)
  7498                                  
  7499                                  ;BREAK <$GetSetCdPg - get or set global code page>
  7500                                  ;----------------------------------------------------------------------------
  7501                                  ;**	$GetSetCdPg - Get or Set Global Code Page
  7502                                  ;
  7503                                  ;   System call format:
  7504                                  ;
  7505                                  ;	MOV	AH,GetSetCdPg	; DOS 3.3
  7506                                  ;	MOV	AL,n		; n = 1 : get code page, n = 2 : set code page
  7507                                  ;	MOV	BX,CODE_PAGE	(set code page only)
  7508                                  ;	INT	21
  7509                                  ;
  7510                                  ;	ENTRY	(al) = n
  7511                                  ;		(bx) = code page
  7512                                  ;	EXIT	'C' clear
  7513                                  ;		  global code page is set	(set global code page)
  7514                                  ;		  (BX) = active code page id	(get global code page)
  7515                                  ;		  (DX) = system code page id	(get global code page)
  7516                                  ;		'C' set
  7517                                  ;		  (AX) = error code
  7518                                  
  7519                                  ;procedure  $GetSetCdPg,NEAR   ; DOS 3.3
  7520                                  
  7521                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7522                                  	; DOSCODE:4BC9h
  7523                                  
  7524                                  _$GetSetCdPg:
  7525                                  
  7526                                  ;hkn; SS is DOSDATA
  7527                                  	;context DS
  7528                                  
  7529 00000DEA 16                      	push	ss
  7530 00000DEB 1F                      	pop	ds
  7531                                  
  7532                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  7533 00000DEC BE[0012]                	MOV	SI,COUNTRY_CDPG	  ; (DOSDATA:122Ah for MSDOS 6.21)
  7534                                  
  7535 00000DEF 3C01                    	CMP	AL,1		       ; get global code page
  7536 00000DF1 7512                    	JNZ	short setglpg 	       ; set global code page
  7537                                  	
  7538                                  	;;mov	bx,[si+65h] ; MSDOS 3.3
  7539                                  	;mov	bx,[si+6Ah] ; MSDOS 6.0
  7540 00000DF3 8B5C6A                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  7541                                  					; get active code page id;smr;use ds
  7542                                  	;mov	dx,[si+48h]
  7543 00000DF6 8B5448                  	MOV	DX,[SI+DOS_CCDPG.ccSysCodePage]
  7544                                  				  	; get sys code page id;smr;use ds
  7545 00000DF9 E885F6                  	call	Get_User_Stack
  7546                                  ;ASSUME DS:NOTHING
  7547                                  	;;mov	[si+2],bx
  7548                                  	;MOV	[SI+user_env.user_BX],BX ; update returned bx
  7549                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7550 00000DFC E85BFE                  	call    set_user_bx	; MOV [SI+user_env.user_BX],BX 
  7551                                  	;mov	[si+6],dx
  7552 00000DFF 895406                  	MOV	[SI+user_env.user_DX],DX ; update returned dx
  7553                                  OK_RETURN:
  7554                                  	; 15/12/2022
  7555                                  	;transfer SYS_RET_OK
  7556 00000E02 E932F8                  	jmp	SYS_RET_OK
  7557                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7558                                  	;jmp	short nono_jmp
  7559                                  
  7560                                  ;hkn; ASSUME DS:DOSGROUP
  7561                                  ;ASSUME	DS:DOSDATA
  7562                                  
  7563                                  setglpg:
  7564 00000E05 3C02                    	CMP	AL,2
  7565 00000E07 752F                    	JNZ	short nomem
  7566                                  	
  7567                                  	;;mov	dx,[si+63h] ; MSDOS 3.3
  7568                                  	;mov	dx,[si+68h] ; MSDOS 6.0
  7569 00000E09 8B5468                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]	;smr;use ds
  7570                                  	
  7571                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7572 00000E0C B80014                  	mov     ax,1400h
  7573 00000E0F CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7574                                  			; Return: AL = 00h not installed, OK to install
  7575                                  			; 01h not installed, not OK
  7576                                  			; FFh installed
  7577 00000E11 3CFF                    	CMP	AL,0FFH
  7578 00000E13 7523                    	JNZ	short nomem		; not in memory
  7579                                  
  7580                                  	;CallInstall SetCodePage,NLSFUNC,1 ;set the code page
  7581 00000E15 B80114                  	mov     ax,1401h
  7582 00000E18 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - CHANGE CODE PAGE
  7583                                  			; DS:SI -> internal code page structure
  7584                                  			; BX = new code page, DX = country code???
  7585                                  			; Return: AL = status
  7586                                  			; 00h successful
  7587                                  			; else DOS error code
  7588                                  	;cmp	al,0
  7589 00000E1A 08C0                    	or	al,al			; success ?
  7590 00000E1C 74E4                    	JZ	short OK_RETURN		; yes
  7591                                  
  7592 00000E1E 3C41                    	CMP	AL,65			; set device code page failed
  7593 00000E20 75C6                    	JNZ	short seterr
  7594                                  	;MOV	AX,65
  7595                                  	; 06/01/2024
  7596 00000E22 98                      	cbw
  7597 00000E23 A3[2403]                	MOV	[EXTERR],AX
  7598                                  	;mov	byte [EXTERR_ACTION],6
  7599                                  	;mov	byte [EXTERR_CLASS],5
  7600                                  	;mov	byte [EXTERR_LOCUS],4
  7601 00000E26 C606[2603]06            	MOV	byte [EXTERR_ACTION],errACT_Ignore
  7602 00000E2B C606[2703]05            	MOV	byte [EXTERR_CLASS],errCLASS_HrdFail
  7603 00000E30 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
  7604                                  	;transfer From_GetSet
  7605 00000E35 E910F8                  	jmp	From_GetSet
  7606                                  
  7607                                  	; 15/12/2022
  7608                                  ;seterr:
  7609                                  	;;;transfer SYS_RET_ERR
  7610                                  	;;jmp	SYS_RET_ERR
  7611                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7612                                  	;jmp	short NLSERROR
  7613                                  
  7614                                  nomem:
  7615                                  	;error	error_invalid_function	; function not defined
  7616                                  	;mov	al,1
  7617 00000E38 B001                    	mov	al,error_invalid_function
  7618 00000E3A EBAC                    	jmp	short seterr
  7619                                  
  7620                                  ;EndProc $GetSetCdPg
  7621                                  
  7622                                  ; 09/01/2024
  7623                                  ; 13/05/2019 - Retro DOS v4.0
  7624                                  ; DOSCODE:4C2Bh (MSDOS 6.21, MSDOS.SYS)
  7625                                  
  7626                                  ;BREAK <$Get_Drive_Freespace -- Return bytes of free disk space on a drive>
  7627                                  ;----------------------------------------------------------------------------
  7628                                  ;**	$Get_Drive_Freespace - Return amount of drive free space
  7629                                  ;
  7630                                  ;	$Get_Drive_Freespace returns the # of free allocation units on a
  7631                                  ;		drive.
  7632                                  ;
  7633                                  ;	This call returns the same info in the same registers (except for the
  7634                                  ;	FAT pointer) as the old FAT pointer calls
  7635                                  ;
  7636                                  ;	ENTRY	DL = Drive number
  7637                                  ;	EXIT	AX = Sectors per allocation unit
  7638                                  ;		   = -1 if bad drive specified
  7639                                  ;		On User Stack
  7640                                  ;		    BX = Number of free allocation units
  7641                                  ;		    DX = Total Number of allocation units on disk
  7642                                  ;		    CX = Sector size
  7643                                  
  7644                                  ;procedure   $GET_DRIVE_FREESPACE,NEAR
  7645                                  
  7646                                  _$GET_DRIVE_FREESPACE:
  7647                                  
  7648                                  ;hkn; SS is DOSDATA
  7649                                  	;context DS
  7650 00000E3C 16                      	push	ss
  7651 00000E3D 1F                      	pop	ds
  7652                                  
  7653 00000E3E 88D0                    	MOV	AL,DL
  7654                                  	;invoke	GetThisDrv		; Get drive
  7655 00000E40 E85B5C                  	call	GETTHISDRV
  7656                                  SET_AX_RET:
  7657 00000E43 7212                    	JC	short BADFDRV
  7658                                  	;invoke	DISK_INFO
  7659 00000E45 E8A21E                  	call	DISK_INFO
  7660 00000E48 87D3                    	XCHG	DX,BX
  7661                                  	;JC	short SET_AX_RET	; User FAILed to I 24
  7662                                  	; 06/01/2024
  7663 00000E4A 720B                    	jc	short BADFDRV
  7664 00000E4C 30E4                    	XOR	AH,AH			; Chuck Fat ID byte
  7665                                  DoSt:
  7666 00000E4E E830F6                  	call	Get_User_Stack
  7667                                  ;ASSUME	DS:NOTHING
  7668                                  	;mov	[si+6],dx
  7669                                  	;;mov	[si+4],cx
  7670                                  	;;mov	[si+2],bx
  7671                                  	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7672 00000E51 895406                  	MOV	[SI+user_env.user_DX],DX ; total clusters
  7673                                  	;MOV	[SI+user_env.user_CX],CX
  7674                                  	;MOV	[SI+user_env.user_BX],BX
  7675                                  	;;MOV	[SI+user_env.user_AX],AX
  7676                                  	;mov	[si],ax
  7677                                  	;;return
  7678                                  	;retn
  7679                                  	; 09/01/2024
  7680 00000E54 E9FEFD                  	jmp     gdrvfspc_ret    ; ax = sectors per cluster (modified)
  7681                                  
  7682                                  BADFDRV:
  7683                                  	; MSDOS 3.3
  7684                                  	;;mov	al,0Fh
  7685                                  	;mov	al,error_invalid_drive	; Assume error
  7686                                  
  7687                                  	; 13/05/2019 - Retro DOS v4.0
  7688                                  
  7689                                  	; MSDOS 6.0 & MSDOS 3.3
  7690                                  	;invoke	FCB_RET_ERR
  7691 00000E57 E8FCF7                  	call	FCB_RET_ERR
  7692                                  	
  7693 00000E5A B8FFFF                  	MOV	AX,-1
  7694 00000E5D EBEF                    	JMP	short DoSt
  7695                                  
  7696                                  ;EndProc $GET_DRIVE_FREESPACE
  7697                                  
  7698                                  ;	BREAK <$Get_DMA, $Set_DMA -- Get/Set current DMA address>
  7699                                  ;----------------------------------------------------------------------------
  7700                                  ;**	$Get_DMA - Get Disk Transfer Address
  7701                                  ;
  7702                                  ;	ENTRY	none
  7703                                  ;	EXIT	ES:BX is current transfer address
  7704                                  ;	USES	all
  7705                                  
  7706                                  	; 09/01/2024
  7707                                  _$GET_DMA:
  7708 00000E5F 368B1E[2C03]            	MOV	BX,[SS:DMAADD]
  7709 00000E64 368B0E[2E03]            	MOV	CX,[SS:DMAADD+2]
  7710 00000E69 E815F6                  	call	Get_User_Stack
  7711                                  	;mov	[si+2],bx
  7712                                  	;mov	[si+10h],cx
  7713                                  	; 09/01/2024
  7714                                  	;MOV	[SI+user_env.user_BX],BX
  7715 00000E6C 894C10                  	MOV	[SI+user_env.user_ES],CX
  7716                                  	;retn
  7717                                  	; 09/01/2024
  7718 00000E6F E9E8FD                  	jmp	set_user_bx ; (PCDOS 7.1 IBMDOS.COM)
  7719                                  
  7720                                  ;**	$Set_DMA - Set Disk Transfer Address
  7721                                  ;----------------------------------------------------------------------------
  7722                                  ;	ENTRY	DS:DX is current transfer address
  7723                                  ;	EXIT	none
  7724                                  ;	USES	all
  7725                                  
  7726                                  _$SET_DMA:
  7727 00000E72 368916[2C03]            	MOV	[SS:DMAADD],DX
  7728 00000E77 368C1E[2E03]            	MOV	[SS:DMAADD+2],DS
  7729 00000E7C C3                      	retn
  7730                                  
  7731                                  ;	BREAK <$Get_Default_Drive, $Set_Default_Drive -- Set/Get default drive>
  7732                                  ;------------------------------------------------------------------------------
  7733                                  
  7734                                  ;**	$Get_Default_Drive - Get Current Default Drive
  7735                                  ;-----------------------------------------------------
  7736                                  ;	ENTRY	none
  7737                                  ;	EXIT	(AL) = drive number
  7738                                  ;	USES	all
  7739                                  
  7740                                  _$GET_DEFAULT_DRIVE:
  7741 00000E7D 36A0[3603]              	MOV	AL,[SS:CURDRV]
  7742 00000E81 C3                      	retn
  7743                                  
  7744                                  ;**	$Set_Default_Drive - Specify new Default Drive
  7745                                  ;-----------------------------------------------------
  7746                                  ;	ENTRY	(DL) = Drive number for new default drive
  7747                                  ;	EXIT	(AL) = Number of drives, NO ERROR RETURN IF DRIVE NUMBER BAD
  7748                                  
  7749                                  _$SET_DEFAULT_DRIVE:
  7750 00000E82 88D0                    	MOV	AL,DL
  7751 00000E84 FEC0                    	INC	AL			; A=1, B=2...
  7752 00000E86 E8F95B                  	call	GetVisDrv		; see if visible drive
  7753 00000E89 7204                    	JC	short SETRET		; errors do not set
  7754 00000E8B 36A2[3603]              	MOV	[SS:CURDRV],AL		; no, set
  7755                                  
  7756                                  SETRET:
  7757 00000E8F 36A0[4700]              	MOV	AL,[SS:CDSCOUNT]	; let user see what the count really is
  7758 00000E93 C3                      	retn
  7759                                  
  7760                                  ;BREAK <$Get/Set_Interrupt_Vector - Get/Set interrupt vectors>
  7761                                  ;----------------------------------------------------------------------------
  7762                                  
  7763                                  ;**	$Get_Interrupt_Vector - Get Interrupt Vector
  7764                                  ;---------------------------------------------------
  7765                                  ;	$Get_Interrupt_Vector is the official way for user pgms to get the
  7766                                  ;	contents of an interrupt vector.
  7767                                  ;
  7768                                  ;	ENTRY	(AL) = interrupt number
  7769                                  ;	EXIT	(ES:BX) = current interrupt vector
  7770                                  
  7771                                  _$GET_INTERRUPT_VECTOR:
  7772 00000E94 E82E00                  	CALL	RECSET
  7773 00000E97 26C41F                  	LES	BX,[ES:BX]
  7774 00000E9A E8E4F5                  	call	Get_User_Stack
  7775                                  set_user_es_bx:
  7776                                  	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7777                                  	;;mov	[si+2],bx
  7778                                  	;mov	[si+10h],es
  7779                                  	;MOV	[SI+user_env.user_BX],BX
  7780 00000E9D 8C4410                  	MOV	[SI+user_env.user_ES],ES
  7781                                  	;retn
  7782 00000EA0 E9B7FD                  	jmp	set_user_bx
  7783                                  
  7784                                  ;**	$Set_Interrupt_Vector - Set Interrupt Vector
  7785                                  ;---------------------------------------------------
  7786                                  ;	$Set_Interrupt_Vector is the official way for user pgms to set the
  7787                                  ;	contents of an interrupt vector.
  7788                                  ;
  7789                                  ;	M004, M068: Also set A20OFF_COUNT to 1 if EXECA20OFF bit has been set 
  7790                                  ;	and if A20OFF_COUNT is non-zero. See under tag M003 in inc\dossym.inc 
  7791                                  ;	for explanation.
  7792                                  ;
  7793                                  ;	ENTRY	(AL) = interrupt number
  7794                                  ;		(ds:dx) = desired new vector value
  7795                                  ;	EXIT	none
  7796                                  ;	USES	all
  7797                                  
  7798                                  ; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7799                                  ; 13/05/2019 - Retro DOS v4.0
  7800                                  
  7801                                  _$SET_INTERRUPT_VECTOR:
  7802 00000EA3 E81F00                  	CALL	RECSET
  7803 00000EA6 FA                      	CLI				; Watch out!!!!! Folks sometimes use
  7804 00000EA7 268917                  	MOV	[ES:BX],DX		;   this for hardware ints (like timer).
  7805 00000EAA 268C5F02                	MOV	[ES:BX+2],DS
  7806 00000EAE FB                      	STI
  7807                                  					; M004, M068 - Start
  7808                                  	; MSDOS 6.0
  7809 00000EAF 36F606[8600]04          	test	byte [ss:DOS_FLAG],EXECA20OFF ; 4
  7810                                  					; Q: was the previous call an int 21h
  7811                                  					;    exec call
  7812                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7813                                  	;jnz	short siv_1		; Y: go set count
  7814                                  	;retn				; N: return
  7815                                  	; 15/12/2022
  7816 00000EB5 740D                    	jz	short siv_2
  7817                                  siv_1:	
  7818 00000EB7 36803E[8500]00          	cmp	byte [ss:A20OFF_COUNT],0 ; Q: is count 0
  7819 00000EBD 7505                    	jnz	short siv_2		 ; N: done
  7820                                  	; 20/09/2023
  7821 00000EBF 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]
  7822                                  	;mov	byte [ss:A20OFF_COUNT],1 ; Y: set it to 1 to indicate to dos
  7823                                  					 ; dispatcher to turn A20 Off before
  7824                                  					 ; returning to user.
  7825                                  siv_2:
  7826                                  	; 07/12/2022
  7827 00000EC4 C3                      	retn				; M004, M068 - End
  7828                                  	
  7829                                  RECSET:
  7830 00000EC5 31DB                    	XOR	BX,BX
  7831 00000EC7 8EC3                    	MOV	ES,BX
  7832 00000EC9 88C3                    	MOV	BL,AL
  7833 00000ECB D1E3                    	SHL	BX,1
  7834 00000ECD D1E3                    	SHL	BX,1
  7835 00000ECF C3                      	retn
  7836                                  
  7837                                  ;	BREAK <$Char_Oper - hack on paths, switches so that xenix can look like PCDOS>
  7838                                  ;-------------------------------------------------------------------------------------
  7839                                  
  7840                                  ;**	$Char_Oper - Manipulate Switch Character
  7841                                  ;
  7842                                  ;	This function was put in to facilitate XENIX path/switch compatibility
  7843                                  ;
  7844                                  ;	ENTRY	AL = function:
  7845                                  ;		    0 - read switch char
  7846                                  ;		    1 - set switch char (char in DL)
  7847                                  ;		    2 - read device availability
  7848                                  ;			Always returns available
  7849                                  ;		    3 - set device availability
  7850                                  ;			No longer supported (NOP)
  7851                                  ;	EXIT	(al) = 0xff iff error
  7852                                  ;		(al) != 0xff if ok
  7853                                  ;		  (dl) = character/flag, if "read switch char" subfunction
  7854                                  ;	USES	AL, DL
  7855                                  ;
  7856                                  ;	NOTE	This already obsolete function has been deactivated in DOS 5.0
  7857                                  ;		The character / is always returned for subfunction 0,
  7858                                  ;		subfunction 2 always returns -1, all other subfunctions are ignored.
  7859                                  
  7860                                  ; 13/05/2019 - Retro DOS v4.0
  7861                                  ; DOSCODE:4CC9h (MSDOS 6.21, MSDOS.SYS)
  7862                                  
  7863                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7864                                  ; DOSCODE:4CBCh (MSDOS 5.0, MSDOS.SYS)
  7865                                  
  7866                                  _$CHAR_OPER:
  7867                                  	; MSDOS 6.0
  7868 00000ED0 08C0                    	or	al,al				; get switch?
  7869 00000ED2 B22F                    	mov	dl,'/'				; assume yes
  7870 00000ED4 7407                    	jz	short chop_1			; jump if yes
  7871 00000ED6 3C02                    	cmp	al,2				; check device availability?
  7872 00000ED8 B2FF                    	mov	dl,-1				; assume yes
  7873 00000EDA 7401                    	jz	short chop_1			; jump if yes
  7874 00000EDC C3                      	retn					; otherwise just quit
  7875                                  
  7876                                  ; subfunctions requiring return of value to user come here. DL holds
  7877                                  ; value to return
  7878                                  
  7879                                  chop_1:
  7880 00000EDD E8A1F5                  	call	Get_User_Stack
  7881 00000EE0 895406                  	mov	[SI+user_env.user_DX],dx	; store value for user
  7882 00000EE3 C3                      	retn
  7883                                  
  7884                                  	; MSDOS 3.3
  7885                                  	; Offset 1B87h in IBMDOS.COM (MSDOS 3.3), 1987
  7886                                  	;push	ss
  7887                                  	;pop	ds
  7888                                  	;cmp	al,1
  7889                                  	;jb	short chop_1
  7890                                  	;jz	short chop_2
  7891                                  	;cmp	al,3
  7892                                  	;jb	short chop_3
  7893                                  	;jz	short chop_5
  7894                                  	;mov	al,0FFh
  7895                                  	;retn
  7896                                  ;chop_1:
  7897                                  	;mov	dl,[chSwitch]
  7898                                  	;jmp	short chop_4
  7899                                  ;chop_2:
  7900                                  	;mov	[chSwitch],dl
  7901                                  	;retn
  7902                                  ;chop_3:
  7903                                  	;mov	dl, FFh
  7904                                  ;chop_4:
  7905                                  	;call	Get_User_Stack
  7906                                  	;mov	[si+6],dx
  7907                                  ;chop_5:
  7908                                  	;retn
  7909                                  
  7910                                  ;**	$GetExtendedError - Return Extended error code
  7911                                  ;----------------------------------------------------------------------------
  7912                                  ;	This function reads up the extended error info from the static
  7913                                  ;	variables where it was stored.
  7914                                  ;
  7915                                  ;	ENTRY	none
  7916                                  ;	EXIT	AX = Extended error code (0 means no extended error)
  7917                                  ;		BL = recommended action
  7918                                  ;		BH = class of error
  7919                                  ;		CH = locus of error
  7920                                  ;		ES:DI = may be pointer
  7921                                  ;	USES	ALL
  7922                                  
  7923                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7924                                  
  7925                                  _$GetExtendedError:
  7926 00000EE4 16                      	push	ss
  7927 00000EE5 1F                      	pop	ds
  7928 00000EE6 A1[2403]                	MOV	AX,[EXTERR]
  7929 00000EE9 C43E[2803]              	LES	DI,[EXTERRPT]
  7930 00000EED 8B1E[2603]              	MOV	BX,[EXTERR_ACTION]	; BL = Action, BH = Class
  7931 00000EF1 8A2E[2303]              	MOV	CH,[EXTERR_LOCUS]
  7932 00000EF5 E889F5                  	call	Get_User_Stack
  7933                                  	;mov	[si+0Ah],di
  7934 00000EF8 897C0A                  	MOV	[SI+user_env.user_DI],DI
  7935                                  
  7936                                  	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7937                                  	;;mov	[si+10h],es
  7938                                  	;MOV	[SI+user_env.user_ES],ES
  7939                                  	;;mov	[si+2],bx
  7940                                  	;MOV	[SI+user_env.user_BX],BX
  7941 00000EFB E89FFF                  	call	set_user_es_bx
  7942                                  
  7943                                  	;mov	[si+4],cx
  7944 00000EFE 894C04                  	MOV	[SI+user_env.user_CX],CX
  7945                                  jmp_SYS_RET_OK:
  7946                                  	; 15/12/2022
  7947                                  	;jmp	SYS_RET_OK
  7948                                  	; 25/06/2019
  7949 00000F01 E936F7                  	jmp	SYS_RET_OK_clc ; 15/12/2022
  7950                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7951                                  ;jmp_SYS_RET_OK:
  7952                                  	;jmp	SYS_RET_OK
  7953                                  
  7954                                  ; --------------------------------------------------------------------------
  7955                                  ; 09/01/2024
  7956                                  %if 0
  7957                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7958                                  	; DOSCODE:4CF3h
  7959                                  ;patch_or_unknown:
  7960                                  ;get_code_page:
  7961                                  	push    si
  7962                                  	mov     si, COUNTRY_CDPG
  7963                                  	;mov	ax, [si+DOS_CCDPG.ccDosCodePage]
  7964                                  	mov     ax, [ss:si+6Ah]
  7965                                  	pop     si
  7966                                  	retn
  7967                                  %endif
  7968                                  ; --------------------------------------------------------------------------
  7969                                  
  7970                                  ; 29/04/2019 - Retro DOS v4.0
  7971                                  
  7972                                  ;BREAK	<ECS_call - Extended Code System support function>
  7973                                  ;---------------------------------------------------------------------------
  7974                                  ; Inputs:
  7975                                  ;	AL = 0	get lead byte table
  7976                                  ;		on return DS:SI has the table location
  7977                                  ;
  7978                                  ;	AL = 1	set / reset interim console flag
  7979                                  ;		DL = flag (00H or 01H)
  7980                                  ;		no return
  7981                                  ;
  7982                                  ;	AL = 2	get interim console flag
  7983                                  ;		on return DL = current flag value
  7984                                  ;
  7985                                  ;	AL = OTHER then error, and returns with:
  7986                                  ;		AX = error_invalid_function
  7987                                  ;
  7988                                  ;  NOTE: THIS CALL DOES GUARANTEE THAT REGISTER OTHER THAN
  7989                                  ;	 SS:SP WILL BE PRESERVED!
  7990                                  ;---------------------------------------------------------------------------
  7991                                  
  7992                                  _$ECS_Call:
  7993 00000F04 08C0                    	or	al,al			; AL = 0 (get table)?
  7994                                  	;jnz	short _okok
  7995                                  	; 15/12/2022
  7996 00000F06 7403                    	jz	short get_lbt
  7997                                  ;_okok:
  7998 00000F08 E92CF7                  	jmp	SYS_RET_OK
  7999                                  get_lbt:
  8000 00000F0B E873F5                  	call	Get_User_Stack		; *
  8001                                  
  8002                                  ;hkn; dbcs_table moved low to dosdata
  8003                                  	;mov	word [si+8],DBCS_TAB+2
  8004 00000F0E C74408[E50C]            	mov	word [si+user_env.user_SI],DBCS_TAB+2
  8005                                  
  8006 00000F13 06                      	push	es
  8007                                  	;getdseg <es>			; es = DOSDATA
  8008 00000F14 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  8009                                  	;mov	[si+14],es
  8010 00000F19 8C440E                  	mov	[SI+user_env.user_DS],es
  8011 00000F1C 07                      	pop	es
  8012                                  
  8013                                  	; 15/12/2022
  8014 00000F1D EBE2                    	jmp	short jmp_SYS_RET_OK ; jmp SYS_RET_OK_clc ; *
  8015                                  ;_okok:
  8016                                  	; 15/12/2022	
  8017                                  	;;transfer SYS_RET_OK
  8018                                  	;jmp	short jmp_SYS_RET_OK
  8019                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8020                                  	;;jmp	SYS_RET_OK
  8021                                  	;jmp	short jmp_SYS_RET_OK
  8022                                  
  8023                                  ;============================================================================
  8024                                  ; PARSE.ASM, MSDOS 6.0, 1991
  8025                                  ;============================================================================
  8026                                  ; 19/07/2018 - Retro DOS v3.0
  8027                                  ; 15/05/2019 - Retro DOS v4.0
  8028                                  
  8029                                  ; System calls for parsing command lines
  8030                                  ;
  8031                                  ;   $PARSE_FILE_DESCRIPTOR
  8032                                  ;
  8033                                  ;   Modification history:
  8034                                  ;
  8035                                  ;       Created: ARR 30 March 1983
  8036                                  ;               EE PathParse 10 Sept 1983
  8037                                  ;
  8038                                  
  8039                                  ;BREAK <$Parse_File_Descriptor -- Parse an arbitrary string into an FCB>
  8040                                  ;---------------------------------------------------------------------------
  8041                                  ; Inputs:
  8042                                  ;       DS:SI Points to a command line
  8043                                  ;       ES:DI Points to an empty FCB
  8044                                  ;       Bit 0 of AL = 1 At most one leading separator scanned off
  8045                                  ;                   = 0 Parse stops if separator encountered
  8046                                  ;       Bit 1 of AL = 1 If drive field blank in command line - leave FCB
  8047                                  ;                   = 0  "    "    "     "         "      "  - put 0 in FCB
  8048                                  ;       Bit 2 of AL = 1 If filename field blank - leave FCB
  8049                                  ;                   = 0  "       "      "       - put blanks in FCB
  8050                                  ;       Bit 3 of AL = 1 If extension field blank - leave FCB
  8051                                  ;                   = 0  "       "      "        - put blanks in FCB
  8052                                  ; Function:
  8053                                  ;       Parse command line into FCB
  8054                                  ; Returns:
  8055                                  ;       AL = 1 if '*' or '?' in filename or extension, 0 otherwise
  8056                                  ;       DS:SI points to first character after filename
  8057                                  ;---------------------------------------------------------------------------
  8058                                  
  8059                                  _$PARSE_FILE_DESCRIPTOR:
  8060 00000F1F E8F23F                  	call	MAKEFCB
  8061 00000F22 56                      	PUSH    SI
  8062 00000F23 E85BF5                  	call	Get_User_Stack
  8063                                  	;pop	word [si+8]
  8064 00000F26 8F4408                  	POP     word [SI+user_env.user_SI]
  8065 00000F29 C3                      	retn
  8066                                  
  8067                                  ;============================================================================
  8068                                  ; MISC.ASM, MSDOS 6.0, 1991
  8069                                  ;============================================================================
  8070                                  ; 19/07/2018 - Retro DOS v3.0
  8071                                  
  8072                                  ; 29/04/2019 - Retro DOS v4.0
  8073                                  
  8074                                  ;ENTRYPOINTSEG	EQU	0CH
  8075                                  ;MAXDIF		EQU	0FFFH
  8076                                  ;SAVEXIT 	EQU	10
  8077                                  ;WRAPOFFSET	EQU	0FEF0h
  8078                                  
  8079                                  ;
  8080                                  ;----------------------------------------------------------------------------
  8081                                  ;
  8082                                  ;**	$SLEAZEFUNC - Get a Pointer to the Media Byte
  8083                                  ;
  8084                                  ;	Return Stuff sort of like old get fat call
  8085                                  ;
  8086                                  ;	ENTRY	none
  8087                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  8088                                  ;			GOD help anyone who tries to do ANYTHING except
  8089                                  ;			READ this ONE byte.
  8090                                  ;		DX = Total Number of allocation units on disk
  8091                                  ;		CX = Sector size
  8092                                  ;		AL = Sectors per allocation unit
  8093                                  ;		   = -1 if bad drive specified
  8094                                  ;	USES	all
  8095                                  ;
  8096                                  ;**	$SLEAZEFUNCDL - Get a Pointer to the Media Byte
  8097                                  ;
  8098                                  ;	Identical to $SLEAZEFUNC except (dl) = drive
  8099                                  ;
  8100                                  ;	ENTRY	(dl) = drive (0=default, 1=A, 2=B, etc.)
  8101                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  8102                                  ;			GOD help anyone who tries to do ANYTHING except
  8103                                  ;			READ this ONE byte.
  8104                                  ;		DX = Total Number of allocation units on disk
  8105                                  ;		CX = Sector size
  8106                                  ;		AL = Sectors per allocation unit
  8107                                  ;		   = -1 if bad drive specified
  8108                                  ;	USES	all
  8109                                  ;
  8110                                  ;----------------------------------------------------------------------------
  8111                                  ;
  8112                                  
  8113                                  _$SLEAZEFUNC:
  8114                                  	; 10/01/2024
  8115                                  	; 15/05/2019 - Retro DOS v4.0
  8116 00000F2A B200                    	MOV	DL,0
  8117                                  _$SLEAZEFUNCDL:
  8118 00000F2C 16                      	push	ss
  8119 00000F2D 1F                      	pop	ds
  8120                                  	
  8121 00000F2E 88D0                    	MOV	AL,DL
  8122 00000F30 E86B5B                  	call	GETTHISDRV		; Get CDS structure
  8123                                  SET_AL_RET:
  8124                                  	; MSDOS 3.3
  8125                                  	;;mov	al, 0Fh
  8126                                  	;MOV	AL,error_invalid_drive	; Assume error	;AC000;
  8127                                  	
  8128                                  	; MSDOS 6.0 & MSDOS 3.3
  8129 00000F33 721D                    	JC	short BADSLDRIVE
  8130                                  
  8131 00000F35 E8B21D                  	call	DISK_INFO
  8132                                  	;JC	short SET_AL_RET	; User FAILed to I 24
  8133 00000F38 7218                    	jc	short BADSLDRIVE
  8134 00000F3A 8826[9805]              	MOV	[FATBYTE],AH
  8135                                  
  8136                                  ; NOTE THAT A FIXED MEMORY CELL IS USED --> THIS CALL IS NOT
  8137                                  ; RE-ENTRANT. USERS BETTER GET THE ID BYTE BEFORE THEY MAKE THE
  8138                                  ; CALL AGAIN
  8139                                  
  8140                                  	; 10/01/2024
  8141                                  	;MOV	DI,FATBYTE
  8142 00000F3E 30E4                    	XOR	AH,AH			; AL has sectors/cluster
  8143 00000F40 E83EF5                  	call	Get_User_Stack
  8144                                  	;mov	[si+4],cx
  8145                                  	;mov	[si+6],bx
  8146                                  	;mov	[si+2],di
  8147 00000F43 894C04                  	MOV	[SI+user_env.user_CX],CX
  8148 00000F46 895C06                  	MOV	[SI+user_env.user_DX],BX
  8149                                  	;MOV	[SI+user_env.user_BX],DI
  8150                                  	; 10/01/2024
  8151 00000F49 C74402[9805]            	MOV	word [SI+user_env.user_BX],FATBYTE
  8152                                  	
  8153                                  	;mov	[si+0Eh],ss
  8154 00000F4E 8C540E                  	MOV     [SI+user_env.user_DS],SS ; stash correct pointer
  8155                                  
  8156 00000F51 C3                      	retn
  8157                                  
  8158                                  BADSLDRIVE:
  8159 00000F52 E901F7                  	jmp	FCB_RET_ERR
  8160                                  
  8161                                  ;
  8162                                  ;----------------------------------------------------------------------------
  8163                                  ;
  8164                                  ;**	$Get_INDOS_Flag - Return location of DOS Critical Section Flag
  8165                                  ;
  8166                                  ;	Returns location of DOS status for interrupt routines
  8167                                  ;
  8168                                  ;	ENTRY	none
  8169                                  ;	EXIT	(es:bx) = flag location
  8170                                  ;	USES	all
  8171                                  ;
  8172                                  ;----------------------------------------------------------------------------
  8173                                  ;
  8174                                  
  8175                                  _$GET_INDOS_FLAG:
  8176 00000F55 E829F5                          CALL	Get_User_Stack
  8177                                          ;MOV	WORD [SI+2],INDOS
  8178 00000F58 C74402[2103]            	MOV     word [SI+user_env.user_BX],INDOS
  8179                                  getin_segm:	; 13/01/2024
  8180                                  	;MOV	[SI+10H],SS
  8181 00000F5D 8C5410                  	MOV	[SI+user_env.user_ES],SS
  8182 00000F60 C3                      	RETN 
  8183                                  ;
  8184                                  ;----------------------------------------------------------------------------
  8185                                  ;
  8186                                  ;**	$Get_IN_Vars - Return Pointer to DOS Variables
  8187                                  ;
  8188                                  ;	Return a pointer to interesting DOS variables This call is version
  8189                                  ;	dependent and is subject to change without notice in future versions.
  8190                                  ;	Use at risk.
  8191                                  ;
  8192                                  ;	ENTRY	none
  8193                                  ;	EXIT	(es:bx) = address of SYSINITVAR
  8194                                  ;	uses	ALL
  8195                                  ;
  8196                                  ;----------------------------------------------------------------------------
  8197                                  ;
  8198                                  
  8199                                  	; 13/01/2024
  8200                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:5226h
  8201                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:4D65h
  8202                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:4D58h	
  8203                                  
  8204                                  _$GET_IN_VARS:
  8205 00000F61 E81DF5                  	CALL	Get_User_Stack
  8206                                  	;MOV	WORD [SI+2],SYSINITVAR
  8207                                  	;MOV	word [SI+user_env.user_BX],SYSINITVAR
  8208 00000F64 C74402[2600]            	MOV	word [SI+user_env.user_BX],SYSINITVARS
  8209                                  	; 13/01/2024
  8210                                  	;;MOV	[SI+10H],SS
  8211                                  	;MOV	[SI+user_env.user_ES],SS
  8212                                  	;RETN
  8213 00000F69 EBF2                    	jmp	short getin_segm
  8214                                  
  8215                                  ;
  8216                                  ;----------------------------------------------------------------------------
  8217                                  ;
  8218                                  ;**	$Get_Default_DPB - Return a pointer to the Default DPB
  8219                                  ;
  8220                                  ;	Return pointer to drive parameter table for default drive
  8221                                  ;
  8222                                  ;	ENTRY	none
  8223                                  ;	EXIT	(ds:bx) = DPB address
  8224                                  ;	USES	all
  8225                                  ;
  8226                                  ;**	$Get_DPB - Return a pointer to a specified DPB
  8227                                  ;
  8228                                  ;	Return pointer to a specified drive parameter table
  8229                                  ;
  8230                                  ;	ENTRY	(dl) = drive # (0 = default, 1=A, 2=B, etc.)
  8231                                  ;	EXIT	(al) = 0 iff ok
  8232                                  ;		  (ds:bx) = DPB address
  8233                                  ;		(al) = -1 if bad drive
  8234                                  ;	USES	all
  8235                                  ;
  8236                                  ;----------------------------------------------------------------------------
  8237                                  ;
  8238                                  
  8239                                  ; 15/05/2019 - Retro DOS v4.0
  8240                                  
  8241                                  _$GET_DEFAULT_DPB:
  8242 00000F6B B200                    	MOV	DL,0
  8243                                  _$GET_DPB:
  8244 00000F6D 16                      	push	ss
  8245 00000F6E 1F                      	pop	ds
  8246                                  
  8247 00000F6F 88D0                    	MOV	AL,DL
  8248 00000F71 E82A5B                  	call	GETTHISDRV		; Get CDS structure
  8249 00000F74 7222                    	JC	short ISNODRV 		; no valid drive
  8250 00000F76 C43E[A205]              	LES	DI,[THISCDS]		; check for net CDS
  8251                                  	;;test	word [es:di+43h],8000h
  8252                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
  8253                                  	;test	byte [es:di+44h],80h
  8254 00000F7A 26F6454480              	test	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
  8255 00000F7F 7517                    	JNZ	short ISNODRV 		; No DPB to point at on NET stuff
  8256 00000F81 E88903                  	call	ECritDisk
  8257 00000F84 E85447                  	call	FATREAD_CDS		; Force Media Check and return DPB
  8258 00000F87 E89E03                  	call	LCritDisk
  8259 00000F8A 720C                    	JC	short ISNODRV 		; User FAILed to I 24, only error we
  8260                                  					;   have.
  8261 00000F8C E8F2F4                  	call	Get_User_Stack
  8262                                  	;mov	[si+2],bp
  8263 00000F8F 896C02                  	MOV	[SI+user_env.user_BX],BP
  8264                                  	;mov	[si+0Eh],es
  8265 00000F92 8C440E                  	MOV	[SI+user_env.user_DS],ES
  8266 00000F95 30C0                    	XOR	AL,AL
  8267 00000F97 C3                      	retn
  8268                                  ISNODRV:
  8269 00000F98 B0FF                    	MOV	AL,-1
  8270 00000F9A C3                      	retn
  8271                                  
  8272                                  ;
  8273                                  ;----------------------------------------------------------------------------
  8274                                  ;
  8275                                  ;**	$Disk_Reset - Flush out Dirty Buffers
  8276                                  ;
  8277                                  ;	$DiskReset flushes and invalidates all buffers.  BUGBUG - do
  8278                                  ;		we really invalidate?  SHould we?  THis screws non-removable
  8279                                  ;		caching.  Maybe CHKDSK relies upon it, though....
  8280                                  ;
  8281                                  ;	ENTRY	none
  8282                                  ;	EXIT	none
  8283                                  ;	USES	all
  8284                                  ;
  8285                                  ;----------------------------------------------------------------------------
  8286                                  ;
  8287                                  
  8288                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8289                                  	; DOSCODE:4D94h
  8290                                  _$DISK_RESET:
  8291                                  	; 15/05/2019 - Retro DOS v4.0
  8292 00000F9B B0FF                    	mov	al,0FFh	; -1
  8293 00000F9D 16                      	push	ss
  8294 00000F9E 1F                      	pop	ds
  8295                                  	; 06/11/2022
  8296                                  	;MOV	AL,-1
  8297 00000F9F E86B03                  	call	ECritDisk
  8298                                  	; MSDOS 6.0
  8299                                  	;;or	word [DOS34_FLAG],4
  8300                                  	;or	word [DOS34_FLAG],FROM_DISK_RESET    ;AN000;
  8301 00000FA2 800E[1106]04            	or	byte [DOS34_FLAG],FROM_DISK_RESET ; 4 ; 15/05/2019
  8302 00000FA7 E8AA4A                  	call	FLUSHBUF
  8303                                  	; MSDOS 6.0
  8304                                  	;and	word [DOS34_FLAG],0FFFBh
  8305                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8306                                  	;and	word [DOS34_FLAG],NO_FROM_DISK_RESET ;AN000;
  8307                                  	; 15/12/2022
  8308 00000FAA 8026[1106]FB            	and	byte [DOS34_FLAG],NO_FROM_DISK_RESET ; 0FBh ; 15/05/2019
  8309 00000FAF C706[B50D]0000          	mov	word [SC_STATUS],0	; Throw out secondary cache M041
  8310                                  ;
  8311                                  ; We will "ignore" any errors on the flush, and go ahead and invalidate. This
  8312                                  ; call doesn't return any errors and it is supposed to FORCE a known state, so
  8313                                  ; let's do it.
  8314                                  ;
  8315                                  ; Invalidate 'last-buffer' used
  8316                                  ;
  8317 00000FB5 BBFFFF                  	MOV	BX,-1 ; 0FFFFh	
  8318 00000FB8 891E[2000]              	MOV	[LastBuffer+2],BX
  8319 00000FBC 891E[1E00]              	MOV	[LastBuffer],BX
  8320                                  
  8321                                  	; MSDOS 3.3 
  8322                                  	; IBMDOS.COM, Offset 1C66h
  8323                                  	;;;;
  8324                                  	;lds	si,[BUFFHEAD]
  8325                                  	;mov	ax,20FFh	; .buf_ID,    AL = FFh (Free buffer)
  8326                                  				; .buf_flags, AH = 0, reset/clear
  8327                                  ;DRST_1:
  8328                                  	;;mov	[si+4],ax
  8329                                  	;mov	[si+BUFFINFO.buf_ID],ax
  8330                                  	;lds	si,[SI]
  8331                                  	;cmp	si,bx ; -1
  8332                                  	;je	short DRST_2
  8333                                  	;;mov	[si+4],ax
  8334                                  	;mov	[si+BUFFINFO.buf_ID],ax
  8335                                  	;lds	si,[SI]
  8336                                  	;cmp	si,bx
  8337                                  	;jne	short DRST_1
  8338                                  	;;;;
  8339                                  ;DRST_2:
  8340 00000FC0 E86503                  	call	LCritDisk
  8341 00000FC3 B8FFFF                  	MOV	AX,-1
  8342                                  	; 07/12/2022
  8343                                  	;mov	ax,0FFFFh
  8344                                  	;CallInstall NetFlushBuf,MultNET,32,AX,AX
  8345 00000FC6 50                      	push	ax ; * MSDOS 6.0 ; 15/05/2019
  8346 00000FC7 B82011                  	mov     ax,1120h
  8347 00000FCA CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
  8348                                  			; DS = DOS CS
  8349                                  			; Return: CF clear (successful)
  8350 00000FCC 58                      	pop	ax ; * MSDOS 6.0 ; 15/05/2019
  8351                                  	
  8352 00000FCD C3                      	retn
  8353                                  
  8354                                  	; 19/07/2018 - Retro DOS v3.0
  8355                                  
  8356                                  ;
  8357                                  ;	BREAK <$SetDPB - Create a valid DPB from a user-specified BPB>
  8358                                  ;
  8359                                  ;----------------------------------------------------------------------------
  8360                                  ;
  8361                                  ;**	$SetDPB - Create a DPB
  8362                                  ;
  8363                                  ;	SetDPB Creates a valid DPB from a user-specified BPB
  8364                                  ;
  8365                                  ;	ENTRY	ES:BP Points to DPB
  8366                                  ;		DS:SI Points to BPB
  8367                                  ;	EXIT	DPB setup
  8368                                  ;	USES	ALL but BP, DS, ES
  8369                                  ;
  8370                                  ;----------------------------------------------------------------------------
  8371                                  ;
  8372                                  
  8373                                  ; 10/05/2019 - Retro DOS v4.0
  8374                                  
  8375                                  ; DOSCODE:4DD6h (MSDOS 6.21, MSDOS.SYS)
  8376                                  
  8377                                  ; MSDOS 6.0
  8378 00000FCE 0300                    word3:	dw	3			; M008 -- word value for divides
  8379                                  
  8380                                  ; 13/01/2024
  8381                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8382                                  ; DOSCODE:4DC9h (MSDOS 5.0, MSDOS.SYS)
  8383                                  
  8384                                  ;procedure   $SETDPB,NEAR
  8385                                  
  8386                                  _$SETDPB:
  8387 00000FD0 89EF                    	MOV	DI,BP
  8388                                  	;ADD	DI,2			; Skip over dpb_drive and dpb_UNIT
  8389                                  	; 13/01/2024
  8390 00000FD2 47                      	inc	di
  8391 00000FD3 47                      	inc	di
  8392 00000FD4 AD                      	LODSW
  8393 00000FD5 AB                      	STOSW				; dpb_sector_size
  8394                                  	; MSDOS 6.0
  8395                                  	;cmp	byte [si+3],0
  8396 00000FD6 807C0300                	CMP	BYTE [SI+A_BPB.BPB_NUMBEROFFATS-2],0 ; FAT file system drive ;AN000;
  8397 00000FDA 7509                    	JNZ	short yesfat			     ; yes		;AN000;
  8398                                  	;mov	byte [es:di+4],0
  8399 00000FDC 26C6450400              	MOV	BYTE [ES:DI+DPB.FAT_COUNT-4],0
  8400                                  	; 13/01/2024
  8401 00000FE1 89C3                    	mov	bx,ax
  8402 00000FE3 EB70                    	JMP	short setend			     ; NO		;AN000;
  8403                                  
  8404                                  yesfat: ; 10/08/2018
  8405 00000FE5 89C2                    	MOV	DX,AX
  8406 00000FE7 AC                      	LODSB
  8407                                  	;DEC	AL
  8408                                  	; 17/12/2022
  8409 00000FE8 48                      	dec	ax
  8410 00000FE9 AA                      	STOSB				; dpb_cluster_mask
  8411                                  	;INC	AL
  8412 00000FEA 40                      	inc	ax
  8413 00000FEB 30E4                    	XOR	AH,AH
  8414                                  LOG2LOOP:
  8415 00000FED A801                    	test	AL,1
  8416 00000FEF 7506                    	JNZ	short SAVLOG
  8417 00000FF1 FEC4                    	INC	AH
  8418 00000FF3 D0E8                    	SHR	AL,1
  8419 00000FF5 EBF6                    	JMP	SHORT LOG2LOOP
  8420                                  SAVLOG:
  8421 00000FF7 88E0                    	MOV	AL,AH
  8422 00000FF9 AA                      	STOSB				; dpb_cluster_shift
  8423 00000FFA 88C3                    	MOV	BL,AL
  8424 00000FFC A5                      	MOVSW				; dpb_first_FAT Start of FAT (# of reserved sectors)
  8425 00000FFD AC                      	LODSB
  8426 00000FFE AA                      	STOSB				; dpb_FAT_count Number of FATs
  8427                                  ;	OR	AL,AL			; NONFAT ?				;AN000;
  8428                                  ;	JZ	short setend		; yes, don't do anything                ;AN000;
  8429 00000FFF 88C7                    	MOV	BH,AL
  8430 00001001 AD                      	LODSW
  8431 00001002 AB                      	STOSW				; dpb_root_entries Number of directory entries
  8432 00001003 B105                    	MOV	CL,5
  8433 00001005 D3EA                    	SHR	DX,CL			; Directory entries per sector
  8434 00001007 48                      	DEC	AX
  8435 00001008 01D0                    	ADD	AX,DX			; Cause Round Up
  8436 0000100A 89D1                    	MOV	CX,DX
  8437 0000100C 31D2                    	XOR	DX,DX
  8438 0000100E F7F1                    	DIV	CX
  8439 00001010 89C1                    	MOV	CX,AX			; Number of (root) directory sectors
  8440 00001012 47                      	INC	DI
  8441 00001013 47                      	INC	DI			; Skip dpb_first_sector
  8442 00001014 A5                      	MOVSW			; Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
  8443 00001015 AC                      	LODSB
  8444                                  	;mov	[es:bp+17h],al
  8445 00001016 26884617                	MOV	[ES:BP+DPB.MEDIA],AL	; Media byte
  8446 0000101A AD                      	LODSW				; Number of sectors in a FAT
  8447                                  	
  8448                                  	;;;
  8449                                  	;MSDOS 3.3
  8450                                  	;
  8451                                  	;STOSB		; DPB.FAT_SIZE
  8452                                  	;MUL	BH
  8453                                  	
  8454                                  	;MSDOS 6.0
  8455                                  	;
  8456 0000101B AB                      	STOSW		; DPB.FAT_SIZE	;AC000;;>32mb dpb_FAT_size
  8457 0000101C 88FA                    	MOV	DL,BH			;AN000;;>32mb
  8458 0000101E 30F6                    	XOR	DH,DH			;AN000;;>32mb
  8459 00001020 F7E2                    	MUL	DX			;AC000;;>32mb Space occupied by all FATs
  8460                                  	;;;
  8461                                  	
  8462                                  	;add	ax,[es:bp+6]
  8463 00001022 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
  8464 00001026 AB                      	STOSW				; dpb_dir_sector
  8465 00001027 01C8                    	ADD	AX,CX			; Add number of (root) directory sectors
  8466                                  	;mov	[es:bp+0Bh],ax
  8467 00001029 2689460B                	MOV	[ES:BP+DPB.FIRST_SECTOR],AX
  8468                                  	
  8469                                  	; MSDOS 6.0
  8470 0000102D 88D9                    	MOV	CL,BL			;F.C. >32mb				;AN000;
  8471                                  	;;cmp	word [es:bp+0Dh],0
  8472                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
  8473                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8474                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8475                                  	; 15/12/2022
  8476                                  	; 28/07/2019
  8477 0000102F 268B5E0D                	mov	bx,[ES:BP+DSKSIZ]
  8478 00001033 09DB                    	or	bx,bx
  8479 00001035 751A                    	JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8480                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
  8481                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8482                                  	
  8483                                  
  8484 00001037 30ED                    	XOR	CH,CH			;F.C. >32mb				;AN000;
  8485                                  	;mov	bx,[si+8]
  8486 00001039 8B5C08                  	MOV	BX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK]	;AN000;
  8487                                  	;mov	dx,[si+10]
  8488 0000103C 8B540A                  	MOV	DX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK+2]	;AN000;
  8489 0000103F 29C3                    	SUB	BX,AX			;AN000;;F.C. >32mb
  8490 00001041 83DA00                  	SBB	DX,0			;AN000;;F.C. >32mb
  8491 00001044 09C9                    	OR	CX,CX			;AN000;;F.C. >32mb
  8492 00001046 7407                    	JZ	short norot		;AN000;;F.C. >32mb
  8493                                  rott:					;AN000;;F.C. >32mb
  8494 00001048 F8                      	CLC				;AN000;;F.C. >32mb
  8495 00001049 D1DA                    	RCR	DX,1			;AN000;;F.C. >32mb
  8496 0000104B D1DB                    	RCR	BX,1			;AN000;;F.C. >32mb
  8497 0000104D E2F9                    	LOOP	rott			;AN000;;F.C. >32mb
  8498                                  norot:					;AN000;
  8499                                  	; 15/12/2022
  8500                                  	;MOV	AX,BX			;AN000;;F.C. >32mb
  8501 0000104F EB04                    	JMP	short setend		;AN000;;F.C. >32mb
  8502                                  normal_dpb:
  8503                                  	;;sub	ax,[es:bp+0Dh]
  8504                                  	;SUB	AX,[ES:BP+DSKSIZ]
  8505                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8506                                  	; 15/12/2022
  8507                                  	; bx = [es:bp+DSKSIZ]
  8508                                  	;sub	ax,bx ; 28/07/2019
  8509                                  	;;SUB	AX,[ES:BP+DSKSIZ]
  8510                                  	; 15/12/2022
  8511 00001051 29C3                    	sub	bx,ax
  8512                                  	;NEG	AX			; Sectors in data area
  8513                                  ;;	MOV	CL,BL			; dpb_cluster_shift
  8514                                  	; 15/12/2022
  8515                                  	; CL = cluster shift
  8516                                  	; BX = number of data sectors 
  8517                                  	;SHR	AX,CL			; Div by sectors/cluster
  8518 00001053 D3EB                    	shr	bx,cl 
  8519                                  setend:
  8520                                  ;	M008 - CAS
  8521                                  ;
  8522                                  	; 15/12/2022
  8523 00001055 43                      	inc	bx
  8524                                  	;INC	AX			; +2 (reserved), -1 (count -> max)
  8525                                  ;
  8526                                  ;	There has been a bug in our fatsize calculation for so long
  8527                                  ;	  that we can't correct it now without causing some user to
  8528                                  ;	  experience data loss. There are even cases where allowing
  8529                                  ;	  the number of clusters to exceed the fats is the optimal
  8530                                  ;	  case -- where adding 2 more fat sectors would make the
  8531                                  ;	  data field smaller so that there's nothing to use the extra
  8532                                  ;	  fat sectors for.
  8533                                  ;
  8534                                  ;	Note that this bug had very minor known symptoms. CHKDSK would
  8535                                  ;	  still report that there was a cluster left when the disk was
  8536                                  ;	  actually full. Very graceful failure for a corrupt system
  8537                                  ;	  configuration. There may be worse cases that were never
  8538                                  ;	  properly traced back to this bug. The problem cases only
  8539                                  ;	  occurred when partition sizes were very near FAT sector
  8540                                  ;	  rounding boundaries, which were rare cases.
  8541                                  ;
  8542                                  ;	Also, it's possible that some third-party partition program might
  8543                                  ;	  create a partition that had a less-than-perfect FAT calculation
  8544                                  ;	  scheme. In this hypothetical case, the number of allocation
  8545                                  ;	  clusters which don't actually have FAT entries to represent
  8546                                  ;	  them might be larger and might create a more catastrophic
  8547                                  ;	  failure. So we'll provide the safeguard of limiting the
  8548                                  ;	  max_cluster to the amount that will fit in the FATs.
  8549                                  ;
  8550                                  ;	ax = maximum legal cluster, ES:BP -> dpb
  8551                                  
  8552                                  ;	make sure the number of fat sectors is actually enough to
  8553                                  ;	  hold that many clusters. otherwise, back the number of
  8554                                  ;	  clusters down
  8555                                  
  8556                                  	; 15/12/2022
  8557                                  	; bx = number of clusters
  8558                                  
  8559                                  	; 19/07/2018 - Retro DOS v3.0
  8560                                  	; MSDOS 6.0
  8561                                  	; 15/12/2022
  8562                                  	;mov	bx,ax			; remember calculated # clusters
  8563                                  
  8564                                  	; 01/08/2018 (MSDOS 3.3)
  8565                                  	;mov	al,[ES:BP+DPB.FAT_SIZE]
  8566                                  	;xor	ah,ah 
  8567                                  
  8568                                  	; 10/05/2019 - Retro DOS v4.0
  8569                                  	;mov	ax,[ES:BP+0Fh]
  8570 00001056 268B460F                	mov	ax,[ES:BP+DPB.FAT_SIZE]
  8571                                  
  8572                                  	;mul	word [es:bp+2]	
  8573 0000105A 26F76602                	mul	word [ES:BP+DPB.SECTOR_SIZE] ; how big is the FAT?
  8574 0000105E 81FBF60F                	cmp	bx,4096-10  ; 0FF6h	; test for 12 vs. 16 bit fat
  8575 00001062 720D                    	jb	short setend_fat12
  8576 00001064 D1EA                    	shr	dx,1
  8577                                  
  8578                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8579                                  	; 15/12/2022
  8580                                  ;cs3 7/2/92
  8581 00001066 751C                    	jnz	short setend_faterr	; some bonehead gave us more fatspace
  8582                                  					; than enough for the maximum FAT,
  8583                                  					; so go ahead and use the calculated
  8584                                  					; number of clusters.
  8585                                  ;cs3 7/2/92
  8586                                  
  8587 00001068 D1D8                    	rcr	ax,1			; find number of entries
  8588 0000106A 3DF70F                  	cmp	ax,4096-10+1		; would this truncation move us
  8589                                  ;					;  into 12-bit fatland?
  8590 0000106D 7215                    	jb	short setend_faterr	; then go ahead and let the
  8591                                  ;					;  inconsistency pass through
  8592                                  ;					;  rather than lose data by
  8593                                  ;					;  correcting the fat type
  8594 0000106F EB0E                    	jmp	short setend_fat16
  8595                                  
  8596                                  setend_fat12:
  8597 00001071 01C0                    	add	ax,ax			; (fatsiz*2)/3 = # of fat entries
  8598 00001073 11D2                    	adc	dx,dx
  8599                                  
  8600                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8601                                  ;cs3 7/2/92
  8602                                  	; 15/12/2022
  8603 00001075 83FA03                  	cmp	dx,3			; if our fatspace is WAY more than
  8604 00001078 730A                    	jnb	short setend_faterr	; we need, we may get an overflow
  8605                                  					; here. Check for it and use
  8606                                  					; the calculated size in this case.
  8607                                  ;cs3 7/2/92
  8608                                  
  8609 0000107A 2EF736[CE0F]            	div	word [cs:word3]
  8610                                  
  8611                                  setend_fat16:
  8612 0000107F 48                      	dec	ax			; limit at 1
  8613 00001080 39D8                    	cmp	ax,bx			; is fat big enough?
  8614 00001082 7602                    	jbe	short setend_fat	; use max value that'll fit
  8615                                  
  8616                                  setend_faterr:
  8617 00001084 89D8                    	mov	ax,bx			; use calculated value
  8618                                  
  8619                                  setend_fat:
  8620                                  
  8621                                  ;	now ax = maximum legal cluster
  8622                                  
  8623                                  ;	end M008
  8624                                  
  8625                                  	;mov	[es:bp+0Dh], ax
  8626 00001086 2689460D                	MOV	[ES:BP+DPB.MAX_CLUSTER],AX
  8627                                  	;;mov	word [es:bp+1Ch],0  ; MSDOS 3.3
  8628                                  	;mov	word [es:bp+1Dh],0  ; MSDOS 6.0
  8629 0000108A 26C7461D0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 
  8630                                  					; Init so first ALLOC starts at
  8631                                  					; begining of FAT
  8632                                  	;;mov	word [es:bp+1Eh],-1 ; MSDOS 3.3
  8633                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
  8634 00001090 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; current count is invalid.
  8635                                  
  8636 00001096 C3                      	retn
  8637                                  
  8638                                  ;EndProc $SETDPB
  8639                                  
  8640                                  ;BREAK <$Create_Process_Data_Block,SetMem -- Set up process data block>
  8641                                  
  8642                                  ;
  8643                                  ;----------------------------------------------------------------------------
  8644                                  ;
  8645                                  ;**	$Dup_PDB
  8646                                  ;
  8647                                  ; Inputs:   DX is new segment address of process
  8648                                  ;	    SI is end of new allocation block
  8649                                  ;
  8650                                  ;----------------------------------------------------------------------------
  8651                                  ;
  8652                                  
  8653                                  _$DUP_PDB:
  8654                                  
  8655                                  ;hkn;	CreatePDB would have a CS override. This is not valid.
  8656                                  ;hkn;	Must set up ds in order to acess CreatePDB. Also SS is 
  8657                                  ;hkn;	has been assumed to be NOTHING. It may not have DOSDATA.
  8658                                  
  8659                                  	; MSDOS 3.3
  8660                                  	;MOV	byte [CS:CreatePDB],0FFh  ; indicate a new process
  8661                                  	;MOV	DS,[CS:CurrentPDB]
  8662                                  
  8663                                  	; 15/05/2019 - Retro DOS v4.0
  8664                                  	; MSDOS 6.0
  8665 00001097 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  8666 0000109C C606[A803]FF            	MOV	byte [CreatePDB],0FFh
  8667 000010A1 8E1E[3003]              	MOV	DS,[CurrentPDB]
  8668                                  
  8669 000010A5 56                      	PUSH	SI
  8670 000010A6 EB0A                    	JMP	SHORT CreateCopy
  8671                                  
  8672                                  ;
  8673                                  ;----------------------------------------------------------------------------
  8674                                  ;
  8675                                  ; Inputs:
  8676                                  ;	DX = Segment number of new base
  8677                                  ; Function:
  8678                                  ;	Set up program base and copy term and ^C from int area
  8679                                  ; Returns:
  8680                                  ;	None
  8681                                  ; Called at DOS init
  8682                                  ;
  8683                                  ;----------------------------------------------------------------------------
  8684                                  ;
  8685                                  
  8686                                  ; 15/05/2019 - Retro DOS v4.0
  8687                                  ; DOSCODE:4EB6h (MSDOS 6.21, MSDOS.SYS)
  8688                                  
  8689                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8690                                  ; DOSCODE:4EA2h (MSDOS 5.0, MSDOS.SYS)
  8691                                  
  8692                                  _$CREATE_PROCESS_DATA_BLOCK:
  8693                                  			; Offset 1D02h in IBMDOS.COM (MSDOS 3.3), 1987
  8694 000010A8 E8D6F3                  	CALL	Get_User_Stack
  8695                                  	;mov	ds,[si+14h]
  8696 000010AB 8E5C14                  	MOV	DS,[SI+user_env.user_CS]
  8697                                  	;push	word [2]
  8698 000010AE FF360200                	PUSH	word [PDB.BLOCK_LEN] ;*
  8699                                  CreateCopy:
  8700 000010B2 8EC2                    	MOV	ES,DX
  8701                                  
  8702 000010B4 31F6                    	XOR	SI,SI			; copy entire PDB
  8703 000010B6 89F7                    	MOV	DI,SI
  8704 000010B8 B98000                  	MOV	CX,128
  8705 000010BB F3A5                    	REP	MOVSW
  8706                                  
  8707                                  ; DOS 3.3 7/9/86
  8708                                  	;mov	cx,20
  8709                                  	;MOV	CX,FILPERPROC		; copy handles in case of
  8710                                  	; 15/12/2022
  8711 000010BD B114                    	mov	cl,FILPERPROC ; 06/07/2019
  8712                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8713                                  	;mov	cx,FILPERPROC
  8714                                  
  8715                                  	;mov	di,18h
  8716 000010BF BF1800                  	MOV	DI,PDB.JFN_TABLE	; Set Handle Count has been issued
  8717                                  	;;PUSH	DS ; * 15/05/2019
  8718                                  	;;lds	si,[34h]
  8719                                  	;LDS	SI,[PDB.JFN_Pointer]
  8720                                  	;REP	MOVSB
  8721                                  	;;POP	DS ; * 15/05/2019
  8722                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8723                                  	; 05/12/2022
  8724                                  	; (push ds then pop ds is not needed here!)
  8725                                  	;push	ds
  8726                                  	;lds	si,[34h]
  8727 000010C2 C5363400                	lds	si,[PDB.JFN_Pointer]
  8728 000010C6 F3A4                    	rep	movsb
  8729                                  	;pop	ds
  8730                                  
  8731                                  ; DOS 3.3 7/9/86
  8732                                  	;hkn ;CreatePDB would have a CS override. This is not valid.
  8733                                  	;hkn ;Must set up ds in order to access CreatePDB. Also SS is 
  8734                                  	;hkn ;has been assumed to be NOTHING. It may not have DOSDATA.
  8735                                  
  8736 000010C8 2E8E1E[0700]            	mov	ds,[cs:DosDSeg] ; 15/05/2019
  8737                                  
  8738                                  	;;test	byte [cs:CreatePDB],0FFh
  8739                                  	;cmp	byte [CS:CreatePDB],0	; Shall we create a process?
  8740                                  	; 17/12/2022
  8741 000010CD 380E[A803]              	cmp	[CreatePDB],cl ; 0
  8742                                  	;cmp	byte [CreatePDB],0 ; 15/05/2019
  8743 000010D1 744A                    	JZ	short Create_PDB_cont 	; nope, old style call
  8744                                  
  8745                                  ; Here we set up for a new process...
  8746                                  
  8747                                  	;PUSH	CS			; Called at DOSINIT time, NO SS
  8748                                  	;POP	DS
  8749                                  
  8750                                  	; MSDOS 6.0
  8751                                  	;;getdseg <ds>			; ds -> dosdata
  8752                                  	;mov	ds,[cs:DosDSeg] ; 15/05/2019
  8753                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8754                                  	; (nonsense! but i put this for addr compatibility as temporary)
  8755                                  	; 15/12/2022
  8756                                  	;mov	ds,[cs:DosDSeg] ; 15/05/2019
  8757                                  
  8758 000010D3 31DB                    	XOR	BX,BX			; dup all jfns
  8759                                  	;mov	cx,20
  8760                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8761                                  	;MOV	CX,FILPERPROC		; only 20 of them
  8762                                  	; 15/12/2022
  8763 000010D5 B114                    	mov	cl,FILPERPROC ; 06/07/2019
  8764                                  
  8765                                  Create_dup_jfn:
  8766 000010D7 06                      	PUSH	ES ;**			; save new PDB
  8767 000010D8 E89F55                  	call	SFFromHandle		; get sf pointer
  8768 000010DB B0FF                    	MOV	AL,-1			; unassigned JFN
  8769 000010DD 7224                    	JC	short CreateStash	; file was not really open
  8770                                  	;;test	word [es:di+5],1000h
  8771                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_no_inherit
  8772                                  	; 15/05/2019
  8773                                  	;test	byte [es:di+6],10h
  8774 000010DF 26F6450610              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_no_inherit>>8)
  8775 000010E4 751D                    	JNZ	short CreateStash	; if no-inherit bit is set, skip dup.
  8776                                  
  8777                                  ; We do not inherit network file handles.
  8778                                  
  8779                                  	;mov	ah,[es:di+2]
  8780 000010E6 268A6502                	MOV	AH,[ES:DI+SF_ENTRY.sf_mode]
  8781                                  	;and	ah,0F0h
  8782 000010EA 80E4F0                  	AND	AH,SHARING_MASK
  8783                                  	;cmp	ah,70h
  8784 000010ED 80FC70                  	CMP	AH,SHARING_NET_FCB
  8785 000010F0 7411                    	jz	short CreateStash
  8786                                  
  8787                                  ; The handle we have found is duplicatable (and inheritable). Perform
  8788                                  ; duplication operation.
  8789                                  
  8790 000010F2 893E[9E05]              	MOV	[THISSFT],DI
  8791 000010F6 8C06[A005]              	MOV	[THISSFT+2],ES
  8792 000010FA E84519                  	call	DOS_DUP 		; signal duplication
  8793                                  
  8794                                  ; get the old sfn for copy
  8795                                  
  8796 000010FD E85D55                  	call	pJFNFromHandle		; ES:DI is jfn
  8797 00001100 268A05                  	MOV	AL,[ES:DI]		; get sfn
  8798                                  
  8799                                  ; Take AL (old sfn or -1) and stash it into the new position
  8800                                  
  8801                                  CreateStash:
  8802 00001103 07                      	POP	ES ;**
  8803                                  	;mov	[es:bx+18h],al
  8804 00001104 26884718                	MOV	[ES:BX+PDB.JFN_TABLE],AL ; copy into new place!
  8805 00001108 43                      	INC	BX			; next jfn...
  8806 00001109 E2CC                    	LOOP	Create_dup_jfn
  8807                                  
  8808 0000110B 8B1E[3003]              	MOV	BX,[CurrentPDB]		; get current process
  8809                                  	; 06/11/2022
  8810                                  	;mov	[es:16h],bx
  8811 0000110F 26891E1600              	MOV	[ES:PDB.PARENT_PID],BX	; stash in child
  8812 00001114 8C06[3003]              	MOV	[CurrentPDB],ES
  8813                                  	;MOV	DS,BX ; 28/07/2019
  8814                                  	; 07/12/2022
  8815                                  	;mov	ds,[cs:DosDSeg]
  8816                                  	; 15/12/2022
  8817                                  	; ds = [cs:DosDSeg]
  8818 00001118 C606[A803]00            	mov	byte [CreatePDB],0	; reset flag
  8819                                  	;mov	ds,bx
  8820                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8821                                  	; 15/12/2022
  8822                                  	;mov	ds,bx
  8823                                  
  8824                                  ; end of new process create
  8825                                  
  8826                                  Create_PDB_cont:
  8827                                  	;MOV	BYTE [CS:CreatePDB],0	; reset flag
  8828                                  
  8829                                  ;hkn; It comes to this point from 2 places. So, change to DOSDATA temporarily	
  8830                                  
  8831                                  	;; 28/07/2019
  8832                                  	;;push	ds
  8833                                  	;;mov	ds,[cs:DosDSeg]
  8834                                  	;mov	byte [CreatePDB],0
  8835                                  	;;pop	ds
  8836                                  
  8837                                  ; 05/12/2022
  8838                                  ;	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8839                                  ;	; (push-pop ds is nonsense here! 
  8840                                  ;	;  but i am using same code with original MSDOS.SYS
  8841                                  ;	;  for address compatibility.)
  8842                                  ;	push	ds
  8843                                  ;	; ds = [cs:DosDSeg] !
  8844                                  ;	mov	ds,[cs:DosDSeg]  ; again !
  8845                                  ;	mov	byte [CreatePDB],0
  8846                                  ;	pop	ds
  8847                                  
  8848 0000111D 58                      	POP	AX ;*
  8849                                  
  8850                                  	;entry	SETMEM
  8851                                  
  8852                                  	; 17/12/2022
  8853                                  	; cx = 0
  8854                                  
  8855                                  ;---------------------------------------------------------------------------
  8856                                  ; Inputs:
  8857                                  ;	AX = Size of memory in paragraphs
  8858                                  ;	DX = Segment
  8859                                  ; Function:
  8860                                  ;	Completely prepares a program base at the
  8861                                  ;	specified segment.
  8862                                  ; Called at DOS init
  8863                                  ; Outputs:
  8864                                  ;	DS = DX
  8865                                  ;	ES = DX
  8866                                  ;	[0] has INT int_abort
  8867                                  ;	[2] = First unavailable segment
  8868                                  ;	[5] to [9] form a long call to the entry point
  8869                                  ;	[10] to [13] have exit address (from int_terminate)
  8870                                  ;	[14] to [17] have ctrl-C exit address (from int_ctrl_c)
  8871                                  ;	[18] to [21] have fatal error address (from int_fatal_abort)
  8872                                  ; DX,BP unchanged. All other registers destroyed.
  8873                                  ;---------------------------------------------------------------------------
  8874                                  
  8875                                  SETMEM:
  8876                                  	;XOR	CX,CX
  8877                                  	; 17/12/2022
  8878                                  	; cx = 0
  8879 0000111E 8ED9                    	MOV	DS,CX
  8880 00001120 8EC2                    	MOV	ES,DX
  8881                                  	;mov	si,88h
  8882 00001122 BE8800                  	MOV	SI,addr_int_terminate
  8883                                  	;mov	di,10 ; 0Ah
  8884 00001125 BF0A00                  	MOV	DI,SAVEXIT
  8885                                  	;MOV	CX,6
  8886                                  	; 15/12/2022
  8887 00001128 B106                    	mov	cl,6
  8888 0000112A F3A5                    	REP	MOVSW
  8889 0000112C 26A30200                	MOV	[ES:2],AX
  8890 00001130 29D0                    	SUB	AX,DX
  8891 00001132 3DFF0F                  	CMP	AX,MAXDIF ; 0FFFh
  8892 00001135 7603                    	JBE	short HAVDIF
  8893 00001137 B8FF0F                  	MOV	AX,MAXDIF
  8894                                  HAVDIF:
  8895 0000113A 83E810                  	SUB	AX,10h			; Allow for 100h byte "stack"
  8896 0000113D BB0C00                  	MOV	BX,ENTRYPOINTSEG ; 0Ch	;	in .COM files
  8897 00001140 29C3                    	SUB	BX,AX
  8898 00001142 B104                    	MOV	CL,4
  8899 00001144 D3E0                    	SHL	AX,CL
  8900 00001146 8EDA                    	MOV	DS,DX
  8901                                  
  8902                                  	; (MSDOS 6.0 note)
  8903                                  	;
  8904                                  	; The address in BX:AX will be F01D:FEF0 if there is 64K or more 
  8905                                  	; memory in the system. This is equivalent to 0:c0 if A20 is OFF.
  8906                                  	; If DOS is in HMA this equivalence is no longer valid as A20 is ON.
  8907                                  	; But the BIOS which now resides in FFFF:30 has 5 bytes in FFFF:D0
  8908                                  	; (F01D:FEF0) which is the same as the ones in 0:C0, thereby 
  8909                                  	; making this equvalence valid for this particular case. If however
  8910                                  	; there is less than 64K remaining the address in BX:AX will not 
  8911                                  	; be the same as above. We will then stuff 0:c0, the call 5 address
  8912                                  	; into the PSP.
  8913                                  	;
  8914                                  	; Therefore for the case where there is less than 64K remaining in 
  8915                                  	; the system old CPM Apps that look at PSP:6 to determine memory
  8916                                  	; requirements will not work. Call 5, however will continue to work
  8917                                  	; for all cases.
  8918                                  	;
  8919                                  
  8920                                  	;mov	[6],ax
  8921                                  	;mov	[8],bx
  8922                                  
  8923 00001148 A30600                  	MOV	[PDB.CPM_CALL+1],AX
  8924 0000114B 891E0800                	MOV	[PDB.CPM_CALL+3],BX
  8925                                  
  8926                                  	; 06/05/2019 - Retro DOS v4.0
  8927 0000114F 3DF0FE                  	cmp	ax,WRAPOFFSET ; 0FEF0h	; Q: does the system have >= 64k of
  8928                                  					;    memory left
  8929 00001152 740C                    	je	short addr_ok		; Y: the above calculated address is
  8930                                  					;    OK
  8931                                  					; N: 
  8932                                  
  8933 00001154 C7060600C000            	MOV	WORD [PDB.CPM_CALL+1],0C0h
  8934 0000115A C70608000000            	MOV	WORD [PDB.CPM_CALL+3],0
  8935                                  addr_ok:
  8936                                  	;mov	word [0],20CDh
  8937 00001160 C7060000CD20            	MOV	word [PDB.EXIT_CALL],(int_abort*256) + mi_INT
  8938                                  	;mov	byte [5],9Ah
  8939 00001166 C60605009A              	MOV	BYTE [PDB.CPM_CALL],mi_Long_CALL
  8940                                  	;mov	word [50h],21CDh
  8941 0000116B C7065000CD21            	MOV	WORD [PDB.CALL_SYSTEM],(int_command*256) + mi_INT
  8942                                  	;mov	byte [52h],0CBh
  8943 00001171 C6065200CB              	MOV	BYTE [PDB.CALL_SYSTEM+2],mi_Long_RET
  8944                                  	;mov	word [34h],18h
  8945 00001176 C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE
  8946                                  	;mov	word [36h],ds
  8947 0000117C 8C1E3600                	MOV	WORD [PDB.JFN_Pointer+2],DS
  8948                                  	;mov	word [32h],20
  8949 00001180 C70632001400            	MOV	WORD [PDB.JFN_Length],FILPERPROC
  8950                                  ;
  8951                                  ; The server runs several PDB's without creating them VIA EXEC.  We need to
  8952                                  ; enumerate all PDB's at CPS time in order to find all references to a
  8953                                  ; particular SFT.  We perform this by requiring that the server link together
  8954                                  ; for us all sub-PDB's that he creates. The requirement for us, now, is to
  8955                                  ; initialize this pointer.
  8956                                  ;
  8957                                   	;mov	word [38h],-1
  8958 00001186 C7063800FFFF            	MOV	word [PDB.Next_PDB],-1
  8959                                  	;mov	word [3Ah],-1
  8960 0000118C C7063A00FFFF            	MOV	word [PDB.Next_PDB+2],-1
  8961                                  
  8962                                  	; 06/05/2019
  8963                                  	; Set the real version number in the PSP - 5.00
  8964                                  
  8965                                  	;mov	word [es:PDB.Version],1406h ; MSDOS 6.21 (DOSCODE:4FB6h)
  8966                                  	; 07/12/2022
  8967 00001192 26C70640000616          	mov	word [ES:PDB.Version],(MINOR_VERSION*256)+MAJOR_VERSION
  8968                                  
  8969 00001199 C3                      	retn
  8970                                  
  8971                                  ; 29/04/2019 - Retro DOS v4.0
  8972                                  
  8973                                  ;BREAK <$GSetMediaID -- get set media ID>
  8974                                  
  8975                                  ;---------------------------------------------------------------------------
  8976                                  ; Inputs:
  8977                                  ;	BL= drive number as defined in IOCTL
  8978                                  ;	AL= 0 get media ID
  8979                                  ;	    1 set media ID
  8980                                  ;	DS:DX= buffer containing information
  8981                                  ;		DW  0  info level (set on input)
  8982                                  ;		DD  ?  serial #
  8983                                  ;		DB  11 dup(?)  volume id
  8984                                  ;		DB   8 dup(?)  file system type
  8985                                  ; Function:
  8986                                  ;	Get or set media ID
  8987                                  ; Returns:
  8988                                  ;	carry clear, DS:DX is filled
  8989                                  ;	carry set, error
  8990                                  ;---------------------------------------------------------------------------
  8991                                  
  8992                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8993                                  _$GSetMediaID:
  8994                                  	; RAWIO - GET_MEDIA_ID
  8995 0000119A B96608                  	mov	cx,0866h	      ;AN000;MS.; assume get  for IOCTL
  8996 0000119D 3C00                    	cmp	al,0		      ;AN001;MS.; get ?
  8997 0000119F 7406                    	je	short doioctl 	      ;AN000;MS.; yes
  8998                                  	;cmp	al,1		      ;AN000;MS.; set ?
  8999                                  	;jne	short errorfunc	      ;AN000;MS.; no
  9000                                  	; 15/12/2022
  9001 000011A1 FEC8                    	dec	al
  9002 000011A3 7507                    	jnz	short errorfunc ; al > 1
  9003                                  	; RAWIO - SET_MEDIA_ID
  9004                                  	;mov	cx,0846h	      ;AN001;MS.;
  9005                                  	; 15/12/2022
  9006 000011A5 B146                    	mov	cl,46h	; cx = 0846h 
  9007                                  doioctl:			      ;AN000;
  9008 000011A7 B00D                    	mov	al,0Dh		      ;AN000;MS.; generic IOCTL
  9009                                  	;invoke	$IOCTL		      ;AN000;MS.; let IOCTL take care of it
  9010                                  	;call	_$IOCTL
  9011                                  	;retn			      ;AN000;MS.;
  9012                                  	; 15/12/2022
  9013 000011A9 E9D410                  	jmp	_$IOCTL
  9014                                  errorfunc:			      ;AN000;
  9015                                  	;error	error_invalid_function;AN000;MS. ; invalid function
  9016                                  	;mov	al,1
  9017 000011AC B001                    	mov	al,error_invalid_function
  9018 000011AE E98FF4                  	jmp	SYS_RET_ERR
  9019                                  
  9020                                  ; 16/05/2019 - Retro DOS v4.0
  9021                                  
  9022                                  ;============================================================================
  9023                                  ; MISC2.ASM, MSDOS 6.0, 1991
  9024                                  ;============================================================================
  9025                                  ; 20/07/2018 - Retro DOS v3.0
  9026                                  ; 29/04/2019 - Retro DOS v4.0
  9027                                  
  9028                                  ; Break <STRCMP - compare two ASCIZ strings DS:SI to ES:DI>
  9029                                  ;----------------------------------------------------------------------------
  9030                                  ;
  9031                                  ;   Strcmp - compare ASCIZ DS:SI to ES:DI. Case INSENSITIVE. '/' = '\'
  9032                                  ;	     Strings of different lengths don't match.
  9033                                  ;   Inputs:  DS:SI - pointer to source string  ES:DI - pointer to dest string
  9034                                  ;   Outputs: Z if strings same, NZ if different
  9035                                  ;   Registers modified: NONE
  9036                                  ;----------------------------------------------------------------------------
  9037                                  
  9038                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  9039                                  StrCmp:
  9040 000011B1 56                      	push	si
  9041 000011B2 57                      	push	di
  9042 000011B3 50                      	push	ax
  9043                                  Cmplp:
  9044 000011B4 AC                      	LODSB
  9045 000011B5 E8953E                  	call	UCase			; convert to upper case
  9046 000011B8 E8E73E                  	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
  9047 000011BB 88C4                    	MOV	AH,AL
  9048 000011BD 268A05                  	MOV	AL,[ES:DI]
  9049 000011C0 47                      	INC	DI
  9050 000011C1 E8893E                  	call	UCase			; convert to upper case
  9051 000011C4 E8DB3E                  	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
  9052 000011C7 38C4                    	CMP	AH,AL
  9053 000011C9 7504                    	JNZ	short PopRet		; Strings dif
  9054                                  
  9055 000011CB 08C0                    	OR	AL,AL
  9056 000011CD 75E5                    	JNZ	short Cmplp		; More string
  9057                                  PopRet:
  9058 000011CF 58                      	pop	ax
  9059 000011D0 5F                      	pop	di
  9060 000011D1 5E                      	pop	si
  9061 000011D2 C3                      	retn
  9062                                  
  9063                                  ;Break <STRCPY - copy ASCIZ string from DS:SI to ES:DI>
  9064                                  ;----------------------------------------------------------------------------
  9065                                  ;
  9066                                  ;   Strcpy - copy an ASCIZ string from DS:SI to ES:DI and make uppercase
  9067                                  ;   FStrcpy - copy an ASCIZ string from DS:SI to ES:DI. no modification of
  9068                                  ;	characters.
  9069                                  ;
  9070                                  ;   Inputs:	DS:SI - pointer to source string
  9071                                  ;		ES:DI - pointer to destination string
  9072                                  ;   Outputs:	ES:DI point byte after nul byte at end of dest string
  9073                                  ;		DS:SI point byte after nul byte at end of source string
  9074                                  ;   Registers modified: SI,DI
  9075                                  ;----------------------------------------------------------------------------
  9076                                  
  9077                                  StrCpy:
  9078 000011D3 50                      	push	ax
  9079                                  CPYLoop:
  9080 000011D4 AC                      	LODSB
  9081 000011D5 E8753E                  	call	UCase			; convert to upper case
  9082 000011D8 E8C73E                  	call	PATHCHRCMP		; convert / to \ ;
  9083 000011DB AA                      	STOSB
  9084                                  
  9085 000011DC 08C0                    	OR	AL,AL
  9086 000011DE 75F4                    	JNZ	short CPYLoop
  9087 000011E0 58                      	pop	ax
  9088 000011E1 C3                      	retn
  9089                                  
  9090                                  ;----------------------------------------------------------------------------
  9091                                  ; Procedure Name : FStrCpy
  9092                                  ;----------------------------------------------------------------------------
  9093                                  
  9094                                  FStrCpy:
  9095 000011E2 50                      	push	ax
  9096                                  FCPYLoop:
  9097 000011E3 AC                      	LODSB
  9098 000011E4 AA                      	STOSB
  9099 000011E5 08C0                    	OR	AL,AL
  9100 000011E7 75FA                    	JNZ	short FCPYLoop
  9101 000011E9 58                      	pop	ax
  9102 000011EA C3                      	retn
  9103                                  
  9104                                  ; 20/07/2018 - Retro DOS v3.0
  9105                                  ;----------------------------------------------------------------------------
  9106                                  ; UCase, IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1E2Fh
  9107                                  ;----------------------------------------------------------------------------
  9108                                  ;
  9109                                  ;UCase:	
  9110                                  ;	call	_UCase	 ; Offset 5518h (GetLet, Offset 5517h)
  9111                                  ;	retn
  9112                                  
  9113                                  ;Break <StrLen - compute length of string ES:DI>
  9114                                  ;----------------------------------------------------------------------------
  9115                                  ;**	StrLen - Compute Length of String
  9116                                  ;
  9117                                  ;	StrLen computes the length of a string, including the trailing 00
  9118                                  ;
  9119                                  ;	ENTRY	(es:di) = address of string
  9120                                  ;	EXIT	(cx) = size of string
  9121                                  ;	USES	cx, flags
  9122                                  ;----------------------------------------------------------------------------
  9123                                  
  9124                                  StrLen:
  9125 000011EB 57                      	push	di
  9126 000011EC 50                      	push	ax
  9127                                  	;MOV	CX,-1
  9128 000011ED B9FFFF                  	mov	cx,65535
  9129 000011F0 30C0                    	XOR	AL,AL
  9130 000011F2 F2AE                    	REPNE	SCASB
  9131 000011F4 F7D1                    	NOT	CX
  9132 000011F6 58                      	pop	ax
  9133 000011F7 5F                      	pop	di
  9134 000011F8 C3                      	retn
  9135                                  
  9136                                  ;----------------------------------------------------------------------------
  9137                                  ;**	DStrLen - Compute Length of String
  9138                                  ;
  9139                                  ;	ENTRY	(ds:si) = address of string
  9140                                  ;	EXIT	(cx) = size of string, including trailing NUL
  9141                                  ;	USES	cx, flags
  9142                                  ;----------------------------------------------------------------------------
  9143                                  
  9144                                  DStrLen:	; BUGBUG - this guy is a pig, who uses him?
  9145 000011F9 E80300                  	CALL	XCHGP
  9146 000011FC E8ECFF                  	CALL	StrLen
  9147                                  	;CALL	XCHGP
  9148                                  	;retn
  9149                                  	; 18/12/2022
  9150                                  	;jmp	short XCHGP
  9151                                  
  9152                                  ;----------------------------------------------------------------------------
  9153                                  ;**	XCHGP - Exchange Source and Destination Pointers
  9154                                  ;
  9155                                  ;	XCHGP exchanges (DS:SI) and (ES:DI)
  9156                                  ;
  9157                                  ;	ENTRY	none
  9158                                  ;	EXIT	pairs exchanged
  9159                                  ;	USES	SI, DI, DS, ES
  9160                                  ;----------------------------------------------------------------------------
  9161                                  
  9162                                  XCHGP:
  9163 000011FF 1E                      	push	ds
  9164 00001200 06                      	push	es
  9165 00001201 1F                      	pop	ds
  9166 00001202 07                      	pop	es
  9167 00001203 87F7                    	XCHG	SI,DI
  9168                                  xchgp_retn:
  9169 00001205 C3                      	retn
  9170                                  
  9171                                  ;Break	<Idle - wait for a specified amount of time>
  9172                                  ;----------------------------------------------------------------------------
  9173                                  ;
  9174                                  ;   Idle - when retrying an operation due to a lock/sharing violation,
  9175                                  ;   	   we spin until RetryLoop is exhausted.
  9176                                  ;
  9177                                  ;   Inputs:	RetryLoop is the number of times we spin
  9178                                  ;   Outputs:	Wait
  9179                                  ;   Registers modified: none
  9180                                  ;----------------------------------------------------------------------------
  9181                                  
  9182                                  Idle:
  9183                                  	;test	byte [SS:FSHARING],0FFh
  9184 00001206 36803E[7205]00          	cmp	byte [SS:FSHARING],0	;hkn; SS override
  9185                                  	;retnz
  9186 0000120C 75F7                    	jnz	short xchgp_retn
  9187                                  	;SAVE	<CX>
  9188 0000120E 51                      	push	cx
  9189 0000120F 368B0E[1C00]            	MOV	CX,[ss:RetryLoop]	;hkn; SS override
  9190 00001214 E308                    	JCXZ	Idle3
  9191                                  Idle1:	
  9192 00001216 51                      	PUSH	CX
  9193 00001217 31C9                    	XOR	CX,CX
  9194                                  Idle2:	
  9195 00001219 E2FE                    	LOOP	Idle2
  9196 0000121B 59                      	POP	CX
  9197 0000121C E2F8                    	LOOP	Idle1
  9198                                  Idle3:	
  9199                                  	;RESTORE <CX>
  9200 0000121E 59                      	pop	cx
  9201 0000121F C3                      	retn
  9202                                  
  9203                                  ;Break	<TableDispatch - dispatch to a table>
  9204                                  ;----------------------------------------------------------------------------
  9205                                  ;
  9206                                  ;   TableDispatch - given a table and an index, jmp to the approptiate
  9207                                  ;   routine. Preserve all input registers to the routine.
  9208                                  ;
  9209                                  ;   Inputs:	Push	return address
  9210                                  ;		Push	Table address
  9211                                  ;		Push	index (byte)
  9212                                  ;   Outputs:	appropriate routine gets jumped to.
  9213                                  ;		return indicates invalid index
  9214                                  ;   Registers modified: none.
  9215                                  ;----------------------------------------------------------------------------
  9216                                  
  9217                                  struc TFrame	 ; TableFrame
  9218 00000000 ????                    .OldBP:	 resw 1  ; 0
  9219 00000002 ????                    .OldRet: resw 1  ; 2
  9220 00000004 ??                      .Index:	 resb 1  ; 4
  9221 00000005 ??                      .Pad:	 resb 1  ; 5  
  9222 00000006 ????                    .Tab:	 resw 1  ; 6
  9223 00000008 ????                    .NewRet: resw 1  ; 8
  9224                                  endstruc
  9225                                  
  9226                                  TableDispatch:
  9227 00001220 55                      	PUSH	BP
  9228 00001221 89E5                    	MOV	BP,SP
  9229 00001223 53                      	PUSH	BX			; save BX
  9230                                  	;mov	bx,[bp+6]
  9231 00001224 8B5E06                  	MOV	BX,[BP+TFrame.Tab]	; get pointer to table
  9232 00001227 2E8A1F                  	MOV	BL,[CS:BX]		; maximum index
  9233                                  	;cmp	[bp+4],bl
  9234 0000122A 385E04                  	CMP	[BP+TFrame.Index],BL	; table error?
  9235 0000122D 7317                    	JAE	short TableError	; yes
  9236                                  	;mov	bl,[bp+4]
  9237 0000122F 8A5E04                  	MOV	BL,[BP+TFrame.Index]	; get desired table index
  9238 00001232 30FF                    	XOR	BH,BH			; convert to word
  9239 00001234 D1E3                    	SHL	BX,1			; convert to word pointer
  9240 00001236 43                      	INC	BX			; point past first length byte
  9241                                  	; 17/08/2018
  9242                                  	;add	bx,[bp+6]
  9243 00001237 035E06                  	ADD	BX,[BP+TFrame.Tab]	; get real offset
  9244 0000123A 2E8B1F                  	MOV	BX,[CS:BX]		; get contents of table entry
  9245                                  	;mov	[bp+6],bx
  9246 0000123D 895E06                  	MOV	[BP+TFrame.Tab],BX	; put table entry into return address
  9247 00001240 5B                      	POP	BX			; restore BX
  9248 00001241 5D                      	POP	BP			; restore BP
  9249 00001242 83C404                  	ADD	SP,4			; clean off Index and our return addr
  9250 00001245 C3                      	retn				; do operation
  9251                                  TableError:
  9252 00001246 5B                      	POP	BX			; restore BX
  9253 00001247 5D                      	POP	BP			; restore BP
  9254 00001248 C20600                  	RETN	6			; clean off Index, Table and RetAddr
  9255                                  
  9256                                  ;Break	<TestNet - determine if a CDS is for the network>
  9257                                  ;----------------------------------------------------------------------------
  9258                                  ;
  9259                                  ;   TestNet - examine CDS pointed to by ThisCDS and see if it indicates a
  9260                                  ;	network CDS. This will handle NULL cds also.
  9261                                  ;
  9262                                  ;   Inputs:	ThisCDS points to CDS or NULL
  9263                                  ;   Outputs:	ES:DI = ThisCDS
  9264                                  ;		carry Set => network
  9265                                  ;		carry Clear => local
  9266                                  ;   Registers modified: none.
  9267                                  ;----------------------------------------------------------------------------
  9268                                  
  9269                                  TestNet:
  9270                                  	;LES	DI,[CS:THISCDS]
  9271                                  
  9272                                  	; 16/05/2019 - Retro DOS v4.0
  9273 0000124B 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  9274 00001250 26C43E[A205]            	LES	DI,[ES:THISCDS]
  9275 00001255 83FFFF                  	CMP	DI,-1
  9276 00001258 7408                    	JZ	short CMCRet		; UNC? carry is clear
  9277                                  	;;test	word [es:di+43h],8000h
  9278                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
  9279                                  	;test	byte [es:di+44h],80h
  9280 0000125A 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
  9281 0000125F 7501                    	JNZ	short CMCRet		; jump has carry clear
  9282 00001261 C3                      	retn				; carry is clear
  9283                                  CMCRet: 
  9284 00001262 F5                      	CMC
  9285 00001263 C3                      	retn
  9286                                  
  9287                                  ;Break	<IsSFTNet - see if an sft is for the network>
  9288                                  ;----------------------------------------------------------------------------
  9289                                  ;
  9290                                  ;   IsSFTNet - examine SF pointed to by ES:DI and see if it indicates a
  9291                                  ;	network file.
  9292                                  ;
  9293                                  ;   Inputs:	ES:DI point to SFT
  9294                                  ;   Outputs:	Zero set if not network sft
  9295                                  ;		zero reset otherwise
  9296                                  ;		Carry CLEAR!!!
  9297                                  ;   Registers modified: none.
  9298                                  ;----------------------------------------------------------------------------
  9299                                  
  9300                                  IsSFTNet:
  9301                                  	;;test	word [es:di+5],8000h
  9302                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
  9303                                  	; 16/05/2019 
  9304                                  	;test	byte [es:di+6],80h
  9305 00001264 26F6450680              	TEST	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
  9306 00001269 C3                      	retn
  9307                                  
  9308                                  ;Break	<FastInit - Initialize FastTable entries >
  9309                                  ;----------------------------------------------------------------------------
  9310                                  ;   DOS 4.00   2/9/87
  9311                                  ;   FastInit  - initialize the FASTXXX routine entry
  9312                                  ;		  in the FastTable
  9313                                  ;
  9314                                  ;   Inputs:	BX = FASTXXX ID ( 1=fastopen )
  9315                                  ;		DS:SI = address of FASTXXX routine entry
  9316                                  ;		   SI = -1 for query only
  9317                                  ;   Outputs:	Carry flag clear, if success
  9318                                  ;		Carry flag set,   if failure
  9319                                  ;
  9320                                  ;
  9321                                  ;----------------------------------------------------------------------------
  9322                                  
  9323                                  ;Procedure FastInit,NEAR
  9324                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
  9325                                  
  9326                                  ;	; MSDOS 3.3
  9327                                  ;	; IBMDOS.COM (1987) - Offset 1EB3h
  9328                                  ;FastInit:
  9329                                  ;	mov	di,FastTable ; FastOpenTable
  9330                                  ;	mov	ax,[cs:di+4]		; Entry segment
  9331                                  ;	mov	bx,cs			; get DOS segment
  9332                                  ;	cmp	ax,bx			; first time installed ?	
  9333                                  ;	je	short ok_install	; yes
  9334                                  ;	stc				; set carry
  9335                                  ;	retn				; (cf=1 means) already installed !
  9336                                  ;
  9337                                  ;ok_install:
  9338                                  ;	mov	bx,FastTable ; FastOpenTable
  9339                                  ;	mov	cx,ds
  9340                                  ;	; set address of FASTXXX (FASTOPEN) routine entry
  9341                                  ;	mov	[cs:bx+4],cx
  9342                                  ;	mov	[cs:bx+2],si
  9343                                  ;	retn
  9344                                  
  9345                                  ; 16/05/2019 - Retro DOS v4.0
  9346                                  
  9347                                  FastInit:
  9348                                  	; MSDOS 6.0
  9349                                  	;hkn; set up es to dosdataseg.
  9350 0000126A 06                      	push	es
  9351                                  	;getdseg <es>			; es -> dosdata
  9352 0000126B 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  9353                                  
  9354                                  	;hkn; FastTable is in DOSDATA
  9355 00001270 BF[320D]                	MOV	DI,FastTable+2		;AN000;FO. points to fastxxx entry
  9356 00001273 4B                      	DEC	BX			;AN000;FO.;; decrement index
  9357 00001274 89DA                    	MOV	DX,BX			;AN000;FO.;; save bx
  9358 00001276 D1E3                    	SHL	BX,1			;AN000;FO.;; times 4, each entry is DWORD
  9359 00001278 D1E3                    	SHL	BX,1			;AN000;FO.
  9360 0000127A 01DF                    	ADD	DI,BX			;AN000;FO. index to the entry
  9361 0000127C 268B4502                	MOV	AX,[ES:DI+2]		;AN000;FO. get entry segment
  9362                                  fcheck: 				;AN000;
  9363 00001280 8CC9                    	MOV	CX,CS			;AN000;FO.;; get DOS segment
  9364 00001282 39C8                    	CMP	AX,CX			;AN000;FO.;; first time installed ?
  9365 00001284 7405                    	JZ	short ok_install	;AN000;FO.;; yes
  9366 00001286 09C0                    	OR	AX,AX			;AN000;FO.;
  9367                                  	;JZ	short ok_install	;AN000;FO.;
  9368                                  	;STC				;AN000;FO.;; already installed !
  9369                                  	;JMP	SHORT FSret		;AN000;FO. set carry
  9370                                  	; 14/01/2024
  9371 00001288 F9                      	stc
  9372 00001289 7517                    	jnz	short FSret
  9373                                  ok_install:				;AN000;
  9374 0000128B 83FEFF                  	CMP	SI,-1			;AN000;FO.; Query only ?
  9375 0000128E 7412                    	JZ	short FSret		;AN000;FO.; yes
  9376 00001290 8CD9                    	MOV	CX,DS			;AN000;FO.; get FASTXXX entry segment
  9377 00001292 26894D02                	MOV	[ES:DI+2],CX		;AN000;FO.; initialize routine entry
  9378 00001296 268935                  	MOV	[ES:DI],SI		;AN000;FO.; initialize routine offset
  9379                                  
  9380                                  ;hkn; FastFlg moved to DOSDATA
  9381 00001299 BF[3A0D]                	MOV	DI,FastFlg		;AN000;FO.; get addr of FASTXXX flags
  9382 0000129C 01D7                    	ADD	DI,DX			;AN000;FO.; index to a FASTXXX flag
  9383                                  	;or	byte [es:di],80h
  9384 0000129E 26800D80                	OR	byte [ES:DI],Fast_yes	;AN000;FO.; indicate installed
  9385                                  FSret:					;AN000;
  9386 000012A2 07                      	pop	es
  9387 000012A3 C3                      	retn				;AN000;FO.
  9388                                  
  9389                                  ;EndProc FastInit
  9390                                  
  9391                                  ;Break	<FastRet - initial routine in FastOpenTable >
  9392                                  ;----------------------------------------------------------------------------
  9393                                  ;   DOS 3.3   6/10/86
  9394                                  ;   FastRet	- indicate FASTXXXX  not in memory
  9395                                  ;
  9396                                  ;   Inputs:	None
  9397                                  ;   Outputs:	AX = -1 and carry flag set
  9398                                  ;
  9399                                  ;   Registers modified: none.
  9400                                  ;----------------------------------------------------------------------------
  9401                                  
  9402                                  FastRet:
  9403                                  	;mov	ax,-1
  9404                                  	;stc
  9405                                  	;retf
  9406 000012A4 F9                      	STC
  9407 000012A5 19C0                    	sbb	ax,ax		; (ax) = -1, 'C' set
  9408 000012A7 CB                      	RETF
  9409                                  
  9410                                  ;Break	<NLS_OPEN - do $open for NLSFUNC>
  9411                                  ;----------------------------------------------------------------------------
  9412                                  ;   DOS 3.3   6/10/86
  9413                                  ;   NLS_OPEN	- call $OPEN for NLSFUNC
  9414                                  ;
  9415                                  ;   Inputs:	Same input as $OPEN except CL = mode
  9416                                  ;   Outputs:	same output as $OPEN
  9417                                  ;
  9418                                  ;----------------------------------------------------------------------------
  9419                                  
  9420                                  ;hkn; NOTE! SS MUST HAVE BEEN SET UP TO DOSDATA BY THE TIME THESE
  9421                                  ;hkn; NLS FUNCTIONS ARE CALLED!!! THERE FORE WE WILL USE SS OVERRIDES
  9422                                  ;hkn; IN ORDER TO ACCESS DOS DATA VARIABLES!
  9423                                  
  9424                                  NLS_OPEN:
  9425                                  ;	MOV	BL,[CPSWFLAG]	 ; disable code page matching logic
  9426                                  ;	MOV	BYTE [CPSWFLAG],0
  9427                                  ;	PUSH	BX		 ; save current state
  9428                                  
  9429 000012A8 88C8                    	MOV	AL,CL		 ; set up correct interface for $OPEN
  9430 000012AA E8375C                  	call	_$OPEN
  9431                                  
  9432                                  ;	POP	BX		 ; restore current state
  9433                                  ;	MOV	[CPSWFLAG],BL
  9434                                  
  9435 000012AD C3                      	RETN
  9436                                  
  9437                                  ;Break	<NLS_LSEEK - do $LSEEK for NLSFUNC>
  9438                                  ;----------------------------------------------------------------------------
  9439                                  ;   DOS 3.3   6/10/86
  9440                                  ;   NLS_LSEEK	- call $LSEEK for NLSFUNC
  9441                                  ;
  9442                                  ;   Inputs:	BP = open mode
  9443                                  ;   Outputs:	same output as $LSEEK
  9444                                  ;
  9445                                  ;----------------------------------------------------------------------------
  9446                                  
  9447                                  ; 16/05/2019 - Retro DOS v4.0
  9448                                  
  9449                                  NLS_LSEEK:
  9450 000012AE 36FF36[8405]            	PUSH	word [SS:USER_SP] ; save user stack
  9451 000012B3 36FF36[8605]            	PUSH	word [SS:USER_SS]
  9452 000012B8 E81000                  	CALL	Fake_User_Stack
  9453 000012BB 89E8                    	MOV	AX,BP		; set up correct interface for $LSEEK
  9454 000012BD E8D155                  	call	_$LSEEK
  9455 000012C0 368F06[8605]            	POP	word [SS:USER_SS] ; restore user stack
  9456 000012C5 368F06[8405]            	POP	word [SS:USER_SP]
  9457 000012CA C3                      	RETN
  9458                                  
  9459                                  ;Break	<Fake_User_Stack - save user stack>
  9460                                  ;----------------------------------------------------------------------------
  9461                                  ;   DOS 3.3   6/10/86
  9462                                  ;   Fake_User_Stack - save user stack pointer
  9463                                  ;
  9464                                  ;----------------------------------------------------------------------------
  9465                                  
  9466                                  Fake_User_Stack:
  9467 000012CB 36A1[6A0D]              	MOV	AX,[SS:USER_SP_2F] ; replace with INT 2F stack
  9468 000012CF 36A3[8405]              	MOV	[SS:USER_SP],AX
  9469 000012D3 8CD0                    	MOV	AX,SS
  9470 000012D5 36A3[8605]              	MOV	[SS:USER_SS],AX
  9471 000012D9 C3                      	RETN
  9472                                  
  9473                                  ;Break	<GetDevList - get device header list pointer>
  9474                                  ;----------------------------------------------------------------------------
  9475                                  ;   DOS 3.3   7/25/86
  9476                                  ;   GetDevList - get device header list pointer
  9477                                  ;
  9478                                  ;   Output: AX:BX points to the device header list
  9479                                  ;----------------------------------------------------------------------------
  9480                                  
  9481                                  GetDevList:
  9482                                  	; 16/05/2019 - Retro DOS v4.0
  9483 000012DA BE[280D]                	MOV	SI,SysInitTable
  9484 000012DD 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  9485 000012E2 C534                    	LDS	SI,[SI]
  9486                                  	;mov	ax,[si+34]  ; SSYSINITVARS offset 34 = [SI+SYSI.DEV]
  9487 000012E4 8B4422                  	MOV	AX,[SI+SYSI.DEV]
  9488                                  	;mov	bx,[si+36]  ; SSYSINITVARS offset 36 = [SI+SYSI.DEV+2]
  9489 000012E7 8B5C24                  	MOV	BX,[SI+SYSI.DEV+2]
  9490 000012EA C3                      	RETN
  9491                                  
  9492                                  ;Break	<NLS_IOCTL - do $IOCTL for NLSFUNC>
  9493                                  ;----------------------------------------------------------------------------
  9494                                  ;   DOS 3.3   7/25/86
  9495                                  ;   NLS_IOCTL	- call $IOCTL for NLSFUNC
  9496                                  ;
  9497                                  ;   Inputs:	BP = function code 0CH
  9498                                  ;   Outputs:	same output as generic $IOCTL
  9499                                  ;
  9500                                  ;----------------------------------------------------------------------------
  9501                                  
  9502                                  NLS_IOCTL:
  9503                                  	; 16/05/2019 - Retro DOS v4.0
  9504 000012EB 36FF36[8405]            	PUSH	word [SS:USER_SP] ; save user stack
  9505 000012F0 36FF36[8605]            	PUSH	word [SS:USER_SS]
  9506 000012F5 E8D3FF                  	CALL	Fake_User_Stack
  9507 000012F8 89E8                    	MOV	AX,BP		; set up correct interface for $IOCTL
  9508 000012FA E8830F                  	call	_$IOCTL
  9509 000012FD 368F06[8605]            	POP	word [SS:USER_SS] ; restore user stack
  9510 00001302 368F06[8405]            	POP	word [SS:USER_SP]
  9511 00001307 C3                      	RETN
  9512                                  
  9513                                  ;Break	<NLS_GETEXT- get extended error for NLSFUNC>
  9514                                  ;----------------------------------------------------------------------------
  9515                                  ;   DOS 3.3   7/25/86
  9516                                  ;   NLS_GETEXT	-
  9517                                  ;
  9518                                  ;   Inputs:	none
  9519                                  ;   Outputs:	AX = extended error
  9520                                  ;
  9521                                  ;----------------------------------------------------------------------------
  9522                                  
  9523                                  NLS_GETEXT:
  9524                                  	; 16/05/2019 - Retro DOS v4.0
  9525 00001308 36A1[2403]              	MOV	AX,[SS:EXTERR]	 ; return extended error
  9526                                  	; 23/09/2023
  9527                                  MSG_RETRIEVAL:
  9528 0000130C C3                      	RETN
  9529                                  
  9530                                  ; 29/04/2019 - Retro DOS v4.0
  9531                                  
  9532                                  ;Break	<MSG_RETRIEVAL- get beginning addr of system and parser messages>
  9533                                  
  9534                                  ;----------------------------------------------------------------------------
  9535                                  ;   DOS 4.00
  9536                                  ;
  9537                                  ;   Inputs:	DL=0 get extended error message addr
  9538                                  ;		  =1 set extended error message addr
  9539                                  ;		  =2 get parser error message addr
  9540                                  ;		  =3 set parser error message addr
  9541                                  ;		  =4 get critical error message addr
  9542                                  ;		  =5 set critical error message addr
  9543                                  ;		  =6 get file system error message addr
  9544                                  ;		  =7 set file system error message addr
  9545                                  ;		  =8 get address for code reduction
  9546                                  ;		  =9 set address for code reduction
  9547                                  ;   Function:	get/set message address
  9548                                  ;   Outputs:	ES:DI points to addr when get
  9549                                  ;----------------------------------------------------------------------------
  9550                                  
  9551                                  ;Procedure MSG_RETRIEVAL,NEAR
  9552                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
  9553                                  
  9554                                  ; 23/09/2023
  9555                                  ;MSG_RETRIEVAL:
  9556                                  
  9557                                  ;;	NOTE:  This function lives in command.com resident code now.
  9558                                  ;;	If the int 2F ever gets this far, we'll return registers
  9559                                  ;;	unchanged, which produces the same result as before, if
  9560                                  ;;	command.com wasn't present (and therefore no messages available).
  9561                                  ;;
  9562                                  ;;	I didn't point the entry in the 2F table to No_Op because
  9563                                  ;;	No_Op zeroes AL.
  9564                                  ;;
  9565                                  ;;;hkn; set up ds to point to DOSDATA
  9566                                  ;;	push	ds
  9567                                  ;;	getdseg	<ds>			; ds -> dosdata
  9568                                  ;;
  9569                                  ;;	PUSH	AX		    ;AN000;;MS. save regs
  9570                                  ;;	PUSH	SI		    ;AN000;;MS. save regs
  9571                                  ;;	MOV	AX,DX		    ;AN000;;MS.
  9572                                  ;;	MOV	SI,OFFSET DOSDATA:MSG_EXTERROR ;AN000;;MS.
  9573                                  ;;	test	AL,1		    ;AN000;;MS. get ?
  9574                                  ;;	JZ	toget		    ;AN000;;MS. yes
  9575                                  ;;	DEC	AL		    ;AN000;;MS.
  9576                                  ;;toget:				    ;AN000;
  9577                                  ;;	SHL	AL,1		    ;AN000;;MS. times 2
  9578                                  ;;	XOR	AH,AH		    ;AN000;;MS.
  9579                                  ;;	ADD	SI,AX		    ;AN000;;MS. position to the entry
  9580                                  ;;	test	DL,1		    ;AN000;;MS. get ?
  9581                                  ;;	JZ	getget			     ;AN000;;MS. yes
  9582                                  ;;	MOV	WORD PTR DS:[SI],DI    ;AN000;;MS. set MSG
  9583                                  ;;	MOV	WORD PTR DS:[SI+2],ES  ;AN000;;MS. address to ES:DI
  9584                                  ;;	JMP	SHORT MSGret		     ;AN000;;MS. exit
  9585                                  ;;getget: 				     ;AN000;
  9586                                  ;;	LES	DI,DWORD PTR DS:[SI]	     ;AN000;;MS. get msg addr
  9587                                  ;;MSGret: 				     ;AN000;
  9588                                  ;;	POP	SI			     ;AN000;;MS.
  9589                                  ;;	POP	AX			     ;AN000;;MS.
  9590                                  ;;
  9591                                  ;;	pop	ds
  9592                                  
  9593                                  ;	return				     ;AN000;;MS. exit
  9594                                  
  9595                                  ; 23/09/2023
  9596                                  ;	retn	; 29/04/2019
  9597                                  
  9598                                  ;============================================================================
  9599                                  ; ECritDisk, LCritDisk, ECritDevice, LCritDevice
  9600                                  ; IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1F36h
  9601                                  ;============================================================================
  9602                                  ; 20/07/2018 - Retro DOS v3.0
  9603                                  
  9604                                  ;	; MSDOS 3.3
  9605                                  ;	; 08/08/2018 - Retro DOS v3.0
  9606                                  ;ECritMEM:
  9607                                  ;ECritSFT:
  9608                                  ;	;
  9609                                  ;ECritDisk:
  9610                                  ;	retn
  9611                                  ;	;push	ax
  9612                                  ;	
  9613                                  ;	mov	ax,8001h
  9614                                  ;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9615                                  ;			; AL = critical section number (00h-0Fh)
  9616                                  ;	pop	ax
  9617                                  ;	retn
  9618                                  ;
  9619                                  ;	; MSDOS 3.3
  9620                                  ;	; 08/08/2018 - Retro DOS v3.0
  9621                                  ;LCritMEM:
  9622                                  ;LCritSFT:
  9623                                  ;	;
  9624                                  ;LCritDisk:
  9625                                  ;	retn
  9626                                  ;	;push	ax
  9627                                  ;	
  9628                                  ;	mov	ax,8101h
  9629                                  ;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9630                                  ;			; AL = critical section number (00h-0Fh)
  9631                                  ;	pop	ax
  9632                                  ;	retn
  9633                                  ;
  9634                                  ;ECritDevice:
  9635                                  ;	retn
  9636                                  ;	;push	ax
  9637                                  ;	
  9638                                  ;	mov	ax,8002h
  9639                                  ;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9640                                  ;			; AL = critical section number (00h-0Fh)
  9641                                  ;	pop	ax
  9642                                  ;	retn
  9643                                  ;
  9644                                  ;LCritDevice:
  9645                                  ;	retn
  9646                                  ;	;push	ax
  9647                                  ;	
  9648                                  ;	mov	ax,8102h
  9649                                  ;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9650                                  ;			; AL = critical section number (00h-0Fh)
  9651                                  ;	pop	ax
  9652                                  ;	retn
  9653                                  
  9654                                  ;============================================================================
  9655                                  ; CRIT.ASM, MSDOS 6.0, 1991
  9656                                  ;============================================================================
  9657                                  ; 12/05/2019 - Retro DOS v4.0
  9658                                  
  9659                                  ; Critical Section Routines
  9660                                  
  9661                                  ; MSDOS 6.21 - MSDOS.SYS - DOSCODE:513Ah
  9662                                  
  9663                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  9664                                  ; DOSCODE:5126h (MSDOS 5.0 MSDOS.SYS)
  9665                                  
  9666                                  ; ---------------------------------------------------------------------------
  9667                                  ; Each handler must leave everything untouched; including flags!
  9668                                  ;
  9669                                  ; Sleaze for time savings: first instruction is a return. This is patched
  9670                                  ; by the sharer to be a PUSH AX to complete the correct routines.
  9671                                  ; ---------------------------------------------------------------------------
  9672                                  
  9673                                  ; (DOSMAC.INC, MSDOS 6.0, 1991)
  9674                                  ; ---------------------------------------------------------------------------
  9675                                  ; Some old versions of the 80286 have a bug in the chip. The popf instruction
  9676                                  ; will enable interrupts. Therefore in a section of code with interrupts
  9677                                  ; disabled and you need a popf instruction use the 'popff' macro instead.
  9678                                  ; ---------------------------------------------------------------------------
  9679                                  
  9680                                  ;%macro POPFF 0
  9681                                  ;	jmp	$+3
  9682                                  ;	iret
  9683                                  ;	push	cs
  9684                                  ;	call	$-2
  9685                                  ;%endmacro
  9686                                  
  9687                                  ; ---------------------------
  9688                                  
  9689                                  ;Procedure  ECritDisk,NEAR
  9690                                  	;public  ECritMEM
  9691                                  	;public  ECritSFT
  9692                                  ECritMEM:
  9693                                  ECritSFT:
  9694                                  ;
  9695                                  ECritDisk:
  9696                                  
  9697                                  ;SR; Check if critical section is to be entered
  9698                                  
  9699 0000130D 9C                      	pushf
  9700 0000130E 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9701 00001314 740D                    	jz	short ECritDisk_2
  9702                                  
  9703                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9704                                  ;	;popff  ; * (macro)
  9705                                  ;	jmp	short ECritDisk_1 ; *
  9706                                  ;
  9707                                  ;ECritDisk_iret: ; *
  9708                                  ;	iret ; *
  9709                                  
  9710                                  	; 16/12/2022
  9711                                  	; 13/11/2022
  9712                                  	;jmp	short ECritDisk_1
  9713                                  	; 06/11/2022
  9714                                  ;ECritDisk_iret:
  9715                                  ;	iret	
  9716                                  
  9717                                  	; 06/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9718                                  ECritDisk_1:
  9719 00001316 0E                      	push	cs ; *
  9720 00001317 E80800                  	call	ECritDisk_iret ; *		
  9721                                  	
  9722                                  ECritDisk_0:
  9723 0000131A 50                      	PUSH    AX
  9724                                  	;MOV	AX,8000h+critDisk
  9725                                  	;INT	int_IBM
  9726 0000131B B80180                  	mov	ax,8001h
  9727 0000131E CD2A                    	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9728                                  			; AL = critical section number (00h-0Fh)
  9729 00001320 58                      	POP     AX
  9730 00001321 C3                      	retn
  9731                                  
  9732                                  	; 16/12/2022
  9733                                  	; 13/11/2022
  9734                                  ECritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0
  9735                                  LCritDisk_iret: 
  9736 00001322 CF                      	iret
  9737                                  
  9738                                  ECritDisk_2:
  9739                                  	;;popff ; *
  9740                                  	;;retn
  9741                                  ;	jmp	short ECritDisk_3 ; *
  9742                                  ;ECritDisk_iret2: ; *
  9743                                  ;	iret
  9744                                  	
  9745                                  	; 16/12/2022
  9746                                  	; 13/11/2022
  9747                                  	;jmp	short ECritDisk_3
  9748                                  ;ECritDisk_iret2:
  9749                                  	;iret
  9750                                  
  9751                                  ECritDisk_3:
  9752 00001323 0E                      	push    cs ; *
  9753                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9754                                  	;call	ECritDisk_iret2 ; *
  9755                                  	;retn
  9756                                  	; 16/12/2022
  9757 00001324 E8FBFF                  	call	ECritDisk_iret
  9758 00001327 C3                      	retn
  9759                                  
  9760                                  ;EndProc ECritDisk
  9761                                  
  9762                                  ; ---------------------------
  9763                                  
  9764                                  ;Procedure   LCritDisk,NEAR
  9765                                  	;public  LCritMEM
  9766                                  	;public  LCritSFT
  9767                                  LCritMEM:
  9768                                  LCritSFT:
  9769                                  ;
  9770                                  LCritDisk:
  9771                                  
  9772                                  ;SR; Check if critical section is to be entered
  9773                                  
  9774 00001328 9C                      	pushf
  9775 00001329 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9776 0000132F 740C                    	jz	short LCritDisk_2
  9777                                  	;popff  ; * (macro)
  9778                                  ;	jmp	short LCritDisk_1 ; *
  9779                                  ;
  9780                                  ;LCritDisk_iret: ; *
  9781                                  ;	iret ; *
  9782                                  
  9783                                  	; 16/12/2022
  9784                                  	; 13/11/2022
  9785                                  	;jmp	short LCritDisk_1
  9786                                  ;LCritDisk_iret:
  9787                                  	;iret
  9788                                  
  9789                                  LCritDisk_1:
  9790 00001331 0E                      	push	cs ; *
  9791 00001332 E8EDFF                  	call	LCritDisk_iret ; *		
  9792                                  	
  9793                                  LCritDisk_0:
  9794 00001335 50                      	PUSH	AX
  9795                                  	;MOV	AX,8100h+critDisk
  9796                                  	;INT	int_IBM
  9797 00001336 B80181                  	mov	ax,8101h
  9798 00001339 CD2A                    	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9799                                  			; AL = critical section number (00h-0Fh)
  9800 0000133B 58                      	POP	AX
  9801 0000133C C3                      	retn
  9802                                  
  9803                                  ;LCritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0 
  9804                                  ;	iret
  9805                                  
  9806                                  LCritDisk_2:
  9807                                  	;;popff ; *
  9808                                  	;;retn
  9809                                  ;	jmp	short LCritDisk_3 ; *
  9810                                  ;LCritDisk_iret2: ; *
  9811                                  ;	iret
  9812                                  
  9813                                  	; 16/12/2022
  9814                                  	; 13/11/2022
  9815                                  	;jmp	short LCritDisk_3
  9816                                  ;LCritDisk_iret2:
  9817                                  	;iret
  9818                                  
  9819                                  LCritDisk_3:
  9820 0000133D 0E                      	push    cs ; *
  9821                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9822                                  	;call	LCritDisk_iret2 ; *
  9823                                  	;retn
  9824                                  	; 16/12/2022
  9825 0000133E E8E1FF                  	call	LCritDisk_iret
  9826 00001341 C3                      	retn
  9827                                  
  9828                                  ;EndProc LCritDisk
  9829                                  
  9830                                  ; ---------------------------
  9831                                  
  9832                                  ;Procedure   ECritDevice,NEAR
  9833                                  
  9834                                  ECritDevice:
  9835                                  
  9836                                  ;SR; Check if critical section is to be entered
  9837                                  
  9838 00001342 9C                      	pushf
  9839 00001343 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9840 00001349 740D                    	jz	short ECritDevice_2
  9841                                  	;popff  ; * (macro)
  9842                                  ;	jmp	short ECritDevice_1 ; *
  9843                                  ;
  9844                                  ;ECritDevice_iret: ; *
  9845                                  ;	iret ; *
  9846                                  
  9847                                  	; 16/12/2022	
  9848                                  	; 13/11/2022
  9849                                  	;jmp	short ECritDevice_1
  9850                                  ;ECritDevice_iret:
  9851                                  	;iret
  9852                                  
  9853                                  ECritDevice_1:
  9854 0000134B 0E                      	push	cs ; *
  9855 0000134C E80800                  	call	ECritDevice_iret ; *		
  9856                                  	
  9857                                  ECritDevice_0:
  9858 0000134F 50                      	PUSH	AX
  9859                                  	;MOV	AX,8000h+critDevice
  9860                                  	;INT	int_IBM
  9861 00001350 B80280                  	mov	ax,8002h
  9862 00001353 CD2A                    	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9863                                  			; AL = critical section number (00h-0Fh)
  9864 00001355 58                      	POP     AX
  9865 00001356 C3                      	retn
  9866                                  
  9867                                  	; 16/12/2022
  9868                                  	; 06/12/2022
  9869                                  ECritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0
  9870                                  LCritDevice_iret: 
  9871 00001357 CF                      	iret
  9872                                  
  9873                                  ECritDevice_2:
  9874                                  	;;popff ; *
  9875                                  	;;retn
  9876                                  ;	jmp	short ECritDevice_3 ; *
  9877                                  ;ECritDevice_iret2: ; *
  9878                                  ;	iret
  9879                                  
  9880                                  	; 16/12/2022
  9881                                  	; 13/11/2022
  9882                                  	;jmp	short ECritDevice_3
  9883                                  ;ECritDevice_iret2:
  9884                                  	;iret
  9885                                  
  9886                                  ECritDevice_3:
  9887 00001358 0E                      	push    cs ; *
  9888                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9889                                  	;call	ECritDevice_iret2 ; *
  9890                                  	;retn
  9891                                  	; 16/12/2022
  9892 00001359 E8FBFF                  	call	ECritDevice_iret
  9893 0000135C C3                      	retn
  9894                                  
  9895                                  ;EndProc ECritDevice
  9896                                  
  9897                                  ; ---------------------------
  9898                                  
  9899                                  ;Procedure   LCritDevice,NEAR
  9900                                  
  9901                                  LCritDevice:
  9902                                  
  9903                                  ;SR; Check if critical section is to be entered
  9904                                  
  9905 0000135D 9C                      	pushf
  9906 0000135E 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9907 00001364 740C                    	jz	short LCritDevice_2
  9908                                  	;popff  ; * (macro)
  9909                                  ;	jmp	short LCritDevice_1 ; *
  9910                                  ;
  9911                                  ;LCritDevice_iret: ; *
  9912                                  ;	iret ; *
  9913                                  
  9914                                  	; 16/12/2022
  9915                                  	; 13/11/2022
  9916                                  	;jmp	short LCritDevice_1
  9917                                  ;LCritDevice_iret:
  9918                                  	;iret
  9919                                  
  9920                                  LCritDevice_1:
  9921 00001366 0E                      	push	cs ; *
  9922 00001367 E8EDFF                  	call	LCritDevice_iret ; *		
  9923                                  	
  9924                                  LCritDevice_0:
  9925 0000136A 50                      	PUSH	AX
  9926                                  	;MOV	AX,8100h+critDevice
  9927                                  	;INT	int_IBM
  9928 0000136B B80281                  	mov	ax,8102h
  9929 0000136E CD2A                    	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9930                                  			; AL = critical section number (00h-0Fh)
  9931 00001370 58                      	POP     AX
  9932 00001371 C3                      	retn
  9933                                  
  9934                                  ;LCritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0 
  9935                                  ;	iret
  9936                                  
  9937                                  LCritDevice_2:
  9938                                  	;;popff ; *
  9939                                  	;;retn
  9940                                  ;	jmp	short LCritDevice_3 ; *
  9941                                  ;LCritDevice_iret2: ; *
  9942                                  ;	iret
  9943                                  
  9944                                  	; 16/12/2022
  9945                                  	; 13/11/2022
  9946                                  	;jmp	short LCritDevice_3
  9947                                  ;LCritDevice_iret2:
  9948                                  	;iret
  9949                                  
  9950                                  LCritDevice_3:
  9951 00001372 0E                      	push    cs ; *
  9952                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9953                                  	;call	LCritDevice_iret2 ; *
  9954                                  	;retn
  9955                                  	; 16/12/2022
  9956 00001373 E8E1FF                  	call	LCritDevice_iret
  9957 00001376 C3                      	retn
  9958                                  
  9959                                  ;EndProc LCritDevice
  9960                                  
  9961                                  ;============================================================================
  9962                                  ; CPMIO.ASM, MSDOS 6.0, 1991
  9963                                  ;============================================================================
  9964                                  ; 20/07/2018 - Retro DOS v3.0
  9965                                  
  9966                                  ;============================================================================
  9967                                  ; STDIO.ASM - (MSDOS 2.0)
  9968                                  ;============================================================================
  9969                                  
  9970                                  ;
  9971                                  ; Standard device IO for MSDOS (first 12 function calls)
  9972                                  ;
  9973                                  
  9974                                  ;.xlist
  9975                                  ;.xcref
  9976                                  ;INCLUDE STDSW.ASM
  9977                                  ;INCLUDE DOSSEG.ASM
  9978                                  ;.cref
  9979                                  ;.list
  9980                                  
  9981                                  ;TITLE   STDIO - device IO for MSDOS
  9982                                  ;NAME    STDIO
  9983                                  
  9984                                  ;INCLUDE IO.ASM
  9985                                  
  9986                                  ; ---------------------------------------------------------------------------
  9987                                  ;
  9988                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
  9989                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
  9990                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
  9991                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
  9992                                  ;			    to restore MSDOS 2.0 device IO source code 
  9993                                  ;
  9994                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)	
  9995                                  	
  9996                                  ;============================================================================
  9997                                  ; STDIO.ASM - (MSDOS 2.0)
  9998                                  ;============================================================================
  9999                                  
 10000                                  ;
 10001                                  ; Standard device IO for MSDOS (first 12 function calls)
 10002                                  ;
 10003                                  
 10004                                  ;.xlist
 10005                                  ;.xcref
 10006                                  ;INCLUDE STDSW.ASM
 10007                                  ;INCLUDE DOSSEG.ASM
 10008                                  ;.cref
 10009                                  ;.list
 10010                                  
 10011                                  ;TITLE   STDIO - device IO for MSDOS
 10012                                  ;NAME    STDIO
 10013                                  
 10014                                  ;INCLUDE IO.ASM
 10015                                  
 10016                                  ; ---------------------------------------------------------------------------
 10017                                  ;
 10018                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
 10019                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
 10020                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
 10021                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
 10022                                  ;			    to restore MSDOS 2.0 device IO source code 
 10023                                  ;
 10024                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)		
 10025                                  ;
 10026                                  ;============================================================================
 10027                                  ; IO.ASM (MSDOS 2.0) (IBMDOS.COM 2.0) - STRIN.ASM (MSDOS 2.0, 19/08/1983)
 10028                                  ;============================================================================
 10029                                  ; Retro DOS v2.0 by Erdogan Tan, 13/03/2018 - 14/03/2018
 10030                                  
 10031                                  ; (Disassembled code of IBMDOS.COM, 08/03/1983) - Dissassembler: IDA Pro Free
 10032                                  ; (Comments are from CPMIO.ASM - 1991, MSDOS 6.0) 
 10033                                  
 10034                                  ;============================================================================
 10035                                  ; CPMIO.ASM (MSDOS 6.0, 1991)
 10036                                  ;============================================================================
 10037                                  ; Retro DOS v4.0 by Erdogan Tan, 04/05/2019
 10038                                  
 10039                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10040                                  
 10041                                  ;**	Standard device IO for MSDOS (first 12 function calls)
 10042                                  ;
 10043                                  ;	TITLE	IBMCPMIO - device IO for MSDOS
 10044                                  ;	NAME	IBMCPMIO
 10045                                  
 10046                                  ;	Old style CP/M 1-12 system calls to talk to reserved devices
 10047                                  ;
 10048                                  ;	$Std_Con_Input_No_Echo
 10049                                  ;	$Std_Con_String_Output
 10050                                  ;	$Std_Con_String_Input
 10051                                  ;	$RawConIO
 10052                                  ;	$RawConInput
 10053                                  ;	RAWOUT
 10054                                  ;	RAWOUT2
 10055                                  ;
 10056                                  
 10057                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
 10058                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
 10059                                  ; references to be SS or CS relative which is desired.
 10060                                  
 10061                                  ; ---------------------------------------------------------------------------
 10062                                  
 10063                                  ;	TITLE	CPMIO2 - device IO for MSDOS
 10064                                  ;	NAME	CPMIO2
 10065                                  
 10066                                  ;
 10067                                  ;	Microsoft Confidential
 10068                                  ;	Copyright (C) Microsoft Corporation 1991
 10069                                  ;	All Rights Reserved.
 10070                                  ;
 10071                                  
 10072                                  ;**	Old style CP/M 1-12 system calls to talk to reserved devices
 10073                                  ;
 10074                                  ;	$Std_Con_Input
 10075                                  ;	$Std_Con_Output
 10076                                  ;	OUTT
 10077                                  ;	TAB
 10078                                  ;	BUFOUT
 10079                                  ;	$Std_Aux_Input
 10080                                  ;	$Std_Aux_Output
 10081                                  ;	$Std_Printer_Output
 10082                                  ;	$Std_Con_Input_Status
 10083                                  ;	$Std_Con_Input_Flush
 10084                                  ;
 10085                                  ;	Revision History:
 10086                                  ;
 10087                                  ;	  AN000	 version 4.00 - Jan. 1988
 10088                                  
 10089                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
 10090                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
 10091                                  ; references to be SS or CS relative which is desired.
 10092                                  
 10093                                  ;DOSCODE SEGMENT
 10094                                  ;	ASSUME	SS:DOSDATA,CS:DOSCODE
 10095                                  
 10096                                  
 10097                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
 10098                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
 10099                                  ;hkn;	not valid. 
 10100                                  
 10101                                  ; DOSCODE:51BAh (MSDOS 6.21, MSDOS.SYS)
 10102                                  ; 08/11/2022
 10103                                  ; DOSCODE:51A6h (MSDOS 5.0, MSDOS.SYS)
 10104                                  
 10105                                  ;
 10106                                  ;----------------------------------------------------------------------------
 10107                                  ;
 10108                                  ; Procedure : $Std_Con_Input_No_Echo
 10109                                  ;
 10110                                  ;----------------------------------------------------------------------------
 10111                                  ;
 10112                                  
 10113                                  _$STD_CON_INPUT_NO_ECHO:   ;System call 8
 10114                                  
 10115                                  ; Inputs:
 10116                                  ;	None
 10117                                  ; Function:
 10118                                  ;	Input character from console, no echo
 10119                                  ; Returns:
 10120                                  ;	AL = character
 10121                                  
 10122 00001377 1E                      	push	ds
 10123 00001378 56                      	push	si
 10124                                  INTEST:
 10125 00001379 E8F03D                  	call	STATCHK
 10126 0000137C 753B                    	jnz	short GET ; 08/09/2018
 10127                                  ;*************************************************************************
 10128                                  ;hkn; SS override
 10129 0000137E 36803E[A00A]00          	cmp	byte [SS:PRINTER_FLAG],0  ; is printer idle?
 10130 00001384 7505                    	jnz	short no_sys_wait
 10131 00001386 B405                    	mov	ah,5			; get input status with system wait
 10132 00001388 E81831                  	call	IOFUNC
 10133                                  no_sys_wait:
 10134                                  ;**************************************************************************
 10135 0000138B B484                    	MOV	AH,84h
 10136 0000138D CD2A                    	INT	int_IBM	 ; int 2Ah
 10137                                  
 10138                                  ;;; 7/15/86  update the date in the idle loop
 10139                                  ;;; Dec 19, 1986 D.C.L. changed following CMP to Byte Ptr from Word Ptr
 10140                                  ;;;;		 to shorten loop in consideration of the PC Convertible
 10141                                  
 10142                                  ;hkn; SS override
 10143 0000138F 36803E[910D]FF          	CMP	byte [SS:DATE_FLAG],-1	; date is updated may be every
 10144 00001395 751B                    	JNZ	short NoUpdate		; 65535 x ? ms if no one calls
 10145                                  
 10146 00001397 50                      	PUSH	AX
 10147 00001398 53                      	PUSH	BX			; following is tricky,
 10148 00001399 51                      	PUSH	CX			; it may be called by critical handler
 10149 0000139A 52                      	PUSH	DX			; at that time, DEVCALL is used by
 10150                                  					; other's READ or WRITE
 10151 0000139B 1E                      	PUSH	DS			; save DS = SFT's segment
 10152                                  
 10153                                  ;hkn; READTIME must use ds = DOSDATA
 10154                                  ;hkn;	PUSH	CS			; READTIME must use DS=CS
 10155                                  
 10156 0000139C 16                      	PUSH	SS ; 04/05/2019
 10157 0000139D 1F                      	POP	DS
 10158                                  
 10159 0000139E B80000                  	MOV	AX,0			; therefore, we save DEVCALL
 10160 000013A1 E89102                  	CALL	Save_Restore_Packet	; save DEVCALL packet
 10161                                  	;invoke	READTIME		; readtime
 10162 000013A4 E873F7                  	call	READTIME
 10163 000013A7 B80100                  	MOV	AX,1
 10164 000013AA E88802                  	CALL	Save_Restore_Packet	; restore DEVCALL packet
 10165                                  
 10166                                  ;	; MSDOS 3.3 (IBMDOS.COM, Offset 1F8Ch)
 10167                                  ;	; (MSDOS 6.0 code does not contain IBM DOS FETCHI_TAG check)
 10168                                  ;	push	bx
 10169                                  ;	mov	bx,DATE_FLAG
 10170                                  ;	add	bx,2  ; mov bx,FETCHI_FLAG
 10171                                  ;	cmp	word [cs:bx],5872h
 10172                                  ;	jz	short FETCHI_TAG_chk_ok
 10173                                  ;	call	DOSINIT
 10174                                  ;FETCHI_TAG_chk_ok:
 10175                                  ;	pop	bx
 10176                                  
 10177 000013AD 1F                      	POP	DS			; restore DS
 10178 000013AE 5A                      	POP	DX
 10179 000013AF 59                      	POP	CX
 10180 000013B0 5B                      	POP	BX
 10181 000013B1 58                      	POP	AX
 10182                                  NoUpdate:
 10183                                  
 10184                                  ;hkn; SS override
 10185 000013B2 36FF06[910D]            	INC	word [SS:DATE_FLAG]
 10186                                  
 10187                                  ;;; 7/15/86 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 10188 000013B7 EBC0                    	JMP	short INTEST
 10189                                  GET:
 10190 000013B9 30E4                    	XOR	AH,AH
 10191 000013BB E8E530                  	call	IOFUNC
 10192 000013BE 5E                      	POP	SI
 10193 000013BF 1F                      	POP	DS
 10194                                  ;;; 7/15/86
 10195                                  
 10196                                  ;hkn; SS override
 10197                                  	; MSDOS 6.0
 10198 000013C0 36C606[900D]00          	MOV	BYTE [SS:SCAN_FLAG],0
 10199                                  	;
 10200 000013C6 3C00                    	CMP	AL,0	    ; extended code ( AL )
 10201 000013C8 7505                    	JNZ	short noscan
 10202                                  
 10203                                  ;hkn; SS override
 10204                                  	;MOV	BYTE [SS:SCAN_FLAG],1 ; set this flag for ALT_Q key
 10205                                  	; 20/06/2023
 10206 000013CA 36FE06[900D]            	inc	byte [SS:SCAN_FLAG]
 10207                                  noscan:
 10208 000013CF C3                      	retn
 10209                                  ;
 10210                                  ;----------------------------------------------------------------------------
 10211                                  ;
 10212                                  ;**	$STD_CON_STRING_OUTPUT - Console String Output
 10213                                  ;
 10214                                  ;
 10215                                  ;	ENTRY	(DS:DX) Point to output string '$' terminated
 10216                                  ;	EXIT	none
 10217                                  ;	USES	ALL
 10218                                  ;
 10219                                  ;----------------------------------------------------------------------------
 10220                                  ;
 10221                                  
 10222                                  _$STD_CON_STRING_OUTPUT:	;System call 9
 10223                                  
 10224 000013D0 89D6                    	mov	si,dx
 10225                                  STRING_OUT1:	
 10226 000013D2 AC                      	lodsb
 10227 000013D3 3C24                    	cmp	al,'$'
 10228 000013D5 74F8                    	je	short noscan
 10229                                  NEXT_STR1:
 10230 000013D7 E88702                  	call	OUTT
 10231 000013DA EBF6                    	jmp	short STRING_OUT1
 10232                                  
 10233                                  ;----------------------------------------------------------------------------
 10234                                  ;
 10235                                  ;**	$STD_CON_STRING_INPUT - Input Line from Console
 10236                                  ;
 10237                                  ;	$STD_CON_STRING_INPUT Fills a buffer from console input until CR
 10238                                  ;
 10239                                  ;	ENTRY	(ds:dx) = input buffer
 10240                                  ;	EXIT	none
 10241                                  ;	USES	ALL
 10242                                  ;
 10243                                  ;----------------------------------------------------------------------------
 10244                                  
 10245                                  	; 15/01/2024
 10246                                  
 10247                                  _$STD_CON_STRING_INPUT:		;System call 10
 10248                                  
 10249                                  	; 15/01/2024
 10250                                  	;mov	ax,ss
 10251                                  	;mov	es,ax
 10252 000013DC 16                      	push	ss
 10253 000013DD 07                      	pop	es
 10254                                  
 10255 000013DE 89D6                    	mov	si,dx
 10256 000013E0 30ED                    	xor	ch,ch
 10257 000013E2 AD                      	lodsw
 10258                                  
 10259                                  ;	(AL) = the buffer length
 10260                                  ;	(AH) = the template length
 10261                                  
 10262 000013E3 08C0                            or	al,al
 10263 000013E5 74E8                            jz	short noscan	;Buffer is 0 length!!?
 10264 000013E7 88E3                    	mov	bl,ah		;Init template counter
 10265 000013E9 88EF                            mov	bh,ch		;Init template counter
 10266                                  
 10267                                  ;	(BL) = the number of bytes in the template
 10268                                  
 10269 000013EB 38D8                            cmp	al,bl
 10270 000013ED 7605                            jbe	short NOEDIT	;If length of buffer inconsistent with contents
 10271 000013EF 80380D                          cmp	byte [bx+si],c_CR ; 0Dh
 10272 000013F2 7402                            jz	short EDITON	;If CR correctly placed EDIT is OK
 10273                                  
 10274                                  ; The number of chars in the template is >= the number of chars in buffer or
 10275                                  ; there is no CR at the end of the template. This is an inconsistant state
 10276                                  ; of affairs. Pretend that the template was empty:
 10277                                  ;
 10278                                  
 10279                                  NOEDIT:	
 10280 000013F4 88EB                    	mov	bl,ch		;Reset buffer
 10281                                  EDITON: 
 10282 000013F6 88C2                    	mov	dl,al
 10283 000013F8 4A                      	dec	dx		;DL is # of bytes we can put in the buffer
 10284                                  
 10285                                  ;	Top level. We begin to read a line in.
 10286                                  
 10287                                  NEWLIN: 
 10288 000013F9 36A0[F901]              	mov	al,[SS:CARPOS]
 10289 000013FD 36A2[FA01]              	mov	[SS:STARTPOS],al ;Remember position in raw buffer
 10290                                  
 10291 00001401 56                      	push	si
 10292 00001402 BF[FB01]                	mov	di,INBUF ;Build the new line here
 10293 00001405 36882E[7905]            	mov	byte [SS:INSMODE],ch ;Insert mode off
 10294 0000140A 88EF                    	mov	bh,ch		;No chars from template yet
 10295 0000140C 88EE                    	mov	dh,ch		;No chars to new line yet
 10296 0000140E E866FF                  	call	_$STD_CON_INPUT_NO_ECHO ;Get first char
 10297 00001411 3C0A                    	cmp	al,c_LF		; 0Ah	;Linefeed 
 10298 00001413 7503                    	jnz	short GOTCH
 10299                                  
 10300                                  ;	This is the main loop of reading in a character and processing it.
 10301                                  ;
 10302                                  ;	(BH) = the index of the next byte in the template
 10303                                  ;	(BL) = the length of the template
 10304                                  ;	(DH) = the number of bytes in the buffer
 10305                                  ;	(DL) = the length of the buffer
 10306                                  
 10307                                  GETCH:
 10308 00001415 E85FFF                  	call	_$STD_CON_INPUT_NO_ECHO
 10309                                  GOTCH:
 10310                                  ;
 10311                                  ; Brain-damaged Tim Patterson ignored ^F in case his BIOS did not flush the
 10312                                  ; input queue.
 10313                                  ;
 10314 00001418 3C06                            cmp	al,"F"-"@"  ; CMP AL, 6  ; Ignore ^F
 10315 0000141A 74F9                    	jz	short GETCH
 10316                                  
 10317                                  ;	If the leading char is the function-key lead byte
 10318                                  
 10319                                  	;cmp	al,[SS:ESCCHAR]
 10320                                  
 10321                                  	; 04/05/2019 - Retro DOS v4.0
 10322                                  
 10323                                  ;hkn; 	ESCCHAR is in TABLE seg (DOSCODE)
 10324                                  
 10325 0000141C 2E3A06[1A0A]            	CMP	AL,[cs:ESCCHAR]
 10326 00001421 7439                            jz	short ESCAPE	;change reserved keyword DBM 5-7-87
 10327                                  
 10328                                  ;	Rubout and ^H are both destructive backspaces.
 10329                                  
 10330 00001423 3C7F                            cmp	al,c_DEL ; 7FH
 10331                                          ;jz	short BACKSPJ
 10332                                          ; 15/01/2024
 10333 00001425 7466                    	je	short BACKSP
 10334 00001427 3C08                    	cmp	al,c_BS  ; 8
 10335                                          ;jz	short BACKSPJ
 10336                                          ; 15/01/2024
 10337 00001429 7462                    	je	short BACKSP
 10338                                  
 10339                                  	; 04/05/2019 -	MSDOS 6.0, also MSDOS 6.21 has bug (bullshit) here. 
 10340                                  	;		Two NOPs -instead of a JMP short, as two bytes-
 10341                                  	;	   	after CMP and a CMP again!
 10342                                  	;		
 10343                                  	;		-It would be better if they use a 'JMP short' to 
 10344                                  	;	      	DOSCODE:5279h from DOSCODE:5271h and leave NOPs
 10345                                  	;		between them. Then, they would be able use a patch
 10346                                  	;		between 5271h and 5279h when if it will be required.
 10347                                  	;		I think Tim Patterson would not do this CMP mistake!-
 10348                                  	;	
 10349                                  	; (MSDOS.SYS, from DOSCODE:5271h to DOSCODE:5279h)
 10350                                  
 10351                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10352                                  	;
 10353                                  	; (Note: nops below might be used for patching code for Windows 3.1)
 10354                                  
 10355                                  ;DOSCODE:526D	cmp     al, 8
 10356                                  ;DOSCODE:526F	jz      short BACKSPJ
 10357                                  ;DOSCODE:5271	cmp     al, 17h
 10358                                  ;DOSCODE:5273	nop
 10359                                  ;DOSCODE:5274	nop
 10360                                  ;DOSCODE:5275	cmp     al, 15h
 10361                                  ;DOSCODE:5277	nop
 10362                                  ;DOSCODE:5278	nop
 10363                                  ;DOSCODE:5279	cmp     al, 0Dh
 10364                                  ;DOSCODE:527B	jz      short ENDLIN
 10365                                  ;DOSCODE:527D	cmp     al, 0Ah
 10366                                  ;DOSCODE:527F	jz      short PHYCRLF
 10367                                  	
 10368                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10369                                  	; DOSCODE:525Dh
 10370                                  
 10371                                  ; 16/12/2022
 10372                                  %if 0
 10373                                  	; MSDOS 6.0
 10374                                  ;	^W deletes backward once and then backs up until a letter is before the
 10375                                  ;	cursor
 10376                                  
 10377                                  	CMP     AL,"W"-"@" ; 17h
 10378                                  
 10379                                  ;	The removal of the comment characters before the jump statement will
 10380                                  ;	cause ^W to backup a word.
 10381                                  
 10382                                  ;***	JZ	short WordDel
 10383                                  	NOP
 10384                                  	NOP
 10385                                  
 10386                                  	CMP     AL,"U"-"@" ; 15h
 10387                                  
 10388                                  ;	The removal of the comment characters before the jump statement will
 10389                                  ;	cause ^U to clear a line.
 10390                                  
 10391                                  ;***	JZ	short LineDel
 10392                                  	NOP
 10393                                  	NOP
 10394                                  
 10395                                  %endif
 10396                                  
 10397                                  ;	CR terminates the line.
 10398                                  
 10399 0000142B 3C0D                            cmp	al,c_CR ; 0Dh
 10400 0000142D 7430                            jz	short ENDLIN
 10401                                  
 10402                                  ;	LF goes to a new line and keeps on reading.
 10403                                  
 10404 0000142F 3C0A                            cmp	al,c_LF ; 0Ah
 10405 00001431 7442                    	jz	short PHYCRLF
 10406                                  
 10407                                  ;	^X (or ESC) deletes the line and starts over
 10408                                  
 10409                                  	; MSDOS 3.3
 10410                                  	;cmp	al,[ss:CANCHAR] ; 1Bh
 10411                                  	;jz	short KILNEW
 10412                                  
 10413                                  	; MSDOS 6.0 (& MSDOS 6.21)
 10414                                  
 10415                                  ;hkn; 	CANCHAR is in TABLE seg (DOSCODE), so CS override
 10416                                  
 10417 00001433 2E3A06[190A]            	cmp	al,[cs:CANCHAR] ; 1Bh
 10418 00001438 7440                    	jz	short KILNEW
 10419                                  	
 10420                                  	;cmp	al,CANCEL ; 1Bh	; Retro DOS v3.0
 10421                                  	;jz	short KILNEW
 10422                                  
 10423                                  ; Otherwise, we save the input character.
 10424                                  
 10425                                  SAVCH:	
 10426 0000143A 38D6                    	cmp	dh,dl
 10427 0000143C 7317                    	jnb	short BUFFUL		; buffer is full.
 10428 0000143E AA                              stosb
 10429 0000143F FEC6                    	inc	dh                      ; increment count in buffer.
 10430 00001441 E8B102                  	call	BUFOUT			; Print control chars nicely
 10431                                  
 10432 00001444 36803E[7905]00                  cmp	byte [SS:INSMODE], 0
 10433 0000144A 75C9                    	jnz	short GETCH		; insertmode => don't advance template
 10434 0000144C 38DF                            cmp	bh,bl
 10435 0000144E 73C5                            jnb	short GETCH		; no more characters in template
 10436 00001450 46                              inc	si                      ; Skip to next char in template
 10437 00001451 FEC7                            inc	bh                      ; remember position in template
 10438 00001453 EBC0                            jmp	short GETCH
 10439                                  
 10440                                  	; 15/01/2024
 10441                                  ;BACKSPJ: 
 10442                                  	;jmp	short BACKSP
 10443                                  
 10444                                  BUFFUL: 
 10445 00001455 B007                    	mov	al, 7			; Bell to signal full buffer
 10446 00001457 E80702                  	call	OUTT
 10447 0000145A EBB9                    	jmp	short GETCH
 10448                                  
 10449                                  ESCAPE: 
 10450                                  	;transfer OEMFunctionKey
 10451 0000145C E9E6F5                  	JMP	OEMFunctionKey		; let the OEM's handle the key dispatch
 10452                                  
 10453                                  ENDLIN:
 10454 0000145F AA                              stosb				; Put the CR in the buffer
 10455 00001460 E8FE01                  	call	OUTT                    ; Echo it
 10456 00001463 5F                              pop	di                      ; Get start of user buffer
 10457 00001464 8875FF                          mov	[di-1], dh		; Tell user how many bytes
 10458 00001467 FEC6                            inc	dh			; DH is length including CR
 10459                                  
 10460                                  COPYNEW:
 10461                                  	; (IBMDOS.COM, MSDOS 2.0, STRIN.ASM)
 10462                                  	;mov	bp, es
 10463                                  	;mov	bx, ds
 10464                                  	;mov	es, bx
 10465                                  	;mov	ds, bp
 10466                                  	;mov	si, INBUF
 10467                                  	;mov	cl, dh
 10468                                  	;rep	movsb
 10469                                  	;retn
 10470                                  
 10471                                  	; CPMIO.ASM (MSDOS 6.0)
 10472                                  	; (IBMDOS.COM, MSDOS 3.3, Offset 2061h) 
 10473                                  	;SAVE	<DS,ES>
 10474 00001469 1E                      	PUSH	DS
 10475 0000146A 06                      	PUSH	ES
 10476                                  	;RESTORE <DS,ES>		; XCHG ES,DS
 10477 0000146B 1F                      	POP	DS
 10478 0000146C 07                      	POP	ES
 10479                                  
 10480                                  ;;hkn; INBUF is in DOSDATA
 10481 0000146D BE[FB01]                        MOV     SI,INBUF
 10482 00001470 88F1                            MOV     CL,DH                   ; set up count
 10483 00001472 F3A4                            REP     MOVSB                   ; Copy final line to user buffer
 10484                                  OLDBAK_RETN:
 10485 00001474 C3                              RETN
 10486                                  
 10487                                  ;	Output a CRLF to the user screen and do NOT store it into the buffer
 10488                                  
 10489                                  PHYCRLF:
 10490 00001475 E81B01                  	CALL	CRLF
 10491 00001478 EB9B                            JMP	short GETCH
 10492                                  
 10493                                  	; MSDOS 6.0 (& MSDOS 3.3, IBMDOS.COM, 1987)
 10494                                  
 10495                                  ; DOSCODE:52CAh (MSDOS 621, MSDOS.SYS)
 10496                                  
 10497                                  	; Note: Following routines were not used in IBMDOS.COM
 10498                                  	;	-CRTL+W, CRTL+U is not activated-
 10499                                  	;	but they were in the kernel code!?)
 10500                                  
 10501                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10502                                  	; DOSCODE:52B6h
 10503                                  
 10504                                  ;;;;;;;;
 10505                                  
 10506                                  ; 16/12/2022
 10507                                  %if 0
 10508                                  ;
 10509                                  ; Delete the previous line
 10510                                  ;
 10511                                  LineDel:
 10512                                  	OR      DH,DH
 10513                                  	JZ	short GETCH	 ; 06/12/2022
 10514                                  	Call    BackSpace
 10515                                  	JMP	short LineDel
 10516                                  
 10517                                  %endif
 10518                                  
 10519                                  ;
 10520                                  ; delete the previous word.
 10521                                  ;
 10522                                  WordDel:
 10523                                  WordLoop:
 10524                                  ;	Call    BackSpace               ; backspace the one spot
 10525                                  ;	OR      DH,DH
 10526                                  ;	JZ	short GetChj
 10527                                  ;	MOV     AL,[ES:DI-1]
 10528                                  ;	cmp     al,'0'
 10529                                  ;	jb	short GetChj
 10530                                  ;	cmp     al,'9'
 10531                                  ;	jbe	short WordLoop
 10532                                  ;	OR      AL,20h
 10533                                  ;	CMP     AL,'a'
 10534                                  ;	JB	short GetChj
 10535                                  ;	CMP     AL,'z'
 10536                                  ;	JBE	short WordLoop
 10537                                  ;GetChj: 
 10538                                  ;	JMP	GETCH
 10539                                  
 10540                                  ; 16/12/2022
 10541                                  %if 0
 10542                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10543                                  	; (Worddel is not called or jumped from anywhere!)
 10544                                  WordDel:
 10545                                  WordLoop:
 10546                                  	Call    BackSpace               ; backspace the one spot
 10547                                  	OR      DH,DH
 10548                                  	JZ	short GetChj
 10549                                  	MOV     AL,[ES:DI-1]
 10550                                  	cmp     al,'0'
 10551                                  	jb	short GetChj
 10552                                  	cmp     al,'9'
 10553                                  	jbe	short WordLoop
 10554                                  	OR      AL,20h
 10555                                  	CMP     AL,'a'
 10556                                  	JB	short GetChj
 10557                                  	CMP     AL,'z'
 10558                                  	JBE	short WordLoop
 10559                                  GetChj: 
 10560                                  	JMP	GETCH
 10561                                  
 10562                                  %endif
 10563                                  
 10564                                  ;;;;;;;;
 10565                                  
 10566                                  ; DOSCODE:52F3h (MSDOS 621, MSDOS.SYS)
 10567                                  
 10568                                  ; The user wants to throw away what he's typed in and wants to start over.
 10569                                  ; We print the backslash and then go to the next line and tab to the correct
 10570                                  ; spot to begin the buffered input.
 10571                                  
 10572                                  KILNEW:
 10573 0000147A B05C                            mov	al,'\'
 10574 0000147C E8E201                          call	OUTT            ;Print the CANCEL indicator
 10575 0000147F 5E                              pop	si		;Remember start of edit buffer
 10576                                  PUTNEW:
 10577 00001480 E81001                  	call	CRLF            ;Go to next line on screen
 10578 00001483 36A0[FA01]              	mov	al,[SS:STARTPOS]
 10579 00001487 E84B02                  	call	TAB             ;Tab over
 10580 0000148A E96CFF                          JMP     NEWLIN		;Start over again
 10581                                  
 10582                                  ;	Destructively back up one character position
 10583                                  
 10584                                  BACKSP:
 10585                                  	; 09/09/2018
 10586 0000148D E80800                  	Call    BackSpace
 10587 00001490 EB83                    	JMP     short GETCH	; 15/01/2024
 10588                                  
 10589                                  	; 15/01/2024
 10590                                  ;User really wants an ESC character in his line
 10591                                  TWOESC:	
 10592 00001492 2EA0[1A0A]              	mov	al,[cs:ESCCHAR] ; 10/06/2019
 10593 00001496 EBA2                    	jmp	short SAVCH
 10594                                  
 10595                                  BackSpace:
 10596 00001498 08F6                    	or	dh,dh
 10597 0000149A 7419                    	jz	short OLDBAK	;No chars in line, do nothing to line
 10598 0000149C E85800                  	call	BACKUP          ;Do the backup
 10599 0000149F 268A05                  	mov	al,[es:di]	;Get the deleted char
 10600 000014A2 3C20                            cmp	al,20h	; ' '
 10601 000014A4 730F                    	jnb	short OLDBAK	;Was a normal char
 10602 000014A6 3C09                            cmp	al,c_HT ; 9
 10603 000014A8 741B                    	jz	short BAKTAB	;Was a tab, fix up users display
 10604                                  ;; 9/27/86 fix for ctrl-U backspace
 10605 000014AA 3C15                    	CMP     AL,"U"-"@" ; 15h ; ctrl-U is a section symbol not ^U
 10606 000014AC 7407                    	JZ	short OLDBAK
 10607 000014AE 3C14                           	CMP     AL,"T"-"@" ; 14h ; ctrl-T is a paragraphs symbol not ^T
 10608 000014B0 7403                    	JZ	short OLDBAK
 10609                                  ;; 9/27/86 fix for ctrl-U backspace
 10610 000014B2 E84500                          call	BACKMES         ;Was a control char, zap the '^'
 10611                                  OLDBAK:
 10612 000014B5 36803E[7905]00                  cmp	byte [SS:INSMODE], 0
 10613 000014BB 75B7                    	jnz	short OLDBAK_RETN ;In insert mode, done
 10614 000014BD 08FF                    	or	bh,bh
 10615 000014BF 74B3                            jz	short OLDBAK_RETN 
 10616                                  				;Not advanced in template, stay where we are
 10617 000014C1 FECF                    	dec	bh		;Go back in template
 10618 000014C3 4E                              dec	si
 10619 000014C4 C3                      	retn
 10620                                  BAKTAB:
 10621 000014C5 57                              push	di
 10622 000014C6 4F                              dec	di		;Back up one char
 10623 000014C7 FD                              std			;Go backward
 10624 000014C8 88F1                            mov	cl,dh		;Number of chars currently in line
 10625 000014CA B020                            mov	al,20h	; ' '
 10626 000014CC 53                              push	bx
 10627 000014CD B307                            mov	bl,7		;Max
 10628 000014CF E30E                            jcxz	FIGTAB		;At start, do nothing
 10629                                  FNDPOS:
 10630 000014D1 AE                              scasb			;Look back
 10631 000014D2 7609                    	jbe	short CHKCNT
 10632 000014D4 26807D0109              	cmp	byte [es:di+1],9
 10633 000014D9 7409                    	jz	short HAVTAB	;Found a tab
 10634 000014DB FECB                    	dec	bl		;Back one char if non tab control char
 10635                                  CHKCNT:
 10636 000014DD E2F2                            loop	FNDPOS
 10637                                  FIGTAB:		
 10638 000014DF 362A1E[FA01]            	sub	bl,[SS:STARTPOS]
 10639                                  HAVTAB:
 10640 000014E4 28F3                    	sub	bl,dh
 10641 000014E6 00D9                    	add	cl,bl
 10642 000014E8 80E107                  	and	cl,7		;CX has correct number to erase
 10643 000014EB FC                      	cld			;Back to normal
 10644 000014EC 5B                      	pop	bx
 10645 000014ED 5F                      	pop	di
 10646 000014EE 74C5                    	jz	short OLDBAK	;Nothing to erase
 10647                                  TABBAK:
 10648 000014F0 E80700                  	call	BACKMES
 10649 000014F3 E2FB                    	loop	TABBAK		;Erase correct number of chars
 10650 000014F5 EBBE                    	jmp	short OLDBAK
 10651                                  
 10652                                  BACKUP:
 10653 000014F7 FECE                            dec	dh		;Back up in line
 10654 000014F9 4F                              dec	di
 10655                                  BACKMES:
 10656 000014FA B008                            mov	al,c_BS ; 8	;Backspace
 10657 000014FC E86201                          call	OUTT
 10658 000014FF B020                            mov	al,20h ; ' '	;Erase
 10659 00001501 E85D01                          call	OUTT
 10660 00001504 B008                            mov	al,c_BS ; 8	;Backspace
 10661 00001506 E95801                  	jmp	OUTT		;Done
 10662                                  
 10663                                  	; 15/01/2024
 10664                                  ;User really wants an ESC character in his line
 10665                                  ;TWOESC:	
 10666                                  ;	mov	al,[cs:ESCCHAR] ; 10/06/2019
 10667                                  ;	jmp	SAVCH
 10668                                  
 10669                                  ;Copy the rest of the template
 10670                                  COPYLIN:
 10671 00001509 88D9                            mov	cl,bl		;Total size of template
 10672 0000150B 28F9                    	sub	cl,bh		;Minus position in template, is number to move
 10673 0000150D EB07                            jmp	short COPYEACH
 10674                                  
 10675                                  COPYSTR:
 10676 0000150F E83200                  	call	FINDOLD         ;Find the char
 10677 00001512 EB02                    	jmp	short COPYEACH  ;Copy up to it
 10678                                  
 10679                                  ;Copy one char from template to line
 10680                                  COPYONE:
 10681 00001514 B101                            mov	cl,1
 10682                                  ;Copy CX chars from template to line
 10683                                  COPYEACH:
 10684 00001516 36C606[7905]00                  mov	byte [SS:INSMODE],0	;All copies turn off insert mode
 10685 0000151C 38D6                    	cmp	dh,dl
 10686 0000151E 740F                            jz	short GETCH2		;At end of line, can't do anything
 10687 00001520 38DF                            cmp	bh,bl
 10688 00001522 740B                            jz	short GETCH2		;At end of template, can't do anything
 10689 00001524 AC                              lodsb
 10690 00001525 AA                              stosb
 10691 00001526 E8CC01                  	call	BUFOUT
 10692 00001529 FEC7                            inc	bh			;Ahead in template
 10693 0000152B FEC6                            inc	dh			;Ahead in line
 10694 0000152D E2E7                            loop	COPYEACH
 10695                                  GETCH2:
 10696 0000152F E9E3FE                          jmp	GETCH
 10697                                  
 10698                                  ;Skip one char in template
 10699                                  SKIPONE:
 10700 00001532 38DF                    	cmp	bh,bl
 10701 00001534 74F9                    	jz	short GETCH2		;At end of template
 10702 00001536 FEC7                    	inc	bh			;Ahead in template
 10703 00001538 46                      	inc	si
 10704                                          ;jmp	GETCH
 10705                                  	; 15/01/2024
 10706 00001539 EBF4                    	jmp	short GETCH2
 10707                                  
 10708                                  SKIPSTR:
 10709 0000153B E80600                  	call	FINDOLD                 ;Find out how far to go
 10710 0000153E 01CE                            add	si,cx			;Go there
 10711 00001540 00CF                            add	bh,cl
 10712                                          ;jmp	GETCH
 10713                                  	; 15/01/2024
 10714 00001542 EBEB                    	jmp	short GETCH2
 10715                                  
 10716                                  ;Get the next user char, and look ahead in template for a match
 10717                                  ;CX indicates how many chars to skip to get there on output
 10718                                  ;NOTE: WARNING: If the operation cannot be done, the return
 10719                                  ;       address is popped off and a jump to GETCH is taken.
 10720                                  ;       Make sure nothing extra on stack when this routine
 10721                                  ;       is called!!! (no PUSHes before calling it).
 10722                                  
 10723                                  FINDOLD:
 10724 00001544 E830FE                          call	_$STD_CON_INPUT_NO_ECHO
 10725                                  
 10726                                  	; STRIN.ASM (MSDOS 2.11, 19/07/2018) 
 10727                                  
 10728                                  	;CMP	AL,[SS:ESCCHAR]	
 10729                                  	;JNZ	SHORT FINDSETUP
 10730                                  
 10731                                  	; CPMIO.ASM (MSDOS 6.0, 04/05/2019 - Retro DOS v4.0)
 10732                                  
 10733                                  ;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override
 10734                                  
 10735 00001547 2E3A06[1A0A]            	CMP	AL,[CS:ESCCHAR]		; did he type a function key?
 10736 0000154C 7505                    	JNZ	SHORT FINDSETUP		; no, set up for scan
 10737                                  
 10738 0000154E E826FE                  	CALL	_$STD_CON_INPUT_NO_ECHO	; eat next char
 10739 00001551 EB1D                            JMP	SHORT NOTFND		; go try again
 10740                                  FINDSETUP:
 10741 00001553 88D9                    	mov	cl,bl
 10742 00001555 28F9                            sub	cl,bh		;CX is number of chars to end of template
 10743 00001557 7417                    	jz	short NOTFND	;At end of template
 10744 00001559 49                              dec	cx		;Cannot point past end, limit search
 10745 0000155A 7414                            jz	short NOTFND	;If only one char in template, forget it
 10746 0000155C 06                      	push	es
 10747 0000155D 1E                      	push	ds
 10748 0000155E 07                      	pop	es
 10749 0000155F 57                      	push	di
 10750 00001560 89F7                    	mov	di,si		;Template to ES:DI
 10751 00001562 47                      	inc	di
 10752 00001563 F2AE                    	repne	scasb		;Look
 10753 00001565 5F                      	pop	di
 10754 00001566 07                      	pop	es
 10755 00001567 7507                    	jnz	short NOTFND	;Didn't find the char
 10756 00001569 F6D1                            not	cl		;Turn how far to go into how far we went
 10757 0000156B 00D9                            add	cl,bl		;Add size of template
 10758 0000156D 28F9                            sub	cl,bh		;Subtract current pos, result distance to skip
 10759                                  FINDOLD_RETN:
 10760 0000156F C3                      	retn
 10761                                  
 10762                                  NOTFND:
 10763 00001570 5D                      	pop	bp              ;Chuck return address
 10764                                  	;jmp	GETCH
 10765                                  	; 15/01/2024
 10766                                  GETCH2_j:
 10767 00001571 EBBC                    	jmp	short GETCH2
 10768                                  
 10769                                  REEDIT:
 10770 00001573 B040                    	mov	al,'@'		;Output re-edit character
 10771 00001575 E8E900                  	call	OUTT
 10772 00001578 5F                      	pop	di
 10773 00001579 57                      	push	di
 10774 0000157A 06                      	push	es
 10775 0000157B 1E                      	push	ds
 10776 0000157C E8EAFE                  	call	COPYNEW		;Copy current line into template
 10777 0000157F 1F                      	pop	ds
 10778 00001580 07                      	pop	es
 10779 00001581 5E                      	pop	si
 10780 00001582 88F3                    	mov	bl,dh		;Size of line is new size template
 10781 00001584 E9F9FE                  	jmp	PUTNEW		;Start over again
 10782                                  
 10783                                  EXITINS:
 10784                                  ENTERINS:
 10785 00001587 36F616[7905]            	not	byte [SS:INSMODE]
 10786                                  	;jmp	GETCH
 10787                                  	; 15/01/2024
 10788 0000158C EBE3                    	jmp	short GETCH2_j
 10789                                  
 10790                                  ;Put a real live ^Z in the buffer (embedded)
 10791                                  CTRLZ:
 10792 0000158E B01A                    	mov	al,"Z"-"@" ; 1Ah
 10793 00001590 E9A7FE                          jmp	SAVCH
 10794                                  
 10795                                  ;Output a CRLF
 10796                                  CRLF:
 10797 00001593 B00D                    	mov	al,c_CR ; 0Dh 
 10798 00001595 E8C900                  	call	OUTT
 10799 00001598 B00A                    	mov	al,c_LF ; 0Ah
 10800 0000159A E9C400                  	jmp	OUTT
 10801                                  
 10802                                  ;
 10803                                  ;----------------------------------------------------------------------------
 10804                                  ;
 10805                                  ;**	$RAW_CON_IO - Do Raw Console I/O
 10806                                  ;
 10807                                  ;	Input or output raw character from console, no echo
 10808                                  ;
 10809                                  ;	ENTRY	DL = -1 if input
 10810                                  ;		   =  output character if output
 10811                                  ;	EXIT	(AL) = input character if input
 10812                                  ;	USES	all
 10813                                  ;
 10814                                  ;----------------------------------------------------------------------------
 10815                                  ; 20/07/2018 - Retro DOS v3.0
 10816                                  
 10817                                  ; 04/05/2019 - Retro DOS v4.0
 10818                                  ; DOSCODE:541Ch (MSDOS 6.21, MSDOS.SYS)
 10819                                  
 10820                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10821                                  ; DOSCODE:5408h (MSDOS 5.0, MSDOS.SYS)
 10822                                  
 10823                                  _$RAW_CON_IO:			; System call 6
 10824 0000159D 88D0                    	MOV	AL,DL
 10825 0000159F 3CFF                    	CMP	AL,-1
 10826 000015A1 7541                    	JNZ	SHORT RAWOUT ; 16/12/2022
 10827                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10828                                  	;jz	short rci1
 10829                                  	;jmp	short RAWOUT
 10830                                  	; 16/12/202
 10831                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10832                                  	;nop
 10833                                  rci1:
 10834                                  			; Get pointer to register save area
 10835 000015A3 36C43E[8405]            	LES	DI,[SS:USER_SP] ; 12/03/2018
 10836 000015A8 31DB                    	XOR	BX,BX
 10837                                      	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10838 000015AA E8B120                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10839                                          ;JC	SHORT RET17
 10840 000015AD 72C0                            jc	short FINDOLD_RETN
 10841 000015AF B401                    	MOV	AH,1
 10842 000015B1 E8EF2E                  	CALL	IOFUNC
 10843 000015B4 750B                    	JNZ	SHORT RESFLG
 10844 000015B6 E8853B                  	CALL	SPOOLINT
 10845                                  	;OR	BYTE [ES:DI+16H],40H
 10846 000015B9 26804D1640              	OR	BYTE [ES:DI+user_env.user_F],40H ; Set user's zero flag
 10847 000015BE 30C0                    	XOR	AL,AL
 10848                                  RET17:
 10849 000015C0 C3                      	RETN
 10850                                  
 10851                                  RESFLG:
 10852                                  	;AND	BYTE [ES:DI+16H],0FFH-40H  ; 0BFh
 10853 000015C1 26806516BF              	AND	BYTE [ES:DI+user_env.user_F],0FFH-40H
 10854                                  				; Reset user's zero flag
 10855                                  ;RILP:
 10856                                  rci0:
 10857 000015C6 E8753B                  	CALL	SPOOLINT
 10858                                  ;
 10859                                  ;----------------------------------------------------------------------------
 10860                                  ;
 10861                                  ;**	$Raw_CON_INPUT - Raw Console Input
 10862                                  ;
 10863                                  ;	Input raw character from console, no echo
 10864                                  ;
 10865                                  ;	ENTRY	none
 10866                                  ;	EXIT	(al) = character
 10867                                  ;	USES	all
 10868                                  ;
 10869                                  ;----------------------------------------------------------------------------
 10870                                  ;
 10871                                  
 10872                                  ;rci0:	invoke	SPOOLINT
 10873                                  
 10874                                  	;entry	$RAW_CON_INPUT
 10875                                  
 10876                                  	; 04/05/2019 - Retro DOS v4.0
 10877                                  
 10878                                  ; DOSCODE:544Bh (MSDOS 6.21, MSDOS.SYS)
 10879                                  
 10880                                  _$RAW_CON_INPUT:		; System call 7
 10881 000015C9 53                      	push	bx
 10882 000015CA 31DB                    	XOR	BX,BX
 10883                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10884 000015CC E88F20                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10885 000015CF 5B                      	pop	bx
 10886 000015D0 72EE                    	JC	SHORT RET17
 10887 000015D2 B401                    	MOV	AH,1
 10888 000015D4 E8CC2E                  	CALL	IOFUNC
 10889                                  	;JZ	SHORT RILP	; MSDOS 2.11
 10890                                  	;XOR	AH,AH
 10891                                          ;CALL	IOFUNC
 10892                                          ;RETN
 10893 000015D7 7506                    	jnz	short rci5	; MSDOS 3.3 & MSDOS 6.0
 10894 000015D9 B484                    	MOV	AH,84h
 10895 000015DB CD2A                    	INT	int_IBM  ; int 2Ah
 10896 000015DD EBE7                    	JMP	short rci0
 10897                                  rci5:	
 10898 000015DF 30E4                    	XOR	AH,AH
 10899                                  	;CALL	IOFUNC
 10900                                  	;RETN
 10901                                  	; 18/12/2022
 10902 000015E1 E9BF2E                  	jmp	IOFUNC
 10903                                  
 10904                                  ;       Output the character in AL to stdout
 10905                                  ;
 10906                                  	;entry	RAWOUT
 10907                                  RAWOUT:
 10908 000015E4 53                      	PUSH    BX
 10909 000015E5 BB0100                  	MOV     BX,1
 10910                                  
 10911                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10912 000015E8 E87320                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10913 000015EB 721B                    	JC	SHORT RAWRET1
 10914                                  
 10915                                  	;
 10916                                  	; MSDOS 2.11
 10917                                          ;TEST	BYTE [SI+18H],080H	; output to file?
 10918                                          ;JZ	SHORT RAWNORM		; if so, do normally
 10919                                          ;PUSH	DS
 10920                                          ;PUSH	SI
 10921                                          ;LDS	SI,[SI+19H]		; output to special?
 10922                                  	;TEST	BYTE [SI+4],ISSPEC
 10923                                  	;POP	SI
 10924                                  	;
 10925                                          
 10926                                  	; MSDOS 3.3 & MSDOS 6.0
 10927                                  	;mov	bx,[si+5]
 10928 000015ED 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags] ;hkn; DS set up by get_io_sft
 10929                                   ;
 10930                                   ; If we are a network handle OR if we are not a local device then go do the
 10931                                   ; output the hard way.
 10932                                   ;	
 10933                                  	;and	bx,8080h
 10934 000015F0 81E38080                	AND	BX,sf_isnet+devid_device
 10935                                  	;cmp	bx,80h
 10936 000015F4 81FB8000                	CMP	BX,devid_device
 10937 000015F8 7510                    	jnz     short RAWNORM
 10938 000015FA 1E                      	push    ds
 10939                                  	;lds	bx,[si+7]
 10940 000015FB C55C07                  	LDS	BX,[SI+SF_ENTRY.sf_devptr] ; output to special?
 10941                                  	;test	byte [bx+4],10h
 10942 000015FE F6470410                	TEST	BYTE [BX+SYSDEV.ATT],ISSPEC
 10943                                  	;
 10944                                  
 10945 00001602 1F                      	POP	DS
 10946 00001603 7405                    	JZ	SHORT RAWNORM		; if not, do normally
 10947                                  
 10948 00001605 CD29                    	INT	int_fastcon  ; int 29h	; quickly output the char
 10949                                  
 10950                                  	;JMP	SHORT RAWRET
 10951                                  ;RAWNORM:
 10952                                  ;	CALL    RAWOUT3
 10953                                  RAWRET: 
 10954 00001607 F8                      	CLC
 10955                                  RAWRET1:
 10956 00001608 5B                      	POP     BX
 10957                                  RAWRET2:
 10958 00001609 C3                      	RETN
 10959                                  RAWNORM:
 10960 0000160A E80700                  	CALL    RAWOUT3
 10961 0000160D EBF8                    	jmp	short RAWRET
 10962                                  
 10963                                  ;	Output the character in AL to handle in BX
 10964                                  ;
 10965                                  ;	entry	RAWOUT2
 10966                                  
 10967                                  RAWOUT2:
 10968                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10969                                  	;JC	SHORT RET18
 10970 0000160F E84C20                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10971 00001612 72F5                    	JC	SHORT RAWRET2
 10972                                  RAWOUT3:
 10973 00001614 50                      	PUSH	AX
 10974 00001615 EB0C                    	JMP	SHORT RAWOSTRT
 10975                                  ROLP:
 10976 00001617 E8243B                  	CALL	SPOOLINT
 10977                                  
 10978                                  	; 01/05/2019 - Retro DOS v4.0
 10979                                  
 10980                                  	; MSDOS 6.0
 10981                                  	;OR	word [ss:DOS34_FLAG],CTRL_BREAK_FLAG ; 001000000000b
 10982                                  	; 17/12/2022
 10983 0000161A 36800E[1206]02          	or	byte [ss:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8) ; 02h
 10984                                  	;or	word [ss:DOS34_FLAG],200h
 10985                                  				;AN002; set control break
 10986                                  	;invoke DSKSTATCHK
 10987 00001620 E8983A                  	call	DSKSTATCHK	;AN002; check control break
 10988                                  RAWOSTRT:
 10989 00001623 B403                    	MOV	AH,3
 10990 00001625 E87B2E                  	CALL	IOFUNC
 10991 00001628 74ED                    	JZ	SHORT ROLP
 10992                                  
 10993                                  	; MSDOS 6.0
 10994                                  ;SR;
 10995                                  ; IOFUNC now returns ax = 0ffffh if there was an I24 on a status call and
 10996                                  ;the user failed. We do not send a char if this happens. We however return
 10997                                  ;to the caller with carry clear because this DOS call does not return any
 10998                                  ;status. 
 10999                                  ;
 11000 0000162A 40                      	inc	ax		;fail on I24 if ax = -1
 11001 0000162B 58                      	POP	AX
 11002 0000162C 7405                    	jz	short nosend	;yes, do not send char
 11003 0000162E B402                    	MOV	AH,2
 11004 00001630 E8702E                  	call	IOFUNC
 11005                                  nosend:
 11006 00001633 F8                      	CLC			; Clear carry indicating successful
 11007 00001634 C3                      	retn
 11008                                  
 11009                                  	; MSDOS 3.3 & MSDOS 2.11
 11010                                  	;POP	AX
 11011                                  	;MOV	AH,2
 11012                                          ;CALL	IOFUNC
 11013                                  	;CLC			; Clear carry indicating successful
 11014                                  ;RET18:    
 11015                                  	;RETN
 11016                                  
 11017                                  ;;10/08/2018
 11018                                  ; 20/07/2018 - Retro DOS v3.0
 11019                                  ; ---------------------------------------------------------------------------
 11020                                  ; Retro DOS v2.0 (MSDOS 2.11) - OUTMES
 11021                                  ; ---------------------------------------------------------------------------
 11022                                  
 11023                                  ; This routine is called at DOS init
 11024                                  
 11025                                  ;;	;procedure OUTMES,NEAR ; String output for internal messages
 11026                                  ;;OUTMES:
 11027                                  ;;	;LODS	CS:BYTE PTR [SI]
 11028                                  ;;	CS	LODSB
 11029                                  ;;	CMP     AL,"$" ; 24h
 11030                                  ;;	JZ	SHORT RET18
 11031                                  ;;	CALL	OUTT
 11032                                  ;;	JMP     SHORT OUTMES
 11033                                  
 11034                                  ; ---------------------------------------------------------------------------
 11035                                  
 11036                                  ; 20/07/2018 - Retro DOS v3.0
 11037                                  
 11038                                  ; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 2252h
 11039                                  
 11040                                  ;
 11041                                  ;----------------------------------------------------------------------------
 11042                                  ;
 11043                                  ; Inputs:
 11044                                  ;	AX=0 save the DEVCALL request packet
 11045                                  ;	  =1 restore the DEVCALL request packet
 11046                                  ; Function:
 11047                                  ;	save or restore the DEVCALL packet
 11048                                  ; Returns:
 11049                                  ;	none
 11050                                  ;
 11051                                  ;----------------------------------------------------------------------------
 11052                                  ;
 11053                                  
 11054                                  ; 04/05/2019 - Retro DOS v4.0
 11055                                  ; DOSCODE:54B9h (MSDOS 6.21, MSDOS.SYS)
 11056                                  
 11057                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11058                                  ; DOSCODE:54A5h (MSDOS 5.0, MSDOS.SYS)
 11059                                  
 11060                                  ; 12/05/2019
 11061                                  
 11062                                  	; 15/01/2024
 11063                                  
 11064                                  Save_Restore_Packet:
 11065 00001635 1E                      	PUSH	DS
 11066 00001636 06                      	PUSH	ES
 11067 00001637 56                      	PUSH	SI
 11068 00001638 57                      	PUSH	DI
 11069                                  
 11070                                  	; 16/12/2022
 11071                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11072                                  	; 09/09/2018
 11073 00001639 BF[6C0D]                	mov	di,FAKE_STACK_2F
 11074 0000163C BE[5A03]                	mov	si,DEVCALL
 11075 0000163F BE[5A03]                	mov	si,DEVCALL
 11076                                  	;
 11077                                  	; 21/09/2023
 11078 00001642 09C0                    	or	ax,ax 
 11079                                  	;CMP	AX,0		; save packet
 11080 00001644 7402                    	JZ	short save_packet ; 16/12/2022
 11081                                  	;je	short set_seg
 11082                                  
 11083                                  	; MSDOS 6.0
 11084                                  restore_packet:
 11085                                  ;	MOV	SI,OFFSET DOSDATA:Packet_Temp	;source
 11086                                  ;	MOV	DI,OFFSET DOSDATA:DEVCALL	;destination
 11087                                  	; MSDOS 3.3
 11088                                  	;mov	si,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 11089                                  	;mov	di,DEVCALL  ; 09/09/2018
 11090                                  	;
 11091                                  	;JMP	short set_seg
 11092                                  
 11093                                  	; 16/12/2022	
 11094                                  	; 09/09/2018
 11095 00001646 87F7                    	xchg	si,di  ; DI = offset DEVCALL, SI = offset FAKE_STACK_2F
 11096                                  
 11097                                  ; 16/12/2022
 11098                                  %if 0
 11099                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11100                                  	cmp	ax,0		; save packet
 11101                                  	jz	short save_packet
 11102                                  	mov	si,FAKE_STACK_2F ; 07/12/2022
 11103                                  	mov	di,DEVCALL 
 11104                                  	jmp	short set_seg
 11105                                  
 11106                                  	; MSDOS 6.0
 11107                                  save_packet:
 11108                                  ;	MOV	DI,OFFSET DOSDATA:Packet_Temp	;destination
 11109                                  ;	MOV	SI,OFFSET DOSDATA:DEVCALL	;source
 11110                                  	; 09/09/2018
 11111                                  	; MSDOS 3.3
 11112                                  	;mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 11113                                  	;mov	si,DEVCALL ; 09/09/2018
 11114                                  
 11115                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11116                                  	mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 11117                                  	mov	si,DEVCALL
 11118                                  %endif
 11119                                  
 11120                                  ; 15/01/2024
 11121                                  ; 16/12/2022
 11122                                  save_packet:
 11123                                  ;set_seg:
 11124                                  	; MSDOS 3.3
 11125                                  	;mov	ax,cs
 11126                                  
 11127                                  	; MSDOS 6.0
 11128                                  	;MOV	AX,SS		; set DS,ES to DOSDATA
 11129                                  	;MOV	DS,AX
 11130                                  	;MOV	ES,AX
 11131                                  	; 15/01/2024
 11132 00001648 16                      	push	ss
 11133 00001649 1F                      	pop	ds
 11134 0000164A 1E                      	push	ds
 11135 0000164B 07                      	pop	es
 11136                                  
 11137 0000164C B90B00                  	MOV	CX,11		; 11 words to move
 11138 0000164F F3A5                    	REP	MOVSW
 11139                                  
 11140 00001651 5F                      	POP	DI
 11141 00001652 5E                      	POP	SI
 11142 00001653 07                      	POP	ES
 11143 00001654 1F                      	POP	DS
 11144 00001655 C3                      	retn
 11145                                  
 11146                                  ;============================================================================
 11147                                  ; CPMIO2.ASM, MSDOS 6.0, 1991
 11148                                  ;============================================================================
 11149                                  ; 20/07/2018 - Retro DOS v3.0
 11150                                  ; 01/05/2019 - Retro DOS v4.0
 11151                                  
 11152                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
 11153                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
 11154                                  ;hkn;	not valid. 
 11155                                  
 11156                                  ;
 11157                                  ;----------------------------------------------------------------------------
 11158                                  ;
 11159                                  ;**	$STD_CON_INPUT - System Call 1
 11160                                  ;
 11161                                  ;	Input character from console, echo
 11162                                  ;
 11163                                  ;	ENTRY	none
 11164                                  ;	EXIT	(al) = character
 11165                                  ;	USES	ALL
 11166                                  ;
 11167                                  ;----------------------------------------------------------------------------
 11168                                  ;
 11169                                  
 11170                                  _$STD_CON_INPUT:	;System call 1
 11171                                  	
 11172 00001656 E81EFD                  	CALL	_$STD_CON_INPUT_NO_ECHO
 11173 00001659 50                      	PUSH	AX
 11174 0000165A E80400                  	CALL	OUTT
 11175 0000165D 58                      	POP	AX
 11176                                  CON_INPUT_RETN:	
 11177 0000165E C3                      	RETN
 11178                                  
 11179                                  ;
 11180                                  ;----------------------------------------------------------------------------
 11181                                  ;
 11182                                  ;**	$STD_CON_OUTPUT - System Call 2
 11183                                  ;
 11184                                  ;	Output character to console
 11185                                  ;
 11186                                  ;	ENTRY	(dl) = character
 11187                                  ;	EXIT	none
 11188                                  ;	USES	all
 11189                                  ;
 11190                                  ;----------------------------------------------------------------------------
 11191                                  ;
 11192                                  
 11193                                  ; DOSCODE:54E9h (MSDOS 6.21, MSDOS.SYS)
 11194                                  
 11195                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11196                                  ; DOSCODE:54D5h (MSDOS 5.0, MSDOS.SYS)
 11197                                  
 11198                                  _$STD_CON_OUTPUT:	;System call 2
 11199                                  
 11200 0000165F 88D0                    	MOV	AL,DL
 11201                                  OUTT:
 11202 00001661 3C20                    	CMP	AL,20H ; " "
 11203 00001663 725C                    	JB	SHORT CTRLOUT
 11204 00001665 3C7F                    	CMP	AL,c_DEL ; 7Fh
 11205 00001667 7405                    	JZ	SHORT OUTCH
 11206                                  OUTCHA:	
 11207                                  	;INC	BYTE PTR [CARPOS]
 11208 00001669 36FE06[F901]            	INC	BYTE [SS:CARPOS]
 11209                                  OUTCH:
 11210 0000166E 1E                      	PUSH	DS
 11211 0000166F 56                      	PUSH	SI
 11212                                  	;INC	BYTE PTR [CHARCO]		;invoke statchk...
 11213                                  	;AND	BYTE PTR [CHARCO],00111111B	;AN000; every 64th char
 11214 00001670 36FE06[0003]            	INC	BYTE [SS:CHARCO]	
 11215                                  	;AND	BYTE [SS:CHARCO],00111111B
 11216                                  	; 01/05/2019 - Retro DOS v4.0
 11217 00001675 368026[0003]3F          	and	byte [SS:CHARCO],3Fh
 11218 0000167B 7505                    	JNZ	SHORT OUTSKIP
 11219                                  
 11220 0000167D 50                      	PUSH	AX
 11221 0000167E E8EB3A                  	CALL	STATCHK
 11222 00001681 58                      	POP	AX
 11223                                  OUTSKIP:
 11224 00001682 E85FFF                  	CALL	RAWOUT				;output the character
 11225                                  
 11226 00001685 5E                      	POP	SI
 11227 00001686 1F                      	POP	DS
 11228                                  
 11229                                  	;TEST	BYTE PTR [PFLAG],-1
 11230                                  	;retz
 11231 00001687 36F606[FE02]FF          	TEST	BYTE [SS:PFLAG],0FFh
 11232 0000168D 74CF                    	JZ	SHORT CON_INPUT_RETN
 11233                                  
 11234 0000168F 53                      	PUSH	BX
 11235 00001690 1E                      	PUSH	DS
 11236 00001691 56                      	PUSH	SI
 11237 00001692 BB0100                  	MOV	BX,1
 11238                                  	; 20/07/2018 - Retro DOS v3.0
 11239                                  	; MSDOS 3.3
 11240                                  	; MSDOS 6.0 (CPMIO2.ASM)
 11241 00001695 E8C61F                  	CALL	GET_IO_SFT		;hkn; GET_IO_SFT will set up DS:SI
 11242                                  					;hkn; to sft entry
 11243 00001698 7224                    	JC	SHORT TRIPOPJ
 11244                                  
 11245                                  	; 01/05/2019 - Retro DOS v4.0
 11246                                  
 11247                                  	;mov	bx,[si+5]
 11248 0000169A 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags]
 11249                                  	;test	bx,8000h
 11250                                  	;TEST	BX,sf_isnet	; 8000h		; output to NET?
 11251 0000169D F6C780                  	test	bh,(sf_isnet>>8) ; 80h
 11252 000016A0 751C                    	JNZ	short TRIPOPJ 			; if so, no echo
 11253                                  	;;test	bx,80h
 11254                                  	;TEST	BX,devid_device 		; output to file?
 11255 000016A2 F6C380                  	test	bl,devid_device ; 80h
 11256 000016A5 7417                    	JZ	SHORT TRIPOPJ 			; if so, no echo
 11257                                  	; 14/03/2018
 11258                                  	;call	GET_IO_FCB	 	; IBMDOS.COM, MSDOS 2.11
 11259                                  	;jc	short TRIPOPJ
 11260                                  	; MSDOS 2.11
 11261                                  	;test	byte [SI+18H], 80h
 11262                                  	;jz	short TRIPOPJ
 11263 000016A7 BB0400                  	MOV	BX,4
 11264 000016AA E8B11F                  	CALL	GET_IO_SFT
 11265 000016AD 720F                    	JC	SHORT TRIPOPJ
 11266                                  	;;test	word [si+5], 800h
 11267                                  	;TEST	word [SI+SF_ENTRY.sf_flags],sf_net_spool ; 800H
 11268                                  	;test	byte [si+6],8 ; 08/11/2022
 11269 000016AF F6440608                	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8) ; 8 
 11270                                  						; StdPrn redirected?
 11271                                  	;;JZ	SHORT LISSTRT2J			; No, OK to echo
 11272                                  	;jz	LISSTRT2 ; 10/08/2018 
 11273                                  	; 16/12/2022
 11274 000016B3 7503                    	jnz	short outch1
 11275 000016B5 E98700                  	jmp	LISSTRT2
 11276                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11277                                  	;jz	short LISSTRT2J
 11278                                  outch1:
 11279                                  	;MOV	BYTE [PFLAG],0
 11280 000016B8 36C606[FE02]00          	MOV	BYTE [SS:PFLAG],0		; If a spool, NEVER echo
 11281                                  	; MSDOS 2.11
 11282                                  	;mov	bx,4
 11283                                  	;jmp	short LISSTRT2
 11284                                  	
 11285                                  TRIPOPJ:
 11286                                  	; 20/07/2018
 11287 000016BE E98100                  	JMP	TRIPOP
 11288                                  
 11289                                  	; 16/12/2022
 11290                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11291                                  ;LISSTRT2J:
 11292                                  ;	JMP	LISSTRT2
 11293                                  
 11294                                  CTRLOUT:
 11295 000016C1 3C0D                    	CMP	AL,c_CR ; 0Dh
 11296 000016C3 7420                    	JZ	SHORT ZERPOS
 11297 000016C5 3C08                    	CMP	AL,c_BS ; 8
 11298 000016C7 7424                    	JZ	SHORT BACKPOS
 11299 000016C9 3C09                    	CMP	AL,c_HT ; 9
 11300 000016CB 75A1                    	JNZ	SHORT OUTCH
 11301                                  	;MOV	AL,[CARPOS]
 11302 000016CD 36A0[F901]              	MOV	AL,[SS:CARPOS]
 11303 000016D1 0CF8                    	OR	AL,0F8H
 11304 000016D3 F6D8                    	NEG	AL
 11305                                  TAB:
 11306 000016D5 51                      	PUSH	CX
 11307 000016D6 88C1                    	MOV	CL,AL
 11308 000016D8 B500                    	MOV	CH,0
 11309 000016DA E307                    	JCXZ	POPTAB
 11310                                  TABLP:
 11311 000016DC B020                    	MOV	AL," "
 11312 000016DE E880FF                  	CALL	OUTT
 11313 000016E1 E2F9                    	LOOP	TABLP
 11314                                  POPTAB:
 11315 000016E3 59                      	POP	CX
 11316                                  
 11317 000016E4 C3                      	RETN
 11318                                  
 11319                                  ZERPOS:
 11320                                  	;MOV	BYTE PTR [CARPOS],0
 11321 000016E5 36C606[F901]00          	MOV	BYTE [SS:CARPOS],0
 11322                                  	; 10/08/2018
 11323 000016EB EB81                    	JMP	short OUTCH ; 04/05/2019
 11324                                  	
 11325                                  	; 18/12/2022
 11326                                  ;OUTJ:	
 11327                                  	;JMP	OUTT
 11328                                  
 11329                                  BACKPOS:
 11330                                  	;DEC	BYTE PTR [CARPOS]
 11331 000016ED 36FE0E[F901]            	DEC	BYTE [SS:CARPOS]
 11332 000016F2 E979FF                  	JMP	OUTCH
 11333                                  
 11334                                  BUFOUT:
 11335 000016F5 3C20                    	CMP	AL," "
 11336 000016F7 7315                    	JAE	SHORT OUTJ		;Normal char
 11337 000016F9 3C09                    	CMP	AL,9
 11338 000016FB 7411                    	JZ	SHORT OUTJ		;OUT knows how to expand tabs
 11339                                  	;DOS 3.3  7/14/86
 11340 000016FD 3C15                    	CMP	AL,"U"-"@" ; 15h	; turn ^U to section symbol
 11341 000016FF 740D                    	JZ	short CTRLU
 11342 00001701 3C14                    	CMP	AL,"T"-"@" ; 14h	; turn ^T to paragraph symbol
 11343 00001703 7409                    	JZ	short CTRLU
 11344                                  NOT_CTRLU:
 11345                                  	;DOS 3.3  7/14/86
 11346 00001705 50                      	PUSH	AX
 11347 00001706 B05E                    	MOV	AL,"^"
 11348 00001708 E856FF                  	CALL	OUTT		;Print '^' before control chars
 11349 0000170B 58                      	POP	AX
 11350 0000170C 0C40                    	OR	AL,40H		;Turn it into Upper case mate
 11351                                  CTRLU:
 11352                                  	;CALL	OUTT
 11353                                  	; 18/12/2022
 11354                                  OUTJ:
 11355 0000170E E950FF                  	jmp	OUTT
 11356                                  ;BUFOUT_RETN:
 11357                                  	;RETN
 11358                                  
 11359                                  ;
 11360                                  ;----------------------------------------------------------------------------
 11361                                  ;
 11362                                  ;**	$STD_AUX_INPUT - System Call 3
 11363                                  ;
 11364                                  ;	$STD_AUX_INPUT returns a character from Aux Input
 11365                                  ;
 11366                                  ;	ENTRY	none
 11367                                  ;	EXIT	(al) = character
 11368                                  ;	USES	all
 11369                                  ;
 11370                                  ;----------------------------------------------------------------------------
 11371                                  ;
 11372                                  
 11373                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11374                                  
 11375                                  _$STD_AUX_INPUT:	;System call 3
 11376                                  
 11377 00001711 E8583A                  	CALL	STATCHK
 11378 00001714 BB0300                  	MOV	BX,3
 11379 00001717 E8441F                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 11380                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 11381                                  	;retc
 11382                                  	; 16/12/2022
 11383                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11384                                  	;JC	SHORT BUFOUT_RETN
 11385                                  	;JMP	SHORT TAISTRT
 11386                                  	; 07/12/2022
 11387 0000171A 7304                    	jnc	SHORT TAISTRT
 11388 0000171C C3                      	retn	
 11389                                  
 11390                                  AUXILP:
 11391 0000171D E81E3A                  	CALL	SPOOLINT
 11392                                  TAISTRT:
 11393 00001720 B401                    	MOV	AH,1
 11394 00001722 E87E2D                  	CALL	IOFUNC
 11395 00001725 74F6                    	JZ	SHORT AUXILP
 11396 00001727 30E4                    	XOR	AH,AH
 11397                                  	; 16/12/2022
 11398                                  	;CALL	IOFUNC
 11399                                  	;RETN
 11400                                  	; 07/12/2022
 11401 00001729 E9772D                  	jmp	IOFUNC
 11402                                  
 11403                                  ;
 11404                                  ;----------------------------------------------------------------------------
 11405                                  ;
 11406                                  ;**	$STD_AUX_OUTPUT - Output character to AUX
 11407                                  ;
 11408                                  ;	ENTRY	(dl) = character
 11409                                  ;	EXIT	none
 11410                                  ;	USES	all
 11411                                  ;
 11412                                  ;----------------------------------------------------------------------------
 11413                                  ;
 11414                                  
 11415                                  _$STD_AUX_OUTPUT:	;System call 4
 11416                                  
 11417 0000172C 53                      	PUSH	BX
 11418 0000172D BB0300                  	MOV	BX,3
 11419 00001730 EB04                    	JMP	SHORT SENDOUT
 11420                                  
 11421                                  ;
 11422                                  ;----------------------------------------------------------------------------
 11423                                  ;
 11424                                  ;**	$STD_PRINTER_OUTPUT - Output character to printer
 11425                                  ;
 11426                                  ;	ENTRY	(dl) = character
 11427                                  ;	EXIT	none
 11428                                  ;	USES	all
 11429                                  ;
 11430                                  ;----------------------------------------------------------------------------
 11431                                  ;
 11432                                  
 11433                                  _$STD_PRINTER_OUTPUT:	;System call 5
 11434                                  
 11435 00001732 53                      	PUSH	BX
 11436 00001733 BB0400                  	MOV	BX,4
 11437                                  
 11438                                  SENDOUT:
 11439 00001736 88D0                    	MOV	AL,DL
 11440 00001738 50                      	PUSH	AX
 11441 00001739 E8303A                  	CALL	STATCHK
 11442 0000173C 58                      	POP	AX
 11443 0000173D 1E                      	PUSH	DS
 11444 0000173E 56                      	PUSH	SI
 11445                                  LISSTRT2:
 11446 0000173F E8CDFE                  	CALL	RAWOUT2
 11447                                  TRIPOP:
 11448 00001742 5E                      	POP	SI
 11449 00001743 1F                      	POP	DS
 11450 00001744 5B                      	POP	BX
 11451                                  SCIS_RETN:	; 20/07/2018
 11452 00001745 C3                      	RETN
 11453                                  ;
 11454                                  ;----------------------------------------------------------------------------
 11455                                  ;
 11456                                  ;**	$STD_CON_INPUT_STATUS - System Call 11
 11457                                  ;
 11458                                  ;	Check console input status
 11459                                  ;
 11460                                  ;	ENTRY	none
 11461                                  ;	EXIT	AL = -1 character available, = 0 no character
 11462                                  ;	USES	all
 11463                                  ;
 11464                                  ;----------------------------------------------------------------------------
 11465                                  ;
 11466                                  
 11467                                  _$STD_CON_INPUT_STATUS:		;System call 11
 11468                                  
 11469 00001746 E8233A                  	CALL	STATCHK
 11470 00001749 B000                    	MOV	AL,0		; no xor!!
 11471                                  	;retz
 11472 0000174B 74F8                    	JZ	SHORT SCIS_RETN ; 15/04/2018
 11473 0000174D 0CFF                    	OR	AL,-1
 11474                                  ;SCIS_RETN:
 11475 0000174F C3                      	RETN
 11476                                  
 11477                                  ;
 11478                                  ;----------------------------------------------------------------------------
 11479                                  ;
 11480                                  ;**	$STD_CON_INPUT_FLUSH - System Call 12
 11481                                  ;
 11482                                  ;	Flush console input buffer and perform call in AL
 11483                                  ;
 11484                                  ;	ENTRY	(AL) = DOS function to be called after flush (1,6,7,8,10)
 11485                                  ;	EXIT	(al) = 0 iff (al) was not one of the supported fcns
 11486                                  ;		return arguments for the fcn supplied in (AL)
 11487                                  ;	USES	all
 11488                                  ;
 11489                                  ;----------------------------------------------------------------------------
 11490                                  ;
 11491                                  
 11492                                  _$STD_CON_INPUT_FLUSH:		;System call 12
 11493                                  
 11494 00001750 50                      	PUSH	AX
 11495 00001751 52                      	PUSH	DX
 11496 00001752 31DB                    	XOR	BX,BX
 11497 00001754 E8071F                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 11498                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 11499 00001757 7205                    	JC	SHORT BADJFNCON
 11500 00001759 B404                    	MOV	AH,4
 11501 0000175B E8452D                  	CALL	IOFUNC
 11502                                  
 11503                                  BADJFNCON:
 11504 0000175E 5A                      	POP	DX
 11505 0000175F 58                      	POP	AX
 11506 00001760 88C4                    	MOV	AH,AL
 11507 00001762 3C01                    	CMP	AL,1
 11508 00001764 7413                    	JZ	SHORT REDISPJ
 11509 00001766 3C06                    	CMP	AL,6
 11510 00001768 740F                    	JZ	SHORT REDISPJ
 11511 0000176A 3C07                    	CMP	AL,7
 11512 0000176C 740B                    	JZ	SHORT REDISPJ
 11513 0000176E 3C08                    	CMP	AL,8
 11514 00001770 7407                    	JZ	SHORT REDISPJ
 11515 00001772 3C0A                    	CMP	AL,10
 11516 00001774 7403                    	JZ	SHORT REDISPJ
 11517 00001776 B000                    	MOV	AL,0
 11518 00001778 C3                      	RETN
 11519                                  
 11520                                  REDISPJ:
 11521 00001779 FA                      	CLI
 11522                                  	;transfer REDISP
 11523 0000177A E90BEC                  	JMP	REDISP
 11524                                  
 11525                                  ;============================================================================
 11526                                  ; FCBIO.ASM, MSDOS 6.0, 1991
 11527                                  ;============================================================================
 11528                                  ; 20/07/2018 - Retro DOS v3.0
 11529                                  ; 17/05/2019 - Retro DOS v4.0
 11530                                  
 11531                                  ;**	FCBIO.ASM - Ancient 1.0 1.1 FCB system calls
 11532                                  ;
 11533                                  ;	$GET_FCB_POSITION
 11534                                  ;	$FCB_DELETE
 11535                                  ;	$GET_FCB_FILE_LENGTH
 11536                                  ;	$FCB_CLOSE
 11537                                  ;	$FCB_RENAME
 11538                                  ;	SaveFCBInfo
 11539                                  ;	ResetLRU
 11540                                  ;	SetOpenAge
 11541                                  ;	LRUFCB
 11542                                  ;	FCBRegen
 11543                                  ;	BlastSFT
 11544                                  ;	CheckFCB
 11545                                  ;	SFTFromFCB
 11546                                  ;	FCBHardErr
 11547                                  ;
 11548                                  ;	Revision history:
 11549                                  ;
 11550                                  ;		Created: ARR 4 April 1983"
 11551                                  ;			 MZ  6 June  1983 completion of functions
 11552                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 11553                                  ;					  times.  Change so successive closes work by
 11554                                  ;					  always returning OK.	Also, detect I/O to
 11555                                  ;					  already closed FCB and return EOF.
 11556                                  ;			 MZ 16 Jan   1984 More braindamage.  Need to separate info
 11557                                  ;					  out of sft into FCB for reconnection
 11558                                  ;
 11559                                  ;		A000	 version 4.00  Jan. 1988
 11560                                  
 11561                                  ;Break <$Get_FCB_Position - set random record fields to current pos>
 11562                                  ;----------------------------------------------------------------------------
 11563                                  ;
 11564                                  ;   $Get_FCB_Position - look at an FCB, retrieve the current position from the
 11565                                  ;	extent and next record field and set the random record field to point
 11566                                  ;	to that record
 11567                                  ;
 11568                                  ;   Inputs:	DS:DX point to a possible extended FCB
 11569                                  ;   Outputs:	The random record field of the FCB is set to the current record
 11570                                  ;   Registers modified: all
 11571                                  ;
 11572                                  ;----------------------------------------------------------------------------
 11573                                  ;
 11574                                  
 11575                                  _$GET_FCB_POSITION:
 11576 0000177D E8E704                  	call	GetExtended		; point to FCB
 11577 00001780 E8B704                  	call	GetExtent		; DX:AX is current record
 11578                                  	;mov	[si+21h],ax
 11579 00001783 894421                  	MOV	[SI+SYS_FCB.RR],AX 	; drop in low order piece
 11580                                  	;mov	[si+23h],dl
 11581 00001786 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; drop in high order piece
 11582                                  	;cmp	word [si+0Eh],64
 11583 00001789 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 11584 0000178D 7303                    	JAE	short GetFCBBye
 11585                                  	;mov	[si+24h],dh
 11586 0000178F 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 11587                                  GoodPath:	; 16/12/2022
 11588                                  GetFCBBye:
 11589 00001792 E9BEEE                  	jmp	FCB_RET_OK
 11590                                  
 11591                                  ;Break <$FCB_Delete - remove several files that match the input FCB>
 11592                                  ;----------------------------------------------------------------------------
 11593                                  ;
 11594                                  ;**	$FCB_Delete - Delete from FCB Template
 11595                                  ;
 11596                                  ;	given an FCB, remove all directory entries in the current
 11597                                  ;	directory that have names that match the FCB's ?  marks.
 11598                                  ;
 11599                                  ;	ENTRY	(DS:DX) = address of FCB
 11600                                  ;	EXIT	entries matching the FCB are deleted
 11601                                  ;		(al) = ff iff no entries were deleted
 11602                                  ;	USES	all
 11603                                  ;
 11604                                  ;----------------------------------------------------------------------------
 11605                                  ;
 11606                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11607                                  
 11608                                  _$FCB_DELETE:		; System call 19
 11609                                  					; OpenBuf is in DOSDATA
 11610 00001795 BF[BE03]                	MOV	DI,OPENBUF 		; appropriate place 
 11611                                  
 11612 00001798 E87853                  	call	TransFCB		; convert FCB to path
 11613 0000179B 7207                    	JC	short BadPath 		; signal no deletions
 11614                                  
 11615 0000179D 16                      	push	SS
 11616 0000179E 1F                      	pop	DS			; SS is DOSDATA
 11617                                  
 11618 0000179F E8900D                  	call	DOS_DELETE		; wham
 11619                                  	;JC	short BadPath
 11620                                  	; 16/12/2022
 11621 000017A2 73EE                    	jnc 	short GoodPath
 11622                                  ;GoodPath:
 11623                                  ;	;jmp	FCB_RET_OK		; do a good return
 11624                                  ;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11625                                  ;	jmp	short GetFCBBye
 11626                                  
 11627                                  BadPath:
 11628                                  	; Error code is in AX
 11629                                  
 11630 000017A4 E9AFEE                  	jmp	FCB_RET_ERR		; let someone else signal the error
 11631                                  
 11632                                  ;Break <$Get_FCB_File_Length - return the length of a file>
 11633                                  ;----------------------------------------------------------------------------
 11634                                  ;
 11635                                  ;   $Get_FCB_File_Length - set the random record field to the length of the
 11636                                  ;	file in records (rounded up if partial).
 11637                                  ;
 11638                                  ;   Inputs:	DS:DX - point to a possible extended FCB
 11639                                  ;   Outputs:	Random record field updated to reflect the number of records
 11640                                  ;   Registers modified: all
 11641                                  ;
 11642                                  ;----------------------------------------------------------------------------
 11643                                  ;
 11644                                  	; 15/01/2024
 11645                                  
 11646                                  _$GET_FCB_FILE_LENGTH:
 11647                                  
 11648 000017A7 E8BD04                  	call	GetExtended		; get real FCB pointer
 11649                                  					; DX points to Input FCB
 11650                                  
 11651                                  					; OpenBuf is in DOSDATA
 11652 000017AA BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 11653                                  
 11654 000017AD 1E                      	push	ds			; save pointer to true FCB
 11655 000017AE 56                      	push	si
 11656 000017AF E86153                  	call	TransFCB		; Trans name DS:DX, sets SATTRIB
 11657 000017B2 5E                      	pop	si
 11658 000017B3 1F                      	pop	ds
 11659 000017B4 72EE                    	JC	short BadPath
 11660 000017B6 1E                      	push	ds			; save pointer
 11661 000017B7 56                      	push	si
 11662 000017B8 16                      	push	ss		
 11663 000017B9 1F                      	pop	ds
 11664 000017BA E88511                  	call	GET_FILE_INFO		; grab the info
 11665 000017BD 5E                      	pop	si			; get pointer back
 11666 000017BE 1F                      	pop	ds
 11667 000017BF 72E3                    	JC	short BadPath 		; invalid something
 11668                                  	; 15/01/2024
 11669                                  	;MOV	DX,BX (*)		; get high order size
 11670                                  	;MOV	AX,DI (**)		; get low order size
 11671 000017C1 89D8                    	mov	ax,bx ; hw of file size
 11672                                  	;
 11673                                  	;mov	bx,[si+0Eh]
 11674 000017C3 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 11675 000017C6 09DB                    	OR	BX,BX			; empty record => 0 size for file
 11676 000017C8 7502                    	JNZ	short GetSize 		; not empty
 11677                                  	;MOV	BX,128
 11678 000017CA B380                    	mov	bl,128	; 15/01/2024
 11679                                  GetSize:
 11680                                  	; 15/01/2024
 11681                                  	;MOV	DI,AX			; save low order word
 11682                                  	;MOV	AX,DX			; move high order for divide
 11683                                  	;xchg	ax,dx ; (*)
 11684                                  	; ax = hw of file size
 11685                                  
 11686 000017CC 31D2                    	XOR	DX,DX			; clear out high
 11687 000017CE F7F3                    	DIV	BX			; wham
 11688 000017D0 50                      	PUSH	AX			; save dividend
 11689 000017D1 89F8                    	MOV	AX,DI ; (**)		; get low order piece
 11690 000017D3 F7F3                    	DIV	BX			; wham
 11691 000017D5 89D1                    	MOV	CX,DX			; save remainder
 11692 000017D7 5A                      	POP	DX			; get high order dividend
 11693 000017D8 E306                    	JCXZ	LengthStore		; no roundup
 11694 000017DA 83C001                  	ADD	AX,1
 11695 000017DD 83D200                  	ADC	DX,0			; 32-bit increment
 11696                                  LengthStore:
 11697                                  	;mov	[si+21h],ax
 11698 000017E0 894421                  	MOV	[SI+SYS_FCB.RR],AX	; store low order
 11699                                  	;mov	[si+23h],dl
 11700 000017E3 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; store high order
 11701 000017E6 08F6                    	OR	DH,DH
 11702 000017E8 74A8                    	JZ	short GoodPath		; not storing insignificant zero
 11703                                  	;mov	[si+24h],dh
 11704 000017EA 887424                  	MOV	[SI+SYS_FCB.RR+3],DH	; save that high piece
 11705                                  	; 16/12/2022
 11706                                  GoodRet:
 11707                                  	;jmp	FCB_RET_OK
 11708 000017ED EBA3                    	jmp	short GoodPath
 11709                                  
 11710                                  ;Break <$FCB_Close - close a file>
 11711                                  ;----------------------------------------------------------------------------
 11712                                  ;
 11713                                  ;   $FCB_Close - given an FCB, look up the SFN and close it. Do not free it
 11714                                  ;	as the FCB may be used for further I/O
 11715                                  ;
 11716                                  ;   Inputs:	DS:DX point to FCB
 11717                                  ;   Outputs:	AL = FF if file was not found on disk
 11718                                  ;   Registers modified: all
 11719                                  ;
 11720                                  ;----------------------------------------------------------------------------
 11721                                  ;
 11722                                  
 11723                                  	; 16/01/2024
 11724                                  
 11725                                  _$FCB_CLOSE:		; System call 16
 11726                                  
 11727 000017EF 30C0                    	XOR	AL,AL			; default search attributes
 11728 000017F1 E87304                  	call	GetExtended		; DS:SI point to real FCB
 11729 000017F4 7403                    	JZ	short NoAttr		; not extended
 11730 000017F6 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 11731                                  NoAttr:
 11732                                  					; SS override
 11733 000017F9 36A2[6B05]              	MOV	[SS:ATTRIB],AL		; stash away found attributes
 11734 000017FD E8D503                  	call	SFTFromFCB
 11735 00001800 72EB                    	JC	short GoodRet 		; MZ 16 Jan Assume death
 11736                                  
 11737                                  	; If the sharer is present, then the SFT is not regenable. Thus, 
 11738                                  	; there is no need to set the SFT's attribute.
 11739                                  
 11740                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 11741                                  	;;; done
 11742                                  
 11743                                  	;mov	al,[es:di+4]
 11744 00001802 268A4504                	MOV	AL,[ES:DI+SF_ENTRY.sf_attr]
 11745 00001806 30E4                    	XOR	AH,AH
 11746 00001808 50                      	PUSH	AX
 11747                                  
 11748                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 11749                                  	;;; done
 11750                                  
 11751 00001809 E8335B                  	call	CheckShare
 11752 0000180C 7508                    	JNZ	short NoStash
 11753 0000180E 36A0[6B05]              	MOV	AL,[SS:ATTRIB]
 11754                                  	;mov	[es:di+4],al
 11755 00001812 26884504                	MOV	[ES:DI+SF_ENTRY.sf_attr],AL ; attempted attribute for close
 11756                                  NoStash:
 11757                                  
 11758                                  ; 16/01/2024
 11759                                  %if 0
 11760                                  	;mov	ax,[si+14h]
 11761                                  	MOV	AX,[SI+SYS_FCB.FDATE] ; move in the time and date
 11762                                  	;mov	[es:di+0Fh],ax
 11763                                  	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 11764                                  	;mov	ax,[si+16h]
 11765                                  	MOV	AX,[SI+SYS_FCB.FTIME]
 11766                                  	;mov	[es:di+0Dh],ax
 11767                                  	MOV	[ES:DI+SF_ENTRY.sf_time],AX
 11768                                  	;mov	ax,[si+10h]
 11769                                  	MOV	AX,[SI+SYS_FCB.FILSIZ]
 11770                                  	;mov	[es:di+11h],ax
 11771                                  	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 11772                                  	;mov	ax,[si+12h]
 11773                                  	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 11774                                  	;mov	[es:di+13h],ax
 11775                                  	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 11776                                  	;or	word [es:di+5],4000h
 11777                                  	; 17/12/2022
 11778                                  	or	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8) ; 40h
 11779                                  	;OR	word [ES:DI+SF_ENTRY.sf_flags],sf_close_nodate
 11780                                  %else
 11781                                  	; 16/01/2024 (PCDOS 7.1 IBMDOS.COM)
 11782 00001816 1E                      	push	ds
 11783                                  	;lds	ax,[si+14h]
 11784 00001817 C54414                  	lds	ax,[si+SYS_FCB.FDATE]	; move in the time and date
 11785                                  	;mov	[es:di+0Fh],ax
 11786 0000181A 2689450F                	mov	[es:di+SF_ENTRY.sf_date],ax
 11787                                  	;mov	[es:di+0Dh],ds		
 11788 0000181E 268C5D0D                	mov	[es:di+SF_ENTRY.sf_time],ds
 11789 00001822 1F                      	pop	ds
 11790                                  	;lds	ax,[si+10h]
 11791 00001823 C54410                  	lds	ax,[si+SYS_FCB.FILSIZ]
 11792                                  	;mov	[es:di+11h],ax
 11793 00001826 26894511                	mov	[es:di+SF_ENTRY.sf_size],ax
 11794                                  	;mov	[es:di+13h],ds
 11795 0000182A 268C5D13                	mov	[es:di+SF_ENTRY.sf_size+2],ds
 11796                                  	; 16/01/2024
 11797                                  	;;or	word [es:di+5], 4000h
 11798                                  	;or	word [es:di+SF_ENTRY.sf_flags], sf_close_nodate
 11799 0000182E 26804D0640              	or	byte [es:di+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8) ; 40h
 11800                                  %endif
 11801                                  
 11802 00001833 16                      	push	ss
 11803 00001834 1F                      	pop	ds
 11804 00001835 E80317                  	call	DOS_CLOSE	; wham
 11805 00001838 C43E[9E05]              	LES	DI,[THISSFT]
 11806                                  
 11807                                  	;;; 9/8/86 F.C. restore SFT attribute
 11808 0000183C 59                      	POP	CX
 11809                                  	;mov	[es:di+4],cl
 11810 0000183D 26884D04                	MOV	[ES:DI+SF_ENTRY.sf_attr],CL
 11811                                  	;;; 9/8/86 F.C. restore SFT attribute
 11812                                  
 11813 00001841 9C                      	PUSHF
 11814                                  	;test	word [es:di],0FFFFh
 11815                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],0
 11816                                  				; zero ref count gets blasted
 11817 00001842 26833D00                	cmp	word [ES:DI],0
 11818 00001846 7507                    	jnz     short CloseOK
 11819 00001848 50                      	PUSH	AX
 11820 00001849 B04D                    	MOV	AL,'M' ; 4Dh
 11821 0000184B E8FC02                  	call	BlastSFT
 11822 0000184E 58                      	POP	AX
 11823                                  CloseOK:
 11824 0000184F 9D                      	POPF
 11825 00001850 739B                    	JNC	short GoodRet
 11826                                  	;cmp	al,6
 11827 00001852 3C06                    	CMP	AL,error_invalid_handle
 11828 00001854 7497                    	JZ	short GoodRet
 11829                                  	;mov	al,2
 11830 00001856 B002                    	MOV	AL,error_file_not_found
 11831                                  fren90:
 11832                                  	; 16/12/2022
 11833                                  fcb_close_err:
 11834 00001858 E9FBED                  	jmp	FCB_RET_ERR
 11835                                  
 11836                                  ;
 11837                                  ;----------------------------------------------------------------------------
 11838                                  ;
 11839                                  ;**	$FCB_Rename - Rename a File
 11840                                  ;
 11841                                  ;	$FCB_Rename - rename a file in place within a directory. Renames
 11842                                  ;	multiple files copying from the meta characters.
 11843                                  ;
 11844                                  ;	ENTRY	DS:DX point to an FCB. The normal name field is the source
 11845                                  ;		    name of the files to be renamed. Starting at offset 11h
 11846                                  ;		    in the FCB is the destination name.
 11847                                  ;	EXIT	AL = 0 -> no error occurred and all files were renamed
 11848                                  ;		AL = FF -> some files may have been renamed but:
 11849                                  ;			rename to existing file or source file not found
 11850                                  ;	USES	ALL
 11851                                  ;
 11852                                  ;----------------------------------------------------------------------------
 11853                                  ;
 11854                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11855                                  
 11856                                  _$FCB_RENAME:		; System call 23
 11857                                  
 11858 0000185B E80904                  	call	GetExtended		; get pointer to real FCB
 11859 0000185E 52                      	push	dx
 11860 0000185F 8A04                    	MOV	AL,[SI] 		; get drive byte
 11861 00001861 83C610                  	ADD	SI,10h			; point to destination
 11862                                  
 11863                                  					; RenBuf is in DOSDATA
 11864 00001864 BF[3E04]                	MOV	DI,RENBUF		; point to destination buffer
 11865 00001867 FF34                    	push	word [SI]
 11866 00001869 1E                      	push	ds
 11867                                  	;push	di			; save source pointer for TransFCB
 11868                                  	; 16/01/2024 - BugFix !
 11869 0000186A 56                      	push	si
 11870 0000186B 8804                    	MOV	[SI],AL			; drop in real drive
 11871 0000186D 89F2                    	MOV	DX,SI			; let TransFCB know where the FCB is
 11872 0000186F E8A152                  	call	TransFCB		; munch this pathname
 11873 00001872 5E                      	pop	si
 11874 00001873 1F                      	pop	ds	
 11875 00001874 8F04                    	pop	WORD [SI]		; get path back
 11876 00001876 5A                      	pop	dx			; Original FCB pointer
 11877 00001877 72DF                    	JC	short fren90		; bad path -> error
 11878                                  
 11879                                  					; SS override for WFP_Start & Ren_WFP
 11880 00001879 368B36[B205]            	MOV	SI,[ss:WFP_START]	; get pointer
 11881 0000187E 368936[B405]            	MOV	[ss:REN_WFP],SI		; stash it
 11882                                  
 11883                                  					; OpenBuf is in DOSDATA
 11884 00001883 BF[BE03]                	MOV	DI,OPENBUF		; appropriate spot
 11885 00001886 E88A52                  	call	TransFCB		; wham
 11886                                  					; NOTE that this call is pointing
 11887                                  					;  back to the ORIGINAL FCB so
 11888                                  					;  SATTRIB gets set correctly
 11889 00001889 72CD                    	JC	short fren90		; error
 11890 0000188B E8820E                  	call	DOS_RENAME
 11891 0000188E 72C8                    	JC	short fren90
 11892                                  	; 16/12/2022
 11893 00001890 E9C0ED                  	jmp	FCB_RET_OK
 11894                                  	
 11895                                  ;	Error -
 11896                                  ;
 11897                                  ;	(al) = error code
 11898                                  
 11899                                  	; 16/12/2022
 11900                                  ;fren90:	
 11901                                  ;	;jmp	FCB_RET_ERR
 11902                                  ;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11903                                  ;	jmp	short fcb_close_err
 11904                                  
 11905                                  ;Break <Misbehavior fixers>
 11906                                  ;
 11907                                  ;   FCBs suffer from several problems. First, they are maintained in the
 11908                                  ;   user's space so he may move them at will. Second, they have a small
 11909                                  ;   reserved area that may be used for system information. Third, there was
 11910                                  ;   never any "rules for behavior" for FCBs; there was no protocol for their
 11911                                  ;   usage.
 11912                                  ;
 11913                                  ;   This results in the following misbehavior:
 11914                                  ;
 11915                                  ;	infinite opens of the same file:
 11916                                  ;
 11917                                  ;	While (TRUE) {			While (TRUE) {
 11918                                  ;	    FCBOpen (FCB);		    FCBOpen (FCB);
 11919                                  ;	    Read (FCB); 		    Write (FCB);
 11920                                  ;	    }				    }
 11921                                  ;
 11922                                  ;	infinite opens of different files:
 11923                                  ;
 11924                                  ;	While (TRUE) {			While (TRUE) {
 11925                                  ;	    FCBOpen (FCB[i++]); 	    FCBOpen (FCB[i++]);
 11926                                  ;	    Read (FCB); 		    Write (FCB);
 11927                                  ;	    }				    }
 11928                                  ;
 11929                                  ;	multiple closes of the same file:
 11930                                  ;
 11931                                  ;	FCBOpen (FCB);
 11932                                  ;	while (TRUE)
 11933                                  ;	    FCBClose (FCB);
 11934                                  ;
 11935                                  ;	I/O after closing file:
 11936                                  ;
 11937                                  ;	FCBOpen (FCB);
 11938                                  ;	while (TRUE) {
 11939                                  ;	    FCBWrite (FCB);
 11940                                  ;	    FCBClose (FCB);
 11941                                  ;	    }
 11942                                  ;
 11943                                  ;   The following is am implementation of a methodology for emulating the
 11944                                  ;   above with the exception of I/O after close. We are NOT attempting to
 11945                                  ;   resolve that particular misbehavior. We will enforce correct behaviour in
 11946                                  ;   FCBs when they refer to a network file or when there is file sharing on
 11947                                  ;   the local machine.
 11948                                  ;
 11949                                  ;   The reserved fields of the FCB (10 bytes worth) is divided up into various
 11950                                  ;   structures depending on the file itself and the state of operations of the
 11951                                  ;   OS. The information contained in this reserved field is enough to
 11952                                  ;   regenerate the SFT for the local non-shared file. It is assumed that this
 11953                                  ;   regeneration procedure may be expensive. The SFT for the FCB is
 11954                                  ;   maintained in a LRU cache as the ONLY performance inprovement.
 11955                                  ;
 11956                                  ;   No regeneration of SFTs is attempted for network FCBs.
 11957                                  ;
 11958                                  ;   To regenerate the SFT for a local FCB, it is necessary to determine if the
 11959                                  ;   file sharer is working. If the file sharer is present then the SFT is not
 11960                                  ;   regenerated.
 11961                                  ;
 11962                                  ;   Finally, if there is no local sharing, the full name of the file is no
 11963                                  ;   longer available. We can make up for this by using the following
 11964                                  ;   information:
 11965                                  ;
 11966                                  ;	The Drive number (from the DPB).
 11967                                  ;	The physical sector of the directory that contains the entry.
 11968                                  ;	The relative position of the entry in the sector.
 11969                                  ;	The first cluster field.
 11970                                  ;	The last used SFT.
 11971                                  ;      OR In the case of a device FCB
 11972                                  ;	The low 6 bits of sf_flags (indicating device type)
 11973                                  ;	The pointer to the device header
 11974                                  ;
 11975                                  ;   We read in the particular directory sector and examine the indicated
 11976                                  ;   directory entry. If it matches, then we are kosher; otherwise, we fail.
 11977                                  ;
 11978                                  ;   Some key items need to be remembered:
 11979                                  ;
 11980                                  ;	Even though we are caching SFTs, they may contain useful sharing
 11981                                  ;	information. We enforce good behavior on the FCBs.
 11982                                  ;
 11983                                  ;	Network support must not treat FCBs as impacting the ref counts on
 11984                                  ;	open VCs. The VCs may be closed only at process termination.
 11985                                  ;
 11986                                  ;	If this is not an installed version of the DOS, file sharing will
 11987                                  ;	always be present.
 11988                                  ;
 11989                                  ;	We MUST always initialize lstclus to = firclus when regenerating a
 11990                                  ;	file. Otherwise we start allocating clusters up the wazoo.
 11991                                  ;
 11992                                  ;	Always initialize, during regeneration, the mode field to both isFCB
 11993                                  ;	and open_for_both. This is so the FCB code in the sharer can find the
 11994                                  ;	proper OI record.
 11995                                  ;
 11996                                  ;   The test bits are:
 11997                                  ;
 11998                                  ;	00 -> local file
 11999                                  ;	40 -> sharing local
 12000                                  ;	80 -> network
 12001                                  ;	C0 -> local device
 12002                                  
 12003                                  ;Break	<SaveFCBInfo - store pertinent information from an SFT into the FCB>
 12004                                  ;----------------------------------------------------------------------------
 12005                                  ;
 12006                                  ;   SaveFCBInfo - given an FCB and its associated SFT, copy the relevant
 12007                                  ;	pieces of information into the FCB to allow for subsequent
 12008                                  ;	regeneration. Poke LRU also.
 12009                                  ;
 12010                                  ;   Inputs:	ThisSFT points to a complete SFT.
 12011                                  ;		DS:SI point to the FCB (not an extended one)
 12012                                  ;   Outputs:	The relevant reserved fields in the FCB are filled in.
 12013                                  ;		DS:SI preserved
 12014                                  ;		ES:DI point to sft
 12015                                  ;   Registers modified: All
 12016                                  ;
 12017                                  ;
 12018                                  ;----------------------------------------------------------------------------
 12019                                  ;
 12020                                  
 12021                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12022                                  
 12023                                  SaveFCBInfo:
 12024                                  
 12025 00001893 36C43E[9E05]            	LES	DI,[SS:THISSFT]		; SS override
 12026 00001898 E8C9F9                  	call	IsSFTNet
 12027 0000189B 740B                    	JZ	short SaveLocal		; if not network then save local info
 12028                                  ;
 12029                                  ;----- In net support -----
 12030                                  ;
 12031                                  	; 17/05/2019 - Retro DOS v4.0
 12032                                  
 12033                                  	; MSDOS 3.3
 12034                                  	;;mov	ax,[es:di+1Dh]
 12035                                  	;mov	ax,[es:di+SF_ENTRY.sf_dirsec]
 12036                                  	;;mov	[si+1Ah],ax
 12037                                  	;mov	[si+fcb_net_handle],ax
 12038                                  	;push	es
 12039                                  	;push	di
 12040                                  	;;les	di,[es:di+19h]
 12041                                  	;LES	DI,[ES:DI+sf_netid]
 12042                                  	;;mov	[si+1Ch],di
 12043                                  	;MOV	[SI+fcb_netID],DI	; save net ID
 12044                                  	;;mov 	[si+1Eh],es
 12045                                  	;MOV	[SI+fcb_netID+2],ES
 12046                                  	;pop	di
 12047                                  	;pop	es
 12048                                  
 12049                                  	; MSDOS 6.0
 12050                                  	;mov	ax,[es:di+0Bh]
 12051 0000189D 268B450B                	MOV	AX,[ES:DI+sf_serial_ID] ;AN000;;IFS. save IFS ID
 12052                                  	;mov	[si+1Ch],ax
 12053 000018A1 89441C                  	MOV	[SI+fcb_netID],ax	;AN000;;IFS.
 12054                                  	
 12055                                  	;mov	bl,80h
 12056 000018A4 B380                    	MOV	BL,FCBNETWORK
 12057                                  ;
 12058                                  ;----- END In net support -----
 12059                                  ;
 12060 000018A6 EB65                    	jmp	SHORT SaveSFN
 12061                                  
 12062                                  SaveLocal:
 12063                                  	;IF	Installed
 12064 000018A8 E8945A                  	call	CheckShare
 12065                                  	;JZ	short SaveNoShare	; no sharer
 12066                                  	;JMP	short SaveShare		; sharer present
 12067                                  	; 16/12/2022
 12068                                  	; 28/07/2019
 12069 000018AB 755B                    	jnz	short SaveShare
 12070                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12071                                  	;JZ	short SaveNoShare	; no sharer
 12072                                  	;JMP	short SaveShare		; sharer present
 12073                                  
 12074                                  SaveNoShare:
 12075                                  	;;test 	word [es:di+5],80h
 12076                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 12077 000018AD 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 80h	
 12078 000018B2 7542                    	JNZ	short SaveNoShareDev	; Device
 12079                                  
 12080                                  	; Save no sharing local file information
 12081                                  
 12082                                  	;;mov	ax,[es:di+1Dh]  ; MSDOS 3.3
 12083                                  	;mov	ax,[es:di+1Bh]  ; MSDOS 6.0
 12084 000018B4 268B451B                	MOV	AX,[ES:DI+SF_ENTRY.sf_dirsec] ; get directory sector F.C.
 12085                                  	;mov	[si+1Dh],ax
 12086 000018B8 89441D                  	MOV	[SI+fcb_nsl_dirsec],AX
 12087                                  
 12088                                  	; MSDOS 6.0
 12089                                  
 12090                                  	;SR; Store high byte of directory sector
 12091                                  	;mov	ax,[es:di+1Dh]
 12092 000018BB 268B451D                	mov	ax,[es:di+SF_ENTRY.sf_dirsec+2] ; get high word
 12093                                  	
 12094                                  	; SR;
 12095                                  	; We have to store the read-only and archive attributes of the file.
 12096                                  	; We extract it from the SFT and store it in the top two bits of the 
 12097                                  	; sector number ( sector number == 22 bits only )
 12098                                  
 12099                                  	;mov	bl,[es:di+4]
 12100 000018BF 268A5D04                	mov	bl,[es:di+SF_ENTRY.sf_attr]
 12101 000018C3 88DF                    	mov	bh,bl
 12102 000018C5 D0CB                    	ror	bl,1
 12103 000018C7 D0E7                    	shl	bh,1
 12104 000018C9 08FB                    	or	bl,bh
 12105 000018CB 80E3C0                  	and	bl,0C0h
 12106 000018CE 08D8                    	or	al,bl
 12107                                  	;mov	[si+18h],al ; 08/11/2022
 12108 000018D0 884418                  	mov	[si+fcb_sfn],al	; sector number = 22 bits
 12109                                  
 12110                                  	; MSDOS 6.0 (& MSDOS 3.3)
 12111                                  	;mov	al,[es:di+1Fh]
 12112 000018D3 268A451F                	MOV	AL,[ES:DI+SF_ENTRY.sf_dirpos] ; location in sector
 12113                                  	;mov	[si+1Fh],al
 12114 000018D7 88441F                  	MOV	[SI+fcb_nsl_dirpos],AL
 12115                                  	;mov	ax,[es:di+0Bh]
 12116 000018DA 268B450B                	MOV	AX,[ES:DI+SF_ENTRY.sf_firclus] ; first cluster
 12117                                  	;mov	[si+1Bh],ax
 12118 000018DE 89441B                  	MOV	[SI+fcb_nsl_firclus],AX
 12119 000018E1 B300                    	MOV	BL,0
 12120                                  
 12121                                  	; Create the bits field from the dirty/device bits of the flags word 
 12122                                  	; and the mode byte
 12123                                  
 12124                                  SetFCBBits:
 12125                                  	;mov	ax,[es:di+5]
 12126 000018E3 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 12127 000018E7 24C0                    	AND	AL,0C0h 		; mask off drive bits
 12128                                  	;or	al,[es:di+2]
 12129 000018E9 260A4502                	OR	AL,[ES:DI+SF_ENTRY.sf_mode] ; stick in open mode
 12130                                  	;mov	[si+1Ah], al
 12131 000018ED 88441A                  	MOV	[SI+fcb_nsl_bits],AL	; save dirty info
 12132                                  
 12133                                  	; MSDOS 6.0
 12134                                  	
 12135                                  	; SR;
 12136                                  	; Check if we came here for local file or device. If for local file, 
 12137                                  	; skip setting of SFT index
 12138                                  	
 12139 000018F0 08DB                    	or	bl,bl
 12140 000018F2 742A                    	jz	short SaveNoSFN		; do not save SFN if local file
 12141                                  
 12142 000018F4 EB17                    	JMP	short SaveSFN 		; go and save SFN
 12143                                  
 12144                                  	; Save no sharing local device information
 12145                                  
 12146                                  SaveNoShareDev:
 12147                                  	;mov	ax,[es:di+7]
 12148 000018F6 268B4507                	MOV	AX,[ES:DI+SF_ENTRY.sf_devptr]
 12149                                  	;mov	[si+1Ah],ax
 12150 000018FA 89441A                  	MOV	[SI+fcb_nsld_drvptr],AX
 12151                                  	;mov	ax,[es:di+9]
 12152 000018FD 268B4509                	MOV	AX,[ES:DI+SF_ENTRY.sf_devptr+2]
 12153 00001901 89441C                  	MOV	[SI+fcb_nsld_drvptr+2],AX
 12154                                  	;mov	bl,40h
 12155 00001904 B340                    	MOV	BL,FCBDEVICE
 12156                                  	; 28/12/2022
 12157 00001906 EBDB                    	JMP	short SetFCBBits	; go and save SFN
 12158                                  
 12159                                  SaveShare:
 12160                                  	;ENDIF
 12161                                  
 12162                                  ;----- In share support -----
 12163                                  
 12164                                  	;call	far [ss:ShSave]
 12165 00001908 36FF1E[B800]            	Call	far [ss:JShare+(10*4)] ; 10 = ShSave ; SS Override
 12166                                  
 12167                                  ;----- end in share support -----
 12168                                  
 12169                                  	; 17/05/2019
 12170                                  
 12171                                  SaveSFN:
 12172                                  	;lea	ax,[di-6]
 12173 0000190D 8D45FA                  	LEA	AX,[DI-SFT.SFTable]
 12174                                  	
 12175                                  	; Adjust for offset to table.
 12176                                  	
 12177 00001910 362B06[4000]            	SUB	AX,[SS:SFTFCB]		; SS override for SftFCB
 12178                                  
 12179 00001915 53                      	push	bx			;bx = FCB type (net/Share or local)
 12180                                  	;;mov	bl,53 ; MSDOS 3.3
 12181                                  	;mov	bl,59 ; MSDOS 6.0
 12182 00001916 B33B                    	MOV	BL,SF_ENTRY.size
 12183 00001918 F6F3                    	DIV	BL
 12184                                  	;mov	[si+18h],al
 12185 0000191A 884418                  	MOV	[SI+fcb_sfn],AL		; last used SFN
 12186 0000191D 5B                      	pop	bx			;restore bx
 12187                                  
 12188                                  SaveNoSFN:
 12189                                  	;mov	ax,[es:di+5]
 12190 0000191E 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 12191 00001922 243F                    	AND	AL,3Fh			; get real drive
 12192 00001924 08D8                    	OR	AL,BL
 12193                                  	;mov	[si+19h],al
 12194 00001926 884419                  	MOV	[SI+fcb_l_drive],AL
 12195                                  
 12196 00001929 36A1[1000]              	MOV	AX,[SS:FCBLRU]		; get lru count
 12197 0000192D 40                      	INC	AX
 12198                                  	;mov	[es:di+15h],ax
 12199 0000192E 26894515                	MOV	[ES:DI+sf_LRU],AX
 12200 00001932 7506                    	JNZ	short SimpleStuff
 12201                                  	
 12202                                  	; lru flag overflowed. Run through all FCB sfts and adjust:  
 12203                                  	; LRU < 8000H get set to 0. Others -= 8000h. This LRU = 8000h
 12204                                  	
 12205                                  	;mov	bx,15h
 12206 00001934 BB1500                  	MOV	BX,SF_ENTRY.sf_position
 12207 00001937 E80500                  	call	ResetLRU
 12208                                  
 12209                                  	; Set new LRU to AX
 12210                                  SimpleStuff:
 12211 0000193A 36A3[1000]              	MOV	[SS:FCBLRU],AX
 12212 0000193E C3                      	retn
 12213                                  
 12214                                  ;Break	<ResetLRU - reset overflowed lru counts>
 12215                                  ;----------------------------------------------------------------------------
 12216                                  ;
 12217                                  ;   ResetLRU - during lru updates, we may wrap at 64K. We must walk the
 12218                                  ;   entire set of SFTs and subtract 8000h from their lru counts and truncate
 12219                                  ;   at 0.
 12220                                  ;
 12221                                  ;   Inputs:	BX is offset into SFT field where lru firld is kept
 12222                                  ;		ES:DI point to SFT currently being updated
 12223                                  ;   Outputs:	All FCB SFTs have their lru fields truncated
 12224                                  ;		AX has 8000h
 12225                                  ;   Registers modified: none
 12226                                  ;
 12227                                  ;----------------------------------------------------------------------------
 12228                                  ;
 12229                                  
 12230                                  	; 17/05/2019 - Retro DOS v4.0
 12231                                  ResetLRU:
 12232                                  	; ResetLRU is only called from fcbio.asm. So SS can be assumed to be 
 12233                                  	; DOSDATA
 12234                                  
 12235 0000193F B80080                  	MOV	AX,8000h
 12236 00001942 06                      	push	es
 12237 00001943 57                      	push	di
 12238                                  	;LES	DI,[CS:SFTFCB]		; get pointer to head
 12239 00001944 36C43E[4000]            	LES	DI,[SS:SFTFCB] ; MSDOS 6.0
 12240                                  	;mov	cx,[es:di+4]
 12241 00001949 268B4D04                	MOV	CX,[ES:DI+SFT.SFCount]
 12242                                  	;lea	di,[di+6]
 12243 0000194D 8D7D06                  	LEA	DI,[DI+SFT.SFTable] 	; point at table
 12244                                  ovScan:
 12245 00001950 262901                  	SUB	[ES:DI+BX],AX		; decrement lru count
 12246 00001953 7703                    	JA	short ovLoop
 12247 00001955 268901                  	MOV	[ES:DI+BX],AX		; truncate at 0
 12248                                  ovLoop:
 12249                                  	;;add	di,53	; MSDOS 3.3
 12250                                  	;add	di,59	; MSDOS 6.0	
 12251 00001958 83C73B                  	ADD	DI,SF_ENTRY.size	; advance to next
 12252 0000195B E2F3                    	LOOP	ovScan
 12253 0000195D 5F                      	pop	di
 12254 0000195E 07                      	pop	es
 12255 0000195F 268901                  	MOV	[ES:DI+BX],AX
 12256 00001962 C3                      	retn
 12257                                  
 12258                                  ;IF  0  ; We dont need this routine any more.
 12259                                  ;
 12260                                  ;Break	<SetOpenAge - update the open age of a SFT>
 12261                                  ;----------------------------------------------------------------------------
 12262                                  ;
 12263                                  ;   SetOpenAge - In order to maintain the first N open files in the FCB cache,
 12264                                  ;   we keep the 'open age' or an LRU count based on opens. We update the
 12265                                  ;   count here and fill in the appropriate field.
 12266                                  ;
 12267                                  ;   Inputs:	ES:DI point to SFT
 12268                                  ;   Outputs:	ES:DI has the open age field filled in.
 12269                                  ;		If open age has wraparound, we will have subtracted 8000h
 12270                                  ;		    from all open ages.
 12271                                  ;   Registers modified: AX
 12272                                  ;
 12273                                  ;----------------------------------------------------------------------------
 12274                                  ;
 12275                                  ;SetOpenAge:
 12276                                  ;	; 20/07/2018 - Retro DOS v3.0
 12277                                  ;	; MSDOS 3.3 - IBMDOS.COM, Offset 2597h 
 12278                                  ;	; (& MSDOS 6.0, FCBIO.ASM)
 12279                                  ;
 12280                                  ;	; SetOpenAge is called from fcbio2.asm. SS can be assumed to be valid.
 12281                                  ;
 12282                                  ;	MOV	AX,[CS:OpenLRU]	; SS override
 12283                                  ;	INC	AX
 12284                                  ;	;mov	[es:di+17h],ax
 12285                                  ;	MOV	[ES:DI+sf_OpenAge],AX
 12286                                  ;	JNZ	short SetDone
 12287                                  ;	;mov	bx,17h
 12288                                  ;	MOV	BX,SF_ENTRY.sf_position+2 ; mov bx,sf_OpenAge
 12289                                  ;	call	ResetLRU
 12290                                  ;SetDone:
 12291                                  ;	MOV	[CS:OpenLRU],AX
 12292                                  ;	retn
 12293                                  ;
 12294                                  ;ENDIF	; SetOpenAge no longer needed
 12295                                  
 12296                                  ; 21/07/2018 - Retro DOS v3.0
 12297                                  ; LRUFCB for MSDOS 6.0 !
 12298                                  
 12299                                  ;Break	<LRUFCB - perform LRU on FCB sfts>
 12300                                  ;----------------------------------------------------------------------------
 12301                                  ;
 12302                                  ;   LRUFCB - find LRU fcb in cache. Set ThisSFT and return it. We preserve
 12303                                  ;	the first keepcount sfts if they are network sfts or if sharing is
 12304                                  ;	loaded.  If carry is set then NO BLASTING is NECESSARY.
 12305                                  ;
 12306                                  ;   Inputs:	none
 12307                                  ;   Outputs:	ES:DI point to SFT
 12308                                  ;		ThisSFT points to SFT
 12309                                  ;		SFT is zeroed
 12310                                  ;		Carry set of closes failed
 12311                                  ;   Registers modified: none
 12312                                  ;
 12313                                  ;----------------------------------------------------------------------------
 12314                                  ;
 12315                                  ; MSDOS 6.0
 12316                                  ;IF 0	; rewritten this routine
 12317                                  ;
 12318                                  ;LRUFCB: ; MSDOS 3.3 - IBMDOS.COM (1987) - Offset 25ADh
 12319                                  ;	call	save_world
 12320                                  ;	
 12321                                  ; Find nth oldest NET/SHARE FCB. We want to find its age for the second scan
 12322                                  ; to find the lease recently used one that is younger than the open age.  We
 12323                                  ; operate be scanning the list n times finding the least age that is greater
 12324                                  ; or equal to the previous minimum age.
 12325                                  ;
 12326                                  ;   BP is the count of times we need to go through this loop.
 12327                                  ;   AX is the current acceptable minimum age to consider
 12328                                  ;
 12329                                  ;	mov	bp,[CS:KEEPCOUNT]	; k = keepcount;
 12330                                  ;	XOR	AX,AX			; low = 0;
 12331                                  ;
 12332                                  ; If we've scanned the table n times, then we are done.
 12333                                  ;
 12334                                  ;lru1:
 12335                                  ;	CMP	bp,0			; while (k--) {
 12336                                  ;	JZ	short lru75
 12337                                  ;	DEC	bp
 12338                                  ;
 12339                                  ; Set up for scan.
 12340                                  ;
 12341                                  ;   AX is the minimum age for consideration
 12342                                  ;   BX is the minimum age found during the scan
 12343                                  ;   SI is the position of the entry that corresponds to BX
 12344                                  ;
 12345                                  ;	MOV	BX,-1			;     min = 0xffff;
 12346                                  ;	MOV	si,BX			;     pos = 0xffff;
 12347                                  ;	LES	DI,[CS:SFTFCB]		;     for (CX=FCBCount; CX>0; CX--)
 12348                                  ;	;mov	cx,[es:di+4]
 12349                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 12350                                  ;	;lea	di,[di+6]
 12351                                  ;	LEA	DI,[DI+SFT.SFTable]
 12352                                  ;
 12353                                  ; Innermost loop.  If the current entry is free, then we are done.  Or, if the
 12354                                  ; current entry is busy (indicating a previous aborted allocation), then we
 12355                                  ; are done.  In both cases, we use the found entry.
 12356                                  ;
 12357                                  ;lru2:
 12358                                  ;	cmp	word [es:di],0
 12359                                  ;	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0
 12360                                  ;	jz	short lru25
 12361                                  ;	;cmp	word [es:di],-1
 12362                                  ;	;cmp	word [es:di+SFT_ENTRY.sf_ref_count],sf_busy
 12363                                  ;	cmp	word [es:di],sf_busy
 12364                                  ;	jnz	short lru3
 12365                                  ;
 12366                                  ; The entry is usable without further scan.  Go and use it.
 12367                                  ;
 12368                                  ;lru25:
 12369                                  ;	MOV	si,DI			;	      pos = i;
 12370                                  ;	JMP	short lru11		;	      goto got;
 12371                                  ;
 12372                                  ; See if the entry is for the network or for the sharer.
 12373                                  ;
 12374                                  ;  If for the sharer or network then
 12375                                  ;	if the age < current minimum AND >= allowed minimum then
 12376                                  ;	    this entry becomes current minimum
 12377                                  ;
 12378                                  ;lru3:
 12379                                  ;	;test	word [es:di+5],8000h
 12380                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet 
 12381                                  ;					;	  if (!net[i]
 12382                                  ;	JNZ	short lru35
 12383                                  ;if installed
 12384                                  ;	call	CheckShare		;		&& !sharing)
 12385                                  ;	JZ	short lru5		;	  else
 12386                                  ;ENDIF
 12387                                  ;
 12388                                  ; This SFT is for the net or is for the sharer. See if it less than the
 12389                                  ; current minimum.
 12390                                  ;
 12391                                  ;lru35:
 12392                                  ;	;mov	dx,[es:di+17h]
 12393                                  ;	MOV	DX,[ES:DI+sf_OpenAge]
 12394                                  ;	CMP	DX,AX			;	  if (age[i] >= low &&
 12395                                  ;	JB	short lru5
 12396                                  ;	CMP	DX,BX
 12397                                  ;	JAE	short lru5		;	      age[i] < min) {
 12398                                  ;
 12399                                  ; entry is new minimum.  Remember his age.
 12400                                  ;
 12401                                  ;	mov	bx,DX			;	      min = age[i];
 12402                                  ;	mov	si,di			;	      pos = i;
 12403                                  ;
 12404                                  ; End of loop.	gp back for more
 12405                                  ;
 12406                                  ;lru5:
 12407                                  ;	;add	di,53
 12408                                  ;	add	di,SF_ENTRY.size
 12409                                  ;	loop	lru2			;	      }
 12410                                  ;
 12411                                  ; The scan is complete. If we have successfully found a new minimum (pos != -1)
 12412                                  ; set then threshold value to this new minimum + 1. Otherwise, the scan is
 12413                                  ; complete.  Go find LRU.
 12414                                  ;
 12415                                  ;lru6:	
 12416                                  ;	cmp	si,-1			; position not -1?
 12417                                  ;	jz	short lru75		; no, done with everything
 12418                                  ;	lea	ax,[bx+1]		; set new threshold age
 12419                                  ;	jmp	short lru1		; go and loop for more
 12420                                  ;lru65:	
 12421                                  ;	stc
 12422                                  ;	jmp	short LRUDead		;	  return -1;
 12423                                  ;
 12424                                  ; Main loop is done. We have AX being the age+1 of the nth oldest sharer or
 12425                                  ; network entry. We now make a second pass through to find the LRU entry
 12426                                  ; that is local-no-share or has age >= AX
 12427                                  ;
 12428                                  ;lru75:
 12429                                  ;	mov	bx,-1			; min = 0xffff;
 12430                                  ;	mov	si,bx			; pos = 0xffff;
 12431                                  ;	LES	DI,[CS:SFTFCB]		; for (CX=FCBCount; CX>0; CX--)
 12432                                  ;	;mov	cx,[es:di+4]
 12433                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 12434                                  ;	;lea	di,[di+6]
 12435                                  ;	LEA	DI,[DI+SFT.SFTable]
 12436                                  ;
 12437                                  ; If this is is local-no-share then go check for LRU else if age >= threshold
 12438                                  ; then check for lru.
 12439                                  ;
 12440                                  ;lru8:
 12441                                  ;	;test	word [es:di+5],8000h
 12442                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 12443                                  ;	jnz	short lru85		; is for network, go check age
 12444                                  ;	call	CheckShare		; sharer here?
 12445                                  ;	jz	short lru86		; no, go check lru
 12446                                  ;
 12447                                  ; Network or sharer.  Check age
 12448                                  ;
 12449                                  ;lru85:
 12450                                  ;	;cmp	[es:di+17h],ax
 12451                                  ;	cmp	[es:di+sf_OpenAge],ax
 12452                                  ;	jb	short lru9		; age is before threshold, skip it
 12453                                  ;
 12454                                  ; Check LRU
 12455                                  ;
 12456                                  ;lru86:
 12457                                  ;	;cmp	[es:di+15h],bx
 12458                                  ;	cmp	[es:di+sf_LRU],bx	; is LRU less than current LRU?
 12459                                  ;	jae	short lru9		; no, skip this
 12460                                  ;	mov	si,di			; remember position
 12461                                  ;	;mov	bx,[es:di+15h]
 12462                                  ;	mov	bx,[es:di+sf_LRU]	; remember new minimum LRU
 12463                                  ;
 12464                                  ; Done with this entry, go back for more.
 12465                                  ;
 12466                                  ;lru9:
 12467                                  ;	;add	di, 53
 12468                                  ;	add	di,SF_ENTRY.size
 12469                                  ;	loop	lru8
 12470                                  ;
 12471                                  ; Scan is complete. If we found NOTHING that satisfied us then we bomb
 12472                                  ; out. The conditions here are:
 12473                                  ;
 12474                                  ;  No local-no-shares AND all net/share entries are older than threshold
 12475                                  ;
 12476                                  ;lru10:
 12477                                  ;	cmp	si,-1			; if no one f
 12478                                  ;	jz	short lru65		;     return -1;
 12479                                  ;lru11:
 12480                                  ;	mov	di,si
 12481                                  ;	MOV	[CS:THISSFT],DI		; set thissft
 12482                                  ;	MOV	[CS:THISSFT+2],ES
 12483                                  ;
 12484                                  ; If we have sharing or thisSFT is a net sft, then close it until ref count
 12485                                  ; is 0.
 12486                                  ;
 12487                                  ;	;test	word [es:di+5],8000h
 12488                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 12489                                  ;	JNZ	short LRUClose
 12490                                  ;IF INSTALLED
 12491                                  ;	call	CheckShare
 12492                                  ;	JZ	short LRUDone
 12493                                  ;ENDIF
 12494                                  ;
 12495                                  ; Repeat close until ref count is 0
 12496                                  ;
 12497                                  ;LRUClose:
 12498                                  ;	push	ss
 12499                                  ;	pop	ds
 12500                                  ;	LES	DI,[THISSFT]
 12501                                  ;	cmp     word [es:di],0
 12502                                  ;	;CMP	word [ES:DI+SFT.sf_ref_count],0 ; is ref count still <> 0?
 12503                                  ;	JZ	short LRUDone 		; nope, all done
 12504                                  ;	call	DOS_CLOSE
 12505                                  ;	jnc	short LRUClose		; no error => clean up
 12506                                  ;	;cmp	al,6
 12507                                  ;	cmp	al,error_invalid_handle
 12508                                  ;	jz	short LRUClose
 12509                                  ;	stc
 12510                                  ;	JMP	short LRUDead
 12511                                  ;LRUDone:
 12512                                  ;	XOR	AL,AL
 12513                                  ;	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 12514                                  ;
 12515                                  ;LRUDead:
 12516                                  ;	call	restore_world
 12517                                  ;	LES     DI,[CS:THISSFT]
 12518                                  ;	jnc	short LRUFCB_retn
 12519                                  ;LRUFCB_err:
 12520                                  ;	; mov	al, 23h	
 12521                                  ;	MOV	AL,error_FCB_unavailable
 12522                                  ;LRUFCB_retn:	
 12523                                  ;	retn:
 12524                                  ;
 12525                                  ;ENDIF	; LRUFCB has been rewritten below.
 12526                                  
 12527                                  ; 17/05/2019 - Retro DOS v4.0
 12528                                  ; LRUFCB for MSDOS 6.0 !
 12529                                  ;----------------------------------------------------------------------------
 12530                                  ;
 12531                                  ; LruFCB -- allocate the LRU SFT from the SFT Table. The LRU scheme
 12532                                  ; maintains separate counts for net/Share and local SFTs. We allocate a 
 12533                                  ; net/Share SFT only if we do not find a local SFT. This helps keep
 12534                                  ; net/Share SFTs which cannot be regenerated for as long as possible. We
 12535                                  ; optimize regeneration operations by keeping track of the current local
 12536                                  ; SFT. This avoids scanning of the SFTs as long as we have at least one 
 12537                                  ; local SFT in the SFT Block.
 12538                                  ;
 12539                                  ; Inputs: al = 0 => Regenerate SFT operation
 12540                                  ;	    = 1 => Allocate new SFT for Open/Create
 12541                                  ;
 12542                                  ; Outputs: Carry clear
 12543                                  ;	 	es:di = Address of allocated SFT
 12544                                  ;	  	ThisSFT = Address of allocated SFT
 12545                                  ;
 12546                                  ;	  carry set if closes of net/Share files failed 
 12547                                  ;		al = error_FCB_unavailable
 12548                                  ;
 12549                                  ; Registers affected: None
 12550                                  ;
 12551                                  ;----------------------------------------------------------------------------
 12552                                  
 12553                                  ;LruFCB	PROC	NEAR
 12554                                  LRUFCB:
 12555                                  	; 17/05/2019 - Retro DOS v4.0
 12556                                  	; DOSCODE:5805h (MSDOS 6.21, MSDOS.SYS)
 12557                                  
 12558                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12559                                  	; DOSCODE:57F1h (MSDOS 5.0, MSDOS.SYS)
 12560                                  
 12561 00001963 06                      	push	es	; * (MSDOS 6.21)
 12562                                  	
 12563 00001964 E8FBEA                  	call	save_world
 12564                                  	
 12565                                  	;getdseg <ds>		;ds = DOSDATA
 12566 00001967 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 12567                                  
 12568 0000196C 08C0                    	or	al,al		;Check if regenerate allocation
 12569 0000196E 751A                    	jnz	short lru1	;Try to find SFT to use
 12570                                  
 12571                                  	; This is a regen call. If LocalSFT contains the address of a valid 
 12572                                  	; local SFT, just return that SFT to reuse
 12573                                  
 12574 00001970 8B3E[4410]              	mov	di,[LocalSFT]
 12575 00001974 0B3E[4610]              	or	di,[LocalSFT+2]	;is address == 0?
 12576 00001978 7410                    	jz	short lru1	;invalid local SFT, find one
 12577                                  
 12578                                  	; We have found a valid local SFT. Recycle this SFT
 12579                                  
 12580 0000197A C43E[4410]              	les	di,[LocalSFT]
 12581                                  
 12582                                  gotlocalSFT:
 12583 0000197E 893E[9E05]              	mov	[THISSFT],di
 12584 00001982 8C06[A005]              	mov	[THISSFT+2],es
 12585 00001986 F8                      	clc
 12586 00001987 E9AD00                  	jmp	LRUDone		;clear up SFT and return
 12587                                  
 12588                                  lru1:
 12589 0000198A C43E[4000]              	les	di,[SFTFCB]	;es:di = SF Table for FCBs
 12590                                  	;mov	cx,[es:di+4]
 12591 0000198E 268B4D04                	mov	cx,[es:di+SFT.SFCount]	;cx = number of SFTs
 12592                                  	;lea	di,[di+6]
 12593 00001992 8D7D06                  	lea	di,[di+SFT.SFTable]	;es:di = first SFT
 12594                                  
 12595                                  	; We scan through all the SFTs scanning for a free one. It also 
 12596                                  	; remembers the LRU SFT for net/Share SFTs and local SFTs separately. 
 12597                                  	; bx = min. LRU for local SFTs
 12598                                  	; si = pos. of local SFT with min. LRU
 12599                                  	; dx = min. LRU for net/Share SFTs
 12600                                  	; bp = pos. of net/Share SFT with min. LRU
 12601                                  
 12602 00001995 BBFFFF                  	mov	bx,-1		; init. to 0xffff ( max. LRU value )
 12603 00001998 89DE                    	mov	si,bx
 12604 0000199A 89DA                    	mov	dx,bx
 12605 0000199C 89DD                    	mov	bp,bx
 12606                                  
 12607                                  findSFT:
 12608                                  	;See if this SFT is a free one. If so, return it
 12609 0000199E 26830D00                	or	word [es:di],0
 12610                                  	;or	word [es:di+SF_ENTRY.sf_ref_count],0 ;reference count = 0 ?
 12611 000019A2 744D                    	jz	short gotSFT	;yes, SFT is free
 12612                                  	;;cmp	word [es:di],-1
 12613                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy ;Is it busy?
 12614 000019A4 26833DFF                	cmp	word [es:di],sf_busy ; -1 
 12615 000019A8 7447                    	jz	short gotSFT	;no, can use it
 12616                                  
 12617                                  	; Check if this SFT is local and store its address in LocalSFT. Can be 
 12618                                  	; used for a later regen.
 12619                                  
 12620                                  	; 16/12/2022
 12621                                  	; 08/11/2022
 12622                                  	;test	byte [es:di+6],80h
 12623 000019AA 26F6450680              	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
 12624                                  	; 08/11/2022 Retro DOS v4.0 (MSDOS 5.0 MSDOS.SYS compatibility)
 12625                                  	;;test	word [es:di+5],8000h
 12626                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; network SFT?
 12627 000019AF 7532                    	jnz	short lru5	;yes, get net/Share LRU
 12628                                  
 12629                                  ;IF installed
 12630 000019B1 E88B59                  	call	CheckShare	;Share present?
 12631                                  ;ENDIF
 12632 000019B4 752D                    	jnz	short lru5	;yes, get net/Share LRU
 12633                                  
 12634                                  	;Local SFT, register its address
 12635                                  
 12636                                  	; !!HACK!!!
 12637                                  	; There is a slightly dirty hack out here in a desperate bid to save  
 12638                                  	; code space. There is similar code duplicated at label 'gotSFT'. We 
 12639                                  	; enter from there if al = 0, update the LocalSFT variable, and since 
 12640                                  	; al = 0, we jump out of the loop to the exit point. I have commented 
 12641                                  	; out the code that previously existed at label 'gotSFT'
 12642                                  
 12643                                  hackpoint:
 12644 000019B6 893E[4410]              	mov	[LocalSFT],di
 12645 000019BA 8C06[4610]              	mov	[LocalSFT+2],es	;store local SFT address
 12646                                  
 12647 000019BE 08C0                    	or	al,al		;Is operation = REGEN?
 12648 000019C0 74BC                    	jz	short gotlocalSFT ;yes, return this SFT for reuse
 12649                                  
 12650                                  	;Get LRU for local files
 12651                                  	
 12652                                  	;cmp	[es:di+15h],bx
 12653 000019C2 26395D15                	cmp	[es:di+sf_LRU],bx ;SFT.LRU < min?
 12654 000019C6 7306                    	jae	short lru4	;no, skip 
 12655                                  
 12656                                  	;mov	bx,[es:di+15h]
 12657 000019C8 268B5D15                	mov	bx,[es:di+sf_LRU] ;yes, store new minimum
 12658 000019CC 89FE                    	mov	si,di		;store SFT position
 12659                                  lru4:
 12660                                  	;add	di,59
 12661 000019CE 83C73B                  	add	di,SF_ENTRY.size ;go to next SFT
 12662 000019D1 E2CB                    	loop	findSFT
 12663                                  
 12664                                  	; Check whether we got a net/Share or local SFT. If local SFT 
 12665                                  	; available, we will reuse it instead of net/Share LRU
 12666                                  
 12667 000019D3 89F7                    	mov	di,si
 12668 000019D5 83FEFF                  	cmp	si,-1		;local SFT available?
 12669 000019D8 7517                    	jnz	short gotSFT	;yes, return it
 12670                                  
 12671                                  	;No local SFT, see if we got a net/Share SFT
 12672                                  
 12673 000019DA 89EF                    	mov	di,bp
 12674 000019DC 83FDFF                  	cmp	bp,-1		;net/Share SFT available?
 12675 000019DF 7530                    	jnz	short gotnetSFT	;yes, return it
 12676                                  noSFT:
 12677                                  	; NB: This error should never occur. We always must have an LRU SFT. 
 12678                                  	; This error can occur only if the SFT has been corrupted or the LRU 
 12679                                  	; count is not maintained properly.
 12680                                  
 12681 000019E1 EB51                    	jmp	short errorbadSFT ;error, no FCB available.
 12682                                  
 12683                                  	; Handle the LRU for net/Share SFTs
 12684                                  lru5:
 12685                                  	;cmp	[es:di+15h],dx
 12686 000019E3 26395515                	cmp	[es:di+sf_LRU],dx ;SFT.LRU < min?
 12687 000019E7 73E5                    	jae	short lru4	;no, skip 
 12688                                  
 12689                                  	;mov	dx,[es:di+15h]
 12690 000019E9 268B5515                	mov	dx,[es:di+sf_LRU] ;yes, store new minimum
 12691                                  
 12692 000019ED 89FD                    	mov	bp,di		;store SFT position
 12693 000019EF EBDD                    	jmp	short lru4	;continue with next SFT
 12694                                  
 12695                                  gotSFT:
 12696 000019F1 08C0                    	or	al,al
 12697 000019F3 74C1                    	jz	short hackpoint	;save es:di in LocalSFT
 12698                                  
 12699                                  	; HACK!!!
 12700                                  	; The code here differs from the code at 'hackpoint' only in the 
 12701                                  	; order of the check for al. If al = 0, we can jump to 'hackpoint' 
 12702                                  	; and then from there jump out to 'gotlocalSFT'. The original code 
 12703                                  	; has been commented out below and replaced by the code just above.
 12704                                  
 12705                                  ;If regen, then this SFT can be registered as a local one ( even if free ).
 12706                                  ;
 12707                                  ;	or	al,al		  ;Regen?
 12708                                  ;	jnz	short notlocaluse ;yes, register it and return
 12709                                  ;
 12710                                  ;Register this SFT as a local one
 12711                                  ;
 12712                                  ;	mov	[LocalSFT],di
 12713                                  ;	mov	[LocalSFT+2],es
 12714                                  ;	jmp	gotlocalSFT	;return to caller
 12715                                  ;
 12716                                  ;notlocaluse:
 12717                                  
 12718                                  	; The caller is probably going to use this SFT for a net/Share file. 
 12719                                  	; We will come here only on a Open/Create when the caller($FCB_OPEN) 
 12720                                  	; does not really know whether it is a local file or not. We 
 12721                                  	; invalidate LocalSFT if the SFT we are going to use was previously 
 12722                                  	; registered as a local SFT that can be recycled.
 12723                                  
 12724 000019F5 8CC0                    	mov	ax,es
 12725 000019F7 393E[4410]              	cmp	[LocalSFT],di		;Offset same?
 12726 000019FB 7506                    	jne	short notinvalid
 12727 000019FD 3906[4610]              	cmp	[LocalSFT+2],ax		;Segments same?
 12728 00001A01 7403                    	je	short zerolocalSFT	;no, no need to invalidate
 12729                                  notinvalid:
 12730 00001A03 E978FF                  	jmp	gotlocalSFT
 12731                                  
 12732                                  	; The SFT we are going to use was registered in the LocalSFT variable. 
 12733                                  	; Invalidate this variable i.e LocalSFT = NULL
 12734                                  
 12735                                  zerolocalSFT:
 12736 00001A06 31C0                    	xor	ax,ax ; 0
 12737 00001A08 A3[4410]                	mov	[LocalSFT],ax
 12738 00001A0B A3[4610]                	mov	[LocalSFT+2],ax
 12739                                  
 12740 00001A0E E96DFF                  	jmp	gotlocalSFT
 12741                                  
 12742                                  gotnetSFT:
 12743                                  	; We have an SFT that is currently net/Share. If it is going to be 
 12744                                  	; used for a regen, we know it has to be a local SFT. Update the 
 12745                                  	; LocalSFT variable
 12746                                  
 12747 00001A11 08C0                    	or	al,al
 12748 00001A13 7508                    	jnz	short closenet
 12749                                  
 12750 00001A15 893E[4410]              	mov	[LocalSFT],di
 12751 00001A19 8C06[4610]              	mov	[LocalSFT+2],es	;store local SFT address
 12752                                  closenet:
 12753 00001A1D 893E[9E05]              	mov	[THISSFT],di	; set thissft
 12754 00001A21 8C06[A005]              	mov	[THISSFT+2],es	
 12755                                  
 12756                                  	; If we have sharing or thisSFT is a net sft, then close it until ref 
 12757                                  	; count is 0.
 12758                                  	; NB: We come here only if it is a net/Share SFT that is going to be 
 12759                                  	; recycled -- no need to check for this.
 12760                                  
 12761                                  LRUClose:
 12762 00001A25 26833D00                	cmp	word [es:di],0
 12763                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0 ; is ref count still <> 0?
 12764 00001A29 740C                    	jz	short LRUDone	; nope, all done
 12765                                  
 12766 00001A2B E80D15                  	call	DOS_CLOSE
 12767 00001A2E 73F5                    	jnc	short LRUClose	; no error => clean up
 12768                                  
 12769                                  	; Bugbug: I dont know why we are trying to close after we get an 
 12770                                  	; error closing. Seems like we could have a potential infinite loop  
 12771                                  	; here. This has to be verified.
 12772                                  
 12773 00001A30 3C06                    	cmp	al,error_invalid_handle ; 6
 12774 00001A32 74F1                    	je	short LRUClose
 12775                                  errorbadSFT:
 12776 00001A34 F9                      	stc
 12777 00001A35 EB05                    	JMP	short LRUDead
 12778                                  LRUDone:
 12779 00001A37 30C0                    	XOR	AL,AL
 12780 00001A39 E80E01                  	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 12781                                  
 12782                                  LRUDead:
 12783 00001A3C E80CEA                  	call	restore_world		; use macro
 12784                                  	
 12785 00001A3F 07                      	pop	es ; * (MSDOS 6.21)
 12786                                  
 12787                                  	;getdseg <es>
 12788 00001A40 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 12789 00001A45 26C43E[9E05]            	les	di,[es:THISSFT]		;es:di points at allocated SFT
 12790                                  
 12791                                  	;;retnc
 12792                                  	;jc	short LruFCB_err
 12793                                  	;retn
 12794                                  
 12795                                  	; 16/12/2022
 12796                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12797 00001A4A 7302                    	jnc	short LruFCB_retn
 12798                                  	;jc	short LruFCB_err
 12799                                  	;retn
 12800                                  		
 12801                                  LruFCB_err:
 12802 00001A4C B023                    	MOV	AL,error_FCB_unavailable ; 23h
 12803                                  LruFCB_retn:
 12804 00001A4E C3                      	retn
 12805                                  	
 12806                                  ;LruFCB	ENDP
 12807                                  
 12808                                  ; 17/05/2019 - Retro DOS v4.0
 12809                                  
 12810                                  ; DOSCODE:58F3h (MSDOS 6.21, MSDOS.SYS)
 12811                                  
 12812                                  ; --------------------------------------------------------------------------
 12813                                  ;**** RegenCopyName -- This function copies the filename from the FCB to
 12814                                  ; SFT and also to DOS local buffers. There was duplicate code in FCBRegen
 12815                                  ; to copy the name to different destinations
 12816                                  ;
 12817                                  ; Inputs: ds:si = source string
 12818                                  ;	 es:di = destination string
 12819                                  ;	 cx = length of string
 12820                                  ;
 12821                                  ; Outputs: String copied to destination
 12822                                  ;
 12823                                  ; Registers affected: cx,di,si
 12824                                  ; --------------------------------------------------------------------------
 12825                                  
 12826                                  RegenCopyName:
 12827                                  CopyName:
 12828 00001A4F AC                      	lodsb			;load character
 12829 00001A50 E8FA35                  	call	UCase		; convert char to upper case
 12830                                  StuffChar2:
 12831 00001A53 AA                      	STOSB			;store converted character
 12832 00001A54 E2F9                    	LOOP	CopyName	;
 12833                                  DoneName:
 12834 00001A56 C3                      	retn
 12835                                  
 12836                                  ; --------------------------------------------------------------------------
 12837                                  
 12838                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12839                                  FCBRegen:
 12840                                  	; called from SFTFromFCB. SS already DOSDATA
 12841                                  
 12842                                  	; General data filling. Mode is sf_isFCB + open_for_both, date/time 
 12843                                  	; we do not fill, size we do no fill, position we do not fill,
 12844                                  	; bit 14 of flags = TRUE, other bits = FALSE
 12845                                  
 12846                                  	;mov	al,[si+19h]
 12847 00001A57 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 12848                                  
 12849                                  	; We discriminate based on the first two bits in the reserved field.
 12850                                  	
 12851                                  	;test	al,80h
 12852 00001A5A A880                    	test	AL,FCBSPECIAL		; check for no sharing test
 12853 00001A5C 741C                    	JZ	short RegenNoSharing	; yes, go regen from no sharing
 12854                                  
 12855                                  	; The FCB is for a network or a sharing based system. At this point 
 12856                                  	; we have already closed the SFT for this guy and reconnection is 
 12857                                  	; impossible.
 12858                                  	;
 12859                                  	; Remember that he may have given us a FCB with bogus information in
 12860                                  	; it. Check to see if sharing is present or if the redir is present.
 12861                                  	; If either is around, presume that we have cycled out the FCB and 
 12862                                  	; give the hard error. Otherwise, just return with carry set.
 12863                                  
 12864 00001A5E E8DE58                  	call	CheckShare		; test for sharer
 12865 00001A61 7509                    	JNZ	short RegenFail		; yep, fail this.
 12866                                  	
 12867                                  	;mov	ax,1100h
 12868 00001A63 B80011                  	MOV	AX,MultNET<<8		; install check on multnet
 12869 00001A66 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK
 12870                                  			; Return: AL = 00h  not installed, OK to install
 12871                                  			; 01h  not installed, not OK to install
 12872                                  			; FFh  installed
 12873 00001A68 08C0                    	OR	AL,AL			; is it there?
 12874 00001A6A 740C                    	JZ	short RegenDead		; no, just fail the operation
 12875                                  RegenFail:
 12876                                  	; 17/05/2019 - Retro DOS v4.0
 12877                                  	;MOV	AX,[CS:USER_IN_AX]	; SS override
 12878 00001A6C 36A1[3A03]              	mov	ax,[SS:USER_IN_AX] ; MSDOS 6.0
 12879                                  
 12880                                  	;cmp	ah,10h
 12881 00001A70 80FC10                  	cmp	AH,FCB_CLOSE
 12882 00001A73 7403                    	jz	short RegenDead
 12883 00001A75 E89301                  	call	FCBHardErr		; massive hard error.
 12884                                  RegenDead:
 12885 00001A78 F9                      	STC				; carry set
 12886                                  FCBRegen_retn:
 12887 00001A79 C3                      	retn
 12888                                  
 12889                                  	; Local FCB without sharing. Check to see if sharing is loaded. If 
 12890                                  	; so fail the operation.
 12891                                  
 12892                                  RegenNoSharing:
 12893 00001A7A E8C258                  	call	CheckShare		; Sharing around?
 12894 00001A7D 75ED                    	JNZ	short RegenFail
 12895                                  	
 12896                                  	; Find an SFT for this guy.
 12897                                  	
 12898                                  	; 17/05/2019 - Retro DOS v4.0
 12899                                  
 12900                                  	; MSDOS 3.3
 12901                                  	;call	LRUFCB
 12902                                  	;jc	short FCBRegen_retn
 12903                                  	
 12904                                  	; MSDOS 6.0
 12905 00001A7F 50                      	push	ax
 12906 00001A80 B000                    	mov	al,0			;indicate it is a regen operation
 12907 00001A82 E8DEFE                  	call	LRUFCB
 12908 00001A85 58                      	pop	ax
 12909 00001A86 72F1                    	jc	short FCBRegen_retn
 12910                                  
 12911                                  	;mov	word [es:di+2],8002h
 12912 00001A88 26C745020280            	MOV	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB+open_for_both+SHARING_COMPAT
 12913 00001A8E 243F                    	AND	AL,3Fh			; get drive number for flags
 12914 00001A90 98                      	CBW
 12915                                  	;or	ax,4000h
 12916 00001A91 0D0040                  	OR	AX,sf_close_nodate	; normal FCB operation
 12917                                  
 12918                                  	; The bits field consists of the upper two bits (dirty and device) 
 12919                                  	; from the SFT and the low 4 bits from the open mode.
 12920                                  
 12921                                  	;mov	cl,[si+1Ah]
 12922 00001A94 8A4C1A                  	MOV	CL,[SI+fcb_nsl_bits]	; stick in dirty bits.
 12923 00001A97 88CD                    	MOV	CH,CL
 12924 00001A99 80E5C0                  	AND	CH,0C0h 		; mask off the dirty/device bits
 12925 00001A9C 08E8                    	OR	AL,CH
 12926                                  	;and	cl,0Fh
 12927 00001A9E 80E10F                  	AND	CL,access_mask		; get the mode bits
 12928                                  	;mov	[es:di+2],cl
 12929 00001AA1 26884D02                	MOV	[ES:DI+SF_ENTRY.sf_mode],CL
 12930                                  	;mov	[es:di+5],ax
 12931 00001AA5 26894505                	MOV	[ES:DI+SF_ENTRY.sf_flags],AX ; initial flags
 12932                                  	;MOV	AX,[CS:PROC_ID]		; SS override
 12933 00001AA9 36A1[3C03]              	mov	ax,[ss:PROC_ID] ; MSDOS 6.0
 12934                                  	;mov	[es:di+31h],ax
 12935 00001AAD 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX
 12936 00001AB1 1E                      	push	ds
 12937 00001AB2 56                      	push	si
 12938 00001AB3 06                      	push	es
 12939 00001AB4 57                      	push	di
 12940 00001AB5 16                      	push	ss
 12941 00001AB6 07                      	pop	es
 12942 00001AB7 BF[4B05]                	MOV	DI,NAME1		; NAME1 is in DOSDATA
 12943                                  
 12944 00001ABA B90800                  	MOV	CX,8
 12945 00001ABD 46                      	INC	SI			; Skip past drive byte to name in FCB
 12946                                  
 12947                                  	; MSDOS 3.3
 12948                                  ;RegenCopyName:
 12949                                  	;lodsb
 12950                                  	;call	UCase
 12951                                  	;stosb
 12952                                  	;loop	RegenCopyName
 12953                                  
 12954                                  	; MSDOS 6.0
 12955 00001ABE E88EFF                  	call	RegenCopyName		;copy the name to NAME1
 12956                                  
 12957 00001AC1 16                      	push	ss	; SS is DOSDATA
 12958 00001AC2 1F                      	pop	ds
 12959                                  
 12960                                  	;mov	byte [ATTRIB],16h
 12961 00001AC3 C606[6B05]16            	MOV	byte [ATTRIB],attr_hidden+attr_system+attr_directory
 12962                                  					; Must set this to something interesting
 12963                                  					; to call DEVNAME.
 12964 00001AC8 E81027                  	call	DEVNAME 		; check for device
 12965 00001ACB 5E                      	pop	si
 12966 00001ACC 07                      	pop	es
 12967 00001ACD 5E                      	pop	si
 12968 00001ACE 1F                      	pop	ds
 12969 00001ACF 7219                    	JC	short RegenFileNoSharing ; not found on device list => file
 12970                                  
 12971                                  	; Device found. We can ignore disk-specific info
 12972                                  
 12973                                  	;mov	[es:di+5],bh
 12974 00001AD1 26887D05                	MOV	[ES:DI+SF_ENTRY.sf_flags],BH ; device parms
 12975                                  	;mov	byte [es:di+4],0
 12976 00001AD5 26C6450400              	MOV	byte [ES:DI+SF_ENTRY.sf_attr],0 ; attribute
 12977                                  					; SS override
 12978                                  	;LDS	SI,[CS:DEVPT]		; get device driver
 12979 00001ADA 36C536[9A05]            	lds	si,[ss:DEVPT] ; MSDOS 6.0
 12980                                  	;mov	[es:di+7],si
 12981 00001ADF 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 12982                                  	;mov	[es:di+9],ds
 12983 00001AE3 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 12984 00001AE7 C3                      	retn				; carry is clear
 12985                                  
 12986                                  RegenDeadJ:
 12987 00001AE8 EB8E                    	JMP	short RegenDead
 12988                                  
 12989                                  	; File found. Just copy in the remaining pieces.
 12990                                  
 12991                                  RegenFileNoSharing:
 12992                                  	;mov	ax,[es:di+5]
 12993 00001AEA 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 12994 00001AEE 83E03F                  	AND	AX,03Fh
 12995 00001AF1 1E                      	push	ds
 12996 00001AF2 56                      	push	si
 12997 00001AF3 E8D64E                  	call	FIND_DPB
 12998                                  	;mov	[es:di+7],si
 12999 00001AF6 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 13000                                  	;mov	[es:di+9],ds
 13001 00001AFA 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 13002 00001AFE 5E                      	pop	si
 13003 00001AFF 1F                      	pop	ds
 13004 00001B00 72E6                    	jc	short RegenDeadJ	; if find DPB fails, then drive
 13005                                  					; indicator was bogus
 13006                                  	;mov	ax,[si+1Dh]
 13007 00001B02 8B441D                  	MOV	AX,[SI+fcb_nsl_dirsec]
 13008                                  	;;mov	[es:di+1Dh],ax ; MSDOS 3.3
 13009                                  	;mov	[es:di+1Bh],ax ; MSDOS 6.0
 13010 00001B05 2689451B                	MOV	[ES:DI+SF_ENTRY.sf_dirsec],AX
 13011                                  
 13012                                  	; MSDOS 6.0
 13013                                  
 13014                                  	; SR;
 13015                                  	; Extract the read-only and archive bits from the top 2 bits of the sector
 13016                                  	; number
 13017                                  
 13018                                  	;mov	al,[si+18h]
 13019 00001B09 8A4418                  	mov	al,[si+fcb_sfn]
 13020 00001B0C 24C0                    	and	al,0C0h		;get the 2 attribute bits
 13021 00001B0E 88C4                    	mov	ah,al
 13022 00001B10 D0C4                    	rol	ah,1
 13023 00001B12 D0E8                    	shr	al,1
 13024 00001B14 08E0                    	or	al,ah
 13025 00001B16 243F                    	and	al,03Fh		;mask off unused bits
 13026                                  	;mov	[es:di+4],al
 13027 00001B18 26884504                	mov	[es:di+SF_ENTRY.sf_attr],al
 13028                                  
 13029                                  	; SR;
 13030                                  	; Update the higher word of the directory sector from the FCB
 13031                                  
 13032                                  	;;mov	al,[si+18h]
 13033 00001B1C 8A4418                  	mov	al,[si+fcb_sfn]
 13034 00001B1F 243F                    	and	al,03Fh		;mask off top 2 bits -- attr bits
 13035 00001B21 28E4                    	sub	ah,ah
 13036                                  	;mov	[es:di+1Dh],ax
 13037 00001B23 2689451D                	mov	[es:di+SF_ENTRY.sf_dirsec+2],ax ;update high word
 13038                                  
 13039                                  	; MSDOS 6.0 (& MSDOS 3.3)
 13040                                  	;mov	ax,[si+1Bh]
 13041 00001B27 8B441B                  	MOV	AX,[SI+fcb_nsl_firclus]
 13042                                  	;mov	[es:di+0Bh],ax
 13043 00001B2A 2689450B                	MOV	[ES:DI+SF_ENTRY.sf_firclus],AX
 13044                                  	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
 13045                                  	;mov	[es:di+35h],ax ; MSDOS 6.0
 13046 00001B2E 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 13047                                  	;mov	al,[si+1Fh]
 13048 00001B32 8A441F                  	MOV	AL,[SI+fcb_nsl_dirpos]
 13049                                  	;mov  	[es:di+1Fh],al
 13050 00001B35 2688451F                	MOV	[ES:DI+SF_ENTRY.sf_dirpos],AL
 13051                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 13052 00001B39 26FF05                  	inc	word [ES:DI]		; Increment reference count.
 13053                                  					; Existing FCB entries would be
 13054                                  					; flushed unnecessarily because of
 13055                                  					; check in CheckFCB of the ref_count.
 13056                                  					; July 22/85 - BAS
 13057                                  	;lea	si,[si+1]
 13058 00001B3C 8D7401                  	LEA	SI,[SI+SYS_FCB.name]
 13059                                  	;lea	di,[di+20h]
 13060 00001B3F 8D7D20                  	LEA	DI,[DI+SF_ENTRY.sf_name]
 13061                                  	;mov	cx,11
 13062 00001B42 B90B00                  	MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 13063                                  	
 13064                                  	; MSDOS 6.0
 13065 00001B45 E807FF                  	call	RegenCopyName	;copy name to SFT 
 13066                                  	
 13067                                  	; MSDOS 3.3
 13068                                  ;RegenCopyName2:
 13069                                  	;lodsb
 13070                                  	;call    UCase
 13071                                  	;stosb
 13072                                  	;loop    RegenCopyName2
 13073                                  
 13074 00001B48 F8                      	clc
 13075 00001B49 C3                      	retn
 13076                                  
 13077                                  ; 17/05/2019 - Retro DOS v4.0
 13078                                  
 13079                                  ;**	BlastSFT - FIll SFT with Garbage
 13080                                  ; --------------------------------------------------------------------------
 13081                                  ;	BlastSFT is used when an SFT is no longer needed; it's called with
 13082                                  ;	various garbage values to put into the SFT.  I don't know why,
 13083                                  ;	presumably to help with debugging (jgl).  We clear the few fields
 13084                                  ;	necessary to show that the SFT is free after filling it.
 13085                                  ;
 13086                                  ;	ENTRY	(es:di) = address of SFT
 13087                                  ;		(al) = fill character
 13088                                  ;	EXIT	(ax) = -1
 13089                                  ;		'C' clear
 13090                                  ;	USES	AX, CX, Flags
 13091                                  
 13092                                  BlastSFT:
 13093 00001B4A 57                      	push	di
 13094                                  	;mov	cx,53 ; MSDOS 3.3
 13095                                  	;mov	cx,59 ; MSDOS 6.0
 13096 00001B4B B93B00                  	mov	cx,SF_ENTRY.size
 13097 00001B4E F3AA                    	rep	stosb
 13098 00001B50 5F                      	pop	di
 13099 00001B51 29C0                    	sub	ax,ax	; 0		; clear 'C'-----------------;
 13100 00001B53 268905                  	mov	[es:di],ax
 13101                                  	;mov	[es:di+SFT_ENTRY.sf_ref_count],ax ; set ref count   ;
 13102                                  	;mov	[es:di+15h],ax
 13103 00001B56 26894515                	mov	[es:di+sf_LRU],ax	; set lru		    ;
 13104 00001B5A 48                      	dec	ax	; -1					    ;
 13105                                  	;mov	[es:di+17h],ax ; 0FFFFh ; -1
 13106 00001B5B 26894517                	mov	[es:di+sf_OpenAge],ax	; set open age to -1	    ;
 13107                                  BlastSFT_retn:
 13108 00001B5F C3                      	retn				; return with 'C' clear     ;
 13109                                  
 13110                                  ;Break	<CheckFCB - see if the SFT pointed to by the FCB is still OK>
 13111                                  ; --------------------------------------------------------------------------
 13112                                  ;
 13113                                  ;   CheckFCB - examine an FCB and its contents to see if it needs to be
 13114                                  ;   regenerated.
 13115                                  ;
 13116                                  ;   Inputs:	DS:SI point to FCB (not extended)
 13117                                  ;		AL is SFT index
 13118                                  ;   Outputs:	Carry Set - FCB needs to be regened
 13119                                  ;		Carry clear - FCB is OK. ES:DI point to SFT
 13120                                  ;   Registers modified: AX and BX
 13121                                  ;
 13122                                  ; --------------------------------------------------------------------------
 13123                                  
 13124                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13125                                  	; DOSCODE:59F0h (MSDOS 5.0, MSDOS.SYS)
 13126                                  CheckFCB:
 13127                                  		
 13128                                  	; called from $fcb_open and sftfromfcb. SS already set up to DOSDATA
 13129                                  
 13130                                  	; MSDOS 3.3
 13131                                  
 13132                                  	; LES	DI,[CS:SFTFCB]
 13133                                  
 13134                                  	; MSDOS 6.0
 13135                                  	
 13136                                  	; SR;
 13137                                  	; We check if the given FCB is for a local file. If so, we return a 
 13138                                  	; bad SFT status forcing the caller to regenerate the SFT.
 13139                                  
 13140                                  	;test	byte [si+19h],0C0h
 13141 00001B60 F64419C0                	test	byte [si+fcb_l_drive],FCBNETWORK|FCBSHARE|FCBDEVICE
 13142 00001B64 744F                    	jz	short BadSFT		;Local file, return bad SFT
 13143 00001B66 36C43E[4000]            	LES     DI,[SS:SFTFCB]		; SS override
 13144                                  
 13145                                  	; MSDOS 6.0 (& MSDOS 3.3)
 13146                                  	;cmp	[es:di+4],al
 13147 00001B6B 26384504                	CMP	[ES:DI+SFT.SFCount],AL
 13148 00001B6F 7244                    	JC	short BadSFT
 13149                                  	;;mov	bl,53 ; MSDOS 3.3
 13150                                  	;mov	bl,59 ; MSDOS 6.0
 13151 00001B71 B33B                    	MOV	BL,SF_ENTRY.size
 13152 00001B73 F6E3                    	MUL	BL
 13153                                  	;lea	di,[di+6]
 13154 00001B75 8D7D06                  	LEA	DI,[DI+SFT.SFTable]
 13155 00001B78 01C7                    	ADD	DI,AX
 13156                                  	;MOV	AX,[CS:PROC_ID]	; MSDOS 3.3
 13157 00001B7A 36A1[3C03]              	mov	ax,[SS:PROC_ID] ; MSDOS 6.0  ; SS override
 13158                                  	;cmp	[es:di+31h],ax
 13159 00001B7E 26394531                	CMP	[ES:DI+SF_ENTRY.sf_PID],AX
 13160 00001B82 7531                    	JNZ	short BadSFT		; must match process
 13161 00001B84 26833D00                	cmp	word [es:di],0
 13162                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],0
 13163 00001B88 742B                    	JZ	short BadSFT		; must also be in use
 13164                                  	;mov	al,[si+19h]
 13165 00001B8A 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 13166                                  	;test	al,80h
 13167 00001B8D A880                    	test	AL,FCBSPECIAL		; a special FCB?
 13168 00001B8F 7430                    	JZ	short CheckNoShare	; No. try local or device
 13169                                  
 13170                                  	; Since we are a special FCB, try NOT to use a bogus test instruction.
 13171                                  	; FCBSHARE is a superset of FCBNETWORK.
 13172                                  
 13173 00001B91 50                      	PUSH	AX
 13174                                  	;and	al,0C0h
 13175 00001B92 24C0                    	AND	AL,FCBMASK
 13176                                  	;cmp	al,0C0h
 13177 00001B94 3CC0                    	CMP	AL,FCBSHARE		; net FCB?
 13178 00001B96 58                      	POP	AX
 13179 00001B97 751E                    	JNZ	short CheckNet		; yes
 13180                                  ;
 13181                                  ;----- In share support -----
 13182                                  ;
 13183                                  	;call	far [cs:JShare+(11*4)]
 13184 00001B99 36FF1E[BC00]            	Call    far [ss:JShare+(11*4)] ; 11 = ShChk ; SS Override
 13185 00001B9E 7215                    	JC	short BadSFT
 13186 00001BA0 EB06                    	JMP	SHORT CheckD
 13187                                  ;
 13188                                  ;----- End in share support -----
 13189                                  ;
 13190                                  	; 09/11/2022
 13191                                  	; (There is not any procedure/sub
 13192                                  	;  which calls or jumps to CheckFirClus here)
 13193                                  	;;;
 13194                                  CheckFirClus:
 13195                                  	;cmp     bx,[es:di+0Bh]
 13196                                  	; 07/12/2022
 13197 00001BA2 263B5D0B                	CMP	BX,[ES:DI+SF_ENTRY.sf_firclus]
 13198 00001BA6 750D                    	JNZ	short BadSFT
 13199                                  	;;;
 13200                                  CheckD: 
 13201 00001BA8 243F                    	AND	AL,3Fh
 13202                                  	;mov	ah,[es:di+5]
 13203 00001BAA 268A6505                	MOV	AH,[ES:DI+SF_ENTRY.sf_flags]
 13204 00001BAE 80E43F                  	AND	AH,3Fh
 13205 00001BB1 38C4                    	CMP	AH,AL
 13206                                  	; 16/12/2022
 13207 00001BB3 74AA                    	jz	short BlastSFT_retn	; carry is clear
 13208                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13209                                  	;jnz	short BadSFT
 13210                                  ;CheckD_retn:
 13211                                  	;retn
 13212                                  BadSFT: 
 13213 00001BB5 F9                      	STC
 13214 00001BB6 C3                      	retn
 13215                                  				
 13216                                  CheckNet:
 13217                                  	; 17/05/2019 - Retro DOS v4.0
 13218                                  	
 13219                                  ;----- In net support -----
 13220                                  
 13221                                  	; MSDOS 3.3
 13222                                  	;;mov	ax,[si+1Ah]
 13223                                  	;mov	ax,[si+fcb_net_handle]
 13224                                  	;;cmp	ax,[es:di+1Dh]
 13225                                  	;cmp	ax,[ES:DI+SF_ENTRY.sf_dirsec]
 13226                                  	;jnz	short BadSFT
 13227                                  	;;cmp	ax,[es:di+19h]
 13228                                  	;cmp	ax,[ES:DI+sf_netid]
 13229                                  	;jnz     short BadSFT
 13230                                  	;;mov	ax,[si+1Eh]
 13231                                  	;mov	ax,[si+fcb_l_attr]
 13232                                  	;;cmp	ax,[es:di+1Bh]
 13233                                  	;cmp	ax,[es:di+SF_ENTRY.sf_lstclus]
 13234                                  	;jnz     short BadSFT
 13235                                  
 13236                                  	; MSDOS 6.0
 13237                                  	;mov	ax,[si+1Ch]
 13238 00001BB7 8B441C                  	MOV	AX,[SI+fcb_netID]	;AN000;IFS.DOS 4.00
 13239                                  	; 09/11/2022
 13240                                  	;cmp	ax,[es:di+0Bh] 
 13241 00001BBA 263B450B                	CMP	AX,[ES:DI+sf_serial_ID]	;AN000;IFS.DOS 4.00
 13242 00001BBE 75F5                    	JNZ	short BadSFT
 13243                                  
 13244                                  ;----- END In net support -----
 13245                                  
 13246                                  CheckNet_retn:
 13247 00001BC0 C3                      	retn
 13248                                  
 13249                                  CheckNoShare:
 13250                                  
 13251                                  ; 16/12/2022
 13252                                  ;	; 09/11/2022 (following test instruction is nonsense!)
 13253                                  ;	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)
 13254                                  ;	;test	al,40h
 13255                                  ;	test	AL,FCBDEVICE		; Device?
 13256                                  ;	;jnz	short $+2 ; 09/11/2022
 13257                                  ;	JNZ	short CheckNoShareDev 	; Yes
 13258                                  
 13259                                  	; MSDOS 3.3 - IBMDOS.COM - Offset 27EFh
 13260                                  	;;mov	bx,[si+1Dh]
 13261                                  	;MOV	BX,[SI+fcb_nsl_dirsec]
 13262                                  	;;cmp	bx,[es:di+1Dh]
 13263                                  	;cmp	bx,[ES:DI+SF_ENTRY.sf_dirsec]
 13264                                  	;jnz	short BadSFT
 13265                                  	;;mov	bl,[si+1Fh]
 13266                                  	;MOV	bl,[SI+fcb_nsl_dirpos]
 13267                                  	;;cmp	bl,[es:di+1Fh]
 13268                                  	;cmp	bl,[ES:DI+SF_ENTRY.sf_dirpos]
 13269                                  	;jnz	short BadSFT
 13270                                  	;;mov	bl,[si+1Ah]
 13271                                  	;MOV	bl,[SI+fcb_nsl_bits]
 13272                                  	;;mov	bh,[es:di+5]
 13273                                  	;MOV	bh,[ES:DI+SF_ENTRY.sf_flags]
 13274                                  	;xor	bh,bl
 13275                                  	;and	bh,0C0h
 13276                                  	;jnz	short BadSFT
 13277                                  	;;xor	bl,[es:di+2]
 13278                                  	;xor	bl,[ES:DI+SF_ENTRY.sf_mode]
 13279                                  	;and	bl,0Fh
 13280                                  	;jnz	short BadSFT
 13281                                  	;push	di
 13282                                  	;push	si
 13283                                  	;;lea	di,[di+20h]  ; MSDOS 3.3
 13284                                  	;LEA	DI,[DI+SF_ENTRY.sf_name]
 13285                                  	;;lea	si,[si+1]
 13286                                  	;LEA	SI,[SI+SYS_FCB.name]
 13287                                  	;;mov	cx,11
 13288                                  	;MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 13289                                  	;repe	cmpsb
 13290                                  	;pop	si
 13291                                  	;pop	di
 13292                                  	;jnz	short BadSFT
 13293                                  	;;mov	bx,[si+1Bh]
 13294                                  	;MOV	bX,[SI+fcb_nsl_firclus]
 13295                                  	;jmp	short CheckFirClus
 13296                                  
 13297                                  	; MSDOS 6.0
 13298                                  
 13299                                  	; SR;
 13300                                  	; The code below to match a local FCB with its SFT can no longer be
 13301                                  	; used. We just return a no-match status. This check is done right
 13302                                  	; at the top.
 13303                                  
 13304                                  CheckNoShareDev:
 13305                                  	;mov	bx,[si+1Ah]
 13306 00001BC1 8B5C1A                  	MOV	BX,[SI+fcb_nsld_drvptr]
 13307                                  	;cmp	bx,[es:di+7]
 13308 00001BC4 263B5D07                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr]
 13309 00001BC8 75EB                    	JNZ	short BadSFT
 13310                                  	;mov	bx,[si+1Ch]
 13311 00001BCA 8B5C1C                  	MOV	BX,[SI+fcb_nsld_drvptr+2]
 13312                                  	;cmp	bx,[es:di+9]
 13313 00001BCD 263B5D09                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr+2]
 13314 00001BD1 75E2                    	JNZ	short BadSFT
 13315 00001BD3 EBD3                    	JMP	short CheckD
 13316                                  
 13317                                  ;Break	<SFTFromFCB - take a FCB and obtain a SFT from it>
 13318                                  ;----------------------------------------------------------------------------
 13319                                  ;
 13320                                  ;   SFTFromFCB - the workhorse of this compatability crap. Check to see if
 13321                                  ;	the SFT for the FCB is Good. If so, make ThisSFT point to it. If not
 13322                                  ;	good, get one from the cache and regenerate it. Overlay the LRU field
 13323                                  ;	with PID
 13324                                  ;
 13325                                  ;   Inputs:	DS:SI point to FCB
 13326                                  ;   Outputs:	ThisSFT point to appropriate SFT
 13327                                  ;		Carry clear -> OK ES:DI -> SFT
 13328                                  ;		Carry set -> error in ax
 13329                                  ;   Registers modified: ES,DI, AX
 13330                                  ;
 13331                                  ;----------------------------------------------------------------------------
 13332                                  
 13333                                  SFTFromFCB:
 13334                                  	; called from fcbio and $fcb_close. SS already set up to DOSDATA
 13335                                  
 13336                                  	; 17/05/2019 - Retro DOS v4.0
 13337                                  
 13338 00001BD5 50                      	push	ax
 13339 00001BD6 53                      	push	bx
 13340                                  	;mov	al,[si+18h]
 13341 00001BD7 8A4418                  	MOV	AL,[SI+fcb_sfn] 	; set SFN for check
 13342 00001BDA E883FF                  	call	CheckFCB
 13343 00001BDD 5B                      	pop	bx
 13344 00001BDE 58                      	pop	ax
 13345                                  	;MOV	[CS:THISSFT],DI		; SS override
 13346                                  	;MOV	[CS:THISSFT+2],ES
 13347 00001BDF 36893E[9E05]            	MOV	[SS:THISSFT],DI		; SS override
 13348 00001BE4 368C06[A005]            	MOV	[SS:THISSFT+2],ES
 13349 00001BE9 7311                    	JNC	short Set_SFT		; no problems, just set thissft
 13350                                  	
 13351                                  	; 09/11/2022 (MSDOS 5.0)
 13352                                  	; 31/05/2019
 13353 00001BEB 06                      	push	es ; * (MSDOS 6.21) & (MSDOS 5.0)
 13354 00001BEC E873E8                  	call	save_world
 13355 00001BEF E865FE                  	call	FCBRegen
 13356 00001BF2 E856E8                  	call	restore_world		; use macro restore world
 13357 00001BF5 07                      	pop	es ; * (MSDOS 6.21) ; 31/05/2019 ; 09/11/2022 (MSDOS 5.0)	
 13358                                  
 13359                                  	;MOV	AX,[CS:EXTERR]		; SS override
 13360 00001BF6 36A1[2403]              	MOV	AX,[SS:EXTERR]		; SS override
 13361 00001BFA 72C4                    	jc	short CheckNet_retn
 13362                                  
 13363                                  Set_SFT: 
 13364                                  	;LES	DI,[CS:THISSFT]		; SS override for THISSFT & PROC_ID
 13365 00001BFC 36C43E[9E05]            	les	di,[ss:THISSFT]
 13366                                  	;PUSH	word [CS:PROC_ID]	; set process id
 13367 00001C01 36FF36[3C03]            	push	word [ss:PROC_ID]
 13368                                  	;pop	word [es:di+31h]
 13369 00001C06 268F4531                	POP     word [ES:DI+SF_ENTRY.sf_PID]
 13370 00001C0A C3                      	retn				; carry is clear
 13371                                  
 13372                                  ;Break	<FCBHardErr - generate INT 24 for hard errors on FCBS>
 13373                                  ;----------------------------------------------------------------------------
 13374                                  ;
 13375                                  ;   FCBHardErr - signal to a user app that he is trying to use an
 13376                                  ;	unavailable FCB.
 13377                                  ;
 13378                                  ;   Inputs:	none.
 13379                                  ;   Outputs:	none.
 13380                                  ;   Registers modified: all
 13381                                  ;
 13382                                  ;----------------------------------------------------------------------------
 13383                                  
 13384                                  FCBHardErr:
 13385                                  	; 17/05/2019 - Retro DOS v4.0
 13386 00001C0B 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 13387                                  	;
 13388                                  	;mov	ax,23h
 13389 00001C10 B82300                  	MOV	AX,error_FCB_unavailable
 13390                                  	;;mov	byte [cs:ALLOWED],8
 13391                                  	;MOV	byte [CS:ALLOWED],Allowed_FAIL
 13392 00001C13 26C606[4B03]08          	mov	byte [es:ALLOWED],Allowed_FAIL	
 13393                                  	
 13394                                  	;LES	BP,[CS:THISDPB]
 13395 00001C19 26C42E[8A05]            	les	bp,[es:THISDPB]
 13396                                  	
 13397 00001C1E BF0100                  	MOV	DI,1			; Fake some registers
 13398 00001C21 89F9                    	MOV	CX,DI
 13399                                  	;mov	dx,[es:bp+0Bh]
 13400 00001C23 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 13401 00001C27 E8E136                  	call	HARDERR
 13402 00001C2A F9                      	STC
 13403 00001C2B C3                      	retn
 13404                                  
 13405                                  ;============================================================================
 13406                                  ; FCBIO2.ASM, MSDOS 6.0, 1991
 13407                                  ;============================================================================
 13408                                  ; 21/07/2018 - Retro DOS v3.0
 13409                                  ; 17/05/2019 - Retro DOS v4.0
 13410                                  
 13411                                  ;**	FCBIO2.ASM - Ancient 1.0 1.1 FCB system calls
 13412                                  ;
 13413                                  ;	GetRR
 13414                                  ;	GetExtent
 13415                                  ;	SetExtent
 13416                                  ;	GetExtended
 13417                                  ;	GetRecSize
 13418                                  ;	FCBIO
 13419                                  ;	$FCB_OPEN
 13420                                  ;	$FCB_CREATE
 13421                                  ;	$FCB_RANDOM_WRITE_BLOCK
 13422                                  ;	$FCB_RANDOM_READ_BLOCK
 13423                                  ;	$FCB_SEQ_READ
 13424                                  ;	$FCB_SEQ_WRITE
 13425                                  ;	$FCB_RANDOM_READ
 13426                                  ;	$FCB_RANDOM_WRITE
 13427                                  ;
 13428                                  ;	Revision history:
 13429                                  ;
 13430                                  ;		Created: ARR 4 April 1983
 13431                                  ;			 MZ  6 June  1983 completion of functions
 13432                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 13433                                  ;				  times.  Change so successive closes work by
 13434                                  ;				  always returning OK.	Also, detect I/O to
 13435                                  ;				  already closed FCB and return EOF.
 13436                                  ;		 MZ 16 Jan   1984 More braindamage.  Need to separate info
 13437                                  ;				  out of sft into FCB for reconnection
 13438                                  ;
 13439                                  ;	    A000   version 4.00	Jan. 1988
 13440                                  
 13441                                  ; Defintions for FCBOp flags
 13442                                  
 13443                                  RANDOM	equ 2				; random operation
 13444                                  FCBREAD equ 4				; doing a read
 13445                                  BLOCK	equ 8				; doing a block I/O
 13446                                  
 13447                                  ;Break <GetRR - return the random record field in DX:AX>
 13448                                  ;---------------------------------------------------------------------------
 13449                                  ;
 13450                                  ;   GetRR - correctly load DX:AX with the random record field (3 or 4 bytes)
 13451                                  ;	from the FCB pointed to by DS:SI
 13452                                  ;
 13453                                  ;   Inputs:	DS:SI point to an FCB
 13454                                  ;		BX has record size
 13455                                  ;   Outputs:	DX:AX contain the contents of the random record field
 13456                                  ;   Registers modified: none
 13457                                  ;---------------------------------------------------------------------------
 13458                                  
 13459                                  GetRR:
 13460                                  	;mov	ax,[si+21h]
 13461 00001C2C 8B4421                  	MOV	AX,[SI+SYS_FCB.RR]	; get low order part
 13462                                  	;mov	dx,[si+23h]
 13463 00001C2F 8B5423                  	MOV	DX,[SI+SYS_FCB.RR+2]	; get high order part
 13464 00001C32 83FB40                  	CMP	BX,64			; ignore MSB of RR if recsiz > 64
 13465 00001C35 7202                    	JB	short GetRRBye
 13466 00001C37 30F6                    	XOR	DH,DH
 13467                                  GetRRBye:
 13468 00001C39 C3                      	retn
 13469                                  
 13470                                  ;Break <GetExtent - retrieve next location for sequential IO>
 13471                                  ;---------------------------------------------------------------------------
 13472                                  ;
 13473                                  ;   GetExtent - Construct the next record to perform I/O from the EXTENT and
 13474                                  ;	NR fields in the FCB.
 13475                                  ;
 13476                                  ;   Inputs:	DS:SI - point to FCB
 13477                                  ;   Outputs:	DX:AX contain the contents of the random record field
 13478                                  ;   Registers modified: none
 13479                                  ;---------------------------------------------------------------------------
 13480                                  
 13481                                  GetExtent:
 13482                                  	;mov	al,[si+20h]
 13483 00001C3A 8A4420                  	MOV	AL,[SI+SYS_FCB.NR]	; get low order piece
 13484                                  	;mov	dx,[si+0Ch]
 13485 00001C3D 8B540C                  	MOV	DX,[SI+SYS_FCB.EXTENT]	; get high order piece
 13486 00001C40 D0E0                    	SHL	AL,1
 13487 00001C42 D1EA                    	SHR	DX,1
 13488 00001C44 D0D8                    	RCR	AL,1	; move low order bit of DL to high order of AH
 13489 00001C46 88D4                    	MOV	AH,DL
 13490 00001C48 88F2                    	MOV	DL,DH
 13491 00001C4A 30F6                    	XOR	DH,DH
 13492 00001C4C C3                      	retn
 13493                                  
 13494                                  ;Break <SetExtent - update the extent/NR field>
 13495                                  ;---------------------------------------------------------------------------
 13496                                  ;
 13497                                  ;   SetExtent - change the position of an FCB by filling in the extent/NR
 13498                                  ;	fields
 13499                                  ;
 13500                                  ;   Inputs:	DS:SI point to FCB
 13501                                  ;		DX:AX is a record location in file
 13502                                  ;   Outputs:	Extent/NR fields are filled in
 13503                                  ;   Registers modified: CX
 13504                                  ;---------------------------------------------------------------------------
 13505                                  
 13506                                  SetExtent:
 13507 00001C4D 50                      	push	ax
 13508 00001C4E 52                      	push	dx
 13509 00001C4F 89C1                    	MOV	CX,AX
 13510 00001C51 247F                    	AND	AL,7FH			; next rec field
 13511                                  	;mov	[si+20h],al
 13512 00001C53 884420                  	MOV	[SI+SYS_FCB.NR],AL
 13513 00001C56 80E180                  	AND	CL,80H			; save upper bit
 13514 00001C59 D1E1                    	SHL	CX,1
 13515 00001C5B D1D2                    	RCL	DX,1			; move high bit of CX to low bit of DX
 13516 00001C5D 88E8                    	MOV	AL,CH
 13517 00001C5F 88D4                    	MOV	AH,DL
 13518                                  	;mov	[si+0Ch], ax
 13519 00001C61 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; all done
 13520 00001C64 5A                      	pop	dx
 13521 00001C65 58                      	pop	ax
 13522 00001C66 C3                      	retn
 13523                                  
 13524                                  ;Break <GetExtended - find FCB in potential extended fcb>
 13525                                  ;---------------------------------------------------------------------------
 13526                                  ;
 13527                                  ;   GetExtended - Make DS:SI point to FCB from DS:DX
 13528                                  ;
 13529                                  ;   Inputs:	DS:DX point to a possible extended FCB
 13530                                  ;   Outputs:	DS:SI point to the FCB part
 13531                                  ;		zeroflag set if not extended fcb
 13532                                  ;   Registers modified: SI
 13533                                  ;---------------------------------------------------------------------------
 13534                                  
 13535                                  GetExtended:
 13536 00001C67 89D6                    	MOV	SI,DX			; point to Something
 13537 00001C69 803CFF                  	CMP	BYTE [SI],-1		; look for extention
 13538 00001C6C 7503                    	JNZ	short GetBye		; not there
 13539 00001C6E 83C607                  	ADD	SI,7			; point to FCB
 13540                                  GetBye:
 13541 00001C71 39D6                    	CMP	SI,DX			; set condition codes
 13542                                  getextd_retn:
 13543 00001C73 C3                      	retn
 13544                                  
 13545                                  ;Break <GetRecSize - return in BX the FCB record size>
 13546                                  ;---------------------------------------------------------------------------
 13547                                  ;
 13548                                  ;   GetRecSize - return in BX the record size from the FCB at DS:SI
 13549                                  ;
 13550                                  ;   Inputs:	DS:SI point to a non-extended FCB
 13551                                  ;   Outputs:	BX contains the record size
 13552                                  ;   Registers modified: None
 13553                                  ;---------------------------------------------------------------------------
 13554                                  
 13555                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13556                                  GetRecSize:
 13557                                  	;mov	bx,[si+0Eh]
 13558 00001C74 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 13559 00001C77 09DB                    	OR	BX,BX			; is it nul?
 13560 00001C79 74F8                    	jz	short getextd_retn
 13561 00001C7B BB8000                  	MOV	BX,128			; use default size
 13562                                  	;mov	[si+0Eh],bx
 13563 00001C7E 895C0E                  	MOV	[SI+SYS_FCB.RECSIZ],BX	; stuff it back
 13564 00001C81 C3                      	retn
 13565                                  
 13566                                  ;BREAK <FCBIO - do internal FCB I/O>
 13567                                  ;---------------------------------------------------------------------------
 13568                                  ;
 13569                                  ;   FCBIO - look at FCBOP and merge all FCB operations into a single routine.
 13570                                  ;
 13571                                  ;   Inputs:	FCBOP flags which operations need to be performed
 13572                                  ;		DS:DX point to FCB
 13573                                  ;		CX may have count of number of records to xfer
 13574                                  ;   Outputs:	AL has error code
 13575                                  ;   Registers modified: all
 13576                                  ;---------------------------------------------------------------------------
 13577                                  
 13578                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13579                                  	; DOSCODE:5B17h (MSDOS 5.0 MSDOS.SYS)
 13580                                  FCBIO:
 13581                                  
 13582                                  FEOF	EQU	1
 13583                                  FTRIM	EQU	2
 13584                                  
 13585                                  %define	FCBErr	byte [bp-1]  ; byte	
 13586                                  %define	cRec	word [bp-3]  ; word	
 13587                                  ;%define RecPos	word [bp-7]  ; dword
 13588                                  %define RecPosL	word [bp-7]  ; word
 13589                                  %define RecPosH	word [bp-5]  ; word
 13590                                  %define	RecSize	word [bp-9]  ; word
 13591                                  ;%define bPos	word [bp-13] ; dword
 13592                                  %define bPosL	word [bp-13] ; word
 13593                                  %define bPosH	word [bp-11] ; word
 13594                                  %define cByte	word [bp-15] ; word	
 13595                                  %define cResult word [bp-17] ; word	
 13596                                  %define	cRecRes	word [bp-19] ; word
 13597                                  %define	FCBOp	byte [bp-20] ; byte
 13598                                  
 13599                                  	;Enter
 13600                                  
 13601 00001C82 55                      	push	bp
 13602 00001C83 89E5                    	mov	bp,sp
 13603 00001C85 83EC14                  	sub	sp,20
 13604                                  	;mov	[bp-20],al
 13605 00001C88 8846EC                  	MOV	FCBOp,AL
 13606                                  	;mov	byte [bp-1],0
 13607 00001C8B C646FF00                	MOV	FCBErr,0		;   FCBErr = 0;
 13608 00001C8F E8D5FF                  	call	GetExtended		;   FCB = GetExtended ();
 13609                                  	;test	byte [bp-20],8
 13610 00001C92 F646EC08                	TEST	FCBOp,BLOCK		;   if ((OP&BLOCK) == 0)
 13611 00001C96 7503                    	JNZ	short GetPos
 13612 00001C98 B90100                  	MOV	CX,1			;	cRec = 1;
 13613                                  GetPos:
 13614                                  	;mov	[bp-3],cx
 13615 00001C9B 894EFD                  	MOV	cRec,CX 		;*Tail coalesce
 13616 00001C9E E899FF                  	call	GetExtent		;   RecPos = GetExtent ();
 13617 00001CA1 E8D0FF                  	call	GetRecSize		;   RecSize = GetRecSize ();
 13618                                  	;mov	[bp-9],bx
 13619 00001CA4 895EF7                  	MOV	RecSize,BX
 13620                                  	;test	byte [bp-20],2
 13621 00001CA7 F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&RANDOM) <> 0)
 13622 00001CAB 7403                    	JZ	short GetRec
 13623 00001CAD E87CFF                  	call	GetRR			;	RecPos = GetRR ();
 13624                                  GetRec:
 13625                                  	;mov	[bp-7],ax
 13626 00001CB0 8946F9                  	MOV	RecPosL,AX		;*Tail coalesce
 13627                                  	;mov	[bp-5],dx
 13628 00001CB3 8956FB                  	MOV	RecPosH,DX
 13629 00001CB6 E894FF                  	call	SetExtent		;   SetExtent (RecPos);
 13630                                  	;mov	ax,[bp-5]
 13631 00001CB9 8B46FB                  	MOV	AX,RecPosH		;   bPos = RecPos * RecSize;
 13632 00001CBC F7E3                    	MUL	BX
 13633 00001CBE 89C7                    	MOV	DI,AX
 13634                                  	;mov	ax,[bp-7]
 13635 00001CC0 8B46F9                  	MOV	AX,RecPosL
 13636 00001CC3 F7E3                    	MUL	BX
 13637 00001CC5 01FA                    	ADD	DX,DI
 13638                                  	;mov	[bp-13],ax
 13639 00001CC7 8946F3                  	MOV	bPosL,AX
 13640                                  	;mov	[bp-11],dx
 13641 00001CCA 8956F5                  	MOV	bPosH,DX
 13642                                  	;mov	ax,[bp-3]
 13643 00001CCD 8B46FD                  	MOV	AX,cRec 		;   cByte = cRec * RecSize;
 13644 00001CD0 F7E3                    	MUL	BX
 13645                                  	;mov	[bp-15],ax
 13646 00001CD2 8946F1                  	MOV	cByte,AX
 13647                                  
 13648                                  ;hkn; 	SS override
 13649 00001CD5 360306[2C03]            	ADD	AX,[SS:DMAADD]		;   if (cByte+DMA > 64K) {
 13650 00001CDA 83D200                  	ADC	DX,0
 13651 00001CDD 7419                    	JZ	short DoOper
 13652                                  	;mov	byte [bp-1],2
 13653 00001CDF C646FF02                	MOV	FCBErr,FTRIM		;	FCBErr = FTRIM;
 13654                                  
 13655                                  ;hkn; 	SS override
 13656 00001CE3 36A1[2C03]              	MOV	AX,[SS:DMAADD]		;	cRec = (64K-DMA)/RecSize;
 13657 00001CE7 F7D8                    	NEG	AX
 13658 00001CE9 7501                    	JNZ	short DoDiv
 13659 00001CEB 48                      	DEC	AX
 13660                                  DoDiv:
 13661 00001CEC 31D2                    	XOR	DX,DX
 13662 00001CEE F7F3                    	DIV	BX
 13663                                  	;mov	[bp-3],ax
 13664 00001CF0 8946FD                  	MOV	cRec,AX
 13665 00001CF3 F7E3                    	MUL	BX			;	cByte = cRec * RecSize;
 13666                                  	;mov	[bp-15],ax
 13667 00001CF5 8946F1                  	MOV	cByte,AX		;	}
 13668                                  DoOper:
 13669 00001CF8 31DB                    	XOR	BX,BX
 13670                                  	;mov	[bp-17],bx
 13671 00001CFA 895EEF                  	MOV	cResult,BX		;   cResult = 0;
 13672                                  	;cmp	[bp-15],bx
 13673 00001CFD 395EF1                  	CMP	cByte,BX		;   if (cByte <> 0 ||
 13674 00001D00 7506                    	JNZ	short DoGetExt
 13675                                  	;test	byte [bp-1],2
 13676 00001D02 F646FF02                	TEST	FCBErr,FTRIM		;	(FCBErr&FTRIM) == 0) {
 13677                                  	;JZ	short DoGetExt
 13678                                  	;JMP	short SkipOp
 13679                                  	; 16/12/2022
 13680 00001D06 7576                    	jnz	short SkipOp
 13681                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13682                                  	;JZ	short DoGetExt
 13683                                  	;JMP	short SkipOp
 13684                                  DoGetExt:
 13685 00001D08 E8CAFE                  	call	SFTFromFCB		;	if (!SFTFromFCB (SFT,FCB))
 13686 00001D0B 730F                    	JNC	short ContinueOp
 13687                                  FCBDeath:
 13688 00001D0D E846E9                  	call	FCB_RET_ERR		; signal error, map for extended
 13689                                  	;mov	word [bp-19],0
 13690 00001D10 C746ED0000              	MOV	cRecRes,0		; no bytes transferred
 13691                                  	;mov	byte [bp-1],1
 13692 00001D15 C646FF01                	MOV	FCBErr,FEOF		;	    return FTRIM;
 13693 00001D19 E9EF00                  	JMP	FCBSave 		; bam!
 13694                                  ContinueOp:
 13695                                  	;mov	ax,[si+10h]
 13696 00001D1C 8B4410                  	MOV	AX,[SI+SYS_FCB.FILSIZ]
 13697                                  	;mov	[es:di+11h],ax
 13698 00001D1F 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 13699                                  	;mov	ax,[si+12h]
 13700 00001D23 8B4412                  	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 13701                                  	;mov	[es:di+13h],ax
 13702 00001D26 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 13703                                  	;mov	ax,[bp-13]
 13704 00001D2A 8B46F3                  	MOV	AX,bPosL
 13705                                  	;mov	dx,[bp-11]
 13706 00001D2D 8B56F5                  	MOV	DX,bPosH
 13707                                  	;mov	[es:di+15h],ax
 13708 00001D30 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 13709                                  	;xchg	dx,[es:di+17h]
 13710 00001D34 26875517                	XCHG	[ES:DI+SF_ENTRY.sf_position+2],DX
 13711 00001D38 52                      	PUSH	DX			; save away Open age.
 13712                                  	;mov	cx,[bp-15]
 13713 00001D39 8B4EF1                  	MOV	CX,cByte		;	cResult =
 13714                                  
 13715                                  ;hkn; DOS_Read is in DOSCODE
 13716 00001D3C BF[E232]                	MOV	DI,DOS_READ		;	    *(OP&FCBRead ? DOS_Read
 13717                                  	;test	byte [bp-20],4
 13718 00001D3F F646EC04                	TEST	FCBOp,FCBREAD		;		 : DOS_Write)(cRec);
 13719 00001D43 7503                    	JNZ	short DoContext
 13720                                  
 13721                                  ;hkn; DOS_Write is in DOSCODE
 13722 00001D45 BF[0B35]                	MOV	DI,DOS_WRITE
 13723                                  DoContext:
 13724 00001D48 55                      	push	bp
 13725 00001D49 1E                      	push	ds
 13726 00001D4A 56                      	push	si
 13727                                  
 13728                                  ;hkn; SS is DOSDATA
 13729 00001D4B 16                      	push	ss
 13730 00001D4C 1F                      	pop	ds
 13731                                  
 13732                                  ;; Fix for disk full
 13733 00001D4D FFD7                    	CALL	DI	; DOS_READ or DOS_WRITE	
 13734                                  	
 13735 00001D4F 5E                      	pop	si
 13736 00001D50 1F                      	pop	ds
 13737 00001D51 5D                      	pop	bp
 13738 00001D52 72B9                    	JC	short FCBDeath
 13739                                  	
 13740 00001D54 36803E[0B06]00          	CMP	BYTE [SS:DISK_FULL],0	; treat disk full as error
 13741 00001D5A 740A                    	JZ	short NODSKFULL
 13742 00001D5C 36C606[0B06]00          	MOV	BYTE [SS:DISK_FULL],0	; clear the flag
 13743                                  	;mov	byte [bp-1],1 
 13744 00001D62 C646FF01                	MOV	FCBErr,FEOF		; set disk full flag
 13745                                  NODSKFULL:
 13746                                  ;; Fix for disk full
 13747                                  	;mov	[bp-17],cx
 13748 00001D66 894EEF                  	MOV	cResult,CX
 13749 00001D69 E827FB                  	call	SaveFCBInfo		;	SaveFCBInfo (FCB);
 13750                                  	;pop	word [es:di+17h]	
 13751 00001D6C 268F4517                	POP	WORD [ES:DI+SF_ENTRY.sf_position+2] ; restore open age
 13752                                  			       ; (sf_OpenAge = SF_ENTRY.sf_position+2)			
 13753                                  	;mov	ax,[es:di+11h]
 13754 00001D70 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 13755                                  	;mov	[si+10h],ax
 13756 00001D74 894410                  	MOV	[SI+SYS_FCB.FILSIZ],AX
 13757                                  	;mov	ax,[es:di+13h]
 13758 00001D77 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 13759                                  	;mov	[si+12h],ax
 13760 00001D7B 894412                  	MOV	[SI+SYS_FCB.FILSIZ+2],AX
 13761                                  					;	}
 13762                                  SkipOp:
 13763                                  	;mov	ax,[bp-17]
 13764 00001D7E 8B46EF                  	MOV	AX,cResult		;   cRecRes = cResult / RecSize;
 13765 00001D81 31D2                    	XOR	DX,DX
 13766                                  	;div	word [bp-9]
 13767 00001D83 F776F7                  	DIV	RecSize
 13768                                  	;mov	[bp-19],ax
 13769 00001D86 8946ED                  	MOV	cRecRes,AX
 13770                                  	;add	[bp-7],ax
 13771 00001D89 0146F9                  	ADD	RecPosL,AX		;   RecPos += cRecResult;
 13772                                  	;adc	word [bp-5],0
 13773 00001D8C 8356FB00                	ADC	RecPosH,0
 13774                                  
 13775                                  ; If we have not gotten the expected number of records, we signal an EOF
 13776                                  ; condition. On input, this is EOF. On output this is usually disk full.
 13777                                  ; BUT... Under 2.0 and before, all device output IGNORED this condition. So
 13778                                  ; do we.
 13779                                  
 13780                                  	;cmp	ax,[bp-3]
 13781 00001D90 3B46FD                  	CMP	AX,cRec 		;   if (cRecRes <> cRec)
 13782 00001D93 7411                    	JZ	short TryBlank
 13783                                  	;test	byte [bp-20],4
 13784 00001D95 F646EC04                	TEST	FCBOp,FCBREAD		;	if (OP&FCBRead || !DEVICE)
 13785 00001D99 7507                    	JNZ	short SetEOF
 13786                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13787                                  	; MSDOS 3.3
 13788                                  	;;test	word [es:di+5],80h
 13789                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 13790                                  	;JNZ	short TryBlank
 13791                                  	; MSDOS 5.0 & MSDOS 6.0
 13792                                  	;test	byte [es:di+5],80h
 13793 00001D9B 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 13794 00001DA0 7504                    	jnz	short TryBlank
 13795                                  
 13796                                  SetEOF:
 13797                                  	;mov	byte [bp-1],1
 13798 00001DA2 C646FF01                	MOV	FCBErr,FEOF		;	FCBErr = FEOF;
 13799                                  TryBlank:				;
 13800 00001DA6 09D2                    	OR	DX,DX			;   if (cResult%RecSize <> 0) {
 13801 00001DA8 7426                    	JZ	short SetExt
 13802                                  	;add	word [bp-7],1
 13803 00001DAA 8346F901                	ADD	RecPosL,1		;	RecPos++;
 13804                                  	;adc	word [bp-5],0
 13805 00001DAE 8356FB00                	ADC	RecPosH,0
 13806                                  	;test	byte [bp-20],4
 13807 00001DB2 F646EC04                	TEST	FCBOp,FCBREAD		;	if(OP&FCBRead) <> 0) {
 13808 00001DB6 7418                    	JZ	short SetExt
 13809                                  	;inc	word [bp-19]
 13810 00001DB8 FF46ED                  	INC	cRecRes 		;	cRecRes++;
 13811                                  	;mov	byte [bp-1],3
 13812 00001DBB C646FF03                	MOV	FCBErr,FTRIM+FEOF	;	FCBErr = FTRIM | FEOF;
 13813                                  	;mov	cx,[bp-9]
 13814 00001DBF 8B4EF7                  	MOV	CX,RecSize		;	Blank (RecSize-cResult%RecSize,
 13815 00001DC2 29D1                    	SUB	CX,DX			;	       DMA+cResult);
 13816 00001DC4 30C0                    	XOR	AL,AL
 13817                                  ;hkn; 	SS override
 13818 00001DC6 36C43E[2C03]            	les     di,[ss:DMAADD]
 13819                                  	;add	di,[bp-17]
 13820 00001DCB 037EEF                  	ADD	DI,cResult
 13821 00001DCE F3AA                    	REP	STOSB			;   }	}
 13822                                  SetExt:
 13823                                  	;mov	dx,[bp-5]
 13824 00001DD0 8B56FB                  	MOV	DX,RecPosH
 13825                                  	;mov	ax,[bp-7]
 13826 00001DD3 8B46F9                  	MOV	AX,RecPosL
 13827                                  	;test	byte [bp-20],2
 13828 00001DD6 F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&Random) == 0 ||
 13829 00001DDA 7406                    	JZ	short DoSetExt
 13830                                  	;test	byte [bp-20],8
 13831 00001DDC F646EC08                	TEST	FCBOp,BLOCK		;	(OP&BLOCK) <> 0)
 13832 00001DE0 7403                    	JZ	short TrySetRR
 13833                                  DoSetExt:
 13834 00001DE2 E868FE                  	call	SetExtent		;	SetExtent (RecPos, FCB);
 13835                                  TrySetRR:
 13836                                  	;test	byte [bp-20],8
 13837 00001DE5 F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 13838 00001DE9 740F                    	JZ	short TryReturn
 13839                                  	;mov	[si+21h],ax
 13840 00001DEB 894421                  	MOV	[SI+SYS_FCB.RR],AX	;	FCB->RR = RecPos;
 13841                                  	;mov	[si+23h],dl
 13842 00001DEE 885423                  	MOV	[SI+SYS_FCB.RR+2],DL
 13843                                  	;cmp	word [si+0Eh],64
 13844 00001DF1 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 13845 00001DF5 7303                    	JAE	short TryReturn
 13846                                  	;mov	[si+24h],dh
 13847 00001DF7 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 13848                                  TryReturn: 
 13849                                  	;test	byte [bp-20],4
 13850 00001DFA F646EC04                	TEST	FCBOp,FCBREAD		;   if (!(FCBOP & FCBREAD)) {
 13851 00001DFE 750B                    	JNZ	short FCBSave
 13852 00001E00 1E                      	push	ds			;	FCB->FDate = date;
 13853 00001E01 E8ECEC                  	call	DATE16			;	FCB->FTime = time;
 13854 00001E04 1F                      	pop	ds
 13855                                  	;mov	[si+14h],ax
 13856 00001E05 894414                  	MOV	[SI+SYS_FCB.FDATE],AX
 13857                                  	;mov	[si+16h],dx
 13858 00001E08 895416                  	MOV	[SI+SYS_FCB.FTIME],DX	;	}
 13859                                  FCBSave: 
 13860                                  	;test	byte [bp-20],8
 13861 00001E0B F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 13862 00001E0F 7409                    	jz	short DoReturn
 13863                                  	;mov	cx,[bp-19]
 13864 00001E11 8B4EED                  	MOV	CX,cRecRes		;	user_CX = cRecRes;
 13865 00001E14 E86AE6                  	call    Get_User_Stack
 13866                                  	;mov	[si+4],cx
 13867 00001E17 894C04                  	MOV	[SI+user_env.user_CX],CX
 13868                                  DoReturn:
 13869                                  	;mov	al,[bp-1]
 13870 00001E1A 8A46FF                  	MOV	AL,FCBErr		;   return (FCBERR);
 13871                                  	;Leave	
 13872 00001E1D 89EC                    	mov     sp,bp
 13873 00001E1F 5D                      	pop     bp
 13874 00001E20 C3                      	retn
 13875                                  
 13876                                  ; 22/07/2018 - Retro DOS v3.0
 13877                                  
 13878                                  ;Break <$FCB_Open - open an old-style FCB>
 13879                                  ;---------------------------------------------------------------------------
 13880                                  ;
 13881                                  ;   $FCB_Open - CPM compatability file open. The user has formatted an FCB
 13882                                  ;	for us and asked to have the rest filled in.
 13883                                  ;
 13884                                  ;   Inputs:	DS:DX point to an unopenned FCB
 13885                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 13886                                  ;		FCB has the following fields filled in:
 13887                                  ;		    Time/Date Extent/NR Size
 13888                                  ;---------------------------------------------------------------------------
 13889                                  
 13890                                  _$FCB_OPEN:			; System call 15
 13891                                  
 13892 00001E21 B80200                  	MOV	AX,SHARING_COMPAT+open_for_both
 13893                                  
 13894                                  ;hkn; DOS_Open is in DOSCODE
 13895 00001E24 B9[822B]                	MOV	CX,DOS_OPEN
 13896                                  
 13897                                  ; The following is common code for Creation and openning of FCBs. AX is
 13898                                  ; either attributes (for create) or open mode (for open)... DS:DX points to
 13899                                  ; the FCB
 13900                                  
 13901                                  DoAccess:
 13902 00001E27 1E                      	push	ds
 13903 00001E28 52                      	push	dx
 13904 00001E29 51                      	push	cx
 13905 00001E2A 50                      	push	ax			; save FCB pointer away
 13906                                  
 13907                                  ;hkn; 	OpenBuf is in DOSDATA
 13908 00001E2B BF[BE03]                	MOV	DI,OPENBUF
 13909 00001E2E E8E24C                  	call	TransFCB		; crunch the fcb
 13910 00001E31 58                      	pop	ax
 13911 00001E32 59                      	pop	cx
 13912 00001E33 5A                      	pop	dx
 13913 00001E34 1F                      	pop	ds			; get fcb
 13914 00001E35 7303                    	JNC	short FindFCB		; everything seems ok
 13915                                  FCBOpenErr:
 13916                                  	; AL has error code
 13917 00001E37 E91CE8                  	jmp	FCB_RET_ERR
 13918                                  FindFCB:
 13919 00001E3A E82AFE                  	call	GetExtended		; DS:SI will point to FCB
 13920                                  
 13921                                  	; 17/05/2019 - Retro DOS v4.0
 13922                                  
 13923                                  	; MSDOS 3.3
 13924                                  	;call	LRUFCB
 13925                                  	;jc	short HardMessage
 13926                                  
 13927                                  	; MSDOS 6.0
 13928 00001E3D 50                      	push	ax
 13929 00001E3E B001                    	mov	al,1			;indicate Open/Create operation
 13930 00001E40 E820FB                  	call	LRUFCB			; get a sft entry (no error)
 13931 00001E43 58                      	pop	ax
 13932 00001E44 722A                    	jc	short HardMessage
 13933                                  	
 13934                                  	;mov	word [es:di+2],8000h
 13935 00001E46 26C745020080            	mov	word [es:di+SF_ENTRY.sf_mode],sf_isFCB
 13936 00001E4C 1E                      	push	ds
 13937 00001E4D 56                      	push	si	
 13938 00001E4E 53                      	push	bx			; save fcb pointer
 13939 00001E4F 89CE                    	MOV	SI,CX
 13940                                  
 13941                                  ;hkn; SS is DOSDATA
 13942 00001E51 16                      	push	ss
 13943 00001E52 1F                      	pop	ds			    ; let DOS_Open see variables
 13944 00001E53 FFD6                    	CALL	SI ; DOS_OPEN or DOS_CREATE ; go open the file
 13945 00001E55 5B                      	pop	bx
 13946 00001E56 5E                      	pop	si
 13947 00001E57 1F                      	pop	ds			; get fcb
 13948                                  
 13949                                  ;hkn; SS override
 13950 00001E58 36C43E[9E05]            	LES	DI,[SS:THISSFT]		; get sf pointer
 13951 00001E5D 7318                    	JNC	short FCBOK		; operation succeeded
 13952                                  failopen:
 13953 00001E5F 50                      	PUSH	AX
 13954 00001E60 B052                    	MOV	AL,"R"	; 52h		; clear out field (free sft)
 13955 00001E62 E8E5FC                  	call	BlastSFT
 13956 00001E65 58                      	POP	AX
 13957                                  	;cmp	ax,4
 13958 00001E66 83F804                  	CMP	AX,error_too_many_open_files
 13959 00001E69 7405                    	JZ	short HardMessage
 13960                                  	;cmp	ax,24h
 13961 00001E6B 83F824                  	CMP	AX,error_sharing_buffer_exceeded
 13962 00001E6E 7505                    	jnz	short DeadFCB
 13963                                  HardMessage:
 13964 00001E70 50                      	PUSH	AX
 13965 00001E71 E897FD                  	call	FCBHardErr
 13966 00001E74 58                      	POP	AX
 13967                                  DeadFCB:
 13968                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13969                                  	;jmp	FCB_RET_ERR
 13970 00001E75 EBC0                    	jmp	short FCBOpenErr
 13971                                  FCBOK:
 13972                                  	; MSDOS 6.0
 13973 00001E77 E8EAF3                  	call	IsSFTNet		;AN007;F.C. >32mb  Non Fat file?
 13974 00001E7A 750F                    	JNZ	short FCBOK2		;AN007;F.C. >32mb  yes
 13975 00001E7C E8C054                  	call	CheckShare		;AN000;F.C. >32mb  share around?
 13976 00001E7F 750A                    	JNZ	short FCBOK2		;AN000;F.C. >32mb  yes
 13977                                  ;SR;
 13978                                  ; If we reach here, we know we have got a local SFT. Let's update the 
 13979                                  ; LocalSFT variable to reflect this.
 13980                                  
 13981 00001E81 36893E[4410]            	mov	[ss:LocalSFT],di
 13982 00001E86 368C06[4610]            	mov	[ss:LocalSFT+2],es; Store the SFT address
 13983                                  ;;SR;
 13984                                  ;; The check below is not valid anymore since we regenerate for media > 32M.
 13985                                  ;;
 13986                                  ;;	CMP	WORD [ES:DI+SF_ENTRY.sf_dirsec+2],0 
 13987                                  ;;					       ;AN000;F.C. >32mb  if dirsec >32mb
 13988                                  ;;	JZ	short FCBOK2		       ;AN000;F.C. >32mb    then error
 13989                                  ;;	MOV	AX,error_sys_comp_not_loaded   ;AN000;F.C. >32mb
 13990                                  ;;	JMP	short failopen		       ;AN000;F.C. >32mb
 13991                                  
 13992                                  FCBOK2:
 13993                                  	; MSDOS 6.0 (& MSDOS 3.3)
 13994 00001E8B 26FF05                  	inc	word [es:di]
 13995                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count] ; increment reference count
 13996 00001E8E E802FA                  	call	SaveFCBInfo
 13997                                  	; MSDOS 3.3
 13998                                  	;call	SetOpenAge
 13999                                  	; MSDOS 6.0 (& MSDOS 3.3)
 14000                                  	;test	word [es:di+5],80h
 14001                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 14002 00001E91 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device  ; 28/07/2019
 14003 00001E96 7508                    	JNZ	short FCBNoDrive	; do not munge drive on devices
 14004 00001E98 8A04                    	MOV	AL,[SI]			; get drive byte
 14005 00001E9A E8014C                  	call	GETTHISDRV		; convert
 14006                                  	;INC	AL
 14007                                  	; 17/12/2022
 14008 00001E9D 40                      	inc	ax
 14009 00001E9E 8804                    	MOV	[SI],AL			; stash in good drive letter
 14010                                  FCBNoDrive:
 14011                                  	;mov	word [si+0Eh],128
 14012 00001EA0 C7440E8000              	MOV	word [SI+SYS_FCB.RECSIZ],80h ; stuff in default record size
 14013                                  
 14014                                  	;mov	ax,[es:di+0Dh]
 14015 00001EA5 268B450D                	MOV	AX,[ES:DI+SF_ENTRY.sf_time] ; set time
 14016                                  	;mov	[si+16h],ax
 14017 00001EA9 894416                  	MOV	[SI+SYS_FCB.FTIME],AX
 14018                                  	;mov	ax,[es:di+0Fh]
 14019 00001EAC 268B450F                	MOV	AX,[ES:DI+SF_ENTRY.sf_date] ; set date
 14020                                  	;mov	[si+14h],ax
 14021 00001EB0 894414                  	MOV	[SI+SYS_FCB.FDATE],AX
 14022                                  	;mov	ax,[es:di+11h]
 14023 00001EB3 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size] ; set sizes
 14024                                  	;mov	[si+10h],ax
 14025 00001EB7 894410                  	MOV	[SI+SYS_FCB.FILSIZ],AX
 14026                                  	;mov	ax,[es:di+13h]
 14027 00001EBA 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 14028                                  	;mov	[si+12h],ax
 14029 00001EBE 894412                  	MOV	[SI+SYS_FCB.FILSIZ+2],AX
 14030 00001EC1 31C0                    	XOR	AX,AX			; convenient zero
 14031                                  	;mov	[si+0Ch],ax
 14032 00001EC3 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; point to beginning of file
 14033                                  
 14034                                  ; We must scan the set of FCB SFTs for one that appears to match the current
 14035                                  ; one.	We cheat and use CheckFCB to match the FCBs.
 14036                                  
 14037                                  ;hkn; 	SS override
 14038 00001EC6 36C43E[4000]            	LES	DI,[SS:SFTFCB]		; get the pointer to head of the list
 14039                                  	;mov	ah,[es:di+4]
 14040 00001ECB 268A6504                	MOV	AH,[ES:DI+SFT.SFCount]	; get number of SFTs to scan
 14041                                  OpenScan:
 14042                                  	;cmp	al,[si+18h]
 14043 00001ECF 3A4418                  	CMP	AL,[SI+fcb_sfn]		; don't compare ourselves
 14044 00001ED2 7407                    	JZ	short SkipCheck
 14045 00001ED4 50                      	push	ax			; preserve count
 14046 00001ED5 E888FC                  	call	CheckFCB		; do they match
 14047 00001ED8 58                      	pop	ax			; get count back
 14048 00001ED9 7309                    	JNC	short OpenFound		; found a match!
 14049                                  SkipCheck:
 14050 00001EDB FEC0                    	INC	AL			; advance to next FCB
 14051 00001EDD 38E0                    	CMP	AL,AH			; table full?
 14052 00001EDF 75EE                    	JNZ	short OpenScan		; no, go for more
 14053                                  OpenDone:
 14054 00001EE1 30C0                    	xor	al,al			; return success
 14055 00001EE3 C3                      	retn
 14056                                  
 14057                                  ; The SFT at ES:DI is the one that is already in use for this FCB. We set the
 14058                                  ; FCB to use this one. We increment its ref count. We do NOT close it at all.
 14059                                  ; Consider:
 14060                                  ;
 14061                                  ;   open (foo)	delete (foo) open (bar)
 14062                                  ;
 14063                                  ; This causes us to recycle (potentially) bar through the same local SFT as
 14064                                  ; foo even though foo is no longer needed; this is due to the server closing
 14065                                  ; foo for us when we delete it. Unfortunately, we cannot see this closure.
 14066                                  ; If we were to CLOSE bar, the server would then close the only reference to
 14067                                  ; bar and subsequent I/O would be lost to the redirector.
 14068                                  ;
 14069                                  ; This gets solved by NOT closing the sft, but zeroing the ref count
 14070                                  ; (effectively freeing the SFT) and informing the sharer (if relevant) that
 14071                                  ; the SFT is no longer in use. Note that the SHARER MUST keep its ref counts
 14072                                  ; around. This will allow us to access the same file through multiple network
 14073                                  ; connections and NOT prematurely terminate when the ref count on one
 14074                                  ; connection goes to zero.
 14075                                  
 14076                                  OpenFound:
 14077                                  	;mov	[si+18h],al
 14078 00001EE4 884418                  	MOV	[SI+fcb_sfn],AL 	; assign with this
 14079 00001EE7 26FF05                  	inc	word [es:di]
 14080                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 14081                                  					; remember this new invocation
 14082 00001EEA 36A1[1000]              	MOV	AX,[SS:FCBLRU]		; update LRU counts
 14083                                  	;mov	[es:di+15h],ax
 14084 00001EEE 26894515                	MOV	[ES:DI+sf_LRU],AX
 14085                                  ;
 14086                                  ; We have an FCB sft that is now of no use.  We release sharing info and then
 14087                                  ; blast it to prevent other reuse.
 14088                                  ;
 14089 00001EF2 16                      	push	ss
 14090 00001EF3 1F                      	pop	ds
 14091 00001EF4 C43E[9E05]              	LES	DI,[THISSFT]
 14092 00001EF8 26FF0D                  	dec	word [es:di]
 14093                                  	;DEC	word [ES:DI+SF_ENTRY.sf_ref_count]
 14094                                  					; free the newly allocated SFT
 14095 00001EFB E87954                  	call	ShareEnd
 14096 00001EFE B043                    	MOV	AL,'C'	 ; 43h
 14097 00001F00 E847FC                  	call	BlastSFT
 14098 00001F03 EBDC                    	JMP	short OpenDone
 14099                                  
 14100                                  ;BREAK	<$FCB_Create - create a new directory entry>
 14101                                  ;----------------------------------------------------------------------------
 14102                                  ;
 14103                                  ;   $FCB_Create - CPM compatability file create. The user has formatted an
 14104                                  ;	FCB for us and asked to have the rest filled in.
 14105                                  ;
 14106                                  ;   Inputs:	DS:DX point to an unopenned FCB
 14107                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 14108                                  ;		FCB has the following fields filled in:
 14109                                  ;		    Time/Date Extent/NR Size
 14110                                  ;----------------------------------------------------------------------------
 14111                                  
 14112                                  _$FCB_CREATE:		; System call 22
 14113                                  
 14114                                  ;hkn; DOS_Create is in DOSCODE
 14115 00001F05 B9[582A]                	MOV	CX,DOS_CREATE		; routine to call
 14116 00001F08 31C0                    	XOR	AX,AX			; attributes to create
 14117 00001F0A E85AFD                  	call	GetExtended		; get extended FCB
 14118 00001F0D 7403                    	JZ	short DoAccessJ		; not an extended FCB
 14119 00001F0F 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 14120                                  DoAccessJ:
 14121 00001F12 E912FF                  	JMP	DoAccess		; do dirty work
 14122                                  
 14123                                  ; 22/07/2018 - Retro DOS v3.0
 14124                                  
 14125                                  ;BREAK <$FCB_Random_write_Block - write a block of records to a file >
 14126                                  ;----------------------------------------------------------------------------
 14127                                  ;
 14128                                  ;   $FCB_Random_Write_Block - retrieve a location from the FCB, seek to it
 14129                                  ;	and write a number of blocks from it.
 14130                                  ;
 14131                                  ;   Inputs:	DS:DX point to an FCB
 14132                                  ;   Outputs:	AL = 0 write was successful and the FCB position is updated
 14133                                  ;		AL <> 0 Not enough room on disk for the output
 14134                                  ;
 14135                                  ;----------------------------------------------------------------------------
 14136                                  
 14137                                  _$FCB_RANDOM_WRITE_BLOCK:
 14138                                  	;mov	AL,0Ah	
 14139 00001F15 B00A                    	MOV	AL,RANDOM+BLOCK
 14140 00001F17 E968FD                  	JMP	FCBIO
 14141                                  
 14142                                  ;BREAK <$FCB_Random_Read_Block - read a block of records to a file >
 14143                                  ;----------------------------------------------------------------------------
 14144                                  ;
 14145                                  ;   $FCB_Random_Read_Block - retrieve a location from the FCB, seek to it
 14146                                  ;	and read a number of blocks from it.
 14147                                  ;
 14148                                  ;   Inputs:	DS:DX point to an FCB
 14149                                  ;   Outputs:	AL = error codes defined above
 14150                                  ;
 14151                                  ;----------------------------------------------------------------------------
 14152                                  
 14153                                  _$FCB_RANDOM_READ_BLOCK:
 14154                                  	;mov	AL,0Eh	
 14155 00001F1A B00E                    	MOV	AL,RANDOM+FCBREAD+BLOCK
 14156 00001F1C E963FD                  	JMP	FCBIO
 14157                                  
 14158                                  ;BREAK <$FCB_Seq_Read - read the next record from a file >
 14159                                  ;----------------------------------------------------------------------------
 14160                                  ;
 14161                                  ;   $FCB_Seq_Read - retrieve the next record from an FCB and read it into
 14162                                  ;	memory
 14163                                  ;
 14164                                  ;   Inputs:	DS:DX point to an FCB
 14165                                  ;   Outputs:	AL = error codes defined above
 14166                                  ;
 14167                                  ;----------------------------------------------------------------------------
 14168                                  
 14169                                  _$FCB_SEQ_READ:
 14170                                  	;mov	AL,4	
 14171 00001F1F B004                    	MOV	AL,FCBREAD
 14172 00001F21 E95EFD                  	JMP	FCBIO
 14173                                  
 14174                                  ;BREAK <$FCB_Seq_Write - write the next record to a file >
 14175                                  ;----------------------------------------------------------------------------
 14176                                  ;
 14177                                  ;   $FCB_Seq_Write - retrieve the next record from an FCB and write it to the
 14178                                  ;	file
 14179                                  ;
 14180                                  ;   Inputs:	DS:DX point to an FCB
 14181                                  ;   Outputs:	AL = error codes defined above
 14182                                  ;
 14183                                  ;----------------------------------------------------------------------------
 14184                                  
 14185                                  _$FCB_SEQ_WRITE:
 14186 00001F24 B000                    	MOV	AL,0
 14187 00001F26 E959FD                  	jmp	FCBIO
 14188                                  
 14189                                  ;BREAK <$FCB_Random_Read - Read a single record from a file >
 14190                                  ;----------------------------------------------------------------------------
 14191                                  ;
 14192                                  ;   $FCB_Random_Read - retrieve a location from the FCB, seek to it and read a
 14193                                  ;	record from it.
 14194                                  ;
 14195                                  ;   Inputs:	DS:DX point to an FCB
 14196                                  ;   Outputs:	AL = error codes defined above
 14197                                  ;
 14198                                  ;----------------------------------------------------------------------------
 14199                                  
 14200                                  _$FCB_RANDOM_READ:
 14201                                  	;mov	AL,6	
 14202 00001F29 B006                    	MOV	AL,RANDOM+FCBREAD
 14203 00001F2B E954FD                  	jmp	FCBIO			; single block
 14204                                  
 14205                                  ;BREAK <$FCB_Random_Write - write a single record to a file >
 14206                                  ;----------------------------------------------------------------------------
 14207                                  ;
 14208                                  ;   $FCB_Random_Write - retrieve a location from the FCB, seek to it and write
 14209                                  ;	a record to it.
 14210                                  ;
 14211                                  ;   Inputs:	DS:DX point to an FCB
 14212                                  ;   Outputs:	AL = error codes defined above
 14213                                  ;
 14214                                  ;----------------------------------------------------------------------------
 14215                                  
 14216                                  _$FCB_RANDOM_WRITE:
 14217                                  	;mov	AL,2	
 14218 00001F2E B002                    	MOV	AL,RANDOM
 14219 00001F30 E94FFD                  	jmp	FCBIO
 14220                                  
 14221                                  ;============================================================================
 14222                                  ; SEARCH.ASM, MSDOS 6.0, 1991
 14223                                  ;============================================================================
 14224                                  ; 22/07/2018 - Retro DOS v3.0
 14225                                  ; 17/05/2019 - Retro DOS v4.0
 14226                                  
 14227                                  ; DOSCODE:5DDFh (MSDOS 6.21, MSDOS.SYS)
 14228                                  
 14229                                  ; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14230                                  ; DOSCODE:5DCBh (MSDOS 5.0, MSDOS.SYS)
 14231                                  
 14232                                  ;**	Search.asm
 14233                                  ;----------------------------------------------------------------------------
 14234                                  ;	Directory search system calls.
 14235                                  ;	These will be passed direct text of the pathname from the user. 
 14236                                  ;	They will need to be passed through the macro expander prior to
 14237                                  ;	being sent through the low-level stuff. 
 14238                                  ;	I/O specs are defined in DISPATCH. The system calls are:
 14239                                  ;
 14240                                  ;	$Dir_Search_First	  written
 14241                                  ;	$Dir_Search_Next	  written
 14242                                  ;	$Find_First	  written
 14243                                  ;	$Find_Next		  written
 14244                                  ;	PackName		  written
 14245                                  ;
 14246                                  ;	Modification history:
 14247                                  ;
 14248                                  ;	  Created: ARR 4 April 1983
 14249                                  
 14250                                  ;----------------------------------------------------------------------------
 14251                                  ; Procedure Name : $DIR_SEARCH_FIRST
 14252                                  ;
 14253                                  ; Inputs:
 14254                                  ;	DS:DX Points to unopenned FCB
 14255                                  ; Function:
 14256                                  ;	Directory is searched for first matching entry and the directory
 14257                                  ;	entry is loaded at the disk transfer address
 14258                                  ; Returns:
 14259                                  ;	AL = -1 if no entries matched, otherwise 0
 14260                                  ;----------------------------------------------------------------------------
 14261                                  
 14262                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 2B88h
 14263                                  
 14264                                  _$DIR_SEARCH_FIRST:
 14265 00001F33 368916[A605]            	MOV	[SS:THISFCB],DX
 14266 00001F38 368C1E[A805]            	MOV	[SS:THISFCB+2],DS
 14267 00001F3D 89D6                    	MOV	SI,DX
 14268 00001F3F 803CFF                  	CMP	BYTE [SI],0FFH
 14269 00001F42 7503                    	JNZ	short NORMFCB4
 14270 00001F44 83C607                  	ADD	SI,7			; Point to drive select byte
 14271                                  NORMFCB4:
 14272 00001F47 FF34                    	push	word [SI]		; Save original drive byte for later
 14273                                  
 14274 00001F49 16                      	push	ss
 14275 00001F4A 07                      	pop	es			; get es to address DOSGroup
 14276                                  
 14277 00001F4B BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 14278 00001F4E E8C24B                  	call	TransFCB		; convert the FCB, set SATTRIB EXTFCB
 14279 00001F51 7304                    	JNC	short SearchIt		; no error, go and look
 14280 00001F53 5B                      	pop	bx			; Clean stack
 14281                                  
 14282                                  ; Error code is in AX
 14283                                  
 14284                                  	; 09/11/2022
 14285                                  dcf_errj:
 14286 00001F54 E9FFE6                  	jmp	FCB_RET_ERR		; error
 14287                                  
 14288                                  SearchIt:
 14289 00001F57 16                      	push	ss
 14290 00001F58 1F                      	pop	ds			; get ready for search
 14291 00001F59 FF36[2C03]              	push	word [DMAADD]
 14292 00001F5D FF36[2E03]              	push	word [DMAADD+2]
 14293 00001F61 C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14294 00001F67 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14295                                  	; MSDOS 3.3
 14296                                  	;call	DOS_SEARCH_FIRST
 14297                                  	; MSDOS 6.0
 14298 00001F6B E88501                  	call	GET_FAST_SEARCH		; search
 14299 00001F6E 8F06[2E03]              	pop	word [DMAADD+2]
 14300 00001F72 8F06[2C03]              	pop	word [DMAADD]
 14301 00001F76 7303                    	JNC	short SearchSet		; no error, transfer info
 14302 00001F78 5B                      	pop	bx			; Clean stack
 14303                                  
 14304                                  ; Error code is in AX
 14305                                  
 14306                                  	; 09/11/2022
 14307                                  	;jmp	FCB_RET_ERR
 14308 00001F79 EBD9                    	jmp	short dcf_errj
 14309                                  
 14310                                  ; The search was successful (or the search-next). We store the information
 14311                                  ; into the user's FCB for continuation.
 14312                                  
 14313                                  SearchSet:
 14314 00001F7B BE[BE04]                	MOV	SI,SEARCHBUF
 14315 00001F7E C43E[A605]              	LES	DI,[THISFCB]		; point to the FCB
 14316 00001F82 F606[6C05]FF            	TEST	byte [EXTFCB],0FFh		;
 14317 00001F87 7403                    	JZ	short NORMFCB1
 14318 00001F89 83C707                  	ADD	DI,7			; Point past the extension
 14319                                  NORMFCB1:
 14320 00001F8C 5B                      	pop	bx			; Get original drive byte
 14321 00001F8D 08DB                    	OR	BL,BL
 14322 00001F8F 7506                    	JNZ	short SearchDrv
 14323 00001F91 8A1E[3603]              	MOV	BL,[CURDRV]
 14324 00001F95 FEC3                    	INC	BL
 14325                                  SearchDrv:
 14326 00001F97 AC                      	LODSB				; Get correct search contin drive byte
 14327 00001F98 86C3                    	XCHG	AL,BL			; Search byte to BL, user byte to AL
 14328 00001F9A 47                      	INC	DI
 14329                                  	;STOSB				; Store the correct "user" drive byte
 14330                                  					;  at the start of the search info
 14331 00001F9B B90A00                  	MOV	CX,20/2
 14332 00001F9E F3A5                    	REP	MOVSW			; Rest of search cont info, SI -> entry
 14333 00001FA0 86C3                    	XCHG	AL,BL			; User drive byte back to BL, search
 14334                                  					;   byte to AL
 14335 00001FA2 AA                      	STOSB				; Search contin drive byte at end of
 14336                                  					;   contin info
 14337 00001FA3 C43E[2C03]              	LES	DI,[DMAADD]
 14338 00001FA7 F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 14339 00001FAC 740D                    	JZ	short NORMFCB2
 14340 00001FAE B0FF                    	MOV	AL,0FFh
 14341 00001FB0 AA                      	STOSB
 14342 00001FB1 FEC0                    	INC	AL
 14343                                  	;MOV	CX,5
 14344                                  	; 17/12/2022
 14345 00001FB3 B105                    	mov	cl,5
 14346 00001FB5 F3AA                    	REP	STOSB
 14347 00001FB7 A0[6D05]                	MOV	AL,[SATTRIB]
 14348 00001FBA AA                      	STOSB
 14349                                  NORMFCB2:
 14350 00001FBB 88D8                    	MOV	AL,BL			; User Drive byte
 14351 00001FBD AA                      	STOSB
 14352                                  	;MOV	CX,16			; 32 / 2 words of dir entry
 14353                                  	; 17/12/2022
 14354 00001FBE B110                    	mov	cl,16
 14355 00001FC0 F3A5                    	REP	MOVSW
 14356 00001FC2 E98EE6                  	jmp	FCB_RET_OK
 14357                                  
 14358                                  ;----------------------------------------------------------------------------
 14359                                  ;
 14360                                  ; Procedure Name : $DIR_SEARCH_NEXT
 14361                                  ;
 14362                                  ; Inputs:
 14363                                  ;	DS:DX points to unopenned FCB returned by $DIR_SEARCH_FIRST
 14364                                  ; Function:
 14365                                  ;	Directory is searched for the next matching entry and the directory
 14366                                  ;	entry is loaded at the disk transfer address
 14367                                  ; Returns:
 14368                                  ;	AL = -1 if no entries matched, otherwise 0
 14369                                  ;----------------------------------------------------------------------------
 14370                                  
 14371                                  _$DIR_SEARCH_NEXT:
 14372 00001FC5 368916[A605]            	MOV	[SS:THISFCB],DX
 14373 00001FCA 368C1E[A805]            	MOV	[SS:THISFCB+2],DS
 14374 00001FCF 36C606[6D05]00          	MOV	byte [SS:SATTRIB],0
 14375 00001FD5 36C606[6C05]00          	MOV	byte [SS:EXTFCB],0
 14376                                  
 14377 00001FDB 16                      	push	ss
 14378 00001FDC 07                      	pop	es
 14379                                  
 14380 00001FDD BF[BE04]                	MOV	DI,SEARCHBUF
 14381                                  
 14382 00001FE0 89D6                    	MOV	SI,DX
 14383 00001FE2 803CFF                  	CMP	BYTE [SI],0FFh
 14384 00001FE5 750D                    	JNZ	short NORMFCB6
 14385 00001FE7 83C606                  	ADD	SI,6
 14386 00001FEA AC                      	LODSB
 14387                                  
 14388 00001FEB 36A2[6D05]              	MOV	[SS:SATTRIB],AL
 14389 00001FEF 36FE0E[6C05]            	DEC	byte [SS:EXTFCB]
 14390                                  NORMFCB6:
 14391 00001FF4 AC                      	LODSB				; Get original user drive byte
 14392 00001FF5 50                      	push	ax			; Put it on stack
 14393 00001FF6 8A4414                  	MOV	AL,[SI+20]		; Get correct search contin drive byte
 14394 00001FF9 AA                      	STOSB				; Put in correct place
 14395 00001FFA B90A00                  	MOV	CX,20/2
 14396 00001FFD F3A5                    	REP	MOVSW			; Transfer in rest of search contin info
 14397                                  
 14398 00001FFF 16                      	push	ss
 14399 00002000 1F                      	pop	ds
 14400                                  
 14401 00002001 FF36[2C03]              	push	word [DMAADD]
 14402 00002005 FF36[2E03]              	push	word [DMAADD+2]
 14403 00002009 C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14404 0000200F 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14405 00002013 E8200E                  	call	DOS_SEARCH_NEXT 	; Find it
 14406 00002016 8F06[2E03]              	pop	word [DMAADD+2]
 14407 0000201A 8F06[2C03]              	pop	word [DMAADD]
 14408 0000201E 7203                    	JC	short SearchNoMore
 14409 00002020 E958FF                  	JMP	SearchSet		; Ok set return
 14410                                  
 14411                                  SearchNoMore:
 14412 00002023 C43E[A605]              	LES	DI,[THISFCB]
 14413 00002027 F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 14414 0000202C 7403                    	JZ	short NORMFCB8
 14415 0000202E 83C707                  	ADD	DI,7			; Point past the extension
 14416                                  NORMFCB8:
 14417 00002031 5B                      	pop	bx			; Get original drive byte
 14418 00002032 26881D                  	MOV	[ES:DI],BL		; Store the correct "user" drive byte
 14419                                  					;  at the right spot
 14420                                  ; error code is in AX
 14421                                  
 14422 00002035 E91EE6                  	jmp	FCB_RET_ERR
 14423                                  
 14424                                  ; 17/05/2019 - Retro DOS v4.0
 14425                                  
 14426                                  ; DOSCODE:5EE6h (MSDOS 6.21, MSDOS.SYS)
 14427                                  
 14428                                  ;---------------------------------------------------------------------------
 14429                                  ;
 14430                                  ;   Procedure Name : $FIND_FIRST
 14431                                  ; 
 14432                                  ;   Assembler usage:
 14433                                  ;	    MOV AH, FindFirst
 14434                                  ;	    LDS DX, name
 14435                                  ;	    MOV CX, attr
 14436                                  ;	    INT 21h
 14437                                  ;	; DMA address has datablock
 14438                                  ;
 14439                                  ;   Error Returns:
 14440                                  ;	    AX = error_path_not_found
 14441                                  ;	       = error_no_more_files
 14442                                  ;---------------------------------------------------------------------------
 14443                                  
 14444                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14445                                  	; DOSCODE:5ED2h (MSDOS 5.0, MSDOS.SYS)
 14446                                  
 14447                                  _$FIND_FIRST:
 14448 00002038 89D6                    	MOV	SI,DX			; get name in appropriate place
 14449 0000203A 36880E[6D05]            	MOV	[SS:SATTRIB],CL		; Search attribute to correct loc
 14450                                  
 14451 0000203F BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 14452                                  
 14453 00002042 E8344B                  	call	TransPathSet		; convert the path
 14454 00002045 7305                    	JNC	short Find_it 		; no error, go and look
 14455                                  FindError:
 14456                                  	;mov	al,3
 14457 00002047 B003                    	mov	al, error_path_not_found ; error and map into one.
 14458                                  	; 09/11/2022
 14459                                  FF_errj:
 14460 00002049 E9F4E5                  	jmp	SYS_RET_ERR
 14461                                  Find_it:
 14462 0000204C 16                      	push	ss
 14463 0000204D 1F                      	pop	ds
 14464                                  
 14465 0000204E FF36[2C03]              	push	word [DMAADD]
 14466 00002052 FF36[2E03]              	push	word [DMAADD+2]
 14467 00002056 C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14468 0000205C 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14469                                  	; MSDOS 3.3
 14470                                  	;call	DOS_SEARCH_FIRST
 14471                                  	; MSDOS 6.0
 14472 00002060 E89000                  	call	GET_FAST_SEARCH 	; search
 14473 00002063 8F06[2E03]              	pop	word [DMAADD+2]
 14474 00002067 8F06[2C03]              	pop	word [DMAADD]
 14475                                  	
 14476                                  	; 16/12/2022
 14477                                  	;JNC	short FindSet 		; no error, transfer info
 14478 0000206B 72DC                    	jc	short FF_errj	; jmp SYS_RET_ERR
 14479                                  	;
 14480                                  	;jmp	SYS_RET_ERR
 14481                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14482                                  ;FFF_errj:
 14483                                  	;jmp	short FF_errj	; jmp SYS_RET_ERR
 14484                                  
 14485                                  FindSet:
 14486 0000206D BE[BE04]                	MOV	SI,SEARCHBUF
 14487 00002070 C43E[2C03]              	LES	DI,[DMAADD]
 14488 00002074 B91500                  	MOV	CX,21
 14489 00002077 F3A4                    	REP	MOVSB
 14490 00002079 56                      	PUSH	SI			; Save pointer to start of entry
 14491                                  	;mov	al,[si+0Bh]
 14492 0000207A 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 14493 0000207D AA                      	STOSB
 14494                                  	;add	si,16h ; 22
 14495 0000207E 83C616                  	ADD	SI,dir_entry.dir_time
 14496 00002081 A5                      	MOVSW				; dir_time
 14497 00002082 A5                      	MOVSW				; dir_date
 14498 00002083 46                      	INC	SI
 14499 00002084 46                      	INC	SI			; Skip dir_first
 14500 00002085 A5                      	MOVSW				; dir_size (2 words)
 14501 00002086 A5                      	MOVSW
 14502 00002087 5E                      	POP	SI			; Point back to dir_name
 14503 00002088 E83500                   	CALL	PackName
 14504 0000208B E9A9E5                  	jmp	SYS_RET_OK		; bye with no errors
 14505                                  
 14506                                  ;---------------------------------------------------------------------------
 14507                                  ;
 14508                                  ;   Procedure Name : $FIND_NEXT
 14509                                  ;
 14510                                  ;   Assembler usage:
 14511                                  ;	; dma points at area returned by find_first
 14512                                  ;	    MOV AH, findnext
 14513                                  ;	    INT 21h
 14514                                  ;	; next entry is at dma
 14515                                  ;
 14516                                  ;   Error Returns:
 14517                                  ;	    AX = error_no_more_files
 14518                                  ;---------------------------------------------------------------------------
 14519                                  
 14520                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14521                                  _$FIND_NEXT:
 14522 0000208E 16                      	push	ss
 14523 0000208F 07                      	pop	es
 14524                                  
 14525 00002090 BF[BE04]                	MOV	DI,SEARCHBUF
 14526                                  
 14527 00002093 36C536[2C03]            	LDS	SI,[SS:DMAADD]
 14528                                  
 14529 00002098 B91500                  	MOV	CX,21
 14530 0000209B F3A4                    	REP	MOVSB			; Put the search continuation info
 14531                                  					;  in the right place
 14532 0000209D 16                      	push	ss
 14533 0000209E 1F                      	pop	ds			; get ready for search
 14534                                  	
 14535 0000209F FF36[2C03]              	push	word [DMAADD]
 14536 000020A3 FF36[2E03]              	push	word [DMAADD+2]
 14537 000020A7 C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14538 000020AD 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14539 000020B1 E8820D                  	call	DOS_SEARCH_NEXT 	; Find it
 14540 000020B4 8F06[2E03]              	pop	word [DMAADD+2]
 14541 000020B8 8F06[2C03]              	pop	word [DMAADD]
 14542 000020BC 73AF                    	JNC	short FindSet 		; No error, set info
 14543                                  	;jmp	SYS_RET_ERR
 14544                                  	; 16/12/2022
 14545 000020BE EB89                    	jmp	short FF_errj	; jmp SYS_RET_ERR
 14546                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14547                                  	;jmp	short FFF_errj	; jmp SYS_RET_ERR
 14548                                  
 14549                                  ;---------------------------------------------------------------------------
 14550                                  ;**	PackName - Convert file names from FCB to ASCIZ format.
 14551                                  ;
 14552                                  ;	PackName transfers a file name from DS:SI to ES:DI and converts it to
 14553                                  ;	the ASCIZ format.
 14554                                  ;
 14555                                  ;	ENTRY	(DS:SI) = 11 character FCB or dir entry name
 14556                                  ;		(ES:DI) = destination area (13 bytes)
 14557                                  ;	EXIT	(ds:SI) and (es:DI) advanced
 14558                                  ;	USES	al, CX, SI, DI, Flags  (BUGBUG - not verified - jgl)
 14559                                  ;---------------------------------------------------------------------------
 14560                                  
 14561                                  PackName:
 14562                                  ;	Move over 8 characters to cover the name component, then trim it's
 14563                                  ;	trailing blanks.
 14564                                  
 14565 000020C0 B90800                  	MOV	CX,8			; Pack the name
 14566 000020C3 F3A4                    	REP	MOVSB			; Move all of it
 14567                                  main_kill_tail:
 14568 000020C5 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 14569 000020CA 7507                    	JNZ	short find_check_dot
 14570 000020CC 4F                      	DEC	DI			; Back up over trailing space
 14571 000020CD 41                      	INC	CX
 14572 000020CE 83F908                  	CMP	CX,8
 14573 000020D1 72F2                    	JB	short main_kill_tail
 14574                                  find_check_dot:
 14575                                  	;CMP	WORD [SI],(" " << 8) | " "
 14576 000020D3 813C2020                	cmp     word [si],2020h 
 14577 000020D7 7506                    	JNZ	short got_ext 		; Some chars in extension
 14578 000020D9 807C0220                	CMP	BYTE [SI+2]," "
 14579 000020DD 7410                    	JZ	short find_done		; No extension
 14580                                  got_ext:
 14581 000020DF B02E                    	MOV	AL,"."	; 2Eh
 14582 000020E1 AA                      	STOSB
 14583                                  	;MOV	CX,3
 14584                                  	; 18/12/2022
 14585                                  	;mov	cl,3
 14586                                  	;REP	MOVSB
 14587 000020E2 A4                      	movsb
 14588 000020E3 A4                      	movsb
 14589 000020E4 A4                      	movsb
 14590                                  ext_kill_tail:
 14591 000020E5 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 14592 000020EA 7503                    	JNZ	short find_done
 14593 000020EC 4F                      	DEC	DI			; Back up over trailing space
 14594 000020ED EBF6                    	JMP	short ext_kill_tail
 14595                                  find_done:
 14596 000020EF 31C0                    	XOR	AX,AX
 14597 000020F1 AA                      	STOSB				; NUL terminate
 14598 000020F2 C3                      	retn
 14599                                  
 14600                                  ;---------------------------------------------------------------------------
 14601                                  
 14602                                  	; 17/05/2019 - Retro DOS v4.0
 14603                                  GET_FAST_SEARCH:
 14604                                  	; 22/07/2018
 14605                                  	; MSDOS 6.0
 14606                                  	; 17/12/2022
 14607 000020F3 36800E[1206]04          	OR	byte [ss:DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)  ; 04h
 14608                                  	;OR	word [ss:DOS34_FLAG],SEARCH_FASTOPEN  ; 400h
 14609                                  					;FO.trigger fastopen ;AN000;
 14610                                  	;call	DOS_SEARCH_FIRST
 14611                                  	;retn
 14612                                  	; 17/12/2022
 14613 000020F9 E94E0C                  	jmp	DOS_SEARCH_FIRST
 14614                                  
 14615                                  ;============================================================================
 14616                                  ; PATH.ASM, MSDOS 6.0, 1991
 14617                                  ;============================================================================
 14618                                  ; 06/08/2018 - Retro DOS v3.0
 14619                                  ; 17/05/2019 - Retro DOS v4.0
 14620                                  
 14621                                  ; DOSCODE:5FB0h (MSDOS 6.21, MSDOS.SYS)
 14622                                  
 14623                                  ;**	Directory related system calls. These will be passed direct text of the
 14624                                  ;	pathname from the user. They will need to be passed through the macro
 14625                                  ;	expander prior to being sent through the low-level stuff. I/O specs are
 14626                                  ;	defined in DISPATCH. The system calls are:
 14627                                  ;
 14628                                  ;	$CURRENT_DIR  Written
 14629                                  ;	$RMDIR	  Written
 14630                                  ;	$CHDIR	  Written
 14631                                  ;	$MKDIR	  Written
 14632                                  ;
 14633                                  ;
 14634                                  ;	Modification history:
 14635                                  ;
 14636                                  ;	    Created: ARR 4 April 1983
 14637                                  ;		 MZ 10 May 1983     CurrentDir implemented
 14638                                  ;		 MZ 11 May 1983     RmDir, ChDir, MkDir implemented
 14639                                  ;		 EE 19 Oct 1983     RmDir no longer allows you to delete a
 14640                                  ;				    current directory.
 14641                                  ;		 MZ 19 Jan 1983     Brain damaged applications rely on success
 14642                                  
 14643                                  ;	I_Need	ThisCDS,DWORD		; pointer to Current CDS
 14644                                  ;	I_Need	WFP_Start,WORD		; pointer to beginning of directory text
 14645                                  ;	I_Need	Curr_Dir_End,WORD	; offset to end of directory part
 14646                                  ;	I_Need	OpenBuf,128		; temp spot for translated name
 14647                                  ;	I_need	fSplice,BYTE		; TRUE => do splice
 14648                                  ;	I_Need	NoSetDir,BYTE		; TRUE => no exact match on splice
 14649                                  ;	I_Need	cMeta,BYTE
 14650                                  ;	I_Need	DrvErr,BYTE					;AN000;
 14651                                  
 14652                                  ;BREAK <$CURRENT_DIR - dump the current directory into user space>
 14653                                  ;----------------------------------------------------------------------------
 14654                                  ;
 14655                                  ;   Procedure Name : $CURRENT_DIR
 14656                                  ;
 14657                                  ;   Assembler usage:
 14658                                  ;		LDS	SI,area
 14659                                  ;		MOV	DL,drive
 14660                                  ;		INT	21h
 14661                                  ;	    ; DS:SI is a pointer to 64 byte area that contains drive
 14662                                  ;	    ; current directory.
 14663                                  ;   Error returns:
 14664                                  ;	    AX = error_invalid_drive
 14665                                  ;
 14666                                  ;----------------------------------------------------------------------------
 14667                                  
 14668                                  _$CURRENT_DIR:
 14669                                  	;06/08/2018 - Retro DOS v3.0
 14670                                  	;IBMDOS.COM (MSDOS 3.3, 1987) - Offset 2D4Eh
 14671 000020FC E80EF2                  	call	ECritDisk
 14672 000020FF 88D0                    	MOV	AL,DL			; get drive number (0=def, 1=A)
 14673 00002101 E87E49                  	call	GetVisDrv		; grab it
 14674 00002104 7310                    	JNC	short CurrentValidate 	; no error -> go and validate dir
 14675                                  CurdirErr:
 14676 00002106 E81FF2                  	call	LCritDisk
 14677                                  
 14678                                  	; MSDOS 3.3
 14679                                  	;mov	al,0Fh
 14680                                  	
 14681                                  	; MSDOS 6.0
 14682 00002109 1E                      	push	ds
 14683 0000210A 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 14684 0000210F A0[1006]                	mov	al,[DrvErr]		;IFS.			;AN000;
 14685 00002112 1F                      	pop	ds
 14686                                  
 14687                                  curdir_errj:
 14688 00002113 E92AE5                  	jmp	SYS_RET_ERR		;IFS. make noise	;AN000;
 14689                                  
 14690                                  CurrentValidate:
 14691 00002116 1E                      	push	ds			; save destination
 14692 00002117 56                      	push	si
 14693                                  	
 14694                                  	;LDS	SI,[CS:THISCDS] ; MSDOS 3.3
 14695                                  	
 14696                                  	; MSDOS 6.0
 14697 00002118 2E8E1E[0700]            	mov     ds,[cs:DosDSeg]
 14698 0000211D C536[A205]              	lds     si,[THISCDS]
 14699                                  
 14700                                  ; 16/12/2022
 14701                                  %if 0
 14702                                  	; 09/11/2022 (following test instruction is nonsense!)
 14703                                  	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)
 14704                                  
 14705                                  	;test	word [si+43h],8000h
 14706                                  	TEST	word [SI+curdir.flags],curdir_isnet
 14707                                  	;jnz	short $+2  ; 09/11/2022	
 14708                                  	jnz	short DoCheck
 14709                                  %endif
 14710                                  
 14711                                  ; Random optimization nuked due to some utilities using GetCurrentDir to do
 14712                                  ; media check.
 14713                                  ;	CMP	word [SI+curdir.ID],0
 14714                                  ;	JZ	short GetDst
 14715                                  DoCheck:
 14716                                  	;MOV	byte [cs:NoSetDir],0	; interested only in contents
 14717                                  
 14718                                  	; MSDOS 6.0
 14719 00002121 1E                      	push	ds
 14720 00002122 2E8E1E[0700]            	mov     ds,[cs:DosDSeg]
 14721 00002127 C606[4C03]00            	mov	byte [NoSetDir],0
 14722 0000212C 1F                      	pop	ds
 14723                                  
 14724 0000212D BF[BE03]                	MOV	DI,OPENBUF
 14725 00002130 E83521                  	call	ValidateCDS		; output is ES:DI -> CDS
 14726                                  
 14727 00002133 06                      	push	es	 		; swap source and destination
 14728 00002134 57                      	push	di
 14729 00002135 5E                      	pop	si
 14730 00002136 1F                      	pop	ds
 14731                                  GetDst:
 14732 00002137 5F                      	pop	di
 14733 00002138 07                      	pop	es			; get real destination
 14734 00002139 72CB                    	JC	short CurdirErr
 14735                                  	;ADD	SI,curdir.text ; add si,0 ; 09/08/2018
 14736                                  	;
 14737                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14738                                  	; DOSCODE:5FE2h (MSDOS 5.0, MSDOS.SYS)
 14739                                  	; 16/12/2022
 14740                                  	;add	si,0  ; add si,curdir.text
 14741                                  	;
 14742                                  	;add	si,[si+4Fh] ; 17/05/2019
 14743 0000213B 03744F                  	ADD	SI,[SI+curdir.end]
 14744 0000213E 803C5C                  	CMP	BYTE [SI],'\'	; 5Ch	; root or subdirs present?
 14745 00002141 7501                    	JNZ	short CurrentCopy
 14746 00002143 46                      	INC	SI
 14747                                  CurrentCopy:
 14748                                  ;	call	FStrCpy
 14749                                  ;; 10/29/86 E5 char
 14750 00002144 50                      	PUSH	AX
 14751 00002145 AC                      	LODSB				; get char
 14752 00002146 08C0                    	OR	AL,AL
 14753 00002148 7413                    	JZ	short FOK
 14754 0000214A 3C05                    	CMP	AL,05H
 14755 0000214C 740D                    	JZ	short FCHANGE
 14756 0000214E EB01                    	JMP	short FFF
 14757                                  FCPYNEXT:
 14758 00002150 AC                      	LODSB				; get char
 14759                                  FFF:
 14760 00002151 3C5C                    	CMP	AL,'\'			; beginning of directory
 14761 00002153 7508                    	JNZ	short FOK		; no
 14762 00002155 AA                      	STOSB				; put into user's buffer
 14763 00002156 AC                      	LODSB				; 1st char of dir is 05?
 14764 00002157 3C05                    	CMP	AL,05H
 14765 00002159 7502                    	JNZ	short FOK		; no
 14766                                  FCHANGE:
 14767 0000215B B0E5                    	MOV	AL,0E5H			; make it E5
 14768                                  FOK:
 14769 0000215D AA                      	STOSB				; put into user's buffer
 14770 0000215E 08C0                    	OR	AL,AL			; final char
 14771 00002160 75EE                    	JNZ	short FCPYNEXT		; no
 14772 00002162 58                      	POP	AX
 14773                                  
 14774                                  ;; 10/29/86 E5 char
 14775 00002163 30C0                    	xor	AL,AL			; MZ 19 Jan 84
 14776 00002165 E8C0F1                  	call	LCritDisk
 14777 00002168 E9CCE4                  	jmp	SYS_RET_OK		; no more, bye!
 14778                                  
 14779                                  ; 17/05/2019 - Retro DOS v4.0
 14780                                  
 14781                                  ; DOSCODE:6029h (MSDOS 6.21, MSDOS.SYS)
 14782                                  
 14783                                  ;BREAK <$RmDir -- Remove a directory>
 14784                                  ;----------------------------------------------------------------------------
 14785                                  ;
 14786                                  ; Procedure Name : $RmDir
 14787                                  ;
 14788                                  ; Inputs:
 14789                                  ;	DS:DX Points to asciz name
 14790                                  ; Function:
 14791                                  ;	Delete directory if empty
 14792                                  ; Returns:
 14793                                  ;	STD XENIX Return
 14794                                  ;	AX = error_path_not_found If path bad
 14795                                  ;	AX = error_access_denied If
 14796                                  ;		Directory not empty
 14797                                  ;		Path not directory
 14798                                  ;		Root directory specified
 14799                                  ;		Directory malformed (. and .. not first two entries)
 14800                                  ;		User tries to delete a current directory
 14801                                  ;	AX = error_current_directory
 14802                                  ;
 14803                                  ;----------------------------------------------------------------------------
 14804                                  
 14805                                  	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14806                                  	; DOSCODE:6015h (MSDOS 5.0, MSDOS.SYS)
 14807                                  
 14808                                  _$RMDIR:
 14809 0000216B 52                      	push	dx			; Save ptr to name
 14810 0000216C 1E                      	push	ds
 14811 0000216D 89D6                    	mov	si,dx			; Load ptr into si
 14812 0000216F BF[BE03]                	mov	di,OPENBUF		; di = ptr to buf for trans name
 14813 00002172 57                      	push	di
 14814 00002173 E80B4A                  	call	TransPathNoSet		; Translate the name
 14815 00002176 5F                      	pop	di			; di = ptr to buf for trans name
 14816 00002177 7306                    	jnc	short rmlset		; If transpath succeeded, continue
 14817 00002179 1F                      	pop	ds
 14818 0000217A 5A                      	pop	dx			; Restore the name
 14819                                  	;mov	al,3
 14820 0000217B B003                    	mov	al,error_path_not_found ; Otherwise, return an error
 14821                                  	; 16/12/2022
 14822                                  rmdir_errj: ; 10/08/2018
 14823                                  chdir_errj:
 14824 0000217D EB94                    	jmp	short curdir_errj
 14825                                  	;jmp	SYS_RET_ERR
 14826                                  rmlset:
 14827 0000217F 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1	;   if (cMeta >= 0)
 14828 00002185 7512                    	Jnz	short rmerr		;	return (-1);
 14829 00002187 16                      	push	ss
 14830 00002188 07                      	pop	es
 14831 00002189 30C0                    	xor	al,al			; al = 0 , ie drive a:
 14832                                  rmloop: 
 14833 0000218B E86549                  	call	GetCDSFromDrv		; Get curdir for drive in al
 14834 0000218E 720F                    	jc	short rmcont		; If error, exit loop & cont normally
 14835 00002190 E81EF0                  	call	StrCmp			; Are the 2 paths the same?
 14836 00002193 7404                    	jz	short rmerr		; Yes, report error.
 14837 00002195 FEC0                    	inc	al			; No, inc al to next drive number
 14838 00002197 EBF2                    	jmp	short rmloop		; Go check next drive.
 14839                                  rmerr:
 14840 00002199 1F                      	pop	ds
 14841 0000219A 5A                      	pop	dx			; Restore the name
 14842                                  	;mov	al,10h
 14843 0000219B B010                    	mov	al,error_current_directory ; error
 14844                                  	; 16/12/2022
 14845                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14846                                  ;chdir_errj:
 14847 0000219D EBDE                    	jmp	short rmdir_errj
 14848                                  rmcont:
 14849 0000219F 1F                      	pop	ds
 14850 000021A0 5A                      	pop	dx			; Restore the name
 14851 000021A1 BE[0B32]                	MOV	SI,DOS_RMDIR
 14852 000021A4 EB7C                    	JMP	DoDirCall
 14853                                  
 14854                                  ; 17/05/2019 - Retro DOS v4.0
 14855                                  
 14856                                  ; DOSCODE:6065h (MSDOS 6.21, MSDOS.SYS)
 14857                                  
 14858                                  ;BREAK <$ChDir -- Change current directory on a drive>
 14859                                  ;----------------------------------------------------------------------------
 14860                                  ;
 14861                                  ; $ChDir - Top-level change directory system call.  This call is responsible
 14862                                  ; for setting up the CDS for the specified drive appropriately.  There are
 14863                                  ; several cases to consider:
 14864                                  ;
 14865                                  ;   o	Local, simple CDS.  In this case, we take the input path and convert
 14866                                  ;	it into a WFP.	We verify the existance of this directory and then
 14867                                  ;	copy the WFP into the CDS and set up the ID field to point to the
 14868                                  ;	directory cluster.
 14869                                  ;   o	Net CDS.  We form the path from the root (including network prefix)
 14870                                  ;	and verify its existance (via DOS_Chdir).  If successful, we copy the
 14871                                  ;	WFP back into the CDS.
 14872                                  ;   o	SUBST'ed CDS.  This is no different than the local, simple CDS.
 14873                                  ;   o	JOIN'ed CDS.  This is trouble as there are two CDS's at work.  If we
 14874                                  ;	call TransPath, we will get the PHYSICAL CDS that the path refers to
 14875                                  ;	and the PHYSICAL WFP that the input path refers to.  This is perfectly
 14876                                  ;	good for the validation but not for currency.  We call TransPathNoSet
 14877                                  ;	to process the path but to return the logical CDS and the logical
 14878                                  ;	path.  We then copy the logical path into the logical CDS.
 14879                                  ;
 14880                                  ; Inputs:
 14881                                  ;	DS:DX Points to asciz name
 14882                                  ; Returns:
 14883                                  ;	STD XENIX Return
 14884                                  ;	AX = chdir_path_not_found if error
 14885                                  ;
 14886                                  ;----------------------------------------------------------------------------
 14887                                  
 14888                                  _$CHDIR:
 14889 000021A6 BF[BE03]                	MOV	DI,OPENBUF		; spot for translated name
 14890 000021A9 89D6                    	MOV	SI,DX			; get source
 14891 000021AB E8C749                  	call	TransPath		; go munge the path and get real CDS
 14892 000021AE 7304                    	JNC	short ChDirCrack	; no errors, try path
 14893                                  ChDirErrP:
 14894                                  	;mov	al,3
 14895 000021B0 B003                    	MOV	AL,error_path_not_found
 14896                                  ChDirErr:
 14897                                  	;jmp	SYS_RET_ERR 	; oops!
 14898                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14899 000021B2 EBC9                    	jmp	short chdir_errj
 14900                                  
 14901                                  ChDirCrack:
 14902 000021B4 803E[7A05]FF            	CMP	byte [CMETA],-1		; No meta chars allowed.
 14903 000021B9 75F5                    	JNZ	short ChDirErrP
 14904                                  
 14905                                  ; We cannot do a ChDir (yet) on a raw CDS. This is treated as a path not
 14906                                  ; found.
 14907                                  
 14908 000021BB C43E[A205]              	LES	DI,[THISCDS]
 14909 000021BF 83FFFF                  	CMP	DI,-1			;   if (ThisCDS == NULL)
 14910 000021C2 74EC                    	JZ	short ChDirErrP		;	error ();
 14911                                  
 14912                                  ; Find out if the directory exists.
 14913                                  
 14914 000021C4 E80110                  	call	DOS_CHDIR
 14915                                  	;Jc	short ChDirErr
 14916                                  	; 16/12/2022
 14917 000021C7 72B4                    	jc	short chdir_errj
 14918                                  ;
 14919                                  ; Get back CDS to see if a join as seen. Set the currency pointer (only if
 14920                                  ; not network). If one was seen, all we need to do is copy in the text
 14921                                  ;
 14922 000021C9 C43E[A205]              	LES	DI,[THISCDS]
 14923                                  	;test	word [es:di+43h],2000h
 14924                                  	; 17/12/2022
 14925 000021CD 26F6454420              	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
 14926                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice
 14927 000021D2 7425                    	JZ	short GotCDS
 14928                                  
 14929                                  ; The CDS was joined. Let's go back and grab the logical CDS.
 14930                                  
 14931 000021D4 06                      	push	es	
 14932 000021D5 57                      	push	di
 14933 000021D6 51                      	push	cx			; save CDS and cluster...
 14934 000021D7 E8A7E2                  	call	Get_User_Stack		; get original text
 14935                                  	
 14936                                  	;mov	di,[si+6]
 14937 000021DA 8B7C06                  	MOV	DI,[SI+user_env.user_DX]
 14938                                  	;mov	ds,[si+0Eh]
 14939 000021DD 8E5C0E                  	MOV	DS,[SI+user_env.user_DS]
 14940                                  	
 14941 000021E0 BE[BE03]                	MOV	SI,OPENBUF		; spot for translated name
 14942 000021E3 87F7                    	XCHG	SI,DI
 14943 000021E5 30C0                    	XOR	AL,AL			; do no splicing
 14944 000021E7 57                      	push	di
 14945 000021E8 E89649                  	call	TransPathNoSet		; Munge path
 14946 000021EB 5E                      	pop	si
 14947                                  
 14948                                  ; There should NEVER be an error here.
 14949                                  
 14950                                  ;IF FALSE
 14951                                  ;	JNC SKipErr
 14952                                  ;	fmt <>,<>,<"$p: Internal CHDIR error\n">
 14953                                  ;SkipErr:
 14954                                  ;ENDIF
 14955 000021EC C43E[A205]              	LES	DI,[THISCDS]		; get new CDS
 14956                                  	;mov	word [es:di+49h],-1
 14957 000021F0 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],-1
 14958                                  					; no valid cluster here...
 14959 000021F6 59                      	pop	cx
 14960 000021F7 5F                      	pop	di
 14961 000021F8 07                      	pop	es
 14962                                  
 14963                                  ; ES:DI point to the physical CDS, CX is the ID (local only)
 14964                                  
 14965                                  GotCDS:
 14966                                  
 14967                                  ; wfp_start points to the text. See if it is long enough
 14968                                  
 14969                                  	; MSDOS 3.3
 14970                                  	;push	ss
 14971                                  	;pop	ds
 14972                                  	;mov	si,[WFP_START]
 14973                                  	;push	cx
 14974                                  	;call	DStrLen
 14975                                  	;cmp	cx,67 ; cmp cx,DIRSTRLEN
 14976                                  	;pop	cx
 14977                                  	;ja	short ChDirErrP
 14978                                  
 14979                                  	; MSDOS 6.0
 14980 000021F9 E85000                  	CALL	Check_PathLen		;PTM.		;AN000;
 14981 000021FC 77B2                    	JA	short ChDirErrP
 14982                                  	; MSDOS 3.3 & MSDOS 6.0
 14983                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
 14984                                  	; 17/12/2022
 14985 000021FE 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8
 14986 00002203 7512                    	JNZ	short SkipRecency
 14987                                  	; MSDOS 6.0
 14988                                  	;test	word [es:di+43h],2000h
 14989                                  	; 17/12/2022
 14990 00002205 26F6454420              	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
 14991                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice 
 14992                                  					;PTM. for Join and Subst ;AN000;
 14993 0000220A 7403                    	JZ	short setdirclus	;PTM.		;AN000;
 14994 0000220C B9FFFF                  	MOV	CX,-1			;PTM.		;AN000;
 14995                                  setdirclus:
 14996                                  	;mov	[es:di+49h],cx
 14997 0000220F 26894D49                	MOV	[ES:DI+curdir.ID],CX
 14998 00002213 C43E[A205]              	LES	DI,[THISCDS]		; get logical CDS
 14999                                  SkipRecency:
 15000 00002217 E8C8EF                  	call	FStrCpy
 15001 0000221A 30C0                    	XOR	AL,AL
 15002                                  mkdir_ok:
 15003 0000221C E918E4                  	jmp	SYS_RET_OK
 15004                                  
 15005                                  ; 17/05/2019 - Retro DOS v4.0
 15006                                  
 15007                                  ; DOSCODE:60E1h (MSDOS 6.21, MSDOS.SYS)
 15008                                  
 15009                                  ;BREAK <$MkDir - Make a directory entry>
 15010                                  ;---------------------------------------------------------------------------
 15011                                  ;
 15012                                  ; Procedure Name : $MkDir
 15013                                  ; Inputs:
 15014                                  ;	DS:DX Points to asciz name
 15015                                  ; Function:
 15016                                  ;	Make a new directory
 15017                                  ; Returns:
 15018                                  ;	STD XENIX Return
 15019                                  ;	AX = mkdir_path_not_found if path bad
 15020                                  ;	AX = mkdir_access_denied  If
 15021                                  ;		Directory cannot be created
 15022                                  ;		Node already exists
 15023                                  ;		Device name given
 15024                                  ;		Disk or directory(root) full
 15025                                  ;---------------------------------------------------------------------------
 15026                                  
 15027                                  	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15028                                  
 15029                                  _$MKDIR:
 15030 0000221F BE[D830]                	MOV	SI,DOS_MKDIR
 15031                                  DoDirCall:
 15032 00002222 BF[BE03]                	MOV	DI,OPENBUF		; spot for translated name
 15033                                  
 15034 00002225 56                      	push	si
 15035 00002226 89D6                    	MOV	SI,DX			; get source
 15036 00002228 E84A49                  	call	TransPath		; go munge the path
 15037 0000222B 5E                      	pop	si
 15038 0000222C 7305                    	JNC	short MkDirCrack	; no errors, try path
 15039                                  MkErrP:
 15040 0000222E B003                    	MOV	AL,error_path_not_found	; oops!
 15041                                  MkErr:
 15042 00002230 E90DE4                  	jmp	SYS_RET_ERR
 15043                                  MkDirCrack:
 15044 00002233 36803E[7A05]FF          	CMP	byte [SS:CMETA],-1
 15045 00002239 75F3                    	JNZ	short MkErrP
 15046                                  
 15047                                  	; MSDOS 3.3
 15048                                  	;push	ss
 15049                                  	;pop	ds
 15050                                  	;call	si
 15051                                  	;jb	short MkErr
 15052                                  	;;jmp	short mkdir_ok
 15053                                  	;jmp	SYS_RET_OK
 15054                                  
 15055                                  	; MSDOS 6.0
 15056 0000223B 56                      	PUSH	SI			;PTM.			;AN000;
 15057 0000223C E80D00                  	CALL	Check_PathLen		;PTM. check path len > 67 ? ;AN000;
 15058 0000223F 5E                      	POP	SI			;PTM.			;AN000;
 15059 00002240 7604                    	JBE	short pathok		;PTM.			;AN000;
 15060                                  	;mov	al,5
 15061 00002242 B005                    	MOV	AL,error_access_denied	;PTM. ops!
 15062                                  	;jmp	SYS_RET_ERR		;PTM.
 15063 00002244 EBEA                    	jmp	short MkErr
 15064                                  pathok:
 15065 00002246 FFD6                    	CALL	SI			; go get file
 15066 00002248 72E6                    	JC	short MkErr		; no errors
 15067                                  	; 16/12/2022
 15068                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15069 0000224A EBD0                    	jmp	short mkdir_ok
 15070                                  	;jmp	SYS_RET_OK
 15071                                  
 15072                                  ;----------------------------------------------------------------------------
 15073                                  ;
 15074                                  ; Procedure Name : Check_PathLen
 15075                                  ;
 15076                                  ; Inputs:
 15077                                  ;	nothing
 15078                                  ; Function:
 15079                                  ;	check if final path length greater than 67
 15080                                  ; Returns:
 15081                                  ;	Above flag set if > 67
 15082                                  ;
 15083                                  ;---------------------------------------------------------------------------
 15084                                  
 15085                                  Check_PathLen:
 15086                                  	; 09/09/2018
 15087                                  	;mov	SI,[WFP_START]
 15088 0000224C 368B36[B205]            	MOV	SI,[SS:WFP_START] ; MSDOS 6.0
 15089                                  Check_PathLen2:
 15090 00002251 16                      	push	ss
 15091 00002252 1F                      	pop	ds
 15092                                  	;mov	SI,[WFP_START]	  ; MSDOS 3.3
 15093 00002253 51                      	push	CX	
 15094 00002254 E8A2EF                  	CALL	DStrLen
 15095 00002257 83F943                  	CMP	CX,DIRSTRLEN ; 67
 15096 0000225A 59                      	POP	CX
 15097 0000225B C3                      	retn
 15098                                  
 15099                                  ;============================================================================
 15100                                  ; IOCTL.ASM, MSDOS 6.0, 1991
 15101                                  ;============================================================================
 15102                                  ; 07/08/2018 - Retro DOS v3.0
 15103                                  ; 17/05/2019 - Retro DOS v4.0
 15104                                  
 15105                                  ;**	IOCTL system call.
 15106                                  ;----------------------------------------------------------------------------
 15107                                  ;	$IOCTL
 15108                                  ;
 15109                                  ;	  Revision history:
 15110                                  ;
 15111                                  ;		Created: ARR 4 April 1983
 15112                                  ;
 15113                                  ;		GenericIOCTL added:		KGS	22 April 1985
 15114                                  ;
 15115                                  ;		A000	version 4.00	Jan. 1988
 15116                                  ;
 15117                                  ;		Used jump table to dispatch IOCTL functions. HKN 3/12/90
 15118                                  ;
 15119                                  
 15120                                  ;BREAK <IOCTL - munge on a handle to do device specific stuff>
 15121                                  ;---------------------------------------------------------------------------
 15122                                  ;
 15123                                  ;   Assembler usage:
 15124                                  ;	    MOV     BX, Handle
 15125                                  ;	    MOV     DX, Data
 15126                                  ;
 15127                                  ;	(or LDS     DX,BUF
 15128                                  ;	    MOV     CX,COUNT)
 15129                                  ;
 15130                                  ;	    MOV     AH, Ioctl
 15131                                  ;	    MOV     AL, Request
 15132                                  ;	    INT     21h
 15133                                  ;
 15134                                  ;   AH = 0  Return a combination of low byte of sf_flags and device driver
 15135                                  ;	    attribute word in DX, handle in BX:
 15136                                  ;	    DH = high word of device driver attributes
 15137                                  ;	    DL = low byte of sf_flags
 15138                                  ;	 1  Set the bits contained in DX to sf_flags.  DH MUST be 0.  Handle
 15139                                  ;	    in BX.
 15140                                  ;	 2  Read CX bytes from the device control channel for handle in BX
 15141                                  ;	    into DS:DX.  Return number read in AX.
 15142                                  ;	 3  Write CX bytes to the device control channel for handle in BX from
 15143                                  ;	    DS:DX.  Return bytes written in AX.
 15144                                  ;	 4  Read CX bytes from the device control channel for drive in BX
 15145                                  ;	    into DS:DX.  Return number read in AX.
 15146                                  ;	 5  Write CX bytes to the device control channel for drive in BX from
 15147                                  ;	    DS:DX.  Return bytes written in AX.
 15148                                  ;	 6  Return input status of handle in BX. If a read will go to the
 15149                                  ;	    device, AL = 0FFh, otherwise 0.
 15150                                  ;	 7  Return output status of handle in BX. If a write will go to the
 15151                                  ;	    device, AL = 0FFh, otherwise 0.
 15152                                  ;	 8  Given a drive in BX, return 1 if the device contains non-
 15153                                  ;	    removable media, 0 otherwise.
 15154                                  ;	 9  Return the contents of the device attribute word in DX for the
 15155                                  ;	    drive in BX.  0200h is the bit for shared.	1000h is the bit for
 15156                                  ;	    network. 8000h is the bit for local use.
 15157                                  ;	 A  Return 8000h if the handle in BX is for the network or not.
 15158                                  ;	 B  Change the retry delay and the retry count for the system. BX is
 15159                                  ;	    the count and CX is the delay.
 15160                                  ;
 15161                                  ;   Error returns:
 15162                                  ;	    AX = error_invalid_handle
 15163                                  ;	       = error_invalid_function
 15164                                  ;	       = error_invalid_data
 15165                                  ;
 15166                                  ;-------------------------------------------------------------------------------
 15167                                  ;
 15168                                  ;   This is the documentation copied from DOS 4.0 it is much better
 15169                                  ;   than the above
 15170                                  ;
 15171                                  ;	There are several basic forms of IOCTL calls:
 15172                                  ;
 15173                                  ;
 15174                                  ;	** Get/Set device information:	**
 15175                                  ;
 15176                                  ;	ENTRY	(AL) = function code
 15177                                  ;		  0 - Get device information
 15178                                  ;		  1 - Set device information
 15179                                  ;		(BX) = file handle
 15180                                  ;		(DX) = info for "Set Device Information"
 15181                                  ;	EXIT	'C' set if error
 15182                                  ;		  (AX) = error code
 15183                                  ;		'C' clear if OK
 15184                                  ;		  (DX) = info for "Get Device Information"
 15185                                  ;	USES	ALL
 15186                                  ;
 15187                                  ;
 15188                                  ;	**  Read/Write Control Data From/To Handle  **
 15189                                  ;
 15190                                  ;	ENTRY	(AL) = function code
 15191                                  ;		  2 - Read device control info
 15192                                  ;		  3 - Write device control info
 15193                                  ;		(BX) = file handle
 15194                                  ;		(CX) = transfer count
 15195                                  ;		(DS:DX) = address for data
 15196                                  ;	EXIT	'C' set if error
 15197                                  ;		  (AX) = error code
 15198                                  ;		'C' clear if OK
 15199                                  ;		  (AX) = count of bytes transfered
 15200                                  ;	USES	ALL
 15201                                  ;
 15202                                  ;
 15203                                  ;	**  Read/Write Control Data From/To Block Device  **
 15204                                  ;
 15205                                  ;	ENTRY	(AL) = function code
 15206                                  ;		  4 - Read device control info
 15207                                  ;		  5 - Write device control info
 15208                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 15209                                  ;		(CX) = transfer count
 15210                                  ;		(DS:DX) = address for data
 15211                                  ;	EXIT	'C' set if error
 15212                                  ;		  (AX) = error code
 15213                                  ;		'C' clear if OK
 15214                                  ;		  (AX) = count of bytes transfered
 15215                                  ;	USES	ALL
 15216                                  ;
 15217                                  ;
 15218                                  ;	**  Get Input/Output Status  **
 15219                                  ;
 15220                                  ;	ENTRY	(AL) = function code
 15221                                  ;		  6 - Get Input status
 15222                                  ;		  7 - Get Output Status
 15223                                  ;		(BX) = file handle
 15224                                  ;	EXIT	'C' set if error
 15225                                  ;		  (AX) = error code
 15226                                  ;		'C' clear if OK
 15227                                  ;		  (AL) = 00 if not ready
 15228                                  ;		  (AL) = FF if ready
 15229                                  ;	USES	ALL
 15230                                  ;
 15231                                  ;
 15232                                  ;	**  Get Drive Information  **
 15233                                  ;
 15234                                  ;	ENTRY	(AL) = function code
 15235                                  ;		  8 - Check for removable media
 15236                                  ;		  9 - Get device attributes
 15237                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 15238                                  ;	EXIT	'C' set if error
 15239                                  ;		  (AX) = error code
 15240                                  ;		'C' clear if OK
 15241                                  ;		  (AX) = 0/1 media is removable/fixed (func. 8)
 15242                                  ;		  (DX) = device attribute word (func. 9)
 15243                                  ;	USES	ALL
 15244                                  ;
 15245                                  ;
 15246                                  ;	**  Get Redirected bit	**
 15247                                  ;
 15248                                  ;	ENTRY	(AL) = function code
 15249                                  ;		  0Ah - Network stuff
 15250                                  ;		(BX) = file handle
 15251                                  ;	EXIT	'C' set if error
 15252                                  ;		  (AX) = error code
 15253                                  ;		'C' clear if OK
 15254                                  ;		  (DX) = SFT flags word, 8000h set if network file
 15255                                  ;	USES	ALL
 15256                                  ;
 15257                                  ;
 15258                                  ;	**  Change sharer retry parameters  **
 15259                                  ;
 15260                                  ;	ENTRY	(AL) = function code
 15261                                  ;		  0Bh - Set retry parameters
 15262                                  ;		(CX) = retry loop count
 15263                                  ;		(DX) = number of retries
 15264                                  ;	EXIT	'C' set if error
 15265                                  ;		  (AX) = error code
 15266                                  ;		'C' clear if OK
 15267                                  ;	USES	ALL
 15268                                  ;
 15269                                  ;
 15270                                  ;   =================================================================
 15271                                  ;
 15272                                  ;	**  New Standard Control  **
 15273                                  ;
 15274                                  ;	ALL NEW IOCTL FACILITIES SHOULD USE THIS FORM.	THE OTHER
 15275                                  ;	FORMS ARE OBSOLETE.
 15276                                  ;
 15277                                  ;   =================================================================
 15278                                  ;
 15279                                  ;	ENTRY	(AL) = function code
 15280                                  ;		  0Ch - Control Function subcode
 15281                                  ;		(BX) = File Handle
 15282                                  ;		(CH) = Category Indicator
 15283                                  ;		(CL) = Function within category
 15284                                  ;		(DS:DX) = address for data, if any
 15285                                  ;		(SI) = Passed to device as argument, use depends upon function
 15286                                  ;		(DI) = Passed to device as argument, use depends upon function
 15287                                  ;	EXIT	'C' set if error
 15288                                  ;		  (AX) = error code
 15289                                  ;		'C' clear if OK
 15290                                  ;		  (SI) = Return value, meaning is function dependent
 15291                                  ;		  (DI) = Return value, meaning is function dependent
 15292                                  ;		  (DS:DX) = Return address, use is function dependent
 15293                                  ;	USES	ALL
 15294                                  ;
 15295                                  ;    ============== Generic IOCTL Definitions for DOS 3.2 ============
 15296                                  ;     (See inc\ioctl.inc for more info)
 15297                                  ;
 15298                                  ;	ENTRY	(AL) = function code
 15299                                  ;		  0Dh - Control Function subcode
 15300                                  ;		(BL) = Drive Number (0 = Default, 1= 'A')
 15301                                  ;		(CH) = Category Indicator
 15302                                  ;		(CL) = Function within category
 15303                                  ;		(DS:DX) = address for data, if any
 15304                                  ;		(SI) = Passed to device as argument, use depends upon function
 15305                                  ;		(DI) = Passed to device as argument, use depends upon function
 15306                                  ;
 15307                                  ;	EXIT	'C' set if error
 15308                                  ;		  (AX) = error code
 15309                                  ;		'C' clear if OK
 15310                                  ;		  (DS:DX) = Return address, use is function dependent
 15311                                  ;	USES	ALL
 15312                                  ;
 15313                                  ;---------------------------------------------------------------------------
 15314                                  	
 15315                                  	; 17/05/2019 - Retro DOS v4.0
 15316                                  	; DOSCODE:611Eh (MSDOS 6.21, MSDOS.SYS)
 15317                                  
 15318                                  	; 11/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15319                                  	; DOSCODE:610Ah (MSDOS 5.0, MSDOS.SYS)
 15320                                  
 15321                                  IOCTLJMPTABLE:	;label	word
 15322                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15323 0000225C [9822]                  	dw	ioctl_getset_data	; 0
 15324 0000225E [9822]                  	dw	ioctl_getset_data   	; 1
 15325 00002260 [E822]                  	dw	ioctl_control_string	; 2
 15326 00002262 [E822]                  	dw	ioctl_control_string	; 3
 15327 00002264 [3C24]                  	dw	ioctl_get_dev		; 4
 15328 00002266 [3C24]                  	dw	ioctl_get_dev		; 5
 15329 00002268 [0223]                  	dw	ioctl_status		; 6
 15330 0000226A [0223]                  	dw	ioctl_status		; 7
 15331 0000226C [A323]                  	dw	ioctl_rem_media		; 8
 15332 0000226E [E123]                  	dw	ioctl_drive_attr	; 9
 15333 00002270 [2E24]                  	dw	ioctl_handle_redir	; A
 15334 00002272 [1E23]                  	dw	Set_Retry_Parameters	; B
 15335 00002274 [2C23]                  	dw	GENERICIOCTLHANDLE	; C
 15336 00002276 [4323]                  	dw	GENERICIOCTL		; D
 15337                                  	; MSDOS 6.0 (& MSDOS 3.3)
 15338 00002278 [ED24]                  	dw	ioctl_drive_owner	; E
 15339 0000227A [ED24]                  	dw	ioctl_drive_owner	; F
 15340                                  	; MSDOS 6.0
 15341 0000227C [2C23]                  	dw	query_handle_support	; 10h
 15342 0000227E [4323]                  	dw	query_device_support	; 11h
 15343                                  
 15344                                  	; 11/11/2022
 15345                                  _$IOCTL:
 15346 00002280 8CDE                    	MOV	SI,DS			; Stash DS for calls 2,3,4 and 5
 15347 00002282 16                      	push	ss
 15348 00002283 1F                      	pop	ds			;hkn; SS is DOSDATA
 15349                                  
 15350                                  	; MSDOS 3.3
 15351                                  	;cmp	al,0Fh 
 15352                                  	; MSDOS 6.0
 15353 00002284 3C11                    	cmp	al,11h			; al must be between 0 & 11h
 15354 00002286 770D                    	ja	short ioctl_bad_funj2	; if not bad function #
 15355                                  
 15356                                  	; 14/01/2024
 15357                                  	; 28/05/2019
 15358                                  	;push	AX	; 14/01/2024	; Need to save AL for generic IOCTL
 15359 00002288 89C7                    	mov	di,ax			; di NOT a PARM
 15360 0000228A 81E7FF00                	and	di,0FFh			; di = al
 15361 0000228E D1E7                    	shl	di,1			; di = index into jmp table
 15362                                  	;pop	AX			; Restore AL for generic IOCTL
 15363                                  
 15364 00002290 2EFFA5[5C22]            	jmp	word [CS:DI+IOCTLJMPTABLE]
 15365                                  
 15366                                  ioctl_bad_funj2:
 15367 00002295 E90301                  	JMP	ioctl_bad_fun  ; 10/08/2018
 15368                                  
 15369                                  ;--------------------------------------------------------------------------
 15370                                  ;
 15371                                  ; IOCTL: AL = 0,1
 15372                                  ;
 15373                                  ; ENTRY: DS = DOSDATA
 15374                                  ;
 15375                                  ;--------------------------------------------------------------------------
 15376                                  
 15377                                  ioctl_getset_data:
 15378                                  	; MSDOS 6.0
 15379 00002298 E8DF43                  	call	SFFromHandle		; ES:DI -> SFT
 15380 0000229B 7305                    	JNC	short ioctl_check_permissions ; have valid handle
 15381                                  ioctl_bad_handle:
 15382                                  	;mov	al,6
 15383 0000229D B006                    	mov	al,error_invalid_handle
 15384                                  ioctl_error:
 15385 0000229F E99EE3                  	jmp	SYS_RET_ERR
 15386                                  
 15387                                  ioctl_check_permissions:
 15388 000022A2 3C00                    	CMP	AL,0
 15389                                  	;mov	al,[es:di+5]
 15390 000022A4 268A4505                	MOV	AL,[ES:DI+SF_ENTRY.sf_flags]; Get low byte of flags
 15391 000022A8 741B                    	JZ	short ioctl_read	; read the byte
 15392                                  
 15393 000022AA 08F6                    	or	dh,dh
 15394 000022AC 7404                    	JZ	short ioctl_check_device ; can I set with this data?
 15395                                  	;mov	al,0Dh
 15396 000022AE B00D                    	mov	al,error_invalid_data	; no DH <> 0
 15397                                  	;jmp	SYS_RET_ERR
 15398 000022B0 EBED                    	jmp	short ioctl_error
 15399                                  
 15400                                  ioctl_check_device:
 15401 000022B2 A880                    	test	AL,devid_device  ; 80h	; can I set this handle?
 15402 000022B4 74DF                    	jz	short ioctl_bad_funj2
 15403 000022B6 80CA80                  	OR	DL,devid_device 	; Make sure user doesn't turn off the
 15404                                  					;   device bit!! He can muck with the
 15405                                  					;   others at will.
 15406 000022B9 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 15407 000022BE 26885505                	MOV	BYTE [ES:DI+SF_ENTRY.sf_flags],DL  ;AC000;MS.; Set flags
 15408                                  ioctl_ok:
 15409 000022C2 E972E3                  	jmp	SYS_RET_OK
 15410                                  
 15411                                  ioctl_read:
 15412 000022C5 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk  ; 2
 15413 000022CA 30E4                    	XOR	AH,AH
 15414 000022CC A880                    	test	AL,devid_device 	; Should I set high byte
 15415 000022CE 740D                    	JZ	short ioctl_no_high	; no
 15416 000022D0 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 15417                                  	;les	di,[es:di+7]
 15418 000022D5 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 15419                                  	;mov	ah,[es:di+5]
 15420 000022D9 268A6505                	MOV	AH,[ES:DI+SYSDEV.ATT+1] ; Get high byte
 15421                                  ioctl_no_high:
 15422 000022DD 89C2                    	MOV	DX,AX
 15423                                  ioctl_set_dx:	; 16/12/2022
 15424 000022DF E89FE1                  	call	Get_User_Stack
 15425                                  	;mov	[si+6],dx
 15426 000022E2 895406                  	MOV	[SI+user_env.user_DX],DX
 15427                                  	;;jmp	SYS_RET_OK
 15428                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15429                                  ioctl_ok_j:
 15430                                  	; 16/12/2022
 15431 000022E5 E952E3                  	jmp	SYS_RET_OK_clc	 ; (after 'Get_User_Stack') 
 15432                                  	;jmp	short ioctl_ok
 15433                                  	; 26/07/2019
 15434                                  	;jmp	SYS_RET_OK_clc
 15435                                  
 15436                                  ;--------------------------------------------------------------------------
 15437                                  ;
 15438                                  ; IOCTL: AL = 2,3
 15439                                  ;
 15440                                  ; ENTRY: DS = DOSDATA
 15441                                  ;	 SI = user's DS
 15442                                  ;
 15443                                  ;--------------------------------------------------------------------------
 15444                                  
 15445                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15446                                  ioctl_control_string:
 15447 000022E8 E88F43                  	call	SFFromHandle		; ES:DI -> SFT
 15448 000022EB 72B0                    	JC	short ioctl_bad_handle	; invalid handle
 15449                                  	; 07/12/2022
 15450                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 15451                                  	;jz	short ioctl_bad_funj2			; No it is a file
 15452                                  	; MSDOS 5.0 & MSDOS 6.0
 15453 000022ED 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 15454 000022F2 74A1                    	jz	short ioctl_bad_funj2			; No it is a file
 15455 000022F4 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 15456 000022F9 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 15457 000022FD 30DB                    	XOR	BL,BL			; Unit number of char dev = 0
 15458 000022FF E94201                  	JMP	ioctl_do_string
 15459                                  
 15460                                  ;--------------------------------------------------------------------------
 15461                                  ;
 15462                                  ; IOCTL: AL = 6,7
 15463                                  ;
 15464                                  ; ENTRY: DS = DOSDATA
 15465                                  ;
 15466                                  ;--------------------------------------------------------------------------
 15467                                  
 15468                                  ioctl_status:
 15469 00002302 B401                    	MOV	AH,1
 15470 00002304 2C06                    	SUB	AL,6			; 6=0,7=1
 15471 00002306 7402                    	JZ	short ioctl_get_status
 15472 00002308 B403                    	MOV	AH,3
 15473                                  ioctl_get_status:
 15474 0000230A 50                      	PUSH	AX
 15475 0000230B E85013                  	call	GET_IO_SFT
 15476 0000230E 58                      	POP	AX
 15477                                  	;JNC	short DO_IOFUNC
 15478                                  	;JMP	short ioctl_bad_handle	; invalid SFT
 15479                                  	; 16/12/2022
 15480 0000230F 728C                    	jc	short ioctl_bad_handle
 15481                                  DO_IOFUNC:
 15482 00002311 E88F21                  	call	IOFUNC
 15483 00002314 88C4                    	MOV	AH,AL
 15484 00002316 B0FF                    	MOV	AL,0FFH
 15485 00002318 7502                    	JNZ	short ioctl_status_ret
 15486 0000231A FEC0                    	INC	AL
 15487                                  ioctl_status_ret:
 15488                                  	;jmp	SYS_RET_OK
 15489                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15490                                  	;jmp	short ioctl_ok_j
 15491                                  	; 16/12/2022
 15492 0000231C EBA4                    	jmp	short ioctl_ok
 15493                                  
 15494                                  ;--------------------------------------------------------------------------
 15495                                  ;
 15496                                  ; IOCTL: AL = B
 15497                                  ;
 15498                                  ; ENTRY: DS = DOSDATA
 15499                                  ;
 15500                                  ;--------------------------------------------------------------------------
 15501                                  
 15502                                  Set_Retry_Parameters:
 15503                                  	; 09/09/2018
 15504 0000231E 890E[1C00]              	MOV	[RetryLoop],CX		; 0 retry loop count allowed
 15505 00002322 09D2                    	OR	DX,DX			; zero retries not allowed
 15506 00002324 7475                    	JZ	short ioctl_bad_fun
 15507 00002326 8916[1A00]              	MOV	[RetryCount],DX		; Set new retry count
 15508                                  doneok:
 15509                                  	;jmp	SYS_RET_OK		; Done
 15510                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15511                                  	;jmp	short ioctl_status_ret
 15512                                  	; 16/12/2022
 15513 0000232A EB96                    	jmp	short ioctl_ok	 ; jmp SYS_RET_OK
 15514                                  
 15515                                  ;--------------------------------------------------------------------------
 15516                                  ;
 15517                                  ; Generic IOCTL entry point. AL = C, D, 10h, 11h
 15518                                  ;
 15519                                  ;	here we invoke the Generic IOCTL using the IOCTL_Req structure.
 15520                                  ;	SI:DX -> Users Device Parameter Table
 15521                                  ;	IOCALL -> IOCTL_Req structure
 15522                                  ;
 15523                                  ; 	If on entry AL >= IOCTL_QUERY_HANDLE the function is a
 15524                                  ;	QueryIOCtlSupport call ELSE it's a standard generic IOCtl
 15525                                  ;	call.
 15526                                  ;
 15527                                  ; BUGBUG: Don't push anything on the stack between GENERIOCTL: and 
 15528                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15529                                  ;         return address off the stack if the drive is invalid.
 15530                                  ;
 15531                                  ;--------------------------------------------------------------------------
 15532                                  
 15533                                  query_handle_support:	; Entry point for handles
 15534                                  GENERICIOCTLHANDLE:
 15535 0000232C E84B43                  	call	SFFromHandle		; Get SFT for device.
 15536 0000232F 726F                    	jc	short ioctl_bad_handlej
 15537                                  
 15538                                  	;test	word [es:di+5],8000h
 15539                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet	; M031;
 15540                                  	;test	byte [es:di+6],80h
 15541 00002331 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 15542 00002336 7563                    	jnz	short ioctl_bad_fun	; Cannot do this over net.
 15543                                  
 15544 00002338 C606[2303]04            	mov	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 15545                                  	;les	di,[es:di+7]
 15546 0000233D 26C47D07                	les	di,[es:di+SF_ENTRY.sf_devptr]	; Get pointer to device.
 15547 00002341 EB0F                    	jmp	short Do_GenIOCTL
 15548                                  
 15549                                  query_device_support:	; Entry point for devices:
 15550                                  GENERICIOCTL:
 15551 00002343 C606[2303]02            	mov	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 15552 00002348 80FD08                  	cmp	ch,IOC_DC ; 8		; Only disk devices are allowed to use
 15553 0000234B 754E                    	jne	short ioctl_bad_fun	; no handles with Generic IOCTL.
 15554                                  
 15555 0000234D E88101                  	CALL	Check_If_Net		; ES:DI := Get_hdr_block of device in BL
 15556 00002350 7549                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 15557                                  
 15558                                  Do_GenIOCTL:
 15559                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320 
 15560                                  					; Can device handle Generic IOCTL funcs
 15561                                  	; 09/09/2018
 15562                                  	;test	byte [es:di+4],40h
 15563 00002352 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 15564 00002357 7442                    	jz	short ioctl_bad_fun
 15565                                  
 15566                                  	; 17/05/2019 - Retro DOS v4.0
 15567                                  
 15568                                  	; MSDOS 6.0
 15569                                  	;mov	byte [IOCALL_REQFUNC],19 ; 13h
 15570 00002359 C606[7E03]13            	mov	byte [IOCALL_REQFUNC],GENIOCTL ; Assume real Request
 15571                                  	;cmp	al,10h
 15572 0000235E 3C10                    	cmp	AL,IOCTL_QUERY_HANDLE	; See if this is just a query
 15573 00002360 7C0C                    	jl	short SetIOCtlBlock
 15574                                  	
 15575                                  	;TEST	word [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 15576                                  	;test	byte [es:di+4],80h 
 15577 00002362 26F6450480              	TEST	byte [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 15578 00002367 7432                    	jz	short ioctl_bad_fun	; No support for query 
 15579                                  	;
 15580                                  	;mov	byte [IOCALL_REQFUNC],19h	
 15581 00002369 C606[7E03]19            	mov	byte [IOCALL_REQFUNC],IOCTL_QUERY ; Just a query (5.00)
 15582                                  
 15583                                  SetIOCtlBlock:
 15584 0000236E 06                      	PUSH	ES			; DEVIOCALL2 expects Device header block
 15585 0000236F 57                      	PUSH	DI			; in DS:SI
 15586                                  					; Setup Generic IOCTL Request Block
 15587                                  	;mov	byte [IOCALL_REQLEN],23
 15588 00002370 C606[7C03]17            	mov	byte [IOCALL_REQLEN],IOCTL_REQ.size
 15589                                  	; 07/09/2018 (MSDOS 3.3)
 15590                                  	;;mov	byte [IOCALL_REQFUNC],19
 15591                                  	;mov	byte [IOCALL_REQFUNC],GENIOCTL ; 07/09/2018
 15592                                  	;
 15593 00002375 881E[7D03]              	MOV	[IOCALL_REQUNIT],BL
 15594 00002379 882E[8903]              	MOV	[IOCALL+IOCTL_REQ.MAJORFUNCTION],CH
 15595 0000237D 880E[8A03]              	MOV	[IOCALL+IOCTL_REQ.MINORFUNCTION],CL
 15596 00002381 8936[8B03]              	MOV	[IOCALL+IOCTL_REQ.REG_SI],SI
 15597 00002385 893E[8D03]              	MOV	[IOCALL+IOCTL_REQ.REG_DI],DI
 15598 00002389 8916[8F03]              	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET],DX
 15599 0000238D 8936[9103]              	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2],SI
 15600                                  
 15601                                  ;hkn; IOCALL is in DOSDATA
 15602 00002391 BB[7C03]                	MOV	BX,IOCALL
 15603                                  
 15604 00002394 16                      	PUSH	SS
 15605 00002395 07                      	POP	ES
 15606                                  					; DS:SI -> Device header.
 15607 00002396 5E                      	POP	SI
 15608 00002397 1F                      	POP	DS
 15609                                  	; 10/08/2018
 15610 00002398 E9E200                  	jmp	ioctl_do_IO		; Perform Call to device driver
 15611                                  
 15612                                  ioctl_bad_fun:
 15613 0000239B B001                    	mov	al, error_invalid_function  ; 1
 15614 0000239D E9A0E2                  	jmp	SYS_RET_ERR	
 15615                                  
 15616                                  ioctl_bad_handlej:
 15617 000023A0 E9FAFE                  	jmp	ioctl_bad_handle
 15618                                  
 15619                                  ;---------------------------------------------------------------------------
 15620                                  ;
 15621                                  ; IOCTL: AL = 8
 15622                                  ;
 15623                                  ; ENTRY: DS = DOSDATA
 15624                                  ;
 15625                                  ; BUGBUG: Don't push anything on the stack between ioctl_rem_media: and 
 15626                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15627                                  ;         return address off the stack if the drive is invalid.
 15628                                  ;
 15629                                  ;-------------------------------------------------------------------------
 15630                                  
 15631                                  ioctl_rem_media:
 15632                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15633 000023A3 E82B01                  	CALL	Check_If_Net
 15634 000023A6 75F3                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 15635                                  					;   certainly don't know how to do this
 15636                                  					;   call.
 15637                                  	;test	word [es:di+4],800h
 15638                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL ; See if device can
 15639                                  	;test	byte [es:di+5],8
 15640 000023A8 26F6450508              	TEST	byte [es:di+SYSDEV.ATT+1],(DEVOPCL>>8)
 15641 000023AD 74EC                    	JZ	short ioctl_bad_fun		; NO
 15642                                  
 15643                                  ;hkn; SS override for IOCALL
 15644 000023AF 36C606[7E03]0F          	MOV	byte [SS:IOCALL_REQFUNC],DEVRMD ; 15
 15645 000023B5 B00D                    	MOV	AL,REMHL  ; 13
 15646 000023B7 88DC                    	MOV	AH,BL			; Unit number
 15647 000023B9 36A3[7C03]              	MOV	[SS:IOCALL_REQLEN],AX
 15648 000023BD 31C0                    	XOR	AX,AX
 15649 000023BF 36A3[7F03]              	MOV	[SS:IOCALL_REQSTAT],AX
 15650 000023C3 06                      	PUSH	ES
 15651 000023C4 1F                      	POP	DS
 15652 000023C5 89FE                    	MOV	SI,DI			; DS:SI -> driver
 15653 000023C7 16                      	PUSH	SS
 15654 000023C8 07                      	POP	ES
 15655                                  
 15656                                  ;hkn; IOCALL is in DOSDATA (msconst.asm)
 15657 000023C9 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 15658 000023CC 1E                      	push	ds
 15659 000023CD 56                      	push	si
 15660 000023CE E8A722                  	call	DEVIOCALL2
 15661 000023D1 5E                      	pop	si
 15662 000023D2 1F                      	pop	ds
 15663                                  
 15664                                  ;hkn; SS override
 15665 000023D3 36A1[7F03]              	MOV	AX,[SS:IOCALL_REQSTAT]	; Get Status word
 15666 000023D7 250002                  	AND	AX,STBUI ; 200h		; Mask to busy bit
 15667 000023DA B109                    	MOV	CL,9
 15668 000023DC D3E8                    	SHR	AX,CL			; Busy bit to bit 0
 15669                                  ioctl_da_ok_j:	; 11/11/2022
 15670 000023DE E956E2                  	jmp	SYS_RET_OK
 15671                                  
 15672                                  ;-------------------------------------------------------------------------
 15673                                  ;
 15674                                  ; IOCTL: AL = 9
 15675                                  ;
 15676                                  ; ENTRY: DS = DOSDATA
 15677                                  ;
 15678                                  ;-------------------------------------------------------------------------
 15679                                  
 15680                                  ioctl_drive_attr:
 15681                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15682 000023E1 88D8                    	mov	al,bl
 15683 000023E3 E8B846                  	call	GETTHISDRV
 15684 000023E6 7241                    	jc	short ioctl_drv_err
 15685 000023E8 E8B800                  	call	Get_Driver_BL
 15686                                  	; MSDOS 6.0
 15687 000023EB 723C                    	JC	short ioctl_drv_err	; drive not valid
 15688                                  
 15689                                  	;mov	dx,[es:di+4]
 15690 000023ED 268B5504                	mov	dx,[es:di+SYSDEV.ATT]	
 15691                                  					; get device attribute word
 15692 000023F1 88C3                    	MOV	BL,AL			; Phys letter to BL (A=0)
 15693                                  
 15694                                  ;hkn; SS override
 15695 000023F3 36C43E[A205]            	LES	DI,[SS:THISCDS]
 15696                                  	;test	word [es:di+43h],8000h
 15697                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 15698                                  	;test	byte [es:di+44h],80h
 15699 000023F8 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 15700 000023FD 7403                    	JZ	short IOCTLShare
 15701                                  
 15702                                  	;or	dx,1000h ; (MSDOS 3.3)
 15703                                  
 15704                                  ;	Net devices don't return a device attribute word.
 15705                                  ;	Bit 12 = 1, meaning net device, all others = 0.
 15706                                  
 15707 000023FF BA0010                  	MOV	DX,1000h ; MSDOS 6.0
 15708                                  IOCTLShare:
 15709 00002402 16                      	push	ss
 15710 00002403 1F                      	pop	ds
 15711 00002404 BE[BE03]                	MOV	SI,OPENBUF
 15712 00002407 80C341                  	ADD	BL,"A"	; 41h
 15713 0000240A 881C                    	MOV	[SI],BL
 15714 0000240C C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
 15715 00002411 B80003                  	MOV	AX,0300h
 15716 00002414 F8                      	CLC
 15717                                  	;INT	int_IBM
 15718 00002415 CD2A                    	int     2Ah	; Microsoft Networks - CHECK DIRECT I/O
 15719                                  			; DS:SI -> ASCIZ disk device name 
 15720                                  			; (may be full path or only drive
 15721                                  			; specifier--must include the colon)
 15722                                  			; Return: CF clear if absolute disk access allowed
 15723 00002417 7303                    	JNC	short IOCTLLocal	; Not shared
 15724                                  	;OR	DX,0200H		; Shared, bit 9
 15725                                  	; 17/12/2022
 15726 00002419 80CE02                  	or	dh,02h
 15727                                  IOCTLLocal:
 15728                                  	;test	word [es:di+43h],1000h
 15729                                  	;TEST	word [ES:DI+curdir.flags],curdir_local
 15730                                  	;test	byte [es:di+44h],10h
 15731 0000241C 26F6454410              	TEST	byte [ES:DI+curdir.flags+1],(curdir_local>>8)
 15732                                  	;JZ	short ioctl_set_DX
 15733                                  	; 16/12/2022
 15734 00002421 7403                    	jz	short _ioctl_set_DX
 15735                                  	;OR	DX,8000h
 15736                                  	; 17/12/2022
 15737 00002423 80CE80                  	or	dh,80h
 15738                                  ;ioctl_set_DX:
 15739                                  _ioctl_set_DX:
 15740                                  	; 16/12/2022
 15741 00002426 E9B6FE                  	jmp	ioctl_set_dx
 15742                                  ; 16/12/2022
 15743                                  %if 0	
 15744                                  	call	Get_User_Stack
 15745                                  	MOV	[SI+user_env.user_DX],DX
 15746                                  	;;jmp	SYS_RET_OK
 15747                                  	;; 25/06/2019
 15748                                  	;jmp	SYS_RET_OK_clc
 15749                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15750                                  ioctl_gd_ok_j:
 15751                                  	jmp	short ioctl_da_ok_j
 15752                                  %endif
 15753                                  
 15754                                  ioctl_drv_err:
 15755 00002429 B00F                    	mov	al,error_invalid_drive ; 0Fh
 15756                                  ioctl_gd_err_j:	; 11/11/2022
 15757 0000242B E912E2                  	jmp	SYS_RET_ERR
 15758                                  
 15759                                  ;--------------------------------------------------------------------------
 15760                                  ;
 15761                                  ; IOCTL: AL = A
 15762                                  ;
 15763                                  ; ENTRY: DS = DOSDATA
 15764                                  ;
 15765                                  ;--------------------------------------------------------------------------
 15766                                  
 15767                                  ioctl_handle_redir:
 15768 0000242E E84942                  	call	SFFromHandle		; ES:DI -> SFT
 15769 00002431 7303                    	JNC	short ioctl_got_sft	; have valid handle
 15770 00002433 E967FE                  	jmp	ioctl_bad_handle ; 10/08/2018
 15771                                  
 15772                                  ioctl_got_sft:
 15773                                  	;mov	dx,[es:di+5]
 15774 00002436 268B5505                	MOV	DX,[ES:DI+SF_ENTRY.sf_flags] ; Get flags
 15775                                  	;JMP	short ioctl_set_DX	; pass dx to user and return
 15776                                  	; 16/12/2022
 15777 0000243A EBEA                    	jmp	short _ioctl_set_DX
 15778                                  
 15779                                  	; 16/12/2022
 15780                                  ;ioctl_bad_funj:
 15781                                  	;JMP	ioctl_bad_fun
 15782                                  
 15783                                  ;--------------------------------------------------------------------------
 15784                                  ;
 15785                                  ; IOCTL: AL= 4,5
 15786                                  ;
 15787                                  ; ENTRY: DS = DOSDATA
 15788                                  ;	 SI = user's DS
 15789                                  ;
 15790                                  ;
 15791                                  ; BUGBUG: Don't push anything on the stack between ioctl_get_dev: and 
 15792                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15793                                  ;         return address off the stack if the drive is invalid.
 15794                                  ;
 15795                                  ;-------------------------------------------------------------------------
 15796                                  
 15797                                  ioctl_get_dev:
 15798 0000243C E89200                  	CALL	Check_If_Net
 15799                                  	;JNZ	short ioctl_bad_funj	; There are no "net devices", and they
 15800                                  					; certainly don't know how to do this
 15801                                  					; call.
 15802                                  	; 16/12/2022
 15803 0000243F 7403                    	jz	short ioctl_do_string
 15804                                  ioctl_bad_funj:
 15805 00002441 E957FF                  	JMP	ioctl_bad_fun
 15806                                  
 15807                                  ioctl_do_string:
 15808                                  	;test	word [es:di+4],4000h
 15809                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVIOCTL; See if device accepts control
 15810                                  	;test	byte [es:di+5],40h
 15811 00002444 26F6450540              	TEST	byte [ES:DI+SYSDEV.ATT+1],(DEVIOCTL>>8)
 15812 00002449 74F6                    	JZ	short ioctl_bad_funj		; NO
 15813                                  					; assume IOCTL read
 15814 0000244B C606[7E03]03            	MOV	byte [IOCALL_REQFUNC],DEVRDIOCTL  ; 3
 15815                                  
 15816 00002450 A801                    	TEST	AL,1			; is it func. 4/5 or 2/3
 15817 00002452 7405                    	JZ	short ioctl_control_call ; it is read. goto ioctl_control_call
 15818                                  
 15819                                  					; it is an IOCTL write
 15820 00002454 C606[7E03]0C            	MOV	byte [IOCALL_REQFUNC],DEVWRIOCTL ; 12
 15821                                  
 15822                                  ioctl_control_call:
 15823 00002459 B016                    	MOV	AL,DRDWRHL ; 22
 15824                                  ioctl_setup_pkt:
 15825 0000245B 88DC                    	MOV	AH,BL			; Unit number
 15826 0000245D A3[7C03]                	MOV	[IOCALL_REQLEN],AX
 15827 00002460 31C0                    	XOR	AX,AX
 15828 00002462 A3[7F03]                	MOV	[IOCALL_REQSTAT],AX
 15829 00002465 A2[8903]                	MOV	[IOMED],AL
 15830 00002468 890E[8E03]              	MOV	[IOSCNT],CX
 15831 0000246C 8916[8A03]              	MOV	[IOXAD],DX
 15832 00002470 8936[8C03]              	MOV	[IOXAD+2],SI
 15833 00002474 06                      	PUSH	ES
 15834 00002475 1F                      	POP	DS
 15835 00002476 89FE                    	MOV	SI,DI			; DS:SI -> driver
 15836 00002478 16                      	PUSH	SS
 15837 00002479 07                      	POP	ES
 15838                                  
 15839 0000247A BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 15840                                  ioctl_do_IO:
 15841 0000247D E8F821                  	call	DEVIOCALL2
 15842                                  
 15843                                  ;hkn; SS override for IOCALL
 15844                                  	;test	word [SS:IOCALL_REQSTAT],8000h
 15845                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 15846                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 15847 00002480 36F606[8003]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 15848 00002486 7507                    	JNZ	short ioctl_string_err
 15849                                  
 15850                                  ;hkn; SS override
 15851 00002488 36A1[8E03]              	MOV	AX,[SS:IOSCNT]		; Get actual bytes transferred
 15852                                  	; 16/12/2022
 15853 0000248C E9A8E1                  	jmp	SYS_RET_OK
 15854                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15855                                  	;jmp	short ioctl_gd_ok_j
 15856                                  
 15857                                  ioctl_string_err:
 15858 0000248F 368B3E[7F03]            	MOV	DI,[SS:IOCALL_REQSTAT]	;Get Error
 15859                                  device_err:
 15860 00002494 81E7FF00                	AND	DI,STECODE ; 00FFh	; mask out irrelevant bits
 15861 00002498 89F8                    	MOV	AX,DI
 15862 0000249A E86A30                  	call	SET_I24_EXTENDED_ERROR
 15863                                  
 15864                                  ;hkn; use SS override
 15865                                  ;hkn;	mov	ax,[CS:EXTERR]
 15866 0000249D 36A1[2403]              	mov	ax,[SS:EXTERR]
 15867                                  	;jmp	SYS_RET_ERR
 15868                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15869 000024A1 EB88                    	jmp	short ioctl_gd_err_j
 15870                                  
 15871                                  ; 17/05/2019 - Retro DOS v4.0
 15872                                  
 15873                                  ;--------------------------------------------------------------------------
 15874                                  ; Proc name : Get_Driver_BL
 15875                                  ;
 15876                                  ;	DS is DOSDATA
 15877                                  ;	BL is drive number (0=default)
 15878                                  ;	Returns pointer to device in ES:DI, unit number in BL if carry clear
 15879                                  ;	No regs modified
 15880                                  ;
 15881                                  ;---------------------------------------------------------------------------
 15882                                  
 15883                                  Get_Driver_BL:
 15884 000024A3 50                      	PUSH	AX
 15885 000024A4 88D8                    	MOV	AL,BL			; Drive
 15886 000024A6 E8F545                  	call	GETTHISDRV
 15887 000024A9 7224                    	jc	short ioctl_bad_drv
 15888 000024AB 30DB                    	XOR	BL,BL			; Unit zero on Net device
 15889 000024AD C606[2303]03            	MOV	byte [EXTERR_LOCUS],errLOC_Net ; 3
 15890 000024B2 C43E[A205]              	LES	DI,[THISCDS]
 15891                                  	;test	word [es:di+43h],8000h
 15892                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 15893                                  	;test	byte [es:di+44h],80h
 15894 000024B6 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 15895                                  	;les	di,[es:di+45h]
 15896 000024BB 26C47D45                	LES	DI,[ES:DI+curdir.devptr] ; ES:DI -> Dpb or net dev
 15897 000024BF 750D                    	JNZ	short got_dev_ptr	 ; Is net
 15898 000024C1 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 15899                                  	;mov	bl,[es:di+1]
 15900 000024C6 268A5D01                	MOV	BL,[ES:DI+DPB.UNIT]	; Unit number
 15901                                  	;les	di,[es:di+13h]
 15902 000024CA 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Driver addr
 15903                                  got_dev_ptr:
 15904 000024CE F8                      	CLC
 15905                                  ioctl_bad_drv:
 15906 000024CF 58                      	POP	AX
 15907 000024D0 C3                      	retn
 15908                                  
 15909                                  ;-------------------------------------------------------------------------
 15910                                  ; Proc Name : Check_If_Net:
 15911                                  ;
 15912                                  ;
 15913                                  ; Checks if the device is over the net or not. Returns result in ZERO flag.
 15914                                  ; If no device is found, the return address is popped off the stack, and a
 15915                                  ; jump is made to ioctl_drv_err.
 15916                                  ;
 15917                                  ; On Entry:
 15918                                  ; Registers same as those for Get_Driver_BL
 15919                                  ;
 15920                                  ; On Exit:
 15921                                  ; ZERO flag	- set if not a net device
 15922                                  ;		- reset if net device
 15923                                  ; ES:DI -> the device
 15924                                  ;
 15925                                  ;
 15926                                  ; BUGBUG: This function assumes the following stack setup on entry
 15927                                  ;
 15928                                  ;	  SP+2 -> Error return address
 15929                                  ;	  SP   -> Normal return address
 15930                                  ;
 15931                                  ;-------------------------------------------------------------------------
 15932                                  
 15933                                  Check_If_Net:
 15934                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15935 000024D1 E8CFFF                  	CALL	Get_Driver_BL
 15936 000024D4 720E                    	JC	short ioctl_drv_err_pop	; invalid drive letter
 15937 000024D6 06                      	PUSH	ES
 15938 000024D7 57                      	PUSH	DI
 15939 000024D8 C43E[A205]              	LES	DI,[THISCDS]
 15940                                  	;test	word [es:di+43h],8000h
 15941                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 15942                                  	;test	byte [es:di+44h],80h
 15943 000024DC 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 15944 000024E1 5F                      	POP	DI
 15945 000024E2 07                      	POP	ES
 15946 000024E3 C3                      	retn
 15947                                  
 15948                                  ioctl_drv_err_pop:
 15949 000024E4 58                      	pop	ax			; pop off return address
 15950 000024E5 E941FF                  	jmp	ioctl_drv_err
 15951                                  
 15952                                  ioctl_bad_funj3:
 15953 000024E8 E9B0FE                  	jmp	ioctl_bad_fun
 15954                                  
 15955                                  ioctl_string_errj:
 15956 000024EB EBA2                    	jmp	short ioctl_string_err  ; 25/05/2019
 15957                                  
 15958                                  ;--------------------------------------------------------------------------
 15959                                  ;
 15960                                  ; IOCTL: AL = E, F
 15961                                  ;
 15962                                  ; ENTRY: DS = DOSDATA
 15963                                  ;
 15964                                  ;
 15965                                  ; BUGBUG: Don't push anything on the stack between ioctl_drive_owner: and 
 15966                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15967                                  ;         return address off the stack if the drive is invalid.
 15968                                  ;
 15969                                  ;--------------------------------------------------------------------------
 15970                                  
 15971                                  ioctl_drive_owner:
 15972                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15973 000024ED E8E1FF                  	Call	Check_If_Net
 15974 000024F0 75F6                    	JNZ	short ioctl_bad_funj3 	; There are no "net devices", and they
 15975                                  					;   certainly don't know how to do this
 15976                                  					;   call.
 15977                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320	; See if device can handle this
 15978                                  	; 09/09/2018
 15979                                  	;test	byte [es:di+4],40h
 15980 000024F2 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 15981 000024F7 74EF                    	JZ	short ioctl_bad_funj3 	; NO
 15982                                  	;mov	byte [IOCALL_REQFUNC],23
 15983 000024F9 C606[7E03]17            	mov	byte [IOCALL_REQFUNC],DEVGETOWN	; default to get owner
 15984 000024FE 3C0E                    	cmp	al,0Eh			; Get Owner ?
 15985 00002500 7405                    	jz	short GetOwner
 15986                                  SetOwner:
 15987 00002502 C606[7E03]18            	MOV	byte [IOCALL_REQFUNC],DEVSETOWN ; 24
 15988                                  GetOwner:
 15989 00002507 B00D                    	MOV	AL,OWNHL ; 13
 15990 00002509 88DC                    	MOV	AH,BL			; Unit number
 15991 0000250B A3[7C03]                	MOV	[IOCALL_REQLEN],AX
 15992 0000250E 31C0                    	XOR	AX,AX
 15993 00002510 A3[7F03]                	MOV	[IOCALL_REQSTAT],AX
 15994 00002513 06                      	PUSH	ES
 15995 00002514 1F                      	POP	DS
 15996 00002515 89FE                    	MOV	SI,DI			; DS:SI -> driver
 15997 00002517 16                      	PUSH	SS
 15998 00002518 07                      	POP	ES
 15999 00002519 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 16000 0000251C 1E                      	push	ds
 16001 0000251D 56                      	push	si
 16002 0000251E E85721                  	call	DEVIOCALL2
 16003 00002521 5E                      	pop	si
 16004 00002522 1F                      	pop	ds
 16005                                  ;hkn; SS override
 16006                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 16007                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 16008 00002523 36F606[8003]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 16009 00002529 75C0                    	jnz	short ioctl_string_errj
 16010 0000252B 36A0[7D03]              	MOV	AL,[SS:IOCALL_REQUNIT]	; Get owner returned by device
 16011                                  					; owner returned is 1-based.
 16012 0000252F E905E1                  	jmp	SYS_RET_OK
 16013                                  
 16014                                  ;============================================================================
 16015                                  ; DELETE.ASM, MSDOS 6.0, 1991
 16016                                  ;============================================================================
 16017                                  ; 07/08/2018 - Retro DOS v3.0
 16018                                  ; 17/05/2019 - Retro DOS v4.0
 16019                                  
 16020                                  ;	TITLE	DOS_DELETE - Internal DELETE call for MS-DOS
 16021                                  ;	NAME	DOS_DELETE
 16022                                  
 16023                                  ;
 16024                                  ;	Microsoft Confidential
 16025                                  ;	Copyright (C) Microsoft Corporation 1991
 16026                                  ;	All Rights Reserved.
 16027                                  ;
 16028                                  
 16029                                  ;**	DELETE.ASM - Low level routine for deleting files
 16030                                  ;----------------------------------------------------------------------------
 16031                                  ;		DOS_DELETE
 16032                                  ;		REN_DEL_Check
 16033                                  ;		FastOpen_Delete	       ; DOS 3.3
 16034                                  ;		FastOpen_Update	       ; DOS 3.3
 16035                                  
 16036                                  ;   Revision history:
 16037                                  ;
 16038                                  ;   A000  version 4.00	Jan. 1988
 16039                                  ;   A001  Fastopen Rename fix	April 1989
 16040                                  
 16041                                  ;Installed = TRUE
 16042                                  
 16043                                  ;	i_need	NoSetDir,BYTE
 16044                                  ;	i_need	Creating,BYTE
 16045                                  ;	i_need	DELALL,BYTE
 16046                                  ;	i_need	THISDPB,DWORD
 16047                                  ;	i_need	THISSFT,DWORD
 16048                                  ;	i_need	THISCDS,DWORD
 16049                                  ;	i_need	CURBUF,DWORD
 16050                                  ;	i_need	ATTRIB,BYTE
 16051                                  ;	i_need	SATTRIB,BYTE
 16052                                  ;	i_need	WFP_START,WORD
 16053                                  ;	i_need	REN_WFP,WORD			 ;BN001
 16054                                  ;	i_need	NAME1,BYTE			 ;BN001
 16055                                  ;	i_need	FoundDel,BYTE
 16056                                  ;	i_need	AUXSTACK,BYTE
 16057                                  ;	i_need	VOLCHNG_FLAG,BYTE
 16058                                  ;	i_need	JShare,DWORD
 16059                                  ;	i_need	FastOpenTable,BYTE		  ; DOS 3.3
 16060                                  ;	i_need	FastTable,BYTE			  ; DOS 4.00
 16061                                  ;
 16062                                  ;	i_need	Del_ExtCluster,WORD		  ; DOS 4.00
 16063                                  ;
 16064                                  ;	i_need	SAVE_BX,WORD			  ; DOS 4.00
 16065                                  ;	i_need	DMAADD,DWORD
 16066                                  ;	i_need	RENAMEDMA,BYTE
 16067                                  
 16068                                  ;----------------------------------------------------------------------------
 16069                                  ;
 16070                                  ; Procedure Name : DOS_DELETE
 16071                                  ;
 16072                                  ; Inputs:
 16073                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 16074                                  ;		terminated)
 16075                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 16076                                  ;		( = -1 if current dir not involved, else
 16077                                  ;		 Points to first char after last "/" of current dir part)
 16078                                  ;	[THISCDS] Points to CDS being used
 16079                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 16080                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 16081                                  ; Function:
 16082                                  ;	Delete the specified file(s)
 16083                                  ; Outputs:
 16084                                  ;	CARRY CLEAR
 16085                                  ;		OK
 16086                                  ;	CARRY SET
 16087                                  ;	    AX is error code
 16088                                  ;		error_file_not_found
 16089                                  ;			Last element of path not found
 16090                                  ;		error_path_not_found
 16091                                  ;			Bad path (not in curr dir part if present)
 16092                                  ;		error_bad_curr_dir
 16093                                  ;			Bad path in current directory part of path
 16094                                  ;		error_access_denied
 16095                                  ;			Attempt to delete device or directory
 16096                                  ;		***error_sharing_violation***
 16097                                  ;			Deny both access required, generates an INT 24.
 16098                                  ;			This error is NOT returned. The INT 24H is generated,
 16099                                  ;			  and the file is ignored (not deleted). Delete will
 16100                                  ;			  simply continue on looking for more files.
 16101                                  ;			  Carry will NOT be set in this case.
 16102                                  ; DS preserved, others destroyed
 16103                                  ;
 16104                                  ;----------------------------------------------------------------------------
 16105                                  
 16106                                  FILEFOUND   equ 01h
 16107                                  FILEDELETED equ 10h
 16108                                  
 16109                                  
 16110                                  	; 12/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16111                                  	; DOSCODE:63E9h (MSDOS 5.0, MSDOS.SYS)
 16112                                  
 16113                                  DOS_DELETE:
 16114                                  
 16115                                  ;hkn; DOS_Delete is called from file.asm and fcbio.asm. DS has been set up 
 16116                                  ;hkn; appropriately at this point.
 16117                                  
 16118 00002532 E816ED                  	call	TestNet
 16119 00002535 7306                    	JNC	short LOCAL_DELETE
 16120                                  
 16121                                  ;IF NOT Installed
 16122                                  ;	transfer NET_DELETE
 16123                                  ;ELSE
 16124                                  	;MOV	AX,(MultNET SHL 8) | 19
 16125                                  	;INT	2FH
 16126                                  	;return
 16127                                  
 16128 00002537 B81311                  	mov	ax,1113h
 16129 0000253A CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
 16130                                  			; SS = DS = DOS CS, SDA first filename pointer -> 
 16131                                  			;		fully-qualified filename in DOS CS
 16132                                  			; SDA CDS pointer -> current directory structure for drive with file
 16133                                  			; Return: CF set on error
 16134 0000253C C3                      	retn
 16135                                  ;ENDIF
 16136                                  
 16137                                  LOCAL_DELETE:
 16138 0000253D C606[6F05]00            	MOV	byte [FOUNDDEL],0	; No files found and no files deleted
 16139 00002542 E8C8ED                  	call	ECritDisk
 16140                                  	;mov	word [CREATING],0E500h
 16141 00002545 C706[7E05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Assume not del *.*
 16142 0000254B 8B36[B205]              	MOV	SI,[WFP_START]
 16143                                  SKPNUL:
 16144 0000254F AC                      	LODSB
 16145 00002550 08C0                    	OR	AL,AL
 16146 00002552 75FB                    	JNZ	short SKPNUL		; go to end
 16147 00002554 83EE04                  	SUB	SI,4			; Back over possible "*.*"
 16148 00002557 813C2A2E                	CMP	WORD [SI],2E2Ah ; "*."
 16149 0000255B 7506                    	JNZ	short TEST_QUEST
 16150 0000255D 807C022A                	CMP	BYTE [SI+2],"*"
 16151 00002561 741F                    	JZ	short CHECK_ATTS
 16152                                  TEST_QUEST:
 16153 00002563 83EE09                  	SUB	SI,9		; Back over possible "????????.???"
 16154 00002566 87FE                    	XCHG	DI,SI
 16155                                  
 16156 00002568 16                      	push	ss
 16157                                  	;pop	ds ; ! Retro DOS v3.0 BUG !
 16158 00002569 07                      	pop	es ; 17/05/2019
 16159                                  
 16160 0000256A B83F3F                  	MOV	AX,"??" ; 3F3Fh
 16161 0000256D B90400                  	MOV	CX,4		; four sets of "??"
 16162 00002570 F3AF                    	REPE	SCASW
 16163 00002572 751C                    	JNZ	short NOT_ALL
 16164 00002574 87FE                    	XCHG	DI,SI
 16165 00002576 AD                      	LODSW
 16166 00002577 3D2E3F                  	CMP	AX,3F2Eh ; ".?"
 16167 0000257A 7514                    	JNZ	short NOT_ALL
 16168 0000257C AD                      	LODSW
 16169 0000257D 3D3F3F                  	CMP	AX,"??"
 16170 00002580 750E                    	JNZ	short NOT_ALL
 16171                                  CHECK_ATTS:
 16172 00002582 A0[6D05]                	MOV	AL,[SATTRIB]
 16173                                  	;and	al,1Fh
 16174 00002585 241F                    	AND	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 16175                                  					; Look only at hidden bits
 16176                                  	;cmp	al,1Fh
 16177 00002587 3C1F                    	CMP	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 16178                                  					; All must be set
 16179 00002589 7505                    	JNZ	short NOT_ALL
 16180                                  
 16181                                  ; NOTE WARNING DANGER-----
 16182                                  ;    This DELALL stuff is not safe. It allows directories to be deleted.
 16183                                  ;	It should ONLY be used by FORMAT in the ROOT directory.
 16184                                  
 16185 0000258B C606[7F05]00            	MOV	byte [DELALL],0		; DEL *.* - flag deleting all
 16186                                  NOT_ALL:
 16187 00002590 C606[4C03]01            	MOV	byte [NoSetDir],1
 16188 00002595 E89519                  	call	GetPathNoSet
 16189 00002598 7312                    	JNC	short Del_found
 16190 0000259A 750B                    	JNZ	short _bad_path
 16191 0000259C 08C9                    	OR	CL,CL
 16192 0000259E 7407                    	JZ	short _bad_path
 16193                                  No_file:
 16194 000025A0 B80200                  	MOV	AX,error_file_not_found
 16195                                  ErrorReturn:
 16196 000025A3 F9                      	STC
 16197                                  	;call	LCritDisk
 16198                                  	;retn
 16199                                  	; 18/12/2022
 16200 000025A4 E981ED                  	jmp	LCritDisk
 16201                                  
 16202                                  _bad_path:
 16203 000025A7 B80300                  	MOV	AX,error_path_not_found
 16204 000025AA EBF7                    	JMP	short ErrorReturn
 16205                                  
 16206                                  Del_found:
 16207 000025AC 750C                    	JNZ	short NOT_DIR		; Check for dir specified
 16208 000025AE 803E[7F05]00            	CMP	byte [DELALL],0		; DelAll = 0 allows delete of dir.
 16209 000025B3 7405                    	JZ	short NOT_DIR
 16210                                  Del_access_err:
 16211 000025B5 B80500                  	MOV	AX,error_access_denied
 16212 000025B8 EBE9                    	JMP	short ErrorReturn
 16213                                  
 16214                                  NOT_DIR:
 16215 000025BA 08E4                    	OR	AH,AH			; Check if device name
 16216 000025BC 78F7                    	JS	short Del_access_err	; Can't delete I/O devices
 16217                                  
 16218                                  ; Main delete loop. CURBUF+2:BX points to a matching directory entry.
 16219                                  
 16220                                  DELFILE:
 16221 000025BE 800E[6F05]01            	OR	byte [FOUNDDEL],FILEFOUND ; file found, not deleted yet
 16222                                  
 16223                                  ; If we are deleting the Volume ID, then we set VOLUME_CHNG flag to make
 16224                                  ; DOS issue a build BPB call the next time this drive is accessed.
 16225                                  
 16226 000025C3 1E                      	PUSH	DS
 16227 000025C4 8A26[7F05]              	MOV	AH,[DELALL]
 16228 000025C8 C53E[E205]              	LDS	DI,[CURBUF]
 16229                                  	
 16230                                  ;hkn; SS override
 16231 000025CC 36F606[6B05]01          	TEST	byte [SS:ATTRIB],attr_read_only ; are we deleting RO files too?
 16232 000025D2 7509                    	JNZ	short DoDelete		; yes
 16233                                  
 16234 000025D4 F6470B01                	TEST	byte [BX+dir_entry.dir_attr],attr_read_only
 16235 000025D8 7403                    	JZ	short DoDelete		; not read only
 16236                                  
 16237 000025DA 1F                      	POP	DS
 16238 000025DB EB32                    	JMP	SHORT DELNXT		; Skip it (Note ES:BP not set)
 16239                                  
 16240                                  DoDelete:
 16241 000025DD E88400                  	call	REN_DEL_Check		; Sets ES:BP = [THISDPB]
 16242 000025E0 7303                    	JNC	short DEL_SHARE_OK
 16243 000025E2 1F                      	POP	DS
 16244 000025E3 EB2A                    	JMP	SHORT DELNXT		; Skip it
 16245                                  
 16246                                  DEL_SHARE_OK:
 16247                                  	; 17/05/2019 - Retro DOS v4.0
 16248                                  	; MSDOS 6.0
 16249                                  	;test	byte [di+5],40h
 16250 000025E5 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 16251                                  					;LB. if already dirty		  ;AN000;
 16252 000025E9 7507                    	JNZ	short yesdirty		;LB.  don't increment dirty count ;AN000;
 16253 000025EB E86B35                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 16254                                  	;or	byte [di+5],40h
 16255 000025EE 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty
 16256                                  yesdirty:
 16257 000025F2 8827                    	mov	[bx],ah 
 16258                                  	;MOV	[BX+dir_entry.dir_name],AH ; Put in E5H or 0
 16259 000025F4 8B1C                    	MOV	BX,[SI] 		; Get firclus pointer
 16260 000025F6 1F                      	POP	DS
 16261 000025F7 800E[6F05]10            	OR	byte [FOUNDDEL],FILEDELETED ; 10h ; Deleted file
 16262                                  
 16263 000025FC 83FB02                  	CMP	BX,2
 16264 000025FF 720E                    	JB	short DELNXT		; File has invalid FIRCLUS (too small)
 16265                                  	;cmp	bx,[es:bp+0Dh]
 16266 00002601 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 16267 00002605 7708                    	JA	short DELNXT		; File has invalid FIRCLUS (too big)
 16268                                  
 16269 00002607 E8BD28                  	call	RELEASE 		; Free file data
 16270 0000260A 7252                    	JC	short No_fileJ
 16271                                  
 16272                                  ; DOS 3.3  FastOpen
 16273                                  
 16274 0000260C E8C300                  	CALL	FastOpen_Delete 	; delete the dir info in fastopen
 16275                                  
 16276                                  ; DOS 3.3  FastOpen
 16277                                  
 16278                                  DELNXT:
 16279 0000260F C42E[8A05]              	LES	BP,[THISDPB]		; Possible to get here without this set
 16280 00002613 E88218                  	call	GETENTRY		; Registers need to be reset
 16281 00002616 7246                    	JC	short No_fileJ
 16282 00002618 E8BB17                  	call	NEXTENT
 16283 0000261B 73A1                    	JNC	short DELFILE
 16284 0000261D C42E[8A05]              	LES	BP,[THISDPB]		; NEXTENT sets ES=DOSGROUP
 16285                                  	; 12/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16286                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 16287                                  	;;mov	al,[es:bp+0]
 16288                                  	; 15/12/2022
 16289 00002621 268A4600                	MOV	AL,[ES:BP]
 16290 00002625 E82C34                  	call	FLUSHBUF
 16291 00002628 7234                    	JC	short No_fileJ
 16292                                  ;
 16293                                  ; Now we need to test FoundDel for our flags. The cases to consider are:
 16294                                  ;
 16295                                  ;   not found not deleted		file not found
 16296                                  ;   not found	  deleted		*** impossible ***
 16297                                  ;	found not deleted		access denied (read-only)
 16298                                  ;	found	  deleted		no error
 16299                                  ;
 16300 0000262A F606[6F05]10            	TEST	byte [FOUNDDEL],FILEDELETED ; did we delete a file?
 16301 0000262F 7426                    	JZ	short DelError		; no, figure out what's wrong.
 16302                                  ; We set VOLCHNG_FLAG to indicate that we have changed the volume label
 16303                                  ; and to force the DOS to issue a media check.
 16304 00002631 F606[6B05]08            	TEST	byte [ATTRIB],attr_volume_id ; 8
 16305 00002636 741C                    	jz	short No_Set_Flag
 16306 00002638 50                      	PUSH	AX
 16307 00002639 06                      	PUSH	ES
 16308 0000263A 57                      	PUSH	DI
 16309 0000263B C43E[A205]              	LES	DI,[THISCDS]
 16310 0000263F 268A25                  	MOV	AH,[ES:DI]		; Get drive
 16311 00002642 80EC41                  	SUB	AH,'A'                  ; Convert to 0-based
 16312 00002645 8826[A10A]              	mov	[VOLCHNG_FLAG],AH
 16313                                  	
 16314                                  	; MSDOS 6.0
 16315 00002649 30FF                    	XOR	BH,BH			;>32mb delete volume id from boot record ;AN000;
 16316 0000264B E8DC04                  	call	Set_Media_ID		;>32mb set volumme id to boot record	 ;AN000;
 16317                                  	 
 16318 0000264E E88A30                  	call	FATREAD_CDS		; force media check
 16319 00002651 5F                      	POP	DI
 16320 00002652 07                      	POP	ES
 16321 00002653 58                      	POP	AX
 16322                                  No_Set_Flag:
 16323                                  	;call	LCritDisk		; carry is clear
 16324                                  	;retn
 16325                                  	; 18/12/2022
 16326 00002654 E9D1EC                  	jmp	LCritDisk
 16327                                  DelError:
 16328 00002657 F606[6F05]01            	TEST	byte [FOUNDDEL],FILEFOUND ; not deleted. Did we find file?
 16329 0000265C 7503                    	JNZ	short Del_access_errJ 	; yes. Access denied
 16330                                  No_fileJ:
 16331 0000265E E93FFF                  	JMP	No_file ; 10/08/2018 		; Nope
 16332                                  Del_access_errJ:
 16333 00002661 E951FF                  	JMP	Del_access_err ; 10/08/2018
 16334                                  
 16335                                  ; 08/08/2018 - Retro DOS v3.0
 16336                                  
 16337                                  ;Break	<REN_DEL_Check - check for access for rename and delete>
 16338                                  ;---------------------------------------------------------------------------
 16339                                  ; Procedure Name : REN_DEL_Check
 16340                                  ;
 16341                                  ; Inputs:
 16342                                  ;	[THISDPB] set
 16343                                  ;	[CURBUF+2]:BX points to entry
 16344                                  ;	[CURBUF+2]:SI points to firclus field of entry
 16345                                  ;	[WFP_Start] points to name
 16346                                  ; Function:
 16347                                  ;	Check for Exclusive access on given file.
 16348                                  ;	  Used by RENAME, SET_FILE_INFO, and DELETE.
 16349                                  ; Outputs:
 16350                                  ;	ES:BP = [THISDPB]
 16351                                  ;	NOTE: The WFP string pointed to by [WFP_Start] Will be Modified.  The
 16352                                  ;		last element will be loaded from the directory entry.  This is
 16353                                  ;		so the name given to the sharer doesn't have any meta chars in
 16354                                  ;		it.
 16355                                  ;	Carry set if sharing violation, INT 24H generated
 16356                                  ;	    NOTE THAT AX IS NOT error_sharing_violation.
 16357                                  ;		This is because input AX is preserved.
 16358                                  ;		Caller must set the error if needed.
 16359                                  ;	Carry clear
 16360                                  ;		OK
 16361                                  ; AX,DS,BX,SI,DI preserved
 16362                                  ;---------------------------------------------------------------------------
 16363                                  
 16364                                  REN_DEL_Check:
 16365                                  
 16366 00002664 1E                      	PUSH	DS
 16367 00002665 57                      	PUSH	DI
 16368 00002666 50                      	PUSH	AX
 16369 00002667 53                      	PUSH	BX
 16370 00002668 56                      	PUSH	SI		; Save CURBUF pointers
 16371                                  	
 16372 00002669 16                      	push	ss
 16373 0000266A 07                      	pop	es
 16374                                  
 16375                                  ;hkn; context ES will assume ES to DOSDATA
 16376                                  ;hkn; ASSUME	ES:DOSGROUP
 16377                                  
 16378                                  ;hkn; SS override
 16379 0000266B 368B3E[B205]            	MOV	DI,[SS:WFP_START] ; ES:DI -> WFP
 16380 00002670 89DE                    	MOV	SI,BX
 16381                                  
 16382                                  ;hkn; SS override
 16383 00002672 368E1E[E405]            	MOV	DS,[SS:CURBUF+2] ; DS:SI -> entry (FCB style name)
 16384 00002677 89FB                    	MOV	BX,DI		; Set backup limit for skipback
 16385 00002679 83C302                  	ADD	BX,2		; Skip over d: to point to leading '\'
 16386 0000267C E86CEB                  	call	StrLen		; CX is length of ES:DI including NUL
 16387 0000267F 49                      	DEC	CX		; Don't include nul in count
 16388 00002680 01CF                    	ADD	DI,CX		; Point to NUL at end of string
 16389 00002682 E8D346                  	call	SkipBack	; Back up one element
 16390 00002685 47                      	INC	DI		; Point to start of last element
 16391                                  
 16392                                  	; 17/05/2019 - Retro DOS v4.0
 16393                                  ;hkn; SS override
 16394                                  	; MSDOS 6.0
 16395 00002686 36893E[0106]            	MOV	[SS:SAVE_BX],DI	;IFS. save for DOS_RENAME   ;AN000;
 16396                                  	;
 16397 0000268B E832FA                  	call	PackName	; Transfer name from entry to ASCIZ tail.
 16398 0000268E 5E                      	POP	SI		; Get back entry pointers
 16399 0000268F 5B                      	POP	BX
 16400 00002690 53                      	PUSH	BX
 16401 00002691 56                      	PUSH	SI		; Back on stack
 16402                                  	
 16403 00002692 16                      	push	ss
 16404 00002693 1F                      	pop	ds
 16405                                  
 16406                                  ;hkn; context DS will assume ES to DOSDATA
 16407                                  ;hkn; ASSUME	DS:DOSGROUP
 16408                                  
 16409                                  ; Close the file if possible by us.
 16410                                  ;
 16411                                  ;if installed
 16412 00002694 FF1E[C400]              	Call	far [JShare+(13*4)] ; 13 = ShCloseFile
 16413                                  ;else
 16414                                  ;	Call	ShCloseFile
 16415                                  ;endif
 16416 00002698 8C1E[A005]              	MOV	[THISSFT+2],DS
 16417                                  
 16418                                  ;hkn; AUXSTACK is in DOSDATA
 16419 0000269C C706[9E05][6507]        	MOV	word [THISSFT],AUXSTACK-SF_ENTRY.size  ; RENAMEDMA+(384-59)
 16420                                  				; Scratch space
 16421 000026A2 30E4                    	XOR	AH,AH		; Indicate file to DOOPEN (high bit off)
 16422 000026A4 E8AA24                  	call	DOOPEN		; Fill in SFT for share check
 16423 000026A7 C43E[9E05]              	LES	DI,[THISSFT]
 16424                                  	;mov	word [es:di+2],10h
 16425 000026AB 26C745021000            	MOV	word [ES:DI+SF_ENTRY.sf_mode],SHARING_DENY_BOTH ; 10h
 16426                                  				; requires exclusive access
 16427                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],1 ; Pretend open
 16428 000026B1 26C7050100              	mov	word [ES:DI],1
 16429 000026B6 E8C34C                  	call	ShareEnter
 16430 000026B9 720D                    	jc	short CheckDone
 16431 000026BB C43E[9E05]              	LES	DI,[THISSFT]
 16432                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],0
 16433 000026BF 26C7050000              	mov	word [ES:DI],0	; Pretend closed and free
 16434                                  	
 16435 000026C4 E8B04C                  	call	ShareEnd	; Tell sharer we're done with THISSFT
 16436 000026C7 F8                      	CLC
 16437                                  CheckDone:
 16438 000026C8 C42E[8A05]              	LES	BP,[THISDPB]
 16439 000026CC 5E                      	POP	SI
 16440 000026CD 5B                      	POP	BX
 16441 000026CE 58                      	POP	AX
 16442 000026CF 5F                      	POP	DI
 16443 000026D0 1F                      	POP	DS
 16444 000026D1 C3                      	retn
 16445                                  
 16446                                  ;Break	<FastOpen_Delete - delete dir info in fastopen>
 16447                                  ;---------------------------------------------------------------------------
 16448                                  ; Procedure Name : FastOpen_Delete
 16449                                  ; Inputs:
 16450                                  ;	None
 16451                                  ; Function:
 16452                                  ;	Call FastOpen to delete the dir info.
 16453                                  ; Outputs:
 16454                                  ;	None
 16455                                  ;---------------------------------------------------------------------------
 16456                                  
 16457                                  FastOpen_Delete:
 16458 000026D2 9C                      	PUSHF			; save flag
 16459 000026D3 56                      	PUSH	SI		; save registers
 16460 000026D4 53                      	PUSH	BX
 16461 000026D5 50                      	PUSH	AX
 16462                                  	;mov	si,[WFP_START] ; MSDOS 3.3
 16463                                  ;hkn; SS override
 16464                                  	; 17/05/2019 - Retro DOS v4.0
 16465                                  	; MSDOS 6.0
 16466 000026D6 368B36[B205]            	MOV	SI,[ss:WFP_START] ; ds:si points to path name
 16467                                  	
 16468 000026DB B003                    	MOV	AL,FONC_delete	; al = 3
 16469                                  fastinvoke:
 16470                                  ;hkn; FastTable is in DOSDATA
 16471 000026DD BB[320D]                	MOV	BX,FastTable+2
 16472 000026E0 FF1F                    	CALL	far [BX]	; call fastopen
 16473 000026E2 58                      	POP	AX		; restore registers
 16474 000026E3 5B                      	POP	BX
 16475 000026E4 5E                      	POP	SI
 16476 000026E5 9D                      	POPF			; restore flag
 16477 000026E6 C3                      	retn
 16478                                  
 16479                                  	; 13/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16480                                  	; DOSCODE:65A0h (MSDOS 5.0 MSDOS.SYS)
 16481                                  
 16482                                  ;Break	<FastOpen_Rename - Rename directory>	   ; PTR 5622
 16483                                  ;---------------------------------------------------------------------------
 16484                                  ; PROCEDURE Name : FastOpen_Rename
 16485                                  ;
 16486                                  ; Inputs:
 16487                                  ;	 REN_WFP   = Path Name
 16488                                  ;	 NAME1	   = New Name
 16489                                  ; Function:
 16490                                  ;	Call FastOpen to rename the dir entry in the cache
 16491                                  ; Outputs:
 16492                                  ;	None
 16493                                  ;---------------------------------------------------------------------------
 16494                                  
 16495                                  FastOpen_Rename:
 16496                                  	; 17/05/2019 - Retro DOS v4.0
 16497                                  	; 08/08/2018 - Retro DOS v3.0
 16498                                  	; MSDOS 6.0
 16499 000026E7 9C                      	PUSHF			;AN001 save flag
 16500 000026E8 56                      	PUSH	SI		;AN001 save registers
 16501 000026E9 57                      	PUSH	DI		;AN001
 16502 000026EA 53                      	PUSH	BX		;AN001
 16503 000026EB 50                      	PUSH	AX		;AN001
 16504                                  	;
 16505                                  ;hkn; SS override
 16506 000026EC 368B36[B405]            	MOV	SI,[SS:REN_WFP]	;AN001	;;AN001  ds:si-->Path name addrs
 16507                                  
 16508                                  ;hkn; NAME1 is in DOSDATA
 16509 000026F1 BF[4B05]                	MOV	DI,NAME1	;;AN001  ds:di-->New name addrs
 16510                                  	;mov	al,6
 16511 000026F4 B006                    	MOV	AL,FONC_Rename	;;AN001  al = 6
 16512                                  	
 16513                                  ;hkn; FastTable is in DOSDATA
 16514 000026F6 BB[320D]                	MOV	BX,FastTable+2
 16515 000026F9 FF1F                    	CALL	far [BX]	;;AN001  call fastopen
 16516                                  	
 16517 000026FB 58                      	POP	AX		; restore registers  ;AN001
 16518 000026FC 5B                      	POP	BX				     ;AN001
 16519 000026FD 5F                      	POP	DI				     ;AN001
 16520 000026FE 5E                      	POP	SI				     ;AN001
 16521 000026FF 9D                      	POPF			; restore flag	     ;AN001
 16522 00002700 C3                      	retn					     ;AN001
 16523                                  
 16524                                  ;Break	<FastOpen_Update - update dir info in fastopen>
 16525                                  ;---------------------------------------------------------------------------
 16526                                  ; Procedure Name : FastOpen_Update
 16527                                  ;
 16528                                  ; Inputs:
 16529                                  ;	DL     drive number (A=0,B=1,,,)
 16530                                  ;	CX     first cluster #
 16531                                  ;	AH     0 updates dir entry
 16532                                  ;	       1 updates CLUSNUM , BP = new CLUSNUM
 16533                                  ;	ES:DI  directory entry
 16534                                  ; Function:
 16535                                  ;	Call FastOpen to update the dir info.
 16536                                  ; Outputs:
 16537                                  ;	None
 16538                                  ;---------------------------------------------------------------------------
 16539                                  
 16540                                  FastOpen_Update:
 16541 00002701 9C                      	PUSHF			; save flag
 16542 00002702 56                      	PUSH	SI
 16543 00002703 53                      	PUSH	BX		; save regs
 16544 00002704 50                      	PUSH	AX
 16545 00002705 B004                    	MOV	AL,FONC_update	; al = 4
 16546 00002707 EBD4                    	JMP	short fastinvoke
 16547                                  
 16548                                  	; 17/05/2019
 16549                                  
 16550                                  	; MSDOS 6.0
 16551                                  ;entry Fast_Dispatch		; future fastxxxx entry	;AN000;
 16552                                  ;---------------------------------------------------------------------------
 16553                                  Fast_Dispatch:
 16554                                  ;hkn; FastTable is in DOSDATA
 16555 00002709 BE[320D]                	MOV	SI,FastTable+2	; index to the	     ;AN000;
 16556                                  ;hkn; use SS override
 16557 0000270C 36FF1C                  	CALL	far [SS:SI]	; RMFD call fastopen
 16558 0000270F C3                      	retn
 16559                                  
 16560                                  ;============================================================================
 16561                                  ; RENAME.ASM, MSDOS 6.0, 1991
 16562                                  ;============================================================================
 16563                                  ; 08/08/2018 - Retro DOS v3.0
 16564                                  ; 17/05/2019 - Retro DOS v4.0
 16565                                  
 16566                                  ;	TITLE	DOS_RENAME - Internal RENAME call for MS-DOS
 16567                                  ;	NAME	DOS_RENAME
 16568                                  
 16569                                  ;**	Low level routine for renaming files
 16570                                  ;----------------------------------------------------------------------------
 16571                                  ;	DOS_RENAME
 16572                                  ;
 16573                                  ;	Modification history:
 16574                                  ;
 16575                                  ;	    Created: ARR 30 March 1983
 16576                                  
 16577                                  ;----------------------------------------------------------------------------
 16578                                  ;
 16579                                  ; Procedure Name : DOS_RENAME
 16580                                  ;
 16581                                  ; Inputs:
 16582                                  ;	[WFP_START] Points to SOURCE WFP string ("d:/" must be first 3
 16583                                  ;		chars, NUL terminated)
 16584                                  ;	[CURR_DIR_END] Points to end of Current dir part of string [SOURCE]
 16585                                  ;		( = -1 if current dir not involved, else
 16586                                  ;		 Points to first char after last "/" of current dir part)
 16587                                  ;	[REN_WFP] Points to DEST WFP string ("d:/" must be first 3
 16588                                  ;		chars, NUL terminated)
 16589                                  ;	[THISCDS] Points to CDS being used
 16590                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 16591                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 16592                                  ; Function:
 16593                                  ;	Rename the specified file(s)
 16594                                  ;	NOTE: This routine uses most of AUXSTACK as a temp buffer.
 16595                                  ; Outputs:
 16596                                  ;	CARRY CLEAR
 16597                                  ;	    OK
 16598                                  ;	CARRY SET
 16599                                  ;	    AX is error code
 16600                                  ;		error_file_not_found
 16601                                  ;			No match for source, or dest path invalid
 16602                                  ;		error_not_same_device
 16603                                  ;			Source and dest are on different devices
 16604                                  ;		error_access_denied
 16605                                  ;			Directory specified (not simple rename),
 16606                                  ;			Device name given, Destination exists.
 16607                                  ;			NOTE: In third case some renames may have
 16608                                  ;			 been done if metas.
 16609                                  ;		error_path_not_found
 16610                                  ;			Bad path (not in curr dir part if present)
 16611                                  ;			SOURCE ONLY
 16612                                  ;		error_bad_curr_dir
 16613                                  ;			Bad path in current directory part of path
 16614                                  ;			SOURCE ONLY
 16615                                  ;		error_sharing_violation
 16616                                  ;			Deny both access required, generates an INT 24.
 16617                                  ; DS preserved, others destroyed
 16618                                  ;
 16619                                  ;----------------------------------------------------------------------------
 16620                                  
 16621                                  	; 14/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16622                                  
 16623                                  DOS_RENAME:
 16624                                  
 16625                                  ;hkn; DOS_RENAME is called from file.asm and fcbio.asm. DS has been set up
 16626                                  ;hkn; at this point to DOSDATA.
 16627                                  
 16628 00002710 E838EB                  	call	TestNet
 16629 00002713 7306                    	JNC	short LOCAL_RENAME
 16630                                  
 16631                                  ;IF NOT Installed
 16632                                  ;	transfer NET_RENAME
 16633                                  ;ELSE
 16634                                  	;MOV	AX,(MultNET SHL 8) OR 17
 16635                                  	;INT	2FH
 16636                                  	;return
 16637                                  
 16638 00002715 B81111                  	mov     ax, 1111h
 16639 00002718 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
 16640                                  			; SS = DS = DOS CS, 
 16641                                  			; SDA first filename pointer = offset of fully-qualified old name
 16642                                  			; SDA CDS pointer -> current directory
 16643                                  			; Return: CF set on error
 16644 0000271A C3                      	retn
 16645                                  ;ENDIF
 16646                                  
 16647                                  LOCAL_RENAME:
 16648 0000271B C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 16649 00002720 8B36[B205]              	MOV	SI,[WFP_START]
 16650 00002724 8B3E[B405]              	MOV	DI,[REN_WFP]
 16651 00002728 8A04                    	MOV	AL,[SI]
 16652 0000272A 8A25                    	MOV	AH,[DI]
 16653 0000272C 0D2020                  	OR	AX,2020H		; Lower case
 16654 0000272F 38E0                    	CMP	AL,AH
 16655 00002731 7405                    	JZ	short SAMEDRV
 16656 00002733 B81100                  	MOV	AX,error_not_same_device ; 11h
 16657 00002736 F9                      	STC
 16658 00002737 C3                      	retn
 16659                                  
 16660                                  SAMEDRV:
 16661 00002738 FF36[2E03]              	PUSH	WORD [DMAADD+2]
 16662 0000273C FF36[2C03]              	PUSH	WORD [DMAADD]
 16663 00002740 8C1E[2E03]              	MOV	[DMAADD+2],DS
 16664                                  
 16665                                  ;hkn; RENAMEDMA is in DOSDATA
 16666 00002744 C706[2C03][2006]        	MOV	WORD [DMAADD],RENAMEDMA
 16667 0000274A C606[7005]00            	MOV	byte [FOUND_DEV],0	; Rename fails on DEVS, assume not a dev
 16668 0000274F E8BBEB                  	call	ECritDisk
 16669 00002752 E8F505                  	call	DOS_SEARCH_FIRST	; Sets [NoSetDir] to 1, [CURBUF+2]:BX
 16670                                  					;    points to entry
 16671 00002755 7314                    	JNC	short Check_Dev
 16672 00002757 83F812                  	CMP	AX,error_no_more_files ; 12h
 16673 0000275A 7503                    	JNZ	short GOTERR
 16674 0000275C B80200                  	MOV	AX,error_file_not_found ; 2
 16675                                  GOTERR:
 16676 0000275F F9                      	STC
 16677                                  RENAME_POP:
 16678 00002760 8F06[2C03]              	POP	WORD [DMAADD]
 16679 00002764 8F06[2E03]              	POP	WORD [DMAADD+2]
 16680                                  	;call	LCritDisk
 16681                                  	;retn
 16682                                  	; 16/12/2022
 16683 00002768 E9BDEB                  	jmp	LCritDisk
 16684                                  
 16685                                  Check_Dev:
 16686                                  	; 17/05/2019 - Retro DOS v4.0
 16687                                  	;mov	ax,5
 16688 0000276B B80500                  	MOV	AX,error_access_denied	; Assume error
 16689                                  	
 16690                                  	; MSDOS 6.0
 16691 0000276E 1E                      	PUSH	DS			      ;PTM.			    ;AN000;
 16692 0000276F C536[2C03]              	LDS	SI,[DMAADD]		      ;PTM.  chek if source a dir   ;AN000;
 16693                                  	;add	si,21
 16694 00002773 83C615                  	ADD	SI,find_buf.attr	      ;PTM.			    ;AN000;
 16695                                  	;test	byte [si+11],10h
 16696 00002776 F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;PTM.	    ;AN000;
 16697 0000277A 7407                    	JZ	short notdir		      ;PTM.			    ;AN000;
 16698 0000277C 8B36[B405]              	MOV	SI,[REN_WFP]		      ;PTM.  if yes, make sure path ;AN000;
 16699 00002780 E8CEFA                  	call	Check_PathLen2		      ;PTM.   length < 67	    ;AN000;
 16700                                  notdir:
 16701 00002783 1F                      	POP	DS			      ;PTM.			    ;AN000;
 16702 00002784 77D9                    	JA	short GOTERR		      ;PTM.			    ;AN000;
 16703                                  
 16704                                  	; MSDOS 3.3 & MSDOS 6.0
 16705 00002786 803E[7005]00            	CMP	byte [FOUND_DEV],0
 16706 0000278B 75D2                    	JNZ	short GOTERR
 16707                                  
 16708                                  ; At this point a source has been found. There is search continuation info (a
 16709                                  ; la DOS_SEARCH_NEXT) for the source at RENAMEDMA, together with the first
 16710                                  ; directory entry found.
 16711                                  ; [THISCDS], [THISDPB], and [THISDRV] are set and will remain correct
 16712                                  ; throughout the RENAME since it is known at this point that the source and
 16713                                  ; destination are both on the same device.
 16714                                  ; [SATTRIB] is also set.
 16715                                  
 16716 0000278D 89DE                    	MOV	SI,BX
 16717                                  	;add	si,26
 16718 0000278F 83C61A                  	ADD	SI,dir_entry.dir_first
 16719 00002792 E8CFFE                  	call	REN_DEL_Check
 16720 00002795 7305                    	JNC	short REN_OK1
 16721 00002797 B82000                  	MOV	AX,error_sharing_violation  ; 20h
 16722 0000279A EBC4                    	JMP	short RENAME_POP
 16723                                  
 16724                                  ;------------------------------------------------------------------------------
 16725                                  ; Check if the source is a file or directory. If file, delete the entry
 16726                                  ; from the Fastopen cache. If directory, rename it later
 16727                                  ;------------------------------------------------------------------------------
 16728                                  
 16729                                  REN_OK1:				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 16730                                  	; MSDOS 6.0
 16731 0000279C 56                      	PUSH	SI
 16732 0000279D C536[2C03]              	LDS	SI,[DMAADD]		;BN00X; PTM. check if source a dir ;AN000;
 16733                                  	;add	si,21
 16734 000027A1 83C615                  	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 16735                                  	;test	byte [si+11],10h
 16736 000027A4 F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM. ;AN000;
 16737 000027A8 7403                    	JZ	short NOT_DIR1		;;BN00XPTM.			;AN000;
 16738 000027AA 5E                      	POP	SI			;BN00X
 16739 000027AB EB04                    	JMP	SHORT SWAP_SOURCE	;BN00X
 16740                                  NOT_DIR1:				;;BN00X it is a file, delete the entry
 16741 000027AD 5E                      	POP	SI
 16742                                  
 16743                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 16744 000027AE E821FF                  	call	FastOpen_Delete 	; delete dir info in fastopen DOS 3.3
 16745                                  SWAP_SOURCE:
 16746                                  	; MSDOS 3.3
 16747                                  	;MOV	SI,[REN_WFP]
 16748                                  	;MOV	[WFP_START],SI
 16749                                  	; MSDOS 6.0
 16750 000027B1 A1[B205]                	MOV	AX,[WFP_START]		; Swap source and destination
 16751 000027B4 8B36[B405]              	MOV	SI,[REN_WFP]		; Swap source and destination
 16752 000027B8 8936[B205]              	MOV	[WFP_START],SI		; WFP_START = Destination path
 16753 000027BC A3[B405]                	MOV	[REN_WFP],AX		; REN_WFP   = Source path
 16754                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16755 000027BF C706[B605]FFFF          	MOV	word [CURR_DIR_END],-1	; No current dir on dest
 16756                                  	;mov	word [CREATING],0E5FFh
 16757 000027C5 C706[7E05]FFE5          	MOV	WORD [CREATING],DIRFREE*256+0FFh  ; Creating, not DEL *.*
 16758                                  					; A rename is like a CREATE_NEW as far
 16759                                  					; as the destination is concerned.
 16760 000027CB E85F17                  	call	GetPathNoSet
 16761                                  
 16762                                  ;   If this GETPATH fails due to file not found, we know all renames will work
 16763                                  ;   since no files match the destination name. If it fails for any other
 16764                                  ;   reason, the rename fails on a path not found, or whatever (also fails if
 16765                                  ;   we find a device or directory). If the GETPATH succeeds, we aren't sure
 16766                                  ;   if the rename should fail because we haven't built an explicit name by
 16767                                  ;   substituting for the meta chars in it. In this case the destination file
 16768                                  ;   spec with metas is in [NAME1] and the explicit source name is at RENAMEDMA
 16769                                  ;   in the directory entry part.
 16770                                  	
 16771 000027CE 7223                    	JC	short NODEST
 16772                                  	
 16773                                  	; MSDOS 6.0
 16774                                  	;JZ	short BAD_ACC 		; Dest string is a directory	;AC000;
 16775                                  	; !! MSDOS 3.3 !!
 16776                                  	;JZ	short BAD_ACC ; !!	; Dest string is a directory
 16777                                  
 16778 000027D0 08E4                    	OR	AH,AH			; Device?
 16779 000027D2 792C                    	JNS	short SAVEDEST		; No, continue
 16780                                  BAD_ACC:
 16781 000027D4 B80500                  	MOV	AX,error_access_denied
 16782 000027D7 F9                      	STC
 16783                                  RENAME_CLEAN:
 16784 000027D8 9C                      	PUSHF				; Save carry state
 16785 000027D9 50                      	PUSH	AX			; and error code (if carry set)
 16786 000027DA A0[7605]                	MOV	AL,[THISDRV]
 16787 000027DD E87432                  	call	FLUSHBUF
 16788 000027E0 58                      	POP	AX
 16789 000027E1 803E[4A03]00            	CMP	byte [FAILERR],0
 16790 000027E6 7504                    	JNZ	short BAD_ERR		; User FAILed to I 24
 16791 000027E8 9D                      	POPF
 16792 000027E9 E974FF                  	JMP	RENAME_POP
 16793                                  
 16794                                  BAD_ERR:
 16795 000027EC 58                      	POP	AX			; Saved flags
 16796                                  	; 16/12/202
 16797                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16798                                  BAD_PATH: ; *
 16799 000027ED B80300                  	MOV	AX,error_path_not_found
 16800 000027F0 E96CFF                  	JMP	GOTERR
 16801                                  
 16802                                  NODEST:
 16803 000027F3 75F8                    	JNZ	short BAD_PATH
 16804 000027F5 803E[4A03]00            	CMP	byte [FAILERR],0
 16805 000027FA 75F1                    	JNZ	short BAD_PATH		; Search for dest failed 
 16806                                  					; because user FAILed on I 24
 16807                                  	; 14/11/2022
 16808 000027FC 08C9                    	OR	CL,CL
 16809                                  	;JNZ	short SAVEDEST
 16810                                  	; 17/05/2019
 16811 000027FE 74ED                    	jz	short BAD_PATH ; *
 16812                                  ;BAD_PATH: ; *
 16813                                  ;	MOV	AX,error_path_not_found
 16814                                  ;	;STC
 16815                                  ;	;JMP	RENAME_POP
 16816                                  ;	; 17/05/2019
 16817                                  ;	jmp	GOTERR 
 16818                                  
 16819                                  ; 16/12/2022
 16820                                  %if 0
 16821                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16822                                  	or	cl,cl
 16823                                  	jnz	short SAVEDEST
 16824                                  	;jz	short BAD_PATH ; *
 16825                                  BAD_PATH: ; *
 16826                                  	;mov	ax,3
 16827                                  	mov	ax,error_path_not_found
 16828                                  	stc
 16829                                  	jmp	RENAME_POP
 16830                                  %endif
 16831                                  
 16832                                  SAVEDEST:
 16833 00002800 16                      	push	ss
 16834 00002801 07                      	pop	es
 16835                                  
 16836                                  ;hkn; NAME1 & NAME2 is in DOSDATA
 16837 00002802 BF[5705]                	MOV	DI,NAME2
 16838 00002805 BE[4B05]                	MOV	SI,NAME1
 16839                                  
 16840 00002808 B90B00                  	MOV	CX,11
 16841 0000280B F3A4                    	REP	MOVSB			; Save dest with metas at NAME2
 16842 0000280D A1[C205]                	MOV	AX,[DIRSTART]
 16843 00002810 A3[6405]                	MOV	[DESTSTART],AX
 16844                                  BUILDDEST:
 16845 00002813 16                      	push	ss
 16846 00002814 07                      	pop	es			; needed due to JMP BUILDDEST below
 16847                                  
 16848                                  ;hkn; RENAMEDMA, NAME1, NAME2 in DOSDATA
 16849 00002815 BB[3506]                	MOV	BX,RENAMEDMA+21		; Source of replace chars
 16850 00002818 BF[4B05]                	MOV	DI,NAME1		; Real dest name goes here
 16851 0000281B BE[5705]                	MOV	SI,NAME2		; Raw dest
 16852                                  
 16853 0000281E B90B00                  	MOV	CX,11
 16854                                  
 16855                                  	; 17/05/2019 - Retro DOS v4.0
 16856                                  	
 16857                                  	; MSDOS 6.0
 16858 00002821 E81201                  	CALL	NEW_RENAME		;IFS. replace ? chars	;AN000;
 16859                                  
 16860                                  	; MSDOS 3.3
 16861                                  
 16862                                  ; 08/08/2018 - Retro DOS v3.0
 16863                                  ; MSDOS 6.0 
 16864                                  ;---------------------------------------------------------------------------
 16865                                  ;Procedure: NEW_RENAME
 16866                                  ;
 16867                                  ;Input: DS:SI -> raw string with ?
 16868                                  ;	ES:DI -> destination string
 16869                                  ;	DS:BX -> source string
 16870                                  ;Function: replace ? chars of raw string with chars in source string and
 16871                                  ;	   put in destination string
 16872                                  ;Output: ES:DI-> new string
 16873                                  ;---------------------------------------------------------------------------
 16874                                  ;
 16875                                  ;NEW_RENAME:
 16876                                  ;NEWNAM:
 16877                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 341Ah
 16878                                  ;	LODSB
 16879                                  ;	CMP	AL,"?"
 16880                                  ;	JNZ	short NOCHG
 16881                                  ;	MOV	AL,[BX] 		; Get replace char
 16882                                  ;NOCHG:
 16883                                  ;	STOSB
 16884                                  ;	INC	BX			; Next replace char
 16885                                  ;	LOOP	NEWNAM
 16886                                  ;	; MSDOS 6.0
 16887                                  ;	;retn
 16888                                  
 16889                                  	; MSDOS 3.3 & MSDOS 6.0
 16890                                  	;mov	byte [ATTRIB],16h
 16891 00002824 C606[6B05]16            	MOV	byte [ATTRIB],attr_all	; Stop duplicates with any attributes
 16892 00002829 C606[7E05]FF            	MOV	byte [CREATING],0FFH
 16893 0000282E E8AA19                  	call	DEVNAME 		; Check if we built a device name
 16894 00002831 73A1                    	JNC	short BAD_ACC
 16895 00002833 8B1E[6405]              	MOV	BX,[DESTSTART]
 16896 00002837 C42E[8A05]              	LES	BP,[THISDPB]
 16897 0000283B E88C16                  	call	SETDIRSRCH		; Reset search to start of dir
 16898 0000283E 7294                    	JC	short BAD_ACC 		; Screw up
 16899 00002840 E84615                  	call	FINDENTRY		; See if new name already exists
 16900 00002843 738F                    	JNC	short BAD_ACC 		; Error if found
 16901 00002845 803E[4A03]00            	CMP	byte [FAILERR],0
 16902 0000284A 752A                    	JNZ	short BAD_ACCJ		; Find failed because user FAILed to I 24
 16903 0000284C A1[6405]                	MOV	AX,[DESTSTART]		; DIRSTART of dest
 16904 0000284F 3B06[2F06]              	CMP	AX,[RENAMEDMA+15]	; DIRSTART of source
 16905 00002853 745D                    	JZ	short SIMPLE_RENAME	; If =, just give new name
 16906                                  
 16907                                  	;mov	al,[RENAMEDMA+32]
 16908 00002855 A0[4006]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr]
 16909 00002858 A810                    	TEST	AL,attr_directory ; 10h
 16910 0000285A 751A                    	JNZ	short BAD_ACCJ		; Can only do a simple rename on dirs,
 16911                                  					; otherwise the . and .. entries get
 16912                                  					; wiped.
 16913 0000285C A2[6B05]                	MOV	[ATTRIB],AL
 16914 0000285F 8C1E[A005]              	MOV	[THISSFT+2],DS
 16915                                  
 16916                                  ;hkn; AUXSTACK is in DOSDATA
 16917                                  	;mov	si,[RENAMEDMA+145h]
 16918 00002863 BE[6507]                	MOV	SI,AUXSTACK-SF_ENTRY.size  ; RENAMEDMA+325
 16919 00002866 8936[9E05]              	MOV	[THISSFT],SI
 16920                                  	;mov	word [SI+2],2
 16921 0000286A C744020200              	MOV	word [SI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 16922 0000286F 31C9                    	XOR	CX,CX			; Set "device ID" for call into makenode
 16923 00002871 E84521                  	call	RENAME_MAKE		; This is in mknode
 16924 00002874 7303                    	JNC	short GOT_DEST
 16925                                  BAD_ACCJ:
 16926 00002876 E95BFF                  	JMP	BAD_ACC
 16927                                  
 16928                                  GOT_DEST:
 16929 00002879 53                      	push	bx
 16930 0000287A C43E[9E05]              	LES	DI,[THISSFT]		; RENAME_MAKE entered this into sharing
 16931 0000287E E8F64A                  	call	ShareEnd		; we need to remove it.
 16932 00002881 5B                      	pop	bx
 16933                                  
 16934                                  ; A zero length entry with the correct new name has now been made at
 16935                                  ;   [CURBUF+2]:BX.
 16936                                  
 16937 00002882 C43E[E205]              	LES	DI,[CURBUF]
 16938                                  
 16939                                  	; MSDOS 6.0
 16940                                  	;test	byte [es:di+5],40h
 16941 00002886 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 16942                                  					;LB. if already dirty		  ;AN000;
 16943 0000288B 7508                    	JNZ	short yesdirty1		;LB.  don't increment dirty count ;AN000;
 16944 0000288D E8C932                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 16945                                  	;or	byte [es:di+5],40h
 16946 00002890 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 16947                                  yesdirty1:
 16948 00002895 89DF                    	MOV	DI,BX
 16949                                  	;add	di,11
 16950 00002897 83C70B                  	ADD	DI,dir_entry.dir_attr	; Skip name
 16951                                  
 16952                                  ;hkn; RENAMEDMA is in DOSDATA
 16953                                  	;mov	si,[RENAMEDMA+32]
 16954 0000289A BE[4006]                	MOV	SI,RENAMEDMA+21+dir_entry.dir_attr
 16955                                  	;mov	cx,21
 16956 0000289D B91500                  	MOV	CX,dir_entry.size-dir_entry.dir_attr
 16957 000028A0 F3A4                    	REP	MOVSB
 16958 000028A2 E87B00                  	CALL	GET_SOURCE
 16959 000028A5 7276                    	JC	short RENAME_OVER
 16960 000028A7 89DF                    	MOV	DI,BX
 16961 000028A9 8E06[E405]              	MOV	ES,[CURBUF+2]
 16962 000028AD B0E5                    	MOV	AL,DIRFREE ; 0E5h
 16963 000028AF AA                      	STOSB				; "free" the source
 16964 000028B0 EB13                    	JMP	SHORT DIRTY_IT
 16965                                  
 16966                                  SIMPLE_RENAME:
 16967 000028B2 E86B00                  	CALL	GET_SOURCE		; Get the source back
 16968 000028B5 7266                    	JC	short RENAME_OVER
 16969 000028B7 89DF                    	MOV	DI,BX
 16970 000028B9 8E06[E405]              	MOV	ES,[CURBUF+2]
 16971                                  
 16972                                  ;hkn; NAME1 is in DOSDATA
 16973 000028BD BE[4B05]                	MOV	SI,NAME1		; New Name
 16974 000028C0 B90B00                  	MOV	CX,11
 16975 000028C3 F3A4                    	REP	MOVSB
 16976                                  DIRTY_IT:
 16977 000028C5 8B3E[E205]              	MOV	DI,[CURBUF]
 16978                                  
 16979                                  	; MSDOS 6.0
 16980 000028C9 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 16981                                  					;LB. if already dirty		  ;AN000;
 16982 000028CE 7508                    	JNZ	short yesdirty2		;LB.  don't increment dirty count ;AN000;
 16983 000028D0 E88632                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 16984                                  	
 16985 000028D3 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 16986                                  
 16987                                  ;------------------------------------------------------------------------------
 16988                                  ; Check if the source is a directory of file. If directory rename it to the
 16989                                  ; the new name in the Fastopen cache buffer. If file name it has been
 16990                                  ; previously deleted.
 16991                                  ;------------------------------------------------------------------------------
 16992                                  
 16993                                  yesdirty2:
 16994                                  	; MSDOS 6.0
 16995 000028D8 56                      	PUSH	SI
 16996 000028D9 C536[2C03]              	LDS	SI,[DMAADD]		;;BN00XPTM. chek if source a dir ;AN000;
 16997 000028DD 83C615                  	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 16998 000028E0 F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM.	;AN000;
 16999 000028E4 7406                    	JZ	short NOT_DIR2		;;BN00XPTM.			;AN000;
 17000 000028E6 E8FEFD                  	call	FastOpen_Rename		;;BN00X rename dir entry in fastopen
 17001 000028E9 5E                      	POP	SI
 17002 000028EA EB01                    	JMP	SHORT NOT_DIRTY1
 17003                                  NOT_DIR2:				;;BN00X it is a file, delete the entry
 17004 000028EC 5E                      	POP	SI
 17005                                  NOT_DIRTY1:				;;BN00X
 17006                                  NEXT_SOURCE:
 17007                                  ;hkn; RENAMEDMA is in DOSDATA
 17008 000028ED BE[2106]                	MOV	SI,RENAMEDMA+1		;Name
 17009                                  
 17010                                  ; WARNING! Rename_Next leaves the disk critical section *ALWAYS*. We need
 17011                                  ; to enter it before going to RENAME_Next.
 17012                                  
 17013 000028F0 E81AEA                  	call	ECritDisk
 17014 000028F3 C606[7E05]00            	MOV	byte [CREATING],0 ; Correct setting for search (we changed it
 17015                                  				  ;  to FF when we made the prev new file).
 17016 000028F8 E88705                  	call	RENAME_NEXT
 17017                                  
 17018                                  ; Note, now, that we have exited the previous ENTER and so are back to where
 17019                                  ; we were before.
 17020                                  
 17021 000028FB 7220                    	JC	short RENAME_OVER
 17022                                  
 17023                                  	;lea	si,[bx+26]
 17024 000028FD 8D771A                  	LEA	SI,[BX+dir_entry.dir_first]
 17025 00002900 E861FD                  	call	REN_DEL_Check
 17026 00002903 7306                    	JNC	short REN_OK2
 17027 00002905 B82000                  	MOV	AX,error_sharing_violation ; 20h
 17028                                  jmp_to_rename_clean: ; 28/12/2022
 17029 00002908 E9CDFE                  	JMP	RENAME_CLEAN ; 10/08/2018
 17030                                  
 17031                                  ;------------------------------------------------------------------------------
 17032                                  ; Check if file or directory. If file, delete file from the Fastopen cache,
 17033                                  ; if directory, rename directory name in the Fastopen cache.
 17034                                  ;-----------------------------------------------------------------------------
 17035                                  
 17036                                  REN_OK2:
 17037                                  	; MSDOS 6.0
 17038                                  	;mov	al,[RERNAMEDMA+32]
 17039 0000290B A0[4006]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr] ; PTR P5622
 17040                                  	;test	al,10h
 17041 0000290E A810                    	TEST	AL,attr_directory	;;BN00X directory
 17042 00002910 7406                    	JZ	short Ren_Directory	;;BN00X no - file, delete it
 17043                                  	
 17044                                  	; MSDOS 3.3 & MSDOS 6.0
 17045 00002912 E8BDFD                  	call	FastOpen_Delete 	;;BN00X delete dir info in fastopen DOS 3.3
 17046                                  jmp_to_builddest: ; 28/12/2022
 17047 00002915 E9FBFE                  	JMP	BUILDDEST		;;BN00X
 17048                                  
 17049                                  	; MSDOS 6.0
 17050                                  Ren_Directory:
 17051 00002918 E8CCFD                  	call	FastOpen_Rename 	;;BN00X delete dir info in fastopen DOS 3.3
 17052                                  	;JMP	BUILDDEST
 17053                                  	; 28/12/2022
 17054 0000291B EBF8                    	jmp	short jmp_to_builddest
 17055                                  
 17056                                  RENAME_OVER:
 17057 0000291D F8                      	CLC
 17058                                  	;JMP	RENAME_CLEAN ; 10/08/2018
 17059                                  	; 28/12/2022
 17060 0000291E EBE8                    	jmp	short jmp_to_rename_clean
 17061                                  
 17062                                  ;----------------------------------------------------------------------------
 17063                                  ; Procedure: GET_SOURCE
 17064                                  ;
 17065                                  ; Inputs:
 17066                                  ;	RENAMEDMA has source info
 17067                                  ; Function:
 17068                                  ;	Re-find the source
 17069                                  ; Output:
 17070                                  ;	[CURBUF] set
 17071                                  ;	[CURBUF+2]:BX points to entry
 17072                                  ;	Carry set if error (currently user FAILed to I 24)
 17073                                  ; DS preserved, others destroyed
 17074                                  ;----------------------------------------------------------------------------
 17075                                  
 17076                                  GET_SOURCE:
 17077 00002920 8B1E[2F06]              	MOV	BX,[RENAMEDMA+15]	; DirStart
 17078 00002924 C42E[8A05]              	LES	BP,[THISDPB]
 17079 00002928 E89F15                  	call	SETDIRSRCH
 17080 0000292B 7214                    	JC	short gs_ret_label	; retc
 17081 0000292D E88A18                  	call	STARTSRCH
 17082 00002930 A1[2D06]                	MOV	AX,[RENAMEDMA+13]	; Lastent
 17083                                  	;call	GETENT
 17084                                  	; 18/12/2022
 17085 00002933 E96515                  	jmp	GETENT
 17086                                  ;gs_ret_label:
 17087                                  	;retn
 17088                                  
 17089                                  ; MSDOS 6.0 
 17090                                  ;---------------------------------------------------------------------------
 17091                                  ;Procedure: NEW_RENAME
 17092                                  ;
 17093                                  ;Input: DS:SI -> raw string with ?
 17094                                  ;	ES:DI -> destination string
 17095                                  ;	DS:BX -> source string
 17096                                  ;Function: replace ? chars of raw string with chars in source string and
 17097                                  ;	   put in destination string
 17098                                  ;Output: ES:DI-> new string
 17099                                  ;---------------------------------------------------------------------------
 17100                                  
 17101                                  NEW_RENAME:
 17102                                  	; 17/05/2019 - Retro DOS v4.0
 17103                                  NEWNAM:
 17104                                  	; DOSCODE:680Eh (MSDOS 6.21, MSDOS.SYS)
 17105 00002936 AC                      	LODSB
 17106 00002937 3C3F                    	CMP	AL,"?" ; 3Fh
 17107 00002939 7502                    	JNZ	short NOCHG
 17108 0000293B 8A07                    	MOV	AL,[BX] 		; Get replace char
 17109                                  NOCHG:
 17110 0000293D AA                      	STOSB
 17111 0000293E 43                      	INC	BX			; Next replace char
 17112 0000293F E2F5                    	LOOP	NEWNAM
 17113                                  	; MSDOS 6.0
 17114                                  gs_ret_label:	; 18/12/2022
 17115 00002941 C3                      	retn
 17116                                  
 17117                                  ;============================================================================
 17118                                  ; FINFO.ASM, MSDOS 6.0, 1991
 17119                                  ;============================================================================
 17120                                  ; 08/08/2018 - Retro DOS v3.0
 17121                                  ; 17/05/2019 - Retro DOS v4.0
 17122                                  
 17123                                  ;**	Low level routines for returning file information and setting file
 17124                                  ;	attributes
 17125                                  ;
 17126                                  ;	GET_FILE_INFO
 17127                                  ;	SET_FILE_ATTRIBUTE
 17128                                  ;
 17129                                  ;	Modification history:
 17130                                  ;
 17131                                  ;	    Created: ARR 30 March 1983
 17132                                  ;
 17133                                  ;	M025: Return access_denied if attempting to set
 17134                                  ;	      attribute of root directory.
 17135                                  ;
 17136                                  
 17137                                  ;SUBTTL GET_FILE_INFO -- Get File Information
 17138                                  
 17139                                  ;---------------------------------------------------------------------------
 17140                                  ; Procedure Name : GET_FILE_INFO
 17141                                  ;
 17142                                  ; Inputs:
 17143                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17144                                  ;		terminated)
 17145                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17146                                  ;		( = -1 if current dir not involved, else
 17147                                  ;		 Points to first char after last "/" of current dir part)
 17148                                  ;	[THISCDS] Points to CDS being used
 17149                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17150                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 17151                                  ; Function:
 17152                                  ;	Get Information about a file
 17153                                  ; Returns:
 17154                                  ;	CARRY CLEAR
 17155                                  ;	    AX = Attribute of file
 17156                                  ;	    CX = Time stamp of file
 17157                                  ;	    DX = Date stamp of file
 17158                                  ;	    BX:DI = Size of file (32 bit)
 17159                                  ;	CARRY SET
 17160                                  ;	    AX is error code
 17161                                  ;		error_file_not_found
 17162                                  ;			Last element of path not found
 17163                                  ;		error_path_not_found
 17164                                  ;			Bad path (not in curr dir part if present)
 17165                                  ;		error_bad_curr_dir
 17166                                  ;			Bad path in current directory part of path
 17167                                  ; DS preserved, others destroyed
 17168                                  ;---------------------------------------------------------------------------
 17169                                  
 17170                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17171                                  
 17172                                  GET_FILE_INFO:
 17173                                  
 17174                                  ;hkn; get_file_info is called from file.asm and fcbio.asm. DS has been set 
 17175                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 17176                                  
 17177 00002942 E806E9                  	call	TestNet
 17178 00002945 7306                    	JNC	short LOCAL_INFO
 17179                                  
 17180                                  ;IF NOT Installed
 17181                                  ;	transfer NET_GET_FILE_INFO
 17182                                  ;ELSE
 17183                                  ;	MOV	AX,(MultNET SHL 8) OR 15
 17184                                  ;	INT	2FH
 17185                                  ;	return
 17186                                  
 17187 00002947 B80F11                  	mov     ax, 110Fh
 17188 0000294A CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
 17189                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 17190                                  			; SDA CDS pointer -> current directory
 17191                                  			; Return: CF set on error, AX = file attributes
 17192 0000294C C3                      	retn
 17193                                  ;ENDIF
 17194                                  
 17195                                  LOCAL_INFO:
 17196 0000294D E8BDE9                  	call	ECritDisk
 17197 00002950 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 17198                                  	; MSDOS 3.3
 17199                                  	;call	GETPATH
 17200                                  	; MSDOS 6.0
 17201 00002955 E8D800                  	call	GET_FAST_PATH
 17202                                  	; MSDOS 3.3 & MSDOS 6.0
 17203 00002958 7312                    	JNC	short info_check_dev
 17204                                  NO_PATH:
 17205 0000295A 750B                    	JNZ	short bad_path1
 17206 0000295C 08C9                    	OR	CL,CL
 17207 0000295E 7407                    	JZ	short bad_path1
 17208                                  info_no_file:
 17209 00002960 B80200                  	MOV	AX,error_file_not_found
 17210                                  BadRet:
 17211 00002963 F9                      	STC
 17212                                  JustRet:
 17213                                  	;call	LCritDisk
 17214                                  	;retn
 17215                                  	; 18/12/2022
 17216 00002964 E9C1E9                  	jmp	LCritDisk
 17217                                  
 17218                                  bad_path1:
 17219 00002967 B80300                  	MOV	AX,error_path_not_found
 17220 0000296A EBF7                    	jmp	short BadRet
 17221                                  
 17222                                  info_check_dev:
 17223 0000296C 08E4                    	OR	AH,AH
 17224 0000296E 78F0                    	JS	short info_no_file	; device
 17225                                  
 17226                                  	; MSDOS 6.0
 17227                                  ;SR;
 17228                                  ; If root dir then CurBuf == -1. Check for this case and return subdir attr
 17229                                  ;for a root dir
 17230                                  
 17231 00002970 833E[E205]FF            	cmp	word [CURBUF],-1	;is it a root dir?
 17232 00002975 7506                    	jne	short not_root		;no, CurBuf ptr is valid
 17233                                  
 17234 00002977 30E4                    	xor	ah,ah
 17235 00002979 B010                    	mov	al,attr_directory ; 10h
 17236                                  	;clc
 17237                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17238                                  	; (DOSCODE:683Eh)
 17239                                  	; 16/12/2022
 17240                                  	;clc
 17241 0000297B EBE7                    	jmp	short JustRet
 17242                                  
 17243                                  not_root:
 17244                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17245 0000297D 1E                      	PUSH	DS
 17246 0000297E 8E1E[E405]              	MOV	DS,[CURBUF+2]
 17247 00002982 89DE                    	MOV	SI,BX
 17248 00002984 31DB                    	XOR	BX,BX			; Assume size=0 (dir)
 17249 00002986 89DF                    	MOV	DI,BX
 17250                                  	;mov	cx,[si+16h]
 17251 00002988 8B4C16                  	MOV	CX,[SI+dir_entry.dir_time]
 17252                                  	;mov	dx,[si+18h]
 17253 0000298B 8B5418                  	MOV	DX,[SI+dir_entry.dir_date]
 17254 0000298E 30E4                    	XOR	AH,AH
 17255                                  	;mov	al,[si+0Bh]
 17256 00002990 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 17257                                  	;test	al,10h
 17258 00002993 A810                    	TEST	AL,attr_directory
 17259 00002995 7506                    	JNZ	short NO_SIZE
 17260                                  	;mov	di,[si+1Ch]
 17261 00002997 8B7C1C                  	MOV	DI,[SI+dir_entry.dir_size_l]
 17262                                  	;mov	bx,[si+1Eh]
 17263 0000299A 8B5C1E                  	MOV	BX,[SI+dir_entry.dir_size_h]
 17264                                  NO_SIZE:
 17265 0000299D 1F                      	POP	DS
 17266                                  	;CLC
 17267                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17268                                  	; (DOSCODE:6864h)
 17269                                  	; 16/12/2022
 17270                                  	;clc
 17271 0000299E EBC4                    	jmp	short JustRet
 17272                                  
 17273                                  ;Break	<SET_FILE_ATTRIBUTE -- Set File Attribute>
 17274                                  ;-------------------------------------------------------------------------------
 17275                                  ; Procedure Name : SET_FILE_ATTRIBUTE
 17276                                  ; Inputs:
 17277                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17278                                  ;		terminated)
 17279                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17280                                  ;		( = -1 if current dir not involved, else
 17281                                  ;		 Points to first char after last "/" of current dir part)
 17282                                  ;	[THISCDS] Points to CDS being used
 17283                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17284                                  ;	[SATTRIB] is attribute of search (determines what files may be found)
 17285                                  ;	AX is new attributes to give to file
 17286                                  ; Function:
 17287                                  ;	Set File Attributes
 17288                                  ; Returns:
 17289                                  ;	CARRY CLEAR
 17290                                  ;	    No error
 17291                                  ;	CARRY SET
 17292                                  ;	    AX is error code
 17293                                  ;		error_file_not_found
 17294                                  ;			Last element of path not found
 17295                                  ;		error_path_not_found
 17296                                  ;			Bad path (not in curr dir part if present)
 17297                                  ;		error_bad_curr_dir
 17298                                  ;			Bad path in current directory part of path
 17299                                  ;		error_access_denied
 17300                                  ;			Attempt to set an attribute which cannot be set
 17301                                  ;			(attr_directory, attr_volume_ID)
 17302                                  ;		error_sharing_violation
 17303                                  ;			Sharing mode of file did not allow the change
 17304                                  ;			(this request requires exclusive write/read access)
 17305                                  ;			(INT 24H generated)
 17306                                  ; DS preserved, others destroyed
 17307                                  ;----------------------------------------------------------------------------
 17308                                  
 17309                                  SET_FILE_ATTRIBUTE:
 17310                                  
 17311                                  ;hkn; set_file_attr is called from file.asm. DS has been set 
 17312                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 17313                                  
 17314 000029A0 A9D8FF                  	TEST	AX,~attr_changeable ; 0FFD8h
 17315 000029A3 7414                    	JZ	short set_look
 17316                                  _BAD_ACC:
 17317 000029A5 C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
 17318 000029AA C606[2703]07            	MOV	byte [EXTERR_CLASS],errCLASS_Apperr ; 7
 17319 000029AF C606[2603]04            	MOV	byte [EXTERR_ACTION],errACT_Abort ; 4
 17320 000029B4 B80500                  	MOV	AX,error_access_denied ; 5
 17321 000029B7 F9                      	STC
 17322 000029B8 C3                      	retn
 17323                                  
 17324                                  set_look:
 17325 000029B9 E88FE8                  	call	TestNet
 17326 000029BC 7308                    	JNC	short LOCAL_SET
 17327                                  
 17328                                  ;IF NOT Installed
 17329                                  ;	transfer NET_SEQ_SET_FILE_ATTRIBUTE
 17330                                  ;ELSE
 17331 000029BE 50                      	PUSH	AX
 17332                                  	
 17333                                  	;MOV	AX,(MultNET SHL 8) OR 14
 17334                                  	;INT	2FH
 17335                                  
 17336 000029BF B80E11                  	mov     ax, 110Eh
 17337 000029C2 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
 17338                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 17339                                  			; SDA CDS pointer -> current directory
 17340                                  			; STACK: WORD new file attributes
 17341                                  			; Return: CF set on error
 17342                                  
 17343 000029C4 5B                      	POP	BX			; clean stack
 17344 000029C5 C3                      	retn
 17345                                  ;ENDIF
 17346                                  
 17347                                  LOCAL_SET:
 17348 000029C6 E844E9                  	call	ECritDisk
 17349 000029C9 50                      	PUSH	AX			; Save new attributes
 17350 000029CA C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 17351 000029CF E85515                  	call	GETPATH 		; get path through fastopen if there	;AC000;
 17352 000029D2 7303                    	JNC	short set_check_device
 17353 000029D4 5B                      	POP	BX			; Clean stack (don't zap AX)
 17354 000029D5 EB83                    	JMP	short NO_PATH
 17355                                  
 17356                                  set_check_device:
 17357 000029D7 08E4                    	OR	AH,AH
 17358 000029D9 7906                    	JNS	short set_check_share
 17359 000029DB 58                      	POP	AX
 17360 000029DC E849E9                  	call	LCritDisk
 17361 000029DF EBC4                    	JMP	short _BAD_ACC 		; device
 17362                                  
 17363                                  set_check_share:
 17364 000029E1 58                      	POP	AX			; Get new attributes
 17365                                  
 17366                                  	; MSDOS 6.0
 17367 000029E2 833E[E205]FF            	cmp	word [CURBUF], -1	; M025: Q: is this the root dir
 17368 000029E7 740A                    	je	short cannot_set_root	; M025: Y: return error
 17369                                  
 17370                                  	; MSDOS 3.3 & MSDOS 6.0
 17371 000029E9 E878FC                  	call	REN_DEL_Check
 17372 000029EC 730B                    	JNC	short set_do
 17373 000029EE B82000                  	MOV	AX,error_sharing_violation ; 32
 17374 000029F1 EB3A                    	jmp	short OK_BYE
 17375                                  
 17376                                  	; MSDOS 6.0
 17377                                  cannot_set_root:			; M025:
 17378 000029F3 B80500                  	mov	ax,error_access_denied	; M025: return error is attempting
 17379 000029F6 F9                      	stc				; M025: to set attr. of root
 17380 000029F7 EB34                    	jmp	short OK_BYE		; M025:
 17381                                  
 17382                                  set_do:
 17383                                  	; MSDOS 3.3 & MSDOS 6.0
 17384 000029F9 C43E[E205]              	LES	DI,[CURBUF]
 17385 000029FD 2680670BD8              	AND	BYTE [ES:BX+dir_entry.dir_attr],~attr_changeable ; 0D8h
 17386 00002A02 2608470B                	OR	BYTE [ES:BX+dir_entry.dir_attr],AL
 17387                                  
 17388                                  	; MSDOS 6.0
 17389 00002A06 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 17390                                  					;LB. if already dirty		  ;AN000;
 17391 00002A0B 7508                    	JNZ	short yesdirty3		;LB.  don't increment dirty count ;AN000;
 17392 00002A0D E84931                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 17393                                  	
 17394 00002A10 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 17395                                  yesdirty3:
 17396 00002A15 A0[7605]                	MOV	AL,[THISDRV]
 17397                                  ;;;; 10/1/86 F.C update fastopen cache
 17398 00002A18 52                      	PUSH	DX
 17399 00002A19 57                      	PUSH	DI
 17400 00002A1A B400                    	MOV	AH,0		  ; dir entry update
 17401 00002A1C 88C2                    	MOV	DL,AL		  ; drive number A=0,B=1,,
 17402 00002A1E 89DF                    	MOV	DI,BX		  ; ES:DI -> dir entry
 17403 00002A20 E8DEFC                  	call	FastOpen_Update
 17404 00002A23 5F                      	POP	DI
 17405 00002A24 5A                      	POP	DX
 17406                                  ;;;; 9/11/86 F.C update fastopen cache
 17407 00002A25 E82C30                  	call	FLUSHBUF
 17408 00002A28 7303                    	JNC	short OK_BYE
 17409 00002A2A B80200                  	MOV	AX,error_file_not_found
 17410                                  OK_BYE:
 17411                                  	;call	LCritDisk
 17412                                  	;retn
 17413                                  	; 16/12/2022
 17414 00002A2D E9F8E8                  	jmp	LCritDisk
 17415                                  
 17416                                  	; 17/05/2019 - Retro DOS v4.0
 17417                                  
 17418                                  	; MSDOS 6.0
 17419                                  GET_FAST_PATH:
 17420                                  ;hkn; use SS override for FastOpenFlg
 17421 00002A30 36800E[3A0D]01          	OR	byte [ss:FastOpenFlg],FastOpen_Set
 17422                                  					;FO. trigger fastopen	;AN000;
 17423 00002A36 E8EE14                  	call	GETPATH
 17424 00002A39 9C                      	PUSHF			 	;FO.			;AN000;
 17425 00002A3A 368026[3A0D]80          	AND	byte [ss:FastOpenFlg],Fast_yes 
 17426                                  					;FO. clear all fastopen flags ;AN000;
 17427 00002A40 9D                      	POPF				;FO.			;AN000;
 17428 00002A41 C3                      	retn
 17429                                  
 17430                                  ;============================================================================
 17431                                  ; DUP.ASM, MSDOS 6.0, 1991
 17432                                  ;============================================================================
 17433                                  ; 08/08/2018 - Retro DOS v3.0
 17434                                  ; 17/05/2019 - Retro DOS v4.0
 17435                                  
 17436                                  ;** 	Low level DUP routine for use by EXEC when creating a new process.
 17437                                  ;   	Exports the DUP to the server machine and increments the SFT ref count
 17438                                  ;
 17439                                  ;	DOS_DUP
 17440                                  ;
 17441                                  ;	Modification history:
 17442                                  ;
 17443                                  ;	  Created: ARR 30 March 1983
 17444                                  
 17445                                  ;BREAK <DOS_DUP -- DUP SFT across network>
 17446                                  ;---------------------------------------------------------------------------
 17447                                  ; Procedure Name : DOS_DUP
 17448                                  ;
 17449                                  ; Inputs:
 17450                                  ;	[THISSFT] set to the SFT for the file being DUPed
 17451                                  ;		(a non net SFT is OK, in this case the ref
 17452                                  ;		 count is simply incremented)
 17453                                  ; Function:
 17454                                  ;	Signal to the devices that a logical open is occurring
 17455                                  ; Returns:
 17456                                  ;	ES:DI point to SFT
 17457                                  ;    Carry clear
 17458                                  ;	SFT ref_count is incremented
 17459                                  ; Registers modified: None.
 17460                                  ; NOTE:
 17461                                  ;	This routine is called from $CREATE_PROCESS_DATA_BLOCK at DOSINIT
 17462                                  ;	time with SS NOT DOSGROUP. There will be no Network handles at
 17463                                  ;	that time.
 17464                                  ;---------------------------------------------------------------------------
 17465                                  
 17466                                  DOS_DUP:
 17467                                  	;LES	DI,[CS:THISSFT]  ; MSDOS 3.3
 17468                                  
 17469                                  	; MSDOS 6.0
 17470 00002A42 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 17471 00002A47 26C43E[9E05]            	les	di,[es:THISSFT]
 17472                                  
 17473                                  	;Entry	Dos_Dup_Direct
 17474                                  DOS_Dup_Direct:
 17475 00002A4C E815E8                  	call	IsSFTNet
 17476 00002A4F 7503                    	JNZ	short DO_INC
 17477 00002A51 E8A01B                  	call	DEV_OPEN_SFT
 17478                                  DO_INC:
 17479                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 17480 00002A54 26FF05                  	inc	word [ES:DI]		; Clears carry (if this ever wraps
 17481                                  					;   we're in big trouble anyway)
 17482 00002A57 C3                      	retn
 17483                                  
 17484                                  ;============================================================================
 17485                                  ; CREATE.ASM, MSDOS 6.0, 1991
 17486                                  ;============================================================================
 17487                                  ; 08/08/2018 - Retro DOS v3.0
 17488                                  ; 18/05/2019 - Retro DOS v4.0
 17489                                  
 17490                                  ;TITLE	DOS_CREATE/DOS_CREATE_NEW - Internal CREATE calls for MS-DOS
 17491                                  ;NAME	DOS_CREATE
 17492                                  ;----------------------------------------------------------------------------
 17493                                  ;**	Internal Create and Create new to create a local or NET file and SFT.
 17494                                  ;
 17495                                  ;	DOS_CREATE
 17496                                  ;	DOS_CREATE_NEW
 17497                                  ;	SET_MKND_ERR
 17498                                  ;	SET_Media_ID
 17499                                  ;	SET_EXT_Mode
 17500                                  ;
 17501                                  ;	Revision history:
 17502                                  ;
 17503                                  ;	    A000 version 4.00	  Jan. 1988
 17504                                  ;	    A001  D490 -- Change IOCTL subfunctios from 63h,43h to 66h, 46h
 17505                                  
 17506                                  ;Installed = TRUE
 17507                                  
 17508                                  ;	i_need	THISSFT,DWORD
 17509                                  ;	i_need	THISCDS,DWORD
 17510                                  ;	I_need	EXTERR,WORD
 17511                                  ;	I_Need	ExtErr_locus,BYTE
 17512                                  ;	I_need	JShare,DWORD
 17513                                  ;	I_need	VOLCHNG_FLAG,BYTE
 17514                                  ;	I_need	SATTRIB,BYTE
 17515                                  ;	I_need	CALLVIDM,DWORD
 17516                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000; extended open
 17517                                  ;	I_need	NAME1,BYTE			  ;AN000;
 17518                                  ;	I_need	NO_NAME_ID,BYTE 		  ;AN000;
 17519                                  ;	I_need	Packet_Temp,WORD		  ;AN000;
 17520                                  ;	I_need	DOS34_FLAG,WORD 		  ;AN000;
 17521                                  ;	I_need	SAVE_BX,WORD			  ;AN000;
 17522                                  
 17523                                  ;***	DOS_CREATE - Create a File
 17524                                  ;----------------------------------------------------------------------------
 17525                                  ;	DOS_Create is called to create the specified file, truncating
 17526                                  ;	the old one if it exists.
 17527                                  ;
 17528                                  ;	ENTRY	AX is Attribute to create
 17529                                  ;		(ds) = DOSDATA
 17530                                  ;		[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17531                                  ;			terminated)
 17532                                  ;		[CURR_DIR_END] Points to end of Current dir part of string
 17533                                  ;			( = -1 if current dir not involved, else
 17534                                  ;			 Points to first char after last "/" of current dir part)
 17535                                  ;		[THISCDS] Points to CDS being used
 17536                                  ;			(Low word = -1 if NUL CDS (Net direct request))
 17537                                  ;		[THISSFT] Points to SFT to fill in if file created
 17538                                  ;			(sf_mode field set so that FCB may be detected)
 17539                                  ;		[SATTRIB] Is attribute of search, determines what files can be found
 17540                                  ;
 17541                                  ;	EXIT	sf_ref_count is NOT altered
 17542                                  ;		CARRY CLEAR
 17543                                  ;		    THISSFT filled in.
 17544                                  ;			sf_mode = unchanged for FCB, sharing_compat + open_for_both
 17545                                  ;		CARRY SET
 17546                                  ;		    AX is error code
 17547                                  ;			error_path_not_found
 17548                                  ;				Bad path (not in curr dir part if present)
 17549                                  ;			error_bad_curr_dir
 17550                                  ;				Bad path in current directory part of path
 17551                                  ;			error_access_denied
 17552                                  ;				Attempt to re-create read only file , or
 17553                                  ;				create a second volume id or create a dir
 17554                                  ;			error_sharing_violation
 17555                                  ;				The sharing mode was correct but not allowed
 17556                                  ;				generates an INT 24
 17557                                  ;	USES	all but DS
 17558                                  ;----------------------------------------------------------------------------
 17559                                  
 17560                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17561                                  	; DOSCODE:6920h (MSDOS 5.0, MSDOS.SYS)
 17562                                  
 17563                                  DOS_CREATE:
 17564                                  	; 18/05/2019 - Retro DOS v4.0
 17565                                  	; DOSCODE:6934h (MSDOS 6.21, MSDOS.SYS)
 17566                                  
 17567                                  ;hkn; dispatched to from file.asm and fcbio.asm. DS set up to DOSDATA at 
 17568                                  ;hkn; this point.
 17569                                  
 17570 00002A58 30E4                    	XOR	AH,AH		; Truncate is OK
 17571                                  
 17572                                  ;	Enter here from Dos_Create_New
 17573                                  ;
 17574                                  ;	(ah) = 0 iff truncate OK
 17575                                  
 17576                                  Create_inter:
 17577 00002A5A A8C0                    	TEST	AL,~(attr_all+attr_ignore+attr_volume_id) ; 80h
 17578                                  				; Mask out any meaningless bits
 17579 00002A5C 7511                    	JNZ	short AttErr
 17580 00002A5E A808                    	TEST	AL,attr_volume_id
 17581 00002A60 7407                    	JZ	short NoReset
 17582                                  	
 17583                                  	; MSDOS 6.0
 17584                                  	; 16/12/2022
 17585 00002A62 800E[1106]80            	OR	byte [DOS34_FLAG],DBCS_VOLID ; 80h ;AN000;FOR dbcs volid
 17586                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17587                                  	;or	word [DOS34_FLAG],DBCS_VOLID ; 80h 
 17588                                  	
 17589 00002A67 B008                    	MOV	AL,attr_volume_id ; 8
 17590                                  NoReset:
 17591 00002A69 0C20                    	OR	AL,attr_archive ; File changed  ; 20 h
 17592 00002A6B A850                    	TEST	AL,attr_directory+attr_device ; 50h
 17593 00002A6D 740A                    	JZ	short ATT_OK
 17594                                  AttErr:
 17595 00002A6F B80500                  	MOV	AX,5		; Attribute problem
 17596 00002A72 C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
 17597 00002A77 EB66                    	JMP	SHORT SET_MKND_ERR ; Gotta use MKDIR to make dirs, NEVER allow
 17598                                  				   ;	attr_device to be set.
 17599                                  ATT_OK:
 17600 00002A79 C43E[9E05]              	LES	DI,[THISSFT]
 17601 00002A7D 06                      	PUSH	ES
 17602 00002A7E C436[A205]              	LES	SI,[THISCDS]
 17603 00002A82 83FEFF                  	CMP	SI,-1
 17604 00002A85 751D                    	JNE	short TEST_RE_NET
 17605                                  
 17606                                  ;	No CDS, it must be redirected.
 17607                                  
 17608 00002A87 07                      	POP	ES
 17609                                  
 17610                                  	; MSDOS 6.0
 17611                                  ;Extended open hooks
 17612                                  	;test	byte [EXTOPEN_ON],1
 17613 00002A88 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 17614 00002A8D 740D                    	JZ	short NOEXTOP 		    ;AN000;EO. no, do normal
 17615                                  IFS_extopen:				    ;AN000;EO.
 17616 00002A8F 50                      	PUSH	AX			    ;AN000;EO. pass create attr
 17617                                  	;MOV	AX,(MultNET SHL 8) OR 46    ;AN000;EO. issue extended open verb
 17618 00002A90 B82E11                  	mov	ax,112Eh
 17619 00002A93 CD2F                    	INT	2FH			    ;AN000;EO.
 17620 00002A95 5B                      	POP	BX			    ;AN000;EO. trash bx
 17621 00002A96 C606[F605]00            	MOV	byte [EXTOPEN_ON],0	    ;AN000;EO.
 17622 00002A9B C3                      	retn				    ;AN000;EO.
 17623                                  NOEXTOP:				    ;AN000;
 17624                                  ;Extended open hooks
 17625                                  
 17626                                  ;IF NOT Installed
 17627                                  ;	transfer NET_SEQ_CREATE
 17628                                  ;ELSE
 17629 00002A9C 50                      	PUSH	AX
 17630                                  
 17631                                  	;MOV	AX,(MultNET SHL 8) OR 24
 17632                                  	;INT	2FH
 17633                                  
 17634 00002A9D B81811                  	mov     ax,1118h
 17635 00002AA0 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
 17636                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 17637                                  			; SDA first filename pointer -> fully-qualified name of file
 17638                                  			; STACK: WORD file creation mode???
 17639                                  
 17640 00002AA2 5B                      	POP	BX			; BX is trashed anyway
 17641 00002AA3 C3                      	retn
 17642                                  ;ENDIF
 17643                                  
 17644                                  ;	We have a CDS. See if it's network
 17645                                  
 17646                                  TEST_RE_NET:
 17647                                  	;;test	word [es:si+43h],8000h
 17648                                  	;TEST	word [ES:SI+curdir.flags],curdir_isnet
 17649                                  	; 07/12/2022
 17650                                  	;test	byte [es:si+44h],80h
 17651                                  	; 17/12/2022
 17652 00002AA4 26F6444480              	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
 17653 00002AA9 07                      	POP	ES
 17654 00002AAA 7419                    	JZ	short LOCAL_CREATE
 17655                                  
 17656                                  	; MSDOS 6.0
 17657 00002AAC E8BF00                  	CALL	Set_EXT_mode		    ;AN000;EO.
 17658 00002AAF 7205                    	JC	SHORT dochk		    ;AN000;EO.
 17659                                  	;;or	word [es:di+2],2
 17660                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 17661                                  	; 17/12/2022
 17662 00002AB1 26804D0202              	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 17663                                  
 17664                                  ;Extended open hooks
 17665                                  dochk:
 17666 00002AB6 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 17667 00002ABB 75D2                    	JNZ	short IFS_extopen	    ;AN000;EO. yes, issue extended open
 17668                                  ;Extended open hooks
 17669                                  
 17670                                  ;IF NOT Installed
 17671                                  ;	transfer NET_CREATE
 17672                                  ;ELSE
 17673 00002ABD 50                      	PUSH	AX
 17674                                  	
 17675                                  	;MOV	AX,(MultNET SHL 8) OR 23
 17676                                  	;INT	2FH
 17677                                  	
 17678 00002ABE B81711                  	mov     ax,1117h
 17679 00002AC1 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
 17680                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 17681                                  			; SDA first filename pointer -> fully-qualified name of file to open
 17682                                  			; SDA CDS pointer -> current directory
 17683                                  			; Return: CF set on error
 17684                                  
 17685 00002AC3 5B                      	POP	BX			; BX is trashed anyway
 17686                                  ;nomore:
 17687 00002AC4 C3                      	retn
 17688                                  ;ENDIF
 17689                                  
 17690                                  ;**	It's a local create. We have a local CDS for it.
 17691                                  
 17692                                  LOCAL_CREATE:
 17693                                  	; MSDOS 6.0
 17694 00002AC5 E8A600                  	CALL	Set_EXT_mode	;AN000;EO. set mode if from extended open
 17695 00002AC8 7205                    	JC	short setdone	;AN000;EO.
 17696                                  	
 17697                                  	; MSDOS 3.3 & MSDOS 6.0
 17698                                  	; 17/12/2022
 17699                                  	;;or	word [es:di+2],2
 17700                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 17701                                  	;or	byte [es:di+2],2
 17702 00002ACA 26804D0202              	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both	
 17703                                  setdone:
 17704 00002ACF E83BE8                  	call	ECritDisk
 17705 00002AD2 E8BE1E                  	call	MakeNode
 17706 00002AD5 7317                    	JNC	short Create_ok
 17707 00002AD7 C606[A10A]FF            	mov	byte [VOLCHNG_FLAG],-1	; indicate no change in volume label
 17708 00002ADC E849E8                  	call	LCritDisk
 17709                                  
 17710                                  	;entry	SET_MKND_ERR
 17711                                  SET_MKND_ERR:
 17712                                  
 17713                                  ;	Looks up MakeNode errors and converts them. AL is MakeNode
 17714                                  ;	error, SI is GETPATH bad spot return if path_not_found error.
 17715                                  
 17716                                  ;hkn; CRTERRTAB is in TABLE seg (DOSCODE)
 17717 00002ADF BB[E62A]                	MOV     BX,CRTERRTAB
 17718                                  	;XLAT  ; MSDOS 3.3
 17719                                  	; 18/05/2019 - Retro DOS v4.0
 17720 00002AE2 2E                      	CS
 17721 00002AE3 D7                      	XLAT
 17722                                  CreatBadRet:
 17723 00002AE4 F9                      	STC
 17724 00002AE5 C3                      	retn
 17725                                  
 17726                                  ; 13/05/2019 - Retro DOS v4.0
 17727                                  ; DOSCODE:69C4h (MSDOS 6.21, MSDOS.SYS)
 17728                                  ; ---------------------------------------------------------------------------
 17729                                  
 17730                                  ;** Internal Create and Create new to create a local or NET file and SFT.
 17731                                  
 17732                                  ; 17/07/2018 - Retro DOS v3.0
 17733                                  ; Offset 12B1h of IBMDOS.COM (MSDOS 3.3), 1987
 17734                                  
 17735                                  ;CRTERRTAB: ; 19/07/2018 - MSDOS 3.3	
 17736                                  ;	db	0,5,52h,50h,3,5,20h
 17737                                  
 17738                                  ;CRTERRTAB: ; 18/05/2019 - MSDOS 6.0	
 17739                                  ;	db	0,5,52h,50h,3,5,20h,2
 17740                                  
 17741                                  ; 08/08/2018
 17742                                  
 17743                                  CRTERRTAB:	;LABEL BYTE	; Lookup table for MakeNode returns
 17744 00002AE6 00                      	DB	0			; none
 17745 00002AE7 05                      	DB	error_access_denied	; MakeNode error 1
 17746 00002AE8 52                      	DB	error_cannot_make	; MakeNode error 2
 17747 00002AE9 50                      	DB	error_file_exists	; MakeNode error 3
 17748 00002AEA 03                      	DB	error_path_not_found	; MakeNode error 4
 17749 00002AEB 05                      	DB	error_access_denied	; MakeNode error 5
 17750 00002AEC 20                      	DB	error_sharing_violation ; MakeNode error 6
 17751                                  	; MSDOS 6.0
 17752 00002AED 02                      	DB	error_file_not_found	; MakeNode error 7
 17753                                  
 17754                                  ; ---------------------------------------------------------------------------
 17755                                  
 17756                                  ; We have just created a new file. This results in the truncation of old
 17757                                  ; files. We must inform the sharer to slash all the open SFT's for this
 17758                                  ; file to the current size.
 17759                                  
 17760                                  ; If we created a volume id on the diskette, set the VOLCHNG_FLAG to logical
 17761                                  ; drive number to force a Build BPB after Media Check.
 17762                                  
 17763                                  ;;; FASTOPEN 8/29/86
 17764                                  Create_ok:
 17765 00002AEE E8E1FB                  	call	FastOpen_Delete
 17766                                  ;;; FASTOPEN 8/29/86
 17767 00002AF1 A0[6D05]                	mov	al,[SATTRIB]
 17768 00002AF4 A808                    	test	al,attr_volume_id
 17769 00002AF6 741C                    	jz	short NoVolLabel
 17770 00002AF8 C43E[A205]              	LES	DI,[THISCDS]
 17771                                  	;mov	ah,[ES:DI+curdir.text]	; get drive letter
 17772 00002AFC 268A25                  	mov	ah,[ES:DI] ; 09/08/2018
 17773 00002AFF 80EC41                  	sub	ah,'A'	; 41h		; convert to drive number
 17774 00002B02 8826[A10A]              	mov	[VOLCHNG_FLAG],ah	;Set flag to indicate volid change
 17775                                  	
 17776                                  	; 18/05/2019 - Retro DOS v4.0
 17777                                  
 17778                                  	; MSDOS 6.0
 17779 00002B06 B701                    	MOV	BH,1			;AN000;>32mb set volume id to boot record
 17780 00002B08 E81F00                  	CALL	Set_Media_ID		;AN000;>32mb
 17781                                  	
 17782 00002B0B E8FFE7                  	call	ECritDisk
 17783 00002B0E E8CA2B                  	call	FATREAD_CDS		; force a media check
 17784 00002B11 E814E8                  	call	LCritDisk
 17785                                  
 17786                                  NoVolLabel:
 17787 00002B14 B80200                  	MOV	ax,2
 17788 00002B17 C43E[9E05]              	LES	DI,[THISSFT]
 17789                                  ;if installed
 17790                                  	;call	JShare + 14 * 4
 17791 00002B1B FF1E[C800]              	call	far [JShare+(14*4)] ; 14 = ShSU
 17792                                  ;else
 17793                                  ;	Call	ShSU
 17794                                  ;endif
 17795 00002B1F E806E8                  	call	LCritDisk
 17796 00002B22 E94901                  	jmp	SET_SFT_MODE
 17797                                  
 17798                                  ;---------------------------------------------------------------------------
 17799                                  ; Procedure Name : Dos_Create_New
 17800                                  ;
 17801                                  ; Inputs:
 17802                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17803                                  ;		terminated)
 17804                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17805                                  ;		( = -1 if current dir not involved, else
 17806                                  ;		 Points to first char after last "/" of current dir part)
 17807                                  ;	[THISCDS] Points to CDS being used
 17808                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17809                                  ;	[THISSFT] Points to SFT to fill in if file created
 17810                                  ;		(sf_mode field set so that FCB may be detected)
 17811                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 17812                                  ;	AX is Attribute to create
 17813                                  ; Function:
 17814                                  ;	Try to create the specified file truncating an old one that exists
 17815                                  ; Outputs:
 17816                                  ;	sf_ref_count is NOT altered
 17817                                  ;	CARRY CLEAR
 17818                                  ;	    THISSFT filled in.
 17819                                  ;		sf_mode = sharing_compat + open_for_both for Non-FCB SFT
 17820                                  ;	CARRY SET
 17821                                  ;	    AX is error code
 17822                                  ;		error_path_not_found
 17823                                  ;			Bad path (not in curr dir part if present)
 17824                                  ;		error_bad_curr_dir
 17825                                  ;			Bad path in current directory part of path
 17826                                  ;		error_access_denied
 17827                                  ;			Create a second volume id or create a dir
 17828                                  ;		error_file_exists
 17829                                  ;			Already a file by this name
 17830                                  ; DS preserved, others destroyed
 17831                                  ;---------------------------------------------------------------------------
 17832                                  
 17833                                  DOS_Create_New:
 17834 00002B25 B401                    	MOV	AH,1		; Truncate is NOT OK
 17835 00002B27 E930FF                  	JMP	Create_inter
 17836                                  
 17837                                  ; MSDOS 6.0
 17838                                  ;---------------------------------------------------------------------------
 17839                                  ; Procedure Name : Set_Media_ID
 17840                                  ;
 17841                                  ; Inputs:
 17842                                  ;	NAME1= Volume ID
 17843                                  ;	BH= 0, delete volume id
 17844                                  ;	    1, set new volume id
 17845                                  ;	DS= DOSGROUP
 17846                                  ; Function:
 17847                                  ;	Set Volume ID to DOS 4.00 Boot record.
 17848                                  ; Outputs:
 17849                                  ;	CARRY CLEAR
 17850                                  ;	    volume id set
 17851                                  ;	CARRY SET
 17852                                  ;	    AX is error code
 17853                                  ;---------------------------------------------------------------------------
 17854                                  
 17855                                  	; 18/05/2019 - Retro DOS v4.0
 17856                                  Set_Media_ID:
 17857 00002B2A 50                      	PUSH	AX		;AN000;;>32mb
 17858 00002B2B 06                      	PUSH	ES		;AN000;;>32mb
 17859 00002B2C 57                      	PUSH	DI		;AN000;;>32mb
 17860                                  
 17861 00002B2D FEC4                    	INC	AH		;AN000;;>32mb  bl=drive #
 17862 00002B2F 88E3                    	MOV	BL,AH		;AN000;;>32mb  bl=drive # (A=1,B=2,,,)
 17863 00002B31 B00D                    	MOV	AL,0DH		;AN000;;>32mb  generic IOCTL
 17864 00002B33 B96608                  	MOV	CX,0866H	;AN001;;>32mb  get media id
 17865                                  
 17866                                  ;hkn; PACKET_TEMP is in DOSDATA
 17867 00002B36 BA[6C0D]                	MOV	DX,Packet_Temp	;AN000;>32mb
 17868                                  
 17869 00002B39 53                      	PUSH	BX		;AN000;;>32mb
 17870 00002B3A 52                      	PUSH	DX		;AN000;;>32mb
 17871 00002B3B 30FF                    	XOR	BH,BH		;AN000;;>32mb
 17872                                  
 17873                                  	;invoke	$IOCTL		;AN000;;>32mb
 17874 00002B3D E840F7                  	call	_$IOCTL	
 17875                                  
 17876 00002B40 5A                      	POP	DX		;AN000;;>32mb
 17877 00002B41 5B                      	POP	BX		;AN000;;>32mb
 17878 00002B42 7224                    	JC	short geterr	;AN000;;>32mb
 17879                                  
 17880 00002B44 08FF                    	OR	BH,BH		;AN000;;>32mb delete volume id
 17881 00002B46 7405                    	JZ	short NoName	;AN000;>32mb yes
 17882                                  
 17883                                  ;hkn; NAME1 is in DOSDATA
 17884 00002B48 BE[4B05]                	MOV	SI,NAME1	;AN000;>32mb
 17885                                  
 17886 00002B4B EB03                    	JMP	SHORT doset	;AN000;>32mb yes
 17887                                  NoName: 			;AN000;
 17888                                  
 17889                                  ;hkn; NO_NAME_ID is in DOSDATA
 17890 00002B4D BE[BA0D]                	MOV	SI,NO_NAME_ID	;AN000;>32mb
 17891                                  
 17892                                  doset:				;AN000;
 17893 00002B50 89D7                    	MOV	DI,DX		;AN000;;>32mb
 17894                                  	;add	di,6
 17895 00002B52 83C706                  	ADD	DI,MEDIA_ID_INFO.MEDIA_Label ;AN000;;>32mb
 17896                                  
 17897                                  ;hkn; ES & DS must point to SS
 17898                                  ;hkn;	PUSH	CS		;AN000;;>32mb  move new volume id to packet
 17899 00002B55 16                      	PUSH	SS		;AN000;;>32mb  move new volume id to packet
 17900                                  
 17901 00002B56 1F                      	POP	DS		;AN000;;>32mb
 17902                                  
 17903                                  ;hkn;	PUSH	CS		;AN000;;>32mb
 17904 00002B57 16                      	PUSH	SS		;AN000;;>32mb
 17905                                  
 17906 00002B58 07                      	POP	ES		;AN000;;>32mb
 17907 00002B59 B90B00                  	MOV	CX,11		;AN000;;>32mb
 17908 00002B5C F3A4                    	REP	MOVSB		;AN000;;>32mb
 17909 00002B5E B94608                  	MOV	CX,0846H	;AN001;;>32mb
 17910 00002B61 B00D                    	MOV	AL,0DH		;AN000;;>32mb
 17911 00002B63 30FF                    	XOR	BH,BH		;AN000;;>32mb
 17912                                  	;invoke	$IOCTL		;AN000;;>32mb  set volume id
 17913 00002B65 E818F7                  	call	_$IOCTL	
 17914                                  geterr: 			;AN000;
 17915                                  ;hkn;	PUSH	CS		;AN000;>32mb
 17916 00002B68 16                      	PUSH	SS		;AN000;>32mb
 17917                                  
 17918 00002B69 1F                      	POP	DS		;AN000;>32mb   ds= dosgroup
 17919                                  
 17920 00002B6A 5F                      	POP	DI		;AN000;;>32mb
 17921 00002B6B 07                      	POP	ES		;AN000;;>32mb
 17922 00002B6C 58                      	POP	AX		;AN000;;>32mb
 17923 00002B6D C3                      	retn			;AN000;>32mb
 17924                                  
 17925                                  ; MSDOS 6.0
 17926                                  ;---------------------------------------------------------------------------
 17927                                  ; Procedure Name : Set_EXT_mode
 17928                                  ;
 17929                                  ; Inputs:
 17930                                  ;	[EXTOPEN_ON]= flag for extended open
 17931                                  ;	SAVE_BX= mode specified in Extended Open
 17932                                  ; Function:
 17933                                  ;	Set mode in ThisSFT
 17934                                  ; Outputs:
 17935                                  ;	carry set,mode is set if from Extended Open
 17936                                  ;	carry clear, mode not set yet
 17937                                  ;---------------------------------------------------------------------------
 17938                                  
 17939                                  ; 13/05/2019 - Retro DOS v4.0
 17940                                  
 17941                                  Set_EXT_mode:
 17942                                  
 17943                                  ;hkn; SS override
 17944 00002B6E 36F606[F605]01          	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 17945 00002B74 740B                    	JZ	short NOTEX		    ;AN000;EO. no, do normal
 17946 00002B76 50                      	PUSH	AX			    ;AN000;EO.
 17947                                  
 17948                                  ;hkn; SS override
 17949 00002B77 36A1[0106]              	MOV	AX,[ss:SAVE_BX]		    ;AN000;EO.
 17950                                  	;or	[es:di+2],ax
 17951 00002B7B 26094502                	OR	[ES:DI+SF_ENTRY.sf_mode],AX ;AN000;EO.
 17952 00002B7F 58                      	POP	AX			    ;AN000;EO.
 17953 00002B80 F9                      	STC				    ;AN000;EO.
 17954                                  NOTEX:					    ;AN000;
 17955 00002B81 C3                      	retn				    ;AN000;EO.
 17956                                  
 17957                                  ;============================================================================
 17958                                  ; OPEN.ASM, MSDOS 6.0, 1991
 17959                                  ;============================================================================
 17960                                  ; 08/08/2018 - Retro DOS v3.0
 17961                                  ; 18/05/2019 - Retro DOS v4.0
 17962                                  
 17963                                  ;	TITLE	DOS_OPEN - Internal OPEN call for MS-DOS
 17964                                  ;	NAME	DOS_OPEN
 17965                                  
 17966                                  ;**	OPEN.ASM - File Open
 17967                                  ;----------------------------------------------------------------------------
 17968                                  ;	Low level routines for openning a file from a file spec.
 17969                                  ;	Also misc routines for sharing errors
 17970                                  ;
 17971                                  ;	DOS_Open
 17972                                  ;	Check_Access_AX
 17973                                  ;	SHARE_ERROR
 17974                                  ;	SET_SFT_MODE
 17975                                  ;	Code_Page_Mismatched_Error		   ; DOS 4.00
 17976                                  ;
 17977                                  ;	Revision history:
 17978                                  ;
 17979                                  ;	    Created: ARR 30 March 1983
 17980                                  ;	    A000	version 4.00   Jan. 1988
 17981                                  ;
 17982                                  ;	M034 - The value in save_bx must be pushed on to the stack for
 17983                                  ; 	       remote extended opens and not save_cx.
 17984                                  ;
 17985                                  ;	M035 - if open made from exec then we must set the appropriate bits
 17986                                  ;	       on the stack before calling off to the redir.
 17987                                  ;	M042 - Bit 11 of DOS34_FLAG set indicates that the redir knows how 
 17988                                  ;	       to handle open from exec. In this case set the appropriate bit
 17989                                  ;	       else do not.
 17990                                  ;----------------------------------------------------------------------------	
 17991                                  
 17992                                  ;Installed = TRUE
 17993                                  
 17994                                  ;	i_need	NoSetDir,BYTE
 17995                                  ;	i_need	THISSFT,DWORD
 17996                                  ;	i_need	THISCDS,DWORD
 17997                                  ;	i_need	CURBUF,DWORD
 17998                                  ;	i_need	CurrentPDB,WORD
 17999                                  ;	i_need	CURR_DIR_END,WORD
 18000                                  ;	I_need	RetryCount,WORD
 18001                                  ;	I_need	Open_Access,BYTE
 18002                                  ;	I_need	fSharing,BYTE
 18003                                  ;	i_need	JShare,DWORD
 18004                                  ;	I_need	FastOpenFlg,byte
 18005                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000;; DOS 4.00
 18006                                  ;	I_need	ALLOWED,BYTE			  ;AN000;; DOS 4.00
 18007                                  ;	I_need	EXTERR,WORD			  ;AN000;; DOS 4.00
 18008                                  ;	I_need	EXTERR_LOCUS,BYTE		  ;AN000;; DOS 4.00
 18009                                  ;	I_need	EXTERR_ACTION,BYTE		  ;AN000;; DOS 4.00
 18010                                  ;	I_need	EXTERR_CLASS,BYTE		  ;AN000;; DOS 4.00
 18011                                  ;	I_need	CPSWFLAG,BYTE			  ;AN000;; DOS 4.00
 18012                                  ;	I_need	EXITHOLD,DWORD			  ;AN000;; DOS 4.00
 18013                                  ;	I_need	THISDPB,DWORD			  ;AN000;; DOS 4.00
 18014                                  ;	I_need	SAVE_CX,WORD			  ;AN000;; DOS 4.00
 18015                                  ;	I_need	SAVE_BX,WORD			  ;M034
 18016                                  ;
 18017                                  ;	I_need	DOS_FLAG,BYTE
 18018                                  ;	I_need	DOS34_FLAG,WORD			  ;M042
 18019                                  
 18020                                  ;Break	<DOS_Open - internal file access>
 18021                                  ;---------------------------------------------------------------------------
 18022                                  ; Procedure Name : DOS_Open
 18023                                  ;
 18024                                  ; Inputs:
 18025                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 18026                                  ;		terminated)
 18027                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 18028                                  ;		( = -1 if current dir not involved, else
 18029                                  ;		 Points to first char after last "/" of current dir part)
 18030                                  ;	[THISCDS] Points to CDS being used
 18031                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 18032                                  ;	[THISSFT] Points to SFT to fill in if file found
 18033                                  ;		(sf_mode field set so that FCB may be detected)
 18034                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 18035                                  ;	AX is Access and Sharing mode
 18036                                  ;	  High NIBBLE of AL (Sharing Mode)
 18037                                  ;		sharing_compat	   file is opened in compatibility mode
 18038                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 18039                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 18040                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 18041                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 18042                                  ;	  Low NIBBLE of AL (Access Mode)
 18043                                  ;		open_for_read	file is opened for reading
 18044                                  ;		open_for_write	file is opened for writing
 18045                                  ;		open_for_both	file is opened for both reading and writing.
 18046                                  ;
 18047                                  ;	  For FCB SFTs AL should = sharing_compat + open_for_both
 18048                                  ;		(not checked)
 18049                                  ; Function:
 18050                                  ;	Try to open the specified file
 18051                                  ; Outputs:
 18052                                  ;	sf_ref_count is NOT altered
 18053                                  ;	CARRY CLEAR
 18054                                  ;	    THISSFT filled in.
 18055                                  ;	CARRY SET
 18056                                  ;	    AX is error code
 18057                                  ;		error_file_not_found
 18058                                  ;			Last element of path not found
 18059                                  ;		error_path_not_found
 18060                                  ;			Bad path (not in curr dir part if present)
 18061                                  ;		error_bad_curr_dir
 18062                                  ;			Bad path in current directory part of path
 18063                                  ;		error_invalid_access
 18064                                  ;			Bad sharing mode or bad access mode or bad combination
 18065                                  ;		error_access_denied
 18066                                  ;			Attempt to open read only file for writting, or
 18067                                  ;			open a directory
 18068                                  ;		error_sharing_violation
 18069                                  ;			The sharing mode was correct but not allowed
 18070                                  ;			generates an INT 24 on compatibility mode SFTs
 18071                                  ; DS preserved, others destroyed
 18072                                  ;----------------------------------------------------------------------------
 18073                                  
 18074                                  ; 18/05/2019 - Retro DOS v4.0
 18075                                  ; DOSCODE:6A60h (MSDOS 6.21, MSDOS.SYS)
 18076                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 18077                                  ; DOSCODE:6A4Ch (MSDOS 5.0, MSDOS.SYS)
 18078                                  
 18079                                  DOS_OPEN:
 18080                                  	; DS has been set up to DOSDATA in file.asm and fcbio2.asm. 
 18081                                  
 18082 00002B82 C606[4C03]00            	MOV	byte [NoSetDir],0
 18083 00002B87 E83301                  	CALL	Check_Access_AX
 18084 00002B8A 722B                    	JC	short do_ret_label	    ; retc
 18085                                  
 18086 00002B8C C43E[9E05]              	LES	DI,[THISSFT]
 18087 00002B90 30E4                    	XOR	AH,AH
 18088                                  
 18089                                  	; sleaze! move only access/sharing mode in. Leave sf_isFCB unchanged
 18090                                  
 18091 00002B92 26884502                	MOV	[ES:DI+SF_ENTRY.sf_mode],AL ; For moment do this on FCBs too
 18092 00002B96 06                      	PUSH	ES
 18093 00002B97 C436[A205]              	LES	SI,[THISCDS]
 18094                                  	; 18/08/2018
 18095 00002B9B 83FEFF                  	CMP	SI,-1
 18096 00002B9E 7530                    	JNZ	short TEST_RE_NET1
 18097 00002BA0 07                      	POP	ES
 18098                                  
 18099                                  	; MSDOS 6.0
 18100                                  ;Extended open hooks
 18101 00002BA1 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extnded open		;AN000;
 18102 00002BA6 7410                    	JZ	short _NOEXTOP 		    ;FT. no, do normal			;AN000;
 18103                                  _IFS_extopen:									;AN000;
 18104 00002BA8 A0[0106]                	MOV	AL,[SAVE_BX]		    ; M034 - save_bx has original bx  
 18105                                  					    ; with which call was made. This
 18106                                  					    ; has the open access bits. 
 18107                                  	;;MOV	AL,[SAVE_CX]		    ; M034 - FT. al= create attribute
 18108                                  	
 18109 00002BAB 50                      	PUSH	AX			    ;FT. pass create attr to IFS	;AN000;
 18110                                  	;mov	ax,112Eh
 18111                                  	;MOV	AX,(MultNET SHL 8) OR 46    ;FT. issue extended open verb	;AN000;
 18112 00002BAC B82E11                  	mov	ax,(MultNET*256)+46 
 18113 00002BAF CD2F                    	INT	2FH			    ;FT.				;AN000;
 18114 00002BB1 5B                      	POP	BX			    ;FT. trash bx			;AN000;
 18115 00002BB2 C606[F605]00            	MOV	byte [EXTOPEN_ON],0	    ;FT.				;AN000;
 18116                                  
 18117                                  do_ret_label:
 18118 00002BB7 C3                      	retn				    ;FT.				;AN000;
 18119                                  _NOEXTOP:
 18120                                  ;Extended open hooks
 18121                                  	;
 18122                                  ;IF NOT Installed
 18123                                  	;transfer NET_SEQ_OPEN
 18124                                  ;ELSE
 18125                                  	
 18126                                  do_net_int2f:
 18127 00002BB8 F606[8600]01            	test	byte [DOS_FLAG],EXECOPEN ; Q: was this open call made from exec
 18128 00002BBD 7409                    	jz	short not_exec_open	; N: just do net open
 18129                                  					; Y: check to see if redir is aware
 18130                                  					;    of this 
 18131                                  	
 18132                                  					; M042 - start
 18133                                  	;test	word [DOS34_FLAG],EXEC_AWARE_REDIR ; 800h
 18134 00002BBF F606[1206]08            	test	byte [DOS34_FLAG+1],(EXEC_AWARE_REDIR>>8)
 18135                                  					; Q: does this redir know how to 
 18136                                  					;    this
 18137 00002BC4 7402                    	jz	short not_exec_open	; N: just do net open
 18138                                  					; Y: set bit 3 of access byte and 
 18139                                  					;    set sharing mode to DENY_WRITE
 18140                                  					; M042 - end
 18141                                  	
 18142                                  	; NOTE: This specific mode has not been set for the code assembled
 18143                                  	; under the "NOT Installed" conditional. Currently Installed is 
 18144                                  	; always one.
 18145                                  					; M035 - set the bits on the stack
 18146                                  	;mov	al,23h
 18147 00002BC6 B023                    	mov	AL,SHARING_DENY_WRITE+EXEC_OPEN
 18148                                  	
 18149                                  not_exec_open:
 18150                                  	; MSDOS 3.3 & MSDOS 6.0
 18151 00002BC8 50                      	PUSH	AX
 18152                                  
 18153                                  	;MOV	AX,(MultNET SHL 8) OR 22
 18154                                  	;INT	2FH
 18155                                  
 18156 00002BC9 B81611                  	mov     ax,1116h
 18157 00002BCC CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
 18158                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 18159                                  			; SDA first filename pointer -> fully-qualified name of file to open
 18160                                  			; STACK: WORD file open mode
 18161                                  			; Return: CF set on error
 18162                                  
 18163 00002BCE 5B                      	POP	BX			; clean stack
 18164                                  ;do_ret_label: ; 09/08/2018
 18165 00002BCF C3                      	retn
 18166                                  ;ENDIF
 18167                                  
 18168                                  TEST_RE_NET1:
 18169                                  	;TEST	word [ES:SI+curdir.flags],curdir_isnet
 18170                                  	; 17/12/2022
 18171 00002BD0 26F6444480              	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
 18172 00002BD5 07                      	POP	ES
 18173                                  	; 18/05/2019
 18174 00002BD6 7409                    	JZ	short LOCAL_OPEN
 18175                                  
 18176                                  ;Extended open hooks
 18177                                  	; MSDOS 6.0
 18178 00002BD8 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extended open	;AN000;
 18179 00002BDD 75C9                    	JNZ	short _IFS_extopen	      ;FT. isuue extended open	;AN000;
 18180                                  ;Extended open hooks
 18181                                  
 18182                                  ;IF NOT Installed
 18183                                  ;	transfer NET_OPEN
 18184                                  ;ELSE
 18185 00002BDF EBD7                    	jmp	short do_net_int2f
 18186                                  ;ENDIF
 18187                                  
 18188                                  LOCAL_OPEN:
 18189                                  	; MSDOS 3.3 & MSDOS 6.0
 18190 00002BE1 E829E7                  	call	ECritDisk
 18191                                  
 18192                                  ; DOS 3.3 FastOPen 6/16/86
 18193                                  
 18194                                  	;or	byte [FastOpenFlg],5
 18195 00002BE4 800E[3A0D]05            	OR	byte [FastOpenFlg],FastOpen_Set+Special_Fill_Set ; only open can
 18196                                  
 18197 00002BE9 E83B13                  	call	GETPATH
 18198                                  
 18199                                  ; DOS 3.3 FastOPen 6/16/86
 18200                                  
 18201 00002BEC 731D                    	JNC	short Open_found
 18202 00002BEE 7511                    	JNZ	short bad_path2
 18203 00002BF0 08C9                    	OR	CL,CL
 18204 00002BF2 740D                    	JZ	short bad_path2
 18205                                  OpenFNF:
 18206 00002BF4 B80200                  	MOV	AX,error_file_not_found	; 2
 18207                                  OpenBadRet:
 18208                                  ;hkn; FastOpenFlg is in DOSDATA use SS override
 18209                                  	; 12/08/2018
 18210                                  	;mov	byte [cs:FastOpenFlg],0 ; IBMDOS.COM (MSDOS 3.3) offset 36CAh
 18211                                  	; MSDOS 6.0
 18212 00002BF7 368026[3A0D]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes    ;; DOS 3.3
 18213 00002BFD F9                      	STC
 18214                                  	;call	LCritDisk
 18215                                  	; 16/12/2022
 18216 00002BFE E927E7                  	jmp	LCritDisk
 18217                                  	;;JMP	Clear_FastOpen ; 10/08/2018
 18218                                  	;retn 	; 08/09/2018
 18219                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18220                                  	;jmp	Clear_FastOpen
 18221                                  
 18222                                  bad_path2:
 18223 00002C01 B80300                  	MOV	AX,error_path_not_found	; 3
 18224 00002C04 EBF1                    	JMP	short OpenBadRet
 18225                                  
 18226                                  Open_Bad_Access:
 18227 00002C06 B80500                  	MOV	AX,error_access_denied	; 5
 18228 00002C09 EBEC                    	JMP	short OpenBadRet
 18229                                  
 18230                                  Open_found:
 18231 00002C0B 74F9                    	JZ	short Open_Bad_Access 	; test for directories
 18232 00002C0D 08E4                    	OR	AH,AH
 18233 00002C0F 783E                    	JS	short open_ok		; Devices don't have attributes
 18234 00002C11 8E06[E405]              	MOV	ES,[CURBUF+2]		; get buffer location
 18235                                  	;mov	al,[es:bx+0Bh]
 18236 00002C15 268A470B                	MOV	AL,[ES:BX+dir_entry.dir_attr]
 18237 00002C19 A808                    	TEST	AL,attr_volume_id	; can't open volume ids
 18238 00002C1B 75E9                    	JNZ	short Open_Bad_Access
 18239 00002C1D A801                    	TEST	AL,attr_read_only	; check write on read only
 18240 00002C1F 742E                    	JZ	short open_ok
 18241                                  
 18242                                  ; The file is marked READ-ONLY. We verify that the open mode allows access to
 18243                                  ; the read-only file. Unfortunately, with FCB's and net-FCB's we cannot
 18244                                  ; determine at the OPEN time if such access is allowed. Thus, we defer such
 18245                                  ; processing until the actual write operation:
 18246                                  ;
 18247                                  ; If FCB, then we change the mode to be read_only.
 18248                                  ; If net_FCB, then we change the mode to be read_only.
 18249                                  ; If not open for read then error.
 18250                                  
 18251 00002C21 1E                      	push	ds
 18252 00002C22 56                      	push	si
 18253 00002C23 C536[9E05]              	LDS	SI,[THISSFT]
 18254                                  	;mov	cx,[si+2]
 18255 00002C27 8B4C02                  	MOV	CX,[SI+SF_ENTRY.sf_mode]
 18256                                  	; 17/12/2022
 18257                                  	;test	ch,80h
 18258 00002C2A F6C580                  	test	ch,sf_isFCB>>8
 18259                                  	;TEST	CX,sf_isFCB ; 8000h	; is it FCB?
 18260 00002C2D 750A                    	JNZ	short ResetAccess	; yes, reset the access
 18261 00002C2F 88CA                    	MOV	DL,CL
 18262 00002C31 80E2F0                  	AND	DL,SHARING_MASK	; 0F0h
 18263 00002C34 80FA70                  	CMP	DL,SHARING_NET_FCB ; 70h ; is it net FCB?
 18264 00002C37 7508                    	JNZ	short NormalOpen	; no
 18265                                  ResetAccess:
 18266                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)	
 18267                                  	;AND	CX,~access_mask	; 0FFF0h ; clear access
 18268                                  	; 16/12/2022
 18269 00002C39 80E1F0                  	and	cl,0F0h ; 18/05/2019
 18270                                  ;	OR	CX,open_for_read ; 0	; stick in open_for_read
 18271 00002C3C 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],CX
 18272 00002C3F EB0C                    	JMP	SHORT FillSFT
 18273                                  
 18274                                  ; The SFT is normal. See if the requested access is open_for_read
 18275                                  
 18276                                  NormalOpen:
 18277 00002C41 80E10F                  	AND	CL,access_mask	;0Fh	; remove extras
 18278 00002C44 80F900                  	CMP	CL,open_for_read ; 0	; is it open for read?
 18279 00002C47 7404                    	JZ	short FillSFT
 18280 00002C49 5E                      	pop	si
 18281 00002C4A 1F                      	pop	ds
 18282 00002C4B EBB9                    	JMP	short Open_Bad_Access
 18283                                  ;
 18284                                  ; All done, restore registers and fill the SFT.
 18285                                  ;
 18286                                  FillSFT:
 18287 00002C4D 5E                      	pop	si
 18288 00002C4E 1F                      	pop	ds
 18289                                  open_ok:
 18290 00002C4F E8FF1E                  	call	DOOPEN			; Fill in SFT
 18291                                  
 18292                                  ;hkn; FastOpenFlg is in DOSDATA. use SS override
 18293                                  	; 18/05/2019
 18294                                  	;and	byte [ss:FastOpenFlag],80h
 18295 00002C52 368026[3A0D]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes	;; DOS 3.3
 18296                                  	; 12/08/2018
 18297                                  	;and	byte [FastOpenFlg],Fast_yes	
 18298                                  
 18299                                  	; MSDOS 6.0
 18300 00002C58 E84300                  	CALL	DO_SHARE_CHECK
 18301 00002C5B 7303                    	JNC	short SHARE_OK
 18302                                  	;call	LCritDisk
 18303                                  	; 16/12/2022
 18304 00002C5D E9C8E6                  	jmp	LCritDisk
 18305                                  	;;JMP	short Clear_FastOpen
 18306                                  	;retn	; 18/05/2019
 18307                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18308                                  	;jmp	short Clear_FastOpen	
 18309                                  
 18310                                  	; MSDOS 3.3
 18311                                  ;DO_SHARE_CHECK:
 18312                                  ;	MOV	CX,[RetryCount]		; Get # tries to do
 18313                                  ;OpenShareRetry:
 18314                                  ;	push	cx			; Save number left to do
 18315                                  ;	call	SHARE_CHECK		; Final Check
 18316                                  ;	pop	cx			; CX = # left
 18317                                  ;	JNC	short SHARE_OK		; No problem with access
 18318                                  ;	call	Idle
 18319                                  ;	LOOP	OpenShareRetry		; One more retry used up
 18320                                  ;OpenShareFail:
 18321                                  ;	LES	DI,[THISSFT]
 18322                                  ;	call	SHARE_ERROR
 18323                                  ;	JNC	short DO_SHARE_CHECK	; User wants more retry
 18324                                  	
 18325                                  	;12/08/2018
 18326                                  	;mov	byte [ss:FastOpenFlg],0
 18327                                  	;08/09/2018
 18328                                  	;mov	byte [FastOpenFlg],0
 18329                                  	;call	LCritDisk
 18330                                  	;JMP	short Clear_FastOpen
 18331                                  	;retn
 18332                                  
 18333                                  SHARE_OK:
 18334                                  	; MSDOS 3.3 & MSDOS 6.0
 18335 00002C60 B80300                  	MOV	AX,3
 18336 00002C63 C43E[9E05]              	LES	DI,[THISSFT]
 18337                                  ;if installed
 18338                                  	;call	JShare + 14 * 4
 18339 00002C67 FF1E[C800]              	call	far [JShare+(14*4)]  ; 14 = ShSU
 18340                                  ;else
 18341                                  ;	Call	ShSU
 18342                                  ;endif
 18343 00002C6B E8BAE6                  	call	LCritDisk
 18344                                  	
 18345                                  	;FallThru Set_SFT_Mode
 18346                                  
 18347                                  ;----------------------------------------------------------------------------
 18348                                  ; Procedure Name : SET_SFT_MODE
 18349                                  ;
 18350                                  ; Finish SFT initialization for new reference. Set the correct mode.
 18351                                  ;
 18352                                  ;   Inputs:
 18353                                  ;	ThisSFT points to SFT
 18354                                  ;
 18355                                  ;   Outputs:
 18356                                  ;	Carry clear
 18357                                  ;   Registers modified: AX.
 18358                                  ;---------------------------------------------------------------------------
 18359                                  
 18360                                  ;hkn; called from create. DS already set up to DOSDATA.
 18361                                  
 18362                                  SET_SFT_MODE:
 18363 00002C6E C43E[9E05]              	LES	DI,[THISSFT]
 18364 00002C72 E87F19                  	call	DEV_OPEN_SFT
 18365                                  	;test	word [es:di+2],8000h
 18366                                  	; 17/12/2022
 18367                                  	;test	byte [es:di+3],80h
 18368 00002C75 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8
 18369                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; Clears carry
 18370 00002C7A 7407                    	JZ	short Clear_FastOpen	; sf_mode correct (retz)
 18371 00002C7C A1[3003]                	MOV	AX,[CurrentPDB]
 18372                                  	;mov	[es:di+31h],ax
 18373 00002C7F 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX ; For FCB sf_PID=PDB
 18374                                  
 18375                                  Clear_FastOpen:
 18376 00002C83 C3                      	retn			       ;;;;; DOS 3.3
 18377                                  
 18378                                  ;----------------------------------------------------------------------------
 18379                                  ; Procedure Name : SHARE_ERROR
 18380                                  ;
 18381                                  ; Called on sharing violations. ES:DI points to SFT. AX has error code
 18382                                  ; If SFT is FCB or compatibility mode gens INT 24 error.
 18383                                  ; Returns carry set AX=error_sharing_violation if user says ignore (can't
 18384                                  ; really ignore). Carry clear if user wants a retry. ES, DI, DS preserved
 18385                                  ;---------------------------------------------------------------------------
 18386                                  
 18387                                  SHARE_ERROR:
 18388                                  	; 17/12/2022
 18389                                  	;test	byte [es:di+3],80h
 18390 00002C84 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8 ; 80h
 18391                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; 8000h
 18392 00002C89 7509                    	JNZ	short _HARD_ERR
 18393 00002C8B 268A4D02                	MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 18394 00002C8F 80E1F0                  	AND	CL,SHARING_MASK  ; 0F0h
 18395                                  	;CMP	CL,SHARING_COMPAT ; 0
 18396                                  	;JNE	short _NO_HARD_ERR
 18397                                  	; 21/09/2023
 18398 00002C92 7505                    	jnz	short _NO_HARD_ERR
 18399                                  _HARD_ERR:
 18400 00002C94 E8BA46                  	call	SHARE_VIOLATION
 18401                                  	;retnc				; User wants retry
 18402 00002C97 73EA                    	jnc	short Clear_FastOpen
 18403                                  _NO_HARD_ERR:
 18404 00002C99 B82000                  	MOV	AX,error_sharing_violation  ; 20h
 18405 00002C9C F9                      	STC
 18406 00002C9D C3                      	retn
 18407                                  
 18408                                  ; MSDOS 6.0
 18409                                  ;----------------------------------------------------------------------------
 18410                                  ; Procedure Name : DO_SHARE_CHECK
 18411                                  ;
 18412                                  ; Input: THISDPB, WFP_Start, THISSFT set
 18413                                  ; Functions: check file sharing mode is valid
 18414                                  ; Output: carry set, error
 18415                                  ;	  carry clear, share ok
 18416                                  ;----------------------------------------------------------------------------
 18417                                  
 18418                                  	; 18/05/2019 - Retro DOS v4.0
 18419                                  DO_SHARE_CHECK:
 18420 00002C9E E86CE6                  	call	ECritDisk		; enter critical section
 18421                                  OPN_RETRY:
 18422 00002CA1 8B0E[1A00]              	MOV	CX,[RetryCount]		; Get # tries to do
 18423                                  OpenShareRetry:
 18424 00002CA5 51                      	push	cx			; Save number left to do
 18425 00002CA6 E8A346                  	call	SHARE_CHECK		; Final Check
 18426 00002CA9 59                      	pop	cx			; CX = # left
 18427 00002CAA 730E                    	JNC	short Share_Ok2		; No problem with access
 18428 00002CAC E857E5                  	call	Idle
 18429 00002CAF E2F4                    	LOOP	OpenShareRetry		; One more retry used up
 18430                                  OpenShareFail:
 18431 00002CB1 C43E[9E05]              	LES	DI,[THISSFT]
 18432 00002CB5 E8CCFF                  	call	SHARE_ERROR
 18433 00002CB8 73E7                    	JNC	short OPN_RETRY		; User wants more retry
 18434                                  Share_Ok2:
 18435                                  	;call	LCritDisk		; leave critical section
 18436                                  	;retn
 18437                                  	; 18/12/2022
 18438 00002CBA E96BE6                  	jmp	LCritDisk
 18439                                  
 18440                                  ;-----------------------------------------------------------------------------
 18441                                  ; Procedure Name : Check_Access
 18442                                  ;
 18443                                  ; Inputs:
 18444                                  ;	AX is mode
 18445                                  ;	  High NIBBLE of AL (Sharing Mode)
 18446                                  ;		sharing_compat	   file is opened in compatibility mode
 18447                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 18448                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 18449                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 18450                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 18451                                  ;	  Low NIBBLE of AL (Access Mode)
 18452                                  ;		open_for_read	file is opened for reading
 18453                                  ;		open_for_write	file is opened for writing
 18454                                  ;		open_for_both	file is opened for both reading and writing.
 18455                                  ; Function:
 18456                                  ;	Check this access mode for correctness
 18457                                  ; Outputs:
 18458                                  ;	[open_access] = AL input
 18459                                  ;	Carry Clear
 18460                                  ;		Mode is correct
 18461                                  ;		AX unchanged
 18462                                  ;	Carry Set
 18463                                  ;		Mode is bad
 18464                                  ;		AX = error_invalid_access
 18465                                  ; No other registers effected
 18466                                  ;----------------------------------------------------------------------------
 18467                                  
 18468                                  Check_Access_AX:
 18469 00002CBD A2[6E05]                	MOV	[OPEN_ACCESS],AL
 18470 00002CC0 53                      	PUSH	BX
 18471                                  
 18472                                  ;	If sharing, then test for special sharing mode for FCBs
 18473                                  
 18474 00002CC1 88C3                    	MOV	BL,AL
 18475 00002CC3 80E3F0                  	AND	BL,SHARING_MASK ; 0F0h
 18476 00002CC6 803E[7205]FF            	CMP	byte [FSHARING],-1
 18477 00002CCB 7505                    	JNZ	short CheckShareMode	; not through server call, must be ok
 18478 00002CCD 80FB70                  	CMP	BL,SHARING_NET_FCB
 18479 00002CD0 7405                    	JZ	short CheckAccessMode	; yes, we have an FCB
 18480                                  CheckShareMode:
 18481 00002CD2 80FB40                  	CMP	BL,40h			; is this a good sharing mode?
 18482 00002CD5 770D                    	JA	short Make_Bad_Access
 18483                                  CheckAccessMode:
 18484 00002CD7 88C3                    	MOV	BL,AL
 18485 00002CD9 80E30F                  	AND	BL,access_mask
 18486 00002CDC 80FB02                  	CMP	BL,2
 18487 00002CDF 7703                    	JA	short Make_Bad_Access
 18488 00002CE1 5B                      	POP	BX
 18489 00002CE2 F8                      	CLC
 18490 00002CE3 C3                      	retn
 18491                                  
 18492                                  Make_Bad_Access:
 18493 00002CE4 B80C00                  	MOV	AX,error_invalid_access ; 0Ch
 18494 00002CE7 5B                      	POP	BX
 18495 00002CE8 F9                      	STC
 18496 00002CE9 C3                      	retn
 18497                                  
 18498                                  ;============================================================================
 18499                                  ; DINFO.ASM, MSDOS 6.0, 1991
 18500                                  ;============================================================================
 18501                                  ; 08/08/2018 - Retro DOS v3.0
 18502                                  ; 18/05/2019 - Retro DOS v4.0
 18503                                  
 18504                                  ;**	Low level routine for returning disk drive information from a local
 18505                                  ;	  or NET device
 18506                                  ;
 18507                                  ;	DISK_INFO
 18508                                  ;
 18509                                  ;	  Modification history:
 18510                                  ;
 18511                                  ;		Created: ARR 30 March 1983
 18512                                  
 18513                                  ;	Break	<DISK_INFO -- Get Disk Drive Information>
 18514                                  ;---------------------------------------------------------------------------
 18515                                  ; Procedure Name : DISK_INFO
 18516                                  ;
 18517                                  ; Inputs:
 18518                                  ;	[THISCDS] Points to the Macro List Structure of interest
 18519                                  ;		(It MAY NOT be NUL, error not detected)
 18520                                  ; Function:
 18521                                  ;	Get Interesting Drive Information
 18522                                  ; Returns:
 18523                                  ;	DX = Number of free allocation units
 18524                                  ;	BX = Total Number of allocation units on disk
 18525                                  ;	CX = Sector size
 18526                                  ;	AL = Sectors per allocation unit
 18527                                  ;	AH = FAT ID BYTE
 18528                                  ;	Carry set if error (currently user FAILed to I 24)
 18529                                  ; Segs except ES preserved, others destroyed
 18530                                  ;----------------------------------------------------------------------------
 18531                                  
 18532                                  ;hkn; called from getset.asm and misc.asm. DS has already been set up to 
 18533                                  ;hkn; DOSDATA. 
 18534                                  
 18535                                  DISK_INFO:
 18536                                  	; 08/08/2018 - Retro DOS v3.0
 18537                                  	; IBM DOS.COM (MSDOS 3.3, 1987) - Offset 37C5h
 18538                                  
 18539 00002CEA E85EE5                  	call	TestNet
 18540 00002CED 7306                    	JNC	short LOCAL_DSK_INFO
 18541                                  
 18542                                  ;IF NOT Installed
 18543                                  ;	transfer NET_DISK_INFO
 18544                                  ;ELSE
 18545                                  	;MOV	AX,(MultNET SHL 8) OR 12
 18546                                  	;INT	2FH
 18547                                  	;return
 18548                                  
 18549 00002CEF B80C11                  	mov     ax,110Ch
 18550 00002CF2 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
 18551                                  			; ES:DI -> current directory
 18552                                  			; Return: AL = sectors per cluster, BX = total clusters
 18553                                  			; CX = bytes per sector, DX = number of available clusters
 18554 00002CF4 C3                      	retn
 18555                                  ;ENDIF
 18556                                  
 18557                                  LOCAL_DSK_INFO:
 18558 00002CF5 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 18559 00002CFA E810E6                  	call	ECritDisk
 18560 00002CFD E8DB29                  	call	FATREAD_CDS		; perform media check.
 18561 00002D00 7241                    	JC	short CRIT_LEAVE
 18562 00002D02 BB0200                  	MOV	BX,2
 18563 00002D05 E83D28                  	call	UNPACK			; Get first FAT sector into CURBUF
 18564 00002D08 7239                    	JC	short CRIT_LEAVE
 18565 00002D0A C536[E205]              	LDS	SI,[CURBUF]
 18566                                  	;mov	ah,[si+20]
 18567 00002D0E 8A6414                  	MOV	AH,[SI+BUFINSIZ]	; get FAT ID BYTE
 18568                                  
 18569                                  ;hkn; SS is DOSDATA
 18570 00002D11 16                      	push	ss
 18571 00002D12 1F                      	pop	ds
 18572                                  	;mov	cx,[es:bp+0Dh]
 18573 00002D13 268B4E0D                	MOV	CX,[ES:BP+DPB.MAX_CLUSTER]
 18574                                  
 18575                                  ; Examine the current free count. If it indicates that we have an invalid
 18576                                  ; count, do the expensive calculation.
 18577                                  
 18578                                  	;mov	dx,[es:bp+1Fh]
 18579 00002D17 268B561F                	MOV	DX,[ES:BP+DPB.FREE_CNT] ; get free count
 18580 00002D1B 83FAFF                  	CMP	DX,-1			; is it valid?
 18581 00002D1E 7404                    	JZ	short DoScan
 18582                                  
 18583                                  ; Check to see if it is in a reasonable range. If so, trust it and return.
 18584                                  ; Otherwise, we need to blast out an internal error message and then recompute
 18585                                  ; the count.
 18586                                  
 18587 00002D20 39CA                    	CMP	DX,CX			; is it in a reasonable range?
 18588 00002D22 7222                    	JB	short GotVal		; yes, trust it.
 18589                                  DoScan:
 18590 00002D24 31D2                    	XOR	DX,DX
 18591 00002D26 49                      	DEC	CX
 18592                                  SCANFREE:
 18593 00002D27 E81B28                  	call	UNPACK
 18594 00002D2A 7217                    	JC	short CRIT_LEAVE
 18595 00002D2C 7501                    	JNZ	short NOTFREECLUS
 18596 00002D2E 42                      	INC	DX			; A free one
 18597                                  NOTFREECLUS:
 18598 00002D2F 43                      	INC	BX			; Next cluster
 18599 00002D30 E2F5                    	LOOP	SCANFREE
 18600 00002D32 4B                      	DEC	BX			; BX was next cluster. Convert to
 18601                                  ReturnVals:
 18602 00002D33 4B                      	DEC	BX			; count
 18603                                  	;mov	al,[es:bp+4]
 18604 00002D34 268A4604                	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 18605 00002D38 FEC0                    	INC	AL			; Sectors/cluster
 18606                                  	;mov	cx,[es:bp+2]
 18607 00002D3A 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE] ; Bytes/sector
 18608                                  	;mov	[es:bp+1Fh],dx
 18609 00002D3E 2689561F                	MOV	[ES:BP+DPB.FREE_CNT],DX
 18610 00002D42 F8                      	CLC
 18611                                  CRIT_LEAVE:
 18612                                  	;call	LCritDisk
 18613                                  	;retn
 18614                                  	; 17/12/2022
 18615 00002D43 E9E2E5                  	jmp	LCritDisk
 18616                                  
 18617                                  ; We have correctly computed everything previously. Load up registers for
 18618                                  ; return.
 18619                                  
 18620                                  GotVal: 
 18621 00002D46 89CB                    	MOV	BX,CX			; get cluster count
 18622 00002D48 EBE9                    	JMP	short ReturnVals
 18623                                  
 18624                                  ;============================================================================
 18625                                  ; ISEARCH.ASM, MSDOS 6.0, 1991
 18626                                  ;============================================================================
 18627                                  ; 22/07/2018 - Retro DOS v3.0
 18628                                  
 18629                                  ;	TITLE	DOS_SEARCH - Internal SEARCH calls for MS-DOS
 18630                                  ;	NAME	DOS_SEARCH
 18631                                  
 18632                                  ;**	Low level routines for doing local and NET directory searches
 18633                                  ;
 18634                                  ;	DOS_SEARCH_FIRST
 18635                                  ;	DOS_SEARCH_NEXT
 18636                                  ;	RENAME_NEXT
 18637                                  ;
 18638                                  ;	Revision history:
 18639                                  ;
 18640                                  ;	    Created: ARR 30 March 1983
 18641                                  ;	    A000	version 4.00  Jan. 1988
 18642                                  ;	    A001	PTM 3564 -- search for fastopen
 18643                                  
 18644                                  ;Installed = TRUE
 18645                                  
 18646                                  ;--------------------------------------------------------------------------
 18647                                  ;
 18648                                  ; Procedure Name : DOS_SEARCH_FIRST
 18649                                  ;
 18650                                  ; Inputs:
 18651                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 18652                                  ;		terminated)
 18653                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 18654                                  ;		( = -1 if current dir not involved, else
 18655                                  ;		 Points to first char after last "/" of current dir part)
 18656                                  ;	[THISCDS] Points to CDS being used
 18657                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 18658                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 18659                                  ;	[DMAADD] Points to 53 byte buffer
 18660                                  ; Function:
 18661                                  ;	Initiate a search for the given file spec
 18662                                  ; Outputs:
 18663                                  ;	CARRY CLEAR
 18664                                  ;	    The 53 bytes ot DMAADD are filled in as follows:
 18665                                  ;
 18666                                  ;	LOCAL
 18667                                  ;	    Drive Byte (A=1, B=2, ...) High bit clear
 18668                                  ;		NEVER STORE DRIVE BYTE AFTER  found_it
 18669                                  ;	    11 byte search name with Meta chars in it
 18670                                  ;	    Search Attribute Byte, attribute of search
 18671                                  ;	    WORD LastEnt value
 18672                                  ;	    WORD DirStart
 18673                                  ;	    4 byte pad
 18674                                  ;	    32 bytes of the directory entry found
 18675                                  ;	NET
 18676                                  ;	    21 bytes First byte has high bit set
 18677                                  ;	    32 bytes of the directory entry found
 18678                                  ;
 18679                                  ;	CARRY SET
 18680                                  ;	    AX = error code
 18681                                  ;		error_no_more_files
 18682                                  ;			No match for this file
 18683                                  ;		error_path_not_found
 18684                                  ;			Bad path (not in curr dir part if present)
 18685                                  ;		error_bad_curr_dir
 18686                                  ;			Bad path in current directory part of path
 18687                                  ; DS preserved, others destroyed
 18688                                  ;---------------------------------------------------------------------------
 18689                                  
 18690                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 18691                                  	; DOSCODE:6C22h (MSDOS 5.0, MSDOS.SYS)
 18692                                  
 18693                                  DOS_SEARCH_FIRST:
 18694                                  	; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 3826h
 18695                                  
 18696 00002D4A C43E[A205]              	LES	DI,[THISCDS]
 18697 00002D4E 83FFFF                  	CMP	DI,-1
 18698 00002D51 7506                    	JNZ	short TEST_RE_NET2
 18699                                  
 18700                                  ;IF NOT Installed
 18701                                  ;	transfer NET_SEQ_SEARCH_FIRST
 18702                                  ;ELSE
 18703                                  	;mov	ax,1119h
 18704 00002D53 B81911                  	MOV	AX,(MultNET<<8)|25
 18705 00002D56 CD2F                    	INT	2Fh
 18706 00002D58 C3                      	retn
 18707                                  ;ENDIF
 18708                                  
 18709                                  TEST_RE_NET2:
 18710                                  	;test	word [es:di+43h],8000h
 18711                                  	; 17/12/2022
 18712                                  	;test	byte [es:di+44h],80h
 18713                                  	; 28/12/2022
 18714 00002D59 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8	
 18715                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 18716 00002D5E 7406                    	JZ	short LOCAL_SEARCH_FIRST
 18717                                  
 18718                                  ;IF NOT Installed
 18719                                  ;	transfer NET_SEARCH_FIRST
 18720                                  ;ELSE
 18721                                  	;mov	ax,111Bh
 18722 00002D60 B81B11                  	MOV	AX,(MultNET<<8)|27
 18723 00002D63 CD2F                    	INT	2FH
 18724 00002D65 C3                      	retn
 18725                                  ;ENDIF
 18726                                  	; 18/05/2019 - Retro DOS v4.0
 18727                                  LOCAL_SEARCH_FIRST:
 18728 00002D66 E8A4E5                  	call	ECritDisk
 18729                                  	; MSDOS 6.0
 18730                                  	;;test	word [DOS34_FLAG],400h
 18731                                  	; 17/12/2022
 18732                                  	;test	byte [DOS34_FLAG+1],04h
 18733 00002D69 F606[1206]04            	test	byte [DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)
 18734                                  	;TEST	word [DOS34_FLAG],SEARCH_FASTOPEN ;AN000;
 18735 00002D6E 7405                    	JZ	short NOFN			;AN000;
 18736                                  	;or	byte [FastOpenFlg],1
 18737 00002D70 800E[3A0D]01            	OR	byte [FastOpenFlg],FastOpen_Set	;AN000;
 18738                                  NOFN:						;AN000;
 18739 00002D75 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 18740                                  	; MSDOS 6.0
 18741 00002D7A E84101                  	CALL	CHECK_QUESTION		;AN000;;FO. is '?' in path
 18742 00002D7D 7305                    	JNC	short norm_GETPATH	;AN000;;FO. no
 18743                                  	;and	byte [FastOpenFlg],80h
 18744 00002D7F 8026[3A0D]80            	AND	byte [FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
 18745                                  norm_GETPATH:
 18746 00002D84 E8A011                  	call	GETPATH
 18747                                  	; BX = offset NAME1
 18748                                  ;_getdone:
 18749 00002D87 7318                    	JNC	short find_check_dev
 18750 00002D89 7511                    	JNZ	short bad_path3
 18751 00002D8B 08C9                    	OR	CL,CL
 18752 00002D8D 740D                    	JZ	short bad_path3
 18753                                  find_no_more:
 18754                                  	;mov	ax,12h
 18755 00002D8F B81200                  	MOV	AX,error_no_more_files
 18756                                  BadBye:
 18757                                  	; MSDOS 6.0
 18758 00002D92 368026[3A0D]80          	AND	byte [SS:FastOpenFlg],Fast_yes  ;AN000;;FO. reset fastopen
 18759                                  
 18760 00002D98 F9                      	STC
 18761                                  	;call	LCritDisk
 18762                                  	;retn
 18763                                  	; 18/12/2022
 18764 00002D99 E98CE5                  	jmp	LCritDisk
 18765                                  
 18766                                  bad_path3:
 18767                                  	;mov	ax,3
 18768 00002D9C B80300                  	MOV	AX,error_path_not_found
 18769 00002D9F EBF1                    	JMP	short BadBye
 18770                                  
 18771                                  find_check_dev:
 18772 00002DA1 08E4                    	OR	AH,AH
 18773 00002DA3 790A                    	JNS	short found_entry
 18774 00002DA5 C706[4803]FFFF          	MOV	word [LASTENT],-1	; Cause DOS_SEARCH_NEXT to fail
 18775 00002DAB FE06[7005]              	INC	byte [FOUND_DEV]	; Tell DOS_RENAME we found a device
 18776                                  found_entry:
 18777                                  
 18778                                  ; We set the physical drive byte here Instead of after found_it; Doing
 18779                                  ; a search-next may not have wfp_start set correctly
 18780                                  
 18781 00002DAF C43E[2C03]              	LES	DI,[DMAADD]
 18782 00002DB3 8B36[B205]              	MOV	SI,[WFP_START]		; get pointer to beginning
 18783 00002DB7 AC                      	LODSB
 18784 00002DB8 2C40                    	SUB	AL,'A'-1                ; logical drive
 18785 00002DBA AA                      	STOSB				; High bit not set (local)
 18786                                  found_it:
 18787 00002DBB C43E[2C03]              	LES	DI,[DMAADD]
 18788 00002DBF 47                      	INC	DI
 18789                                  
 18790                                  	; MSDOS 6.0
 18791 00002DC0 1E                      	PUSH	DS				  ;FO.;AN001; save ds
 18792                                  	;test	byte [FastOpenFlg],10h
 18793 00002DC1 F606[3A0D]10            	TEST	byte [FastOpenFlg],Set_For_Search ;FO.;AN001; from fastopen
 18794 00002DC6 7408                    	JZ	short notfast			  ;FO.;AN001;
 18795 00002DC8 89DE                    	MOV	SI,BX				  ;FO.;AN001;
 18796 00002DCA 8E1E[E405]              	MOV	DS,[CURBUF+2]			  ;FO.;AN001;
 18797 00002DCE EB03                    	JMP	SHORT movmov			  ;FO.;AN001;
 18798                                  
 18799                                  notfast:
 18800 00002DD0 BE[4B05]                	MOV	SI,NAME1		; find_buf 2 = formatted name
 18801                                  movmov:
 18802                                  ; Special E5 code
 18803 00002DD3 A4                      	MOVSB
 18804 00002DD4 26807DFF05              	CMP	BYTE [ES:DI-1],5
 18805 00002DD9 7505                    	JNZ	short NOTKANJB
 18806 00002DDB 26C645FFE5              	MOV	BYTE [ES:DI-1],0E5H
 18807                                  NOTKANJB:
 18808 00002DE0 B90A00                  	MOV	CX,10
 18809 00002DE3 F3A4                    	REP	MOVSB
 18810                                  
 18811                                  	; 08/09/2018
 18812 00002DE5 1F                      	POP	DS			;FO.;AN001; restore ds
 18813                                  
 18814 00002DE6 A0[6B05]                	MOV	AL,[ATTRIB]
 18815 00002DE9 AA                      	STOSB
 18816 00002DEA 50                      	PUSH	AX			; Save AH device info
 18817 00002DEB A1[4803]                	MOV	AX,[LASTENT]
 18818 00002DEE AB                      	STOSW
 18819 00002DEF A1[C205]                	MOV	AX,[DIRSTART]
 18820 00002DF2 AB                      	STOSW
 18821                                  ; 4 bytes of 21 byte cont structure left for NET stuff
 18822 00002DF3 83C704                  	ADD	DI,4
 18823 00002DF6 58                      	POP	AX			; Recover AH device info
 18824 00002DF7 08E4                    	OR	AH,AH
 18825 00002DF9 781B                    	JS	short DOSREL		; Device entry is DOSGROUP relative
 18826 00002DFB 833E[E205]FF            	CMP	WORD [CURBUF],-1
 18827 00002E00 7510                    	JNZ	short OKSTORE
 18828                                  
 18829                                  	; MSDOS 6.0
 18830 00002E02 F606[3A0D]10            	TEST	byte [FastOpenFlg],Set_For_Search
 18831                                  					;AN000;;FO. from fastopen and is good
 18832 00002E07 7509                    	JNZ	short OKSTORE		;AN000;;FO.
 18833                                  
 18834                                  	; The user has specified the root directory itself, rather than some
 18835                                  	; contents of it. We can't "find" that.
 18836                                  
 18837 00002E09 26C745F8FFFF            	MOV	WORD [ES:DI-8],-1	; Cause DOS_SEARCH_NEXT to fail by
 18838                                  					;   stuffing a -1 at Lastent
 18839 00002E0F E97DFF                  	JMP	find_no_more
 18840                                  
 18841                                  OKSTORE:
 18842 00002E12 8E1E[E405]              	MOV	DS,[CURBUF+2]
 18843                                  DOSREL:
 18844                                  	; BX = offset NAME1 (from GETPATH)
 18845 00002E16 89DE                    	MOV	SI,BX			; SI-> start of entry
 18846                                  
 18847                                  ; NOTE: DOS_RENAME depends on BX not being altered after this point
 18848                                  
 18849                                  	;mov	cx,32
 18850 00002E18 B92000                  	MOV	CX,dir_entry.size
 18851                                  ;;;;; 7/29/86
 18852 00002E1B 89F8                    	MOV	AX,DI			; save the 1st byte addr
 18853 00002E1D F3A4                    	REP	MOVSB
 18854 00002E1F 89C7                    	MOV	DI,AX			; restore 1st byte addr
 18855 00002E21 26803D05                	CMP	BYTE [ES:DI],05H	; special char check
 18856 00002E25 7504                    	JNZ	short NO05
 18857 00002E27 26C605E5                	MOV	BYTE [ES:DI],0E5H	; convert it back to E5
 18858                                  NO05:
 18859                                  
 18860                                  ;;;;; 7/29/86
 18861                                  
 18862                                  ;hkn; FastOpenflg is in DOSDATA use SS
 18863                                  	; 16/12/2022
 18864                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18865                                  	; MSDOS 6.0
 18866                                  	;AND	byte [SS:FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
 18867                                  	; 18/05/2019 - Retro DOS v4.0
 18868 00002E2B 16                      	push	ss
 18869 00002E2C 1F                      	pop	ds
 18870                                  	; 16/12/2022
 18871 00002E2D 8026[3A0D]80            	AND	byte [FastOpenFlg],Fast_yes
 18872                                  
 18873                                  ;hkn; SS is DOSDATA
 18874                                  	;push	ss
 18875                                  	;pop	ds
 18876 00002E32 F8                      	CLC
 18877                                  	;call	LCritDisk
 18878                                  	;retn
 18879                                  	; 16/12/2022
 18880 00002E33 E9F2E4                  	jmp	LCritDisk
 18881                                  
 18882                                  ;BREAK <DOS_SEARCH_NEXT - scan for subsequent matches>
 18883                                  ;----------------------------------------------------------------------------
 18884                                  ;
 18885                                  ; Procedure Name : DOS_SEARCH_NEXT
 18886                                  ;
 18887                                  ; Inputs:
 18888                                  ;	[DMAADD] Points to 53 byte buffer returned by DOS_SEARCH_FIRST
 18889                                  ;	    (only first 21 bytes must have valid information)
 18890                                  ; Function:
 18891                                  ;	Look for subsequent matches
 18892                                  ; Outputs:
 18893                                  ;	CARRY CLEAR
 18894                                  ;	    The 53 bytes at DMAADD are updated for next call
 18895                                  ;		(see DOS_SEARCH_FIRST)
 18896                                  ;	CARRY SET
 18897                                  ;	    AX = error code
 18898                                  ;		error_no_more_files
 18899                                  ;			No more files to find
 18900                                  ; DS preserved, others destroyed
 18901                                  ;---------------------------------------------------------------------------
 18902                                  
 18903                                  ;hkn; called from search.asm. DS already set up at this point.
 18904                                  
 18905                                  DOS_SEARCH_NEXT:
 18906 00002E36 C43E[2C03]              	LES	DI,[DMAADD]
 18907 00002E3A 268A05                  	MOV	AL,[ES:DI]
 18908 00002E3D A880                    	TEST	AL,80H			; Test for NET
 18909 00002E3F 7406                    	JZ	short LOCAL_SEARCH_NEXT
 18910                                  ;IF NOT Installed
 18911                                  ;	transfer NET_SEARCH_NEXT
 18912                                  ;ELSE
 18913                                  	;mov	ax,111Ch
 18914 00002E41 B81C11                  	MOV	AX,(MultNET<<8)|28
 18915 00002E44 CD2F                    	INT	2FH  ; Multiplex - NETWORK REDIRECTOR - FINDNEXT
 18916                                  		     ; SS = DS = DOS CS, [DTA] = 21-byte findfirst search data
 18917                                  		     ; Return: CF set on error, AX = DOS error code
 18918                                  		     ; CF clear if successful
 18919 00002E46 C3                      	retn
 18920                                  ;ENDIF
 18921                                  
 18922                                  LOCAL_SEARCH_NEXT:
 18923                                  	;AL is drive A=1
 18924                                  	;mov	byte [EXTERR_LOCUS],2
 18925 00002E47 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 18926 00002E4C E8BEE4                  	call	ECritDisk
 18927                                  
 18928                                  ;hkn; DummyCDS is in DOSDATA
 18929 00002E4F C706[A205][F304]        	MOV     word [THISCDS],DUMMYCDS
 18930                                  ;hkn; Segment address is DOSDATA - use ds
 18931                                  ;hkn;	MOV     WORD [THISCDS+2],CS
 18932 00002E55 8C1E[A405]              	mov	[THISCDS+2],DS
 18933                                  
 18934 00002E59 0440                    	ADD	AL,'A'-1
 18935 00002E5B E8833B                  	call	InitCDS
 18936                                  
 18937                                  ;	call	GETTHISDRV		; Set CDS pointer
 18938                                  
 18939 00002E5E 7236                    	JC	short No_files		; Bogus drive letter
 18940 00002E60 C43E[A205]              	LES	DI,[THISCDS]		; Get CDS pointer
 18941                                  	;les	bp,[es:di+45h]
 18942 00002E64 26C46D45                	LES	BP,[ES:DI+curdir.devptr] ; Get DPB pointer
 18943 00002E68 E8C3D7                  	call	GOTDPB			; [THISDPB] = ES:BP
 18944                                  
 18945                                  	 ;16/12/2022
 18946 00002E6B 268A4600                	mov	al,[ES:BP]
 18947                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18948                                  	;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[ES:BP+0]
 18949 00002E6F A2[7605]                	mov	[THISDRV],AL
 18950                                  	;mov	word [CREATING],0E500h
 18951 00002E72 C706[7E05]00E5          	MOV	WORD [CREATING],(DIRFREE*256)+0
 18952 00002E78 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 18953 00002E7D C536[2C03]              	LDS	SI,[DMAADD]
 18954 00002E81 AC                      	LODSB				; Drive Byte
 18955                                  
 18956                                  	;entry	RENAME_NEXT		; Entry used by DOS_RENAME
 18957                                  RENAME_NEXT:
 18958                                  	;context ES
 18959 00002E82 16                      	push	ss
 18960 00002E83 07                      	pop	es			; THIS BLOWS ES:BP POINTER TO DPB
 18961                                  
 18962                                  ;hkn; NAME1 is in DOSDATA
 18963 00002E84 BF[4B05]                	MOV	DI,NAME1
 18964                                  
 18965 00002E87 B90B00                  	MOV	CX,11
 18966 00002E8A F3A4                    	REP	MOVSB			; Search name
 18967 00002E8C AC                      	LODSB				; Attribute
 18968                                  
 18969                                  ;hkn; SS override
 18970 00002E8D 36A2[6B05]              	MOV	[SS:ATTRIB],AL
 18971 00002E91 AD                      	LODSW				; LastEnt
 18972 00002E92 09C0                    	OR	AX,AX
 18973 00002E94 7903                    	JNS	short cont_load
 18974                                  No_files:
 18975 00002E96 E9F6FE                  	JMP	find_no_more
 18976                                  
 18977                                  cont_load:
 18978 00002E99 50                      	PUSH	AX			; Save LastEnt
 18979 00002E9A AD                      	LODSW				; DirStart
 18980 00002E9B 89C3                    	MOV	BX,AX
 18981                                  
 18982                                  ;hkn; SS is DOSDATA
 18983                                  	;context DS
 18984 00002E9D 16                      	push	ss
 18985 00002E9E 1F                      	pop	ds
 18986 00002E9F C42E[8A05]              	LES	BP,[THISDPB]		; Recover ES:BP
 18987                                  	;invoke	SetDirSrch
 18988 00002EA3 E82410                  	call	SETDIRSRCH
 18989 00002EA6 7303                    	JNC	short SEARCH_GOON
 18990 00002EA8 58                      	POP	AX			; Clean stack
 18991 00002EA9 EBEB                    	JMP	short No_files
 18992                                  
 18993                                  SEARCH_GOON:
 18994 00002EAB E80C13                  	call	STARTSRCH
 18995 00002EAE 58                      	POP	AX
 18996 00002EAF E8E90F                  	call	GETENT
 18997 00002EB2 72E2                    	JC	short No_files
 18998 00002EB4 E81F0F                  	call	NEXTENT
 18999 00002EB7 72DD                    	JC	short No_files
 19000 00002EB9 30E4                    	XOR	AH,AH			; If Search_Next, can't be a DEV
 19001 00002EBB E9FDFE                  	JMP	found_it ; 10/08/2018
 19002                                  
 19003                                  ; MSDOS 6.0
 19004                                  ;---------------------------------------------------------------------------
 19005                                  ;
 19006                                  ; Procedure Name : CHECK_QUESTION
 19007                                  ;
 19008                                  ; Input: [WFP_START]= pointer to final path
 19009                                  ; Function: check '?' char
 19010                                  ; Output: carry clear, if no '?'
 19011                                  ;	 carry set, if '?' exists
 19012                                  ;---------------------------------------------------------------------------
 19013                                  
 19014                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19015                                  CHECK_QUESTION:
 19016                                  ;hkn;	wfp_start is in DOSDATA;hkn;	MOV	WORD PTR ThisCDS+2,CS
 19017                                  ;hkn;	PUSH	CS			;AN000;;FO.
 19018 00002EBE 16                      	push	ss
 19019 00002EBF 1F                      	POP	DS			;AN000;;FO. ds:si -> final path
 19020                                  	; 16/12/2022
 19021                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 19022 00002EC0 8B36[B205]              	MOV	SI,[WFP_START]		;AN000;;FO.
 19023                                  	;mov	si,[ss:WFP_START]
 19024                                  getnext:				;AN000;
 19025 00002EC4 AC                      	LODSB				;AN000;;FO. get char
 19026 00002EC5 08C0                    	OR	AL,AL			;AN000;;FO. is it null
 19027 00002EC7 7405                    	JZ	short NO_Question	;AN000;;FO. yes
 19028 00002EC9 3C3F                    	CMP	AL,'?'                  ;AN000;;FO. is '?'
 19029 00002ECB 75F7                    	JNZ	short getnext 		;AN000;;FO. no
 19030 00002ECD F9                      	STC				;AN000;;FO.
 19031                                  NO_Question:				;AN000;
 19032 00002ECE C3                      	retn				;AN000;;FO.
 19033                                  
 19034                                  ;============================================================================
 19035                                  ; ABORT.ASM, MSDOS 6.0, 1991
 19036                                  ;============================================================================
 19037                                  ; 23/07/2018 - Retro DOS v3.0
 19038                                  ; 18/05/2019 - Retro DOS v4.0
 19039                                  
 19040                                  ;**
 19041                                  ;
 19042                                  ; Internal Abort call closes all handles and FCBs associated with a process.
 19043                                  ;  If process has NET resources a close all is sent out over the net.
 19044                                  ;
 19045                                  ;   DOS_ABORT
 19046                                  ;
 19047                                  ;   Modification history:
 19048                                  ;
 19049                                  ;       Created: ARR 30 March 1983
 19050                                  ;
 19051                                  ;	M038	SR	10/16/90	Free SFT with the PSP of the process
 19052                                  ;				being terminated only if it is busy.
 19053                                  ;
 19054                                  
 19055                                  ;Break   <DOS_ABORT -- CLOSE all files for process>
 19056                                  ;--------------------------------------------------------------------------
 19057                                  ;
 19058                                  ; Procedure Name : DOS_ABORT
 19059                                  ;
 19060                                  ; Inputs:
 19061                                  ;       [CurrentPDB] set to PID of process aborting
 19062                                  ; Function:
 19063                                  ;       Close all files and free all SFTs for this PID
 19064                                  ; Returns:
 19065                                  ;       None
 19066                                  ; All destroyed except stack
 19067                                  ;---------------------------------------------------------------------------
 19068                                  
 19069                                  DOS_ABORT:
 19070 00002ECF 368E06[3003]            	MOV     ES,[SS:CurrentPDB]	; SS override
 19071 00002ED4 268B0E3200              	MOV     CX,[ES:PDB.JFN_Length]  ; Number of JFNs
 19072                                  reset_free_jfn:
 19073 00002ED9 89CB                    	MOV     BX,CX
 19074 00002EDB 51                      	PUSH    CX
 19075 00002EDC 4B                      	DEC     BX                      ; get jfn (start with last one)
 19076                                  
 19077 00002EDD E83538                  	CALL	_$CLOSE
 19078 00002EE0 59                      	POP     CX
 19079 00002EE1 E2F6                    	LOOP    reset_free_jfn          ; and do 'em all
 19080                                  
 19081                                  ; Note: We do need to explicitly close FCBs. Reasons are as follows: If we
 19082                                  ; are running in the no-sharing no-network environment, we are simulating the
 19083                                  ; 2.0 world and thus if the user doesn't close the file, that is his problem
 19084                                  ; BUT... the cache remains in a state with garbage that may be reused by the
 19085                                  ; next process. We scan the set and blast the ref counts of the FCBs we own.
 19086                                  ;
 19087                                  ; If sharing is loaded, then the following call to close process will
 19088                                  ; correctly close all FCBs. We will then need to walk the list AFTER here.
 19089                                  ;
 19090                                  ; Finally, the following call to NET_Abort will cause an EOP to be sent to all
 19091                                  ; known network resources. These resources are then responsible for cleaning
 19092                                  ; up after this process.
 19093                                  ;
 19094                                  ; Sleazy, eh?
 19095                                  
 19096                                  	;context DS			; SS is DOSDATA
 19097 00002EE3 16                      	push	ss
 19098 00002EE4 1F                      	pop	ds  ; 09/09/2018
 19099                                  
 19100                                  	;CallInstall Net_Abort, MultNET, 29
 19101 00002EE5 B81D11                  	mov	ax, 111Dh
 19102 00002EE8 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR 
 19103                                  			;	    - CLOSE ALL REMOTE FILES FOR PROCESS
 19104                                  			; DS???, SS = DOS CS
 19105                                  ;if installed
 19106 00002EEA FF1E[A000]              	call	far [JShare+(4*4)]	; 4 = MFTCloseP
 19107                                  ;else
 19108                                  ;	call 	MFTCloseP
 19109                                  ;endif
 19110                                  
 19111                                  ; Scan the FCB cache for guys that belong to this process and zap their ref
 19112                                  ; counts.
 19113                                  					; SS override
 19114 00002EEE 36C43E[4000]            	les     di,[ss:SFTFCB]		; grab the pointer to the table
 19115                                  	;mov	cx,[es:di+4]
 19116 00002EF3 268B4D04                	mov     cx,[es:di+SFT.SFCount]
 19117 00002EF7 E317                    	jcxz    FCBScanDone
 19118                                  	;lea	di,[di+6]
 19119 00002EF9 8D7D06                  	LEA     DI,[DI+SFT.SFTable]	; point at table
 19120 00002EFC 36A1[3C03]              	mov     ax,[SS:PROC_ID]		; SS override
 19121                                  FCBTest:
 19122                                  	;cmp	[es:di+31h],ax
 19123 00002F00 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax ; is this one of ours
 19124 00002F04 7505                    	jnz	short FCBNext		; no, skip it
 19125 00002F06 26C7050000              	mov	word [es:di],0
 19126                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0  ; yes, blast ref count
 19127                                  FCBNext:
 19128 00002F0B 83C73B                  	add     di,SF_ENTRY.size ; 59 (for MSDOS 6.0)
 19129 00002F0E E2F0                    	loop    FCBTest
 19130                                  FCBScanDone:
 19131                                  
 19132                                  ; Walk the SFT to eliminate all busy SFT's for this process.
 19133                                  
 19134 00002F10 31DB                    	XOR     BX,BX
 19135                                  Scan:
 19136 00002F12 53                      	push    bx
 19137 00002F13 E87A37                  	call	SFFromSFN
 19138 00002F16 5B                      	pop     bx
 19139                                  	;jnc	short Scan1
 19140                                  	;retn
 19141                                  	; 18/12/2022
 19142 00002F17 72B5                    	jc	short NO_Question ; retn
 19143                                  
 19144                                  ;M038
 19145                                  ; Do what the comment above says, check for busy state
 19146                                  
 19147                                  Scan1:
 19148                                  	;cmp	word [es:di],0
 19149                                  	;jz	short scan_next  ; MSDOS 3.3
 19150                                  	; MSDOS 6.0
 19151 00002F19 26833DFF                	cmp	word [es:di],sf_busy ; -1
 19152                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
 19153                                  				; Is Sft busy? ;M038
 19154 00002F1D 7519                    	jnz	short scan_next
 19155                                  ;
 19156                                  ; we have a SFT that is busy. See if it is for the current process
 19157                                  ;
 19158 00002F1F 36A1[3C03]              	mov     ax,[SS:PROC_ID]		; SS override
 19159                                  	;cmp	[es:di+31h],ax
 19160 00002F23 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax
 19161 00002F27 750F                    	jnz	short scan_next
 19162 00002F29 36A1[3E03]              	mov     ax,[SS:USER_ID]		; SS override
 19163                                  	;cmp	[es:di+2Fh],ax
 19164 00002F2D 2639452F                	cmp	[es:di+SF_ENTRY.sf_UID],ax
 19165 00002F31 7505                    	jnz	short scan_next
 19166                                  
 19167                                  ; This SFT is labelled as ours.
 19168                                  
 19169 00002F33 26C7050000              	mov	word [es:di],0
 19170                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0
 19171                                  scan_next:
 19172 00002F38 43                      	inc     bx
 19173 00002F39 EBD7                    	jmp     short Scan
 19174                                  
 19175                                  ;============================================================================
 19176                                  ; CLOSE.ASM, MSDOS 6.0, 1991
 19177                                  ;============================================================================
 19178                                  ; 23/07/2018 - Retro DOS v3.0
 19179                                  ; 18/05/2019 - Retro DOS v4.0
 19180                                  
 19181                                  ;**	Internal Close and Commit calls to close a local or NET SFT.
 19182                                  ;
 19183                                  ;	DOS_CLOSE
 19184                                  ;	DOS_COMMIT
 19185                                  ;	FREE_SFT
 19186                                  ;	SetSFTTimes
 19187                                  ;
 19188                                  ;	Revision history:
 19189                                  ;
 19190                                  ;	   AN000  version 4.00	Jan. 1988
 19191                                  ;	   A005   PTM 3718 --- lost clusters when fastopen installed
 19192                                  ;	   A011   PTM 4766 --- C2 fastopen problem
 19193                                  
 19194                                  ;Installed = TRUE
 19195                                  
 19196                                  ;Break <DOS_CLOSE -- CLOSE FILE from SFT>
 19197                                  ;---------------------------------------------------------------------------
 19198                                  ;
 19199                                  ; Procedure Name : DOS_CLOSE
 19200                                  ;
 19201                                  ; Inputs:
 19202                                  ;	[THISSFT] set to the SFT for the file being used
 19203                                  ; Function:
 19204                                  ;	Close the indicated file via the SFT
 19205                                  ; Returns:
 19206                                  ;	sf_ref_count decremented otherwise
 19207                                  ;	ES:DI point to SFT
 19208                                  ;	Carry set if error
 19209                                  ;	    AX has error code
 19210                                  ; DS preserved, others destroyed
 19211                                  ;---------------------------------------------------------------------------
 19212                                  
 19213                                  ;hkn; DOS_CLOSE called from fcbio.asm and handle.asm. DS alreday set up.
 19214                                  
 19215                                  ; 18/05/2019 - Retro DOS v4.0
 19216                                  ; DOSCODE:6E2Eh (MSDOS 6.21, MSDOS.SYS)
 19217                                  
 19218                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19219                                  ; DOSCODE:6E1Ah (MSDOS 5.0, MSDOS.SYS)
 19220                                  
 19221                                  ; 23/07/2018 - IBMDOS.COM (MSDOS 3.3), 1987 - Offset 39D0h
 19222                                  
 19223                                  DOS_CLOSE:
 19224 00002F3B C43E[9E05]              	LES	DI,[THISSFT]
 19225                                  	;mov	bx,[ES:DI+5]
 19226 00002F3F 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 19227                                  
 19228                                  ; Network closes are handled entirely by the net code.
 19229                                  
 19230                                  	;;test	bx,8000h
 19231                                  	;TEST	BX,sf_isnet
 19232                                  	; 17/12/2022
 19233                                  	;test	bh,80h
 19234 00002F43 F6C780                  	test	bh,(sf_isnet>>8)
 19235 00002F46 7406                    	JZ	short LocalClose
 19236                                  
 19237                                  	;CallInstall Net_Close,MultNET,6
 19238 00002F48 B80611                  	mov     ax,1106h
 19239 00002F4B CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE
 19240                                  			; ES:DI -> SFT
 19241                                  			; SFT DPB field -> DPB of drive containing file
 19242                                  			; Return: CF set on error, AX = DOS error code
 19243                                  			; CF clear if successful
 19244 00002F4D C3                      	retn
 19245                                  
 19246                                  ; All closes release the sharing information.
 19247                                  ; No commit releases sharing information
 19248                                  ;
 19249                                  ; All closes decrement the ref count.
 19250                                  ; No commit decrements the ref count.
 19251                                  
 19252                                  LocalClose:
 19253 00002F4E E8BCE3                  	call	ECritDisk
 19254 00002F51 E86401                  	CALL	SetSFTTimes
 19255 00002F54 E8E200                  	CALL	FREE_SFT		; dec ref count or mark as busy
 19256                                  
 19257                                  ;hkn; SS is DOSDATA
 19258                                  	;Context DS
 19259 00002F57 16                      	push	ss
 19260 00002F58 1F                      	pop	ds
 19261                                  
 19262 00002F59 50                      	push	ax
 19263 00002F5A 53                      	push	bx
 19264 00002F5B E81944                  	call	ShareEnd
 19265 00002F5E 5B                      	pop	bx
 19266 00002F5F 58                      	pop	ax
 19267                                  
 19268                                  ; Commit enters here. AX from commit MUST be <> 1, BX is flags word
 19269                                  
 19270                                  CloseEntry:
 19271 00002F60 50                      	PUSH	AX
 19272                                  
 19273                                  ; File clean or device does not get stamped nor disk looked at.
 19274                                  
 19275                                  	;test	bx,0C0h
 19276                                  	; 17/12/2022
 19277 00002F61 F6C3C0                  	test	bl,devid_file_clean+devid_device
 19278                                  	;TEST	BX,devid_file_clean+devid_device
 19279 00002F64 7403                    	JZ	short rdir
 19280                                  	; 14/11/2022
 19281 00002F66 E9BD00                  	JMP	FREE_SFT_OK		; either clean or device
 19282                                  	;jnz	short FREE_SFT_OK ; 24/07/2019	
 19283                                  
 19284                                  ; Retrieve the directory entry for the file
 19285                                  
 19286                                  rdir:
 19287 00002F69 E8DA00                  	CALL	DirFromSFT
 19288                                  	;mov	al,5
 19289 00002F6C B005                    	MOV	AL,error_access_denied
 19290 00002F6E 7303                    	JNC	short clook
 19291                                  	; 14/11/2022
 19292 00002F70 E9B400                  	JMP	CloseFinish		; pretend the close worked.
 19293                                  	;jc	short CloseFinish ; 24/07/2019
 19294                                  clook:
 19295                                  
 19296                                  ; ES:DI points to entry
 19297                                  ; DS:SI points to SFT
 19298                                  ; ES:BX points to buffer header
 19299                                  
 19300 00002F73 57                      	push	di
 19301 00002F74 56                      	push	si
 19302                                  	;lea	si,[si+20h]
 19303 00002F75 8D7420                  	LEA	SI,[SI+SF_ENTRY.sf_name]
 19304                                  
 19305                                  ; ES:DI point to directory entry
 19306                                  ; DS:SI point to unpacked name
 19307                                  
 19308 00002F78 E884E2                  	call	XCHGP
 19309                                  
 19310                                  ; ES:DI point to unpacked name
 19311                                  ; DS:SI point to directory entry
 19312                                  
 19313 00002F7B E8B60E                  	call	MetaCompare
 19314 00002F7E E87EE2                  	call	XCHGP
 19315 00002F81 5E                      	pop	si
 19316 00002F82 5F                      	pop	di
 19317 00002F83 740C                    	JZ	short CLOSE_GO		; Name OK
 19318                                  Bye:	
 19319 00002F85 89F7                    	MOV	DI,SI
 19320 00002F87 1E                      	PUSH	DS
 19321 00002F88 07                      	POP	ES			; ES:DI points to SFT
 19322 00002F89 16                      	PUSH	SS
 19323 00002F8A 1F                      	POP	DS
 19324 00002F8B F9                      	STC
 19325                                  	;mov	al,2
 19326 00002F8C B002                    	MOV	AL,error_file_not_found
 19327 00002F8E E99600                  	JMP	CloseFinish ; 24/07/2019
 19328                                  
 19329                                  	; 18/05/2019 - Retro DOS v4.0
 19330                                  CLOSE_GO:
 19331                                  	; MSDOS 6.0
 19332                                  	;test	word [si+2],8000h
 19333                                  	;TEST	word [SI+SF_ENTRY.sf_mode],sf_isFCB ; FCB ?
 19334                                  	; 17/12/2022
 19335                                  	;test	byte [si+3],80h
 19336 00002F91 F6440380                	test	byte [SI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8) ; FCB ?
 19337 00002F95 740D                    	JZ	short nofcb		; no, set dir attr, sf_attr
 19338                                  	; MSDOS 3.3 & MSDOS 6.0
 19339                                  	;mov	ch,[es:di+0Bh]
 19340 00002F97 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]
 19341                                  	;mov	al,[si+4]
 19342 00002F9B 8A4404                  	MOV	AL,[SI+SF_ENTRY.sf_attr]
 19343                                  
 19344                                  ;hkn; SS override
 19345 00002F9E 36A2[6B05]              	MOV	[SS:ATTRIB],AL
 19346                                  	; MSDOS 3.3
 19347                                  	;;call	MatchAttributes
 19348                                  	;;JNZ	short Bye		; attributes do not match
 19349                                  	; 18/05/2019
 19350 00002FA2 EB07                    	JMP	SHORT setattr		;FT.
 19351                                  nofcb:
 19352                                  	; MSDOS 6.0
 19353                                  	;mov	al,[si+4]
 19354 00002FA4 8A4404                  	MOV	AL,[SI+SF_ENTRY.sf_attr] ;FT.		;AN000;
 19355 00002FA7 2688450B                	MOV	[ES:DI+dir_entry.dir_attr],AL ;FT.	;AN000;
 19356                                  setattr:
 19357                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19358                                  	;or	byte [es:di+0Bh],20h
 19359 00002FAB 26804D0B20              	OR	BYTE [ES:DI+dir_entry.dir_attr],attr_archive ;Set archive
 19360                                  	; MSDOS 6.0
 19361                                  	;mov	ax,[es:di+1Ah]
 19362 00002FB0 268B451A                	MOV	AX,[ES:DI+dir_entry.dir_first] ;AN011
 19363                                  					;F.O. save old first cluster
 19364                                  ;hkn; SS override
 19365 00002FB4 36A3[BE0F]              	MOV	[SS:OLD_FIRSTCLUS],AX	;AN011;F.O. save old first cluster
 19366                                  
 19367                                  	;mov	ax,[si+0Bh]
 19368 00002FB8 8B440B                  	MOV	AX,[SI+SF_ENTRY.sf_firclus]
 19369                                  	;mov	[es:di+1Ah],ax
 19370 00002FBB 2689451A                	MOV	[ES:DI+dir_entry.dir_first],AX	;Set firclus pointer
 19371                                  	;mov	ax,[si+11h]
 19372 00002FBF 8B4411                  	MOV	AX,[SI+SF_ENTRY.sf_size]
 19373                                  	;mov	[es:di+1Ch],ax
 19374 00002FC2 2689451C                	MOV	[ES:DI+dir_entry.dir_size_l],AX	;Set size
 19375                                  	;mov	ax,[si+13h]
 19376 00002FC6 8B4413                  	MOV	AX,[SI+SF_ENTRY.sf_size+2]
 19377                                  	;mov	[es:di+1Eh],ax
 19378 00002FC9 2689451E                	MOV	[ES:DI+dir_entry.dir_size_h],AX
 19379                                  	;mov	ax,[si+0Fh]
 19380 00002FCD 8B440F                  	MOV	AX,[SI+SF_ENTRY.sf_date]
 19381                                  	;mov	[es:di+18h],ax
 19382 00002FD0 26894518                	MOV	[ES:DI+dir_entry.dir_date],AX	;Set date
 19383                                  	;mov	ax,[si+0Dh]
 19384 00002FD4 8B440D                  	MOV	AX,[SI+SF_ENTRY.sf_time]
 19385                                  	;mov	[es:di+16h],ax
 19386 00002FD7 26894516                	MOV	[ES:DI+dir_entry.dir_time],AX	;Set time
 19387                                  
 19388                                  	; MSDOS 6.0
 19389                                  ;; File Tagging
 19390 00002FDB 26F6470540              	TEST	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty  
 19391                                  				  ;LB. if already dirty		    ;AN000;
 19392 00002FE0 7508                    	JNZ	short yesdirty4	  ;LB.  don't increment dirty count ;AN000;
 19393                                  	; 02/06/2019
 19394 00002FE2 E8742B                  	call	INC_DIRTY_COUNT   ;LB.				    ;AN000;
 19395                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19396                                  	;or	byte [es:bx+5],40h
 19397 00002FE5 26804F0540              	OR	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty
 19398                                  yesdirty4:
 19399 00002FEA 1E                      	push	ds
 19400 00002FEB 56                      	push	si
 19401                                  	; MSDOS 6.0
 19402                                  	;mov	cx,[si+0Bh]
 19403                                  	; 07/12/2022
 19404 00002FEC 8B4C0B                  	MOV	CX,[SI+SF_ENTRY.sf_firclus] ; do this for Fastopen
 19405                                  ;hkn; SS override
 19406 00002FEF 36A0[7605]              	MOV	AL,[SS:THISDRV]
 19407                                  	; MSDOS 3.3 
 19408                                  	;push	ss
 19409                                  	;pop	ds
 19410                                  	;MOV	AL,[THISDRV]
 19411                                  ;;; 10/1/86  update fastopen cache
 19412                                  	; MSDOS 3.3 & MSDOS 6.0
 19413 00002FF3 52                      	PUSH	DX
 19414 00002FF4 B400                    	MOV	AH,0			; dir entry update
 19415 00002FF6 88C2                    	MOV	DL,AL			; drive number A=0, B=1,,,
 19416                                  	; MSDOS 6.0
 19417 00002FF8 09C9                    	OR	CX,CX			;AN005; first cluster 0; may be truncated
 19418 00002FFA 750D                    	JNZ	short do_update2	;AN005; no, do update
 19419 00002FFC B403                    	MOV	AH,3			;AN005; do a delete cache entry
 19420                                  	;mov	di,[si+1Bh]
 19421 00002FFE 8B7C1B                  	MOV	DI,[SI+SF_ENTRY.sf_dirsec] ;AN005; cx:di = dir sector
 19422                                  	;mov	cx,[si+1Dh]
 19423 00003001 8B4C1D                  	MOV	CX,[SI+SF_ENTRY.sf_dirsec+2] ;AN005;
 19424                                  	;mov	dh,[si+1Fh]
 19425 00003004 8A741F                  	MOV	DH,[SI+SF_ENTRY.sf_dirpos] ;AN005; dh = dir pos
 19426 00003007 EB0E                    	JMP	SHORT do_update 	;AN011;F.O.
 19427                                  do_update2:				;AN011;F.O.
 19428                                  ;hkn; SS override fort OLD_FIRSTCLUS
 19429                                  	; 
 19430 00003009 363B0E[BE0F]            	CMP	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O. same as old first clusetr?
 19431 0000300E 7407                    	JZ	short do_update		;AN011;F.O. yes
 19432 00003010 B402                    	MOV	AH,2			;AN011;F.O. delete the old entry
 19433 00003012 368B0E[BE0F]            	MOV	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O.
 19434                                  do_update:				;AN005;
 19435                                  ;hkn; SS is DOSDATA
 19436                                  	;Context DS
 19437 00003017 16                      	push	ss
 19438 00003018 1F                      	pop	ds	
 19439                                  	; MSDOS 3.3 & MSDOS 6.0
 19440 00003019 E8E5F6                  	call	FastOpen_Update 	; invoke fastopen
 19441 0000301C 5A                      	POP	DX
 19442                                  
 19443                                  ;;; 10/1/86  update fastopen cache
 19444 0000301D E8342A                  	call	FLUSHBUF		; flush all relevant buffers
 19445 00003020 5F                      	pop	di
 19446 00003021 07                      	pop	es
 19447                                  	;mov	al,5
 19448 00003022 B005                    	MOV	AL,error_access_denied
 19449 00003024 7201                    	JC	short CloseFinish
 19450                                  FREE_SFT_OK:
 19451 00003026 F8                      	CLC				; signal no error.
 19452                                  CloseFinish:
 19453                                  
 19454                                  ; Indicate to the device that the SFT is being closed.
 19455                                  
 19456                                  ;;;; 7/21/86
 19457 00003027 9C                      	PUSHF				; save flag from DirFromSFT
 19458 00003028 E8D115                  	call	DEV_CLOSE_SFT
 19459 0000302B 9D                      	POPF
 19460                                  ;;;; 7/21/86
 19461                                  ;
 19462                                  ; See if the ref count indicates that we have busied the SFT. If so, mark the
 19463                                  ; SFT as being free. Note that we do NOT need to be in critSFT as we are ONLY
 19464                                  ; going to be moving from busy to free.
 19465                                  ;
 19466 0000302C 59                      	POP	CX			; get old ref count
 19467 0000302D 9C                      	PUSHF
 19468 0000302E 49                      	DEC	CX			; if cx != 1
 19469 0000302F 7503                    	JNZ	short NoFree		; then do NOT free SFT
 19470 00003031 26890D                  	mov	[es:di],cx
 19471                                  	;MOV	[ES:DI+SF_ENTRY.sf_ref_Count],CX ; mov [es:di+0],cx
 19472                                  NoFree:
 19473 00003034 E8F1E2                  	call	LCritDisk
 19474 00003037 9D                      	POPF
 19475 00003038 C3                      	retn
 19476                                  
 19477                                  ;---------------------------------------------------------------------------
 19478                                  ;
 19479                                  ; Procedure Name : FREE_SFT
 19480                                  ;
 19481                                  ; ES:DI -> SFT. Decs sft_ref_count. If the count goes to 0, mark it as busy.
 19482                                  ; Flags preserved. Return old ref count in AX
 19483                                  ;
 19484                                  ; Note that busy is indicated by the SFT ref count being -1.
 19485                                  ;
 19486                                  ;---------------------------------------------------------------------------
 19487                                  
 19488                                  FREE_SFT:
 19489 00003039 9C                      	PUSHF		; Save carry state
 19490 0000303A 268B05                  	mov	ax,[es:di]
 19491                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 19492 0000303D 48                      	DEC	AX
 19493 0000303E 7501                    	JNZ	short SetCount
 19494 00003040 48                      	DEC	AX
 19495                                  SetCount:
 19496 00003041 268705                  	xchg	ax,[es:di]
 19497                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 19498 00003044 9D                      	POPF
 19499 00003045 C3                      	retn
 19500                                  
 19501                                  	; 18/05/2019 - Retro DOS v4.0
 19502                                  
 19503                                  ;----------------------------------------------------------------------------
 19504                                  ;
 19505                                  ; Procedure Name : DirFromSFT
 19506                                  ;
 19507                                  ;   DirFromSFT - locate a directory entry given an SFT.
 19508                                  ;
 19509                                  ;   Inputs:	ES:DI point to SFT
 19510                                  ;		DS = DOSDATA
 19511                                  ;   Outputs:
 19512                                  ;		EXTERR_LOCUS = errLOC_Disk
 19513                                  ;		CurBuf points to buffer
 19514                                  ;		Carry Clear -> operation OK
 19515                                  ;		    ES:DI point to entry
 19516                                  ;		    ES:BX point to buffer
 19517                                  ;		    DS:SI point to SFT
 19518                                  ;		Carry SET   -> operation failed
 19519                                  ;		    registers trashified
 19520                                  ;   Registers modified: ALL
 19521                                  ;----------------------------------------------------------------------------
 19522                                  
 19523                                  DirFromSFT:
 19524                                  	;mov	byte [EXTERR_LOCUS],2
 19525 00003046 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 19526 0000304B 06                      	push	es
 19527 0000304C 57                      	push	di
 19528                                  	; MSDOS 3.3
 19529                                  	;;mov	dx,[es:di+1Dh]
 19530                                  	;MOV	dx,[ES:DI+SF_ENTRY.sf_dirsec]
 19531                                  	; MSDOS 6.0
 19532                                  	;mov	dx,[es:[di+1Dh]
 19533 0000304D 268B551D                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec+2]  ;F.C. >32mb
 19534 00003051 8916[0706]              	MOV	[HIGH_SECTOR],DX		 ;F.C. >32mb
 19535                                  	;mov	dx,[es:di+1Bh]
 19536 00003055 268B551B                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec]
 19537                                  	; 19/05/2019
 19538 00003059 FF36[0706]              	PUSH	word [HIGH_SECTOR]	;F.C. >32mb
 19539                                  	; MSDOS 3.3 & MSDOS 6.0
 19540 0000305D 52                      	PUSH	DX
 19541 0000305E E86A26                  	call	FATREAD_SFT		; ES:BP points to DPB, [THISDRV] set
 19542                                  					; [THISDPB] set
 19543 00003061 5A                      	POP	DX
 19544 00003062 8F06[0706]              	POP	word [HIGH_SECTOR]	;F.C. >32mb
 19545 00003066 721E                    	JC	short PopDone
 19546                                  	; 22/09/2023
 19547                                  	;XOR	AL,AL	; *		; Pre read
 19548                                  	;;mov	byte [ALLOWED],18h
 19549                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 19550                                  	;call	GETBUFFR
 19551                                  	; 22/09/2023
 19552 00003068 E8E528                  	call	GETBUFFER ; * 		; Pre read
 19553 0000306B 7219                    	JC	short PopDone
 19554 0000306D 5E                      	pop	si
 19555 0000306E 1F                      	pop	ds			; Get back SFT pointer
 19556                                  
 19557                                  ;hkn; SS override
 19558 0000306F 36C43E[E205]            	LES	DI,[SS:CURBUF]
 19559                                  	;or	byte [es:di+5],4
 19560 00003074 26804D0504              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 19561 00003079 89FB                    	MOV	BX,DI			; ES:BX point to buffer header
 19562                                  	;;lea	di,[di+16] ; MSDOS 3.3
 19563                                  	;lea	di,[di+20] ; MSDOS 6.0
 19564 0000307B 8D7D14                  	LEA	DI,[DI+BUFINSIZ] 	; Point to buffer
 19565                                  	;mov	al,32
 19566 0000307E B020                    	MOV	AL,dir_entry.size
 19567                                  	;mul	byte [si+1Fh] ; MSDOS 6.0
 19568 00003080 F6641F                  	MUL	byte [SI+SF_ENTRY.sf_dirpos]
 19569 00003083 01C7                    	ADD	DI,AX			; Point at the entry
 19570 00003085 C3                      	retn				; carry is clear
 19571                                  PopDone:
 19572 00003086 5F                      	pop	di
 19573 00003087 07                      	pop	es
 19574                                  PopDone_retn:
 19575 00003088 C3                      	retn
 19576                                  
 19577                                  ;----------------------------------------------------------------------------
 19578                                  ;
 19579                                  ;**	DOS_Commit - UPdate Directory Entries
 19580                                  ;
 19581                                  ;	ENTRY	same as DOS_CLOSE (??? BUGBUG - update this jgl)
 19582                                  ;		(DS) = DOSGROUP
 19583                                  ;	EXIT	Same as DOS_CLOSE except ref_count field is not altered
 19584                                  ;	USES	all but DS
 19585                                  ;
 19586                                  ;----------------------------------------------------------------------------
 19587                                  
 19588                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19589                                  ; DOSCODE:6F72h (MSDOS 5.0, MSDOS.SYS)
 19590                                  
 19591                                  DOS_COMMIT:
 19592                                  	;hkn; called from srvcall. DS already set up.
 19593 00003089 C43E[9E05]              	LES	DI,[THISSFT]
 19594                                  	;mov	bx,[es:di+5]
 19595 0000308D 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 19596                                  	;test	bx,0C0h
 19597                                  	; 17/12/2022
 19598 00003091 F6C3C0                  	test	bl,devid_file_clean+devid_device ;Clears carry
 19599                                  	;TEST	BX,devid_file_clean+devid_device ;Clears carry
 19600 00003094 75F2                    	jnz	short PopDone_retn
 19601                                  	;test	bx,8000h
 19602                                  	; 17/12/2022
 19603                                  	;test	bh,80h
 19604 00003096 F6C780                  	test	bh,(sf_isnet>>8) ; 80h
 19605                                  	;TEST	BX,sf_isnet ; 8000h
 19606 00003099 7406                    	JZ	short LOCAL_COMMIT
 19607                                  
 19608                                  ;IF NOT Installed
 19609                                  ;	transfer NET_COMMIT
 19610                                  ;ELSE
 19611                                  	;mov	ax,1107h
 19612 0000309B B80711                  	MOV	AX,(MultNET<<8)|7
 19613 0000309E CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
 19614                                  			; ES:DI -> SFT
 19615                                  			; SFT DPB field -> DPB of drive containing file
 19616                                  			; Return: CF set on error, AX = DOS error code
 19617                                  			; CF clear if successful
 19618                                  localcommit_retn: ; 18/12/2022	
 19619 000030A0 C3                      	retn
 19620                                  ;ENDIF
 19621                                  
 19622                                  ; Perform local commit operation by doing a close but not releaseing the SFT.
 19623                                  ; There are three ways we can do this. One is to enter a critical section to
 19624                                  ; protect a potential free. The second is to increment the ref count to mask
 19625                                  ; the close decrementing.
 19626                                  ;
 19627                                  ; The proper way is to let the caller's of close decide if a decrement should
 19628                                  ; be done. We do this by providing another entry into close after the
 19629                                  ; decrement and after the share information release.
 19630                                  
 19631                                  ; DOSCODE:6FA0h (MSDOS 6.21, MSDOS.SYS)
 19632                                  ; DOSCODE:6F8Ch (MSDOS 5.0, MSDOS.SYS) 
 19633                                  
 19634                                  LOCAL_COMMIT:
 19635 000030A1 E869E2                  	call	ECritDisk
 19636                                  	; MSDOS 6.0
 19637 000030A4 E866E2                  	call	ECritDisk	;PTM.
 19638 000030A7 E80E00                  	call	SetSFTTimes
 19639 000030AA B8FFFF                  	MOV	AX,-1
 19640 000030AD E8B0FE                  	call	CloseEntry
 19641                                  	; MSDOS 6.0
 19642 000030B0 9C                      	PUSHF			;PTM.				;AN000;
 19643 000030B1 E84015                  	call	DEV_OPEN_SFT	;PTM.  increment device count	;AN000;
 19644 000030B4 9D                      	POPF			;PTM.				;AN000;
 19645                                  	;call	LCritDisk	;PTM.				;AN000;
 19646                                  	; 18/12/2022
 19647 000030B5 E970E2                  	jmp	LCritDisk
 19648                                  ;localcommit_retn:
 19649                                  ;	retn
 19650                                  
 19651                                  ;Break	<SetSFTTimes - signal a change in the times for an SFT>
 19652                                  ;----------------------------------------------------------------------------
 19653                                  ;
 19654                                  ; Procedure Name : SetSFTTimes
 19655                                  ;
 19656                                  ;   SetSFTTimes - Examine the flags for a SFT and set the time appropriately.
 19657                                  ;   Reflect these times in other SFT's for the same file.
 19658                                  ;
 19659                                  ;   Inputs:	ES:DI point to SFT
 19660                                  ;		BX = sf_flags set apprpriately
 19661                                  ;   Outputs:	Set sft times to current time if File & dirty & !nodate
 19662                                  ;   Registers modified: All except ES:DI, BX, AX
 19663                                  ;
 19664                                  ;----------------------------------------------------------------------------
 19665                                  
 19666                                  SetSFTTimes:
 19667                                  ;	File clean or device does not get stamped nor disk looked at.
 19668                                  	
 19669                                  	;test	bx,0C0h
 19670                                  	; 17/12/2022
 19671 000030B8 F6C3C0                  	test	bl,devid_file_clean+devid_device
 19672                                  	;TEST	BX,devid_file_clean+devid_device
 19673                                  	;retnz				; clean or device => no timestamp
 19674 000030BB 75E3                    	jnz	short localcommit_retn
 19675                                  
 19676                                  ;	file and dirty. See if date is good
 19677                                  
 19678                                  	;test	bx,4000h
 19679                                  	; 17/12/2022
 19680                                  	;test	bh,40h
 19681 000030BD F6C740                  	test	bh,(sf_close_nodate>>8)
 19682                                  	;TEST	BX,sf_close_nodate
 19683                                  	;retnz				; nodate => no timestamp
 19684 000030C0 75DE                    	jnz	short localcommit_retn
 19685                                  
 19686 000030C2 50                      	push	ax
 19687 000030C3 53                      	push	bx
 19688 000030C4 E829DA                  	call	DATE16			; Date/Time to AX/DX
 19689                                  	;mov	[es:di+0Fh],ax
 19690 000030C7 2689450F                	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 19691                                  	;mov	[es:di+0Dh],dx
 19692 000030CB 2689550D                	MOV	[ES:DI+SF_ENTRY.sf_time],DX
 19693 000030CF 31C0                    	XOR	AX,AX
 19694                                  ;if installed
 19695                                  	;call	JShare + 14 * 4
 19696 000030D1 FF1E[C800]              	call	far [JShare+(14*4)]	; 14 = ShSU
 19697                                  ;else
 19698                                  ;	call	ShSU
 19699                                  ;endif
 19700 000030D5 5B                      	pop	bx
 19701 000030D6 58                      	pop	ax
 19702 000030D7 C3                      	retn
 19703                                  
 19704                                  ;============================================================================
 19705                                  ; DIRCALL.ASM, MSDOS 6.0, 1991
 19706                                  ;============================================================================
 19707                                  ; 23/07/2018 - Retro DOS v3.0
 19708                                  ; 18/05/2019 - Retro DOS v4.0
 19709                                  
 19710                                  ; DOSCODE:6FDAh (MSDOS 6.21, MSDOS.SYS)
 19711                                  
 19712                                  ;TITLE DIRCALL - Directory manipulation internal calls
 19713                                  ;NAME  DIRCALL
 19714                                  
 19715                                  ;**	Low level directory manipulation routines for making removing and
 19716                                  ;	  verifying local or NET directories
 19717                                  ;
 19718                                  ;	DOS_MKDIR
 19719                                  ;	DOS_CHDIR
 19720                                  ;	DOS_RMDIR
 19721                                  ;
 19722                                  ;	Modification history:
 19723                                  ;
 19724                                  ;		Created: ARR 30 March 1983
 19725                                  
 19726                                  ;BREAK <DOS_MkDir - Make a directory entry>
 19727                                  ;---------------------------------------------------------------------------
 19728                                  ;
 19729                                  ; Procedure Name : DOS_MkDir
 19730                                  ;
 19731                                  ; Inputs:
 19732                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 19733                                  ;		terminated)
 19734                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 19735                                  ;		( = -1 if current dir not involved, else
 19736                                  ;		 Points to first char after last "/" of current dir part)
 19737                                  ;	[THISCDS] Points to CDS being used
 19738                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 19739                                  ; Function:
 19740                                  ;	Make a new directory
 19741                                  ; Returns:
 19742                                  ;	Carry Clear
 19743                                  ;		No error
 19744                                  ;	Carry Set
 19745                                  ;	    AX is error code
 19746                                  ;		error_path_not_found
 19747                                  ;			Bad path (not in curr dir part if present)
 19748                                  ;		error_bad_curr_dir
 19749                                  ;			Bad path in current directory part of path
 19750                                  ;		error_access_denied
 19751                                  ;			Already exists, device name
 19752                                  ; DS preserved, Others destroyed
 19753                                  ;---------------------------------------------------------------------------
 19754                                  
 19755                                  ;hkn; called from path.asm. DS already set up.
 19756                                  
 19757                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19758                                  ; DOSCODE:6FC6h (MSDOS 5.0, MSDOS.SYS)
 19759                                  
 19760                                  DOS_MKDIR:
 19761 000030D8 E870E1                  	call	TestNet
 19762 000030DB 7313                    	JNC	short LOCAL_MKDIR
 19763                                  
 19764                                  ;IF NOT Installed
 19765                                  ;	transfer NET_MKDIR
 19766                                  ;ELSE
 19767                                  	;mov	ax,1103h
 19768 000030DD B80311                  	MOV	AX,(MultNET<<8)|3
 19769 000030E0 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
 19770                                  			; SS = DOS CS
 19771                                  			; SDA first filename pointer -> fully-qualified directory name
 19772                                  			; SDA CDS pointer -> current directory
 19773                                  			; Return: CF set on error, AX = DOS error code
 19774                                  			; CF clear if successful
 19775 000030E2 C3                      	retn
 19776                                  ;ENDIF
 19777                                  
 19778                                  NODEACCERRJ:
 19779                                  	;mov	ax,5
 19780 000030E3 B80500                  	MOV	AX,error_access_denied
 19781                                  _BadRet:
 19782 000030E6 F9                      	STC
 19783                                  	;call	LCritDisk
 19784                                  	;retn
 19785                                  	; 18/12/2022
 19786 000030E7 E93EE2                  	jmp	LCritDisk
 19787                                  
 19788                                  PATHNFJ:
 19789 000030EA E83BE2                  	call	LCritDisk
 19790 000030ED E9EFF9                  	jmp	SET_MKND_ERR	; Map the MakeNode error and return
 19791                                  
 19792                                  LOCAL_MKDIR:
 19793 000030F0 E81AE2                  	call	ECritDisk
 19794                                  
 19795                                  ; MakeNode requires an SFT to fiddle with. We Use a temp spot (RENBUF)
 19796                                  
 19797 000030F3 8C16[A005]              	MOV	[THISSFT+2],SS
 19798                                  
 19799                                  ;hkn; DOSDATA
 19800 000030F7 C706[9E05][3E04]        	MOV	WORD [THISSFT],RENBUF
 19801                                  
 19802                                  ;  NOTE: Need WORD PTR because MASM takes type of
 19803                                  ;   TempSFT (byte) instead of type of sf_mft (word).
 19804                                  
 19805                                  	;mov	word [RENBUF+33h],0 ; MSDOS 6.0
 19806 000030FD C706[7104]0000          	MOV	WORD [RENBUF+SF_ENTRY.sf_MFT],0
 19807                                  				; make sure SHARER won't complain.
 19808                                  	;mov	al,10h
 19809 00003103 B010                    	MOV	AL,attr_directory
 19810 00003105 E88B18                  	call	MakeNode
 19811 00003108 72E0                    	JC	short PATHNFJ
 19812 0000310A 83F803                  	CMP	AX,3
 19813 0000310D 74D4                    	JZ	short NODEACCERRJ ; Can't make a device into a directory
 19814 0000310F C42E[8A05]              	LES	BP,[THISDPB]	; Makenode zaps this
 19815 00003113 C53E[E205]              	LDS	DI,[CURBUF]
 19816 00003117 29FE                    	SUB	SI,DI
 19817 00003119 56                      	PUSH	SI		; Pointer to dir_first
 19818                                  	; MSDOS 6.0
 19819                                  	;push	word [DI+8]
 19820 0000311A FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;F.C. >32mb
 19821                                  	; MSDOS 3.3 & MSDOS 6.0
 19822                                  	;push	word [di+6]
 19823 0000311D FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Sector of new node
 19824 00003120 16                      	push	ss
 19825 00003121 1F                      	pop	ds
 19826 00003122 FF36[C205]              	PUSH	word [DIRSTART]	; Parent for .. entry
 19827 00003126 31C0                    	XOR	AX,AX
 19828 00003128 A3[C205]                	MOV	[DIRSTART],AX	; Null directory
 19829 0000312B E8A117                  	call	NEWDIR
 19830 0000312E 726F                    	JC	short NODEEXISTSPOPDEL ; No room
 19831 00003130 E8680D                  	call	GETENT		; First entry
 19832 00003133 726A                    	JC	short NODEEXISTSPOPDEL ; Screw up
 19833 00003135 C43E[E205]              	LES	DI,[CURBUF]
 19834                                  
 19835                                  	; MSDOS 6.0
 19836 00003139 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 19837                                  				 ;LB. if already dirty		    ;AN000;
 19838 0000313E 7508                    	JNZ	short yesdirty5	 ;LB.   don't increment dirty count ;AN000;
 19839 00003140 E8162A                  	call	INC_DIRTY_COUNT  ;LB.				    ;AN000;
 19840                                  	
 19841                                  	; MSDOS 3.3 & MSDOS 6.0
 19842                                  	;or	byte [es:di+5],40h  ; 07/12/2022
 19843 00003143 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 19844                                  yesdirty5:
 19845                                  	;;add	di,16 ; MSDOS 3.3
 19846                                  	;add	di,20 ; MSDOS 6.0
 19847 00003148 83C714                  	ADD	DI,BUFINSIZ	; Point at buffer
 19848 0000314B B82E20                  	MOV	AX,202EH	; ". "
 19849 0000314E 8B16[C205]              	MOV	DX,[DIRSTART]	; Point at itself
 19850 00003152 E81A18                  	call	SETDOTENT
 19851 00003155 B82E2E                  	MOV	AX,2E2EH	; ".."
 19852 00003158 5A                      	POP	DX		; Parent
 19853 00003159 E81318                  	call	SETDOTENT
 19854 0000315C C42E[8A05]              	LES	BP,[THISDPB]
 19855                                  	; 22/09/2023
 19856                                  	;;mov	byte [ALLOWED],18h
 19857                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 19858 00003160 5A                      	POP	DX		; Entry sector
 19859                                  	; MSDOS 6.0
 19860 00003161 8F06[0706]              	POP	word [HIGH_SECTOR] ;F.C. >32mb
 19861                                  
 19862                                  	;XOR	AL,AL ; *	; Pre read
 19863                                  	;call	GETBUFFR
 19864                                  	; 22/09/2023
 19865 00003165 E8E827                  	call	GETBUFFER ; *	; Pre read
 19866 00003168 725B                    	JC	short NODEEXISTSP
 19867 0000316A 8B16[C205]              	MOV	DX,[DIRSTART]
 19868 0000316E C53E[E205]              	LDS	DI,[CURBUF]
 19869                                  	;or	byte [di+5],4
 19870 00003172 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 19871 00003176 5E                      	POP	SI		; dir_first pointer
 19872 00003177 01FE                    	ADD	SI,DI
 19873 00003179 8914                    	MOV	[SI],DX
 19874 0000317B 31D2                    	XOR	DX,DX
 19875 0000317D 895402                  	MOV	[SI+2],DX	; Zero size
 19876 00003180 895404                  	MOV	[SI+4],DX
 19877                                  DIRUP:
 19878                                  	; MSDOS 6.0
 19879 00003183 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 19880                                  	;			 ;LB. if already dirty 		   ;AN000;
 19881 00003187 7507                    	JNZ	short yesdirty6	 ;LB.  don't increment dirty count ;AN000;
 19882 00003189 E8CD29                  	call	INC_DIRTY_COUNT  ;LB.				   ;AN000;
 19883                                  	
 19884                                  	; MSDOS 3.3 & MSDOS 6.0
 19885                                  	;or	byte [di+5],40h
 19886 0000318C 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty	; Dirty buffer
 19887                                  yesdirty6:
 19888 00003190 16                      	push	ss
 19889 00003191 1F                      	pop	ds
 19890 00003192 268A4600                	mov	al,[es:bp]
 19891                                  	;MOV	AL,[ES:BP+DPB.DRIVE]  ; mov al,[es:bp+0]
 19892 00003196 E8BB28                  	call	FLUSHBUF
 19893                                  	;mov	ax,5
 19894 00003199 B80500                  	MOV	AX,error_access_denied
 19895                                  	;call	LCritDisk
 19896                                  	;retn
 19897                                  	; 18/12/2022
 19898 0000319C E989E1                  	jmp	LCritDisk
 19899                                  
 19900                                  NODEEXISTSPOPDEL:
 19901 0000319F 5A                      	POP	DX		; Parent
 19902 000031A0 5A                      	POP	DX		; Entry sector
 19903                                  	; MSDOS 6.0 
 19904 000031A1 8F06[0706]              	POP	word [HIGH_SECTOR] ; F.C. >32mb
 19905 000031A5 C42E[8A05]              	LES	BP,[THISDPB]
 19906                                  	; 22/09/2023
 19907                                  	;;mov	byte [ALLOWED],18h
 19908                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 19909                                  	;XOR	AL,AL ; *	; Pre read
 19910                                  	;call	GETBUFFR
 19911                                  	; 22/09/2023
 19912 000031A9 E8A427                  	call	GETBUFFER ; *	; Pre read
 19913 000031AC 7217                    	JC	short NODEEXISTSP
 19914 000031AE C53E[E205]              	LDS	DI,[CURBUF]
 19915                                  	;or	byte [di+5],4
 19916 000031B2 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 19917 000031B6 5E                      	POP	SI		; dir_first pointer
 19918 000031B7 01FE                    	ADD	SI,DI
 19919                                  	;sub	si,1Ah ; 26
 19920 000031B9 83EE1A                  	SUB	SI,dir_entry.dir_first	;Point back to start of dir entry
 19921 000031BC C604E5                  	MOV	BYTE [SI],0E5H	; Free the entry
 19922 000031BF E8C1FF                  	CALL	DIRUP		; Error doesn't matter since erroring anyway
 19923                                  NODEEXISTS:
 19924 000031C2 E91EFF                  	JMP	NODEACCERRJ ; 10/08/2018
 19925                                  
 19926                                  NODEEXISTSP:
 19927 000031C5 5E                      	POP	SI		; Clean stack
 19928 000031C6 EBFA                    	JMP	short NODEEXISTS
 19929                                  
 19930                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19931                                  
 19932                                  ;BREAK <DOS_ChDir -- Verify a directory>
 19933                                  ;----------------------------------------------------------------------------
 19934                                  ;
 19935                                  ; Procedure Name : DOS_ChDir
 19936                                  ;
 19937                                  ; Inputs:
 19938                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 19939                                  ;		terminated)
 19940                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 19941                                  ;		( = -1 if current dir not involved, else
 19942                                  ;		 Points to first char after last "/" of current dir part)
 19943                                  ;	[THISCDS] Points to CDS being used May not be NUL
 19944                                  ; Function:
 19945                                  ;	Validate the path for potential new current directory
 19946                                  ; Returns:
 19947                                  ;	NOTE:
 19948                                  ;	    [SATTRIB] is modified by this call
 19949                                  ;	Carry Clear
 19950                                  ;	    CX is cluster number of the DIR, LOCAL CDS ONLY
 19951                                  ;		Caller must NOT set ID fields on a NET CDS.
 19952                                  ;	Carry Set
 19953                                  ;	    AX is error code
 19954                                  ;		error_path_not_found
 19955                                  ;			Bad path
 19956                                  ;		error_access_denied
 19957                                  ;			device or file name
 19958                                  ; DS preserved, Others destroyed
 19959                                  ;----------------------------------------------------------------------------
 19960                                  
 19961                                  ;hkn; called from path.asm and dir2.asm. DS already set up.
 19962                                  
 19963                                  ; 18/05/2019 - Retro DOS v4.0
 19964                                  ; DOSCODE:70DAh (MSDOS 6.21, MSDOS.SYS)
 19965                                  
 19966                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19967                                  ; DOSCODE:70C6h (MSDOS 5.0, MSDOS.SYS)
 19968                                  
 19969                                  DOS_CHDIR:
 19970 000031C8 E880E0                  	call	TestNet
 19971 000031CB 7306                    	JNC	short LOCAL_CHDIR
 19972                                  
 19973                                  ;IF NOT Installed
 19974                                  ;	transfer NET_CHDIR
 19975                                  ;ELSE
 19976                                  	;mov	ax,1105h
 19977 000031CD B80511                  	MOV	AX,(MultNET<<8)|5
 19978 000031D0 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CHDIR
 19979                                  			; SS = DOS CS
 19980                                  			; SDA first filename pointer -> fully-qualified directory name
 19981                                  			; SDA CDS pointer -> current directory
 19982                                  			; Return: CF set on error, AX = DOS error code
 19983                                  			; CF clear if successful
 19984 000031D2 C3                      	retn
 19985                                  ;ENDIF
 19986                                  
 19987                                  LOCAL_CHDIR:
 19988 000031D3 E837E1                  	call	ECritDisk
 19989                                  	; MSDOS 6.0
 19990                                  	;;test	word [es:di+43h],2000h
 19991                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice ;PTM.
 19992                                  	; 17/12/2022
 19993                                  	;test	byte [es:di+44h],20h
 19994 000031D6 26F6454420              	test	byte [ES:DI+curdir.flags+1],(curdir_splice>>8) ;PTM.
 19995 000031DB 7406                    	JZ	short nojoin		   ;PTM.
 19996                                  	;mov	word [es:di+49h], 0FFFFh
 19997 000031DD 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],0FFFFH ;PTM.
 19998                                  nojoin:
 19999                                  	; MSDOS 3.3 & MSDOS 6.0
 20000 000031E3 C606[4C03]00            	MOV	byte [NoSetDir],0 ; FALSE
 20001                                  	;mov	byte [SATTRIB],16h
 20002 000031E8 C606[6D05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 20003                                  				; Dir calls can find these
 20004                                  ; DOS 3.3  6/24/86 FastOpen
 20005 000031ED 800E[3A0D]01            	OR	byte [FastOpenFlg],FastOpen_Set	; set fastopen flag
 20006 000031F2 E8320D                  	call	GETPATH
 20007 000031F5 9C                      	PUSHF						;AN000;
 20008 000031F6 8026[3A0D]80            	AND	byte [FastOpenFlg],Fast_yes ; clear it all ;AC000;
 20009 000031FB 9D                      	POPF						;AN000;
 20010                                  ; DOS 3.3  6/24/86 FastOpen
 20011                                  
 20012                                  	; MSDOS 3.3
 20013                                  	;mov	byte [FastOpenFlg],0
 20014                                  	
 20015                                  	;mov	ax,3
 20016 000031FC B80300                  	MOV	AX,error_path_not_found
 20017 000031FF 7207                    	JC	short ChDirDone
 20018 00003201 753A                    	JNZ	short NOTDIRPATH	; Path not a DIR
 20019 00003203 8B0E[C205]              	MOV	CX,[DIRSTART]		; Get cluster number
 20020 00003207 F8                      	CLC
 20021                                  ChDirDone:
 20022                                  	;call	LCritDisk
 20023                                  	;retn
 20024                                  	; 18/12/2022
 20025 00003208 E91DE1                  	jmp	LCritDisk
 20026                                  
 20027                                  ;BREAK <DOS_RmDir -- Remove a directory>
 20028                                  ;----------------------------------------------------------------------------
 20029                                  ;
 20030                                  ; Procedure Name : DOS_RmDir
 20031                                  ;
 20032                                  ; Inputs:
 20033                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 20034                                  ;		terminated)
 20035                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 20036                                  ;		( = -1 if current dir not involved, else
 20037                                  ;		 Points to first char after last "/" of current dir part)
 20038                                  ;	[THISCDS] Points to CDS being used
 20039                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 20040                                  ; Function:
 20041                                  ;	Remove a directory
 20042                                  ;	NOTE: Attempt to remove current directory must be detected by caller
 20043                                  ; Returns:
 20044                                  ;	NOTE:
 20045                                  ;	    [SATTRIB] is modified by this call
 20046                                  ;	Carry Clear
 20047                                  ;		No error
 20048                                  ;	Carry Set
 20049                                  ;	    AX is error code
 20050                                  ;		error_path_not_found
 20051                                  ;			Bad path (not in curr dir part if present)
 20052                                  ;		error_bad_curr_dir
 20053                                  ;			Bad path in current directory part of path
 20054                                  ;		error_access_denied
 20055                                  ;			device or file name, root directory
 20056                                  ;			Bad directory ('.' '..' messed up)
 20057                                  ; DS preserved, Others destroyed
 20058                                  ;----------------------------------------------------------------------------
 20059                                  
 20060                                  ;hkn; called from path.asm. DS already set up.
 20061                                  
 20062                                  ; 18/05/2019 - Retro DOS v4.0
 20063                                  ; DOSCODE:711Fh (MSDOS 6.21, MSDOS.SYS)
 20064                                  
 20065                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20066                                  ; DOSCODE:710Bh (MSDOS 5.0, MSDOS.SYS)
 20067                                  
 20068                                  DOS_RMDIR:
 20069 0000320B E83DE0                  	call	TestNet
 20070 0000320E 7306                    	JNC	short LOCAL_RMDIR
 20071                                  
 20072                                  ;IF NOT Installed
 20073                                  ;	transfer NET_RMDIR
 20074                                  ;ELSE
 20075                                  	;mov	ax,1101h
 20076 00003210 B80111                  	MOV	AX,(MultNET<<8)|1
 20077 00003213 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
 20078                                  			; SS = DOS CS
 20079                                  			; SDA first filename pointer -> fully-qualified directory name
 20080                                  			; SDA CDS pointer -> current directory
 20081                                  			; Return: CF set on error, AX = DOS error code
 20082                                  			; CF clear if successful
 20083 00003215 C3                      	retn
 20084                                  ;ENDIF
 20085                                  
 20086                                  LOCAL_RMDIR:
 20087 00003216 E8F4E0                  	call	ECritDisk
 20088 00003219 C606[4C03]00            	MOV	byte [NoSetDir],0
 20089                                  	;mov	byte [SATTRIB],16h
 20090 0000321E C606[6D05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 20091                                  					; Dir calls can find these
 20092 00003223 E8010D                  	call	GETPATH
 20093 00003226 720C                    	JC	short NOPATH		; Path not found
 20094 00003228 7513                    	JNZ	short NOTDIRPATH	; Path not a DIR
 20095 0000322A 8B3E[C205]              	MOV	DI,[DIRSTART]
 20096 0000322E 09FF                    	OR	DI,DI			; Root ?
 20097 00003230 750E                    	JNZ	short rmdir_get_buf	; No
 20098 00003232 EB09                    	JMP	SHORT NOTDIRPATH
 20099                                  
 20100                                  NOPATH:
 20101                                  	;mov	ax,3
 20102 00003234 B80300                  	MOV	AX,error_path_not_found
 20103 00003237 E9ACFE                  	JMP	_BadRet
 20104                                  
 20105                                  NOTDIRPATHPOP:
 20106 0000323A 58                      	POP	AX  ; MSDOS 6.0		;F.C. >32mb
 20107 0000323B 58                      	POP	AX
 20108                                  NOTDIRPATHPOP2:
 20109 0000323C 58                      	POP	AX
 20110                                  NOTDIRPATH:
 20111 0000323D E9A3FE                  	JMP	NODEACCERRJ
 20112                                  
 20113                                  rmdir_get_buf:
 20114 00003240 C53E[E205]              	LDS	DI,[CURBUF]
 20115 00003244 29FB                    	SUB	BX,DI		; Compute true offset
 20116 00003246 53                      	PUSH	BX		; Save entry pointer
 20117                                  	
 20118                                  	; MSDOS 6.0
 20119                                  	;push	word [di+8]
 20120 00003247 FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2] ;F.C. >32mb
 20121                                  	
 20122                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20123                                  	;push	word [di+6]
 20124 0000324A FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Save sector number
 20125                                  
 20126                                  ;hkn; SS is DOSDATA
 20127                                  	;context DS
 20128 0000324D 16                      	push	ss
 20129 0000324E 1F                      	pop	ds
 20130                                  	;context ES
 20131 0000324F 16                      	push	ss
 20132 00003250 07                      	pop	es
 20133                                  
 20134                                  ;hkn; NAME1 is in DOSDATA
 20135 00003251 BF[4B05]                	MOV	DI,NAME1
 20136 00003254 B03F                    	MOV	AL,'?'
 20137 00003256 B90B00                  	MOV	CX,11
 20138 00003259 F3AA                    	REP	STOSB
 20139 0000325B 30C0                    	XOR	AL,AL
 20140 0000325D AA                      	STOSB				; Nul terminate it
 20141 0000325E E8590F                  	call	STARTSRCH		; Set search
 20142 00003261 E8340C                  	call	GETENTRY		; Get start of directory
 20143 00003264 72D4                    	JC	short NOTDIRPATHPOP	; Screw up
 20144 00003266 8E1E[E405]              	MOV	DS,[CURBUF+2]
 20145 0000326A 89DE                    	MOV	SI,BX
 20146 0000326C AD                      	LODSW
 20147                                  	;CMP	AX,(' ' SHL 8) OR '.'   ; First entry '.'?
 20148 0000326D 3D2E20                  	cmp	ax,202Eh ; ". "
 20149 00003270 75C8                    	JNZ	short NOTDIRPATHPOP	; Nope
 20150                                  	;add	si,30
 20151 00003272 83C61E                  	ADD	SI,dir_entry.size-2 ; Next entry
 20152 00003275 AD                      	LODSW
 20153                                  	;CMP	AX,('.' SHL 8) OR '.'   ; Second entry '..'?
 20154                                  	;cmp	ax, '..'
 20155 00003276 3D2E2E                  	cmp	ax,2E2Eh
 20156 00003279 75BF                    	JNZ	short NOTDIRPATHPOP	; Nope
 20157                                  
 20158                                  ;hkn; SS is DOSDATA
 20159                                  	;context DS
 20160 0000327B 16                      	push	ss
 20161 0000327C 1F                      	pop	ds
 20162 0000327D C706[4803]0200          	MOV	word [LASTENT],2	; Skip . and ..
 20163 00003283 E8120C                  	call	GETENTRY		; Get next entry
 20164 00003286 72B2                    	JC	short NOTDIRPATHPOP	; Screw up
 20165                                  	;mov	byte [ATTRIB],16h
 20166 00003288 C606[6B05]16            	MOV	byte [ATTRIB],attr_directory+attr_hidden+attr_system
 20167 0000328D E8100B                  	call	SRCH			; Do a search
 20168 00003290 73A8                    	JNC	short NOTDIRPATHPOP	; Found another entry!
 20169 00003292 803E[4A03]00            	CMP	byte [FAILERR],0
 20170 00003297 75A1                    	JNZ	short NOTDIRPATHPOP	; Failure of search due to I 24 FAIL
 20171 00003299 C42E[8A05]              	LES	BP,[THISDPB]
 20172 0000329D 8B1E[C205]              	MOV	BX,[DIRSTART]
 20173 000032A1 E8231C                  	call	RELEASE 		; Release data in sub dir
 20174 000032A4 7294                    	JC	short NOTDIRPATHPOP	; Screw up
 20175 000032A6 5A                      	POP	DX			; Sector # of entry
 20176 000032A7 8F06[0706]              	POP	word [HIGH_SECTOR] ; MSDOS 6.0	; F.C. >32mb
 20177                                  	; 22/09/2023
 20178                                  	;;mov	byte [ALLOWED],18h
 20179                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 20180                                  	;XOR	AL,AL ; *		; Pre read
 20181                                  	;call	GETBUFFR		; Get sector back
 20182 000032AB E8A226                  	call	GETBUFFER ; *		; Pre Read
 20183 000032AE 728C                    	JC	short NOTDIRPATHPOP2	; Screw up
 20184 000032B0 C53E[E205]              	LDS	DI,[CURBUF]
 20185                                  	;or	byte [di+5],4
 20186 000032B4 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 20187 000032B8 5B                      	POP	BX			; Pointer to start of entry
 20188 000032B9 01FB                    	ADD	BX,DI			; Corrected
 20189 000032BB C607E5                  	MOV	BYTE [BX],0E5H		; Free the entry
 20190                                  
 20191                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 20192 000032BE 1E                      	PUSH	DS
 20193                                  
 20194                                  ;hkn; SS is DOSDATA
 20195                                  	;context DS
 20196 000032BF 16                      	push	ss
 20197 000032C0 1F                      	pop	ds
 20198                                  
 20199                                  	; MSDOS 6.0
 20200 000032C1 E80EF4                  	call	FastOpen_Delete 	; call fastopen to delete an entry
 20201                                  
 20202                                  ;	; MSDOS 3.3
 20203                                  ;_FastOpen_Delete:
 20204                                  ;	push	ax
 20205                                  ;	mov	si,[WFP_START]
 20206                                  ;	mov	bx,FastTable
 20207                                  ;	;mov	al,3  ; FONC_delete
 20208                                  ;	mov	al,FONC_delete
 20209                                  ;	call	far [BX+2]  ; FastTable+2
 20210                                  ;	pop	ax
 20211                                  
 20212 000032C4 1F                      	POP	DS
 20213                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 20214                                  
 20215 000032C5 E9BBFE                  	JMP	DIRUP			; In MKDIR, dirty buffer and flush
 20216                                  
 20217                                  ;============================================================================
 20218                                  ; DISK.ASM, MSDOS 6.0, 1991
 20219                                  ;============================================================================
 20220                                  ; 23/07/2018 - Retro DOS v3.0 
 20221                                  ; 04/05/2019 - Retro DOS v4.0
 20222                                  
 20223                                  ;	TITLE	DISK - Disk utility routines
 20224                                  ;	NAME	Disk
 20225                                  
 20226                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 20227                                  ;
 20228                                  ;	SWAPCON
 20229                                  ;	SWAPBACK
 20230                                  ;	DOS_READ
 20231                                  ;	DOS_WRITE
 20232                                  ;	get_io_sft
 20233                                  ;	DirRead
 20234                                  ;	FIRSTCLUSTER
 20235                                  ;	SET_BUF_AS_DIR
 20236                                  ;	FATSecRd
 20237                                  ;	DREAD
 20238                                  ;	CHECK_WRITE_LOCK
 20239                                  ;	CHECK_READ_LOCK
 20240                                  ;
 20241                                  ;	Revision history:
 20242                                  ;
 20243                                  ;		A000   version 4.00  Jan. 1988
 20244                                  ;
 20245                                  ;----------------------------------------------------------------------------
 20246                                  ;
 20247                                  ; M065 : B#5276. On raw read/write of a block of characters if a critical
 20248                                  ;		error happens, DOS retries the entire block assuming that
 20249                                  ;		zero characters were transferred. Modified the code to take
 20250                                  ;		into account the number of characters transfered before
 20251                                  ;		retrying the operation.
 20252                                  ;
 20253                                  ;----------------------------------------------------------------------------
 20254                                  ;
 20255                                  
 20256                                  ;Installed = TRUE
 20257                                  
 20258                                  ;Break	<SwapCon, Swap Back - Old-style I/O to files>
 20259                                  
 20260                                  ; **** Drivers for file input from devices ****
 20261                                  ;----------------------------------------------------------------------------
 20262                                  ;   Indicate that there is no more I/O occurring through another SFT outside
 20263                                  ;   of handles 0 and 1
 20264                                  ;
 20265                                  ;   Inputs:	DS is DOSDATA
 20266                                  ;   Outputs:	CONSWAP is set to false.
 20267                                  ;   Registers modified: none
 20268                                  ;----------------------------------------------------------------------------
 20269                                  
 20270                                  ; IBMDOS.COM (MSDOS 3.3) - Offset 3CF8h
 20271                                  
 20272                                  ; DOSCODE:71E3h (MSDOS 6.21, MSDOS.SYS)
 20273                                  ; 04/05/2019 - Retro DOS v4.0
 20274                                  
 20275                                  ; DOSCODE:71CFh (MSDOS 5.0, MSDOS.SYS)
 20276                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20277                                  
 20278                                  SWAPBACK:
 20279 000032C8 C606[5703]00            	MOV	BYTE [CONSWAP],0	; signal no conswaps
 20280 000032CD C3                      	retn
 20281                                  
 20282                                  ;----------------------------------------------------------------------------
 20283                                  ;
 20284                                  ; Procedure Name : SWAPCON
 20285                                  ;
 20286                                  ;   Copy ThisSFT to CONSFT for use by the 1-12 primitives.
 20287                                  ;
 20288                                  ;   Inputs:	ThisSFT as the sft of the desired file
 20289                                  ;		DS is DOSDATA
 20290                                  ;   Outputs:	CONSWAP is set.  CONSFT = ThisSFT.
 20291                                  ;   Registers modified: none
 20292                                  ;--------------------------------------------------------------------------
 20293                                  
 20294                                  SWAPCON:
 20295                                  	; MSDOS 3.3
 20296                                  	;push	es
 20297                                  	;push	di
 20298                                  	;mov	byte [CONSWAP],1
 20299                                  	;les	di,[THISSFT]
 20300                                  	;mov	word [CONSFT],di
 20301                                  	;mov	word [CONSFT+2],es
 20302                                  	;pop	di
 20303                                  	;pop	es
 20304                                  	;retn
 20305                                  
 20306                                  	; MSDOS 6.0
 20307 000032CE C606[5703]01            	mov	byte [CONSWAP],1	; ConSwap = TRUE
 20308 000032D3 50                      	push	ax
 20309 000032D4 A1[9E05]                	mov	ax,[THISSFT]
 20310 000032D7 A3[E605]                	mov	[CONSFT],ax
 20311 000032DA A1[A005]                	mov	ax,[THISSFT+2]
 20312 000032DD A3[E805]                	mov	[CONSFT+2],ax
 20313 000032E0 58                      	pop	ax
 20314 000032E1 C3                      	retn
 20315                                  
 20316                                  ; DOSCODE:71FDh (MSDOS 6.21, MSDOS.SYS)
 20317                                  ; 04/05/2019 - Retro DOS v4.0
 20318                                  
 20319                                  ;Break	<DOS_READ -- MAIN READ ROUTINE AND DEVICE IN ROUTINES>
 20320                                  ;-----------------------------------------------------------------------------
 20321                                  ;
 20322                                  ; Inputs:
 20323                                  ;	ThisSFT set to the SFT for the file being used
 20324                                  ;	[DMAADD] contains transfer address
 20325                                  ;	CX = No. of bytes to read
 20326                                  ;	DS = DOSDATA
 20327                                  ; Function:
 20328                                  ;	Perform read operation
 20329                                  ; Outputs:
 20330                                  ;    Carry clear
 20331                                  ;	SFT Position and cluster pointers updated
 20332                                  ;	CX = No. of bytes read
 20333                                  ;	ES:DI point to SFT
 20334                                  ;    Carry set
 20335                                  ;	AX is error code
 20336                                  ;	CX = 0
 20337                                  ;	ES:DI point to SFT
 20338                                  ; DS preserved, all other registers destroyed
 20339                                  ;
 20340                                  ;-----------------------------------------------------------------------------
 20341                                  
 20342                                  ;hkn; called from fcbio.asm, handle.asm and dev.asm. DS is be set up.
 20343                                  
 20344                                  ; DOSCODE:71E9h (MSDOS 5.0, MSDOS.SYS)
 20345                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20346                                  
 20347                                  DOS_READ:
 20348 000032E2 C43E[9E05]              	LES	DI,[THISSFT]
 20349                                  
 20350                                  ; Verify that the sft has been opened in a mode that allows reading.
 20351                                  
 20352                                  	;mov	al,[es:di+2]
 20353 000032E6 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 20354                                  	;and	al,0Fh
 20355 000032EA 240F                    	AND	AL,access_mask
 20356                                  	;cmp	al,1
 20357 000032EC 3C01                    	CMP	AL,open_for_write
 20358 000032EE 7503                    	JNE	short READ_NO_MODE	; Is read or both
 20359 000032F0 E90306                  	jmp	SET_ACC_ERR
 20360                                  
 20361                                  READ_NO_MODE:
 20362 000032F3 E8E104                  	call	SETUP
 20363 000032F6 E30B                    	JCXZ	NoIORet 		; no bytes to read - fast return
 20364 000032F8 E869DF                  	call	IsSFTNet
 20365 000032FB 7408                    	JZ	short LOCAL_READ
 20366                                  
 20367                                  ;IF NOT Installed
 20368                                  ;	transfer NET_READ
 20369                                  ;ELSE
 20370                                  	;mov	ax,1108h
 20371 000032FD B80811                  	MOV	AX,(MultNET<<8)|8
 20372 00003300 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE
 20373                                  			; ES:DI -> SFT
 20374                                  			; SFT DPB field -> DPB of drive containing file
 20375                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 20376                                  			; Return: CF set on error, CX = bytes read
 20377 00003302 C3                      	retn
 20378                                  ;ENDIF
 20379                                  
 20380                                  ; The user ended up requesting 0 bytes of input. We do nothing for this case
 20381                                  ; except return immediately.
 20382                                  
 20383                                  NoIORet:
 20384 00003303 F8                      	CLC
 20385 00003304 C3                      	retn
 20386                                  
 20387                                  LOCAL_READ:
 20388                                  	;test	word [es:di+5],80h
 20389                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device  ; Check for named device I/O
 20390 00003305 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 02/06/2019
 20391 0000330A 750E                    	JNZ	short READDEV
 20392                                  
 20393                                  	;mov	byte [EXTERR_LOCUS],2
 20394 0000330C C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 20395 00003311 E8F9DF                  	call	ECritDisk
 20396 00003314 E89B05                  	call	DISKREAD
 20397                                  
 20398                                  critexit:
 20399                                  	;call	LCritDisk
 20400                                  	;retn
 20401                                  	; 16/12/2022
 20402 00003317 E90EE0                  	jmp	LCritDisk
 20403                                  
 20404                                  ; We are reading from a device. Examine the status of the device to see if we
 20405                                  ; can short-circuit the I/O. If the device in the EOF state or if it is the
 20406                                  ; null device, we can safely indicate no transfer.
 20407                                  
 20408                                  READDEV:
 20409                                  	;mov	byte [EXTERR_LOCUS],4
 20410 0000331A C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 20411                                  	;mov	bl,[es:di+5]
 20412 0000331F 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 20413 00003323 C43E[2C03]              	LES	DI,[DMAADD]
 20414                                  	;test	bl,40h
 20415 00003327 F6C340                  	test	BL,devid_device_EOF	; End of file?
 20416 0000332A 7407                    	JZ	short ENDRDDEVJ3
 20417                                  	;test	bl,4
 20418 0000332C F6C304                  	test	BL,devid_device_null	; NUL device?
 20419 0000332F 7405                    	JZ	short TESTRAW 		; NO
 20420 00003331 30C0                    	XOR	AL,AL			; Indicate EOF by setting zero
 20421                                  ENDRDDEVJ3:
 20422                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 20423                                  	;JMP	short ENDRDDEVJ2
 20424                                  	; 16/12/2022
 20425 00003333 E96701                  	jmp	ENDRDDEV ; 04/05/2019
 20426                                  
 20427                                  ; We need to hit the device. Figure out if we do a raw read or we do the
 20428                                  ; bizarre std_con_string_input.
 20429                                  
 20430                                  TESTRAW:
 20431                                  	;test	bl,20h
 20432 00003336 F6C320                  	test	BL,devid_device_raw	; Raw mode?
 20433 00003339 7508                    	JNZ	short DVRDRAW 		; Yes, let the device do all local editing
 20434                                  	;test	bl,1
 20435 0000333B F6C301                  	test	BL,devid_device_con_in	; Is it console device?
 20436 0000333E 7461                    	JZ	short NOTRDCON
 20437 00003340 E98F01                  	JMP	READCON
 20438                                  
 20439                                  DVRDRAW:
 20440 00003343 06                      	PUSH	ES
 20441 00003344 1F                      	POP	DS			; Xaddr to DS:DI
 20442                                  
 20443                                  	; 04/05/2019 - Retro DOS v4.0
 20444                                  
 20445                                  	; MSDOS 6.0
 20446                                  ;SR;
 20447                                  ;Check for win386 presence -- if present, do polled read of characters
 20448                                  
 20449 00003345 36F606[3010]01          	test	byte [ss:IsWin386],1 ; 19/05/2019
 20450 0000334B 7408                    	jz	short ReadRawRetry	;not present
 20451 0000334D F6C301                  	test	bl,devid_device_con_in	;is it console device
 20452 00003350 7403                    	jz	short ReadRawRetry	;no, do normal read
 20453 00003352 E9BA00                  	jmp	do_polling		;yes, do win386 polling loop
 20454                                  
 20455                                  ReadRawRetry:
 20456 00003355 89FB                    	MOV	BX,DI			; DS:BX transfer addr
 20457 00003357 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 20458 00003359 89C2                    	MOV	DX,AX			; Start at 0
 20459 0000335B E89013                  	call	SETREAD
 20460 0000335E 1E                      	PUSH	DS			; Save Seg part of Xaddr
 20461                                  
 20462                                  ;hkn; SS override
 20463 0000335F 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 20464 00003364 E80E13                  	call	DEVIOCALL
 20465 00003367 89FA                    	MOV	DX,DI			; DS:DX is preserved by INT 24
 20466 00003369 B486                    	MOV	AH,86H			; Read error
 20467                                  
 20468                                  ;hkn; SS override
 20469 0000336B 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 20470                                  	; MSDOS 3.3
 20471                                  	;test	di,8000h
 20472                                  	;jz	short CRDROK
 20473                                  	; MSDOS 6.0
 20474 00003370 09FF                    	or	di,di
 20475 00003372 7923                    	jns	short CRDROK		; no errors
 20476                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20477 00003374 E8631F                  	call	CHARHARD
 20478 00003377 89D7                    	MOV	DI,DX			; DS:DI is Xaddr
 20479                                  
 20480                                  	; 04/05/2019
 20481                                  
 20482                                  	; MSDOS 6.0
 20483 00003379 36033E[6C03]            	add	di,[ss:CALLSCNT]	; update ptr and count to reflect the	M065
 20484 0000337E 362B0E[6C03]            	sub	cx,[ss:CALLSCNT]	; number of chars xferred		M065
 20485                                  
 20486                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20487 00003383 08C0                    	OR	AL,AL
 20488 00003385 7410                    	JZ	short CRDROK		; Ignore
 20489 00003387 3C03                    	CMP	AL,3
 20490 00003389 7403                    	JZ	short CRDFERR 		; fail.
 20491 0000338B 1F                      	POP	DS			; Recover saved seg part of Xaddr
 20492 0000338C EBC7                    	JMP	short ReadRawRetry	; Retry
 20493                                  
 20494                                  ; We have encountered a device-driver error. We have informed the user of it
 20495                                  ; and he has said for us to fail the system call.
 20496                                  
 20497                                  CRDFERR:
 20498 0000338E 5F                      	POP	DI			; Clean stack
 20499                                  DEVIOFERR:
 20500                                  
 20501                                  ;hkn; SS override
 20502 0000338F 36C43E[9E05]            	LES	DI,[SS:THISSFT]
 20503 00003394 E95D05                  	jmp	SET_ACC_ERR_DS
 20504                                  
 20505                                  CRDROK:
 20506 00003397 5F                      	POP	DI			; Chuck saved seg of Xaddr
 20507 00003398 89D7                    	MOV	DI,DX
 20508                                  
 20509                                  ;hkn; SS override
 20510 0000339A 36033E[6C03]            	ADD	DI,[ss:CALLSCNT]	; Amount transferred
 20511                                  	;JMP	SHORT ENDRDDEVJ3
 20512                                  	; 16/12/2022
 20513 0000339F EB6B                    	jmp	short ENDRDDEVJ2
 20514                                  
 20515                                  ; We are going to do a cooked read on some character device. There is a
 20516                                  ; problem here, what does the data look like? Is it a terminal device, line
 20517                                  ; CR line CR line CR, or is it file data, line CR LF line CR LF? Does it have
 20518                                  ; a ^Z at the end which is data, or is the ^Z not data?  In any event we're
 20519                                  ; going to do this: Read in pieces up to CR (CRs included in data) or ^z (^z
 20520                                  ; included in data). this "simulates" the way con works in cooked mode
 20521                                  ; reading one line at a time. With file data, however, the lines will look
 20522                                  ; like, LF line CR. This is a little weird.
 20523                                  
 20524                                  NOTRDCON:
 20525 000033A1 8CC0                    	MOV	AX,ES
 20526 000033A3 8ED8                    	MOV	DS,AX
 20527 000033A5 89FB                    	MOV	BX,DI
 20528 000033A7 31D2                    	XOR	DX,DX
 20529 000033A9 89D0                    	MOV	AX,DX
 20530 000033AB 51                      	PUSH	CX
 20531 000033AC B90100                  	MOV	CX,1
 20532 000033AF E83C13                  	call	SETREAD
 20533 000033B2 59                      	POP	CX
 20534                                  
 20535                                  ;hkn; SS override
 20536 000033B3 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 20537                                  	;lds	si,[si+7]
 20538 000033B8 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 20539                                  DVRDLP:
 20540 000033BB E8FD1C                  	call	DSKSTATCHK
 20541 000033BE E8B712                  	call	DEVIOCALL2
 20542 000033C1 57                      	PUSH	DI		; Save "count" done
 20543 000033C2 B486                    	MOV	AH,86H
 20544                                  
 20545                                  ;hkn; SS override
 20546 000033C4 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 20547                                  	
 20548                                  	; MSDOS 3.3
 20549                                  	;test	di,8000h
 20550                                  	;jz	short CRDOK
 20551                                  	; MSDOS 6.0
 20552 000033C9 09FF                    	or	di,di
 20553 000033CB 7917                    	jns	short CRDOK
 20554                                  	
 20555 000033CD E80A1F                  	call	CHARHARD
 20556 000033D0 5F                      	POP	DI
 20557                                  
 20558                                  ;hkn; SS override
 20559 000033D1 36C706[6C03]0100        	MOV	word [SS:CALLSCNT],1
 20560 000033D8 3C01                    	CMP	AL,1
 20561 000033DA 74DF                    	JZ	short DVRDLP		;Retry
 20562 000033DC 3C03                    	CMP	AL,3
 20563 000033DE 74AF                    	JZ	short DEVIOFERR		; FAIL
 20564 000033E0 30C0                    	XOR	AL,AL			; Ignore, Pick some random character
 20565 000033E2 EB12                    	JMP	SHORT DVRDIGN
 20566                                  
 20567                                  CRDOK:
 20568 000033E4 5F                      	POP	DI
 20569                                  
 20570                                  ;hkn; SS override
 20571 000033E5 36833E[6C03]01          	CMP	word [SS:CALLSCNT],1
 20572                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 20573 000033EB 751F                    	JNZ	short ENDRDDEVJ2
 20574                                  	; 16/12/2022
 20575                                  	;jnz	short ENDRDDEV ; 24/07/2019
 20576                                  
 20577 000033ED 1E                      	PUSH	DS
 20578                                  
 20579                                  ;hkn; SS override
 20580 000033EE 368E1E[6A03]            	MOV	DS,[SS:CALLXAD+2]
 20581 000033F3 8A05                    	MOV	AL,[DI]			; Get the character we just read
 20582 000033F5 1F                      	POP	DS
 20583                                  DVRDIGN:
 20584                                  
 20585                                  ;hkn; SS override
 20586 000033F6 36FF06[6803]            	INC	WORD [SS:CALLXAD]	; Next character
 20587 000033FB 36C706[5D03]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 20588 00003402 47                      	INC	DI			; Next character
 20589 00003403 3C1A                    	CMP	AL,1Ah			; ^Z?
 20590                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 20591 00003405 7405                    	JZ	short ENDRDDEVJ2	; Yes, done zero set (EOF)
 20592                                  	; 16/12/2022
 20593                                  	;jz	short ENDRDDEV ; 24/07/2019	
 20594 00003407 3C0D                    	CMP	AL,c_CR  ; 0Dh		; CR?
 20595 00003409 E0B0                    	LOOPNZ	DVRDLP			; Loop if no, else done
 20596 0000340B 40                      	INC	AX			; Resets zero flag so NOT EOF, unless
 20597                                  					;  AX=FFFF which is not likely
 20598                                  ENDRDDEVJ2:
 20599                                  	; 16/12/2022
 20600                                  	;JMP	short ENDRDDEV		; changed short to long for win386
 20601                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20602 0000340C E98E00                  	jmp	ENDRDDEV
 20603                                  
 20604                                  	; 04/05/2019
 20605                                  
 20606                                  	; MSDOS 6.0
 20607                                  ;SR;
 20608                                  ;Polling code for raw read on CON when WIN386 is present
 20609                                  ;
 20610                                  ;At this point -- ds:di is transfer address
 20611                                  ;		  cx is count
 20612                                  
 20613                                  do_polling:
 20614 0000340F 89FB                    	mov	bx,di			;ds:bx is Xfer address
 20615 00003411 31C0                    	xor	ax,ax
 20616 00003413 89C2                    	mov	dx,ax
 20617 00003415 E8D612                  	call	SETREAD			;prepare device packet
 20618                                  
 20619                                  do_io:
 20620                                  ;Change read to a NON-DESTRUCTIVE READ, NO WAIT
 20621                                  
 20622 00003418 26C6470205              	mov	byte [es:bx+2],DEVRDND ; 5 ;Change command code
 20623 0000341D 1E                      	push	ds
 20624 0000341E 36C536[9E05]            	lds	si,[ss:THISSFT]		;get device header
 20625 00003423 E84F12                  	call	DEVIOCALL		;call device driver
 20626 00003426 1F                      	pop	ds
 20627                                  	
 20628                                  	;test	word [es:bx+3],8000h
 20629                                  	; 16/12/2022
 20630                                  	;test	byte [es:bx+4],80h
 20631 00003427 26F6470480              	test	byte [es:bx+SRHEAD.REQSTAT+1],STERR>>8 
 20632                                  	;test	word [es:bx+SRHEAD.REQSTAT],STERR ;check if error
 20633 0000342C 7413                    	jz	short check_busy	;no
 20634                                  
 20635 0000342E 1E                      	push	ds
 20636 0000342F 89FA                    	mov	dx,di
 20637                                  	;invoke charhard		;invoke int 24h handler
 20638 00003431 E8A61E                  	call	CHARHARD
 20639 00003434 89D7                    	mov	di,dx
 20640 00003436 08C0                    	or	al,al
 20641 00003438 745D                    	jz	short pop_done_read	;ignore by user, assume read done
 20642 0000343A 3C03                    	cmp	al,3
 20643 0000343C 7448                    	jz	short devrderr		;user asked to fail
 20644 0000343E 1F                      	pop	ds
 20645 0000343F EBD7                    	jmp	short do_io		;user asked to retry
 20646                                  
 20647                                  check_busy:
 20648                                  	;test	word [es:bx+3],200h
 20649                                  	; 16/12/2022
 20650 00003441 26F6470402              	test	byte [es:bx+SRHEAD.REQSTAT+1],02h
 20651                                  	;test	word [es:bx+SRHEAD.REQSTAT],0200h ;see if busy bit set
 20652 00003446 7547                    	jnz	short no_char		;yes, no character available
 20653                                  
 20654                                  ;Character is available. Read in 1 character at a time until all characters
 20655                                  ;are read in or no character is available
 20656                                  
 20657 00003448 26C6470204              	mov	byte [es:bx+2],DEVRD ; 4 ;command code is READ now
 20658 0000344D 26C747120100            	mov	word [es:bx+18],1	;change count to 1 character
 20659 00003453 1E                      	push	ds
 20660 00003454 36C536[9E05]            	lds	si,[ss:THISSFT]
 20661 00003459 E81912                  	call	DEVIOCALL
 20662                                  
 20663 0000345C 89FA                    	mov	dx,di
 20664 0000345E B486                    	mov	ah,86h
 20665                                  	;mov	di,[es:bx+3]
 20666 00003460 268B7F03                	mov	di,[es:bx+SRHEAD.REQSTAT] ;get returned status
 20667 00003464 F7C70080                	test	di,STERR ; 8000h	;was there an error during read?
 20668 00003468 7410                    	jz	short next_char		;no,read next character
 20669                                  
 20670                                  	;invoke	charhard		;invoke int 24h handler
 20671 0000346A E86D1E                  	call	CHARHARD
 20672 0000346D 89D7                    	mov	di,dx			;restore di
 20673 0000346F 08C0                    	or	al,al			;
 20674 00003471 7424                    	jz	short pop_done_read	;ignore by user,assume read is done
 20675 00003473 3C03                    	cmp	al,3
 20676 00003475 740F                    	jz	short devrderr		;user issued a 'fail',indicate error
 20677 00003477 1F                      	pop	ds
 20678 00003478 EB9E                    	jmp	short do_io		;user issued a retry
 20679                                  
 20680                                  next_char:
 20681 0000347A 1F                      	pop	ds
 20682 0000347B 89D7                    	mov	di,dx
 20683 0000347D 49                      	dec	cx			;decrement count
 20684 0000347E E318                    	jcxz	done_read		;all characters read in
 20685 00003480 26FF470E                	inc	word [es:bx+14]		;update transfer address
 20686 00003484 EB92                    	jmp	short do_io			;read next character in
 20687                                  
 20688                                  devrderr:
 20689 00003486 5F                      	pop	di			;discard segment address
 20690 00003487 36C43E[9E05]            	les	di,[ss:THISSFT]
 20691                                  	;transfer SET_ACC_ERR_DS	;indicate error
 20692 0000348C E96504                  	jmp     SET_ACC_ERR_DS
 20693                                  
 20694                                  no_char:
 20695                                  ;Since no character is available, we let win386 switch the VM out
 20696                                  
 20697 0000348F 50                      	push	ax
 20698 00003490 B484                    	mov	ah,84h	; Microsoft Networks - KEYBOARD BUSY LOOP
 20699 00003492 CD2A                    	int	2Ah			;indicate idle to WIN386
 20700                                  
 20701                                  ;When control returns from WIN386, we continue the raw read
 20702                                  
 20703 00003494 58                      	pop	ax
 20704 00003495 EB81                    	jmp	do_io
 20705                                  
 20706                                  pop_done_read:
 20707 00003497 1F                      	pop	ds
 20708                                  done_read:
 20709 00003498 36033E[6C03]            	add	di,[ss:CALLSCNT] ; 19/05/2019
 20710                                  
 20711                                  	; 16/12/2022
 20712                                  
 20713                                  	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 20714                                  	;jmp	ENDRDDEV ; 04/05/2019
 20715                                  
 20716                                  	; 04/05/2019 - Retro DOS v4.0
 20717                                  ENDRDDEV:
 20718 0000349D 16                      	push	ss
 20719 0000349E 1F                      	pop	ds
 20720 0000349F EB1F                    	jmp	short endrddev1
 20721                                  
 20722                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20723                                  	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 20724                                  
 20725                                  TRANBUF:
 20726 000034A1 AC                      	LODSB
 20727 000034A2 AA                      	STOSB
 20728 000034A3 3C0D                    	CMP	AL,c_CR ; 0Dh	; Check for carriage return
 20729 000034A5 7503                    	JNZ	short NORMCH
 20730 000034A7 C6040A                  	MOV	BYTE [SI],c_LF ; 0Ah
 20731                                  NORMCH:
 20732 000034AA 3C0A                    	CMP	AL,c_LF ; 0Ah
 20733 000034AC E0F3                    	LOOPNZ	TRANBUF
 20734 000034AE 7507                    	JNZ	short ENDRDCON
 20735 000034B0 31F6                    	XOR	SI,SI		; Cause a new buffer to be read
 20736 000034B2 E8ACE1                  	call	OUTT		; Transmit linefeed
 20737 000034B5 0C01                    	OR	AL,1		; Clear zero flag--not end of file
 20738                                  ENDRDCON:
 20739                                  ;hkn; SS is DOSDATA
 20740 000034B7 16                      	push	ss
 20741 000034B8 1F                      	pop	ds
 20742 000034B9 E80CFE                  	CALL	SWAPBACK
 20743 000034BC 8936[2200]              	MOV	[CONTPOS],SI
 20744                                  
 20745                                  	; 16/12/2022
 20746                                  ;ENDRDDEV:
 20747                                  ;;hkn; SS is DOSDATA
 20748                                  ;	push	ss
 20749                                  ;	pop	ds
 20750                                  endrddev1:	; 04/05/2019
 20751 000034C0 893E[B805]              	MOV	[NEXTADD],DI
 20752 000034C4 7509                    	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 20753 000034C6 C43E[9E05]              	LES	DI,[THISSFT]
 20754                                  	;and	byte [es:di+5],0BFh
 20755 000034CA 26806505BF              	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF 
 20756                                  				; Mark as no more data available
 20757                                  SETSFTC:
 20758                                  	; 31/07/2019
 20759                                  	;call	SETSFT
 20760                                  	;retn
 20761 000034CF E9B604                  	jmp	SETSFT
 20762                                  
 20763                                  ; 16/12/2022
 20764                                  %if 0
 20765                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20766                                  ENDRDDEV:
 20767                                  ;hkn; SS is DOSDATA
 20768                                  	push	ss
 20769                                  	pop	ds
 20770                                  	MOV	[NEXTADD],DI
 20771                                  	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 20772                                  	LES	DI,[THISSFT]
 20773                                  	;and	byte [es:di+5],0BFh
 20774                                  	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF 
 20775                                  				; Mark as no more data available
 20776                                  SETSFTC:
 20777                                  	;call	SETSFT
 20778                                  	;retn
 20779                                  	jmp	SETSFT	
 20780                                  %endif
 20781                                  
 20782                                  READCON:
 20783 000034D2 E8F9FD                  	CALL	SWAPCON
 20784 000034D5 8B36[2200]              	MOV	SI,[CONTPOS]
 20785 000034D9 09F6                    	OR	SI,SI
 20786 000034DB 75C4                    	JNZ	short TRANBUF
 20787 000034DD 803E[7B02]80            	CMP	BYTE [CONBUF],128 ; 80h
 20788 000034E2 7406                    	JZ	short GETBUF
 20789 000034E4 C706[7B02]80FF          	MOV	WORD [CONBUF],0FF80H ; Set up 128-byte buffer with no template
 20790                                  GETBUF:
 20791 000034EA 51                      	PUSH	CX
 20792 000034EB 06                      	PUSH	ES
 20793 000034EC 57                      	PUSH	DI
 20794                                  
 20795                                  ;hkn; CONBUF is in DOSDATA
 20796 000034ED BA[7B02]                	MOV	DX,CONBUF
 20797                                  
 20798 000034F0 E8E9DE                  	call	_$STD_CON_STRING_INPUT	; Get input buffer
 20799 000034F3 5F                      	POP	DI
 20800 000034F4 07                      	POP	ES
 20801 000034F5 59                      	POP	CX
 20802                                  
 20803                                  ;hkn; CONBUF is in DOSDATA
 20804 000034F6 BE[7D02]                	MOV	SI,CONBUF+2
 20805                                  
 20806 000034F9 803C1A                  	CMP	BYTE [SI],1AH	; Check for Ctrl-Z in first character
 20807 000034FC 75A3                    	JNZ	short TRANBUF
 20808 000034FE B01A                    	MOV	AL,1AH
 20809 00003500 AA                      	STOSB
 20810 00003501 4F                      	DEC	DI
 20811 00003502 B00A                    	MOV	AL,c_LF
 20812 00003504 E85AE1                  	call	OUTT		; Send linefeed
 20813 00003507 31F6                    	XOR	SI,SI
 20814 00003509 EBAC                    	JMP	short ENDRDCON ; 04/05/2019
 20815                                  
 20816                                  ; 24/07/2018 - Retro DOS v3.0
 20817                                  
 20818                                  ;Break	<DOS_WRITE -- MAIN WRITE ROUTINE AND DEVICE OUT ROUTINES>
 20819                                  ;---------------------------------------------------------------------------
 20820                                  ;
 20821                                  ; Procedure Name : DOS_WRITE
 20822                                  ;
 20823                                  ; Inputs:
 20824                                  ;	ThisSFT set to the SFT for the file being used
 20825                                  ;	[DMAADD] contains transfer address
 20826                                  ;	CX = No. of bytes to write
 20827                                  ; Function:
 20828                                  ;	Perform write operation
 20829                                  ;	NOTE: If CX = 0 on input, file is truncated or grown
 20830                                  ;		to current sf_position
 20831                                  ; Outputs:
 20832                                  ;    Carry clear
 20833                                  ;	SFT Position and cluster pointers updated
 20834                                  ;	CX = No. of bytes written
 20835                                  ;	ES:DI point to SFT
 20836                                  ;    Carry set
 20837                                  ;	AX is error code
 20838                                  ;	CX = 0
 20839                                  ;	ES:DI point to SFT
 20840                                  ; DS preserved, all other registers destroyed
 20841                                  ;---------------------------------------------------------------------------
 20842                                  
 20843                                  ;hkn; called from fcbio2.asm, handle.asm and dev.asm. DS is set up at this 
 20844                                  ;hkn; point to DOSDATA.
 20845                                  
 20846                                  ; 04/05/2019 - Retro DOS v4.0
 20847                                  ; DOSCODE:742Ch (MSDOS 6.21, MSDOS.SYS)
 20848                                  
 20849                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20850                                  ; DOSCODE:7418h (MSDOS 5.0, MSDOS.SYS)
 20851                                  
 20852                                  DOS_WRITE:
 20853 0000350B C43E[9E05]              	LES	DI,[THISSFT]
 20854                                  	;mov	al,[ES:DI+2]
 20855 0000350F 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 20856                                  	;and	al,0Fh
 20857 00003513 240F                    	AND	AL,access_mask
 20858                                  	;cmp	al,0
 20859 00003515 3C00                    	CMP	AL,open_for_read
 20860 00003517 7503                    	JNE	short Check_FCB_RO		 ;Is write or both
 20861                                  BadMode:
 20862 00003519 E9DA03                  	jmp	SET_ACC_ERR
 20863                                  
 20864                                  ; NOTE: The following check for writting to a Read Only File is performed
 20865                                  ;	    ONLY on FCBs!!!!
 20866                                  ;	We ALLOW writes to Read Only files via handles to allow a CREATE
 20867                                  ;	    of a read only file which can then be written to.
 20868                                  ;	This is OK because we are NOT ALLOWED to OPEN a RO file via handles
 20869                                  ;	    for writting, or RE-CREATE an EXISTING RO file via handles. Thus,
 20870                                  ;	    CREATing a NEW RO file, or RE-CREATing an existing file which
 20871                                  ;	    is NOT RO to be RO, via handles are the only times we can write
 20872                                  ;	    to a read-only file.
 20873                                  
 20874                                  Check_FCB_RO:
 20875                                  	;;test	word [es:di+2],8000h
 20876                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 20877                                  	;JZ	short WRITE_NO_MODE	; Not an FCB
 20878                                  	
 20879                                  	;test	byte [es:di+3],80h
 20880 0000351C 26F6450380              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 20881 00003521 7407                    	JZ	short WRITE_NO_MODE	; Not an FCB
 20882                                  
 20883                                  	;test	byte [es:di+4],1
 20884 00003523 26F6450401              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_read_only
 20885 00003528 75EF                    	JNZ	short BadMode 		; Can't write to Read_Only files via FCB
 20886                                  WRITE_NO_MODE:
 20887 0000352A E8AA02                  	call	SETUP
 20888 0000352D E834DD                  	call	IsSFTNet
 20889 00003530 7406                    	JZ	short LOCAL_WRITE
 20890                                  
 20891                                  ;IF NOT Installed
 20892                                  ;	transfer NET_WRITE
 20893                                  ;ELSE
 20894                                  	;mov	ax,1109h
 20895 00003532 B80911                  	MOV	AX,(MultNET<<8)|9
 20896 00003535 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
 20897                                  			; ES:DI -> SFT
 20898                                  			; SFT DPB field -> DPB of drive containing file
 20899                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 20900                                  			; Return: CF set on error, CX = bytes written
 20901 00003537 C3                      	retn
 20902                                  ;ENDIF
 20903                                  
 20904                                  LOCAL_WRITE:
 20905                                  	;;test	word [es:di+5],80h
 20906                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 20907                                  	;jnz	short WRTDEV
 20908                                  
 20909                                  	;test	byte [es:di+5],80h
 20910 00003538 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; Check for named device I/O
 20911 0000353D 756E                    	jnz	short WRTDEV
 20912                                  
 20913                                  	;mov	byte [EXTERR_LOCUS],2
 20914 0000353F C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 20915 00003544 E8C6DD                  	call	ECritDisk
 20916                                  
 20917 00003547 E8F404                  	call	DISKWRITE
 20918                                  
 20919                                  	; 04/05/2019 - Retro DOS v4.0
 20920                                  
 20921                                  	; MSDOS 6.0
 20922                                  ; Extended Open
 20923 0000354A 7210                    	JC	short nocommit
 20924                                  	
 20925 0000354C C43E[9E05]              	LES	DI,[THISSFT]
 20926                                  	
 20927                                  	;;test	word [ES:DI+2],4000h
 20928                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],AUTO_COMMIT_WRITE
 20929                                  	;JZ	short nocommit
 20930                                  	
 20931                                  	;test	byte [ES:DI+3],40h
 20932 00003550 26F6450340              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(AUTO_COMMIT_WRITE>>8)
 20933 00003555 7405                    	JZ	short nocommit
 20934                                  	
 20935 00003557 51                      	PUSH	CX
 20936 00003558 E82EFB                  	call	DOS_COMMIT
 20937 0000355B 59                      	POP	CX
 20938                                  nocommit:
 20939                                  ; Extended Open
 20940                                  	;call	LCritDisk
 20941                                  	;retn
 20942                                  	; 18/12/2022
 20943 0000355C E9C9DD                  	jmp	LCritDisk
 20944                                  
 20945                                  DVWRTRAW:
 20946 0000355F 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 20947 00003561 E8BD11                  	call	SETWRITE
 20948 00003564 1E                      	PUSH	DS			; Save seg of transfer
 20949                                  
 20950                                  ;hkn; SS override
 20951 00003565 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 20952 0000356A E80811                  	call	DEVIOCALL		; DS:SI -> DEVICE
 20953                                  
 20954 0000356D 89FA                    	MOV	DX,DI			; Offset part of Xaddr saved in DX
 20955 0000356F B487                    	MOV	AH,87H
 20956                                  
 20957                                  ;hkn; SS override
 20958 00003571 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 20959                                  
 20960                                  	; MSDOS 3.3
 20961                                  	;test	di,8000h
 20962                                  	;jz	short CWRTROK
 20963                                  
 20964                                  	; MSDOS 6.0
 20965 00003576 09FF                    	or	di,di
 20966 00003578 7920                    	jns	short CWRTROK
 20967                                  	
 20968                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20969 0000357A E85D1D                  	call	CHARHARD
 20970                                  
 20971                                  	; 04/05/2019  - Retro DOS v4.0
 20972                                  
 20973                                  	; MSDOS 6.0
 20974 0000357D 362B0E[6C03]            	sub	cx,[ss:CALLSCNT]	; update ptr & count to reflect	M065
 20975 00003582 89D3                    	mov	bx,dx			; number of chars xferred	M065
 20976 00003584 36031E[6C03]            	add	bx,[ss:CALLSCNT]	;				M065
 20977 00003589 89DF                    	mov	di,bx			;				M065
 20978                                  	
 20979                                  	; MSDOS 3.3
 20980                                  	;MOV	BX,DX			; Recall transfer addr		M065
 20981                                  
 20982                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20983 0000358B 08C0                    	OR	AL,AL
 20984 0000358D 740B                    	JZ	short CWRTROK 		; Ignore
 20985 0000358F 3C03                    	CMP	AL,3
 20986 00003591 7403                    	JZ	short CWRFERR
 20987 00003593 1F                      	POP	DS			; Recover saved seg of transfer
 20988 00003594 EBC9                    	JMP	short DVWRTRAW		; Try again
 20989                                  CWRFERR:
 20990 00003596 58                      	POP	AX			; Chuck saved seg of transfer
 20991 00003597 E9F4FD                  	JMP	CRDFERR 		; Will pop one more stack element
 20992                                  CWRTROK:
 20993 0000359A 58                      	POP	AX			; Chuck saved seg of transfer
 20994 0000359B 1F                      	POP	DS
 20995 0000359C A1[6C03]                	MOV	AX,[CALLSCNT]		; Get actual number of bytes transferred
 20996                                  ENDWRDEV:
 20997 0000359F C43E[9E05]              	LES	DI,[THISSFT]
 20998 000035A3 89C1                    	MOV	CX,AX
 20999                                  	;call	ADDREC
 21000                                  	;retn
 21001                                  	; 16/12/2022
 21002                                  	; 10/06/2019
 21003 000035A5 E90104                  	jmp	ADDREC
 21004                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21005                                  	;call	ADDREC
 21006                                  	;retn
 21007                                  	
 21008                                  WRTNUL:
 21009 000035A8 89CA                    	MOV	DX,CX			; Entire transfer done
 21010                                  WRTCOOKJ:
 21011 000035AA E98D00                  	JMP	WRTCOOKDONE
 21012                                  WRTDEV:
 21013                                  	;mov	byte [EXTERR_LOCUS],4
 21014 000035AD C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 21015                                  	;or	byte [es:di+5],40h
 21016 000035B2 26804D0540              	OR	BYTE [ES:DI+SF_ENTRY.sf_flags],devid_device_EOF
 21017                                  					; Reset EOF for input
 21018                                  	;mov	bl,[es:di+5]
 21019 000035B7 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 21020 000035BB 31C0                    	XOR	AX,AX
 21021 000035BD E3E0                    	JCXZ	ENDWRDEV		; problem of creating on a device.
 21022 000035BF 1E                      	PUSH	DS
 21023 000035C0 88D8                    	MOV	AL,BL
 21024 000035C2 C51E[2C03]              	LDS	BX,[DMAADD]		; Xaddr to DS:BX
 21025 000035C6 89DF                    	MOV	DI,BX			; Xaddr to DS:DI
 21026 000035C8 31D2                    	XOR	DX,DX			; Set starting point
 21027                                  	;test	al,20h
 21028 000035CA A820                    	test	AL,devid_device_raw	; Raw?
 21029                                  	;JZ	short TEST_DEV_CON
 21030                                  	;JMP	DVWRTRAW
 21031                                  	; 16/12/2022
 21032 000035CC 7591                    	jnz	short DVWRTRAW
 21033                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21034                                  	;JZ	short TEST_DEV_CON
 21035                                  	;JMP	short DVWRTRAW
 21036                                  
 21037                                  TEST_DEV_CON:
 21038                                  	;test	al,2
 21039 000035CE A802                    	test	AL,devid_device_con_out ; Console output device?
 21040 000035D0 756E                    	jnz	short WRITECON
 21041                                  	;test	al,4
 21042 000035D2 A804                    	test	AL,devid_device_null
 21043 000035D4 75D2                    	JNZ	short WRTNUL
 21044 000035D6 89D0                    	MOV	AX,DX
 21045 000035D8 803F1A                  	CMP	BYTE [BX],1Ah		; ^Z?
 21046 000035DB 74CD                    	JZ	short WRTCOOKJ		; Yes, transfer nothing
 21047 000035DD 51                      	PUSH	CX
 21048 000035DE B90100                  	MOV	CX,1
 21049 000035E1 E83D11                  	call	SETWRITE
 21050 000035E4 59                      	POP	CX
 21051                                  
 21052                                  ;hkn; SS override
 21053 000035E5 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 21054                                  ;
 21055                                  ;SR; Removed X25 support from here
 21056                                  ;
 21057                                  	;lds	si,[si+7]
 21058 000035EA C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 21059                                  DVWRTLP:
 21060 000035ED E8CB1A                  	call	DSKSTATCHK
 21061 000035F0 E88510                  	call	DEVIOCALL2
 21062 000035F3 57                      	PUSH	DI
 21063 000035F4 B487                    	MOV	AH,87H
 21064                                  
 21065                                  ;hkn; SS override
 21066 000035F6 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 21067                                  	
 21068                                  	; MSDOS 3.3
 21069                                  	;test	di,8000h
 21070                                  	;jz	short CWROK
 21071                                  
 21072                                  	; MSDOS 6.0
 21073 000035FB 09FF                    	or	di,di
 21074 000035FD 7916                    	jns	short CWROK
 21075                                  	
 21076                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21077 000035FF E8D81C                  	call	CHARHARD
 21078 00003602 5F                      	POP	DI
 21079                                  
 21080                                  ;hkn; SS override
 21081 00003603 36C706[6C03]0100        	MOV	word [SS:CALLSCNT],1
 21082 0000360A 3C01                    	CMP	AL,1
 21083 0000360C 74DF                    	JZ	short DVWRTLP 	; Retry
 21084 0000360E 08C0                    	OR	AL,AL
 21085 00003610 740C                    	JZ	short DVWRTIGN	; Ignore
 21086                                  	; 10/08/2018
 21087 00003612 E979FD                  	JMP	CRDFERR 	; Fail, pops one stack element
 21088                                  CWROK:
 21089 00003615 5F                      	POP	DI
 21090                                  
 21091                                  ;hkn; SS override
 21092 00003616 36833E[6C03]00          	CMP	word [SS:CALLSCNT],0
 21093 0000361C 741C                    	JZ	short WRTCOOKDONE
 21094                                  DVWRTIGN:
 21095 0000361E 42                      	INC	DX
 21096                                  
 21097                                  ;hkn; SS override for CALLXAD
 21098 0000361F 36FF06[6803]            	INC	WORD [SS:CALLXAD]
 21099 00003624 47                      	INC	DI
 21100 00003625 1E                      	PUSH	DS
 21101 00003626 368E1E[6A03]            	MOV	DS,[SS:CALLXAD+2]
 21102 0000362B 803D1A                  	CMP	BYTE [DI],1Ah	; ^Z?
 21103 0000362E 1F                      	POP	DS
 21104 0000362F 7409                    	JZ	short WRTCOOKDONE
 21105                                  
 21106                                  ;hkn; SS override
 21107 00003631 36C706[5D03]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 21108 00003638 E2B3                    	LOOP	DVWRTLP
 21109                                  WRTCOOKDONE:
 21110 0000363A 89D0                    	MOV	AX,DX
 21111 0000363C 1F                      	POP	DS
 21112 0000363D E95FFF                  	JMP	ENDWRDEV ; 10/08/2018
 21113                                  
 21114                                  WRITECON:
 21115 00003640 1E                      	PUSH	DS
 21116                                  
 21117                                  ;hkn; SS is DOSDATA
 21118 00003641 16                      	push	ss
 21119 00003642 1F                      	pop	ds
 21120 00003643 E888FC                  	CALL	SWAPCON
 21121 00003646 1F                      	POP	DS
 21122 00003647 89DE                    	MOV	SI,BX
 21123 00003649 51                      	PUSH	CX
 21124                                  WRCONLP:
 21125 0000364A AC                      	LODSB
 21126 0000364B 3C1A                    	CMP	AL,1Ah		; ^Z?
 21127 0000364D 7405                    	JZ	short CONEOF
 21128 0000364F E80FE0                  	call	OUTT
 21129 00003652 E2F6                    	LOOP	WRCONLP
 21130                                  CONEOF:
 21131 00003654 58                      	POP	AX			; Count
 21132 00003655 29C8                    	SUB	AX,CX			; Amount actually written
 21133 00003657 1F                      	POP	DS
 21134 00003658 E86DFC                  	CALL	SWAPBACK
 21135 0000365B E941FF                  	JMP	ENDWRDEV
 21136                                  
 21137                                  ;---------------------------------------------------------------------------
 21138                                  ;
 21139                                  ; Procedure Name : get_io_sft
 21140                                  ;
 21141                                  ;   Convert JFN number in BX to sf_entry in DS:SI We get the normal SFT if
 21142                                  ;   CONSWAP is FALSE or if the handle desired is 2 or more. Otherwise, we
 21143                                  ;   retrieve the sft from ConSFT which is set by SwapCon.
 21144                                  ;
 21145                                  ;---------------------------------------------------------------------------
 21146                                  
 21147                                  ; 04/05/2019 - Retro DOS v4.0
 21148                                  ; DOSCODE:7583h (MSDOS 6.21, MSDOS.SYS)
 21149                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21150                                  ; DOSCODE:756Fh (MSDOS 5.0, MSDOS.SYS)
 21151                                  
 21152                                  GET_IO_SFT:
 21153                                  	;test	byte [SS:CONSWAP],0FFh
 21154 0000365E 36803E[5703]00          	cmp	byte [SS:CONSWAP],0			;smr;SS Override
 21155 00003664 7512                    	JNZ	short GetRedir
 21156                                  GetNormal:
 21157 00003666 16                      	push	ss
 21158 00003667 1F                      	pop	ds
 21159 00003668 06                      	PUSH	ES
 21160 00003669 57                      	PUSH	DI
 21161 0000366A E80D30                  	call	SFFromHandle
 21162 0000366D 7206                    	JC	short RET44P
 21163 0000366F 8CC6                    	MOV	SI,ES
 21164 00003671 8EDE                    	MOV	DS,SI
 21165 00003673 89FE                    	MOV	SI,DI
 21166                                  RET44P:
 21167 00003675 5F                      	POP	DI
 21168 00003676 07                      	POP	ES
 21169 00003677 C3                      	retn
 21170                                  GetRedir:
 21171 00003678 83FB01                  	CMP	BX,1
 21172 0000367B 77E9                    	JA	short GetNormal
 21173 0000367D 36C536[E605]            	LDS	SI,[SS:CONSFT]
 21174 00003682 F8                      	CLC
 21175                                  get_io_sft_retn:
 21176 00003683 C3                      	retn
 21177                                  
 21178                                  ;Break	<DIRREAD -- READ A DIRECTORY SECTOR>
 21179                                  ;---------------------------------------------------------------------------
 21180                                  ;
 21181                                  ; Procedure Name : DIRREAD
 21182                                  ;
 21183                                  ; Inputs:
 21184                                  ;	AX = Directory block number (relative to first block of directory)
 21185                                  ;	ES:BP = Base of drive parameters
 21186                                  ;	[DIRSEC] = First sector of first cluster of directory
 21187                                  ;	[CLUSNUM] = Next cluster
 21188                                  ;	[CLUSFAC] = Sectors/Cluster
 21189                                  ; Function:
 21190                                  ;	Read the directory block into [CURBUF].
 21191                                  ; Outputs:
 21192                                  ;	[NXTCLUSNUM] = Next cluster (after the one skipped to)
 21193                                  ;	[SECCLUSPOS] Set
 21194                                  ;	ES:BP unchanged
 21195                                  ;	[CURBUF] Points to Buffer with dir sector
 21196                                  ;	Carry set if error (user said FAIL to I 24)
 21197                                  ; DS preserved, all other registers destroyed.
 21198                                  ;---------------------------------------------------------------------------
 21199                                  
 21200                                  ;hkn; called from dir.asm. DS already set up to DOSDATA.
 21201                                  
 21202                                  DIRREAD:
 21203                                  
 21204                                  ; Note that ClusFac is the sectors per cluster. This is NOT necessarily
 21205                                  ; the same as what is in the DPB! In the case of the root directory, we have
 21206                                  ; ClusFac = # sectors in the root directory. The root directory is detected
 21207                                  ; by DIRStart = 0.
 21208                                  
 21209 00003684 31D2                    	XOR	DX,DX
 21210                                  	;CMP	word [DIRSTART],0
 21211                                  	; 21/09/2023
 21212 00003686 3916[C205]              	cmp	[DIRSTART],dx ; 0
 21213 0000368A 7503                    	jnz	short SubDir
 21214 0000368C 92                      	XCHG	AX,DX
 21215 0000368D EB0C                    	JMP	short DoRead
 21216                                  
 21217                                  ; Convert the sector number in AX into cluster and sector-within-cluster pair
 21218                                  
 21219                                  SubDir:
 21220 0000368F 88C2                    	MOV	DL,AL
 21221                                  	;and	dl,[es:bp+4]
 21222 00003691 26225604                	AND	DL,[ES:BP+DPB.CLUSTER_MASK]
 21223                                  
 21224                                  ;	(DX) = sector-in-cluster
 21225                                  
 21226                                  	;mov	cl,[es:bp+5]
 21227 00003695 268A4E05                	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 21228 00003699 D3E8                    	SHR	AX,CL
 21229                                  
 21230                                  ;	(DX) = position in cluster
 21231                                  ;	(AX) = number of clusters to skip
 21232                                  
 21233                                  DoRead:
 21234 0000369B 8816[7305]              	MOV	[SECCLUSPOS],DL
 21235 0000369F 89C1                    	MOV	CX,AX
 21236 000036A1 88D4                    	MOV	AH,DL
 21237                                  
 21238                                  ;	(CX) = number of clusters to skip.
 21239                                  ;	(AH) = remainder
 21240                                  
 21241                                  	; 04/05/2019 - Retro DOS v4.0
 21242                                  	 
 21243                                  	; MSDOS 6.0
 21244                                  	;MOV	DX,[DIRSEC+2]	     	  ;>32mb
 21245                                  	;MOV	[HIGH_SECTOR],DX	  ;>32mb
 21246                                  	;MOV	DX,[DIRSEC]
 21247                                  	;ADD	DL,AH
 21248                                  	;ADC	DH,0
 21249                                  	;ADC	word [HIGH_SECTOR],0	  ;>32mb
 21250                                  	; 21/09/2023
 21251 000036A3 31DB                    	xor	bx,bx ; 0
 21252 000036A5 8B16[BE05]              	mov	dx,[DIRSEC]
 21253 000036A9 00E2                    	add	dl,ah
 21254 000036AB 10DE                    	adc	dh,bl ; 0
 21255 000036AD 131E[C005]              	adc	bx,[DIRSEC+2]
 21256 000036B1 891E[0706]              	mov	[HIGH_SECTOR],bx
 21257                                  
 21258 000036B5 8B1E[BC05]              	MOV	BX,[CLUSNUM]
 21259 000036B9 891E[DC05]              	MOV	[NXTCLUSNUM],BX
 21260 000036BD E319                    	JCXZ	FIRSTCLUSTER
 21261                                  SKPCLLP:
 21262 000036BF E8831E                  	call	UNPACK
 21263 000036C2 72BF                    	jc	short get_io_sft_retn
 21264 000036C4 87DF                    	XCHG	BX,DI
 21265 000036C6 E8651E                  	call	IsEOF			; test for eof based on fat size
 21266 000036C9 7302                    	JAE	short HAVESKIPPED
 21267 000036CB E2F2                    	LOOP	SKPCLLP
 21268                                  HAVESKIPPED:
 21269 000036CD 891E[DC05]              	MOV	[NXTCLUSNUM],BX
 21270 000036D1 89FA                    	MOV	DX,DI
 21271 000036D3 88E3                    	MOV	BL,AH
 21272 000036D5 E81617                  	call	FIGREC
 21273                                  
 21274                                  	;entry	FIRSTCLUSTER
 21275                                  
 21276                                  FIRSTCLUSTER:
 21277                                  	; 22/09/2023
 21278                                  	;;mov	byte [ALLOWED],18h
 21279                                  	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 21280                                  	;XOR	AL,AL ; *	; Indicate pre-read
 21281                                  	;call	GETBUFFR
 21282 000036D8 E87522                  	call	GETBUFFER ; *	; pre-read
 21283 000036DB 72A6                    	jc	short get_io_sft_retn
 21284                                  
 21285                                  	;entry	SET_BUF_AS_DIR
 21286                                  
 21287                                  SET_BUF_AS_DIR:
 21288                                  
 21289                                  ;	Set the type of CURBUF to be a directory sector.
 21290                                  ;	Only flags are modified.
 21291                                  
 21292 000036DD 1E                      	PUSH	DS
 21293 000036DE 56                      	PUSH	SI
 21294 000036DF C536[E205]              	LDS	SI,[CURBUF]
 21295                                  	;or	byte [si+5],4
 21296 000036E3 804C0504                	OR	byte [SI+BUFFINFO.buf_flags],buf_isDIR	; Clears carry
 21297 000036E7 5E                      	POP	SI
 21298 000036E8 1F                      	POP	DS
 21299                                  dirread_retn:
 21300 000036E9 C3                      	retn
 21301                                  
 21302                                  ;Break	<FATSECRD -- READ A FAT SECTOR>
 21303                                  ;----------------------------------------------------------------------------
 21304                                  ;
 21305                                  ; Procedure Name : FATSECRD
 21306                                  ; Inputs:
 21307                                  ;	Same as DREAD
 21308                                  ;	DS:BX = Transfer address
 21309                                  ;	CX = Number of sectors
 21310                                  ;	DX = Absolute record number
 21311                                  ;	ES:BP = Base of drive parameters
 21312                                  ; Function:
 21313                                  ;	Calls BIOS to perform FAT read.
 21314                                  ; Outputs:
 21315                                  ;	Same as DREAD
 21316                                  ;---------------------------------------------------------------------------
 21317                                  
 21318                                  	; 04/05/2019 - Retro DOS v4.0
 21319                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)	
 21320                                  
 21321                                  FATSECRD:
 21322                                  ;hkn; SS override
 21323                                  	;mov	byte [ss:ALLOWED],18h
 21324 000036EA 36C606[4B03]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 21325 000036F0 89CF                    	MOV	DI,CX
 21326                                  	;mov	cl,[es:bp+8]
 21327 000036F2 268A4E08                	MOV	CL,[ES:BP+DPB.FAT_COUNT]
 21328                                  	; MSDOS 3.3
 21329                                  	;;mov	al,[es:bp+0Fh]
 21330                                  	;MOV	AL,[ES:BP+DPB.FAT_SIZE] 				
 21331                                  	;XOR	AH,AH
 21332                                  	; MSDOS 6.0
 21333                                  	;mov	ax,[es:bp+0Fh]
 21334 000036F6 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE] ;>32mb
 21335 000036FA 30ED                    	XOR	CH,CH	
 21336 000036FC 52                      	PUSH	DX
 21337                                  NXTFAT:
 21338                                  	; MSDOS 6.0
 21339                                  ;hkn; SS override
 21340 000036FD 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0	;>32mb FAT sectors cannot exceed
 21341 00003704 51                      	PUSH	CX			;32mb
 21342 00003705 50                      	PUSH	AX
 21343 00003706 89F9                    	MOV	CX,DI
 21344 00003708 E85B00                  	call	DSKREAD
 21345 0000370B 58                      	POP	AX
 21346 0000370C 59                      	POP	CX
 21347 0000370D 7420                    	JZ	short RET41P		; Carry clear
 21348 0000370F 01C2                    	ADD	DX,AX
 21349 00003711 E2EA                    	LOOP	NXTFAT
 21350 00003713 5A                      	POP	DX
 21351 00003714 89F9                    	MOV	CX,DI
 21352                                  
 21353                                  ; NOTE FALL THROUGH
 21354                                  
 21355                                  ;Break	<DREAD -- DO A DISK READ>
 21356                                  ;---------------------------------------------------------------------------
 21357                                  ;
 21358                                  ; Procedure Name : DREAD
 21359                                  ;
 21360                                  ; Inputs:
 21361                                  ;	DS:BX = Transfer address
 21362                                  ;	CX = Number of sectors
 21363                                  ;	DX = Absolute record number	      (LOW)
 21364                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 21365                                  ;	ES:BP = Base of drive parameters
 21366                                  ;	[ALLOWED] must be set in case call to HARDERR needed
 21367                                  ; Function:
 21368                                  ;	Calls BIOS to perform disk read. If BIOS reports
 21369                                  ;	errors, will call HARDERRRW for further action.
 21370                                  ; Outputs:
 21371                                  ;	Carry set if error (currently user FAILED to INT 24)
 21372                                  ; DS,ES:BP preserved. All other registers destroyed.
 21373                                  ;---------------------------------------------------------------------------
 21374                                  
 21375                                  	;entry	DREAD
 21376                                  DREAD:
 21377 00003716 E84D00                  	call	DSKREAD
 21378 00003719 74CE                    	jz	short dirread_retn	; Carry clear
 21379                                  ;hkn; SS override
 21380 0000371B 36C606[7505]00          	MOV	BYTE [SS:READOP],0
 21381 00003721 E89A00                  	call	HARDERRRW
 21382 00003724 3C01                    	CMP	AL,1			; Check for retry
 21383 00003726 74EE                    	JZ	short DREAD
 21384 00003728 3C03                    	CMP	AL,3			; Check for FAIL
 21385 0000372A F8                      	CLC
 21386 0000372B 7501                    	JNZ	short NO_CAR		; Ignore
 21387 0000372D F9                      	STC
 21388                                  NO_CAR:
 21389 0000372E C3                      	retn
 21390                                  RET41P: 
 21391 0000372F 5A                      	POP	DX
 21392 00003730 C3                      	retn
 21393                                  
 21394                                  ; 24/07/2018 - Retro DOS v3.0
 21395                                  
 21396                                  ;Break	<CHECK_WRITE_LOCK>
 21397                                  ;---------------------------------------------------------------------------
 21398                                  ;
 21399                                  ; Procedure Name : CHECK_WRITE_LOCK
 21400                                  ;
 21401                                  ; Inputs:
 21402                                  ;	output of SETUP
 21403                                  ;	ES:DI -> SFT
 21404                                  ; Function:
 21405                                  ;	check write lock
 21406                                  ; Outputs:
 21407                                  ;	Carry set if error
 21408                                  ;	Carry clear if ok
 21409                                  ;
 21410                                  ;----------------------------------------------------------------------------
 21411                                  
 21412                                  	; 04/05/2019 - Retro DOS v4.0
 21413                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21414                                  
 21415                                  CHECK_WRITE_LOCK:
 21416                                  	; MSDOS 6.0
 21417                                  	;test	byte [es:di+4],8
 21418 00003731 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 21419                                  	;JZ	short write_cont			     ;no
 21420                                  	;;call	SET_ACC_ERR_DS
 21421                                  	;;retn
 21422                                  	;;jnz	SET_ACC_ERR_DS
 21423                                  	; 19/08/2018
 21424                                  	;jz	short write_cont
 21425                                  	;jmp	SET_ACC_ERR_DS
 21426                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21427 00003736 7403                    	JZ	short write_cont
 21428                                  	;call	SET_ACC_ERR_DS
 21429                                  	;retn
 21430                                  	; 16/12/2022
 21431 00003738 E9B901                  	jmp	SET_ACC_ERR_DS
 21432                                  
 21433                                  write_cont:				;
 21434 0000373B 51                      	PUSH	CX			;save reg
 21435 0000373C 09C9                    	OR	CX,CX			;
 21436 0000373E 7501                    	JNZ	short Not_Truncate	;
 21437 00003740 49                      	dec	cx			;(cx) = -1; check for lock on whole file
 21438                                  Not_Truncate:				;
 21439 00003741 B080                    	MOV	AL,80H			;check write access
 21440 00003743 E8BD3B                  	call	LOCK_CHECK		;check lock
 21441 00003746 59                      	POP	CX			;restore reg
 21442 00003747 7305                    	JNC	short WRITE_OK		;lock ok
 21443 00003749 E85F01                  	call	WRITE_LOCK_VIOLATION	;issue I24
 21444 0000374C 73ED                    	JNC	short write_cont	;retry
 21445                                  WRITE_OK:				;
 21446 0000374E C3                      	retn				;
 21447                                  
 21448                                  ;Break	<CHECK_READ_LOCK>
 21449                                  ;---------------------------------------------------------------------------
 21450                                  ;
 21451                                  ; Procedure Name : CHECK_READ_LOC
 21452                                  ;
 21453                                  ; Inputs:
 21454                                  ;	ES:DI -> SFT
 21455                                  ;	output of SETUP
 21456                                  ; Function:
 21457                                  ;	check read lock
 21458                                  ; Outputs:
 21459                                  ;	Carry set if error
 21460                                  ;	Carry clear if ok
 21461                                  ;----------------------------------------------------------------------------
 21462                                  
 21463                                  CHECK_READ_LOCK:
 21464                                  	; MSDOS 6.0
 21465                                  	;test	byte [es:di+4],8
 21466 0000374F 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 21467                                  	;JZ	short do_retry			   	     ; no
 21468                                  	;;call	SET_ACC_ERR
 21469                                  	;;retn
 21470                                  	;;jnz	SET_ACC_ERR
 21471                                  	; 16/12/2022
 21472                                  	; 28/07/2019
 21473 00003754 7403                    	jz	short do_retry
 21474 00003756 E99D01                  	jmp	SET_ACC_ERR
 21475                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21476                                  	;JZ	short do_retry
 21477                                  	;call	SET_ACC_ERR
 21478                                  	;retn
 21479                                  do_retry:				;
 21480 00003759 30C0                    	xor	al,al			;check read access
 21481 0000375B E8A53B                  	call	LOCK_CHECK		;check lock
 21482 0000375E 7305                    	JNC	short READLOCK_OK 	;lock ok
 21483 00003760 E82801                  	call	READ_LOCK_VIOLATION	;issue I24
 21484 00003763 73F4                    	JNC	short do_retry		;retry
 21485                                  READLOCK_OK:				;
 21486 00003765 C3                      	retn				;
 21487                                  
 21488                                  ;============================================================================
 21489                                  ; DISK2.ASM, MSDOS 6.0, 1991
 21490                                  ;============================================================================
 21491                                  ; 24/07/2018 - Retro DOS v3.0
 21492                                  ; 04/05/2019 - Retro DOS v4.0
 21493                                  
 21494                                  ;	TITLE	DISK2 - Disk utility routines
 21495                                  ;	NAME	Disk2
 21496                                  
 21497                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 21498                                  ;
 21499                                  ;	DskRead
 21500                                  ;	DWRITE
 21501                                  ;	DSKWRITE
 21502                                  ;	HarderrRW
 21503                                  ;	SETUP
 21504                                  ;	BREAKDOWN
 21505                                  ;	READ_LOCK_VIOLATION
 21506                                  ;	WRITE_LOCK_VIOLATION
 21507                                  ;	DISKREAD
 21508                                  ;	SET_ACC_ERR_DS
 21509                                  ;	SET_ACC_ERR
 21510                                  ;	SETSFT
 21511                                  ;	SETCLUS
 21512                                  ;	AddRec
 21513                                  ;
 21514                                  ;	Revision history:
 21515                                  ;
 21516                                  ;		AN000 version 4.00 Jan. 1988
 21517                                  ;		M039 DB 10/17/90 - Disk read/write optimization
 21518                                  
 21519                                  ; 04/05/2019 - Retro DOS v4.0
 21520                                  ; DOSCODE:7699h (MSDOS 6.21, MSDOS.SYS)
 21521                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21522                                  ; DOSCODE:7685h (MSDOS 5.0, MSDOS.SYS)
 21523                                  
 21524                                  ;Break	<DSKREAD -- PHYSICAL DISK READ>
 21525                                  ;---------------------------------------------------------------------------
 21526                                  ;
 21527                                  ; Procedure Name : DSKREAD
 21528                                  ;
 21529                                  ; Inputs:
 21530                                  ;	DS:BX = Transfer addr
 21531                                  ;	CX = Number of sectors
 21532                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 21533                                  ;	DX = Absolute record number	       (LOW)
 21534                                  ;	ES:BP = Base of drive parameters
 21535                                  ; Function:
 21536                                  ;	Call BIOS to perform disk read
 21537                                  ; Outputs:
 21538                                  ;	DI = CX on entry
 21539                                  ;	CX = Number of sectors unsuccessfully transfered
 21540                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 21541                                  ;	Zero set if OK (from BIOS) (carry clear)
 21542                                  ;	Zero clear if error (carry clear)
 21543                                  ; SI Destroyed, others preserved
 21544                                  ;---------------------------------------------------------------------------
 21545                                  
 21546                                  DSKREAD:
 21547 00003766 51                      	PUSH	CX
 21548                                  	;mov	ah,[es:bp+17h] ; 04/05/2019
 21549 00003767 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 21550                                  	;mov	al,[es:bp+1]
 21551 0000376B 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 21552 0000376F 53                      	PUSH	BX
 21553 00003770 06                      	PUSH	ES
 21554 00003771 E87A0F                  	call	SETREAD
 21555 00003774 EB27                    	JMP	short DODSKOP
 21556                                  
 21557                                  ;Break	<DWRITE -- SEE ABOUT WRITING>
 21558                                  ;--------------------------------------------------------------------------
 21559                                  ;
 21560                                  ; Procedure Name : DWRITE
 21561                                  ;
 21562                                  ; Inputs:
 21563                                  ;	DS:BX = Transfer address
 21564                                  ;	CX = Number of sectors
 21565                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 21566                                  ;	DX = Absolute record number	       (LOW)
 21567                                  ;	ES:BP = Base of drive parameters
 21568                                  ;	[ALLOWED] must be set in case HARDERR called
 21569                                  ; Function:
 21570                                  ;	Calls BIOS to perform disk write. If BIOS reports
 21571                                  ;	errors, will call HARDERRRW for further action.
 21572                                  ; Output:
 21573                                  ;	Carry set if error (currently, user FAILed to I 24)
 21574                                  ; BP preserved. All other registers destroyed.
 21575                                  ;----------------------------------------------------------------------------
 21576                                  
 21577                                  	;entry	DWRITE
 21578                                  DWRITE:
 21579 00003776 E81600                  	CALL	DSKWRITE
 21580 00003779 7413                    	jz	short dw_ret_label	; Carry clear (retz)
 21581                                  
 21582                                  ;hkn; SS override
 21583 0000377B 36C606[7505]01          	MOV	BYTE [SS:READOP],1
 21584 00003781 E83A00                  	call	HARDERRRW
 21585 00003784 3C01                    	CMP	AL,1		; Check for retry
 21586 00003786 74EE                    	JZ	short DWRITE
 21587 00003788 3C03                    	CMP	AL,3		; Check for FAIL
 21588 0000378A F8                      	CLC
 21589 0000378B 7501                    	JNZ	short NO_CAR2 	; Ignore
 21590 0000378D F9                      	STC
 21591                                  NO_CAR2:
 21592                                  dw_ret_label:
 21593 0000378E C3                      	retn
 21594                                  
 21595                                  ;Break	<DSKWRITE -- PHYSICAL DISK WRITE>
 21596                                  ;---------------------------------------------------------------------------
 21597                                  ;
 21598                                  ; Procedure Name : DSKWRITE
 21599                                  ;
 21600                                  ; Inputs:
 21601                                  ;	DS:BX = Transfer addr
 21602                                  ;	CX = Number of sectors
 21603                                  ;	DX = Absolute record number	       (LOW)
 21604                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 21605                                  ;	ES:BP = Base of drive parameters
 21606                                  ; Function:
 21607                                  ;	Call BIOS to perform disk read
 21608                                  ; Outputs:
 21609                                  ;	DI = CX on entry
 21610                                  ;	CX = Number of sectors unsuccessfully transfered
 21611                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 21612                                  ;	Zero set if OK (from BIOS) (carry clear)
 21613                                  ;	Zero clear if error (carry clear)
 21614                                  ; SI Destroyed, others preserved
 21615                                  ;
 21616                                  ;----------------------------------------------------------------------------
 21617                                  
 21618                                  	;entry	DSKWRITE
 21619                                  DSKWRITE:
 21620 0000378F 51                      	PUSH	CX
 21621                                  	;mov	ah,[es:bp+17h] ; 04/05/2019
 21622 00003790 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 21623                                  	;mov	al,[es:bp+1]
 21624 00003794 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 21625 00003798 53                      	PUSH	BX
 21626 00003799 06                      	PUSH	ES
 21627 0000379A E8840F                  	call	SETWRITE
 21628                                  DODSKOP:
 21629 0000379D 8CD9                    	MOV	CX,DS		; Save DS
 21630 0000379F 1F                      	POP	DS		; DS:BP points to DPB
 21631 000037A0 1E                      	PUSH	DS
 21632                                  
 21633                                  	;lds	si,[ds:bp+13h] ; 04/05/2019
 21634 000037A1 3EC57613                	LDS	SI,[ds:BP+DPB.DRIVER_ADDR] ; 07/09/2018
 21635 000037A5 E8D00E                  	call	DEVIOCALL2
 21636                                  
 21637 000037A8 8ED9                    	MOV	DS,CX		; Restore DS
 21638 000037AA 07                      	POP	ES		; Restore ES
 21639 000037AB 5B                      	POP	BX
 21640                                  
 21641                                  ;hkn; SS override
 21642 000037AC 368B0E[6C03]            	MOV	CX,[SS:CALLSCNT] ; Number of sectors transferred
 21643 000037B1 5F                      	POP	DI
 21644 000037B2 29F9                    	SUB	CX,DI
 21645 000037B4 F7D9                    	NEG	CX		; Number of sectors not transferred
 21646                                  
 21647                                  ;hkn; SS override
 21648 000037B6 36A1[5D03]              	MOV	AX,[SS:DEVCALL_REQSTAT]
 21649                                  	;test	ax,8000h
 21650                                  	; 17/12/2022
 21651                                  	;test	ah,80h
 21652 000037BA F6C480                  	test	ah,(STERR>>8)
 21653                                  	;test	AX,STERR
 21654 000037BD C3                      	retn
 21655                                  
 21656                                  ;Break	<HardErrRW - map extended errors and call harderr>
 21657                                  ;---------------------------------------------------------------------------
 21658                                  ;
 21659                                  ; Procedure Name : HardErrRW
 21660                                  ;
 21661                                  ; Inputs:
 21662                                  ;	AX is error code from read or write
 21663                                  ;	Other registers set as per HARDERR
 21664                                  ; Function:
 21665                                  ;	Checks the error code for special extended
 21666                                  ;	errors and maps them if needed. Then invokes
 21667                                  ;	Harderr
 21668                                  ; Outputs:
 21669                                  ;	Of HARDERR
 21670                                  ; AX may be modified prior to call to HARDERR.
 21671                                  ; No other registers altered.
 21672                                  ;
 21673                                  ;---------------------------------------------------------------------------
 21674                                  
 21675                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21676                                  HARDERRRW:
 21677                                  	;cmp	al,0Fh
 21678 000037BE 3C0F                    	CMP	AL,error_I24_wrong_disk
 21679 000037C0 7512                    	JNZ	short DO_ERR				; Nothing to do
 21680                                  
 21681                                  	; MSDOS 3.3
 21682                                  	;push	ds
 21683                                  	;push	si
 21684                                  	;lds	si,[ss:CALLVIDRW]
 21685                                  	;mov	[ss:EXTERRPT+2], ds
 21686                                  	;mov	[ss:EXTERRPT], si
 21687                                  	;pop	si
 21688                                  	;pop	ds
 21689                                  
 21690                                  	; MSDOS 6.0
 21691 000037C2 50                      	push	ax
 21692 000037C3 36A1[7003]              	mov	ax,[SS:CALLVIDRW]		; get ptr lo  ;smr;SS Override
 21693 000037C7 36A3[2803]              	mov	[ss:EXTERRPT],ax		; set ext err ptr lo
 21694 000037CB 36A1[7203]              	mov	ax,[SS:CALLVIDRW+2]		; get ptr hi from dev
 21695 000037CF 36A3[2A03]              	mov	[ss:EXTERRPT+2],ax		; set ext err ptr hi
 21696 000037D3 58                      	pop	ax
 21697                                  DO_ERR:
 21698                                  	;;call	HARDERR
 21699                                  	;;retn
 21700                                  	; 16/12/2022
 21701                                  	; 10/06/2019
 21702 000037D4 E9341B                  	jmp	HARDERR	
 21703                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21704                                  	;call	HARDERR
 21705                                  	;retn
 21706                                  
 21707                                  ; 24/07/2018 - Retro DOS v3.0
 21708                                  
 21709                                  ;Break	<SETUP -- SETUP A DISK READ OR WRITE FROM USER>
 21710                                  ;----------------------------------------------------------------------------
 21711                                  ;
 21712                                  ; Procedure Name : SETUP
 21713                                  ;
 21714                                  ; Inputs:
 21715                                  ;	ES:DI point to SFT (value also in THISSFT)
 21716                                  ;	DMAAdd contains transfer address
 21717                                  ;	CX = Byte count
 21718                                  ;	DS = DOSDATA
 21719                                  ;   WARNING Stack must be clean, two ret addrs on stack, 1st of caller,
 21720                                  ;		2nd of caller of caller.
 21721                                  ; Outputs:
 21722                                  ;	    CX = byte count
 21723                                  ;	    [THISDPB] = Base of drive parameters if file
 21724                                  ;		      = Pointer to device header if device or NET
 21725                                  ;	    ES:DI Points to SFT
 21726                                  ;	    [NEXTADD] = Displacement of disk transfer within segment
 21727                                  ;	    [TRANS] = 0 (No transfers yet)
 21728                                  ;	    BytPos = Byte position in file
 21729                                  ;
 21730                                  ;	The following fields are relevant to local files (not devices) only:
 21731                                  ;
 21732                                  ;	    SecPos = Position of first sector (local files only)
 21733                                  ;	    [BYTSECPOS] = Byte position in first sector (local files only)
 21734                                  ;	    [CLUSNUM] = First cluster (local files only)
 21735                                  ;	    [SECCLUSPOS] = Sector within first cluster (local files only)
 21736                                  ;	    [THISDRV] = Physical unit number (local files only)
 21737                                  ;
 21738                                  ;      RETURNS ONE LEVEL UP WITH:
 21739                                  ;	   CX = 0
 21740                                  ;	   CARRY = Clear
 21741                                  ;	IF AN ERROR IS DETECTED
 21742                                  ; All other registers destroyed
 21743                                  ;----------------------------------------------------------------------------
 21744                                  
 21745                                  ;hkn; called from disk.asm. DS has been set up to DOSDATA.
 21746                                  
 21747                                  ; DOSCODE:770Bh (MSDOS 6.21, MSDOS.SYS)
 21748                                  
 21749                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21750                                  ; DOSCODE:76F7h (MSDOS 5.0, MSDOS.SYS)
 21751                                  
 21752                                  SETUP:
 21753                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 411Bh
 21754                                  
 21755                                  	;lds 	si,[es:di+7]
 21756 000037D7 26C57507                	LDS	SI,[ES:DI+SF_ENTRY.sf_devptr]
 21757                                  
 21758                                  ;hkn; SS override
 21759 000037DB 368C1E[8C05]            	MOV	[SS:THISDPB+2],DS
 21760                                  
 21761                                  ;hkn; SS is DOSDATA
 21762 000037E0 16                      	push	ss
 21763 000037E1 1F                      	pop	ds
 21764                                  
 21765 000037E2 8936[8A05]              	MOV	[THISDPB],SI
 21766                                  
 21767 000037E6 8B1E[2C03]              	MOV	BX,[DMAADD]
 21768 000037EA 891E[B805]              	MOV	[NEXTADD],BX		;Set NEXTADD to start of Xaddr
 21769 000037EE C606[7405]00            	MOV	BYTE [TRANS],0		;No transferes
 21770                                  	;mov	ax,[es:di+15h]
 21771 000037F3 268B4515                	MOV	AX,[ES:DI+SF_ENTRY.sf_position]
 21772                                  	;mov	dx,[es:di+17h]
 21773 000037F7 268B5517                	MOV	DX,[ES:DI+SF_ENTRY.sf_position+2]
 21774 000037FB 8916[D005]              	MOV	[BYTPOS+2],DX		;Set it
 21775 000037FF A3[CE05]                	MOV	[BYTPOS],AX
 21776                                  	;test	word [es:di+5],8080h
 21777 00003802 26F745058080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet+devid_device
 21778 00003808 753C                    	JNZ	short NOSETSTUFF	;Following not done on devs or NET
 21779 0000380A 06                      	PUSH	ES
 21780 0000380B C42E[8A05]              	LES	BP,[THISDPB]		;Point at the DPB
 21781                                  
 21782                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21783                                  	;;mov	bl,[es:bp+0]
 21784                                  	;MOV	BL,[ES:BP+DPB.DRIVE]
 21785                                  	; 05/12/2022
 21786 0000380F 268A5E00                	mov	bl,[es:bp]
 21787                                  	
 21788 00003813 881E[7605]              	MOV	[THISDRV],BL		;Set THISDRV
 21789                                  	;mov	bx,[es:bp+2]
 21790 00003817 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 21791                                  
 21792                                  	;; MSDOS 3.3
 21793                                  	;cmp	dx,bx
 21794                                  	;jnb	short EOFERR
 21795                                  	;div	bx
 21796                                  	;mov	[SECPOS],ax
 21797                                  	;mov	[BYTSECPOS],dx
 21798                                  	;mov	dx,ax
 21799                                  	;;and	al,[es:bp+4]
 21800                                  	;AND	AL,[ES:BP+DPB.CLUSTER_MASK]
 21801                                  	;mov	[SECCLUSPOS],al
 21802                                  	;mov	ax,cx
 21803                                  	;;mov	cl,[es:bp+5]
 21804                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 21805                                  	;shr	dx,cl
 21806                                  	;mov	[CLUSNUM],dx
 21807                                  	;pop	es
 21808                                  	;mov	cx,ax
 21809                                  
 21810                                  	; 04/05/2019 - Retro DOS v4.0
 21811                                  
 21812                                  	; MSDOS 6.0
 21813                                  ;M039: Optimized this section.
 21814 0000381B 51                              PUSH    CX			;SHR32 and DIV32 use CX.
 21815 0000381C E83405                  	call	DIV32			;DX:AX/BX = CX:AX + DX (rem)
 21816 0000381F 8916[CC05]              	MOV	[BYTSECPOS],DX
 21817 00003823 A3[C405]                	MOV	[SECPOS],AX
 21818 00003826 890E[C605]              	MOV	[SECPOS+2],CX
 21819 0000382A 89CA                    	MOV	DX,CX
 21820                                  
 21821 0000382C 89C3                    	MOV	BX,AX
 21822                                  	;and	bl,[es:bp+4]
 21823 0000382E 26225E04                	AND	BL,[ES:BP+DPB.CLUSTER_MASK]
 21824 00003832 881E[7305]              	MOV	[SECCLUSPOS],BL
 21825                                  
 21826 00003836 E84105                  	call	SHR32			;(DX:AX SHR dpb_cluster_shift)
 21827 00003839 59                      	POP	CX			;CX = byte count.
 21828 0000383A 751F                    	JNZ	short EOFERR		;cluster number above 64k
 21829                                  	;cmp	ax,[es:bp+0Dh]
 21830 0000383C 263B460D                	CMP	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  if > disk size ;AN000;
 21831 00003840 7719                    	JA	short EOFERR		   ;>32mb  then EOF       ;AN000;
 21832                                  
 21833 00003842 A3[BC05]                	MOV	[CLUSNUM],AX
 21834 00003845 07                      	POP	ES			; ES:DI point to SFT
 21835                                  ;M039
 21836                                  
 21837                                  NOSETSTUFF:
 21838 00003846 89C8                    	MOV	AX,CX		; AX = Byte count.
 21839 00003848 0306[2C03]              	ADD	AX,[DMAADD]	; See if it will fit in one segment
 21840 0000384C 730C                    	JNC	short setup_OK	; Must be less than 64
 21841 0000384E A1[2C03]                	MOV	AX,[DMAADD]
 21842 00003851 F7D8                    	NEG	AX		; Amount of room left in segment (know
 21843                                  				;    less than 64K since max value of CX
 21844                                  				;    is FFFF).
 21845 00003853 7501                    	JNZ	short NoDec
 21846 00003855 48                      	DEC	AX
 21847                                  NoDec:
 21848 00003856 89C1                    	MOV	CX,AX		; Can do this much
 21849 00003858 E304                    	JCXZ	NOROOM		; Silly user gave Xaddr of FFFF in segment
 21850                                  setup_OK:
 21851 0000385A C3                      	retn
 21852                                  
 21853                                  EOFERR:
 21854 0000385B 07                      	POP	ES		; ES:DI point to SFT
 21855 0000385C 31C9                    	XOR	CX,CX		; No bytes read
 21856                                  ;;;;;;;;;;; 7/18/86
 21857                                  	; MSDOS 3.3
 21858                                  	;MOV	BYTE [DISK_FULL],1 ; set disk full flag
 21859                                  ;;;;;;;;;;;
 21860                                  NOROOM:
 21861 0000385E 5B                      	POP	BX		; Kill return address
 21862 0000385F F8                      	CLC
 21863 00003860 C3                      	retn			; RETURN TO CALLER OF CALLER
 21864                                  
 21865                                  ;Break	<BREAKDOWN -- CUT A USER READ OR WRITE INTO PIECES>
 21866                                  ;---------------------------------------------------------------------------
 21867                                  ;
 21868                                  ; Procedure Name : BREAKDOWN
 21869                                  ;
 21870                                  ; Inputs:
 21871                                  ;	CX = Length of disk transfer in bytes
 21872                                  ;	ES:BP = Base of drive parameters
 21873                                  ;	[BYTSECPOS] = Byte position within first sector
 21874                                  ;	DS = DOSDATA
 21875                                  ; Outputs:
 21876                                  ;	[BYTCNT1] = Bytes to transfer in first sector
 21877                                  ;	[SECCNT] = No. of whole sectors to transfer
 21878                                  ;	[BYTCNT2] = Bytes to transfer in last sector
 21879                                  ; AX, BX, DX destroyed. No other registers affected.
 21880                                  ;---------------------------------------------------------------------------
 21881                                  
 21882                                  BREAKDOWN:
 21883 00003861 A1[CC05]                	MOV	AX,[BYTSECPOS]
 21884 00003864 89CB                    	MOV	BX,CX
 21885 00003866 09C0                    	OR	AX,AX
 21886 00003868 740E                    	JZ	short SAVFIR	; Partial first sector?
 21887                                  	;sub	ax,[es:bp+2]
 21888 0000386A 262B4602                	SUB	AX,[ES:BP+DPB.SECTOR_SIZE]
 21889 0000386E F7D8                    	NEG	AX		; Max number of bytes left in first sector
 21890 00003870 29C3                    	SUB	BX,AX		; Subtract from total length
 21891 00003872 7304                    	JAE	short SAVFIR
 21892 00003874 01D8                    	ADD	AX,BX		; Don't use all of the rest of the sector
 21893 00003876 31DB                    	XOR	BX,BX		; And no bytes are left
 21894                                  SAVFIR:
 21895 00003878 A3[D205]                	MOV	[BYTCNT1],AX
 21896 0000387B 89D8                    	MOV	AX,BX
 21897 0000387D 31D2                    	XOR	DX,DX
 21898                                  	;div	word [ES:BP+2]
 21899 0000387F 26F77602                	DIV	word [ES:BP+DPB.SECTOR_SIZE]  ; How many whole sectors?
 21900 00003883 A3[D605]                	MOV	[SECCNT],AX
 21901 00003886 8916[D405]              	MOV	[BYTCNT2],DX	; Bytes remaining for last sector
 21902                                  	; MSDOS 3.3
 21903                                  	;OR	DX,[BYTCNT1]	; SMR ONESECTORFIX BUGBUG
 21904                                  	;retnz			; NOT (BYTCNT1 = BYTCNT2 = 0)
 21905                                  	;CMP	AX,1
 21906                                  	;retnz
 21907                                  	;MOV	AX,[ES:BP+DPB.SECTOR_SIZE] ; Buffer EXACT one sector I/O
 21908                                  	;MOV	[BYTCNT2],AX
 21909                                  	;MOV	[SECCNT],DX	; DX = 0
 21910                                  _RET45:
 21911 0000388A C3                      	retn
 21912                                  
 21913                                  ; DOSCODE:77BFh (MSDOS 6.21, MSDOS.SYS)
 21914                                  
 21915                                  ;----------------------------------------------------------------------------
 21916                                  ;
 21917                                  ; Procedure Name : READ_LOCK_VIOLATION
 21918                                  ;
 21919                                  ; ES:DI points to SFT. This entry used by NET_READ
 21920                                  ; Carry set if to return error (CX=0,AX=error_sharing_violation).
 21921                                  ; Else do retrys.
 21922                                  ; ES:DI,DS,CX preserved
 21923                                  ;
 21924                                  ;----------------------------------------------------------------------------
 21925                                  
 21926                                  READ_LOCK_VIOLATION:
 21927 0000388B C606[7505]00            	MOV	byte [READOP],0
 21928                                  ERR_ON_CHECK:
 21929                                  	;;test	word [es:di+2],8000h
 21930                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 21931                                  	;JNZ	short HARD_ERR
 21932                                  
 21933                                  	; 04/05/2019
 21934                                  	;test	byte [es:di+3],80h
 21935 00003890 26F6450380              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 21936 00003895 7508                    	JNZ	short HARD_ERR
 21937                                  
 21938                                  	;PUSH	CX
 21939                                  	;;mov	cl,[es:di+2]
 21940                                  	;MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 21941                                  	;;and	cl,0F0h
 21942                                  	;AND	CL,SHARING_MASK
 21943                                  	;;cmp	cl,0
 21944                                  	;CMP	CL,SHARING_COMPAT
 21945                                  	;POP	CX
 21946                                  	;JNE	short NO_HARD_ERR
 21947                                  	; 21/09/2023
 21948 00003897 268A4502                	mov	al,[ES:DI+SF_ENTRY.sf_mode]
 21949 0000389B 24F0                    	and	al,SHARING_MASK
 21950                                  	;cmp	al,SHARING_COMPAT
 21951                                  	;jne	short NO_HARD_ERR
 21952 0000389D 7505                    	jnz	short NO_HARD_ERR
 21953                                  HARD_ERR:
 21954 0000389F E8773A                  	call	LOCK_VIOLATION
 21955 000038A2 73E6                    	jnc	short _RET45		; User wants Retrys
 21956                                  NO_HARD_ERR:
 21957 000038A4 31C9                    	XOR	CX,CX			;No bytes transferred
 21958                                  	;mov	ax,21h
 21959 000038A6 B82100                  	MOV	AX,error_lock_violation
 21960 000038A9 F9                      	STC
 21961 000038AA C3                      	retn
 21962                                  
 21963                                  ;----------------------------------------------------------------------------
 21964                                  ;
 21965                                  ; Procedure Name : WRITE_LOCK_VIOLATION
 21966                                  ;
 21967                                  ; Same as READ_LOCK_VIOLATION except for READOP.
 21968                                  ; This entry used by NET_WRITE
 21969                                  ;
 21970                                  ;----------------------------------------------------------------------------
 21971                                  
 21972                                  WRITE_LOCK_VIOLATION:
 21973 000038AB C606[7505]01            	MOV	byte [READOP],1
 21974 000038B0 EBDE                    	JMP	short ERR_ON_CHECK
 21975                                  
 21976                                  ; 04/05/2019 - Retro DOS v4.0
 21977                                  
 21978                                  ; DOSCODE:77ECh (MSDOS 6.21, MSDOS.SYS)
 21979                                  
 21980                                  ;Break	<DISKREAD -- PERFORM USER DISK READ>
 21981                                  ;----------------------------------------------------------------------------
 21982                                  ;
 21983                                  ; Procedure Name : DISKREAD
 21984                                  ;
 21985                                  ; Inputs:
 21986                                  ;	Outputs of SETUP
 21987                                  ; Function:
 21988                                  ;	Perform disk read
 21989                                  ; Outputs:
 21990                                  ;    Carry clear
 21991                                  ;	CX = No. of bytes read
 21992                                  ;	ES:DI point to SFT
 21993                                  ;	SFT offset and cluster pointers updated
 21994                                  ;    Carry set
 21995                                  ;	CX = 0
 21996                                  ;	ES:DI point to SFT
 21997                                  ;	AX has error code
 21998                                  ;----------------------------------------------------------------------------
 21999                                  
 22000                                  ;hkn; called from disk.asm. DS already set up.
 22001                                  
 22002                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22003                                  ; DOSCODE:77D8h (MSDOS 5.0, MSDOS.SYS)
 22004                                  
 22005                                  DISKREAD:
 22006                                  	;mov	ax,[es:di+11h]
 22007 000038B2 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 22008                                  	;mov	bx,[es:di+13h]
 22009 000038B6 268B5D13                	MOV	BX,[ES:DI+SF_ENTRY.sf_size+2]
 22010 000038BA 2B06[CE05]              	SUB	AX,[BYTPOS]
 22011 000038BE 1B1E[D005]              	SBB	BX,[BYTPOS+2]
 22012 000038C2 7226                    	JB	short RDERR		;Read starts past EOF
 22013 000038C4 750A                    	JNZ	short ENUF		;More than 64k to EOF
 22014 000038C6 09C0                    	OR	AX,AX
 22015 000038C8 7420                    	JZ	short RDERR		;Read starts at EOF
 22016 000038CA 39C8                    	CMP	AX,CX
 22017 000038CC 7302                    	JAE	short ENUF		;I/O fits
 22018 000038CE 89C1                    	MOV	CX,AX			;Limit read to up til EOF
 22019                                  ENUF:
 22020                                  	; MSDOS 3.3
 22021                                  	;test	byte [es:di+4],8
 22022                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 22023                                  	;jnz	short SET_ACC_ERR
 22024                                  	;call	LOCK_CHECK
 22025                                  	;jnb	short _READ_OK
 22026                                  	;call	READ_LOCK_VIOLATION
 22027                                  	;jnb	short ENUF
 22028                                  	;retn
 22029                                  
 22030                                  	; MSDOS 6.0
 22031 000038D0 E87CFE                  	call	CHECK_READ_LOCK		;IFS. check read lock	;AN000;
 22032 000038D3 7301                    	JNC	short _READ_OK 		; There are no locks
 22033 000038D5 C3                      	retn
 22034                                  
 22035                                  _READ_OK:
 22036 000038D6 C42E[8A05]              	LES	BP,[THISDPB]
 22037 000038DA E884FF                  	CALL	BREAKDOWN
 22038 000038DD 8B0E[BC05]              	MOV	CX,[CLUSNUM]
 22039                                  
 22040 000038E1 E87013                  	call	FNDCLUS
 22041                                       	; MSDOS 6.0			;M022 conditional removed here
 22042 000038E4 720E                    	JC	short SET_ACC_ERR_DS	; fix to take care of I24 fail
 22043                                  					; migrated from 330a - HKN
 22044 000038E6 09C9                    	OR	CX,CX
 22045 000038E8 7413                    	JZ	short SKIPERR
 22046                                  RDERR:
 22047 000038EA B40E                    	MOV	AH,0EH			;MS. read/data/fail ;AN000;
 22048 000038EC E92102                  	jmp	WRTERR22
 22049                                  
 22050                                  ;RDLASTJ: 
 22051                                  	;JMP	RDLAST                  ;M039
 22052                                  
 22053                                  SETSFTJ2: 
 22054 000038EF E99600                  	JMP	SETSFT
 22055                                  
 22056                                  CANOT_READ:
 22057                                  	; MSDOS 3.3
 22058                                  	;POP	CX		;M039.
 22059                                  	; MSDOS 3.3 & MSDOS 6.0
 22060 000038F2 59                      	POP	CX              ;Clean stack.
 22061 000038F3 5B                      	POP	BX
 22062                                  
 22063                                  	;entry	SET_ACC_ERR_DS
 22064                                  SET_ACC_ERR_DS:
 22065                                  
 22066                                  ;hkn; SS is DOSDATA
 22067                                  	;Context DS
 22068 000038F4 16                      	push	ss
 22069 000038F5 1F                      	pop	ds
 22070                                  
 22071                                  	;entry	SET_ACC_ERR
 22072                                  SET_ACC_ERR:
 22073 000038F6 31C9                    	XOR	CX,CX
 22074                                  	;mov	ax,5
 22075 000038F8 B80500                  	MOV	AX,error_access_denied
 22076 000038FB F9                      	STC
 22077 000038FC C3                      	retn
 22078                                  
 22079                                  SKIPERR:
 22080 000038FD 8916[BA05]              	MOV	[LASTPOS],DX
 22081 00003901 891E[BC05]              	MOV	[CLUSNUM],BX
 22082 00003905 833E[D205]00            	CMP	word [BYTCNT1],0
 22083 0000390A 7405                    	JZ	short RDMID
 22084                                  
 22085 0000390C E8BB13                  	call	BUFRD
 22086 0000390F 72E3                    	JC	short SET_ACC_ERR_DS
 22087                                  
 22088                                  RDMID:
 22089 00003911 833E[D605]00            	CMP	word [SECCNT],0
 22090                                  	;JZ	RDLAST ; 10/08/2018
 22091 00003916 7453                    	jz	short RDLAST
 22092                                  
 22093 00003918 E84414                  	call	NEXTSEC
 22094 0000391B 72D2                    	JC	short SETSFTJ2
 22095                                  
 22096 0000391D C606[7405]01            	MOV	BYTE [TRANS],1		; A transfer is taking place
 22097                                  ONSEC:
 22098 00003922 8A16[7305]              	MOV	DL,[SECCLUSPOS]	; (dx/DL = Extent start) ((dh = ?))
 22099 00003926 8B0E[D605]              	MOV	CX,[SECCNT]
 22100 0000392A 8B1E[BC05]              	MOV	BX,[CLUSNUM]
 22101                                  RDLP:
 22102 0000392E E85F14                  	call	OPTIMIZE
 22103 00003931 72C1                    	JC	short SET_ACC_ERR_DS
 22104                                  
 22105 00003933 57                      	PUSH	DI                      ;DI = Next physical cluster.
 22106 00003934 50                      	PUSH	AX                      ;AX = # of sectors remaining.
 22107 00003935 53                      	PUSH	BX			;[DMAADD+2]:BX = Transfer address.
 22108                                  	;mov	byte [ALLOWED],38h
 22109 00003936 C606[4B03]38            	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 22110 0000393B 8E1E[2E03]              	MOV	DS,[DMAADD+2]
 22111                                  
 22112 0000393F 52                      	PUSH	DX                      ;[HIGH_SECTOR]:DX = phys. sector #.
 22113 00003940 51                      	PUSH	CX                      ;CX = # of contiguous sectors to read.
 22114                                  
 22115                                  	; 04/05/2019 - Retro DOS v4.0
 22116                                  
 22117                                  	; MSDOS 6.0
 22118 00003941 E80222                  	call	SET_RQ_SC_PARMS		;LB. do this for SC ;AN000;
 22119                                  
 22120                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22121 00003944 E8CFFD                  	call	DREAD
 22122                                  
 22123                                  	; MSDOS 3.3 
 22124                                  	;pop	bx
 22125                                  	;pop	dx
 22126                                  	;jc	short CANOT_READ
 22127                                  	;add	bx,dx	; (bx = Extent end)
 22128                                  	;mov	al,[es:bp] ; mov al,[es:bp+0]
 22129                                  	;;mov	al,[ES:BP+DPB.DRIVE] 
 22130                                  	;call	SETVISIT
 22131                                  	; ->***
 22132                                  ;M039
 22133                                  	; MSDOS 6.0 
 22134 00003947 59                      	pop	cx
 22135 00003948 5A                      	pop	dx
 22136 00003949 368F06[0C06]            	pop	WORD [ss:TEMP_VAR]
 22137 0000394E 72A2                    	jc	short CANOT_READ
 22138                                  
 22139 00003950 368C1E[0E06]            	mov	[ss:TEMP_VAR2],ds
 22140                                  
 22141                                  ;       CX = # of contiguous sectors read. (These constitute a block of
 22142                                  ;            sectors, also termed an "Extent".)
 22143                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 22144                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 22145                                  ;       ES:BP -> Drive Parameter Block (DPB).
 22146                                  ;
 22147                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
 22148                                  ;	buffers must be "read" into the transfer memory block, so that the
 22149                                  ;       transfer memory reflects the most recent data.
 22150                                  
 22151 00003955 E85E00                  	call	DskRdBufScan
 22152                                  
 22153                                  	;Context DS
 22154 00003958 16                      	push	ss
 22155 00003959 1F                      	pop	ds
 22156                                          
 22157 0000395A 59                      	pop	cx
 22158 0000395B 5B                              pop	bx
 22159                                  
 22160                                  ;       CX = # of sector remaining.
 22161                                  ;       BX = Next physical cluster.
 22162                                  
 22163                                  ;M039
 22164                                  
 22165                                  ;;;;;;;;
 22166                                  ;	; 25/07/2018 - Retro DOS v3.0
 22167                                  ;	; ***->
 22168                                  ;	; MSDOS 3.3
 22169                                  ;	; IBMDOS.COM (1987) - Offset 42BDh
 22170                                  ;bufq:
 22171                                  ;;	DX = Extent start.
 22172                                  ;;	BX = Extent end.
 22173                                  ;;	 AL = Drive #.
 22174                                  ;;     DS:DI-> 1st buffer in queue.
 22175                                  ;
 22176                                  ;	;or	byte [di+5],20h
 22177                                  ;	or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 22178                                  ;	;cmp	al,[di+4]	
 22179                                  ;	cmp	al,[DI+BUFFINFO.buf_ID]
 22180                                  ;	jnz	short bufq3
 22181                                  ;	;cmp	[di+6],dx
 22182                                  ;	cmp	[DI+BUFFINFO.buf_sector],dx
 22183                                  ;	jb	short bufq3	; Jump if Extent start > buffer sector.
 22184                                  ;	;cmp	[di+6],bx
 22185                                  ;	cmp	[DI+BUFFINFO.buf_sector],bx
 22186                                  ;	jnb	short bufq3	; Jump if Extent end >= buffer sector.
 22187                                  ;	
 22188                                  ;	; Buffer sector is in the Extent (contiguous sectors to read)
 22189                                  ;
 22190                                  ;;      Buffer's sector is in Extent: if it is dirty, copy its contents to
 22191                                  ;;      transfer memory; otherwise, just re-position it in the buffer queue
 22192                                  ;;      as MRU (Most Recently Used).
 22193                                  ;
 22194                                  ;	;test	byte [di+5],40h
 22195                                  ;	test	byte [DI+BUFFINFO.buf_flags],buf_dirty ; Bit 6 = dirty flag
 22196                                  ;	jz	short bufq2	; clear buffer, check the next buff sec
 22197                                  ;	pop	ax ; transfer address
 22198                                  ;	push	ax
 22199                                  ;	push	di
 22200                                  ;	push	dx
 22201                                  ;	;sub	dx,[di+6]
 22202                                  ;	sub	dx,[DI+BUFFINFO.buf_sector]
 22203                                  ;	neg	dx
 22204                                  ;
 22205                                  ;;      DX = offset (in sectors) of buffer sector within Transfer memory
 22206                                  ;;           block.
 22207                                  ;
 22208                                  ;	mov	si,di
 22209                                  ;	mov	di,ax
 22210                                  ;	mov	ax,dx
 22211                                  ;	;mov	cx,[es:bp+6]	
 22212                                  ;	mov     cx,[ES:BP+DPB.SECTOR_SIZE] ; CX = sector size (in bytes).
 22213                                  ;	mul	cx
 22214                                  ;	add	di,ax
 22215                                  ;
 22216                                  ;	lea	si,[si+16]
 22217                                  ;	lea	si,[SI+BUFINSIZ] ;DS:SI -> buffer data.
 22218                                  ;	shr	cx,1
 22219                                  ;	push	es
 22220                                  ;	mov	es,[SS:DMAADD+2]
 22221                                  ;
 22222                                  ;;      CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 22223                                  ;;      DS:SI-> Buffer sector data.
 22224                                  ;;      ES:DI-> Destination within Transfer memory block.
 22225                                  ;
 22226                                  ;	rep	movsw			;Copy buffer sector to Transfer memory
 22227                                  ;	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 22228                                  ;	;rep	movsb                   ;Copy last byte.
 22229                                  ;	jnc	short bufq1
 22230                                  ;	movsb
 22231                                  ;bufq1:
 22232                                  ;	pop	es
 22233                                  ;	pop	dx
 22234                                  ;	pop	di
 22235                                  ;	mov	al,[es:bp]  ; mov al,[es:bp+0]
 22236                                  ;	;mov	al,[ES:BP+DPB.DRIVE]
 22237                                  ;bufq2:
 22238                                  ;	call	SCANPLACE
 22239                                  ;bufq3:
 22240                                  ;	call	SKIPVISIT
 22241                                  ;	jnz	short bufq
 22242                                  ;	
 22243                                  ;	push	ss
 22244                                  ;	pop	ds
 22245                                  ;	pop	cx
 22246                                  ;	pop	cx
 22247                                  ;	pop	bx	
 22248                                  ;bufq4:
 22249                                  ;;;;;;;
 22250 0000395C E30D                    	JCXZ	RDLAST
 22251                                  
 22252 0000395E E8CD1B                  	call	IsEOF			; test for eof on fat size
 22253 00003961 7325                    	JAE	short SETSFT
 22254                                  
 22255 00003963 B200                    	MOV	DL,0
 22256 00003965 FF06[BA05]              	INC	word [LASTPOS]		; We'll be using next cluster
 22257 00003969 EBC3                    	JMP	short RDLP ; 19/05/2019
 22258                                  
 22259                                  RDLAST:
 22260 0000396B A1[D405]                	MOV	AX,[BYTCNT2]
 22261 0000396E 09C0                    	OR	AX,AX
 22262 00003970 7416                    	JZ	short SETSFT
 22263 00003972 A3[D205]                	MOV	[BYTCNT1],AX
 22264                                  
 22265 00003975 E8E713                  	call	NEXTSEC
 22266 00003978 720E                    	JC	short SETSFT
 22267                                  
 22268 0000397A C706[CC05]0000          	MOV	word [BYTSECPOS],0
 22269 00003980 E84713                  	call	BUFRD
 22270                                  	; 10/08/2018
 22271                                  
 22272 00003983 7303                    	JNC	short SETSFT
 22273 00003985 E96CFF                  	JMP	SET_ACC_ERR_DS
 22274                                  
 22275                                  ;------------------------------------------------------------------------------
 22276                                  ;
 22277                                  ; Procedure Name : SETSFT
 22278                                  ; Inputs:
 22279                                  ;	[NEXTADD],[CLUSNUM],[LASTPOS] set to determine transfer size
 22280                                  ;		and set cluster fields
 22281                                  ; Function:
 22282                                  ;	Update [THISSFT] based on the transfer
 22283                                  ; Outputs:
 22284                                  ;	sf_position, sf_lstclus, and sf_cluspos updated
 22285                                  ;	ES:DI points to [THISSFT]
 22286                                  ;	CX No. of bytes transferred
 22287                                  ;	Carry clear
 22288                                  ;
 22289                                  ;----------------------------------------------------------------------------
 22290                                  
 22291                                  	;entry	SETSFT
 22292                                  
 22293                                  ; 26/07/2018 - Retro DOS v3.0
 22294                                  SETSFT:
 22295 00003988 C43E[9E05]              	LES	DI,[THISSFT]
 22296                                  
 22297                                  ; Same as SETSFT except ES:DI already points to SFT
 22298                                  	;entry	SETCLUS
 22299                                  SETCLUS:	
 22300 0000398C 8B0E[B805]              	MOV	CX,[NEXTADD]
 22301 00003990 2B0E[2C03]              	SUB	CX,[DMAADD]		; Number of bytes transfered
 22302                                  	;;test	word [es:di+5],80h
 22303                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 22304                                  	;JNZ	short ADDREC		; don't set clusters if device
 22305                                  
 22306                                  	; 04/05/2019 - Retro DOS v4.0
 22307                                  	;test	byte [es:di+5],80h
 22308 00003994 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 22309 00003999 750E                    	JNZ	short ADDREC		; don't set clusters if device
 22310                                  
 22311 0000399B A1[BC05]                	MOV	AX,[CLUSNUM]
 22312                                  	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
 22313                                  	;mov	[es:di+35h],ax ; MSDOS 6.0 (& MSDOS 6.21)
 22314 0000399E 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 22315 000039A2 A1[BA05]                	MOV	AX,[LASTPOS]
 22316                                  	;mov	[es:di+19h],ax
 22317 000039A5 26894519                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],AX
 22318                                  
 22319                                  ;----------------------------------------------------------------------------
 22320                                  ;
 22321                                  ; Procedure : AddRec
 22322                                  ; Inputs:
 22323                                  ;	ES:DI points to SFT
 22324                                  ;	CX is No. Bytes transferred
 22325                                  ; Function:
 22326                                  ;	Update the SFT offset based on the transfer
 22327                                  ; Outputs:
 22328                                  ;	sf_position updated to point to first byte after transfer
 22329                                  ;	ES:DI points to SFT
 22330                                  ;	CX No. of bytes transferred
 22331                                  ;	Carry clear
 22332                                  ;----------------------------------------------------------------------------
 22333                                  
 22334                                  	;entry	AddRec
 22335                                  ADDREC:
 22336 000039A9 E309                    	JCXZ	RET28		; If no records read,  don't change position
 22337                                  	;add	[es:di+15h],cx
 22338 000039AB 26014D15                	ADD	[ES:DI+SF_ENTRY.sf_position],CX  ; Update current position
 22339                                  	;adc	word [es:di+17h], 0
 22340 000039AF 2683551700              	ADC	WORD [ES:DI+SF_ENTRY.sf_position+2],0
 22341                                  RET28:	
 22342 000039B4 F8                      	CLC
 22343 000039B5 C3                      	retn
 22344                                  
 22345                                  ; 25/07/2018
 22346                                  ; MSDOS 6.0
 22347                                  ;Break   <DskRdBufScan -- Disk Read Buffer Scan>
 22348                                  ;----------------------------------------------------------------------------
 22349                                  ;
 22350                                  ; Procedure Name : DskRdBufScan
 22351                                  ;
 22352                                  ; Inputs:
 22353                                  ;       CX = # of contiguous sectors read. (These constitute a block of
 22354                                  ;            sectors, also termed an "Extent".)
 22355                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 22356                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 22357                                  ;       ES:BP -> Drive Parameter Block (DPB).
 22358                                  ;
 22359                                  ; Function:
 22360                                  ;	The Buffer Queue is scanned: the contents of any dirty buffers are
 22361                                  ;	"read" into the transfer memory block, so that the transfer memory
 22362                                  ;	reflects the most recent data.
 22363                                  ;
 22364                                  ; Outputs:
 22365                                  ;       Transfer memory updated as required.
 22366                                  ;
 22367                                  ; Uses:
 22368                                  ;       DS,AX,BX,CX,SI,DI destroyed.
 22369                                  ;       SS override for all global variables.
 22370                                  ;
 22371                                  ; Notes:
 22372                                  ;       FIRST_BUFF_ADDR is set-up to contain the LAST buffer to check, rather
 22373                                  ;	than the FIRST.
 22374                                  ;----------------------------------------------------------------------------
 22375                                  ;M039: Created
 22376                                  
 22377                                  ; 04/05/2019 - Retro DOS v4.0
 22378                                  ; DOSCODE:78F0h (MSDOS 6.21, MSDOS.SYS)
 22379                                  
 22380                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22381                                  ; DOSCODE:78DCh (MSDOS 5.0, MSDOS.SYS) 
 22382                                  
 22383                                  ;procedure DskRdBufScan,NEAR
 22384                                  ;
 22385                                  ;ASSUME  DS:NOTHING
 22386                                  
 22387                                  DskRdBufScan:
 22388 000039B6 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0 ; Any dirty buffers?
 22389 000039BC 743C                    	je	short bufx		     ; -no, skip all work.
 22390                                  
 22391 000039BE 368B1E[0706]            	mov     bx,[ss:HIGH_SECTOR]
 22392 000039C3 89DE                    	mov     si,bx
 22393 000039C5 01D1                    	add     cx,dx
 22394 000039C7 83D600                  	adc     si,0
 22395                                  
 22396 000039CA E8111F                  	call	GETCURHEAD		;DS:DI -> 1st buf in queue.
 22397                                  	;mov	ax,[di+2]
 22398 000039CD 8B4502                  	mov     ax,[di+BUFFINFO.buf_prev]
 22399 000039D0 36A3[BB0E]              	mov     [ss:FIRST_BUFF_ADDR],ax
 22400                                  		
 22401                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22402                                  	;;mov	al,[es:bp+0]
 22403                                  	;mov	al,[es:bp+DPB.DRIVE]
 22404                                  	; 15/12/2022
 22405 000039D4 268A4600                	mov	al,[es:bp]
 22406                                  
 22407                                  ;       BX:DX = Extent start.
 22408                                  ;       SI:CX = Extent end + 1.
 22409                                  ;          AL = Drive #.
 22410                                  ;       DS:DI-> 1st buffer in queue.
 22411                                  ;[FIRST_BUFF_ADDR] = Address offset of last buffer in queue.
 22412                                  
 22413                                  bufq:	
 22414                                  	;cmp	al,[di+4]
 22415 000039D8 3A4504                  	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
 22416 000039DB 7514                    	jne	short bufq1        	;  -no, jump.
 22417                                  
 22418                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 22419                                  ;       ja	short bufq1		;Jump if Extent start > buffer sector.
 22420                                  
 22421                                  	;cmp	bx,[di+8]
 22422 000039DD 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 22423 000039E0 7503                    	jne	short bufq01
 22424                                  	;cmp	dx,[di+6]
 22425 000039E2 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 22426                                  bufq01:
 22427 000039E5 770A                    	ja	short bufq1
 22428                                  
 22429                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 22430                                  ;       ja	short bufq2		;Jump if Extent end >= buffer sector.
 22431                                  
 22432                                  	;cmp	si,[di+8]
 22433 000039E7 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 22434 000039EA 7503                    	jne	short bufq02
 22435                                  	;cmp	cx,[di+6]
 22436 000039EC 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 22437                                  bufq02:
 22438 000039EF 770A                    	ja	short bufq2
 22439                                  bufq1:	
 22440 000039F1 363B3E[BB0E]            	cmp     di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
 22441 000039F6 8B3D                    	mov	di,[di]
 22442                                  	;mov	di,[di+BUFFINFO.buf_next] ; Set-up for next buffer.
 22443 000039F8 75DE                    	jne	short bufq		; -no, do next buffer
 22444                                  bufx:
 22445 000039FA C3                      	retn				;Exit.
 22446                                  
 22447                                  ;       Buffer's sector is in Extent: if it is dirty, copy its contents to
 22448                                  ;	transfer memory; otherwise, just re-position it in the buffer queue
 22449                                  ;       as MRU (Most Recently Used).
 22450                                  
 22451                                  bufq2:	
 22452 000039FB 50                      	push	ax
 22453                                  	;test	byte [di+5],40h
 22454 000039FC F6450540                	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
 22455 00003A00 742D                    	jz	short bufq3                    ; -no, jump.
 22456                                  
 22457                                  ;       SaveReg <cx,dx,si,di,es>
 22458 00003A02 51                      	push	cx
 22459 00003A03 52                      	push	dx
 22460 00003A04 56                      	push	si
 22461 00003A05 57                      	push	di
 22462 00003A06 06                      	push	es
 22463                                  
 22464 00003A07 89D0                    	mov     ax,dx
 22465                                  	;sub	ax,[di+6]
 22466 00003A09 2B4506                  	sub	ax,[di+BUFFINFO.buf_sector]
 22467 00003A0C F7D8                    	neg	ax
 22468                                  
 22469                                  ;       AX = offset (in sectors) of buffer sector within Transfer memory
 22470                                  ;            block. (Note: the upper word of the sector # may be ignored
 22471                                  ;	     since no more than 64k bytes will ever be read. This 64k limit
 22472                                  ;            is imposed by the input parameters of the disk read operation.)
 22473                                  
 22474                                  	;lea	si,[di+20]
 22475 00003A0E 8D7514                  	lea	si,[di+BUFINSIZ]	;DS:SI -> buffer data.
 22476                                  	;mov	cx,[es:bp+2]
 22477 00003A11 268B4E02                	mov     cx,[es:bp+DPB.SECTOR_SIZE] ;CX = sector size (in bytes).
 22478 00003A15 F7E1                    	mul     cx			;AX = offset (in bytes) of buf. sector
 22479 00003A17 368B3E[0C06]            	mov     di,[ss:TEMP_VAR]
 22480 00003A1C 01C7                    	add	di,ax
 22481 00003A1E 368E06[0E06]            	mov	es,[ss:TEMP_VAR2]
 22482 00003A23 D1E9                    	shr	cx,1
 22483                                  
 22484                                  ;	   CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 22485                                  ;       DS:SI-> Buffer sector data.
 22486                                  ;       ES:DI-> Destination within Transfer memory block.
 22487                                  
 22488 00003A25 F3A5                    	rep	movsw			;Copy buffer sector to Transfer memory
 22489                                  	;; 04/05/2019
 22490                                  	;;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 22491                                  	;;rep	movsb                   ;Copy last byte.
 22492                                  	;jnc	short bufq03	
 22493                                  	;movsb
 22494                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22495                                  	;adc	cx,0
 22496                                  	;rep	movsb
 22497                                  	; 22/09/2023
 22498 00003A27 7301                    	jnc	short bufq03
 22499 00003A29 A4                      	movsb
 22500                                  bufq03:
 22501                                  	;RestoreReg <es,di,si,dx,cx>
 22502 00003A2A 07                      	pop	es
 22503 00003A2B 5F                      	pop	di
 22504 00003A2C 5E                      	pop	si
 22505 00003A2D 5A                      	pop	dx
 22506 00003A2E 59                      	pop	cx
 22507                                  
 22508                                  ;       DS:DI -> current buffer.
 22509                                  bufq3:	
 22510 00003A2F 89F8                    	mov     ax,di			;DS:AX -> Current buffer.
 22511                                          ;invoke SCANPLACE
 22512 00003A31 E8BC1E                  	call	SCANPLACE
 22513 00003A34 363B06[BB0E]            	cmp	ax,[ss:FIRST_BUFF_ADDR] ;Last buffer?
 22514 00003A39 58                      	pop	ax
 22515                                  	;jne	short bufq		; -no, jump.
 22516                                  	;;jmp	short bufx		; -yes, exit.
 22517                                  	;; 12/06/2019
 22518                                  	;retn
 22519                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compability)
 22520 00003A3A 759C                    	jne	short bufq
 22521 00003A3C EBBC                    	jmp	short bufx
 22522                                  
 22523                                  ;EndProc DskRdBufScan
 22524                                  
 22525                                  ;============================================================================
 22526                                  ; DISK3.ASM, MSDOS 6.0, 1991
 22527                                  ;============================================================================
 22528                                  ; 04/05/2019 - Retro DOS v4.0
 22529                                  ; 24/07/2018 - Retro DOS v3.0
 22530                                  
 22531                                  ;Break   <DISKWRITE -- PERFORM USER DISK WRITE>
 22532                                  ;----------------------------------------------------------------------------
 22533                                  ;
 22534                                  ; Procedure Name : DISKWRITE
 22535                                  ;
 22536                                  ; Inputs:
 22537                                  ;       Outputs of SETUP
 22538                                  ; Function:
 22539                                  ;       Perform disk write
 22540                                  ; Outputs:
 22541                                  ;    Carry clear
 22542                                  ;       CX = No. of bytes written
 22543                                  ;       ES:DI point to SFT
 22544                                  ;       SFT offset and cluster pointers updated
 22545                                  ;    Carry set
 22546                                  ;       CX = 0
 22547                                  ;       ES:DI point to SFT
 22548                                  ;       AX has error code
 22549                                  ;----------------------------------------------------------------------------
 22550                                  
 22551                                  ;hkn; called by DOS_WRITE. DS already set up at this point.
 22552                                  
 22553                                  ; DOSCODE:797Ah (MSDOS 6.21, MSDOS.SYS)
 22554                                  
 22555                                  ; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22556                                  ; DOSCODE:7966h (MSDOS 5.0, MSDOS.SYS) 
 22557                                  
 22558                                  DISKWRITE:
 22559                                  	; MSDOS 3.3
 22560                                  	; IBMDOS.COM - Offset 436Dh
 22561                                  	;;test	byte [es:di+4],8
 22562                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 22563                                  	;jz	short write_cont
 22564                                  	;jmp	SET_ACC_ERR_DS
 22565                                  ;write_cont:
 22566                                  	;push	cx
 22567                                  	;or	cx,cx
 22568                                  	;jnz	short Not_Truncate
 22569                                  	;;mov	cx,-1
 22570                                  	;dec	cx
 22571                                  ;Not_Truncate:
 22572                                  	;call	LOCK_CHECK
 22573                                  	;pop	cx
 22574                                  	;jnb	short _WRITE_OK
 22575                                  	;call	WRITE_LOCK_VIOLATION
 22576                                  	;jnb	short DISKWRITE
 22577                                  	;retn
 22578                                  
 22579                                  	; MSDOS 6.0
 22580 00003A3E E8F0FC                  	call	CHECK_WRITE_LOCK	;IFS. check write lock	;AN000;
 22581                                  	; 19/08/2018
 22582 00003A41 7304                    	JNC	short _WRITE_OK		;IFS. lock check ok	;AN000;
 22583 00003A43 C3                      	retn
 22584                                  
 22585                                  WRTEOFJ:
 22586 00003A44 E9DC01                  	JMP     WRTEOF
 22587                                  
 22588                                  _WRITE_OK:
 22589                                   	; 27/07/2018
 22590                                  	; IBMDOS.COM - Offset 438Eh
 22591                                  	
 22592                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22593                                  	;and	word [es:di+5],0BFBFh
 22594 00003A47 26816505BFBF            	AND     word [ES:DI+SF_ENTRY.sf_flags],~(sf_close_nodate|devid_file_clean)
 22595                                  				; Mark file as dirty, clear no date on close
 22596                                  
 22597                                  	; 04/05/2019 - Retro DOS v4.0	
 22598                                  
 22599                                  	; MSDOS 6.0
 22600                                  	; mov 	ax,[es:di+11h]
 22601 00003A4D 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]		;M039
 22602 00003A51 A3[0C06]                        MOV	[TEMP_VAR],AX                           ;M039
 22603                                  	;mov	ax,[es:di+13h]
 22604 00003A54 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]		;M039
 22605 00003A58 A3[0E06]                        MOV	[TEMP_VAR2],AX                          ;M039
 22606                                  
 22607                                  ;	TEMP_VAR2:TEMP_VAR = Current file size (sf_size);M039
 22608                                  
 22609                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22610 00003A5B C42E[8A05]              	LES     BP,[THISDPB]
 22611                                  
 22612 00003A5F E8FFFD                  	call	BREAKDOWN
 22613                                  
 22614 00003A62 A1[CE05]                	MOV     AX,[BYTPOS]
 22615 00003A65 8B16[D005]              	MOV     DX,[BYTPOS+2]
 22616 00003A69 E3D9                    	JCXZ    WRTEOFJ                 ;Make the file length = sf_position
 22617 00003A6B 01C8                    	ADD     AX,CX
 22618 00003A6D 83D200                  	ADC     DX,0                    ;DX:AX = last byte to write + 1.
 22619                                  
 22620                                  	;mov	bx,[es:bp+2]
 22621 00003A70 268B5E02                	MOV     BX,[ES:BP+DPB.SECTOR_SIZE]
 22622                                  
 22623                                  	; MSDOS 3.3
 22624                                  	;cmp	dx,bx
 22625                                  	;jnb	short WRTERR33
 22626                                  	;div	bx
 22627                                  	;mov	bx,ax
 22628                                  	;OR	DX,DX
 22629                                  	;JNZ	short CALCLUS
 22630                                  	;dec	ax
 22631                                  ;CALCLUS:
 22632                                  	; MSDOS 3.3
 22633                                  	;mov	cl,[es:bp+5]
 22634                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 22635                                  	;shr	ax,cl
 22636                                  	;push	ax
 22637                                  	;push	dx
 22638                                  	;push	es
 22639                                  	;les	di,[THISSFT]
 22640                                  	;;mov	ax,[es:di+11h]
 22641                                  	;;mov	dx,[es:di+13h]
 22642                                  	;mov	ax,[ES:DI+SF_ENTRY.sf_size]
 22643                                  	;mov	dx,[ES:DI+SF_ENTRY.sf_size+2]
 22644                                  	;pop	es
 22645                                  	;;DX:AX = current file size (in bytes).
 22646                                  	;;div	word [es:bp+2]
 22647                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 22648                                  	;mov	cx,ax
 22649                                  	;or	dx,dx
 22650                                  	;jz	short NORND
 22651                                  	;inc	ax
 22652                                  ;NORND:
 22653                                  	; MSDOS 6.0
 22654 00003A74 E8DC02                  	CALL	DIV32                   ;DX:AX/BX = CX:AX + DX (rem.).
 22655 00003A77 89C6                    	MOV	SI,AX
 22656 00003A79 890E[0706]                      MOV	[HIGH_SECTOR],CX
 22657                                  
 22658                                  ;       [HIGH_SECTOR]:SI = Last full sector to write.
 22659                                  
 22660 00003A7D 09D2                    	OR	DX,DX
 22661 00003A7F 52                      	PUSH	DX			;M039: Free DX for use by SHR32
 22662 00003A80 89CA                    	MOV	DX,CX			;M039
 22663 00003A82 7506                    	JNZ	short CALCLUS
 22664 00003A84 83E801                  	SUB	AX,1                    ;AX must be zero base indexed	;AC000;
 22665 00003A87 83DA00                  	SBB	DX,0			;M039 ;F.C. >32mb		;AN000;
 22666                                  
 22667                                  CALCLUS:
 22668                                  	; MSDOS 6.0
 22669 00003A8A E8ED02                  	CALL	SHR32                   ;F.C. >32mb			;AN000;
 22670 00003A8D 5A                      	POP	DX
 22671                                  
 22672                                  ;       AX = Last cluster to write.
 22673                                  ;       DX = # of bytes in last sector to write (the "tail").
 22674                                  ;       BX = [ES:BP+DPB.SECTOR_SIZE]
 22675                                  
 22676 00003A8E 50                      	PUSH	AX
 22677 00003A8F 52                      	PUSH	DX
 22678                                  ;M039
 22679 00003A90 8B16[0E06]              	mov	dx,[TEMP_VAR2]
 22680 00003A94 A1[0C06]                	mov	ax,[TEMP_VAR]           ;DX:AX = current file size (in bytes).
 22681 00003A97 E8B902                  	call	DIV32           	;DX:AX/BX = CX:AX + DX (rem.)
 22682 00003A9A 890E[0E06]              	mov	[TEMP_VAR2],cx
 22683 00003A9E 890E[CA05]              	mov	[VALSEC+2],cx
 22684 00003AA2 89C1                    	mov	cx,ax
 22685 00003AA4 89F3                    	mov	bx,si
 22686                                  
 22687                                  ;       [HIGH_SECTOR]:BX = Last full sector to write.
 22688                                  ;          [VALSEC+2]:CX = Last full sector of current file.
 22689                                  ;         [TEMP_VAR2]:CX = Last full sector of current file.
 22690                                  ;                     DX = # of bytes in last sector of current file.
 22691                                  ;M039
 22692 00003AA6 09D2                    	OR	DX,DX
 22693 00003AA8 7407                    	JZ	short NORND
 22694                                  	;ADD	AX,1            	;Round up if any remainder	;AC000;
 22695                                  	;ADC	word [VALSEC+2],0
 22696                                  	; 22/09/2023
 22697 00003AAA 40                      	inc	ax  ; 0FFFFh -> 0
 22698 00003AAB 7504                    	jnz	short NORND
 22699 00003AAD FF06[CA05]              	inc	word [VALSEC+2]
 22700                                  NORND:	
 22701                                  	; MSDOS 3.3 & MSDOS 6.0
 22702 00003AB1 A3[C805]                	MOV     [VALSEC],AX
 22703                                  
 22704                                  ;       [VALSEC] = Last sector of current file.
 22705                                  
 22706 00003AB4 31C0                    	XOR     AX,AX
 22707 00003AB6 A3[DE05]                	MOV     [GROWCNT],AX
 22708 00003AB9 A3[E005]                	MOV     [GROWCNT+2],AX
 22709 00003ABC 58                      	POP     AX
 22710                                  
 22711                                  	; MSDOS 6.0
 22712 00003ABD 8B3E[0706]              	MOV	DI,[HIGH_SECTOR]        ;F.C. >32mb			;AN000;
 22713 00003AC1 3B3E[0E06]              	CMP	DI,[TEMP_VAR2]		;M039; F.C. >32mb		;AN000;
 22714 00003AC5 7263                    	JB	short NOGROW		;F.C. >32mb                     ;AN000;
 22715 00003AC7 7408                    	JZ	short lowsec		;F.C. >32mb                     ;AN000;
 22716 00003AC9 29CB                    	SUB	BX,CX                   ;F.C. >32mb                     ;AN000;
 22717 00003ACB 1B3E[0E06]              	SBB	DI,[TEMP_VAR2]   	;M039; F.C. >32mb di:bx no. of sectors ;AN000;
 22718 00003ACF EB08                    	JMP	short yesgrow           ;F.C. >32mb                     ;AN000;
 22719                                  lowsec:
 22720                                  	;MOV	DI,0			;F.C. >32mb
 22721                                  	; 22/09/2023
 22722 00003AD1 31FF                    	xor	di,di
 22723                                  	; MSDOS 3.3 & MSDOS 6.0
 22724 00003AD3 29CB                    	SUB	BX,CX			; Number of full sectors
 22725 00003AD5 7253                    	JB	short NOGROW
 22726 00003AD7 7444                    	JZ	short TESTTAIL
 22727                                  yesgrow:
 22728                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22729 00003AD9 89D1                    	MOV     CX,DX
 22730 00003ADB 93                      	XCHG    AX,BX
 22731                                  	;mul	word [es:bp+2]
 22732 00003ADC 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]  ; Bytes of full sector growth
 22733                                  	
 22734                                  	; MSDOS 6.0
 22735 00003AE0 8916[0706]              	MOV	[HIGH_SECTOR],DX         ;F.C. >32mb save dx                    ;AN000;
 22736 00003AE4 A3[0E06]                	MOV	[TEMP_VAR2],AX    	 ;M039; F.C. >32mb save ax		;AN000;
 22737 00003AE7 89F8                    	MOV	AX,DI                    ;F.C. >32mb                            ;AN000;
 22738                                  	;mul	word [es:bp+2]
 22739 00003AE9 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE] ;F.C. >32mb do higher word multiply ;AN000;
 22740                                  	
 22741 00003AED 0306[0706]              	ADD	AX,[HIGH_SECTOR]         ;F.C. >32mb add lower value            ;AN000;
 22742 00003AF1 89C2                    	MOV	DX,AX                    ;F.C. >32mb DX:AX is the result of     ;AN000;
 22743 00003AF3 A1[0E06]                	MOV	AX,[TEMP_VAR2]    	 ;M039; F.C. >32mb a 32 bit multiply	;AN000;
 22744                                  
 22745                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22746 00003AF6 29C8                    	SUB     AX,CX			; Take off current "tail"
 22747 00003AF8 83DA00                  	SBB     DX,0			; 32-bit extension
 22748 00003AFB 01D8                    	ADD     AX,BX			; Add on new "tail"
 22749 00003AFD 83D200                  	ADC     DX,0			; ripple tim's head off
 22750 00003B00 EB21                    	JMP     SHORT SETGRW
 22751                                  
 22752                                  HAVSTART:
 22753                                  	;int 3
 22754 00003B02 89C1                    	MOV     CX,AX
 22755 00003B04 E86D11                  	call	SKPCLP
 22756                                  	;JCXZ	DOWRTJ
 22757                                  	; 16/12/2022
 22758 00003B07 E357                    	jcxz	DOWRT
 22759                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22760                                  	;jcxz	DOWRTJ
 22761                                  
 22762 00003B09 E80F13                  	call	ALLOCATE
 22763                                  	;JNC	short DOWRTJ
 22764                                  	; 16/12/2022
 22765 00003B0C 7352                    	jnc	short DOWRT
 22766                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22767                                  	;jnc	short DOWRTJ
 22768                                  
 22769                                  	;entry   WRTERR
 22770                                  WRTERR:
 22771 00003B0E B40F                    	MOV     AH,0FH			;MS. write/data/fail/abort      ;AN000;
 22772                                  
 22773                                  	;entry WRTERR22
 22774                                  WRTERR22:
 22775 00003B10 A0[7605]                	MOV     AL,[THISDRV]		;MS.                            ;AN000;
 22776                                  
 22777                                  	; 27/07/2018
 22778                                  WRTERR33:
 22779                                  	;MOV	CX,0			;No bytes transferred
 22780 00003B13 31C9                    	XOR     CX,CX
 22781                                  					
 22782 00003B15 C43E[9E05]              	LES     DI,[THISSFT]
 22783                                  	;CLC ; 19/05/2019
 22784                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22785                                  	; 16/12/2022
 22786                                  	;clc
 22787 00003B19 C3                      	retn
 22788                                  
 22789                                  	; 16/12/2022
 22790                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22791                                  ;DOWRTJ:
 22792                                  	;JMP	short DOWRT
 22793                                  
 22794                                  ACC_ERRWJ:
 22795                                  	; 10/08/2018
 22796                                  	;JMP	SET_ACC_ERRW
 22797                                  	; 16/12/2022
 22798 00003B1A E9D7FD                  	jmp	SET_ACC_ERR_DS
 22799                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22800                                  	;jmp	SET_ACC_ERRW	
 22801                                  
 22802                                  TESTTAIL:
 22803 00003B1D 29D0                    	SUB     AX,DX
 22804 00003B1F 7609                    	JBE	short NOGROW
 22805 00003B21 31D2                    	XOR     DX,DX
 22806                                  SETGRW:
 22807 00003B23 A3[DE05]                	MOV	[GROWCNT],AX
 22808 00003B26 8916[E005]              	MOV	[GROWCNT+2],DX
 22809                                  NOGROW:
 22810 00003B2A 58                      	POP     AX
 22811 00003B2B 8B0E[BC05]              	MOV     CX,[CLUSNUM]    ; First cluster accessed
 22812 00003B2F E82211                  	call	FNDCLUS
 22813 00003B32 72E6                    	JC	short ACC_ERRWJ
 22814 00003B34 891E[BC05]              	MOV     [CLUSNUM],BX
 22815 00003B38 8916[BA05]              	MOV     [LASTPOS],DX
 22816                                  
 22817 00003B3C 29D0                    	SUB     AX,DX           ; Last cluster minus current cluster
 22818 00003B3E 7420                    	JZ	short DOWRT	; If we have last clus, we must have first
 22819 00003B40 E3C0                    	JCXZ    HAVSTART        ; See if no more data
 22820 00003B42 51                      	PUSH    CX              ; No. of clusters short of first
 22821 00003B43 89C1                    	MOV     CX,AX
 22822 00003B45 E8D312                  	call	ALLOCATE
 22823 00003B48 59                      	POP     CX
 22824 00003B49 72C3                    	JC	short WRTERR
 22825 00003B4B 8B16[BA05]              	MOV     DX,[LASTPOS]
 22826 00003B4F 42                      	INC     DX
 22827 00003B50 49                      	DEC     CX
 22828 00003B51 7405                    	JZ	short NOSKIP
 22829 00003B53 E81E11                  	call	SKPCLP
 22830 00003B56 72C2                    	JC	short ACC_ERRWJ
 22831                                  NOSKIP:
 22832 00003B58 891E[BC05]              	MOV     [CLUSNUM],BX
 22833 00003B5C 8916[BA05]              	MOV     [LASTPOS],DX
 22834                                  DOWRT:
 22835 00003B60 833E[D205]00            	CMP     word [BYTCNT1],0
 22836 00003B65 7409                    	JZ	short WRTMID
 22837 00003B67 8B1E[BC05]              	MOV     BX,[CLUSNUM]
 22838 00003B6B E89511                  	call	BUFWRT
 22839 00003B6E 72AA                    	JC	short ACC_ERRWJ
 22840                                  WRTMID:
 22841 00003B70 A1[D605]                	MOV     AX,[SECCNT]
 22842 00003B73 09C0                    	OR      AX,AX
 22843                                  	; 20/11/2022
 22844 00003B75 746F                    	JZ	short WRTLAST	; 24/07/2019	;M039
 22845 00003B77 0106[C405]              	ADD     [SECPOS],AX
 22846                                  	; 19/05/2019
 22847                                  	; MSDOS 6.0
 22848 00003B7B 8316[C605]00            	ADC	WORD [SECPOS+2],0	;F.C. >32mb 	;AN000;
 22849 00003B80 E8DC11                  	call	NEXTSEC
 22850                                  	; 16/12/2022
 22851 00003B83 7295                    	JC	short ACC_ERRWJ
 22852                                  	;JC	short SET_ACC_ERRW	;M039
 22853 00003B85 C606[7405]01            	MOV     BYTE [TRANS],1		; A transfer is taking place
 22854 00003B8A 8A16[7305]              	MOV     DL,[SECCLUSPOS] 	; (dx/DL = Extent start) ((dh = ?))
 22855 00003B8E 8B1E[BC05]              	MOV     BX,[CLUSNUM]
 22856 00003B92 8B0E[D605]              	MOV     CX,[SECCNT]
 22857                                  WRTLP:
 22858 00003B96 E8F711                  	call	OPTIMIZE
 22859 00003B99 7248                    	JC	short SET_ACC_ERRW
 22860                                  	; 16/12/2022
 22861                                  	;JC	short ACC_ERRWJ
 22862                                  
 22863                                  ;M039
 22864                                  ;       DI = Next physical cluster.
 22865                                  ;       AX = # sectors remaining.
 22866                                  ;       [DMAADD+2]:BX = transfer address (source data address).
 22867                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 22868                                  ;	     sectors, also termed an "Extent".)
 22869                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 22870                                  ;       ES:BP -> Drive Parameter Block (DPB).
 22871                                  ;
 22872                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 22873                                  ;	are in Extent; they are being over-written.
 22874                                  
 22875 00003B9B 57                      	push    di
 22876 00003B9C 50                      	push    ax
 22877                                  
 22878                                  	; MSDOS 3.3
 22879                                  	; IBMDOS.COM (1987) - Offset 4497h
 22880                                  	;push	dx
 22881                                  	;push	bx
 22882                                  	;mov	al,[es:bp]
 22883                                  	;;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 22884                                  	;mov	bx,cx
 22885                                  	;add	bx,dx	; (bx = Extent end)
 22886                                  
 22887                                  ;	DX = Extent start.
 22888                                  ;	BX = Extent end.
 22889                                  ;	AL = Drive #.
 22890                                  
 22891                                  	;call	SETVISIT
 22892                                  
 22893                                  ;wbufq1:
 22894                                  	;;or	byte [di+5],20h
 22895                                  	;or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 22896                                  	;;cmp	al,[di+4]	
 22897                                  	;cmp	al,[DI+BUFFINFO.buf_ID]
 22898                                  	;jnz	short wbufq2	; Jump if Extent start > buffer sector.
 22899                                  	;;cmp	[di+6],dx
 22900                                  	;cmp	[DI+BUFFINFO.buf_sector],dx
 22901                                  	;jb	short wbufq2
 22902                                  	;;cmp	[di+6],bx
 22903                                  	;cmp	[DI+BUFFINFO.buf_sector],bx
 22904                                  	;jnb	short wbufq2	; Jump if Extent end >= buffer sector.
 22905                                  
 22906                                  	;; Buffer sector is in the Extent
 22907                                  
 22908                                  	;;mov	word [di+4],20FFh
 22909                                  	;mov	word [DI+BUFFINFO.buf_ID],20FFh
 22910                                  	;				; .buf_ID,    AL = FFh (Free buffer)
 22911                                  	;				; .buf_flags, AH = 0, reset/clear
 22912                                  	;call	SCANPLACE
 22913                                  ;wbufq2:
 22914                                  	;call	SKIPVISIT
 22915                                  	;jnz	short wbufq1
 22916                                  	;pop	bx
 22917                                  	;pop	dx
 22918                                  
 22919                                          ; MSDOS 6.0
 22920 00003B9D E82D01                  	call	DskWrtBufPurge		;DS trashed.
 22921                                  
 22922                                  ;ASSUME DS:NOTHING
 22923                                  ;M039
 22924                                  	; MSDOS 3.3 & MSDOS 6.0
 22925                                  ;hkn; SS override for DMAADD and ALLOWED
 22926 00003BA0 368E1E[2E03]            	MOV     DS,[SS:DMAADD+2]
 22927                                  	;mov	byte [ss:ALLOWED],38h
 22928 00003BA5 36C606[4B03]38          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 22929                                  
 22930                                  ;	put logic from DWRITE in-line here so we can modify it
 22931                                  ;	for DISK FULL conditions.
 22932                                  
 22933                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22934                                  	; DOSCODE:7AD8h (MSDOS 5.0 MSDOS.SYS)
 22935                                  
 22936                                  	; 16/12/2022
 22937                                  	; MSDOS 3.3 (& MSDOS 5.0)
 22938                                  	;call	DWRITE
 22939                                  
 22940                                  ;DWRITE_OKAY:
 22941                                  
 22942                                  	; 16/12/2022
 22943                                  	; MSDOS 5.0 (& MSDOS 3.3)
 22944                                  	;pop     cx
 22945                                  	;pop     bx
 22946                                  	;push    ss
 22947                                  	;pop     ds
 22948                                  	;jc      short SET_ACC_ERRW
 22949                                  	;jcxz    WRTLAST
 22950                                  	;mov     dl, 0
 22951                                  	;inc     word [LASTPOS]
 22952                                  	;jmp     short WRTLP
 22953                                  
 22954                                  	; 16/12/2022
 22955                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22956                                  DWRITE_LUP:
 22957                                  	; 23/07/2019 - Retro DOS v3.2
 22958                                  
 22959                                  	; MSDOS 6.0
 22960 00003BAB E8E1FB                  	call	DSKWRITE
 22961 00003BAE 7417                    	jz	short DWRITE_OKAY
 22962                                  
 22963                                  ;;	int	3
 22964                                  
 22965 00003BB0 3C27                    	cmp	al,error_handle_Disk_Full	; compressed volume full?
 22966 00003BB2 7423                    	jz	short DWRITE_DISK_FULL
 22967                                  
 22968                                  	; 16/12/2022
 22969                                  
 22970                                  ;;hkn; SS override
 22971 00003BB4 36C606[7505]01          	MOV	BYTE [SS:READOP],1
 22972 00003BBA E801FC                  	call	HARDERRRW
 22973 00003BBD 3C01                    	CMP	AL,1		; Check for retry
 22974 00003BBF 74EA                    	JZ	short DWRITE_LUP
 22975                                  
 22976                                  	; 16/12/2022
 22977                                  	; 23/07/2019
 22978                                  	;POP	CX ; *4*
 22979                                  	;POP	BX ; *5*
 22980                                  	;
 22981                                  	;push	ss
 22982                                  	;pop	ds
 22983                                  	;
 22984                                  
 22985                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22986                                  
 22987                                  	; 16/12/2022
 22988 00003BC1 3C03                    	CMP	AL,3		; Check for FAIL
 22989 00003BC3 F8                      	CLC
 22990 00003BC4 7501                    	JNZ	short DWRITE_OKAY ; Ignore
 22991 00003BC6 F9                      	STC
 22992                                  
 22993                                  DWRITE_OKAY:
 22994                                  	; 16/12/2022
 22995                                  	; 23/07/2019
 22996                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22997 00003BC7 59                      	POP	CX ; *4*
 22998 00003BC8 5B                      	POP	BX ; *5*
 22999                                  
 23000                                  ;       CX = # sectors remaining.
 23001                                  ;       BX = Next physical cluster.
 23002                                  
 23003                                  ;hkn; SS override
 23004                                          ;Context DS
 23005                                  	; 16/12/2022
 23006                                  	;push	ss
 23007                                  	;pop	ds
 23008                                  
 23009                                  	; 16/12/2022
 23010 00003BC9 7218                    	jc	short SET_ACC_ERRW
 23011                                  
 23012                                  	; 16/12/2022
 23013 00003BCB 16                      	push	ss
 23014 00003BCC 1F                      	pop	ds
 23015                                  
 23016 00003BCD E317                    	JCXZ    WRTLAST
 23017                                  
 23018                                  	;MOV	DL,0
 23019 00003BCF 30D2                    	xor	dl,dl ; 23/07/2019
 23020 00003BD1 FF06[BA05]              	INC     word [LASTPOS]	; We'll be using next cluster
 23021 00003BD5 EBBF                    	JMP     short WRTLP
 23022                                  
 23023                                  	; 23/07/2019 - Retro DOS v3.2
 23024                                  	; 09/08/2018
 23025                                  	; MSDOS 6.0
 23026                                  DWRITE_DISK_FULL:
 23027                                  	;Context DS		;SQ 3-5-93 DS must be setup on return!
 23028                                  	; 16/12/2022
 23029 00003BD7 16                      	push	ss
 23030 00003BD8 1F                      	pop	ds
 23031 00003BD9 59                      	pop	cx		; unjunk stack
 23032 00003BDA 5B                      	pop	bx
 23033 00003BDB C606[0B06]01            	mov	byte [DISK_FULL],1
 23034                                  	;stc
 23035 00003BE0 E92BFF                  	jmp	WRTERR ; 24/07/2019 ; go to disk full exit
 23036                                  
 23037                                  	; 16/12/2022
 23038                                  SET_ACC_ERRW:
 23039 00003BE3 E90EFD                  	jmp	SET_ACC_ERR_DS
 23040                                  
 23041                                  WRTLAST:
 23042 00003BE6 A1[D405]                	MOV     AX,[BYTCNT2]
 23043 00003BE9 09C0                    	OR      AX,AX
 23044 00003BEB 7413                    	JZ	short FINWRT
 23045 00003BED A3[D205]                	MOV     [BYTCNT1],AX
 23046 00003BF0 E86C11                  	call	NEXTSEC
 23047 00003BF3 72EE                    	JC	short SET_ACC_ERRW
 23048 00003BF5 C706[CC05]0000          	MOV     word [BYTSECPOS],0
 23049 00003BFB E80511                  	call	BUFWRT
 23050 00003BFE 72E3                    	JC	short SET_ACC_ERRW
 23051                                  FINWRT:
 23052 00003C00 C43E[9E05]              	LES     DI,[THISSFT]
 23053 00003C04 A1[DE05]                	MOV     AX,[GROWCNT]
 23054 00003C07 8B0E[E005]              	MOV     CX,[GROWCNT+2]
 23055 00003C0B 09C0                    	OR      AX,AX
 23056 00003C0D 7502                    	JNZ	short UPDATE_size
 23057 00003C0F E30F                    	JCXZ    SAMSIZ
 23058                                  UPDATE_size:
 23059                                  	;add	[es:di+11h],ax
 23060 00003C11 26014511                	ADD     [ES:DI+SF_ENTRY.sf_size],AX
 23061                                  	;adc	[es:di+13h],cx
 23062 00003C15 26114D13                	ADC     [ES:DI+SF_ENTRY.sf_size+2],CX
 23063                                  
 23064                                  ; Make sure that all other SFT's see this growth also.
 23065                                  
 23066 00003C19 B80100                  	MOV     AX,1
 23067                                  ;if installed
 23068                                  	;Call	JShare + 14 * 4
 23069 00003C1C FF1E[C800]              	call    far [JShare+(14*4)]	; 14 = ShSU
 23070                                  ;else
 23071                                  ;	Call    ShSU
 23072                                  ;endif
 23073                                  
 23074                                  SAMSIZ:
 23075 00003C20 E969FD                  	jmp	SETCLUS	; ES:DI already points to SFT
 23076                                  
 23077                                  	; 16/12/2022
 23078                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23079                                  ;SET_ACC_ERRW:
 23080                                  	;jmp	SET_ACC_ERR_DS
 23081                                  
 23082                                  WRTEOF:
 23083 00003C23 89C1                    	MOV     CX,AX
 23084 00003C25 09D1                    	OR      CX,DX
 23085 00003C27 746C                    	JZ	short KILLFIL
 23086 00003C29 83E801                  	SUB     AX,1
 23087 00003C2C 83DA00                  	SBB     DX,0
 23088                                  
 23089                                  	; MSDOS 3.3
 23090                                  	;;div	word [es:bp+2]
 23091                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 23092                                  	;;mov	cl,[es:bp+5]
 23093                                  	;mov	cl,[ES:BP+DPB.CLUSTER_SHIFT] 
 23094                                  	;shr	ax,cl
 23095                                  
 23096                                  	; MSDOS 6.0
 23097 00003C2F 53                      	PUSH	BX
 23098                                  	;mov	bx,[es:bp+2]
 23099 00003C30 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]    ;F.C. >32mb                       ;AN000;
 23100 00003C34 E81C01                  	CALL	DIV32                         ;F.C. >32mb                       ;AN000;
 23101 00003C37 5B                      	POP	BX			      ;F.C. >32mb			;AN000;
 23102 00003C38 89CA                    	MOV	DX,CX			      ;M039
 23103 00003C3A 890E[0706]                      MOV	[HIGH_SECTOR],CX              ;M039: Probably extraneous, but not sure.
 23104 00003C3E E83901                  	CALL	SHR32                         ;F.C. >32mb                       ;AN000;
 23105                                  
 23106 00003C41 89C1                    	MOV     CX,AX
 23107 00003C43 E80E10                  	call	FNDCLUS
 23108                                  SET_ACC_ERRWJ2:
 23109 00003C46 729B                    	JC	short SET_ACC_ERRW
 23110                                  
 23111 00003C48 E326                    	JCXZ    RELFILE
 23112 00003C4A E8CE11                  	call	ALLOCATE
 23113                                  	;JC	short WRTERRJ              ;;;;;;;;; disk full
 23114                                  	; 16/12/2022
 23115 00003C4D 7303                    	jnc	short UPDATE
 23116 00003C4F E9BCFE                  	JMP	WRTERR
 23117                                  UPDATE:
 23118 00003C52 C43E[9E05]              	LES	DI,[THISSFT]
 23119 00003C56 A1[CE05]                	MOV	AX,[BYTPOS]
 23120                                  	;mov	[es:di+11h],ax
 23121 00003C59 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 23122 00003C5D A1[D005]                	MOV	AX,[BYTPOS+2]
 23123                                  	;mov	[es:di+13h],ax
 23124 00003C60 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 23125                                  ;
 23126                                  ; Make sure that all other SFT's see this growth also.
 23127                                  ;
 23128 00003C64 B80200                  	MOV     AX,2
 23129                                  ;if installed
 23130                                  	;Call	JShare + 14 * 4
 23131 00003C67 FF1E[C800]              	call    far [JShare+(14*4)]	; 14 = ShSU
 23132                                  ;else
 23133                                  ;	Call    ShSU
 23134                                  ;endif
 23135 00003C6B 31C9                    	XOR     CX,CX
 23136 00003C6D E939FD                  	jmp	ADDREC
 23137                                  
 23138                                  	; 16/12/2022
 23139                                  ;WRTERRJ: 
 23140                                  	;JMP	WRTERR
 23141                                  
 23142                                  ;;;;;;;;;;;;;;;; 7/18/86
 23143                                  ;;;;;;;;;;;;;;;;
 23144                                  
 23145                                  RELFILE:
 23146                                  	; MSDOS 6.0
 23147 00003C70 06                      	PUSH    ES                    ;AN002; BL Reset Lstclus and cluspos to
 23148 00003C71 C43E[9E05]              	LES     DI,[THISSFT]          ;AN002; BL beginning of file if current
 23149                                  	;cmp	dx,[es:di+19h]
 23150 00003C75 263B5519                	CMP     DX,[ES:DI+SF_ENTRY.sf_cluspos]	;AN002; BL cluspos is past EOF.
 23151 00003C79 730E                    	JAE	short SKIPRESET	      		;AN002; BL
 23152                                  	;mov	[es:di+19h],0
 23153 00003C7B 26C745190000            	MOV     word [ES:DI+SF_ENTRY.sf_cluspos],0 ;AN002; BL
 23154                                  	;mov	dx,[es:di+0Bh]
 23155 00003C81 268B550B                	MOV     DX,[ES:DI+SF_ENTRY.sf_firclus]	;AN002; BL
 23156                                  	;mov	[es:di+35h],dx
 23157 00003C85 26895535                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],DX	;AN002; BL
 23158                                  SKIPRESET:                            		;AN002; BL
 23159 00003C89 07                      	POP     ES                    		;AN002; BL
 23160                                  ;
 23161 00003C8A BAFFFF                  	MOV     DX,0FFFFH
 23162 00003C8D E83912                  	call	RELBLKS
 23163                                  	; 16/12/2022
 23164                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23165 00003C90 73C0                    	jnc	short UPDATE
 23166                                  SET_ACC_ERRWJ:
 23167                                  	;JC	short SET_ACC_ERRWJ2
 23168                                  	;JMP	SHORT UPDATE
 23169                                  	; 16/12/2022
 23170 00003C92 E95FFC                  	jmp	SET_ACC_ERR_DS
 23171                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23172                                  	;JC	short SET_ACC_ERRWJ2
 23173                                  	;JMP	SHORT UPDATE
 23174                                  
 23175                                  KILLFIL:
 23176 00003C95 31DB                    	XOR     BX,BX
 23177 00003C97 06                      	PUSH    ES
 23178 00003C98 C43E[9E05]              	LES     DI,[THISSFT]
 23179                                  	;mov	[es:di+19h],bx
 23180 00003C9C 26895D19                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],BX
 23181                                  	;mov	[es:di+35h],bx ; 04/05/2019
 23182 00003CA0 26895D35                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],BX
 23183                                  	;xchg	bx,[es:di+0Bh]
 23184 00003CA4 26875D0B                	XCHG    BX,[ES:DI+SF_ENTRY.sf_firclus]
 23185 00003CA8 07                      	POP	ES
 23186                                  
 23187 00003CA9 09DB                    	OR	BX,BX
 23188                                  	;JZ	short UPDATEJ
 23189                                  	; 16/12/2022
 23190 00003CAB 74A5                    	jz	short UPDATE
 23191                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23192                                  	;jz	short UPDATEJ
 23193                                  
 23194                                  ;; 10/23/86 FastOpen update
 23195 00003CAD 06                      	PUSH	ES              ; since first cluster # is 0
 23196 00003CAE 55                      	PUSH	BP              ; we must delete the old cache entry
 23197 00003CAF 50                      	PUSH	AX
 23198 00003CB0 51                      	PUSH	CX
 23199 00003CB1 52                      	PUSH	DX
 23200 00003CB2 C42E[8A05]              	LES	BP,[THISDPB]             ; get current DPB
 23201                                  	; 15/12/2022
 23202 00003CB6 268A5600                	mov	dl,[ES:BP] ; mov dl,[es:bp+0]
 23203                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23204                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; get current drive
 23205 00003CBA 89D9                    	MOV	CX,BX                    ; first cluster #
 23206 00003CBC B402                    	MOV	AH,2                     ; delete cache entry by drive:firclus
 23207 00003CBE E840EA                  	call	FastOpen_Update          ; call fastopen
 23208 00003CC1 5A                      	POP	DX
 23209 00003CC2 59                      	POP	CX
 23210 00003CC3 58                      	POP	AX
 23211 00003CC4 5D                      	POP	BP
 23212 00003CC5 07                      	POP	ES
 23213                                  ;; 10/23/86 FastOpen update
 23214                                  
 23215 00003CC6 E8FE11                  	call	RELEASE
 23216 00003CC9 72C7                    	JC	short SET_ACC_ERRWJ
 23217                                  UPDATEJ:
 23218                                  	; 20/11/2022
 23219 00003CCB EB85                    	JMP	short UPDATE ; 10/08/2018
 23220                                  
 23221                                  ;Break   <DskWrtBufPurge -- Disk Write Buffer Purge>
 23222                                  ;----------------------------------------------------------------------------
 23223                                  ;
 23224                                  ; Procedure Name : DskWrtBufPurge
 23225                                  ;
 23226                                  ; Inputs:
 23227                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 23228                                  ;	     sectors, also termed an "Extent".)
 23229                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 23230                                  ;       ES:BP -> Drive Parameter Block (DPB).
 23231                                  ;
 23232                                  ; Function:
 23233                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 23234                                  ;	are in Extent; they are being over-written.
 23235                                  ;
 23236                                  ; Outputs:
 23237                                  ;       (Same as Input.)
 23238                                  ; Uses:
 23239                                  ;       All registers except DS,AX,SI,DI preserved.
 23240                                  ;       SS override for all global variables.
 23241                                  ;----------------------------------------------------------------------------
 23242                                  ;M039: Created
 23243                                  
 23244                                  ;procedure   DskWrtBufPurge,NEAR
 23245                                  ;
 23246                                  ;ASSUME  DS:NOTHING
 23247                                  
 23248                                  ; 04/05/2019 - Retro DOS v4.0
 23249                                  ; DOSCODE:7C0Eh (MSDOS 6.21, MSDOS.SYS)
 23250                                  
 23251                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23252                                  ; DOSCODE:7BD4h (MSDOS 5.0, MSDOS.SYS) 
 23253                                  
 23254                                  DskWrtBufPurge:
 23255                                  	;SaveReg <bx,cx>
 23256 00003CCD 53                      	push	bx
 23257 00003CCE 51                      	push	cx
 23258                                  
 23259 00003CCF 368B1E[0706]            	mov	bx,[ss:HIGH_SECTOR]	;BX:DX = Extent start (sector #).
 23260 00003CD4 89DE                    	mov	si,bx
 23261 00003CD6 01D1                    	add	cx,dx
 23262 00003CD8 83D600                  	adc	si,0                    ;SI:CX = Extent end + 1.
 23263                                  
 23264                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23265                                  	;;mov	al,[es:bp+0]
 23266                                  	;mov	al,[es:bp+DPB.DRIVE]
 23267                                  	; 15/12/2022
 23268 00003CDB 268A4600                	mov	al,[es:bp]
 23269                                  
 23270                                  ;	BX:DX = Extent start.
 23271                                  ;	SI:CX = Extent end + 1.
 23272                                  ;	AL = Drive #
 23273                                  
 23274 00003CDF 36833E[7700]00          	cmp	word [ss:SC_CACHE_COUNT],0 ;Secondary cache in-use?
 23275 00003CE5 7431                    	je	short nosc		; -no, jump.
 23276                                  
 23277                                  ;	If any of the sectors to be written are in the secondary cache (SC),
 23278                                  ;	invalidate the entire SC. (This is an optimization; we really only
 23279                                  ;	need to invalidate those sectors which intersect, but that's slower.)
 23280                                  
 23281 00003CE7 363A06[B00D]            	cmp	al,[ss:CurSC_DRIVE]	;Same drive?
 23282 00003CEC 752A                    	jne	short nosc		; -no, jump.
 23283                                  
 23284 00003CEE 50                      	push    ax
 23285 00003CEF 36A1[B10D]              	mov     ax,[ss:CurSC_SECTOR]
 23286 00003CF3 368B3E[B30D]            	mov     di,[ss:CurSC_SECTOR+2]	;DI:AX = SC start.
 23287                                  
 23288                                  	;Cmp32	si,cx,di,ax		;Extent end < SC start?
 23289                                  	;jbe	short sc5		; -yes, jump.
 23290                                  
 23291 00003CF8 39FE                    	cmp	si,di
 23292 00003CFA 7502                    	jne	short sc01
 23293 00003CFC 39C1                    	cmp	cx,ax
 23294                                  sc01: 
 23295 00003CFE 7617                    	jbe	short sc5	
 23296                                  
 23297 00003D00 360306[7700]            	add	ax,[ss:SC_CACHE_COUNT]
 23298 00003D05 83D700                  	adc	di,0                    ;DI:AX = SC end + 1.
 23299                                  	
 23300                                  	;Cmp32	bx,dx,di,ax             ;Extent start > SC end?
 23301                                  	;jae	short sc5		; -yes, jump.
 23302                                  
 23303 00003D08 39FB                    	cmp	bx,di
 23304 00003D0A 7502                    	jne	short sc02
 23305 00003D0C 39C2                    	cmp	dx,ax
 23306                                  sc02:
 23307 00003D0E 7307                    	jnb	short sc5
 23308                                  
 23309 00003D10 36C706[B50D]0000        	mov	word [ss:SC_STATUS],0	;Extent intersects SC: invalidate SC.
 23310                                  sc5:	
 23311 00003D17 58                      	pop     ax
 23312                                  
 23313                                  ;	Free any buffered sectors which are in Extent; they are being over-
 23314                                  ;	written.
 23315                                  
 23316                                  nosc:	
 23317 00003D18 E8C31B                  	call	GETCURHEAD		;DS:DI -> first buffer in queue.
 23318                                  
 23319                                  _bufq:	
 23320                                  	;cmpo	al,[di+4]
 23321 00003D1B 3A4504                  	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
 23322 00003D1E 7527                    	jne	short bufq5		; -no, jump.
 23323                                  
 23324                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 23325                                  ;       ja	short bufq5		;Jump if Extent start > buffer sector.
 23326                                  
 23327                                  	;cmp	bx,[di+8]
 23328 00003D20 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 23329 00003D23 7503                    	jne	short bufq04
 23330                                  	;cmp	dx,[di+6]
 23331 00003D25 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 23332                                  bufq04:
 23333 00003D28 771D                    	ja	short bufq5
 23334                                  
 23335                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 23336                                  ;       jbe	short bufq5		;Jump if Extent end < buffer sector.
 23337                                  
 23338                                  	;cmp	si,[di+8]
 23339 00003D2A 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 23340 00003D2D 7503                    	jne	short bufq05
 23341                                  	;cmp	cx,[di+6]
 23342 00003D2F 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 23343                                  bufq05:
 23344 00003D32 7613                    	jbe	short bufq5
 23345                                  
 23346                                  ;	Buffer's sector is in Extent, so free it; it is being over-written.
 23347                                  
 23348                                  	;test	byte [di+5],40h
 23349 00003D34 F6450540                	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
 23350 00003D38 7403                    	jz	short bufq4		; -no, jump.
 23351 00003D3A E8221E                  	call	DEC_DIRTY_COUNT		; -yes, decrement dirty count.
 23352                                  bufq4:
 23353                                  	;mov	word [di+4],20FFh
 23354 00003D3D C74504FF20              	mov     word [di+BUFFINFO.buf_ID],((buf_visit<<8)|0FFh)
 23355                                  
 23356 00003D42 E8AB1B                  	call	SCANPLACE
 23357 00003D45 EB02                    	jmp     short bufq6
 23358                                  bufq5: 
 23359 00003D47 8B3D                    	mov     di,[di]
 23360                                  	;mov	di,[di+BUFFINFO.buf_next]
 23361                                  bufq6: 
 23362 00003D49 363B3E[BB0E]            	cmp	di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
 23363 00003D4E 75CB                    	jne	short _bufq		; --no, go do next buffer.
 23364                                  	
 23365                                  	;RestoreReg <cx,bx>
 23366 00003D50 59                      	pop	cx
 23367 00003D51 5B                      	pop	bx
 23368 00003D52 C3                      	retn
 23369                                  
 23370                                  ;EndProc DskWrtBufPurge
 23371                                  
 23372                                  ;Break   <DIV32 -- PERFORM 32 BIT DIVIDE>
 23373                                  ;----------------------------------------------------------------------------
 23374                                  ;
 23375                                  ; Procedure Name : DIV32
 23376                                  ;
 23377                                  ; Inputs:
 23378                                  ;       DX:AX = 32 bit dividend   BX= divisor
 23379                                  ; Function:
 23380                                  ;       Perform 32 bit division:  DX:AX/BX = CX:AX + DX (rem.)
 23381                                  ; Outputs:
 23382                                  ;       CX:AX = quotient , DX= remainder
 23383                                  ; Uses:
 23384                                  ;       All registers except AX,CX,DX preserved.
 23385                                  ;----------------------------------------------------------------------------
 23386                                  ;M039: DIV32 optimized for divisor of 512 (common sector size).
 23387                                  
 23388                                  ; 04/05/2019 - Retro DOS v4.0
 23389                                  ; DOSCODE:7C94h (MSDOS 6.21, MSDOS.SYS)
 23390                                  
 23391                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23392                                  ; DOSCODE:7C5Ah (MSDOS 5.0, MSDOS.SYS) 
 23393                                  
 23394                                  DIV32:
 23395 00003D53 81FB0002                	cmp	bx,512
 23396 00003D57 7515                    	jne	short div5
 23397                                  
 23398 00003D59 89D1                    	mov	cx,dx
 23399 00003D5B 89C2                    	mov	dx,ax           ; CX:AX = Dividend
 23400 00003D5D 81E2FF01                	and	dx,(512-1)      ; DX = Remainder
 23401 00003D61 88E0                    	mov	al,ah
 23402 00003D63 88CC                    	mov	ah,cl
 23403 00003D65 88E9                    	mov	cl,ch
 23404 00003D67 30ED                    	xor	ch,ch
 23405 00003D69 D1E9                    	shr	cx,1
 23406 00003D6B D1D8                    	rcr	ax,1
 23407 00003D6D C3                      	retn
 23408                                  div5:	
 23409 00003D6E 89C1                    	mov	cx,ax
 23410 00003D70 89D0                    	mov	ax,dx
 23411 00003D72 31D2                    	xor	dx,dx
 23412 00003D74 F7F3                    	div	bx              ; 0:AX/BX
 23413 00003D76 91                      	xchg	cx,ax
 23414 00003D77 F7F3                    	div	bx              ; DX:AX/BX
 23415 00003D79 C3                      	retn
 23416                                  
 23417                                  ;Break   <SHR32 -- PERFORM 32 BIT SHIFT RIGHT>
 23418                                  ;----------------------------------------------------------------------------
 23419                                  ;
 23420                                  ; Procedure Name : SHR32
 23421                                  ;
 23422                                  ; Inputs:
 23423                                  ;	DX:AX = 32 bit sector number
 23424                                  ; Function:
 23425                                  ;       Perform 32 bit shift right
 23426                                  ; Outputs:
 23427                                  ;	AX = cluster number
 23428                                  ;	ZF = 1 if no error
 23429                                  ;	   = 0 if error (cluster number > 64k)
 23430                                  ; Uses:
 23431                                  ;       DX,CX
 23432                                  ;---------------------------------------------------------------------------
 23433                                  ; M017	- SHR32 rewritten for better performance
 23434                                  ; M039	- Additional optimization
 23435                                  
 23436                                  ; 04/05/2019 - Retro DOS v4.0
 23437                                  ; DOSCODE:7CBBh (MSDOS 6.21, MSDOS.SYS)
 23438                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23439                                  ; DOSCODE:7C81h (MSDOS 5.0, MSDOS.SYS) 
 23440                                  
 23441                                  SHR32:
 23442                                  	;mov	cl,[es:bp+5]
 23443 00003D7A 268A4E05                	mov	cl,[ES:BP+DPB.CLUSTER_SHIFT]
 23444 00003D7E 30ED                    	xor	ch,ch	    ;ZF=1
 23445 00003D80 E306                    	jcxz	norota
 23446                                  
 23447                                  rotashft2:
 23448 00003D82 D1EA                    	shr	dx,1	    ;ZF reflects state of DX.
 23449 00003D84 D1D8                    	rcr	ax,1	    ;ZF not affected.
 23450 00003D86 E2FA                    	loop	rotashft2
 23451                                  norota:
 23452 00003D88 C3                      	retn
 23453                                  
 23454                                  ;============================================================================
 23455                                  ; DIR.ASM, MSDOS 6.0, 1991
 23456                                  ;============================================================================
 23457                                  ; 27/07/2018 - Retro DOS v3.0
 23458                                  ; 19/05/2019 - Retro DOS v4.0 
 23459                                  
 23460                                  ;	TITLE	DIR - Directory and path cracking
 23461                                  ;	NAME	Dir
 23462                                  
 23463                                  ;Break	<FINDENTRY -- LOOK FOR AN ENTRY>
 23464                                  ;---------------------------------------------------------------------------
 23465                                  ;
 23466                                  ; Procedure Name : FINDENTRY,SEARCH
 23467                                  ;
 23468                                  ; Inputs:
 23469                                  ;	[THISDPB] set
 23470                                  ;	[SECCLUSPOS] = 0
 23471                                  ;	[DIRSEC] = Starting directory sector number
 23472                                  ;	[CLUSNUM] = Next cluster of directory
 23473                                  ;	[CLUSFAC] = Sectors/Cluster
 23474                                  ;	[NAME1] = Name to look for
 23475                                  ; Function:
 23476                                  ;	Find file name in disk directory.
 23477                                  ;	"?" matches any character.
 23478                                  ; Outputs:
 23479                                  ;	Carry set if name not found
 23480                                  ;	ELSE
 23481                                  ;	Zero set if attributes match (always except when creating)
 23482                                  ;	AH = Device ID (bit 7 set if not disk)
 23483                                  ;	[THISDPB] = Base of drive parameters
 23484                                  ;	DS = DOSGROUP
 23485                                  ;	ES = DOSGROUP
 23486                                  ;	[CURBUF+2]:BX = Pointer into directory buffer
 23487                                  ;	[CURBUF+2]:SI = Pointer to First Cluster field in directory entry
 23488                                  ;	[CURBUF] has directory record with match
 23489                                  ;	[NAME1] has file name
 23490                                  ;	[LASTENT] is entry number of the entry
 23491                                  ; All other registers destroyed.
 23492                                  ;----------------------------------------------------------------------------
 23493                                  
 23494                                  ;hkn; called from rename.asm and dir2.asm. DS must be already set up at
 23495                                  ;hkn; this point.
 23496                                  
 23497                                  SEARCH:
 23498                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23499                                  	; DOSCODE:7C90h (MSDOS 5.0, MSDOS.SYS) 
 23500                                  
 23501                                  	; 19/05/2019 - Retro DOS v4.0
 23502                                  	; DOSCODE:7CCA (MSDOS 6.21, MSDOS.SYS)
 23503                                  
 23504                                  	; 27/07/2018 - Retro DOS v3.0
 23505                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 45B3h 
 23506                                  	; 15/03/2018 - Retro DOS v2.0
 23507                                  
 23508                                  	;entry	FindEntry
 23509                                  FINDENTRY:
 23510 00003D89 E82E04                  	call	STARTSRCH
 23511 00003D8C A0[6B05]                	MOV	AL,[ATTRIB]
 23512                                  	;and	al,9Eh
 23513 00003D8F 24DE                    	AND	AL,~attr_ignore		; Ignore useless bits
 23514                                  	;cmp	al,8
 23515 00003D91 3C08                    	CMP	AL,attr_volume_id	; Looking for vol ID only ?
 23516 00003D93 7503                    	JNZ	short NOTVOLSRCH	; No
 23517 00003D95 E86D01                  	CALL	SETROOTSRCH		; Yes force search of root
 23518                                  NOTVOLSRCH:
 23519 00003D98 E8FD00                  	CALL	GETENTRY
 23520 00003D9B 7303                    	JNC	short SRCH
 23521 00003D9D E99100                  	JMP	SETESRET
 23522                                  
 23523                                  	;entry	Srch
 23524                                  SRCH:
 23525 00003DA0 1E                      	PUSH	DS
 23526 00003DA1 8E1E[E405]              	MOV	DS,[CURBUF+2]
 23527                                  
 23528                                  ;	(DS:BX) = directory entry address
 23529                                  
 23530 00003DA5 8A27                    	mov	ah,[BX]
 23531                                  	;MOV	AH,[BX+dir_entry.dir_name] ; mov ah,[bx+0]
 23532 00003DA7 08E4                    	OR	AH,AH			; End of directory?
 23533 00003DA9 7436                    	JZ	short FREE
 23534                                  
 23535                                  ;hkn; SS override
 23536 00003DAB 363A26[7F05]            	CMP	AH,[SS:DELALL]		; Free entry?
 23537 00003DB0 742F                    	JZ	short FREE
 23538                                  	;test	byte [bx+0Bh],8
 23539 00003DB2 F6470B08                	TEST	byte [BX+dir_entry.dir_attr],attr_volume_id
 23540                                  					; Volume ID file?
 23541 00003DB6 7405                    	JZ	short CHKFNAM 		; NO
 23542                                  
 23543                                  ;hkn; SS override
 23544 00003DB8 36FE06[7B05]            	INC	BYTE [SS:VOLID]
 23545                                  CHKFNAM:
 23546                                  ;	Context ES
 23547 00003DBD 8CD6                    	MOV	SI,SS
 23548 00003DBF 8EC6                    	MOV	ES,SI
 23549 00003DC1 89DE                    	MOV	SI,BX
 23550                                  
 23551                                  ;hkn; NAME1 is in DOSDATA
 23552 00003DC3 BF[4B05]                	MOV	DI,NAME1
 23553                                  ;;;;; 7/29/86
 23554                                  
 23555                                  ;hkn; SS override for NAME1
 23556                                  	;CMP	BYTE [SS:NAME1],0E5H	; special char check
 23557                                  	;JNZ	short NO_E5
 23558                                  	;MOV	BYTE [SS:NAME1],05H
 23559                                  	; 22/09/2023
 23560 00003DC6 26803DE5                	cmp	byte [es:di],0E5h
 23561 00003DCA 7504                    	jnz	short NO_E5
 23562 00003DCC 26C60505                	mov	byte [es:di],05h
 23563                                  NO_E5:
 23564                                  ;;;;; 7/29/86
 23565 00003DD0 E86100                  	CALL	MetaCompare
 23566 00003DD3 7428                    	JZ	short FOUND
 23567 00003DD5 1F                      	POP	DS
 23568                                  
 23569                                  	;entry	NEXTENT
 23570                                  NEXTENT:
 23571 00003DD6 C42E[8A05]              	LES	BP,[THISDPB]
 23572 00003DDA E86600                  	CALL	NEXTENTRY
 23573 00003DDD 73C1                    	JNC	short SRCH
 23574 00003DDF EB50                    	JMP	SHORT SETESRET
 23575                                  
 23576                                  FREE:
 23577 00003DE1 1F                      	POP	DS
 23578 00003DE2 8B0E[4803]              	MOV	CX,[LASTENT]
 23579 00003DE6 3B0E[D805]              	CMP	CX,[ENTFREE]
 23580 00003DEA 7304                    	JAE	short TSTALL
 23581 00003DEC 890E[D805]              	MOV	[ENTFREE],CX
 23582                                  TSTALL:
 23583 00003DF0 3A26[7F05]              	CMP	AH,[DELALL]		; At end of directory?
 23584                                  NEXTENTJ:
 23585 00003DF4 74E0                    	je	short NEXTENT 		; No - continue search
 23586 00003DF6 890E[DA05]              	MOV	[ENTLAST],CX
 23587 00003DFA F9                      	STC
 23588 00003DFB EB34                    	JMP	SHORT SETESRET
 23589                                  
 23590                                  FOUND:
 23591                                  ; We have a file with a matching name. We must now consider the attributes:
 23592                                  ; ATTRIB	Action
 23593                                  ; ------	------
 23594                                  ; Volume_ID	Is Volume_ID in test?
 23595                                  ; Otherwise	If no create then Is ATTRIB+extra superset of test?
 23596                                  ;		If create then Is ATTRIB equal to test?
 23597                                  
 23598 00003DFD 8A2C                    	MOV	CH,[SI] 		; Attributes of file
 23599 00003DFF 1F                      	POP	DS
 23600 00003E00 8A26[6B05]              	MOV	AH,[ATTRIB]		; Attributes of search
 23601                                  	;and	ah,9Eh
 23602 00003E04 80E4DE                  	AND	AH,~attr_ignore
 23603                                  	;lea	si,[si+15]
 23604 00003E07 8D740F                  	LEA	SI,[SI+dir_entry.dir_first-dir_entry.dir_attr]
 23605                                  					; point to first cluster field
 23606                                  	;test	ch,8
 23607 00003E0A F6C508                  	TEST	CH,attr_volume_id	; Volume ID file?
 23608 00003E0D 7409                    	JZ	short check_one_volume_id ; Nope check other attributes
 23609                                  	;test	ah,8
 23610 00003E0F F6C408                  	TEST	AH,attr_volume_id	; Can we find Volume ID?
 23611                                  	;JZ	short NEXTENTJ		; Nope, (not even $FCB_CREATE)
 23612                                  	; 16/12/2022
 23613 00003E12 74C2                    	jz	short NEXTENT ; 19/05/2019
 23614                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23615                                  	;JZ	short NEXTENTJ
 23616 00003E14 30E4                    	XOR	AH,AH			; Set zero flag for $FCB_CREATE
 23617 00003E16 EB11                    	JMP	SHORT RETFF		; Found Volume ID
 23618                                  check_one_volume_id:
 23619                                  	;CMP	ah,8
 23620 00003E18 80FC08                  	CMP	AH,attr_volume_id	; Looking only for Volume ID?
 23621                                  	;JZ	short NEXTENTJ		; Yes, continue search
 23622                                  	; 16/12/2022
 23623 00003E1B 74B9                    	je	short NEXTENT ; 19/05/2019
 23624                                  	;JZ	short NEXTENTJ
 23625 00003E1D E8AE03                  	CALL	MatchAttributes
 23626 00003E20 7407                    	JZ	SHORT RETFF
 23627 00003E22 F606[7E05]FF            	TEST	BYTE [CREATING],-1	; Pass back mismatch if creating
 23628                                  	; 16/12/2022
 23629                                  	;JZ	short NEXTENTJ		; Otherwise continue searching
 23630 00003E27 74AD                    	jz	short NEXTENT ; 19/05/2019
 23631                                  RETFF:
 23632 00003E29 C42E[8A05]              	LES	BP,[THISDPB]
 23633                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23634                                  	;MOV	AH,[ES:BP+DPB.DRIVE]  ; mov ah,[es:bp+0]
 23635                                  	; 15/12/2022
 23636 00003E2D 268A6600                	MOV	AH,[ES:BP]
 23637                                  SETESRET:
 23638 00003E31 16                      	PUSH	SS
 23639 00003E32 07                      	POP	ES
 23640 00003E33 C3                      	retn
 23641                                  
 23642                                  ;----------------------------------------------------------------------------
 23643                                  ;
 23644                                  ; Procedure Name : MetaCompare
 23645                                  ;
 23646                                  ; Inputs:
 23647                                  ;	DS:SI -> 11 character FCB style name NO '?'
 23648                                  ;	    Typically this is a directory entry. It MUST be in upper case
 23649                                  ;	ES:DI -> 11 character FCB style name with possible '?'
 23650                                  ;	    Typically this is a FCB or SFT. It MUST be in upper case
 23651                                  ; Function:
 23652                                  ;	Compare FCB style names allowing for ? match to any char
 23653                                  ; Outputs:
 23654                                  ;	Zero if match else NZ
 23655                                  ; Destroys CX,SI,DI all others preserved
 23656                                  ;----------------------------------------------------------------------------
 23657                                  
 23658                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23659                                  	; DOSCODE:7D3Fh (MSDOS 5.0, MSDOS.SYS) 
 23660                                  
 23661                                  MetaCompare:
 23662 00003E34 B90B00                  	MOV	CX,11
 23663                                  WILDCRD:
 23664 00003E37 F3A6                    	REPE	CMPSB
 23665 00003E39 7407                    	JZ	short MetaRet 		; most of the time we will fail.
 23666                                  CHECK_META:
 23667 00003E3B 26807DFF3F              	CMP	BYTE [ES:DI-1],"?"
 23668 00003E40 74F5                    	JZ	short WILDCRD
 23669                                  MetaRet:
 23670 00003E42 C3                       	retn				; Zero set, Match
 23671                                  
 23672                                  ;Break	<NEXTENTRY -- STEP THROUGH DIRECTORY>
 23673                                  ;----------------------------------------------------------------------------
 23674                                  ;
 23675                                  ; Procedure Name : NEXTENTRY
 23676                                  ;
 23677                                  ; Inputs:
 23678                                  ;	Same as outputs of GETENTRY, above
 23679                                  ; Function:
 23680                                  ;	Update BX, and [LASTENT] for next directory entry.
 23681                                  ;	Carry set if no more.
 23682                                  ;----------------------------------------------------------------------------
 23683                                  
 23684                                  NEXTENTRY:
 23685                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23686                                  	; DOSCODE:7D4Eh (MSDOS 5.0, MSDOS.SYS) 
 23687                                  
 23688                                  	; 19/05/2019 - Retro DOS v4.0
 23689                                  	; DOSCODE:7D88h (MSDOS 6.21, MSDOS.SYS)
 23690                                  
 23691                                  	; 27/07/2018 - Retro DOS v3.0
 23692                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 4671h 
 23693                                  	; 15/03/2018 - Retro DOS v2.0
 23694                                  
 23695 00003E43 A1[4803]                	MOV	AX,[LASTENT]
 23696 00003E46 3B06[DA05]              	CMP	AX,[ENTLAST]
 23697 00003E4A 7422                    	JZ	short NONE
 23698 00003E4C 40                      	INC	AX
 23699                                  	;ADD	BX,32
 23700 00003E4D 8D5F20                  	LEA	BX,[BX+32]
 23701 00003E50 39D3                    	CMP	BX,DX
 23702                                  	; 21/11/2022 - MSDOS 5.0 MSDOS.SYS (DOSCODE:7D5Dh)
 23703                                  	;JB	short HAVIT ; MSDOS 6.0 src (dir.asm)
 23704                                  	; 16/12/2022
 23705 00003E52 751C                    	jne	short HAVIT ; MSDOS 6.21 (DOSCODE:7D97h)
 23706 00003E54 8A1E[7305]              	MOV	BL,[SECCLUSPOS]
 23707 00003E58 FEC3                    	INC	BL
 23708 00003E5A 3A1E[7705]              	CMP	BL,[CLUSFAC]
 23709 00003E5E 7215                    	JB	short SAMECLUS
 23710 00003E60 8B1E[DC05]              	MOV	BX,[NXTCLUSNUM]
 23711 00003E64 E8C716                  	call	IsEOF
 23712 00003E67 7305                    	JAE	short NONE
 23713                                  	; 23/07/2019
 23714 00003E69 83FB02                  	CMP	BX,2
 23715                                  	;JB	short NONE
 23716                                  	;JMP	short GETENT
 23717                                  	; 16/12/2022
 23718 00003E6C 732D                    	jnb	short GETENT
 23719                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23720                                  	;JB	short NONE
 23721                                  	;JMP	short GETENT
 23722                                  NONE:
 23723 00003E6E F9                      	STC
 23724 00003E6F C3                      	retn
 23725                                  HAVIT:
 23726 00003E70 A3[4803]                	MOV	[LASTENT],AX
 23727 00003E73 F8                      	CLC
 23728                                  nextentry_retn:
 23729 00003E74 C3                      	retn
 23730                                  SAMECLUS:
 23731 00003E75 881E[7305]              	MOV	[SECCLUSPOS],BL
 23732 00003E79 A3[4803]                	MOV	[LASTENT],AX
 23733 00003E7C 1E                      	PUSH	DS
 23734 00003E7D C53E[E205]              	LDS	DI,[CURBUF]
 23735                                  	; 19/05/2019
 23736                                  	; MSDOS 6.0
 23737                                  	;;mov	dx,[di+8]
 23738                                  	; 23/09/2023
 23739                                  	;MOV	DX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 23740                                  ;hkn; SS override
 23741                                  	;MOV	[SS:HIGH_SECTOR],DX 		;AN000; >32mb
 23742                                  	; 23/09/2023
 23743 00003E81 8B7508                  	mov	si,[di+BUFFINFO.buf_sector+2]	
 23744                                  	
 23745                                  	;mov	dx,[di+6]
 23746 00003E84 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector]	;AN000; >32mb
 23747                                  	;inc	dx ; MSDOS 3.3
 23748                                  	; MSDOS 6.0
 23749                                  	;ADD	DX,1				;AN000; >32mb
 23750                                  	;ADC	word [SS:HIGH_SECTOR],0 	;AN000; >32mb
 23751                                  	; 23/09/2023
 23752 00003E87 42                      	inc	dx
 23753 00003E88 7501                    	jnz	short nextexntry_fc
 23754 00003E8A 46                      	inc	si
 23755                                  	;inc	word [SS:HIGH_SECTOR]
 23756                                  nextexntry_fc:
 23757                                  	; 23/09/2023
 23758 00003E8B 368936[0706]            	mov	[SS:HIGH_SECTOR],si
 23759                                  	; MSDOS 3.3 & MSDOS 6.0
 23760 00003E90 1F                      	POP	DS
 23761 00003E91 E844F8                  	call	FIRSTCLUSTER
 23762 00003E94 31DB                    	XOR	BX,BX
 23763 00003E96 EB23                    	JMP	short SETENTRY
 23764                                  
 23765                                  ;----------------------------------------------------------------------------
 23766                                  ;
 23767                                  ; Procedure Name : GETENTRY
 23768                                  ;
 23769                                  ; Inputs:
 23770                                  ;	[LASTENT] has directory entry
 23771                                  ;	ES:BP points to drive parameters
 23772                                  ;	[DIRSEC],[CLUSNUM],[CLUSFAC],[ENTLAST] set for DIR involved
 23773                                  ; Function:
 23774                                  ;	Locates directory entry in preparation for search
 23775                                  ;	GETENT provides entry for passing desired entry in AX
 23776                                  ; Outputs:
 23777                                  ;	[CURBUF+2]:BX = Pointer to next directory entry in CURBUF
 23778                                  ;	[CURBUF+2]:DX = Pointer to first byte after end of CURBUF
 23779                                  ;	[LASTENT] = New directory entry number
 23780                                  ;	[NXTCLUSNUM],[SECCLUSPOS] set via DIRREAD
 23781                                  ;	Carry set if error (currently user FAILed to I 24)
 23782                                  ;----------------------------------------------------------------------------
 23783                                  
 23784                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23785                                  GETENTRY:
 23786                                  	; 27/07/2018 - Retro DOS v3.0
 23787 00003E98 A1[4803]                	MOV	AX,[LASTENT]
 23788                                  
 23789                                  	;entry	GETENT
 23790                                  GETENT:
 23791 00003E9B A3[4803]                	MOV	[LASTENT],AX
 23792                                  ;
 23793                                  ; Convert the entry number in AX into a byte offset from the beginning of the
 23794                                  ; directory.
 23795                                  ;
 23796 00003E9E B105                    	mov	cl,5			; shift left by 5 = mult by 32
 23797 00003EA0 D3C0                    	rol	ax,cl			; keep hight order bits
 23798 00003EA2 89C2                    	mov	dx,ax
 23799                                  	; 19/05/2019 - Retro DOS v4.0
 23800                                  	;and	ax,0FFE0h
 23801                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23802                                  	;and	ax,~(32-1)		; mask off high order bits
 23803                                  	; 16/12/2022
 23804 00003EA4 24E0                    	and	al,0E0h ; ~31
 23805 00003EA6 83E21F                  	and	dx,1Fh
 23806                                  	;and	dx,32-1			; mask off low order bits
 23807                                  ;
 23808                                  ; DX:AX contain the byte offset of the required directory entry from the
 23809                                  ; beginning of the directory. Convert this to a sector number. Round the
 23810                                  ; sector size down to a multiple of 32.
 23811                                  ;
 23812                                  	;mov	bx,[es:bp+2]
 23813 00003EA9 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 23814 00003EAD 80E3E0                  	and	bl,0E0h
 23815                                  	;AND	BL,255-31		; Must be multiple of 32
 23816 00003EB0 F7F3                    	DIV	BX
 23817 00003EB2 89D3                    	MOV	BX,DX			; Position within sector
 23818 00003EB4 53                      	PUSH	BX
 23819 00003EB5 E8CCF7                  	call	DIRREAD
 23820 00003EB8 5B                      	POP	BX
 23821                                  	;retc
 23822 00003EB9 72B9                    	jc	short nextentry_retn	
 23823                                  SETENTRY:
 23824 00003EBB 8B16[E205]              	MOV	DX,[CURBUF]
 23825                                  	;add	dx,16 ; MSDOS 3.3
 23826                                  	;add	dx,20 ; MSDOS 6.0 
 23827 00003EBF 83C214                  	ADD	DX,BUFINSIZ
 23828 00003EC2 01D3                    	ADD	BX,DX
 23829                                  	;add	dx,[es:bp+2]
 23830 00003EC4 26035602                	ADD	DX,[ES:BP+DPB.SECTOR_SIZE]  ; Always clears carry
 23831                                  	; 29/12/2022
 23832                                  	; MSDOS 6.21 MSDOS.SYS contains a 'CLC' here, at DOSCODE:7E15h
 23833 00003EC8 F8                      	clc
 23834 00003EC9 C3                      	retn
 23835                                  
 23836                                  ;Break	<SETDIRSRCH SETROOTSRCH -- Set Search environments>
 23837                                  ;----------------------------------------------------------------------------
 23838                                  ;
 23839                                  ; Procedure Name : SETDIRSRCH,SETROOTSRCH
 23840                                  ;
 23841                                  ; Inputs:
 23842                                  ;	BX cluster number of start of directory
 23843                                  ;	ES:BP Points to DPB
 23844                                  ;	DI next cluster number from fastopen extended info. DOS 3.3 only
 23845                                  ; Function:
 23846                                  ;	Set up a directory search
 23847                                  ; Outputs:
 23848                                  ;	[DIRSTART] = BX
 23849                                  ;	[CLUSFAC],[CLUSNUM],[SECCLUSPOS],[DIRSEC] set
 23850                                  ;	Carry set if error (currently user FAILed to I 24)
 23851                                  ; destroys AX,DX,BX
 23852                                  ;----------------------------------------------------------------------------
 23853                                  
 23854                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23855                                  SETDIRSRCH:
 23856 00003ECA 09DB                    	OR	BX,BX
 23857 00003ECC 7437                    	JZ	short SETROOTSRCH
 23858 00003ECE 891E[C205]              	MOV	[DIRSTART],BX
 23859                                  	;mov	al,[es:bp+4]
 23860 00003ED2 268A4604                	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 23861 00003ED6 FEC0                    	INC	AL
 23862 00003ED8 A2[7705]                	MOV	[CLUSFAC],AL
 23863                                  
 23864                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 23865                                  	;SAVE	<SI>
 23866 00003EDB 56                      	push	si
 23867                                  	;test	byte [FastOpenFlg],2
 23868 00003EDC F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success
 23869 00003EE1 7507                    	JNZ	short UNP_OK
 23870                                  
 23871                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 23872                                  	;invoke	UNPACK
 23873 00003EE3 E85F16                  	call	UNPACK
 23874 00003EE6 7302                    	JNC	short UNP_OK
 23875                                  	;RESTORE <SI>
 23876 00003EE8 5E                      	pop	si
 23877                                  	;return
 23878 00003EE9 C3                      	retn
 23879                                  
 23880                                  UNP_OK:
 23881 00003EEA 893E[BC05]              	MOV	[CLUSNUM],DI
 23882 00003EEE 89DA                    	MOV	DX,BX
 23883 00003EF0 30DB                    	XOR	BL,BL
 23884 00003EF2 881E[7305]              	MOV	[SECCLUSPOS],BL
 23885                                  	;invoke	FIGREC
 23886 00003EF6 E8F50E                  	call	FIGREC
 23887                                  	;RESTORE <SI>
 23888 00003EF9 5E                      	pop	si
 23889                                  	
 23890                                  	; 19/05/2019 - Retro DOS v4.0
 23891                                  
 23892                                  	; MSDOS 6.0
 23893                                  	;PUSH	DX			   ;AN000; >32mb
 23894                                  	;MOV	DX,[HIGH_SECTOR]	   ;AN000; >32mb
 23895                                  	;MOV	[DIRSEC+2],DX		   ;AN000; >32mb
 23896                                  	;POP	DX			   ;AN000; >32mb
 23897                                  
 23898                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23899                                  	;push	dx
 23900                                  	;mov	dx,[HIGH_SECTOR]
 23901                                  	;mov	[DIRSEC+2],dx
 23902                                  	;pop	dx
 23903                                  	;MOV	[DIRSEC],dx
 23904                                  	; 16/12/2022
 23905 00003EFA A1[0706]                	mov	ax,[HIGH_SECTOR]
 23906 00003EFD A3[C005]                	mov	[DIRSEC+2],AX
 23907 00003F00 8916[BE05]              	MOV	[DIRSEC],DX
 23908                                  
 23909                                  	; 16/12/2022
 23910                                  	; cf=0 (at the return of FIGREC)
 23911                                  	;CLC
 23912 00003F04 C3                      	retn
 23913                                  
 23914                                  	;entry	SETROOTSRCH
 23915                                  SETROOTSRCH:
 23916 00003F05 31C0                    	XOR	AX,AX
 23917 00003F07 A3[C205]                	MOV	[DIRSTART],AX
 23918                                  	; 22/09/2023
 23919 00003F0A A3[C005]                	mov	[DIRSEC+2],ax ; 0
 23920 00003F0D A2[7305]                	MOV	[SECCLUSPOS],AL
 23921 00003F10 48                      	DEC	AX
 23922 00003F11 A3[BC05]                	MOV	[CLUSNUM],AX
 23923                                  	;mov	ax,[es:bp+0Bh]
 23924 00003F14 268B460B                	MOV	AX,[ES:BP+DPB.FIRST_SECTOR]
 23925                                  	; 19/05/2019
 23926                                  	;;mov	dx,[es:bp+10h] ; MSDOS 3.3
 23927                                  	;mov	dx,[es:bp+11h] ; MSDOS 6.0
 23928 00003F18 268B5611                	MOV	DX,[ES:BP+DPB.DIR_SECTOR]
 23929 00003F1C 29D0                    	SUB	AX,DX
 23930 00003F1E A2[7705]                	MOV	[CLUSFAC],AL
 23931 00003F21 8916[BE05]              	MOV	[DIRSEC],DX		      ;F.C. >32mb
 23932                                  	; 22/09/2023
 23933                                  	; MSDOS 6.0
 23934                                  	;MOV	WORD [DIRSEC+2],0	      ;F.C. >32mb
 23935 00003F25 F8                      	CLC
 23936 00003F26 C3                      	retn
 23937                                  
 23938                                  ;============================================================================
 23939                                  ; DIR2.ASM, MSDOS 6.0, 1991
 23940                                  ;============================================================================
 23941                                  ; 27/07/2018 - Retro DOS v3.0
 23942                                  ; 19/05/2019 - Retro DOS v4.0 
 23943                                  
 23944                                  ;	TITLE	DIR2 - Directory and path cracking
 23945                                  ;	NAME	Dir2
 23946                                  
 23947                                  ;Break	<GETPATH -- PARSE A WFP>
 23948                                  ;----------------------------------------------------------------------------
 23949                                  ;
 23950                                  ; Procedure Name : GETPATH
 23951                                  ;
 23952                                  ; Inputs:
 23953                                  ;	[WFP_START] Points to WFP string ("d:\" must be first 3 chars, NUL
 23954                                  ;		terminated; d:/ (note forward slash) indicates a real device).
 23955                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 23956                                  ;		( = -1 if current dir not involved, else
 23957                                  ;		 Points to first char after last "/" of current dir part)
 23958                                  ;	[THISCDS] Points to CDS being used
 23959                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 23960                                  ;	[NoSetDir] set
 23961                                  ;	[THISDPB] set to DPB if disk otherwise garbage.
 23962                                  ; Function:
 23963                                  ;	Crack the path
 23964                                  ; Outputs:
 23965                                  ;	Sets EXTERR_LOCUS = errLOC_Disk if disk file
 23966                                  ;	Sets EXTERR_LOCUS = errLOC_Unk if char device
 23967                                  ;	ID1 field of [THISCDS] updated appropriately
 23968                                  ;	[ATTRIB] = [SATTRIB]
 23969                                  ;	ES:BP Points to DPB
 23970                                  ;	Carry set if bad path
 23971                                  ;	   SI Points to path element causing failure
 23972                                  ;	   Zero set
 23973                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 23974                                  ;	      start a search on the last directory
 23975                                  ;	      CL is zero if there is a bad name in the path
 23976                                  ;	      CL is non-zero if the name was simply not found
 23977                                  ;		 [ENTFREE] may have free spot in directory
 23978                                  ;		 [NAME1] is the name.
 23979                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 23980                                  ;	   Zero reset
 23981                                  ;	      File in middle of path or bad name in path or attribute mismatch
 23982                                  ;		or path too long or malformed path
 23983                                  ;	ELSE
 23984                                  ;	   [CurBuf] = -1 if root directory
 23985                                  ;	   [CURBUF] contains directory record with match
 23986                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 23987                                  ;	   [CURBUF+2]:SI Points into [CURBUF] to dir_first field for entry
 23988                                  ;	   AH = device ID
 23989                                  ;	      bit 7 of AH set if device SI and BX
 23990                                  ;	      will point DOSGROUP relative The firclus
 23991                                  ;	      field of the device entry contains the device pointer
 23992                                  ;	   [NAME1] Has name looked for
 23993                                  ;	   If last element is a directory zero is set and:
 23994                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 23995                                  ;	      are set up to start a search on it.
 23996                                  ;	      unless [NoSetDir] is non zero in which case the return is
 23997                                  ;	      like that for a file (except for zero flag)
 23998                                  ;	   If last element is a file zero is reset
 23999                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 24000                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 24001                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 24002                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 24003                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 24004                                  ; DS preserved, Others destroyed
 24005                                  ;---------------------------------------------------------------------------
 24006                                  
 24007                                  ;hkn; called from delete.asm, finfo.asm, mknode.asm and rename.asm.
 24008                                  ;hkn; DS already set up at this point.
 24009                                  
 24010                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24011                                  GETPATH:
 24012                                  	;mov	word [CREATING],0E500h
 24013 00003F27 C706[7E05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Not Creating, not DEL *.*
 24014                                  
 24015                                  ; Same as GetPath only CREATING and DELALL already set
 24016                                  
 24017                                  	;entry	GetPathNoSet
 24018                                  GetPathNoSet:
 24019                                  	;mov	byte [EXTERR_LOCUS],2	
 24020 00003F2D C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 24021 00003F32 C706[E205]FFFF          	MOV	word [CURBUF],-1	; initial setting
 24022                                  
 24023                                  ; See if the input indicates a device that has already been detected. If so,
 24024                                  ; go build the guy quickly. Otherwise, let findpath find the device.
 24025                                  
 24026 00003F38 8B3E[B205]              	MOV	DI,[WFP_START]		; point to the beginning of the name
 24027                                  	;cmp	word [DI+1],5C3Ah
 24028                                  	;CMP	WORD [DI+1],'\' << 8 + ':'
 24029 00003F3C 817D013A5C              	cmp	word [DI+1],':\'
 24030 00003F41 7438                    	JZ	short CrackIt
 24031                                  
 24032                                  ; Let ChkDev find it in the device list
 24033                                  
 24034 00003F43 83C703                  	ADD	DI,3
 24035                                  	; 18/08/2018
 24036                                  	;MOV	SI,DI			; let CHKDEV see the original name
 24037                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24038                                  	; 16/12/2022
 24039                                  	;mov	si,di ; not required ! (it is written in CHKDEV proc already!)
 24040 00003F46 E8AB00                  	CALL	CHKDEV
 24041 00003F49 722E                    	JC	short InternalError
 24042                                  
 24043                                  Build_devJ:
 24044 00003F4B A0[6D05]                	MOV	AL,[SATTRIB]
 24045 00003F4E A2[6B05]                	MOV	[ATTRIB],AL
 24046                                  	;mov	byte [EXTERR_LOCUS],1
 24047 00003F51 C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; In the particular case of
 24048                                  					; "finding" a char device
 24049                                  					; set LOCUS to Unknown. This makes
 24050                                  					; certain idiotic problems reported
 24051                                  					; by a certain 3 letter OEM go away.
 24052                                  
 24053                                  ; Take name in name1 and pack it back into where wfp_start points. This
 24054                                  ; guarantees wfp_start pointing to a canonical representation of a device.
 24055                                  ; We are allowed to do this as GetPath is *ALWAYS* called before entering a
 24056                                  ; wfp into the share set.
 24057                                  ;
 24058                                  ; We copy chars from name1 to wfp_start remembering the position of the last
 24059                                  ; non-space seen +1.  This position is kept in DX.
 24060                                  
 24061                                  ;hkn; SS is DOSDATA
 24062 00003F56 16                      	push	ss
 24063 00003F57 07                      	pop	es
 24064                                  
 24065                                  ;hkn; NAME1 is in DOSDATA
 24066 00003F58 BE[4B05]                	mov	si,NAME1
 24067 00003F5B 8B3E[B205]              	mov	di,[WFP_START]
 24068 00003F5F 89FA                    	mov	dx,di
 24069 00003F61 B90800                  	mov	cx,8			; 8 chars in device name
 24070                                  MoveLoop:
 24071 00003F64 AC                      	lodsb
 24072 00003F65 AA                      	stosb
 24073 00003F66 3C20                    	cmp	al," "
 24074 00003F68 7402                    	jz	short NoSave
 24075                                  
 24076 00003F6A 89FA                    	mov	dx,di
 24077                                  NoSave:
 24078 00003F6C E2F6                    	loop	MoveLoop
 24079                                  
 24080                                  ; DX is the position of the last seen non-space + 1. We terminate the name
 24081                                  ; at this point.
 24082                                  
 24083 00003F6E 89D7                    	mov	di,dx
 24084 00003F70 C60500                  	mov	byte [di],0		; end of string
 24085 00003F73 E8C402                  	call	Build_device_ent	; Clears carry sets zero
 24086 00003F76 FEC0                    	INC	AL			; reset zero
 24087 00003F78 C3                      	retn
 24088                                  
 24089                                  InternalError:
 24090                                  InternalError_loop:
 24091 00003F79 EBFE                    	JMP	short InternalError_loop	; freeze
 24092                                  
 24093                                  ; Start off at the correct spot. Optimize if the current dir part is valid.
 24094                                  
 24095                                  CrackIt:
 24096 00003F7B 8B36[B605]              	MOV	SI,[CURR_DIR_END]	; get current directory pointer
 24097 00003F7F 83FEFF                  	CMP	SI,-1			; valid?
 24098 00003F82 7503                    	JNZ	short LOOK_SING		; Yes, use it.
 24099 00003F84 8D7503                  	LEA	SI,[DI+3]		; skip D:\.
 24100                                  LOOK_SING:
 24101                                  	;mov	byte [ATTRIB],16h
 24102 00003F87 C606[6B05]16            	MOV	byte [ATTRIB],attr_directory+attr_system+attr_hidden
 24103                                  					; Attributes to search through Dirs
 24104 00003F8C C43E[A205]              	LES	DI,[THISCDS]
 24105 00003F90 B8FFFF                  	MOV	AX,-1
 24106                                  	;mov	bx,[es:di+73]
 24107 00003F93 268B5D49                	MOV	BX,[ES:DI+curdir.ID]
 24108 00003F97 8B36[B605]              	MOV	SI,[CURR_DIR_END]
 24109                                  
 24110                                  ; AX = -1
 24111                                  ; BX = cluster number of current directory. THis number is -1 if the media
 24112                                  ;      has been uncertainly changed.
 24113                                  ; SI = offset in DOSGroup into path to end of current directory text. This
 24114                                  ;      may be -1 if no current directory part has been used.
 24115                                  
 24116 00003F9B 39C6                    	CMP	SI,AX			; if Current directory is not part
 24117 00003F9D 743B                    	JZ	short NO_CURR_D		; then we must crack from root
 24118 00003F9F 39C3                    	CMP	BX,AX			; is the current directory cluster valid
 24119                                  
 24120                                  ; DOS 3.3  6/25/86
 24121 00003FA1 7437                    	JZ	short NO_CURR_D		; no, crack form the root
 24122                                  	;test	byte [FastOpenFlg],1
 24123 00003FA3 F606[3A0D]01            	TEST	byte [FastOpenFlg],FastOpen_Set ; for fastopen ?
 24124 00003FA8 743D                    	JZ	short GOT_SEARCH_CLUSTER	; no
 24125 00003FAA 06                      	PUSH	ES			; save registers
 24126 00003FAB 57                      	PUSH	DI
 24127 00003FAC 51                      	PUSH	CX
 24128 00003FAD FF74FF                  	PUSH	word [SI-1]		; save \ and 1st char of next element
 24129 00003FB0 56                      	PUSH	SI
 24130 00003FB1 53                      	PUSH	BX
 24131                                  
 24132 00003FB2 C644FF00                	MOV	BYTE [SI-1],0		; call fastopen to look up cur dir info
 24133 00003FB6 8B36[B205]              	MOV	SI,[WFP_START]
 24134                                  
 24135                                  ;hkn; FastOpenTable, Dir_Info_Buff & FastOpen_Ext_Info are in DOSDATA
 24136 00003FBA BB[300D]                	MOV	BX,FastOpenTable
 24137 00003FBD BF[460D]                	MOV	DI,Dir_Info_Buff
 24138 00003FC0 B9[3B0D]                	MOV	CX,FastOpen_Ext_Info
 24139                                  	;mov	al,1
 24140 00003FC3 B001                    	MOV	AL,FONC_Look_up
 24141 00003FC5 1E                      	PUSH	DS
 24142 00003FC6 07                      	POP	ES
 24143                                  	;call	far [BX+2]
 24144 00003FC7 FF5F02                  	CALL	far [BX+fastopen_entry.name_caching]
 24145 00003FCA 7203                    	JC	short GO_Chk_end1 	;fastopen not installed, or wrong drive.
 24146                                  					; Go to Got_Srch_cluster
 24147                                  	; 29/12/2022
 24148                                  	;CMP	BYTE [SI],0		;fastopen has current dir info?
 24149                                  	;JE	short GO_Chk_end	;yes. Go to got_search_cluster
 24150                                  	;stc
 24151                                  	;jmp	short GO_Chk_end	;Go to No_Curr_D
 24152                                  
 24153 00003FCC 803C01                  	cmp	byte [si],1
 24154                                  GO_Chk_end1:	; 29/12/2022
 24155 00003FCF F5                      	cmc 
 24156                                  	; [si] = 0 -> cf = 0
 24157                                  	; [si] > 0 -> cf = 1
 24158                                  
 24159                                  ;GO_Chk_end1:
 24160                                  	; 29/12/2022
 24161                                  	;clc
 24162                                  
 24163                                  GO_Chk_end:				; restore registers
 24164 00003FD0 5B                      	POP	BX
 24165 00003FD1 5E                      	POP	SI
 24166 00003FD2 8F44FF                  	POP	word [SI-1]
 24167 00003FD5 59                      	POP	CX
 24168 00003FD6 5F                      	POP	DI
 24169 00003FD7 07                      	POP	ES
 24170 00003FD8 730D                    	JNC	short GOT_SEARCH_CLUSTER ; crack based on cur dir
 24171                                  
 24172                                  ; DOS 3.3  6/25/86
 24173                                  ;
 24174                                  ; We must cract the path beginning at the root. Advance pointer to beginning
 24175                                  ; of path and go crack from root.
 24176                                  
 24177                                  NO_CURR_D:
 24178 00003FDA 8B36[B205]              	MOV	SI,[WFP_START]
 24179 00003FDE 8D7403                  	LEA	SI,[SI+3]		; Skip "d:/"
 24180 00003FE1 C42E[8A05]              	LES	BP,[THISDPB]		; Get ES:BP
 24181 00003FE5 EB3B                    	JMP	short ROOTPATH
 24182                                  
 24183                                  ; We are able to crack from the current directory part. Go set up for search
 24184                                  ; of specified cluster.
 24185                                  
 24186                                  GOT_SEARCH_CLUSTER:
 24187 00003FE7 C42E[8A05]              	LES	BP,[THISDPB]		; Get ES:BP
 24188 00003FEB E8DCFE                  	call	SETDIRSRCH
 24189                                  	;JC	short SETFERR
 24190                                  	;JMP	short FINDPATH
 24191                                  	; 16/12/2022
 24192 00003FEE 7342                    	jnc	short FINDPATH ; 17/08/2018
 24193                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24194                                  	;JC	short SETFERR
 24195                                  	;JMP	short FINDPATH
 24196                                  SETFERR:
 24197 00003FF0 30C9                    	XOR	CL,CL			; set zero
 24198 00003FF2 F9                      	STC
 24199 00003FF3 C3                      	retn
 24200                                  
 24201                                  ;---------------------------------------------------------------------------
 24202                                  ;
 24203                                  ; Procedure Name : ChkDev
 24204                                  ;
 24205                                  ; Check to see if the name at DS:DI is a device. Returns carry set if not a
 24206                                  ;   device.
 24207                                  ; Blasts CX,SI,DI,AX,BX
 24208                                  ;---------------------------------------------------------------------------
 24209                                  
 24210                                  CHKDEV:
 24211 00003FF4 89FE                    	MOV	SI,DI
 24212 00003FF6 8CD7                    	MOV	DI,SS
 24213 00003FF8 8EC7                    	MOV	ES,DI
 24214                                  
 24215 00003FFA BF[4B05]                	MOV	DI,NAME1
 24216 00003FFD B90900                  	MOV	CX,9
 24217                                  TESTLOOP:
 24218 00004000 E84910                  	call	GETLET
 24219                                  
 24220 00004003 3C2E                    	CMP	AL,'.'
 24221 00004005 740E                    	JZ	short TESTDEVICE
 24222 00004007 E89810                  	call	PATHCHRCMP
 24223 0000400A 7407                    	JZ	short NOTDEV
 24224 0000400C 08C0                    	OR	AL,AL
 24225 0000400E 7405                    	JZ	short TESTDEVICE
 24226                                  
 24227 00004010 AA                      	STOSB
 24228 00004011 E2ED                    	LOOP	TESTLOOP
 24229                                  NOTDEV:
 24230 00004013 F9                      	STC
 24231 00004014 C3                      	retn
 24232                                  
 24233                                  TESTDEVICE:
 24234                                  	;ADD	CX,2
 24235                                  	; 24/09/2023
 24236 00004015 41                      	inc	cx
 24237 00004016 41                      	inc	cx
 24238 00004017 B020                    	MOV	AL,' '
 24239 00004019 F3AA                    	REP	STOSB
 24240 0000401B 8CD0                    	MOV	AX,SS
 24241 0000401D 8ED8                    	MOV	DS,AX
 24242                                  	;call	DEVNAME
 24243                                  	;retn
 24244                                  	; 18/12/2022
 24245 0000401F E9B901                  	jmp	DEVNAME
 24246                                  
 24247                                  ;Break	<ROOTPATH, FINDPATH -- PARSE A PATH>
 24248                                  ;----------------------------------------------------------------------------
 24249                                  ;
 24250                                  ; Procedure Name : ROOTPATH,FINDPATH
 24251                                  ;
 24252                                  ; Inputs:
 24253                                  ;	Same as FINDPATH but,
 24254                                  ;	SI Points to asciz string of path which is assumed to start at
 24255                                  ;		the root (no leading '/').
 24256                                  ; Function:
 24257                                  ;	Search from root for path
 24258                                  ; Outputs:
 24259                                  ;	Same as FINDPATH but:
 24260                                  ;	If root directory specified, [CURBUF] and [NAME1] are NOT set, and
 24261                                  ;	[NoSetDir] is ignored.
 24262                                  ;----------------------------------------------------------------------------
 24263                                  
 24264                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24265                                  	; DOSCODE:7F47h (MSDOS 5.0, MSDOS.SYS)
 24266                                  
 24267                                  ROOTPATH:
 24268 00004022 E8E0FE                  	call	SETROOTSRCH
 24269                                  	; 24/09/2023
 24270 00004025 30E4                    	xor	ah,ah
 24271                                  	;CMP	BYTE [SI],0
 24272 00004027 3824                    	cmp	[si],ah ; 0
 24273 00004029 7507                    	JNZ	short FINDPATH
 24274                                  
 24275                                  ; Root dir specified
 24276 0000402B A0[6D05]                	MOV	AL,[SATTRIB]
 24277 0000402E A2[6B05]                	MOV	[ATTRIB],AL
 24278                                  	; 24/09/2023
 24279                                  	;XOR	AH,AH			; Sets "device ID" byte, sets zero
 24280                                  					; (dir), clears carry.
 24281 00004031 C3                      	retn
 24282                                  
 24283                                  ; Inputs:
 24284                                  ;	[ATTRIB] Set to get through directories
 24285                                  ;	[SATTRIB] Set to find last element
 24286                                  ;	ES:BP Points to DPB
 24287                                  ;	SI Points to asciz string of path (no leading '/').
 24288                                  ;	[SECCLUSPOS] = 0
 24289                                  ;	[DIRSEC] = Phys sec # of first sector of directory
 24290                                  ;	[CLUSNUM] = Cluster # of next cluster
 24291                                  ;	[CLUSFAC] = Sectors per cluster
 24292                                  ;	[NoSetDir] set
 24293                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 24294                                  ;		( = -1 if current dir not involved, else
 24295                                  ;		 Points to first char after last "/" of current dir part)
 24296                                  ;	[THISCDS] Points to CDS being used
 24297                                  ;	[CREATING] and [DELALL] set
 24298                                  ; Function:
 24299                                  ;	Parse path name
 24300                                  ; Outputs:
 24301                                  ;	ID1 field of [THISCDS] updated appropriately
 24302                                  ;	[ATTRIB] = [SATTRIB]
 24303                                  ;	ES:BP Points to DPB
 24304                                  ;	[THISDPB] = ES:BP
 24305                                  ;	Carry set if bad path
 24306                                  ;	   SI Points to path element causing failure
 24307                                  ;	   Zero set
 24308                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 24309                                  ;	      start a search on the last directory
 24310                                  ;	      CL is zero if there is a bad name in the path
 24311                                  ;	      CL is non-zero if the name was simply not found
 24312                                  ;		 [ENTFREE] may have free spot in directory
 24313                                  ;		 [NAME1] is the name.
 24314                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 24315                                  ;	   Zero reset
 24316                                  ;	      File in middle of path or bad name in path
 24317                                  ;		or path too long or malformed path
 24318                                  ;	ELSE
 24319                                  ;	   [CURBUF] contains directory record with match
 24320                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 24321                                  ;	   [CURBUF+2]:SI Points to fcb_FIRCLUS field for entry
 24322                                  ;	   [NAME1] Has name looked for
 24323                                  ;	   AH = device ID
 24324                                  ;	      bit 7 of AH set if device SI and BX
 24325                                  ;	      will point DOSGROUP relative The firclus
 24326                                  ;	      field of the device entry contains the device pointer
 24327                                  ;	   If last element is a directory zero is set and:
 24328                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 24329                                  ;	      are set up to start a search on it,
 24330                                  ;	      unless [NoSetDir] is non zero in which case the return is
 24331                                  ;	      like that for a file (except for zero flag)
 24332                                  ;	   If last element is a file zero is reset
 24333                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 24334                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 24335                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 24336                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 24337                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 24338                                  ; Destroys all other registers
 24339                                  
 24340                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24341                                  	; DOSCODE:7F58h (MSDOS 5.0, MSDOS.SYS)
 24342                                  
 24343                                      	;entry	FINDPATH
 24344                                  FINDPATH:
 24345 00004032 06                      	PUSH	ES			; Save ES:BP
 24346 00004033 56                      	PUSH	SI
 24347 00004034 89F7                    	MOV	DI,SI
 24348 00004036 8B0E[C205]              	MOV	CX,[DIRSTART]		; Get start clus of dir being searched
 24349 0000403A 833E[B605]FF            	CMP	word [CURR_DIR_END],-1
 24350 0000403F 740E                    	JZ	short NOIDS		; No current dir part
 24351 00004041 3B3E[B605]              	CMP	DI,[CURR_DIR_END]
 24352 00004045 7508                    	JNZ	short NOIDS		; Not to current dir end yet
 24353 00004047 C43E[A205]              	LES	DI,[THISCDS]
 24354                                  	;mov	[es:di+73],cx
 24355 0000404B 26894D49                	MOV	[ES:DI+curdir.ID],CX	; Set current directory currency
 24356                                  NOIDS:
 24357                                  
 24358                                  ; Parse the name off of DS:SI into NAME1. AL = 1 if there was a meta
 24359                                  ; character in the string. CX,DI may be destroyed.
 24360                                  ;
 24361                                  ;	invoke	NAMETRANS
 24362                                  ;	MOV	CL,AL
 24363                                  ;
 24364                                  ; The above is the slow method. The name has *already* been munged by
 24365                                  ; TransPath so no special casing needs to be done. All we do is try to copy
 24366                                  ; the name until ., \ or 0 is hit.
 24367                                  
 24368 0000404F 8CD0                    	MOV	AX,SS
 24369 00004051 8EC0                    	MOV	ES,AX
 24370                                  
 24371                                  ;hkn; Name1 is in DOSDATA
 24372 00004053 BF[4B05]                	MOV	DI,NAME1
 24373 00004056 B82020                  	MOV	AX,'  ' ; 2020h
 24374 00004059 AA                      	STOSB
 24375 0000405A AB                      	STOSW
 24376 0000405B AB                      	STOSW
 24377 0000405C AB                      	STOSW
 24378 0000405D AB                      	STOSW
 24379 0000405E AB                      	STOSW
 24380                                  
 24381                                  ;hkn; Name1 is in DOSDATA
 24382 0000405F BF[4B05]                	MOV	DI,NAME1
 24383 00004062 30E4                    	XOR	AH,AH			; bits for CL
 24384                                  GetNam:
 24385                                  	; 19/05/2019 - Retro DOS v4.0
 24386                                  	;INC	CL ; ?*! ; MSDOS 6.0	;AN000; KK increment volid count
 24387                                  
 24388                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24389                                  	; 16/12/2022
 24390                                  	;inc	cl ; not required !	
 24391                                  	
 24392 00004064 AC                      	LODSB
 24393 00004065 3C2E                    	CMP	AL,'.'	; 2Eh
 24394 00004067 7412                    	JZ	short _SetExt
 24395 00004069 08C0                    	OR	AL,AL
 24396 0000406B 7424                    	JZ	short _GetDone
 24397 0000406D 3C5C                    	CMP	AL,'\'	; 5Ch
 24398 0000406F 7420                    	JZ	short _GetDone
 24399 00004071 3C3F                    	CMP	AL,'?'	; 3Fh
 24400 00004073 7503                    	JNZ	short StoNam
 24401 00004075 80CC01                  	OR	AH,1
 24402                                  StoNam: 
 24403 00004078 AA                      	STOSB
 24404 00004079 EBE9                    	JMP	short GetNam
 24405                                  _SetExt:
 24406 0000407B BF[5305]                	MOV	DI,NAME1+8
 24407                                  GetExt:
 24408 0000407E AC                      	LODSB
 24409 0000407F 08C0                    	OR	AL,AL
 24410 00004081 740E                    	JZ	short _GetDone
 24411 00004083 3C5C                    	CMP	AL,'\'
 24412 00004085 740A                    	JZ	short _GetDone
 24413 00004087 3C3F                    	CMP	AL,'?'
 24414 00004089 7503                    	JNZ	short StoExt
 24415 0000408B 80CC01                  	OR	AH,1
 24416                                  StoExt: 
 24417 0000408E AA                      	STOSB
 24418 0000408F EBED                    	JMP	short GetExt
 24419                                  _GetDone:
 24420 00004091 4E                      	DEC	SI
 24421 00004092 88E1                    	MOV	CL,AH  ; 0 or 1 ; 29/12/2022
 24422 00004094 80C980                  	OR	CL,80H
 24423 00004097 5F                      	POP	DI			; Start of this element
 24424 00004098 07                      	POP	ES			; Restore ES:BP
 24425 00004099 39FE                    	CMP	SI,DI
 24426 0000409B 7503                    	JNZ	short check_device
 24427 0000409D E9E200                  	JMP	_BADPATH		; NUL parse (two delims most likely)
 24428                                  check_device:
 24429 000040A0 56                      	PUSH	SI			; Start of next element
 24430                                  	;MOV	AL,[SI]
 24431                                  	;OR	AL,AL
 24432                                  	; 23/09/2023
 24433 000040A1 803C00                  	cmp	byte [si],0
 24434 000040A4 7508                    	JNZ	short NOT_LAST
 24435                                  
 24436                                  ; for last element of the path switch to the correct search attributes
 24437                                  
 24438 000040A6 8A3E[6D05]              	MOV	BH,[SATTRIB]
 24439 000040AA 883E[6B05]              	MOV	[ATTRIB],BH
 24440                                  
 24441                                  NOT_LAST:
 24442                                  
 24443                                  ; check name1 to see if we have a device...
 24444                                  
 24445 000040AE 06                      	PUSH	ES			; Save ES:BP
 24446                                  
 24447                                  ;hkn; SS is DOSDATA
 24448                                  	;context ES
 24449 000040AF 16                      	push	ss
 24450 000040B0 07                      	pop	es
 24451 000040B1 E82701                  	call	DEVNAME 		; blast BX
 24452 000040B4 07                      	POP	ES			; Restore ES:BP
 24453 000040B5 720B                    	JC	short FindFile		; Not a device
 24454 000040B7 08C0                    	OR	AL,AL			; Test next char again
 24455 000040B9 7403                    	JZ	short GO_BDEV
 24456 000040BB E9C800                  	JMP	FILEINPATH		; Device name in middle of path
 24457                                  
 24458                                  GO_BDEV:
 24459 000040BE 5E                      	POP	SI			; Points to NUL at end of path
 24460 000040BF E989FE                  	JMP	Build_devJ
 24461                                  
 24462                                  FindFile:
 24463                                  ;;;; 7/28/86
 24464 000040C2 803E[4B05]E5            	CMP	BYTE [NAME1],0E5H	; if 1st char = E5
 24465 000040C7 7505                    	JNZ	short NOE5		; no
 24466 000040C9 C606[4B05]05            	MOV	BYTE [NAME1],05H	; change it to 05
 24467                                  NOE5:
 24468                                  ;;;; 7/28/86
 24469 000040CE 57                      	PUSH	DI			; Start of this element
 24470 000040CF 06                      	PUSH	ES			; Save ES:BP
 24471 000040D0 51                      	PUSH	CX			; CL return from NameTrans
 24472                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 24473                                  
 24474 000040D1 E89502                  	CALL	LookupPath		; call fastopen to get dir entry
 24475 000040D4 7303                    	JNC	short DIR_FOUND		; found dir entry
 24476                                  
 24477                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 24478 000040D6 E8B0FC                  	call	FINDENTRY
 24479                                  DIR_FOUND:
 24480 000040D9 59                      	POP	CX
 24481 000040DA 07                      	POP	ES
 24482 000040DB 5F                      	POP	DI
 24483 000040DC 7303                    	JNC	short LOAD_BUF
 24484 000040DE E9CA00                  	JMP	BADPATHPOP
 24485                                  
 24486                                  LOAD_BUF:
 24487 000040E1 C53E[E205]              	LDS	DI,[CURBUF]
 24488                                  	;test	byte [bx+0Bh],10h
 24489 000040E5 F6470B10                	TEST	BYTE [BX+dir_entry.dir_attr],attr_directory
 24490 000040E9 7503                    	JNZ	short GO_NEXT 		; DOS 3.3
 24491 000040EB E99800                  	JMP	FILEINPATH		; Error or end of path
 24492                                  
 24493                                  ; if we are not setting the directory, then check for end of string
 24494                                  
 24495                                  GO_NEXT:
 24496                                  ;hkn; SS override
 24497 000040EE 36803E[4C03]00          	CMP	BYTE [SS:NoSetDir],0
 24498 000040F4 7423                    	JZ	short SetDir
 24499 000040F6 89FA                    	MOV	DX,DI			; Save pointer to entry
 24500 000040F8 8CD9                    	MOV	CX,DS
 24501                                  
 24502                                  ;hkn; SS is DOSDATA
 24503                                  	;context DS
 24504 000040FA 16                      	push	ss
 24505 000040FB 1F                      	pop	ds
 24506 000040FC 5F                      	POP	DI			; Start of next element
 24507                                  	; 19/05/2019 - Retro DOS v4.0
 24508                                  	; MSDOS 6.0
 24509 000040FD F606[3A0D]01            	TEST	byte [FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 24510 00004102 740B                    	JZ	short _nofast			; the FastOpen
 24511 00004104 F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success ; Lookup just happened
 24512 00004109 7404                    	JZ	short _nofast			; no
 24513 0000410B 8B3E[660D]              	MOV	DI,[Next_Element_Start]	; no need to insert it again
 24514                                  _nofast:
 24515 0000410F 803D00                  	CMP	BYTE [DI],0
 24516                                  	;;JNZ	short NEXT_ONE		; DOS 3.3
 24517                                  	;;JMP	_SETRET  ; retn		; Got it
 24518                                  	;retn	; 05/09/2018
 24519                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24520                                  	;jmp	_SETRET
 24521                                  	; 16/12/2022
 24522 00004112 7421                    	jz	short _SETRET
 24523                                  
 24524                                  NEXT_ONE:
 24525 00004114 57                      	PUSH	DI			; Put start of next element back on stack
 24526 00004115 89D7                    	MOV	DI,DX
 24527 00004117 8ED9                    	MOV	DS,CX			; Get back pointer to entry
 24528                                  SetDir:
 24529 00004119 8B14                    	MOV	DX,[SI] 		; Dir_first
 24530                                  
 24531                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 24532 0000411B 1E                      	PUSH	DS		      ; save [curbuf+2]
 24533                                  ;hkn; SS is DOSDATA
 24534 0000411C 16                      	push	ss
 24535 0000411D 1F                      	pop	ds		      ; set DS Dosgroup
 24536                                  	;test	byte [FastOpenFlg],2
 24537 0000411E F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success
 24538 00004123 7411                    	JZ	short DO_NORMAL	      ; fastopen not in memory or path not
 24539 00004125 89D3                    	MOV	BX,DX		      ; not found
 24540 00004127 8B3E[BC05]              	MOV	DI,[CLUSNUM]	      ; clusnum was set in LookupPath
 24541 0000412B 50                      	PUSH	AX		      ; save device id (AH)
 24542 0000412C E89BFD                  	call	SETDIRSRCH
 24543 0000412F 58                      	POP	AX		      ; restore device id (AH)
 24544 00004130 83C402                  	ADD	SP,2		      ; pop ds in stack
 24545 00004133 EB37                    	JMP	short FAST_OPEN_SKIP
 24546                                  
 24547                                  	; 16/12/2022
 24548                                  _SETRET:
 24549 00004135 C3                      	retn
 24550                                  
 24551                                  DO_NORMAL:
 24552 00004136 1F                      	POP	DS			; DS = [curbuf + 2]
 24553                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 24554                                  
 24555 00004137 29FB                    	SUB	BX,DI			; Offset into sector of start of entry
 24556 00004139 29FE                    	SUB	SI,DI			; Offset into sector of dir_first
 24557 0000413B 53                      	PUSH	BX
 24558 0000413C 50                      	PUSH	AX
 24559 0000413D 56                      	PUSH	SI
 24560 0000413E 51                      	PUSH	CX
 24561                                  	;push	word [di+6]
 24562 0000413F FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector]	;AN000;>32mb
 24563                                  	; 19/05/2019
 24564                                  	; MSDOS 6.0
 24565                                  	;push	word [di+8]
 24566 00004142 FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;AN000;>32mb
 24567 00004145 89D3                    	MOV	BX,DX
 24568                                  
 24569                                  ;hkn; SS is DOSDATA
 24570                                  	;context DS
 24571 00004147 16                      	push	ss
 24572 00004148 1F                      	pop	ds
 24573                                  	;invoke	SETDIRSRCH		; This uses UNPACK which might blow
 24574 00004149 E87EFD                  	call	SETDIRSRCH		; the entry sector buffer
 24575                                  	; 19/05/2019
 24576                                  	; MSDOS 6.0
 24577 0000414C 8F06[0706]              	POP	word [HIGH_SECTOR]
 24578 00004150 5A                      	POP	DX
 24579 00004151 7203                    	JC	short SKIP_GETB
 24580                                  	; 22/09/2023
 24581                                  	;;mov	byte [ALLOWED],18h
 24582                                  	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 24583                                  	;XOR	AL,AL ; *
 24584                                  	;;invoke GETBUFFR		; Get the entry buffer back
 24585                                  	;call	GETBUFFR
 24586 00004153 E8FA17                  	call	GETBUFFER ; * ; pre-read
 24587                                  SKIP_GETB:
 24588 00004156 59                      	POP	CX
 24589 00004157 5E                      	POP	SI
 24590 00004158 58                      	POP	AX
 24591 00004159 5B                      	POP	BX
 24592 0000415A 7305                    	JNC	short SET_THE_BUF
 24593 0000415C 5F                      	POP	DI			; Start of next element
 24594 0000415D 89FE                    	MOV	SI,DI			; Point with SI
 24595 0000415F EB21                    	JMP	SHORT _BADPATH
 24596                                  
 24597                                  SET_THE_BUF:
 24598 00004161 E879F5                  	call	SET_BUF_AS_DIR
 24599 00004164 8B3E[E205]              	MOV	DI,[CURBUF]
 24600 00004168 01FE                    	ADD	SI,DI			; Get the offsets back
 24601 0000416A 01FB                    	ADD	BX,DI
 24602                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 24603                                  FAST_OPEN_SKIP:
 24604 0000416C 5F                      	POP	DI			; Start of next element
 24605 0000416D E89D02                  	CALL	InsertPath		; insert dir entry info
 24606                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 24607 00004170 8A05                    	MOV	AL,[DI]
 24608 00004172 08C0                    	OR	AL,AL
 24609 00004174 74BF                    	JZ	short _SETRET		; At end
 24610 00004176 47                      	INC	DI			; Skip over "/"
 24611 00004177 89FE                    	MOV	SI,DI			; Point with SI
 24612 00004179 E8260F                  	call	PATHCHRCMP
 24613 0000417C 7503                    	JNZ	short find_bad_name	; oops
 24614 0000417E E9B1FE                  	JMP	FINDPATH		; Next element
 24615                                  
 24616                                  find_bad_name:
 24617 00004181 4E                      	DEC	SI			; Undo above INC to get failure point
 24618                                  _BADPATH:
 24619 00004182 30C9                    	XOR	CL,CL			; Set zero
 24620 00004184 EB2C                    	JMP	SHORT BADPRET
 24621                                  
 24622                                  FILEINPATH:
 24623 00004186 5F                      	POP	DI			; Start of next element
 24624                                  
 24625                                  ;hkn; SS is DOSDATA
 24626                                  	;context DS			; Got to from one place with DS gone
 24627 00004187 16                      	push	ss
 24628 00004188 1F                      	pop	ds
 24629                                  
 24630                                  ; DOS 3.3 FastOpen
 24631                                  	;test	byte [FastOpenFlg],1
 24632 00004189 F606[3A0D]01            	TEST	byte [FastOpenFlg],FastOpen_Set  ; do this here is we don't want to
 24633 0000418E 740B                    	JZ	short NO_FAST		; device info to fastopen
 24634                                  	;test	byte [FastOpenFlg],2
 24635 00004190 F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success
 24636 00004195 7404                    	JZ	short NO_FAST
 24637 00004197 8B3E[660D]              	MOV	DI,[Next_Element_Start]  ; This takes care of one time lookup
 24638                                  					 ; success
 24639                                  NO_FAST:
 24640                                  ; DOS 3.3 FastOpen
 24641 0000419B 8A05                    	MOV	AL,[DI]
 24642 0000419D 08C0                    	OR	AL,AL
 24643 0000419F 7404                    	JZ	short INCRET
 24644 000041A1 89FE                    	MOV	SI,DI			; Path too long
 24645 000041A3 EB0D                    	JMP	SHORT BADPRET
 24646                                  
 24647                                  INCRET:
 24648                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 24649                                  
 24650 000041A5 E86502                  	CALL   InsertPath		; insert dir entry info
 24651                                  
 24652                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 24653 000041A8 FEC0                    	INC	AL			; Reset zero
 24654                                  	; 16/12/2022	
 24655                                  ;_SETRET:
 24656 000041AA C3                      	retn
 24657                                  
 24658                                  BADPATHPOP:
 24659 000041AB 5E                      	POP	SI			; Start of next element
 24660 000041AC 8A04                    	MOV	AL,[SI]
 24661 000041AE 89FE                    	MOV	SI,DI			; Start of bad element
 24662 000041B0 08C0                    	OR	AL,AL			; zero if bad element is last, non-zero if path too long
 24663                                  BADPRET:
 24664 000041B2 A0[6D05]                	MOV	AL,[SATTRIB]
 24665 000041B5 A2[6B05]                	MOV	[ATTRIB],AL		; Make sure return correct
 24666 000041B8 F9                      	STC
 24667 000041B9 C3                      	retn
 24668                                  
 24669                                  ;Break	<STARTSRCH -- INITIATE DIRECTORY SEARCH>
 24670                                  ;---------------------------------------------------------------------------
 24671                                  ;
 24672                                  ; Procedure Name : STARTSRCH
 24673                                  ;
 24674                                  ; Inputs:
 24675                                  ;	[THISDPB] Set
 24676                                  ; Function:
 24677                                  ;	Set up a search for GETENTRY and NEXTENTRY
 24678                                  ; Outputs:
 24679                                  ;	ES:BP = Drive parameters
 24680                                  ;	Sets up LASTENT, ENTFREE=ENTLAST=-1, VOLID=0
 24681                                  ; Destroys ES,BP,AX
 24682                                  ;--------------------------------------------------------------------------
 24683                                  
 24684                                  STARTSRCH:
 24685 000041BA C42E[8A05]              	LES	BP,[THISDPB]
 24686 000041BE 31C0                    	XOR	AX,AX
 24687 000041C0 A3[4803]                	MOV	[LASTENT],AX
 24688 000041C3 A2[7B05]                	MOV	[VOLID],AL		; No volume ID found
 24689 000041C6 48                      	DEC	AX
 24690 000041C7 A3[D805]                	MOV	[ENTFREE],AX
 24691 000041CA A3[DA05]                	MOV	[ENTLAST],AX
 24692 000041CD C3                      	retn
 24693                                  
 24694                                  ;BREAK <MatchAttributes - the final check for attribute matching>
 24695                                  ;----------------------------------------------------------------------------
 24696                                  ; Procedure Name : MatchAttributes
 24697                                  ;
 24698                                  ; Input:    [Attrib] = attribute to search for
 24699                                  ;	    CH = found attribute
 24700                                  ; Output:   JZ <match>
 24701                                  ;	    JNZ <nomatch>
 24702                                  ; Registers modified: noneski
 24703                                  ;----------------------------------------------------------------------------
 24704                                  
 24705                                  MatchAttributes:
 24706 000041CE 50                      	PUSH	AX
 24707                                  
 24708                                  ;hkn; SS override
 24709 000041CF 36A0[6B05]              	MOV	AL,[ss:ATTRIB]		; AL <- SearchSet
 24710 000041D3 F6D0                    	NOT	AL			; AL <- SearchSet'
 24711 000041D5 20E8                    	AND	AL,CH			; AL <- SearchSet' and FoundSet
 24712                                  	;and	al,16h
 24713 000041D7 2416                    	AND	AL,attr_all	; AL <- SearchSet' and FoundSet and Important
 24714                                  ;
 24715                                  ; the result is non-zero if an attribute is not in the search set
 24716                                  ; and in the found set and in the important set. This means that we do not
 24717                                  ; have a match. Do a JNZ <nomatch> or JZ <match>
 24718                                  ;
 24719 000041D9 58                      	POP	AX
 24720 000041DA C3                      	retn
 24721                                  
 24722                                  ; 19/05/2019 - Retro DOS v4.0
 24723                                  ; DOSCODE:8148h (MSDOS 6.21, MSDOS.SYS)
 24724                                  
 24725                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24726                                  ; DOSCODE:810Dh (MSDOS 5.0, MSDOS.SYS)
 24727                                  
 24728                                  ;Break <DevName - Look for name of device>
 24729                                  ;---------------------------------------------------------------------------
 24730                                  ;
 24731                                  ; Procedure Name : DevName
 24732                                  ;
 24733                                  ; Inputs:
 24734                                  ;	DS,ES:DOSDATA
 24735                                  ;	Filename in NAME1
 24736                                  ;	ATTRIB set so that we can error out if looking for Volume IDs
 24737                                  ; Function:
 24738                                  ;	Determine if file is in list of I/O drivers
 24739                                  ; Outputs:
 24740                                  ;	Carry set if not a device
 24741                                  ;	ELSE
 24742                                  ;	Zero flag set
 24743                                  ;	BH = Bit 7,6 = 1, bit 5 = 0 (cooked mode)
 24744                                  ;	     bits 0-4 set from low byte of attribute word
 24745                                  ;	DEVPT = DWORD pointer to Device header of device
 24746                                  ; BX destroyed, others preserved
 24747                                  ;---------------------------------------------------------------------------
 24748                                  
 24749                                  DEVNAME:
 24750                                  	; 28/07/2018 - Retro DOS v3.0
 24751                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 49FBh
 24752                                  
 24753 000041DB 56                      	PUSH	SI
 24754 000041DC 57                      	PUSH	DI
 24755 000041DD 51                      	PUSH	CX
 24756 000041DE 50                      	PUSH	AX
 24757                                  
 24758                                  ; E5 special code
 24759 000041DF FF36[4B05]              	PUSH	WORD [NAME1]
 24760 000041E3 803E[4B05]05            	CMP	byte [NAME1],5
 24761 000041E8 7505                    	JNZ	short NOKTR
 24762 000041EA C606[4B05]E5            	MOV	byte [NAME1],0E5h
 24763                                  NOKTR:
 24764                                  	;test	byte [ATTRIB],8
 24765 000041EF F606[6B05]08            	TEST	byte [ATTRIB],attr_volume_id
 24766                                  					; If looking for VOL id don't find devs
 24767 000041F4 7521                    	JNZ	short RET31
 24768                                  
 24769                                  ;hkn; NULDEV is in DOSDATA
 24770 000041F6 BE[4800]                	MOV	SI,NULDEV
 24771                                  LOOKIO:
 24772                                  	; 21/11/2022
 24773                                  	;test	byte [SI+SYSDEV.ATT+1],80h
 24774                                  	; 17/12/2022
 24775                                  	;test	byte [si+5],80h
 24776 000041F9 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
 24777                                  	;;test	word [si+4],8000h
 24778                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP
 24779 000041FD 7411                    	JZ	short SKIPDEV 		; Skip block devices (NET and LOCAL)
 24780 000041FF 89F0                    	MOV	AX,SI
 24781                                  	;add	si,10
 24782 00004201 83C60A                  	ADD	SI,SYSDEV.NAME
 24783                                  
 24784                                  ;hkn; NAME1 is in DOSDATA
 24785 00004204 BF[4B05]                	MOV	DI,NAME1
 24786 00004207 B90400                  	MOV	CX,4			; All devices are 8 letters
 24787 0000420A F3A7                    	REPE	CMPSW			; Check for name in list
 24788 0000420C 89C6                    	MOV	SI,AX
 24789 0000420E 7415                    	JZ	short IOCHK		; Found it?
 24790                                  SKIPDEV:
 24791 00004210 C534                    	LDS	SI,[SI]			; Get address of next device
 24792 00004212 83FEFF                  	CMP	SI,-1			; At end of list?
 24793 00004215 75E2                    	JNZ	short LOOKIO
 24794                                  RET31:	
 24795 00004217 F9                      	STC				; Not found
 24796                                  RETNV:	
 24797 00004218 8CD1                    	MOV	CX,SS
 24798 0000421A 8ED9                    	MOV	DS,CX
 24799                                  
 24800 0000421C 8F06[4B05]              	POP	WORD [NAME1]
 24801 00004220 58                      	POP	AX
 24802 00004221 59                      	POP	CX
 24803 00004222 5F                      	POP	DI
 24804 00004223 5E                      	POP	SI
 24805 00004224 C3                      	RETN
 24806                                  
 24807                                  IOCHK:
 24808                                  ;hkn; SS override for DEVPT
 24809 00004225 368C1E[9C05]            	MOV	[SS:DEVPT+2],DS		; Save pointer to device
 24810                                  	;mov	bh,[si+4]
 24811 0000422A 8A7C04                  	MOV	BH,[SI+SYSDEV.ATT]
 24812 0000422D 80CFC0                  	OR	BH,0C0h
 24813 00004230 80E7DF                  	and	bh,0DFh
 24814                                  	;AND	BH,~(020h)		; Clears Carry
 24815 00004233 368936[9A05]            	MOV	[SS:DEVPT],SI
 24816 00004238 EBDE                    	JMP	short RETNV
 24817                                  
 24818                                  ;BREAK <Build_device_ent - Make a Directory entry>
 24819                                  ;---------------------------------------------------------------------------
 24820                                  ; Procedure Name : Build_device_ent
 24821                                  ;
 24822                                  ; Inputs:
 24823                                  ;	[NAME1] has name
 24824                                  ;	BH is attribute field (supplied by DEVNAME)
 24825                                  ;	[DEVPT] points to device header (supplied by DEVNAME)
 24826                                  ; Function:
 24827                                  ;	Build a directory entry for a device at DEVFCB
 24828                                  ; Outputs:
 24829                                  ;	BX points to DEVFCB
 24830                                  ;	SI points to dir_first field
 24831                                  ;	AH = input BH
 24832                                  ;	AL = 0
 24833                                  ;	dir_first = DEVPT
 24834                                  ;	Zero Set, Carry Clear
 24835                                  ; DS,ES,BP preserved, others destroyed
 24836                                  ;--------------------------------------------------------------------------
 24837                                  
 24838                                  Build_device_ent:
 24839 0000423A B82020                  	MOV	AX,"  " ; 2020h
 24840                                  
 24841                                  ;hkn; DEVFCB is in DOSDATA
 24842 0000423D BF[5305]                	MOV	DI,DEVFCB+8		; Point to extent field
 24843                                  
 24844                                  ;	Fill dir_ext  BUGBUG - use ERRNZs for this stuff!
 24845                                  
 24846 00004240 AB                      	STOSW
 24847 00004241 AA                      	STOSB				; Blank out extent field
 24848                                  	;mov	al,40h
 24849 00004242 B040                    	MOV	AL,attr_device
 24850                                  
 24851                                  ;	Fill Dir_attr
 24852                                  
 24853 00004244 AA                      	STOSB				; Set attribute field
 24854 00004245 31C0                    	XOR	AX,AX
 24855 00004247 B90A00                  	MOV	CX,10
 24856                                  
 24857                                  ; Fill dir_pad
 24858                                  
 24859 0000424A F3AB                    	REP	STOSW			; Fill rest with zeros
 24860 0000424C E8A1C8                  	call	DATE16
 24861                                  
 24862                                  ;hkn; DEVFCB is in DOSDATA
 24863 0000424F BF[6105]                	MOV	DI,DEVFCB+dir_entry.dir_time ; 09/08/2018
 24864 00004252 92                      	XCHG	AX,DX
 24865                                  
 24866                                  ; Fill dir_time
 24867                                  
 24868 00004253 AB                      	STOSW
 24869 00004254 92                      	XCHG	AX,DX
 24870                                  
 24871                                  ; Fill dir_date
 24872                                  
 24873 00004255 AB                      	STOSW
 24874 00004256 89FE                    	MOV	SI,DI			; SI points to dir_first field
 24875 00004258 A1[9A05]                	MOV	AX,[DEVPT]
 24876                                  
 24877                                  ; Fill dir_first
 24878                                  
 24879 0000425B AB                      	STOSW				; Dir_first points to device
 24880 0000425C A1[9C05]                	MOV	AX,[DEVPT+2]
 24881                                  ;
 24882                                  ; Fill dir_size_l
 24883                                  ;
 24884 0000425F AB                      	STOSW
 24885 00004260 88FC                    	MOV	AH,BH			; Put device atts in AH
 24886                                  
 24887                                  ;hkn; DEVFCB is in DOSDATA
 24888 00004262 BB[4B05]                	MOV	BX,DEVFCB
 24889 00004265 30C0                    	XOR	AL,AL			; Set zero, clear carry
 24890 00004267 C3                      	retn
 24891                                  
 24892                                  ;Break	<ValidateCDS - given a CDS, validate the media and the current directory>
 24893                                  ;----------------------------------------------------------------------------
 24894                                  ;
 24895                                  ;   ValidateCDS - Get current CDS. Splice it. Call FatReadCDS to check
 24896                                  ;   media. If media has been changed, do DOS_Chdir to validate path.
 24897                                  ;   If invalid, reset original CDS to root.
 24898                                  ;
 24899                                  ;   Inputs:	ThisCDS points to CDS of interest
 24900                                  ;		SS:DI points to temp buffer
 24901                                  ;   Outputs:	The current directory string is validated on the appropriate
 24902                                  ;		    drive
 24903                                  ;		ThisDPB changed
 24904                                  ;		ES:DI point to CDS
 24905                                  ;		Carry set if error (currently user FAILed to I 24)
 24906                                  ;   Registers modified: all
 24907                                  ;----------------------------------------------------------------------------
 24908                                  
 24909                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24910                                  	; DOSCODE:819Bh (MSDOS 5.0, MSDOS.SYS)
 24911                                  
 24912                                  ValidateCDS:
 24913                                  	; 19/05/2019 - Retro DOS v4.0
 24914                                  	; 28/07/2018 - Retro DOS v3.0
 24915                                  
 24916                                     %define  Temp	[bp-2]	; word
 24917                                     %define  SaveCDS	[bp-6]	; dword
 24918                                     %define  SaveCDSL	[bp-6]	; word
 24919                                     %define  SaveCDSH	[bp-4]	; word
 24920                                  
 24921                                  	;Enter
 24922 00004268 55                      	push	bp
 24923 00004269 89E5                    	mov	bp,sp
 24924 0000426B 83EC06                  	sub	sp,6
 24925                                  
 24926 0000426E 897EFE                  	MOV	Temp,DI
 24927                                  
 24928                                  ;hkn; SS override
 24929 00004271 36C536[A205]            	LDS	SI,[SS:THISCDS]
 24930 00004276 8976FA                  	MOV	SaveCDSL,SI
 24931 00004279 8C5EFC                  	MOV	SaveCDSH,DS
 24932                                  	;EnterCrit critDisk
 24933 0000427C E88ED0                  	call	ECritDisk
 24934                                  	; 21/11/2022
 24935                                  	;test	byte [SI+curdir.flags+1],80h
 24936                                  	;test	word [si+67],8000h
 24937                                  	; 17/12/2022
 24938                                  	;test	byte [SI+68],80h
 24939 0000427F F6444480                	test	byte [SI+curdir.flags+1],(curdir_isnet>>8)
 24940                                  	;TEST	word [SI+curdir.flags],curdir_isnet	; Clears carry
 24941 00004283 7403                    	JZ	short _DoSplice
 24942 00004285 E99200                  	JMP	FatFail
 24943                                  _DoSplice:
 24944 00004288 30D2                    	XOR	DL,DL
 24945 0000428A 368616[4C03]            	XCHG	DL,[SS:NoSetDir]
 24946                                  
 24947                                  ;hkn; SS is DOSDATA
 24948                                  	;Context ES
 24949 0000428F 16                      	push	ss
 24950 00004290 07                      	pop	es
 24951                                  	;Invoke	FStrcpy
 24952 00004291 E84ECF                  	call	FStrCpy
 24953 00004294 8B76FE                  	MOV	SI,Temp
 24954                                  
 24955                                  ;hkn; SS is DOSDATA
 24956                                  	;Context DS
 24957 00004297 16                      	push	ss
 24958 00004298 1F                      	pop	ds	
 24959                                  	;Invoke	Splice
 24960 00004299 E85D2B                  	call	Splice
 24961                                  
 24962                                   ;hkn; SS is DOSDATA
 24963                                  	;Context DS			;   FatReadCDS (ThisCDS);
 24964 0000429C 16                      	push	ss
 24965 0000429D 1F                      	pop	ds
 24966 0000429E 8816[4C03]              	MOV	[NoSetDir],DL
 24967 000042A2 C43E[A205]              	LES	DI,[THISCDS]
 24968                                  	;SAVE	<BP>
 24969 000042A6 55                      	push	bp
 24970                                  	;Invoke	FATREAD_CDS
 24971 000042A7 E83114                  	call	FATREAD_CDS	
 24972                                  	;RESTORE <BP>
 24973 000042AA 5D                      	pop	bp
 24974 000042AB 726D                    	JC	short FatFail
 24975                                  
 24976 000042AD C536[A205]              	LDS	SI,[THISCDS]		;   if (ThisCDS->ID == -1) {
 24977                                  	;cmp	word [si+73],-1
 24978 000042B1 837C49FF                	CMP	word [SI+curdir.ID],-1
 24979 000042B5 7555                    	JNZ	short RestoreCDS
 24980                                  
 24981                                  ;hkn; SS is DOSDATA
 24982                                  	;Context ES
 24983 000042B7 16                      	push	ss
 24984 000042B8 07                      	pop	es
 24985                                  
 24986                                  ;hkn; SS override
 24987                                  	;SAVE	<wfp_Start>		;	t = wfp_Start;
 24988 000042B9 36FF36[B205]            	push	word [SS:WFP_START]
 24989                                  	;cmp	si,[bp-6]
 24990 000042BE 3B76FA                  	CMP	SI,SaveCDSL		; if not spliced
 24991 000042C1 750B                    	JNZ	short DoChdir
 24992                                  	;mov	di,[bp-2]
 24993 000042C3 8B7EFE                  	MOV	DI,Temp
 24994                                  
 24995                                  ;hkn; SS override
 24996 000042C6 36893E[B205]            	MOV	[SS:WFP_START],DI	;	wfp_start = d;
 24997                                  	;Invoke	FStrCpy 		;	strcpy (d, ThisCDS->Text);
 24998 000042CB E814CF                  	call	FStrCpy
 24999                                  DoChdir:
 25000                                  ;hkn; SS is DOSDATA
 25001                                  	;Context DS
 25002 000042CE 16                      	push	ss
 25003 000042CF 1F                      	pop	ds
 25004                                  	;SAVE	<<WORD PTR SAttrib>,BP> ;	c = DOSChDir ();
 25005 000042D0 FF36[6D05]              	push	word [SATTRIB]
 25006 000042D4 55                      	push	bp
 25007                                  	;Invoke	DOS_ChDir
 25008 000042D5 E8F0EE                  	call	DOS_CHDIR
 25009                                  	;RESTORE <BP,BX,wfp_start>	;	wfp_Start = t;
 25010 000042D8 5D                      	pop	bp
 25011 000042D9 5B                      	pop	bx
 25012 000042DA 8F06[B205]              	pop	word [WFP_START]
 25013 000042DE 881E[6D05]              	MOV	[SATTRIB],BL
 25014 000042E2 C576FA                  	LDS	SI,SaveCDS
 25015 000042E5 730F                    	JNC	short SetCluster	;	if (c == -1) {
 25016                                  
 25017                                  ;hkn; SS override for THISCDS
 25018 000042E7 368936[A205]            	MOV	[SS:THISCDS],SI		;	    ThisCDS = TmpCDS;
 25019 000042EC 368C1E[A405]            	MOV	[SS:THISCDS+2],DS
 25020 000042F1 31C9                    	XOR	CX,CX			;	    TmpCDS->text[3] = c = 0;
 25021 000042F3 884C03                  	MOV	[SI+3],CL		;	    }
 25022                                  SetCluster:
 25023                                  	;mov	word [si+73],0FFFFh
 25024 000042F6 C74449FFFF              	MOV	word [SI+curdir.ID],-1	;	TmpCDS->ID = -1;
 25025 000042FB 36C536[A205]            	LDS	SI,[SS:THISCDS]		;	ThisCDS->ID = c;
 25026                                  	; 21/11/2022
 25027                                  	;test	byte [si+curdir.flags+1],20h
 25028                                  	; 19/05/2019
 25029                                  	; MSDOS 6.0
 25030                                  	; 17/12/2022
 25031                                  	;test	byte [si+68],20h
 25032 00004300 F6444420                	test	byte [SI+curdir.flags+1],(curdir_splice>>8)	
 25033                                  	;;test	word [si+67],2000h
 25034                                  	;TEST	word [SI+curdir.flags],curdir_splice ;AN000;;MS. for Join and Subst
 25035 00004304 7403                    	JZ	short _setdirclus		     ;AN000;;MS.
 25036 00004306 B9FFFF                  	MOV	CX,-1				     ;AN000;;MS.
 25037                                  _setdirclus:
 25038                                  	;mov	[si+73],cx
 25039 00004309 894C49                  	MOV	[SI+curdir.ID],CX	;	}
 25040                                  RestoreCDS:
 25041 0000430C C47EFA                  	LES	DI,SaveCDS
 25042 0000430F 36893E[A205]            	MOV	[SS:THISCDS],DI
 25043 00004314 368C06[A405]            	MOV	[SS:THISCDS+2],ES
 25044 00004319 F8                      	CLC
 25045                                  FatFail:
 25046                                  	;LeaveCrit critDisk
 25047 0000431A E80BD0                  	call	LCritDisk
 25048                                  
 25049                                  	;les	di,[bp-6]
 25050 0000431D C47EFA                  	LES	DI,SaveCDS
 25051                                  	;Leave
 25052 00004320 89EC                    	mov	sp,bp
 25053 00004322 5D                      	pop	bp
 25054 00004323 C3                      	retn
 25055                                  
 25056                                  ; 28/07/2018 - Retro DOS v3.0
 25057                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - offset 43BDh
 25058                                  
 25059                                  ;Break	<CheckThisDevice - Check for being a device>
 25060                                  ;---------------------------------------------------------------------------
 25061                                  ;
 25062                                  ;   CheckThisDevice - Examine the area at DS:SI to see if there is a valid
 25063                                  ;   device specified. We will return carry if there is a device present. 
 25064                                  ;   The forms of devices we will recognize are:
 25065                                  ;
 25066                                  ;	[path]device
 25067                                  ;
 25068                                  ;   Note that the drive letter has *already* been removed. All other forms
 25069                                  ;   are not considered to be devices. If such a device is found we change
 25070                                  ;   the source pointer to point to the device component.
 25071                                  ;
 25072                                  ;   Inputs:	ES is DOSDATA
 25073                                  ;		DS:SI contains name
 25074                                  ;   Outputs:	ES is DOSDATA
 25075                                  ;		DS:SI point to name or device
 25076                                  ;		Carry flag set if device was found
 25077                                  ;		Carry flag reset otherwise
 25078                                  ;   Registers Modified: all except ES:DI, DS
 25079                                  ;----------------------------------------------------------------------------
 25080                                  
 25081                                  CheckThisDevice:
 25082 00004324 57                      	push	di
 25083 00004325 56                      	push	si
 25084 00004326 89F7                    	MOV	DI,SI
 25085                                  
 25086                                  ; Check for presence of \dev\ (Dam multiplan!)
 25087                                  
 25088 00004328 8A04                    	MOV	AL,[SI]
 25089 0000432A E8750D                  	call	PATHCHRCMP		; is it a path char?
 25090 0000432D 7517                    	JNZ	short ParseDev		; no, go attempt to parse device
 25091 0000432F 46                      	INC	SI			; simulate LODSB
 25092                                  
 25093                                  ; We have the leading path separator. Look for DEV part.
 25094                                  
 25095 00004330 AD                      	LODSW
 25096 00004331 0D2020                  	OR	AX,2020h
 25097 00004334 3D6465                  	cmp	ax,"de"
 25098                                  	;CMP	AX,"e"<< 8 + "d"
 25099 00004337 752D                    	JNZ	short NotDevice		; not "de", assume not device
 25100 00004339 AC                      	LODSB
 25101 0000433A 0C20                    	OR	AL,20h
 25102 0000433C 3C76                    	CMP	AL,"v"                  ; Not "v", assume not device
 25103 0000433E 7526                    	JNZ	short NotDevice
 25104 00004340 AC                      	LODSB
 25105 00004341 E85E0D                  	call	PATHCHRCMP		; do we have the last path separator?
 25106 00004344 7520                    	JNZ	short NotDevice		; no. go for it.
 25107                                  
 25108                                  ; DS:SI now points to a potential drive. Preserve them as NameTrans advances
 25109                                  ; SI and DevName may destroy DS.
 25110                                  
 25111                                  ParseDev:
 25112 00004346 1E                      	push	ds
 25113 00004347 56                      	push	si			; preserve the source pointer
 25114 00004348 E8950C                  	call	NameTrans		; advance DS:SI
 25115 0000434B 803C00                  	CMP	BYTE [SI],0		; parse entire string?
 25116 0000434E F9                      	STC				; simulate a Carry return from DevName
 25117 0000434F 750B                    	JNZ	short SkipSearch	; no parse. simulate a file return.
 25118                                  
 25119                                  ;hkn; SS is DOSDATA
 25120 00004351 16                      	push	ss
 25121 00004352 1F                      	pop	ds
 25122                                  
 25123                                  ; M026 - start - fix ported from ROMDOS2 for bug # 2849
 25124                                  ;
 25125                                  ; SR;
 25126                                  ; We have to set Attrib before invoking DevName. Otherwise, the value from
 25127                                  ; a previous DOS call is used and DevName thinks it is not a device if the
 25128                                  ; old call set the volume attribute bit.
 25129                                  
 25130 00004353 A0[6D05]                	mov	al,[SATTRIB]
 25131 00004356 A2[6B05]                	mov	[ATTRIB],al		;set Attrib for DevName
 25132                                  
 25133                                  ; M026 - end
 25134                                  
 25135 00004359 E87FFE                  	call	DEVNAME
 25136                                  
 25137                                  SkipSearch:
 25138 0000435C 5E                      	pop	si
 25139 0000435D 1F                      	pop	ds
 25140                                  
 25141                                  ; SI points to the beginning of the potential device. If we have a device
 25142                                  ; then we do not change SI. If we have a file, then we reset SI back to the
 25143                                  ; original value. At this point Carry set indicates FILE.
 25144                                  
 25145                                  CheckReturn:
 25146 0000435E 5F                      	pop	di			; get original SI
 25147 0000435F 7302                    	JNC	short Check_Done	; if device then do not reset pointer
 25148 00004361 89FE                    	MOV	SI,DI
 25149                                  Check_Done:
 25150 00004363 5F                      	pop	di
 25151 00004364 F5                      	CMC				; invert carry. Carry => device
 25152 00004365 C3                      	retn
 25153                                  NotDevice:
 25154 00004366 F9                      	STC
 25155 00004367 EBF5                    	JMP	short CheckReturn
 25156                                  
 25157                                  ;BREAK <LookupPath - call fastopen to get dir entry info>
 25158                                  ;-----------------------------------------------------------------------------
 25159                                  ;
 25160                                  ; Procedure Name : LookupPath
 25161                                  ;
 25162                                  ; Output  DS:SI -> path name,
 25163                                  ;	  ES:DI -> dir entry info buffer
 25164                                  ;	  ES:CX -> extended dir info buffer
 25165                                  ;
 25166                                  ;	  carry flag clear : tables pointed by ES:DI and ES:CX are filled by
 25167                                  ;			     FastOpen, DS:SI points to char just one after
 25168                                  ;			     the last char of path name which is fully or
 25169                                  ;			     partially found in FastOPen
 25170                                  ;	  carry flag set : FastOpen not in memory or path name not found
 25171                                  ;
 25172                                  ;----------------------------------------------------------------------------
 25173                                  
 25174                                  LookupPath:
 25175                                  ;	PUSH	AX
 25176                                  
 25177                                  ;hkn; SS override
 25178                                  	;test	byte [ss:FastOpenFlg],1
 25179 00004369 36F606[3A0D]01          	TEST	byte [ss:FastOpenFlg],FastOpen_Set  ; flg is set in DOSOPEN
 25180 0000436F 7503                    	JNZ	short FASTINST			    ; and this routine is
 25181                                  NOLOOK:
 25182 00004371 E99700                  	JMP	NOLOOKUP			    ; executed once
 25183                                  
 25184                                  FASTINST:
 25185                                  ;hkn; SS override
 25186                                  	;test	byte [ss:FastOpenFlg],8
 25187 00004374 36F606[3A0D]08          	TEST	byte [ss:FastOpenFlg],No_Lookup	    ; no more lookup?
 25188 0000437A 75F5                    	JNZ	short NOLOOK			    ; yes
 25189                                  
 25190 0000437C BB[300D]                	MOV	BX,FastOpenTable		    ; get fastopen related tab
 25191                                  
 25192                                  ;hkn; SS override
 25193 0000437F 368B36[B205]            	MOV	SI,[SS:WFP_START]		    ; si points to path name
 25194 00004384 BF[460D]                	MOV	DI,Dir_Info_Buff
 25195 00004387 B9[3B0D]                	MOV	CX,FastOpen_Ext_Info
 25196 0000438A B001                    	MOV	AL,FONC_Look_up 		    ; al = 1
 25197 0000438C 1E                      	PUSH	DS
 25198 0000438D 07                      	POP	ES
 25199                                  
 25200                                  ;hkn; SS override
 25201                                  	;call	far [bx+2]
 25202 0000438E FF5F02                  	CALL	far [BX+fastopen_entry.name_caching] ;call fastopen
 25203 00004391 7267                    	JC	short NOTFOUND			    ; fastopen not in memory
 25204                                  
 25205 00004393 8D5CFE                  	LEA	BX,[SI-2]
 25206                                  
 25207                                  ;hkn; SS override
 25208 00004396 363B1E[B205]            	CMP	BX,[SS:WFP_START]		    ; path found ?
 25209 0000439B 745D                    	JZ	short NOTFOUND			    ; no
 25210                                  
 25211                                  	; 19/05/2019 - Retro DOS v4.0
 25212                                  
 25213                                  	; MSDOS 6.0				    ; fully or partially found
 25214 0000439D 803C00                  	CMP	BYTE [SI],0			    ;AN000;FO.
 25215 000043A0 751A                    	JNZ	short parfnd			    ;AN000;FO.; partiallyfound
 25216 000043A2 51                      	PUSH	CX				    ;AN000;FO.; is attribute matched ?
 25217                                  
 25218                                  ;hkn; SS override for attrib/sattrib
 25219 000043A3 368A0E[6B05]            	MOV	CL,[ss:ATTRIB]			    ;AN000;FO.;
 25220 000043A8 368A2E[6D05]            	MOV	CH,[ss:SATTRIB]			    ;AN000;FO.; attrib=sattrib
 25221 000043AD 36882E[6B05]            	MOV	[ss:ATTRIB],CH			    ;AN000;FO.;
 25222                                  	;mov	ch,[es:di+0Bh]
 25223 000043B2 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]	    ;AN000;FO.;
 25224 000043B6 E815FE                  	call	MatchAttributes 		    ;AN000;FO.;
 25225                                  ;;;	MOV	[ss:ATTRIB],CL			    ;AN001;FO.; restore attrib
 25226 000043B9 59                      	POP	CX				    ;AN000;FO.;
 25227 000043BA 754F                    	JNZ	short NOLOOKUP			    ;AN000;FO.; not matched
 25228                                  parfnd:
 25229                                  
 25230                                  ;hkn; SS override
 25231 000043BC 368936[660D]            	MOV	[SS:Next_Element_Start],SI	    ; save si
 25232 000043C1 89CB                    	MOV	BX,CX
 25233                                  	; MSDOS 6.0
 25234                                  	;mov	ax,[bx+7]
 25235 000043C3 8B4707                  	MOV	AX,[BX+FEI.lastent]		    ;AN000;;FO. restore lastentry
 25236                                  ;hkn; SS override for LASTENT, DIRSTART, CLUSNUM
 25237 000043C6 36A3[4803]              	MOV	[SS:LASTENT],AX			    ;AN000;;FO.
 25238 000043CA 8B4709                  	MOV	AX,[BX+FEI.dirstart]		    ;AN001;;FO. restore dirstart
 25239 000043CD 36A3[C205]              	MOV	[SS:DIRSTART],AX		    ;AN001;;FO.
 25240                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25241                                  	;;mov	ax,[bx+3] ; MSDOS 3.3
 25242                                  	;mov	ax,[bx+5] ; MSDOS 6.0
 25243 000043D1 8B4705                  	MOV	AX,[BX+FEI.clusnum]		    ; restore next cluster num
 25244 000043D4 36A3[BC05]              	MOV	[SS:CLUSNUM],AX			    ;
 25245                                  
 25246 000043D8 06                      	PUSH	ES				    ; save ES
 25247                                  ;hkn; SS override
 25248 000043D9 36C41E[8A05]            	LES	BX,[SS:THISDPB]			    ; put drive id
 25249 000043DE 268A27                  	mov	ah,[ES:BX] ; 15/08/2018
 25250                                  	;MOV	AH,[ES:BX+DPB.DRIVE]		    ; in AH for DOOPEN
 25251 000043E1 07                      	POP	ES				    ; pop ES
 25252                                  ;SR;
 25253                                  ; We cannot have a root dir if we have come here. So, we zero out CurBuf to
 25254                                  ;indicate it is not a root dir
 25255                                  
 25256 000043E2 36C706[E205]0000        	mov	word [SS:CURBUF],0		    ; indicate not root dir
 25257 000043E9 368C06[E405]            	MOV	WORD [SS:CURBUF+2],ES		    ; [curbuf+2].bx points to
 25258 000043EE 89FB                    	MOV	BX,DI				    ; start of entry
 25259                                  	;lea	si,[di+1Ah]
 25260 000043F0 8D751A                  	LEA	SI,[DI+dir_entry.dir_first]	    ; [curbuf+2]:si points to
 25261                                  						    ; dir_first field in the
 25262                                  						    ; dir entry
 25263                                  ;hkn; SS override for FastOpenFlg
 25264                                  	;or	byte [ss:FastOpenFlg],12h ; 29/12/2022
 25265 000043F3 36800E[3A0D]12          	OR	byte [SS:FastOpenFlg],Lookup_Success+Set_For_Search
 25266                                  ;	POP	AX
 25267 000043F9 C3                      	RETN
 25268                                  NOTFOUND:
 25269 000043FA 83F8FF                  	CMP	AX,-1				    ; not in memory ?
 25270 000043FD 7506                    	JNZ	short Partial_Success 		    ; yes, in memory
 25271 000043FF 36C606[3A0D]00          	MOV	byte [SS:FastOpenFlg],0		    ; no more fastopen
 25272                                  Partial_Success:
 25273                                  	;and	byte [SS:FastOpenFlg],0FBh
 25274 00004405 368026[3A0D]FB          	AND	byte [SS:FastOpenFlg],Special_Fill_Reset
 25275                                  NOLOOKUP:
 25276                                  ;	POP	AX
 25277 0000440B F9                      	STC
 25278 0000440C C3                      	RETN
 25279                                  
 25280                                  ;BREAK <InsertPath - call fastopen to insert dir entry info>
 25281                                  ;-----------------------------------------------------------------------------
 25282                                  ;
 25283                                  ; Procedure Name : InsertPath
 25284                                  ; Input:  FastOpen_Set flag set when from DOSOPEN otherwise 0
 25285                                  ;	  Lookup_Success flag set when got dir entry info from FASTOPEN
 25286                                  ;	  DS = DOSDATA
 25287                                  ; Output: FastOPen_Ext_Info is set and path dir info is inserted
 25288                                  ;
 25289                                  ;-----------------------------------------------------------------------------
 25290                                  
 25291                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25292                                  
 25293                                  InsertPath:
 25294 0000440D 9C                      	PUSHF
 25295                                  ;hkn; SS override for FastOpenFlag
 25296                                  	;test	byte [SS:FastOpenFlg], 1
 25297 0000440E 36F606[3A0D]01          	TEST	byte [SS:FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 25298 00004414 7479                    	JZ	short GET_NEXT_ELEMENT		; the FastOpen
 25299                                  	;test	byte [ss:FastOpenFlg],2
 25300 00004416 36F606[3A0D]02          	TEST	byte [SS:FastOpenFlg],Lookup_Success ; Lookup just happened
 25301 0000441C 740D                    	JZ	short INSERT_DIR_INFO		; no
 25302                                  	;and	byte [ss:FastOpenFlg],0FDh
 25303 0000441E 368026[3A0D]FD          	AND	byte [SS:FastOpenFlg],Lookup_Reset  ; we got dir info from fastopen so
 25304 00004424 368B3E[660D]            	MOV	DI,[SS:Next_Element_Start]	; no need to insert it again
 25305 00004429 EB5E                    	JMP	short GET_NEXT2
 25306                                  INSERT_DIR_INFO:				; save registers
 25307 0000442B 1E                      	PUSH	DS
 25308 0000442C 06                      	PUSH	ES
 25309 0000442D 53                      	PUSH	BX
 25310 0000442E 56                      	PUSH	SI
 25311 0000442F 57                      	PUSH	DI
 25312 00004430 51                      	PUSH	CX
 25313 00004431 50                      	PUSH	AX
 25314                                  
 25315                                  ;hkn; SS override
 25316 00004432 36C53E[E205]            	LDS	DI,[SS:CURBUF]			; DS:DI -> buffer header
 25317 00004437 BE[3B0D]                	MOV	SI,FastOpen_Ext_Info
 25318                                  	;mov	ax,[di+6]
 25319 0000443A 8B4506                  	MOV	AX,[DI+BUFFINFO.buf_sector]	; get directory sector
 25320                                  	; MSDOS 6.0
 25321                                  	;mov	[ss:si+1],ax
 25322 0000443D 36894401                	MOV	[SS:SI+FEI.dirsec],AX 		;AN000; >32mb save dir sector
 25323                                  	; 19/05/2019 - Retro DOS v4.0
 25324 00004441 8B4508                  	MOV	AX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 25325                                  
 25326                                  ;hkn; SS is DOSDATA
 25327 00004444 16                      	push	ss
 25328 00004445 1F                      	pop	ds
 25329                                  	; MSDOS 3.3	
 25330                                  	;;mov	[si+1],ax	
 25331                                  	;MOV	[SI+FEI.dirsec],AX
 25332                                  	; MSDOS 6.0
 25333                                  	;mov	[si+3],ax
 25334 00004446 894403                  	MOV	[SI+FEI.dirsec+2],AX		;AN000;>32mb save high dir sector
 25335                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25336 00004449 A1[BC05]                	MOV	AX,[CLUSNUM]		; save next cluster number
 25337                                  	;;mov	[si+5],ax ; MSDOS 6.0
 25338                                  	;mov	[si+3],ax ; MSDOS 3.3
 25339 0000444C 894405                  	MOV	[SI+FEI.clusnum],AX
 25340                                  	; MSDOS 6.0
 25341 0000444F A1[4803]                	MOV	AX,[LASTENT]		;AN000;FO. save lastentry for search first
 25342                                  	;mov	[si+7],ax
 25343 00004452 894407                  	MOV	[SI+FEI.lastent],AX	;AN000;FO.
 25344 00004455 A1[C205]                	MOV	AX,[DIRSTART]		;AN001;FO. save  for search first
 25345                                  	;mov	[si+9],ax
 25346 00004458 894409                  	MOV	[SI+FEI.dirstart],AX	;AN001;FO.
 25347                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25348 0000445B 89D8                    	MOV	AX,BX
 25349                                  	;;add	di,16  ; MSDOS 3.3
 25350                                  	;add	di,20  ; MSDOS 6.0
 25351 0000445D 83C714                  	ADD	DI,BUFINSIZ		; DS:DI -> start of data in buffer
 25352 00004460 29F8                    	SUB	AX,DI			; AX=BX relative to start of sector
 25353                                  	;mov	cl,32
 25354 00004462 B120                    	MOV	CL,dir_entry.size
 25355 00004464 F6F1                    	DIV	CL
 25356                                  	;MOV	[SI+FEI.dirpos],AL	; save directory entry # in buffer
 25357 00004466 8804                    	mov	[si],al
 25358                                  
 25359 00004468 1E                      	PUSH	DS
 25360 00004469 07                      	POP	ES
 25361                                  
 25362 0000446A 8E1E[E405]              	MOV	DS,[CURBUF+2]
 25363 0000446E 89DF                    	MOV	DI,BX			; DS:DI -> dir entry info
 25364                                  	;cmp	word [di+1Ah],0
 25365 00004470 837D1A00                	CMP	word [DI+dir_entry.dir_first],0 
 25366                                  					; never insert info when file is empty
 25367 00004474 740C                    	JZ	short SKIP_INSERT	; e.g. newly created file
 25368                                  
 25369 00004476 56                      	PUSH	SI			; ES:BX -> extended info
 25370 00004477 5B                      	POP	BX
 25371                                  
 25372                                  	;mov	al,2
 25373 00004478 B002                    	MOV	AL,FONC_insert		; call fastopen insert operation
 25374 0000447A BE[300D]                	MOV	SI,FastOpenTable
 25375                                  	;call	far [es:si+2]	 ; call dword ptr es:[si+2] ; 29/12/2022
 25376                                  	; 07/12/2022
 25377 0000447D 26FF5C02                	CALL	far [ES:SI+fastopen_entry.name_caching]
 25378                                  
 25379 00004481 F8                      	CLC
 25380                                  SKIP_INSERT:
 25381 00004482 58                      	POP	AX
 25382 00004483 59                      	POP	CX			; restore registers
 25383 00004484 5F                      	POP	DI
 25384 00004485 5E                      	POP	SI
 25385 00004486 5B                      	POP	BX
 25386 00004487 07                      	POP	ES
 25387 00004488 1F                      	POP	DS
 25388                                  GET_NEXT2:
 25389                                  	;or	[ss:FastOpenFlg],8
 25390 00004489 36800E[3A0D]08          	OR	byte [SS:FastOpenFlg],No_Lookup
 25391                                  					; we got dir info from fastopen so
 25392                                  GET_NEXT_ELEMENT:
 25393 0000448F 9D                      	POPF
 25394 00004490 C3                      	RETN
 25395                                  
 25396                                  ;============================================================================
 25397                                  ; DEV.ASM (MSDOS 6.0, 1991)
 25398                                  ;============================================================================
 25399                                  ; 17/07/2018 - Retro DOS v3.0
 25400                                  ; 30/04/2019 - Retro DOS v4.0
 25401                                  
 25402                                  ;**	Misc Routines to do 1-12 low level I/O and call devices
 25403                                  
 25404                                  ; Offset 12B8h of IBMDOS.COM (MSDOS 3.3), 1987
 25405                                  
 25406                                  ;DOSCODE:8401h (MSDOS 6.21, MSDOS.SYS)
 25407                                  
 25408                                  ;Public DEV001S, DEV001E 		; Pathgen labels
 25409                                  ;DEV001s:
 25410                                  ;		length of packets
 25411 00004491 160E160D0F0E            LenTab:	 DB	DRDWRHL, DRDNDHL, DRDWRHL, DSTATHL, DFLSHL, DRDNDHL
 25412                                  ;LenTab: db	22,14,22,13,15,14
 25413                                  
 25414                                  ;	Error Function
 25415                                  
 25416                                  CmdTab:
 25417 00004497 8604                    	DB	86h, DEVRD	; 0 input
 25418 00004499 8605                    	DB	86h, DEVRDND	; 1 input status
 25419 0000449B 8708                    	DB	87h, DEVWRT	; 2 output
 25420 0000449D 870A                    	DB	87h, DEVOST	; 3 output status
 25421 0000449F 8607                    	DB	86h, DEVIFL	; 4 input flush
 25422 000044A1 8605                    	DB	86h, DEVRDND	; 5 input status with system WAIT
 25423                                  
 25424                                  ; Offset 12BEh of IBMDOS.COM (MSDOS 3.3), 1987
 25425                                  
 25426                                  ;CmdTab:
 25427                                  ;	db	86h, 4
 25428                                  ;	db	86h, 5
 25429                                  ;	db	87h, 8
 25430                                  ;	db	87h, 10
 25431                                  ;	db	86h, 7
 25432                                  ;	db	86h, 5
 25433                                  
 25434                                  ;DEV001E:
 25435                                  
 25436                                  ; 30/04/2019 - Retro DOS v4.0
 25437                                  ; DOSCODE:8413h (MSDOS 6.21, MSDOS.SYS)
 25438                                  
 25439                                  ;Break	<IOFUNC -- DO FUNCTION 1-12 I/O>
 25440                                  ;----------------------------------------------------------------------------
 25441                                  ;
 25442                                  ; Procedure Name : IOFUNC
 25443                                  ;
 25444                                  ; Inputs:
 25445                                  ;	DS:SI Points to SFT
 25446                                  ;	AH is function code
 25447                                  ;		= 0 Input
 25448                                  ;		= 1 Input Status
 25449                                  ;		= 2 Output
 25450                                  ;		= 3 Output Status
 25451                                  ;		= 4 Flush
 25452                                  ;		= 5 Input Status - System WAIT invoked for K09 if no char
 25453                                  ;				   present.
 25454                                  ;	AL = character if output
 25455                                  ; Function:
 25456                                  ;	Perform indicated I/O to device or file
 25457                                  ; Outputs:
 25458                                  ;	AL is character if input
 25459                                  ;	If a status call
 25460                                  ;		zero set if not ready
 25461                                  ;		zero reset if ready (character in AL for input status)
 25462                                  ; For regular files:
 25463                                  ;	Input Status
 25464                                  ;		Gets character but restores position
 25465                                  ;		Zero set on EOF
 25466                                  ;	Input
 25467                                  ;		Gets character advances position
 25468                                  ;		Returns ^Z on EOF
 25469                                  ;	Output Status
 25470                                  ;		Always ready
 25471                                  ; AX altered, all other registers preserved
 25472                                  ;----------------------------------------------------------------------------
 25473                                  
 25474                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25475                                  ; DOSCODE:83D8h (MSDOS 5.0, MSDOS.SYS)
 25476                                  
 25477                                  IOFUNC:
 25478 000044A3 368C16[8C03]            	MOV	[SS:IOXAD+2],SS		; SS override for IOXAD, IOSCNT, 
 25479                                  					; DEVIOBUF
 25480 000044A8 36C706[8A03][BC03]      	MOV	WORD [SS:IOXAD],DEVIOBUF
 25481 000044AF 36C706[8E03]0100        	MOV	WORD [SS:IOSCNT],1
 25482 000044B6 36A3[BC03]              	MOV	WORD [SS:DEVIOBUF],AX
 25483                                  	;test	byte [si+6],80h
 25484                                  	;TEST	word [SI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
 25485 000044BA F6440680                	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 25486 000044BE 7403                    	JZ	short IOTO22		;AN000;
 25487 000044C0 E9A500                  	JMP	IOTOFILE		;AN000;
 25488                                  IOTO22:
 25489                                  	;test	word [si+5],80h
 25490                                  	;TEST	word [SI+SF_ENTRY.sf_flags],devid_device 
 25491 000044C3 F6440580                	test	byte [SI+SF_ENTRY.sf_flags],devid_device	
 25492 000044C7 7503                    	JNZ	short IOTO33		;AN000;
 25493 000044C9 E99C00                  	JMP	IOTOFILE		;AN000;
 25494                                  IOTO33:
 25495 000044CC 06                      	push	es ; * (MSDOS 6.21)
 25496 000044CD E892BF                  	call	save_world
 25497 000044D0 8CDA                    	MOV	DX,DS
 25498 000044D2 8CD3                    	MOV	BX,SS
 25499 000044D4 8EDB                    	MOV	DS,BX
 25500 000044D6 8EC3                    	MOV	ES,BX
 25501 000044D8 31DB                    	XOR	BX,BX
 25502 000044DA 80FC05                  	cmp	ah,5		    ; system wait enabled?
 25503 000044DD 7503                    	jnz	short _no_sys_wait
 25504                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25505                                  	; 16/12/2022
 25506 000044DF 80CF04                  	or	bh,04h
 25507                                  	;or	bx,0400H	    ; Set bit 10 in status word for driver
 25508                                  				    ; It is up to device driver to carry out
 25509                                  				    ; appropriate action.
 25510                                  _no_sys_wait:
 25511 000044E2 891E[7F03]              	MOV	[IOCALL_REQSTAT],BX
 25512 000044E6 31DB                    	XOR	BX,BX
 25513 000044E8 881E[8903]              	MOV	[IOMED],BL
 25514                                  
 25515 000044EC 88E3                    	MOV	BL,AH		 	; get function
 25516 000044EE 2E8AA7[9144]            	MOV	AH,[cs:BX+LenTab]
 25517 000044F3 D1E3                    	SHL	BX,1
 25518 000044F5 2E8B8F[9744]            	MOV	CX,[cs:BX+CmdTab]
 25519 000044FA BB[7C03]                	MOV	BX,IOCALL ; DOSDATA:037Ch
 25520 000044FD 8826[7C03]              	MOV	[IOCALL_REQLEN],AH
 25521 00004501 882E[7E03]              	MOV	[IOCALL_REQFUNC],CH
 25522                                  
 25523 00004505 8EDA                    	MOV	DS,DX
 25524 00004507 E86B01                  	CALL	DEVIOCALL
 25525 0000450A 368B3E[7F03]            	MOV	DI,[SS:IOCALL_REQSTAT]	; SS override
 25526 0000450F 21FF                    	and	di,di
 25527 00004511 7834                    	js	short DevErr
 25528                                  OKDevIO:
 25529 00004513 8CD0                    	MOV	AX,SS
 25530 00004515 8ED8                    	MOV	DS,AX
 25531                                  
 25532                                  	;cmp	ch,5
 25533 00004517 80FD05                  	CMP	CH,DEVRDND
 25534 0000451A 7506                    	JNZ	short DNODRD
 25535 0000451C A0[8903]                	MOV	AL,[IORCHR]
 25536 0000451F A2[BC03]                	MOV	[DEVIOBUF],AL
 25537                                  
 25538                                  DNODRD: 
 25539 00004522 8A26[8003]              	MOV	AH,[IOCALL_REQSTAT+1]
 25540 00004526 F6D4                    	NOT	AH			; Zero = busy, not zero = ready
 25541                                  	;and	ah,2
 25542 00004528 80E402                  	AND	AH,STBUI>>8
 25543                                  
 25544                                  QuickReturn:				;AN000; 2/13/KK
 25545 0000452B E81DBF                  	call	restore_world
 25546 0000452E 07                      	pop	es ; * (MSDOS 6.21)
 25547                                  
 25548                                  	; SR;
 25549                                  	; We return ax = -1 if the user failed on I24. This is the case if 
 25550                                  	; IoStatFail = -1 (set after return from the I24)
 25551                                  
 25552                                  	; MSDOS 6.0
 25553 0000452F 9C                      	pushf
 25554 00004530 36A0[8300]              	mov	al,[ss:IoStatFail]	;assume fail error
 25555 00004534 98                      	cbw				;sign extend to word
 25556 00004535 83F8FF                  	cmp	ax,-1
 25557 00004538 7507                    	jne	short not_fail_ret
 25558 0000453A 36FE06[8300]            	inc	byte [ss:IoStatFail]
 25559 0000453F 9D                      	popf
 25560 00004540 C3                      	retn
 25561                                  
 25562                                  not_fail_ret:
 25563 00004541 36A1[BC03]              	mov	ax,[ss:DEVIOBUF]	;ss override
 25564 00004545 9D                      	popf
 25565 00004546 C3                      	retn
 25566                                  
 25567                                  DevErr:
 25568 00004547 88CC                    	MOV	AH,CL
 25569 00004549 E88E0D                  	call	CHARHARD
 25570 0000454C 3C01                    	CMP	AL,1
 25571 0000454E 7507                    	JNZ	short NO_RETRY
 25572 00004550 E8F8BE                  	call	restore_world
 25573                                  	; 12/05/2019
 25574 00004553 07                      	pop	es ; * (MSDOS 6.21)		
 25575 00004554 E94CFF                  	JMP	IOFUNC	; 10/08/2018
 25576                                  
 25577                                  NO_RETRY:
 25578                                  	; Know user must have wanted Ignore OR Fail. Make sure device shows ready
 25579                                  	; ready so that DOS doesn't get caught in a status loop when user 
 25580                                  	; simply wants to ignore the error.
 25581                                  	;
 25582                                  	; SR; If fail wanted by user set ax to special value (ax = -1). This 
 25583                                  	; should be checked by the caller on return
 25584                                  
 25585                                  					; SS override
 25586 00004557 368026[8003]FD          	and	byte [SS:IOCALL_REQSTAT+1],0FDh
 25587                                  	;AND	BYTE [SS:IOCALL_REQSTAT+1],~(STBUI>>8)
 25588                                  
 25589                                  	; SR;
 25590                                  	; Check if user failed
 25591                                  
 25592                                  	; MSDOS 6.0
 25593 0000455D 3C03                    	cmp	al,3
 25594 0000455F 7505                    	jnz	short not_fail
 25595 00004561 36FE0E[8300]            	dec	byte [ss:IoStatFail]	;set flag indicating fail on I24
 25596                                  not_fail:
 25597 00004566 EBAB                    	JMP	short OKDevIO
 25598                                  
 25599                                  IOTOFILE:
 25600 00004568 08E4                    	OR	AH,AH
 25601 0000456A 7421                    	JZ	short IOIN
 25602 0000456C FECC                    	DEC	AH
 25603 0000456E 7405                    	JZ	short IOIST
 25604 00004570 FECC                    	DEC	AH
 25605 00004572 7411                    	JZ	short IOUT
 25606                                  IOUT_retn:	; 18/12/2022
 25607 00004574 C3                      	retn				; NON ZERO FLAG FOR OUTPUT STATUS
 25608                                  IOIST:
 25609                                  	;push	word [si+15h]
 25610 00004575 FF7415                  	PUSH	WORD [SI+SF_ENTRY.sf_position]   ; Save position
 25611                                  	;push	word [si+17h]
 25612 00004578 FF7417                  	PUSH	WORD [SI+SF_ENTRY.sf_position+2]
 25613 0000457B E80F00                  	CALL	IOIN
 25614                                  	;pop	word [si+17h]
 25615 0000457E 8F4417                  	POP	WORD [SI+SF_ENTRY.sf_position+2] ; Restore position
 25616                                  	;pop	word [si+15h]
 25617 00004581 8F4415                  	POP	WORD [SI+SF_ENTRY.sf_position]
 25618 00004584 C3                      	retn
 25619                                  IOUT:
 25620 00004585 E82500                  	CALL	SETXADDR
 25621 00004588 E880EF                  	call	DOS_WRITE
 25622                                  	;CALL	RESTXADDR	; If you change this into a jmp don't
 25623                                  	; 18/12/2022
 25624 0000458B EB52                    	jmp	RESTXADDR
 25625                                  ;IOUT_retn:
 25626                                  	;retn			; come crying to me when things don't
 25627                                  				; work ARR
 25628                                  IOIN:
 25629 0000458D E81D00                  	CALL	SETXADDR
 25630                                  					; SS override for DOS34_FLAG
 25631                                  	;OR	word [SS:DOS34_FLAG],Disable_EOF_I24	;AN000;
 25632                                  	;or	word [ss:DOS34_FLAG],40h
 25633                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25634                                  	; 16/12/2022
 25635 00004590 36800E[1106]40          	or	byte [ss:DOS34_FLAG],40h 
 25636 00004596 E849ED                  	CALL	DOS_READ
 25637                                  	;AND	word [SS:DOS34_FLAG],NO_Disable_EOF_I24 ;AN000;
 25638                                  	;and	word [SS:DOS34_FLAG],0FFBFh
 25639                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25640                                  	; 16/12/2022
 25641 00004599 368026[1106]BF          	and	byte [SS:DOS34_FLAG],0BFh ; 07/12/2022
 25642 0000459F 09C9                    	OR	CX,CX			; Check EOF
 25643 000045A1 E83B00                  	CALL	RESTXADDR
 25644                                  					; SS override
 25645 000045A4 36A0[BC03]              	MOV	AL,[SS:DEVIOBUF]	; Get byte from trans addr
 25646 000045A8 75CA                    	jnz	short IOUT_retn	
 25647 000045AA B01A                    	MOV	AL,1AH			; ^Z if no bytes
 25648 000045AC C3                      	retn
 25649                                  
 25650                                  SETXADDR:
 25651                                  					; SS override
 25652 000045AD 368F06[6C03]            	POP	WORD [SS:CALLSCNT]	; Return address
 25653                                  
 25654 000045B2 06                      	push	es ; * (MSDOS 6.21)
 25655                                  
 25656 000045B3 E8ACBE                  	call	save_world
 25657                                  					; SS override for DMAADD and THISSFT
 25658                                  	; 24/09/2023
 25659                                  	;PUSH	WORD [SS:DMAADD]	; Save Disk trans addr
 25660                                  	;PUSH	WORD [SS:DMAADD+2]
 25661 000045B6 368C1E[A005]            	MOV	[SS:THISSFT+2],DS
 25662                                  
 25663 000045BB 16                      	push	ss
 25664 000045BC 1F                      	pop	ds
 25665                                  
 25666                                  	; 24/09/2023
 25667 000045BD FF36[2C03]              	push	word [DMAADD]
 25668 000045C1 FF36[2E03]              	push	word [DMAADD+2]
 25669                                  
 25670 000045C5 8936[9E05]              	MOV	[THISSFT],SI		; Finish setting SFT pointer
 25671 000045C9 8B0E[8C03]              	MOV	CX,[IOXAD+2]
 25672 000045CD 890E[2E03]              	MOV	[DMAADD+2],CX
 25673 000045D1 8B0E[8A03]              	MOV	CX,[IOXAD]
 25674 000045D5 890E[2C03]              	MOV	[DMAADD],CX		; Set byte trans addr
 25675 000045D9 8B0E[8E03]              	MOV	CX,[IOSCNT]		; ioscnt specifies length of buffer
 25676 000045DD EB10                    	JMP	SHORT RESTRET		; RETURN ADDRESS
 25677                                  
 25678                                  RESTXADDR:
 25679 000045DF 8F06[6C03]              	POP	WORD [CALLSCNT]		; Return address
 25680 000045E3 8F06[2E03]              	POP	WORD [DMAADD+2]		; Restore Disk trans addr
 25681 000045E7 8F06[2C03]              	POP	WORD [DMAADD]
 25682                                  
 25683 000045EB E85DBE                  	call	restore_world
 25684                                  
 25685 000045EE 07                      	pop	es ; * (MSDOS 6.21)
 25686                                  					; SS override
 25687                                  RESTRET:
 25688 000045EF 36FF26[6C03]            	JMP	WORD [SS:CALLSCNT]	; Return address
 25689                                  
 25690                                  ; DOSCODE:8569h (MSDOS 6.21, MSDOS.SYS)
 25691                                  ; 21/11/2022
 25692                                  ; DOSCODE:852Eh (MSDOS 5.0, MSDOS.SYS)
 25693                                  
 25694                                  ;Break <DEV_OPEN_SFT, DEV_CLOSE_SFT - OPEN or CLOSE A DEVICE>
 25695                                  
 25696                                  ;----------------------------------------------------------------------------
 25697                                  ;**	Dev_Open_SFT - Open the Device for an SFT
 25698                                  ;
 25699                                  ;	Dev_Open_SFT issues an open call to the device associated with
 25700                                  ;	the SFT.
 25701                                  ;
 25702                                  ;	ENTRY	(ES:DI) = SFT
 25703                                  ;	EXIT	none
 25704                                  ;	USES	all
 25705                                  ;----------------------------------------------------------------------------
 25706                                  
 25707                                  DEV_OPEN_SFT:
 25708 000045F4 06                      	push	es ; * (MSDOS 6.21)
 25709 000045F5 E86ABE                  	call	save_world
 25710                                  	;mov	al,0Dh	
 25711 000045F8 B00D                    	MOV	AL,DEVOPN
 25712 000045FA EB06                    	JMP	SHORT DO_OPCLS
 25713                                  
 25714                                  ;----------------------------------------------------------------------------
 25715                                  ; Procedure Name : DEV_CLOSE_SFT
 25716                                  ;
 25717                                  ; Inputs:
 25718                                  ;	ES:DI Points to SFT
 25719                                  ; Function:
 25720                                  ;	Issue a CLOSE call to the correct device
 25721                                  ; Outputs:
 25722                                  ;	None
 25723                                  ; ALL preserved
 25724                                  ;----------------------------------------------------------------------------
 25725                                  
 25726                                  DEV_CLOSE_SFT:
 25727 000045FC 06                      	push	es ; * (MSDOS 6.21)
 25728 000045FD E862BE                  	call	save_world
 25729                                  	;mov	al,0Eh	
 25730 00004600 B00E                    	MOV	AL,DEVCLS
 25731                                  
 25732                                  	; Main entry for device open and close. AL contains the function 
 25733                                  	; requested. Subtlety: if Sharing is NOT loaded then we do NOT issue 
 25734                                  	; open/close to block devices. This allows networks to function but 
 25735                                  	; does NOT hang up with bogus change-line code.
 25736                                  
 25737                                  	;entry	DO_OPCLS
 25738                                  DO_OPCLS:
 25739                                  	; Is the SFT for the net? If so, no action necessary.
 25740                                  
 25741                                  	; MSDOS 6.0
 25742                                  	;test	word [es:di+5],8000h
 25743                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 25744 00004602 26F6450680              	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 25745 00004607 7567                    	jnz	short OPCLS_DONE	; NOP on net SFTs
 25746 00004609 30E4                    	XOR	AH,AH			; Unit
 25747                                  	;test	byte [es:di+5],80h
 25748 0000460B 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 25749                                  	;les	di,[es:di+7]
 25750 00004610 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get DPB or device
 25751 00004614 7513                    	JNZ	short GOT_DEV_ADDR
 25752                                  
 25753                                  	; We are about to call device open/close on a block driver. If no 
 25754                                  	; sharing then just short circuit to done.
 25755                                  	
 25756                                  	; MSDOS 6.0
 25757                                  					; SS override
 25758 00004616 36803E[0303]01          	CMP	byte [ss:fShare],1	;AN010; /NC or no SHARE
 25759 0000461C 7652                    	JBE	short OPCLS_DONE	;AN010; yes
 25760                                  
 25761                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25762                                  	;mov	ah,[es:di+1]
 25763 0000461E 268A6501                	MOV	AH,[ES:DI+DPB.UNIT]	; (ah) = unit
 25764 00004622 268A0D                  	mov	cl,[es:di]
 25765                                  	;MOV	CL,[ES:DI+DPB.DRIVE]	; (cl) = drive
 25766                                  	;;les	di,[es:di+12h] ; MSDOS 3.3
 25767                                  	;les	di,[es:di+13h] ; MSDOS 6.0
 25768 00004625 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Get device
 25769                                  GOT_DEV_ADDR:				; ES:DI -> device
 25770                                  	;test	word [es:di+4],800h
 25771                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL
 25772 00004629 26F6450508              	test	byte [ES:DI+SYSDEV.ATT+1],(DEVOPCL>>8)
 25773 0000462E 7440                    	JZ	short OPCLS_DONE	; Device can't
 25774 00004630 06                      	PUSH	ES
 25775 00004631 1F                      	POP	DS
 25776 00004632 89FE                    	MOV	SI,DI			; DS:SI -> device
 25777                                  
 25778                                  OPCLS_RETRY:
 25779                                  	;Context ES
 25780 00004634 16                      	push	ss
 25781 00004635 07                      	pop	es
 25782                                  					; DEVCALL is in DOSDATA
 25783 00004636 BF[5A03]                	MOV	DI,DEVCALL
 25784                                  
 25785 00004639 89FB                    	MOV	BX,DI
 25786 0000463B 50                      	PUSH	AX
 25787                                  	;mov	al,13
 25788 0000463C B00D                    	MOV	AL,DOPCLHL
 25789 0000463E AA                      	STOSB				; Length
 25790 0000463F 58                      	POP	AX
 25791 00004640 86E0                    	XCHG	AH,AL
 25792 00004642 AA                      	STOSB				; Unit
 25793 00004643 86E0                    	XCHG	AH,AL
 25794 00004645 AA                      	STOSB				; Command
 25795 00004646 26C7050000              	MOV	WORD [ES:DI],0		; Status
 25796 0000464B 50                      	PUSH	AX			; Save Unit,Command
 25797                                  	;invoke	DEVIOCALL2
 25798 0000464C E82900                  	call	DEVIOCALL2
 25799                                  
 25800                                  	;mov	di,[es:bx+3]
 25801 0000464F 268B7F03                	MOV	DI,[ES:BX+SRHEAD.REQSTAT]
 25802                                  	;test	di,8000h
 25803                                  	;jz	short OPCLS_DONEP	
 25804 00004653 21FF                    	and	di,di
 25805 00004655 7918                    	jns	short OPCLS_DONEP	; No error
 25806                                  	; 21/11/2022
 25807                                  	;test	word [si+4],8000h
 25808                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP
 25809                                  	;test	word [si+5],80h
 25810 00004657 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
 25811 0000465B 7404                    	JZ	short BLKDEV
 25812 0000465D B486                    	MOV	AH,86H			; Read error in data, Char dev
 25813 0000465F EB04                    	JMP	SHORT HRDERR
 25814                                  BLKDEV:
 25815 00004661 88C8                    	MOV	AL,CL			; Drive # in AL
 25816 00004663 B406                    	MOV	AH,6			; Read error in data, Blk dev
 25817                                  HRDERR:
 25818                                  	;invoke	CHARHARD
 25819 00004665 E8720C                  	call	CHARHARD
 25820 00004668 3C01                    	cmp	al,1
 25821 0000466A 7503                    	jne	short OPCLS_DONEP	; IGNORE or FAIL
 25822                                  					;  Note that FAIL is essentually IGNORED
 25823 0000466C 58                      	POP	AX			; Get back Unit, Command
 25824 0000466D EBC5                    	JMP	short OPCLS_RETRY
 25825                                  OPCLS_DONEP:
 25826 0000466F 58                      	POP	AX			; Clean stack
 25827                                  OPCLS_DONE:
 25828 00004670 E8D8BD                  	call	restore_world
 25829 00004673 07                      	pop	es ; * (MSDOS 6.21)
 25830 00004674 C3                      	retn
 25831                                  
 25832                                  ; 30/04/2019 - Retro DOS v4.0
 25833                                  ; DOSCODE:85EAh (MSDOS 6.21, MSDOS.SYS)
 25834                                  
 25835                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25836                                  ; DOSCODE:85AFh (MSDOS 5.0, MSDOS.SYS)
 25837                                  
 25838                                  ;Break	<DEVIOCALL, DEVIOCALL2 - CALL A DEVICE>
 25839                                  ;----------------------------------------------------------------------------
 25840                                  ;**	DevIoCall  - Call Device
 25841                                  ;
 25842                                  ;	ENTRY	DS:SI Points to device SFT
 25843                                  ;		ES:BX Points to request data
 25844                                  ;	EXIT	DS:SI -> Device driver
 25845                                  ;	USES	DS:SI,AX
 25846                                  ;----------------------------------------------------------------------------
 25847                                  ;**	DevIoCall2 - Call Device
 25848                                  ;
 25849                                  ;	ENTRY	DS:SI Points to DPB
 25850                                  ;		ES:BX Points to request data
 25851                                  ;	EXIT	DS:SI -> Device driver
 25852                                  ;	USES	DS:SI,AX
 25853                                  ;----------------------------------------------------------------------------
 25854                                  
 25855                                  DEVIOCALL:
 25856                                  					; SS override for CALLSSEC, 
 25857                                  	;lds	si,[si+7]		; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
 25858 00004675 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 25859                                  
 25860                                  	;entry	DEVIOCALL2
 25861                                  DEVIOCALL2:
 25862                                  	;EnterCrit critDevice
 25863 00004678 E8C7CC                  	call	ECritDevice
 25864                                  
 25865                                  	; MSDOS 6.0
 25866                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP ;AN000; >32mb block device ?
 25867                                  	;test	byte [si+5],80h
 25868 0000467B F6440580                	test	byte [si+SYSDEV.ATT+1],(DEVTYP>>8)
 25869 0000467F 7548                    	jnz	short chardev2		;AN000; >32mb no
 25870                                  
 25871                                  	; 16/12/2022
 25872                                  	; 22/11/2022
 25873 00004681 268A4702                	mov	al,[ES:BX+SRHEAD.REQFUNC] ; [es:bx+2]
 25874 00004685 3C04                    	cmp	al,DEVRD	; 4
 25875 00004687 7408                    	je	short chkext	
 25876 00004689 3C08                    	cmp	al,DEVWRT	; 8
 25877 0000468B 7404                    	je	short chkext
 25878 0000468D 3C09                    	cmp	al,DEVWRTV	; 9
 25879 0000468F 7538                    	jne	short chardev2
 25880                                  
 25881                                  	; 16/12/2022
 25882                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25883                                  	;;cmp	byte [es:bx+2],4
 25884                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVRD  ;AN000; >32mb read ?
 25885                                  	;JZ	short chkext		;AN000; >32mb   yes
 25886                                  	;;cmp	byte [es:bx+2],8
 25887                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRT ;AN000; >32mb write ?
 25888                                  	;JZ	short chkext		;AN000; >32mb   yes
 25889                                  	;;cmp	byte [es:bx+2],9
 25890                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRTV
 25891                                  	;				;AN000; >32mb write/verify ?
 25892                                  	;JNZ	short chardev2		;AN000; >32mb no
 25893                                  chkext:
 25894 00004691 E89900                  	CALL	RW_SC			;AN000;LB. use secondary cache if there
 25895 00004694 7255                    	JC	short dev_exit		;AN000;LB. done
 25896                                  
 25897                                  	;test	byte [si+4],2
 25898 00004696 F6440402                	TEST	byte [SI+SYSDEV.ATT],EXTDRVR ;AN000;>32mb extended driver?
 25899 0000469A 741D                    	JZ	short chksector		;AN000;>32mb   no
 25900 0000469C 26800708                	ADD	BYTE [ES:BX],8		;AN000;>32mb   make length to 30
 25901 000046A0 36A1[6E03]              	MOV	AX,[SS:CALLSSEC]	;AN000;>32mb
 25902 000046A4 36C706[6E03]FFFF        	MOV	word [SS:CALLSSEC],-1	;AN000;>32mb   old sector  =-1
 25903 000046AB 36A3[7403]              	MOV	[SS:CALLNEWSC],AX	;AN000;>32mb   new sector  =
 25904 000046AF 36A1[0706]              	MOV	AX,[SS:HIGH_SECTOR]	;AN000; >32mb  low sector,high sector
 25905 000046B3 36A3[7603]              	MOV	[SS:CALLNEWSC+2],AX	;AN000; >32mb
 25906 000046B7 EB10                    	JMP	short chardev2		;AN000; >32mb
 25907                                  chksector:				;AN000; >32mb
 25908 000046B9 36833E[0706]00          	CMP	word [SS:HIGH_SECTOR],0	;AN000; >32mb   if >32mb
 25909 000046BF 7408                    	JZ	short chardev2		;AN000; >32mb   then fake error
 25910                                  	;mov	word [es:bx+3],8107h
 25911 000046C1 26C747030781            	MOV	word [ES:BX+SRHEAD.REQSTAT],STERR+STDON+error_I24_not_DOS_disk 
 25912                                  					;AN000; >32mb
 25913 000046C7 EB22                    	JMP	SHORT dev_exit		;AN000; >32mb
 25914                                  
 25915                                  chardev2:				;AN000;
 25916                                  	; As above only DS:SI points to device header on entry, and DS:SI is 
 25917                                  	; preserved
 25918                                  
 25919                                  	;mov	ax,[si+6]
 25920 000046C9 8B4406                  	MOV	AX,[SI+SYSDEV.STRAT]
 25921 000046CC 36A3[7803]              	MOV	[SS:CALLDEVAD],AX
 25922 000046D0 368C1E[7A03]            	MOV	[SS:CALLDEVAD+2],DS
 25923 000046D5 36FF1E[7803]            	CALL	far [SS:CALLDEVAD]
 25924                                  
 25925                                  	;mov	ax,[si+8]
 25926 000046DA 8B4408                  	MOV	AX,[SI+SYSDEV.INT]
 25927 000046DD 36A3[7803]              	MOV	[SS:CALLDEVAD],AX
 25928 000046E1 36FF1E[7803]            	CALL	far [SS:CALLDEVAD]
 25929                                  
 25930                                  	; MSDOS 6.0
 25931 000046E6 E83A01                  	CALL	VIRREAD 		;AN000;LB. move data from SC to buffer
 25932 000046E9 72DE                    	JC	short chardev2		;AN000;LB. bad sector or exceeds max sec
 25933                                  
 25934                                  dev_exit:
 25935                                  	;LeaveCrit critDevice
 25936                                  	;call	LCritDevice
 25937                                  	;retn
 25938                                  	; 18/12/2022
 25939 000046EB E96FCC                  	jmp	LCritDevice
 25940                                  
 25941                                  ; DOSCODE:8669h (MSDOS 6.21, MSDOS.SYS)
 25942                                  ; 22/11/2022
 25943                                  ; DOSCODE:862Eh (MSDOS 5.0, MSDOS.SYS)
 25944                                  
 25945                                  ;Break	<SETREAD, SETWRITE -- SET UP HEADER BLOCK>
 25946                                  ;---------------------------------------------------------------------------
 25947                                  ;
 25948                                  ; Procedure Name : SETREAD, SETWRITE
 25949                                  ;
 25950                                  ; Inputs:
 25951                                  ;	DS:BX = Transfer Address
 25952                                  ;	CX = Record Count
 25953                                  ;	DX = Starting Record
 25954                                  ;	AH = Media Byte
 25955                                  ;	AL = Unit Code
 25956                                  ; Function:
 25957                                  ;	Set up the device call header at DEVCALL
 25958                                  ; Output:
 25959                                  ;	ES:BX Points to DEVCALL
 25960                                  ; No other registers effected
 25961                                  ;
 25962                                  ;---------------------------------------------------------------------------
 25963                                  
 25964                                  SETREAD:
 25965 000046EE 57                      	PUSH	DI
 25966 000046EF 51                      	PUSH	CX
 25967 000046F0 50                      	PUSH	AX
 25968 000046F1 B104                    	MOV	CL,DEVRD ; mov cl,4
 25969                                  SETCALLHEAD:
 25970 000046F3 B016                    	MOV	AL,DRDWRHL ; mov al,16h
 25971 000046F5 16                      	PUSH	SS
 25972 000046F6 07                      	POP	ES
 25973                                  					; DEVCALL is in DOSDATA
 25974 000046F7 BF[5A03]                	MOV	DI,DEVCALL
 25975                                  
 25976 000046FA AA                      	STOSB				; length
 25977 000046FB 58                      	POP	AX			; 
 25978 000046FC AA                      	STOSB				; Unit
 25979 000046FD 50                      	PUSH	AX
 25980 000046FE 88C8                    	MOV	AL,CL
 25981 00004700 AA                      	STOSB				; Command code
 25982 00004701 31C0                    	XOR	AX,AX
 25983 00004703 AB                      	STOSW				; Status
 25984 00004704 83C708                  	ADD	DI,8			; Skip link fields
 25985 00004707 58                      	POP	AX
 25986 00004708 86E0                    	XCHG	AH,AL
 25987 0000470A AA                      	STOSB				; Media byte
 25988 0000470B 86C4                    	XCHG	AL,AH
 25989 0000470D 50                      	PUSH	AX
 25990 0000470E 89D8                    	MOV	AX,BX
 25991 00004710 AB                      	STOSW
 25992                                  
 25993 00004711 8CD8                    	MOV	AX,DS
 25994 00004713 AB                      	STOSW				; Transfer addr
 25995                                  
 25996 00004714 59                      	POP	CX			; Real AX
 25997 00004715 58                      	POP	AX			; Real CX
 25998 00004716 AB                      	STOSW				; Count
 25999                                  
 26000 00004717 92                      	XCHG	AX,DX			; AX=Real DX, DX=real CX, CX=real AX
 26001 00004718 AB                      	STOSW				; Start
 26002 00004719 91                      	XCHG	AX,CX
 26003 0000471A 87D1                    	XCHG	DX,CX
 26004 0000471C 5F                      	POP	DI
 26005                                  					; DEVCALL is in DOSDATA
 26006 0000471D BB[5A03]                	MOV	BX,DEVCALL
 26007 00004720 C3                      	retn
 26008                                  
 26009                                  	;entry	SETWRITE
 26010                                  SETWRITE:
 26011                                  
 26012                                  ; Inputs:
 26013                                  ;	DS:BX = Transfer Address
 26014                                  ;	CX = Record Count
 26015                                  ;	DX = Starting Record
 26016                                  ;	AH = Media Byte
 26017                                  ;	AL = Unit Code
 26018                                  ; Function:
 26019                                  ;	Set up the device call header at DEVCALL
 26020                                  ; Output:
 26021                                  ;	ES:BX Points to DEVCALL
 26022                                  ; No other registers effected
 26023                                  
 26024 00004721 57                      	PUSH	DI
 26025 00004722 51                      	PUSH	CX
 26026 00004723 50                      	PUSH	AX
 26027 00004724 B108                    	MOV	CL,DEVWRT ; mov cl,8
 26028 00004726 36020E[FF02]            	ADD	CL,[SS:VERFLG]		; SS override
 26029 0000472B EBC6                    	JMP	SHORT SETCALLHEAD
 26030                                  
 26031                                  ; 30/04/2019 - Retro DOS v4.0
 26032                                  ; DOSCODE:86A8h (MSDOS 6.21, MSDOS.SYS)
 26033                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26034                                  ; DOSCODE:866Dh (MSDOS 5.0, MSDOS.SYS)
 26035                                  
 26036                                  ;Break	<RW_SC -- Read Write Secondary Cache>
 26037                                  ;---------------------------------------------------------------------------
 26038                                  ;
 26039                                  ; Procedure Name : RW_SC
 26040                                  ;
 26041                                  ; Inputs:
 26042                                  ;	 [SC_CACHE_COUNT]= secondary cache count
 26043                                  ;	 [SC_STATUS]= SC validity status
 26044                                  ;	 [SEQ_SECTOR]= last sector read
 26045                                  ; Function:
 26046                                  ;	Read from or write through secondary cache
 26047                                  ; Output:
 26048                                  ;	ES:BX Points to DEVCALL
 26049                                  ;	carry clear, I/O is not done
 26050                                  ;		     [SC_FLAG]=1 if continuos sectors will be read
 26051                                  ;	carry set, I/O is done
 26052                                  ;
 26053                                  ;----------------------------------------------------------------------------
 26054                                  
 26055                                  RW_SC:
 26056                                  	; SS override for all variables used.
 26057                                  	
 26058 0000472D 36833E[7700]00          	CMP	word [ss:SC_CACHE_COUNT],0  ;AN000;LB. secondary cache exists?
 26059 00004733 7421                    	JZ	short scexit4		    ;AN000;LB. no, do nothing
 26060 00004735 36833E[6C03]01          	CMP	word [ss:CALLSCNT],1	    ;AN000;LB. sector count = 1 (buffer I/O)
 26061 0000473B 7519                    	JNZ	short scexit4 		    ;AN000;LB. no, do nothing
 26062 0000473D 51                      	PUSH	CX			    ;AN000;LB.
 26063 0000473E 52                      	PUSH	DX			    ;AN000;LB. yes
 26064 0000473F 1E                      	PUSH	DS			    ;AN000;LB. save registers
 26065 00004740 56                      	PUSH	SI			    ;AN000;LB.
 26066 00004741 06                      	PUSH	ES			    ;AN000;LB.
 26067 00004742 57                      	PUSH	DI			    ;AN000;LB.
 26068                                  
 26069 00004743 368B16[6E03]            	MOV	DX,[ss:CALLSSEC]	    ;AN000;LB. starting sector
 26070 00004748 36803E[5C03]04          	CMP	BYTE [ss:DEVCALL_REQFUNC],DEVRD ;AN000;LB. read ?
 26071 0000474E 7408                    	JZ	short doread		    ;AN000;LB. yes
 26072 00004750 E8BE00                  	CALL	INVALIDATE_SC		    ;AN000;LB. invalidate SC
 26073 00004753 E98B00                  	JMP	scexit2 		    ;AN000;LB. back to normal
 26074                                  scexit4:				    ;AN000;
 26075 00004756 F8                      	CLC				    ;AN000;LB. I/O not done yet
 26076 00004757 C3                      	retn				    ;AN000;LB.
 26077                                  doread: 				    ;AN000;
 26078 00004758 E82001                  	CALL	SC2BUF			    ;AN000;LB. check if in SC
 26079 0000475B 720A                    	JC	short readSC		    ;AN000;LB.
 26080 0000475D 36C706[5D03]0001        	MOV	word [ss:DEVCALL_REQSTAT],STDON ;AN000;LB. fake done and ok
 26081 00004764 F9                      	STC				    ;AN000;LB. set carry
 26082 00004765 EB68                    	JMP	short saveseq 		    ;AN000;LB. save seq. sector #
 26083                                  readSC: 				    ;AN000;
 26084 00004767 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]   	    ;AN000;LB. subtract sector num from
 26085 0000476B 368B0E[6E03]            	MOV	CX,[ss:CALLSSEC]	    ;AN000;LB. saved sequential sector
 26086 00004770 362B0E[A90D]            	SUB	CX,[ss:SEQ_SECTOR]    	    ;AN000;LB. number
 26087 00004775 361B06[AB0D]            	SBB	AX,[ss:SEQ_SECTOR+2]  	    ;AN000;LB.
 26088                                  	; 24/09/2023
 26089                                  	;CMP	AX,0			    ;AN000;LB. greater than 64K
 26090 0000477A 7552                    	JNZ	short saveseq2		    ;AN000;LB. yes,save seq. sector #
 26091                                  chklow: 						
 26092 0000477C 83F901                  	CMP	CX,1			    ;AN000;LB. <= 1
 26093 0000477F 774D                    	JA	short saveseq2		    ;AN000;LB. no, not sequential
 26094 00004781 36C706[B50D]FFFF        	MOV	word [ss:SC_STATUS],-1	    ;AN000;LB. presume all SC valid
 26095 00004788 36A1[7700]              	MOV	AX,[ss:SC_CACHE_COUNT]	    ;AN000;LB. yes, sequential
 26096 0000478C 36A3[6C03]              	MOV	[ss:CALLSCNT],AX	    ;AN000;LB. read continuous sectors
 26097                                  readsr:
 26098 00004790 36A1[6A03]              	MOV	AX,[ss:CALLXAD+2]	    ;AN000;LB. save buffer addr
 26099 00004794 36A3[0E06]              	MOV	[ss:TEMP_VAR2],AX	    ;AN000;LB. in temp vars
 26100 00004798 36A1[6803]              	MOV	AX,[ss:CALLXAD]	    	    ;AN000;LB.
 26101 0000479C 36A3[0C06]              	MOV	[ss:TEMP_VAR],AX	    ;AN000;LB.
 26102                                  
 26103 000047A0 36A1[7300]              	MOV	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. use SC cache addr as
 26104 000047A4 36A3[6803]              	MOV	[ss:CALLXAD],AX		    ;AN000;LB. transfer addr
 26105 000047A8 36A1[7500]              	MOV	AX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
 26106 000047AC 36A3[6A03]              	MOV	[ss:CALLXAD+2],AX	    ;AN000;LB.
 26107 000047B0 36C606[B70D]01          	MOV	byte [ss:SC_FLAG],1	    ;AN000;LB. flag it for later;
 26108 000047B6 36A0[AF0D]              	MOV	AL,[ss:SC_DRIVE]	    ;AN000;LB. current drive
 26109 000047BA 36A2[B00D]              	MOV	[ss:CurSC_DRIVE],AL	    ;AN000;LB. set current drive
 26110 000047BE 36A1[6E03]              	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB. current sector
 26111 000047C2 36A3[B10D]              	MOV	[ss:CurSC_SECTOR],AX	    ;AN000;LB. set current sector
 26112 000047C6 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB.
 26113 000047CA 36A3[B30D]              	MOV	[ss:CurSC_SECTOR+2],AX	    ;AN000;LB.
 26114                                  saveseq2:				    ;AN000;
 26115 000047CE F8                      	CLC				    ;AN000;LB. clear carry
 26116                                  saveseq:				    ;AN000;	
 26117 000047CF 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB. save current sector #
 26118 000047D3 36A3[AB0D]              	MOV	[ss:SEQ_SECTOR+2],AX	    ;AN000;LB. for access mode ref.
 26119 000047D7 36A1[6E03]              	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB.	
 26120 000047DB 36A3[A90D]              	MOV	[ss:SEQ_SECTOR],AX 	    ;AN000;LB.	
 26121 000047DF EB01                    	JMP	short scexit 		    ;AN000;LB.	
 26122                                  scexit2:				    ;AN000;LB.
 26123 000047E1 F8                      	CLC				    ;AN000;LB.	clear carry
 26124                                  scexit: 				    ;AN000;		
 26125 000047E2 5F                      	POP	DI			    ;AN000;LB.
 26126 000047E3 07                      	POP	ES			    ;AN000;LB. restore registers
 26127 000047E4 5E                      	POP	SI			    ;AN000;LB.
 26128 000047E5 1F                      	POP	DS			    ;AN000;LB.
 26129 000047E6 5A                      	POP	DX			    ;AN000;LB.
 26130 000047E7 59                      	POP	CX			    ;AN000;LB.
 26131 000047E8 C3                      	retn				    ;AN000;LB.
 26132                                  
 26133                                  ;Break	<IN_SC -- check if in secondary cache>
 26134                                  ;--------------------------------------------------------------------------
 26135                                  ;
 26136                                  ; Procedure Name : IN_SC
 26137                                  ;
 26138                                  ; Inputs:  [SC_DRIVE]= requesting drive
 26139                                  ;	   [CURSC_DRIVE]= current SC drive
 26140                                  ;	   [CURSC_SECTOR]= starting scetor # of SC
 26141                                  ;	   [SC_CACHE_COUNT]= SC count
 26142                                  ;	   [HIGH_SECTOR]:DX= sector number
 26143                                  ; Function:
 26144                                  ;	Check if the sector is in secondary cache
 26145                                  ; Output:
 26146                                  ;	carry clear, in SC
 26147                                  ;	   CX= the index in the secondary cache
 26148                                  ;	carry set, not in SC
 26149                                  ;
 26150                                  ;---------------------------------------------------------------------------
 26151                                  
 26152                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26153                                  IN_SC:
 26154                                  	; SS override for all variables used
 26155 000047E9 36A0[AF0D]              	MOV	AL,[ss:SC_DRIVE]	    ;AN000;;LB. current drive
 26156 000047ED 363A06[B00D]            	CMP	AL,[ss:CurSC_DRIVE]	    ;AN000;;LB. same as SC drive
 26157 000047F2 751B                    	JNZ	short outrange2		    ;AN000;;LB. no
 26158 000047F4 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;;LB. subtract sector num from
 26159 000047F8 89D1                    	MOV	CX,DX			    ;AN000;;LB. secondary starting sector
 26160 000047FA 362B0E[B10D]            	SUB	CX,[ss:CurSC_SECTOR]        ;AN000;;LB. number
 26161 000047FF 361B06[B30D]            	SBB	AX,[ss:CurSC_SECTOR+2]      ;AN000;;LB.
 26162                                  	; 24/09/2023
 26163                                  	;CMP	AX,0			    ;AN000;;LB. greater than 64K
 26164 00004804 7509                    	JNZ	short outrange2		    ;AN000;;LB. yes
 26165 00004806 363B0E[7700]            	CMP	CX,[ss:SC_CACHE_COUNT]	    ;AN000;;LB. greater than SC count
 26166 0000480B 7302                    	JAE	short outrange2		    ;AN000;;LB. yes
 26167 0000480D F8                      	CLC				    ;AN000;;LB. clear carry
 26168                                  	;JMP	short inexit		    ;AN000;;LB. in SC
 26169                                  	; 16/12/2022
 26170 0000480E C3                      	retn	; 30/04/2019
 26171                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26172                                  	;jmp	short inexit
 26173                                  
 26174                                  outrange2:				    ;AN000;;LB. set carry
 26175 0000480F F9                      	STC				    ;AN000;;LB.
 26176                                  inexit: 				    ;AN000;;LB.
 26177 00004810 C3                      	retn				    ;AN000;;LB.
 26178                                  
 26179                                  ;Break	<INVALIDATE_SC - invalide secondary cache>
 26180                                  ;---------------------------------------------------------------------------
 26181                                  ;
 26182                                  ; Procedure Name : Invalidate_Sc
 26183                                  ;
 26184                                  ; Inputs:  [SC_DRIVE]= requesting drive
 26185                                  ;	   [CURSC_DRIVE]= current SC drive
 26186                                  ;	   [CURSC_SECTOR]= starting scetor # of SC
 26187                                  ;	   [SC_CACHE_COUNT]= SC count
 26188                                  ;	   [SC_STATUS]= SC status word
 26189                                  ;	   [HIGH_SECTOR]:DX= sector number
 26190                                  ;
 26191                                  ; Function:
 26192                                  ;	invalidate secondary cache if in there
 26193                                  ; Output:
 26194                                  ;	[SC_STATUS] is updated
 26195                                  ;---------------------------------------------------------------------------
 26196                                  
 26197                                  INVALIDATE_SC:
 26198                                  	; SS override for all variables used
 26199                                  
 26200 00004811 E8D5FF                  	CALL	IN_SC			    ;AN000;;LB. in secondary cache
 26201 00004814 720C                    	JC	short outrange		    ;AN000;;LB. no
 26202 00004816 B80100                  	MOV	AX,1			    ;AN000;;LB. invalidate the sector
 26203 00004819 D3E0                    	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
 26204 0000481B F7D0                    	NOT	AX			    ;AN000;;LB.
 26205 0000481D 362106[B50D]            	AND	[ss:SC_STATUS],AX	    ;AN000;;LB. save the status
 26206                                  outrange:				    ;AN000;;LB.
 26207 00004822 C3                      	retn				    ;AN000;;LB.
 26208                                  
 26209                                  ; DOSCODE:87A5h (MSDOS 6.21, MSDOS.SYS)
 26210                                  ; 22/11/2022
 26211                                  ; DOSCODE:876Ah (MSDOS 5.0, MSDOS.SYS)
 26212                                  
 26213                                  ;Break	<VIRREAD- virtually read data into buffer>
 26214                                  ;--------------------------------------------------------------------------
 26215                                  ;
 26216                                  ; Procedure Name : SC_FLAG
 26217                                  ;
 26218                                  ; Inputs:  SC_FLAG = 0, no sectors were read into SC
 26219                                  ;		     1, continuous sectors were read into SC
 26220                                  ; Function:
 26221                                  ;	   Move data from SC to buffer
 26222                                  ; Output:
 26223                                  ;	 carry clear, data is moved to buffer
 26224                                  ;	 carry set, bad sector or exceeds maximum sector
 26225                                  ;	   SC_FLAG =0
 26226                                  ;	   CALLSCNT=1
 26227                                  ;	   SC_STATUS= -1 if succeeded
 26228                                  ;     
 26229                                  ;		       0 if failed
 26230                                  ;--------------------------------------------------------------------------
 26231                                  
 26232                                  VIRREAD:
 26233                                  	; SS override for all variables used
 26234                                  
 26235 00004823 36803E[B70D]00          	CMP	byte [ss:SC_FLAG],0	    ;AN000;;LB. from SC fill
 26236 00004829 744E                    	JZ	short sc2end		    ;AN000;;LB. no
 26237 0000482B 36A1[0E06]              	MOV	AX,[ss:TEMP_VAR2]	    ;AN000;;LB. restore buffer addr
 26238 0000482F 36A3[6A03]              	MOV	[ss:CALLXAD+2],AX	    ;AN000;;LB.
 26239 00004833 36A1[0C06]              	MOV	AX,[ss:TEMP_VAR]	    ;AN000;;LB.
 26240 00004837 36A3[6803]              	MOV	[ss:CALLXAD],AX		    ;AN000;;LB.
 26241 0000483B 36C606[B70D]00          	MOV	byte [ss:SC_FLAG],0	    ;AN000;;LB. reset sc_flag
 26242 00004841 36C706[6C03]0100        	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. one sector transferred
 26243                                  
 26244                                  	;TEST	word [SS:DEVCALL_REQSTAT],STERR ;AN000;;LB. error?
 26245 00004848 36F606[5E03]80          	test	byte [ss:DEVCALL_REQSTAT+1],(STERR>>8) ; 80h
 26246 0000484E 7513                    	JNZ	short scerror 		    ;AN000;;LB. yes
 26247 00004850 1E                      	PUSH	DS			    ;AN000;;LB.
 26248 00004851 56                      	PUSH	SI			    ;AN000;;LB.
 26249 00004852 06                      	PUSH	ES			    ;AN000;;LB.
 26250 00004853 57                      	PUSH	DI			    ;AN000;;LB.
 26251 00004854 52                      	PUSH	DX			    ;AN000;;LB.
 26252 00004855 51                      	PUSH	CX			    ;AN000;;LB.
 26253 00004856 31C9                    	XOR	CX,CX			    ;AN000;;LB. we want first sector in SC
 26254 00004858 E83100                  	CALL	SC2BUF2 		    ;AN000;;LB. move data from SC to buf
 26255 0000485B 59                      	POP	CX
 26256 0000485C 5A                      	POP	DX			    ;AN000;;LB.
 26257 0000485D 5F                      	POP	DI			    ;AN000;;LB.
 26258 0000485E 07                      	POP	ES			    ;AN000;;LB.
 26259 0000485F 5E                      	POP	SI			    ;AN000;;LB.
 26260 00004860 1F                      	POP	DS			    ;AN000;;LB.
 26261 00004861 EB16                    	JMP	SHORT sc2end		    ;AN000;;LB. return
 26262                                  scerror:				    ;AN000;
 26263 00004863 36C706[6C03]0100        	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. reset sector count to 1
 26264 0000486A 36C706[B50D]0000        	MOV	word [ss:SC_STATUS],0	    ;AN000;;LB. invalidate all SC sectors
 26265 00004871 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1    ;AN000;;LB. invalidate drive
 26266 00004877 F9                      	STC				    ;AN000;;LB. carry set
 26267 00004878 C3                      	retn				    ;AN000;;LB.
 26268                                  sc2end: 				    ;AN000;
 26269 00004879 F8                      	CLC				    ;AN000;;LB. carry clear
 26270 0000487A C3                      	retn				    ;AN000;;LB.
 26271                                  
 26272                                  ; 30/04/2019 - Retro  DOS v4.0
 26273                                  ; DOSCODE:87FDh (MSDOS 6.21, MSDOS.SYS)
 26274                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26275                                  ; DOSCODE:87C2h (MSDOS 5.0, MSDOS.SYS)
 26276                                  
 26277                                  ;Break	<SC2BUF- move data from SC to buffer>
 26278                                  ;----------------------------------------------------------------------------
 26279                                  ;
 26280                                  ; Procedure Name : SC2BUF
 26281                                  ;
 26282                                  ; Inputs:  [SC_STATUS] = SC validity status
 26283                                  ;	   [SC_SECTOR_SIZE] = request sector size
 26284                                  ;	   [SC_CACHE_PTR] = pointer to SC
 26285                                  ; Function:
 26286                                  ;	   Move data from SC to buffer
 26287                                  ; Output:
 26288                                  ;	   carry clear, in SC  and data is moved
 26289                                  ;	   carry set, not in SC and data is not moved
 26290                                  ;---------------------------------------------------------------------------
 26291                                  
 26292                                  SC2BUF:
 26293                                  	; SS override for all variables used
 26294 0000487B E86BFF                  	CALL	IN_SC			    ;AN000;LB. in secondary cache
 26295                                  	;JC	short noSC		    ;AN000;LB. no
 26296                                  	; 24/09/2023
 26297 0000487E 723D                    	jc	short sexit
 26298 00004880 B80100                  	MOV	AX,1			    ;AN000;LB. check if valid sector
 26299 00004883 D3E0                    	SHL	AX,CL			    ;AN000;LB. in the secondary cache
 26300 00004885 368506[B50D]            	TEST	[ss:SC_STATUS],AX	    ;AN000;LB.
 26301 0000488A 7430                    	JZ	short noSC		    ;AN000;LB. invalid
 26302                                  ;entry SC2BUF2
 26303                                  SC2BUF2:				    ;AN000;
 26304                                  	;MOV	AX,CX			    ;AN000;LB. times index with
 26305                                  	;MUL	word [ss:SC_SECTOR_SIZE]    ;AN000;LB. sector size
 26306                                  	; 24/09/2023
 26307 0000488C 36A1[AD0D]              	mov	ax,[ss:SC_SECTOR_SIZE]
 26308 00004890 91                      	xchg	ax,cx ; cx = [ss:SC_SECTOR_SIZE]
 26309 00004891 F7E1                    	mul	cx
 26310 00004893 360306[7300]            	ADD	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. add SC starting addr
 26311 00004898 361316[7500]            	ADC	DX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
 26312 0000489D 8EDA                    	MOV	DS,DX			    ;AN000;LB. DS:SI-> SC sector addr
 26313 0000489F 89C6                    	MOV	SI,AX			    ;AN000;LB.
 26314 000048A1 368E06[6A03]            	MOV	ES,[ss:CALLXAD+2]		    ;AN000;LB. ES:DI-> buffer addr
 26315 000048A6 368B3E[6803]            	MOV	DI,[ss:CALLXAD]		    ;AN000;LB.
 26316                                  	; 24/09/2023
 26317                                  	;MOV	CX,[ss:SC_SECTOR_SIZE]	    ;AN000;LB. count= sector size
 26318 000048AB D1E9                    	SHR	CX,1			    ;AN000;LB. may use DWORD move for 386
 26319                                  ;entry MOVWORDS
 26320                                  MOVWORDS:				    ;AN000;
 26321 000048AD 36803E[6A00]00          	CMP	byte [ss:DDMOVE],0	    ;AN000;LB. 386 ?
 26322 000048B3 7403                    	JZ	short nodd		    ;AN000;LB. no
 26323 000048B5 D1E9                    	SHR	CX,1			    ;AN000;LB. words/2
 26324 000048B7 66                      	DB	66H			    ;AN000;LB. use double word move
 26325                                  nodd:
 26326 000048B8 F3A5                    	REP	MOVSW			    ;AN000;LB. move to buffer
 26327 000048BA F8                      	CLC				    ;AN000;LB. clear carry
 26328 000048BB C3                      	retn				    ;AN000;LB. exit
 26329                                  noSC:					    ;AN000;
 26330 000048BC F9                      	STC				    ;AN000;LB. set carry
 26331                                  sexit:					    ;AN000;
 26332 000048BD C3                      	retn				    ;AN000;LB.
 26333                                  
 26334                                  ;============================================================================
 26335                                  ; MKNODE.ASM, MSDOS 6.0, 1991
 26336                                  ;============================================================================
 26337                                  ; 29/07/2018 - Retro DOS v3.0
 26338                                  ; 19/05/2019 - Retro DOS v4.0
 26339                                  
 26340                                  ;	TITLE	MKNODE - Node maker
 26341                                  ;	NAME	MKNODE
 26342                                  
 26343                                  ;**	MKNODE.ASM
 26344                                  ;----------------------------------------------------------------------------
 26345                                  ;	Low level routines for making a new local file system node
 26346                                  ;	and filling in an SFT from a directory entry
 26347                                  ;
 26348                                  ;	BUILDDIR
 26349                                  ;	SETDOTENT
 26350                                  ;	MakeNode
 26351                                  ;	NEWENTRY
 26352                                  ;	FREEENT
 26353                                  ;	NEWDIR
 26354                                  ;	DOOPEN
 26355                                  ;	RENAME_MAKE
 26356                                  ;	CHECK_VIRT_OPEN
 26357                                  ;
 26358                                  ;	Revision history:
 26359                                  ;
 26360                                  ;	 AN000	version 4.0  Jan. 1988
 26361                                  ;	 A004	PTM 3680  --- Make SFT NAME field offset same as 3.30
 26362                                  
 26363                                  ;Break   <BUILDDIR,NEWDIR -- ALLOCATE DIRECTORIES>
 26364                                  ;----------------------------------------------------------------------------
 26365                                  ;
 26366                                  ; Procedure Name : BUILDDIR,NEWDIR
 26367                                  ;
 26368                                  ; Inputs:
 26369                                  ;       ES:BP Points to DPB
 26370                                  ;       [THISSFT] Set if using NEWDIR entry point
 26371                                  ;               (used by ALLOCATE)
 26372                                  ;       [LASTENT] current last valid entry number in directory if no free
 26373                                  ;               entries
 26374                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 26375                                  ; Function:
 26376                                  ;       Grow directory if no free entries and not root
 26377                                  ; Outputs:
 26378                                  ;       CARRY SET IF FAILURE
 26379                                  ;       ELSE
 26380                                  ;          AX entry number of new entry
 26381                                  ;          If a new dir [DIRSTART],[CLUSFAC],[CLUSNUM],[DIRSEC] set
 26382                                  ;               AX = first entry of new dir
 26383                                  ;       GETENT should be called to set [LASTENT]
 26384                                  ;
 26385                                  ;----------------------------------------------------------------------------
 26386                                  
 26387                                  ; 19/05/2019 - Retro DOS v4.0
 26388                                  ; DOSCODE:8845h (MSDOS 6.21, MSDOS.SYS)
 26389                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26390                                  ; DOSCODE:880Ah (MSDOS 6.21, MSDOS.SYS)
 26391                                  
 26392                                  ; 24/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 MSDOS.SYS)
 26393                                  ; DOSCODE:8845h (MSDOS 6.22, MSDOS.SYS)
 26394                                  
 26395                                  BUILDDIR:
 26396                                  	; 29/07/2018 - Retro DOS v3.0
 26397                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 4E66h
 26398                                  
 26399 000048BE A1[D805]                        MOV     AX,[ENTFREE]
 26400 000048C1 83F8FF                          CMP     AX,-1 ; 0FFFFh
 26401                                  	;JZ	short CHECK_IF_ROOT
 26402                                          ;CLC
 26403                                          ;retn
 26404                                  	; 24/09/2023
 26405 000048C4 7507                    	jne	short builddir_cmc_retn  ; cf=1 (will be 0)
 26406                                  
 26407                                  CHECK_IF_ROOT:
 26408 000048C6 833E[C205]00                    CMP     word [DIRSTART],0
 26409 000048CB 7502                            JNZ	short NEWDIR
 26410                                          ;STC
 26411                                  	; 24/09/2023
 26412                                  	; [DIRSTART]=0, cf=0, zf=1 (cf will be 1 after cmc instruction)
 26413                                  builddir_cmc_retn:
 26414                                  	; 24/09/2023
 26415 000048CD F5                      	cmc	; cf=1 <-> cf=0
 26416                                  builddir_retn:
 26417 000048CE C3                              retn				; Can't grow root
 26418                                  
 26419                                  	;entry   NEWDIR
 26420                                  NEWDIR: 
 26421 000048CF 8B1E[C205]              	MOV     BX,[DIRSTART]
 26422 000048D3 09DB                            OR      BX,BX
 26423 000048D5 7405                            JZ	short NULLDIR
 26424 000048D7 E82806                  	call	GETEOF
 26425 000048DA 72F2                            jc	short builddir_retn	; Screw up
 26426                                  NULLDIR:
 26427 000048DC B90100                          MOV     CX,1
 26428 000048DF E83905                  	call	ALLOCATE
 26429 000048E2 72EA                            jc	short  builddir_retn
 26430 000048E4 8B16[C205]                      MOV     DX,[DIRSTART]
 26431 000048E8 09D2                            OR      DX,DX
 26432 000048EA 750D                            JNZ	short ADDINGDIR
 26433 000048EC E8DBF5                  	call	SETDIRSRCH
 26434 000048EF 72DD                            jc	short  builddir_retn
 26435 000048F1 C706[4803]FFFF                  MOV     word [LASTENT],-1
 26436 000048F7 EB29                            JMP     SHORT GOTDIRREC
 26437                                  ADDINGDIR:
 26438 000048F9 53                              PUSH    BX
 26439 000048FA 8B1E[BC05]                      MOV     BX,[CLUSNUM]
 26440 000048FE E82D0C                          call	IsEOF
 26441 00004901 5B                              POP     BX
 26442 00004902 7217                            JB	short NOTFIRSTGROW
 26443                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 26444 00004904 891E[BC05]                      MOV     [CLUSNUM],BX
 26445                                  	; 24/09/2023
 26446                                  	;PUSH	CX ; (not necessary)
 26447 00004908 50                      	PUSH	AX
 26448 00004909 55                      	PUSH	BP
 26449 0000490A B401                            MOV     AH,1			; CLUSNUM update
 26450                                  	; 15/12/2022
 26451 0000490C 268A5600                	mov	dl,[ES:BP] ; 09/09/2018
 26452                                          ; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26453                                  	;;mov	dl,[es:bp+0]
 26454                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; drive #
 26455 00004910 8B0E[C205]                      MOV     CX,[DIRSTART]		; first cluster #
 26456 00004914 89DD                            MOV     BP,BX 			; CLUSNUM
 26457 00004916 E8E8DD                  	call	FastOpen_Update
 26458 00004919 5D                              POP     BP
 26459 0000491A 58                              POP     AX
 26460                                  	; 24/09/2023
 26461                                          ;POP	CX
 26462                                  
 26463                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 26464                                  NOTFIRSTGROW:
 26465 0000491B 89DA                            MOV     DX,BX
 26466 0000491D 30DB                            XOR     BL,BL
 26467 0000491F E8CC04                  	call	FIGREC
 26468                                  GOTDIRREC:
 26469                                  	;mov	cl,[es:bp+4]
 26470 00004922 268A4E04                        MOV     CL,[ES:BP+DPB.CLUSTER_MASK]
 26471 00004926 FEC1                            INC     CL
 26472 00004928 30ED                            XOR     CH,CH
 26473                                  ZERODIR:
 26474 0000492A 51                              PUSH    CX
 26475                                  	; 22/09/2023
 26476                                  	;;mov	byte [ALLOWED],18h
 26477                                          ;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 26478 0000492B B0FF                            MOV     AL,0FFH
 26479                                          ;call	GETBUFFR
 26480 0000492D E82210                          call	GETBUFFRD ; *
 26481 00004930 7302                    	JNC	short GET_SSIZE
 26482 00004932 59                              POP     CX
 26483 00004933 C3                              retn
 26484                                  
 26485                                  GET_SSIZE:
 26486                                  	;mov	cx,[es:bp+2]
 26487 00004934 268B4E02                        MOV     CX,[ES:BP+DPB.SECTOR_SIZE]
 26488 00004938 06                              PUSH    ES
 26489 00004939 C43E[E205]                      LES     DI,[CURBUF]
 26490                                  	;or	byte [es:di+5],4
 26491 0000493D 26804D0504                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 26492 00004942 57                              PUSH    DI
 26493                                  	;;add	di,16	; MSDOS 3.3
 26494                                  	;add	di,20	; MSDOS 6.0	
 26495 00004943 83C714                          ADD     DI,BUFINSIZ
 26496 00004946 31C0                            XOR     AX,AX
 26497 00004948 D1E9                            SHR     CX,1
 26498 0000494A F3AB                            REP     STOSW
 26499 0000494C 7301                            JNC	short EVENZ
 26500 0000494E AA                              STOSB
 26501                                  EVENZ:
 26502 0000494F 5F                              POP     DI
 26503                                  
 26504                                  	; MSDOS 6.0
 26505 00004950 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 26506                                  					;LB. if already dirty		  ;AN000;
 26507 00004955 7508                            JNZ	short yesdirty7		;LB.  don't increment dirty count ;AN000;
 26508 00004957 E8FF11                          call	INC_DIRTY_COUNT		;LB. 				  ;AN000;
 26509                                          
 26510                                  	;or	byte [es:di+5],40h
 26511 0000495A 26804D0540              	OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 26512                                  yesdirty7:
 26513 0000495F 07                              POP	ES
 26514 00004960 59                              POP	CX
 26515                                  
 26516                                  	; 19/05/2019 - Retro DOS v4.0
 26517                                  
 26518                                  	; MSDOS 3.3
 26519                                  	;INC	DX
 26520                                  
 26521                                  	; MSDOS 6.0
 26522                                  	; 24/09/2023
 26523                                  	;add	dx,1
 26524                                  	;;adc	word [HIGH_SECTOR],0
 26525                                  	;; 24/09/2023
 26526                                  	;; ax=0
 26527                                  	;adc	[HIGH_SECTOR],ax ; 0
 26528                                  	; 24/09/2023
 26529 00004961 42                      	inc	dx
 26530 00004962 7504                    	jnz	short loop_zerodir
 26531 00004964 FF06[0706]              	inc	word [HIGH_SECTOR]
 26532                                  loop_zerodir:
 26533 00004968 E2C0                            LOOP    ZERODIR
 26534                                  
 26535 0000496A A1[4803]                        MOV     AX,[LASTENT]
 26536 0000496D 40                              INC     AX
 26537                                  	; 24/09/2023
 26538                                  	; cf=0
 26539                                  	;CLC
 26540 0000496E C3                              retn
 26541                                  
 26542                                  ;--------------------------------------------------------------------------
 26543                                  ;
 26544                                  ; Procedure Name : SETDOTENT
 26545                                  ;
 26546                                  ; set up a . or .. directory entry for a directory.
 26547                                  ;
 26548                                  ;   Inputs:     ES:DI point to the beginning of a directory entry.
 26549                                  ;               AX contains ". " or ".."
 26550                                  ;               DX contains first cluster of entry
 26551                                  ;
 26552                                  ;----------------------------------------------------------------------------
 26553                                  
 26554                                  SETDOTENT:
 26555                                  ;	Fill in name field
 26556 0000496F AB                              STOSW
 26557 00004970 B90400                          MOV     CX,4
 26558 00004973 B82020                          MOV     AX,"  " ; 2020h
 26559 00004976 F3AB                            REP     STOSW
 26560 00004978 AA                              STOSB
 26561                                  
 26562                                  ;	Set up attribute
 26563                                  	;mov	al, 10h
 26564 00004979 B010                            MOV     AL,attr_directory
 26565 0000497B AA                              STOSB
 26566                                  
 26567                                  ;	Initialize time and date of creation
 26568 0000497C 83C70A                          ADD     DI,10
 26569 0000497F 8B36[9E05]                      MOV     SI,[THISSFT]
 26570                                  	;mov	ax,[si+0Dh]
 26571 00004983 8B440D                          MOV     AX,[SI+SF_ENTRY.sf_time]
 26572 00004986 AB                              STOSW
 26573                                  	;mov	ax,[si+0Fh]
 26574 00004987 8B440F                          MOV     AX,[SI+SF_ENTRY.sf_date]
 26575 0000498A AB                      	STOSW
 26576                                  
 26577                                  ;	Set up first cluster field
 26578 0000498B 89D0                            MOV     AX,DX
 26579 0000498D AB                              STOSW
 26580                                  
 26581                                  ;	0 file size
 26582 0000498E 31C0                            XOR     AX,AX
 26583 00004990 AB                              STOSW
 26584 00004991 AB                              STOSW
 26585 00004992 C3                              retn
 26586                                  
 26587                                  ;Break   <MAKENODE -- CREATE A NEW NODE>
 26588                                  ;---------------------------------------------------------------------------
 26589                                  ;
 26590                                  ; Procedure Name : MakeNode
 26591                                  ;
 26592                                  ; Inputs:
 26593                                  ;       AL - attribute to create
 26594                                  ;       AH = 0 if it is ok to truncate a file already by this name
 26595                                  ;	AH != 0 if truncation not allowed (prexisting file is an error)
 26596                                  ;               (AH ignored on dirs and devices)
 26597                                  ;
 26598                                  ;        NOTE: When making a DIR or volume ID, AH need not be set since
 26599                                  ;               a name already existant is ALWAYS an error in these cases.
 26600                                  ;
 26601                                  ;       [WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 26602                                  ;               terminated)
 26603                                  ;       [CURR_DIR_END] Points to end of Current dir part of string
 26604                                  ;               ( = -1 if current dir not involved, else
 26605                                  ;                Points to first char after last "/" of current dir part)
 26606                                  ;       [THISCDS] Points to CDS being used
 26607                                  ;       [THISSFT] Points to an empty SFT. EXCEPT sf_mode filled in.
 26608                                  ; Function:
 26609                                  ;       Make a new node
 26610                                  ; Outputs:
 26611                                  ;       Sets EXTERR_LOCUS = errLOC_Disk or errLOC_Unk via GetPathNoset
 26612                                  ;       CARRY SET IF ERROR
 26613                                  ;          AX = 1 A node by this name exists and is a directory
 26614                                  ;          AX = 2 A new node could not be created
 26615                                  ;          AX = 3 A node by this name exists and is a disk file
 26616                                  ;               (AH was NZ on input)
 26617                                  ;          AX = 4 Bad Path
 26618                                  ;               SI return from GetPath maintained
 26619                                  ;          AX = 5 Attribute mismatch
 26620                                  ;          AX = 6 Sharing Violation
 26621                                  ;               (INT 24 generated ALWAYS since create is always compat mode
 26622                                  ;          AX = 7 file not found for Extended Open (not exists and fails)
 26623                                  ;       ELSE
 26624                                  ;          AX = 0 Disk Node
 26625                                  ;          AX = 3 Device Node (error in some cases)
 26626                                  ;          [DIRSTART],[DIRSEC],[CLUSFAC],[CLUSNUM] set to directory
 26627                                  ;               containing new node.
 26628                                  ;          [CURBUF+2]:BX Points to entry
 26629                                  ;          [CURBUF+2]:SI Points to entry.dir_first
 26630                                  ;          [THISSFT] is filled in
 26631                                  ;               sf_mode = unchanged.
 26632                                  ;          Attribute byte in entry is input AL
 26633                                  ; DS preserved, others destroyed
 26634                                  ;
 26635                                  ;-------------------------------------------------------------------------
 26636                                  
 26637                                  ; 19/05/2019 - Retro DOS v4.0
 26638                                  ; DOSCODE:8925h (MSDOS 6.21, MSDOS.SYS)
 26639                                  
 26640                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26641                                  ; DOSCODE:88EAh (MSDOS 5.0, MSDOS.SYS)
 26642                                  
 26643                                  MakeNode:
 26644                                  	;mov	word [CREATING],0E5FFh
 26645 00004993 C706[7E05]FFE5          	MOV	WORD [CREATING],DIRFREE*256 + 0FFh ; Creating, not DEL *.*
 26646 00004999 50                              PUSH    AX              ; Save AH value
 26647 0000499A C606[4C03]00            	MOV	byte [NoSetDir],0
 26648 0000499F A2[6D05]                	MOV	[SATTRIB],AL
 26649 000049A2 E888F5                  	call	GetPathNoSet
 26650 000049A5 88CA                            MOV     DL,CL           ; Save CL info
 26651 000049A7 89C1                            MOV     CX,AX           ; Device ID to CH
 26652 000049A9 58                              POP     AX              ; Get back AH
 26653 000049AA 732E                            JNC	short make_exists ; File existed
 26654 000049AC 7505                            JNZ	short make_err_4 ; Path bad
 26655 000049AE 80FA80                          CMP     DL,80h          ; Check "CL" return from GETPATH
 26656 000049B1 7406                            JZ	short make_type	; Name simply not found, and no metas
 26657                                  make_err_4:
 26658 000049B3 B004                            MOV     AL,4            ; case 1 bad path
 26659                                  make_err_ret:
 26660 000049B5 30E4                            XOR     AH,AH
 26661 000049B7 F9                              STC
 26662                                  ;make_retn:	; 22/11/2022
 26663 000049B8 C3                              retn
 26664                                  
 26665                                          ;entry	RENAME_MAKE     ; Used by DOS_RENAME to "copy" a node
 26666                                  RENAME_MAKE:
 26667                                  make_type:
 26668                                  ;Extended Open hooks
 26669                                  	; MSDOS 6.0
 26670                                  	;TESTB	EXTOPEN_ON,EXT_OPEN_ON	;FT. from extended open		;AN000;
 26671 000049B9 F606[F605]01            	test	byte [EXTOPEN_ON],EXT_OPEN_ON ; 1
 26672 000049BE 7411                    	JZ	short make_type2	;FT. no				;AN000;
 26673 000049C0 800E[F605]04            	OR	byte [EXTOPEN_ON],EXT_FILE_NOT_EXISTS ; 4
 26674                                  					;FT. set for extended open ;AN000;
 26675                                  	;TESTB	EXTOPEN_FLAG,0F0H	;FT. not exists and fails	;AN000;
 26676 000049C5 F606[F405]F0            	test	byte [EXTOPEN_FLAG],0F0h
 26677 000049CA 7505                    	JNZ	short make_type2	;FT. no				;AN000;
 26678 000049CC F9                      	STC				;FT. set carry			;AN000;
 26679 000049CD B80700                  	MOV    AX,7			;FT. file not found		;AN000;
 26680                                  	; 22/11/2022
 26681                                  make_retn:
 26682                                  	;return
 26683 000049D0 C3                      	retn				;FT.				;AN000;
 26684                                  
 26685                                  ;	Extended Open hooks
 26686                                  
 26687                                  make_type2:
 26688 000049D1 C43E[9E05]                      LES     DI,[THISSFT]
 26689 000049D5 31C0                            XOR     AX,AX           ; nothing exists Disk Node
 26690 000049D7 F9                              STC                     ; Not found
 26691 000049D8 EB5A                            JMP     short make_new
 26692                                  
 26693                                  ; The node exists. It may be either a device, directory or file:
 26694                                  ;   Zero set => directory
 26695                                  ;   High bit of CH on => device
 26696                                  ;   else => file
 26697                                  
 26698                                  make_exists:
 26699 000049DA 7448                            JZ	short make_exists_dir
 26700 000049DC B003                            MOV     AL,3            ; file exists type 3  (error or device node)
 26701                                  	;test	byte [ATTRIB],18h
 26702 000049DE F606[6B05]18            	TEST	byte [ATTRIB],attr_volume_id+attr_directory
 26703 000049E3 753B                            JNZ	short make_err_ret_5
 26704                                  				; Cannot already exist as Disk or Device Node
 26705                                                                  ;       if making DIR or Volume ID
 26706 000049E5 08ED                            OR      CH,CH
 26707 000049E7 781A                            JS	short make_share ; No further checks on attributes if device
 26708 000049E9 08E4                            OR      AH,AH
 26709 000049EB 75C8                            JNZ	short make_err_ret ; truncating NOT OK (AL = 3)
 26710 000049ED 51                              PUSH    CX              ; Save device ID
 26711 000049EE 8E06[E405]                      MOV     ES,[CURBUF+2]
 26712                                  	;mov	ch,[es:bx+0Bh]
 26713 000049F2 268A6F0B                        MOV     CH,[ES:BX+dir_entry.dir_attr] ; Get file attributes
 26714                                  	;test	ch,1
 26715 000049F6 F6C501                  	test	CH,attr_read_only
 26716 000049F9 7524                            JNZ	short make_err_ret_5P ; Cannot create on read only files
 26717 000049FB E8D0F7                  	call	MatchAttributes
 26718 000049FE 59                              POP     CX              ; Devid back in CH
 26719 000049FF 751F                            JNZ	short make_err_ret_5 ; Attributes not ok
 26720 00004A01 30C0                            XOR     AL,AL           ; AL = 0, Disk Node
 26721                                  make_share:
 26722 00004A03 30E4                            XOR     AH,AH
 26723 00004A05 50                              PUSH    AX              ; Save Disk or Device node
 26724 00004A06 51                              PUSH    CX              ; Save Device ID
 26725 00004A07 88EC                            MOV     AH,CH           ; Device ID to AH
 26726 00004A09 E84501                          CALL    DOOPEN          ; Fill in SFT for share check
 26727 00004A0C C43E[9E05]                      LES     DI,[THISSFT]
 26728 00004A10 56                      	push	si
 26729 00004A11 53                      	push	bx		; Save CURBUF pointers
 26730 00004A12 E86729                  	call	ShareEnter
 26731 00004A15 735A                            jnc	short MakeEndShare
 26732                                  
 26733                                  ; User failed request.
 26734 00004A17 5B                      	pop	bx
 26735 00004A18 5E                      	pop	si
 26736 00004A19 59                      	pop	cx
 26737 00004A1A 58                      	pop	ax
 26738                                  
 26739                                  Make_Share_ret:
 26740 00004A1B B006                            MOV     AL,6
 26741 00004A1D EB96                            JMP	short make_err_ret
 26742                                  
 26743                                  make_err_ret_5P:
 26744 00004A1F 59                              POP     CX              ; Get back device ID
 26745                                  make_err_ret_5:
 26746 00004A20 B005                            MOV     AL,5            ; Attribute mismatch
 26747                                          ; 22/11/2022
 26748 00004A22 EB91                    	JMP     short make_err_ret
 26749                                  
 26750                                  make_exists_dir:
 26751 00004A24 B001                            MOV     AL,1            ; exists as directory, always an error
 26752                                  	; 22/11/2022
 26753 00004A26 EB8D                    	JMP     short make_err_ret
 26754                                  
 26755                                  make_save:
 26756 00004A28 50                              PUSH    AX              ; Save whether Disk or File
 26757 00004A29 89C8                            MOV     AX,CX           ; Device ID to AH
 26758 00004A2B E87400                          CALL    NEWENTRY
 26759 00004A2E 58                              POP     AX              ; 0 if Disk, 3 if File
 26760 00004A2F 739F                            jnc	short make_retn
 26761 00004A31 B002                            MOV     AL,2            ; create failed case 2
 26762                                  make_save_retn:
 26763 00004A33 C3                              retn
 26764                                  
 26765                                  make_new:
 26766 00004A34 E8F1FF                          call    make_save
 26767 00004A37 72FA                            jc	short make_save_retn	; case 2 fail
 26768                                  	;test	byte [ATTRIB],10h
 26769 00004A39 F606[6B05]10            	test	BYTE [ATTRIB],attr_directory
 26770 00004A3E 75F3                            jnz	short make_save_retn	; Don't "open" directories,
 26771                                  					; so don't tell the sharer about them
 26772 00004A40 50                      	push	ax
 26773 00004A41 53                      	push	bx
 26774 00004A42 56                      	push	si		
 26775 00004A43 E83629                          call	ShareEnter
 26776 00004A46 5E                      	pop	si
 26777 00004A47 5B                      	pop	bx
 26778 00004A48 58                      	pop	ax
 26779 00004A49 73E8                    	jnc	short make_save_retn
 26780                                  
 26781                                  ; We get here by having the user FAIL a share problem. Typically a failure of
 26782                                  ; this nature is an out-of-space or an internal error. We clean up as best as
 26783                                  ; possible: delete the newly created directory entry and return share_error.
 26784                                  
 26785 00004A4B 50                              PUSH    AX
 26786 00004A4C C43E[E205]                      LES     DI,[CURBUF]
 26787                                  	;mov	byte [es:bx],0E5h
 26788 00004A50 26C607E5                	MOV	BYTE [ES:BX],DIRFREE	; nuke newly created entry.
 26789                                  	
 26790                                  	; MSDOS 6.0
 26791                                  	;test	byte [es:di+5],40h
 26792 00004A54 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 26793                                  					;LB. if already dirty		  ;AN000;
 26794 00004A59 7508                            JNZ	short yesdirty8		;LB.  don't increment dirty count ;AN000;
 26795                                  	; 22/11/2022
 26796 00004A5B E8FB10                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 26797                                  	;or	byte [es:di+5],40h
 26798 00004A5E 26804D0540                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty ; flag buffer as dirty
 26799                                  yesdirty8:
 26800 00004A63 C42E[8A05]                      LES     BP,[THISDPB]
 26801                                  	; 15/12/2022
 26802 00004A67 268A4600                        mov	al,[ES:BP]
 26803                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26804                                  	;;mov	al,[es:bp+0]
 26805                                  	;MOV	AL,[ES:BP+DPB.DRIVE]	; get drive for flush
 26806 00004A6B E8E60F                          call	FLUSHBUF		; write out buffer.
 26807 00004A6E 58                              POP     AX
 26808 00004A6F EBAA                            jmp	short Make_Share_ret
 26809                                  
 26810                                  ; We have found an existing file. We have also entered it into the share set.
 26811                                  ; At this point we need to call newentry to correctly address the problem of
 26812                                  ; getting rid of old data (create an existing file) or creating a new
 26813                                  ; directory entry (create a new file). Unfortunately, this operation may
 26814                                  ; result in an INT 24 that the user doesn't return from, thus locking the file
 26815                                  ; irretrievably into the share set. The correct solution is for us to LEAVE
 26816                                  ; the share set now, do the operation and then reassert the share access.
 26817                                  ;
 26818                                  ; We are allowed to do this! There is no window! After all, we are in
 26819                                  ; critDisk here and for someone else to get in, they must enter critDisk also.
 26820                                  
 26821                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26822                                  	; DOSCODE:89C8h (MSDOS 5.0, MSDOS.SYS)
 26823                                  
 26824                                  MakeEndShare:
 26825 00004A71 C43E[9E05]                      LES     DI,[THISSFT]		; grab SFT
 26826 00004A75 31C0                            XOR     AX,AX
 26827 00004A77 E893C8                  	call	ECritSFT
 26828 00004A7A 268705                  	xchg	AX,[ES:DI]
 26829                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 26830 00004A7D 50                      	push	ax
 26831 00004A7E 57                      	push	di
 26832 00004A7F 06                      	push	es
 26833 00004A80 9C                              PUSHF
 26834 00004A81 E8F328                          call	ShareEnd                ; remove sharing
 26835 00004A84 9D                              POPF
 26836 00004A85 07                      	pop	es
 26837 00004A86 5F                      	pop	di
 26838 00004A87 268F05                          pop	word [ES:DI]	
 26839                                  	;pop	word [ES:DI+SF_ENTRY.sf_ref_count]
 26840 00004A8A E89BC8                  	call	LCritSFT
 26841                                  	; 22/11/2022
 26842                                  	; DOSCODE:89E4h (MSDOS 5.0, MSDOS.SYS)
 26843 00004A8D 5B                      	pop	bx
 26844 00004A8E 5E                      	pop	si
 26845 00004A8F 59                      	pop	cx
 26846 00004A90 58                      	pop	ax
 26847 00004A91 E894FF                          CALL    make_save
 26848                                  
 26849                                  ; If the user failed, we do not reenter into the sharing set.
 26850                                  
 26851 00004A94 729D                            jc	short make_save_retn	; bye if error
 26852 00004A96 50                      	push	ax
 26853 00004A97 53                      	push	bx
 26854 00004A98 56                      	push	si
 26855 00004A99 9C                              PUSHF
 26856 00004A9A E8DF28                          call	ShareEnter
 26857 00004A9D 9D                              POPF
 26858 00004A9E 5E                      	pop	si
 26859 00004A9F 5B                      	pop	bx
 26860 00004AA0 58                      	pop	ax
 26861                                  
 26862                                  ; If Share_check fails, then we have an internal ERROR!!!!!
 26863                                  
 26864                                  makeendshare_retn:
 26865 00004AA1 C3                              retn
 26866                                  
 26867                                  ;---------------------------------------------------------------------------
 26868                                  ;
 26869                                  ; Procedure Name : NEWENTRY
 26870                                  ;
 26871                                  ; Inputs:
 26872                                  ;       [THISSFT] set
 26873                                  ;       [THISDPB] set
 26874                                  ;       [LASTENT] current last valid entry number in directory if no free
 26875                                  ;               entries
 26876                                  ;       [VOLID] set if a volume ID was found during search
 26877                                  ;	Attrib Contains attributes for new file
 26878                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 26879                                  ;       CARRY FLAG INDICATES STATUS OF SEARCH FOR FILE
 26880                                  ;               NC means file existed (device)
 26881                                  ;               C  means file did not exist
 26882                                  ;       AH = Device ID byte
 26883                                  ;       If FILE
 26884                                  ;           [CURBUF+2]:BX points to start of directory entry
 26885                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 26886                                  ;       If device
 26887                                  ;           DS:BX points to start of "fake" directory entry
 26888                                  ;           DS:SI points to dir_first of "fake" directory entry
 26889                                  ;               (has DWORD pointer to device header)
 26890                                  ; Function:
 26891                                  ;       Make a new directory entry
 26892                                  ;       If an old one existed it is truncated first
 26893                                  ; Outputs:
 26894                                  ;       Carry set if error
 26895                                  ;               Can't grow dir, atts didn't match, attempt to make 2nd
 26896                                  ;               vol ID, user FAILed to I 24
 26897                                  ;       else
 26898                                  ;               outputs of DOOPEN
 26899                                  ; DS, BX, SI preserved (meaning on SI BX, not value), others destroyed
 26900                                  ;
 26901                                  ;----------------------------------------------------------------------------
 26902                                  
 26903                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26904                                  	; DOSCODE:89F9h (MSDOS 5.0, MSDOS.SYS)
 26905                                  
 26906                                  NEWENTRY:
 26907 00004AA2 C42E[8A05]                      LES     BP,[THISDPB]
 26908 00004AA6 7315                            JNC	short EXISTENT	
 26909 00004AA8 803E[4A03]00                    CMP     byte [FAILERR],0
 26910                                  	;STC
 26911                                          ;jnz	short makeendshare_retn	; User FAILed, node might exist
 26912                                          ; 24/09/2023
 26913 00004AAD 750C                    	jnz	short ERRRET3
 26914 00004AAF E80CFE                  	CALL    BUILDDIR        ; Try to build dir
 26915 00004AB2 72ED                            jc	short makeendshare_retn	; Failed
 26916 00004AB4 E8E4F3                          call	GETENT          ; Point at that free entry
 26917 00004AB7 72E8                            jc	short makeendshare_retn	; Failed
 26918 00004AB9 EB0E                            JMP     SHORT FREESPOT
 26919                                  
 26920                                  ERRRET3:
 26921 00004ABB F9                              STC
 26922                                  newentry_retn:
 26923 00004ABC C3                              retn
 26924                                  
 26925                                  EXISTENT:
 26926 00004ABD 08E4                            OR      AH,AH           ; Check if file is I/O device
 26927 00004ABF 7903                            JNS	short NOT_DEV1
 26928 00004AC1 E98D00                          JMP     DOOPEN          ; If so, proceed with open
 26929                                  
 26930                                  NOT_DEV1:
 26931 00004AC4 E82901                          call	FREEENT		; Free cluster chain
 26932 00004AC7 72F3                            jc	short newentry_retn ; Failed
 26933                                  FREESPOT:
 26934                                  	;test	byte [ATTRIB],8
 26935 00004AC9 F606[6B05]08            	test	BYTE [ATTRIB],attr_volume_id
 26936 00004ACE 7407                            JZ	short NOTVOLID
 26937 00004AD0 803E[7B05]00                    CMP     BYTE [VOLID],0
 26938 00004AD5 75E4                            JNZ	short ERRRET3	; Can't create a second volume ID
 26939                                  NOTVOLID:
 26940 00004AD7 8E06[E405]                      MOV     ES,[CURBUF+2]
 26941 00004ADB 89DF                            MOV     DI,BX
 26942                                  
 26943 00004ADD BE[4B05]                        MOV     SI,NAME1
 26944                                  
 26945 00004AE0 B90500                          MOV     CX,5
 26946 00004AE3 F3A5                            REP     MOVSW
 26947 00004AE5 A4                              MOVSB                   ; Move name into dir entry
 26948 00004AE6 A0[6B05]                	MOV	AL,[ATTRIB]
 26949 00004AE9 AA                      	STOSB                   ; Attributes
 26950                                  
 26951                                  ;; File Tagging for Create DOS 4.00
 26952 00004AEA B105                            MOV     CL,5            ;FT. assume normal FBUGBUG	;AN000;
 26953                                  ;; File Tagging for Create DOS 4.00
 26954                                  
 26955 00004AEC 31C0                            XOR     AX,AX
 26956 00004AEE F3AB                            REP     STOSW           ; Zero pad
 26957 00004AF0 E8FDBF                          call	DATE16
 26958 00004AF3 92                              XCHG    AX,DX
 26959 00004AF4 AB                              STOSW                   ; dir_time
 26960 00004AF5 92                              XCHG    AX,DX
 26961 00004AF6 AB                              STOSW                   ; dir_date
 26962 00004AF7 31C0                            XOR     AX,AX
 26963 00004AF9 57                              PUSH    DI              ; Correct SI input value
 26964                                  				; 	(recomputed for new buffer)
 26965 00004AFA AB                              STOSW                   ; Zero dir_first and size
 26966 00004AFB AB                              STOSW
 26967 00004AFC AB                              STOSW
 26968                                  updnxt:
 26969 00004AFD 8B36[E205]              	MOV	SI,[CURBUF]
 26970                                  
 26971                                  	; 19/05/2019 - Retro DOS v4.0
 26972                                  
 26973                                  	; MSDOS 6.0
 26974 00004B01 26F6440540              	TEST	byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 26975                                  				;LB. if already dirty		  ;AN000;
 26976 00004B06 7508                            JNZ	short yesdirty9	;LB.  don't increment dirty count ;AN000;
 26977 00004B08 E84E10                          call	INC_DIRTY_COUNT	;LB.				  ;AN000;
 26978                                          
 26979                                  	;or	byte [es:si+5],40h
 26980 00004B0B 26804C0540              	OR      byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 26981                                  yesdirty9:
 26982 00004B10 C42E[8A05]                      LES     BP,[THISDPB]
 26983                                  	; 15/12/2022
 26984 00004B14 268A4600                	MOV	AL,[ES:BP]
 26985                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26986                                  	;;mov	al,[es:bp+0]
 26987                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; Sets AH value again (in AL)
 26988 00004B18 50                              PUSH    AX
 26989 00004B19 53                              PUSH    BX
 26990                                  
 26991                                  ; If we have a file, we need to increment the open ref. count so that
 26992                                  ; we have some protection against invalid media changes if an Int 24
 26993                                  ; error occurs.
 26994                                  ; Do nothing for a device.
 26995                                  
 26996 00004B1A 06                      	push	es
 26997 00004B1B 57                      	push	di
 26998 00004B1C C43E[9E05]                      LES     DI,[THISSFT]
 26999                                  	;test	word [es:di+5],80h
 27000                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 27001 00004B20 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 27002 00004B25 751A                            jnz	short GotADevice
 27003 00004B27 1E                      	push	ds
 27004 00004B28 53                      	push	bx
 27005 00004B29 C51E[8A05]                      LDS     BX,[THISDPB]
 27006                                  	;mov	[es:di+7],bx
 27007 00004B2D 26895D07                        MOV     [ES:DI+SF_ENTRY.sf_devptr],BX
 27008 00004B31 8CDB                            MOV     BX,DS
 27009                                  	;mov	[es:di+9],bx
 27010 00004B33 26895D09                        MOV     [ES:DI+SF_ENTRY.sf_devptr+2],BX
 27011 00004B37 5B                      	pop	bx
 27012 00004B38 1F                      	pop	ds ; need to use DS for segment later on
 27013 00004B39 E8B8FA                  	call	DEV_OPEN_SFT    ; increment ref. count
 27014 00004B3C C606[A20A]01                    mov	byte [VIRTUAL_OPEN],1; set flag
 27015                                  GotADevice:
 27016 00004B41 5F                      	pop	di
 27017 00004B42 07                      	pop	es
 27018                                  
 27019 00004B43 E80E0F                          call	FLUSHBUF
 27020 00004B46 E8EF00                          Call    CHECK_VIRT_OPEN ; decrement ref. count            ;AN000;
 27021 00004B49 5B                              POP     BX
 27022 00004B4A 58                              POP     AX
 27023 00004B4B 5E                              POP     SI              ; Get SI input back
 27024 00004B4C 88C4                            MOV     AH,AL           ; Get I/O driver number back
 27025 00004B4E 7301                    	jnc	short DOOPEN    ; Failed
 27026 00004B50 C3                      	retn
 27027                                  	
 27028                                  ;NOTE FALL THROUGH
 27029                                  
 27030                                  ; DOSCODE:8AE4h (MSDOS 6.21, MSDOS.SYS)
 27031                                  
 27032                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27033                                  ; DOSCODE:8AA9h (MSDOS 5.0, MSDOS.SYS)
 27034                                  
 27035                                  ; DOOPEN
 27036                                  ;----------------------------------------------------------------------------
 27037                                  ;
 27038                                  ; Inputs:
 27039                                  ;       [THISDPB] points to DPB if file
 27040                                  ;       [THISSFT] points to SFT being used
 27041                                  ;       AH = Device ID byte
 27042                                  ;       If FILE
 27043                                  ;           [CURBUF+2]:BX points to start of directory entry
 27044                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 27045                                  ;       If device
 27046                                  ;           DS:BX points to start of "fake" directory entry
 27047                                  ;           DS:SI points to dir_first of "fake" directory entry
 27048                                  ;               (has DWORD pointer to device header)
 27049                                  ; Function:
 27050                                  ;       Fill in SFT from dir entry
 27051                                  ; Outputs:
 27052                                  ;       CARRY CLEAR
 27053                                  ;       sf_ref_count and sf_mode fields not altered
 27054                                  ;       sf_flags high byte = 0
 27055                                  ;       sf_flags low byte = AH except
 27056                                  ;       sf_flags Bit 6 set (not dirty or not EOF)
 27057                                  ;       sf_attr sf_date sf_time sf_name set from entry
 27058                                  ;       sf_position = 0
 27059                                  ;       If device
 27060                                  ;           sf_devptr = dword at dir_first (pointer to device header)
 27061                                  ;           sf_size = 0
 27062                                  ;       If file
 27063                                  ;           sf_firclus sf_size set from entry
 27064                                  ;           sf_devptr = [THISDPB]
 27065                                  ;           sf_cluspos = 0
 27066                                  ;           sf_lstclus = sf_firclus
 27067                                  ;           sf_dirsec sf_dirpos set
 27068                                  ; DS,SI,BX preserved, others destroyed
 27069                                  ;
 27070                                  ;----------------------------------------------------------------------------
 27071                                  
 27072                                  	;entry	DOOPEN
 27073                                  DOOPEN:
 27074                                  ;	Generate and store attribute
 27075                                  
 27076 00004B51 88E6                            MOV     DH,AH           ; AH to different place
 27077 00004B53 C43E[9E05]                      LES     DI,[THISSFT]
 27078                                  	;add	di,4
 27079 00004B57 83C704                          ADD     DI,SF_ENTRY.sf_attr ; Skip ref_count and mode fields
 27080                                  	; 24/09/2023
 27081 00004B5A 31C0                    	xor	ax,ax
 27082                                  	;XOR	AL,AL		; Assume it's a device, devices have an
 27083                                  				;   attribute of 0 (for R/O testing etc).
 27084 00004B5C 08F6                            OR      DH,DH           ; See if our assumption good.
 27085 00004B5E 7807                            JS	short DEV_SFT1	; If device DS=DOSGROUP
 27086 00004B60 8E1E[E405]                      MOV     DS,[CURBUF+2]
 27087                                  	;mov	al,[BX+0Bh]
 27088 00004B64 8A470B                          MOV     AL,[BX+dir_entry.dir_attr]
 27089                                  				; If file, get attrib from dir entry
 27090                                  DEV_SFT1:
 27091 00004B67 AA                              STOSB                   ; sf_attr, ES:DI -> sf_flags
 27092                                  
 27093                                  ;	Generate and store flags word
 27094                                  
 27095                                  	; 24/09/2023
 27096                                  	;XOR	AX,AX
 27097                                          ; ah=0
 27098 00004B68 88F0                    	MOV     AL,DH
 27099                                  	;or	al,40h
 27100 00004B6A 0C40                            OR      AL,devid_file_clean
 27101 00004B6C AB                              STOSW                   ; sf_flags, ES:DI -> sf_devptr
 27102                                  
 27103                                  ;	Generate and store device pointer
 27104                                  
 27105 00004B6D 1E                              PUSH    DS
 27106                                  	;lds	ax,[bx+1Ah]
 27107 00004B6E C5471A                          LDS     AX,[BX+dir_entry.dir_first] ; Assume device
 27108 00004B71 08F6                            OR      DH,DH
 27109 00004B73 7805                            JS	short DEV_SFT2
 27110                                  
 27111                                  ;hkn; SS override
 27112 00004B75 36C506[8A05]                    LDS     AX,[SS:THISDPB]	; Was file
 27113                                  DEV_SFT2:
 27114 00004B7A AB                              STOSW 			; store offset
 27115 00004B7B 8CD8                            MOV     AX,DS
 27116 00004B7D 1F                              POP     DS
 27117 00004B7E AB                      	STOSW			; store segment
 27118                                  				; ES:DI -> sf_firclus
 27119                                  
 27120                                  ;	Generate pointer to, generate and store first cluster 
 27121                                  ;	(irrelevant for devices)
 27122                                  
 27123 00004B7F 56                              PUSH    SI              ; Save pointer to dir_first
 27124 00004B80 A5                              MOVSW                   ; dir_first -> sf_firclus
 27125                                                                  ; DS:SI -> dir_size_l, ES:DI -> sf_time
 27126                                  
 27127                                  ;	Copy time/date of last modification
 27128                                  
 27129                                  	;sub	si,6
 27130 00004B81 83EE06                          SUB     SI,dir_entry.dir_size_l - dir_entry.dir_time 
 27131                                  				; DS:SI->dir_time
 27132 00004B84 A5                              MOVSW                   ; dir_time -> sf_time
 27133                                                                  ; DS:SI -> dir_date, ES:DI -> sf_date
 27134 00004B85 A5                              MOVSW                   ; dir_date -> sf_date
 27135                                                                  ; DS:SI -> dir_first, ES:DI -> sf_size
 27136                                  
 27137                                  ;	Generate and store file size (0 for devices)
 27138                                  
 27139 00004B86 AD                              LODSW                   ; skip dir_first, DS:SI -> dir_size_l
 27140 00004B87 AD                              LODSW                   ; dir_size_l in AX , DS:SI -> dir_size_h
 27141 00004B88 89C1                            MOV     CX,AX           ; dir_size_l in CX
 27142 00004B8A AD                              LODSW                   ; dir_size_h (size AX:CX), DS:SI -> ????
 27143 00004B8B 08F6                            OR      DH,DH
 27144 00004B8D 7904                            JNS	short FILE_SFT1
 27145 00004B8F 31C0                            XOR     AX,AX
 27146 00004B91 89C1                            MOV     CX,AX           ; Devices are open ended
 27147                                  FILE_SFT1:
 27148 00004B93 91                              XCHG    AX,CX
 27149 00004B94 AB                              STOSW                   ; Low word of sf_size
 27150 00004B95 91                              XCHG    AX,CX
 27151 00004B96 AB                              STOSW                   ; High word of sf_size
 27152                                                                  ; ES:DI -> sf_position
 27153                                  ; Initialize position to 0
 27154                                  
 27155 00004B97 31C0                            XOR     AX,AX
 27156 00004B99 AB                              STOSW
 27157 00004B9A AB                              STOSW                   ; sf_position
 27158                                                                  ; ES:DI -> sf_cluspos
 27159                                  
 27160                                  ; Generate cluster optimizations for files
 27161                                  
 27162 00004B9B 08F6                            OR      DH,DH
 27163 00004B9D 7843                            JS	short DEV_SFT3
 27164 00004B9F AB                              STOSW                   ; sf_cluspos ; 19h
 27165                                  	;mov	ax,[bx+1Ah]
 27166 00004BA0 8B471A                          MOV     AX,[BX+dir_entry.dir_first]
 27167                                  	; 19/05/2019
 27168                                  	; MSDOS 3.3
 27169                                  	;STOSW 			; sf_lstclus ; 1Bh
 27170                                  	; MSDOS 6.0
 27171 00004BA3 57                              PUSH	DI              ;AN004; save dirsec offset
 27172                                  	;sub	di,1Bh
 27173 00004BA4 83EF1B                          SUB	DI,SF_ENTRY.sf_dirsec	;AN004; es:di -> SFT
 27174                                  	;mov	[es:di+35h],ax
 27175 00004BA7 26894535                        MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX	;AN004; save it
 27176 00004BAB 5F                              POP	DI              ;AN004; restore dirsec offset
 27177                                  
 27178                                  ; DOS 3.3  FastOpen  6/13/86
 27179                                  
 27180 00004BAC 1E                      	PUSH	DS
 27181                                  
 27182                                  ;hkn; SS is DOSDATA
 27183 00004BAD 16                      	push	ss
 27184 00004BAE 1F                      	pop	ds
 27185                                  	;test	byte [FastOpenFlg],4
 27186 00004BAF F606[3A0D]04            	TEST	byte [FastOpenFlg],Special_Fill_Set
 27187 00004BB4 7411                    	JZ	short Not_FastOpen
 27188                                  
 27189                                  ;hkn; FastOpen_Ext_Info is in DOSDATA
 27190 00004BB6 BE[3B0D]                        MOV     SI,FastOpen_Ext_Info
 27191                                  
 27192                                  	;mov	ax,[si+1]
 27193 00004BB9 8B4401                          MOV     AX,[SI+FEI.dirsec]
 27194 00004BBC AB                              STOSW                   ; sf_dirsec
 27195                                  	; MSDOS 6.0
 27196                                  	;mov	ax,[si+3]
 27197 00004BBD 8B4403                          MOV	AX,[SI+FEI.dirsec+2]
 27198                                  				;;; changed for >32mb
 27199 00004BC0 AB                              STOSW                   ; sf_dirsec
 27200                                  	; 19/08//2018
 27201 00004BC1 8A04                    	mov	al,[SI]
 27202                                          ;MOV	AL,[SI+FEI.dirpos] ; mov al,[SI+0]
 27203 00004BC3 AA                              STOSB                   ; sf_dirpos
 27204 00004BC4 1F                              POP	DS
 27205                                          ;JMP	short Next_Name
 27206                                  	; 24/09/2023
 27207 00004BC5 EB1E                    	jmp	short FILE_SFT2  ; cf=0 (after 'test' instruction)
 27208                                  
 27209                                  ; DOS 3.3  FastOpen  6/13/86
 27210                                  
 27211                                  Not_FastOpen:
 27212                                          ;POP     DS		; normal path
 27213                                  
 27214                                  ;hkn; SS override
 27215                                  	;MOV	SI,[SS:CURBUF]	; DS:SI->buffer header
 27216                                  	; 16/12/2022
 27217                                  	; 28/07/2019
 27218 00004BC7 8B36[E205]              	mov	si,[CURBUF]
 27219 00004BCB 1F                      	pop	ds
 27220                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27221                                  	;pop	ds
 27222                                  	;mov	si,[ss:CURBUF]
 27223                                  	
 27224                                  	;mov	ax,[si+6]
 27225 00004BCC 8B4406                          MOV     AX,[SI+BUFFINFO.buf_sector]     ;F.C. >32mb ;AN000;
 27226 00004BCF AB                              STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 27227                                  	; 19/05/2019        
 27228                                  	; MSDOS 6.0
 27229                                  	;mov	ax,[si+8]
 27230 00004BD0 8B4408                  	MOV	AX,[SI+BUFFINFO.buf_sector+2]	;F.C. >32mb ;AN000;
 27231 00004BD3 AB                              STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 27232                                          
 27233 00004BD4 89D8                    	MOV     AX,BX
 27234                                  	;;add	si,16	; MSDOS 3.3	
 27235                                  	;add	si,20	; MSDOS 6.0
 27236 00004BD6 83C614                          ADD     SI,BUFINSIZ     ; DS:SI-> start of data in buffer
 27237 00004BD9 29F0                            SUB     AX,SI           ; AX = BX relative to start of sector
 27238                                          ;mov	cl,32
 27239 00004BDB B120                    	MOV     CL,dir_entry.size
 27240 00004BDD F6F1                            DIV     CL
 27241 00004BDF AA                              STOSB                   ; sf_dirpos
 27242                                  Next_Name:
 27243 00004BE0 EB03                            JMP     SHORT FILE_SFT2
 27244                                  
 27245                                  	; 24/09/2023
 27246                                  	; cf=0 (after 'or' instruction)
 27247                                  DEV_SFT3:
 27248                                  	;add	di,7
 27249 00004BE2 83C707                          ADD     DI,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 27250                                  FILE_SFT2:
 27251                                  
 27252                                  ; Copy in the object's name
 27253                                  
 27254 00004BE5 89DE                            MOV     SI,BX           ; DS:SI points to dir_name
 27255 00004BE7 B90B00                          MOV     CX,11
 27256 00004BEA F3A4                            REP     MOVSB           ; sf_name
 27257 00004BEC 5E                              POP     SI              ; recover DS:SI -> dir_first
 27258                                  
 27259                                  ;hkn; SS is DOSDATA
 27260 00004BED 16                              push	ss
 27261 00004BEE 1F                      	pop	ds
 27262                                  	; 24/09/2023
 27263                                  	; cf=0
 27264                                          ;CLC
 27265 00004BEF C3                              retn
 27266                                  
 27267                                  ;---------------------------------------------------------------------------
 27268                                  ;
 27269                                  ; Procedure Name : FREEENT
 27270                                  ;
 27271                                  ; Inputs:
 27272                                  ;       ES:BP -> DPB
 27273                                  ;       [CURBUF] Set
 27274                                  ;       [CURBUF+2]:BX points to directory entry
 27275                                  ;       [CURBUF+2]:SI points to above dir_first
 27276                                  ; Function:
 27277                                  ;       Free the cluster chain for the entry if present
 27278                                  ; Outputs:
 27279                                  ;       Carry set if error (currently user FAILed to I 24)
 27280                                  ;       (NOTE dir_firclus and dir_size_l/h are wrong)
 27281                                  ; DS BX SI ES BP preserved (BX,SI in meaning, not value) others destroyed
 27282                                  ;---------------------------------------------------------------------------
 27283                                  
 27284                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27285                                  FREEENT:
 27286 00004BF0 1E                              PUSH    DS
 27287 00004BF1 C53E[E205]                      LDS     DI,[CURBUF]
 27288 00004BF5 8B0C                            MOV     CX,[SI]         ; Get pointer to clusters
 27289                                  	; 19/05/2019 - Retro DOS v4.0
 27290                                  	; MSDOS 6.0
 27291 00004BF7 8B5508                  	MOV	DX,[DI+BUFFINFO.buf_sector+2]  ;F.C. >32mb	;AN000;
 27292                                  ;hkn; SS override
 27293 00004BFA 368916[0706]                    MOV	[SS:HIGH_SECTOR],DX		;F.C. >32mb	;AN000;
 27294 00004BFF 8B5506                          MOV     DX,[DI+BUFFINFO.buf_sector]
 27295 00004C02 1F                              POP     DS
 27296 00004C03 83F902                  	CMP	CX,2
 27297 00004C06 722E                            JB	short RET1	; Was 0 length file (or mucked Firclus if CX=1)
 27298                                  	;cmp	cx,[es:bp+0Dh]
 27299 00004C08 263B4E0D                        CMP     CX,[ES:BP+DPB.MAX_CLUSTER]
 27300 00004C0C 7728                            JA	short RET1	; Treat like zero length file (firclus mucked)
 27301 00004C0E 29FB                            SUB     BX,DI
 27302 00004C10 53                              PUSH    BX              ; Save offset
 27303 00004C11 FF36[0706]              	PUSH	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 27304 00004C15 52                              PUSH    DX              ; Save sector number
 27305 00004C16 89CB                            MOV     BX,CX
 27306 00004C18 E8AC02                          call	RELEASE         ; Free any data allocated
 27307 00004C1B 5A                              POP     DX
 27308 00004C1C 8F06[0706]                      POP	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 27309 00004C20 7302                            JNC	short GET_BUF_BACK
 27310 00004C22 5B                              POP     BX
 27311                                  freeent_retn:
 27312 00004C23 C3                              retn			; Screw up
 27313                                  
 27314                                  GET_BUF_BACK:
 27315                                  	; 22/09/2023
 27316                                  	;;mov	byte [ALLOWED],18h
 27317                                          ;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 27318                                          ;XOR	AL,AL ; *
 27319                                  	;call	GETBUFFR        ; Get sector back
 27320 00004C24 E8290D                  	call	GETBUFFER ; * ; pre read      
 27321                                  
 27322 00004C27 5B                      	POP     BX              ; Get offset back
 27323 00004C28 72F9                            jc	short freeent_retn
 27324 00004C2A E8B0EA                  	call	SET_BUF_AS_DIR
 27325 00004C2D 031E[E205]                      ADD     BX,[CURBUF]	; Correct it for new buffer
 27326 00004C31 89DE                            MOV     SI,BX
 27327                                  	;add	si,1Ah
 27328 00004C33 83C61A                          ADD     SI,dir_entry.dir_first	; Get corrected SI
 27329                                  RET1:
 27330 00004C36 F8                              CLC
 27331 00004C37 C3                              retn
 27332                                  
 27333                                  ;---------------------------------------------------------------------------
 27334                                  ;
 27335                                  ; Procedure Name : CHECK_VIRT_OPEN
 27336                                  ;
 27337                                  ; CHECK_VIRT_OPEN checks to see if we had performed a "virtual open" (by
 27338                                  ; examining the flag [VIRTUAL_OPEN] to see if it is 1). If we did, then
 27339                                  ; it calls Dev_Close_SFT to decrement the ref. count. It also resets the
 27340                                  ; flag [VIRTUAL_OPEN].
 27341                                  ; No registers affected (including flags).
 27342                                  ; On input, [THISSFT] points to current SFT.
 27343                                  ;
 27344                                  ;---------------------------------------------------------------------------
 27345                                  
 27346                                  CHECK_VIRT_OPEN:
 27347 00004C38 50                      	PUSH    AX
 27348 00004C39 9F                              lahf                    ; preserve flags
 27349 00004C3A 803E[A20A]00                    CMP     byte [VIRTUAL_OPEN],0
 27350 00004C3F 7410                            JZ	short ALL_CLOSED
 27351 00004C41 C606[A20A]00                    mov     byte [VIRTUAL_OPEN],0	; reset flag
 27352 00004C46 06                      	push	es
 27353 00004C47 57                      	push	di
 27354 00004C48 C43E[9E05]                      LES     DI,[THISSFT]
 27355 00004C4C E8ADF9                          call	DEV_CLOSE_SFT
 27356 00004C4F 5F                      	pop	di
 27357 00004C50 07                      	pop	es
 27358                                  
 27359                                  ALL_CLOSED:
 27360 00004C51 9E                              sahf                    ; restore flags
 27361 00004C52 58                              POP     AX
 27362 00004C53 C3                              retn
 27363                                  
 27364                                  ;============================================================================
 27365                                  ; ROM.ASM, MSDOS 6.0, 1991
 27366                                  ;============================================================================
 27367                                  ; 29/07/2018 - Retro DOS v3.0
 27368                                  ; 20/05/2019 - Retro DOS v4.0
 27369                                  
 27370                                  ;	TITLE	ROM - Miscellaneous routines
 27371                                  ;	NAME	ROM
 27372                                  
 27373                                  ;**	Misc Low level routines for doing simple FCB computations, Cache
 27374                                  ;       reads and writes, I/O optimization, and FAT allocation/deallocation
 27375                                  ;
 27376                                  ;	SKPCLP
 27377                                  ;	FNDCLUS
 27378                                  ;	BUFSEC
 27379                                  ;	BUFRD
 27380                                  ;	BUFWRT
 27381                                  ;	NEXTSEC
 27382                                  ;	OPTIMIZE
 27383                                  ;	FIGREC
 27384                                  ;	ALLOCATE
 27385                                  ;	RESTFATBYT
 27386                                  ;	RELEASE
 27387                                  ;	RELBLKS
 27388                                  ;	GETEOF
 27389                                  ;
 27390                                  ;	Modification history:
 27391                                  ;
 27392                                  ;		Created: ARR 30 March 1983
 27393                                  ;               M039: DB 10/25/90 - Disk read/write optimization.
 27394                                  
 27395                                  ;Break   <FNDCLUS -- Skip over allocation units>
 27396                                  ;--------------------------------------------------------------------------
 27397                                  ;
 27398                                  ; Procedure Name : FNDCLUS
 27399                                  ;
 27400                                  ; Inputs:
 27401                                  ;       CX = No. of clusters to skip
 27402                                  ;       ES:BP = Base of drive parameters
 27403                                  ;       [THISSFT] point to SFT
 27404                                  ; Outputs:
 27405                                  ;       BX = Last cluster skipped to
 27406                                  ;       CX = No. of clusters remaining (0 unless EOF)
 27407                                  ;       DX = Position of last cluster
 27408                                  ;       Carry set if error (currently user FAILed to I 24)
 27409                                  ; DI destroyed. No other registers affected.
 27410                                  ;--------------------------------------------------------------------------
 27411                                  
 27412                                  ; 20/05/2019 - Retro DOS v4.0
 27413                                  ; DOSCODE:8BF2h (MSDOS 6.21, MSDOS.SYS)
 27414                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27415                                  ; DOSCODE:8BB7h (MSDOS 5.0, MSDOS.SYS)
 27416                                  
 27417                                  FNDCLUS:
 27418 00004C54 06                      	PUSH	ES
 27419 00004C55 C43E[9E05]                      LES     DI,[THISSFT]		; setup addressability to SFT
 27420                                  	;;mov	bx,[es:di+1Bh] ; MSDOS 3.3
 27421                                  	;mov	bx,[es:di+35h] ; MSDOS 6.0
 27422 00004C59 268B5D35                	MOV	BX,[ES:DI+SF_ENTRY.sf_lstclus]
 27423                                  	;mov	dx,[es:di+19h]
 27424 00004C5D 268B5519                        MOV     DX,[ES:DI+SF_ENTRY.sf_cluspos]
 27425 00004C61 09DB                    	OR	BX,BX
 27426 00004C63 7424                    	JZ	short NOCLUS
 27427                                  
 27428 00004C65 29D1                            SUB     CX,DX
 27429 00004C67 7308                            JNB	short FINDIT
 27430                                  
 27431 00004C69 01D1                            ADD     CX,DX
 27432 00004C6B 31D2                            XOR     DX,DX
 27433                                  	;mov	bx,[es:di+0Bh]
 27434 00004C6D 268B5D0B                        MOV     BX,[ES:DI+SF_ENTRY.sf_firclus]
 27435                                  FINDIT:
 27436 00004C71 07                              POP	ES
 27437 00004C72 E313                    	JCXZ	RET9
 27438                                  
 27439                                  	;entry	SKPCLP
 27440                                  SKPCLP:
 27441 00004C74 E8CE08                  	call	UNPACK
 27442 00004C77 7214                            jc	short fndclus_retn	; retc
 27443                                  
 27444                                  	; 09/09/2018
 27445                                  
 27446                                  	; MSDOS 3.3
 27447                                  	;push	bx
 27448                                  	;mov	bx,di
 27449                                  	;call	IsEOF
 27450                                  	;pop	bx	
 27451                                  	;jae	short RET9
 27452                                  
 27453                                  	; 20/05/2019 - Retro DOS v4.0
 27454                                  
 27455                                  	; MSDOS 6.0
 27456 00004C79 87DF                    	xchg	bx,di
 27457 00004C7B E8B008                  	call	IsEOF
 27458 00004C7E 87DF                    	xchg	bx,di
 27459 00004C80 7305                    	jae	short RET9
 27460                                  
 27461 00004C82 87DF                            XCHG    BX,DI
 27462 00004C84 42                              INC     DX
 27463                                  
 27464 00004C85 E2ED                    	LOOP	SKPCLP			; RMFS
 27465                                  RET9:	
 27466 00004C87 F8                      	CLC
 27467 00004C88 C3                              retn
 27468                                  NOCLUS:
 27469 00004C89 07                              POP	ES
 27470 00004C8A 41                              INC	CX
 27471 00004C8B 4A                              DEC	DX
 27472 00004C8C F8                              CLC
 27473                                  
 27474                                  fndclus_retn:
 27475 00004C8D C3                              retn
 27476                                  
 27477                                  ;Break  <BUFSEC -- BUFFER A SECTOR AND SET UP A TRANSFER>
 27478                                  ;--------------------------------------------------------------------------
 27479                                  ;
 27480                                  ; Procedure Name : BUFSEC
 27481                                  ;
 27482                                  ; Inputs:
 27483                                  ;       AH = priority of buffer
 27484                                  ;       AL = 0 if buffer must be read, 1 if no pre-read needed
 27485                                  ;       ES:BP = Base of drive parameters
 27486                                  ;       [CLUSNUM] = Physical cluster number
 27487                                  ;       [SECCLUSPOS] = Sector position of transfer within cluster
 27488                                  ;       [BYTCNT1] = Size of transfer
 27489                                  ; Function:
 27490                                  ;       Insure specified sector is in buffer, flushing buffer before
 27491                                  ;       read if necessary.
 27492                                  ; Outputs:
 27493                                  ;       ES:DI = Pointer to buffer
 27494                                  ;       SI = Pointer to transfer address
 27495                                  ;       CX = Number of bytes
 27496                                  ;       [NEXTADD] updated
 27497                                  ;       [TRANS] set to indicate a transfer will occur
 27498                                  ;       Carry set if error (user FAILed to I 24)
 27499                                  ;--------------------------------------------------------------------------
 27500                                  
 27501                                  BUFSEC:
 27502 00004C8E 8B16[BC05]                      MOV     DX,[CLUSNUM]
 27503 00004C92 8A1E[7305]                      MOV     BL,[SECCLUSPOS]
 27504                                  	;mov	byte [ALLOWED],38h
 27505 00004C96 C606[4B03]38                    MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
 27506 00004C9B E85001                          CALL    FIGREC
 27507 00004C9E E8B60C                  	call	GETBUFFR
 27508 00004CA1 72EA                            jc	short fndclus_retn
 27509                                  
 27510 00004CA3 C606[7405]01                    MOV     BYTE [TRANS],1	; A transfer is taking place
 27511 00004CA8 8B36[B805]                      MOV     SI,[NEXTADD]
 27512 00004CAC 89F7                            MOV     DI,SI
 27513 00004CAE 8B0E[D205]                      MOV     CX,[BYTCNT1]
 27514 00004CB2 01CF                            ADD     DI,CX
 27515 00004CB4 893E[B805]                      MOV     [NEXTADD],DI
 27516 00004CB8 C43E[E205]                      LES     DI,[CURBUF]
 27517                                  	;or	byte [es:di+5],8
 27518 00004CBC 26804D0508                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDATA
 27519                                  	;;lea	di,[di+16] ; MSDOS 3.3 
 27520                                  	;lea	di,[di+20] ; MSDOS 6.0
 27521 00004CC1 8D7D14                          LEA     DI,[DI+BUFINSIZ]        ; Point to buffer
 27522 00004CC4 033E[CC05]                      ADD     DI,[BYTSECPOS]
 27523 00004CC8 F8                              CLC
 27524 00004CC9 C3                              retn
 27525                                  
 27526                                  ;Break   <BUFRD, BUFWRT -- PERFORM BUFFERED READ AND WRITE>
 27527                                  
 27528                                  ;---------------------------------------------------------------------------
 27529                                  ;
 27530                                  ; Procedure Name : BUFRD
 27531                                  ;
 27532                                  ; Do a partial sector read via one of the system buffers
 27533                                  ; ES:BP Points to DPB
 27534                                  ; Carry set if error (currently user FAILed to I 24)
 27535                                  ;
 27536                                  ; DS - set to DOSDATA
 27537                                  ;
 27538                                  ;----------------------------------------------------------------------------
 27539                                  
 27540                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27541                                  	; 20/05/2019 - Retro DOS v4.0
 27542                                  BUFRD:
 27543 00004CCA 06                              PUSH	ES
 27544 00004CCB 31C0                            xor	ax, ax			; pre-read sector
 27545 00004CCD E8BEFF                          CALL    BUFSEC
 27546 00004CD0 7303                            JNC	short BUF_OK
 27547                                  
 27548                                  BUF_IO_FAIL:				; this label used by BUFWRT also
 27549 00004CD2 07                              POP	ES
 27550 00004CD3 EB2B                            JMP     SHORT RBUFPLACED
 27551                                  
 27552                                  BUF_OK:
 27553 00004CD5 8CC3                            MOV     BX,ES
 27554 00004CD7 8E06[2E03]                      MOV     ES,[DMAADD+2]
 27555 00004CDB 8EDB                            MOV     DS,BX
 27556 00004CDD 87FE                    	XCHG    DI,SI
 27557 00004CDF D1E9                            SHR     CX,1
 27558                                  ;M039
 27559                                  	; MSDOS 3.3
 27560                                  	;JNC	short EVENRD
 27561                                  	;MOVSB
 27562                                  ;EVENRD:
 27563                                  	;REP     MOVSW
 27564                                  
 27565                                  ;	CX = # of whole WORDs ; CF=1 if odd # of bytes.
 27566                                  ;       DS:SI-> Source within Buffer.
 27567                                  ;       ES:DI-> Destination within Transfer memory block.
 27568                                  
 27569                                  	; MSDOS 6.0
 27570 00004CE1 F3A5                    	rep	movsw			;Copy Buffer to Transfer memory.
 27571                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 27572                                  	;rep	movsb                   ;Copy last byte.
 27573                                  	; 16/12/2022
 27574 00004CE3 7301                    	jnc	short EVENRD ; **** 20/05/2019
 27575 00004CE5 A4                      	movsb ; ****
 27576                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27577                                  	;adc	cx,0
 27578                                  	;rep	movsb
 27579                                  ;M039
 27580                                  EVENRD: ; ****
 27581 00004CE6 07                              POP	ES
 27582                                  ;hkn; SS override
 27583 00004CE7 36C53E[E205]                    LDS     DI,[SS:CURBUF]
 27584                                  	;;lea	bx,[di+16]
 27585                                  	;lea	bx,[di+20] ; MSDOS 6.0
 27586 00004CEC 8D5D14                  	LEA     BX,[DI+BUFINSIZ]
 27587 00004CEF 29DE                            SUB     SI,BX                   ; Position in buffer
 27588 00004CF1 E8030C                          call	PLACEBUF
 27589                                  	;cmp	si,[es:bp+2]
 27590 00004CF4 263B7602                	CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Read Last byte?
 27591 00004CF8 7205                            JB	short RBUFPLACEDC	; No, leave buf where it is
 27592                                  ;M039
 27593                                  	; MSDOS 3.3
 27594                                  	;call	PLACEHEAD               ; Make it prime candidate for chucking
 27595                                                                          ;  even though it is MRU.
 27596                                          ; MSDOS 6.0
 27597 00004CFA 36893E[6D00]            	MOV	[ss:BufferQueue],DI	; Make it prime candidate for
 27598                                  ;M039					; chucking even though it is MRU.
 27599                                  
 27600                                  RBUFPLACEDC:
 27601 00004CFF F8                              CLC
 27602                                  RBUFPLACED:
 27603 00004D00 16                      	push	ss
 27604 00004D01 1F                      	pop	ds
 27605 00004D02 C3                              retn
 27606                                  
 27607                                  ;----------------------------------------------------------------------------
 27608                                  ;
 27609                                  ; Procedure : BUFWRT
 27610                                  ;
 27611                                  ; Do a partial sector write via one of the system buffers
 27612                                  ; ES:BP Points to DPB
 27613                                  ; Carry set if error (currently user FAILed to I 24)
 27614                                  ;
 27615                                  ; DS - set to DOSDATA
 27616                                  ;
 27617                                  ;----------------------------------------------------------------------------
 27618                                  
 27619                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27620                                  	; 20/05/2019 - Retro DOS v4.0
 27621                                  BUFWRT:
 27622                                          ;MOV     AX,[SECPOS]
 27623                                          ; MSDOS 6.0
 27624                                  	;ADD	AX,1            	; Set for next sector
 27625                                          ;MOV	[SECPOS],AX 		;F.C. >32mb	;AN000;
 27626                                          ;ADC	word [SECPOS+2],0	;F.C. >32mb	;AN000;
 27627                                          ; 24/09/2023
 27628 00004D03 FF06[C405]              	inc	word [SECPOS]
 27629 00004D07 7504                    	jnz	short bufw_secpos
 27630 00004D09 FF06[C605]              	inc	word [SECPOS+2]
 27631                                  bufw_secpos:
 27632 00004D0D A1[C605]                	MOV	AX,[SECPOS+2]		;F.C. >32mb	;AN000;
 27633 00004D10 3B06[CA05]                      CMP	AX,[VALSEC+2]		;F.C. >32mb	;AN000;
 27634 00004D14 B001                            MOV	AL,1			;F.C. >32mb	;AN000;
 27635 00004D16 770F                            JA	short NOREAD		;F.C. >32mb	;AN000;
 27636 00004D18 720B                            JB	short _doread		;F.C. >32mb	;AN000;
 27637 00004D1A A1[C405]                        MOV	AX,[SECPOS]		;F.C. >32mb	;AN000;
 27638                                  
 27639                                  	; MSDOS 3.3
 27640                                  	;INC	AX
 27641                                  	;MOV	[SECPOS],AX ; 09/09/2018
 27642                                  
 27643                                  	; 20/05/2019
 27644                                  	; MSDOS 3.3 & MSDOS 6.0
 27645 00004D1D 3B06[C805]                      CMP     AX,[VALSEC]		; Has sector been written before?
 27646 00004D21 B001                            MOV     AL,1
 27647 00004D23 7702                            JA	short NOREAD		; Skip preread if SECPOS>VALSEC
 27648                                  _doread:
 27649 00004D25 30C0                            XOR     AL,AL
 27650                                  NOREAD:
 27651 00004D27 06                              PUSH	ES
 27652 00004D28 E863FF                          CALL    BUFSEC
 27653 00004D2B 72A5                    	JC	short BUF_IO_FAIL
 27654 00004D2D 8E1E[2E03]                      MOV     DS,[DMAADD+2]
 27655 00004D31 D1E9                            SHR     CX,1
 27656                                  ;M039
 27657                                  	; MSDOS 3.3
 27658                                  	;JNC	short EVENWRT ; 09/09/2018
 27659                                  	;MOVSB
 27660                                  ;EVENWRT:
 27661                                  	;REP	MOVSW
 27662                                  
 27663                                  ;	CX = # of whole WORDs; CF=1 if odd # of bytes.
 27664                                  ;       DS:SI-> Source within Transfer memory block.
 27665                                  ;       ES:DI-> Destination within Buffer.
 27666                                  
 27667                                  	; MSDOS 6.0
 27668 00004D33 F3A5                    	rep	movsw			;Copy Transfer memory to Buffer.
 27669                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 27670                                  	;rep	movsb                   ;Copy last byte.
 27671                                  	; 16/12/2022
 27672 00004D35 7301                    	jnc	short EVENWRT ; **** 20/05/2019
 27673 00004D37 A4                      	movsb ; ****
 27674                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27675                                  	;adc	cx,0
 27676                                  	;rep	movsb
 27677                                  ;M039
 27678                                  EVENWRT: ; ****
 27679 00004D38 07                              POP	ES
 27680                                  
 27681                                  ;hkn; SS override
 27682 00004D39 36C51E[E205]                    LDS     BX,[SS:CURBUF]
 27683                                  
 27684                                  	; MSDOS 6.0
 27685 00004D3E F6470540                        TEST	byte [BX+BUFFINFO.buf_flags],buf_dirty
 27686                                  					;LB. if already dirty		  ;AN000;
 27687 00004D42 7507                            JNZ	short yesdirty10	;LB.  don't increment dirty count ;AN000;
 27688 00004D44 E8120E                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 27689                                  	
 27690                                  	;or	byte [bx+5],40h
 27691 00004D47 804F0540                        OR	byte [BX+BUFFINFO.buf_flags],buf_dirty
 27692                                  yesdirty10:
 27693                                  	;;lea	si,[bx+16]
 27694                                  	;lea	si,[bx+20] ; MSDOS 6.0
 27695 00004D4B 8D7714                          LEA     SI,[BX+BUFINSIZ]
 27696 00004D4E 29F7                            SUB     DI,SI                   ; Position in buffer
 27697                                  ;M039
 27698                                  	; MSDOS 3.3
 27699                                  	;MOV	SI,DI
 27700                                  	;MOV	DI,BX
 27701                                  	;call	PLACEBUF
 27702                                  	;;cmp	si,[es:bp+2]
 27703                                  	;CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 27704                                  	;JB	short WBUFPLACED	; No, leave buf where it is
 27705                                  	;call	PLACEHEAD               ; Make it prime candidate for chucking
 27706                                                                          ;  even though it is MRU.
 27707                                  	; MSDOS 6.0
 27708                                  	;cmp	di,[es:bp+2]
 27709 00004D50 263B7E02                	CMP	di,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 27710 00004D54 7205                            JB	short WBUFPLACED	; No, leave buf where it is
 27711 00004D56 36891E[6D00]                    MOV	[ss:BufferQueue],BX	; Make it prime candidate for
 27712                                  					; chucking even though it is MRU.
 27713                                  ;M039
 27714                                  
 27715                                  WBUFPLACED:
 27716 00004D5B F8                              CLC
 27717 00004D5C 16                      	push	ss
 27718 00004D5D 1F                      	pop	ds
 27719 00004D5E C3                              retn
 27720                                  
 27721                                  ;Break   <NEXTSEC -- Compute next sector to read or write>
 27722                                  ;---------------------------------------------------------------------------
 27723                                  ;
 27724                                  ; Procedure Name : NEXTSEC
 27725                                  ;
 27726                                  ; Compute the next sector to read or write
 27727                                  ; ES:BP Points to DPB
 27728                                  ;
 27729                                  ;---------------------------------------------------------------------------
 27730                                  
 27731                                  NEXTSEC:
 27732 00004D5F F606[7405]FF            	test	byte [TRANS],0FFh ; -1 
 27733 00004D64 7426                            JZ	short CLRET
 27734                                  
 27735 00004D66 A0[7305]                        MOV     AL,[SECCLUSPOS]
 27736 00004D69 FEC0                            INC     AL
 27737                                  	;cmp	al,[es:bp+4]
 27738 00004D6B 263A4604                        CMP     AL,[ES:BP+DPB.CLUSTER_MASK]
 27739 00004D6F 7618                            JBE	short SAVPOS
 27740                                  
 27741 00004D71 8B1E[BC05]                      MOV     BX,[CLUSNUM]
 27742 00004D75 E8B607                          call	IsEOF
 27743 00004D78 7314                            JAE	short NONEXT
 27744                                  
 27745 00004D7A E8C807                          call	UNPACK
 27746 00004D7D 720F                            JC	short NONEXT
 27747                                  clusgot:
 27748 00004D7F 893E[BC05]                      MOV     [CLUSNUM],DI
 27749 00004D83 FF06[BA05]                      INC     word [LASTPOS]
 27750 00004D87 B000                            MOV     AL,0
 27751                                  SAVPOS:
 27752 00004D89 A2[7305]                        MOV     [SECCLUSPOS],AL
 27753                                  CLRET:
 27754 00004D8C F8                              CLC
 27755 00004D8D C3                              retn
 27756                                  NONEXT:
 27757 00004D8E F9                              STC
 27758 00004D8F C3                              retn
 27759                                  
 27760                                  ;Break	<OPTIMIZE -- DO A USER DISK REQUEST WELL>
 27761                                  ;----------------------------------------------------------------------------
 27762                                  ;
 27763                                  ; Procedure Name : OPTIMIZE
 27764                                  ;
 27765                                  ; Inputs:
 27766                                  ;       BX = Physical cluster
 27767                                  ;       CX = No. of records
 27768                                  ;       DL = sector within cluster
 27769                                  ;       ES:BP = Base of drive parameters
 27770                                  ;       [NEXTADD] = transfer address
 27771                                  ; Outputs:
 27772                                  ;       AX = No. of records remaining
 27773                                  ;       BX = Transfer address
 27774                                  ;       CX = No. or records to be transferred
 27775                                  ;       DX = Physical sector address            (LOW)
 27776                                  ;       [HIGH_SECTOR] = Physical sector address (HIGH)
 27777                                  ;       DI = Next cluster
 27778                                  ;       [CLUSNUM] = Last cluster accessed
 27779                                  ;       [NEXTADD] updated
 27780                                  ;       Carry set if error (currently user FAILed to I 24)
 27781                                  ; ES:BP unchanged. Note that segment of transfer not set.
 27782                                  ;
 27783                                  ;---------------------------------------------------------------------------
 27784                                  
 27785                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27786                                  OPTIMIZE:
 27787 00004D90 52                      	PUSH    DX
 27788 00004D91 53                              PUSH    BX
 27789                                  	;mov	al,[es:bp+4]
 27790 00004D92 268A4604                        MOV     AL,[ES:BP+DPB.CLUSTER_MASK]
 27791 00004D96 FEC0                            INC     AL              ; Number of sectors per cluster
 27792 00004D98 88C4                            MOV     AH,AL
 27793 00004D9A 28D0                            SUB     AL,DL           ; AL = Number of sectors left in first cluster
 27794 00004D9C 89CA                            MOV     DX,CX
 27795                                  	;MOV	CX,0
 27796                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27797                                  	; 16/12/2022
 27798 00004D9E 31C9                    	xor	cx,cx	; sub cx,cx
 27799                                  OPTCLUS:
 27800                                  ; AL has number of sectors available in current cluster
 27801                                  ; AH has number of sectors available in next cluster
 27802                                  ; BX has current physical cluster
 27803                                  ; CX has number of sequential sectors found so far
 27804                                  ; DX has number of sectors left to transfer
 27805                                  ; ES:BP Points to DPB
 27806                                  ; ES:SI has FAT pointer
 27807                                  
 27808                                  do_norm3:
 27809 00004DA0 E8A207                          call	UNPACK
 27810 00004DA3 7236                            JC	short OP_ERR
 27811                                  clusgot2:
 27812 00004DA5 00C1                    	ADD	CL,AL
 27813 00004DA7 80D500                          ADC     CH,0
 27814 00004DAA 39D1                            CMP     CX,DX
 27815 00004DAC 7332                            JAE	short BLKDON
 27816 00004DAE 88E0                            MOV     AL,AH
 27817 00004DB0 43                              INC     BX
 27818 00004DB1 39DF                            CMP     DI,BX
 27819 00004DB3 74EB                            JZ	short OPTCLUS
 27820 00004DB5 4B                              DEC     BX
 27821                                  FINCLUS:
 27822 00004DB6 891E[BC05]                      MOV     [CLUSNUM],BX    ; Last cluster accessed
 27823 00004DBA 29CA                            SUB     DX,CX           ; Number of sectors still needed
 27824 00004DBC 52                              PUSH    DX
 27825 00004DBD 89C8                            MOV     AX,CX
 27826                                  	;mul	word[ES:BP+2]
 27827 00004DBF 26F76602                        MUL	word [ES:BP+DPB.SECTOR_SIZE] 
 27828                                  				; Number of sectors times sector size
 27829 00004DC3 8B36[B805]                      MOV     SI,[NEXTADD]
 27830 00004DC7 01F0                            ADD     AX,SI           ; Adjust by size of transfer
 27831 00004DC9 A3[B805]                        MOV     [NEXTADD],AX
 27832 00004DCC 58                              POP     AX              ; Number of sectors still needed
 27833 00004DCD 5A                              POP     DX              ; Starting cluster
 27834 00004DCE 29D3                            SUB     BX,DX           ; Number of new clusters accessed
 27835 00004DD0 011E[BA05]                      ADD     [LASTPOS],BX
 27836 00004DD4 5B                              POP     BX              ; BL = sector position within cluster
 27837 00004DD5 E81600                  	call	FIGREC
 27838 00004DD8 89F3                            MOV     BX,SI
 27839                                  	; 24/09/2023
 27840                                  	; cf=0 (at the return of FIGREC)
 27841                                  	;CLC
 27842 00004DDA C3                              retn
 27843                                  OP_ERR:
 27844 00004DDB 83C404                          ADD     SP,4
 27845 00004DDE F9                      	STC
 27846 00004DDF C3                              retn
 27847                                  BLKDON:
 27848 00004DE0 29D1                            SUB     CX,DX           ; Number of sectors in cluster we don't want
 27849 00004DE2 28CC                            SUB     AH,CL           ; Number of sectors in cluster we accepted
 27850 00004DE4 FECC                            DEC     AH              ; Adjust to mean position within cluster
 27851 00004DE6 8826[7305]                      MOV     [SECCLUSPOS],AH
 27852 00004DEA 89D1                            MOV     CX,DX           ; Anyway, make the total equal to the request
 27853 00004DEC EBC8                            JMP     SHORT FINCLUS
 27854                                  
 27855                                  ;Break	<FIGREC -- Figure sector in allocation unit>
 27856                                  ;---------------------------------------------------------------------------
 27857                                  ;
 27858                                  ; Procedure Name : FIGREC
 27859                                  ;
 27860                                  ; Inputs:
 27861                                  ;       DX = Physical cluster number
 27862                                  ;       BL = Sector position within cluster
 27863                                  ;       ES:BP = Base of drive parameters
 27864                                  ; Outputs:
 27865                                  ;       DX = physical sector number           (LOW)
 27866                                  ;       [HIGH_SECTOR] Physical sector address (HIGH)
 27867                                  ; No other registers affected.
 27868                                  ;
 27869                                  ;---------------------------------------------------------------------------
 27870                                  
 27871                                  	; 10/06/2019
 27872                                  	; 20/05/2019 - Retro DOS v4.0
 27873                                  	; DOSCODE:8D96h (MSDOS 6.21, MSDOS.SYS)
 27874                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27875                                  	; DOSCODE:8D5Bh (MSDOS 5.0, MSDOS.SYS)	
 27876                                  FIGREC:
 27877 00004DEE 51                              PUSH    CX
 27878                                  	;mov	cl,[es:bp+5]
 27879 00004DEF 268A4E05                        MOV     CL,[ES:BP+DPB.CLUSTER_SHIFT]
 27880 00004DF3 4A                              DEC     DX
 27881 00004DF4 4A                              DEC     DX
 27882                                  
 27883                                  	; MSDOS 3.3
 27884                                  	;SHL	DX,CL
 27885                                  
 27886                                  ;hkn; SS override HIGH_SECTOR
 27887                                  	; MSDOS 6.0
 27888 00004DF5 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0		;F.C. >32mb
 27889                                  	; 24/09/2023
 27890 00004DFC 30ED                    	xor	ch,ch				;F.C. >32mb
 27891 00004DFE 08C9                    	OR	CL,CL				;F.C. >32mb
 27892 00004E00 740C                    	JZ	short noshift			;F.C. >32mb
 27893 00004E02 30ED                    	XOR	CH,CH				;F.C. >32mb
 27894                                  rotleft:					;F.C. >32mb
 27895 00004E04 F8                      	CLC					;F.C. >32mb
 27896 00004E05 D1D2                    	RCL	DX,1				;F.C. >32mb
 27897                                  	; 10/06/2019
 27898 00004E07 36D116[0706]            	RCL	word [ss:HIGH_SECTOR],1		;F.C. >32mb
 27899 00004E0C E2F6                    	LOOP	rotleft				;F.C. >32mb
 27900                                  noshift:
 27901                                  	; MSDOS 3.3 & MSDOS 6.0
 27902 00004E0E 08DA                            OR      DL,BL
 27903                                  	;add	dx,[es:bp+0Bh]
 27904 00004E10 2603560B                        ADD     DX,[ES:BP+DPB.FIRST_SECTOR]
 27905                                  	; MSDOS 6.0
 27906                                  	; 10/06/2019
 27907                                  	;ADC	word [ss:HIGH_SECTOR],0		;F.C. >32mb
 27908                                  	; 24/09/2023
 27909                                  	; cx=0
 27910 00004E14 36110E[0706]            	ADC	word [ss:HIGH_SECTOR],cx ; 0
 27911                                  
 27912                                  	; MSDOS 3.3 & MSDOS 6.0
 27913 00004E19 59                      	POP     CX
 27914                                  figrec_retn:
 27915 00004E1A C3                              retn
 27916                                  
 27917                                  ; 20/05/2019 - Retro DOS v4.0
 27918                                  ; DOSCODE:8DC2h (MSDOS 6.21, MSDOS.SYS)
 27919                                  
 27920                                  ; 30/07/2018 - Retro DOS v3.0
 27921                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 
 27922                                  
 27923                                  ;Break   <ALLOCATE -- Assign disk space>
 27924                                  ;---------------------------------------------------------------------------
 27925                                  ;
 27926                                  ; Procedure Name : ALLOCATE - Allocate Disk Space
 27927                                  ;
 27928                                  ;   ALLOCATE is called to allocate disk clusters. The new clusters are
 27929                                  ;   FAT-chained onto the end of the existing file.
 27930                                  ;
 27931                                  ;   The DPB contains the cluster # of the last free cluster allocated
 27932                                  ;   (dpb_next_free). We start at this cluster and scan towards higher
 27933                                  ;   numbered clusters, looking for the necessary free blocks.
 27934                                  ;
 27935                                  ;   Once again, fancy terminology gets in the way of correct coding. When
 27936                                  ;   using next_free, start scanning AT THAT POINT and not the one following it.
 27937                                  ;   This fixes the boundary condition bug when only free = next_free = 2.
 27938                                  ;
 27939                                  ;       If we get to the end of the disk without satisfaction:
 27940                                  ;
 27941                                  ;           if (dpb_next_free == 2) then we've scanned the whole disk.
 27942                                  ;               return (insufficient_disk_space)
 27943                                  ;           ELSE
 27944                                  ;               dpb_next_free = 2; start scan over from the beginning.
 27945                                  ;
 27946                                  ;   Note that there is no multitasking interlock. There is no race when
 27947                                  ;   examining the entrys in an in-core FAT block since there will be no
 27948                                  ;   context switch. When UNPACK context switches while waiting for a FAT read
 27949                                  ;   we are done with any in-core FAT blocks, so again there is no race. The
 27950                                  ;   only special concern is that V2 and V3 MSDOS left the last allocated
 27951                                  ;   cluster as "00"; marking it EOF only when the entire alloc request was
 27952                                  ;   satisfied. We can't allow another activation to think this cluster is
 27953                                  ;   free, so we give it a special temporary mark to show that it is, indeed,
 27954                                  ;   allocated.
 27955                                  ;
 27956                                  ;   Note that when we run out of space this algorithem will scan from
 27957                                  ;   dpb_next_free to the end, then scan from cluster 2 through the end,
 27958                                  ;   redundantly scanning the later part of the disk. This only happens when
 27959                                  ;   we run out of space, so sue me.
 27960                                  ;
 27961                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 27962                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 27963                                  ;                                                                          ;
 27964                                  ;   The use of FATBYT and RESTFATBYT is somewhat mysterious. Here is the
 27965                                  ;   explanation:
 27966                                  ;
 27967                                  ;   In the NUL file case (sf_firclus currently 0) ALLOCATE is called with
 27968                                  ;   entry BX = 0. What needs to be done in this case is to stuff the cluster
 27969                                  ;   number of the first cluster allocated in sf_firclus when the ALLOCATE is
 27970                                  ;   complete. THIS VALUE IS SAVED TEMPORARILY IN CLUSTER 0, HENCE THE CURRENT
 27971                                  ;   VALUE IN CLUSTER 0 MUST BE SAVED AND RESTORED. This is a side effect of
 27972                                  ;   the fact that PACK and UNPACK don't treat requests for clusters 0 and 1 as
 27973                                  ;   errors. This "stuff" is done by the call to PACK which is right before
 27974                                  ;   the
 27975                                  ;           LOOP   findfre         ; alloc more if needed
 27976                                  ;   instruction when the first cluster is allocated to the nul file. The
 27977                                  ;   value is recalled from cluster 0 and stored at sf_firclus at ads4:
 27978                                  ;
 27979                                  ;   This method is obviously useless (because it is non-reentrant) for
 27980                                  ;   multitasking, and will have to be changed. Storing the required value on
 27981                                  ;   the stack is recommended. Setting sf_firclus at the PACK of cluster 0
 27982                                  ;   (instead of actually doing the PACK) is BAD because it doesn't handle
 27983                                  ;   problems with INT 24 well.
 27984                                  ;
 27985                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 27986                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 27987                                  ;                                                                          ;
 27988                                  ;       ENTRY   BX = Last cluster of file (0 if null file)
 27989                                  ;               CX = No. of clusters to allocate
 27990                                  ;               ES:BP = Base of drive parameters
 27991                                  ;               [THISSFT] = Points to SFT
 27992                                  ;
 27993                                  ;       EXIT    'C' set if insufficient space
 27994                                  ;                 [FAILERR] can be tested to see the reason for failure
 27995                                  ;                 CX = max. no. of clusters that could be added to file
 27996                                  ;               'C' clear if space allocated
 27997                                  ;                 BX = First cluster allocated
 27998                                  ;                 FAT is fully updated
 27999                                  ;                 sf_FIRCLUS field of SFT set if file was null
 28000                                  ;
 28001                                  ;       USES    ALL but SI, BP
 28002                                  
 28003                                  ;callmagic  proc near
 28004                                  ;       push    ds                             ;push segment of routine 
 28005                                  ;       push    Offset MagicPatch              ;push offset for routine
 28006                                  ;       retf                                   ;simulate jmp far
 28007                                  ;                                              ;far return address is on
 28008                                  ;                                              ;stack, so far return from
 28009                                  ;                                              ;call will return this routine
 28010                                  ;callmagic  endp
 28011                                  
 28012                                  
 28013                                  ; 25/09/2023
 28014                                  %if 0
 28015                                  callmagic:
 28016                                  	push	ds
 28017                                  	push	MagicPatch
 28018                                  	retf	
 28019                                  %endif
 28020                                  
 28021                                  ALLOCATE:
 28022                                  	; 10/09/2018
 28023                                  ;BEGIN MAGICDRV MODIFICATIONS
 28024                                  ;
 28025                                  ;7/5/92 scottq
 28026                                  ;
 28027                                  ;This is the disk compression patch location which allows
 28028                                  ;the disk compression software to fail allocations if the
 28029                                  ;FAT would allows allocation, but the free space for compressed
 28030                                  ;data would not.
 28031                                  ;        
 28032                                  ;;;	call    far ptr MAGICPATCH
 28033                                  ;;; We cannot do a far call since we cannot have fix-ups[romdos,hidos],
 28034                                  ;;; but we do know the segment and offset of the routine
 28035                                  ;;; so simulate a far call to dosdata:magicpatch
 28036                                  ;;; note dosassume above, so DS -> dosdata
 28037                                  
 28038                                  	; MSDOS 6.0
 28039                                          ;clc				;clear carry so we fall through
 28040                                  	;				;if no patch is present
 28041                                  	;push	cs			;push segment for far return
 28042                                          ;call	callmagic		;this is a near call
 28043                                          ;jnc	short Regular_Allocate_Path
 28044                                  	;jmp	Disk_Full_Return
 28045                                  
 28046                                  ; 25/09/2023
 28047                                  %if 0
 28048                                  	clc
 28049                                  	push	cs
 28050                                  	call	callmagic
 28051                                  	jnc	short Regular_Allocate_Path
 28052                                  	jmp	Disk_Full_Return
 28053                                  Regular_Allocate_Path:
 28054                                  %endif
 28055                                  
 28056                                  	; 20/05/2019 - Retro DOS v4.0
 28057                                  ;END MAGICDRV MODIFICATIONS
 28058                                  
 28059                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28060                                  	; DOSCODE:8D87h (MSDOS 5.0, MSDOS.SYS)
 28061                                  
 28062 00004E1B 53                              PUSH    BX                      ; save (bx)
 28063 00004E1C 31DB                            XOR     BX,BX
 28064 00004E1E E82407                  	call	UNPACK
 28065 00004E21 893E[9605]                      MOV     [FATBYT],DI             ; save correct cluster 0 value
 28066 00004E25 5B                              POP     BX
 28067 00004E26 72F2                            jc	short figrec_retn	; abort if error   [INTERR?]
 28068                                  
 28069 00004E28 51                              PUSH    CX
 28070 00004E29 53                              PUSH    BX
 28071                                  
 28072 00004E2A 89DA                            MOV     DX,BX
 28073                                  	;;mov	bx,[es:bp+1Ch]  ; MSDOS 3.3
 28074                                  	;mov	bx,[es:bp+1Dh]	; MSDOS 6.0
 28075 00004E2C 268B5E1D                        mov     bx,[ES:BP+DPB.NEXT_FREE]
 28076 00004E30 83FB02                          cmp     bx,2
 28077 00004E33 7709                            ja	short FINDFRE
 28078                                  
 28079                                  ;   couldn't find enough free space beyond dpb_next_free, or dpb_next_free is
 28080                                  ;   <2 or >dpb_max_clus. Reset it and restart the scan
 28081                                  
 28082                                  ads1:
 28083                                  	;;mov	word [es:bp+1Ch],2 ; MSDOS 3.3
 28084                                  	;mov	word [es:bp+1Dh],2 ; MSDOS 6.0
 28085 00004E35 26C7461D0200                    mov     word [ES:BP+DPB.NEXT_FREE],2
 28086 00004E3B BB0100                          mov     bx,1                    ; Counter next instruction so first
 28087                                                                          ;       cluster examined is 2
 28088                                  
 28089                                  ;   Scanning both forwards and backwards for a free cluster
 28090                                  ;
 28091                                  ;       (BX) = forwards scan pointer
 28092                                  ;       (CX) = clusters remaining to be allocated
 28093                                  ;       (DX) = current last cluster in file
 28094                                  ;       (TOS) = last cluster of file
 28095                                  
 28096                                  FINDFRE:
 28097 00004E3E 43                              INC     BX
 28098                                  	;cmp	bx,[es:bp+0Dh]
 28099 00004E3F 263B5E0D                        CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 28100 00004E43 7757                    	ja	short ads7	; at end of disk
 28101 00004E45 E8FD06                          call	UNPACK          ; check out this cluster
 28102 00004E48 722F                            jc	short ads4	; FAT error             [INTERR?]
 28103 00004E4A 75F2                            jnz	short FINDFRE	; not free, keep on truckin
 28104                                  
 28105                                  ;   Have found a free cluster. Chain it to the file
 28106                                  ;
 28107                                  ;       (BX) = found free cluster #
 28108                                  ;       (DX) = current last cluster in file
 28109                                  
 28110                                  	;;mov	[es:bp+1Ch],bx
 28111                                  	;mov	[es:bp+1Dh],bx ; MSDOS 6.0
 28112 00004E4C 26895E1D                        mov	[ES:BP+DPB.NEXT_FREE],bx ; next time start search here
 28113 00004E50 92                              xchg    ax,dx           ; save (dx) in ax
 28114 00004E51 BA0100                          mov     dx,1            ; mark this free guy as "1"
 28115 00004E54 E84207                  	call	PACK            ; set special "temporary" mark
 28116 00004E57 7220                            jc	short ads4	; FAT error             [INTERR?]
 28117                                  	;;cmp	word [es:bp+1Eh],-1
 28118                                          ;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
 28119 00004E59 26837E1FFF              	CMP	word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 28120 00004E5E 7404                            JZ	short NO_ALLOC	; No
 28121                                  	;;dec	word [es:bp+1Eh]
 28122                                          ;dec	word [es:bp+1Fh] ; MSDOS 6.0
 28123 00004E60 26FF4E1F                        DEC     word [ES:BP+DPB.FREE_CNT] ; Reduce free count by 1
 28124                                  NO_ALLOC:
 28125 00004E64 92                              xchg    ax,dx           ; (dx) = current last cluster in file
 28126 00004E65 87DA                            XCHG    BX,DX
 28127 00004E67 89D0                            MOV     AX,DX
 28128 00004E69 E82D07                  	call	PACK            ; link free cluster onto file
 28129                                                                  ;  CAVEAT.. On Nul file, first pass stuffs
 28130                                                                  ;    cluster 0 with FIRCLUS value.
 28131 00004E6C 720B                            jc	short ads4	; FAT error [INTERR?]
 28132 00004E6E 93                              xchg    BX,AX           ; (BX) = last one we looked at
 28133 00004E6F 89DA                            mov     dx,bx           ; (dx) = current end of file
 28134 00004E71 E2CB                            LOOP    FINDFRE         ; alloc more if needed
 28135                                  
 28136                                  ;   We've successfully extended the file. Clean up and exit
 28137                                  ;
 28138                                  ;       (BX) = last cluster in file
 28139                                  
 28140 00004E73 BAFFFF                          MOV     DX,0FFFFH
 28141 00004E76 E82007                  	call	PACK            ; mark last cluster EOF
 28142                                  
 28143                                  ;   Note that FAT errors jump here to clean the stack and exit. This saves us
 28144                                  ;   2 whole bytes. Hope its worth it...
 28145                                  ;
 28146                                  ;       'C' set if error
 28147                                  ;       calling (BX) and (CX) pushed on stack
 28148                                  
 28149                                  ads4:   
 28150 00004E79 5B                      	POP     BX
 28151 00004E7A 59                              POP     CX              ; Don't need this stuff since we're successful
 28152 00004E7B 729D                            jc	short figrec_retn
 28153 00004E7D E8C506                          call	UNPACK          ; Get first cluster allocated for return
 28154                                                                  ; CAVEAT... In nul file case, UNPACKs cluster 0.
 28155 00004E80 7298                            jc	short figrec_retn
 28156 00004E82 E83200                  	call	RESTFATBYT      ; Restore correct cluster 0 value
 28157 00004E85 7293                            jc	short figrec_retn
 28158 00004E87 87DF                            XCHG    BX,DI           ; (DI) = last cluster in file upon our entry
 28159 00004E89 09FF                            OR      DI,DI           ; clear 'C'
 28160 00004E8B 758D                    	jnz	short figrec_retn ; we were extending an existing file
 28161                                  
 28162                                  ;   We were doing the first allocation for a new file. Update the SFT cluster
 28163                                  ;   info
 28164                                  dofastk:
 28165                                  	; 20/05/2019
 28166                                  	; MSDOS 6.0
 28167                                  	;push	dx ; * MSDOS 6.0
 28168                                  	;;mov	dl,[es:bp+0]
 28169                                  	;;MOV	DL,[ES:BP+DPB.DRIVE]	; get drive #
 28170                                  	;mov	dl,[es:bp]
 28171                                  
 28172                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28173                                  	; DOSCODE:8DF9h (MSDOS 5.0, MSDOS.SYS)
 28174                                  	
 28175                                  	; 16/12/2022
 28176                                  	;push	dx ; *
 28177                                  	;mov	dl,[ES:BP+DPB.DRIVE] 
 28178                                  	; 15/12/2022
 28179                                  	;mov	dl,[es:bp]
 28180                                  	
 28181                                  	; MSDOS 3.3 & MSDOS 6.0
 28182 00004E8D 06                      	PUSH	ES
 28183 00004E8E C43E[9E05]              	LES     DI,[THISSFT]
 28184                                  	;mov	[es:di+0Bh],bx
 28185 00004E92 26895D0B                	MOV     [ES:DI+SF_ENTRY.sf_firclus],BX
 28186                                  	;;mov	[es:di+1Bh],bx ; MSDOS 3.3
 28187                                  	;mov	[es:di+35h],bx ; MSDOS 6.0
 28188 00004E96 26895D35                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],BX
 28189 00004E9A 07                      	POP	ES
 28190                                  	;retn
 28191                                  
 28192                                  	;pop	dx ; * MSDOS 6.0
 28193                                  
 28194                                  	; 16/12/2022
 28195                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28196                                  	;pop	dx ; *
 28197                                  
 28198 00004E9B C3                      	retn	
 28199                                  
 28200                                  ;** we're at the end of the disk, and not satisfied. See if we've scanned ALL
 28201                                  ;   of the disk...
 28202                                  
 28203                                  ads7:   
 28204 00004E9C 26837E1D02              	cmp	word [ES:BP+DPB.NEXT_FREE],2
 28205 00004EA1 7592                    	jnz	short ads1	; start scan from front of disk
 28206                                  
 28207                                  ;   Sorry, we've gone over the whole disk, with insufficient luck. Lets give
 28208                                  ;   the space back to the free list and tell the caller how much he could have
 28209                                  ;   had.  We have to make sure we remove the "special mark" we put on the last
 28210                                  ;   cluster we were able to allocate, so it doesn't become orphaned.
 28211                                  ;
 28212                                  ;       (CX) = clusters remaining to be allocated
 28213                                  ;       (TOS) = last cluster of file (before call to ALLOCATE)
 28214                                  ;       (TOS+1) = # of clusters wanted to allocate
 28215                                  
 28216 00004EA3 5B                              POP     BX              ; (BX) = last cluster of file
 28217 00004EA4 BAFFFF                          MOV     DX,0FFFFH
 28218 00004EA7 E81F00                  	call	RELBLKS         ; give back any clusters just alloced
 28219 00004EAA 58                              POP     AX              ; No. of clusters requested
 28220                                                                  ; Don't "retc". We are setting Carry anyway,
 28221                                                                  ;   Alloc failed, so proceed with return CX
 28222                                                                  ;   setup.
 28223 00004EAB 29C8                            SUB     AX,CX           ; AX=No. of clusters allocated
 28224 00004EAD E80700                  	call	RESTFATBYT      ; Don't "retc". We are setting Carry anyway,
 28225                                                                  ;   Alloc failed.
 28226                                  Disk_Full_Return:               ;label added for magic patch 8-6-92 scottq
 28227                                          ; MSDOS 6.0
 28228 00004EB0 C606[0B06]01            	MOV	byte [DISK_FULL],1 ;MS. indicating disk full
 28229 00004EB5 F9                              STC
 28230 00004EB6 C3                              retn
 28231                                  
 28232                                  ;-----------------------------------------------------------------------
 28233                                  ;
 28234                                  ; Procedure Name : RESTFATBYT
 28235                                  ;
 28236                                  ; SEE ALLOCATE CAVEAT
 28237                                  ;       Carry set if error (currently user FAILed to I 24)
 28238                                  ;-----------------------------------------------------------------------
 28239                                  
 28240                                  RESTFATBYT:
 28241 00004EB7 53                              PUSH    BX
 28242 00004EB8 52                              PUSH    DX
 28243 00004EB9 57                              PUSH    DI
 28244 00004EBA 31DB                            XOR     BX,BX
 28245 00004EBC 8B16[9605]                      MOV     DX,[FATBYT]
 28246 00004EC0 E8D606                  	call	PACK
 28247 00004EC3 5F                              POP     DI
 28248 00004EC4 5A                              POP     DX
 28249 00004EC5 5B                              POP     BX
 28250                                  ; 16/12/2022
 28251                                  ; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28252                                  ;RELEASE_flush:
 28253 00004EC6 C3                      	retn
 28254                                  
 28255                                  ;Break	<RELEASE -- DEASSIGN DISK SPACE>
 28256                                  ;---------------------------------------------------------------------------
 28257                                  ;
 28258                                  ; Procedure Name : RELEASE
 28259                                  ;
 28260                                  ; Inputs:
 28261                                  ;       BX = Cluster in file
 28262                                  ;       ES:BP = Base of drive parameters
 28263                                  ; Function:
 28264                                  ;       Frees cluster chain starting with [BX]
 28265                                  ;       Carry set if error (currently user FAILed to I 24)
 28266                                  ; AX,BX,DX,DI all destroyed. Other registers unchanged.
 28267                                  ;
 28268                                  ;-----------------------------------------------------------------------------
 28269                                  
 28270                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28271                                  	; 20/05/2019 - Retro DOS v4.0
 28272                                  RELEASE:
 28273 00004EC7 31D2                            XOR     DX,DX
 28274                                  
 28275                                  	;entry	RELBLKS
 28276                                  RELBLKS:
 28277                                  
 28278                                  ;   Enter here with DX=0FFFFH to put an end-of-file mark in the first cluster
 28279                                  ;   and free the rest in the chain.
 28280                                  
 28281 00004EC9 E87906                  	call	UNPACK
 28282 00004ECC 7224                    	jc	short RELEASE_flush
 28283 00004ECE 7422                    	jz	short RELEASE_flush
 28284 00004ED0 89F8                            MOV     AX,DI
 28285 00004ED2 52                              PUSH    DX
 28286 00004ED3 E8C306                  	call	PACK
 28287 00004ED6 5A                              POP     DX
 28288 00004ED7 7219                    	jc	short RELEASE_flush
 28289 00004ED9 09D2                            OR      DX,DX
 28290 00004EDB 750B                            JNZ	short NO_DEALLOC	; Was putting EOF mark
 28291                                  	;;cmp	word [es:bp+1Eh],-1 ; MSDOS 3.3
 28292                                  	;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
 28293 00004EDD 26837E1FFF              	CMP     word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 28294 00004EE2 7404                            JZ	short NO_DEALLOC	; No
 28295 00004EE4 26FF461F                        INC	word [ES:BP+DPB.FREE_CNT] ; Increase free count by 1
 28296                                  NO_DEALLOC:
 28297 00004EE8 89C3                            MOV     BX,AX
 28298 00004EEA 48                              dec     ax              ; check for "1"
 28299 00004EEB 7405                    	jz	short RELEASE_flush	; is last cluster of incomplete chain
 28300 00004EED E83E06                  	call	IsEOF
 28301 00004EF0 72D5                            JB	short RELEASE	; Carry clear if JMP not taken
 28302                                  
 28303                                  	; 16/12/2022
 28304                                  ; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28305                                  ;%if 0
 28306                                  RELEASE_flush:
 28307                                  	; MSDOS 6.0
 28308 00004EF2 268A4600                	mov	al,[es:bp]
 28309                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 28310 00004EF6 56                      	push	si		; FLUSHBUF may trash these and we guarantee
 28311 00004EF7 51                      	push	cx		;  them to be preserved.
 28312 00004EF8 06                      	push	es
 28313 00004EF9 55                      	push	bp
 28314 00004EFA E8570B                  	call	FLUSHBUF	; commit buffers for this drive
 28315 00004EFD 5D                      	pop	bp
 28316 00004EFE 07                      	pop	es
 28317 00004EFF 59                      	pop	cx
 28318 00004F00 5E                      	pop	si
 28319                                  ;%endif
 28320                                  RET12:
 28321 00004F01 C3                      	retn
 28322                                  
 28323                                  ;Break	<GETEOF -- Find the end of a file>
 28324                                  ;------------------------------------------------------------------------
 28325                                  ;
 28326                                  ; Procedure Name : GETEOF
 28327                                  ;
 28328                                  ; Inputs:
 28329                                  ;       ES:BP Points to DPB
 28330                                  ;       BX = Cluster in a file
 28331                                  ;       DS = CS
 28332                                  ; Outputs:
 28333                                  ;       BX = Last cluster in the file
 28334                                  ;       Carry set if error (currently user FAILed to I 24)
 28335                                  ; DI destroyed. No other registers affected.
 28336                                  ;
 28337                                  ;--------------------------------------------------------------------------
 28338                                  
 28339                                  GETEOF:
 28340 00004F02 E84006                  	call	UNPACK
 28341 00004F05 72FA                            jc	short RET12
 28342 00004F07 53                              PUSH    BX
 28343 00004F08 89FB                            MOV     BX,DI
 28344 00004F0A E82106                  	call	IsEOF
 28345 00004F0D 5B                              POP     BX
 28346 00004F0E 73F1                            JAE     short RET12
 28347 00004F10 89FB                            MOV     BX,DI
 28348 00004F12 EBEE                            JMP     short GETEOF
 28349                                  
 28350                                  ;============================================================================
 28351                                  ; FCB.ASM, MSDOS 6.0, 1991
 28352                                  ;============================================================================
 28353                                  ; 30/07/2018 - Retro DOS v3.0
 28354                                  ; 20/05/2019 - Retro DOS v4.0
 28355                                  
 28356                                  ;	TITLE	FCB - FCB parse calls for MSDOS
 28357                                  ;	NAME	FCB
 28358                                  
 28359                                  ;**	FCB.ASM - Low level routines for parsing names into FCBs and analyzing
 28360                                  ;		  filename characters
 28361                                  ;
 28362                                  ;	MakeFcb
 28363                                  ;	NameTrans
 28364                                  ;	PATHCHRCMP
 28365                                  ;	GetLet
 28366                                  ;	UCase
 28367                                  ;	GetLet3
 28368                                  ;	GetCharType
 28369                                  ;	TESTKANJ
 28370                                  ;	NORMSCAN
 28371                                  ;	DELIM
 28372                                  ;
 28373                                  ;	Revision history:
 28374                                  ;
 28375                                  ;		A000  version 4.00  Jan. 1988
 28376                                  ;	
 28377                                  ;	M048 - access FILE_UCASE_TAB using DS rather than SS.
 28378                                  
 28379                                  TableLook	EQU	-1
 28380                                  
 28381                                  SCANSEPARATOR	EQU	1
 28382                                  DRVBIT		EQU	2
 28383                                  NAMBIT		EQU	4
 28384                                  EXTBIT		EQU	8
 28385                                  
 28386                                  ;----------------------------------------------------------------------------
 28387                                  ;
 28388                                  ; Procedure : MakeFcb
 28389                                  ;
 28390                                  ;----------------------------------------------------------------------------
 28391                                  
 28392                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28393                                  	; DOSCODE:8E77h (MSDOS 5.0, MSDOS.SYS)
 28394                                  MAKEFCB:
 28395                                  ;hkn; SS override
 28396 00004F14 36C606[4E03]00          	MOV	BYTE [SS:SpaceFlag],0
 28397 00004F1A 30D2                    	XOR	DL,DL		; Flag--not ambiguous file name
 28398                                  	;test	al,2
 28399 00004F1C A802                    	test	AL,DRVBIT	; Use current drive field if default?
 28400 00004F1E 7504                    	JNZ	short DEFDRV
 28401 00004F20 26C60500                	MOV	BYTE [ES:DI],0	; No - use default drive
 28402                                  DEFDRV:
 28403 00004F24 47                      	INC	DI
 28404 00004F25 B90800                  	MOV	CX,8
 28405                                  	;test	al,4
 28406 00004F28 A804                    	test	AL,NAMBIT	; Use current name fields as default?
 28407 00004F2A 93                      	XCHG	AX,BX		; Save bits in BX
 28408 00004F2B B020                    	MOV	AL," "
 28409 00004F2D 7404                    	JZ	short FILLB	; If not, go fill with blanks
 28410 00004F2F 01CF                    	ADD	DI,CX
 28411 00004F31 31C9                    	XOR	CX,CX		; Don't fill any
 28412                                  FILLB:
 28413 00004F33 F3AA                    	REP	STOSB
 28414 00004F35 B103                    	MOV	CL,3
 28415 00004F37 F6C308                  	test	BL,EXTBIT	; Use current extension as default
 28416 00004F3A 7404                    	JZ	short FILLB2
 28417 00004F3C 01CF                    	ADD	DI,CX
 28418 00004F3E 31C9                    	XOR	CX,CX
 28419                                  FILLB2:
 28420 00004F40 F3AA                    	REP	STOSB
 28421 00004F42 91                      	XCHG	AX,CX		; Put zero in AX
 28422 00004F43 AB                      	STOSW
 28423 00004F44 AB                      	STOSW			; Initialize two words after to zero
 28424 00004F45 83EF10                  	SUB	DI,16		; Point back at start
 28425                                  	;test	bl,1
 28426 00004F48 F6C301                  	test	BL,SCANSEPARATOR; Scan off separators if not zero
 28427 00004F4B 7409                    	JZ	short SKPSPC
 28428 00004F4D E88800                  	CALL	SCANB		; Peel off blanks and tabs
 28429 00004F50 E82201                  	CALL	DELIM		; Is it a one-time-only delimiter?
 28430 00004F53 7504                    	JNZ	short NOSCAN
 28431 00004F55 46                      	INC	SI		; Skip over the delimiter
 28432                                  SKPSPC:
 28433 00004F56 E87F00                  	CALL	SCANB		; Always kill preceding blanks and tabs
 28434                                  NOSCAN:
 28435 00004F59 E8F000                  	CALL	GETLET
 28436 00004F5C 761E                    	JBE	short NODRV	; Quit if termination character
 28437 00004F5E 803C3A                  	CMP	BYTE [SI],":"	; Check for potential drive specifier
 28438 00004F61 7519                    	JNZ	short NODRV
 28439 00004F63 46                      	INC	SI		; Skip over colon
 28440 00004F64 2C40                    	SUB	AL,"@"          ; Convert drive letter to drive number (A=1)
 28441 00004F66 760F                    	JBE	short BADDRV	; Drive letter out of range
 28442                                  
 28443 00004F68 50                      	PUSH	AX
 28444 00004F69 E8161B                  	call	GetVisDrv
 28445 00004F6C 58                      	POP	AX
 28446 00004F6D 730A                    	JNC	short HAVDRV
 28447                                  
 28448                                  	; 20/05/2019 - Retro DOS v4.0
 28449                                  	; MSDOS 6.0
 28450                                  ;hkn; SS override
 28451 00004F6F 36803E[1006]1A          	CMP	byte [SS:DrvErr],error_not_DOS_disk ; 1Ah
 28452                                  					; if not FAT drive ;AN000;
 28453 00004F75 7402                    	JZ	short HAVDRV		; assume ok	   ;AN000;
 28454                                  BADDRV:
 28455 00004F77 B2FF                    	MOV	DL,-1
 28456                                  HAVDRV:
 28457 00004F79 AA                      	STOSB			; Put drive specifier in first byte
 28458 00004F7A 46                      	INC	SI
 28459 00004F7B 4F                      	DEC	DI		; Counteract next two instructions
 28460                                  NODRV:
 28461 00004F7C 4E                      	DEC	SI		; Back up
 28462 00004F7D 47                      	INC	DI		; Skip drive byte
 28463                                  
 28464                                  	;entry	NORMSCAN
 28465                                  NORMSCAN:
 28466 00004F7E B90800                  	MOV	CX,8
 28467 00004F81 E82200                  	CALL	GETWORD 	; Get 8-letter file name
 28468 00004F84 803C2E                  	CMP	BYTE [SI],"."
 28469 00004F87 7510                    	JNZ	short NODOT
 28470 00004F89 46                      	INC	SI		; Skip over dot if present
 28471                                  
 28472                                  	; 24/09/2023
 28473                                  	;mov	cx,3
 28474 00004F8A B103                    	mov	cl,3	; ch=0
 28475                                  
 28476                                  	; MSDOS 6.0
 28477                                  ;hkn; SS override
 28478                                  	;TEST	word [SS:DOS34_FLAG],DBCS_VOLID2 ; 100h ;AN000;
 28479                                  	; 10/06/2019
 28480 00004F8C 36F606[1206]01          	test	byte [SS:DOS34_FLAG+1],(DBCS_VOLID2>>8) ; 1
 28481 00004F92 7402                    	JZ	short VOLOK				;AN000;
 28482 00004F94 A4                      	MOVSB			; 2nd byte of DBCS	;AN000;
 28483                                  	; 24/09/2023
 28484                                  	;MOV	CX,2					;AN000;
 28485 00004F95 49                      	dec	cx  ; cx=2
 28486                                  	;JMP	SHORT contvol				;AN000;
 28487                                  VOLOK:
 28488                                  	;MOV	CX,3		; Get 3-letter extension
 28489                                  contvol:
 28490 00004F96 E81300                  	CALL	MUSTGETWORD
 28491                                  NODOT:
 28492 00004F99 88D0                    	MOV	AL,DL
 28493                                  
 28494                                  	; MSDOS 6.0
 28495                                  	;and	word [ss:DOS34_FLAG],0FEFFh
 28496                                  	; 18/12/2022
 28497 00004F9B 368026[1206]FE          	and	byte [ss:DOS34_FLAG+1],0FEh ; (~DBCS_VOLID2)>>8
 28498                                  	;and	word [ss:DOS34_FLAG],~DBCS_VOLID2 ; ### BUG FIX ###
 28499                                  
 28500 00004FA1 C3                      	retn
 28501                                  
 28502                                  NONAM:
 28503 00004FA2 01CF                    	ADD	DI,CX
 28504 00004FA4 4E                      	DEC	SI
 28505 00004FA5 C3                      	retn
 28506                                  
 28507                                  GETWORD:
 28508 00004FA6 E8A300                  	CALL	GETLET		
 28509 00004FA9 76F7                    	JBE	short NONAM	; Exit if invalid character
 28510 00004FAB 4E                      	DEC	SI
 28511                                  
 28512                                  ;	UGH!!! Horrible bug here that should be fixed at some point:
 28513                                  ;	If the name we are scanning is longer than CX, we keep on reading!
 28514                                  
 28515                                  MUSTGETWORD:
 28516 00004FAC E89D00                  	CALL	GETLET
 28517                                  
 28518                                  ;	If spaceFlag is set then we allow spaces in a pathname
 28519                                  
 28520                                  ;IF NOT TABLELOOK
 28521                                  ;	JB	short FILLNAM  ; MSDOS 3.3
 28522                                  ;ENDIF
 28523 00004FAF 750C                    	JNZ	short MustCheckCX
 28524                                  
 28525                                  ;hkn; SS override
 28526 00004FB1 36F606[4E03]FF          	test	BYTE [SS:SpaceFlag],0FFh
 28527 00004FB7 7419                    	JZ	short FILLNAM
 28528 00004FB9 3C20                    	CMP	AL," "
 28529 00004FBB 7515                    	JNZ	short FILLNAM
 28530                                  
 28531                                  MustCheckCX:
 28532 00004FBD E3ED                    	JCXZ	MUSTGETWORD
 28533 00004FBF 49                      	DEC	CX
 28534 00004FC0 3C2A                    	CMP	AL,"*"          ; Check for ambiguous file specifier
 28535 00004FC2 7504                    	JNZ	short NOSTAR
 28536 00004FC4 B03F                    	MOV	AL,"?"
 28537 00004FC6 F3AA                    	REP	STOSB
 28538                                  NOSTAR:
 28539 00004FC8 AA                      	STOSB
 28540 00004FC9 3C3F                    	CMP	AL,"?"
 28541 00004FCB 75DF                    	JNZ	short MUSTGETWORD
 28542 00004FCD 80CA01                  	OR	DL,1		; Flag ambiguous file name
 28543 00004FD0 EBDA                    	JMP	short MUSTGETWORD
 28544                                  FILLNAM:
 28545 00004FD2 B020                    	MOV	AL," "
 28546 00004FD4 F3AA                    	REP	STOSB
 28547 00004FD6 4E                      	DEC	SI
 28548 00004FD7 C3                      	retn
 28549                                  
 28550                                  SCANB:
 28551 00004FD8 AC                      	LODSB
 28552 00004FD9 E8A100                  	CALL	SPCHK
 28553 00004FDC 74FA                    	JZ	short SCANB
 28554 00004FDE 4E                      	DEC	SI
 28555                                  scanb_retn:
 28556 00004FDF C3                      	retn
 28557                                  
 28558                                  ;----------------------------------------------------------------------------
 28559                                  ;
 28560                                  ; Procedure Name : NameTrans
 28561                                  ;
 28562                                  ; NameTrans is used by FindPath to scan off an element of a path. We must
 28563                                  ; allow spaces in pathnames
 28564                                  ;
 28565                                  ;   Inputs:	DS:SI points to start of path element
 28566                                  ;   Outputs:	Name1 has unpacked name, uppercased
 28567                                  ;		ES = DOSGroup
 28568                                  ;		DS:SI advanced after name
 28569                                  ;   Registers modified: DI,AX,DX,CX
 28570                                  ;
 28571                                  ;----------------------------------------------------------------------------
 28572                                  
 28573                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28574                                  	; 20/05/2019 - Retro DOS v4.0
 28575                                  NameTrans:
 28576                                  ;hkn; SS override
 28577 00004FE0 36C606[4E03]01          	MOV	BYTE [SS:SpaceFlag],1
 28578 00004FE6 16                      	push	ss
 28579 00004FE7 07                      	pop	es
 28580                                  
 28581                                  ;hkn; NAME1 is in DOSDATA
 28582 00004FE8 BF[4B05]                	MOV	DI,NAME1
 28583 00004FEB 57                      	PUSH	DI
 28584 00004FEC B82020                  	MOV	AX,'  '
 28585 00004FEF B90500                  	MOV	CX,5
 28586 00004FF2 AA                      	STOSB
 28587 00004FF3 F3AB                    	REP	STOSW		; Fill "FCB" at NAME1 with spaces
 28588 00004FF5 30C0                    	XOR	AL,AL		; Set stuff for NORMSCAN
 28589 00004FF7 88C2                    	MOV	DL,AL
 28590 00004FF9 AA                      	STOSB
 28591 00004FFA 5F                      	POP	DI
 28592                                  
 28593 00004FFB E880FF                  	CALL	NORMSCAN
 28594                                  
 28595                                  ;hkn; SS override for NAME1
 28596 00004FFE 36803E[4B05]E5          	CMP	byte [SS:NAME1],0E5H
 28597 00005004 75D9                    	jnz	short scanb_retn
 28598 00005006 36C606[4B05]05          	MOV	byte [SS:NAME1],5 ; Magic name translation
 28599 0000500C C3                      	retn
 28600                                  
 28601                                  ;Break	<GETLET, DELIM -- CHECK CHARACTERS AND CONVERT>
 28602                                  ;============================================================================
 28603                                  
 28604                                  ; 20/05/2019 - Retro DOS v4.0
 28605                                  ; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)
 28606                                  
 28607                                  ;If TableLook
 28608                                  
 28609                                  ;hkn; Table	SEGMENT
 28610                                  ;	PUBLIC	CharType
 28611                                  ;----------------------------------------------------------------------------
 28612                                  
 28613                                  ; Character type table for file name scanning
 28614                                  ; Table provides a mapping of characters to validity bits.
 28615                                  ; Four bits are provided for each character. Values 7Dh and above
 28616                                  ; have all bits set, so that part of the table is chopped off, and
 28617                                  ; the translation routine is responsible for screening these values.
 28618                                  ; The bit values are defined in DOSSYM.INC
 28619                                  
 28620                                  ;	      ; ^A and NUL
 28621                                  ;CharType:
 28622                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28623                                  ;	      ; ^C and ^B
 28624                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28625                                  ;	      ; ^E and ^D
 28626                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28627                                  ;	      ; ^G and ^F
 28628                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28629                                  ;	      ; TAB and BS
 28630                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM+FSPCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28631                                  ;	      ; ^K and ^J
 28632                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28633                                  ;	      ; ^M and ^L
 28634                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28635                                  ;	      ; ^O and ^N
 28636                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28637                                  ;	      ; ^Q and ^P
 28638                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28639                                  ;	      ; ^S and ^R
 28640                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28641                                  ;	      ; ^U and ^T
 28642                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28643                                  ;	      ; ^W and ^V
 28644                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28645                                  ;	      ; ^Y and ^X
 28646                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28647                                  ;	      ; ESC and ^Z
 28648                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28649                                  ;	      ; ^] and ^;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28651                                  ;	      ; ^_ and ^^
 28652                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28653                                  ;	      ; ! and SPACE
 28654                                  ;	 db   LOW (NOT FCHK+FDELIM+FSPCHK)
 28655                                  ;	      ; # and "
 28656                                  ;	 db   LOW (NOT FFCB+FCHK)
 28657                                  ;	      ; $ - )
 28658                                  ;	 db   3 dup (0FFh)
 28659                                  ;	      ; + and *
 28660                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR 0Fh
 28661                                  ;	      ; - and '
 28662                                  ;	 db   NOT (FFCB+FCHK+FDELIM)
 28663                                  ;	      ; / and .
 28664                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FCHK) AND 0Fh
 28665                                  ;	      ; 0 - 9
 28666                                  ;	 db   5 dup (0FFh)
 28667                                  ;	      ; ; and :
 28668                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
 28669                                  ;	      ; = and <
 28670                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
 28671                                  ;	      ; ? and >
 28672                                  ;	 db   NOT FFCB+FCHK+FDELIM
 28673                                  ;	      ; A - Z
 28674                                  ;	 db   13 dup (0FFh)
 28675                                  ;	      ; \ and [
 28676                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR 0Fh
 28677                                  ;	      ; ^ and ]
 28678                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28679                                  ;	      ; _ - {
 28680                                  ;	 db   15 dup (0FFh)
 28681                                  ;	      ; } and |
 28682                                  ;	 db   NOT FFCB+FCHK+FDELIM
 28683                                  
 28684                                  ;CharType_last equ ($ - CharType) * 2	; This is the value of the last
 28685                                  ;					; character in the table
 28686                                  
 28687                                  ;FCHK	equ 1		; normal name char, no chks needed
 28688                                  ;FDELIM	equ 2		; is a delimiter
 28689                                  ;FSPCHK	equ 4		; set if character is not a space or equivalent
 28690                                  ;FFCB	equ 8		; is valid in an FCB
 28691                                  
 28692                                  ; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)
 28693                                  ;----------------------------------------------------------------------------
 28694                                  ; DOSCODE:8F76h (MSDOS 5.0, MSDOS.SYS)
 28695                                  
 28696                                  CharType: ; 63 bytes
 28697 0000500D 6666666606666666                db  66h, 66h, 66h, 66h, 06h, 66h, 66h, 66h ; 0-7
 28698 00005015 6666666666666666        	db  66h, 66h, 66h, 66h, 66h, 66h, 66h, 66h ; 8-15
 28699 0000501D F8F6FFFFFF4FF46E        	db 0F8h,0F6h,0FFh,0FFh,0FFh, 4Fh,0F4h, 6Eh ; 16-23
 28700 00005025 FFFFFFFFFF4444F4        	db 0FFh,0FFh,0FFh,0FFh,0FFh, 44h, 44h,0F4h ; 24-31
 28701 0000502D FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 32-39
 28702 00005035 FFFFFFFFFF6F66FF        	db 0FFh,0FFh,0FFh,0FFh,0FFh, 6Fh, 66h,0FFh ; 40-47
 28703 0000503D FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 48-55
 28704 00005045 FFFFFFFFFFFFF4          	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0F4h	   ; 56-62
 28705                                  
 28706                                  CharType_last equ ($ - CharType) * 2
 28707                                  
 28708                                  ; Offset 12CAh of IBMDOS.COM (MSDOS 3.3), 1987
 28709                                  ;----------------------------------------------------------------------------
 28710                                  ;CharType:
 28711                                  ;       db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 28712                                  ;	db 0F6h,0F0h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 28713                                  ;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 28714                                  ;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 28715                                  ;	db 0F8h,0FFh,0F6h,0FFh,0FFh,0FFh,0FFh,0FFh
 28716                                  ;	db 0FFh,0FFh,0FFh,0F4h,0F4h,0FFh,0FEh,0F6h
 28717                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28718                                  ;	db 0FFh,0FFh,0F4h,0F4h,0F4h,0F4h,0F4h,0FFh
 28719                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28720                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28721                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28722                                  ;	db 0FFh,0FFh,0FFh,0F6h,0F6h,0F6h,0FFh,0FFh
 28723                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28724                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28725                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28726                                  ;	db 0FFh,0FFh,0FFh,0FFh,0F4h,0FFh,0FFh,0FFh
 28727                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28728                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28729                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28730                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28731                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28732                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28733                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28734                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28735                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28736                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28737                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28738                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28739                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28740                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28741                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28742                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28743                                  
 28744                                  ;hkn; Table	ENDS
 28745                                  
 28746                                  ;ENDIF
 28747                                  
 28748                                  ; 20/05/2019 - Retro DOS v4.0
 28749                                  ; DOSCODE:9011h (MSDOS 6.21, MSDOS.SYS)
 28750                                  
 28751                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28752                                  ; DOSCODE:8FB5h (MSDOS 5.0, MSDOS.SYS)
 28753                                  
 28754                                  ;----------------------------------------------------------------------------
 28755                                  ;
 28756                                  ; Procedure Names : GetLet, UCase, GetLet3
 28757                                  ;
 28758                                  ; These routines take a character, convert it to upper case, and check
 28759                                  ; for delimiters.  Three different entry points:
 28760                                  ;	GetLet -  DS:[SI] = character to convert
 28761                                  ;	UCase  -  AL = character to convert
 28762                                  ;	GetLet3 - AL = character
 28763                                  ;		  [BX] = translation table to use
 28764                                  ;
 28765                                  ;	Exit (in all cases) : AL = upper case character
 28766                                  ;			      CY set if char is control char other than TAB
 28767                                  ;			      ZF set if char is a delimiter
 28768                                  ;	Uses : AX, flags
 28769                                  ;
 28770                                  ; NOTE: This routine exists in a fast table lookup version, and a slow
 28771                                  ; inline version.  Return with carry set is only possible in the inline
 28772                                  ; version. The table lookup version is the one in use.
 28773                                  ;
 28774                                  ;----------------------------------------------------------------------------
 28775                                  
 28776                                  ; This entry point has character at [SI]
 28777                                  
 28778                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5517h
 28779                                  GETLET:	
 28780 0000504C AC                      	LODSB
 28781                                  
 28782                                  ; This entry point has character in AL
 28783                                  
 28784                                  	;entry	UCase
 28785                                  UCase:	
 28786                                  	; 09/08/2018
 28787                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5518h
 28788                                  _UCase:
 28789 0000504D 53                      	PUSH	BX
 28790 0000504E BB[310B]                	MOV	BX,FILE_UCASE_TAB+2
 28791                                  
 28792                                  ; Convert the character in AL to upper case
 28793                                  
 28794                                  gl_0:
 28795 00005051 3C61                    	CMP	AL,"a"
 28796 00005053 7214                    	JB	short gl_2	; Already upper case, go check type
 28797 00005055 3C7A                    	CMP	AL,"z"
 28798 00005057 7702                    	JA	short gl_1
 28799 00005059 2C20                    	SUB	AL,20H		; Convert to upper case
 28800                                  
 28801                                  ; Map European character to upper case
 28802                                  
 28803                                  gl_1:
 28804 0000505B 3C80                    	CMP	AL,80H
 28805 0000505D 720A                    	JB	short gl_2	; Not EuroChar, go check type
 28806 0000505F 2C80                    	SUB	AL,80H		; translate to upper case with this index
 28807                                  
 28808                                  	; M048 - Start 
 28809                                  	; Lantastic call Ucase thru int 2f without setting SS to DOSDATA.
 28810                                  	; So we shall set up DS and to access FILE_UCASE_TAB in BX and also 
 28811                                  	; preserve it.
 28812                                  
 28813                                  	; 09/08/2018 - Retro DOS v3.0
 28814                                  	; MSDOS 3.3
 28815                                  	;;XLAT	BYTE [CS:BX]	; ds as file_ucase_tab is in DOSDATA
 28816                                  	;CS	XLAT
 28817                                  
 28818                                  	; 20/05/2019 - Retro DOS v4.0
 28819                                  
 28820                                  	; MSDOS 6.0
 28821 00005061 1E                      	push	ds
 28822                                  	;getdseg <ds>
 28823 00005062 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 28824 00005067 D7                      	XLAT			; ds as file_ucase_tab is in DOSDATA
 28825 00005068 1F                      	pop	ds
 28826                                  
 28827                                  	; M048 - End
 28828                                  
 28829                                  ; Now check the type
 28830                                  
 28831                                  ;If TableLook
 28832                                  gl_2:
 28833                                  	; 20/05/2019 - Retro DOS v4.0
 28834 00005069 50                      	PUSH	AX
 28835                                  
 28836                                  	; MSDOS 3.3
 28837                                  	;mov	bx,CharType
 28838                                  	;; 09/08/2018
 28839                                  	;;xlat	byte [cs:bx]
 28840                                  	;cs	xlat	
 28841                                  	
 28842                                  	; MSDOS 6.0
 28843 0000506A E81800                  	CALL	GetCharType	; returns type flags in AL
 28844                                  	
 28845                                  	;test	al,1	
 28846 0000506D A801                    	TEST	AL,FCHK 	; test for normal character
 28847 0000506F 58                      	POP	AX
 28848                                  
 28849 00005070 5B                      	POP	BX
 28850 00005071 C3                      	RETN
 28851                                  
 28852                                  ; This entry has character in AL and lookup table in BX
 28853                                  
 28854                                  	; MSDOS 6.0
 28855                                  ;	;entry GetLet3
 28856                                  GETLET3: ; 10/08/2018
 28857 00005072 53                      	PUSH	BX
 28858 00005073 EBDC                    	JMP	short gl_0
 28859                                  ;ELSE
 28860                                  ;
 28861                                  ;gl_2:
 28862                                  ;	POP	BX
 28863                                  ;	CMP	AL,"."
 28864                                  ;	retz
 28865                                  ;	CMP	AL,'"'
 28866                                  ;	retz
 28867                                  ;	CALL	PATHCHRCMP
 28868                                  ;	retz
 28869                                  ;	CMP	AL,"["
 28870                                  ;	retz
 28871                                  ;	CMP	AL,"]"
 28872                                  ;	retz
 28873                                  ;ENDIF
 28874                                  
 28875                                  ;---------------------------------------------------------------------
 28876                                  ;
 28877                                  ; DELIM - check if character is a delimiter
 28878                                  ;	Entry : AX = character to check
 28879                                  ;	Exit  : ZF set if character is not a delimiter
 28880                                  ;	Uses  : Flags
 28881                                  ;
 28882                                  ;--------------------------------------------------------------------
 28883                                  
 28884                                  	;entry	DELIM
 28885                                  DELIM:
 28886                                  ;IF TableLook
 28887                                  	; 20/05/2019 - Retro DOS v4.0
 28888 00005075 50                      	PUSH	AX
 28889                                  
 28890                                  	; MSDOS 3.3
 28891                                  	;push	bx
 28892                                  	;mov	bx,CharType
 28893                                  	;;09/08/2018
 28894                                  	;;xlat	byte [cs:bx]
 28895                                  	;cs	xlat
 28896                                  	;pop	bx
 28897                                  
 28898                                  	; MSDOS 6.0
 28899 00005076 E80C00                  	CALL	GetCharType
 28900                                  	
 28901                                  	;test	al,2
 28902 00005079 A802                    	TEST	AL,FDELIM
 28903 0000507B 58                      	POP	AX
 28904 0000507C C3                      	RETN
 28905                                  ;ELSE
 28906                                  ;	CMP	AL,":"
 28907                                  ;	retz
 28908                                  ;
 28909                                  ;	CMP	AL,"<"
 28910                                  ;	retz
 28911                                  ;	CMP	AL,"|"
 28912                                  ;	retz
 28913                                  ;	CMP	AL,">"
 28914                                  ;	retz
 28915                                  ;
 28916                                  ;	CMP	AL,"+"
 28917                                  ;	retz
 28918                                  ;	CMP	AL,"="
 28919                                  ;	retz
 28920                                  ;	CMP	AL,";"
 28921                                  ;	retz
 28922                                  ;	CMP	AL,","
 28923                                  ;	retz
 28924                                  ;ENDIF
 28925                                  
 28926                                  ;-------------------------------------------------------------------------
 28927                                  ;
 28928                                  ;  SPCHK - checks to see if a character is a space or equivalent
 28929                                  ;	Entry : AL = character to check
 28930                                  ;	Exit  : ZF set if character is a space
 28931                                  ;	Uses  : flags
 28932                                  ;
 28933                                  ;-------------------------------------------------------------------------
 28934                                  
 28935                                  	;entry SPCHK
 28936                                  SPCHK:
 28937                                  ;IF TableLook
 28938                                  	; 20/05/2019 - Retro DOS v4.0
 28939 0000507D 50                      	PUSH	AX
 28940                                  
 28941                                  	; MSDOS 3.3
 28942                                  	;push	bx
 28943                                  	;mov	bx,CharType
 28944                                  	;; 09/08/2018
 28945                                  	;;xlat	byte [cs:bx]
 28946                                  	;cs	xlat
 28947                                  	;pop	bx
 28948                                  
 28949                                  	; MSDOS 6.0
 28950 0000507E E80400                  	CALL	GetCharType
 28951                                  	
 28952                                  	;test	al,4
 28953 00005081 A804                    	TEST	AL,FSPCHK
 28954 00005083 58                      	POP	AX
 28955 00005084 C3                      	RETN
 28956                                  ;ELSE
 28957                                  ;	CMP	AL,9		; Filter out tabs too
 28958                                  ;	retz
 28959                                  ;; WARNING! " " MUST be the last compare
 28960                                  ;	CMP	AL," "
 28961                                  ;	return
 28962                                  ;ENDIF
 28963                                  
 28964                                  ;-------------------------------------------------------------------------
 28965                                  ;
 28966                                  ;  GetCharType - return flag bits indicating character type
 28967                                  ;	Bits are defined in DOSSYM.INC. Uses lookup table
 28968                                  ;	defined above at label CharType.
 28969                                  ;
 28970                                  ;	Entry : AL = character to return type flags for
 28971                                  ;	Exit  : AL = type flags
 28972                                  ;	Uses  : AL, flags
 28973                                  ;
 28974                                  ;-------------------------------------------------------------------------
 28975                                  
 28976                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28977                                  
 28978                                  	; 20/05/2019 - Retro DOS v4.0
 28979                                  	; MSDOS 6.0
 28980                                  GetCharType:
 28981                                  	;cmp	al,7Eh
 28982 00005085 3C7E                    	cmp	al,CharType_last 	; beyond end of table?
 28983 00005087 7316                    	jae	short gct_90		; return standard value
 28984                                  
 28985 00005089 53                      	push	bx
 28986 0000508A BB[0D50]                	mov	bx,CharType		; load lookup table
 28987 0000508D D0E8                    	shr	al,1			; adjust for half-byte table entry size
 28988                                  	;xlat	cs:[bx] 		; get flags
 28989 0000508F 2ED7                    	cs	xlat	
 28990 00005091 5B                      	pop	bx
 28991                                  
 28992                                  ; carry clear from previous shift means we want the low nibble.  Otherwise
 28993                                  ; we have to shift the flags down to the low nibble
 28994                                  
 28995 00005092 7308                    	jnc	short gct_80		; carry clear, no shift needed
 28996                                  
 28997 00005094 D0E8                    	shr	al,1			; we want high nibble, shift it down
 28998 00005096 D0E8                    	shr	al,1
 28999 00005098 D0E8                    	shr	al,1
 29000 0000509A D0E8                    	shr	al,1
 29001                                  gct_80:
 29002 0000509C 240F                    	and	al,0Fh			; clear the unused nibble
 29003 0000509E C3                      	retn
 29004                                  gct_90:
 29005 0000509F B00F                    	mov	al,0Fh			; set all flags
 29006 000050A1 C3                      	retn
 29007                                  
 29008                                  ;----------------------------------------------------------------------------
 29009                                  ;
 29010                                  ; Procedure : PATHCHRCMP
 29011                                  ;
 29012                                  ;----------------------------------------------------------------------------
 29013                                  
 29014                                  PATHCHRCMP:
 29015 000050A2 3C2F                    	CMP	AL,'/'
 29016 000050A4 7606                    	JBE	short PathRet
 29017 000050A6 3C5C                    	CMP	AL,'\'
 29018 000050A8 C3                      	retn
 29019                                  GotFor:
 29020 000050A9 B05C                    	MOV	AL,'\'
 29021 000050AB C3                      	retn
 29022                                  PathRet:
 29023 000050AC 74FB                    	JZ	short GotFor
 29024 000050AE C3                      	retn
 29025                                  
 29026                                  ;============================================================================
 29027                                  ; MSCRTLC.ASM, MSDOS 6.0, 1991
 29028                                  ;============================================================================
 29029                                  ; 30/07/2018 - Retro DOS v3.0
 29030                                  ; 29/04/2019 - Retro DOS v4.0
 29031                                  
 29032                                  ; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11, CTRLC.ASM, 1983)
 29033                                  
 29034                                  ;**	MSCTRLC.ASM - ^C and error handler for MSDOS
 29035                                  
 29036                                  ;	TITLE	Control C detection, Hard error and EXIT routines
 29037                                  ;	NAME	IBMCTRLC
 29038                                  
 29039                                  ;**	Low level routines for detecting special characters on CON input,
 29040                                  ;	the ^C exit/int code, the Hard error INT 24 code, the
 29041                                  ;	process termination code, and the INT 0 divide overflow handler.
 29042                                  ;
 29043                                  ;	FATAL
 29044                                  ;	FATAL1
 29045                                  ;	reset_environment
 29046                                  ;	DSKSTATCHK
 29047                                  ;	SPOOLINT
 29048                                  ;	STATCHK
 29049                                  ;	CNTCHAND
 29050                                  ;	DIVOV
 29051                                  ;	CHARHARD
 29052                                  ;	HardErr
 29053                                  ;
 29054                                  ;	Revision history:
 29055                                  ;
 29056                                  ;	    AN000	version 4.0   Jan 1988
 29057                                  ;	    A002	PTM    -- dir >lpt3 hangs
 29058                                  ;	    A003	PTM 3957- fake version for IBMCAHE.COM
 29059                                  ;
 29060                                  ; 	M011: NEC's 8086 clone chip uses Intel's undocumented bit number in
 29061                                  ;	      flags register. In order to return to user normally DOS used to
 29062                                  ;	      move F202 into flags, which sets bit number 1 in flags uncondit-
 29063                                  ;	      ionally. Now it is modified to maintain the state of bit 1.
 29064                                  ;
 29065                                  ; 	M024: suppressed fail and ignore options if not in the middle of int 
 29066                                  ;	      24 and if Ctrl P or ctrl printscrn is pressed in routine 
 29067                                  ;	      charhard.
 29068                                  
 29069                                  ; 29/04/2019 - Retro DOS v4.0
 29070                                  	; MSDOS 6.0
 29071                                  ;		public	LowInt23Addr		
 29072                                  LowInt23Addr: ;	LABEL	DWORD
 29073 000050AF [CD10]0000              	DW	LowInt23, 0
 29074                                  
 29075                                  ;		public	LowInt24Addr
 29076                                  LowInt24Addr: ;	LABEL	DWORD
 29077 000050B3 [E110]0000              	DW	LowInt24, 0
 29078                                  
 29079                                  ;		public	LowInt28Addr
 29080                                  LowInt28Addr: ;	LABEL	DWORD
 29081 000050B7 [F510]0000              	DW	LowInt28, 0
 29082                                  
 29083                                  ;Break	<Checks for ^C in CON I/O>
 29084                                  
 29085                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29086                                  ; 05/05/2019 - Retro DOS v4.0
 29087                                  
 29088                                  ;---------------------------------------------------------------------------
 29089                                  ;
 29090                                  ; Procedure Name : DSKSTATCHK
 29091                                  ;
 29092                                  ; Check for ^C if only one level in
 29093                                  ;
 29094                                  ;---------------------------------------------------------------------------
 29095                                  
 29096                                          ;procedure DSKSTATCHK,NEAR ; Check for ^C if only one level in
 29097                                  
 29098                                  DSKSTATCHK:        
 29099                                  	;CMP	BYTE [INDOS],1
 29100 000050BB 36803E[2103]01                  CMP     BYTE [SS:INDOS],1 ; 15/03/2018
 29101                                  	;retnz			; Do NOTHING
 29102                                  	; 16/12/2022
 29103 000050C1 7534                    	JNZ	SHORT _RET37 ; Retro DOS v2.0 - 04/03/2018         
 29104                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29105                                  	;jz	short _RET37 ; dskstatchk1
 29106                                  	;retn
 29107                                  ;_RET37:
 29108                                  ;dskstatchk1:
 29109 000050C3 51                      	PUSH    CX
 29110 000050C4 06                              PUSH    ES
 29111 000050C5 53                              PUSH    BX
 29112 000050C6 1E                              PUSH    DS
 29113 000050C7 56                              PUSH    SI
 29114                                          
 29115                                  	;PUSH	CS
 29116                                          ;POP	ES
 29117                                          ;PUSH	CS
 29118                                          ;POP	DS
 29119                                  
 29120 000050C8 8CD3                    	MOV	BX,SS		; SS is DOSDATA. ES:BX must be set up
 29121 000050CA 8EC3                    	MOV	ES,BX		; for deviocall2
 29122 000050CC 8EDB                    	MOV	DS,BX
 29123                                  
 29124                                  	; 16/12/2022
 29125                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29126                                  
 29127                                  	; 05/05/2019
 29128                                  	;MOV	BYTE [ss:DSKSTCOM],DEVRDND
 29129                                          ;MOV	BYTE [ss:DSKSTCALL],DRDNDHL
 29130                                  	;mov	word [ss:DSKSTST],0
 29131                                  
 29132                                  	; 16/12/2022
 29133                                  	; 25/06/2019
 29134 000050CE C606[9403]05            	MOV	BYTE [DSKSTCOM],DEVRDND	 ; 5
 29135 000050D3 C606[9203]0E                    MOV	BYTE [DSKSTCALL],DRDNDHL ; 14
 29136 000050D8 C706[9503]0000          	mov	word [DSKSTST],0
 29137                                  
 29138 000050DE BB[9203]                        MOV     BX,DSKSTCALL
 29139                                  
 29140                                  	;LDS	SI,[ss:BCON]
 29141                                          ; 25/062019
 29142 000050E1 C536[3200]              	lds	si,[BCON]
 29143                                  
 29144                                  ; 16/12/2022
 29145                                  ;	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29146                                  ;	mov	byte [ss:DSKSTCOM],DEVRDND  ; 5
 29147                                  ;       mov	byte [ss:DSKSTCALL],DRDNDHL ; 14
 29148                                  ;	mov	word [ss:DSKSTST],0
 29149                                  ;	mov	bx,DSKSTCALL
 29150                                  ;	lds	si,[ss:BCON]
 29151                                  
 29152 000050E5 E890F5                  	CALL	DEVIOCALL2
 29153                                   	; 15/03/2018
 29154                                  	;;test	word [ss:DSKSTST],200h
 29155                                          ;TEST	WORD [SS:DSKSTST],STBUI
 29156                                  	; 05/05/2019
 29157 000050E8 36F606[9603]02          	test	byte [ss:DSKSTST+1],(STBUI>>8) ; 2
 29158 000050EE 7408                    	jz	short _GotCh		; No characters available
 29159                                  
 29160 000050F0 30C0                            XOR     AL,AL                   ; Set zero
 29161                                  RET36:
 29162 000050F2 5E                              POP     SI
 29163 000050F3 1F                              POP     DS
 29164 000050F4 5B                              POP     BX
 29165 000050F5 07                              POP     ES
 29166 000050F6 59                              POP     CX
 29167                                  	; 16/12/2022
 29168                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29169                                  _RET37:
 29170 000050F7 C3                              RETN
 29171                                  
 29172                                  _GotCh:
 29173 000050F8 36A0[9F03]                      MOV     AL,[SS:DSKCHRET]	; SS override
 29174                                  
 29175 000050FC 3C03                            CMP     AL,"C"-"@" ; cmp al,3
 29176 000050FE 75F2                            JNZ     SHORT RET36
 29177 00005100 36C606[9403]04                  MOV     BYTE [SS:DSKSTCOM],DEVRD
 29178 00005106 36C606[9203]16                  MOV     BYTE [SS:DSKSTCALL],DRDWRHL
 29179 0000510C 36880E[9F03]                    MOV     [SS:DSKCHRET],CL
 29180                                  	; 09/09/2018
 29181 00005111 36C706[9503]0000        	MOV	word [SS:DSKSTST],0
 29182 00005118 36C706[A403]0100        	MOV	word [SS:DSKSTCNT],1
 29183 0000511F E856F5                  	CALL	DEVIOCALL2              ; Eat the ^C
 29184 00005122 5E                              POP     SI
 29185 00005123 1F                              POP     DS
 29186 00005124 5B                              POP     BX                      ; Clean stack
 29187 00005125 07                              POP     ES
 29188 00005126 59                              POP     CX
 29189 00005127 E9CF00                          JMP	CNTCHAND ; 10/08/2018
 29190                                  
 29191                                  	; 05/05/2019
 29192                                  NOSTOP:
 29193                                  	; MSDOS 6.0
 29194 0000512A 3C10                    	CMP	AL,"P"-"@"
 29195 0000512C 7509                    	JNZ	short check_next
 29196                                  				    	; SS override
 29197 0000512E 36803E[900D]00          	CMP	BYTE [SS:SCAN_FLAG],0	; ALT_Q ?
 29198 00005134 7405                    	JZ	short INCHKJ		; no
 29199                                  check_end:	; 24/09/2023
 29200 00005136 C3                      	retn
 29201                                  check_next:
 29202                                  	;IF	NOT TOGLPRN
 29203                                  	;CMP	AL,"N"-"@"
 29204                                  	;JZ	short INCHKJ
 29205                                  	;ENDIF
 29206                                  
 29207 00005137 3C03                    	CMP	AL,"C"-"@"
 29208                                  	; 24/09/2023
 29209                                  	;JZ	short INCHKJ
 29210                                  ;check_end:
 29211                                  	;retn
 29212 00005139 75FB                    	jnz	short check_end
 29213                                  
 29214                                  	; 24/09/2023
 29215                                  	; 08/09/2018
 29216                                  INCHKJ:	; 10/08/2018
 29217 0000513B E9A500                  	jmp	INCHK
 29218                                  
 29219                                  	; MSDOS 3.3
 29220                                          ;CMP     AL,"P"-"@"  ; cmp al,16
 29221                                          ;JZ	short INCHKJ
 29222                                  
 29223                                  	; 15/04/2018
 29224                                          ;;IF	NOT TOGLPRN
 29225                                          ;CMP	AL,"N"-"@"
 29226                                          ;JZ	SHORT INCHKJ
 29227                                          ;;ENDIF
 29228                                  	
 29229                                  	;CMP     AL,"C"-"@"  ; cmp al,3
 29230                                          ;JZ	short INCHKJ
 29231                                  	;RETN
 29232                                  
 29233                                  ;	; 08/09/2018
 29234                                  ;INCHKJ:; 10/08/2018
 29235                                  ;	JMP	INCHK
 29236                                  
 29237                                  ;----------------------------------------------------------------------------
 29238                                  ;
 29239                                  ; Procedure Name : SpoolInt
 29240                                  ;
 29241                                  ; SpoolInt - signal processes that the DOS is truly idle. We are allowed to
 29242                                  ; do this ONLY if we are working on a 1-12 system call AND if we are not in
 29243                                  ; the middle of an INT 24.
 29244                                  ;
 29245                                  ;----------------------------------------------------------------------------
 29246                                  
 29247                                  SPOOLINT:
 29248 0000513E 9C                              PUSHF
 29249                                  	; 15/03/2018
 29250 0000513F 36803E[5803]00                  CMP     BYTE [SS:IDLEINT],0	; SS override
 29251 00005145 7423                            JZ      SHORT POPFRET
 29252 00005147 36803E[2003]00                  CMP     BYTE [SS:ERRORMODE],0
 29253 0000514D 751B                            JNZ     SHORT POPFRET		;No spool ints in error mode
 29254                                  
 29255                                  	; 30/07/2018
 29256                                  
 29257                                  	; Note that we are going to allow an external program to issue system 
 29258                                  	; calls at this time. We MUST preserve IdleInt across this.
 29259                                  
 29260 0000514F 36FF36[5803]            	PUSH	WORD [SS:IDLEINT]
 29261                                  
 29262                                  	; 05/05/2019 - Retro DOS v4.0
 29263                                   
 29264                                  	; MSDOS 6.0
 29265 00005154 36803E[F211]00          	cmp	byte [SS:DosHasHMA],0	; Q: is dos running in HMA (M021)
 29266 0000515A 7504                    	jne	short do_low_int28	; Y: the int must be done from low mem
 29267 0000515C CD28                    	INT	int_spooler  ; int 28h 	; N: Execute user int 28 handler
 29268 0000515E EB05                    	jmp	short spool_ret_addr
 29269                                  
 29270                                  do_low_int28:
 29271                                  	;call	far [ss:LowInt28Addr]
 29272 00005160 2EFF1E[B750]            	call	far [cs:LowInt28Addr]	; 05/05/2019
 29273                                  
 29274                                  spool_ret_addr:
 29275                                  	;INT	int_spooler		; INT 28h
 29276                                  
 29277 00005165 368F06[5803]            	POP	WORD [SS:IDLEINT]
 29278                                  POPFRET:
 29279 0000516A 9D                              POPF
 29280                                  _RET18:  
 29281 0000516B C3                      	RETN
 29282                                  
 29283                                  ; 05/05/2019 - Retro DOS v4.0
 29284                                  ; DOSCODE:9137h (MSDOS 6.21, MSDOS.SYS)
 29285                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29286                                  ; DOSCODE:90DBh (MSDOS 5.0, MSDOS.SYS)
 29287                                  
 29288                                  ;----------------------------------------------------------------------------
 29289                                  ;
 29290                                  ; Procedure Name : STATCHK
 29291                                  ;
 29292                                  ;----------------------------------------------------------------------------
 29293                                  
 29294                                  STATCHK:
 29295 0000516C E84CFF                          CALL	DSKSTATCHK              ; Allows ^C to be detected under
 29296                                                                          ; input redirection
 29297 0000516F 53                              PUSH    BX
 29298 00005170 31DB                            XOR     BX,BX
 29299 00005172 E8E9E4                          CALL	GET_IO_SFT
 29300 00005175 5B                              POP     BX
 29301 00005176 72F3                            JC      SHORT _RET18
 29302                                  
 29303 00005178 B401                            MOV     AH,1
 29304 0000517A E826F3                          CALL	IOFUNC
 29305 0000517D 74BF                            JZ      SHORT SPOOLINT
 29306 0000517F 3C13                            CMP     AL,'S'-'@'
 29307 00005181 75A7                            JNZ     SHORT NOSTOP
 29308                                  
 29309                                  	; 05/05/2019
 29310                                  	; MSDOS 6.0			; SS override
 29311 00005183 36803E[900D]00          	CMP	BYTE [SS:SCAN_FLAG],0	; AN000; ALT_R ?
 29312 00005189 75AB                    	JNZ	short check_end		; AN000; yes
 29313                                  
 29314 0000518B 30E4                            XOR     AH,AH
 29315 0000518D E813F3                          CALL	IOFUNC                  ; Eat Cntrl-S
 29316 00005190 EB4A                            JMP     SHORT PAUSOSTRT
 29317                                  PRINTOFF:
 29318                                  PRINTON:
 29319 00005192 36F616[FE02]            	NOT	BYTE [SS:PFLAG] ; 14/03/2018
 29320                                  
 29321                                  	; 30/07/2018 - Retro DOS v3.0
 29322 00005197 53                      	PUSH	BX
 29323 00005198 BB0400                  	MOV	BX,4
 29324 0000519B E8C0E4                  	call	GET_IO_SFT
 29325 0000519E 5B                      	POP	BX
 29326 0000519F 72CA                    	jc	short _RET18
 29327 000051A1 06                      	PUSH	ES
 29328 000051A2 57                      	PUSH	DI
 29329 000051A3 1E                      	PUSH	DS
 29330 000051A4 07                      	POP	ES
 29331 000051A5 89F7                    	MOV	DI,SI			; ES:DI -> SFT
 29332                                  	;test	word [es:di+5],800h
 29333                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_net_spool
 29334                                  	; 05/05/2019
 29335 000051A7 26F6450608              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8)
 29336 000051AC 7418                    	JZ	short NORM_PR 		; Not redirected, echo is OK
 29337                                  
 29338                                  	;Callinstall NetSpoolEchoCheck,MultNet,38,<AX>,<AX> 
 29339                                  					; See if allowed
 29340 000051AE 50                      	push	ax
 29341 000051AF B82611                  	mov	ax,1126h
 29342 000051B2 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 29343                                  			; Return: CF set on error, AX = error code
 29344                                  			; STACK unchanged
 29345 000051B4 58                      	pop	ax
 29346                                  
 29347 000051B5 730F                    	JNC	short NORM_PR 		; Echo is OK
 29348                                  
 29349                                  					; SS override
 29350 000051B7 36C606[FE02]00          	MOV	BYTE [SS:PFLAG],0	; If not allowed, disable echo
 29351                                  
 29352                                  	;Callinstall NetSpoolClose,MultNet,36,<AX>,<AX> ; and close
 29353                                  
 29354 000051BD 50                      	push    ax
 29355 000051BE B82411                  	mov     ax,1124h
 29356 000051C1 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 29357                                  			; ES:DI -> SFT, SS = DOS CS
 29358 000051C3 58                      	pop     ax
 29359                                  
 29360 000051C4 EB10                    	JMP	SHORT RETP6
 29361                                  NORM_PR:
 29362 000051C6 36803E[FE02]00          	CMP	BYTE [SS:PFLAG],0	; SS override
 29363 000051CC 7505                    	JNZ	short PRNOPN
 29364 000051CE E82BF4                  	call	DEV_CLOSE_SFT
 29365 000051D1 EB03                    	JMP	SHORT RETP6
 29366                                  PRNOPN:
 29367 000051D3 E81EF4                  	call	DEV_OPEN_SFT
 29368                                  RETP6:
 29369 000051D6 5F                      	POP	DI
 29370 000051D7 07                      	POP	ES
 29371                                  STATCHK_RETN:
 29372 000051D8 C3                              RETN
 29373                                  PAUSOLP:
 29374 000051D9 E862FF                          CALL    SPOOLINT
 29375                                  PAUSOSTRT:
 29376 000051DC B401                            MOV     AH,1
 29377 000051DE E8C2F2                          CALL	IOFUNC
 29378 000051E1 74F6                            JZ      SHORT PAUSOLP
 29379                                  INCHK:
 29380 000051E3 53                              PUSH    BX
 29381 000051E4 31DB                            XOR     BX,BX
 29382 000051E6 E875E4                          CALL	GET_IO_SFT
 29383 000051E9 5B                              POP     BX
 29384 000051EA 72EC                            JC      SHORT STATCHK_RETN ; 30/07/2018
 29385 000051EC 30E4                            XOR     AH,AH
 29386 000051EE E8B2F2                          CALL	IOFUNC
 29387                                  	; 30/07/2018
 29388                                  	; MSDOS 3.3
 29389                                          ;CMP	AL,'P'-'@' ;cmp al,16
 29390                                          ;JNZ	SHORT NOPRINT
 29391                                  
 29392                                  	;cmp	byte [SS:SCAN_FLAG],0
 29393                                  	;JZ	SHORT PRINTON	
 29394                                  	;mov	byte [ss:SCAN_FLAG],0
 29395                                  
 29396                                  	; 05/05/2019
 29397                                  	; MSDOS 6.0
 29398 000051F1 3C10                    	CMP	AL,"P"-"@"
 29399                                  	;;;;  7/14/86	ALT_Q key fix
 29400 000051F3 749D                    	JZ	short PRINTON		; no! must be CTRL_P
 29401                                  ;NOPRINT:	
 29402                                  	;IF	NOT TOGLPRN
 29403                                  	;CMP	AL,"N"-"@"
 29404                                  	;JZ	short PRINTOFF
 29405                                  	;ENDIF
 29406 000051F5 3C03                    	CMP	AL,"C"-"@" ; cmp al,3 
 29407                                  	;retnz
 29408 000051F7 75DF                    	jnz	short STATCHK_RETN
 29409                                  
 29410                                  	; !! NOTE: FALL THROUGH !!
 29411                                  
 29412                                  ;---------------------------------------------------------------------------
 29413                                  ;
 29414                                  ; Procedure Name : CNTHAND ( CTRLC_C HANDLER )
 29415                                  ;
 29416                                  ; "^C" and CR/LF is printed. Then the user registers are restored and the
 29417                                  ; user CTRL-C handler is executed. At this point the top of the stack has 1)
 29418                                  ; the interrupt return address should the user CTRL-C handler wish to allow
 29419                                  ; processing to continue; 2) the original interrupt return address to the code
 29420                                  ; that performed the function call in the first place. If the user CTRL-C
 29421                                  ; handler wishes to continue, it must leave all registers unchanged and RET
 29422                                  ; (not IRET) with carry CLEAR. If carry is SET then an terminate system call
 29423                                  ; is simulated.
 29424                                  ;
 29425                                  ;---------------------------------------------------------------------------
 29426                                  
 29427                                  CNTCHAND:
 29428                                  	; MSDOS 6.0			; SS override
 29429                                  					; AN002; from RAWOUT
 29430                                  	;TEST	word [SS:DOS34_FLAG],CTRL_BREAK_FLAG  
 29431                                  	;JNZ	short around_deadlock 	; AN002;
 29432                                  
 29433                                  	; 05/05/2019 - Retro DOS v4.0
 29434                                  	; (MSDOS 6.21 MSDOS.SYS DOSCODE:91C4h, 29/12/2022)
 29435 000051F9 36F606[1206]02          	TEST	byte [SS:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8)  ; 2 
 29436 000051FF 7508                    	JNZ	short around_deadlock 	; AN002;
 29437                                  
 29438 00005201 B003                            MOV     AL,3			; Display "^C"
 29439 00005203 E8EFC4                          CALL	BUFOUT
 29440 00005206 E88AC3                          CALL	CRLF
 29441                                  around_deadlock:
 29442 00005209 16                              PUSH    SS
 29443 0000520A 1F                              POP     DS
 29444 0000520B 803E[5703]00                    CMP     BYTE [CONSWAP],0
 29445 00005210 7403                            JZ      SHORT NOSWAP
 29446 00005212 E8B3E0                          CALL	SWAPBACK
 29447                                  NOSWAP:
 29448 00005215 FA                      	CLI				; Prepare to play with stack
 29449 00005216 8E16[8605]              	MOV	SS,[USER_SS]		; User stack now restored
 29450 0000521A 8B26[8405]              	MOV	SP,[USER_SP]
 29451 0000521E E82AB2                          CALL	restore_world       ; User registers now restored
 29452                                  
 29453                                  	; 30/07/2018 - Retro DOS v3.0 
 29454                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56ACh)
 29455                                          ; 14/03/2018 - Retro DOS v2.0
 29456                                  	;MOV	BYTE [CS:INDOS],0	
 29457                                          ;MOV	BYTE [CS:ERRORMODE],0
 29458                                          ;MOV	[CS:ConC_Spsave],SP
 29459                                  	;clc	;30/07/2018
 29460                                          ;INT	int_ctrl_c ; 23h    ; Execute user Ctrl-C handler
 29461                                  	;;int	23h	; DOS - CONTROL "C" EXIT ADDRESS
 29462                                  			; Return: return via RETF 2 with CF set
 29463                                  			; DOS will abort program with errorlevel 0
 29464                                  			; else
 29465                                  			; interrupted DOS call continues
 29466                                  
 29467                                  	; 05/05/2019 - Retro DOS v4.0
 29468                                  	; MSDOS 6.0 (MSDOS 6.21, MSDOS.SYS,91ECh) 
 29469                                  
 29470                                  	; CS was used to address these variables. We have to use DOSDATA
 29471                                  	
 29472 00005221 07                      	pop	es ; *	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:91ECh)
 29473                                  			; (pop es, after 'call restore_world')	
 29474 00005222 1E                      	push	ds
 29475                                  	;getdseg <ds>			; ds -> dosdata
 29476 00005223 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 29477 00005228 C606[2103]00            	mov	byte [INDOS],0		; Go to known state
 29478 0000522D C606[2003]00            	mov	byte [ERRORMODE],0
 29479 00005232 8926[3203]              	mov	[ConC_Spsave],SP	; save his SP
 29480                                  	; User SP has changed because of push. Adjust for it
 29481 00005236 8306[3203]02            	add	word [ConC_Spsave],2
 29482                                  
 29483 0000523B 803E[F211]00            	cmp	byte [DosHasHMA],0	; Q: is dos running in HMA (M021)
 29484 00005240 1F                       	pop	ds	; restore ds
 29485 00005241 7505                    	jne	short do_low_int23	; Y: the int must be done from low mem
 29486 00005243 F8                      	CLC				
 29487 00005244 CD23                    	INT	int_ctrl_c  ; int 23h	; N: Execute user Ctrl-C handler
 29488 00005246 EB06                    	jmp	short ctrlc_ret_addr
 29489                                  
 29490                                  	; 05/05/2019
 29491                                  do_low_int23:
 29492 00005248 F8                      	clc
 29493 00005249 2EFF1E[AF50]            	call	far [cs:LowInt23Addr]	
 29494                                  
 29495                                  	; 30/07/2018 
 29496                                  
 29497                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56C0h)
 29498                                  
 29499                                  ; The user has returned to us. The circumstances we allow are:
 29500                                  ;
 29501                                  ;   IRET	We retry the operation by redispatching the system call
 29502                                  ;   CLC/RETF	POP the stack and retry
 29503                                  ;   ... 	Exit the current process with ^C exit
 29504                                  ;
 29505                                  ; User's may RETURN to us and leave interrupts on. 
 29506                                  ; Turn 'em off just to be sure
 29507                                  
 29508                                  ctrlc_ret_addr: ; 05/05/2019
 29509                                  
 29510 0000524E FA                      	CLI
 29511                                  
 29512                                  	; MSDOS 3.3 
 29513                                  	;MOV	[CS:USER_IN_AX],ax	; save the AX
 29514                                  	;PUSHF				; and the flags (maybe new call)
 29515                                  	;POP	AX
 29516                                  
 29517                                  	; 05/05/2019
 29518                                  	; MSDOS 6.0
 29519                                  
 29520                                  	; We have to use DOSDATA for these variables. Previously CS was used 
 29521                                  
 29522 0000524F 50                      	push	ax
 29523 00005250 8CD8                    	mov	ax,ds
 29524                                  	;getdseg <ds>			; ds -> dosdata
 29525 00005252 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 29526 00005257 A3[0A0D]                	mov	[TEMPSEG],ax
 29527 0000525A 58                      	pop	ax
 29528 0000525B A3[3A03]                	MOV	[USER_IN_AX],ax		; save the AX
 29529 0000525E 9C                      	pushf				; and the flags (maybe new call)
 29530 0000525F 58                      	pop	ax
 29531                                  
 29532                                  ; See if the input stack is identical to the output stack
 29533                                  
 29534                                  	; MSDOS 3.3
 29535                                  	;CMP	SP,[CS:ConC_Spsave]
 29536                                  	;JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP
 29537                                  
 29538                                  	; MSDOS 6.0
 29539 00005260 3B26[3203]              	CMP	SP,[ConC_Spsave]
 29540 00005264 750A                    	JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP
 29541                                  
 29542                                  ; Repeat the operation by redispatching the system call.
 29543                                  
 29544                                  ctrlc_repeat:
 29545                                  	; MSDOS 3.3
 29546                                  	;MOV	AX,[CS:USER_IN_AX]
 29547                                  	; 05/05/2019
 29548                                  	; MSDOS 6.0
 29549 00005266 A1[3A03]                	mov	ax,[USER_IN_AX]
 29550 00005269 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore ds and original sp
 29551                                  	; MSDOS 3.3 & MSDOS 6.0 
 29552                                  	;transfer COMMAND
 29553                                  COMMANDJ:
 29554 0000526D E998B0                  	JMP	COMMAND
 29555                                  
 29556                                  ; The current SP is NOT the same as the input SP. Presume that he 
 29557                                  ; RETF'd leaving some flags on the stack and examine the input
 29558                                  
 29559                                  ctrlc_try_new:
 29560 00005270 83C402                  	ADD	SP,2			; pop those flags
 29561                                  	;;test	ax,1
 29562                                  	;TEST	AX,f_Carry		; did he return with carry?
 29563 00005273 A801                    	test	al,f_Carry ; test al,1
 29564 00005275 74EF                    	JZ	short ctrlc_repeat	; no carry set, just retry
 29565                                  
 29566                                  	; MSDOS 6.0
 29567 00005277 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore ds
 29568                                  
 29569                                  	; Well...  time to abort the user.  
 29570                                  	; Signal a ^C exit and use the EXIT system call..
 29571                                  
 29572                                  ctrlc_abort:
 29573                                  	; MSDOS 3.3
 29574                                          ;;MOV	AX,(EXIT SHL 8) + 0
 29575                                          ;MOV	AX, (EXIT*256) + 0  ; 4C00h
 29576                                  	;mov	byte [CS:DidCTRLC],0FFh ; 14/03/2018
 29577                                          ;transfer COMMAND	    ; give up by faking $EXIT
 29578                                  	;;JMP	SHORT COMMANDJ
 29579                                  	;JMP	COMMAND
 29580                                  
 29581                                  	; 05/05/2019 - Retro DOS v4.0
 29582                                  	; MSDOS 6.0
 29583 0000527B B8004C                  	MOV	AX,(EXIT<<8)+0  ; 4C00h
 29584 0000527E 1E                      	push	ds
 29585                                  	;getdseg <ds>			; ds -> dosdata
 29586 0000527F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]	
 29587 00005284 C606[4D03]FF            	MOV	byte [DidCTRLC],-1 ; 0FFh
 29588 00005289 1F                      	pop	ds
 29589                                  	;transfer COMMAND		; give up by faking $EXIT
 29590 0000528A EBE1                    	JMP	SHORT COMMANDJ
 29591                                  	;JMP	COMMAND
 29592                                  
 29593                                  ;Break	<DIVISION OVERFLOW INTERRUPT>
 29594                                  ;----------------------------------------------------------------------------
 29595                                  ;
 29596                                  ; Procedure Name : DIVOV
 29597                                  ;
 29598                                  ; Default handler for division overflow trap
 29599                                  ;
 29600                                  ;----------------------------------------------------------------------------
 29601                                  
 29602                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29603                                  DIVOV: 
 29604                                  	; 05/05/2019 - Retro DOS v4.0
 29605                                  	; 30/07/2018
 29606                                  	; 07/07/2018 - Retro DOS v3.0
 29607 0000528C BE[9D09]                	mov	si,DIVMES
 29608 0000528F 2E8B1E[B009]            	mov	bx,[cs:DivMesLen]
 29609                                  	;mov	ax,cs
 29610                                  	;mov	ss,ax
 29611                                  	; 05/05/2019
 29612                                  	;getdseg <ss>		; we are in an ISR, flag is CLI
 29613 00005294 2E8E16[0700]            	mov	ss,[cs:DosDSeg]
 29614 00005299 BC[A007]                	mov     sp,AUXSTACK
 29615                                  	;call	RealDivOv ; MSDOS 3.3
 29616 0000529C E80200                  	call	_OUTMES ; MSDOS 6.0
 29617 0000529F EBDA                    	jmp	short ctrlc_abort  ; Use Ctrl-C abort on divide overflow
 29618                                  
 29619                                  ; 30/07/2018
 29620                                  
 29621                                  ; MSDOS 6.0
 29622                                  ;---------------------------------------------------------------------------
 29623                                  ;
 29624                                  ; Procedure Name : OutMes
 29625                                  ;
 29626                                  ;
 29627                                  ; OutMes: perform message output
 29628                                  ; Inputs:   SS:SI points to message
 29629                                  ;	    BX has message length
 29630                                  ; Outputs:  message to BCON
 29631                                  ;
 29632                                  ;Actually, cs:si points to the message now. The segment address is filled in
 29633                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 29634                                  ;NB. This procedure is called only from DIVOV. -SR
 29635                                  ;
 29636                                  ;---------------------------------------------------------------------------
 29637                                  
 29638                                  ;MSDOS 3.3
 29639                                  ;---------------------------------------------------------------------------
 29640                                  ; RealDivOv: perform actual divide overflow stuff.
 29641                                  ; Inputs:   none
 29642                                  ; Outputs:  message to BCON
 29643                                  ;---------------------------------------------------------------------------
 29644                                  
 29645                                  	; 05/05/2019 - Retro DOS v4.0
 29646                                  	; DOSCODE:926Ch (MSDOS 6.21, MSDOS.SYS)
 29647                                  
 29648                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29649                                  	; DOSCODE:9210h (MSDOS 5.0, MSDOS.SYS)
 29650                                  
 29651                                  ;---------------------------------------------------------------------------
 29652                                  ;
 29653                                  ; Procedure Name : OutMes
 29654                                  ;
 29655                                  ; OutMes: perform message output
 29656                                  ; Inputs:   SS:SI points to message
 29657                                  ;	    BX has message length
 29658                                  ; Outputs:  message to BCON
 29659                                  ;
 29660                                  ;Actually, cs:si points to the message now. The segment address is filled in
 29661                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 29662                                  ;NB. This procedure is called only from DIVOV. -SR
 29663                                  ;
 29664                                  ;---------------------------------------------------------------------------
 29665                                  
 29666                                  	; 30/07/2018
 29667                                  	; MSDOS 6.0
 29668                                  _OUTMES:
 29669                                  	; MSDOS 3.3
 29670                                  ;RealDivOv:
 29671                                  	; 07/07/2018 - Retro DOS v3.0
 29672                                          ;Context ES
 29673 000052A1 16                      	push	ss ; 05/05/2019
 29674                                  	;PUSH	CS ; 30/07/2018		; get ES addressability
 29675 000052A2 07                      	POP	ES
 29676                                          ;Context DS
 29677 000052A3 16                      	push	ss ; 05/05/2019	
 29678                                  	;PUSH	CS ; 30/07/2018		; get DS addressability
 29679 000052A4 1F                      	POP	DS
 29680 000052A5 C606[9403]08                    MOV     BYTE [DSKSTCOM],DEVWRT
 29681 000052AA C606[9203]16                    MOV     BYTE [DSKSTCALL],DRDWRHL
 29682 000052AF C706[9503]0000                  MOV     WORD [DSKSTST],0
 29683                                  	; BX = [DivMesLen] = 19
 29684 000052B5 891E[A403]                      MOV     [DSKSTCNT],BX
 29685 000052B9 BB[9203]                        MOV     BX,DSKSTCALL
 29686 000052BC 8936[A003]                      MOV     [DSKCHRET+1],SI		; transfer address (need an EQU)
 29687                                  	; 08/09/2018
 29688                                  	;mov	[DEVIOBUF_PTR],si
 29689                                  	; MSDOS 6.0
 29690                                  					; CS is used for string, fill in 
 29691                                  					; segment address 
 29692 000052C0 8C0E[A203]              	MOV	[DSKCHRET+3],CS
 29693                                  
 29694 000052C4 C536[3200]                      LDS     SI,[BCON]
 29695 000052C8 E8ADF3                          CALL	DEVIOCALL2
 29696                                  
 29697                                  	;; 14/03/2018
 29698                                          ;;MOV	WORD [CS:DSKCHRET+1],DEVIOBUF
 29699                                  	;; 08/09/2018
 29700                                  	;mov	word [CS:DEVIOBUF_PTR],DEVIOBUF
 29701                                          ;MOV	WORD [CS:DSKSTCNT],1
 29702                                          
 29703                                  	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 29704                                  
 29705                                  	; ES still points to DOSDATA. ES is
 29706                                  					; not destroyed by deviocall2. So use
 29707                                  					; ES override.
 29708                                  
 29709 000052CB 26C706[A003][BC03]      	MOV	WORD [ES:DSKCHRET+1],DEVIOBUF
 29710 000052D2 26C706[A403]0100        	MOV	WORD [ES:DSKSTCNT],1
 29711                                  
 29712 000052D9 C3                      	RETN
 29713                                  
 29714                                  ;Break	<CHARHRD,HARDERR,ERROR -- HANDLE DISK ERRORS AND RETURN TO USER>
 29715                                  ;---------------------------------------------------------------------------
 29716                                  ;
 29717                                  ; Procedure Name : CHARHARD
 29718                                  ;
 29719                                  ;
 29720                                  ; Character device error handler
 29721                                  ; Same function as HARDERR
 29722                                  ;
 29723                                  ;---------------------------------------------------------------------------
 29724                                  
 29725                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29726                                  CHARHARD:
 29727                                  	; 05/05/2019 - Retro DOS v4.0
 29728                                  	; 30/07/2018
 29729                                  	; 08/07/2018 - Retro DOS v3.0
 29730                                  
 29731                                  	; MSDOS 6.0
 29732                                  		   			; M024 - start
 29733 000052DA 36803E[2003]00          	cmp	byte [SS:ERRORMODE], 0	; Q: are we in the middle of int 24
 29734                                  	;jne	short @f		; Y: allow fail
 29735 000052E0 750B                    	jne	short chard1
 29736                                  
 29737 000052E2 80CC10                  	OR	AH,Allowed_RETRY ; 10h	; assume ctrl p
 29738                                  
 29739 000052E5 36F606[FE02]FF          	test	byte [ss:PFLAG],-1	; Q: has ctrl p been pressed
 29740 000052EB 7503                    	jnz	short ctrlp		; Y: 
 29741                                  ;@@:
 29742                                  chard1:					; M024 - end
 29743                                  	; MSDOS 6.0 & MSDOS 3.3
 29744                                  
 29745                                  ; Character device error handler
 29746                                  ; Same function as HARDERR
 29747                                  
 29748                                  	;or	ah,38h
 29749 000052ED 80CC38                  	or	ah,Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL
 29750                                  ctrlp:			; SS override for Allowed and EXITHOLD
 29751 000052F0 368826[4B03]            	mov	[SS:ALLOWED],ah
 29752                                  
 29753                                  	; 15/03/2018
 29754 000052F5 368C06[8205]                    MOV     [SS:EXITHOLD+2],ES
 29755 000052FA 36892E[8005]                    MOV     [SS:EXITHOLD],BP
 29756 000052FF 56                              PUSH    SI
 29757                                  	;and	di,0FFh
 29758 00005300 81E7FF00                        AND     DI,STECODE
 29759 00005304 8CDD                            MOV     BP,DS                   ;Device pointer is BP:SI
 29760 00005306 E86400                          CALL    FATALC
 29761 00005309 5E                              POP     SI
 29762                                  	;return
 29763 0000530A C3                              RETN
 29764                                  
 29765                                  ;---------------------------------------------------------------------------
 29766                                  ;
 29767                                  ; Procedure Name : HardErr
 29768                                  ;
 29769                                  ; Hard disk error handler. Entry conditions:
 29770                                  ;	DS:BX = Original disk transfer address
 29771                                  ;	DX = Original logical sector number
 29772                                  ;	CX = Number of sectors to go (first one gave the error)
 29773                                  ;	AX = Hardware error code
 29774                                  ;	DI = Original sector transfer count	
 29775                                  ;	ES:BP = Base of drive parameters
 29776                                  ;	[READOP] = 0 for read, 1 for write
 29777                                  ;	Allowed Set with allowed responses to this error (other bits MUST BE 0)
 29778                                  ; Output:
 29779                                  ;	[FAILERR] will be set if user responded FAIL
 29780                                  ;
 29781                                  ;--------------------------------------------------------------------------
 29782                                  
 29783                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29784                                  HARDERR:
 29785                                  	; 05/05/2019 - Retro DOS v4.0
 29786                                  	; 30/07/2018
 29787                                  	; 08/07/2018 - Retro DOS v3.0
 29788 0000530B 97                      	XCHG    AX,DI                   ; Error code in DI, count in AX
 29789                                          ;and	di,0FFh
 29790 0000530C 81E7FF00                	AND     DI,STECODE              ; And off status bits
 29791                                          ;CMP	DI,WRECODE		; Write Protect Error?
 29792                                  	;cmp	di,0
 29793 00005310 83FF00                  	cmp	DI,error_I24_write_protect ; Write Protect Error?
 29794 00005313 750A                            JNZ     short NOSETWRPERR
 29795 00005315 50                              PUSH    AX
 29796                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29797                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 29798                                          ;;MOV	AL,[ES:BP+0]
 29799                                  	; 15/12/2022
 29800 00005316 268A4600                	mov	al,[ES:BP]
 29801                                          	; 15/03/2018
 29802 0000531A 36A2[2203]                      MOV     [SS:WPERR],AL		; Flag drive with WP error
 29803 0000531E 58                              POP     AX
 29804                                  NOSETWRPERR:
 29805 0000531F 29C8                            SUB     AX,CX                   ; Number of sectors successfully transferred
 29806 00005321 01C2                            ADD     DX,AX                   ; First sector number to retry
 29807 00005323 52                              PUSH    DX
 29808                                  	; 08/07/2018
 29809                                          ;MUL	word [ES:BP+2] 		; Number of bytes transferred
 29810 00005324 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]
 29811 00005328 5A                              POP     DX
 29812 00005329 01C3                            ADD     BX,AX                   ; First address for retry
 29813 0000532B 30E4                            XOR     AH,AH                   ; Flag disk section in error
 29814                                          ;CMP	DX,[ES:BP+6] 		; In reserved area?
 29815 0000532D 263B5606                	CMP	DX,[ES:BP+DPB.FIRST_FAT]
 29816 00005331 721A                            JB      SHORT ERRINT
 29817 00005333 FEC4                            INC     AH                      ; Flag for FAT
 29818                                          ;CMP	DX,[ES:BP+10H] ; MSDOS 3.3
 29819                                  	;cmp	dx,[ES:BP+11h] ; MSDOS 6.0 - 05/05/2019 	
 29820 00005335 263B5611                	CMP	DX,[ES:BP+DPB.DIR_SECTOR]  ; In FAT?  
 29821 00005339 7308                    	JAE	short TESTDIR 		; No
 29822                                  		 ; Err in FAT must force recomp of freespace
 29823                                  	;mov	word [ES:BP+1Eh],-1 ; MSDOS 3.3
 29824                                  	;mov	word [ES:BP+1Fh],-1 ; MSDOS 6.0 - 05/05/2019 
 29825 0000533B 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1
 29826 00005341 EB0A                    	JMP	SHORT ERRINT
 29827                                  TESTDIR:
 29828 00005343 FEC4                            INC     AH
 29829                                          ;CMP	DX,[ES:BP+0BH]		; In directory?
 29830 00005345 263B560B                	CMP	DX,[ES:BP+DPB.FIRST_SECTOR] 
 29831 00005349 7202                            JB      SHORT ERRINT
 29832 0000534B FEC4                            INC     AH                      ; Must be in data area
 29833                                  ERRINT:
 29834 0000534D D0E4                            SHL     AH,1                    ; Make room for read/write bit
 29835 0000534F 360A26[7505]                    OR      AH,[SS:READOP] ; 15/03/2018
 29836                                  
 29837                                  	; 15/08/2018
 29838                                  					; SS override for allowed and EXITHOLD
 29839 00005354 360A26[4B03]            	OR	AH,[SS:ALLOWED]		; Set the allowed_ bits
 29840                                  
 29841                                          ;entry   FATAL
 29842                                  FATAL:
 29843                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29844                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 29845                                          ;;MOV	AL,[ES:BP+0]		; Get drive number
 29846                                  	; 15/12/2022
 29847 00005359 268A4600                	MOV	AL,[ES:BP]        
 29848                                  
 29849                                  	;entry   FATAL1
 29850                                  FATAL1:  
 29851                                  	; 15/03/2018      
 29852 0000535D 368C06[8205]            	MOV     [SS:EXITHOLD+2],ES
 29853 00005362 36892E[8005]                    MOV     [SS:EXITHOLD],BP	; The only things we preserve	
 29854                                  	;LES	SI,[ES:BP+12H] ; MSDOS 3.3
 29855                                  	;LES	SI,[ES:BP+13H] ; MSDOS 6.0 - 05/05/2019
 29856 00005367 26C47613                	LES	SI,[ES:BP+DPB.DRIVER_ADDR]
 29857 0000536B 8CC5                            MOV     BP,ES                   ; BP:SI points to the device involved
 29858                                  
 29859                                  	; DI has the INT-24-style extended error. We now map the error code 
 29860                                  	; for this into the normalized get extended error set by using the 
 29861                                  	; ErrMap24 table as a translate table. Note that we translate ONLY 
 29862                                  	; the device returned codes and leave all others beyond the look up 
 29863                                  	; table alone.
 29864                                  
 29865                                  	; 08/07/2018 - Retro DOS v3.0
 29866                                  FATALC:
 29867 0000536D E89701                  	call	SET_I24_EXTENDED_ERROR
 29868                                  	;cmp	di,0Ch
 29869 00005370 83FF0C                  	CMP	DI,error_I24_gen_failure
 29870 00005373 7603                    	JBE	short GOT_RIGHT_CODE	; Error codes above gen_failure get
 29871 00005375 BF0C00                  	MOV	DI,error_I24_gen_failure; mapped to gen_failure. Real codes
 29872                                  					;  Only come via GetExtendedError
 29873                                  ;** ----------------------------------------------------------------
 29874                                  ;
 29875                                  ; Entry point used by REDIRector on Network I 24 errors.
 29876                                  ;
 29877                                  ;	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
 29878                                  ;
 29879                                  ; ALL I 24 regs set up. ALL Extended error info SET. ALLOWED Set.
 29880                                  ;     EXITHOLD set for restore of ES:BP.
 29881                                  ; ------------------------------------------------------------------
 29882                                  	;entry	NET_I24_ENTRY
 29883                                  NET_I24_ENTRY:
 29884                                  GOT_RIGHT_CODE:
 29885 00005378 36803E[2003]00          	CMP     BYTE [SS:ERRORMODE],0	; No INT 24s if already INT 24
 29886 0000537E 7404                            JZ	SHORT NoSetFail
 29887 00005380 B003                    	MOV	AL,3
 29888 00005382 EB6C                    	JMP	short FailRet
 29889                                  NoSetFail:
 29890 00005384 368926[8805]                    MOV     [SS:CONTSTK],SP		; SS override
 29891 00005389 16                              PUSH	SS
 29892 0000538A 07                              POP	ES
 29893                                      
 29894                                  	; Wango!!! We may need to free some user state info... In 
 29895                                  	; particular, we may have locked down a JFN for a user and he may 
 29896                                  	; NEVER return to us. Thus,we need to free it here and then 
 29897                                  	; reallocate it when we come back.
 29898                                  
 29899 0000538B 36833E[AA05]FF          	CMP	word [SS:SFN],-1 ; 0FFFFh
 29900 00005391 740C                    	JZ	short _NoFree
 29901 00005393 1E                      	push	ds
 29902 00005394 56                      	push	si
 29903 00005395 36C536[AE05]            	LDS	SI,[SS:PJFN]
 29904 0000539A C604FF                  	MOV	BYTE [SI],0FFH
 29905 0000539D 5E                      	pop	si
 29906 0000539E 1F                      	pop	ds
 29907                                  
 29908                                  _NoFree:
 29909 0000539F FA                      	CLI
 29910                                  					; Prepare to play with stack
 29911 000053A0 36FE06[2003]                    INC     BYTE [SS:ERRORMODE]	; Flag INT 24 in progress
 29912 000053A5 36FE0E[2103]                    DEC     BYTE [SS:INDOS]		; INT 24 handler might not return
 29913                                  
 29914                                  	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 29915                                  
 29916                                  	;; Extended Open hooks
 29917                                  					; AN000;IFS.I24 error disabled
 29918                                  	;test	byte [ss:EXTOPEN_ON],2
 29919 000053AA 36F606[F605]02          	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF 
 29920 000053B0 7404                    	JZ	short i24yes		; AN000;IFS.no
 29921                                  faili24:				; AN000;
 29922 000053B2 B003                    	MOV	AL,3			; AN000;IFS.fake fail
 29923 000053B4 EB29                    	JMP	short passi24 		; AN000;IFS.exit
 29924                                  i24yes: 				; AN000;
 29925                                  	;; Extended Open hooks
 29926                                  
 29927 000053B6 368E16[8605]                    MOV     SS,[SS:USER_SS]
 29928 000053BB 268B26[8405]                    MOV     SP,[ES:USER_SP]         ; User stack pointer restored
 29929                                  
 29930                                  	;;int	24h	
 29931                                          ;IN	int_fatal_abort		; Fatal error interrupt vector,
 29932                                  					; must preserve ES
 29933                                  	; 05/05/2019
 29934 000053C0 26803E[F211]00          	cmp	byte [es:DosHasHMA], 0	; Q: is dos running in HMA (M021)
 29935 000053C6 7504                    	jne	short do_low_int24	; Y: the int must be done from low mem
 29936 000053C8 CD24                    	INT	int_fatal_abort 	; Fatal error interrupt vector, 
 29937                                  					; must preserve ES
 29938 000053CA EB05                    	jmp	short criterr_ret_addr
 29939                                  
 29940                                  do_low_int24:
 29941                                  	; 05/05/2019
 29942                                  	; MSDOS 6.0
 29943 000053CC 2EFF1E[B350]            	call    far [cs:LowInt24Addr]
 29944                                  criterr_ret_addr:
 29945 000053D1 268926[8405]                    MOV     [ES:USER_SP],SP         ; restore our stack
 29946 000053D6 268C16[8605]                    MOV     [ES:USER_SS],SS
 29947 000053DB 8CC5                            MOV     BP,ES
 29948 000053DD 8ED5                            MOV     SS,BP
 29949                                  passi24:
 29950 000053DF 368B26[8805]                    MOV     SP,[SS:CONTSTK]
 29951 000053E4 36FE06[2103]                    INC     BYTE [SS:INDOS]		; Back in the DOS
 29952 000053E9 36C606[2003]00                  MOV     BYTE [SS:ERRORMODE],0	; Back from INT 24
 29953 000053EF FB                              STI
 29954                                  FailRet:
 29955 000053F0 36C42E[8005]                    LES     BP,[SS:EXITHOLD]
 29956                                  	
 29957                                  	; 08/07/2018
 29958                                  
 29959                                  	; Triage the user's reply.
 29960                                  
 29961 000053F5 3C01                    	CMP	AL,1
 29962 000053F7 723D                    	JB	short CheckIgnore	; 0 => ignore
 29963 000053F9 7445                    	JZ	short CheckRetry	; 1 => retry
 29964 000053FB 3C03                    	CMP	AL,3			; 3 => fail
 29965 000053FD 754B                    	JNZ	short DoAbort 		; 2, invalid => abort
 29966                                  
 29967                                  	; The reply was fail. See if we are allowed to fail.
 29968                                  
 29969                                  				; SS override for ALLOWED, EXTOPEN_ON, 
 29970                                  				; ALLOWED, FAILERR, WPERR, SFN, pJFN
 29971                                  	;test	byte [ss:ALLOWED],8
 29972 000053FF 36F606[4B03]08          	test	byte [ss:ALLOWED],Allowed_FAIL ; Can we?
 29973 00005405 7443                    	jz	short DoAbort	; No, do abort
 29974                                  DoFail:
 29975 00005407 B003                    	MOV	AL,3		; just in case...
 29976                                  				; AN000;EO. I24 error disabled
 29977                                  	; 05/05/2019
 29978                                  	;(MSDOS 6.0, MSCTRLC.ASM, 1991)
 29979 00005409 36F606[F605]02          	test	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
 29980 0000540F 7505                    	jnz	short CleanUp 		; AN000;EO. no
 29981                                  	
 29982 00005411 36FE06[4A03]            	inc	byte [SS:FAILERR]	; Tell everybody
 29983                                  CleanUp:
 29984 00005416 36C606[2203]FF          	MOV	byte [SS:WPERR],-1
 29985 0000541C 36833E[AA05]FF          	CMP	word [SS:SFN],-1
 29986                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29987                                  	;jnz	short CleanUp2
 29988                                  	;retn
 29989                                  	; 17/12/2022
 29990 00005422 7411                    	jz	short Cleanup_retn ; 08/07/2018 - Retro DOS v3.0
 29991                                  CleanUp2:
 29992 00005424 1E                      	push	ds
 29993 00005425 56                      	push	si
 29994 00005426 50                      	push	ax
 29995 00005427 36A1[AA05]              	MOV	AX,[ss:SFN]
 29996 0000542B 36C536[AE05]            	LDS	SI,[ss:PJFN]
 29997 00005430 8804                    	MOV	[SI],AL
 29998 00005432 58                      	pop	ax
 29999 00005433 5E                      	pop	si
 30000 00005434 1F                      	pop	ds
 30001                                  Cleanup_retn:
 30002 00005435 C3                      	retn
 30003                                  
 30004                                  	; The reply was IGNORE. See if we are allowed to ignore.
 30005                                  
 30006                                  CheckIgnore:
 30007                                  	;test	byte [ss:ALLOWED],20h
 30008 00005436 36F606[4B03]20          	test	byte [ss:ALLOWED],Allowed_IGNORE ; Can we?
 30009 0000543C 74C9                    	jz	short DoFail			 ; No, do fail
 30010 0000543E EBD6                    	jmp	short CleanUp
 30011                                  
 30012                                  	; The reply was RETRY. See if we are allowed to retry.
 30013                                  
 30014                                  CheckRetry:
 30015                                  	;test	byte [ss:ALLOWED],10h
 30016 00005440 36F606[4B03]10          	test	byte [ss:ALLOWED],Allowed_RETRY	; Can we?
 30017 00005446 74BF                    	jz	short DoFail			; No, do fail
 30018 00005448 EBCC                    	JMP	short CleanUp
 30019                                  
 30020                                  	; The reply was ABORT.
 30021                                  DoAbort:
 30022 0000544A 16                      	push	ss
 30023 0000544B 1F                      	pop	ds
 30024                                  
 30025 0000544C 803E[5703]00            	CMP	byte [CONSWAP],0
 30026 00005451 7403                    	JZ	short NOSWAP2
 30027 00005453 E872DE                  	call	SWAPBACK
 30028                                  NOSWAP2:
 30029                                  	; See if we are to truly abort. If we are in the process of aborting, 
 30030                                  	; turn this abort into a fail.
 30031                                  
 30032                                  	;test	[fAborting],0FFh
 30033                                  	;jnz	short DoFail
 30034                                  
 30035 00005456 803E[5903]00            	cmp	byte [fAborting],0
 30036 0000545B 75AA                    	JNZ	short DoFail
 30037                                  
 30038                                  	; Set return code
 30039                                  
 30040 0000545D C606[7C05]02            	MOV	BYTE [EXIT_TYPE],EXIT_HARD_ERROR ; 2
 30041 00005462 30C0                    	XOR	AL,AL
 30042                                  
 30043                                  	; we are truly aborting the process. Go restore information from 
 30044                                  	; the PDB as necessary.
 30045                                  
 30046 00005464 E9850D                  	jmp	exit_inner
 30047                                  
 30048                                  ;** --------------------------------------------------------------------------
 30049                                  ;
 30050                                  ; reset_environment checks the DS value against the CurrentPDB. If they are
 30051                                  ; different, then an old-style return is performed. If they are the same,
 30052                                  ; then we release jfns and restore to parent. We still use the PDB at DS:0 as
 30053                                  ; the source of the terminate addresses.
 30054                                  ;
 30055                                  ; Some subtlety: We are about to issue a bunch of calls that *may* generate
 30056                                  ; INT 24s. We *cannot* allow the user to restart the abort process; we may
 30057                                  ; end up aborting the wrong process or turn a terminate/stay/resident into a
 30058                                  ; normal abort and leave interrupt handlers around. What we do is to set a
 30059                                  ; flag that will indicate that if any abort code is seen, we just continue the
 30060                                  ; operation. In essence, we dis-allow the abort response.
 30061                                  ;
 30062                                  ; output:   none.
 30063                                  ; ----------------------------------------------------------------------------
 30064                                  
 30065                                  	;entry	reset_environment
 30066                                  	
 30067                                  reset_environment:
 30068                                  	; 30/07/2018 - Retro DOS v3.0
 30069                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 588Ah 
 30070                                  
 30071                                  ;***	invoke	Reset_Version		; AN007 ;MS. reset version number
 30072                                  
 30073 00005467 1E                      	PUSH	DS			; save PDB of process
 30074                                  
 30075                                  	; There are no critical sections in force. Although we may enter 
 30076                                  	; here with critical sections locked down, they are no longer 
 30077                                  	; relevant. We may safely free all allocated resources.
 30078                                  
 30079 00005468 B482                    	MOV	AH,82h
 30080                                  		; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
 30081                                  	;int	2Ah 	
 30082 0000546A CD2A                    	INT	int_IBM
 30083                                  
 30084                                  					; SS override
 30085 0000546C 36C606[5903]FF          	MOV	byte [SS:fAborting],-1	; signal abort in progress
 30086                                  
 30087                                  					; DOS 4.00 doesn't need it
 30088                                  	;CallInstall NetResetEnvironment, MultNET, 34  
 30089                                  					; Allow REDIR to clear some stuff
 30090                                  					; On process exit.
 30091 00005472 B82211                  	mov     ax, 1122h
 30092 00005475 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
 30093                                  			; SS = DOS CS
 30094                                  	;mov	al,22h	
 30095 00005477 B022                    	MOV	AL,int_terminate
 30096 00005479 E818BA                  	call	_$GET_INTERRUPT_VECTOR	; and who to go to
 30097                                  
 30098 0000547C 59                      	POP	CX			; get ThisPDB
 30099 0000547D 06                      	push	es
 30100 0000547E 53                      	push	bx			; save return address
 30101                                  
 30102 0000547F 368B1E[3003]            	MOV	BX,[SS:CurrentPDB] 	; get currentPDB
 30103 00005484 8EDB                    	MOV	DS,BX
 30104 00005486 A11600                  	MOV	AX,[PDB.PARENT_PID]	; get parentPDB
 30105                                  
 30106                                  	; AX = parentPDB, BX = CurrentPDB, CX = ThisPDB
 30107                                  	; Only free handles if AX <> BX and BX = CX and [exit_code].upper 
 30108                                  	; is not Exit_keep_process
 30109                                  	
 30110 00005489 39D8                    	CMP	AX,BX
 30111 0000548B 7418                    	JZ	short reset_return	; parentPDB = CurrentPDB
 30112 0000548D 39CB                    	CMP	BX,CX
 30113 0000548F 7514                    	JNZ	short reset_return	; CurrentPDB <> ThisPDB
 30114 00005491 50                      	PUSH	AX			; save parent
 30115                                  
 30116                                  					; SS override
 30117                                  	;cmp	byte [SS:EXIT_TYPE],3
 30118 00005492 36803E[7C05]03          	CMP	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS ; 15/08/2018
 30119 00005498 7406                    	JZ	short reset_to_parent 	; keeping this process
 30120                                  
 30121                                  	; We are truly removing a process. Free all allocation blocks 
 30122                                  	; belonging to this PDB
 30123                                  
 30124                                  	;invoke	arena_free_process
 30125 0000549A E8870D                  	call	arena_free_process
 30126                                  
 30127                                  	; Kill off remainder of this process. Close file handles and signal 
 30128                                  	; to relevant network folks that this process is dead. Remember that 
 30129                                  	; CurrentPDB is STILL the current process!
 30130                                  
 30131                                  	;invoke	DOS_ABORT
 30132 0000549D E82FDA                  	call	DOS_ABORT
 30133                                  
 30134                                  reset_to_parent:
 30135                                  					; SS override
 30136 000054A0 368F06[3003]            	POP	word [SS:CurrentPDB]	; set up process as parent
 30137                                  
 30138                                  reset_return:				; come here for normal return
 30139                                  	;Context DS			; DS is used to refer to DOSDATA  
 30140 000054A5 16                      	push	ss
 30141 000054A6 1F                      	pop	ds	
 30142                                  
 30143 000054A7 B0FF                    	MOV	AL,-1
 30144                                  
 30145                                  	; make sure that everything is clean In this case ignore any errors, 
 30146                                  	; we cannot "FAIL" the abort, the program being aborted is dead.
 30147                                  
 30148                                  	;EnterCrit critDisk
 30149 000054A9 E861BE                  	call	ECritDisk
 30150                                  	;invoke	FLUSHBUF
 30151 000054AC E8A505                  	call	FLUSHBUF
 30152                                  	;LeaveCrit critDisk
 30153 000054AF E876BE                  	call	LCritDisk
 30154                                  
 30155                                  	; Decrement open ref. count if we had done a virtual open earlier.
 30156                                  
 30157 000054B2 E883F7                  	call	CHECK_VIRT_OPEN
 30158 000054B5 FA                      	CLI
 30159 000054B6 C606[2103]00            	MOV	BYTE [INDOS],0		; Go to known state
 30160 000054BB C606[2203]FF            	MOV	BYTE [WPERR],-1		; Forget about WP error
 30161 000054C0 C606[5903]00            	MOV	byte [fAborting],0	; let aborts occur
 30162 000054C5 8F06[8005]              	POP	WORD [EXITHOLD]
 30163 000054C9 8F06[8205]              	POP	WORD [EXITHOLD+2]
 30164                                  
 30165                                  	; Snake into multitasking... Get stack from CurrentPDB person
 30166                                  
 30167 000054CD 8E1E[3003]              	MOV	DS,[CurrentPDB]
 30168 000054D1 8E163000                	MOV	SS,[PDB.USER_STACK+2]
 30169 000054D5 8B262E00                	MOV	SP,[PDB.USER_STACK]
 30170                                  
 30171 000054D9 E86FAF                  	call	restore_world
 30172                                  
 30173                                  	; 05/05/2019
 30174 000054DC 07                      	pop	es ; * ; MSDOS 6.21 (DOSCODE:94A8h, MSDOS.SYS)
 30175                                  
 30176                                  	; MSDOS 6.0
 30177 000054DD 50                      	push	ax			; set up ds, but save ds in TEMPSEG 
 30178 000054DE 8CD8                    	mov	ax,ds			; and not on stack.
 30179                                  	;getdseg <ds>			; ds -> dosdata
 30180 000054E0 2E8E1E[0700]            	mov	ds,[cs:DosDSeg] 
 30181 000054E5 A3[0A0D]                	mov	[TEMPSEG],ax
 30182 000054E8 58                      	pop	ax
 30183                                  					; set up ds to DOSDATA
 30184                                  	;MOV	[CS:USER_SP],AX ; MSDOS 3.3
 30185 000054E9 A3[8405]                	mov	[USER_SP],ax
 30186                                  
 30187 000054EC 58                      	POP	AX			; suck off CS:IP of interrupt...
 30188 000054ED 58                      	POP	AX
 30189 000054EE 58                      	POP	AX
 30190                                  
 30191                                  ; M011 : BEGIN
 30192                                  
 30193                                  	; MSDOS 3.3
 30194                                  ;	MOV	AX,0F202h	; STI
 30195                                  
 30196                                  	; MSDOS 6.0
 30197 000054EF 9F                      	LAHF
 30198 000054F0 86E0                    	XCHG	AH,AL
 30199 000054F2 2402                    	AND	AL,2
 30200 000054F4 B4F2                    	MOV	AH,0F2h
 30201                                  
 30202                                  ; M011 : END
 30203                                  
 30204                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30205 000054F6 50                      	PUSH	AX
 30206                                   
 30207                                  	;PUSH	word [CS:EXITHOLD+2]
 30208                                  	;PUSH	word [CS:EXITHOLD]
 30209                                  	
 30210                                  	; MSDOS 6.0
 30211 000054F7 FF36[8205]              	PUSH	word [EXITHOLD+2]
 30212 000054FB FF36[8005]              	PUSH	word [EXITHOLD]
 30213                                  
 30214                                  	;MOV	AX,[CS:USER_SP]
 30215                                  
 30216                                  	; MSDOS 6.0
 30217 000054FF A1[8405]                	MOV	AX,[USER_SP]
 30218 00005502 8E1E[0A0D]              	mov	ds,[TEMPSEG]	; restore ds
 30219                                  
 30220 00005506 CF                      	IRET			; Long return back to user terminate address
 30221                                  
 30222                                  ;---------------------------------------------------------------------------
 30223                                  ;
 30224                                  ; Procedure Name : SET_I24_EXTENDED_ERROR
 30225                                  ;
 30226                                  ; This routine handles extended error codes.
 30227                                  ; Input : DI = error code from device
 30228                                  ; Output: All EXTERR fields are set
 30229                                  ;
 30230                                  ;--------------------------------------------------------------------------
 30231                                  
 30232                                  SET_I24_EXTENDED_ERROR:
 30233 00005507 50                      	PUSH	AX
 30234                                  					; ErrMap24End is in DOSDATA
 30235 00005508 B8[BB0E]                	MOV	AX,ErrMap24End
 30236 0000550B 2D[AB0E]                	SUB	AX,ErrMap24
 30237                                  					; Change to dosdata to access 
 30238                                  					; ErrMap24 and EXTERR -SR
 30239                                  	; 05/05/2019 - Retro DOS v4.0
 30240                                  	
 30241                                  	; MSDOS 6.0
 30242 0000550E 1E                      	push	ds
 30243                                  	;getdseg <ds>			; ds ->dosdata
 30244 0000550F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 30245                                  
 30246                                  	; AX is the index of the first unavailable error. Do not translate 
 30247                                  	; if greater or equal to AX.
 30248                                  
 30249 00005514 39C7                    	CMP	DI,AX
 30250 00005516 89F8                    	MOV	AX,DI
 30251 00005518 7306                    	JAE	short NoTrans
 30252                                  
 30253                                  	;MOV	AL,[CS:DI+ErrMap24]  ; MSDOS 3.3
 30254 0000551A 8A85[AB0E]              	mov	al,[ErrMap24+di] ; MSDOS 6.0
 30255 0000551E 30E4                    	XOR	AH,AH
 30256                                  NoTrans:
 30257                                  	;MOV	[CS:EXTERR],AX
 30258 00005520 A3[2403]                	mov	[EXTERR],AX
 30259 00005523 1F                      	pop	ds
 30260                                  	;assume	ds:nothing
 30261 00005524 58                      	POP	AX
 30262                                  
 30263                                  	; Now Extended error is set correctly. Translate it to get correct 
 30264                                  	; error locus class and recommended action.
 30265                                  
 30266 00005525 56                      	PUSH	SI
 30267                                  					; ERR_TABLE_24 is in DOSCODE 
 30268 00005526 BE[5B0E]                	MOV	SI,ERR_TABLE_24
 30269 00005529 E84EB1                  	call	CAL_LK			; Set other extended error fields
 30270 0000552C 5E                      	POP	SI
 30271 0000552D C3                      	retn
 30272                                  
 30273                                  ;============================================================================
 30274                                  ; FAT.ASM, MSDOS 6.0, 1991
 30275                                  ;============================================================================
 30276                                  ; 30/07/2018 - Retro DOS v3.0
 30277                                  ; 20/05/2019 - Retro DOS v4.0
 30278                                  
 30279                                  ;	TITLE	FAT - FAT maintenance routines
 30280                                  ;	NAME	FAT
 30281                                  
 30282                                  ;**	FAT.ASM
 30283                                  ;----------------------------------------------------------------------------
 30284                                  ;	Low level local device routines for performing disk change sequence,
 30285                                  ;	setting cluster validity, and manipulating the FAT
 30286                                  ;
 30287                                  ;	IsEof
 30288                                  ;	UNPACK
 30289                                  ;	PACK
 30290                                  ;	MAPCLUSTER
 30291                                  ;	FATREAD_SFT
 30292                                  ;	FATREAD_CDS
 30293                                  ;	FAT_operation
 30294                                  ;
 30295                                  ;	Revision history:
 30296                                  ;
 30297                                  ;	  AN000  version Jan. 1988
 30298                                  ;	   A001  PTM	      -- disk changed for look ahead buffers
 30299                                  ;
 30300                                  ;	M014 - if a request for pack\unpack cluster 0 is made we write\read
 30301                                  ;	       from CL0FATENTRY rather than disk.
 30302                                  
 30303                                  ; DOSCODE:94FAh (MSDOS 6.21, MSDOS.SYS)
 30304                                  
 30305                                  ;Break <IsEOF - check the quantity in BX for EOF>
 30306                                  ;----------------------------------------------------------------------------
 30307                                  ;
 30308                                  ; Procedure Name : IsEOF
 30309                                  ;
 30310                                  ; IsEOF - check the fat value in BX for eof.
 30311                                  ;
 30312                                  ;   Inputs:	ES:BP point to DPB
 30313                                  ;		BX has fat value
 30314                                  ;   Outputs:	JAE eof
 30315                                  ;   Registers modified: none
 30316                                  ;
 30317                                  ;---------------------------------------------------------------------------
 30318                                  
 30319                                  IsEOF:
 30320                                  	;cmp	word [es:bp+0Dh],0FF6h
 30321 0000552E 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; is this 16 bit fat?
 30322 00005534 730B                    	JAE	short EOF16			; yes, check for eof there
 30323                                  
 30324                                  ;J.K. 8/27/86
 30325                                  ;Modified to accept 0FF0h as an eof. This is to handle the diskfull case
 30326                                  ;of any media that has "F0"(Other) as a MediaByte.
 30327                                  ;Hopely, this does not create any side effect for those who may use any value
 30328                                  ;other than "FF8-FFF" as an EOF for their own file.
 30329                                  
 30330 00005536 81FBF00F                	cmp	bx,0FF0h
 30331 0000553A 7404                    	je	short IsEOF_other
 30332                                  
 30333 0000553C 81FBF80F                	CMP	BX,0FF8h		; do the 12 bit compare
 30334                                  IsEOF_other:
 30335 00005540 C3                      	retn
 30336                                  EOF16:
 30337 00005541 83FBF8                  	CMP	BX,0FFF8h		; 16 bit compare
 30338 00005544 C3                      	retn
 30339                                  
 30340                                  ; DOSCODE:9511h (MSDOS 6.21, MSDOS.SYS)
 30341                                  
 30342                                  ;Break	<UNPACK -- UNPACK FAT ENTRIES>
 30343                                  ;---------------------------------------------------------------------------
 30344                                  ;
 30345                                  ; Procedur Name : UNPACK
 30346                                  ;
 30347                                  ; Inputs:
 30348                                  ;	BX = Cluster number (may be full 16-bit quantity)
 30349                                  ;	ES:BP = Base of drive parameters
 30350                                  ; Outputs:
 30351                                  ;	DI = Contents of FAT for given cluster (may be full 16-bit quantity)
 30352                                  ;	Zero set means DI=0 (free cluster)
 30353                                  ;	Carry set means error (currently user FAILed to I 24)
 30354                                  ; SI Destroyed, No other registers affected. Fatal error if cluster too big.
 30355                                  ;
 30356                                  ; NOTE: if BX = 0 then DI = contents of CL0FATENTRY
 30357                                  ;
 30358                                  ;----------------------------------------------------------------------------
 30359                                  	
 30360                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30361                                  	; DOSCODE:94B5h (MSDOS 5.0, MSDOS.SYS)
 30362                                  
 30363                                  	; 20/05/2019 - Retro DOS v4.0
 30364                                  UNPACK:
 30365                                  	; MSDOS 6.0			; M014 - Start
 30366 00005545 09DB                    	or	bx, bx			; Q: are we unpacking cluster 0
 30367 00005547 7507                    	jnz	short up_cont		; N: proceed with normal unpack
 30368 00005549 8B3E[8100]              	mov	di,[CL0FATENTRY]	; Y: return value in CL0FATENTRY
 30369 0000554D 09FF                    	or	di,di 			; return z if di=0
 30370 0000554F C3                      	retn				; done
 30371                                  up_cont:				; M014 - End
 30372                                  	; MSDOS 3.3 & MSDOS 6.0
 30373                                  	;cmp	bx,[es:bp+0Dh]
 30374 00005550 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 30375 00005554 7726                    	JA	short HURTFAT
 30376 00005556 E8D600                  	CALL	MAPCLUSTER
 30377 00005559 721E                    	jc	short _DoContext
 30378 0000555B 8B3D                    	MOV	DI,[DI]
 30379 0000555D 750E                    	JNZ	short High12		; MZ if high 12 bits, go get 'em
 30380 0000555F 268B760D                	MOV	SI,[ES:BP+DPB.MAX_CLUSTER] ; MZ is this 16-bit fat?
 30381 00005563 81FEF60F                	CMP	SI,4096-10
 30382 00005567 720C                    	JB	short Unpack12		; MZ No, go 'AND' off bits
 30383 00005569 09FF                    	OR	DI,DI			; MZ set zero condition code, clears carry
 30384 0000556B EB0C                    	JMP	SHORT _DoContext 	; MZ go do context
 30385                                  High12:
 30386 0000556D D1EF                    	SHR	DI,1
 30387 0000556F D1EF                    	SHR	DI,1
 30388 00005571 D1EF                    	SHR	DI,1
 30389 00005573 D1EF                    	SHR	DI,1
 30390                                  Unpack12:
 30391 00005575 81E7FF0F                	AND	DI,0FFFh		; Clears carry
 30392                                  _DoContext:
 30393 00005579 16                      	PUSH	SS
 30394 0000557A 1F                      	POP	DS
 30395 0000557B C3                      	retn
 30396                                  HURTFAT:
 30397                                  	;;mov	word [es:bp+1Eh],0FFFFh
 30398                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 30399 0000557C 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; Err in FAT must force recomp of freespace
 30400 00005582 50                      	PUSH	AX
 30401 00005583 B488                    	MOV	AH,Allowed_FAIL+80h ; 88h
 30402                                  
 30403                                  ;hkn; SS override
 30404 00005585 36C606[4B03]08          	MOV	byte [SS:ALLOWED],Allowed_FAIL ; 8
 30405                                  ;
 30406                                  ; Signal Bad FAT to INT int_fatal_abort handler. We have an invalid cluster.
 30407                                  ;
 30408 0000558B BFFF0F                  	MOV	DI,0FFFh		; In case INT int_fatal_abort returns (it shouldn't)
 30409 0000558E E8C8FD                  	call	FATAL
 30410 00005591 3C03                    	CMP	AL,3
 30411 00005593 F8                      	CLC
 30412 00005594 7501                    	JNZ	short OKU_RET 		; Try to ignore bad FAT
 30413 00005596 F9                      	STC				; User said FAIL
 30414                                  OKU_RET:
 30415 00005597 58                      	POP	AX
 30416                                  hurtfat_retn:
 30417 00005598 C3                      	retn
 30418                                  
 30419                                  ; DOSCODE:9565h (MSDOS 6.21, MSDOS.SYS)
 30420                                  
 30421                                  ;Break	<PACK -- PACK FAT ENTRIES>
 30422                                  ;----------------------------------------------------------------------------
 30423                                  ;
 30424                                  ; Procedure Name : PACK
 30425                                  ;
 30426                                  ; Inputs:
 30427                                  ;	BX = Cluster number
 30428                                  ;	DX = Data
 30429                                  ;	ES:BP = Pointer to drive DPB
 30430                                  ; Outputs:
 30431                                  ;	The data is stored in the FAT at the given cluster.
 30432                                  ;	SI,DX,DI all destroyed
 30433                                  ;	Carry set means error (currently user FAILed to I 24)
 30434                                  ;	No other registers affected
 30435                                  ;
 30436                                  ; NOTE: if BX = 0 then data in DX is stored in CL0FATENTRY.
 30437                                  ;
 30438                                  ;---------------------------------------------------------------------------
 30439                                  
 30440                                  	; 02/01/2024
 30441                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30442                                  	; 20/05/2019 - Retro DOS v4.0
 30443                                  PACK:
 30444                                  	; MSDOS 6.0			; M014 - start
 30445 00005599 09DB                    	or	bx,bx			; Q: are we packing cluster 0
 30446 0000559B 7505                    	jnz	short p_cont		; N: proceed with normal pack
 30447 0000559D 8916[8100]              	mov	[CL0FATENTRY],dx	; Y: place value in CL0FATENTRY
 30448 000055A1 C3                      	retn				; done
 30449                                  p_cont:					; M014 - end
 30450                                  	; MSDOS 3.3 & MSDOS 6.0
 30451 000055A2 E88A00                  	CALL	MAPCLUSTER
 30452 000055A5 72D2                    	JC	short _DoContext
 30453 000055A7 8B35                    	MOV	SI,[DI]
 30454 000055A9 740B                    	JZ	short ALIGNED 		; byte (not nibble) aligned
 30455 000055AB 51                      	PUSH	CX			; move data to upper 12 bits
 30456 000055AC B104                    	MOV	CL,4
 30457 000055AE D3E2                    	SHL	DX,CL
 30458 000055B0 59                      	POP	CX
 30459 000055B1 83E60F                  	AND	SI,0FH			; leave in original low 4 bits
 30460 000055B4 EB14                    	JMP	SHORT PACKIN
 30461                                  ALIGNED:
 30462                                  	;cmp	word [es:bp+0Dh],0FF6h
 30463 000055B6 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ 16 bit fats?
 30464 000055BC 730A                    	JAE	short Pack16		; MZ yes, go clobber original data
 30465 000055BE 81E600F0                	AND	SI,0F000h		; MZ leave in upper 4 bits of original
 30466 000055C2 81E2FF0F                	AND	DX,0FFFh		; MZ store only 12 bits
 30467 000055C6 EB02                    	JMP	SHORT PACKIN		; MZ go store
 30468                                  Pack16:
 30469 000055C8 31F6                    	XOR	SI,SI			; MZ no original data
 30470                                  PACKIN:
 30471 000055CA 09D6                    	OR	SI,DX
 30472 000055CC 8935                    	MOV	[DI],SI
 30473                                  
 30474                                  ;hkn; SS override
 30475 000055CE 36C536[E205]            	LDS	SI,[SS:CURBUF]
 30476                                  	; MSDOS 6.0
 30477 000055D3 F6440540                	TEST	byte [SI+BUFFINFO.buf_flags],buf_dirty  
 30478                                  					;LB. if already dirty		  ;AN000;
 30479 000055D7 7507                    	JNZ	short yesdirty11	;LB.  don't increment dirty count ;AN000;
 30480                                  	; 10/06/2019
 30481 000055D9 E87D05                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 30482                                  	
 30483                                  	;or	byte [si+5],40h
 30484 000055DC 804C0540                	OR	byte [SI+BUFFINFO.buf_flags],buf_dirty  
 30485                                  yesdirty11:				;LB.				;AN000;
 30486                                  ;hkn; SS override
 30487 000055E0 36803E[7805]00          	CMP	BYTE [SS:CLUSSPLIT],0	; 15/08/2018
 30488                                  ;hkn; SS is DOSDATA
 30489 000055E6 16                      	push	ss
 30490 000055E7 1F                      	pop	ds
 30491 000055E8 74AE                    	jz	short hurtfat_retn	; Carry clear
 30492 000055EA 50                      	PUSH	AX
 30493 000055EB 53                      	PUSH	BX
 30494 000055EC 51                      	PUSH	CX
 30495 000055ED A1[8E05]                	MOV	AX,[CLUSSAVE]
 30496 000055F0 8E1E[E405]              	MOV	DS,[CURBUF+2]
 30497                                  	;;add	si,16 ; MSDOS 3.3
 30498                                  	;add	si,20 ; MSDOS 6.0
 30499 000055F4 83C614                  	ADD	SI,BUFINSIZ
 30500 000055F7 8824                    	MOV	[SI],AH
 30501                                  ;hkn; SS is DOSDATA
 30502                                  	;Context DS
 30503 000055F9 16                      	push	ss
 30504 000055FA 1F                      	pop	ds
 30505                                  	
 30506 000055FB 50                      	PUSH	AX
 30507                                  	
 30508                                  	; MSDOS 6.0
 30509 000055FC 8B16[9205]              	MOV	DX,[CLUSSEC+2]		;F.C. >32mb			;AN000;
 30510 00005600 8916[0706]              	MOV	[HIGH_SECTOR],DX	;F.C. >32mb			;AN000;
 30511                                  
 30512                                  	; MSDOS 3.3 & MSDOS 6.0
 30513 00005604 8B16[9005]              	MOV	DX,[CLUSSEC]
 30514                                  
 30515                                  	;MOV	SI,1	  ; *
 30516                                  	;XOR	AL,AL     ; *
 30517                                  	;call	GETBUFFRB ; *
 30518                                  	; 22/09/2023
 30519 00005608 E83E03                  	call	GETBUFFRA ; *
 30520                                  
 30521 0000560B 58                      	POP	AX
 30522 0000560C 721B                    	JC	short POPP_RET
 30523 0000560E C53E[E205]              	LDS	DI,[CURBUF]
 30524                                  	
 30525                                  	; MSDOS 6.0
 30526 00005612 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 30527                                  					;LB. if already dirty		  ;AN000;
 30528 00005616 7507                    	JNZ	short yesdirty12	;LB.  don't increment dirty count ;AN000;
 30529 00005618 E83E05                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 30530                                  	
 30531                                  	;or	byte [di+5],40h
 30532 0000561B 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty 
 30533                                  yesdirty12:
 30534                                  	;;add	di,16
 30535                                  	;add	di,20 ; MSDOS 6.0
 30536                                  	; 02/01/2024
 30537                                  	;ADD	DI,BUFINSIZ
 30538                                  	;DEC	DI
 30539 0000561F 83C713                  	add	di,BUFINSIZ-1 ; 19
 30540                                  
 30541                                  	;add	di,[es:bp+2]
 30542 00005622 26037E02                	ADD	DI,[ES:BP+DPB.SECTOR_SIZE]
 30543 00005626 8805                    	MOV	[DI],AL
 30544 00005628 F8                      	CLC
 30545                                  POPP_RET:
 30546 00005629 16                      	PUSH	SS
 30547 0000562A 1F                      	POP	DS
 30548 0000562B 59                      	POP	CX
 30549 0000562C 5B                      	POP	BX
 30550 0000562D 58                      	POP	AX
 30551 0000562E C3                      	retn
 30552                                  
 30553                                  ; 31/07/2018 - Retro DOS v3.0
 30554                                  
 30555                                  ;Break	<MAPCLUSTER - BUFFER A FAT SECTOR>
 30556                                  ;---------------------------------------------------------------------------
 30557                                  ;
 30558                                  ; Procedure Name : MAPCLUSTER
 30559                                  ;
 30560                                  ; Inputs:
 30561                                  ;	ES:BP Points to DPB
 30562                                  ;	BX Is cluster number
 30563                                  ; Function:
 30564                                  ;	Get a pointer to the cluster
 30565                                  ; Outputs:
 30566                                  ;	DS:DI Points to contents of FAT for given cluster
 30567                                  ;	DS:SI Points to start of buffer
 30568                                  ;	Zero Not set if cluster data is in high 12 bits of word
 30569                                  ;	Zero set if cluster data is in low 12 or 16 bits
 30570                                  ;	Carry set if failed.
 30571                                  ; SI is destroyed.
 30572                                  ;
 30573                                  ;---------------------------------------------------------------------------
 30574                                  
 30575                                  	; 20/05/2019 - Retro DOS v4.0
 30576                                  	; DOSCODE:9601h (MSDOS 6.21, MSDOS.SYS)
 30577                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30578                                  	; DOSCODE:95A5h (MSDOS 5.0, MSDOS.SYS)
 30579                                  
 30580                                  MAPCLUSTER:
 30581                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5A15h
 30582 0000562F C606[7805]00            	MOV	BYTE [CLUSSPLIT],0
 30583                                  	;SAVE	<AX,BX,CX,DX>
 30584 00005634 50                      	push	ax
 30585 00005635 53                      	push	bx
 30586 00005636 51                      	push	cx
 30587 00005637 52                      	push	dx
 30588 00005638 89D8                    	MOV	AX,BX			; AX = BX
 30589 0000563A 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10  ; MZ 16 bit fat?
 30590 00005640 7302                    	JAE	short Map16		; MZ yes, do 16 bit algorithm
 30591 00005642 D1E8                    	SHR	AX,1			; AX = BX/2
 30592                                  Map16:	
 30593                                  	; MSDOS 6.0			; MZ skip prev => AX=2*BX
 30594 00005644 31FF                    	XOR	DI,DI ; *		; >32mb fat ;AN000;
 30595                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30596 00005646 01D8                    	ADD	AX,BX			; AX = 1.5*fat = byte offset in fat
 30597 00005648 11FF                    	ADC	DI,DI ; * MSDOS 6.0	; >32mb fat ;DI is zero before op;AN000;
 30598 0000564A 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE]
 30599                                  
 30600                                  ;IF FastDiv
 30601                                  ;
 30602                                  ; Gross hack: 99% of all disks have 512 bytes per sector. We test for this
 30603                                  ; case and apply a really fast algorithm to get the desired results
 30604                                  ;
 30605                                  ; Divide method takes 157+4*4=173 (MOV and DIV)
 30606                                  ; Fast method takes 39+20*4=119
 30607                                  ;
 30608                                  ; This saves a bunch.
 30609                                  
 30610 0000564E 81F90002                	CMP	CX,512			; 4  Is this 512 byte sector?
 30611 00005652 7510                    	jne	short _DoDiv		; 4  for no jump
 30612 00005654 89C2                    	MOV	DX,AX			; 2  get set for remainder
 30613 00005656 81E2FF01                	AND	DX,512-1		; 4  Form remainder
 30614 0000565A 88E0                    	MOV	AL,AH			; 2  Quotient in formation in AL
 30615                                  	; MDOS 3.3
 30616                                  	;shr	al,1	
 30617                                  	; MDOS 6.0
 30618 0000565C D1EF                    	shr	di,1			; 2
 30619 0000565E D0D8                    	rcr	al,1			; 2
 30620                                  	; MDOS 3.3 (& MSDOS 6.0)
 30621 00005660 30E4                    	xor	ah,ah			; 3
 30622 00005662 EB04                    	jmp	short DivDone		; 16
 30623                                  _DoDiv:
 30624                                  ;ENDIF
 30625                                  	; MSDOS 3.3
 30626                                  	;xor	dx,dx
 30627                                  	; MSDOS 6.0
 30628 00005664 89FA                    	mov	dx,di			; 2
 30629                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 30630 00005666 F7F1                    	DIV	CX			; 155 AX is FAT sector # DX is sector index
 30631                                  ;IF FastDiv
 30632                                  DivDone:
 30633                                  ;ENDIF
 30634                                  	;add	ax,[es:bp+6]
 30635 00005668 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
 30636 0000566C 49                      	DEC	CX			; CX is sector size - 1
 30637                                  	;SAVE	<AX,DX,CX>
 30638 0000566D 50                      	push	ax
 30639 0000566E 52                      	push	dx
 30640 0000566F 51                      	push	cx
 30641 00005670 89C2                    	MOV	DX,AX
 30642                                  
 30643                                  	; MSDOS 6.0
 30644                                  	; 22/09/2023
 30645                                  	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb  low sector #
 30646                                  	;
 30647                                  	; MDOS 3.3 (& MSDOS 6.0)
 30648                                  	;XOR	AL,AL	   ; *
 30649                                  	;MOV	SI,1	   ; *
 30650                                  	;;invoke GETBUFFRB ; *
 30651                                  	;call	GETBUFFRB  ; *
 30652                                  	; 22/09/2023
 30653 00005672 E8CE02                  	call	GETBUFFRC  ; *!
 30654                                  
 30655                                  	;RESTORE <CX,AX,DX>		; CX is sec siz-1, AX is offset in sec
 30656 00005675 59                      	pop	cx
 30657 00005676 58                      	pop	ax
 30658 00005677 5A                      	pop	dx
 30659 00005678 724C                    	JC	short MAP_POP
 30660                                  
 30661 0000567A C536[E205]              	LDS	SI,[CURBUF]
 30662                                  	;;lea	di,[si+16]
 30663                                  	;lea	di,[si+20] ; MSDOS 6.0
 30664 0000567E 8D7C14                  	LEA	DI,[SI+BUFINSIZ]
 30665 00005681 01C7                    	ADD	DI,AX
 30666 00005683 39C8                    	CMP	AX,CX
 30667 00005685 752C                    	JNZ	short MAPRET
 30668 00005687 8A05                    	MOV	AL,[DI]
 30669                                  	;Context DS		 	;hkn; SS is DOSDATA
 30670 00005689 16                      	push	ss
 30671 0000568A 1F                      	pop	ds	
 30672 0000568B FE06[7805]              	INC	BYTE [CLUSSPLIT]
 30673 0000568F A2[8E05]                	MOV	[CLUSSAVE],AL
 30674 00005692 8916[9005]              	MOV	[CLUSSEC],DX
 30675                                  	; MSDOS 6.0
 30676 00005696 C706[9205]0000          	MOV	WORD [CLUSSEC+2],0      ;F.C. >32mb	;AN000;
 30677 0000569C 42                      	INC	DX
 30678                                  
 30679                                  	; 22/09/2023
 30680                                  	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb FAT sector <32mb ;AN000;
 30681                                  	;
 30682                                  	; MDOS 3.3 (& MSDOS 6.0)
 30683                                  	;XOR	AL,AL	   ; *
 30684                                  	;MOV	SI,1	   ; *
 30685                                  	;;invoke GETBUFFRB ; *
 30686                                  	;call	GETBUFFRB  ; *
 30687                                  	; 22/09/2023
 30688 0000569D E8A302                  	call	GETBUFFRC  ; *!
 30689 000056A0 7224                    	JC	short MAP_POP
 30690                                  
 30691 000056A2 C536[E205]              	LDS	SI,[CURBUF]
 30692 000056A6 8D7C14                  	LEA	DI,[SI+BUFINSIZ]
 30693 000056A9 8A05                    	MOV	AL,[DI]
 30694                                  	;Context DS			;hkn; SS is DOSDATA
 30695 000056AB 16                      	push	ss
 30696 000056AC 1F                      	pop	ds
 30697 000056AD A2[8F05]                	MOV	[CLUSSAVE+1],AL
 30698                                  
 30699                                  ;hkn; CLUSSAVE is in DOSDATA
 30700 000056B0 BF[8E05]                	MOV	DI,CLUSSAVE
 30701                                  MAPRET:
 30702                                  	;RESTORE <DX,CX,BX>
 30703 000056B3 5A                      	pop	dx
 30704 000056B4 59                      	pop	cx
 30705 000056B5 5B                      	pop	bx
 30706 000056B6 31C0                    	XOR	AX,AX			; MZ allow shift to clear carry
 30707 000056B8 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ is this 16-bit fat?
 30708 000056BE 7302                    	JAE	short MapSet		; MZ no, set flags
 30709 000056C0 89D8                    	MOV	AX,BX
 30710                                  MapSet:
 30711 000056C2 A801                    	TEST	AL,1			; set zero flag if not on boundary
 30712                                  	;RESTORE <AX>
 30713 000056C4 58                      	pop	ax
 30714 000056C5 C3                      	retn
 30715                                  
 30716                                  MAP_POP:
 30717                                  	;RESTORE <DX,CX,BX,AX>
 30718 000056C6 5A                      	pop	dx
 30719 000056C7 59                      	pop	cx
 30720 000056C8 5B                      	pop	bx
 30721 000056C9 58                      	pop	ax
 30722                                  fatread_sft_retn: ; 17/12/2022
 30723 000056CA C3                      	retn
 30724                                  
 30725                                  ; 20/05/2019 - Retro DOS v4.0
 30726                                  ; DOSCODE:96B3h (MSDOS 6.21, MSDOS.SYS)
 30727                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30728                                  ; DOSCODE:9657h (MSDOS 5.0, MSDOS.SYS)
 30729                                  
 30730                                  ;Break	<FATREAD_SFT/FATREAD_CDS -- CHECK DRIVE GET FAT>
 30731                                  ;----------------------------------------------------------------------------
 30732                                  ;
 30733                                  ; Procedure Name : FATREAD_SFT
 30734                                  ;
 30735                                  ; Inputs:
 30736                                  ;	ES:DI points to an SFT for the drive of intrest (local only,
 30737                                  ;		giving a NET SFT will produce system crashing results).
 30738                                  ;	DS DOSDATA
 30739                                  ; Function:
 30740                                  ;	Can be used by an SFT routine (like CLOSE) to invalidate buffers
 30741                                  ;	if disk changed.
 30742                                  ;	In other respects, same as FATREAD_CDS.
 30743                                  ;	(note ES:DI destroyed!)
 30744                                  ; Outputs:
 30745                                  ;	Carry set if error (currently user FAILed to I 24)
 30746                                  ; NOTE: This routine may cause FATREAD_CDS to "miss" a disk change
 30747                                  ;	as far as invalidating curdir_ID is concerned.
 30748                                  ;	Since getting a true disk changed on this call is a screw up
 30749                                  ;	anyway, that's the way it goes.
 30750                                  ;
 30751                                  ;---------------------------------------------------------------------------
 30752                                  
 30753                                  FATREAD_SFT:
 30754 000056CB 26C46D07                	LES	BP,[ES:DI+SF_ENTRY.sf_devptr]
 30755                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30756                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 30757                                  	; 15/12/2022
 30758 000056CF 268A4600                	mov	AL,[ES:BP]
 30759 000056D3 A2[7605]                	MOV	[THISDRV],AL
 30760 000056D6 E855AF                  	call	GOTDPB			;Set THISDPB
 30761                                  	;CALL	FAT_GOT_DPB
 30762                                  	; 17/12/2022
 30763 000056D9 EB78                    	jmp	FAT_GOT_DPB
 30764                                  ;fatread_sft_retn:
 30765                                  	;retn
 30766                                  
 30767                                  ;----------------------------------------------------------------------------
 30768                                  ;
 30769                                  ; Procedure Name : FATREAD_CDS
 30770                                  ;
 30771                                  ; Inputs:
 30772                                  ;	DS:DOSDATA
 30773                                  ;	ES:DI points to an CDS for the drive of intrest (local only,
 30774                                  ;		giving a NET or NUL CDS will produce system crashing results).
 30775                                  ; Function:
 30776                                  ;	If disk may have been changed, media is determined and buffers are
 30777                                  ;	flagged invalid. If not, no action is taken.
 30778                                  ; Outputs:
 30779                                  ;	ES:BP = Drive parameter block
 30780                                  ;	THISDPB = ES:BP
 30781                                  ;	THISDRV set
 30782                                  ;	Carry set if error (currently user FAILed to I 24)
 30783                                  ; DS preserved , all other registers destroyed
 30784                                  ;
 30785                                  ;---------------------------------------------------------------------------
 30786                                  
 30787                                  	; 20/05/2019 - Retro DOS v4.0
 30788                                  	; DOSCODE:96C5h (MSDOS 6.21, MSDOS.SYS)
 30789                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30790                                  	; DOSCODE:9669h (MSDOS 5.0, MSDOS.SYS)
 30791                                  
 30792                                  FATREAD_CDS:
 30793 000056DB 06                      	PUSH	ES
 30794 000056DC 57                      	PUSH	DI
 30795                                  	;les	bp,[es:di+45h]
 30796 000056DD 26C46D45                	LES	BP,[ES:DI+curdir.devptr]
 30797                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30798                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 30799                                  	; 15/12/2022
 30800 000056E1 268A4600                	mov	AL,[ES:BP]
 30801 000056E5 A2[7605]                	MOV	[THISDRV],AL
 30802 000056E8 E843AF                  	call	GOTDPB			;Set THISDPB
 30803 000056EB E86500                  	CALL	FAT_GOT_DPB
 30804 000056EE 5F                      	POP	DI			;Get back CDS pointer
 30805 000056EF 07                      	POP	ES
 30806 000056F0 72D8                    	jc	short fatread_sft_retn
 30807 000056F2 7538                    	JNZ	short NO_CHANGE		;Media NOT changed
 30808                                  
 30809                                  ;	Media changed. We now need to find all CDS structures which use this
 30810                                  ;	DPB and invalidate their ID pointers.
 30811                                  
 30812                                  MED_CHANGE:
 30813 000056F4 31C0                    	XOR	AX,AX
 30814 000056F6 48                      	DEC	AX			; AX = -1
 30815 000056F7 1E                      	PUSH	DS
 30816 000056F8 8A0E[4700]              	MOV	CL,[CDSCOUNT]
 30817 000056FC 30ED                    	XOR	CH,CH			; CX is number of structures
 30818                                  	;lds	si,[es:di+45h]
 30819 000056FE 26C57545                	LDS	SI,[ES:DI+curdir.devptr] ; Find all CDS with this devptr
 30820                                  
 30821                                  ;hkn; SS override
 30822                                  
 30823                                  ;	Find all CDSs with this DevPtr
 30824                                  ;
 30825                                  ;	(ax) = -1
 30826                                  ;	(ds:si) = DevPtr
 30827                                  
 30828 00005702 36C43E[3C00]            	LES	DI,[SS:CDSADDR]		; (es:di) = CDS pointer
 30829                                  frcd20: 
 30830                                  	;;test	word [es:di+43h],8000h
 30831                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 30832 00005707 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 30833 0000570C 7518                    	JNZ	short frcd25		; Leave NET guys alone!!
 30834                                  
 30835                                  	; MSDOS 3.3
 30836                                  	;push	es
 30837                                  	;push	di
 30838                                  	;les	di,[es:di+45h]
 30839                                  	;;les	di,[ES:DI+curdir.devptr]
 30840                                  	;call	POINTCOMP
 30841                                  	;pop	di
 30842                                  	;pop	es
 30843                                  	;jnz	short frcd25
 30844                                  
 30845                                  	; MSDOS 6.0
 30846 0000570E 263B7545                	cmp	si,[ES:DI+curdir.devptr]
 30847 00005712 7512                    	jne	short frcd25		; no match
 30848 00005714 8CDB                    	mov	bx,ds
 30849 00005716 263B5D47                	cmp	bx,[ES:DI+curdir.devptr+2]
 30850 0000571A 750A                    	jne	short frcd25		; CDS not for this drive
 30851                                  
 30852                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30853                                  	;test	[es:di+49h],ax
 30854 0000571C 26854549                	test	[ES:DI+curdir.ID],AX
 30855 00005720 7404                    	JZ	short frcd25		; If root (0), leave root
 30856                                  	;mov	[es:di+49h],ax
 30857 00005722 26894549                	MOV	[ES:DI+curdir.ID],AX	; else invalid
 30858                                  frcd25:	
 30859                                  	;;add	di,81  ; MSDOS 3.3
 30860                                  	;add	di,88  ; MSDOS 6.0	 
 30861 00005726 83C758                  	ADD	DI,curdir.size		; Point to next CDS
 30862 00005729 E2DC                    	LOOP	frcd20
 30863 0000572B 1F                      	POP	DS
 30864                                  NO_CHANGE:
 30865 0000572C C42E[8A05]              	LES	BP,[THISDPB]
 30866 00005730 F8                      	CLC
 30867 00005731 C3                      	retn
 30868                                  
 30869                                  ;Break	<Fat_Operation - miscellaneous fat stuff>
 30870                                  ;----------------------------------------------------------------------------
 30871                                  ;
 30872                                  ; Procedure Name : FAT_operation
 30873                                  ;
 30874                                  ;----------------------------------------------------------------------------
 30875                                  
 30876                                  	; 03/01/2024
 30877                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30878                                  
 30879                                  FAT_operation:
 30880                                  	; 31/07/2018 - Retro DOS v3.0
 30881                                  FATERR:
 30882                                  	;mov	word [es:bp+1Eh],-1
 30883                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
 30884 00005732 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 
 30885                                  					; Err in FAT must force recomp of freespace
 30886                                  	;and	di,0FFh
 30887 00005738 81E7FF00                	AND	DI,STECODE		; Put error code in DI
 30888                                  	;mov	byte [ALLOWED],18h
 30889 0000573C C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 30890                                  	;mov	ah,1Ah
 30891 00005741 B41A                    	MOV	AH,2+Allowed_FAIL+Allowed_RETRY ; While trying to read FAT
 30892 00005743 A0[7605]                	MOV	AL,[THISDRV]		; Tell which drive
 30893 00005746 E814FC                  	call	FATAL1
 30894 00005749 C42E[8A05]              	LES	BP,[THISDPB]
 30895 0000574D 3C03                    	CMP	AL,3
 30896 0000574F 7502                    	JNZ	short FAT_GOT_DPB	; User said retry
 30897 00005751 F9                      	STC				; User said FAIL
 30898 00005752 C3                      	retn
 30899                                  
 30900                                  FAT_GOT_DPB:
 30901                                  	;Context DS			;hkn; SS is DOSDATA
 30902 00005753 16                      	push	ss			
 30903 00005754 1F                      	pop	ds
 30904                                  	;mov	al,0Fh
 30905 00005755 B00F                    	MOV	AL,DMEDHL
 30906                                  	;mov	ah,[es:bp+1]
 30907 00005757 268A6601                	MOV	AH,[ES:BP+DPB.UNIT] 
 30908 0000575B A3[5A03]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018 
 30909 0000575E C606[5C03]01            	MOV	BYTE [DEVCALL_REQFUNC],DEVMDCH
 30910 00005763 C706[5D03]0000          	MOV	word [DEVCALL_REQSTAT],0
 30911                                  	;;mov	al,[es:bp+16h]
 30912                                  	;mov	al,[es:bp+17h] ; MSDOS 6.0
 30913 00005769 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 30914 0000576D A2[6703]                	MOV	[CALLMED],AL
 30915 00005770 06                      	PUSH	ES
 30916 00005771 1E                      	PUSH	DS
 30917                                  
 30918                                  ;hkn; DEVCALL is in DOSDATA
 30919 00005772 BB[5A03]                	MOV	BX,DEVCALL
 30920                                  	;;lds	si,[es:bp+12h]
 30921                                  	;lds	si,[es:bp+13h] ; MSDOS 6.0
 30922 00005775 26C57613                	LDS	SI,[ES:BP+DPB.DRIVER_ADDR] ; DS:SI Points to device header
 30923 00005779 07                      	POP	ES			; ES:BX Points to call header
 30924 0000577A E8FBEE                  	call	DEVIOCALL2
 30925                                  	;Context DS		 	;hkn; SS is DOSDATA
 30926 0000577D 16                      	push	ss
 30927 0000577E 1F                      	pop	ds
 30928 0000577F 07                      	POP	ES			; Restore ES:BP
 30929 00005780 8B3E[5D03]              	MOV	DI,[DEVCALL_REQSTAT]
 30930                                  	;test	di,8000h
 30931                                  	;jnz	short FATERR
 30932 00005784 09FF                    	or	di,di
 30933 00005786 78AA                    	js	short FATERR		; have error
 30934 00005788 30E4                    	XOR	AH,AH
 30935                                  	;xchg	ah,[es:bp+17h] ; MSDOS 3.3
 30936                                  	;xchg	ah,[es:bp+18h] ; MSDOS 6.0
 30937 0000578A 26866618                	XCHG	AH,[ES:BP+DPB.FIRST_ACCESS] ; Reset dpb_first_access
 30938 0000578E A0[7605]                	MOV	AL,[THISDRV]		; Use physical unit number
 30939                                  ; See if we had changed volume id by creating one on the diskette
 30940 00005791 3806[A10A]              	cmp	[VOLCHNG_FLAG],AL
 30941 00005795 7508                    	jnz	short CHECK_BYT
 30942 00005797 C606[A10A]FF            	mov	byte [VOLCHNG_FLAG],-1
 30943 0000579C E9A500                  	jmp	GOGETBPB		; Need to get device driver to read in
 30944                                  					; new volume label.
 30945                                  CHECK_BYT:
 30946 0000579F 0A26[6803]              	OR	AH,[CALLRBYT]
 30947                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 30948                                  	;JMP	short NEWDSK
 30949                                  	; 17/12/2022
 30950 000057A3 7863                    	js	short NEWDSK
 30951                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30952                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 30953                                  	;JMP	short NEWDSK
 30954                                  
 30955                                  CHECK_ZR:
 30956 000057A5 743B                    	JZ	short CHKBUFFDIRT	; jump if I don't know
 30957                                  	; 24/09/2023
 30958                                  	; cf=0 (after 'or' instruction)
 30959                                  	;CLC
 30960 000057A7 C3                      	retn				; If Media not changed (NZ)
 30961                                  
 30962                                  DISK_CHNG_ERR:
 30963 000057A8 06                      	PUSH	ES
 30964 000057A9 55                      	PUSH	BP
 30965                                  	;;les	bp,[es:bp+12h]
 30966                                  	;les	bp,[es:bp+13h] ; MSDOS 6.0
 30967 000057AA 26C46E13                	LES	BP,[ES:BP+DPB.DRIVER_ADDR] ; Get device pointer
 30968                                  	;;test	word [es:bp+4],800h
 30969                                  	;TEST	word [ES:BP+SYSDEV.ATT],DEVOPCL ; Did it set vol id?
 30970 000057AE 26F6460508              	test	byte [es:bp+SYSDEV.ATT+1],(DEVOPCL>>8)
 30971 000057B3 5D                      	POP	BP
 30972 000057B4 07                      	POP	ES
 30973 000057B5 7426                    	JZ	short FAIL_OPJ2		; Nope, FAIL
 30974 000057B7 1E                      	PUSH	DS			; Save buffer pointer for ignore
 30975 000057B8 57                      	PUSH	DI
 30976 000057B9 16                      	push	ss			;hkn; SS is DOSDATA
 30977 000057BA 1F                      	pop	ds
 30978                                  	;mov	byte [ALLOWED],18h
 30979 000057BB C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 30980 000057C0 06                      	PUSH	ES
 30981 000057C1 C43E[6903]              	LES	DI,[CALLVIDM]		; Get volume ID pointer
 30982 000057C5 8C06[2A03]              	MOV	[EXTERRPT+2],ES
 30983 000057C9 07                      	POP	ES
 30984 000057CA 893E[2803]              	MOV	[EXTERRPT],DI
 30985                                  	;mov	ax,0Fh
 30986 000057CE B80F00                  	MOV	AX,error_I24_wrong_disk
 30987 000057D1 C606[7505]01            	MOV	byte [READOP],1		; Write
 30988                                  	;invoke	HARDERR
 30989 000057D6 E832FB                  	call	HARDERR
 30990 000057D9 5F                      	POP	DI			; Get back buffer for ignore
 30991 000057DA 1F                      	POP	DS
 30992 000057DB 3C03                    	CMP	AL,3
 30993                                  FAIL_OPJ2:
 30994 000057DD 741C                    	JZ	short FAIL_OP
 30995 000057DF E971FF                  	JMP	FAT_GOT_DPB		; Retry
 30996                                  
 30997                                  CHKBUFFDIRT:
 30998                                  	; 20/05/2019 - Retro DOS v4.0
 30999                                  
 31000                                  	; MSDOS 3.3
 31001                                  	;lds	di,[BUFFHEAD]
 31002                                  
 31003                                  	; MSDOS 6.0
 31004 000057E2 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0	; any dirty buffers ? ;hkn;
 31005 000057E8 741E                    	je	short NEWDSK			; no, skip the check
 31006 000057EA E8F100                  	call	GETCURHEAD			; get pointer to first buffer
 31007                                  nbuffer:
 31008                                  	;cmp	al,[di+4]
 31009 000057ED 384504                  	cmp	[di+BUFFINFO.buf_ID],al	; Unit OK ?
 31010 000057F0 750D                    	jne	short lfnxt			; no, go for next buffer
 31011                                  	;test   byte [di+5],40h
 31012 000057F2 F6450540                	TEST	byte [di+BUFFINFO.buf_flags],buf_dirty	; is the buffer dirty ?
 31013 000057F6 7407                    	jz	short lfnxt			; no, go for next buffer
 31014                                  	;Context DS
 31015 000057F8 16                      	push	ss
 31016 000057F9 1F                      	pop	ds
 31017                                  	; 24/09/2023
 31018                                  	; cf=0 (after 'test' instruction)
 31019                                  	;clc
 31020 000057FA C3                      	retn
 31021                                  
 31022                                  FAIL_OP:					; This label & code is here
 31023                                  	;Context DS				;  for reachability
 31024 000057FB 16                      	push	ss
 31025 000057FC 1F                      	pop	ds
 31026 000057FD F9                      	STC
 31027 000057FE C3                      	retn
 31028                                  
 31029                                  lfnxt:
 31030                                  	; 15/08/2018 - Retro DOS v3.0
 31031                                  	; MSDOS 3.3
 31032                                  	;lds	di,[di]
 31033                                  
 31034                                  	; 20/05/2019 - Retro DOS v4.0
 31035 000057FF 8B3D                    	mov	di,[di]
 31036                                  	;;mov	di,[di+BUFFINFO.buf_next]	; get next buffer
 31037                                  	
 31038                                  	; MSDOS 3.3
 31039                                  	;cmp	di,-1
 31040                                  	;jne	short nbuffer
 31041                                  	
 31042                                  	; MSDOS 6.0
 31043 00005801 36393E[BB0E]            	cmp	[ss:FIRST_BUFF_ADDR],di		; is this where we started ?;hkn;
 31044 00005806 75E5                    	jne	short nbuffer			; no, check this guy also
 31045                                  
 31046                                  ; If no dirty buffers, assume Media changed
 31047                                  NEWDSK:
 31048                                  	;;mov	word [es:bp+1Eh],0FFFFh  ; MSDOS 3.3
 31049                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 31050 00005808 26C7461FFFFF            	mov	word [ES:BP+DPB.FREE_CNT],-1	; Media changed, must
 31051                                  						;  recompute
 31052                                  	; MSDOS 3.3
 31053                                  	;call	SETVISIT
 31054                                  	; MSDOS 6.0
 31055 0000580E E8CD00                  	call	 GETCURHEAD
 31056                                  nxbuffer:
 31057                                  	; MSDOS 3.3
 31058                                  	;or 	byte [di+5],20h
 31059                                  	; MSDOS 3.3 & MSDOS 6.0
 31060                                  	;cmp	[di+4],al
 31061 00005811 384504                  	cmp	[DI+BUFFINFO.buf_ID],al		; This drive ?
 31062 00005814 7510                    	jne	short lfnxt2
 31063                                  	;test	byte [di+5],40h
 31064 00005816 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 31065 0000581A 758C                    	jnz	short DISK_CHNG_ERR
 31066                                  	;mov	word [di+4],20FFh
 31067 0000581C C74504FF20              	mov	word [DI+BUFFINFO.buf_ID],(buf_visit*256)+0FFh ; free up
 31068 00005821 E8CC00                  	call	SCANPLACE
 31069                                  	; MSDOS 6.0
 31070 00005824 EB02                    	jmp	short skpbuff
 31071                                  lfnxt2:
 31072 00005826 8B3D                    	mov	di,[di]
 31073                                  	;mov	di,[di+BUFFINFO.buf_next]
 31074                                  skpbuff:
 31075                                  	; MSDOS 6.0
 31076 00005828 363B3E[BB0E]            	cmp	di,[ss:FIRST_BUFF_ADDR]					;hkn;
 31077 0000582D 75E2                    	jne	short nxbuffer
 31078                                  
 31079 0000582F 36833E[7700]00          	CMP	word [ss:SC_CACHE_COUNT],0 ;LB.  look ahead buffers ?	;AN001;
 31080 00005835 740D                    	JZ	short GOGETBPB		;LB.  no			;AN001;
 31081 00005837 363A06[B00D]            	CMP	AL,[ss:CurSC_DRIVE]	;LB.  same as changed drive	;AN001;
 31082 0000583C 7506                    	JNZ	short GOGETBPB		;LB.  no			;AN001;
 31083 0000583E 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ;LB.  invalidate look ahead buffers ;AN000;
 31084                                  ;lfnxt2:
 31085                                  	; MSDOS 3.3
 31086                                  	;call	SKIPVISIT
 31087                                  	;jnz	short nxbuffer
 31088                                  GOGETBPB:
 31089                                  	; MSDOS 3.3 & MSDOS 6.0
 31090                                  	;;lds	di,[es:bp+12h]
 31091                                  	;lds	di,[es:bp+13h] ; MSDOS 6.0	
 31092 00005844 26C57E13                	LDS	DI,[ES:BP+DPB.DRIVER_ADDR]
 31093                                  	; 20/05/2019
 31094                                  	;test	word [di+4],2000h
 31095                                  	;TEST	word [DI+SYSDEV.ATT],ISFATBYDEV
 31096 00005848 F6450520                	TEST	byte [DI+SYSDEV.ATT+1],(ISFATBYDEV>>8)
 31097 0000584C 7510                    	JNZ	short GETFREEBUF
 31098                                  	;context DS	    		;hkn; SS is DOSDATA
 31099 0000584E 16                      	push	ss
 31100 0000584F 1F                      	pop	ds
 31101 00005850 BB0200                  	MOV	BX,2
 31102 00005853 E8EFFC                  	CALL	UNPACK			; Read the first FAT sector into CURBUF
 31103                                  FAIL_OPJ:
 31104 00005856 72A3                    	JC	short FAIL_OP
 31105 00005858 C53E[E205]              	LDS	DI,[CURBUF]
 31106 0000585C EB13                    	JMP	SHORT GOTGETBUF
 31107                                  
 31108                                  GETFREEBUF:
 31109 0000585E 06                      	PUSH	ES			; Get a free buffer for BIOS to use
 31110 0000585F 55                      	PUSH	BP
 31111                                  	; MSDOS 3.3
 31112                                  	;LDS	DI,[SS:BUFFHEAD] ; 15/08/2018
 31113                                  	; MSDOS 6.0
 31114 00005860 31D2                    	XOR	DX,DX			;LB.  fake to get 1st	  ;AN000;
 31115                                  ;hkn; SS override
 31116 00005862 368916[0706]            	MOV	[SS:HIGH_SECTOR],DX ; 0	;LB.  buffer addr	  ;AN000;
 31117 00005867 E87400                  	call	GETCURHEAD		;LB.			  ;AN000;
 31118                                  	; MSDOS 3.3 & MSDOS 6.0
 31119 0000586A E84F02                  	call	BUFWRITE
 31120 0000586D 5D                      	POP	BP
 31121 0000586E 07                      	POP	ES
 31122                                  	;JC	short FAIL_OPJ
 31123 0000586F 728A                    	jc	short FAIL_OP
 31124                                  GOTGETBUF:
 31125                                  	;;add	di,16
 31126                                  	;add	di,20 ; MSDOS 6.0
 31127 00005871 83C714                  	ADD	DI,BUFINSIZ
 31128                                  
 31129                                  ;hkn; SS override
 31130 00005874 368C1E[6A03]            	MOV	[SS:CALLXAD+2],DS
 31131                                  	;Context DS			;hkn; SS is DOSDATA
 31132 00005879 16                      	push	ss
 31133 0000587A 1F                      	pop	ds
 31134 0000587B 893E[6803]              	MOV	[CALLXAD],DI
 31135                                  	;mov	al,16h
 31136 0000587F B016                    	MOV	AL,DBPBHL
 31137                                  	;mov	ah,[es:bp+1]
 31138 00005881 268A6601                	MOV	AH,[ES:BP+DPB.UNIT]
 31139 00005885 A3[5A03]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018
 31140 00005888 C606[5C03]02            	MOV	BYTE [DEVCALL_REQFUNC],DEVBPB
 31141 0000588D C706[5D03]0000          	MOV	word [DEVCALL_REQSTAT],0
 31142                                  	;;mov	al,[es:bp+16h]
 31143                                  	;mov	al,[es:bp+17h]
 31144 00005893 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 31145 00005897 A2[6703]                	MOV	[CALLMED],AL
 31146 0000589A 06                      	PUSH	ES ; **
 31147 0000589B 1E                      	PUSH	DS ; *
 31148                                  	;;
 31149                                  ; 03/01/2023
 31150                                  %if 0
 31151                                  	;;push	word [es:bp+14h]
 31152                                  	;push	word [es:bp+15h] ; MSDOS 6.0
 31153                                  	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR+2]
 31154                                  	;;push	word [es:bp+12h]
 31155                                  	;push	word [es:bp+13h] ; MSDOS 6.0
 31156                                  	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR]
 31157                                  
 31158                                  ;hkn; DEVCALL is in DOSDATA
 31159                                  	MOV	BX,DEVCALL
 31160                                  	POP	SI
 31161                                  	POP	DS			; DS:SI Points to device header
 31162                                  %endif
 31163                                  	; 03/01/2024
 31164 0000589C BB[5A03]                	mov	bx,DEVCALL
 31165                                  	;lds	si,[es:bp+13h]
 31166 0000589F 26C57613                	lds	si,[es:bp+DPB.DRIVER_ADDR]
 31167                                  					; DS:SI Points to device header
 31168                                  	;;
 31169 000058A3 07                      	POP	ES ; *			; ES:BX Points to call header
 31170                                  	;invoke	DEVIOCALL2
 31171 000058A4 E8D1ED                  	call	DEVIOCALL2
 31172 000058A7 07                      	POP	ES ; **			; Restore ES:BP
 31173                                  	;Context DS
 31174 000058A8 16                      	push	ss		 	;hkn; SS is DOSDATA
 31175 000058A9 1F                      	pop	ds
 31176 000058AA 8B3E[5D03]              	MOV	DI,[DEVCALL_REQSTAT]
 31177                                  	; MSDOS 3.3
 31178                                  	;test	di,8000h
 31179                                  	;jnz	short FATERRJ
 31180                                  	; MSDOS 6.0
 31181 000058AE 09FF                    	or	di,di
 31182 000058B0 7829                    	js	short FATERRJ 		; have error
 31183                                  	;;mov	al,[es:bp+16h]
 31184                                  	;mov	al,[es:bp+17h]  ; MSDOS 6.0
 31185 000058B2 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 31186 000058B6 C536[6C03]              	LDS	SI,[CALLBPB]
 31187                                  	;;mov	word [es:bp+1Ch],0
 31188                                  	;mov	word [es:bp+1Dh],0 ; MSDOS 6.0
 31189 000058BA 26C7461D0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 ; recycle scanning pointer
 31190                                  	;invoke	$SETDPB
 31191 000058C0 E80DB7                  	call	_$SETDPB
 31192                                  
 31193                                  ;hkn; SS override
 31194 000058C3 36C53E[6803]            	LDS	DI,[SS:CALLXAD]		; Get back buffer pointer
 31195                                  	;mov	al,[es:bp+8]
 31196 000058C8 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]
 31197                                  
 31198                                  	; MSDOS 3.3
 31199                                  	;;mov	ah,[es:bp+0Fh]
 31200                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 31201                                  	;;mov	[DI-8],ax
 31202                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AX
 31203                                  
 31204                                  	; MSDOS 6.0
 31205                                  	;mov	[di-0Ah],al
 31206 000058CC 8845F6                  	MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AL 
 31207                                  						;>32mb		  ;AN000;
 31208                                  	;mov	ax,[es:bp+0Fh]
 31209 000058CF 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]		;>32mb
 31210                                  	;mov	[di-9h],ax			  ;AC000;
 31211 000058D3 8945F7                  	MOV	[DI+BUFFINFO.buf_wrtcntinc-BUFINSIZ],AX 
 31212                                  					;>32mb Correct buffer info ;AC000;
 31213                                  	;Context DS			;hkn; SS is DOSDATA
 31214 000058D6 16                      	push	ss
 31215 000058D7 1F                      	pop	ds
 31216 000058D8 30C0                    	XOR	AL,AL			;Media changed (Z), Carry clear
 31217 000058DA C3                      	retn
 31218                                  
 31219                                  FATERRJ: 
 31220 000058DB E954FE                  	JMP	FATERR
 31221                                  
 31222                                  ;============================================================================
 31223                                  ; STDBUF.ASM
 31224                                  ;============================================================================
 31225                                  ; Retro DOS v2.0 - 12/03/2018
 31226                                  
 31227                                  ;
 31228                                  ; Standard buffer management for MSDOS
 31229                                  ;
 31230                                  
 31231                                  ;.xlist
 31232                                  ;.xcref
 31233                                  ;INCLUDE STDSW.ASM
 31234                                  ;.cref
 31235                                  ;.list
 31236                                  
 31237                                  ;TITLE	STDBUF - MSDOS buffer management
 31238                                  ;NAME	STDBUF
 31239                                  
 31240                                  ;INCLUDE BUF.ASM
 31241                                  
 31242                                  ;============================================================================
 31243                                  ; BUF.ASM
 31244                                  ;============================================================================
 31245                                  ; 31/07/2018 - Retro DOS v3.0
 31246                                  ; Retro DOS v2.0 - 12/03/2018
 31247                                  ;
 31248                                  ; buffer management for MSDOS
 31249                                  ;
 31250                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 31251                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 31252                                  ;
 31253                                  ;SUBTTL SETVISIT,SKIPVISIT -- MANAGE BUFFER SCANS
 31254                                  ;
 31255                                  ;SETVISIT:
 31256                                  ;	; 31/07/2018 - Retro DOS v3.0
 31257                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CAFh
 31258                                  ;; Inputs:
 31259                                  ;;      None
 31260                                  ;; Function:
 31261                                  ;;      Set up a scan of I/O buffers
 31262                                  ;; Outputs:
 31263                                  ;;      All visit flags = 0
 31264                                  ;;              NOTE: This pre-scan is needed because a hard disk error
 31265                                  ;;                    may cause a scan to stop in the middle leaving some
 31266                                  ;;                    visit flags set, and some not set.
 31267                                  ;;      DS:DI Points to [BUFFHEAD]
 31268                                  ;; No other registers altered
 31269                                  ;
 31270                                  ;       LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 31271                                  ;	PUSH    AX
 31272                                  ;       ;;XOR	AX,AX	  ;; MSDOS 2.11
 31273                                  ;	;mov	al,0DFh
 31274                                  ;	mov	al,~buf_visit
 31275                                  ;SETLOOP:
 31276                                  ;       ;;MOV	[DI+7],AL ;; MSDOS 2.11
 31277                                  ;	;and	[DI+5],al
 31278                                  ;	AND	[DI+BUFFINFO.buf_flags],AL
 31279                                  ;       LDS     DI,[DI]
 31280                                  ;       CMP     DI,-1
 31281                                  ;       JNZ     SHORT SETLOOP
 31282                                  ;       POP     AX ; 09/09/2018
 31283                                  ;	LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 31284                                  ;SVISIT_RETN:
 31285                                  ;       RETN
 31286                                  ;
 31287                                  ;SKIPVISIT:
 31288                                  ;	; 31/07/2018 - Retro DOS v3.0
 31289                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CC8h
 31290                                  ;
 31291                                  ;; Inputs:
 31292                                  ;;      DS:DI Points to a buffer
 31293                                  ;; Function:
 31294                                  ;;      Skip visited buffers
 31295                                  ;; Outputs:
 31296                                  ;;      DS:DI Points to next unvisited buffer
 31297                                  ;;      Zero is set if skip to LAST buffer
 31298                                  ;; No other registers altered
 31299                                  ;
 31300                                  ;       CMP     DI,-1
 31301                                  ;       ;retz
 31302                                  ;       JZ	SHORT SVISIT_RETN
 31303                                  ;
 31304                                  ;	;;CMP	BYTE [DI+7],1 ;; MSDOS 2.11
 31305                                  ;       ;;;retnz
 31306                                  ;       ;;JNZ	SHORT SVISIT_RETN
 31307                                  ;
 31308                                  ;	;test	byte [di+5],20h
 31309                                  ;	TEST	byte [DI+BUFFINFO.buf_flags],buf_visit	
 31310                                  ;	JNZ	short SKIPLOOP
 31311                                  ;	
 31312                                  ;	push	ax
 31313                                  ;	or	al,1
 31314                                  ;	pop	ax
 31315                                  ;	retn	
 31316                                  ;
 31317                                  ;SKIPLOOP:
 31318                                  ;	LDS     DI,[DI]
 31319                                  ;       JMP     SHORT SKIPVISIT
 31320                                  
 31321                                  ;============================================================================
 31322                                  ; BUF.ASM, MSDOS 6.0, 1991
 31323                                  ;============================================================================
 31324                                  ; 31/07/2018 - Retro DOS v3.0
 31325                                  ; 04/05/2019 - Retro DOS v4.0
 31326                                  
 31327                                  ;	TITLE	BUF - MSDOS buffer management
 31328                                  ;	NAME	BUF
 31329                                  
 31330                                  ;**	BUF.ASM - Low level routines for buffer cache management
 31331                                  ;
 31332                                  ;	GETCURHEAD
 31333                                  ;	ScanPlace
 31334                                  ;	PLACEBUF
 31335                                  ;	PLACEHEAD
 31336                                  ;	PointComp
 31337                                  ;	GETBUFFR
 31338                                  ;	GETBUFFRB
 31339                                  ;	FlushBuf
 31340                                  ;	BufWrite
 31341                                  ;	SET_RQ_SC_PARMS
 31342                                  ;
 31343                                  ;	Revision history:
 31344                                  ;
 31345                                  ;		AN000  version 4.00  Jan. 1988
 31346                                  ;		A004   PTM 3765 -- Disk reset failed
 31347                                  ;		M039 DB 10/17/90 - Disk write optimization
 31348                                  ;		I001   5.0 PTR 722211 - Preserve CY when in buffer in HMA
 31349                                  
 31350                                  ;Break	<GETCURHEAD -- Get current buffer header>
 31351                                  ;----------------------------------------------------------------------------
 31352                                  ; Procedure Name : GetCurHead
 31353                                  ; Inputs:
 31354                                  ;	 No Inputs
 31355                                  ; Function:
 31356                                  ;	Returns the pointer to the first buffer in Queue
 31357                                  ;	and updates FIRST_BUFF_ADDR
 31358                                  ;       and invalidates LASTBUFFER (recency pointer)
 31359                                  ; Outputs:
 31360                                  ;	DS:DI = pointer to the first buffer in Queue
 31361                                  ;	FIRST_BUFF_ADDR = offset ( DI ) of First buffer in Queue
 31362                                  ;       LASTBUFFER = -1
 31363                                  ; No other registers altered
 31364                                  ;----------------------------------------------------------------------------
 31365                                  
 31366                                  ; 04/05/2019 - Retro DOS v4.0
 31367                                  ; DOSCODE:98D2h (MSDOS 6.21, MSDOS.SYS)
 31368                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31369                                  ; DOSCODE:9876h (MSDOS 5.0, MSDOS.SYS)
 31370                                  
 31371                                  GETCURHEAD:
 31372 000058DE 36C53E[6D00]            	lds	di,[ss:BufferQueue]	; Pointer to the first buffer
 31373 000058E3 36C706[1E00]FFFF        	mov	word [ss:LastBuffer],-1	; invalidate last buffer
 31374 000058EA 36893E[BB0E]            	mov	[ss:FIRST_BUFF_ADDR],di	;save first buffer addr
 31375 000058EF C3                      	retn
 31376                                  
 31377                                  ;Break	<SCANPLACE, PLACEBUF -- PUT A BUFFER BACK IN THE POOL>
 31378                                  ;----------------------------------------------------------------------------
 31379                                  ; Procedure Name : ScanPlace
 31380                                  ; Inputs:
 31381                                  ;	Same as PLACEBUF
 31382                                  ; Function:
 31383                                  ;	Save scan location and call PLACEBUF
 31384                                  ; Outputs:
 31385                                  ;	DS:DI Points to saved scan location
 31386                                  ; All registers, except DS:DI, preserved.
 31387                                  ;----------------------------------------------------------------------------
 31388                                  ;M039: Rewritten to preserve registers.
 31389                                  
 31390                                  ;SCANPLACE:
 31391                                  ;	; 31/07/2018 - Retro DOS v3.0
 31392                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 31393                                  ;	push	es
 31394                                  ;	les	si,[di]
 31395                                  ;	;les	si,[DI+BUFFINFO.buf_link]
 31396                                  ;	call	PLACEBUF
 31397                                  ;	push	es
 31398                                  ;	pop	ds
 31399                                  ;	mov	di,si
 31400                                  ;	pop	es
 31401                                  ;scanplace_retn:
 31402                                  ;	retn	
 31403                                  	
 31404                                  	; MSDOS 6.0
 31405                                  SCANPLACE:
 31406 000058F0 FF35                    	push	word [di]
 31407                                  	;push	word [di+BUFFINFO.buf_next] ;Save scan location
 31408 000058F2 E80200                  	call	PLACEBUF
 31409 000058F5 5F                      	pop	di
 31410 000058F6 C3                      	retn
 31411                                  
 31412                                  ;----------------------------------------------------------------------------
 31413                                  ; Procedure Name : PlaceBuf
 31414                                  ; Input:
 31415                                  ;	DS:DI points to buffer (DS->BUFFINFO array, DI=offset in array)
 31416                                  ; Function:
 31417                                  ;	Remove buffer from queue and re-insert it in proper place.
 31418                                  ; NO registers altered
 31419                                  ;----------------------------------------------------------------------------
 31420                                  
 31421                                  ;procedure PLACEBUF,NEAR
 31422                                  
 31423                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31424                                  	; 20/05/2019 - Retro DOS v4.0
 31425                                  PLACEBUF:
 31426                                  	; 31/07/2018 - Retro DOS v3.0
 31427                                  
 31428                                  	; MSDOS 6.0
 31429 000058F7 50                      	push	AX			;Save only regs we modify	;AN000;
 31430 000058F8 53                      	push	BX							;AN000;
 31431                                  	; 23/09/2023
 31432                                  	;push	SI							;AN000;
 31433                                  	
 31434 000058F9 8B05                    	mov	ax,[di]
 31435                                  	;mov	ax,[di+BUFFINFO.buf_next]
 31436 000058FB 368B1E[6D00]            	mov	bx,[ss:BufferQueue]	; bx = offset of head of list;smr;SS Override
 31437                                  	
 31438 00005900 39D8                    	cmp	ax,bx				;Buf = last?		;AN000;
 31439 00005902 7422                    	je	short nret			;Yes, special case	;AN000;
 31440 00005904 39DF                    	cmp	di,bx				;Buf = first?		;AN000;
 31441 00005906 7506                    	jne	short not_first 		;Yes, special case	;AN000;
 31442 00005908 36A3[6D00]              	mov	[ss:BufferQueue],ax		;smr;SS Override
 31443 0000590C EB18                    	jmp	short nret 			;Continue with repositioning;AN000;
 31444                                  not_first:
 31445                                  	; 23/09/2023
 31446 0000590E 56                      	push	si
 31447                                  	;mov	si,[di+2]
 31448 0000590F 8B7502                  	mov	SI,[DI+BUFFINFO.buf_prev]	;No, SI = prior Buf	;AN000;
 31449 00005912 8904                    	mov	[si],ax
 31450                                  	;mov	[SI+BUFFINFO.buf_next],AX	; ax has di->buf_next	;AN000;
 31451 00005914 96                      	xchg	si,ax
 31452                                  	;mov	[si+2],ax
 31453 00005915 894402                  	mov	[SI+BUFFINFO.buf_prev],AX	;			;AN000;
 31454                                  	
 31455 00005918 8B7702                  	mov	SI,[BX+BUFFINFO.buf_prev]	;SI-> last buffer	;AN000;
 31456 0000591B 893C                    	mov	[si],di
 31457                                  	;mov	[SI+BUFFINFO.buf_next],DI	;Add Buf to end of list ;AN000;
 31458 0000591D 897F02                  	mov	[BX+BUFFINFO.buf_prev],DI				;AN000;
 31459 00005920 897502                  	mov	[DI+BUFFINFO.buf_prev],SI	;Update link in Buf too	;AN000;
 31460 00005923 891D                    	mov	[di],bx
 31461                                  	;mov	[DI+BUFFINFO.buf_next],BX				;AN000;
 31462                                  	; 23/09/2023
 31463 00005925 5E                      	pop	si
 31464                                  nret:	
 31465                                  	; 23/09/2023							;AN000;
 31466                                  	;pop	SI							;AN000;
 31467 00005926 5B                      	pop	BX							;AN000;
 31468 00005927 58                      	pop	AX							;AN000;
 31469                                  									;AN000;
 31470                                  	;cmp	byte [di+4],0FFh
 31471 00005928 807D04FF                	cmp	byte [di+BUFFINFO.buf_ID],-1	; Buffer FREE?		;AN000;
 31472 0000592C 7505                            jne	short pbx			; M039: -no, jump.
 31473 0000592E 36893E[6D00]            	mov	[ss:BufferQueue],di		; M039: -yes, make it LRU.
 31474                                  pbx:	
 31475 00005933 C3                      	retn								;AN000;
 31476                                  
 31477                                  	; 31/07/2018 - Retro DOS v3.0
 31478                                  
 31479                                  	; MSDOS 3.3
 31480                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 31481                                  
 31482                                  ;PLACEBUF:
 31483                                  ;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 31484                                  ;	
 31485                                  ;       CALL	save_world
 31486                                  ;       LES     CX,[DI]
 31487                                  ;       CMP     CX,-1           	; Buf is LAST?
 31488                                  ;       JZ      SHORT NRET		; Buffer already last
 31489                                  ;       MOV     BP,ES           	; Pointsave = Buf.nextbuf
 31490                                  ;       PUSH    DS
 31491                                  ;       POP     ES              	; Buf is ES:DI
 31492                                  ;	; 15/03/2018
 31493                                  ;       LDS     SI,[SS:BUFFHEAD] 	; Curbuf = HEAD
 31494                                  ;       CALL    POINTCOMP       	; Buf == HEAD?
 31495                                  ;       JNZ     SHORT BUFLOOP
 31496                                  ;       MOV     [SS:BUFFHEAD],CX
 31497                                  ;       MOV     [SS:BUFFHEAD+2],BP	; HEAD = Pointsave
 31498                                  ;       JMP     SHORT LOOKEND
 31499                                  ;BUFLOOP:
 31500                                  ;	; 31/07/2018
 31501                                  ;	mov	ax,ds
 31502                                  ;	mov	bx,si
 31503                                  ;	;lds	si,[SI+BUFFINFO.buf_link]
 31504                                  ;       LDS     SI,[SI]
 31505                                  ;       CALL    POINTCOMP
 31506                                  ;       jnz	short BUFLOOP
 31507                                  ;	;
 31508                                  ;	mov	ds,ax
 31509                                  ;	mov	si,bx
 31510                                  ;	mov	[SI],cx
 31511                                  ;	;mov	[SI+BUFFINFO.buf_link],cx   ; If Curbuf.nextbuf == buf
 31512                                  ;	mov	[SI+2],bp
 31513                                  ;	;mov	[BX+BUFFINFO.buf_link+2],bp ; Curbuf.nextbuf = Pointsave
 31514                                  ;LOOKEND:
 31515                                  ;	mov	ax,ds
 31516                                  ;	mov	bx,si
 31517                                  ;       LDS     SI,[SI]
 31518                                  ;       CMP     SI,-1
 31519                                  ;       jnz     short LOOKEND
 31520                                  ;GOTHEEND:
 31521                                  ;       mov	ds,ax
 31522                                  ;	mov	[BX],di
 31523                                  ;	MOV     [BX+2],ES 		; Curbuf.nextbuf = Buf
 31524                                  ;       MOV     WORD [ES:DI],-1
 31525                                  ;	;mov	word [ES:DI+BUFFINFO.buf_link],-1
 31526                                  ;       MOV     WORD [ES:DI+2],-1 	; Buf is LAST
 31527                                  ;	;mov	word [ES:DI+BUFFINFO.buf_link+2],-1
 31528                                  ;NRET:
 31529                                  ;       CALL	restore_world
 31530                                  ;	
 31531                                  ;	;cmp	byte [di+4],-1
 31532                                  ;	cmp	byte [DI+BUFFINFO.buf_ID],-1  ; Free buffer ?
 31533                                  ;	jnz     short scanplace_retn
 31534                                  ;	call    PLACEHEAD
 31535                                  ;	retn
 31536                                  
 31537                                  ;EndProc PLACEBUF
 31538                                  
 31539                                  ;M039 - Removed PLACEHEAD.
 31540                                  ;----------------------------------------------------------------------------
 31541                                  ; places buffer at head
 31542                                  ;  NOTE:::::: ASSUMES THAT BUFFER IS CURRENTLY THE LAST
 31543                                  ;	ONE IN THE LIST!!!!!!!
 31544                                  ; BUGBUG ---- this routine can be removed because it has only
 31545                                  ; BUGBUG ---- one instruction. This routine is called from
 31546                                  ; BUGBUG ---- 3 places. ( Size = 3*3+6 = 15 bytes )
 31547                                  ; BUGBUG ---- if coded in line = 3 * 5 = 15 bytes
 31548                                  ; BUGBUG ---- But kept as it is for modularity
 31549                                  ;----------------------------------------------------------------------------
 31550                                  ;procedure   PLACEHEAD,NEAR
 31551                                  ;	mov	word ptr [BufferQueue], di
 31552                                  ;	ret
 31553                                  ;EndProc PLACEHEAD
 31554                                  ;M039
 31555                                  
 31556                                  ;----------------------------------------------------------------------------
 31557                                  ; Procedure Name : PLACEHEAD
 31558                                  ;
 31559                                  ; SAME AS PLACEBUF except places buffer at head
 31560                                  ;----------------------------------------------------------------------------
 31561                                  
 31562                                  	; MSDOS 3.3 (Retro DOS v3.0)
 31563                                  	; 05/09/2018
 31564                                  	; MSDOS 2.11 (Retro DOS v2.0)
 31565                                  ;PLACEHEAD:
 31566                                  ;	; 31/07/2018 - Retro DOS v3.0
 31567                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D4Ah
 31568                                  ;
 31569                                  ;       CALL	save_world
 31570                                  ;       PUSH	DS
 31571                                  ;       POP	ES
 31572                                  ;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 31573                                  ;       LDS     SI,[SS:BUFFHEAD]
 31574                                  ;	; 31/07/2018 - Retro DOS v3.0 (MSDOS 3.3)
 31575                                  ;	CALL    POINTCOMP
 31576                                  ;       JZ      SHORT GOTHEEND2
 31577                                  ;	MOV	[ES:DI],SI
 31578                                  ;	;mov	[ES:DI+BUFFINFO.buf_link],si
 31579                                  ;       MOV	[ES:DI+2],DS
 31580                                  ;	;mov	[ES:DI+BUFFINFO.buf_link+2],ds
 31581                                  ;       MOV	[SS:BUFFHEAD],DI
 31582                                  ;       MOV	[SS:BUFFHEAD+2],ES
 31583                                  ;LOOKEND2:
 31584                                  ;       mov	ax,ds
 31585                                  ;	mov	bx,si
 31586                                  ;	;lds	si,[SI+BUFFINFO.buf_link]
 31587                                  ;       LDS     SI,[SI]
 31588                                  ;       CALL    POINTCOMP
 31589                                  ;       JNZ	SHORT LOOKEND2 ; 05/09/2018
 31590                                  ;       mov	ds,ax
 31591                                  ;	mov	word [bx],-1
 31592                                  ;	;mov	word [BX+BUFFINFO.buf_link],-1
 31593                                  ;	mov	word [bx+2],-1
 31594                                  ;	;mov	word [BX+BUFFINFO.buf_link+2],-1
 31595                                  ;GOTHEEND2:
 31596                                  ;      	call	restore_world
 31597                                  ;placehead_retn:
 31598                                  ;	retn
 31599                                  
 31600                                  ; 20/05/2019 - Retro DOS v4.0
 31601                                  ; DOSCODE:9928h (MSDOS 6.21, MSDOS.SYS)
 31602                                  
 31603                                  ;Break	<POINTCOMP -- 20 BIT POINTER COMPARE>
 31604                                  ;----------------------------------------------------------------------------
 31605                                  ;
 31606                                  ; Procedure Name : PointComp
 31607                                  ; Inputs:
 31608                                  ;         DS:SI & ES:DI
 31609                                  ; Function:
 31610                                  ;          Checks for ((SI==DI) && (ES==DS))
 31611                                  ;	   Assumes that pointers are normalized for the
 31612                                  ;	   same segment
 31613                                  ;
 31614                                  ; Compare DS:SI to ES:DI (or DS:DI to ES:SI) for equality
 31615                                  ; DO NOT USE FOR < or >
 31616                                  ; No Registers altered
 31617                                  ;
 31618                                  ;----------------------------------------------------------------------------
 31619                                  
 31620                                  POINTCOMP:
 31621                                  	; 31/07/2018 - Retro DOS v3.0
 31622                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D84h
 31623 00005934 39FE                    	CMP	SI,DI
 31624 00005936 750A                    	jnz	short _ret_label	; return if nz
 31625                                  	;jnz	short placehead_retn 
 31626 00005938 51                      	PUSH	CX
 31627 00005939 52                      	PUSH	DX
 31628 0000593A 8CD9                    	MOV	CX,DS
 31629 0000593C 8CC2                    	MOV	DX,ES
 31630 0000593E 39D1                    	CMP	CX,DX
 31631 00005940 5A                      	POP	DX
 31632 00005941 59                      	POP	CX
 31633                                  _ret_label:
 31634 00005942 C3                      	retn
 31635                                  
 31636                                  ; 01/08/2018 - Retro DOS v3.0
 31637                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D93h 
 31638                                  
 31639                                  ;Break	<GETBUFFR, GETBUFFRB -- GET A SECTOR INTO A BUFFER>
 31640                                  
 31641                                  ;**	GetBuffr - Get a non-FAT Sector into a Buffer
 31642                                  ;----------------------------------------------------------------------------
 31643                                  ;	GetBuffr does normal ( non-FAT ) sector buffering
 31644                                  ;	It gets the specified local sector into one of the I/O buffers
 31645                                  ;	and shuffles the queue
 31646                                  ; 
 31647                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 31648                                  ;		       ELSE no pre-read
 31649                                  ;		(DX) = Desired physical sector number	      (LOW)
 31650                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 31651                                  ;		(ES:BP) = Pointer to drive parameters
 31652                                  ;		ALLOWED set in case of INT 24
 31653                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 31654                                  ;		'C' clear if OK
 31655                                  ;		CURBUF Points to the Buffer for the sector
 31656                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 31657                                  ;	USES	AX, BX, CX, SI, DI, Flags
 31658                                  ;----------------------------------------------------------------------------
 31659                                  
 31660                                  ;**	GetBuffrb - Get a FAT Sector into a Buffer
 31661                                  ;----------------------------------------------------------------------------
 31662                                  ;	GetBuffrb reads a sector from the FAT file system's FAT table.
 31663                                  ;	It gets the specified sector into one of the I/O buffers
 31664                                  ;	and shuffles the queue. We need a special entry point so that
 31665                                  ;	we can read the alternate FAT sector if the first read fails, also
 31666                                  ;	so we can mark the buffer as a FAT sector.
 31667                                  ; 
 31668                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 31669                                  ;		       ELSE no pre-read
 31670                                  ;		(DX) = Desired physical sector number	     (LOW)
 31671                                  ;		(SI) != 0
 31672                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 31673                                  ;		(ES:BP) = Pointer to drive parameters
 31674                                  ;		ALLOWED set in case of INT 24
 31675                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 31676                                  ;		'C' clear if OK
 31677                                  ;		CUR ddBUF Points to the Buffer for the sector
 31678                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 31679                                  ;	USES	AX, BX, CX, SI, DI, Flags
 31680                                  ;----------------------------------------------------------------------------
 31681                                  
 31682                                  	; 22/09/2023 - RetroDOS v4.2 MSDOS.SYS (optimization)
 31683                                  GETBUFFRC:
 31684 00005943 C706[0706]0000          	mov	word [HIGH_SECTOR],0
 31685                                  GETBUFFRA:
 31686 00005949 30C0                    	xor	al,al
 31687 0000594B BE0100                  	mov	si,1
 31688 0000594E EB09                    	jmp	short GETBUFFRB
 31689                                  
 31690                                  	; 22/09/2023
 31691                                  GETBUFFER:
 31692 00005950 30C0                    	xor	al,al
 31693                                  GETBUFFRD:
 31694                                  	;mov	byte [ALLOWED],18h
 31695 00005952 C606[4B03]18            	mov	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 31696                                  
 31697                                  	; 20/05/2019 - Retro DOS v4.0
 31698                                  	; DOSCODE:9937h (MSDOS 6.21, MSDOS.SYS)
 31699                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31700                                  	; DOSCODE:98DBh (MSDOS 5.0, MSDOS.SYS)
 31701                                  GETBUFFR:
 31702 00005957 31F6                    	XOR	SI,SI
 31703                                  
 31704                                  ;	This entry point is called for FAT buffering with SI != 0
 31705                                  
 31706                                  GETBUFFRB:
 31707 00005959 A3[9405]                	MOV	[PREREAD],AX			; save pre-read flag
 31708                                  	; 15/12/2022
 31709 0000595C 268A4600                	mov	al,[ES:BP]
 31710                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31711                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 31712 00005960 C53E[1E00]              	LDS	DI,[LastBuffer]			; Get the recency pointer
 31713                                  	; MSDOS 6.0
 31714                                  ;hkn; SS override
 31715 00005964 368B0E[0706]            	MOV	CX,[SS:HIGH_SECTOR]		; F.C. >32mb	;AN000;
 31716                                  
 31717                                  ;	See if this is the buffer that was most recently returned.
 31718                                  ;	A big performance win if it is.
 31719                                  
 31720 00005969 83FFFF                  	CMP	DI,-1				; Recency pointer valid?
 31721 0000596C 7412                    	je	short getb5			; No
 31722                                  	;cmp	dx,[di+6]
 31723 0000596E 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 31724 00005971 750D                    	JNZ	short getb5			; Wrong sector
 31725                                  	
 31726                                  	; MSDOS 6.0
 31727                                  	;cmp	cx,[di+8]
 31728 00005973 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]	; F.C. >32mb	;AN000;
 31729 00005976 7508                    	JNZ	short getb5			; F.C. >32mb	;AN000;
 31730                                  	
 31731                                  	;cmp	al,[di+4]
 31732 00005978 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 31733                                  	;JZ	getb35				; Just asked for same buffer
 31734 0000597B 7503                    	jnz	short getb5
 31735                                  	;jmp	getb35
 31736                                  	; 17/12/2022
 31737                                  	; 28/07/2019
 31738 0000597D E9C700                  	jmp	getb35x
 31739                                  	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31740                                  	;jmp	getb35
 31741                                  
 31742                                  ;	It's not the buffer most recently returned. See if it's in the
 31743                                  ;	cache.
 31744                                  ;
 31745                                  ;	(cx:dx) = sector #
 31746                                  ;	(al) = drive #
 31747                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 31748                                  ;	??? list may be incomplete ???
 31749                                  
 31750                                  getb5:	
 31751                                  	; MSDOS 3.3
 31752                                  	;lds	di,[SS:BUFFHEAD]
 31753                                  	; MSDOS 6.0
 31754 00005980 E85BFF                  	CALL	GETCURHEAD			; get Q Head
 31755                                  getb10:	
 31756                                  	;cmp	dx,[di+6]
 31757 00005983 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 31758 00005986 750D                    	jne	short getb12			; wrong sector lo
 31759                                  	
 31760                                  	; MSDOS 6.0
 31761                                  	;cmp	cx,[di+8]
 31762 00005988 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]
 31763 0000598B 7508                    	jne	short getb12			; wrong sector hi
 31764                                  	
 31765                                  	;cmp	al,[di+4]
 31766 0000598D 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 31767                                  	;je	short getb25 ; 05/09/2018	; Found the requested sector
 31768 00005990 7503                    	jne	short getb12
 31769 00005992 E98C00                  	jmp	getb25
 31770                                  getb12:	
 31771                                  	; MSDOS 3.3
 31772                                  	;;mov	di,[DI]
 31773                                  	;;;mov	di,[DI+BUFFINFO.buf_link]
 31774                                  	;
 31775                                  	; 15/08/2018
 31776                                  	;lds	di,[di]
 31777                                  
 31778                                  	;cmp	di,-1 ; 0FFFFh
 31779                                  	;jne	short getb10
 31780                                  	;lds	di,[SS:BUFFHEAD]
 31781                                  
 31782                                  	; MSDOS 6.0
 31783 00005995 8B3D                    	mov	di,[di]
 31784                                  	;mov	DI,[DI+BUFFINFO.BUF_NEXT]
 31785 00005997 363B3E[BB0E]            	cmp	DI,[SS:FIRST_BUFF_ADDR]		; back at the front again?
 31786 0000599C 75E5                    	jne	short getb10			; no, continue looking
 31787                                  
 31788                                  ;	The requested sector is not available in the buffers. DS:DI now points
 31789                                  ;	to the first buffer in the Queue. Flush the first buffer & read in the
 31790                                  ;	new sector into it.
 31791                                  ;
 31792                                  ;	BUGBUG - what goes on here? Isn't the first guy the most recently
 31793                                  ;	used guy? Shuld be for fast lookup. If he is, we shouldn't take
 31794                                  ;	him, we should take LRU. And the above lookup shouldn't be
 31795                                  ;	down a chain, but should be hashed.
 31796                                  ;
 31797                                  ;	(DS:DI) = first buffer in the queue
 31798                                  ;	(CX:DX) = sector # we want
 31799                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 31800                                  
 31801                                  	; MSDOS 3.3 & MSDOS 6.0
 31802                                  ;hkn; SS override
 31803 0000599E 51                      	PUSH	CX  ; MSDOS 6.0
 31804 0000599F 56                      	push	si
 31805 000059A0 52                      	push	dx
 31806 000059A1 55                      	push	bp
 31807 000059A2 06                      	push	es
 31808 000059A3 E81601                  	CALL	BUFWRITE			; Write out the dirty buffer
 31809 000059A6 07                      	pop	es
 31810 000059A7 5D                      	pop	bp
 31811 000059A8 5A                      	pop	dx
 31812 000059A9 5E                      	pop	si
 31813 000059AA 368F06[0706]            	POP	word [SS:HIGH_SECTOR]  ; MSDOS 6.0
 31814                                  	;jc	short getbx			; if got hard error
 31815 000059AF 7303                    	jnc	short getb13
 31816 000059B1 E99D00                  	jmp	getbx
 31817                                  
 31818                                  getb13:
 31819                                  	; MSDOS 6.0
 31820 000059B4 E88F01                  	CALL	SET_RQ_SC_PARMS 		; set parms for secondary cache
 31821                                  
 31822                                  ;	We're ready to read in the buffer, if need be. If the caller
 31823                                  ;	wanted to just *write* the buffer then we'll skip reading it in.
 31824                                  
 31825 000059B7 30E4                    	XOR	AH,AH				; initial flags
 31826                                  ;hkn; SS override
 31827                                  	;test	byte [ss:PREREAD],0FFh
 31828                                  	;jnz	short getb20
 31829 000059B9 363826[9405]            	CMP	[SS:PREREAD],ah ; 0		; am to Read in the new sector?
 31830 000059BE 7549                    	JNZ	short getb20			; no, we're done
 31831                                  	;;lea	bx,[di+16] ; MSDOS 3.3
 31832                                  	;lea	bx,[di+20] ; MSDOS 6.0
 31833 000059C0 8D5D14                  	LEA	BX,[DI+BUFINSIZ] 		; (ds:bx) = data address
 31834                                  	;MOV	CX,1
 31835                                  	; 22/09/2023
 31836 000059C3 29C9                    	sub	cx,cx ; 0
 31837 000059C5 56                      	push	si
 31838 000059C6 57                      	push	di
 31839 000059C7 52                      	push	dx
 31840                                  	; MSDOS 6.0
 31841 000059C8 06                      	push	es ; ***
 31842                                  
 31843                                  ; Note: As far as I can tell, all disk reads into buffers go through
 31844                                  ;	this point. -mrw 10/88
 31845                                  	
 31846                                  	;cmp	byte [ss:BuffInHMA],0	; is buffers in HMA?
 31847                                  	; 22/09/2023
 31848 000059C9 36380E[7900]            	cmp	[ss:BuffInHMA],cl ; 0
 31849 000059CE 7407                    	jz	short getb14
 31850 000059D0 1E                      	push	ds ; **
 31851 000059D1 53                      	push	bx ; *
 31852 000059D2 36C51E[7A00]            	lds	bx,[ss:LoMemBuff]	; Then let's read it into scratch buff
 31853                                  getb14:
 31854                                  ;M039: Eliminated redundant HMA code.
 31855                                  
 31856                                  	; 22/09/2023
 31857 000059D7 41                      	inc	cx ; cx = 1
 31858                                  
 31859                                  	; MSDOS 3.3 (& MSDOS 6.0)
 31860 000059D8 09F6                    	OR	SI,SI			; FAT sector ?
 31861 000059DA 7407                    	JZ	short getb15		
 31862                                  
 31863 000059DC E80BDD                  	call	FATSECRD
 31864                                  	;mov	ah,2
 31865 000059DF B402                    	MOV	AH,buf_isFAT		; Set buf_flags
 31866                                  
 31867 000059E1 EB05                    	JMP	SHORT getb17		; Buffer is marked free if read barfs
 31868                                  
 31869                                  getb15:
 31870 000059E3 E830DD                  	call	DREAD			; Buffer is marked free if read barfs
 31871 000059E6 B400                    	MOV	AH,0			; Set buf_flags to no type, DO NOT XOR!
 31872                                  getb17:
 31873                                  	; 17/12/2022	
 31874                                  ; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31875                                  ;%if 0
 31876                                  	; MSDOS 6.0							  ;I001
 31877 000059E8 9C                      	pushf								  ;I001
 31878 000059E9 36803E[7900]00          	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ? ;I001
 31879 000059EF 7411                    	jz	short not_in_hma	; no				  ;I001
 31880                                  	;mov	cx,[es:bp+2]
 31881 000059F1 268B4E02                	mov	cx,[ES:BP+DPB.SECTOR_SIZE]				  ;I001
 31882 000059F5 D1E9                    	shr	cx,1							  ;I001
 31883 000059F7 9D                      	popf				; Retrieve possible CY from DREAD ;I001
 31884 000059F8 89DE                    	mov	si,bx							  ;I001
 31885 000059FA 5F                      	pop	di ; *							  ;I001
 31886 000059FB 07                      	pop	es ; **							  ;I001
 31887 000059FC FC                      	cld								  ;I001
 31888 000059FD 9C                      	pushf				; Preserve possible CY from DREAD ;I001
 31889 000059FE F3A5                    	rep	movsw			; move the contents of scratch buf;I001
 31890 00005A00 06                      	push	es							  ;I001
 31891 00005A01 1F                      	pop	ds							  ;I001
 31892                                  ;%endif
 31893                                  
 31894                                  ; 17/12/2022
 31895                                  %if 0
 31896                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31897                                  	; MSDOS 5.0
 31898                                  	pushf
 31899                                  	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ?
 31900                                  	jz	short not_in_hma	; no
 31901                                  	popf
 31902                                  	mov	cx,[ES:BP+DPB.SECTOR_SIZE]
 31903                                  	shr	cx,1
 31904                                  	mov	si,bx
 31905                                  	pop	di ; *
 31906                                  	pop	es ; **
 31907                                  	cld
 31908                                  	rep	movsw
 31909                                  	push	es
 31910                                  	pop	ds
 31911                                  	jmp	short getb19 ; 27/11/2022
 31912                                  %endif
 31913                                  
 31914                                  not_in_hma:								  ;I001
 31915 00005A02 9D                      	popf							 	  ;I001
 31916                                  getb19:
 31917 00005A03 07                      	pop	es ; ***
 31918 00005A04 5A                      	pop	dx
 31919 00005A05 5F                      	pop	di
 31920 00005A06 5E                      	pop	si
 31921 00005A07 7248                    	JC	short getbx
 31922                                  
 31923                                  ;	The buffer has the data setup in it (if we were to read)
 31924                                  ;	Setup the various buffer fields
 31925                                  ;
 31926                                  ;	(ds:di) = buffer address
 31927                                  ;	(es:bp) = DPB address
 31928                                  ;	(HIGH_SECTOR:DX) = sector #
 31929                                  ;	(ah) = BUF_FLAGS value
 31930                                  ;	(si) = 0 if non fat sector, != 0 if FAT sector read
 31931                                  
 31932                                  ;hkn; SS override
 31933                                  getb20:	; MSDOS 6.0
 31934 00005A09 368B0E[0706]            	MOV	CX,[SS:HIGH_SECTOR]
 31935                                  	;mov	[di+8],cx
 31936 00005A0E 894D08                  	MOV	[DI+BUFFINFO.buf_sector+2],CX
 31937                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 31938                                   	;mov	[di+6],dx
 31939 00005A11 895506                  	MOV	[DI+BUFFINFO.buf_sector],DX
 31940                                  	;;mov	[di+0Ah],bp  ; MSDOS 3.3
 31941                                  	;mov	[di+0Dh],bp  ; MSDOS 6.0
 31942 00005A14 896D0D                  	MOV	[DI+BUFFINFO.buf_DPB],BP
 31943                                  	;;mov	[di+0Ch],es
 31944                                  	;mov	[di+0Fh],es  ; MSDOS 6.0
 31945 00005A17 8C450F                  	MOV	[DI+BUFFINFO.buf_DPB+2],ES
 31946                                  	; 15/12/2022
 31947 00005A1A 268A4600                	mov	al,[es:bp]
 31948                                  	;mov	al,[es:bp+0]
 31949                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31950                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 31951                                  	;mov	[di+4],ax
 31952 00005A1E 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX		; Set ID and Flags
 31953                                  getb25:	
 31954                                  	; MSDOS 3.3
 31955                                  	;mov     ax,1
 31956                                  
 31957                                  	; MSDOS 6.0
 31958                                  	;mov	byte [di+0Ah],1
 31959 00005A21 C6450A01                	MOV	byte [DI+BUFFINFO.buf_wrtcnt],1	; Default to not a FAT sector ;AC000;
 31960 00005A25 31C0                    	XOR	AX,AX
 31961                                  
 31962                                  	; MSDOS 3.3 (& MSDOS 6.0)
 31963 00005A27 09F6                    	OR	SI,SI				; FAT sector ?
 31964 00005A29 740B                    	JZ	short getb30
 31965                                  
 31966                                  	;mov	al,[es:bp+8]
 31967 00005A2B 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]	; update number of copies of
 31968                                  	
 31969                                  	; MSDOS 6.0
 31970 00005A2F 88450A                  	MOV	[DI+BUFFINFO.buf_wrtcnt],AL	;  this sector present on disk
 31971                                  	;mov	ax,[es:bp+0Fh]
 31972 00005A32 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]		; offset of identical FAT
 31973                                  						;  sectors
 31974                                  	; MSDOS 3.3
 31975                                  	;;mov	ah,[es:bp+0Fh]
 31976                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 31977                                  
 31978                                  ;	BUGBUG - dos 6 can clean this up by not setting wrtcntinc unless wrtcnt
 31979                                  ;		is set
 31980                                  
 31981                                  getb30:	
 31982                                  	; MSDOS 6.0
 31983                                  	;mov	[di+0Bh],ax
 31984 00005A36 89450B                  	MOV	[DI+BUFFINFO.buf_wrtcntinc],AX
 31985                                  
 31986                                  	; MSDOS 3.3
 31987                                  	;;mov	[di+8],ax ; 15/08/2018	
 31988                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt],AX
 31989                                  
 31990 00005A39 E8BBFE                  	CALL	PLACEBUF
 31991                                  
 31992                                  ;hkn; SS override for next 4
 31993                                  getb35: 
 31994                                  	; 17/12/2022
 31995                                  	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31996                                  	; MSDOS 3.3 & MSDOS 5.0 & MSDOS 6.0
 31997                                  	;MOV	[SS:CURBUF+2],DS
 31998                                  	;MOV	[SS:LastBuffer+2],DS
 31999                                  	;MOV	[SS:CURBUF],DI
 32000                                  	;MOV	[SS:LastBuffer],DI
 32001                                  	;CLC
 32002                                  
 32003                                  	; 17/12/2022
 32004                                  	; 07/12/2022
 32005                                  	; Retro DOS v4.0
 32006 00005A3C 368C1E[2000]            	mov	[ss:LastBuffer+2],ds
 32007 00005A41 36893E[1E00]            	mov	[ss:LastBuffer],di
 32008 00005A46 F8                      	clc
 32009                                  getb35x: ; 28/07/2019
 32010 00005A47 368C1E[E405]            	MOV	[ss:CURBUF+2],ds
 32011 00005A4C 36893E[E205]            	MOV	[ss:CURBUF],di
 32012                                  
 32013                                  ;	Return with 'C' set appropriately
 32014                                  ;	(dx) = caller's original value
 32015                                  
 32016                                  getbx:	
 32017 00005A51 16                      	push	ss
 32018 00005A52 1F                      	pop	ds
 32019                                  	;retn
 32020                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32021                                  getbuffrb_retn:
 32022                                  ;flushbuf_retn:	; 17/12/2022
 32023 00005A53 C3                      	retn
 32024                                  
 32025                                  ;Break	<FLUSHBUF -- WRITE OUT DIRTY BUFFERS>
 32026                                  ;----------------------------------------------------------------------------
 32027                                  ; Input:
 32028                                  ;	DS = DOSGROUP
 32029                                  ;	AL = Physical unit number local buffers only
 32030                                  ;	   = -1 for all units and all remote buffers
 32031                                  ; Function:
 32032                                  ;	Write out all dirty buffers for unit, and flag them as clean
 32033                                  ;	Carry set if error (user FAILed to I 24)
 32034                                  ;	    Flush operation completed.
 32035                                  ; DS Preserved, all others destroyed (ES too)
 32036                                  ;----------------------------------------------------------------------------
 32037                                  
 32038                                  	; 20/05/2019 - Retro DOS v4.0
 32039                                  	; DOSCODE:9A35h (MSDOS 6.21, MSDOS.SYS)
 32040                                  
 32041                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32042                                  	; DOSCODE:99DAh (MSDOS 5.0, MSDOS.SYS)
 32043                                  FLUSHBUF:
 32044                                  	; MSDOS 3.3
 32045                                  	;;mov	ah,-1 ; 01/08/2018 - Retro DOS v3.0
 32046                                  	;lds	di,[BUFFHEAD]
 32047                                  
 32048                                  	; MSDOS 6.0
 32049 00005A54 E887FE                  	call	GETCURHEAD
 32050                                  	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 32051 00005A57 36F606[1106]04          	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
 32052 00005A5D 7508                    	jnz	short scan_buf_queue
 32053 00005A5F 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0			;hkn;
 32054 00005A65 7423                    	je	short end_scan
 32055                                  	
 32056                                  scan_buf_queue:
 32057 00005A67 E82900                  	call	CHECKFLUSH
 32058                                  	;push	ax  ; MSDOS 3.3
 32059                                  	; MSDOS 6.0
 32060                                  	;mov	ah,[di+4]
 32061 00005A6A 8A6504                  	mov	ah,[DI+BUFFINFO.buf_ID]
 32062 00005A6D 363826[2203]            	cmp	[SS:WPERR],ah					;hkn;
 32063 00005A72 7408                    	je	short free_the_buf
 32064                                  	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 32065 00005A74 36F606[1106]04          	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
 32066 00005A7A 7405                    	jz	short dont_free_the_buf
 32067                                  	; MSDOS 3.3
 32068                                  	;;mov	al,[di+4]
 32069                                  	;mov	al,[DI+BUFFINFO.buf_ID]
 32070                                  	;cmp	[SS:WPERR],al					;hkn;
 32071                                  	; 15/08/2018
 32072                                  	;jne	short dont_free_the_buf	
 32073                                  free_the_buf:
 32074                                  	; MSDOS 6.0 (& MSDOS 3.3)
 32075 00005A7C C74504FF00              	mov	word [DI+BUFFINFO.buf_ID],00FFh
 32076                                  dont_free_the_buf:
 32077                                  	;pop	ax  ; MSDOS 3.3 	   	
 32078                                  
 32079                                  	; MSDOS 3.3
 32080                                  	;mov	di,[DI]
 32081                                  	;;mov	di,[DI+BUFFINFO.buf_link] ; .buf_next
 32082                                  	;
 32083                                  	; 15/08/2018
 32084                                  	;lds	di,[di]
 32085                                  	;
 32086                                  	;cmp	di,-1 ; 0FFFFh
 32087                                  	;jnz	short scan_buf_queue 
 32088                                  	
 32089                                  	; MSDOS 6.0
 32090 00005A81 8B3D                    	mov	di,[di]
 32091                                  	;mov	di,[DI+BUFFINFO.buf_next] ; .buf_link
 32092 00005A83 363B3E[BB0E]            	cmp	di,[SS:FIRST_BUFF_ADDR]				;hkn;
 32093 00005A88 75DD                    	jne	short scan_buf_queue
 32094                                  
 32095                                  end_scan:
 32096 00005A8A 16                      	push	ss
 32097 00005A8B 1F                      	pop	ds
 32098                                  	; 01/08/2018 - Retro DOS v3.0
 32099                                  	;cmp	byte [FAILERR],0
 32100                                  	;jne	short bad_flush
 32101                                  	;retn
 32102                                  ;bad_flush:
 32103                                  	;stc
 32104                                  	;retn
 32105                                  
 32106                                  	; 17/12/2022
 32107                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32108                                  	; 01/08/2018 - Retro DOS v3.0
 32109 00005A8C 803E[4A03]01            	cmp	byte [FAILERR],1
 32110 00005A91 F5                      	cmc
 32111                                  flushbuf_retn:
 32112 00005A92 C3                      	retn
 32113                                  	
 32114                                  	; 17/12/2022
 32115                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32116                                  	;cmp	byte [FAILERR],0
 32117                                  	;jne	short bad_flush
 32118                                  	;retn
 32119                                  ;bad_flush:
 32120                                  	;stc
 32121                                  	;retn
 32122                                  
 32123                                  ;----------------------------------------------------------------------------
 32124                                  ;
 32125                                  ; Procedure Name : CHECKFLUSH
 32126                                  ;
 32127                                  ; Inputs : AL - Drive number, -1 means do not check for drive
 32128                                  ;	   DS:DI - pointer to buffer
 32129                                  ;
 32130                                  ; Function : Write out a buffer if it is dirty
 32131                                  ;
 32132                                  ; Carry set if problem (currently user FAILed to I 24)
 32133                                  ;
 32134                                  ;----------------------------------------------------------------------------
 32135                                  
 32136                                  CHECKFLUSH:
 32137                                  	; MSDOS 6.0
 32138 00005A93 B4FF                    	mov	ah,-1	; 01/08/2018 Retro DOS v3.0
 32139                                  	;cmp	[di+4],ah
 32140 00005A95 386504                  	CMP	[DI+BUFFINFO.buf_ID],AH
 32141 00005A98 74F8                    	jz	short flushbuf_retn	; Skip free buffer, carry clear
 32142 00005A9A 38C4                    	CMP	AH,AL			; 
 32143 00005A9C 7406                    	JZ	short DOBUFFER		; do this buffer
 32144                                  	;cmp	al,[di+4]
 32145 00005A9E 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 32146 00005AA1 F8                      	CLC
 32147 00005AA2 75EE                    	jnz	short flushbuf_retn	; Buffer not for this unit or SFT
 32148                                  DOBUFFER:
 32149                                  	;test	byte [di+5],40h
 32150 00005AA4 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 32151 00005AA8 74E8                    	jz	short flushbuf_retn	; Buffer not dirty, carry clear by TEST
 32152 00005AAA 50                      	PUSH	AX
 32153                                  	;push	word [di+4]
 32154 00005AAB FF7504                  	PUSH	WORD [DI+BUFFINFO.buf_ID]
 32155 00005AAE E80B00                  	CALL	BUFWRITE
 32156 00005AB1 58                      	POP	AX
 32157 00005AB2 7206                    	JC	short LEAVE_BUF		; Leave buffer marked free (lost).
 32158                                  	;and	ah,0BFh
 32159 00005AB4 80E4BF                  	AND	AH,~buf_dirty		; Buffer is clean, clears carry
 32160                                  	;mov	[di+4],ax
 32161 00005AB7 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX
 32162                                  LEAVE_BUF:
 32163 00005ABA 58                      	POP	AX			; Search info
 32164                                  checkflush_retn:
 32165 00005ABB C3                      	retn
 32166                                  
 32167                                  ;Break	<BUFWRITE -- WRITE OUT A BUFFER IF DIRTY>
 32168                                  ;----------------------------------------------------------------------------
 32169                                  ;
 32170                                  ;	BufWrite writes a buffer to the disk, if it's dirty.
 32171                                  ;
 32172                                  ;	ENTRY	DS:DI Points to the buffer
 32173                                  ;
 32174                                  ;	EXIT	Buffer marked free
 32175                                  ;		Carry set if error (currently user FAILed to I 24)
 32176                                  ;
 32177                                  ;	USES	All buf DS:DI
 32178                                  ;		HIGH_SECTOR
 32179                                  ;----------------------------------------------------------------------------
 32180                                  
 32181                                  	; 20/05/2019 - Retro DOS v4.0
 32182                                  	; DOSCODE:9AA0h (MSDOS 6.21, MSDOS.SYS)
 32183                                  
 32184                                  
 32185                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32186                                  	; DOSCODE:9A45h (MSDOS 5.0, MSDOS.SYS)
 32187                                  
 32188                                  BUFWRITE:
 32189                                  	; 10/09/2018
 32190                                  	; 01/08/2018 - Retro DOS v3.0
 32191                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E94h
 32192 00005ABC B8FF00                  	MOV	AX,00FFH
 32193                                  	;xchg	ax,[di+4]
 32194 00005ABF 874504                  	XCHG	AX,[DI+BUFFINFO.buf_ID]	; Free, in case write barfs
 32195 00005AC2 3CFF                    	CMP	AL,0FFH
 32196 00005AC4 74F5                    	jz      short checkflush_retn	; Buffer is free, carry clear.
 32197                                  	;test	ah,40h
 32198 00005AC6 F6C440                  	test	AH,buf_dirty
 32199 00005AC9 74F0                    	jz      short checkflush_retn	; Buffer is clean, carry clear.
 32200                                  	; MSDOS 6.0
 32201 00005ACB E89100                  	call	DEC_DIRTY_COUNT 	; LB. decrement dirty count
 32202                                  
 32203                                  ;hkn; SS override
 32204 00005ACE 363A06[2203]            	CMP	AL,[SS:WPERR]
 32205 00005AD3 74E6                    	jz      short checkflush_retn	; If in WP error zap buffer
 32206                                  
 32207                                  ;hkn; SS override
 32208                                  	; MSDOS 6.0
 32209 00005AD5 36A2[AF0D]              	MOV	[SS:SC_DRIVE],AL	;LB. set it for invalidation ;AN000;
 32210                                  	
 32211                                  	;;les	bp,[di+10] ; MSDOS 3.3
 32212                                  	;les	bp,[di+13] ; MSDOS 6.0
 32213 00005AD9 C46D0D                  	LES	BP,[DI+BUFFINFO.buf_DPB]
 32214                                  	;;lea	bx,[di+16]
 32215                                  	;lea	bx,[di+20] ; MSDOS 6.0
 32216 00005ADC 8D5D14                  	LEA	BX,[DI+BUFINSIZ]	; Point at buffer
 32217                                  	;mov	dx,[di+6]
 32218 00005ADF 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector] ;F.C. >32mb		;AN000;
 32219                                  	
 32220                                  	; MSDOS 6.0
 32221                                  	;mov	cx,[di+8]
 32222 00005AE2 8B4D08                  	MOV	CX,[DI+BUFFINFO.buf_sector+2] ;F.C. >32mb	;AN000;
 32223                                  
 32224                                  ;hkn; SS override
 32225 00005AE5 36890E[0706]            	MOV	[SS:HIGH_SECTOR],CX	;F.C. >32mb		;AN000;
 32226 00005AEA 8A4D0A                  	MOV	CL,[DI+BUFFINFO.buf_wrtcnt] ;>32mb		;AC000;
 32227                                  	; MSDOS 3.3
 32228                                  	;; mov	cx,[DI+8]
 32229                                  	;mov	cx,[DI+BUFFINFO.buf_wrtcnt]
 32230                                  	;MOV	AL,CH			; [DI+BUFFINFO.buf_wrtcntinc]
 32231 00005AED 30ED                    	XOR	CH,CH
 32232                                  	;;mov	ah,ch ; MSDOS 3.3
 32233                                  
 32234                                  ;hkn; SS override for ALLOWED
 32235                                  	;mov	byte [SS:ALLOWED],18h
 32236 00005AEF 36C606[4B03]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 32237                                  	;test	byte [di+5],8
 32238                                  	; MSDOS 6.0 (& Retro DOS 3.0)
 32239                                  	;test	ah,8
 32240 00005AF5 F6C408                  	test	AH,buf_isDATA
 32241 00005AF8 7406                    	JZ	short NO_IGNORE
 32242                                  	;or	byte [SS:ALLOWED],20h
 32243 00005AFA 36800E[4B03]20          	OR	byte [SS:ALLOWED],Allowed_IGNORE
 32244                                  NO_IGNORE:
 32245                                  	;xor	ah,ah ; 10/09/2018 (MSDOS 3.3, Retro DOS v3.0)
 32246                                  	; MSDOS 6.0
 32247                                  	;mov	ax,[di+11]
 32248 00005B00 8B450B                  	MOV	AX,[DI+BUFFINFO.buf_wrtcntinc]	;>32mb		;AC000;
 32249                                  
 32250 00005B03 57                      	PUSH	DI		; Save buffer pointer
 32251 00005B04 31FF                    	XOR	DI,DI		; Indicate failure
 32252                                  
 32253 00005B06 1E                      	push	ds ; *
 32254 00005B07 53                      	push	bx ; **
 32255                                  WRTAGAIN:
 32256 00005B08 57                      	push	di ; ***
 32257 00005B09 51                      	push	cx ; ****
 32258 00005B0A 50                      	push	ax ; *****
 32259                                  	;MOV	CX,1
 32260                                  	; 17/12/2022
 32261                                  	; ch = 0
 32262 00005B0B B101                    	mov	cl,1 ; 24/07/2019
 32263                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32264                                  	;mov	cx,1
 32265 00005B0D 53                      	push	bx ; ******
 32266 00005B0E 52                      	push	dx ; *******
 32267 00005B0F 1E                      	push	ds ; ********
 32268                                  
 32269                                  ; Note: As far as I can tell, all disk reads into buffers go through this point. -mrw 10/88
 32270                                  
 32271                                  	; MSDOS 6.0
 32272                                  	;cmp	byte [ss:BuffInHMA],0 ; 10/06/2019
 32273                                  	; 22/09/2023
 32274 00005B10 36382E[7900]            	cmp	[ss:BuffInHMA],ch ; 0
 32275 00005B15 7418                    	jz	short NBUFFINHMA
 32276 00005B17 51                      	push	cx
 32277 00005B18 06                      	push	es
 32278 00005B19 89DE                    	mov	si,bx
 32279 00005B1B 268B4E02                	mov	cx,[es:bp+DPB.SECTOR_SIZE]
 32280 00005B1F D1E9                    	shr	cx,1
 32281 00005B21 36C43E[7A00]            	les	di,[ss:LoMemBuff] ; 10/06/2019
 32282 00005B26 89FB                    	mov	bx,di
 32283 00005B28 FC                      	cld
 32284 00005B29 F3A5                    	rep	movsw
 32285 00005B2B 06                      	push	es
 32286 00005B2C 1F                      	pop	ds
 32287 00005B2D 07                      	pop	es
 32288 00005B2E 59                      	pop	cx
 32289                                  NBUFFINHMA:
 32290 00005B2F E844DC                  	call	DWRITE		; Write out the dirty buffer
 32291 00005B32 1F                      	pop	ds ; ********
 32292 00005B33 5A                      	pop	dx ; *******
 32293 00005B34 5B                      	pop	bx ; ******
 32294 00005B35 58                      	pop	ax ; *****
 32295 00005B36 59                      	pop	cx ; ****
 32296 00005B37 5F                      	pop	di ; ***
 32297 00005B38 7201                    	JC	short NOSET
 32298 00005B3A 47                      	INC	DI		; If at least ONE write succeedes, the operation
 32299                                  NOSET:				;	succeedes.
 32300 00005B3B 01C2                    	ADD	DX,AX
 32301 00005B3D E2C9                    	LOOP	WRTAGAIN
 32302 00005B3F 5B                      	pop	bx ; **
 32303 00005B40 1F                      	pop	ds ; *
 32304                                  	;OR	DI,DI		; Clears carry
 32305                                  	;JNZ	short BWROK	; At least one write worked
 32306                                  	;STC			; DI never got INCed, all writes failed.
 32307                                  	; 22/09/2023
 32308 00005B41 83FF01                  	cmp	di,1
 32309                                  BWROK:	
 32310 00005B44 5F                      	POP	DI
 32311 00005B45 C3                      	retn
 32312                                  
 32313                                  ;**	Set_RQ_SC_Parms - Set Secondary Cache Parameters
 32314                                  ;----------------------------------------------------------------------------
 32315                                  ;	Set_RQ_SC_Parms sets the sector size and drive number value
 32316                                  ;	for the secondary cache. This updates SC_SECTOR_SIZE &
 32317                                  ;	SC_DRIVE even if SC is disabled to save the testing
 32318                                  ;	code and time
 32319                                  ;
 32320                                  ;	ENTRY	ES:BP = drive parameter block
 32321                                  ;
 32322                                  ;	EXIT	[SC_SECTOR_SIZE]= drive sector size
 32323                                  ;		[SC_DRIVE]= drive #
 32324                                  ;
 32325                                  ;	USES	Flags
 32326                                  ;----------------------------------------------------------------------------
 32327                                  
 32328                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32329                                  ; 04/05/2019 - Retro DOS v4.0
 32330                                  
 32331                                  SET_RQ_SC_PARMS:
 32332                                  ;hkn; SS override for all variables used in this procedure.
 32333 00005B46 50                      	push	ax
 32334                                  	;mov	ax,[es:bp+2]
 32335 00005B47 268B4602                	MOV	ax,[ES:BP+DPB.SECTOR_SIZE]	; save sector size
 32336 00005B4B 36A3[AD0D]              	MOV	[ss:SC_SECTOR_SIZE],ax
 32337                                  	;;mov	al,[es:bp+0]
 32338                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32339                                  	;MOV	al,[ES:BP+DPB.DRIVE]		; save drive #
 32340                                  	; 15/12/2022
 32341 00005B4F 268A4600                	mov	al,[ES:BP]
 32342 00005B53 36A2[AF0D]              	MOV	[ss:SC_DRIVE],al
 32343 00005B57 58                      	pop	ax
 32344                                  srspx:	
 32345 00005B58 C3                      	retn					;LB. return
 32346                                  
 32347                                  ;Break	<INC_DIRTY_COUNT-increment dirty count>
 32348                                  ;----------------------------------------------------------------------------
 32349                                  ; Input:
 32350                                  ;	none
 32351                                  ; Function:
 32352                                  ;	increment dirty buffers count
 32353                                  ; Output:
 32354                                  ;	dirty buffers count is incremented
 32355                                  ;
 32356                                  ; All registers preserved
 32357                                  ;----------------------------------------------------------------------------
 32358                                  
 32359                                  INC_DIRTY_COUNT:
 32360                                  ;; BUGBUG  ---- remove this routine
 32361                                  ;; BUGBUG ---- only one instruction is needed (speed win, space loose)
 32362 00005B59 36FF06[7100]            	inc	word [ss:DirtyBufferCount]	;hkn;
 32363 00005B5E C3                      	retn
 32364                                  
 32365                                  ;Break	<DEC_DIRTY_COUNT-decrement dirty count>
 32366                                  ;----------------------------------------------------------------------------
 32367                                  ; Input:
 32368                                  ;	none
 32369                                  ; Function:
 32370                                  ;	decrement dirty buffers count
 32371                                  ; Output:
 32372                                  ;	dirty buffers count is decremented
 32373                                  ;
 32374                                  ; All registers preserved
 32375                                  ;----------------------------------------------------------------------------
 32376                                  
 32377                                  DEC_DIRTY_COUNT:
 32378 00005B5F 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0 ;hkn;
 32379 00005B65 7405                    	jz	short ddcx		; BUGBUG - shouldn't it be an
 32380 00005B67 36FF0E[7100]            	dec	word [ss:DirtyBufferCount] 
 32381                                  					; error condition to underflow here? ;hkn;
 32382                                  ddcx:	
 32383 00005B6C C3                      	retn
 32384                                  
 32385                                  ;============================================================================
 32386                                  ; MSPROC.ASM, MSDOS 6.0, 1992
 32387                                  ;============================================================================
 32388                                  ; 02/08/2018 - Retro DOS v3.0
 32389                                  ; 29/04/2019 - Retro DOS v4.0
 32390                                  
 32391                                  ; (15/04/2018 - RetrO DOS v2.0, MSDOS 2.11 - PROC.ASM - 1983)
 32392                                  
 32393                                  ; Pseudo EXEC system call for DOS
 32394                                  
 32395                                  ;	TITLE	MSPROC - process maintenance
 32396                                  ;	NAME	MSPROC
 32397                                  
 32398                                  ; =========================================================================
 32399                                  ;**	Process related system calls and low level routines for DOS 2.X.
 32400                                  ;	I/O specs are defined in DISPATCH.
 32401                                  ;
 32402                                  ;	$WAIT
 32403                                  ;	$EXEC
 32404                                  ;	$Keep_process
 32405                                  ;	Stay_resident
 32406                                  ;	$EXIT
 32407                                  ;	$ABORT
 32408                                  ;	abort_inner
 32409                                  ;
 32410                                  ;	Modification history:
 32411                                  ;
 32412                                  ;		Created: ARR 30 March 1983
 32413                                  ;		AN000	version 4.0 jan. 1988
 32414                                  ;		A007	PTM 3957 - fake vesrion for IBMCACHE.COM
 32415                                  ;		A008	PTM 4070 - fake version for MS WINDOWS
 32416                                  ;
 32417                                  ;		M000	added support for loading programs into UMBs 7/9/90
 32418                                  ;
 32419                                  ;		M004 - MS PASCAL 3.2 support. Please see under tag M003 in 
 32420                                  ;		       dossym.inc. 7/30/90
 32421                                  ;		M005 - Support for EXE programs with out STACK segment and 
 32422                                  ;		       with resident size < 64K - 256 bytes. A 256 byte 
 32423                                  ;		       stack is provided at the end of the program. Note that
 32424                                  ;		       only SP is changed.
 32425                                  ;		M020 - Fix for Rational bug for details see exepatch.asm
 32426                                  ;
 32427                                  ;		M028 - 4b04 implementation
 32428                                  ;
 32429                                  ;		M029 - Support for EXEs without stack rewritten. If EXE is
 32430                                  ;			in memory block >= 64K, sp = 0. If memory block
 32431                                  ;			obtained is <64K, point sp at the end of the memory
 32432                                  ;			block. For EXEs smaller than 64K, 256 bytes are still
 32433                                  ;			added for a stack segment which may be needed if it
 32434                                  ;			is loaded in low memory situations.
 32435                                  ;
 32436                                  ;		M030 - Fixing bug in EXEPACPATCH & changing 4b04 to 4b05
 32437                                  ;
 32438                                  ;		M040 - Bug #3052. The environment sizing code would flag a
 32439                                  ;			a bad environment if it reached 32767 bytes. Changed
 32440                                  ;			to allow 32768 bytes of environment.
 32441                                  ;
 32442                                  ;		M047 - Release the allocated UMB when we failed to load a 
 32443                                  ;		       COM file high. Also ensure that if the biggest block
 32444                                  ;		       into which we load the com file is less than 64K then
 32445                                  ;		       we provide atleast 256 bytes of stack to the user.
 32446                                  ;
 32447                                  ;		M050 - Made Lie table search CASE insensitive
 32448                                  ;
 32449                                  ;		M060 - Removed special version table from the kernal and
 32450                                  ;                      put it in a device drive which puts the address
 32451                                  ;                      in the DOS DATA area location UU_IFS_DOS_CALL
 32452                                  ;		       as a DWORD.
 32453                                  ;
 32454                                  ;		M063 - Modified UMB support. If the HIGH_ONLY bit is set on
 32455                                  ;		       entry do not try to load low if there is no space in
 32456                                  ;		       UMBs.
 32457                                  ;
 32458                                  ;		M068 - Support for copy protect apps. Call ChkCopyProt to 
 32459                                  ;		       set a20off_count. Set bit EXECA20BIT in DOS_FLAG. Also
 32460                                  ;		       change return address to LeaveDos if AL=5.
 32461                                  ;
 32462                                  ;               20-Jul-1992 bens  Added ifdef RESTRICTED_BUILD code that
 32463                                  ;                      controls building a version of MSDOS.SYS that only
 32464                                  ;                      runs programs from a fixed list (defined in the
 32465                                  ;                      file RESTRICT.INC).  Search for "RESTRICTED_BUILD"
 32466                                  ;                      for details.  This feature is used to build a
 32467                                  ;                      "special" version of DOS that can be handed out to
 32468                                  ;                      OEM/ISV customers as part of a "service" disk.
 32469                                  ;
 32470                                  ; =========================================================================
 32471                                  
 32472                                  ;SAVEXIT  EQU  10
 32473                                  
 32474                                  ;BREAK	<$WAIT - return previous process error code>
 32475                                  ; =========================================================================
 32476                                  ;	$WAIT - Return previous process error code.
 32477                                  ;
 32478                                  ;	Assembler usage:
 32479                                  ;
 32480                                  ;	    MOV     AH, WaitProcess
 32481                                  ;	    INT     int_command
 32482                                  ;
 32483                                  ;	ENTRY	none
 32484                                  ;	EXIT	(ax) = exit code
 32485                                  ;	USES	all
 32486                                  ; =========================================================================
 32487                                  
 32488                                  	; 20/05/2019 - Retro DOS v4.0
 32489                                  	; DOSCODE:9B55h (MSDOS 6.21, MSDOS.SYS)
 32490                                  
 32491                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32492                                  	; DOSCODE:9A5Ah (MSDOS 5.0, MSDOS.SYS)	
 32493                                  _$WAIT:
 32494                                  	; 02/08/2018 - Retro DOS v3.0
 32495                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E1h
 32496                                  
 32497 00005B6D 31C0                    	xor	AX,AX
 32498 00005B6F 368706[3403]            	xchg	AX,[ss:exit_code]
 32499 00005B74 E9C0AA                  	jmp	SYS_RET_OK
 32500                                  
 32501                                  ; =========================================================================
 32502                                  ;BREAK <$exec - load/go a program>
 32503                                  ;	EXEC.ASM - EXEC System Call
 32504                                  ;
 32505                                  ;
 32506                                  ; Assembler usage:
 32507                                  ;	    lds     DX, Name
 32508                                  ;	    les     BX, Blk
 32509                                  ;	    mov     AH, Exec
 32510                                  ;	    mov     AL, FUNC
 32511                                  ;	    int     INT_COMMAND
 32512                                  ;
 32513                                  ;	AL  Function
 32514                                  ;	--  --------
 32515                                  ;	 0  Load and execute the program.
 32516                                  ;	 1  Load, create the program header but do not
 32517                                  ;	    begin execution.
 32518                                  ;	 3  Load overlay. No header created.
 32519                                  ;
 32520                                  ;	    AL = 0 -> load/execute program
 32521                                  ;
 32522                                  ;	    +---------------------------+
 32523                                  ;	    | WORD segment address of	|
 32524                                  ;	    | environment.		|
 32525                                  ;	    +---------------------------+
 32526                                  ;	    | DWORD pointer to ASCIZ	|
 32527                                  ;	    | command line at 80h	|
 32528                                  ;	    +---------------------------+
 32529                                  ;	    | DWORD pointer to default	|
 32530                                  ;	    | FCB to be passed at 5Ch	|
 32531                                  ;	    +---------------------------+
 32532                                  ;	    | DWORD pointer to default	|
 32533                                  ;	    | FCB to be passed at 6Ch	|
 32534                                  ;	    +---------------------------+
 32535                                  ;
 32536                                  ;	    AL = 1 -> load program
 32537                                  ;
 32538                                  ;	    +---------------------------+
 32539                                  ;	    | WORD segment address of	|
 32540                                  ;	    | environment.		|
 32541                                  ;	    +---------------------------+
 32542                                  ;	    | DWORD pointer to ASCIZ	|
 32543                                  ;	    | command line at 80h	|
 32544                                  ;	    +---------------------------+
 32545                                  ;	    | DWORD pointer to default	|
 32546                                  ;	    | FCB to be passed at 5Ch	|
 32547                                  ;	    +---------------------------+
 32548                                  ;	    | DWORD pointer to default	|
 32549                                  ;	    | FCB to be passed at 6Ch	|
 32550                                  ;	    +---------------------------+
 32551                                  ;	    | DWORD returned value of	|
 32552                                  ;	    | CS:IP			|
 32553                                  ;	    +---------------------------+
 32554                                  ;	    | DWORD returned value of	|
 32555                                  ;	    | SS:IP			|
 32556                                  ;	    +---------------------------+
 32557                                  ;
 32558                                  ;	    AL = 3 -> load overlay
 32559                                  ;
 32560                                  ;	    +---------------------------+
 32561                                  ;	    | WORD segment address where|
 32562                                  ;	    | file will be loaded.	|
 32563                                  ;	    +---------------------------+
 32564                                  ;	    | WORD relocation factor to |
 32565                                  ;	    | be applied to the image.	|
 32566                                  ;	    +---------------------------+
 32567                                  ;
 32568                                  ; Returns:
 32569                                  ;	    AX = error_invalid_function
 32570                                  ;	       = error_bad_format
 32571                                  ;	       = error_bad_environment
 32572                                  ;	       = error_not_enough_memory
 32573                                  ;	       = error_file_not_found
 32574                                  ; =========================================================================
 32575                                  ;
 32576                                  ;   Revision history:
 32577                                  ;
 32578                                  ;	 A000	version 4.00  Jan. 1988
 32579                                  ;
 32580                                  ; =========================================================================
 32581                                  
 32582                                  Exec_Internal_Buffer		EQU	OPENBUF
 32583                                  Exec_Internal_Buffer_Size	EQU	(128+128+53+curdirLen)
 32584                                  
 32585                                  ; =========================================================================
 32586                                  
 32587                                  ;IF1		; warning message on buffers
 32588                                  ;%out	Please make sure that the following are contiguous and of the
 32589                                  ;%out	following sizes:
 32590                                  ;%out
 32591                                  ;%out	OpenBuf     128
 32592                                  ;%out	RenBuf	    128
 32593                                  ;%out	SearchBuf    53
 32594                                  ;%out	DummyCDS    curdirLen
 32595                                  ;ENDIF
 32596                                  
 32597                                  ; =========================================================================
 32598                                  
 32599                                  ; =========================================================================
 32600                                  ;
 32601                                  ; =========================================================================
 32602                                  
 32603                                  	; 20/05/2019 - Retro DOS v4.0
 32604                                  	; DOSCODE:9B5Fh (MSDOS 6.21, MSDOS.SYS)
 32605                                  
 32606                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32607                                  	; DOSCODE:9B04h (MSDOS 5.0, MSDOS.SYS)
 32608                                  	
 32609                                  _$EXEC:
 32610                                  	; 02/08/2018 - Retro DOS v3.0
 32611                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5EF1h
 32612                                  
 32613                                  EXEC001S:
 32614                                  	;LocalVar    Exec_Blk		,DWORD
 32615                                  	;LocalVar    Exec_Func		,BYTE
 32616                                  	;LocalVar    Exec_Load_High	,BYTE
 32617                                  	;LocalVar    Exec_FH		,WORD
 32618                                  	;LocalVar    Exec_Rel_Fac	,WORD
 32619                                  	;LocalVar    Exec_Res_Len_Para	,WORD
 32620                                  	;LocalVar    Exec_Environ	,WORD
 32621                                  	;LocalVar    Exec_Size		,WORD
 32622                                  	;LocalVar    Exec_Load_Block	,WORD
 32623                                  	;LocalVar    Exec_DMA		,WORD
 32624                                  	;LocalVar    ExecNameLen 	,WORD
 32625                                  	;LocalVar    ExecName		,DWORD
 32626                                  	;
 32627                                  	;LocalVar    Exec_DMA_Save	,WORD
 32628                                  	;LocalVar    Exec_NoStack	,BYTE
 32629                                  
 32630                                  	; MSDOS 3.3 (& MSDOS 6.0)
 32631                                  	;%define	Exec_Blk	dword [bp-4]
 32632                                  	%define		Exec_Blk	[bp-4] ; 09/08/2018
 32633                                  	%define		Exec_BlkL	word [bp-4]	
 32634                                  	%define		Exec_BlkH	word [bp-2]
 32635                                  	%define		Exec_Func	byte [bp-5]
 32636                                  	%define		Exec_Load_High	byte [bp-6]
 32637                                  	%define		Exec_FH		word [bp-8]
 32638                                  	%define		Exec_Rel_Fac	word [bp-10]
 32639                                  	%define		Exec_Res_Len_Para word [bp-12]
 32640                                  	%define		Exec_Environ	word [bp-14]
 32641                                  	%define		Exec_Size	word [bp-16]
 32642                                  	%define		Exec_Load_Block	word [bp-18]
 32643                                  	%define		Exec_DMA	word [bp-20]
 32644                                  	%define		ExecNameLen	word [bp-22]
 32645                                  	;%define	ExecName	dword [bp-26]
 32646                                  	%define		ExecName	[bp-26] ; 09/08/2018
 32647                                  	%define		ExecNameL	word [bp-26]	
 32648                                  	%define		ExecNameH	word [bp-24]
 32649                                  	; MSDOS 6.0
 32650                                  	%define		Exec_DMA_Save	word [bp-28]
 32651                                  	%define		Exec_NoStack	byte [bp-29]
 32652                                  	
 32653                                  	; ==================================================================
 32654                                  	; validate function
 32655                                  	; ==================================================================
 32656                                  		      	
 32657                                  	; M068 - Start
 32658                                  	;
 32659                                  	; Reset the A20OFF_COUNT to 0. This is done as there is a 
 32660                                  	; possibility that the count may not be decremented all the way to
 32661                                  	; 0. A typical case is if the program for which we intended to keep 
 32662                                  	; the A20  off for a sufficiently long time (A20OFF_COUNT int 21 
 32663                                  	; calls), exits pre-maturely due to error conditions.
 32664                                  
 32665                                  	; MSDOS 6.0
 32666 00005B77 36C606[8500]00          	mov	byte [SS:A20OFF_COUNT], 0
 32667                                  
 32668                                  	; If al=5 (ExecReady) we'll change the return address on the stack	
 32669                                  	; to be LeaveDos in msdisp.asm. This ensures that the EXECA20OFF
 32670                                  	; bit set in DOS_FLAG by ExceReady is not cleared in msdisp.asm
 32671                                  
 32672 00005B7D 3C05                    	cmp	al,5			; Q: is this ExecReady call
 32673                                  	;jne	short @f
 32674 00005B7F 7505                    	jne	short Exec_@f		; N: continue
 32675                                  					; Y: change ret addr. to LeaveDos.
 32676 00005B81 59                      	pop	cx			; Note CX is not input to ExecReady
 32677 00005B82 B9[0404]                	mov	cx,LeaveDOS
 32678 00005B85 51                      	push	cx
 32679                                  ;@@:
 32680                                  Exec_@f:
 32681                                  	; M068 - End
 32682                                  	
 32683                                  	;Enter
 32684                                  
 32685 00005B86 55                      	push	bp
 32686 00005B87 89E5                    	mov	bp,sp
 32687                                  	;;sub	sp,26	; MSDOS 3.3
 32688                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)	
 32689                                  	;sub	sp,29	; MSDOS 6.0 (& MSDOS 6.21)
 32690                                  	; 17/12/2022
 32691                                  	; 20/05/2019
 32692 00005B89 83EC1E                  	sub	sp,30	; Retro DOS v4.0	
 32693                                  
 32694                                  	; MSDOS 6.0
 32695 00005B8C 3C05                    	cmp	AL,5			; only 0, 1, 3 or 5 are allowed ;M028
 32696                                  					; M030
 32697 00005B8E 7614                    	jna	short Exec_Check_2
 32698                                  
 32699                                  	; MSDOS 3.3
 32700                                  	;cmp	AL,3
 32701                                  	;jna	short Exec_Check_2
 32702                                  
 32703                                  Exec_Bad_Fun:
 32704 00005B90 36C606[2303]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; 1
 32705                                  					; Extended Error Locus	;smr;SS Override
 32706                                  	;mov	al,1
 32707 00005B96 B001                    	mov	al,error_invalid_function
 32708                                  
 32709                                  Exec_Ret_Err:
 32710                                  	;Leave
 32711 00005B98 89EC                    	mov	sp,bp
 32712 00005B9A 5D                      	pop	bp
 32713                                  	;transfer SYS_RET_ERR
 32714 00005B9B E9A2AA                  	jmp	SYS_RET_ERR
 32715                                  
 32716                                  	; MSDOS 6.0
 32717                                  ExecReadyJ:
 32718 00005B9E E8FD17                  	call	ExecReady		; M028
 32719 00005BA1 E90504                  	jmp	norm_ovl		; do a Leave & xfer sysret_OK ; M028
 32720                                  
 32721                                  Exec_Check_2:
 32722 00005BA4 3C02                    	cmp	AL,2			
 32723 00005BA6 74E8                    	je	short Exec_Bad_Fun
 32724                                  
 32725                                  	; MSDOS 6.0
 32726 00005BA8 3C04                    	cmp	al,4			; 2 & 4 are not allowed
 32727 00005BAA 74E4                    	je	short Exec_Bad_Fun
 32728                                  	
 32729 00005BAC 3C05                    	cmp	al,5			; M028 ; M030
 32730 00005BAE 74EE                    	je	short ExecReadyJ	; M028
 32731                                  
 32732                                  	;mov	[bp-4],bx
 32733 00005BB0 895EFC                  	mov	Exec_BlkL,BX		; stash args
 32734                                  	;mov	[bp-2],es
 32735 00005BB3 8C46FE                  	mov	Exec_BlkH,ES
 32736                                  	;mov	[bp-5],al
 32737 00005BB6 8846FB                  	mov	Exec_Func,AL
 32738                                  	;mov	byte [bp-6],0
 32739 00005BB9 C646FA00                	mov	Exec_Load_High,0
 32740                                  
 32741                                  	;mov	[bp-26],dx
 32742 00005BBD 8956E6                  	mov	ExecNameL,DX		; set up length of exec name
 32743                                  	;mov	[bp-24],ds
 32744 00005BC0 8C5EE8                  	mov	ExecNameH,DS
 32745 00005BC3 89D6                    	mov	SI,DX			; move pointer to convenient place
 32746                                  	;invoke	DStrLen
 32747 00005BC5 E831B6                  	call	DStrLen
 32748                                  	;mov	[bp-22],cx
 32749 00005BC8 894EEA                  	mov	ExecNameLen,CX		; save length
 32750                                  
 32751                                  	; MSDOS 6.0
 32752 00005BCB 36A0[0203]              	mov	al,[ss:AllocMethod]	; M063: save alloc method in 
 32753 00005BCF 36A2[8400]              	mov	[ss:ALLOCMSAVE],al	; M063: AllocMsave
 32754                                  
 32755 00005BD3 30C0                    	xor	AL,AL			; open for reading
 32756 00005BD5 55                      	push	BP
 32757                                  
 32758                                  	; MSDOS 6.0
 32759                                  	;or	byte [ss:DOS_FLAG],1
 32760 00005BD6 36800E[8600]01          	or	byte [ss:DOS_FLAG],EXECOPEN ; this flag is set to indicate to 
 32761                                  					; the redir that this open call is
 32762                                  					; due to an exec.
 32763                                  
 32764                                  	;invoke	$OPEN			; is the file there?
 32765 00005BDC E80513                  	call	_$OPEN
 32766                                  
 32767                                  	; MSDOS 6.0
 32768 00005BDF 9C                      	pushf
 32769                                  	; 02/06/2019
 32770                                  	;and	byte [ss:DOS_FLAG],0FEh
 32771 00005BE0 368026[8600]FE          	and	byte [ss:DOS_FLAG],~EXECOPEN ; reset flag
 32772 00005BE6 9D                      	popf
 32773                                  
 32774 00005BE7 5D                      	pop	BP
 32775                                  
 32776                                  	; MSDOS 3.3 & MSDOS 6.0
 32777 00005BE8 72AE                    	jc	short Exec_Ret_Err
 32778                                  
 32779                                  	;mov	[bp-8],ax
 32780 00005BEA 8946F8                  	mov	Exec_FH,AX
 32781 00005BED 89C3                    	mov	BX,AX
 32782 00005BEF 30C0                    	xor	AL,AL
 32783                                  	;invoke	$Ioctl
 32784 00005BF1 E88CC6                  	call	_$IOCTL
 32785 00005BF4 7207                    	jc	short Exec_BombJ
 32786                                  
 32787                                  	;test	dl,80h
 32788 00005BF6 F6C280                  	test	DL,devid_ISDEV
 32789 00005BF9 740A                    	jz	short Exec_Check_Environ
 32790                                  
 32791                                  	;mov	al,2
 32792 00005BFB B002                    	mov	AL,error_file_not_found
 32793                                  Exec_BombJ:
 32794 00005BFD E9CA00                  	jmp	Exec_Bomb
 32795                                  
 32796                                  BadEnv:
 32797                                  	;mov	al,0Ah
 32798 00005C00 B00A                    	mov	AL,error_bad_environment
 32799 00005C02 E9C500                  	jmp	Exec_Bomb
 32800                                  
 32801                                  Exec_Check_Environ:
 32802                                  	;mov	word [bp-18],0
 32803 00005C05 C746EE0000              	mov	Exec_Load_Block,0
 32804                                  	;mov	word [bp-14],0
 32805 00005C0A C746F20000              	mov	Exec_Environ,0
 32806                                  					; overlays... no environment
 32807                                  	;test	byte [bp-5],2
 32808 00005C0F F646FB02                	test	Exec_Func,exec_func_overlay
 32809 00005C13 7552                    	jnz	short Exec_Read_Header
 32810                                  
 32811                                  	;lds	si,[bp-4]
 32812 00005C15 C576FC                  	lds	SI,Exec_Blk		; get block
 32813 00005C18 8B04                    	mov	ax,[SI]
 32814                                  	;mov	AX,[SI+EXEC1.ENVIRON]	; address of environ
 32815 00005C1A 09C0                    	or	AX,AX
 32816 00005C1C 750C                    	jnz	short Exec_Scan_Env
 32817                                  
 32818 00005C1E 368E1E[3003]            	mov	DS,[SS:CurrentPDB]	;smr;SS Override
 32819                                  	;mov	ax,[44]
 32820 00005C23 A12C00                  	mov	AX,[PDB.ENVIRON]
 32821                                  
 32822                                  ; MSDOS 6.0
 32823                                  ;---------------------------------------------BUG 92 4/30/90-----------------
 32824                                  ;
 32825                                  ; Exec_environ is being correctly initialized after the environment has been
 32826                                  ; allocated and copied form the parent's env. It must not be initialized here.
 32827                                  ; Because if the call to $alloc below fails Exec_dealloc will deallocate the
 32828                                  ; parent's environment.
 32829                                  ;	mov	Exec_Environ,AX
 32830                                  ;
 32831                                  ;----------------------------------------------------------------------------
 32832                                  
 32833                                  	;mov	[bp-14],ax
 32834                                  	;mov	Exec_Environ,ax
 32835                                  
 32836 00005C26 09C0                    	or	AX,AX
 32837 00005C28 743D                    	jz	short Exec_Read_Header
 32838                                  
 32839                                  Exec_Scan_Env:
 32840 00005C2A 8EC0                    	mov	ES,AX
 32841 00005C2C 31FF                    	xor	DI,DI
 32842                                  	;mov	cx,7FFFh ; MSDOS 3.3
 32843 00005C2E B90080                  	mov	CX,8000h ; MSDOS 6.0	; at most 32k of environment ;M040
 32844 00005C31 30C0                    	xor	AL,AL
 32845                                  
 32846                                  Exec_Get_Environ_Len:
 32847 00005C33 F2AE                    	repnz	scasb			; find that nul byte
 32848 00005C35 75C9                    	jnz	short BadEnv
 32849                                  
 32850 00005C37 49                      	dec	CX			; Dec CX for the next nul byte test
 32851 00005C38 78C6                    	js	short BadEnv		; gone beyond the end of the environment
 32852                                  
 32853 00005C3A AE                      	scasb				; is there another nul byte?
 32854 00005C3B 75F6                    	jnz	short Exec_Get_Environ_Len ; no, scan some more
 32855                                  
 32856 00005C3D 57                      	push	DI
 32857                                  	;lea	bx,[DI+11h]
 32858 00005C3E 8D5D11                  	lea	BX,[DI+0Fh+2]
 32859                                  	;add	bx,[bp-22]
 32860 00005C41 035EEA                  	add	BX,ExecNameLen		; BX <- length of environment
 32861                                  					; remember argv[0] length
 32862                                  					; round up and remember argc
 32863 00005C44 B104                    	mov	CL,4
 32864 00005C46 D3EB                    	shr	BX,CL			; number of paragraphs needed
 32865 00005C48 06                      	push	ES
 32866                                  	;invoke	$Alloc			; can we get the space?
 32867 00005C49 E84406                  	call	_$ALLOC
 32868 00005C4C 1F                      	pop	DS
 32869 00005C4D 59                      	pop	CX
 32870                                  
 32871                                  	;jnc	short Exec_Save_Environ
 32872                                  	;jmp	SHORT Exec_No_Mem	; nope... cry and sob
 32873                                  	; 17/12/2022
 32874 00005C4E 7274                    	jc	short Exec_No_Mem ; 02/06/2019
 32875                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 32876                                  	;jnc	short Exec_Save_Environ
 32877                                  	;jmp	SHORT Exec_No_Mem
 32878                                  
 32879                                  Exec_Save_Environ:
 32880 00005C50 8EC0                    	mov	ES,AX
 32881                                  	;mov	[bp-14],ax
 32882 00005C52 8946F2                  	mov	Exec_Environ,AX 	; save him for a rainy day
 32883 00005C55 31F6                    	xor	SI,SI
 32884 00005C57 89F7                    	mov	DI,SI
 32885 00005C59 F3A4                    	rep	movsb			; copy the environment
 32886 00005C5B B80100                  	mov	AX,1
 32887 00005C5E AB                      	stosw
 32888                                  	;lds	si,[bp-26]
 32889 00005C5F C576E6                  	lds	SI,ExecName
 32890                                  	;mov	cx,[bp-22]
 32891 00005C62 8B4EEA                  	mov	CX,ExecNameLen
 32892 00005C65 F3A4                    	rep	movsb
 32893                                  
 32894                                  Exec_Read_Header:
 32895                                  	; We read in the program header into the above data area and
 32896                                  	; determine where in this memory the image will be located.
 32897                                  
 32898                                  	;Context DS
 32899 00005C67 16                      	push	ss
 32900 00005C68 1F                      	pop	ds
 32901                                  	;mov	cx,26
 32902 00005C69 B91A00                  	mov	CX,exec_header_len	; header size
 32903 00005C6C BA[C80F]                	mov	DX,exec_signature
 32904 00005C6F 06                      	push	ES
 32905 00005C70 1E                      	push	DS
 32906 00005C71 E88304                  	call	ExecRead
 32907 00005C74 1F                      	pop	DS
 32908 00005C75 07                      	pop	ES
 32909 00005C76 7250                    	jc	short Exec_Bad_File
 32910                                  
 32911 00005C78 09C0                    	or	AX,AX
 32912 00005C7A 744C                    	jz	short Exec_Bad_File
 32913                                  	;cmp	ax,26
 32914 00005C7C 83F81A                  	cmp	AX,exec_header_len	; did we read the right number?
 32915 00005C7F 7519                    	jnz	short Exec_Com_Filej	; yep... continue
 32916                                  
 32917 00005C81 F706[D40F]FFFF          	test	word [exec_max_BSS],-1 	; indicate load high?
 32918 00005C87 7504                    	jnz	short Exec_Check_Sig
 32919                                  
 32920                                  	;mov	byte [bp-6],0FFh
 32921 00005C89 C646FAFF                	mov	Exec_Load_High,-1
 32922                                  
 32923                                  Exec_Check_Sig:
 32924 00005C8D A1[C80F]                	mov	AX,[exec_signature]	; rms;NSS
 32925                                  	;cmp	ax,5A4Dh ; 'MZ'
 32926 00005C90 3D4D5A                  	cmp	AX,exe_valid_signature	; zibo arises!
 32927 00005C93 7408                    	jz	short Exec_Save_Start 	; assume com file if no signature
 32928                                  
 32929                                  	;cmp	ax,4D5Ah ; 'ZM'
 32930 00005C95 3D5A4D                  	cmp	AX,exe_valid_old_signature  ; zibo arises!
 32931 00005C98 7403                    	jz	short Exec_Save_Start 	; assume com file if no signature
 32932                                  
 32933                                  Exec_Com_Filej:
 32934 00005C9A E9E901                  	jmp	Exec_Com_File
 32935                                  
 32936                                  	; We have the program header... determine memory requirements
 32937                                  
 32938                                  Exec_Save_Start:
 32939 00005C9D A1[CC0F]                	mov	AX,[exec_pages]		; get 512-byte pages	;rms;NSS
 32940 00005CA0 B105                    	mov	CL,5			; convert to paragraphs
 32941 00005CA2 D3E0                    	shl	AX,CL
 32942 00005CA4 2B06[D00F]              	sub	AX,[exec_par_dir] 	; AX = size in paragraphs ;rms;NSS
 32943                                  	;mov	[bp-12],ax
 32944 00005CA8 8946F4                  	mov	Exec_Res_Len_Para,AX
 32945                                  
 32946                                  		; Do we need to allocate memory?
 32947                                  		; Yes if function is not load-overlay
 32948                                  
 32949                                  	;test	byte [bp-5],2
 32950 00005CAB F646FB02                	test	Exec_Func,exec_func_overlay
 32951 00005CAF 7445                    	jz	short Exec_Allocate	; allocation of space
 32952                                  
 32953                                  		; get load address from block
 32954                                  
 32955                                  	;les	di,[bp-4]
 32956 00005CB1 C47EFC                  	les	DI,Exec_Blk
 32957 00005CB4 268B05                  	mov	ax,[es:di]
 32958                                  	;mov	AX,[ES:DI+EXEC3.load_addr]
 32959                                  	;mov	[bp-20],ax
 32960 00005CB7 8946EC                  	mov	Exec_DMA,AX
 32961                                  
 32962                                  	; 17/12/2022
 32963                                  	;;mov	ax,[es:di+2]
 32964                                  	;mov	AX,[ES:DI+EXEC3.reloc_fac]
 32965                                  	;;mov	[bp-10],ax
 32966                                  	;mov	Exec_Rel_Fac,AX
 32967                                  
 32968                                  	; 17/12/2022
 32969                                  	; 30/11/2022 (!most proper code!)
 32970                                  	;mov	dx,[es:di+2]
 32971 00005CBA 268B5502                	mov	dx,[ES:DI+EXEC3.reloc_fac]
 32972                                  	;mov	[bp-10],dx
 32973 00005CBE 8956F6                  	mov	Exec_Rel_Fac,dx
 32974                                  	; ax = Exec_DMA
 32975 00005CC1 E9DE00                  	jmp	Exec_Find_Res
 32976                                  
 32977                                  ; 17/12/2022
 32978                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 32979                                  ; 27/09/2023
 32980                                  %if 0
 32981                                  	; 02/06/2019 - Retro DOS v4.0
 32982                                  	;mov	ax,[bp-20]  ; *+*
 32983                                  	mov	AX,Exec_DMA ; *+*
 32984                                  	; 10/08/2018
 32985                                  	jmp	Exec_Find_Res		; M000
 32986                                  %endif
 32987                                  
 32988                                  Exec_No_Mem:
 32989                                  	;mov	al,8
 32990 00005CC4 B008                    	mov	AL,error_not_enough_memory
 32991 00005CC6 EB02                    	jmp	short Exec_Bomb
 32992                                  
 32993                                  Exec_Bad_File:
 32994                                  	;mov	al,0Bh
 32995 00005CC8 B00B                    	mov	AL,error_bad_format
 32996                                  
 32997                                  Exec_Bomb:
 32998                                  	;mov	bx,[bp-8]
 32999 00005CCA 8B5EF8                  	mov	BX,Exec_FH
 33000 00005CCD E84004                  	call	Exec_Dealloc
 33001                                  	;LeaveCrit CritMem
 33002 00005CD0 E855B6                  	call	LCritMEM
 33003                                  	;save	<AX,BP>
 33004 00005CD3 50                      	push	ax
 33005 00005CD4 55                      	push	bp
 33006                                  	;invoke	$CLOSE
 33007 00005CD5 E83D0A                  	call	_$CLOSE
 33008                                  	;restore <BP,AX>
 33009 00005CD8 5D                      	pop	bp
 33010 00005CD9 58                      	pop	ax
 33011 00005CDA E9BBFE                  	jmp	Exec_Ret_Err
 33012                                  
 33013                                  Exec_Chk_Mem: 
 33014                                  
 33015                                  	; 24/09/2023
 33016                                  	; ds = DOSDATA
 33017                                  ; 17/12/2022
 33018                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 33019                                  ;%if 0
 33020                                  	; MSDOS 6.0    			; M063 - Start
 33021                                  	;mov	al,[ss:AllocMethod]	; save current alloc method in ax
 33022                                  	; 10/06/2019
 33023 00005CDD A0[0203]                	mov	al,[AllocMethod]
 33024                                  	;mov	bl,[ss:ALLOCMSAVE]
 33025 00005CE0 8A1E[8400]              	mov	bl,[ALLOCMSAVE]
 33026                                  	;mov	[ss:AllocMethod],bl	; restore original allocmethod
 33027 00005CE4 881E[0203]              	mov	[AllocMethod],bl
 33028                                  	
 33029 00005CE8 F6C340                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 33030 00005CEB 75D7                    	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 33031                                  	;				; N: continue
 33032                                  	;
 33033 00005CED A840                    	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 33034 00005CEF 74D3                    	jz	short Exec_No_Mem	; N: no memory 
 33035                                  	; 02/06/2019
 33036                                  	;mov	ax,[ss:SAVE_AX]		; Y: restore ax and
 33037 00005CF1 A1[8A00]                	mov	ax,[SAVE_AX]
 33038                                  	;jmp	short Exec_Norm_Alloc	;    Try again
 33039                                  					; M063 - End
 33040 00005CF4 EB2B                    	jmp	short Exec_Norm_Alloc1
 33041                                  ;%endif
 33042                                  
 33043                                  ; 17/12/2022
 33044                                  %if 0
 33045                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 33046                                  	; MSDOS 6.0    			; M063 - Start
 33047                                  	mov	al,[ss:AllocMethod]	; save current alloc method in ax
 33048                                  	mov	bl,[ss:ALLOCMSAVE]
 33049                                  	mov	[ss:AllocMethod],bl	; restore original allocmethod
 33050                                  
 33051                                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 33052                                  	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 33053                                  	;				; N: continue
 33054                                  	;
 33055                                  	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 33056                                  	jz	short Exec_No_Mem	; N: no memory 
 33057                                  
 33058                                  	mov	ax,[ss:SAVE_AX]		; Y: restore ax and
 33059                                  	jmp	short Exec_Norm_Alloc	;    Try again
 33060                                  					; M063 - End
 33061                                  %endif
 33062                                  
 33063                                  Exec_Allocate:
 33064                                  	; 09/09/2018
 33065                                  
 33066                                  	; M005 - START
 33067                                  	; If there is no STACK segment for this exe file and if this
 33068                                  	; not an overlay and the resident size is less than 64K - 
 33069                                  	; 256 bytes we shall add 256 bytes to the programs 
 33070                                  	; resident memory requirement and set Exec_SP to this value.
 33071                                  	
 33072                                  	; 17/12/2022
 33073 00005CF6 29DB                    	sub	bx,bx ; 0	
 33074                                  
 33075                                  	; MSDOS 6.0
 33076                                  	;;mov	byte [bp-29],0
 33077                                  	;mov	Exec_NoStack,0
 33078                                  	; 17/12/2022
 33079 00005CF8 885EE3                  	mov	Exec_NoStack,bl ; 0
 33080 00005CFB 391E[D60F]              	cmp	[exec_SS],bx ; 0
 33081                                  	;cmp	word [exec_SS],0	; Q: is there a stack seg
 33082 00005CFF 7511                    	jne	short ea1		; Y: continue normal processing
 33083 00005D01 391E[D80F]              	cmp	[exec_SP],bx ; 0
 33084                                  	;cmp	word [exec_SP],0	; Q: is there a stack ptr
 33085 00005D05 750B                    	jne	short ea1		; Y: continue normal processing
 33086                                  
 33087                                  	;inc	byte [bp-29]
 33088 00005D07 FE46E3                  	inc	Exec_NoStack
 33089 00005D0A 3DF00F                  	cmp	ax,1000h-10h		; Q: is this >= 64K-256 bytes
 33090 00005D0D 7303                    	jae	short ea1		; Y: don't set Exec_SP
 33091                                  
 33092 00005D0F 83C010                  	add	ax,10h			; add 10h paras to mem requirement
 33093                                  ea1:
 33094                                  	; M005 - END
 33095                                  
 33096                                  	; MSDOS 6.0			; M000 - start
 33097                                  	; 20/05/2019
 33098                                  	; (ds = ss = DOSDATA)
 33099 00005D12 F606[0203]80            	test	byte [AllocMethod],HIGH_FIRST ; 80h
 33100                                  					; Q: is the alloc strat high_first
 33101 00005D17 7405                    	jz	short Exec_Norm_Alloc	; N: normal allocate
 33102                                  					; Y: set high_only bit
 33103 00005D19 800E[0203]40            	or	byte [AllocMethod],HIGH_ONLY ; 40h
 33104                                  					; M000 - end
 33105                                  Exec_Norm_Alloc:
 33106 00005D1E A3[8A00]                	mov	[SAVE_AX],ax		; M000: save ax for possible 2nd  
 33107                                  Exec_Norm_Alloc1:	; 02/06/2019
 33108                                  					; M000: attempt at allocating memory
 33109                                  	; MSDOS 3.3
 33110                                  	;push	ax			; M000
 33111                                  
 33112 00005D21 BBFFFF                  	mov	BX,0FFFFh		; see how much room in arena
 33113 00005D24 1E                      	push	DS
 33114                                  	;invoke	$Alloc			; should have carry set and BX has max
 33115 00005D25 E86805                  	call	_$ALLOC
 33116 00005D28 1F                      	pop	DS
 33117                                  
 33118                                  	; MSDOS 6.0
 33119 00005D29 A1[8A00]                	mov	AX,[SAVE_AX]		; M000
 33120                                  	; MSDOS 3.3
 33121                                  	;pop	ax			; M000
 33122                                  
 33123 00005D2C 83C010                  	add	AX,10h			; room for header
 33124 00005D2F 83FB11                  	cmp	BX,11h			; enough room for a header
 33125                                  	; MSDOS 6.0
 33126 00005D32 72A9                    	jb	short Exec_Chk_Mem	; M000
 33127                                  	; MSDOS 3.3	
 33128                                  	;jb	short Exec_No_Mem
 33129                                  
 33130 00005D34 39D8                    	cmp	AX,BX			; is there enough for bare image?
 33131                                  	; MSDOS 6.0
 33132 00005D36 77A5                    	ja	short Exec_Chk_Mem	; M000
 33133                                  	; MSDOS 3.3
 33134                                  	;ja	short Exec_No_Mem
 33135                                  
 33136                                  	;test	byte [bp-6],0FFh
 33137 00005D38 F646FAFF                	test	Exec_Load_High,-1	; if load high, use max
 33138 00005D3C 7518                    	jnz	short Exec_BX_Max	; use max
 33139                                  
 33140                                  	; 09/09/2018
 33141                                  
 33142 00005D3E 0306[D20F]              	add	AX,[exec_min_BSS] 	; go for min allocation;rms;NSS
 33143                                  	; MSDOS 6.0
 33144 00005D42 7299                    	jc	short Exec_Chk_Mem		; M000
 33145                                  	; MSDOS 3.3
 33146                                  	;jc	short Exec_No_Mem
 33147                                  
 33148 00005D44 39D8                    	cmp	AX,BX			; enough space?
 33149                                  	; MSDOS 6.0
 33150 00005D46 7795                    	ja	short Exec_Chk_Mem	; M000: nope...	
 33151                                  	; MSDOS 3.3
 33152                                  	;ja	short Exec_No_Mem
 33153                                  
 33154 00005D48 2B06[D20F]              	sub	AX,[exec_min_BSS] 	; rms;NSS
 33155 00005D4C 0306[D40F]              	add	AX,[exec_max_BSS] 	; go for the MAX
 33156 00005D50 7204                    	jc	short Exec_BX_Max
 33157                                  
 33158 00005D52 39D8                    	cmp	AX,BX
 33159 00005D54 7602                    	jbe	short Exec_Got_Block
 33160                                  
 33161                                  Exec_BX_Max:
 33162 00005D56 89D8                    	mov	AX,BX
 33163                                  
 33164                                  Exec_Got_Block:
 33165                                  	; 03/08/2018 - Retro DOS v3.0
 33166                                  
 33167 00005D58 1E                      	push	DS
 33168 00005D59 89C3                    	mov	BX,AX
 33169                                  	;mov	[bp-16],bx
 33170 00005D5B 895EF0                  	mov	Exec_Size,BX
 33171                                  	;invoke	$Alloc			; get the space
 33172 00005D5E E82F05                  	call	_$ALLOC
 33173 00005D61 1F                      	pop	DS
 33174                                  	; MSDOS 6.0
 33175                                  	;jc	short Exec_Chk_Mem	; M000
 33176                                  	; MSDOS 3.3
 33177                                  	;;jc	short Exec_No_Mem
 33178                                  	; 20/05/2019
 33179 00005D62 7303                    	jnc	short ea0
 33180 00005D64 E976FF                  	jmp	Exec_Chk_Mem
 33181                                  ea0:
 33182                                  	; MSDOS 6.0
 33183 00005D67 8A0E[8400]              	mov	cl,[ALLOCMSAVE]		; M063: 
 33184 00005D6B 880E[0203]              	mov	[AllocMethod],cl	; M063: restore allocmethod
 33185                                  
 33186                                  ;M029; Begin changes
 33187                                  ; This code does special handling for programs with no stack segment. If so,
 33188                                  ;check if the current block is larger than 64K. If so, we do not modify
 33189                                  ;Exec_SP. If smaller than 64K, we make Exec_SP = top of block. In either
 33190                                  ;case Exec_SS is not changed.
 33191                                  
 33192                                  	; MSDOS 6.0
 33193                                  	;cmp	byte [bp-29],0
 33194 00005D6F 807EE300                	cmp	Exec_NoStack,0
 33195                                  	;je	@f
 33196 00005D73 7412                    	je	short ea2
 33197                                  
 33198 00005D75 81FB0010                	cmp	bx,1000h		; Q: >= 64K memory block
 33199                                  	;jae	@f			; Y: Exec_SP = 0
 33200 00005D79 730C                    	jae	short ea2
 33201                                  
 33202                                  ;Make Exec_SP point at the top of the memory block
 33203                                  
 33204 00005D7B B104                    	mov	cl,4
 33205 00005D7D D3E3                    	shl	bx,cl			; get byte offset
 33206 00005D7F 81EB0001                	sub	bx,100h			; take care of PSP
 33207 00005D83 891E[D80F]              	mov	[exec_SP],bx		; Exec_SP = top of block
 33208                                  ea2:
 33209                                  ;@@:
 33210                                  ;M029; end changes
 33211                                  
 33212                                  	;mov	[bp-18],ax
 33213 00005D87 8946EE                  	mov	Exec_Load_Block,AX
 33214 00005D8A 83C010                  	add	AX,10h
 33215                                  	;test	byte [bp-6],0FFh
 33216 00005D8D F646FAFF                	test	Exec_Load_High,-1
 33217 00005D91 7409                    	jz	short Exec_Use_AX	; use ax for load info
 33218                                  
 33219                                  	;add	ax,[bp-16]
 33220 00005D93 0346F0                  	add	AX,Exec_Size		; go to end
 33221                                  	;sub	ax,[bp-12]
 33222 00005D96 2B46F4                  	sub	AX,Exec_Res_Len_Para	; drop off header
 33223 00005D99 83E810                  	sub	AX,10h			; drop off pdb
 33224                                  
 33225                                  Exec_Use_AX:
 33226                                  	;mov	[bp-10],ax
 33227 00005D9C 8946F6                  	mov	Exec_Rel_Fac,AX 	; new segment
 33228                                  	;mov	[bp-20],ax
 33229 00005D9F 8946EC                  	mov	Exec_DMA,AX ; *+*	; beginning of dma
 33230                                  
 33231                                  	; Determine the location in the file of the beginning of
 33232                                  	; the resident
 33233                                  
 33234                                  ; 17/12/2022
 33235                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 33236                                  ;%if 0
 33237                                  
 33238                                  Exec_Find_Res:
 33239                                  	; MSDOS 6.0
 33240                                  	;;mov	dx,[bp-20]
 33241                                  	;mov	DX,Exec_DMA ; *+*
 33242                                  	;;mov	[bp-28],dx
 33243                                  	;mov	Exec_DMA_Save,DX
 33244                                  
 33245                                  	; 17/12/2022
 33246                                  	; AX = Exec_DMA
 33247                                  
 33248                                  	; 02/06/2019 - Retro DOS v4.0
 33249                                  	;mov	[bp-28],ax ; *+*
 33250 00005DA2 8946E4                  	mov	Exec_DMA_Save,AX ; *+*
 33251                                  
 33252                                  ;%endif
 33253                                  
 33254                                  ; 17/12/2022
 33255                                  %if 0
 33256                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 33257                                  Exec_Find_Res:
 33258                                  	;mov	dx,[bp-20]
 33259                                  	mov	DX,Exec_DMA ; *+*
 33260                                  	;mov	[bp-28],dx
 33261                                  	mov	Exec_DMA_Save,DX
 33262                                  %endif
 33263                                  
 33264                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33265 00005DA5 8B16[D00F]              	mov	DX,[exec_par_dir]
 33266 00005DA9 52                      	push	DX
 33267 00005DAA B104                    	mov	CL,4
 33268 00005DAC D3E2                    	shl	DX,CL			; low word of location
 33269 00005DAE 58                      	pop	AX
 33270 00005DAF B10C                    	mov	CL,12
 33271 00005DB1 D3E8                    	shr	AX,CL			; high word of location
 33272 00005DB3 89C1                    	mov	CX,AX			; CX <- high
 33273                                  
 33274                                  		; Read in the resident image (first, seek to it)
 33275                                  	;mov	bx,[bp-8]
 33276 00005DB5 8B5EF8                  	mov	BX,Exec_FH
 33277 00005DB8 1E                      	push	DS
 33278 00005DB9 30C0                    	xor	AL,AL
 33279                                  	;invoke	$Lseek			; Seek to resident
 33280 00005DBB E8D30A                  	call	_$LSEEK
 33281 00005DBE 1F                      	pop	DS
 33282 00005DBF 7303                    	jnc	short Exec_Big_Read
 33283                                  
 33284 00005DC1 E906FF                  	jmp	Exec_Bomb
 33285                                  
 33286                                  Exec_Big_Read:				; Read resident into memory
 33287                                  	;mov	bx,[bp-12]
 33288 00005DC4 8B5EF4                  	mov	BX,Exec_Res_Len_Para
 33289 00005DC7 81FB0010                	cmp	BX,1000h		; Too many bytes to read?
 33290 00005DCB 7203                    	jb	short Exec_Read_OK
 33291                                  
 33292 00005DCD BBE00F                  	mov	BX,0FE0h		; Max in one chunk FE00 bytes
 33293                                  
 33294                                  Exec_Read_OK:
 33295                                  	;sub	[bp-12],bx
 33296 00005DD0 295EF4                  	sub	Exec_Res_Len_Para,BX	; We read (soon) this many
 33297 00005DD3 53                      	push	BX
 33298 00005DD4 B104                    	mov	CL,4
 33299 00005DD6 D3E3                    	shl	BX,CL			; Get count in bytes from paras
 33300 00005DD8 89D9                    	mov	CX,BX			; Count in correct register
 33301 00005DDA 1E                      	push	DS
 33302                                  	;mov	ds,[bp-20]
 33303 00005DDB 8E5EEC                  	mov	DS,Exec_DMA		; Set up read buffer
 33304                                  
 33305 00005DDE 31D2                    	xor	DX,DX
 33306 00005DE0 51                      	push	CX			; Save our count
 33307 00005DE1 E81303                  	call	ExecRead
 33308 00005DE4 59                      	pop	CX			; Get old count to verify
 33309 00005DE5 1F                      	pop	DS
 33310 00005DE6 7248                    	jc	short Exec_Bad_FileJ
 33311                                  
 33312 00005DE8 39C1                    	cmp	CX,AX			; Did we read enough?
 33313 00005DEA 5B                      	pop	BX			; Get paragraph count back
 33314 00005DEB 7408                    	jz	short ExecCheckEnd	; and do reloc if no more to read
 33315                                  
 33316                                  	; The read did not match the request. If we are off by 512
 33317                                  	; bytes or more then the header lied and we have an error.
 33318                                  
 33319 00005DED 29C1                    	sub	CX,AX
 33320 00005DEF 81F90002                	cmp	CX,512
 33321 00005DF3 733B                    	jae	short Exec_Bad_FileJ
 33322                                  
 33323                                  	; We've read in CX bytes... bump DTA location
 33324                                  
 33325                                  ExecCheckEnd:
 33326                                  	;add	[bp-20],bx
 33327 00005DF5 015EEC                  	add	Exec_DMA,BX		; Bump dma address
 33328                                  	;test	word [bp-12],0FFFFh
 33329 00005DF8 F746F4FFFF              	test	Exec_Res_Len_Para,-1
 33330 00005DFD 75C5                    	jnz	short Exec_Big_Read
 33331                                  
 33332                                  	; The image has now been read in. We must perform relocation
 33333                                  	; to the current location.
 33334                                  
 33335                                  exec_do_reloc:
 33336                                  	;mov	cx,[bp-10]
 33337 00005DFF 8B4EF6                  	mov	CX,Exec_Rel_Fac
 33338 00005E02 A1[D60F]                	mov	AX,[exec_SS]		; get initial SS ;rms;NSS
 33339 00005E05 01C8                    	add	AX,CX			; and relocate him
 33340 00005E07 A3[C20F]                	mov	[exec_init_SS],AX 	; rms;NSS
 33341                                  
 33342 00005E0A A1[D80F]                	mov	AX,[exec_SP]		; initial SP ;rms;NSS
 33343 00005E0D A3[C00F]                	mov	[exec_init_SP],AX 	; rms;NSS
 33344                                  
 33345 00005E10 C406[DC0F]              	les	AX,[exec_IP]		; rms;NSS
 33346 00005E14 A3[C40F]                	mov	[exec_init_IP],AX 	; rms;NSS
 33347 00005E17 8CC0                    	mov	AX,ES			; rms;NSS
 33348 00005E19 01C8                    	add	AX,CX			; relocated...
 33349 00005E1B A3[C60F]                	mov	[exec_init_CS],AX 	; rms;NSS
 33350                                  
 33351 00005E1E 31C9                    	xor	CX,CX
 33352 00005E20 8B16[E00F]              	mov	DX,[exec_rle_table]	; rms;NSS
 33353                                  	;mov	bx,[bp-8]
 33354 00005E24 8B5EF8                  	mov	BX,Exec_FH
 33355 00005E27 1E                      	push	DS
 33356 00005E28 31C0                    	xor	AX,AX
 33357                                  	;invoke	$Lseek
 33358 00005E2A E8640A                  	call	_$LSEEK
 33359 00005E2D 1F                      	pop	DS
 33360 00005E2E 7303                    	jnc	short exec_get_entries
 33361                                  
 33362                                  Exec_Bad_FileJ:
 33363 00005E30 E995FE                  	jmp	Exec_Bad_File
 33364                                  
 33365                                  exec_get_entries:
 33366 00005E33 8B16[CE0F]              	mov	DX,[exec_rle_count]	; Number of entries left ;rms;NSS
 33367                                  
 33368                                  exec_read_reloc:
 33369 00005E37 52                      	push	DX
 33370                                  	;mov	dx,OPENBUF
 33371 00005E38 BA[BE03]                	mov	DX,Exec_Internal_Buffer
 33372                                  	;;mov	cx,388 ; MSDOS 3.3 ; (390>>2)<<2
 33373                                  	;mov	cx,396 ; MSDOS 6.0
 33374 00005E3B B98C01                  	mov	CX,((Exec_Internal_Buffer_Size)/4)*4 ; (397>>2)<<2
 33375 00005E3E 1E                      	push	DS
 33376 00005E3F E8B502                  	call	ExecRead
 33377 00005E42 07                      	pop	ES
 33378 00005E43 5A                      	pop	DX
 33379 00005E44 72EA                    	jc	short Exec_Bad_FileJ
 33380                                  
 33381                                  	;;mov	cx,97 ;  MSDOS 3.3 ; (390>>2)
 33382                                  	;mov	cx,99 ;  MSDOS 6.0
 33383 00005E46 B96300                  	mov	CX,(Exec_Internal_Buffer_Size)/4 ; (397>>2)
 33384                                  					; Pointer to byte location in header
 33385                                  	;mov	di,OPENBUF
 33386 00005E49 BF[BE03]                	mov	DI,Exec_Internal_Buffer
 33387                                  	;mov	si,[bp-10]
 33388 00005E4C 8B76F6                  	mov	SI,Exec_Rel_Fac 	; Relocate a single address
 33389                                  
 33390                                  exec_reloc_one:
 33391 00005E4F 09D2                    	or	DX,DX			; Any more entries?
 33392 00005E51 7416                    	jz	short Exec_Set_PDBJ
 33393                                  
 33394                                  exec_get_addr:
 33395 00005E53 26C51D                  	lds	BX,[ES:DI]		; Get ra/sa of entry
 33396 00005E56 8CD8                    	mov	AX,DS			; Relocate address of item
 33397                                  
 33398                                  	; MSDOS 6.0
 33399                                  ;;;;;;	add	AX,SI  ; MSDOS 3.3
 33400                                  	;add	ax,[bp-28]
 33401 00005E58 0346E4                  	add	AX,Exec_DMA_Save
 33402                                  
 33403 00005E5B 8ED8                    	mov	DS,AX
 33404 00005E5D 0137                    	add	[BX],SI
 33405 00005E5F 83C704                  	add	DI,4
 33406 00005E62 4A                      	dec	DX
 33407 00005E63 E2EA                    	loop	exec_reloc_one		; End of internal buffer?
 33408                                  
 33409                                  	; We've exhausted a single buffer's worth. Read in the next
 33410                                  	; piece of the relocation table.
 33411                                  
 33412 00005E65 06                      	push	ES
 33413 00005E66 1F                      	pop	DS
 33414 00005E67 EBCE                    	jmp	short exec_read_reloc
 33415                                  
 33416                                  Exec_Set_PDBJ:
 33417                                  	; MSDOS 6.0
 33418                                  	
 33419                                  	; We now determine if this is a buggy exe packed file and if 
 33420                                  	; so we patch in the right code. Note that fixexepatch will
 33421                                  	; point to a ret if dos loads low. The load segment as 
 33422                                  	; determined above will be in exec_dma_save
 33423                                  	
 33424 00005E69 06                      	push	es
 33425 00005E6A 50                      	push	ax			; M030
 33426 00005E6B 51                      	push	cx			; M030
 33427                                  	;mov	es,[bp-28]
 33428 00005E6C 8E46E4                  	mov	es,Exec_DMA_Save
 33429 00005E6F 36A1[C60F]              	mov	ax,[ss:exec_init_CS]	; M030
 33430 00005E73 368B0E[C40F]            	mov	cx,[ss:exec_init_IP]	; M030
 33431 00005E78 36FF16[F311]            	call	word [ss:FixExePatch]
 33432                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33433                                  	; (MSDOS 5.0 MSDOS.SYS does not contain 'Rational386Patch')
 33434                                  	;call	word [ss:Rational386PatchPtr]
 33435 00005E7D 59                      	pop	cx			; M030
 33436 00005E7E 58                      	pop	ax			; M030
 33437 00005E7F 07                      	pop	es
 33438                                  
 33439 00005E80 E9DE00                  	jmp	Exec_Set_PDB
 33440                                  
 33441                                  Exec_No_Memj:
 33442 00005E83 E93EFE                  	jmp	Exec_No_Mem
 33443                                  
 33444                                  	; we have a .COM file. First, determine if we are merely
 33445                                  	; loading an overlay.
 33446                                  
 33447                                  Exec_Com_File:
 33448                                  	;test	byte [bp-5],2
 33449 00005E86 F646FB02                	test	Exec_Func,exec_func_overlay
 33450 00005E8A 742D                    	jz	short Exec_Alloc_Com_File
 33451                                  	;lds	si,[bp-4]
 33452 00005E8C C576FC                  	lds	SI,Exec_Blk		; get arg block
 33453 00005E8F AD                      	lodsw				; get load address
 33454                                  	;mov	[bp-20],ax
 33455 00005E90 8946EC                  	mov	Exec_DMA,AX
 33456 00005E93 B8FFFF                  	mov	AX,0FFFFh
 33457 00005E96 EB63                    	jmp	short Exec_Read_Block	; read it all!
 33458                                  
 33459                                  Exec_Chk_Com_Mem:			
 33460                                  	; MSDOS 6.0	     		; M063 - Start
 33461 00005E98 36A0[0203]              	mov	al,[ss:AllocMethod]	; save current alloc method in ax
 33462 00005E9C 368A1E[8400]            	mov	bl,[ss:ALLOCMSAVE]
 33463 00005EA1 36881E[0203]            	mov	[ss:AllocMethod],bl	; restore original allocmethod
 33464 00005EA6 F6C340                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 33465 00005EA9 75D8                    	jnz	short Exec_No_Memj	; Y: no space in UMBs. Quit
 33466                                  					; N: continue
 33467                                  	
 33468 00005EAB A840                    	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 33469 00005EAD 74D4                    	jz	short Exec_No_Memj	; N: no memory 
 33470                                  	
 33471                                  	;mov	ax,[bp-18]
 33472 00005EAF 8B46EE                  	mov	ax,Exec_Load_Block	; M047: ax = block we just allocated	
 33473 00005EB2 31DB                    	xor	bx,bx			; M047: bx => free arena
 33474 00005EB4 E87502                  	call	ChangeOwner		; M047: free this block
 33475                                  	
 33476 00005EB7 EB0E                    	jmp	short Exec_Norm_Com_Alloc
 33477                                  					; M063 - End
 33478                                  	
 33479                                  	; We must allocate the max possible size block (ick!)
 33480                                  	; and set up CS=DS=ES=SS=PDB pointer, IP=100, SP=max
 33481                                  	; size of block.
 33482                                  
 33483                                  Exec_Alloc_Com_File:
 33484                                  	; MSDOS 6.0			; M000 -start
 33485 00005EB9 36F606[0203]80          	test	byte [ss:AllocMethod],HIGH_FIRST ; 80h
 33486                                  					; Q: is the alloc strat high_first
 33487 00005EBF 7406                    	jz	short Exec_Norm_Com_Alloc ; N: normal allocate
 33488                                  					; Y: set high_only bit
 33489 00005EC1 36800E[0203]40          	or	byte [ss:AllocMethod],HIGH_ONLY ; 40h
 33490                                  					; M000 - end
 33491                                  Exec_Norm_Com_Alloc:			; M000
 33492                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33493 00005EC7 BBFFFF                  	mov	BX,0FFFFh
 33494                                  	;invoke	$Alloc			; largest piece available as error
 33495 00005ECA E8C303                  	call	_$ALLOC
 33496 00005ECD 09DB                    	or	BX,BX
 33497                                  	; MSDOS 6.0
 33498 00005ECF 74C7                    	jz	short Exec_Chk_Com_Mem	; M000
 33499                                  	; MSDOS 3.3
 33500                                  	;jz	short Exec_No_Memj
 33501                                  
 33502                                  	;mov	[bp-16],bx
 33503 00005ED1 895EF0                  	mov	Exec_Size,BX		; save size of allocation block
 33504 00005ED4 53                      	push	BX
 33505                                  	;invoke	$ALLOC			; largest piece available
 33506 00005ED5 E8B803                  	call	_$ALLOC
 33507 00005ED8 5B                      	pop	BX			; get size of block...
 33508                                  	;mov	[bp-18],ax
 33509 00005ED9 8946EE                  	mov	Exec_Load_Block,AX
 33510                                  
 33511 00005EDC 83C010                  	add	AX,10h			; increment for header
 33512                                  	;mov	[bp-20],ax
 33513 00005EDF 8946EC                  	mov	Exec_DMA,AX
 33514                                  
 33515 00005EE2 31C0                    	xor	AX,AX			; presume 64K read...
 33516 00005EE4 81FB0010                	cmp	BX,1000h		; 64k or more in block?
 33517 00005EE8 730E                    	jae	short Exec_Read_Com	; yes, read only 64k
 33518                                  
 33519 00005EEA 89D8                    	mov	AX,BX			; convert size to bytes
 33520 00005EEC B104                    	mov	CL,4
 33521 00005EEE D3E0                    	shl	AX,CL
 33522                                  	; 17/12/2022
 33523                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33524                                  	;			(MSDOS 5.0, MSDOS.SYS compatibility)
 33525                                  	; MSDOS 5.0
 33526                                  	;cmp	AX,100h   
 33527                                  	; 02/06/2019 - Retro DOS v4.0
 33528                                  	; MSDOS 6.0
 33529                                          ; 17/12/2022
 33530 00005EF0 3D0002                  	cmp	AX,200h                 ; enough memory for PSP and stack?
 33531 00005EF3 76A3                    	jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 33532                                  	;;jbe	short Exec_No_Memj	; M000: jump if not
 33533                                  	;; Retro DOS v3.0 modification (on MSDOS 6.0 code) -03/08/2018-
 33534                                  	;;jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 33535                                  	;jbe	short Exec_No_Memj	; M000: jump if not
 33536                                  
 33537                                  					; M047: size of the block is < 64K
 33538 00005EF5 2D0001                  	sub	ax,100h			; M047: reserve 256 bytes for stack
 33539                                  
 33540                                  Exec_Read_Com:
 33541                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33542 00005EF8 2D0001                  	sub	AX,100h 		; remember size of psp
 33543                                  Exec_Read_Block:
 33544 00005EFB 50                      	push	AX			; save number to read
 33545                                  	;mov	bx,[bp-8]
 33546 00005EFC 8B5EF8                  	mov	BX,Exec_FH		; of com file
 33547 00005EFF 31C9                    	xor	CX,CX			; but seek to 0:0
 33548 00005F01 89CA                    	mov	DX,CX
 33549 00005F03 31C0                    	xor	AX,AX			; seek relative to beginning
 33550                                  	;invoke	$Lseek			; back to beginning of file
 33551 00005F05 E88909                  	call	_$LSEEK
 33552 00005F08 59                      	pop	CX			; number to read
 33553                                  	;mov	ds,[bp-20]
 33554 00005F09 8E5EEC                  	mov	DS,Exec_DMA
 33555 00005F0C 31D2                    	xor	DX,DX
 33556 00005F0E 51                      	push	CX
 33557 00005F0F E8E501                  	call	ExecRead
 33558 00005F12 5E                      	pop	SI			; get number of bytes to read
 33559 00005F13 7303                    	jnc	short OkRead
 33560 00005F15 E9B0FD                  	jmp	Exec_Bad_File
 33561                                  
 33562                                  	; 10/09/2018
 33563                                  OkRead:
 33564 00005F18 39F0                    	cmp	AX,SI			; did we read them all?
 33565                                  	; MSDOS 6.0
 33566                                  	;jz	short Exec_Chk_Com_Mem	; M00: exactly the wrong number...no 
 33567                                  	; MSDOS 3.3
 33568                                  	;;jz	short Exec_No_Memj	; M00: exactly the wrong number...
 33569 00005F1A 7503                    	jne	short OkRead2
 33570 00005F1C E979FF                  	jmp	Exec_Chk_Com_Mem
 33571                                  OkRead2:
 33572                                  	; MSDOS 6.0
 33573 00005F1F 368A1E[8400]            	mov	bl,[ss:ALLOCMSAVE]	; M063
 33574 00005F24 36881E[0203]            	mov	[ss:AllocMethod],bl	; M063: restore alloc method
 33575                                  
 33576                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33577                                  	;test	byte [bp-5],2
 33578 00005F29 F646FB02                	test	Exec_Func,exec_func_overlay
 33579 00005F2D 7532                    	jnz	short Exec_Set_PDB	; no starto, chumo!
 33580                                  
 33581                                  	;mov	ax,[bp-20]
 33582 00005F2F 8B46EC                  	mov	AX,Exec_DMA
 33583 00005F32 83E810                  	sub	AX,10h
 33584 00005F35 36A3[C60F]              	mov	[SS:exec_init_CS],AX
 33585 00005F39 36C706[C40F]0001        	mov	word [SS:exec_init_IP],100h ; initial IP is 100h
 33586                                  
 33587                                  	; SI is AT MOST FF00h. Add FE to account for PSP - word
 33588                                  	; of 0 on stack.
 33589                                  
 33590 00005F40 81C6FE00                	add	SI,0FEh 		; make room for stack
 33591                                  
 33592                                  	; MSDOS 6.0
 33593 00005F44 83FEFE                  	cmp	si,0FFFEh		; M047: Q: was there >= 64K available
 33594 00005F47 7404                    	je	short Exec_St_Ok	; M047: Y: stack is fine
 33595 00005F49 81C60001                	add	si,100h			; M047: N: add the xtra 100h for stack
 33596                                  
 33597                                  Exec_St_Ok:
 33598                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33599 00005F4D 368936[C00F]            	mov	[SS:exec_init_SP],SI 	; max value for read is also SP!;smr;SS Override
 33600 00005F52 36A3[C20F]              	mov	[SS:exec_init_SS],AX 					;smr;SS Override
 33601 00005F56 8ED8                    	mov	DS,AX
 33602 00005F58 C7040000                	mov	WORD [SI],0		; 0 for return
 33603                                  
 33604                                  	; MSDOS 6.0
 33605                                  
 33606                                  	; M068
 33607                                  	;
 33608                                  	; We now determine if this is a Copy Protected App. If so the 
 33609                                  	; A20OFF_COUNT is set to 6. Note that ChkCopyProt will point to a 
 33610                                  	; a ret if DOS is loaded low. Also DS contains the load segment.
 33611                                  
 33612 00005F5C 36FF16[6100]            	call	word [ss:ChkCopyProt]	
 33613                                  
 33614                                  Exec_Set_PDB:
 33615                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33616                                  	;mov	bx,[bp-8]
 33617 00005F61 8B5EF8                  	mov	BX,Exec_FH		; we are finished with the file.
 33618 00005F64 E8A901                  	call	Exec_Dealloc
 33619 00005F67 55                      	push	BP
 33620                                  	;invoke	$Close			; release the jfn
 33621 00005F68 E8AA07                  	call	_$CLOSE
 33622 00005F6B 5D                      	pop	BP
 33623 00005F6C E89301                  	call	Exec_Alloc
 33624                                  	;test	byte [bp-5],2
 33625 00005F6F F646FB02                	test	Exec_Func,exec_func_overlay
 33626 00005F73 743A                    	jz	short Exec_Build_Header
 33627                                  
 33628                                  	; MSDOS 6.0
 33629 00005F75 E8C201                  	call	Scan_Execname
 33630 00005F78 E8D601                  	call	Scan_Special_Entries
 33631                                  ;SR;
 33632                                  ;The current lie strategy uses the PSP to store the lie version. However,
 33633                                  ;device drivers are loaded as overlays and have no PSP. To handle them, we
 33634                                  ;use the Sysinit flag provided by the BIOS as part of a structure pointed at
 33635                                  ;by BiosDataPtr. If this flag is set, the overlay call has been issued from
 33636                                  ;Sysinit and therefore must be a device driver load. We then get the lie 
 33637                                  ;version for this driver and put it into the Sysinit PSP. When the driver
 33638                                  ;issues the version check, it gets the lie version until the next overlay
 33639                                  ;call is issued.
 33640                                  
 33641 00005F7B 36803E[3F10]00          	cmp	byte [ss:DriverLoad],0	;was Sysinit processing done?
 33642 00005F81 7426                    	je	short norm_ovl		;yes, no special handling
 33643 00005F83 56                      	push	si
 33644 00005F84 06                      	push	es
 33645 00005F85 36C436[4010]            	les	si,[ss:BiosDataPtr]	;get ptr to BIOS data block
 33646                                  	 
 33647                                  	; (es:si points to 'SysinitPresent' address/flag in retrodos4.s) 
 33648 00005F8A 26803C00                	cmp	byte [es:si],0		;in Sysinit?
 33649 00005F8E 7411                    	je	short sysinit_done	;no, Sysinit is finished
 33650                                  	
 33651 00005F90 368E06[3003]            	mov	es,[ss:CurrentPDB]	;es = current PSP (Sysinit PSP)
 33652 00005F95 36FF36[BD0E]            	push	word [ss:SPECIAL_VERSION]
 33653 00005F9A 268F064000              	pop	word [es:PDB.Version]	;store lie version in Sysinit PSP
 33654                                  		;;; PDB.VERSION
 33655 00005F9F EB06                    	jmp	short setver_done
 33656                                  sysinit_done:
 33657 00005FA1 36C606[3F10]00          	mov	byte [ss:DriverLoad],0	;Sysinit done,special handling off
 33658                                  setver_done:
 33659 00005FA7 07                      	pop	es
 33660 00005FA8 5E                      	pop	si
 33661                                  norm_ovl:
 33662                                  	;leave
 33663 00005FA9 89EC                    	mov	sp,bp		
 33664 00005FAB 5D                      	pop	bp
 33665                                  
 33666                                  	;transfer SYS_RET_OK		; overlay load -> done
 33667 00005FAC E988A6                  	jmp	SYS_RET_OK
 33668                                  
 33669                                  Exec_Build_Header:
 33670                                  	;mov	dx,[bp-18]
 33671 00005FAF 8B56EE                  	mov	DX,Exec_Load_Block
 33672                                  					; assign the space to the process
 33673                                  	;mov	si,1
 33674 00005FB2 BE0100                  	mov	SI,ARENA.OWNER		; pointer to owner field
 33675                                  	;mov	ax,[bp-14]
 33676 00005FB5 8B46F2                  	mov	AX,Exec_Environ 	; get environ pointer
 33677 00005FB8 09C0                    	or	AX,AX
 33678 00005FBA 7405                    	jz	short No_Owner		; no environment
 33679                                  
 33680 00005FBC 48                      	dec	AX			; point to header
 33681 00005FBD 8ED8                    	mov	DS,AX
 33682 00005FBF 8914                    	mov	[SI],DX 		; assign ownership
 33683                                  No_Owner:
 33684                                  	;mov	ax,[bp-18]
 33685                                  	;mov	AX,Exec_Load_Block	; get load block pointer
 33686                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 33687                                  	; 17/12/2022
 33688 00005FC1 89D0                    	mov	ax,dx ; 06/06/2019
 33689                                  	;mov	ax,Exec_Load_Block	; get load block pointer
 33690                                  	
 33691 00005FC3 48                      	dec	AX
 33692 00005FC4 8ED8                    	mov	DS,AX			; point to header
 33693 00005FC6 8914                    	mov	[SI],DX 		; assign ownership
 33694                                  
 33695                                  	; MSDOS 6.0
 33696 00005FC8 1E                      	push	DS			;AN000;MS. make ES=DS
 33697 00005FC9 07                      	pop	ES			;AN000;MS.
 33698                                  	;mov	di,8
 33699 00005FCA BF0800                  	mov	DI,ARENA.NAME		;AN000;MS. ES:DI points to destination
 33700 00005FCD E86A01                  	call	Scan_Execname		;AN007;MS. parse execname
 33701                                  					;	   ds:si->name, cx=name length
 33702 00005FD0 51                      	push	CX			;AN007;;MS. save for fake version
 33703 00005FD1 56                      	push	SI			;AN007;;MS. save for fake version
 33704                                  
 33705                                  MoveName:				;AN000;
 33706 00005FD2 AC                      	lodsb				;AN000;;MS. get char
 33707 00005FD3 3C2E                    	cmp	AL,'.'			;AN000;;MS. is '.' ,may be name.exe
 33708 00005FD5 7408                    	jz	short Mem_Done		;AN000;;MS. no, move to header
 33709                                  					;AN000;
 33710 00005FD7 AA                      	stosb				;AN000;;MS. move char
 33711                                  					; MSKK bug fix - limit length copied
 33712 00005FD8 83FF10                  	cmp	di,16 ; ARENAHEADERSIZE	; end of memory arena block?
 33713 00005FDB 7302                    	jae	short Mem_Done		; jump if so
 33714                                  	;
 33715 00005FDD E2F3                    	loop	MoveName		;AN000;;MS. continue
 33716                                  Mem_Done:				;AN000;
 33717 00005FDF 30C0                    	xor	AL,AL			;AN000;;MS. make ASCIIZ
 33718                                  	;cmp	di,16
 33719 00005FE1 83FF10                  	cmp	DI,ARENAHEADERSIZE ; 16 ;AN000;MS. if not all filled
 33720 00005FE4 7301                    	jae	short Fill8		;AN000;MS.
 33721                                  	
 33722 00005FE6 AA                      	stosb				;AN000;MS.
 33723                                  	
 33724                                  Fill8:					;AN000;
 33725 00005FE7 5E                      	pop	SI			;AN007;MS. ds:si -> file name
 33726 00005FE8 59                      	pop	CX			;AN007;MS.
 33727                                  	
 33728 00005FE9 E86501                  	call	Scan_Special_Entries	;AN007;MS.
 33729                                  
 33730                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33731 00005FEC 52                      	push	DX
 33732                                  	;mov	si,[bp-16]
 33733 00005FED 8B76F0                  	mov	SI,Exec_Size
 33734 00005FF0 01D6                    	add	SI,DX
 33735                                  	;Invoke	$Dup_PDB		; ES is now PDB
 33736 00005FF2 E8A2B0                  	call	_$DUP_PDB
 33737 00005FF5 5A                      	pop	DX
 33738                                  
 33739                                  	;push	word [bp-14]
 33740 00005FF6 FF76F2                  	push	Exec_Environ
 33741                                  	;pop	WORD [ES:2Ch]
 33742 00005FF9 268F062C00              	pop	word [ES:PDB.ENVIRON]
 33743                                  
 33744                                  	; MSDOS 6.0			; *** Added for DOS 5.00
 33745                                  					; version number in PSP
 33746 00005FFE 36FF36[BD0E]             	push	word [ss:SPECIAL_VERSION] ; Set the DOS version number to
 33747 00006003 268F064000              	pop	word [ES:PDB.Version]	; to be used for this application
 33748                                  		; PDB.VERSION
 33749                                  
 33750                                  	; MSDOS 3.3 (& MSDOS 6.0)	; set up proper command line stuff
 33751                                  	;lds	si,[bp-4]
 33752 00006008 C576FC                  	lds	SI,Exec_Blk		; get the block
 33753 0000600B 1E                      	push	DS			; save its location
 33754 0000600C 56                      	push	SI
 33755                                  	;lds	si,[si+6]
 33756 0000600D C57406                  	lds	SI,[SI+EXEC0.5C_FCB]	; get the 5c fcb
 33757                                  
 33758                                  	; DS points to user space 5C FCB
 33759                                  
 33760 00006010 B90C00                  	mov	CX,12			; copy drive, name and ext
 33761 00006013 51                      	push	CX
 33762 00006014 BF5C00                  	mov	DI,5Ch
 33763 00006017 8A1C                    	mov	BL,[SI]
 33764 00006019 F3A4                    	rep	movsb
 33765                                  
 33766                                  	; DI = 5Ch + 12 = 5Ch + 0Ch = 68h
 33767                                  
 33768 0000601B 31C0                    	xor	AX,AX			; zero extent, etc for CPM
 33769 0000601D AB                      	stosw
 33770 0000601E AB                      	stosw
 33771                                  
 33772                                  	; DI = 5Ch + 12 + 4 = 5Ch + 10h = 6Ch
 33773                                  
 33774 0000601F 59                      	pop	CX
 33775 00006020 5E                      	pop	SI			; get block
 33776 00006021 1F                      	pop	DS
 33777 00006022 1E                      	push	DS			; save (again)
 33778 00006023 56                      	push	SI
 33779                                  	;lds	si,[si+0Ah]
 33780 00006024 C5740A                  	lds	SI,[SI+EXEC0.6C_FCB]	; get 6C FCB
 33781                                  
 33782                                  	; DS points to user space 6C FCB
 33783                                  
 33784 00006027 8A3C                    	mov	BH,[SI] 		; do same as above
 33785 00006029 F3A4                    	rep	movsb
 33786 0000602B AB                      	stosw
 33787 0000602C AB                      	stosw
 33788 0000602D 5E                      	pop	SI			; get block (last time)
 33789 0000602E 1F                      	pop	DS
 33790                                  	;ld	si,[si+2]
 33791 0000602F C57402                  	lds	SI,[SI+EXEC0.COM_LINE]	; command line
 33792                                  
 33793                                  	; DS points to user space 80 command line
 33794                                  
 33795 00006032 80C980                  	or	CL,80h
 33796 00006035 89CF                    	mov	DI,CX
 33797 00006037 F3A4                    	rep	movsb			; Wham!
 33798                                  
 33799                                  	; Process BX into default AX (validity of drive specs on args).
 33800                                  	; We no longer care about DS:SI.
 33801                                  
 33802 00006039 FEC9                    	dec	CL			; get 0FFh in CL
 33803 0000603B 88F8                    	mov	AL,BH
 33804 0000603D 30FF                    	xor	BH,BH
 33805                                  	;invoke	GetVisDrv
 33806 0000603F E8400A                  	call	GetVisDrv
 33807 00006042 7302                    	jnc	short Exec_BL
 33808                                  
 33809 00006044 88CF                    	mov	BH,CL
 33810                                  
 33811                                  Exec_BL:
 33812 00006046 88D8                    	mov	AL,BL
 33813 00006048 30DB                    	xor	BL,BL
 33814                                  	;invoke	GetVisDrv
 33815 0000604A E8350A                  	call	GetVisDrv
 33816 0000604D 7302                    	jnc	short Exec_Set_Return
 33817                                  
 33818 0000604F 88CB                    	mov	BL,CL
 33819                                  
 33820                                  Exec_Set_Return:
 33821                                  	;invoke	Get_User_Stack			; get his return address
 33822 00006051 E82DA4                  	call	Get_User_Stack
 33823                                  
 33824                                  	;push	word [si+14h]
 33825 00006054 FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 33826                                  	;push	word [si+12h]
 33827 00006057 FF7412                  	push	word [SI+user_env.user_IP]
 33828                                  	;push	word [si+14h]
 33829 0000605A FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 33830                                  	;push	word [si+12h]
 33831 0000605D FF7412                  	push	word [SI+user_env.user_IP]
 33832                                  	;pop	word [ES:0Ah]
 33833 00006060 268F060A00              	pop	WORD [ES:PDB.EXIT]
 33834                                  	;pop	word [ES:0Ch]
 33835 00006065 268F060C00              	pop	WORD [ES:PDB.EXIT+2]
 33836                                  
 33837 0000606A 31C0                    	xor	AX,AX
 33838 0000606C 8ED8                    	mov	DS,AX
 33839                                  					; save them where we can get them
 33840                                  					; later when the child exits.
 33841                                  	;pop	word [88h]
 33842 0000606E 8F068800                	pop	word [addr_int_terminate] ; 22h*4
 33843                                  	;pop	word [90h]
 33844 00006072 8F068A00                	pop	word [addr_int_terminate+2] ; (22h*4)+2
 33845                                  
 33846 00006076 36C706[2C03]8000        	mov	WORD [SS:DMAADD],80h	; SS Override
 33847 0000607D 368E1E[3003]            	mov	DS,[SS:CurrentPDB]	; SS Override
 33848 00006082 368C1E[2E03]            	mov	[SS:DMAADD+2],DS	; SS Override
 33849                                  
 33850                                  	;test	byte [bp-5],1
 33851 00006087 F646FB01                	test	Exec_Func,exec_func_no_execute
 33852 0000608B 7427                    	jz	short exec_go
 33853                                  
 33854 0000608D 36C536[C00F]            	lds	SI,[SS:exec_init_SP]	; get stack SS Override
 33855                                  	;les	di,[bp-4]
 33856 00006092 C47EFC                  	les	DI,Exec_Blk		; and block for return
 33857                                  	;mov	[es:di+10h],ds
 33858 00006095 268C5D10                	mov	[ES:DI+EXEC1.SS],DS	; return SS
 33859                                  
 33860 00006099 4E                      	dec	SI			; 'push' default AX
 33861 0000609A 4E                      	dec	SI
 33862 0000609B 891C                    	mov	[SI],BX 		; save default AX reg
 33863                                  	;mov	[es:di+0Eh], si
 33864 0000609D 2689750E                	mov	[ES:DI+EXEC1.SP],SI	; return 'SP'
 33865                                  
 33866 000060A1 36C506[C40F]            	lds	AX,[SS:exec_init_IP]	; SS Override
 33867                                  	;mov	[es:di+14h],ds
 33868 000060A6 268C5D14                	mov	[ES:DI+EXEC1.CS],DS	; initial entry stuff
 33869                                  	;mov	[es:di+12h],ax
 33870 000060AA 26894512                	mov	[ES:DI+EXEC1.IP],AX
 33871                                  	
 33872                                  	;leave
 33873 000060AE 89EC                    	mov	sp,bp
 33874 000060B0 5D                      	pop	bp	
 33875                                  
 33876                                  	;transfer SYS_RET_OK
 33877 000060B1 E983A5                  	jmp	SYS_RET_OK
 33878                                  
 33879                                  exec_go:
 33880 000060B4 36C536[C40F]            	lds	SI,[SS:exec_init_IP]	; get entry point SS Override
 33881 000060B9 36C43E[C00F]            	les	DI,[SS:exec_init_SP]	; new stack SS Override
 33882 000060BE 8CC0                    	mov	AX,ES
 33883                                  
 33884                                  	; MSDOS 6.0
 33885 000060C0 36803E[F211]00          	cmp	byte [SS:DosHasHMA],0	; Q: is dos in HMA (M021)
 33886 000060C6 741A                    	je	short Xfer_To_User	; N: transfer control to user
 33887                                  
 33888 000060C8 1E                      	push	ds			; Y: control must go to low mem stub
 33889                                  		
 33890 000060C9 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]		;    where we disable a20 and Xfer 
 33891                                  					;    control to user 
 33892 000060CE 800E[8600]04            	or	byte [DOS_FLAG],EXECA20OFF ; M068:
 33893                                  					; M004: Set bit to signal int 21
 33894                                  					; ah = 25 & ah= 49. See dossym.inc 
 33895                                  					; under TAG M003 & M009 for 
 33896                                  					; explanation
 33897 000060D3 8916[6300]              	mov	[A20OFF_PSP],dx		; M068: set the PSP for which A20 is
 33898                                  					; M068: going to be turned OFF.
 33899                                  	
 33900 000060D7 8CD8                    	mov	ax,ds			; ax = segment of low mem stub
 33901 000060D9 1F                      	pop	ds
 33902                                  	
 33903 000060DA 50                      	push	ax			; ret far into the low mem stub
 33904 000060DB B8[FB10]                	mov	ax,disa20_xfer
 33905 000060DE 50                      	push	ax
 33906 000060DF 8CC0                    	mov	AX,ES			; restore ax
 33907 000060E1 CB                      	retf
 33908                                  
 33909                                  Xfer_To_User:
 33910                                  	; DS:SI points to entry point
 33911                                  	; AX:DI points to initial stack
 33912                                  	; DX has PDB pointer
 33913                                  	; BX has initial AX value
 33914                                  
 33915 000060E2 FA                      	cli
 33916                                  	; 15/08/2018
 33917 000060E3 36C606[2103]00          	mov	BYTE [SS:INDOS],0	; SS Override
 33918                                  
 33919 000060E9 8ED0                    	mov	SS,AX			; set up user's stack
 33920 000060EB 89FC                    	mov	SP,DI			; and SP
 33921 000060ED FB                      	sti
 33922                                  
 33923 000060EE 1E                      	push	DS			; fake long call to entry
 33924 000060EF 56                      	push	SI
 33925 000060F0 8EC2                    	mov	ES,DX			; set up proper seg registers
 33926 000060F2 8EDA                    	mov	DS,DX
 33927 000060F4 89D8                    	mov	AX,BX			; set up proper AX
 33928                                  
 33929 000060F6 CB                      	retf
 33930                                  
 33931                                  ; 04/08/2018 - Retro DOS v3.0
 33932                                  
 33933                                  ;----------------------------------------------------------------------------
 33934                                  ;
 33935                                  ;----------------------------------------------------------------------------
 33936                                  
 33937                                  ExecRead:
 33938 000060F7 E81600                  	CALL	Exec_Dealloc
 33939                                  	;mov	bx,[bp-8]
 33940 000060FA 8B5EF8                  	MOV	bx,Exec_FH
 33941                                  
 33942 000060FD 55                      	PUSH	BP
 33943 000060FE E82507                  	call	_$READ
 33944 00006101 5D                      	POP	BP
 33945                                  
 33946                                  	;CALL	Exec_Alloc
 33947                                  	;retn
 33948                                  	; 18/12/2022
 33949                                  	;jmp	short Exec_Alloc
 33950                                  
 33951                                  ; 18/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 
 33952                                  
 33953                                  ;----------------------------------------------------------------------------
 33954                                  ;
 33955                                  ;----------------------------------------------------------------------------
 33956                                  
 33957                                  Exec_Alloc:
 33958 00006102 53                      	push	BX
 33959                                  	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 33960                                  	; 20/05/2019 - Retro DOS v4.0
 33961                                  	; MSDOS 6.0
 33962 00006103 368B1E[3003]            	mov	bx,[SS:CurrentPDB]  ; SS Override
 33963 00006108 E81000                  	call	ChangeOwners
 33964 0000610B E81AB2                  	call	LCritMEM
 33965 0000610E 5B                      	pop	BX
 33966 0000610F C3                      	retn
 33967                                  
 33968                                  ;----------------------------------------------------------------------------
 33969                                  ;
 33970                                  ;----------------------------------------------------------------------------
 33971                                  
 33972                                  Exec_Dealloc:
 33973 00006110 53                      	push	BX
 33974                                  	;mov	bx,0
 33975 00006111 29DB                    	sub	BX,BX		; (bx) = ARENA_OWNER_SYSTEM
 33976 00006113 E8F7B1                  	call	ECritMEM
 33977 00006116 E80200                  	call	ChangeOwners
 33978 00006119 5B                      	pop	BX
 33979 0000611A C3                      	retn
 33980                                  
 33981                                  ; 18/12/2022
 33982                                  %if 0
 33983                                  ;----------------------------------------------------------------------------
 33984                                  ;
 33985                                  ;----------------------------------------------------------------------------
 33986                                  
 33987                                  Exec_Alloc:
 33988                                  	push	BX
 33989                                  	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 33990                                  	; 20/05/2019 - Retro DOS v4.0
 33991                                  	; MSDOS 6.0
 33992                                  	mov	bx,[SS:CurrentPDB]  ; SS Override
 33993                                  	call	ChangeOwners
 33994                                  	call	LCritMEM
 33995                                  	pop	BX
 33996                                  	retn
 33997                                  
 33998                                  %endif
 33999                                  
 34000                                  ;----------------------------------------------------------------------------
 34001                                  ;
 34002                                  ;----------------------------------------------------------------------------
 34003                                  
 34004                                  ChangeOwners:
 34005 0000611B 9C                      	pushf
 34006 0000611C 50                      	push	AX
 34007                                  	;mov	ax,[bp-14]
 34008 0000611D 8B46F2                  	mov	AX,Exec_Environ
 34009 00006120 E80900                  	call	ChangeOwner
 34010                                  	;mov	ax,[bp-18]
 34011 00006123 8B46EE                  	mov	AX,Exec_Load_Block
 34012 00006126 E80300                  	call	ChangeOwner
 34013 00006129 58                      	pop	AX
 34014 0000612A 9D                      	popf
 34015                                  chgown_retn:
 34016 0000612B C3                      	retn
 34017                                  
 34018                                  ;----------------------------------------------------------------------------
 34019                                  ;
 34020                                  ;----------------------------------------------------------------------------
 34021                                  
 34022                                  ChangeOwner:
 34023 0000612C 09C0                    	or	AX,AX			; is area allocated?
 34024 0000612E 74FB                    	jz	short chgown_retn	; no, do nothing
 34025 00006130 48                      	dec	AX
 34026 00006131 1E                      	push	DS
 34027 00006132 8ED8                    	mov	DS,AX
 34028 00006134 891E0100                	mov	[ARENA.OWNER],BX
 34029 00006138 1F                      	pop	DS
 34030 00006139 C3                      	retn
 34031                                  
 34032                                  ;----------------------------------------------------------------------------
 34033                                  ;
 34034                                  ;----------------------------------------------------------------------------
 34035                                  
 34036                                  ; 20/05/2019 - Retro DOS v4.0
 34037                                  
 34038                                  	; MSDOS 6.0
 34039                                  Scan_Execname:
 34040 0000613A C576E6                  	lds	SI,ExecName		; DS:SI points to name
 34041                                  Scan_Execname1:				; M028
 34042                                  Save_Begin:				;
 34043 0000613D 89F1                    	mov	CX,SI			; CX= starting addr
 34044                                  Scan0:					;
 34045 0000613F AC                      	lodsb				; get char
 34046                                  
 34047 00006140 3C3A                    	cmp	AL,':'			; is ':' , may be A:name
 34048 00006142 74F9                    	jz	short Save_Begin	; yes, save si
 34049 00006144 3C5C                    	cmp	AL,'\'                  ; is '\', may be A:\name
 34050 00006146 74F5                    	jz	short Save_Begin	; yes, save si
 34051 00006148 3C00                    	cmp	AL,0			; is end of name
 34052 0000614A 75F3                    	jnz	short Scan0		; no, continue scanning
 34053 0000614C 29CE                    	sub	SI,CX			; get name's length
 34054 0000614E 87F1                    	xchg	SI,CX			; cx= length, si= starting addr
 34055                                  
 34056 00006150 C3                      	retn
 34057                                  
 34058                                  ;----------------------------------------------------------------------------
 34059                                  ;
 34060                                  ;----------------------------------------------------------------------------
 34061                                  
 34062                                  ; 20/05/2019 - Retro DOS v4.0
 34063                                  
 34064                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34065                                  ; DOSCODE:A0EDh (MSDOS 5.0, MSDOS.SYS)
 34066                                  
 34067                                  	; MSDOS 6.0
 34068                                  
 34069                                  Scan_Special_Entries:
 34070                                  
 34071 00006151 49                      	dec	CX			; cx= name length
 34072                                  ;M060	mov	DI,[Special_Entries]	; es:di -> addr of special entries
 34073                                  					;reset to current version
 34074                                  	;mov	word [ss:SPECIAL_VERSION],1406h 
 34075                                  				; (MSDOS 6.21, MSDOS.SYS, DOSCODE:A14Eh)
 34076                                  	;mov	word [ss:SPECIAL_VERSION],5
 34077                                  				; (MSDOS 5.0, MSDOS.SYS, DOSCODE:A0EEh)
 34078                                  
 34079                                  				; 5 for Retro DOS 4.0 (01/12/2022, MSDOS 5.0)
 34080 00006152 36C706[BD0E]0616        	mov	word [ss:SPECIAL_VERSION],(MINOR_VERSION<<8)+MAJOR_VERSION
 34081                                  				; 0005h for Retro DOS v4.1 (MSDOS 5.0)
 34082                                  				; 24/09/2023
 34083                                  				; 1606h for Retro DOS v4.2 (MSDOS 6.22)
 34084                                  ;***	call	Reset_Version
 34085                                  
 34086                                  ;M060	push	SS
 34087                                  ;M060	pop	ES
 34088                                  
 34089 00006159 36C43E[5D00]            	les	DI,[SS:UU_IFS_DOS_CALL]	;M060; ES:DI --> Table in SETVER.SYS
 34090 0000615E 8CC0                    	mov	AX,ES			;M060; First do a NULL ptr check to
 34091 00006160 09F8                    	or	AX,DI			;M060; be sure the table exists
 34092 00006162 7427                    	jz	short End_List		;M060; If ZR then no table
 34093                                  
 34094                                  GetEntries:
 34095 00006164 268A05                  	mov	AL,[ES:DI]		; end of list
 34096 00006167 08C0                    	or	AL,AL
 34097 00006169 7420                    	jz	short End_List		; yes
 34098                                  
 34099 0000616B 36893E[0E06]            	mov	[ss:TEMP_VAR2],DI	; save di
 34100 00006170 38C8                    	cmp	AL,CL			; same length ?
 34101 00006172 751B                    	jnz	short SkipOne 		; no
 34102                                  
 34103 00006174 47                      	inc	DI			; es:di -> special name
 34104 00006175 51                      	push	CX			; save length and name addr
 34105 00006176 56                      	push	SI
 34106                                  
 34107                                  ; M050 - BEGIN
 34108                                  
 34109 00006177 50                      	push	ax			; save len
 34110                                  sse_next_char:
 34111 00006178 AC                      	lodsb
 34112 00006179 E8D1EE                  	call	UCase
 34113 0000617C AE                      	scasb
 34114 0000617D 750D                    	jne	short Not_Matched
 34115 0000617F E2F7                    	loop	sse_next_char
 34116                                  	
 34117                                  ;	repz	cmpsb			; same name ?
 34118                                  ;	jnz	short Not_Matched	; no
 34119                                  
 34120 00006181 58                      	pop	ax			; take len off the stack
 34121                                  
 34122                                  ; M050 - END
 34123                                  
 34124 00006182 268B05                  	mov	AX,[ES:DI]		; get special version
 34125 00006185 36A3[BD0E]              	mov	[ss:SPECIAL_VERSION],AX	; save it
 34126                                  
 34127                                  ;***	mov	AL,[ES:DI+2]		; get fake count
 34128                                  ;***	mov	[ss:FAKE_COUNT],AL 	; save it
 34129                                  
 34130 00006189 5E                      	pop	SI
 34131 0000618A 59                      	pop	CX
 34132                                  	; 18/12/2022
 34133                                  	;jmp	SHORT End_List
 34134                                  
 34135                                  	; 18/12/2022
 34136                                  End_List:
 34137 0000618B C3                      	retn
 34138                                  
 34139                                  Not_Matched:
 34140 0000618C 58                      	pop	ax			; get len from stack ; M050
 34141 0000618D 5E                      	pop	SI			; restore si,cx
 34142 0000618E 59                      	pop	CX
 34143                                  
 34144                                  SkipOne:
 34145 0000618F 368B3E[0E06]            	mov	DI,[ss:TEMP_VAR2]	; restore old di use SS Override
 34146 00006194 30E4                    	xor	AH,AH			; position to next entry
 34147 00006196 01C7                    	add	DI,AX
 34148                                  
 34149 00006198 83C703                  	add	DI,3			; DI -> next entry length
 34150                                  ;***	add	DI,4			; DI -> next entry length
 34151                                  
 34152 0000619B EBC7                    	jmp	short GetEntries
 34153                                  
 34154                                  	; 18/12/2022
 34155                                  ;End_List:
 34156                                  	;retn
 34157                                  
 34158                                  ; 04/08/2018 - Retro DOS v3.0
 34159                                  ; IBMDOS.COm (MSDOS 3.3, 1987) - Offset 633Dh
 34160                                  
 34161                                  ;----------------------------------------------------------------------------
 34162                                  ;SUBTTL Terminate and stay resident handler
 34163                                  ;
 34164                                  ; Input:    DX is  an  offset  from  CurrentPDB  at which to
 34165                                  ;	    truncate the current block.
 34166                                  ;
 34167                                  ; output:   The current block is truncated (expanded) to be [DX+15]/16
 34168                                  ;	    paragraphs long.  An exit is simulated via resetting CurrentPDB
 34169                                  ;	    and restoring the vectors.
 34170                                  ;
 34171                                  ;----------------------------------------------------------------------------
 34172                                  
 34173                                  	; 20/05/2019 - Retro DOS v4.0
 34174                                  	; DOSCODE:A19Bh (MSDOS 6.21, MSDOS.SYS)
 34175                                  
 34176                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 34177                                  	; DOSCODE:A13Bh (MSDOS 5.0, MSDOS.SYS)
 34178                                  
 34179                                  _$KEEP_PROCESS:
 34180 0000619D 50                      	push	AX			; keep exit code around
 34181                                  	;mov	byte [SS:EXIT_TYPE],3
 34182 0000619E 36C606[7C05]03          	mov	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS
 34183 000061A4 368E06[3003]            	mov	ES,[SS:CurrentPDB]
 34184 000061A9 83FA06                  	cmp	DX,6h			; keep enough space around for system
 34185 000061AC 7303                    	jae	short Keep_Shrink	; info
 34186                                  
 34187 000061AE BA0600                  	mov	DX,6h
 34188                                  
 34189                                  Keep_Shrink:
 34190 000061B1 89D3                    	mov	BX,DX
 34191 000061B3 53                      	push	BX
 34192 000061B4 06                      	push	ES
 34193 000061B5 E82E02                  	call	_$SETBLOCK		; ignore return codes.
 34194 000061B8 1F                      	pop	DS
 34195 000061B9 5B                      	pop	BX
 34196 000061BA 7207                    	jc	short Keep_Done		; failed on modification
 34197                                  
 34198 000061BC 8CD8                    	mov	AX,DS
 34199 000061BE 01D8                    	add	AX,BX
 34200                                  	;mov	[2],ax
 34201 000061C0 A30200                  	mov	[PDB.BLOCK_LEN],AX	;PBUGBUG
 34202                                  
 34203                                  Keep_Done:
 34204 000061C3 58                      	pop	AX
 34205 000061C4 EB26                    	jmp	SHORT exit_inner	; and let abort take care of the rest
 34206                                  
 34207                                  ;----------------------------------------------------------------------------
 34208                                  ;
 34209                                  ;----------------------------------------------------------------------------
 34210                                  
 34211                                  STAY_RESIDENT:
 34212                                  	;mov	ax,3100h
 34213 000061C6 B80031                  	mov	AX,(KEEP_PROCESS<<8)+0 ; Lower part is return code;PBUGBUG
 34214 000061C9 83C20F                  	add	DX,15
 34215 000061CC D1DA                    	rcr	DX,1
 34216 000061CE B103                    	mov	CL,3
 34217 000061D0 D3EA                    	shr	DX,CL
 34218                                  
 34219 000061D2 E933A1                  	jmp	COMMAND
 34220                                  
 34221                                  ;----------------------------------------------------------------------------
 34222                                  ;SUBTTL $EXIT - return to parent process
 34223                                  ;   Assembler usage:
 34224                                  ;	    MOV     AL, code
 34225                                  ;	    MOV     AH, Exit
 34226                                  ;	    INT     int_command
 34227                                  ;   Error return:
 34228                                  ;	    None.
 34229                                  ;
 34230                                  ;----------------------------------------------------------------------------
 34231                                  
 34232                                  	; 20/05/2019 - Retro DOS v4.0
 34233                                  	; DOSCODE:A1D3h (MSDOS 6.21, MSDOS.SYS)
 34234                                  
 34235                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 34236                                  	; DOSCODE:A173h (MSDOS 5.0, MSDOS.SYS)
 34237                                  _$EXIT:
 34238                                  	; 04/08/2018 - Retro DOS v3.0
 34239                                  	; IBMDOSDOS.COM (MSDOS 3.3, 1987) - Offset 6375h
 34240 000061D5 30E4                    	xor	AH,AH
 34241 000061D7 368626[4D03]            	xchg	AH,[SS:DidCTRLC]
 34242 000061DC 08E4                    	or	AH,AH
 34243                                  	;mov	BYTE [SS:EXIT_TYPE],0
 34244 000061DE 36C606[7C05]00          	mov	BYTE [SS:EXIT_TYPE],EXIT_TERMINATE
 34245 000061E4 7406                    	jz	short exit_inner
 34246                                  	;mov	BYTE [SS:EXIT_TYPE],1
 34247 000061E6 36C606[7C05]01          	mov	BYTE [SS:EXIT_TYPE],EXIT_CTRL_C
 34248                                  
 34249                                  	;entry	Exit_inner
 34250                                  exit_inner:
 34251 000061EC E892A2                  	call	Get_User_Stack		;PBUGBUG
 34252                                  
 34253 000061EF 36FF36[3003]            	push	word [ss:CurrentPDB]
 34254                                  	;pop	word [si+14h]
 34255 000061F4 8F4414                  	pop	word [SI+user_env.user_CS] ;PBUGBUG
 34256 000061F7 EB08                    	jmp	short abort_inner
 34257                                  
 34258                                  ;BREAK <$ABORT -- Terminate a process>
 34259                                  ;----------------------------------------------------------------------------
 34260                                  ; Inputs:
 34261                                  ;	user_CS:00 must point to valid program header block
 34262                                  ; Function:
 34263                                  ;	Restore terminate and Cntrl-C addresses, flush buffers and transfer
 34264                                  ;	to the terminate address
 34265                                  ; Returns:
 34266                                  ;	TO THE TERMINATE ADDRESS
 34267                                  ;----------------------------------------------------------------------------
 34268                                  
 34269                                  _$ABORT:
 34270 000061F9 30C0                    	xor	AL,AL
 34271                                  	;mov	byte [SS:EXIT_TYPE],0
 34272                                  	;mov	byte [SS:EXIT_TYPE],AL ; = 0
 34273 000061FB 36C606[7C05]00          	mov	byte [SS:EXIT_TYPE],EXIT_ABORT
 34274                                  
 34275                                  	; abort_inner must have AL set as the exit code! The exit type
 34276                                  	; is retrieved from exit_type. Also, the PDB at user_CS needs
 34277                                  	; to be correct as the one that is terminating.
 34278                                  
 34279                                  abort_inner:
 34280 00006201 368A26[7C05]            	mov	AH,[SS:EXIT_TYPE]
 34281 00006206 36A3[3403]              	mov	[SS:exit_code],AX
 34282 0000620A E874A2                  	call	Get_User_Stack
 34283                                  
 34284                                  	;mov	ds,[si+14h]
 34285 0000620D 8E5C14                  	mov	DS,[SI+user_env.user_CS] ; set up old interrupts ;PBUGBUG
 34286 00006210 31C0                    	xor	AX,AX
 34287 00006212 8EC0                    	mov	ES,AX
 34288                                  	;mov	si,10
 34289 00006214 BE0A00                  	mov	SI,SAVEXIT
 34290                                  	;mov	di,88h
 34291 00006217 BF8800                  	mov	DI,addr_int_terminate
 34292 0000621A A5                      	movsw
 34293 0000621B A5                      	movsw
 34294 0000621C A5                      	movsw
 34295 0000621D A5                      	movsw
 34296 0000621E A5                      	movsw
 34297 0000621F A5                      	movsw
 34298 00006220 E944F2                  	jmp	reset_environment
 34299                                  
 34300                                  ;----------------------------------------------------------------------------
 34301                                  ;
 34302                                  ; fixexepatch will point to this is DOS loads low. 
 34303                                  ;
 34304                                  ;----------------------------------------------------------------------------
 34305                                  ; MSDOS 6.0
 34306                                  
 34307                                  ; 29/04/2019 - Retro DOS v4.0
 34308                                  ; DOSCODE:A221h (MSDOS 6.21, MSDOS.SYS)
 34309                                  
 34310                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 34311                                  ; DOSCODE:A1C1h (MSDOS 5.0, MSDOS.SYS)
 34312                                  
 34313                                  RetExePatch: ; proc near
 34314                                  	
 34315 00006223 C3                      	retn
 34316                                  
 34317                                  ;============================================================================
 34318                                  ; ALLOC.ASM, MSDOS 6.0, 1991
 34319                                  ;============================================================================
 34320                                  ; 04/08/2018 - Retro DOS v3.0
 34321                                  ; 14/05/2019 - Retro DOS v4.0
 34322                                  
 34323                                  ;	TITLE ALLOC.ASM - memory arena manager	NAME Alloc
 34324                                  
 34325                                  ;**
 34326                                  ;	Microsoft Confidential
 34327                                  ;	Copyright (C) Microsoft Corporation 1991
 34328                                  ;	All Rights Reserved.
 34329                                  ;
 34330                                  ;	Memory related system calls and low level routines for MSDOS 2.X.
 34331                                  ;	I/O specs are defined in DISPATCH.
 34332                                  ;
 34333                                  ;	$ALLOC
 34334                                  ;	$SETBLOCK
 34335                                  ;	$DEALLOC
 34336                                  ;	$AllocOper
 34337                                  ;	arena_free_process
 34338                                  ;	arena_next
 34339                                  ;	check_signature
 34340                                  ;	Coalesce
 34341                                  ;
 34342                                  ;	Modification history:
 34343                                  ;
 34344                                  ;	    Created: ARR 30 March 1983
 34345                                  ;
 34346                                  ;	    Revision: M000 - added support for allocing UMBs. 7/9/90
 34347                                  ;		      M003 - added support for link/unlink UMBs from
 34348                                  ;			     DOS arena chain. 7/18/90
 34349                                  ;		      M009 - Added error returns invalid function and 
 34350                                  ;			     arena trashed in set link state call.
 34351                                  ;		      M010 - Release UMB arenas allocated to current PDB
 34352                                  ;			     if UMB_HEAD is initialized.
 34353                                  ;
 34354                                  ;		      M016 - MACE utilities mkeyrate.com version 1.0 
 34355                                  ;			     support. Please see under M009 in 
 34356                                  ;			     ..\inc\dossym.inc. 8/31/90.
 34357                                  ;
 34358                                  ;		      M061 - In GetLastArena, if linking in UMBs check to make
 34359                                  ;			     sure that umb_head arena is valid and also make
 34360                                  ;			     sure that the previous arena is pointing to 
 34361                                  ;			     umb_head.
 34362                                  ;
 34363                                  ;		      M064 - allow HIGH_ONLY bit to be set by a call to 
 34364                                  ;			     set allloc strategy.
 34365                                  ;			     use STRAT_MASK to mask out bits 6 & 7 of 
 34366                                  ;			     bx in AllocSetStrat.
 34367                                  ;
 34368                                  ;		      M068 - use a count value (A20OFF_COUNT) rather than
 34369                                  ;			     a bit to indicate to dos dispatcher to turn
 34370                                  ;			     a20 off before iret. See M016.
 34371                                  ;
 34372                                  
 34373                                  ;	BREAK	<memory allocation utility routines>
 34374                                  
 34375                                  
 34376                                  ; 15/04/2018 - Retro DOS v2.0
 34377                                  ;----------------------------------------------------------------------------
 34378                                  ; xenix memory calls for MSDOS
 34379                                  ;
 34380                                  ; CAUTION: The following routines rely on the fact that arena_signature and
 34381                                  ; arena_owner_system are all equal to zero and are contained in DI.
 34382                                  ;
 34383                                  ;INCLUDE DOSSEG.ASM
 34384                                  
 34385                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 34386                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 34387                                  
 34388                                  ;.xlist
 34389                                  ;.xcref
 34390                                  ;INCLUDE DOSSYM.ASM
 34391                                  ;INCLUDE DEVSYM.ASM
 34392                                  ;.cref
 34393                                  ;.list
 34394                                  
 34395                                  ;TITLE ALLOC.ASM - memory arena manager
 34396                                  ;NAME Alloc
 34397                                  
 34398                                  ;SUBTTL memory allocation utility routines
 34399                                  ;PAGE
 34400                                  ;
 34401                                  ; arena data
 34402                                  ;
 34403                                  ;       i_need  arena_head,WORD         ; seg address of start of arena
 34404                                  ;       i_need  CurrentPDB,WORD         ; current process data block addr
 34405                                  ;       i_need  FirstArena,WORD         ; first free block found
 34406                                  ;       i_need  BestArena,WORD          ; best free block found
 34407                                  ;       i_need  LastArena,WORD          ; last free block found
 34408                                  ;       i_need  AllocMethod,BYTE        ; how to alloc first(best)last
 34409                                  
 34410                                  ;**	Arena_Free_Process
 34411                                  ;----------------------------------------------------------------------------
 34412                                  ;	Free all arena blocks allocated to a prOcess
 34413                                  ;
 34414                                  ;	ENTRY	(bx) = PID of process
 34415                                  ;	EXIT	none
 34416                                  ;	USES	????? BUGBUG
 34417                                  ;----------------------------------------------------------------------------
 34418                                  
 34419                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 34420                                  	; DOSCODE:A1C2h (MSDOS 5.0, MSDOS.SYS)
 34421                                  
 34422                                  arena_free_process:
 34423                                  	; 14/05/2019 - Retro DOS v4.0
 34424                                  	; 04/08/2018 - Retro DOS v3.0
 34425 00006224 36A1[2400]                      MOV	AX,[SS:arena_head]
 34426                                  arena_free_process_start:
 34427 00006228 BF0000                  	MOV     DI,ARENA.SIGNATURE ; 0
 34428                                  	;MOV	AX,[SS:arena_head] ; 15/04/2018  
 34429 0000622B E83000                          CALL	check_signature         ; ES <- AX, check for valid block
 34430                                  
 34431                                  arena_free_process_loop:
 34432                                          ;retc
 34433 0000622E 723D                            JC	SHORT AFP_RETN	; Retro DOS v2.0 - 05/03/2018
 34434 00006230 06                      	PUSH    ES
 34435 00006231 1F                              POP     DS
 34436                                  	;cmp	[1],bx 
 34437 00006232 391E0100                        CMP     [ARENA.OWNER],BX	; is block owned by pid?
 34438 00006236 7504                            JNZ     SHORT arena_free_next	; no, skip to next
 34439                                  	;mov	[1],di
 34440 00006238 893E0100                        MOV     [ARENA.OWNER],DI	; yes... free him
 34441                                  
 34442                                  arena_free_next:
 34443                                  	;cmp	byte [di],5Ah ;'Z'
 34444 0000623C 803D5A                          CMP     BYTE [DI],arena_signature_end
 34445                                                                          ; end of road, Jack?
 34446                                          ;retz				; never come back no more
 34447                                  	;JZ	SHORT AFP_RETN  ; MSDOS 3.3 (& MSDOS 2.11)
 34448                                  	; 14/05/2019
 34449                                  	; MSDOS 6.0
 34450 0000623F 7405                    	jz	short arena_chk_umbs
 34451                                          
 34452 00006241 E81300                  	CALL    arena_next              ; next item in ES/AX carry set if trash
 34453 00006244 EBE8                            JMP     SHORT arena_free_process_loop
 34454                                  
 34455                                  	; MSDOS 6.0
 34456                                  arena_chk_umbs:				; M010 - Start
 34457                                  	; 20/05/2019
 34458 00006246 36A1[8C00]              	mov	ax,[ss:UMB_HEAD]	; ax = umb_head
 34459 0000624A 83F8FF                  	cmp	ax,0FFFFh		; Q: is umb_head initialized
 34460 0000624D 741E                    	je	short ret_label		; N: we're done
 34461                                  	
 34462 0000624F 8CDF                    	mov	di,ds			; di = last arena
 34463 00006251 39C7                    	cmp	di,ax			; Q: is last arena above umb_head
 34464 00006253 7318                    	jae	short ret_label		; Y: we've scanned umbs also. done.
 34465 00006255 EBD1                    	jmp	short arena_free_process_start
 34466                                  					; M010 - End
 34467                                  ;AFP_RETN:
 34468                                  ;	RETN
 34469                                  
 34470                                  ;	BREAK	<Arena Helper Routines>
 34471                                  
 34472                                  ;**	Arena_Next - Find Next item in Arena
 34473                                  ;----------------------------------------------------------------------------
 34474                                  ;	ENTRY	DS - pointer to block head
 34475                                  ;		(di) = 0
 34476                                  ;	EXIT	AX,ES - pointers to next head
 34477                                  ;		'C' set iff arena damaged
 34478                                  ;----------------------------------------------------------------------------
 34479                                  
 34480                                  arena_next:
 34481 00006257 8CD8                            MOV     AX,DS                   ; AX <- current block
 34482 00006259 03060300                        ADD     AX,[ARENA.SIZE]		; AX <- AX + current block length
 34483 0000625D 40                              INC     AX                      ; remember that header!
 34484                                  
 34485                                  ;       fall into check_signature and return
 34486                                  ;
 34487                                  ;       CALL    check_signature         ; ES <- AX, carry set if error
 34488                                  ;       RETN
 34489                                  
 34490                                  ;**	Check_Signature - Check Memory Block Signature
 34491                                  ;----------------------------------------------------------------------------
 34492                                  ;	ENTRY	(AX) = address of block header
 34493                                  ;		(di) = 0
 34494                                  ;	EXIT	 ES = AX
 34495                                  ;		'C' clear if signature good
 34496                                  ;		'C' set if signature bad
 34497                                  ;	USES	ES, Flags
 34498                                  ;----------------------------------------------------------------------------
 34499                                  
 34500                                  check_signature:        
 34501                                  
 34502 0000625E 8EC0                    	MOV     ES,AX                   ; ES <- AX
 34503                                  	;cmp	byte [es:di],4Dh ; 'M'
 34504 00006260 26803D4D                        CMP     BYTE [ES:DI],arena_signature_normal
 34505                                                                          ; IF next signature = not_end THEN
 34506 00006264 7407                            JZ      SHORT check_signature_ok ;   GOTO ok
 34507                                  	;cmp 	byte [es:di],5Ah ; 'Z'
 34508 00006266 26803D5A                        CMP     BYTE [ES:DI],arena_signature_end
 34509                                                                          ; IF next signature = end then
 34510 0000626A 7401                            JZ      SHORT check_signature_ok ;   GOTO ok
 34511 0000626C F9                              STC                             ; set error
 34512                                  ret_label: ; MSDOS 6.0
 34513                                  AFP_RETN:
 34514                                   	; Retro DOS v2.0 - 05/03/2018
 34515                                  check_signature_ok:
 34516                                  COALESCE_RETN:
 34517 0000626D C3                      	RETN
 34518                                  
 34519                                  ;**	Coalesce - Combine free blocks ahead with current block
 34520                                  ;----------------------------------------------------------------------------
 34521                                  ;	Coalesce adds the block following the argument to the argument block,
 34522                                  ;	iff it's free.  Coalesce is usually used to join free blocks, but
 34523                                  ;	some callers (such as $setblock) use it to join a free block to it's
 34524                                  ;	preceeding allocated block.
 34525                                  ;
 34526                                  ;	ENTRY	(ds) = pointer to the head of a free block
 34527                                  ;		(di) = 0
 34528                                  ;	EXIT	'C' clear if OK
 34529                                  ;		  (ds) unchanged, this block updated
 34530                                  ;		  (ax) = address of next block, IFF not at end
 34531                                  ;		'C' set if arena trashed
 34532                                  ;	USES	(cx)
 34533                                  ;----------------------------------------------------------------------------
 34534                                          
 34535                                  Coalesce:
 34536                                  	;cmp	byte [di],5Ah ; 'Z'
 34537 0000626E 803D5A                  	CMP     BYTE [DI],arena_signature_end
 34538                                                                          ; IF current signature = END THEN
 34539                                          ;retz				;   GOTO ok
 34540 00006271 74FA                            jz	short COALESCE_RETN
 34541 00006273 E8E1FF                  	CALL    arena_next              ; ES, AX <- next block, Carry set if error
 34542                                          ;retc				; IF no error THEN GOTO check
 34543 00006276 72F5                    	jc	short COALESCE_RETN
 34544                                  
 34545                                  coalesce_check:
 34546                                  	;cmp	[es:1],di
 34547 00006278 26393E0100                      CMP     [ES:ARENA.OWNER],DI
 34548                                          ;retnz				; IF next block isnt free THEN return
 34549 0000627D 75EE                            JNZ	SHORT COALESCE_RETN
 34550                                  	;mov	cx,[ES:3]
 34551 0000627F 268B0E0300              	MOV     CX,[ES:ARENA.SIZE]	; CX <- next block size
 34552 00006284 41                              INC     CX                      ; CX <- CX + 1 (for header size)
 34553                                          ;ADD	[3],CX
 34554 00006285 010E0300                	ADD     [ARENA.SIZE],CX		; current size <- current size + CX
 34555 00006289 268A0D                          MOV     CL,[ES:DI]              ; move up signature
 34556 0000628C 880D                            MOV     [DI],CL
 34557 0000628E EBDE                            JMP     SHORT Coalesce		; try again
 34558                                  
 34559                                  ; 04/08/2018 - Retro DOS v3.0
 34560                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 641Fh
 34561                                  
 34562                                  ;	BREAK  <$Alloc - allocate space in memory>
 34563                                  
 34564                                  ; MSDOS 6.0
 34565                                  ;----------------------------------------------------------------------------
 34566                                  ;**	$Alloc - Allocate Memory Space
 34567                                  ;
 34568                                  ;	$Alloc services the INT21 that allocates memory space to a program.
 34569                                  ;	Alloc returns a pointer to a free block of memory that
 34570                                  ;	has the requested size in paragraphs.
 34571                                  ;
 34572                                  ;	If the allocation strategy is HIGH_FIRST or HIGH_ONLY memory is 
 34573                                  ;	scanned from umb_head if not from arena_head. If the strategy is
 34574                                  ; 	HIGH_FIRST the scan is continued from arena_head if a block of 
 34575                                  ;	appropriate size is not found in the UMBs. If the strategy is 
 34576                                  ;	HIGH_FIRST+HIGH_ONLY only the UMBs are scanned for memory.
 34577                                  ;
 34578                                  ;	In either case if bit 0 of UmbFlag is not initialized then the scan
 34579                                  ;	starts from arena_head.
 34580                                  ;
 34581                                  ;	Assembler usage:
 34582                                  ;           MOV     BX,size
 34583                                  ;           MOV     AH,Alloc
 34584                                  ;           INT     21h
 34585                                  ;
 34586                                  ;	BUGBUG - a lot can be done to improve performance. We can set marks
 34587                                  ;	so that we start searching the arena at it's first non-trivial free
 34588                                  ;	block, we can peephole the code, etc. (We can move some subr calls
 34589                                  ;	inline, etc.) I assume that this is called rarely and that the arena
 34590                                  ;	doesn't have too many memory objects in it beyond the first free one.
 34591                                  ;	verify that this is true; if so, this can stay as is
 34592                                  ;
 34593                                  ;	ENTRY	(bx) = requested size, in bytes
 34594                                  ;		(DS) = (ES) = DOSGROUP
 34595                                  ;	EXIT	'C' clear if memory allocated
 34596                                  ;		  (ax:0) = address of requested memory
 34597                                  ;		'C' set if request failed
 34598                                  ;		  (AX) = error_not_enough_memory
 34599                                  ;		    (bx) = max size we could have allocated
 34600                                  ;		  (ax) = error_arena_trashed
 34601                                  ;	USES	All
 34602                                  ;----------------------------------------------------------------------------
 34603                                  
 34604                                  ; MSDOS 2.11 (& MSDOS 3.3)
 34605                                  ;----------------------------------------------------------------------------
 34606                                  ;SUBTTL $Alloc - allocate space in memory
 34607                                  ;
 34608                                  ;   Assembler usage:
 34609                                  ;           MOV     BX,size
 34610                                  ;           MOV     AH,Alloc
 34611                                  ;           INT     21h
 34612                                  ;         AX:0 is pointer to allocated memory
 34613                                  ;         BX is max size if not enough memory
 34614                                  ;
 34615                                  ;   Description:
 34616                                  ;           Alloc returns  a  pointer  to  a  free  block of
 34617                                  ;       memory that has the requested  size  in  paragraphs.
 34618                                  ;
 34619                                  ;   Error return:
 34620                                  ;           AX = error_not_enough_memory
 34621                                  ;              = error_arena_trashed
 34622                                  ;----------------------------------------------------------------------------
 34623                                  
 34624                                  ; DOSCODE:A28Eh (MSDOS 6.21, MSDOS.SYS)
 34625                                  
 34626                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 34627                                  ; DOSCODE:A22Eh (MSDOS 5.0, MSDOS.SYS)
 34628                                  
 34629                                  _$ALLOC:
 34630                                  	; 25/05/2019 (Procedure has been checked and confirmed)
 34631                                  	; 14/05/2019 - Retro DOS v4.0
 34632                                  	; 04/08/2018 - Retro DOS v3.0
 34633                                  	;EnterCrit critMem
 34634 00006290 E87AB0                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 34635                                  
 34636                                  ; 17/12/2022
 34637                                  ; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34638                                  ;%if 0
 34639                                  	; 14/05/2019
 34640 00006293 16                      	push	ss
 34641 00006294 1F                      	pop	ds
 34642                                  
 34643                                  	; MSDOS 6.0
 34644                                  	;mov	ax,[ss:arena_head]
 34645                                  	;mov	[ss:START_ARENA],ax	; assume LOW_FIRST
 34646                                  
 34647 00006295 A1[2400]                	mov	ax,[arena_head]
 34648 00006298 A3[8E00]                	mov	[START_ARENA],ax			
 34649                                  	
 34650                                  	;test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
 34651 0000629B F606[0203]C0            	test	byte [AllocMethod],HIGH_FIRST+HIGH_ONLY
 34652                                  					; Q: should we start scanning from 
 34653                                  					;    UMB's
 34654 000062A0 740D                    	jz	short norm_alloc	; N: scan from arena_head
 34655                                  		
 34656                                  	;;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
 34657                                  	;cmp	word [UMB_HEAD],-1
 34658                                  	;je	short norm_alloc	; N: scan from arena_head
 34659                                  
 34660                                  	;test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 34661 000062A2 F606[8900]01            	test	byte [UMBFLAG],LINKSTATE ; 1
 34662 000062A7 7406                    	jz	short norm_alloc	; N: scan from arena_head
 34663                                  	
 34664                                  	;mov	ax,[ss:UMB_HEAD]
 34665                                  	;mov	[ss:START_ARENA],ax	; start_arena = umb_head
 34666 000062A9 A1[8C00]                	mov	ax,[UMB_HEAD]
 34667 000062AC A3[8E00]                	mov	[START_ARENA],ax
 34668                                  					; M000 - end
 34669                                  norm_alloc:
 34670 000062AF 31C0                            XOR     AX,AX
 34671 000062B1 89C7                            MOV     DI,AX
 34672                                  	; 15/03/2018
 34673                                          ;MOV	[SS:FirstArena],AX	; init the options
 34674                                          ;MOV	[SS:BestArena],AX
 34675                                          ;MOV	[SS:LastArena],AX
 34676                                  	; 14/05/2019
 34677 000062B3 A3[4003]                	MOV	[FirstArena],AX		; init the options
 34678 000062B6 A3[4203]                        MOV	[BestArena],AX
 34679 000062B9 A3[4403]                        MOV	[LastArena],AX
 34680 000062BC 50                              PUSH    AX                      ; alloc_max <- 0
 34681                                  	; 04/08/2018
 34682                                  start_scan:
 34683                                  	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
 34684                                  	;MOV	AX,[arena_head]
 34685                                  
 34686                                  	; 14/05/2019	
 34687                                  	; MSDOS 6.0
 34688                                  	;mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
 34689 000062BD A1[8E00]                	mov	ax,[START_ARENA]
 34690                                  
 34691                                  	; 27/09/2023 (BugFix) (*) 
 34692                                  	; ( jump from 'alloc_chk' (ds<>ss, ax = [SS:START_ARENA]))
 34693                                  start_scan_x:
 34694                                  
 34695 000062C0 E89BFF                  	CALL    check_signature         ; ES <- AX, carry set if error
 34696 000062C3 7236                            JC      SHORT alloc_err		; IF error THEN GOTO err
 34697                                  
 34698                                  ;%endif
 34699                                  
 34700                                  ; 17/12/2022
 34701                                  %if 0
 34702                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34703                                  
 34704                                  	; MSDOS 6.0
 34705                                  	mov	ax,[ss:arena_head]
 34706                                  	mov	[ss:START_ARENA],ax	; assume LOW_FIRST
 34707                                  
 34708                                  	test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
 34709                                  					; Q: should we start scanning from 
 34710                                  					;    UMB's
 34711                                  	jz	short norm_alloc	; N: scan from arena_head
 34712                                  		
 34713                                  	;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
 34714                                  	;je	short norm_alloc	; N: scan from arena_head
 34715                                  
 34716                                  	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 34717                                  	jz	short norm_alloc	; N: scan from arena_head
 34718                                  	
 34719                                  	mov	ax,[ss:UMB_HEAD]
 34720                                  	mov	[ss:START_ARENA],ax	; start_arena = umb_head
 34721                                  					; M000 - end
 34722                                  norm_alloc:
 34723                                          XOR     AX,AX
 34724                                          MOV     DI,AX
 34725                                  	; 15/03/2018
 34726                                  	MOV	[SS:FirstArena],AX	; init the options
 34727                                  	MOV	[SS:BestArena],AX
 34728                                  	MOV	[SS:LastArena],AX
 34729                                          PUSH    AX                      ; alloc_max <- 0
 34730                                  	; 04/08/2018
 34731                                  start_scan:
 34732                                  	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
 34733                                  	; 14/05/2019	
 34734                                  	; MSDOS 6.0
 34735                                  	mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
 34736                                  	CALL    check_signature         ; ES <- AX, carry set if error
 34737                                          JC      SHORT alloc_err		; IF error THEN GOTO err
 34738                                  %endif
 34739                                  
 34740                                  alloc_scan:
 34741 000062C5 06                              PUSH    ES
 34742 000062C6 1F                              POP     DS                      ; DS <- ES
 34743 000062C7 393E0100                        CMP     [ARENA.OWNER],DI ; 0
 34744 000062CB 7469                            JZ      SHORT alloc_free	; IF current block is free THEN examine
 34745                                  
 34746                                  alloc_next:
 34747                                  	; MSDOS 6.0			; M000 - start 
 34748 000062CD 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 34749 000062D3 741C                    	jz	short norm_strat	; N: see if we reached last arena
 34750                                  	
 34751 000062D5 36F606[0203]80          	test	byte [ss:AllocMethod],HIGH_FIRST
 34752                                  					; Q: is alloc strategy high_first
 34753 000062DB 7414                    	jz	short norm_strat	; N: see if we reached last arena
 34754 000062DD 36A1[8E00]              	mov	ax,[ss:START_ARENA]
 34755 000062E1 363B06[2400]            	cmp	ax,[ss:arena_head]	; Q: did we start scan from 
 34756                                  					;    arena_head
 34757 000062E6 7509                    	jne	short norm_strat	; N: see if we reached last arena
 34758 000062E8 8CD8                    	mov	ax,ds			; ax = current block
 34759 000062EA 363B06[8C00]            	cmp	ax,[ss:UMB_HEAD]	; Q: check against umb_head 
 34760 000062EF EB03                    	jmp	short alloc_chk_end
 34761                                  
 34762                                  norm_strat:
 34763                                  	;cmp	byte [di],5Ah ; 'Z'
 34764 000062F1 803D5A                          CMP     BYTE [DI],arena_signature_end
 34765                                                                          ; IF current block is last THEN
 34766                                  alloc_chk_end:
 34767 000062F4 740E                            JZ      SHORT alloc_end		;   GOTO end
 34768 000062F6 E85EFF                          CALL    arena_next              ; AX, ES <- next block, Carry set if error
 34769 000062F9 73CA                            JNC     SHORT alloc_scan	; IF no error THEN GOTO scan
 34770                                  
 34771                                  alloc_err:
 34772 000062FB 58                              POP     AX
 34773                                  
 34774                                  alloc_trashed:
 34775                                  	;LeaveCrit critMem
 34776 000062FC E829B0                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0	
 34777                                          ;error	error_arena_trashed
 34778                                  	;mov	al,7
 34779 000062FF B007                    	MOV	AL,error_arena_trashed
 34780                                  alloc_errj:
 34781 00006301 E93CA3                  	JMP	SYS_RET_ERR
 34782                                  
 34783                                  alloc_end:
 34784                                  	; 18/05/2019
 34785 00006304 36833E[4003]00                  CMP	WORD [SS:FirstArena],0
 34786 0000630A 7403                    	jz	short alloc_chk 
 34787 0000630C E98400                  	jmp	alloc_do_split
 34788                                  
 34789                                  alloc_chk:
 34790                                  	; MSDOS 6.0
 34791 0000630F 36A1[2400]              	mov	ax,[ss:arena_head]
 34792 00006313 363B06[8E00]            	cmp	ax,[ss:START_ARENA]	; Q: started scanning from arena_head
 34793 00006318 740E                    	je	short alloc_fail	; Y: not enough memory
 34794                                  					; N:
 34795                                  					; Q: is the alloc strat HIGH_ONLY
 34796 0000631A 36F606[0203]40          	test 	byte [ss:AllocMethod],HIGH_ONLY
 34797 00006320 7506                    	jnz	short alloc_fail	; Y: return size of largest UMB
 34798                                  	
 34799 00006322 36A3[8E00]              	mov	[ss:START_ARENA],ax	; N: start scanning from arena_head
 34800                                  	; 27/09/2023 (*)
 34801 00006326 EB98                    	jmp	short start_scan_x ; (*) ; (BugFix)
 34802                                  	;jmp	short start_scan
 34803                                  					; M000 - end
 34804                                  
 34805                                  alloc_fail:
 34806                                          ;invoke Get_User_Stack
 34807 00006328 E856A1                          CALL	Get_User_Stack
 34808 0000632B 5B                      	POP     BX
 34809                                          ;MOV	[SI].user_BX,BX
 34810                                  	;MOV	[SI+2],BX
 34811 0000632C 895C02                  	mov	[SI+user_env.user_BX],bx
 34812                                  	;LeaveCrit critMem
 34813 0000632F E8F6AF                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 34814                                  	;error	error_not_enough_memory
 34815                                  	;mov	al,8
 34816 00006332 B008                    	MOV	AL,error_not_enough_memory
 34817                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34818 00006334 EBCB                    	jmp	short alloc_errj
 34819                                  	;JMP	SYS_RET_ERR
 34820                                  
 34821                                  alloc_free:
 34822 00006336 E835FF                          CALL    Coalesce		; add following free block to current
 34823 00006339 72C0                            JC	SHORT alloc_err		; IF error THEN GOTO err
 34824 0000633B 8B0E0300                        MOV     CX,[ARENA.SIZE]
 34825 0000633F 5A                              POP     DX                      ; check for max found size
 34826 00006340 39D1                            CMP     CX,DX
 34827 00006342 7602                            JNA     SHORT alloc_test
 34828 00006344 89CA                            MOV     DX,CX
 34829                                  
 34830                                  alloc_test:
 34831 00006346 52                              PUSH    DX
 34832 00006347 39CB                            CMP     BX,CX                   ; IF BX > size of current block THEN
 34833 00006349 7782                    	JA      SHORT alloc_next	;   GOTO next
 34834                                  
 34835                                  	; 15/03/2018
 34836 0000634B 36833E[4003]00                  CMP     WORD [SS:FirstArena],0
 34837 00006351 7505                    	JNZ	SHORT alloc_best
 34838 00006353 368C1E[4003]                    MOV     [SS:FirstArena],DS	; save first one found	
 34839                                  alloc_best:
 34840 00006358 36833E[4203]00                  CMP     WORD [SS:BestArena],0
 34841 0000635E 740E                            JZ      SHORT alloc_make_best	; initial best
 34842 00006360 06                              PUSH	ES
 34843 00006361 368E06[4203]                    MOV     ES,[SS:BestArena]
 34844 00006366 26390E0300                      CMP     [ES:ARENA.SIZE],CX	; is size of best larger than found?
 34845 0000636B 07                              POP	ES
 34846 0000636C 7605                            JBE     SHORT alloc_last
 34847                                  alloc_make_best:
 34848 0000636E 368C1E[4203]                    MOV     [SS:BestArena],DS	; assign best
 34849                                  alloc_last:
 34850 00006373 368C1E[4403]                    MOV     [SS:LastArena],DS 	; assign last
 34851 00006378 E952FF                          JMP     alloc_next
 34852                                  ;
 34853                                  ; split the block high
 34854                                  ;
 34855                                  alloc_do_split_high:
 34856 0000637B 368E1E[4403]                    MOV     DS,[SS:LastArena]
 34857 00006380 8B0E0300                        MOV     CX,[ARENA.SIZE]
 34858 00006384 29D9                            SUB     CX,BX
 34859 00006386 8CDA                            MOV     DX,DS
 34860 00006388 7449                            JE      SHORT alloc_set_owner	; sizes are equal, no split
 34861 0000638A 01CA                            ADD     DX,CX                   ; point to next block
 34862 0000638C 8EC2                            MOV     ES,DX                   ; no decrement!
 34863 0000638E 49                              DEC     CX
 34864 0000638F 87D9                            XCHG    BX,CX                   ; bx has size of lower block
 34865 00006391 EB2B                            JMP     SHORT alloc_set_sizes	; cx has upper (requested) size
 34866                                  ;
 34867                                  ; we have scanned memory and have found all appropriate blocks
 34868                                  ; check for the type of allocation desired; first and best are identical
 34869                                  ; last must be split high
 34870                                  ;
 34871                                  alloc_do_split:
 34872                                  
 34873                                  ; 17/12/2022
 34874                                  ; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34875                                  ;%if 0
 34876                                  	; 14/05/2019
 34877                                  	; MSDOS 6.0			; M000 - start
 34878                                  	;xor	cx,cx
 34879 00006393 368A0E[0203]            	mov	cl,[ss:AllocMethod]
 34880                                  	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
 34881 00006398 80E13F                  	and	cl,3Fh
 34882                                  	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
 34883 0000639B 80F901                  	cmp	cl,BEST_FIT
 34884 0000639E 77DB                    	ja	short alloc_do_split_high
 34885                                  ;%endif
 34886                                  
 34887                                  	; 17/12/2022
 34888                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34889                                  	; MSDOS 6.0 & MSDOS 5.0
 34890                                  	;xor	cx,cx
 34891                                  	;mov	cl,[ss:AllocMethod]
 34892                                  	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
 34893                                  	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
 34894                                  	;ja	short alloc_do_split_high
 34895                                  
 34896                                  	; 15/03/2018
 34897                                          ;;CMP	BYTE [SS:AllocMethod], 1
 34898                                  	; 04/08/2018
 34899                                  	;CMP	BYTE [SS:AllocMethod],BEST_FIT
 34900                                          ;JA	SHORT alloc_do_split_high
 34901                                          
 34902 000063A0 368E1E[4003]            	MOV     DS,[SS:FirstArena]        
 34903 000063A5 7205                    	JB      SHORT alloc_get_size
 34904 000063A7 368E1E[4203]            	MOV     DS,[SS:BestArena]
 34905                                  
 34906                                  alloc_get_size:
 34907 000063AC 8B0E0300                        MOV     CX,[ARENA.SIZE]
 34908 000063B0 29D9                            SUB     CX,BX                   ; get room left over
 34909 000063B2 8CD8                            MOV     AX,DS
 34910 000063B4 89C2                            MOV     DX,AX                   ; save for owner setting
 34911 000063B6 741B                            JE      SHORT alloc_set_owner	; IF BX = size THEN (don't split)
 34912 000063B8 01D8                            ADD     AX,BX
 34913 000063BA 40                              INC     AX                      ; remember the header
 34914 000063BB 8EC0                            MOV     ES,AX                   ; ES <- DS + BX (new header location)
 34915 000063BD 49                              DEC     CX                      ; CX <- size of split block
 34916                                  alloc_set_sizes:
 34917 000063BE 891E0300                        MOV     [ARENA.SIZE],BX		; current size <- BX
 34918 000063C2 26890E0300                      MOV     [ES:ARENA.SIZE],CX      ; split size <- CX
 34919                                  	;mov	bl,4Dh ; 'M'
 34920 000063C7 B34D                            MOV     BL,arena_signature_normal
 34921 000063C9 861D                            XCHG    BL,[DI]			; current signature <- 4D
 34922 000063CB 26881D                          MOV     [ES:DI],BL		; new block sig <- old block sig
 34923 000063CE 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 34924                                  
 34925                                  alloc_set_owner:
 34926 000063D3 8EDA                            MOV     DS,DX
 34927 000063D5 36A1[3003]                      MOV     AX,[SS:CurrentPDB] ; 15/03/2018
 34928 000063D9 A30100                          MOV     [ARENA.OWNER],AX
 34929 000063DC 8CD8                            MOV     AX,DS
 34930 000063DE 40                              INC     AX
 34931 000063DF 5B                              POP     BX
 34932                                  	;LeaveCrit critMem
 34933 000063E0 E845AF                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 34934                                  	
 34935                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34936                                  alloc_ok:
 34937                                          ;transfer SYS_RET_OK
 34938 000063E3 E951A2                  	JMP	SYS_RET_OK
 34939                                  
 34940                                  ;	BREAK $SETBLOCK - change size of an allocated block (if possible)
 34941                                  
 34942                                  ; MSDOS 6.0
 34943                                  ;----------------------------------------------------------------------------
 34944                                  ;**	$SETBLOCK - Change size of an Allocated Block
 34945                                  ;
 34946                                  ;	Setblock changes the size of an allocated block. First, we coalesce
 34947                                  ;	any following free space onto this block; then we try to trim the
 34948                                  ;	block down to the size requested.
 34949                                  ;
 34950                                  ;	Note that if the guy wants to grow the block but that growth fails,
 34951                                  ;	we still go ahead and coalesce any trailing free blocks onto it.
 34952                                  ;	Thus the maximum-size-possible value that we return has already
 34953                                  ;	been allocated! This is a bug, dare we fix it? BUGBUG
 34954                                  ;
 34955                                  ;	NOTE - $SETBLOCK is in bed with $ALLOC and jumps into $ALLOC to
 34956                                  ;		finish it's work. For this reason we build the allocsf
 34957                                  ;		structure on the frame, to make us compatible with $ALLOCs
 34958                                  ;		code.
 34959                                  ;
 34960                                  ;	ENTRY	(es) = segment of old block
 34961                                  ;		(bx) = newsize
 34962                                  ;		(ah) = SETBLOCK
 34963                                  ;
 34964                                  ;	EXIT	'C' clear if OK
 34965                                  ;		'C' set if error
 34966                                  ;		  (ax) = error_invalid_block
 34967                                  ;		       = error_arena_trashed
 34968                                  ;		       = error_not_enough_memory
 34969                                  ;		       = error_invalid_function
 34970                                  ;		  (bx) = maximum size possible, iff (ax) = error_not_enough_memory
 34971                                  ;	USES	???? BUGBUG
 34972                                  ;----------------------------------------------------------------------------
 34973                                  
 34974                                  ; MSDOS 2.11 (& MSDOS 3.3)
 34975                                  ;----------------------------------------------------------------------------
 34976                                  ;SUBTTL $SETBLOCK - change size of an allocated block (if possible)
 34977                                  ;
 34978                                  ;   Assembler usage:
 34979                                  ;           MOV     ES,block
 34980                                  ;           MOV     BX,newsize
 34981                                  ;           MOV     AH,setblock
 34982                                  ;           INT     21h
 34983                                  ;         if setblock fails for growing, BX will have the maximum
 34984                                  ;         size possible
 34985                                  ;   Error return:
 34986                                  ;           AX = error_invalid_block
 34987                                  ;              = error_arena_trashed
 34988                                  ;              = error_not_enough_memory
 34989                                  ;              = error_invalid_function
 34990                                  ;----------------------------------------------------------------------------
 34991                                  
 34992                                  _$SETBLOCK:        
 34993                                  	; 04/08/2018 - Retro DOS v3.0
 34994                                  	;EnterCrit   critMem
 34995 000063E6 E824AF                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 34996                                  
 34997 000063E9 BF0000                  	MOV     DI,ARENA.SIGNATURE
 34998 000063EC 8CC0                            MOV     AX,ES
 34999 000063EE 48                              DEC     AX
 35000 000063EF E86CFE                          CALL    check_signature
 35001 000063F2 7303                            JNC     SHORT setblock_grab
 35002                                  
 35003                                  setblock_bad:
 35004 000063F4 E905FF                          JMP     alloc_trashed
 35005                                  
 35006                                  setblock_grab:
 35007 000063F7 8ED8                            MOV     DS,AX
 35008 000063F9 E872FE                          CALL    Coalesce
 35009 000063FC 72F6                            JC      SHORT setblock_bad
 35010 000063FE 8B0E0300                        MOV     CX,[ARENA.SIZE]
 35011 00006402 51                              PUSH    CX
 35012 00006403 39CB                            CMP     BX,CX
 35013 00006405 76A5                            JBE     SHORT alloc_get_size
 35014 00006407 E91EFF                          JMP     alloc_fail
 35015                                  
 35016                                  ;	BREAK $DEALLOC - free previously allocated piece of memory
 35017                                  
 35018                                  ; MSDOS 6.0
 35019                                  ;----------------------------------------------------------------------------
 35020                                  ;**	$DEALLOC - Free Heap Memory
 35021                                  ;
 35022                                  ;	ENTRY	(es) = address of item
 35023                                  ;
 35024                                  ;	EXIT	'C' clear of OK
 35025                                  ;		'C' set if error
 35026                                  ;		  (AX) = error_invalid_block
 35027                                  ;	USES	???? BUGBUG
 35028                                  
 35029                                  ; MSDOS 2.11 (& MSDOS 3.3)
 35030                                  ;----------------------------------------------------------------------------
 35031                                  ;SUBTTL $DEALLOC - free previously allocated piece of memory
 35032                                  ;
 35033                                  ;   Assembler usage:
 35034                                  ;           MOV     ES,block
 35035                                  ;           MOV     AH,dealloc
 35036                                  ;           INT     21h
 35037                                  ;
 35038                                  ;   Error return:
 35039                                  ;           AX = error_invalid_block
 35040                                  ;              = error_arena_trashed
 35041                                  ;---------------------------------------------------------------------------- 
 35042                                  
 35043                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35044                                  _$DEALLOC:
 35045                                  	; 14/05/2019 - Retro DOS v4.0    
 35046                                  	; 04/08/2018 - Retro DOS v3.0
 35047                                  	;EnterCrit   critMem
 35048 0000640A E800AF                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 35049                                  
 35050                                  	; MSDOS 6.0			; M016, M068 - Start
 35051 0000640D 36F606[8600]04          	test	byte [ss:DOS_FLAG],EXECA20OFF
 35052                                  					; Q: was the previous call an int 21
 35053                                  					;    exec call
 35054 00006413 740D                    	jz	short deallocate	; N: continue
 35055 00006415 36803E[8500]00          	cmp	byte [ss:A20OFF_COUNT], 0 ; Q: is count 0
 35056 0000641B 7505                    	jne	short deallocate	; N: continue
 35057                                  	;mov	byte [ss:A20OFF_COUNT], 1 ; Y: set count to 1
 35058                                  	; 25/09/2023
 35059 0000641D 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]
 35060                                  deallocate:				; M016, M068 - End
 35061 00006422 BF0000                  	MOV     DI,ARENA.SIGNATURE ; = 0
 35062 00006425 8CC0                            MOV     AX,ES
 35063 00006427 48                              DEC     AX
 35064 00006428 E833FE                          CALL    check_signature
 35065 0000642B 720A                            JC      SHORT dealloc_err
 35066 0000642D 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 35067                                  	;LeaveCrit critMem
 35068 00006432 E8F3AE                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 35069                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35070                                          ;transfer SYS_RET_OK
 35071                                  dealloc_ok:
 35072 00006435 EBAC                    	jmp	short alloc_ok
 35073                                  	;JMP	SYS_RET_OK
 35074                                  
 35075                                  dealloc_err:
 35076                                  	;LeaveCrit critMem
 35077 00006437 E8EEAE                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 35078                                          ;error	error_invalid_block
 35079                                  	;mov	al,9
 35080 0000643A B009                    	MOV	AL,error_invalid_block
 35081                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35082                                  dealloc_errj:
 35083                                  AllocOperErrj:	; 17/12/2022
 35084 0000643C E901A2                  	JMP	SYS_RET_ERR
 35085                                  
 35086                                  ;	BREAK $AllocOper - get/set allocation mechanism
 35087                                  
 35088                                  ; MSDOS 6.0
 35089                                  ;----------------------------------------------------------------------------
 35090                                  ;**	$AllocOper - Get/Set Allocation Mechanism
 35091                                  ;
 35092                                  ;	Assembler usage:
 35093                                  ;           MOV     AH,AllocOper
 35094                                  ;           MOV     BX,method
 35095                                  ;           MOV     AL,func
 35096                                  ;           INT     21h
 35097                                  ;
 35098                                  ;	ENTRY	
 35099                                  ;		(al) = 0
 35100                                  ;		  Get allocation Strategy in (ax)
 35101                                  ;
 35102                                  ;		(al) = 1, (bx) = method = zw0000xy
 35103                                  ;		  Set allocation strategy.
 35104                                  ;		   w  = 1  => HIGH_ONLY
 35105                                  ;		   z  = 1  => HIGH_FIRST
 35106                                  ;		   xy = 00 => FIRST_FIT
 35107                                  ;		      = 01 => BEST_FIT
 35108                                  ;		      = 10 => LAST_FIT
 35109                                  ;
 35110                                  ;		(al) = 2
 35111                                  ;		  Get UMB link state in (al)
 35112                                  ;
 35113                                  ;		(al) = 3
 35114                                  ;		  Set UMB link state
 35115                                  ;		   (bx) = 0 => Unlink UMBs
 35116                                  ;		   (bx) = 1 => Link UMBs
 35117                                  ;
 35118                                  ;
 35119                                  ;	EXIT	'C' clear if OK
 35120                                  ;
 35121                                  ;		 if (al) = 0
 35122                                  ;		  (ax) = existing method
 35123                                  ;		 if (al) = 1
 35124                                  ;		  Sets allocation strategy
 35125                                  ;		 if (al) = 2
 35126                                  ;		  (al) = 0 => UMBs not linked
 35127                                  ;		  (al) = 1 => UMBs linked in
 35128                                  ;		 if (al) = 3
 35129                                  ;		  Links/Unlinks the UMBs into DOS chain
 35130                                  ;
 35131                                  ;		'C' set if error
 35132                                  ;		  AX = error_invalid_function
 35133                                  ;
 35134                                  ;	Rev. M000 - added support for HIGH_FIRST in (al) = 1. 7/9/90
 35135                                  ; 	Rev. M003 - added functions (al) = 2 and (al) = 3. 7/18/90
 35136                                  ;	Rev. M009 - (al) = 3 will return 'invalid function' in ax if
 35137                                  ;		    umbhead has'nt been initialized by sysinit and 'trashed
 35138                                  ;		    arena' if an arena sig is damaged.
 35139                                  ;----------------------------------------------------------------------------
 35140                                  
 35141                                  ; MSDOS 2.11 (& MSDOS 3.3)
 35142                                  ;----------------------------------------------------------------------------
 35143                                  ;SUBTTL $AllocOper - get/set allocation mechanism
 35144                                  ;
 35145                                  ;   Assembler usage:
 35146                                  ;           MOV     AH,AllocOper
 35147                                  ;           MOV     BX,method
 35148                                  ;           MOV     AL,func
 35149                                  ;           INT     21h
 35150                                  ;
 35151                                  ;   Error return:
 35152                                  ;           AX = error_invalid_function
 35153                                  ;----------------------------------------------------------------------------
 35154                                  
 35155                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35156                                  _$ALLOCOPER:
 35157                                  	; 14/05/2019 - Retro DOS v4.0
 35158                                  	; MSDOS 6.0
 35159 0000643F 08C0                    	or	al,al ; 0
 35160 00006441 741E                    	jz	short AllocGetStrat
 35161                                  	; 17/12/2022
 35162                                  	;cmp	al,1
 35163                                  	;jz	short AllocSetStrat
 35164                                  
 35165                                  	; 01/12/2022
 35166                                  	;cmp	al, 2
 35167                                  	;jb	short AllocSetStrat
 35168                                  	;ja	short AllocSetLink
 35169                                  	;;jmp	short AllocGetLink
 35170                                  ;AllocGetLink:
 35171                                  	; MSDOS 6.0
 35172                                  	;mov	al,[ss:UMBFLAG]		; return link state in al
 35173                                  	;and 	al,LINKSTATE		
 35174                                  	;;transfer SYS_RET_OK
 35175                                  	;jmp	SYS_RET_OK
 35176                                  
 35177 00006443 3C02                    	cmp	al,2
 35178                                  	; 17/12/2022
 35179 00006445 7223                    	jb	short AllocSetStrat ; al = 1
 35180 00006447 7432                    	je	short AllocGetLink
 35181                                  
 35182                                  	;cmp	al,2
 35183                                  	;jz	short AllocGetLink
 35184 00006449 3C03                    	cmp	al,3
 35185 0000644B 7436                    	jz	short AllocSetLink
 35186                                  
 35187                                  	; 15/04/2018
 35188                                  	;CMP	AL,1
 35189                                          ;JB	SHORT AllocOperGet
 35190                                          ;JZ	SHORT AllocOperSet
 35191                                  
 35192                                  AllocOperError:
 35193                                  	; 04/08/2018 - Retro DOS v3.0
 35194                                  	; MSDOS 3.3 (& MSDOS 6.0)	; Extended Error Locus	
 35195                                  	;mov	byte [ss:EXTERR_LOCUS],5
 35196 0000644D 36C606[2303]05                  MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 35197                                  	;error	error_invalid_function
 35198                                  	;mov	al,1
 35199 00006453 B001                    	MOV	AL,error_invalid_function
 35200                                  	; 17/12/2022
 35201                                  ;AllocOperErrj:
 35202                                  	;JMP	SYS_RET_ERR
 35203                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35204                                  	;jmp	short dealloc_errj
 35205                                  	; 17/12/2022
 35206 00006455 EBE5                    	jmp	short AllocOperErrj
 35207                                  
 35208                                  AllocArenaError:
 35209                                  	; MSDOS 6.0
 35210 00006457 36C606[2303]05          	MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 35211                                  					; M009: Extended Error Locus
 35212                                  	;error	error_arena_trashed	; M009:
 35213                                  	;mov	al,7
 35214 0000645D B007                    	MOV	AL,error_arena_trashed
 35215                                  	;JMP	SYS_RET_ERR
 35216 0000645F EBDB                    	jmp	short AllocOperErrj ; 17/12/2022
 35217                                  
 35218                                  AllocGetStrat: 
 35219                                  	; MSDOS 6.0
 35220                                  AllocOperGet:
 35221 00006461 36A0[0203]                      MOV     AL,[SS:AllocMethod]
 35222 00006465 30E4                            XOR     AH,AH
 35223                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35224                                  	;transfer SYS_RET_OK
 35225                                  AllocOperOk:
 35226                                  	; 17/12/2022
 35227                                  	;jmp	short dealloc_ok
 35228 00006467 E9CDA1                  	JMP	SYS_RET_OK
 35229                                  
 35230                                  AllocSetStrat: 
 35231                                  	; 14/05/2019
 35232                                  	; MSDOS 6.0
 35233 0000646A 53                      	push	bx			; M000 - start
 35234                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35235                                  	;and	bx,STRAT_MASK ; 0FF3Fh	; M064: mask off bit 6 & 7
 35236                                  	; 17/12/2022
 35237 0000646B 80E33F                  	and	bl,3Fh
 35238 0000646E 83FB02                  	cmp	bx,2			; BX must be 0-2
 35239                                  	;cmp	bl,2
 35240 00006471 5B                      	pop	bx			; M000 - end
 35241 00006472 77D9                    	ja	short AllocOperError
 35242                                  
 35243                                  AllocOperSet:
 35244 00006474 36881E[0203]                    MOV     [SS:AllocMethod],BL
 35245                                    	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35246                                  	;transfer SYS_RET_OK
 35247                                  AllocOperOkj:
 35248 00006479 EBEC                    	jmp	short AllocOperOk
 35249                                  	;JMP	SYS_RET_OK
 35250                                  
 35251                                  AllocGetLink:
 35252                                  	; MSDOS 6.0
 35253 0000647B 36A0[8900]              	mov	al,[ss:UMBFLAG]		; return link state in al
 35254                                  	;and	al,1
 35255 0000647F 2401                    	and 	al,LINKSTATE		
 35256                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35257                                  	;transfer SYS_RET_OK
 35258                                  AllocOperOkj2:
 35259                                  	; 17/12/2022
 35260 00006481 EBE4                    	jmp	short AllocOperOk
 35261                                  	;jmp	short AllocOperOkj
 35262                                  	;;JMP	SYS_RET_OK
 35263                                  
 35264                                  AllocSetLink:
 35265                                  	; MSDOS 6.0			; M009 - start
 35266 00006483 368B0E[8C00]            	mov	cx,[ss:UMB_HEAD]	; cx = umb_head
 35267 00006488 83F9FF                  	cmp	cx,0FFFFh		; Q: has umb_head been initialized
 35268 0000648B 74C0                    	je	short AllocOperError	; N: error
 35269                                  					; Y: continue
 35270                                  					; M009 - end
 35271 0000648D 83FB01                  	cmp	bx,1			
 35272 00006490 7204                    	jb	short UnlinkUmbs
 35273 00006492 741C                    	jz	short LinkUmbs
 35274                                  	
 35275 00006494 EBB7                    	jmp	short AllocOperError
 35276                                  	
 35277                                  UnlinkUmbs:
 35278                                  	;test	byte [ss:UMBFLAG],1
 35279 00006496 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs unlinked?
 35280 0000649C 7410                    	jz	short unlinked		; Y: return 
 35281                                  	
 35282 0000649E E82900                  	call	GetLastArena		; get arena before umb_head in DS
 35283 000064A1 72B4                    	jc	short AllocArenaError	; M009: arena trashed
 35284                                  	
 35285                                  					; make it last
 35286 000064A3 C60600005A              	mov	byte [0],arena_signature_end
 35287                                  	
 35288                                  	;and	byte [ss:UMBFLAG],0FEh
 35289 000064A8 368026[8900]FE          	and	byte [ss:UMBFLAG],~LINKSTATE ; indicate unlink'd state in umbflag
 35290                                  	
 35291                                  unlinked:
 35292                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35293                                  	;transfer SYS_RET_OK
 35294                                  	; 17/12/2022
 35295 000064AE EBB7                    	jmp	short AllocOperOk
 35296                                  	;jmp	short AllocOperOkj2
 35297                                  	;;JMP	SYS_RET_OK
 35298                                  
 35299                                  LinkUmbs:
 35300 000064B0 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs linked?
 35301 000064B6 7510                    	jnz	short linked		; Y: return
 35302                                  	
 35303 000064B8 E80F00                  	call	GetLastArena		; get arena before umb_head
 35304 000064BB 729A                    	jc	short AllocArenaError	; M009: arena trashed
 35305                                  	
 35306                                  					; make it normal. M061: ds points to
 35307                                  					; arena before umb_head
 35308 000064BD C60600004D              	mov	byte [0],arena_signature_normal
 35309                                  	
 35310 000064C2 36800E[8900]01          	or	byte [ss:UMBFLAG],LINKSTATE ; indicate link'd state in umbflag
 35311                                  linked:
 35312                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35313                                  	;transfer SYS_RET_OK
 35314                                  	; 17/12/2022
 35315 000064C8 EB9D                    	jmp	short AllocOperOk
 35316                                  	;jmp	short unlinked
 35317                                  	;;JMP	SYS_RET_OK
 35318                                  
 35319                                  ; MSDOS 6.0
 35320                                  ;--------------------------------------------------------------------------
 35321                                  ; Procedure Name : GetLastArena		-  M003
 35322                                  ;
 35323                                  ; Inputs	 : cx = umb_head
 35324                                  ;
 35325                                  ;
 35326                                  ; Outputs	 : If UMBs are linked
 35327                                  ;			ES = umb_head
 35328                                  ;			DS = arena before umb_head
 35329                                  ;		   else
 35330                                  ;			DS = last arena
 35331                                  ;			ES = next arena. will be umb_head if NC.
 35332                                  ;
 35333                                  ;		   CY if error
 35334                                  ;
 35335                                  ; Uses		 : DS, ES, DI, BX
 35336                                  ;--------------------------------------------------------------------------
 35337                                  
 35338                                  ; 14/05/2019 - Retro DOS v4.0
 35339                                  ; DOSCODE:A4D6h (MSDOS 6.21, MSDOS.SYS)
 35340                                  
 35341                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35342                                  ; DOSCODE:A476h (MSDOS 5.0, MSDOS.SYS)
 35343                                  	
 35344                                  GetLastArena:
 35345 000064CA 50                      	push	ax			; save ax
 35346                                  
 35347 000064CB 36A1[2400]              	mov	ax,[ss:arena_head]
 35348 000064CF 8EC0                    	mov	es,ax			; es = arena_head
 35349 000064D1 31FF                    	xor	di,di
 35350                                  
 35351 000064D3 26803D5A                	cmp     byte [es:di],arena_signature_end
 35352                                  					; Q: is this the last arena
 35353 000064D7 7419                    	je	short GLA_done		; Y: return last arena in ES		
 35354                                  					
 35355                                  GLA_next:
 35356 000064D9 8ED8                    	mov	ds,ax
 35357 000064DB E879FD                  	call	arena_next		; ax, es -> next arena
 35358                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35359                                  	;jc	short GLA_err
 35360                                  	; 17/12/2022
 35361 000064DE 7228                    	jc	short GLA_err2
 35362                                  
 35363 000064E0 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
 35364 000064E6 7506                    	jnz	short GLA_chkumb	; Y: terminating condition is 
 35365                                  					;    umb_head
 35366                                  					; N: terminating condition is 05Ah
 35367                                  
 35368 000064E8 26803D5A                	cmp     byte [es:di],arena_signature_end
 35369                                  					; Q: is this the last arena
 35370 000064EC EB02                    	jmp	short GLA_@f
 35371                                  GLA_chkumb:
 35372 000064EE 39C8                    	cmp	ax,cx			; Q: is this umb_head
 35373                                  GLA_@f:
 35374 000064F0 75E7                    	jne	short GLA_next		; N: get next arena
 35375                                  
 35376                                  GLA_done:
 35377                                  					; M061 - Start
 35378 000064F2 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
 35379 000064F8 750B                    	jnz	short GLA_ret		; Y: we're done
 35380                                  					; N: let us confirm that the next 
 35381                                  					;    arena is umb_head
 35382 000064FA 8ED8                    	mov	ds,ax
 35383 000064FC E858FD                  	call	arena_next		; ax, es -> next arena
 35384                                  	;jc	short GLA_err
 35385 000064FF 7207                    	jc	short GLA_err2
 35386 00006501 39C8                    	cmp	ax,cx			; Q: is this umb_head
 35387 00006503 7502                    	jne	short GLA_err		; N: error
 35388                                  					; M061 - End
 35389                                  GLA_ret:
 35390                                  	; 17/12/2022				
 35391                                  	;clc
 35392                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35393                                  	;clc
 35394 00006505 58                      	pop	ax			; M061
 35395 00006506 C3                      	retn				; M061
 35396                                  
 35397                                  GLA_err:
 35398 00006507 F9                      	stc				; M061
 35399                                  GLA_err2:
 35400 00006508 58                      	pop	ax
 35401 00006509 C3                      	retn
 35402                                  
 35403                                  ;============================================================================
 35404                                  ; SRVCALL.ASM, MSDOS 6.0, 1991
 35405                                  ;============================================================================
 35406                                  ; 04/08/2018 - Retro DOS v3.0
 35407                                  
 35408                                  ;	TITLE SRVCALL - Server DOS call
 35409                                  ;	NAME  SRVCALL
 35410                                  
 35411                                  ;**	SRVCALL.ASM - Server DOS call functions
 35412                                  ;
 35413                                  ;
 35414                                  ;	$ServerCall
 35415                                  ;
 35416                                  ;	Modification history:
 35417                                  ;
 35418                                  ;	    Created: ARR 08 August 1983
 35419                                  
 35420                                  ;AsmVars <Installed>
 35421                                  
 35422                                  ;include dpl.asm
 35423                                  
 35424                                  ;Installed = TRUE
 35425                                  
 35426                                  ; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 35427                                  ; ---------------------------------------------------------------------------
 35428                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35429                                  
 35430                                  ;BREAK <ServerCall -- Server DOS call>
 35431                                  
 35432                                  ; DOSCODE:A517h (MSDOS 6.21, MSDOS.SYS)
 35433                                  ; DOSCODE:A4B7h (MSDOS 5.0, MSDOS.SYS)
 35434                                  
 35435                                  ;hkn; TABLE	SEGMENT
 35436                                  ;Public SRVC001S,SRVC001E
 35437                                  ;SRVC001S label byte
 35438                                  
 35439                                  SRVC001S:
 35440                                  
 35441 0000650A [0E65]                  SERVERTAB:	dw	SERVER_DISP
 35442 0000650C [6065]                  SERVERLEAVE:	dw	SERVERRETURN
 35443 0000650E 0B                      SERVER_DISP:	db	(SERVER_DISP_END-SERVER_DISP-1)/2 ; = 11
 35444 0000650F [C865]                  		dw	SRV_CALL	; 0
 35445 00006511 [6165]                  		dw	COMMIT_ALL	; 1
 35446 00006513 [9765]                  		dw	CLOSE_NAME	; 2
 35447 00006515 [A265]                  		dw	CLOSE_UID	; 3
 35448 00006517 [A965]                  		dw	CLOSE_UID_PID	; 4
 35449 00006519 [B065]                  		dw	GET_LIST	; 5
 35450 0000651B [0966]                  		dw	GET_DOS_DATA	; 6
 35451 0000651D [2D66]                  		dw	SPOOL_OPER	; 7
 35452 0000651F [2D66]                  		dw	SPOOL_OPER	; 8
 35453 00006521 [2D66]                  		dw	SPOOL_OPER	; 9
 35454 00006523 [3966]                  		dw	_$SetExtendedError  ; 10
 35455                                  
 35456                                  SERVER_DISP_END:  ;  LABEL BYTE
 35457                                  
 35458                                  ;SRVC001E label byte
 35459                                  
 35460                                  SRVC001E:
 35461                                  
 35462                                  ;hkn; TABLE	ENDS
 35463                                  
 35464                                  ;----------------------------------------------------------------------------
 35465                                  ;
 35466                                  ; Procedure Name : $ServerCall
 35467                                  ;
 35468                                  ; Inputs:
 35469                                  ;	DS:DX -> DPL  (except calls 7,8,9)
 35470                                  ; Function:
 35471                                  ;	AL=0	Server DOS call
 35472                                  ;	AL=1	Commit All files
 35473                                  ;	AL=2	Close file by name (SHARING LOADED ONLY) DS:DX in DPL -> name
 35474                                  ;	AL=3	Close all files for DPL_UID
 35475                                  ;	AL=4	Close all files for DPL_UID/PID_PID
 35476                                  ;	AL=5	Get open file list entry
 35477                                  ;		    IN: BX File Index
 35478                                  ;			CX User Index
 35479                                  ;		    OUT:ES:DI -> Name
 35480                                  ;			BX = UID
 35481                                  ;		    CX = # locked blocks held by this UID
 35482                                  ;	AL=6	Get DOS data area
 35483                                  ;		    OUT: DS:SI -> Start
 35484                                  ;			CX size in bytes of swap if indos
 35485                                  ;			DX size in bytes of swap always
 35486                                  ;	AL=7	Get truncate flag
 35487                                  ;	AL=8	Set truncate flag
 35488                                  ;	AL=9	Close all spool files
 35489                                  ;	AL=10	SetExtendedError
 35490                                  ;
 35491                                  ;----------------------------------------------------------------------------
 35492                                  
 35493                                  _$ServerCall:
 35494                                  	; 13/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35495                                  	; DOSCODE:A4D2h (MSDOS 5.0 MSDOS.SYS)		
 35496                                  	; 10/06/2019
 35497                                  	; 29/04/2019 - Retro DOS v4.0
 35498                                  	; DOSCODE:A532h (MSDOS 6.21 MSDOS.SYS)
 35499                                  
 35500                                  	; 05/08/2018 - Retro DOS v3.0
 35501                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 657Bh
 35502 00006525 3C07                    	CMP	AL,7
 35503 00006527 7204                    	JB	short SET_STUFF
 35504 00006529 3C09                    	CMP	AL,9
 35505 0000652B 761A                    	JBE	short NO_SET_ID		; No DPL on calls 7,8,9
 35506                                  SET_STUFF:
 35507 0000652D 89D6                    	MOV	SI,DX			; Point to DPL with DS:SI
 35508                                  	;mov	bx,[si+12h]
 35509 0000652F 8B5C12                  	MOV	BX,[SI+DPL.UID]
 35510                                  
 35511                                  	; MSDOS 6.0
 35512                                  ;SR;
 35513                                  ; WIN386 updates the USER_ID itself. If WIN386 is present we skip the updating
 35514                                  ; of USER_ID
 35515                                  
 35516 00006532 36F606[3010]01          	test	byte [SS:IsWin386],1
 35517 00006538 7505                    	jnz	short skip_win386
 35518                                  
 35519                                  ;hkn; SS override for user_id and proc_id
 35520                                  	; 15/08/2018
 35521 0000653A 36891E[3E03]            	MOV	[SS:USER_ID],BX		; Set UID
 35522                                  
 35523                                  skip_win386:
 35524 0000653F 8B5C14                  	MOV	BX,[SI+DPL.PID]
 35525 00006542 36891E[3C03]            	MOV	[SS:PROC_ID],BX		; Set process ID
 35526                                  NO_SET_ID:
 35527                                  	; 10/06/2019 - Retro DOS v4.0
 35528 00006547 2EFF36[0C65]            	PUSH	word [cs:SERVERLEAVE]	; push return address
 35529 0000654C 2EFF36[0A65]            	PUSH	word [cS:SERVERTAB]	; push table address
 35530 00006551 50                      	PUSH	AX
 35531 00006552 E8CBAC                  	call	TableDispatch
 35532                                  
 35533                                  ;hkn; SS override
 35534                                  	;mov 	byte [SS:EXETERR_LOCUS],1
 35535 00006555 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 35536                                  	;error	error_invalid_function
 35537                                  	;mov	al,1
 35538 0000655B B001                    	MOV	AL,error_invalid_function
 35539                                  servercall_error:
 35540 0000655D E9E0A0                  	JMP	SYS_RET_ERR
 35541                                  
 35542                                  SERVERRETURN:
 35543 00006560 C3                      	retn
 35544                                  
 35545                                  ; Commit - iterate through the open file list and make sure that the
 35546                                  ; directory entries are correctly updated.
 35547                                  
 35548                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35549                                  COMMIT_ALL:
 35550 00006561 31DB                    	XOR	BX,BX			;   for (i=0; ThisSFT=getSFT(i); i++)
 35551 00006563 16                      	push	ss
 35552 00006564 1F                      	pop	ds
 35553 00006565 E8A5AD                  	call	ECritSFT		; Gonna scan SFT cache, lock it down
 35554                                  CommitLoop:
 35555 00006568 53                      	push	bx
 35556 00006569 E82401                  	call	SFFromSFN
 35557 0000656C 7222                    	JC	short CommitDone
 35558 0000656E 26833D00                	cmp	word [es:di],0
 35559                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],0
 35560                                  					; if (ThisSFT->refcount != 0)
 35561 00006572 7418                    	JZ	short CommitNext
 35562                                  	;cmp	word [es:di],0FFFFh ; -1
 35563 00006574 26833DFF                	cmp	word [ES:DI],sf_busy
 35564                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],sf_busy  
 35565                                  					; BUSY SFTs have god knows what
 35566 00006578 7412                    	JZ	short CommitNext	;   in them.
 35567                                  	; 17/12/2022
 35568 0000657A 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
 35569                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
 35570 0000657F 750B                    	JNZ	short CommitNext	;  Skip Network SFTs so the SERVER
 35571                                  					;	doesn't deadlock
 35572 00006581 893E[9E05]              	MOV	[THISSFT],DI
 35573 00006585 8C06[A005]              	MOV	[THISSFT+2],ES
 35574 00006589 E8FDCA                  	call	DOS_COMMIT		;	DOSCommit ();
 35575                                  CommitNext:
 35576 0000658C 5B                      	pop	bx
 35577 0000658D 43                      	INC	BX
 35578 0000658E EBD8                    	JMP	short CommitLoop
 35579                                  CommitDone:
 35580 00006590 E895AD                  	call	LCritSFT
 35581 00006593 5B                      	pop	bx
 35582                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35583                                  Commit_Ok:
 35584 00006594 E9A0A0                  	jmp	SYS_RET_OK
 35585                                  	
 35586                                  
 35587                                  CLOSE_NAME:
 35588                                  
 35589                                  ;if installed
 35590                                  
 35591                                  ;hkn; SS override
 35592                                  	;call	far [ss:MFTcloN]
 35593 00006597 36FF1E[A400]            	Call	far [SS:JShare+(5*4)] ; 5 = MFTcloN
 35594                                  ;else
 35595                                  ;	Call	MFTcloN
 35596                                  ;endif
 35597                                  
 35598                                  CheckReturns:
 35599 0000659C 7202                    	JC	short func_err
 35600                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35601                                  	;transfer SYS_RET_OK
 35602                                  Commit_Okj:
 35603 0000659E EBF4                    	jmp	short Commit_Ok
 35604                                  	;jmp	SYS_RET_OK
 35605                                  
 35606                                  func_err:
 35607                                  	;transfer SYS_RET_ERR
 35608                                  	;jmp	SYS_RET_ERR
 35609 000065A0 EBBB                    	jmp	short servercall_error
 35610                                  
 35611                                  CLOSE_UID:
 35612                                  
 35613                                  ;if installed
 35614                                  ;hkn; SS override
 35615                                  	;call	far [ss:MFTclU]
 35616 000065A2 36FF1E[9C00]            	Call	far [SS:JShare+(3*4)] ; 3 = MTFTclu
 35617                                  ;else
 35618                                  ;	Call	MFTclU
 35619                                  ;endif
 35620 000065A7 EBF3                    	JMP	short CheckReturns
 35621                                  
 35622                                  CLOSE_UID_PID:
 35623                                  
 35624                                  ;if installed
 35625                                  ;hkn; SS override
 35626                                  	;call	far [ss:MFTCloseP]
 35627 000065A9 36FF1E[A000]            	Call	far [SS:JShare+(4*4)] ; 4 = MFTCloseP 
 35628                                  ;else
 35629                                  ;	Call	MFTCloseP
 35630                                  ;endif
 35631 000065AE EBEC                    	JMP	short CheckReturns
 35632                                  
 35633                                  GET_LIST:
 35634                                  
 35635                                  ;if installed
 35636                                  ;hkn; SS override
 35637                                  	;call	far [ss:MFT_get]
 35638 000065B0 36FF1E[B400]            	Call	far [SS:JShare+(9*4)] ; 9 = MFT_get
 35639                                  ;else
 35640                                  ;	Call	MFT_get
 35641                                  ;endif
 35642 000065B5 72E9                    	JC	short func_err
 35643 000065B7 E8C79E                  	call	Get_User_Stack
 35644                                  	;mov	[si+2],bx
 35645 000065BA 895C02                  	MOV	[SI+user_env.user_BX],BX
 35646                                  	;mov	[si+10],di
 35647 000065BD 897C0A                  	MOV	[SI+user_env.user_DI],DI
 35648                                  	;mov	[si+16],es
 35649 000065C0 8C4410                  	MOV	[SI+user_env.user_ES],ES
 35650                                  SetCXOK:
 35651                                  	;mov	[si+4],cx
 35652 000065C3 894C04                  	MOV	[SI+user_env.user_CX],CX
 35653                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35654                                  	;transfer SYS_RET_OK
 35655                                  Commit_Okj2:
 35656                                  	; 17/12/2022
 35657 000065C6 EBCC                    	jmp	short Commit_Ok
 35658                                  	;jmp	short Commit_Okj
 35659                                  	;;jmp	SYS_RET_OK
 35660                                  
 35661                                  SRV_CALL:
 35662 000065C8 58                      	POP	AX			; get rid of call to $srvcall
 35663 000065C9 1E                      	push	ds
 35664 000065CA 56                      	push	si
 35665 000065CB E8B39E                  	call	Get_User_Stack
 35666 000065CE 5F                      	pop	di
 35667 000065CF 07                      	pop	es
 35668                                  
 35669                                  ; DS:SI point to stack
 35670                                  ; ES:DI point to DPL
 35671                                  
 35672 000065D0 E82CAC                  	call	XCHGP
 35673                                  
 35674                                  ; DS:SI point to DPL
 35675                                  ; ES:DI point to stack
 35676                                  ;
 35677                                  ; We now copy the registers from DPL to save stack
 35678                                  
 35679 000065D3 56                      	push	si
 35680 000065D4 B90600                  	MOV	CX,6
 35681 000065D7 F3A5                    	REP	MOVSW			; Put in AX,BX,CX,DX,SI,DI
 35682 000065D9 47                      	INC	DI
 35683 000065DA 47                      	INC	DI			; Skip user_BP
 35684 000065DB A5                      	MOVSW				; DS
 35685 000065DC A5                      	MOVSW				; ES
 35686 000065DD 5E                      	pop	si			; DS:SI -> DPL
 35687 000065DE 8B04                    	mov	ax,[SI]
 35688                                  	;MOV	AX,[SI+DPL.AX]
 35689                                  	;mov	bx,[si+2]
 35690 000065E0 8B5C02                  	MOV	BX,[SI+DPL.BX]
 35691                                  	;mov	cx,[si+4]
 35692 000065E3 8B4C04                  	MOV	CX,[SI+DPL.CX]
 35693                                  	;mov	dx,[si+6]
 35694 000065E6 8B5406                  	MOV	DX,[SI+DPL.DX]
 35695                                  	;mov	di,[si+10]
 35696 000065E9 8B7C0A                  	MOV	DI,[SI+DPL.DI]
 35697                                  	;mov	es,[si+14]
 35698 000065EC 8E440E                  	MOV	ES,[SI+DPL.ES]
 35699                                  	;push	word [si+8]
 35700 000065EF FF7408                  	PUSH	word [SI+DPL.SI]
 35701                                  	;mov	ds,[si+12]
 35702 000065F2 8E5C0C                  	MOV	DS,[SI+DPL.DS]
 35703 000065F5 5E                      	POP	SI
 35704                                  
 35705                                  ;hkn; SS override for next 3
 35706 000065F6 368C1E[EC05]            	MOV	[SS:SAVEDS],DS
 35707 000065FB 36891E[EA05]            	MOV	[SS:SAVEBX],BX
 35708 00006600 36C606[7205]FF          	MOV	byte [SS:FSHARING],-1	; set no redirect flag
 35709 00006606 E97F9D                  	jmp	REDISP
 35710                                  
 35711                                  GET_DOS_DATA:
 35712 00006609 16                      	push	ss
 35713 0000660A 07                      	pop	es
 35714 0000660B BF[2003]                	MOV     DI,SWAP_START
 35715 0000660E B9[AC0A]                	MOV     CX,SWAP_END
 35716 00006611 BA[3A03]                	MOV     DX,SWAP_ALWAYS
 35717 00006614 29F9                    	SUB     CX,DI
 35718 00006616 29FA                    	SUB     DX,DI
 35719 00006618 D1E9                    	SHR     CX,1                    ; div by 2, remainder in carry
 35720 0000661A 83D100                  	ADC     CX,0                    ; div by 2 + round up
 35721 0000661D D1E1                    	SHL     CX,1                    ; round up to 2 boundary.
 35722 0000661F E85F9E                  	call	Get_User_Stack
 35723                                  	;mov	[si+14],es
 35724 00006622 8C440E                  	MOV     [SI+user_env.user_DS],ES
 35725                                  	;mov	[si+8],di
 35726 00006625 897C08                  	MOV     [SI+user_env.user_SI],DI
 35727                                  	;mov	[si+6],dx
 35728 00006628 895406                  	MOV     [SI+user_env.user_DX],DX
 35729 0000662B EB96                    	JMP	short SetCXOK
 35730                                  
 35731                                  SPOOL_OPER:
 35732                                  	;CallInstall NETSpoolOper,MultNET,37,AX,BX
 35733                                  
 35734 0000662D 50                      	push    ax
 35735 0000662E B82511                  	mov     ax,1125h
 35736 00006631 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
 35737                                  			; STACK: WORD subfunction
 35738                                  			; Return: CF set on error, AX = error code
 35739                                  			; STACK unchanged
 35740 00006633 5B                      	pop	bx
 35741                                  	; 17/12/2022
 35742                                  	;JC	short func_err2
 35743 00006634 7390                    	jnc	short Commit_Okj2
 35744                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35745                                  	;;jmp	SYS_RET_OK
 35746                                  	;jmp	short Commit_Okj2
 35747                                  	
 35748                                  func_err2:
 35749 00006636 E907A0                  	jmp	SYS_RET_ERR
 35750                                  
 35751                                  ;Break	<$SetExtendedError - set extended error for later retrieval>
 35752                                  ;--------------------------------------------------------------------------
 35753                                  ;
 35754                                  ; Procedure Name : $SetExtendedError
 35755                                  ;
 35756                                  ; $SetExtendedError takes extended error information and loads it up for the
 35757                                  ; next extended error call. This is used by interrupt-level proccessors to
 35758                                  ; mask their actions.
 35759                                  ;
 35760                                  ;   Inputs: DS:SI points to DPL which contains all registers
 35761                                  ;   Outputs: none
 35762                                  ;
 35763                                  ;---------------------------------------------------------------------------
 35764                                  
 35765                                  _$SetExtendedError:
 35766                                  
 35767                                  ;hkn; SS override for all variables used
 35768                                  
 35769 00006639 8B04                    	mov	ax,[si]
 35770                                  	;MOV	AX,[SI+DPL.AX]
 35771 0000663B 36A3[2403]              	MOV	[SS:EXTERR],AX
 35772                                  	;mov	ax,[si+10]
 35773 0000663F 8B440A                  	MOV	AX,[SI+DPL.DI]
 35774 00006642 36A3[2803]              	MOV	[SS:EXTERRPT],AX
 35775                                  	;mov	ax,[si+14]
 35776 00006646 8B440E                  	MOV	AX,[SI+DPL.ES]
 35777 00006649 36A3[2A03]              	MOV	[SS:EXTERRPT+2],AX
 35778                                  	;mov	ax,[si+2]
 35779 0000664D 8B4402                  	MOV	AX,[SI+DPL.BX]
 35780 00006650 36A3[2603]              	MOV	[SS:EXTERR_ACTION],AX
 35781                                  	;mov	ax,[si+4]
 35782 00006654 8B4404                  	MOV	AX,[SI+DPL.CX]
 35783 00006657 368826[2303]            	MOV	[SS:EXTERR_LOCUS],AH
 35784 0000665C C3                      	retn
 35785                                  
 35786                                  ;============================================================================
 35787                                  ; UTIL.ASM, MSDOS 6.0, 1991
 35788                                  ;============================================================================
 35789                                  ; 05/08/2018 - Retro DOS v3.0
 35790                                  ; 05/05/2019 - Retro DOS v4.0
 35791                                  
 35792                                  ;**	Handle related utilities for MSDOS 2.X.
 35793                                  ;----------------------------------------------------------------------------
 35794                                  ;	pJFNFromHandle	written
 35795                                  ;	SFFromHandle	written
 35796                                  ;	SFFromSFN	written
 35797                                  ;	JFNFree 	written
 35798                                  ;	SFNFree 	written
 35799                                  ;
 35800                                  ;	Modification history:
 35801                                  ;
 35802                                  ;	    Created: MZ 1 April 1983
 35803                                  ;----------------------------------------------------------------------------
 35804                                  
 35805                                  ;	BREAK	<pJFNFromHandle - return pointer to JFN table entry>
 35806                                  
 35807                                  ;**	pJFNFromHandle - Translate Handle to Pointer to JFN
 35808                                  ;----------------------------------------------------------------------------
 35809                                  ;	pJFNFromHandle takes a file handle and turns that into a pointer to
 35810                                  ;	the JFN entry (i.e., to a byte holding the internal file handle #)
 35811                                  ;
 35812                                  ;	NOTE:
 35813                                  ;	  This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 35814                                  ;	  at DOSINIT time with SS NOT DOSGROUP
 35815                                  ;
 35816                                  ;	ENTRY	(bx) = handle
 35817                                  ;	EXIT	'C' clear if ok
 35818                                  ;		  (es:di) = address of JFN value
 35819                                  ;		'C' set if error
 35820                                  ;		  (ax) = error code
 35821                                  ;	USES	AX, DI, ES, Flags
 35822                                  ;----------------------------------------------------------------------------
 35823                                  
 35824                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35825                                  
 35826                                  pJFNFromHandle:
 35827                                  	; 05/05/2019 - Retro DOS v4.0
 35828                                  	;getdseg <es>			; es -> dosdata
 35829 0000665D 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 35830                                  	
 35831                                  	;MOV	ES,[cs:CurrentPDB]	; get user process data block
 35832 00006662 268E06[3003]            	mov	es,[es:CurrentPDB]
 35833                                  
 35834                                  	;cmp	bx,[ES:32h]
 35835 00006667 263B1E3200              	CMP	BX,[ES:PDB.JFN_Length]	; is handle greater than allocated
 35836 0000666C 7204                    	JB	short pjfn10		; no, get offset
 35837                                  ReturnCarry_inv_hndl: ; 05/08/2018 - Retro DOS v3.0
 35838                                  	;mov	al,6
 35839 0000666E B006                    	MOV     AL,error_invalid_handle ; appropriate error
 35840                                  ReturnCarry:
 35841 00006670 F9                      	STC                             ; signal error
 35842 00006671 C3                      	retn				; go back
 35843                                  pjfn10: 
 35844                                  	;les	di,[es:34h]
 35845 00006672 26C43E3400              	LES	DI,[ES:PDB.JFN_Pointer]	; get pointer to beginning of table
 35846 00006677 01DF                    	ADD	DI,BX			; add in offset, clear 'C'
 35847                                  	;clc
 35848                                  pJFNFromHandle_error:
 35849 00006679 C3                      	retn
 35850                                  
 35851                                  ;BREAK <SFFromHandle - return pointer (or error) to SF entry from handle>
 35852                                  ;----------------------------------------------------------------------------
 35853                                  ;
 35854                                  ; Procedure Name : SFFromHandle
 35855                                  ;
 35856                                  ; SFFromHandle - Given a handle, get JFN and then index into SF table
 35857                                  ;
 35858                                  ;   Input:      BX has handle
 35859                                  ;   Output:     Carry Set
 35860                                  ;                   AX has error code
 35861                                  ;               Carry Reset
 35862                                  ;                   ES:DI has pointer to SF entry
 35863                                  ;   Registers modified: If error, AX,ES, else ES:DI
 35864                                  ; NOTE:
 35865                                  ;   This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 35866                                  ;       at DOSINIT time with SS NOT DOSGROUP
 35867                                  ;
 35868                                  ;----------------------------------------------------------------------------
 35869                                  
 35870                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35871                                  
 35872                                  SFFromHandle:
 35873 0000667A E8E0FF                  	CALL	pJFNFromHandle		; get jfn pointer
 35874                                  	;retc				; return if error
 35875 0000667D 72FA                    	jc	short pJFNFromHandle_error
 35876 0000667F 26803DFF                	CMP     BYTE [ES:DI],-1		; unused handle
 35877                                  	;JNZ	short GetSF		; nope, suck out SF
 35878                                  	;;mov	al,6
 35879                                  	;MOV	AL,error_invalid_handle ; appropriate error
 35880                                  	;jmp	short ReturnCarry	; signal it
 35881                                  	; 17/12/2022
 35882                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35883 00006683 74E9                    	jz	short ReturnCarry_inv_hndl ; Retro DOS v3.0 modification
 35884                                  	;JNZ	short GetSF		; nope, suck out SF
 35885                                  	;;mov	al,6
 35886                                  	;MOV	AL,error_invalid_handle ; appropriate error
 35887                                  	;jmp	short ReturnCarry	; signal it
 35888                                  GetSF:
 35889 00006685 53                      	push	bx			; save handle
 35890 00006686 268A1D                  	MOV     BL,[ES:DI]		; get SFN
 35891 00006689 30FF                    	XOR     BH,BH                   ; ignore upper half
 35892 0000668B E80200                  	CALL    SFFromSFN               ; get real sf spot
 35893 0000668E 5B                      	pop	bx			; restore
 35894 0000668F C3                      	retn                        	; say goodbye
 35895                                  
 35896                                  ;BREAK <SFFromSFN - index into SF table for SFN>
 35897                                  
 35898                                  ;**	SFFromSFN - Get an SF Table entry from an SFN
 35899                                  ;----------------------------------------------------------------------------
 35900                                  ;	SFFromSfn uses an SFN to index an entry into the SF table. This
 35901                                  ;	is more than just a simple index instruction because the SF table
 35902                                  ;	can be made up of multiple pieces chained together. We follow the
 35903                                  ;	chain to the right piece and then do the index operation.
 35904                                  ;
 35905                                  ;   NOTE:
 35906                                  ;	This routine is called from SFFromHandle which is called
 35907                                  ;       at DOSINIT time with SS NOT DOSGROUP
 35908                                  ;
 35909                                  ;	ENTRY	BX has SF index
 35910                                  ;	EXIT	'C' clear if OK
 35911                                  ;		  ES:DI points to SF entry
 35912                                  ;		'C' set if index too large
 35913                                  ;	USES	BX, DI, ES
 35914                                  ;----------------------------------------------------------------------------
 35915                                  
 35916                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35917                                  
 35918                                  SFFromSFN:
 35919                                  	; 05/05/2019 - Retro DOS v4.0
 35920                                  	;getdseg <es>			; es -> dosdata
 35921 00006690 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 35922                                  
 35923                                  	;LES	DI,[CS:SFT_ADDR]	; (es:di) = start of SFT table
 35924 00006695 26C43E[2A00]            	les	di,[es:SFT_ADDR]
 35925                                  sfsfn5:	
 35926                                  	;cmp	bx,[es:di+4]
 35927 0000669A 263B5D04                	CMP	BX,[ES:DI+SFT.SFCount]	; is handle in this table?
 35928 0000669E 720E                    	JB	short sfsfn7		; yes, go grab it
 35929                                  	;sub	bx,[es:di+4]
 35930 000066A0 262B5D04                	SUB     BX,[ES:DI+SFT.SFCount]
 35931 000066A4 26C43D                  	les	di,[es:di] ; 14/08/2018
 35932                                  	;LES	DI,[ES:DI+SFT.SFLink]	; get next table segment
 35933 000066A7 83FFFF                  	CMP     DI,-1                   ; end of tables?
 35934 000066AA 75EE                    	JNZ	short sfsfn5		; no, try again
 35935 000066AC F9                      	STC
 35936 000066AD C3                      	retn				; return with error, not found
 35937                                  sfsfn7:
 35938 000066AE 50                      	push	ax
 35939                                  	;mov	ax,53 ; MSDOS 3.3
 35940                                  	;mov	ax,59 ; MSDOS 6.0
 35941                                  	;MOV	AX,SF_ENTRY.size	; put it in a nice place
 35942                                  	
 35943                                  	; 17/12/2022
 35944 000066AF B03B                    	mov	al,SF_ENTRY.size ; 28/05/2019
 35945                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35946                                  	;mov	ax,SF_ENTRY.size ; 59
 35947                                  	
 35948 000066B1 F6E3                    	MUL	BL			; (ax) = offset into this SF block
 35949 000066B3 01C7                    	ADD	DI,AX			; add base of SF block
 35950 000066B5 58                      	pop	ax
 35951                                  	;add	di,6
 35952 000066B6 83C706                  	ADD	DI,SFT.SFTable		; offset into structure, 'C' cleared
 35953 000066B9 C3                      	retn				; return with 'C' clear
 35954                                  
 35955                                  ;	BREAK <JFNFree - return a jfn pointer if one is free>
 35956                                  
 35957                                  ;**	JFNFree - Find a Free JFN Slot
 35958                                  ;----------------------------------------------------------------------------
 35959                                  ;	JFNFree scansthrough the JFN table and returnsa pointer to a free slot
 35960                                  ;
 35961                                  ;	ENTRY	(ss) = DOSDATA
 35962                                  ;	EXIT	'C' clear if OK
 35963                                  ;		  (bx) = new handle
 35964                                  ;		  (es:di) = pointer to JFN slot
 35965                                  ;		'C' set if error
 35966                                  ;		  (al) = error code
 35967                                  ;	USES	bx, di, es, flags
 35968                                  ;----------------------------------------------------------------------------
 35969                                  
 35970                                  JFNFree:
 35971 000066BA 31DB                    	XOR	BX,BX			; (bx) = initial JFN to try
 35972                                  jfnf1:	
 35973 000066BC E89EFF                  	CALL	pJFNFromHandle		; get the appropriate handle
 35974 000066BF 7209                    	JC	short jfnf5		; no more handles
 35975 000066C1 26803DFF                	CMP     BYTE [ES:DI],-1		; free?
 35976 000066C5 7405                    	je	short jfnfx		; yes, carry is clear
 35977 000066C7 43                      	INC     BX                      ; no, next handle
 35978 000066C8 EBF2                    	JMP	short jfnf1		; and try again
 35979                                  
 35980                                  	; Error. 'C' set
 35981                                  jfnf5:	
 35982                                  	;mov	al,4
 35983 000066CA B004                    	MOV	AL,error_too_many_open_files
 35984                                  jfnfx:	
 35985 000066CC C3                      	retn				; bye
 35986                                  
 35987                                  ;	BREAK <SFNFree - Allocate a free SFN>
 35988                                  
 35989                                  ;**	SFNFree - Allocate a Free SFN/SFT
 35990                                  ;----------------------------------------------------------------------------
 35991                                  ;	SFNFree scans through the sf table looking for a free entry
 35992                                  ;	If it finds one it partially allocates it by setting SFT_REF_COUNT = -1
 35993                                  ;
 35994                                  ;	The problem is that we want to mark the SFT busy so that other threads
 35995                                  ;	can't allocate the SFT before we're finished marking it up.  However,
 35996                                  ;	we can't just mark it busy because we may get blown out of our open
 35997                                  ;	by INT24 and leave the thing orphaned.	To solve this we mark it
 35998                                  ;	"allocation in progress" by setting SFT_REF_COUNT = -1.  If we see
 35999                                  ;	an SFT with this value we look to see if it belongs to this user
 36000                                  ;	and process.  If it does belong to us then it must be an orphan
 36001                                  ;	and we reclaim it.
 36002                                  ;
 36003                                  ;	BUGBUG - improve the performance. I guess it's smaller to call SFFromSFN
 36004                                  ;		over and over, but we could at least set a high water mark...
 36005                                  ;		cause an N^2 loop calling slow SFFromSFN is real slow, too slow
 36006                                  ;		even though this is not a frequently called routine - jgl
 36007                                  ;
 36008                                  ;	ENTRY	(ss) = DOSDATA
 36009                                  ;	EXIT	'C' clear if no error
 36010                                  ;		  (bx) = SFN
 36011                                  ;		  (es:di) = pointer to SFT
 36012                                  ;		  es:[di].SFT_REF_COUNT = -1
 36013                                  ;		'C' set if error
 36014                                  ;		  (al) = error code
 36015                                  ;	USES	bx, di, es, Flags
 36016                                  ;----------------------------------------------------------------------------
 36017                                  
 36018                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36019                                  	; DOSCODE:A682h (MSDOS 5.0 MSDOS.SYS)
 36020                                  
 36021                                  SFNFree:
 36022                                  	; 12/08/2018
 36023                                  	; 05/08/2018 - Retro DOS v3.0
 36024                                  	;
 36025                                  	; MSDOS 6.0
 36026 000066CD 50                      	push	ax
 36027 000066CE 31DB                    	xor	bx,bx			; (bx) = SFN to consider
 36028                                  sfnf5:	
 36029 000066D0 53                      	push	bx
 36030 000066D1 E8BCFF                  	call	SFFromSFN		; get the potential handle
 36031 000066D4 5B                      	pop	bx
 36032 000066D5 723A                    	jc	short sfnf95		; no more free SFNs
 36033 000066D7 26833D00                	cmp	word [ES:DI],0
 36034                                  	;cmp	word [ES:DI+SF_ENTRY.sf_Ref_Count],0 ; free?
 36035 000066DB 741D                    	je	short sfnf20			; yep, got one
 36036                                  	
 36037                                  	;cmp	word [es:di],0FFFFh ; -1
 36038 000066DD 26833DFF                	cmp	word [ES:DI],sf_busy
 36039                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 36040 000066E1 7403                    	je	short sfnf10		; special busy mark
 36041                                  sfnf7:	
 36042 000066E3 43                      	inc	bx			; try the next one
 36043 000066E4 EBEA                    	jmp	short sfnf5
 36044                                  
 36045                                  ;	The SFT has the special "busy" mark; if it belongs to us then
 36046                                  ;	it was abandoned during a earlier call and we can use it.
 36047                                  ;
 36048                                  ;	(bx)	= SFN
 36049                                  ;	(es:di) = pointer to SFT
 36050                                  ;	(TOS)	= caller's (ax)
 36051                                  
 36052                                  sfnf10:	
 36053 000066E6 36A1[3E03]              	mov	ax,[SS:USER_ID]
 36054                                  	;cmp	[es:di+2Fh],ax
 36055 000066EA 2639452F                	cmp	[ES:DI+SF_ENTRY.sf_UID],ax
 36056 000066EE 75F3                    	jnz	short sfnf7		; not ours
 36057 000066F0 36A1[3C03]              	mov	ax,[SS:PROC_ID]
 36058                                  	;cmp	[es:di+31h],ax
 36059 000066F4 26394531                	cmp	[ES:DI+SF_ENTRY.sf_PID],ax
 36060 000066F8 75E9                    	jnz	short sfnf7		; can't use this one, try the next
 36061                                  
 36062                                  ;	We have an SFT to allocate
 36063                                  ;
 36064                                  ;	(bx)	= SFN
 36065                                  ;	(es:di) = pointer to SFT
 36066                                  ;	(TOS)	= caller's (ax)
 36067                                  
 36068                                  sfnf20:
 36069                                  	; cf = 0 ;; Retro DOS v3.0
 36070                                  
 36071                                  	;mov	word [es:di],0FFFFh
 36072 000066FA 26C705FFFF              	mov	word [ES:DI],sf_busy
 36073                                  					; make sure that this is allocated
 36074                                  	;mov	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 36075                                  
 36076 000066FF 36A1[3E03]              	mov	ax,[SS:USER_ID]
 36077                                  	;mov	[es:di+2Fh],ax
 36078 00006703 2689452F                	mov	[ES:DI+SF_ENTRY.sf_UID],ax
 36079 00006707 36A1[3C03]              	mov	ax,[SS:PROC_ID]
 36080                                  	;mov	[es:di+31h],ax
 36081 0000670B 26894531                	mov	[ES:DI+SF_ENTRY.sf_PID],ax
 36082                                  sfnf21: ;; Retro DOS v3.0
 36083                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36084                                  	;pop	ax
 36085                                  	;;clc
 36086                                  	;retn				; return with no error
 36087                                  	; 17/12/2022
 36088 0000670F 58                      	pop	ax
 36089                                  	;clc
 36090 00006710 C3                      	retn
 36091                                  
 36092                                  ;**	Error - no more free SFNs
 36093                                  ;
 36094                                  ;	'C' set
 36095                                  ;	(TOS) = saved ax
 36096                                  
 36097                                  sfnf95: 
 36098 00006711 58                      	pop	ax
 36099                                  	;mov	al,4
 36100 00006712 B004                    	mov	al,error_too_many_open_files
 36101 00006714 C3                      	retn				; return with 'C' and error
 36102                                  
 36103                                  ;============================================================================
 36104                                  ; HANDLE.ASM, MSDOS 6.0, 1991
 36105                                  ;============================================================================
 36106                                  ; 13/07/2018 - Retro DOS v3.0
 36107                                  ; 20/05/2019 - Retro DOS v4.0
 36108                                  
 36109                                  ; DOSCODE:A72Bh (MSDOS 6.21, MSDOS.SYS)
 36110                                  
 36111                                  ;	BREAK <$Close - return a handle to the system>
 36112                                  ;----------------------------------------------------------------------------
 36113                                  ;
 36114                                  ;**	$Close - Close a file Handle
 36115                                  ;
 36116                                  ;	BUGBUG - close gets called a LOT with invalid handles - sizzle that
 36117                                  ;		path
 36118                                  ;
 36119                                  ;	Assembler usage:
 36120                                  ;	    MOV     BX, handle
 36121                                  ;	    MOV     AH, Close
 36122                                  ;	    INT     int_command
 36123                                  ;
 36124                                  ;	ENTRY	(bx) = handle
 36125                                  ;	EXIT	<normal INT21 return convention>
 36126                                  ;	USES	all
 36127                                  ;
 36128                                  ;----------------------------------------------------------------------------
 36129                                  
 36130                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36131                                  ; DOSCODE:A6CBh (MSDOS 5.0 MSDOS.SYS)
 36132                                  
 36133                                  _$CLOSE:
 36134                                  ;	Grab the SFT pointer from the JFN.
 36135                                  
 36136 00006715 E85A02                  	call	CheckOwner		; get system file entry
 36137 00006718 722B                    	jc	short CloseError	; error return
 36138 0000671A 16                      	push	ss
 36139 0000671B 1F                      	pop	ds			; For DOS_CLOSE
 36140 0000671C 893E[9E05]              	MOV	[THISSFT],DI		; save offset of pointer
 36141 00006720 8C06[A005]              	MOV	[THISSFT+2],ES		; save segment value
 36142                                  
 36143                                  ; DS:SI point to JFN table entry.
 36144                                  ; ES:DI point to SFT
 36145                                  ;
 36146                                  ; We now examine the user's JFN entry; If the file was a 70-mode file (network
 36147                                  ; FCB, we examine the ref count on the SFT;  if it was 1, we free the JFN.
 36148                                  ; If the file was not a net FCB, we free the JFN too.
 36149                                  
 36150                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],1
 36151 00006724 26833D01                	cmp	word [ES:DI],1		; will the SFT become free?
 36152 00006728 740A                    	jz	short FreeJFN 		; yes, free JFN anyway.
 36153                                  	;mov	al,[ES:DI+2]
 36154 0000672A 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 36155                                  	;and	al,0F0h
 36156 0000672E 24F0                    	AND	AL,SHARING_MASK
 36157                                  	;cmp	al,70h
 36158 00006730 3C70                    	CMP	AL,SHARING_NET_FCB
 36159 00006732 7407                    	JZ	short PostFree		; 70-mode and big ref count => free it
 36160                                  
 36161                                  ; The JFN must be freed.  Get the pointer to it and replace the contents with
 36162                                  ; -1.
 36163                                  
 36164                                  FreeJFN:
 36165 00006734 E826FF                  	call	pJFNFromHandle		;   d = pJFN (handle);
 36166 00006737 26C605FF                	MOV	BYTE [ES:DI],0FFh	; release the JFN
 36167                                  PostFree:
 36168                                  
 36169                                  ; ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_CLOSE!
 36170                                  
 36171 0000673B E8FDC7                  	call	DOS_CLOSE
 36172                                  
 36173                                  ; DOS_Close may return an error. If we see such an error, we report it but
 36174                                  ; the JFN stays closed because DOS_Close always frees the SFT!
 36175                                  
 36176 0000673E 7205                    	JC	short CloseError
 36177                                  	;mov	ah,3Eh
 36178 00006740 B43E                    	MOV	AH,CLOSE		; MZ Bogus multiplan fix
 36179                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36180                                  CloseOk:
 36181 00006742 E9F29E                  	jmp	SYS_RET_OK
 36182                                  CloseError:
 36183 00006745 E9F89E                  	jmp	SYS_RET_ERR
 36184                                  
 36185                                  ;	BREAK <$Commit - commit the file>
 36186                                  ;----------------------------------------------------------------------------
 36187                                  ;
 36188                                  ;**	$Commit - Commit a File
 36189                                  ;
 36190                                  ;	$Commit "commits" a file to disk - all of it's buffers are
 36191                                  ;	flushed out.  BUGBUG - I'm pretty sure that $Commit doesn't update
 36192                                  ;	the directory entry, etc., so this commit is pretty useless. check
 36193                                  ;	and fix this!! jgl
 36194                                  ;
 36195                                  ;	Assembler usage:
 36196                                  ;	    MOV     BX, handle
 36197                                  ;	    MOV     AH, Commit
 36198                                  ;	    INT     int_command
 36199                                  ;
 36200                                  ;	ENTRY	(bx) = handle
 36201                                  ;	EXIT	none
 36202                                  ;	USES	all
 36203                                  ;;----------------------------------------------------------------------------
 36204                                  
 36205                                  _$COMMIT:
 36206                                  ;	Grab the SFT pointer from the JFN.
 36207                                  
 36208 00006748 E82702                  	call	CheckOwner		; get system file entry
 36209 0000674B 7213                    	JC	short CommitError	; error return
 36210 0000674D 16                      	push	ss
 36211 0000674E 1F                      	pop	ds			; For DOS_COMMIT
 36212 0000674F 893E[9E05]              	MOV	[THISSFT],DI		; save offset of pointer
 36213 00006753 8C06[A005]              	MOV	[THISSFT+2],ES		; save segment value
 36214                                  
 36215                                  ;	ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_COMMIT
 36216                                  ;
 36217                                  ;	ES:DI point to SFT
 36218                                  
 36219 00006757 E82FC9                  	call	DOS_COMMIT
 36220 0000675A 7204                    	JC	short CommitError
 36221                                  	; 07/12/2022
 36222                                  	;jc	short CloseError
 36223                                  	;mov	ah,68h
 36224 0000675C B468                    	MOV	AH,COMMIT
 36225                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36226                                  	;jmp	SYS_RET_OK
 36227                                  CommitOk:
 36228 0000675E EBE2                    	jmp	short CloseOk	
 36229                                  
 36230                                  CommitError:
 36231                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36232                                  	;jmp	SYS_RET_ERR
 36233 00006760 EBE3                    	jmp	short CloseError
 36234                                  
 36235                                  ;	BREAK <$ExtHandle - extend handle count>
 36236                                  
 36237                                  ;**	$ExtHandle - Extend Handle Count
 36238                                  ;----------------------------------------------------------------------------
 36239                                  ;	Assembler usage:
 36240                                  ;	    MOV     BX, Number of Opens Allowed (MAX=65534;66535 is
 36241                                  ;	    MOV     AX, 6700H			 reserved to mark SFT
 36242                                  ;	    INT     int_command 		 busy )
 36243                                  ;
 36244                                  ;	ENTRY	(bx) = new number of handles
 36245                                  ;	EXIT	'C' clear if OK
 36246                                  ;		'C' set iff err
 36247                                  ;		  (ax) = error code
 36248                                  ;			 AX = error_not_enough_memory
 36249                                  ;			      error_too_many_open_files
 36250                                  ;	USES	all
 36251                                  ;----------------------------------------------------------------------------
 36252                                  
 36253                                  _$ExtHandle:
 36254 00006762 31ED                    	XOR	BP,BP			; 0: enlarge   1: shrink  2:psp
 36255                                  	;cmp	bx,20
 36256 00006764 83FB14                  	CMP	BX,FILPERPROC
 36257 00006767 7303                    	JAE	short exth2		; Don't set less than FilPerProc no
 36258 00006769 BB1400                  	MOV	BX,FILPERPROC
 36259                                  exth2:	
 36260 0000676C 368E06[3003]            	MOV	ES,[ss:CurrentPDB]	; get user process data block;smr;SS Override
 36261                                  	;mov	cx,[ES:32h]
 36262 00006771 268B0E3200              	MOV	CX,[ES:PDB.JFN_Length]	; get number of handle allowed
 36263 00006776 39CB                    	CMP	BX,CX			; the requested == current
 36264 00006778 7455                    	JE	short ok_done 		; yes and exit
 36265 0000677A 7722                    	JA	short larger		; go allocate new table
 36266                                  
 36267                                  ;	We're going to shrink the # of handles available
 36268                                  
 36269 0000677C BD0100                  	MOV	BP,1			; shrink
 36270                                  	;mov	ds,[ES:36h]
 36271 0000677F 268E1E3600              	MOV	DS,[ES:PDB.JFN_Pointer+2] ;
 36272 00006784 89DE                    	MOV	SI,BX			;
 36273 00006786 29D9                    	SUB	CX,BX			; get difference
 36274                                  
 36275                                  ;	BUGBUG - code a SCASB here, should be a bit smaller
 36276                                  chck_handles:
 36277 00006788 803CFF                  	CMP	BYTE [SI],-1		; scan through handles to ensure close
 36278 0000678B 753D                    	JNZ	short too_many_files	; status
 36279 0000678D 46                      	INC	SI
 36280 0000678E E2F8                    	LOOP	chck_handles
 36281 00006790 83FB14                  	CMP	BX,FILPERPROC		; = 20
 36282 00006793 7709                    	JA	short larger		; no
 36283                                  
 36284 00006795 BD0200                  	MOV	BP,2			; psp
 36285                                  	;mov	di,24
 36286 00006798 BF1800                  	MOV	DI,PDB.JFN_TABLE	; es:di -> jfn table in psp
 36287 0000679B 53                      	PUSH	BX
 36288 0000679C EB1D                    	JMP	short movhandl
 36289                                  
 36290                                  larger:
 36291 0000679E 83FBFF                  	CMP	BX,-1			; 65535 is not allowed
 36292 000067A1 747F                    	JZ	short invalid_func	; 10/08/2018
 36293 000067A3 F8                      	CLC
 36294 000067A4 53                      	PUSH	BX			; save requested number
 36295 000067A5 83C30F                  	ADD	BX,0FH			; adjust to paragraph boundary
 36296 000067A8 B104                    	MOV	CL,4
 36297                                  	;ror	bx,cl			; MSDOS 3.3
 36298 000067AA D3DB                    	RCR	BX,CL			; DOS 4.00 fix		;AC000;
 36299 000067AC 81E3FF1F                	AND	BX,1FFFH		; clear most 3 bits
 36300                                  
 36301 000067B0 55                      	PUSH	BP
 36302 000067B1 E8DCFA                  	call	_$ALLOC			; allocate memory
 36303 000067B4 5D                      	POP	BP
 36304 000067B5 7266                    	JC	short no_memory		; not enough meory
 36305                                  
 36306 000067B7 8EC0                    	MOV	ES,AX			; es:di points to new table memory
 36307 000067B9 31FF                    	XOR	DI,DI
 36308                                  movhandl:
 36309 000067BB 368E1E[3003]            	MOV	DS,[ss:CurrentPDB] 	; get user PDB address	;smr;SS Override
 36310                                  
 36311 000067C0 F7C50300                	test	BP,3			; enlarge ?
 36312 000067C4 740C                    	JZ	short enlarge 		; yes
 36313 000067C6 59                      	POP	CX			; cx = the amount you shrink
 36314 000067C7 51                      	PUSH	CX
 36315 000067C8 EB0C                    	JMP	short copy_hand
 36316                                  
 36317                                  ;	Done.  'C' clear
 36318                                  
 36319                                  ; 17/12/2022
 36320                                  ;ok_done:
 36321                                  ;	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36322                                  ;	;jmp	short CommitOk
 36323                                  ;	; 17/12/2022
 36324                                  ;	jmp	SYS_RET_OK
 36325                                  
 36326                                  too_many_files:
 36327                                  	;mov	al,4
 36328 000067CA B004                    	MOV	AL,error_too_many_open_files
 36329                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36330                                  	;jmp	SYS_RET_ERR
 36331                                  CommitErrorj:
 36332                                  	;jmp	short CommitError
 36333                                  	; 17/12/2022
 36334 000067CC E9719E                  	jmp	SYS_RET_ERR
 36335                                  
 36336                                  ; 17/12/2022 
 36337                                  ok_done:
 36338                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36339                                  	;jmp	short CommitOk
 36340                                  	; 17/12/2022
 36341 000067CF E9659E                  	jmp	SYS_RET_OK
 36342                                  
 36343                                  enlarge:
 36344                                  	;mov	cx,[32h]
 36345 000067D2 8B0E3200                	MOV	CX,[PDB.JFN_Length]	; get number of old handles
 36346                                  copy_hand:
 36347 000067D6 89CA                    	MOV	DX,CX
 36348                                  	;lds	si,[34h]
 36349 000067D8 C5363400                	LDS	SI,[PDB.JFN_Pointer]	; get old table pointer
 36350 000067DC F3A4                    	REP	MOVSB			; copy infomation to new table
 36351 000067DE 59                      	POP	CX			; get new number of handles
 36352 000067DF 51                      	PUSH	CX			; save it again
 36353 000067E0 29D1                    	SUB	CX,DX			; get the difference
 36354 000067E2 B0FF                    	MOV	AL,-1			; set availability to handles
 36355 000067E4 F3AA                    	REP	STOSB
 36356 000067E6 368E1E[3003]            	MOV	DS,[ss:CurrentPDB] 	; get user process data block;smr;SS Override
 36357                                  	;cmp	word [34h],0
 36358 000067EB 833E340000              	CMP	WORD [PDB.JFN_Pointer],0 ; check if original table pointer
 36359 000067F0 750D                    	JNZ	short update_info	; yes, go update PDB entries
 36360 000067F2 55                      	PUSH	BP
 36361 000067F3 1E                      	PUSH	DS			; save old table segment
 36362 000067F4 06                      	PUSH	ES			; save new table segment
 36363 000067F5 8E063600                	MOV	ES,[PDB.JFN_Pointer+2]	; get old table segment
 36364 000067F9 E80EFC                  	call	_$DEALLOC		; deallocate old table meomory
 36365 000067FC 07                      	POP	ES			; restore new table segment
 36366 000067FD 1F                      	POP	DS			; restore old table segment
 36367 000067FE 5D                      	POP	BP
 36368                                  
 36369                                  update_info:
 36370 000067FF F7C50200                	test	BP,2			; psp?
 36371 00006803 7408                    	JZ	short non_psp 		; no
 36372                                  	;mov	word [34h],18h ; 24
 36373 00006805 C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE ; restore
 36374 0000680B EB06                    	JMP	short final
 36375                                  non_psp:
 36376                                  	;mov	word [34h],0
 36377 0000680D C70634000000            	MOV	WORD [PDB.JFN_Pointer],0 ; new table pointer offset always 0
 36378                                  final:
 36379                                  	;mov	[36h],es	
 36380 00006813 8C063600                	MOV	[PDB.JFN_Pointer+2],ES	; update table pointer segment
 36381                                  	;pop	word [32h]
 36382 00006817 8F063200                	POP	word [PDB.JFN_Length]	; restore new number of handles
 36383                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36384                                  	;jmp	SYS_RET_OK
 36385                                  ok_done_j:
 36386 0000681B EBB2                    	jmp	short ok_done
 36387                                  
 36388                                  no_memory:
 36389 0000681D 5B                      	POP	BX			; clean stack
 36390                                  	;mov	al,8
 36391 0000681E B008                    	MOV	AL,error_not_enough_memory
 36392                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36393                                  	;jmp	SYS_RET_ERR
 36394                                  CommitErrorj2:
 36395 00006820 EBAA                    	jmp	short CommitErrorj
 36396                                  
 36397                                  invalid_func:
 36398                                  	;mov	al,1
 36399 00006822 B001                    	MOV	AL,error_invalid_function
 36400                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36401                                  	;jmp	SYS_RET_ERR
 36402                                  CommitErrorj3:
 36403                                  	;jmp	short CommitErrorj2
 36404                                  	; 17/12/2022
 36405 00006824 EBA6                    	jmp	short CommitErrorj
 36406                                  
 36407                                  ; 20/05/2019 - Retro DOS v4.0
 36408                                  ; DOSCODE:A83Ah (MSDOS 6.21, MSDOS.SYS)
 36409                                  
 36410                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36411                                  ; DOSCODE:A7DAh (MSDOS 5.0 MSDOS.SYS)
 36412                                  
 36413                                  ;	BREAK <$READ - Read from a file handle>
 36414                                  ;----------------------------------------------------------------------------
 36415                                  ;
 36416                                  ;**	$Read - Read from a File Handle
 36417                                  ;
 36418                                  ;   Assembler usage:
 36419                                  ;
 36420                                  ;	LDS	DX, buf
 36421                                  ;	MOV	CX, count
 36422                                  ;	MOV	BX, handle
 36423                                  ;	MOV	AH, Read
 36424                                  ;	INT	int_command
 36425                                  ;	  AX has number of bytes read
 36426                                  ;
 36427                                  ;	ENTRY	(bx) = file handle
 36428                                  ;		(cx) = byte count
 36429                                  ;		(ds:dx) = buffer address
 36430                                  ;	EXIT	Through system call return so that to user:
 36431                                  ;		  'C' clear if OK
 36432                                  ;		    (ax) = bytes read
 36433                                  ;		  'C' set if error
 36434                                  ;		    (ax) = error code
 36435                                  ;
 36436                                  ;----------------------------------------------------------------------------
 36437                                  
 36438                                  _$READ:
 36439 00006826 BE[E232]                	MOV	SI,DOS_READ
 36440                                  ReadDo:
 36441 00006829 E831FE                  	call	pJFNFromHandle
 36442 0000682C 7208                    	JC	short ReadError
 36443                                  
 36444 0000682E 268A05                  	MOV	AL,[ES:DI]
 36445 00006831 E83E01                  	call	CheckOwner		; get the handle
 36446 00006834 7303                    	JNC	short ReadSetup		; no errors do the operation
 36447                                  
 36448                                  ;	Have an error. 'C' set
 36449                                  
 36450                                  ReadError:
 36451                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36452                                  	;;jmp	SYS_RET_ERR		; go to error traps
 36453                                  	;jmp	short CommitErrorj3
 36454                                  	; 17/12/2022
 36455 00006836 E9079E                  	jmp	SYS_RET_ERR
 36456                                  
 36457                                  ReadSetup:
 36458 00006839 36893E[9E05]            	MOV	[ss:THISSFT],DI		; save offset of pointer;smr;SS Override
 36459 0000683E 368C06[A005]            	MOV	[ss:THISSFT+2],ES	; save segment value	;smr;SS Override
 36460                                  	; 20/05/2019 - Retro DOS v4.0
 36461                                  	; MSDOS 6.0 
 36462                                  ;; Extended Open
 36463                                  	;test	byte [es:di+3],20h
 36464 00006843 26F6450320              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(INT_24_ERROR>>8)
 36465                                  						 ;AN000;;EO. need i24
 36466 00006848 7406                    	JZ	short needi24 		     	 ;AN000;;EO. yes
 36467 0000684A 36800E[F605]02          	OR	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
 36468                                  					;AN000;;EO. set it off;smr;SS Override
 36469                                  needi24:				;AN000;
 36470                                  ;; Extended Open
 36471 00006850 36FF36[2C03]            	push	word [SS:DMAADD]
 36472 00006855 36FF36[2E03]            	push	word [SS:DMAADD+2]	;smr;SS Override
 36473                                  
 36474                                  ;;;;;	BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 36475                                  
 36476                                  	; 26/07/2019
 36477                                  
 36478                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36479                                  	;
 36480                                  	; (It is not necessary to call 'Align_Buffer' proc here/below because
 36481                                  	; there is not another caller; it is better to put the code in this proc
 36482                                   	; here instead of calling it as a subroutine; but I have modified code
 36483                                  	; here for MSDOS 5.0 MSDOS.SYS address compatibility)
 36484                                  
 36485                                  	; MSDOS 6.0
 36486 0000685A E81300                  	CALL	Align_Buffer		;AN000;MS. align user's buffer
 36487                                  	
 36488                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36489                                  	; MSDOS 3.3
 36490                                  	;MOV	BX,DX			; copy offset
 36491                                  	;push	cx			; don't stomp on count
 36492                                  	;MOV	CL,4			; bits to shift bytes->para
 36493                                  	;SHR	BX,CL			; get number of paragraphs
 36494                                  	;pop	cx			; get count back
 36495                                  	;MOV	AX,DS			; get original segment
 36496                                  	;ADD	AX,BX			; get new segment
 36497                                  	;MOV	DS,AX			; in seg register
 36498                                  	;AND	DX,0Fh			; normalize offset
 36499                                  	;MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 36500                                  	;MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 36501                                  						;smr;SS Override
 36502                                  ;;;;;	END BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 36503                                  	
 36504 0000685D 16                      	push	ss			; go for DOS addressability
 36505 0000685E 1F                      	pop	ds
 36506                                  
 36507 0000685F FFD6                    	CALL	SI ; DOS_READ		; indirect call to operation
 36508                                  
 36509 00006861 8F06[2E03]              	pop	word [DMAADD+2]
 36510 00006865 8F06[2C03]              	pop	word [DMAADD]
 36511                                  	;JNC	short READ_OK		;AN002;
 36512                                  	;JMP	short ReadError		;AN002; if error, say bye bye
 36513                                  	; 17/12/2022
 36514 00006869 72CB                    	jc	short ReadError
 36515                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36516                                  	;jnc	short READ_OK		;AN002;
 36517                                  	;jmp	short ReadError
 36518                                  
 36519                                  READ_OK:
 36520 0000686B 89C8                    	MOV	AX,CX			; get correct return in correct reg
 36521                                  Read_Okj:
 36522                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36523                                  	;;jmp	SYS_RET_OK		; successful return
 36524                                  	;jmp	short ok_done_j
 36525                                  	; 17/12/2022
 36526 0000686D E9C79D                  	jmp	SYS_RET_OK
 36527                                  
 36528                                  ; 13/07/2018 - Retro DOS v3.0
 36529                                  
 36530                                  ;----------------------------------------------------------------------------
 36531                                  
 36532                                  ;   Input: DS:DX points to user's buffer addr
 36533                                  ;   Function: rearrange segment and offset for READ/WRITE buffer
 36534                                  ;   Output: [DMAADD] set
 36535                                  
 36536                                  ; 20/05/2019 - Retro DOS v4.0
 36537                                  ; 26/07/2019
 36538                                  ;	; MSDOS 6.0
 36539                                  ;Align_Buffer:
 36540                                  ;	MOV	BX,DX			; copy offset
 36541                                  ;	push	cx			; don't stomp on count
 36542                                  ;	MOV	CL,4			; bits to shift bytes->para
 36543                                  ;	SHR	BX,CL			; get number of paragraphs
 36544                                  ;	pop	cx			; get count back
 36545                                  ;	MOV	AX,DS			; get original segment
 36546                                  ;	ADD	AX,BX			; get new segment
 36547                                  ;	MOV	DS,AX			; in seg register
 36548                                  ;	AND	DX,0Fh			; normalize offset
 36549                                  ;	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 36550                                  ;	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 36551                                  ;						;smr;SS Override
 36552                                  ;	retn
 36553                                  
 36554                                  ; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36555                                  Align_Buffer:
 36556 00006870 89D3                    	MOV	BX,DX			; copy offset
 36557 00006872 51                      	push	cx			; don't stomp on count
 36558 00006873 B104                    	MOV	CL,4			; bits to shift bytes->para
 36559 00006875 D3EB                    	SHR	BX,CL			; get number of paragraphs
 36560 00006877 59                      	pop	cx			; get count back
 36561 00006878 8CD8                    	MOV	AX,DS			; get original segment
 36562 0000687A 01D8                    	ADD	AX,BX			; get new segment
 36563 0000687C 8ED8                    	MOV	DS,AX			; in seg register
 36564 0000687E 83E20F                  	AND	DX,0Fh			; normalize offset
 36565 00006881 368916[2C03]            	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 36566 00006886 368C1E[2E03]            	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 36567                                  						;smr;SS Override
 36568 0000688B C3                      	retn
 36569                                  
 36570                                  ; 20/05/2019 - Retro DOS v4.0
 36571                                  ; DOSCODE:A8A0h (MSDOS 6.21, MSDOS.SYS)
 36572                                  
 36573                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36574                                  ; DOSCODE:A840h (MSDOS 5.0 MSDOS.SYS)
 36575                                  
 36576                                  ;BREAK <$WRITE - write to a file handle>
 36577                                  ;----------------------------------------------------------------------------
 36578                                  ;
 36579                                  ;   Assembler usage:
 36580                                  ;	    LDS     DX, buf
 36581                                  ;	    MOV     CX, count
 36582                                  ;	    MOV     BX, handle
 36583                                  ;	    MOV     AH, Write
 36584                                  ;	    INT     int_command
 36585                                  ;	  AX has number of bytes written
 36586                                  ;   Errors:
 36587                                  ;	    AX = write_invalid_handle
 36588                                  ;	       = write_access_denied
 36589                                  ;
 36590                                  ;   Returns in register AX
 36591                                  ;
 36592                                  ;----------------------------------------------------------------------------
 36593                                  
 36594                                  _$WRITE:
 36595 0000688C BE[0B35]                	MOV	SI,DOS_WRITE
 36596 0000688F EB98                    	JMP	short ReadDo
 36597                                  
 36598                                  ;BREAK <$LSEEK - move r/w pointer>
 36599                                  ;----------------------------------------------------------------------------
 36600                                  ;
 36601                                  ;   Assembler usage:
 36602                                  ;	    MOV     DX, offsetlow
 36603                                  ;	    MOV     CX, offsethigh
 36604                                  ;	    MOV     BX, handle
 36605                                  ;	    MOV     AL, method
 36606                                  ;	    MOV     AH, LSeek
 36607                                  ;	    INT     int_command
 36608                                  ;	  DX:AX has the new location of the pointer
 36609                                  ;   Error returns:
 36610                                  ;	    AX = error_invalid_handle
 36611                                  ;	       = error_invalid_function
 36612                                  ;   Returns in registers DX:AX
 36613                                  ;
 36614                                  ;----------------------------------------------------------------------------
 36615                                  
 36616                                  ; 21/05/2019 - Retro DOS v4.0
 36617                                  ; DOSCODE:A8A5h (MSDOS 6.21, MSDOS.SYS)
 36618                                  
 36619                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36620                                  ; DOSCODE:A845h (MSDOS 5.0 MSDOS.SYS)
 36621                                  
 36622                                  _$LSEEK:
 36623 00006891 E8DE00                  	call	CheckOwner		; get system file entry
 36624                                  
 36625                                  	; 17/12/2022
 36626                                  ;LSeekError:
 36627                                  	;JNC	short CHKOWN_OK		;AN002;
 36628                                  	;JMP	short ReadError		;AN002; error return
 36629                                  	; 17/12/2022
 36630                                  	; 02/06/2019
 36631 00006894 72A0                    	jc	short ReadError
 36632                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36633                                  	;JNC	short CHKOWN_OK		;AN002;
 36634                                  	;JMP	short ReadError		;AN002; error return
 36635                                  
 36636                                  CHKOWN_OK:
 36637                                  					;AN002;
 36638 00006896 3C02                    	CMP	AL,2			; is the seek value correct?
 36639 00006898 760A                    	JBE	short LSeekDisp		; yes, go dispatch
 36640                                  	;mov	byte [ss:EXTERR_LOCUS],1 
 36641 0000689A 36C606[2303]01          	MOV	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 36642                                  					;smr;SS Override
 36643                                  	;mov	al,1
 36644 000068A0 B001                    	mov	al,error_invalid_function ; invalid method
 36645                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36646                                  LSeekError2:
 36647 000068A2 EB92                    	jmp	short ReadError
 36648                                  
 36649                                  LSeekDisp:
 36650 000068A4 3C01                    	CMP	AL,1			; best way to dispatch; check middle
 36651 000068A6 720A                    	JB	short LSeekStore	; just store CX:DX
 36652 000068A8 771B                    	JA	short LSeekEOF		; seek from end of file
 36653                                  	;add	dx,[es:di+21]
 36654 000068AA 26035515                	ADD	DX,[ES:DI+SF_ENTRY.sf_position]
 36655                                  	;adc	cx,[es:di+23]
 36656 000068AE 26134D17                	ADC	CX,[ES:DI+SF_ENTRY.sf_position+2]
 36657                                  LSeekStore:
 36658 000068B2 89C8                    	MOV	AX,CX			; AX:DX
 36659 000068B4 92                      	XCHG	AX,DX			; DX:AX is the correct value
 36660                                  LSeekSetpos:
 36661                                  	;mov	[es:di+21],ax
 36662 000068B5 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 36663                                  	;mov	[es:di+23],dx
 36664 000068B9 26895517                	MOV	[ES:DI+SF_ENTRY.sf_position+2],DX
 36665 000068BD E8C19B                  	call	Get_User_Stack
 36666                                  	;mov	[si+6],dx
 36667 000068C0 895406                  	MOV	[SI+user_env.user_DX],DX ; return DX:AX
 36668                                  	;jmp	SYS_RET_OK		; successful return
 36669                                  	; 25/06/2019
 36670                                  	;jmp	SYS_RET_OK_clc
 36671                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36672                                  	;jmp	SYS_RET_OK_clc
 36673                                  LSeekOk:
 36674 000068C3 EBA8                    	jmp     short Read_Okj
 36675                                  
 36676                                  LSeekEOF:
 36677                                  	;;test	word [es:di+5],8000h
 36678                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 36679                                  	; 21/05/2019 - Retro DOS v4.0
 36680 000068C5 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 36681 000068CA 750A                    	JNZ	short Check_LSeek_Mode	; Is Net
 36682                                  LOCAL_LSeek:
 36683                                  	;add	dx,[es:di+17]
 36684 000068CC 26035511                	ADD	DX,[ES:DI+SF_ENTRY.sf_size]
 36685                                  	;adc	cx,[es:di+19]
 36686 000068D0 26134D13                	ADC	CX,[ES:DI+SF_ENTRY.sf_size+2]
 36687 000068D4 EBDC                    	JMP	short LSeekStore	; go and set the position
 36688                                  
 36689                                  Check_LSeek_Mode:
 36690                                  	;;test	word [es:di+2],8000h
 36691                                  	;test	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 36692                                  	; 21/05/2019
 36693 000068D6 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 36694 000068DB 75EF                    	JNZ	short LOCAL_LSeek	; FCB treated like local file
 36695                                  	;mov	ax,[es:di+2]
 36696 000068DD 268B4502                	MOV	AX,[ES:DI+SF_ENTRY.sf_mode]
 36697                                  	;and	ax, 0F0h
 36698 000068E1 25F000                  	AND	AX,SHARING_MASK
 36699                                  	;cmp	ax,40h
 36700 000068E4 83F840                  	CMP	AX,SHARING_DENY_NONE
 36701 000068E7 7405                    	JZ	short NET_LSEEK		; LSEEK exported in this mode
 36702                                  	;cmp	ax,30h
 36703 000068E9 83F830                  	CMP	AX,SHARING_DENY_READ
 36704 000068EC 75DE                    	JNZ	short LOCAL_LSeek	; Treated like local Lseek
 36705                                  NET_LSEEK:
 36706                                  ;	JMP	short LOCAL_LSeek
 36707                                  ; REMOVE ABOVE INSTRUCTION TO ENABLE DCR 142
 36708                                  	;CallInstall Net_Lseek,MultNET,33
 36709                                  	;JNC	short LSeekSetPos
 36710                                  
 36711 000068EE B82111                  	mov     ax,1121h
 36712 000068F1 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
 36713                                  			; CX:DX = offset (in bytes) from end
 36714                                  			; ES:DI -> SFT, SFT DPB field -> DPB of drive with file
 36715                                  			; SS = DOS CS
 36716                                  			; Return: CF set on error
 36717                                  			; CF clear if successful, DX:AX = new file position
 36718 000068F3 73C0                    	jnb     short LSeekSetpos
 36719                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36720                                  	;jmp	SYS_RET_ERR
 36721                                  ;LSeekError3:
 36722                                  	; 17/12/2022
 36723                                  LSeekError:
 36724                                  	;jmp	short LSeekError2
 36725                                  DupErr:	; 17/12/2022
 36726 000068F5 E9489D                  	jmp	SYS_RET_ERR
 36727                                  
 36728                                  ;BREAK <FileTimes - modify write times on a handle>
 36729                                  ;----------------------------------------------------------------------------
 36730                                  ;
 36731                                  ;   Assembler usage:
 36732                                  ;	    MOV AH, FileTimes (57H)
 36733                                  ;	    MOV AL, func
 36734                                  ;	    MOV BX, handle
 36735                                  ;	; if AL = 1 then then next two are mandatory
 36736                                  ;	    MOV CX, time
 36737                                  ;	    MOV DX, date
 36738                                  ;	    INT 21h
 36739                                  ;	; if AL = 0 then CX/DX has the last write time/date
 36740                                  ;	; for the handle.
 36741                                  ;
 36742                                  ;	AL=02		 get extended attributes
 36743                                  ;	   BX=handle
 36744                                  ;	   CX=size of buffer (0, return max size )
 36745                                  ;	   DS:SI query list (si=-1, selects all EA)
 36746                                  ;	   ES:DI buffer to hold EA list
 36747                                  ;
 36748                                  ;	AL=03		 get EA name list
 36749                                  ;	   BX=handle
 36750                                  ;	   CX=size of buffer (0, return max size )
 36751                                  ;	   ES:DI buffer to hold name list
 36752                                  ;
 36753                                  ;	AL=04		 set extended attributes
 36754                                  ;	   BX=handle
 36755                                  ;	   ES:DI buffer of EA list
 36756                                  ;
 36757                                  ;
 36758                                  ;   Error returns:
 36759                                  ;	    AX = error_invalid_function
 36760                                  ;	       = error_invalid_handle
 36761                                  ;
 36762                                  ;----------------------------------------------------------------------------
 36763                                  
 36764                                  ; 21/05/2019 - Retro DOS v4.0
 36765                                  ; DOSCODE:A90Dh (MSDOS 6.21, MSDOS.SYS)
 36766                                  
 36767                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36768                                  ; DOSCODE:A8ADh (MSDOS 5.0 MSDOS.SYS)
 36769                                  
 36770                                  _$FILE_TIMES:
 36771                                  	; 13/07/2018 - Retro DOS v3.0
 36772                                  
 36773                                  	; MSDOS 3.3
 36774                                  	;cmp	al,2			; correct subfunction ?
 36775                                  	;jb	short ft1
 36776                                  
 36777                                  	;;mov	byte [ss:EXTERR_LOCUS], 1
 36778                                  	;mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 36779                                  						;SS Overr
 36780                                  	;;mov	al,1
 36781                                  	;mov	al,error_invalid_function ; give bad return
 36782                                  	;jmp	SYS_RET_ERR
 36783                                  
 36784                                  	; MSDOS 6.0
 36785 000068F8 3C02                    	cmp	al,2			; correct subfunction ?
 36786 000068FA 7340                    	jae	short inval_func
 36787                                  ;ft1:
 36788 000068FC E87300                  	call	CheckOwner		; get sft
 36789                                  	; 17/12/2022
 36790 000068FF 72F4                    	jc	short LSeekError	; bad handle
 36791                                  
 36792 00006901 08C0                    	or	al,al			; get time/date ?
 36793 00006903 7515                    	jnz	short ft_set_time
 36794                                  
 36795                                  ;------ here we get the time & date from the sft for the user
 36796                                  
 36797 00006905 FA                      	cli				; is this cli/sti reqd ? BUGBUG
 36798                                  	;mov	cx,[es:di+13]
 36799 00006906 268B4D0D                	mov	cx,[es:di+SF_ENTRY.sf_time] ; get the time
 36800                                  	;mov	dx,[es:di+15]
 36801 0000690A 268B550F                	mov	dx,[es:di+SF_ENTRY.sf_date] ;  & date
 36802 0000690E FB                      	sti
 36803 0000690F E86F9B                  	call	Get_User_Stack
 36804                                  	;mov	[si+4],cx
 36805 00006912 894C04                  	mov	[si+user_env.user_CX],cx
 36806                                  	;mov	[si+6],dx
 36807 00006915 895406                  	mov	[si+user_env.user_DX],dx
 36808 00006918 EB1F                    	jmp	short ok_ret
 36809                                  
 36810                                  ;------ here we set the time in sft
 36811                                  
 36812                                  ft_set_time:
 36813 0000691A E8F0A9                  	call    ECritSFT
 36814                                  	;mov	[es:di+13],cx
 36815 0000691D 26894D0D                	mov	[es:di+SF_ENTRY.sf_time],cx ; drop in new time
 36816                                  	;mov	[es:di+15],dx
 36817 00006921 2689550F                	mov	[es:di+SF_ENTRY.sf_date],dx ;  and date	
 36818                                  
 36819 00006925 31C0                    	xor	ax, ax
 36820 00006927 36FF1E[C800]            	call	far [ss:JShare+(14*4)] ; 14 = ShSU	; SS Override
 36821                                  
 36822                                  ;------ set the flags in SFT entry
 36823                                  	;and	word [es:di+5],0FFBFh
 36824                                  	; 18/12/2022
 36825                                  	;and	byte [es:di+5],0BFh
 36826 0000692C 26806505BF              	and	byte [es:di+SF_ENTRY.sf_flags],~devid_file_clean
 36827                                  	;and	word [es:di+SF_ENTRY.sf_flags],~devid_file_clean 
 36828                                  							; mark file as dirty
 36829                                  	;or	word [es:di+5],4000h
 36830                                  	; 17/12/2022
 36831                                  	;or	byte [es:di+6],40h
 36832 00006931 26804D0640              	or	byte [es:di+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8)
 36833                                  	;or	word [es:di+SF_ENTRY.sf_flags],sf_close_nodate
 36834                                  							; ask close not to
 36835                                  							;   bother about date
 36836                                  							;   and time
 36837 00006936 E8EFA9                  	call	LCritSFT
 36838                                  ok_ret:
 36839                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36840                                  	; 17/12/2022
 36841 00006939 E9FB9C                  	jmp	SYS_RET_OK
 36842                                  	;jmp	short LSeekOk
 36843                                  
 36844                                  inval_func:
 36845                                  	;mov	byte [ss:EXTERR_LOCUS],1
 36846 0000693C 36C606[2303]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 36847                                  						;SS Overr
 36848                                  	;mov	al,1
 36849 00006942 B001                    	mov	al,error_invalid_function ; give bad return
 36850                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36851                                  ft_error:
 36852                                  	;;jmp	SYS_RET_ERR
 36853                                  	;jmp	short LSeekError3
 36854                                  	; 17/12/2022
 36855 00006944 EBAF                    	jmp	short LSeekError
 36856                                  
 36857                                  ; 21/05/2019 - Retro DOS v4.0
 36858                                  ; DOSCODE:A95Bh (MSDOS 6.21, MSDOS.SYS)
 36859                                  
 36860                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36861                                  ; DOSCODE:A8FBh (MSDOS 5.0 MSDOS.SYS)
 36862                                  
 36863                                  ;BREAK <$DUP - duplicate a jfn>
 36864                                  ;----------------------------------------------------------------------------
 36865                                  ;
 36866                                  ;   Assembler usage:
 36867                                  ;	    MOV     BX, fh
 36868                                  ;	    MOV     AH, Dup
 36869                                  ;	    INT     int_command
 36870                                  ;	  AX has the returned handle
 36871                                  ;   Errors:
 36872                                  ;	    AX = dup_invalid_handle
 36873                                  ;	       = dup_too_many_open_files
 36874                                  ;
 36875                                  ;----------------------------------------------------------------------------
 36876                                  
 36877                                  _$DUP:
 36878 00006946 89D8                    	MOV	AX,BX			; save away old handle in AX
 36879 00006948 E86FFD                  	call	JFNFree 		; free handle? into ES:DI, new in BX
 36880                                  DupErrorCheck:
 36881 0000694B 72A8                    	JC	short DupErr		; nope, bye
 36882 0000694D 06                      	push	es
 36883 0000694E 57                      	push	di			; save away SFT
 36884 0000694F 5E                      	pop	si			; into convenient place DS:SI
 36885 00006950 1F                      	pop	ds
 36886 00006951 93                      	XCHG	AX,BX			; get back old handle
 36887 00006952 E81D00                  	call	CheckOwner		; get sft in ES:DI
 36888 00006955 729E                    	JC	short DupErr		; errors go home
 36889 00006957 E8F2C0                  	call	DOS_Dup_Direct
 36890 0000695A E800FD                  	call	pJFNFromHandle		; get pointer
 36891 0000695D 268A1D                  	MOV	BL,[ES:DI]		; get SFT number
 36892 00006960 881C                    	MOV	[SI],BL			; stuff in new SFT
 36893                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36894                                  	;jmp	SYS_RET_OK		; and go home
 36895 00006962 EBD5                    	jmp	short ok_ret
 36896                                  
 36897                                  	; 17/12/2022
 36898                                  ;DupErr:
 36899                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36900                                  	;;jmp	SYS_RET_ERR
 36901                                  	;jmp	short ft_error
 36902                                  
 36903                                  ;BREAK <$DUP2 - force a dup on a particular jfn>
 36904                                  ;----------------------------------------------------------------------------
 36905                                  ;
 36906                                  ;   Assembler usage:
 36907                                  ;	    MOV     BX, fh
 36908                                  ;	    MOV     CX, newfh
 36909                                  ;	    MOV     AH, Dup2
 36910                                  ;	    INT     int_command
 36911                                  ;   Error returns:
 36912                                  ;	    AX = error_invalid_handle
 36913                                  ;
 36914                                  ;----------------------------------------------------------------------------
 36915                                  
 36916                                  _$DUP2:
 36917 00006964 53                      	push	bx
 36918 00006965 51                      	push	cx			; save source
 36919 00006966 89CB                    	MOV	BX,CX			; get one to close
 36920 00006968 E8AAFD                  	call	_$CLOSE			; close destination handle
 36921 0000696B 5B                      	pop	bx
 36922 0000696C 58                      	pop	ax			; old in AX, new in BX
 36923 0000696D E8EDFC                  	call	pJFNFromHandle		; get pointer
 36924 00006970 EBD9                    	JMP	short DupErrorCheck	; check error and do dup
 36925                                  
 36926                                  ;Break	<CheckOwner - verify ownership of handles from server>
 36927                                  ;----------------------------------------------------------------------------
 36928                                  ;   CheckOwner - Due to the ability of the server to close file handles for a
 36929                                  ;   process without the process knowing it (delete/rename of open files, for
 36930                                  ;   example), it is possible for the redirector to issue a call to a handle
 36931                                  ;   that it soes not rightfully own. We check here to make sure that the
 36932                                  ;   issuing process is the owner of the SFT. At the same time, we do a
 36933                                  ;   SFFromHandle to really make sure that the SFT is good.
 36934                                  ;
 36935                                  ;	ENTRY	BX has the handle
 36936                                  ;		User_ID is the current user
 36937                                  ;	EXIT	Carry Clear => ES:DI points to SFT
 36938                                  ;		Carry Set => AX has error code
 36939                                  ;	USES	none
 36940                                  ;----------------------------------------------------------------------------
 36941                                  
 36942                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36943                                  	; 21/05/2019 - Retro DOS v4.0
 36944                                  CheckOwner:
 36945                                  	; 13/07/2018 - Retro DOS v3.0
 36946                                  
 36947 00006972 E805FD                  	call	SFFromHandle
 36948 00006975 721B                    	jc	short co_ret_label	; retc
 36949                                  
 36950 00006977 50                      	push	ax
 36951                                  
 36952                                  	; MSDOS 6.0
 36953                                  
 36954                                  ;SR; WIN386 patch - Do not check for USER_ID for using handles since these 
 36955                                  ;SR; are shared across multiple VMs in win386.
 36956                                  
 36957 00006978 36F606[3010]01          	test	byte [ss:IsWin386],1 ; 02/06/2019
 36958 0000697E 7404                    	jz	short no_win386		;win386 is not present
 36959 00006980 31C0                    	xor	ax,ax			;set the zero flag
 36960 00006982 EB08                    	jmp	short _skip_win386	
 36961                                  
 36962                                  no_win386:
 36963 00006984 36A1[3E03]              	mov	ax,[SS:USER_ID]		;smr;SS Override
 36964                                  	;cmp	ax,[es:di+47]
 36965 00006988 263B452F                	cmp	ax,[es:di+SF_ENTRY.sf_UID]
 36966                                  
 36967                                  _skip_win386:
 36968 0000698C 58                      	pop	ax
 36969                                  	
 36970                                  	; 17/12/2022
 36971 0000698D 7403                    	jz	short co_ret_label
 36972                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36973                                  	;jnz	short CheckOwner_err
 36974                                  	;retn
 36975                                  	
 36976                                  CheckOwner_err:
 36977                                  	;mov	al,6
 36978 0000698F B006                    	mov	al,error_invalid_handle
 36979 00006991 F9                      	stc
 36980                                  
 36981                                  co_ret_label:
 36982 00006992 C3                      	retn
 36983                                  
 36984                                  ;============================================================================
 36985                                  ; MACRO.ASM, MSDOS 6.0, 1991
 36986                                  ;============================================================================
 36987                                  ; Retro	DOS v3.0 - 11/07/2018
 36988                                  ; 21/05/2019 - Retro DOS v4.0
 36989                                  
 36990                                  ;	TITLE	MACRO - Pathname and macro related internal routines
 36991                                  ;	NAME	MACRO
 36992                                  
 36993                                  ;	Microsoft Confidential
 36994                                  ;	Copyright (C) Microsoft Corporation 1991
 36995                                  ;	All Rights Reserved.
 36996                                  
 36997                                  ;**	MACRO.ASM
 36998                                  ;
 36999                                  ;	$AssignOper
 37000                                  ;	FIND_DPB
 37001                                  ;	InitCDS
 37002                                  ;	$UserOper
 37003                                  ;	GetVisDrv
 37004                                  ;	GetThisDrv
 37005                                  ;	GetCDSFromDrv
 37006                                  ;
 37007                                  ;   Revision history:
 37008                                  ;
 37009                                  ;	Created: MZ 4 April 1983
 37010                                  ;		 MZ 18 April 1983   Make TransFCB handle extended FCBs
 37011                                  ;		 AR 2 June 1983     Define/Delete macro for NET redir.
 37012                                  ;		 MZ 3 Nov 83	    Fix InitCDS to reset length to 2
 37013                                  ;		 MZ 4 Nov 83	    Fix NetAssign to use STRLEN only
 37014                                  ;		 MZ 18 Nov 83	    Rewrite string processing for subtree
 37015                                  ;				    aliasing.
 37016                                  ;
 37017                                  ;   MSDOS performs several types of name translation. First, we maintain for
 37018                                  ;   each valid drive letter the text of the current directory on that drive.
 37019                                  ;   For invalid drive letters, there is no current directory so we pretend to
 37020                                  ;   be at the root. A current directory is either the raw local directory
 37021                                  ;   (consisting of drive:\path) or a local network directory (consisting of
 37022                                  ;   \\machine\path. There is a limit on the point to which a .. is allowed.
 37023                                  ;
 37024                                  ;   Given a path, MSDOS will transform this into a real from-the-root path
 37025                                  ;   without . or .. entries. Any component that is > 8.3 is truncated to
 37026                                  ;   this and all * are expanded into ?'s.
 37027                                  ;
 37028                                  ;   The second part of name translation involves subtree aliasing. A list of
 37029                                  ;   subtree pairs is maintained by the external utility SUBST. The results of
 37030                                  ;   the previous 'canonicalization' are then examined to see if any of the
 37031                                  ;   subtree pairs is a prefix of the user path. If so, then this prefix is
 37032                                  ;   replaced with the other subtree in the pair.
 37033                                  ;
 37034                                  ;   A third part involves mapping this "real" path into a "physical" path.  A
 37035                                  ;   list of drive/subtree pairs are maintained by the external utility JOIN.
 37036                                  ;   The output of the previous translation is examined to see if any of the
 37037                                  ;   subtrees in this list are a prefix of the string. If so, then the prefix
 37038                                  ;   is replaced by the appropriate drive letter. In this manner, we can
 37039                                  ;   'mount' one device under another.
 37040                                  ;
 37041                                  ;   The final form of name translation involves the mapping of a user's
 37042                                  ;   logical drive number into the internal physical drive. This is
 37043                                  ;   accomplished by converting the drive number into letter:CON, performing
 37044                                  ;   the above translation and then converting the character back into a drive
 37045                                  ;   number.
 37046                                  ;
 37047                                  ;   There are two main entry points: TransPath and TransFCB. TransPath will
 37048                                  ;   take a path and form the real text of the pathname with all . and ..
 37049                                  ;   removed. TransFCB will translate an FCB into a path and then invoke
 37050                                  ;   TransPath.
 37051                                  ;
 37052                                  ;	A000	version 4.00  Jan. 1988
 37053                                  
 37054                                  ;Installed = TRUE
 37055                                  
 37056                                  ;	I_need	ThisCDS,DWORD		; pointer to CDS used
 37057                                  ;	I_need	CDSAddr,DWORD		; pointer to CDS table
 37058                                  ;	I_need	CDSCount,BYTE		; number of CDS entries
 37059                                  ;	I_need	CurDrv,BYTE		; current macro assignment (old
 37060                                  ;					; current drive)
 37061                                  ;	I_need	NUMIO,BYTE		; Number of physical drives
 37062                                  ;	I_need	fSharing,BYTE		; TRUE => no redirection allowed
 37063                                  ;	I_need	DummyCDS,80h		; buffer for dummy cds
 37064                                  ;	I_need	DIFFNAM,BYTE		; flag for MyName being set
 37065                                  ;	I_need	MYNAME,16		; machine name
 37066                                  ;	I_need	MYNUM,WORD		; machine number
 37067                                  ;	I_need	DPBHEAD,DWORD		; beginning of DPB chain
 37068                                  ;	I_need	EXTERR_LOCUS,BYTE	; Extended Error Locus
 37069                                  ;	I_need	DrvErr,BYTE		; drive error
 37070                                  
 37071                                  ;BREAK <$AssignOper -- Set up a Macro>
 37072                                  ;----------------------------------------------------------------------------
 37073                                  ; Inputs:
 37074                                  ;	AL = 00 get assign mode 		    (ReturnMode)
 37075                                  ;	AL = 01 set assign mode 		    (SetMode)
 37076                                  ;	AL = 02 get attach list entry		    (GetAsgList)
 37077                                  ;	AL = 03 Define Macro (attch start)
 37078                                  ;	    BL = Macro type
 37079                                  ;	       = 0 alias
 37080                                  ;	       = 1 file/device
 37081                                  ;	       = 2 drive
 37082                                  ;	       = 3 Char device -> network
 37083                                  ;	       = 4 File device -> network
 37084                                  ;	    DS:SI -> ASCIZ source name
 37085                                  ;	    ES:DI -> ASCIZ destination name
 37086                                  ;	AL = 04 Cancel Macro
 37087                                  ;	    DS:SI -> ASCIZ source name
 37088                                  ;	AL = 05 Modified get attach list entry
 37089                                  ;	AL = 06 Get ifsfunc item
 37090                                  ;	AL = 07 set in_use of a drive's CDS
 37091                                  ;	     DL = drive number, 0=default  0=A,,
 37092                                  ;	AL = 08 reset in_use of a drive's CDS
 37093                                  ;	     DL = drive number, 0=A, 1=B,,,
 37094                                  ; Function:
 37095                                  ;	Do macro stuff
 37096                                  ; Returns:
 37097                                  ;	Std Xenix style error return
 37098                                  ;----------------------------------------------------------------------------
 37099                                  
 37100                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37101                                  	; 21/05/2019 - Retro DOS v4.0
 37102                                  _$AssignOper:
 37103                                  	; MSDOS 6.0
 37104 00006993 3C07                    	CMP	AL,7			      ; set in_use ?		;AN000;
 37105 00006995 7525                    	JNZ	short chk08		      ; no			;AN000;
 37106                                  srinuse:								;AN000;
 37107 00006997 50                      	PUSH	AX			      ; save al 		;AN000;
 37108 00006998 88D0                    	MOV	AL,DL			      ; AL= drive id		;AN000;
 37109 0000699A E85601                  	CALL	GetCDSFromDrv		      ; ds:si -> cds		;AN000;
 37110 0000699D 58                      	POP	AX			      ; 			;AN000;
 37111 0000699E 7216                    	JC	short baddrv		      ; bad drive		;AN000;
 37112                                  	;cmp	word [si+45h],0
 37113 000069A0 837C4500                	CMP	WORD [SI+curdir.devptr],0     ; dpb ptr =0 ?		;AN000;
 37114 000069A4 7410                    	JZ	short baddrv		      ;     no			;AN000;
 37115 000069A6 3C07                    	CMP	AL,7			      ; set ?			;AN000;
 37116 000069A8 7506                    	JNZ	short resetdrv		      ; no			;AN000;
 37117                                  	;or	word [si+43h],4000h
 37118                                  	; 17/12/2022
 37119                                  	;or	byte [si+44h],40h
 37120 000069AA 804C4440                	or	byte [SI+curdir.flags+1],(curdir_inuse>>8)
 37121                                  	;OR	word [SI+curdir.flags],curdir_inuse ; set in_use	;AN000;
 37122 000069AE EB19                    	JMP	SHORT okdone		      ; 			;AN000;
 37123                                  resetdrv:
 37124                                  	;and	word [si+43h],0BFFFh									;AN000;
 37125                                  	; 18/12/2022
 37126 000069B0 806444BF                	and	byte [SI+curdir.flags+1],0BFh ; (~curdir_inuse)>>8
 37127                                  	;AND	word [SI+curdir.flags],~curdir_inuse ; reset in_use	;AN000;
 37128 000069B4 EB13                    	JMP	SHORT okdone		      ; 			;AN000;
 37129                                  
 37130                                  	; 17/12/2022
 37131                                  baddrv: 								;AN000;
 37132 000069B6 B80F00                  	MOV	AX,error_invalid_drive	      ; error			;AN000;
 37133                                  
 37134                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37135                                  	;JMP	SHORT ASS_ERR		      ; 			;AN000;
 37136                                  	; 17/12/2022
 37137                                  	; 21/05/2019
 37138                                  ASS_ERR:
 37139 000069B9 E9849C                  	jmp	SYS_RET_ERR
 37140                                  
 37141                                  chk08:									;AN000;
 37142 000069BC 3C08                    	CMP	AL,8			      ; reset inuse ?		;AN000;
 37143 000069BE 74D7                    	JZ	short srinuse 		      ; yes			;AN000;
 37144                                  
 37145                                    ;IF	NOT INSTALLED
 37146                                  	;transfer NET_ASSOPER
 37147                                    ;ELSE
 37148                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37149 000069C0 50                      	PUSH	AX
 37150                                  	;mov	ax,111Eh
 37151                                  	;MOV	AX,(MultNET SHL 8) OR 30
 37152 000069C1 B81E11                  	mov	ax,(MultNET*256)+30
 37153 000069C4 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
 37154                                  			; SS = DOS CS
 37155                                  			; STACK: WORD function to execute
 37156                                  			; Return: CF set on error, AX = error code
 37157                                  			; STACK unchanged
 37158 000069C6 5B                      	POP	BX			; Don't zap error code in AX
 37159 000069C7 72F0                    	JC	short ASS_ERR
 37160                                  okdone:
 37161 000069C9 E96B9C                  	jmp	SYS_RET_OK
 37162                                  
 37163                                  	; 17/12/2022
 37164                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37165                                  ;ASS_ERR:
 37166                                  	;jmp	SYS_RET_ERR
 37167                                  
 37168                                    ;ENDIF
 37169                                  
 37170                                  ;Break <FIND_DPB - Find a DPB from a drive number>
 37171                                  ;----------------------------------------------------------------------------
 37172                                  ;**	FIND_DPB - Find a DPB from a Drive #
 37173                                  ;
 37174                                  ;	ENTRY	AL has drive number A = 0
 37175                                  ;	EXIT	'C' set
 37176                                  ;		    No DPB for this drive number
 37177                                  ;		'C' clear
 37178                                  ;		    DS:SI points to DPB for drive
 37179                                  ;	USES	SI, DS, Flags
 37180                                  ;----------------------------------------------------------------------------
 37181                                  
 37182                                  	; 21/05/2019 - Retro DOS v4.0
 37183                                  FIND_DPB:
 37184 000069CC 36C536[2600]            	LDS	SI,[SS:DPBHEAD]		;smr;SS Override
 37185                                  fdpb5:	
 37186 000069D1 83FEFF                  	CMP	SI,-1
 37187 000069D4 7409                    	JZ	short fdpb10
 37188 000069D6 3A04                    	cmp	al,[si]
 37189                                  	;CMP	AL,[SI+DPB.DRIVE]
 37190 000069D8 7406                    	jz	short ret_label15	; Carry clear (retz)
 37191                                  	;;lds	si,[si+18h] ; MSDOS 3.3
 37192                                  	;lds	si,[si+19h] ; MSDOS 6.0
 37193 000069DA C57419                  	LDS	SI,[SI+DPB.NEXT_DPB]
 37194 000069DD EBF2                    	JMP	short fdpb5
 37195                                  fdpb10:	
 37196 000069DF F9                      	STC
 37197                                  ret_label15:
 37198 000069E0 C3                      	retn
 37199                                  
 37200                                  ;	Break <InitCDS - set up an empty CDS>
 37201                                  ;----------------------------------------------------------------------------
 37202                                  ;**	InitCDS - Setup an Empty CDS
 37203                                  ;
 37204                                  ;	ENTRY	ThisCDS points to CDS
 37205                                  ;		AL has uppercase drive letter
 37206                                  ;	EXIT	ThisCDS is now empty
 37207                                  ;		(ES:DI) = CDS
 37208                                  ;		'C' set if no DPB associated with drive
 37209                                  ;	USES	AH,ES,DI, Flags
 37210                                  ;----------------------------------------------------------------------------
 37211                                  
 37212                                  ; 21/05/2019 - Retro DOS v4.0
 37213                                  ; DOSCODE:A9FDh (MSDOS 6.21, MSDOS.SYS)
 37214                                  
 37215                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37216                                  ; DOSCODE:A99Dh (MSDOS 5.0, MSDOS.SYS)
 37217                                  
 37218                                  InitCDS:
 37219                                  	; 19/08/2018
 37220                                  	; 05/08/2018 - Retro DOS v3.0
 37221                                  	; MSDOS 6.0
 37222 000069E1 50                      	push	ax			; save (AL) for caller
 37223 000069E2 36C43E[A205]            	LES	DI,[SS:THISCDS]		; (es:di) = CDS address
 37224                                  	;mov	word [es:di+67],0
 37225 000069E7 26C745430000            	MOV	word [ES:DI+curdir.flags],0 ; "free" CDS
 37226 000069ED 2C40                    	SUB	AL,"A"-1                ; A = 1
 37227 000069EF 363806[4600]            	CMP	[SS:NUMIO],AL		;smr;SS Override
 37228 000069F4 7236                    	JC	short icdsx		; Drive does not map a physical drive
 37229 000069F6 48                      	dec	ax			; (AL) = 0 if A, 1 if B, etc.
 37230 000069F7 50                      	PUSH	AX			; save drive number for later
 37231 000069F8 0441                    	add	al,"A"
 37232 000069FA B43A                    	MOV	AH,':'
 37233 000069FC 268905                  	mov	[ES:DI],ax
 37234                                  	;MOV	[ES:DI+curdir.text],AX 	; set "x:"
 37235                                  	;mov	ax,"\"
 37236                                  	;mov	[es:di+2],ax
 37237                                  	;MOV	word [ES:DI+curdir.text+2],"\"	; NUL terminate
 37238 000069FF 26C745025C00            	mov	word [ES:DI+curdir.text+2],005Ch ; 19/08/2018
 37239                                  	;or	word [es:di+67],4000h
 37240                                  	;or	byte [es:di+68],40h
 37241 00006A05 26804D4440              	OR	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
 37242 00006A0A 29C0                    	sub	ax,ax
 37243                                  	;MOV	[es:di+73],ax ; 0
 37244 00006A0C 26894549                	MOV	[ES:DI+curdir.ID],ax
 37245                                  	;mov	[es:di+75],ax ; 0
 37246 00006A10 2689454B                	MOV	[ES:DI+curdir.ID+2],ax
 37247 00006A14 B002                    	mov	al,2
 37248                                  	;mov	[es:di+79],aX ; 2
 37249 00006A16 2689454F                	MOV	[ES:DI+curdir.end],ax
 37250 00006A1A 58                      	POP	AX			; (al) = drive number
 37251 00006A1B 1E                      	push	ds
 37252 00006A1C 56                      	push	si
 37253 00006A1D E8ACFF                  	call	FIND_DPB
 37254 00006A20 7208                    	JC	short icds5		; OOOOPPPPPSSSS!!!!
 37255                                  	;mov	[es:di+69],si
 37256 00006A22 26897545                	MOV	[ES:DI+curdir.devptr],SI
 37257                                  	;mov	[es:di+71],ds
 37258 00006A26 268C5D47                	MOV	[ES:DI+curdir.devptr+2],DS
 37259                                  icds5:	
 37260 00006A2A 5E                      	pop	si
 37261 00006A2B 1F                      	pop	ds
 37262                                  icdsx:	
 37263 00006A2C 58                      	pop	ax
 37264                                  RET45:
 37265 00006A2D C3                      	retn
 37266                                  
 37267                                  ;Break <$UserOper - get/set current user ID (for net)>
 37268                                  ;----------------------------------------------------------------------------
 37269                                  ;   $UserOper - retrieve or initiate a user id string.	MSDOS will only
 37270                                  ;	maintain this string and do no verifications.
 37271                                  ;
 37272                                  ;   Inputs:	AL has function type (0-get 1-set 2-printer-set 3-printer-get
 37273                                  ;				      4-printer-set-flags,5-printer-get-flags)
 37274                                  ;		DS:DX is user string pointer (calls 1,2)
 37275                                  ;		ES:DI is user buffer (call 3)
 37276                                  ;		BX is assign index (calls 2,3,4,5)
 37277                                  ;		CX is user number (call 1)
 37278                                  ;		DX is flag word (call 4)
 37279                                  ;   Outputs:	If AL = 0 then the current user string is written to DS:DX
 37280                                  ;			and user CX is set to the user number
 37281                                  ;		If AL = 3 then CX bytes have been put at input ES:DI
 37282                                  ;		If AL = 5 then DX is flag word
 37283                                  ;----------------------------------------------------------------------------
 37284                                  
 37285                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37286                                  	; 21/05/2019 - Retro DOS v4.0
 37287                                  _$UserOper:
 37288                                  	; 05/08/2018 - Retro DOS v3.0
 37289                                  	; MSDOS 6.0 (& MSDOS 3.3)
 37290 00006A2E 50                      	PUSH	AX
 37291 00006A2F 2C01                    	SUB	AL,1			; quick dispatch on 0,1
 37292 00006A31 58                      	POP	AX
 37293 00006A32 7211                    	JB	short UserGet 		; return to user the string
 37294 00006A34 742E                    	JZ	short UserSet 		; set the current user
 37295 00006A36 3C05                    	CMP	AL,5			; test for 2,3,4 or 5
 37296 00006A38 763D                    	JBE	short UserPrint		; yep
 37297                                  	;mov	byte [ss:EXTERR_LOCUS],1
 37298 00006A3A 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ;smr;SS Override 
 37299                                  					; Extended Error Locus
 37300                                  	;error	error_invalid_function	; not 0,1,2,3
 37301                                  	;mov	al,1
 37302 00006A40 B001                    	MOV	AL,error_invalid_function
 37303                                  useroper_error:
 37304                                  	; 17/12/2022
 37305                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37306 00006A42 E9FB9B                  	JMP	SYS_RET_ERR
 37307                                  	;jmp	short ASS_ERR
 37308                                  
 37309                                  UserGet:
 37310                                  ; Transfer MYNAME to DS:DX
 37311                                  ; Set Return CX to MYNUM
 37312 00006A45 1E                      	PUSH	DS			; switch registers
 37313 00006A46 07                      	POP	ES
 37314 00006A47 89D7                    	MOV	DI,DX			; destination
 37315 00006A49 368B0E[0E00]            	MOV	CX,[SS:MYNUM]		; Get number	;smr;SS Override
 37316 00006A4E E8309A                  	call	Get_User_Stack
 37317                                  	;mov	[si+4],cx
 37318 00006A51 894C04                  	MOV	[SI+user_env.user_CX],CX ; Set number return
 37319 00006A54 16                      	push	ss			; point to DOSDATA
 37320 00006A55 1F                      	pop	ds
 37321 00006A56 BE[0503]                	MOV	SI,MYNAME		; point source to user string
 37322                                  UserMove:
 37323 00006A59 B90F00                  	MOV	CX,15
 37324 00006A5C F3A4                    	REP	MOVSB			; blam.
 37325 00006A5E 31C0                    	XOR	AX,AX			; 16th byte is 0
 37326 00006A60 AA                      	STOSB
 37327                                  UserBye:
 37328 00006A61 E9D39B                  	jmp	SYS_RET_OK		; no errors here
 37329                                  
 37330                                  UserSet:
 37331                                  ; Transfer DS:DX to MYNAME
 37332                                  ; CX to MYNUM
 37333 00006A64 36890E[0E00]            	MOV	[SS:MYNUM],CX				;smr;SS Override
 37334 00006A69 89D6                    	MOV	SI,DX			; user space has source
 37335 00006A6B 16                      	push	ss
 37336 00006A6C 07                      	pop	es
 37337 00006A6D BF[0503]                	MOV	DI,MYNAME		; point dest to user string
 37338 00006A70 36FE06[0403]            	INC	byte [SS:DIFFNAM]	; signal change ;smr;SS Override
 37339 00006A75 EBE2                    	JMP	short UserMove
 37340                                  
 37341                                  UserPrint:
 37342                                  
 37343                                    ;IF NOT Installed
 37344                                    ;	transfer PRINTER_GETSET_STRING
 37345                                    ;ELSE
 37346 00006A77 50                      	PUSH	AX
 37347                                  	;mov	ax,111Fh
 37348                                  	;MOV	AX,(MultNET SHL 8) OR 31
 37349 00006A78 B81F11                  	mov	ax,(MultNET<<8)|31
 37350 00006A7B CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
 37351                                  			; STACK: WORD function
 37352                                  			; Return: CF set on error, AX = error code
 37353                                  			; STACK unchanged
 37354 00006A7D 5A                      	POP	DX			; Clean stack
 37355                                  	;JNC	short OKPA
 37356 00006A7E 73E1                    	jnc	short UserBye ; 21/05/2019
 37357                                  	; 17/12/2022
 37358 00006A80 EBC0                    	jmp	short useroper_error
 37359                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37360                                  	;jnb     short OKPA
 37361                                  	;jmp     short useroper_error
 37362                                  
 37363                                  	; 17/12/2022
 37364                                  ;OKPA:
 37365                                  ;	jmp	short UserBye
 37366                                  
 37367                                    ;ENDIF
 37368                                  
 37369                                  
 37370                                  ;Break	<GetVisDrv - return visible drive>
 37371                                  ;----------------------------------------------------------------------------
 37372                                  ;   GetVisDrv - correctly map non-spliced inuse drives
 37373                                  ;
 37374                                  ;   Inputs:	AL has drive identifier (0=default)
 37375                                  ;   Outputs:	Carry Set - invalid drive/macro
 37376                                  ;		Carry Clear - AL has physical drive (0=A)
 37377                                  ;		    ThisCDS points to CDS
 37378                                  ;   Registers modified: AL
 37379                                  ;----------------------------------------------------------------------------
 37380                                  
 37381                                  	; 21/05/2019 - Retro DOS v4.0
 37382                                  	; DOSCODE:AA9Fh (MSDOS 6.21, MSDOS.SYS)
 37383                                  
 37384                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37385                                  	; DOSCODE:AA3Fh (MSDOS 5.0, MSDOS.SYS)	
 37386                                  GetVisDrv:
 37387                                  	; 05/08/2018 - Retro DOS v3.0
 37388                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6839h
 37389 00006A82 E81900                  	CALL	GETTHISDRV		; get inuse drive
 37390 00006A85 72A6                    	jc	short RET45
 37391 00006A87 1E                      	push	ds
 37392 00006A88 56                      	push	si
 37393 00006A89 36C536[A205]            	LDS	SI,[SS:THISCDS]		;smr;SS Override
 37394                                  	;test	word [si+67],2000h
 37395                                  	; 17/12/2022
 37396                                  	;test	byte [si+68],20h
 37397 00006A8E F6444420                	test	byte [SI+curdir.flags+1],(curdir_splice>>8)
 37398                                  	;TEST	word [SI+curdir.flags],curdir_splice
 37399 00006A92 5E                      	pop	si
 37400 00006A93 1F                      	pop	ds
 37401 00006A94 7497                    	jz	short RET45		; if not spliced, return OK
 37402                                  	; MSDOS 6.0
 37403                                  	;mov	byte [ss:DrvErr],0Fh
 37404 00006A96 36C606[1006]0F          	MOV	byte [SS:DrvErr],error_invalid_drive ;IFS. ;AN000;smr;SS Override
 37405 00006A9C F9                      	STC				; signal error
 37406 00006A9D C3                      	retn
 37407                                  
 37408                                  ;Break <Getthisdrv - map a drive designator (0=def, 1=A...)>
 37409                                  ;----------------------------------------------------------------------------
 37410                                  ;   GetThisDrv - look through a set of macros and return the current drive and
 37411                                  ;	macro pointer
 37412                                  ;
 37413                                  ;   Inputs:	AL has drive identifier (1=A, 0=default)
 37414                                  ;   Outputs:
 37415                                  ;		Carry Set - invalid drive/macro
 37416                                  ;		Carry Clear - AL has physical drive (0=A)
 37417                                  ;		   ThisCDS points to macro
 37418                                  ;   Registers modified: AL
 37419                                  ;----------------------------------------------------------------------------
 37420                                  
 37421                                  	; 21/05/2019 - Retro DOS v4.0
 37422                                  	; DOSCODE:AABCh (MSDOS 6.21, MSDOS.SYS)
 37423                                  
 37424                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37425                                  	; DOSCODE:AA5Ch (MSDOS 5.0, MSDOS.SYS)	
 37426                                  GETTHISDRV:
 37427                                  	; 05/08/2018
 37428                                  	; 12/07/2018 - Retro DOS v3.0
 37429                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6850h
 37430                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37431 00006A9E 08C0                    	OR	AL,AL			; are we using default drive?
 37432 00006AA0 7505                    	JNZ	SHORT GTD10		; no, go get the CDS pointers
 37433 00006AA2 36A0[3603]              	MOV	AL,[SS:CURDRV]		; get the current drive
 37434                                  	;INC	ax			; Counteract next instruction
 37435                                  	; 04/09/2018
 37436                                  	;inc	al
 37437                                  	; 07/12/2022
 37438 00006AA6 40                      	inc	ax
 37439                                  GTD10:	
 37440                                  	;DEC	AX
 37441                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37442 00006AA7 48                      	dec	ax			; 0 = A
 37443                                  	;dec	al
 37444 00006AA8 1E                      	PUSH	DS			; save world
 37445 00006AA9 56                      	PUSH	SI
 37446                                  	;mov	byte [ss:EXTERR_LOCUS],2
 37447 00006AAA 36C606[2303]02          	MOV	BYTE [SS:EXTERR_LOCUS],errLOC_Disk		;smr;SS Override
 37448 00006AB0 36F606[7205]FF          	TEST	BYTE [SS:FSHARING],-1	; Logical or Physical?	;smr;SS Override
 37449 00006AB6 7420                    	JZ	SHORT GTD20		; Logical
 37450 00006AB8 50                      	PUSH	AX
 37451 00006AB9 06                      	PUSH	ES
 37452 00006ABA 57                      	PUSH	DI
 37453 00006ABB 36C706[A205][F304]      	MOV	WORD [SS:THISCDS],DUMMYCDS ;smr;SS Override
 37454                                  	;mov	[SS:THISCDS+2],CS ; MSDOS 3.3
 37455 00006AC2 368C16[A405]            	MOV	[SS:THISCDS+2],SS ; MSDOS 6.0 ;ThisCDS = &DummyCDS;smr;
 37456 00006AC7 0441                    	ADD	AL,'A'
 37457 00006AC9 E815FF                  	CALL	InitCDS			; InitCDS(c);
 37458                                  	;test	word [es:di+67],4000h
 37459                                  	; 17/12/2022
 37460                                  	;test	byte [es:di+68],40h
 37461 00006ACC 26F6454440              	test	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
 37462                                  	;TEST	WORD [ES:DI+curdir.flags],curdir_inuse	; Clears carry
 37463 00006AD1 5F                      	POP	DI
 37464 00006AD2 07                      	POP	ES
 37465 00006AD3 58                      	POP	AX
 37466 00006AD4 740D                    	JZ	SHORT GTD30		; Not a physical drive.
 37467 00006AD6 EB18                    	JMP	SHORT GTDX		; carry clear
 37468                                  GTD20:
 37469 00006AD8 E81800                  	CALL	GetCDSFromDrv
 37470 00006ADB 7206                    	JC	SHORT GTD30	; Unassigned CDS -> return error already set
 37471                                  	;test	word [si+43h],4000h
 37472                                  	; 17/12/2022
 37473                                  	;test	byte [si+44h],40h
 37474 00006ADD F6444440                	test	byte [SI+curdir.flags+1],(curdir_inuse>>8)
 37475                                  	;TEST	WORD [SI+curdir.flags],curdir_inuse ; Clears Carry
 37476 00006AE1 750D                    	JNZ	SHORT GTDX		; carry clear
 37477                                  GTD30:	
 37478                                  	; 21/05/2019
 37479                                  	; MSDOS 6.0
 37480 00006AE3 B00F                    	MOV	AL,error_invalid_drive	; invalid FAT drive
 37481 00006AE5 36A2[1006]              	MOV	BYTE [ss:DrvErr],AL	; save this for IOCTL
 37482                                  	; MSDOS 3.3 (.& MSDOS 6.0)
 37483 00006AE9 36C606[2303]01          	MOV	BYTE [ss:EXTERR_LOCUS],errLOC_Unk
 37484 00006AEF F9                      	STC
 37485                                  GTDX:	
 37486 00006AF0 5E                      	POP	SI			; restore world
 37487 00006AF1 1F                      	POP	DS
 37488 00006AF2 C3                      	RETN
 37489                                   
 37490                                  
 37491                                  ;Break <GetCDSFromDrv - convert a drive number to a CDS pointer>
 37492                                  ;----------------------------------------------------------------------------
 37493                                  ;   GetCDSFromDrv - given a physical drive number, convert it to a CDS
 37494                                  ;	pointer, returning an error if the drive number is greater than the
 37495                                  ;	number of CDS's
 37496                                  ;
 37497                                  ;   Inputs:	AL is physical unit # A=0...
 37498                                  ;   Outputs:	Carry Set if Bad Drive
 37499                                  ;		Carry Clear
 37500                                  ;		    DS:SI -> CDS
 37501                                  ;		    [THISCDS] = DS:SI
 37502                                  ;   Registers modified: DS,SI
 37503                                  ;----------------------------------------------------------------------------
 37504                                  
 37505                                  	; 21/05/2019 - Retro DOS v4.0
 37506                                  GetCDSFromDrv:
 37507 00006AF3 363A06[4700]            	CMP	AL,[SS:CDSCOUNT]	; is this a valid designator;smr;SS Override
 37508                                  	;JB	SHORT GetCDS	; cf=1	; yes, go get the macro
 37509                                  	;STC				; signal error
 37510                                  	;RETN				; bye
 37511                                  	; 23/09/2023
 37512 00006AF8 F5                      	cmc	; cf=1 <-> cf=0
 37513 00006AF9 7217                    	jc	short GetCDS_retn
 37514                                  GetCDS:
 37515                                  	; 23/09/2023
 37516                                  	;PUSH	BX
 37517 00006AFB 50                      	PUSH	AX
 37518 00006AFC 36C536[3C00]            	LDS	SI,[SS:CDSADDR]		; get pointer to table	;smr;SS Override
 37519                                  	;mov	bl,81 ; MSDOS 3.3
 37520                                  	;mov	bl,88 ; MSDOS 6.0 
 37521                                  	; 23/09/2023
 37522                                  	;MOV	BL,curdir.size		; size in convenient spot
 37523                                  	;MUL	BL			; get net offset
 37524 00006B01 B458                    	mov	ah,curdir.size
 37525 00006B03 F6E4                    	mul	ah
 37526 00006B05 01C6                    	ADD	SI,AX ; *		; convert to true pointer
 37527 00006B07 368936[A205]            	MOV	[SS:THISCDS],SI		; store convenient offset;smr;SS Override
 37528 00006B0C 368C1E[A405]            	MOV	[SS:THISCDS+2],DS	; store convenient segment;smr;SS Override
 37529 00006B11 58                      	POP	AX
 37530                                  	; 23/09/2023
 37531                                  	;POP	BX
 37532                                  	; (cf must be 0 here) ; *
 37533                                  	;CLC				; no error
 37534                                  GetCDS_retn:
 37535 00006B12 C3                      	RETN				; bye!
 37536                                  
 37537                                  ;============================================================================
 37538                                  ; MACRO2.ASM, MSDOS 6.0, 1991
 37539                                  ;============================================================================
 37540                                  ; Retro	DOS v3.0 - 12/07/2018
 37541                                  ; 22/05/2019 - Retro DOS v4.0
 37542                                  
 37543                                  ;BREAK <TransFCB - convert an FCB into a path, doing substitution>
 37544                                  ;----------------------------------------------------------------------------
 37545                                  ;   TransFCB - Copy an FCB from DS:DX into a reserved area doing all of the
 37546                                  ;       gritty substitution.
 37547                                  ;
 37548                                  ;   Inputs:     DS:DX - pointer to FCB
 37549                                  ;               ES:DI - point to destination
 37550                                  ;   Outputs:    Carry Set - invalid path in final map
 37551                                  ;               Carry Clear - FCB has been mapped into ES:DI
 37552                                  ;                   Sattrib is set from possibly extended FCB
 37553                                  ;                   ExtFCB set if extended FCB found
 37554                                  ;   Registers modified: most
 37555                                  ;----------------------------------------------------------------------------
 37556                                  
 37557                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37558                                  TransFCB:
 37559                                  	; 22/05/2019 - Retro DOS v4.0
 37560                                  	; 12/07/2018 - Retro DOS v3.0
 37561                                  	;LocalVar FCBTmp,16
 37562                                  	;ENTER
 37563 00006B13 55                      	push	bp
 37564 00006B14 89E5                    	mov	bp,sp
 37565                                  	;sub	sp,15	; MSDOS 3.3
 37566 00006B16 83EC10                  	sub	sp,16	; MSDOS 6.0
 37567 00006B19 16                      	push	ss
 37568 00006B1A 07                      	pop	es
 37569 00006B1B 06                      	push	es
 37570 00006B1C 57                      	push	di
 37571                                  	;lea	di,[bp-15] ; MSDOS 3.3
 37572                                  	;LEA	DI,FCBTmp 
 37573 00006B1D 8D7EF0                  	lea	di,[bp-16]		; point to FCB temp area
 37574 00006B20 36C606[6C05]00          	mov	byte [SS:EXTFCB],0	; no extended FCB found ;smr;SS Override
 37575 00006B26 36C606[6D05]00          	mov	byte [SS:SATTRIB],0	; default search attributes;smr;SS Override
 37576 00006B2C E838B1                  	call	GetExtended             ; get FCB, extended or not
 37577                                  	; 06/12/2022
 37578 00006B2F 740D                    	jz	short GetDrive		; not an extended FCB, get drive
 37579 00006B31 8A44FF                  	mov	AL,[SI-1]               ; get attributes
 37580 00006B34 36A2[6D05]              	mov	[SS:SATTRIB],AL		; store search attributes;smr;SS Override
 37581 00006B38 36C606[6C05]FF          	mov	byte [SS:EXTFCB],-1	; signal extended FCB  ;smr;SS Override
 37582                                  GetDrive:
 37583 00006B3E AC                      	lodsb				; get drive byte
 37584 00006B3F E85CFF                  	call	GETTHISDRV
 37585 00006B42 722A                    	jc	short BadPack
 37586 00006B44 E87303                  	call	TextFromDrive           ; convert 0-based drive to text
 37587                                  
 37588                                  ; Scan the source to see if there are any illegal chars
 37589                                  
 37590                                  	;mov	bx,CharType		; load lookup table
 37591 00006B47 B90B00                  	mov	cx,11
 37592 00006B4A 56                      	push	si			; back over name, ext
 37593                                  FCBScan:
 37594 00006B4B AC                      	lodsb				; get a byte
 37595                                  	
 37596                                  	; 09/08/2018
 37597                                  	;;xlat	byte [es:bx]
 37598                                  	;es	xlat
 37599                                  
 37600                                  	; 22/05/2019 - Retro DOS v4.0	
 37601 00006B4C E836E5                  	call	GetCharType		; get flags
 37602                                  
 37603                                  	;test	al,8	
 37604 00006B4F A808                    	test	al,FFCB
 37605 00006B51 741B                    	jz	short BadPack
 37606                                  NextCh: 
 37607 00006B53 E2F6                    	loop	FCBScan
 37608 00006B55 5E                      	pop	si
 37609 00006B56 89FB                    	mov	bx,di
 37610 00006B58 E865B5                  	call	PackName                ; crunch the path
 37611 00006B5B 5F                      	pop	di			; get original destination
 37612 00006B5C 07                      	pop	es
 37613 00006B5D 16                      	push	ss			; get DS addressability
 37614 00006B5E 1F                      	pop	ds
 37615                                  	;lea	si,[bp-15] ; MSDOS 3.3
 37616                                  	;LEA	SI,FCBTmp		; point at new pathname
 37617 00006B5F 8D76F0                  	lea	si,[bp-16]
 37618 00006B62 803F00                  	cmp	byte [bx],0
 37619 00006B65 7407                    	jz	short BadPack
 37620 00006B67 55                      	push	bp
 37621 00006B68 E80E00                  	call	TransPathSet            ; convert the path
 37622 00006B6B 5D                      	pop	bp
 37623 00006B6C 7303                    	jnc	short FCBRet		; bye with transPath error code
 37624                                  BadPack:
 37625 00006B6E F9                      	STC
 37626                                  	;mov	al,3
 37627 00006B6F B003                    	MOV     AL,error_path_not_found
 37628                                  FCBRet: 
 37629                                  	;LEAVE
 37630 00006B71 89EC                    	mov	sp,bp
 37631 00006B73 5D                      	pop	bp
 37632                                  TransPath_retn:
 37633 00006B74 C3                      	retn
 37634                                  
 37635                                  ; 12/07/2018 - Retro DOS v3.0
 37636                                  
 37637                                  ;BREAK <TransPath - copy a path, do string sub and put in current dir>
 37638                                  ;----------------------------------------------------------------------------
 37639                                  ;
 37640                                  ;   TransPath - copy a path from DS:SI to ES:DI, performing component string
 37641                                  ;       substitution, insertion of current directory and fixing . and ..
 37642                                  ;       entries. Perform splicing. Allow input string to match splice
 37643                                  ;       exactly.
 37644                                  ;
 37645                                  ;   TransPathSet - Same as above except No splicing is performed if input path
 37646                                  ;       matches splice.
 37647                                  ;
 37648                                  ;   TransPathNoSet - No splicing/local using is performed at all.
 37649                                  ;
 37650                                  ;   The following anomalous behaviour is required:
 37651                                  ;
 37652                                  ;       Drive letters on devices are ignored. (set up DummyCDS)
 37653                                  ;       Paths on devices are ignored. (truncate to 0-length)
 37654                                  ;       Raw net I/O sets ThisCDS => NULL.
 37655                                  ;       fSharing => dummyCDS and no subst/splice. Only canonicalize.
 37656                                  ;
 37657                                  ;   Other behaviour:
 37658                                  ;
 37659                                  ;       ThisCDS set up.
 37660                                  ;       FatRead done on local CDS.
 37661                                  ;       ValidateCDS done on local CDS.
 37662                                  ;
 37663                                  ;   Brief flowchart:
 37664                                  ;
 37665                                  ;       if fSharing then
 37666                                  ;           set up DummyCDS (ThisCDS)
 37667                                  ;           canonicalize (sets cMeta)
 37668                                  ;           splice
 37669                                  ;           fatRead
 37670                                  ;           return
 37671                                  ;       if \\ or d:\\ lead then
 37672                                  ;           set up null CDS (ThisCDS)
 37673                                  ;           canonicalize (sets cMeta)
 37674                                  ;           return
 37675                                  ;       if device then
 37676                                  ;           set up dummyCDS (ThisCDS)
 37677                                  ;           canonicalize (sets cMeta)
 37678                                  ;           return
 37679                                  ;       if file then
 37680                                  ;           getCDS (sets (ThisCDS) from name)
 37681                                  ;           validateCDS (may reset current dir)
 37682                                  ;           Copy current dir
 37683                                  ;           canonicalize (set cMeta)
 37684                                  ;           splice
 37685                                  ;           generate correct CDS (ThisCDS)
 37686                                  ;           if local then
 37687                                  ;               fatread
 37688                                  ;           return
 37689                                  ;
 37690                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 37691                                  ;               DI - point to buffer in DOSDATA
 37692                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 37693                                  ;                   syntax, etc. or user FAILed to I 24.
 37694                                  ;               WFP_Start - points to beginning of buffer
 37695                                  ;               Curr_Dir_End - points to end of current dir in path
 37696                                  ;               DS - DOSDATA
 37697                                  ;   Registers modified: most
 37698                                  ;
 37699                                  ;----------------------------------------------------------------------------
 37700                                  
 37701                                  ; 22/05/2019
 37702                                  ; 13/05/2019 - Retro DOS v4.0
 37703                                  ; DOSCODE:AB99h (MSDOS 6.21, MSDOS.SYS)
 37704                                  
 37705                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37706                                  ; DOSCODE:AB39h (MSDOS 5.0, MSDOS.SYS)
 37707                                  
 37708                                  TransPath:
 37709 00006B75 30C0                    	XOR     AL,AL
 37710 00006B77 EB02                    	JMP     SHORT SetSplice
 37711                                  TransPathSet:
 37712 00006B79 B0FF                    	MOV     AL,-1
 37713                                  SetSplice:
 37714 00006B7B 36A2[4C03]              	MOV	[SS:NoSetDir],AL	;   NoSetDir = !fExact; ;smr;SS Override
 37715 00006B7F B0FF                    	MOV     AL,-1
 37716                                  TransPathNoSet:
 37717 00006B81 36A2[7105]              	MOV	[SS:FSPLICE],AL		;   fSplice = TRUE;     ;smr;SS Override
 37718 00006B85 36C606[7A05]FF          	MOV	byte [ss:CMETA],-1      			;smr;SS Override
 37719 00006B8B 36893E[B205]            	MOV     [SS:WFP_START],DI 				;smr;SS Override
 37720 00006B90 36C706[B605]FFFF        	MOV	word [SS:CURR_DIR_END],-1 ; crack from start	;smr;SS Override
 37721 00006B97 16                      	push	ss
 37722 00006B98 07                      	pop	es
 37723                                  	;lea	bp,[di+134]
 37724 00006B99 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; end of buffer
 37725                                  ;
 37726                                  ; if this is through the server dos call, fsharing is set. We set up a
 37727                                  ; dummy cds and let the operation go.
 37728                                  ;
 37729 00006B9D 36F606[7205]FF          	TEST	byte [SS:FSHARING],-1	; if no sharing		;smr;SS Override
 37730 00006BA3 7435                    	JZ	short CheckUNC		; skip to UNC check
 37731                                  ;
 37732                                  ; ES:DI point to buffer
 37733                                  ;
 37734 00006BA5 E8FC02                  	CALL	DriveFromText           ; get drive and advance DS:SI
 37735 00006BA8 E8F3FE                  	call	GETTHISDRV              ; Set ThisCDS and convert to 0-based
 37736 00006BAB 722A                    	jc	short NoPath
 37737 00006BAD E80A03                  	CALL	TextFromDrive		; drop in new
 37738 00006BB0 8D5D01                  	LEA	BX,[DI+1]               ; backup limit
 37739 00006BB3 E83401                  	CALL	Canonicalize            ; copy and canonicalize
 37740 00006BB6 72BC                    	jc	short TransPath_retn	; errors
 37741                                  ;
 37742                                  ; Perform splices for net guys.
 37743                                  ;
 37744 00006BB8 16                      	push	ss
 37745 00006BB9 1F                      	pop	ds
 37746 00006BBA 8B36[B205]              	MOV     SI,[WFP_START] 		; point to name
 37747 00006BBE F606[7105]FF            	TEST	byte [FSPLICE],-1
 37748 00006BC3 7403                    	JZ	short NoServerSplice
 37749 00006BC5 E83102                  	CALL    Splice
 37750                                  NoServerSplice:
 37751 00006BC8 16                      	push	ss
 37752 00006BC9 1F                      	pop	ds                      ; for FATREAD
 37753 00006BCA C43E[A205]              	LES     DI,[THISCDS]		; for fatread
 37754 00006BCE E83CA7                  	call	ECritDisk
 37755 00006BD1 E807EB                  	call	FATREAD_CDS
 37756 00006BD4 E851A7                  	call	LCritDisk
 37757                                  NoPath:
 37758                                  	;mov	al,3
 37759 00006BD7 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 37760 00006BD9 C3                      	retn				; any errors are in Carry flag
 37761                                  
 37762                                  ; Let the network decide if the name is for a spooled device. It will map
 37763                                  ; the name if so.
 37764                                  
 37765                                  CheckUNC:
 37766 00006BDA 36C706[A205]FFFF        	MOV     WORD [SS:THISCDS],-1	; NULL thisCDS		;smr;SS Override
 37767                                  	;CallInstall NetSpoolCheck,MultNET,35
 37768 00006BE1 B82311                  	mov	ax,1123h
 37769 00006BE4 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
 37770                                  			; DS:SI -> ASCIZ filename to canonicalize
 37771                                  			; ES:DI -> 128-byte buffer for qualified name
 37772                                  			; Return: CF set if not resolved
 37773 00006BE6 7329                    	JNC	short UNCDone
 37774                                  
 37775                                  ; At this point the name is either a UNC-style name (prefixed with two leading
 37776                                  ; \\s) or is a local file/device. Remember that if a net-spooled device was
 37777                                  ; input, then the name has been changed to the remote spooler by the above net
 37778                                  ; call. Also, there may be a drive in front of the \\.
 37779                                  
 37780                                  NO_CHECK:
 37781 00006BE8 E8B902                  	CALL    DriveFromText		; eat drive letter
 37782 00006BEB 50                      	PUSH    AX                      ; save it
 37783 00006BEC 8B04                    	MOV     AX,[SI]			; get first two bytes of path
 37784 00006BEE E8B1E4                  	call    PATHCHRCMP              ; convert to normal form
 37785 00006BF1 86E0                    	XCHG    AH,AL                   ; swap for second byte
 37786 00006BF3 E8ACE4                  	call    PATHCHRCMP              ; convert to normal form
 37787 00006BF6 751F                    	JNZ	short CheckDevice	; not a path char
 37788 00006BF8 38C4                    	CMP     AH,AL                   ; are they same?
 37789 00006BFA 751B                    	JNZ	short CheckDevice	; nope
 37790                                  
 37791                                  ; We have a UNC request. We must copy the string up to the beginning of the
 37792                                  ; local machine root path
 37793                                  
 37794 00006BFC 58                      	POP     AX
 37795 00006BFD A5                      	MOVSW                           ; get the lead \\.
 37796                                  UNCCpy:
 37797 00006BFE AC                      	LODSB                           ; get a byte
 37798 00006BFF E84BE4                   	call	UCase                   ;AN000;; convert the char
 37799 00006C02 08C0                    	OR      AL,AL
 37800 00006C04 740E                    	JZ	short UNCTerm		; end of string. All done.
 37801 00006C06 E899E4                  	call    PATHCHRCMP              ; is it a path char?
 37802 00006C09 89FB                    	MOV     BX,DI                   ; backup position
 37803 00006C0B AA                      	STOSB
 37804 00006C0C 75F0                    	JNZ	short UNCCpy		; no, go copy
 37805 00006C0E E8D900                  	CALL    Canonicalize            ; wham (and set cMeta)
 37806                                  UNCDone:
 37807 00006C11 16                      	push	ss
 37808 00006C12 1F                      	pop	ds
 37809 00006C13 C3                       	retn				; return error code
 37810                                  UNCTerm:
 37811 00006C14 AA                      	STOSB                           ;AN000;
 37812 00006C15 EBFA                    	JMP	short UNCDone		;AN000;
 37813                                  
 37814                                  CheckDevice:
 37815                                  
 37816                                  ; Check DS:SI for device. First eat any path stuff
 37817                                  
 37818 00006C17 58                      	POP     AX                      ; retrieve drive info
 37819 00006C18 803C00                  	CMP     BYTE [SI],0		; check for null file
 37820 00006C1B 7504                    	JNZ	short CheckPath
 37821                                  	;mov	al,2 
 37822 00006C1D B002                    	MOV     AL,error_file_not_found ; bad file error
 37823 00006C1F F9                      	STC                             ; signal error on null input
 37824 00006C20 C3                      	RETN				; bye!
 37825                                  CheckPath:
 37826 00006C21 50                      	push	ax
 37827 00006C22 55                      	push	bp			; save drive number
 37828                                  
 37829                                  
 37830                                  ; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37831                                  %if 0
 37832                                  	; MSDOS 6.0
 37833                                  ;;;BUGBUG BUG 10-26-1992 scottq
 37834                                  ;;;This is a hack for the CDROM extensions (2.1) who scan looking
 37835                                  ;;;for the following POP BP == 5Dh (restore <bp,ax>).
 37836                                  ;;;The problem is that a direct call to CheckThisDevice can (and did)
 37837                                  ;;;end up having a 5D in the opcode's displacement field. The
 37838                                  ;;;scanning code would choke on this thinking it was a POP BP instruction.
 37839                                  ;;;
 37840                                  ;;;What we do here is do a call to a function that is less than 5Dh
 37841                                  ;;;bytes away (and assert its not exactly 5D away) that jmps (transfers)
 37842                                  ;;;to the correct function. This cannot accidently insert a 5Dh.
 37843                                  ;;;
 37844                                  ;;;More info:
 37845                                  ;;;  This particular scan is begun at the UNCdone label for 32 bytes
 37846                                  ;;;looking for pop BP, so you cannot put a 5D between here and there.
 37847                                  ;;;
 37848                                  	call	no5Dshere
 37849                                  start5Dhack:
 37850                                  ;following is replaced with 5Dhack code--Invoke CheckThisDevice         
 37851                                  backfrom5Dhack:
 37852                                  
 37853                                  %endif
 37854                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37855                                  	; Note: 'call no5Dshere' is not required for MSDOS 5.0 MSDOS.SYS
 37856 00006C23 E8FED6                  	call    CheckThisDevice	; E8h,6Fh,0D6h
 37857                                  
 37858 00006C26 5D                      	pop	bp
 37859 00006C27 58                      	pop	ax			; get drive letter back
 37860 00006C28 731C                    	JNC	short DoFile		; yes we have a file.
 37861                                  
 37862                                  ; We have a device. AX has drive letter. At this point we may fake a CDS ala
 37863                                  ; sharing DOS call. We know by getting here that we are NOT in a sharing DOS
 37864                                  ; call.
 37865                                  
 37866 00006C2A 36C606[7205]FF          	MOV	byte [SS:FSHARING],-1	; simulate sharing dos call;smr;SS Override
 37867 00006C30 E86BFE                  	call	GETTHISDRV              ; set ThisCDS and init DUMMYCDS
 37868 00006C33 36C606[7205]00          	MOV     byte [SS:FSHARING],0	;                       ;smr;SS Override
 37869                                  
 37870                                  ; Now that we have noted that we have a device, we put it into a form that
 37871                                  ; getpath can understand. Normally getpath requires d:\ to begin the input
 37872                                  ; string. We relax this to state that if the d:\ is present then the path
 37873                                  ; may be a file. If D:/ (note the forward slash) is present then we have
 37874                                  ; a device.
 37875                                  
 37876 00006C39 E87E02                  	CALL    TextFromDrive
 37877 00006C3C B02F                    	MOV     AL,'/'                  ; path sep.
 37878 00006C3E AA                      	STOSB
 37879 00006C3F E891A5                  	call	StrCpy			; move remainder of string
 37880                                  
 37881 00006C42 F8                      	CLC                             ; everything OK.
 37882 00006C43 16                      	push	ss
 37883 00006C44 1F                      	pop	ds                      ; remainder of OK stuff
 37884                                  DoFile_retn:
 37885 00006C45 C3                      	retn
 37886                                  
 37887                                  ; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37888                                  %if 0
 37889                                  
 37890                                  no5Dshere:
 37891                                  	; 10/08/2018
 37892                                  	jmp	CheckThisDevice		; snoop for device
 37893                                  %endif
 37894                                  
 37895                                  ;.erre (no5Dshere - start5Dhack - 5D)
 37896                                  
 37897                                  ; We have a file. Get the raw CDS.
 37898                                  
 37899                                  DoFile:
 37900                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37901                                  
 37902 00006C46 E839FE                  	call	GetVisDrv               ; get proper CDS
 37903                                  	;mov	al,3 
 37904 00006C49 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad file error
 37905 00006C4B 72F8                    	jc	short DoFile_retn  ; CARRY set -> bogus drive/spliced
 37906                                  
 37907                                  ; ThisCDS has correct CDS. DS:SI advanced to point to beginning of path/file.
 37908                                  ; Make sure that CDS has valid directory; ValidateCDS requires a temp buffer
 37909                                  ; Use the one that we are going to use (ES:DI).
 37910                                  
 37911                                  	;SAVE    <DS,SI,ES,DI>		; save all string pointers.
 37912 00006C4D 1E                      	push	ds
 37913 00006C4E 56                      	push	si
 37914 00006C4F 06                      	push	es
 37915 00006C50 57                      	push	di
 37916 00006C51 E814D6                  	call	ValidateCDS             ; poke CDS and make everything OK
 37917                                  	;RESTORE <DI,ES,SI,DS>		; get back pointers
 37918 00006C54 5F                      	pop	di
 37919 00006C55 07                      	pop	es
 37920 00006C56 5E                      	pop	si
 37921 00006C57 1F                      	pop	ds
 37922                                  	;mov	al,3
 37923 00006C58 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 37924                                  	;retc				; someone failed an operation
 37925 00006C5A 72E9                    	jc	short DoFile_retn
 37926                                  
 37927                                  ; ThisCDS points to correct CDS. It contains the correct text of the
 37928                                  ; current directory. Copy it in.
 37929                                  
 37930 00006C5C 1E                      	push	ds
 37931 00006C5D 56                      	push	si
 37932 00006C5E 36C536[A205]            	LDS     SI,[SS:THISCDS]		; point to CDS	;smr;SS Override
 37933 00006C63 89FB                    	MOV     BX,DI                   ; point to destination
 37934                                  	;add	bx,[si+79] ; MSDOS 6.0
 37935 00006C65 035C4F                  	ADD     BX,[SI+curdir.end]	; point to backup limit
 37936                                  	;lea	bp,[di+134]
 37937 00006C68 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; regenerate end of buffer
 37938                                  					;AN000;
 37939 00006C6C E873A5                  	call	FStrCpy                 ; copy string. ES:DI point to end
 37940 00006C6F 4F                      	DEC     DI                      ; point to NUL byte
 37941                                  
 37942                                  ; Make sure that there is a path char at end.
 37943                                  
 37944 00006C70 B05C                    	MOV     AL,'\'
 37945 00006C72 263845FF                	CMP     [ES:DI-1],AL
 37946 00006C76 7401                    	JZ	short GetOrig
 37947 00006C78 AA                      	STOSB
 37948                                  
 37949                                  ; Now get original string.
 37950                                  
 37951                                  GetOrig:
 37952 00006C79 4F                      	DEC     DI                      ; point to path char
 37953 00006C7A 5E                      	pop	si
 37954 00006C7B 1F                      	pop	ds
 37955                                  
 37956                                  ; BX points to the end of the root part of the CDS (at where a path char
 37957                                  ; should be). Now, we decide whether we use this root or extend it with the
 37958                                  ; current directory. See if the input string begins with a leading 
 37960 00006C7C E8D000                  	CALL    PathSep                 ; is DS:SI a path sep?
 37961 00006C7F 7511                    	JNZ	short PathAssure	; no, DI is correct. Assure a path char
 37962 00006C81 08C0                    	OR      AL,AL                   ; end of string?
 37963 00006C83 7410                    	JZ	short DoCanon		; yes, skip.
 37964                                  ;
 37965                                  ; The string does begin with a \. Reset the beginning of the canonicalization
 37966                                  ; to this root. Make sure that there is a path char there and advance the
 37967                                  ; source string over all leading \'s.
 37968                                  ;
 37969 00006C85 89DF                    	MOV     DI,BX                   ; back up to root point.
 37970                                  SkipPath:
 37971 00006C87 AC                      	LODSB
 37972 00006C88 E817E4                  	call    PATHCHRCMP
 37973 00006C8B 74FA                    	JZ	short SkipPath
 37974 00006C8D 4E                      	DEC     SI
 37975 00006C8E 08C0                    	OR      AL,AL
 37976 00006C90 7403                    	JZ	short DoCanon
 37977                                  
 37978                                  ; DS:SI start at some file name. ES:DI points at some path char. Drop one in
 37979                                  ; for yucks.
 37980                                  
 37981                                  PathAssure:
 37982 00006C92 B05C                    	MOV     AL,'\'	; 5Ch
 37983 00006C94 AA                      	STOSB
 37984                                  
 37985                                  ; ES:DI point to the correct spot for canonicalization to begin.
 37986                                  ; BP is the max extent to advance DI
 37987                                  ; BX is the backup limit for ..
 37988                                  
 37989                                  DoCanon:
 37990 00006C95 E85200                  	CALL    Canonicalize            ; wham.
 37991                                  	;retc				; badly formatted path.
 37992 00006C98 72AB                    	jc	short DoFile_retn
 37993                                  
 37994                                  ; The string has been moved to ES:DI. Reset world to DOS context, pointers
 37995                                  ; to wfp_start and do string substitution. BP is still the max position in
 37996                                  ; buffer.
 37997                                  
 37998 00006C9A 16                      	push	ss
 37999 00006C9B 1F                      	pop	ds
 38000 00006C9C 8B3E[B205]              	MOV     DI,[WFP_START]		; DS:SI point to string
 38001 00006CA0 C536[A205]              	LDS     SI,[THISCDS]		; point to CDS
 38002 00006CA4 E81B02                  	CALL    PathPref                ; is there a prefix?
 38003 00006CA7 7514                    	JNZ	short DoSplice		; no, do splice
 38004                                  
 38005                                  ; We have a match. Check to see if we ended in a path char.
 38006                                  
 38007 00006CA9 8A44FF                  	MOV     AL,[SI-1]		; last char to match
 38008 00006CAC E8F3E3                  	call    PATHCHRCMP              ; did we end on a path char? (root)
 38009 00006CAF 740C                    	JZ	short DoSplice		; yes, no current dir here.
 38010                                  Pathline:                               ; 2/13/KK
 38011 00006CB1 26803D00                	CMP     BYTE [ES:DI],0		; end at NUL?
 38012 00006CB5 7406                    	JZ	short DoSplice
 38013 00006CB7 47                      	INC     DI                      ; point to after current path char
 38014 00006CB8 36893E[B605]            	MOV     [SS:CURR_DIR_END],DI	; point to correct spot ;smr;SS Override
 38015                                  
 38016                                  ; Splice the result.
 38017                                  
 38018                                  DoSplice:
 38019 00006CBD 16                      	push	ss
 38020 00006CBE 1F                      	pop	ds			; back to DOSDATA
 38021 00006CBF 8B36[B205]              	MOV     SI,[WFP_START]		; point to beginning of string
 38022 00006CC3 31C9                    	XOR     CX,CX
 38023 00006CC5 F606[7105]FF            	TEST	byte [FSPLICE],-1
 38024 00006CCA 7403                    	JZ	short SkipSplice
 38025 00006CCC E82A01                  	CALL    Splice                  ; replaces in place.
 38026                                  SkipSplice:
 38027                                  
 38028                                  ; The final thing is to assure ourselves that a FATREAD is done on the local
 38029                                  ; device.
 38030                                  
 38031 00006CCF 16                      	push	ss
 38032 00006CD0 1F                      	pop	ds
 38033 00006CD1 C43E[A205]              	LES     DI,[THISCDS]		; point to correct drive
 38034                                  	;test	word [es:di+67],8000h
 38035                                  	; 17/12/2022
 38036                                  	;test	byte [es:di+68],80h
 38037 00006CD5 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8 ; 04/12/2022
 38038                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
 38039 00006CDA 750D                    	JNZ	short Done		; net, no fatread necessary (retnz)
 38040 00006CDC E30B                    	JCXZ    Done
 38041 00006CDE E82CA6                  	call	ECritDisk
 38042 00006CE1 E8F7E9                  	call	FATREAD_CDS
 38043 00006CE4 E841A6                  	call	LCritDisk
 38044                                  	;mov	al, 3
 38045 00006CE7 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 38046                                  Done:   
 38047 00006CE9 C3                      	retn                         ; any errors in carry flag.
 38048                                  
 38049                                  ; 13/07/2018
 38050                                  
 38051                                  ;BREAK <Canonicalize - copy a path and remove . and .. entries>
 38052                                  ;----------------------------------------------------------------------------
 38053                                  ;   Canonicalize - copy path removing . and .. entries.
 38054                                  ;
 38055                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 38056                                  ;               ES:DI - point to buffer
 38057                                  ;               BX - backup limit (offset from ES) points to slash
 38058                                  ;               BP - end of buffer
 38059                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 38060                                  ;                   syntax, etc.
 38061                                  ;               Carry Clear -
 38062                                  ;                   DS:DI - advanced to end of string
 38063                                  ;                   ES:DI - advanced to end of canonicalized form after nul
 38064                                  ;   Registers modified: AX CX DX (in addition to those above)
 38065                                  ;----------------------------------------------------------------------------
 38066                                  
 38067                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38068                                  
 38069                                  Canonicalize:
 38070                                  
 38071                                  ; We copy all leading path separators.
 38072                                  
 38073 00006CEA AC                      	LODSB                           ;   while (PathChr (*s))
 38074 00006CEB E8B4E3                  	call    PATHCHRCMP
 38075 00006CEE 7507                    	JNZ	short CanonDec
 38076 00006CF0 39EF                    	CMP     DI,BP                   ;       if (d > dlim)
 38077 00006CF2 7319                    	JAE	short CanonBad		;           goto error;
 38078 00006CF4 AA                      	STOSB
 38079 00006CF5 EBF3                    	JMP	short Canonicalize	;           *d++ = *s++;
 38080                                  CanonDec:
 38081 00006CF7 4E                      	DEC     SI
 38082                                  
 38083                                  ; Main canonicalization loop. We come here with DS:SI pointing to a textual
 38084                                  ; component (no leading path separators) and ES:DI being the destination
 38085                                  ; buffer.
 38086                                  
 38087                                  CanonLoop:
 38088                                  
 38089                                  ; If we are at the end of the source string, then we need to check to see that
 38090                                  ; a potential drive specifier is correctly terminated with a path sep char.
 38091                                  ; Otherwise, do nothing
 38092                                  
 38093 00006CF8 31C0                    	XOR     AX,AX
 38094 00006CFA 3804                    	CMP     [SI],AL                 ;       if (*s == 0) {
 38095 00006CFC 751A                    	JNZ	short DoComponent
 38096 00006CFE 26807DFF3A              	CMP     BYTE [ES:DI-1],':'	;           if (d[-1] == ':')
 38097 00006D03 7505                    	JNZ	short DoTerminate
 38098 00006D05 B05C                    	MOV     AL,'\'                  ;               *d++ = '\';
 38099 00006D07 AA                      	STOSB
 38100 00006D08 88E0                    	MOV     AL,AH
 38101                                  DoTerminate:
 38102 00006D0A AA                      	STOSB                           ;           *d++ = 0;
 38103 00006D0B F8                      	CLC                             ;           return (0);
 38104 00006D0C C3                      	retn
 38105                                  
 38106                                  CanonBad:
 38107 00006D0D E8CB01                  	CALL	ScanPathChar            ; check for path chars in rest of string
 38108                                  	;mov	al,3
 38109 00006D10 B003                    	MOV     AL,error_path_not_found ; Set up for bad path error
 38110 00006D12 7402                    	JZ	short PathEnc		; path character encountered in string
 38111                                  	;mov	al,2
 38112 00006D14 B002                    	MOV     AL,error_file_not_found ; Set bad file error
 38113                                  PathEnc:
 38114 00006D16 F9                      	STC
 38115                                  CanonBad_retn:
 38116 00006D17 C3                      	retn
 38117                                  
 38118                                  ; We have a textual component that we must copy. We uppercase it and truncate
 38119                                  ; it to 8.3
 38120                                  
 38121                                  DoComponent:                            ;           }
 38122 00006D18 E85000                  	CALL    CopyComponent		;       if (!CopyComponent (s, d))
 38123 00006D1B 72FA                    	jc	short CanonBad_retn	;           return (-1);
 38124                                  
 38125                                  ; We special case the . and .. cases.  These will be backed up.
 38126                                  
 38127                                  	;CMP	WORD PTR ES:[DI],'.' + (0 SHL 8)
 38128 00006D1D 26833D2E                	CMP	WORD [ES:DI],002Eh
 38129 00006D21 7408                    	JZ	short Skip1
 38130                                  	;CMP	WORD PTR ES:[DI],'..'
 38131 00006D23 26813D2E2E              	CMP     WORD [ES:DI],2E2Eh
 38132 00006D28 750A                    	JNZ	short CanonNormal
 38133 00006D2A 4F                      	DEC     DI                      ;           d--;
 38134                                  Skip1:  
 38135 00006D2B E82A00                  	CALL    SkipBack                ;           SkipBack ();
 38136                                  	;mov	al,3
 38137 00006D2E B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 38138 00006D30 72E5                    	jc	short CanonBad_retn
 38139 00006D32 EB02                    	JMP     short CanonPath         ;           }
 38140                                  
 38141                                  ; We have a normal path. Advance destination pointer over it.
 38142                                  
 38143                                  CanonNormal:                            ;       else
 38144 00006D34 01CF                    	ADD     DI,CX                   ;           d += ct;
 38145                                  
 38146                                  ; We have successfully copied a component. We are now pointing at a path
 38147                                  ; sep char or are pointing at a nul or are pointing at something else.
 38148                                  ; If we point at something else, then we have an error.
 38149                                  
 38150                                  CanonPath:
 38151 00006D36 E81600                  	CALL    PathSep
 38152 00006D39 75D2                    	JNZ	short CanonBad		; something else...
 38153                                  
 38154                                  ; Copy the first path char we see.
 38155                                  
 38156 00006D3B AC                      	LODSB                           ; get the char
 38157 00006D3C E863E3                  	call    PATHCHRCMP              ; is it path char?
 38158 00006D3F 75B6                    	JNZ	short CanonDec		; no, go test for nul
 38159 00006D41 39EF                    	CMP     DI,BP                   ; beyond buffer end?
 38160 00006D43 73C8                    	JAE	short CanonBad		; yep, error.
 38161 00006D45 AA                      	STOSB                           ; copy the one byte
 38162                                  
 38163                                  ; Skip all remaining path chars
 38164                                  
 38165                                  CanonPathLoop:
 38166 00006D46 AC                      	LODSB                           ; get next byte
 38167 00006D47 E858E3                  	call    PATHCHRCMP              ; path char again?
 38168 00006D4A 74FA                    	JZ	short CanonPathLoop	; yep, grab another
 38169 00006D4C 4E                      	DEC     SI                      ; back up
 38170 00006D4D EBA9                    	JMP	short  CanonLoop	; go copy component
 38171                                  
 38172                                  ;BREAK <PathSep - determine if char is a path separator>
 38173                                  ;----------------------------------------------------------------------------
 38174                                  ;   PathSep - look at DS:SI and see if char is / \ or NUL
 38175                                  ;   Inputs:     DS:SI - point to a char
 38176                                  ;   Outputs:    AL has char from DS:SI (/ => \)
 38177                                  ;               Zero set if AL is / \ or NUL
 38178                                  ;               Zero reset otherwise
 38179                                  ;   Registers modified: AL
 38180                                  ;----------------------------------------------------------------------------
 38181                                  
 38182                                  PathSep:
 38183 00006D4F 8A04                    	MOV     AL,[SI]                 ; get the character
 38184                                  PathSepGotCh:				; already have character
 38185 00006D51 08C0                    	OR      AL,AL                   ; test for zero
 38186 00006D53 74C2                    	jz	short CanonBad_retn	; return if equal to zero (NUL)
 38187                                  	;call	PATHCHRCMP              ; check for path character
 38188                                  	;retn				; and return HIS determination
 38189                                  	; 18/12/2022
 38190 00006D55 E94AE3                  	jmp	PATHCHRCMP
 38191                                  
 38192                                  
 38193                                  ;BREAK <SkipBack - move backwards to a path separator>
 38194                                  ;----------------------------------------------------------------------------
 38195                                  ;   SkipBack - look at ES:DI and backup until it points to a / ;   Inputs:     ES:DI - point to a char
 38197                                  ;               BX has current directory back up limit (point to a / \)
 38198                                  ;   Outputs:    ES:DI backed up to point to a path char
 38199                                  ;               AL has char from output ES:DI (path sep if carry clear)
 38200                                  ;               Carry set if illegal backup
 38201                                  ;               Carry Clear if ok
 38202                                  ;   Registers modified: DI,AL
 38203                                  ;----------------------------------------------------------------------------
 38204                                  
 38205                                  SkipBack:
 38206 00006D58 39DF                    	CMP     DI,BX                   ;   while (TRUE) {
 38207 00006D5A 720B                    	JB	short SkipBad		;       if (d < dlim)
 38208 00006D5C 4F                      	DEC     DI                      ;           goto err;
 38209 00006D5D 268A05                  	MOV     AL,[ES:DI]		;       if (pathchr (*--d))
 38210 00006D60 E83FE3                  	call    PATHCHRCMP              ;           break;
 38211 00006D63 75F3                    	JNZ	short SkipBack		;       }
 38212 00006D65 F8                      	CLC                             ;   return (0);
 38213 00006D66 C3                      	retn				;
 38214                                  SkipBad:                                ;err:
 38215                                  	;mov	al,3
 38216 00006D67 B003                    	MOV     AL,error_path_not_found ; bad path error
 38217 00006D69 F9                      	STC                             ;   return (-1);
 38218 00006D6A C3                      	retn				;
 38219                                  
 38220                                  ;Break <CopyComponent - copy out a file path component>
 38221                                  ;----------------------------------------------------------------------------
 38222                                  ;   CopyComponent - copy a file component from a path string (DS:SI) into ES:DI
 38223                                  ;
 38224                                  ;   Inputs:     DS:SI - source path
 38225                                  ;               ES:DI - destination
 38226                                  ;               ES:BP - end of buffer
 38227                                  ;   Outputs:    Carry Set - too long
 38228                                  ;               Carry Clear - DS:SI moved past component
 38229                                  ;                   CX has length of destination
 38230                                  ;   Registers modified: AX,CX,DX
 38231                                  ;----------------------------------------------------------------------------
 38232                                  
 38233                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38234                                  
 38235                                  CopyComponent:
 38236                                  
 38237                                  %define CopyBP	 [BP]		; word
 38238                                  %define CopyD	 [BP+2]		; dword
 38239                                  %define CopyDoff [BP+2]		; word
 38240                                  %define CopyS	 [BP+6]		; dword
 38241                                  %define CopySoff [BP+6]		; word
 38242                                  %define CopyTemp [BP+10]	; byte
 38243                                  
 38244 00006D6B 83EC0E                  	SUB     SP,14                   ; room for temp buffer
 38245 00006D6E 1E                      	push	ds
 38246 00006D6F 56                      	push	si
 38247 00006D70 06                      	push	es
 38248 00006D71 57                      	push	di
 38249 00006D72 55                      	push	bp
 38250 00006D73 89E5                    	MOV     BP,SP
 38251 00006D75 B42E                    	MOV     AH,'.'
 38252 00006D77 AC                      	LODSB
 38253 00006D78 AA                      	STOSB
 38254 00006D79 38E0                    	CMP     AL,AH                   ;   if ((*d++=*s++) == '.') {
 38255 00006D7B 7518                    	JNZ	short NormalComp
 38256 00006D7D E8CFFF                  	CALL    PathSep                 ;       if (!pathsep(*s))
 38257 00006D80 740B                    	JZ	short NulTerm
 38258                                  TryTwoDot:
 38259 00006D82 AC                      	LODSB                           ;           if ((*d++=*s++) != '.'
 38260 00006D83 AA                      	STOSB
 38261 00006D84 38E0                    	CMP     AL,AH
 38262 00006D86 7557                    	JNZ	short CopyBad
 38263 00006D88 E8C4FF                  	CALL    PathSep
 38264 00006D8B 7552                    	JNZ	short CopyBad		;               || !pathsep (*s))
 38265                                  NulTerm:                                ;               return -1;
 38266 00006D8D 30C0                    	XOR     AL,AL                   ;       *d++ = 0;
 38267 00006D8F AA                      	STOSB
 38268 00006D90 897606                  	MOV     CopySoff,SI
 38269 00006D93 EB47                    	JMP     SHORT _GoodRet		;       }
 38270                                  NormalComp:                             ;   else {
 38271 00006D95 8B7606                  	MOV     SI,CopySoff ; [bp+6]
 38272 00006D98 E845E2                  	call	NameTrans               ;       s = NameTrans (s, Name1);
 38273 00006D9B 3B7606                  	CMP     SI,CopySoff             ;       if (s == CopySOff)
 38274 00006D9E 743F                    	JZ	short CopyBad		;           return (-1);
 38275 00006DA0 36F606[7205]FF          	TEST	byte [SS:FSHARING],-1	;       if (!fSharing) {;smr;SS Override
 38276 00006DA6 7510                    	JNZ	short DoPack
 38277 00006DA8 80E201                  	AND     DL,1                    ;           cMeta += fMeta;
 38278 00006DAB 360016[7A05]            	ADD	[ss:CMETA],DL		;           if (cMeta > 0);smr;SS Override
 38279 00006DB0 7F2D                    	JG	short CopyBad		;               return (-1);
 38280 00006DB2 7504                    	JNZ	short DoPack		;           else
 38281 00006DB4 08D2                    	OR      DL,DL                   ;           if (cMeta == 0 && fMeta == 0)
 38282 00006DB6 742F                    	JZ	short CopyBadPath	;               return (-1);
 38283                                  DoPack:                                 ;           }
 38284 00006DB8 897606                  	MOV     CopySoff,SI ; [bp+6]
 38285 00006DBB 16                      	push	ss
 38286 00006DBC 1F                      	pop	ds
 38287 00006DBD BE[4B05]                	MOV     SI,NAME1
 38288 00006DC0 8D7E0A                  	LEA     DI,CopyTemp ; [bp+10]
 38289 00006DC3 57                      	push	di
 38290 00006DC4 E8F9B2                  	call	PackName                ;       PackName (Name1, temp);
 38291 00006DC7 5F                      	pop	di
 38292 00006DC8 E820A4                  	call	StrLen                  ;       if (strlen(temp)+d > bp)
 38293 00006DCB 49                      	DEC     CX
 38294 00006DCC 034E02                  	ADD     CX,CopyDoff ; [bp+2]
 38295                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38296                                  	;cmp	cx,[bp+0]
 38297                                  	; 15/12/2022
 38298                                  	;cmp	cx,[bp]
 38299 00006DCF 3B4E00                  	CMP	CX,CopyBP   ; [bp+0]
 38300 00006DD2 730B                    	JAE	short CopyBad		;           return (-1);
 38301 00006DD4 89FE                    	MOV     SI,DI                   ;       strcpy (d, temp);
 38302 00006DD6 C47E02                  	LES     DI,CopyD    ; [bp+2]	
 38303 00006DD9 E806A4                  	call	FStrCpy
 38304                                  _GoodRet:				;       }
 38305 00006DDC F8                      	CLC
 38306 00006DDD EB0B                    	JMP     SHORT CopyEnd           ;   return 0;
 38307                                  CopyBad:
 38308 00006DDF F9                      	STC
 38309 00006DE0 E8F800                  	CALL    ScanPathChar            ; check for path chars in rest of string
 38310                                  	;mov	al,2
 38311 00006DE3 B002                    	MOV     AL,error_file_not_found ; Set up for bad file error
 38312 00006DE5 7503                    	JNZ	short CopyEnd
 38313                                  CopyBadPath:
 38314 00006DE7 F9                      	STC
 38315                                  	;mov	al,3
 38316 00006DE8 B003                    	MOV     AL,error_path_not_found ; Set bad path error
 38317                                  CopyEnd:
 38318 00006DEA 5D                      	pop	bp
 38319 00006DEB 5F                      	pop	di
 38320 00006DEC 07                      	pop	es
 38321 00006DED 5E                      	pop	si
 38322 00006DEE 1F                      	pop	ds
 38323 00006DEF 9F                      	LAHF
 38324 00006DF0 83C40E                  	ADD     SP,14                   ; reclaim temp buffer
 38325 00006DF3 E8F5A3                  	call	StrLen
 38326 00006DF6 49                      	DEC     CX
 38327 00006DF7 9E                      	SAHF
 38328 00006DF8 C3                      	retn
 38329                                  
 38330                                  ; 14/05/2019 - Retro DOS v4.0
 38331                                  ; DOSCODE:AE22h (MSDOS 6.21, MSDOS.SYS)
 38332                                  
 38333                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38334                                  ; DOSCODE:ADBFh (MSDOS 5.0, MSDOS.SYS)
 38335                                  
 38336                                  ;Break <Splice - pseudo mount by string substitution>
 38337                                  ;----------------------------------------------------------------------------
 38338                                  ;   Splice - take a string and substitute a prefix if one exists. Change
 38339                                  ;       ThisCDS to point to physical drive CDS.
 38340                                  ;   Inputs:     DS:SI point to string
 38341                                  ;               NoSetDir = TRUE => exact matches with splice fail
 38342                                  ;   Outputs:    DS:SI points to thisCDS
 38343                                  ;               ES:DI points to DPB
 38344                                  ;               String at DS:SI may be reduced in length by removing prefix
 38345                                  ;               and substituting drive letter.
 38346                                  ;               CX = 0 If no splice done
 38347                                  ;               CX <> 0 otherwise
 38348                                  ;               ThisCDS points to proper CDS if spliced, otherwise it is
 38349                                  ;                   left alone
 38350                                  ;               ThisDPB points to proper DPB
 38351                                  ;   Registers modified: DS:SI, ES:DI, BX,AX,CX
 38352                                  ;----------------------------------------------------------------------------
 38353                                  
 38354                                  Splice:
 38355 00006DF9 36F606[5A00]FF          	TEST	byte [SS:SPLICES],-1	;smr;SS Override
 38356 00006DFF 7469                    	JZ	short AllDone
 38357 00006E01 36FF36[A205]            	push	word [SS:THISCDS]
 38358 00006E06 36FF36[A405]            	push	word [SS:THISCDS+2]	; TmpCDS = ThisCDS;smr;SS Override
 38359 00006E0B 1E                      	push	ds
 38360 00006E0C 56                      	push	si
 38361 00006E0D 5F                      	pop	di
 38362 00006E0E 07                      	pop	es
 38363 00006E0F 31C0                    	XOR     AX,AX                   ;   for (i=1; s = GetCDSFromDrv (i); i++)
 38364                                  SpliceScan:
 38365 00006E11 E8DFFC                  	call	GetCDSFromDrv
 38366 00006E14 724A                    	JC	short SpliceDone
 38367 00006E16 FEC0                    	INC     AL
 38368                                  	; 17/12/2022
 38369                                  	;test	byte [si+68],20h
 38370 00006E18 F6444420                	test	byte [si+curdir.flags+1],curdir_splice>>8 ; 04/12/2022
 38371                                  	;;test	word [si+67],2000h
 38372                                  	;TEST	word [SI+curdir.flags],curdir_splice
 38373 00006E1C 74F3                    	JZ	short SpliceScan 	;       if ( Spliced (i) ) {
 38374 00006E1E 57                      	push	di
 38375 00006E1F E8A000                  	CALL    PathPref                ;           if (!PathPref (s, d))
 38376 00006E22 7403                    	JZ	short SpliceFound	;
 38377                                  SpliceSkip:
 38378 00006E24 5F                      	pop	di
 38379 00006E25 EBEA                    	JMP	short SpliceScan	;               continue;
 38380                                  SpliceFound:
 38381 00006E27 26803D00                	CMP     BYTE [ES:DI],0		;           if (*s || NoSetDir) {
 38382 00006E2B 7508                    	JNZ	short SpliceDo
 38383 00006E2D 36F606[4C03]FF          	TEST	byte [ss:NoSetDir],-1			;smr;SS Override
 38384 00006E33 75EF                    	JNZ	short SpliceSkip
 38385                                  SpliceDo:
 38386 00006E35 89FE                    	MOV     SI,DI                   ;               p = src + strlen (p);
 38387 00006E37 06                      	push	es
 38388 00006E38 1F                      	pop	ds
 38389 00006E39 5F                      	pop	di
 38390 00006E3A E87F00                  	CALL	TextFromDrive1          ;               src = TextFromDrive1(src,i);
 38391 00006E3D 36A1[B605]              	MOV     AX,[SS:CURR_DIR_END]			;smr;SS Override
 38392 00006E41 09C0                    	OR      AX,AX
 38393 00006E43 7808                    	JS	short NoPoke
 38394 00006E45 01F8                    	ADD     AX,DI                   ;               curdirend += src-p;
 38395 00006E47 29F0                    	SUB     AX,SI
 38396 00006E49 36A3[B605]              	MOV     [SS:CURR_DIR_END],AX			;smr;SS Override
 38397                                  NoPoke:
 38398 00006E4D 803C00                  	CMP     BYTE [SI],0		;               if (*p)
 38399 00006E50 7503                    	JNZ	short SpliceCopy	;                   *src++ = '\\';
 38400 00006E52 B05C                    	MOV     AL,"\"
 38401 00006E54 AA                      	STOSB
 38402                                  SpliceCopy:                             ;               strcpy (src, p);
 38403 00006E55 E88AA3                  	call	FStrCpy
 38404 00006E58 83C404                  	ADD     SP,4                    ; throw away saved stuff
 38405 00006E5B 80C901                  	OR      CL,1                    ; signal splice done.
 38406 00006E5E EB0C                    	JMP     SHORT DoSet             ;               return;
 38407                                  SpliceDone:                             ;               }
 38408 00006E60 368F06[A405]            	pop	word [SS:THISCDS+2]     ;   ThisCDS = TmpCDS;
 38409 00006E65 368F06[A205]            	pop	word [SS:THISCDS]			;smr;SS Override
 38410                                  AllDone:
 38411 00006E6A 31C9                    	XOR     CX,CX
 38412                                  DoSet:
 38413 00006E6C 36C536[A205]            	LDS     SI,[SS:THISCDS]		;   ThisDPB = ThisCDS->devptr;;smr;SS Override
 38414                                  	;les	di,[si+69]
 38415 00006E71 C47C45                  	LES     DI,[SI+curdir.devptr]	
 38416 00006E74 36893E[8A05]            	MOV	[SS:THISDPB],DI				;smr;SS Override
 38417 00006E79 368C06[8C05]            	MOV	[SS:THISDPB+2],ES			;smr;SS Override
 38418                                  Splice_retn:
 38419 00006E7E C3                      	retn
 38420                                  
 38421                                  ; 15/05/2019 - Retro DOS v4.0
 38422                                  ; DOSCODE:AEA9h (MSDOS 6.21, MSDOS.SYS)
 38423                                  
 38424                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38425                                  ; DOSCODE:AE46h (MSDOS 5.0, MSDOS.SYS)
 38426                                  
 38427                                  ;Break <$NameTrans - partially process a name>
 38428                                  ;----------------------------------------------------------------------------
 38429                                  ;   $NameTrans - allow users to see what names get mapped to. This call
 38430                                  ;   performs only string substitution and canonicalization, not splicing.  Due
 38431                                  ;   to Transpath playing games with devices, we need to insure that the output
 38432                                  ;   has drive letter and : in it.
 38433                                  ;
 38434                                  ;   Inputs:     DS:SI - source string for translation
 38435                                  ;               ES:DI - pointer to buffer
 38436                                  ;   Outputs:
 38437                                  ;       Carry Clear
 38438                                  ;               Buffer at ES:DI is filled in with data
 38439                                  ;               ES:DI point byte after nul byte at end of dest string in buffer
 38440                                  ;       Carry Set
 38441                                  ;               AX = error_path_not_found
 38442                                  ;   Registers modified: all
 38443                                  ;----------------------------------------------------------------------------
 38444                                  
 38445                                  _$NameTrans:
 38446 00006E7F 1E                      	push	ds
 38447 00006E80 56                      	push	si
 38448 00006E81 06                      	push	es
 38449 00006E82 57                      	push	di
 38450 00006E83 51                      	push	cx ; MSDOS 6.0
 38451                                  	
 38452                                  	; MSDOS 6.0	
 38453                                  ; M027 - Start
 38454                                  ;
 38455                                  ; Sattrib must be set up with default values here. Otherwise, the value from
 38456                                  ; a previous DOS call is used for attrib and DevName thinks it is not a 
 38457                                  ; device if the old call set the volume attribute bit. Note that devname in
 38458                                  ; dir2.asm gets ultimately called by Transpath. See also M026. Also save
 38459                                  ; and restore CX.
 38460                                  
 38461                                  	;mov	ch,16h
 38462 00006E84 B516                    	mov     ch,attr_hidden+attr_system+attr_directory
 38463 00006E86 E8B902                  	call	SetAttrib
 38464                                  
 38465                                  ; M027 - End
 38466                                  
 38467                                  	; MSDOS 3.3 (& MSDOS 6.0)
 38468 00006E89 BF[BE03]                	MOV     DI,OPENBUF
 38469 00006E8C E8E6FC                  	CALL    TransPath               ; to translation (everything)
 38470 00006E8F 59                      	pop	cx ; MSDOS 6.0
 38471 00006E90 5F                      	pop     di
 38472 00006E91 07                      	pop	es
 38473 00006E92 5E                      	pop     si
 38474 00006E93 1F                      	pop     ds
 38475 00006E94 7303                    	JNC	short TransOK
 38476 00006E96 E9A797                  	jmp	SYS_RET_ERR
 38477                                  TransOK:
 38478 00006E99 BE[BE03]                	MOV     SI,OPENBUF
 38479 00006E9C 16                      	push	ss
 38480 00006E9D 1F                      	pop	ds
 38481                                  ;GotText:
 38482 00006E9E E841A3                  	call	FStrCpy
 38483 00006EA1 E99397                  	jmp	SYS_RET_OK
 38484                                  
 38485                                  ;Break   <DriveFromText - return drive number from a text string>
 38486                                  ;----------------------------------------------------------------------------
 38487                                  ;   DriveFromText - examine DS:SI and remove a drive letter, advancing the
 38488                                  ;   pointer.
 38489                                  ;
 38490                                  ;   Inputs:     DS:SI point to a text string
 38491                                  ;   Outputs:    AL has drive number
 38492                                  ;               DS:SI advanced
 38493                                  ;   Registers modified: AX,SI.
 38494                                  ;----------------------------------------------------------------------------
 38495                                  
 38496                                  DriveFromText:
 38497 00006EA4 30C0                    	XOR     AL,AL                   ;       drive = 0;
 38498                                  	;CMP	BYTE [SI],0		;       if (*s &&
 38499                                  	; 23/09/2023
 38500 00006EA6 3804                    	cmp	[si],al ; 0
 38501 00006EA8 74D4                    	jz	short Splice_retn
 38502 00006EAA 807C013A                	CMP     BYTE [SI+1],':'		;           s[1] == ':') {
 38503 00006EAE 75CE                    	jnz	short Splice_retn
 38504 00006EB0 AD                      	LODSW                           ;           drive = (*s | 020) - 'a'+1;
 38505 00006EB1 0C20                    	OR      AL,20h
 38506                                  	;sub	al,60h
 38507 00006EB3 2C60                    	SUB     AL,'a'-1                ;           s += 2;
 38508 00006EB5 75C7                    	jnz	short Splice_retn
 38509 00006EB7 B0FF                    	MOV	AL,-1                   ; nuke AL...
 38510                                  	; 23/09/2023
 38511                                  	;dec	al ; -1
 38512 00006EB9 C3                      	retn				;           }
 38513                                  
 38514                                  ;Break   <TextFromDrive - convert a drive number to a text string>
 38515                                  ;----------------------------------------------------------------------------
 38516                                  ;   TextFromDrive - turn AL into a drive letter: and put it at es:di with
 38517                                  ;   trailing :. TextFromDrive1 takes a 1-based number.
 38518                                  ;
 38519                                  ;   Inputs:     AL has 0-based drive number
 38520                                  ;   Outputs:    ES:DI advanced
 38521                                  ;   Registers modified: AX
 38522                                  ;----------------------------------------------------------------------------
 38523                                  
 38524                                  TextFromDrive:
 38525 00006EBA FEC0                    	INC     AL
 38526                                  TextFromDrive1:
 38527                                  	;add	al,40h
 38528 00006EBC 0440                    	ADD     AL,'A'-1                ;   *d++ = drive-1+'A';
 38529 00006EBE B43A                    	MOV     AH,":"	; 3Ah           ;   strcat (d, ":");
 38530 00006EC0 AB                      	STOSW
 38531                                  PathPref_retn:
 38532 00006EC1 C3                      	retn
 38533                                  
 38534                                  ;Break   <PathPref - see if one path is a prefix of another>
 38535                                  ;----------------------------------------------------------------------------
 38536                                  ;   PathPref - compare DS:SI with ES:DI to see if one is the prefix of the
 38537                                  ;   other.  Remember that only at a pathchar break are we allowed to have a
 38538                                  ;   prefix: A:\ and A:\FOO
 38539                                  ;
 38540                                  ;   Inputs:     DS:SI potential prefix
 38541                                  ;               ES:DI string
 38542                                  ;   Outputs:    Zero set => prefix found
 38543                                  ;                   DI/SI advanced past matching part
 38544                                  ;               Zero reset => no prefix, DS/SI garbage
 38545                                  ;   Registers modified: CX
 38546                                  ;----------------------------------------------------------------------------
 38547                                  
 38548                                  PathPref:
 38549 00006EC2 E834A3                  	call	DStrLen                 ; get length
 38550 00006EC5 49                      	DEC     CX                      ; do not include nul byte
 38551 00006EC6 F3A6                    	REPZ    CMPSB                   ; compare
 38552 00006EC8 75F7                    	jnz	short PathPref_retn	; if NZ then return NZ
 38553 00006ECA 50                      	push	ax			; save char register
 38554 00006ECB 8A44FF                  	MOV     AL,[SI-1]               ; get last byte to match
 38555 00006ECE E8D1E1                  	call    PATHCHRCMP              ; is it a path char (Root!)
 38556 00006ED1 7406                    	JZ	short Prefix		; yes, match root (I hope)
 38557                                  NotSep:                                 ; 2/13/KK
 38558 00006ED3 268A05                  	MOV     AL,[ES:DI]		; get next char to match
 38559 00006ED6 E878FE                  	CALL    PathSepGotCh            ; was it a pathchar?
 38560                                  Prefix:
 38561 00006ED9 58                      	pop	ax			; get back original
 38562 00006EDA C3                      	retn
 38563                                  
 38564                                  ;Break   <ScanPathChar - see if there is a path character in a string>
 38565                                  ;----------------------------------------------------------------------------
 38566                                  ;     ScanPathChar - search through the string (pointed to by DS:SI) for
 38567                                  ;     a path separator.
 38568                                  ;
 38569                                  ;     Input:    DS:SI target string (null terminated)
 38570                                  ;     Output:   Zero set => path separator encountered in string
 38571                                  ;               Zero clear => null encountered
 38572                                  ;     Registers modified: SI
 38573                                  ;----------------------------------------------------------------------------
 38574                                  
 38575                                  ScanPathChar:
 38576 00006EDB AC                      	LODSB                           ; fetch a character
 38577 00006EDC E872FE                  	call    PathSepGotCh
 38578 00006EDF 75FA                    	JNZ	short ScanPathChar	; not \, / or NUL => go back for more
 38579                                  	;call	PATHCHRCMP              ; path separator?
 38580                                  	;retn
 38581                                  	; 18/12/2022
 38582 00006EE1 E9BEE1                  	jmp	PATHCHRCMP
 38583                                  
 38584                                  ;============================================================================
 38585                                  ; FILE.ASM, MSDOS 6.0, 1991
 38586                                  ;============================================================================
 38587                                  ; 14/07/2018 - Retro DOS v3.0
 38588                                  
 38589                                  ; 13/05/2019 - Retro DOS v4.0
 38590                                  ; DOSCODE:AF10h (MSDOS 6.21, MSDOS.SYS)
 38591                                  
 38592                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38593                                  ; DOSCODE:AEADh (MSDOS 5.0, MSDOS.SYS)
 38594                                  
 38595                                  ; MSDOS 2.11
 38596                                  ;BREAK <$Open - open a file handle>
 38597                                  ;----------------------------------------------------------------------------
 38598                                  ;   Assembler usage:
 38599                                  ;           LDS     DX, Name
 38600                                  ;           MOV     AH, Open
 38601                                  ;           MOV     AL, access
 38602                                  ;           INT     int_command
 38603                                  ;
 38604                                  ;       ACCESS          Function
 38605                                  ;       ------          --------
 38606                                  ;       open_for_read   file is opened for reading
 38607                                  ;       open_for_write  file is opened for writing
 38608                                  ;       open_for_both   file is opened for both reading and writing.
 38609                                  ;
 38610                                  ;   Error returns:
 38611                                  ;           AX = error_invalid_access
 38612                                  ;              = error_file_not_found
 38613                                  ;              = error_access_denied
 38614                                  ;              = error_too_many_open_files
 38615                                  ;----------------------------------------------------------------------------
 38616                                  
 38617                                  ; MSDOS 6.0
 38618                                  ;	BREAK <$Open - open a file from a path string>
 38619                                  ;----------------------------------------------------------------------------
 38620                                  ;
 38621                                  ;**	$OPen - Open a File
 38622                                  ;
 38623                                  ;	given a path name in DS:DX and an open mode in AL, $Open opens the
 38624                                  ;	file and and returns a handle
 38625                                  ;
 38626                                  ;	ENTRY	(DS:DX) = pointer to asciz name
 38627                                  ;		(AL) = open mode
 38628                                  ;	EXIT	'C' clear if OK
 38629                                  ;		  (ax) = file handle
 38630                                  ;		'C' set if error
 38631                                  ;		  (ax) = error code
 38632                                  ;	USES	all
 38633                                  ;
 38634                                  ;----------------------------------------------------------------------------
 38635                                  
 38636                                  ; 13/05/2019 - Retro DOS v4.0
 38637                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38638                                  
 38639                                  _$OPEN:       
 38640 00006EE4 30E4                    	xor	ah,ah  ; MSDOS 6.0	
 38641                                  _$Open2:
 38642                                  	;mov	ch,16h
 38643 00006EE6 B516                    	mov	ch,attr_hidden+attr_system+attr_directory
 38644 00006EE8 E85702                  	call	SetAttrib
 38645 00006EEB B9[822B]                	mov	cx,DOS_OPEN
 38646                                  
 38647                                  	;xor	ah,ah  ; MSDOS 3.3
 38648                                  
 38649 00006EEE 50                      	push	ax
 38650                                  
 38651                                  ;*	General file open/create code. The $CREATE call and the various
 38652                                  ;	$OPEN calls all come here.
 38653                                  ;
 38654                                  ;	We'll share a lot of the standard stuff of allocating SFTs, cracking
 38655                                  ;	path names, etc., and then dispatch to our individual handlers.
 38656                                  ;	WARNING - this info and list is just a guess, not definitive - jgl
 38657                                  ;
 38658                                  ;	(TOS) = create mode
 38659                                  ;	(CX) = address of routine to call to do actual function
 38660                                  ;	(DS:DX) = ASCIZ name
 38661                                  ;	SAttrib = Attribute mask
 38662                                  
 38663                                  ;	Get a free SFT and mark it "being allocated"
 38664                                  
 38665                                  AccessFile:
 38666 00006EEF E81BA4                  	call	ECritSFT
 38667 00006EF2 E8D8F7                  	call	SFNFree			; get a free sfn
 38668 00006EF5 E830A4                  	call	LCritSFT
 38669 00006EF8 7214                    	jc	short OpenFailJ		; oops, no free sft's
 38670 00006EFA 36891E[AA05]            	MOV	[SS:SFN],BX		; save the SFN for later;smr;SS Override
 38671 00006EFF 36893E[9E05]            	MOV	[SS:THISSFT],DI		; save the SF offset	;smr;SS Override
 38672 00006F04 368C06[A005]            	MOV	[SS:THISSFT+2],ES	; save the SF segment	;smr;SS Override
 38673                                  
 38674                                  ;	Find a free area in the user's JFN table.
 38675                                  
 38676 00006F09 E8AEF7                  	call	JFNFree			; get a free jfn
 38677 00006F0C 7303                    	jnc	short SaveJFN
 38678                                  OpenFailJ:
 38679 00006F0E E99300                  	JMP	OpenFail		; there were free JFNs... try SFN
 38680                                  
 38681                                  SaveJFN:
 38682 00006F11 36893E[AE05]            	mov	[ss:PJFN],DI		; save the jfn offset	;smr;SS Override
 38683 00006F16 368C06[B005]            	MOV	[ss:PJFN+2],ES		; save the jfn segment	;smr;SS Override
 38684 00006F1B 36891E[AC05]            	MOV	[ss:JFN],BX		; save the jfn itself	;smr;SS Override
 38685                                  
 38686                                  ;	We have been given an JFN. We lock it down to prevent other tasks from
 38687                                  ;	reusing the same JFN.
 38688                                  
 38689 00006F20 368B1E[AA05]            	MOV	BX,[ss:SFN]					;smr;SS Override
 38690 00006F25 26881D                  	MOV	[ES:DI],BL		; assign the JFN
 38691 00006F28 89D6                    	MOV	SI,DX			; get name in appropriate place
 38692 00006F2A BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 38693 00006F2D 51                      	push	cx			; save routine to call
 38694 00006F2E E844FC                  	call	TransPath		; convert the path
 38695 00006F31 5B                      	pop	bx			; (bx) = routine to call
 38696                                  
 38697 00006F32 36C536[9E05]            	LDS	SI,[SS:THISSFT]					;smr;SS Override
 38698 00006F37 720A                    	JC	short OpenCleanJ	; no error, go and open file
 38699 00006F39 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1				;smr;SS Override
 38700 00006F3F 7404                    	JZ	short SetSearch
 38701                                  	;mov	al,2
 38702 00006F41 B002                    	MOV	AL,error_file_not_found ; no meta chars allowed
 38703                                  OpenCleanJ:
 38704 00006F43 EB50                    	JMP	short OpenClean
 38705                                  
 38706                                  SetSearch:
 38707 00006F45 58                      	pop	ax			; Mode (Open), Attributes (Create)
 38708                                  
 38709                                  ;	We need to get the new inheritance bits.
 38710                                  
 38711 00006F46 31C9                    	xor	cx,cx
 38712                                  	; MSDOS 6.0
 38713                                  	;mov	[si+2],cx ; 0
 38714 00006F48 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],cx ; initialize mode field to 0
 38715                                  	;mov    [si+51],cx ; 0
 38716 00006F4B 894C33                  	MOV	[SI+SF_ENTRY.sf_MFT],cx	 ; clean out sharing info
 38717                                  	;
 38718 00006F4E 81FB[822B]              	CMP	BX,DOS_OPEN
 38719 00006F52 7509                    	JNZ	short _DoOper
 38720                                  	;test   al,80h
 38721 00006F54 A880                    	test	AL,SHARING_NO_INHERIT	; look for no inher
 38722 00006F56 7405                    	JZ	short _DoOper ; 10/08/2018
 38723 00006F58 247F                    	AND	AL,7Fh			; mask off inherit bit
 38724                                  	;mov	cx,1000h
 38725 00006F5A B90010                  	MOV	CX,sf_no_inherit
 38726                                  _DoOper:
 38727                                  	;; MSDOS 3.3
 38728                                  	;;mov	word [si+2], 0
 38729                                  	;;mov	word [si+33h], 0
 38730                                  	;MOV	word [SI+SF_ENTRY.sf_mode],0
 38731                                  	;MOV	word [SI+SF_ENTRY.sf_MFT],0
 38732                                  
 38733                                  	; MSDOS 6.0
 38734                                  ;**	Check if this is an extended open. If so you must set the
 38735                                  ;	modes in sf_mode. Call Set_EXT_mode to do all this. See
 38736                                  ;	Set_EXT_mode in creat.asm
 38737                                  
 38738                                  	; MSDOS 6.0
 38739                                  	;SAVE	<di, es>                ;M022 conditional removed here
 38740 00006F5D 57                      	push	di
 38741 00006F5E 06                      	push	es
 38742 00006F5F 1E                      	push	ds
 38743 00006F60 07                      	pop	es
 38744 00006F61 56                      	push	si
 38745 00006F62 5F                      	pop	di			; (es:di) = SFT address
 38746 00006F63 E808BC                  	call	Set_EXT_mode
 38747                                  	;RESTORE <es, di>
 38748 00006F66 07                      	pop	es
 38749 00006F67 5F                      	pop	di
 38750                                  
 38751                                  	;Context DS
 38752 00006F68 16                      	push	ss
 38753 00006F69 1F                      	pop	ds	
 38754                                  
 38755 00006F6A 51                      	push	cx
 38756 00006F6B FFD3                    	CALL	BX			; blam!
 38757 00006F6D 59                      	pop	cx
 38758 00006F6E C536[9E05]              	LDS	SI,[THISSFT]
 38759 00006F72 721A                    	JC	short OpenE2		;AN000;FT. chek extended open hooks first
 38760                                  	;jc	short OpenE ; MSDOS 3.3
 38761                                  
 38762                                  ;	The SFT was successfully opened. Remove busy mark.
 38763                                  
 38764                                  OpenOK:
 38765                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],1
 38766 00006F74 C7040100                	mov	word [SI],1
 38767                                  	;or	[SI+5],cx
 38768 00006F78 094C05                  	OR	[SI+SF_ENTRY.sf_flags],CX ; set no inherit bit if necessary
 38769                                  
 38770                                  ; If the open mode is 70, we scan the system for other SFT's with the same
 38771                                  ; contents. If we find one, then we can 'collapse' thissft onto the already
 38772                                  ; opened one. Otherwise we use this new one. We compare uid/pid/mode/mft
 38773                                  ;
 38774                                  ; Since this is only relevant on sharer systems, we stick this code into the
 38775                                  ; sharer.
 38776                                  
 38777 00006F7B 36A1[AC05]              	MOV	AX,[ss:JFN]				;smr;SS Override
 38778 00006F7F 36FF1E[C000]            	Call	far [ss:JShare+(12*4)]	; 12 = ShCol	;smr;SS Override
 38779                                  
 38780 00006F84 36C706[AA05]FFFF        	MOV	word [ss:SFN],-1	; clear out sfn pointer	;smr;SS Override
 38781                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38782                                  OpenOkj:
 38783 00006F8B E9A996                  	jmp	SYS_RET_OK		; bye with no errors
 38784                                  
 38785                                  	; MSDOS 6.0
 38786                                  ;Extended Open hooks check
 38787                                  OpenE2:					;AN000;;EO.
 38788 00006F8E 83F857                  	CMP	AX,error_invalid_parameter ;AN000;;EO. IFS extended open ?
 38789 00006F91 7503                    	JNZ	short OpenE		;AN000;;EO. no.
 38790 00006F93 EB11                    	JMP	short OpenCritLeave	;AN000;;EO. keep handle
 38791                                  
 38792                                  ;	Extended Open hooks check
 38793                                  ;
 38794                                  ;	AL has error code.  Stack has argument to dos_open/dos_create.
 38795                                  
 38796                                  OpenClean:
 38797 00006F95 5B                      	pop	bx			; clean off stack
 38798                                  OpenE:
 38799                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],0 ; release SFT
 38800 00006F96 C7040000                	mov	word [SI],0
 38801 00006F9A 36C536[AE05]            	LDS	SI,[ss:PJFN]		;smr;SS Override
 38802 00006F9F C604FF                  	MOV	BYTE [SI],0FFh		; free the SFN...
 38803 00006FA2 EB02                    	JMP	SHORT OpenCritLeave
 38804                                  
 38805                                  OpenFail:
 38806 00006FA4 FB                      	STI
 38807 00006FA5 59                      	pop	cx			; Clean stack
 38808                                  OpenCritLeave:
 38809 00006FA6 36C706[AA05]FFFF        	MOV	word [SS:SFN],-1	; remove mark.
 38810                                  
 38811                                  	; MSDOS 6.0
 38812                                  ; File Tagging DOS 4.00
 38813 00006FAD 36833E[2403]25          	CMP	word [SS:EXTERR],error_Code_Page_Mismatched
 38814                                  					;AN000;;FT. code page mismatch
 38815 00006FB3 7503                    	JNZ	short NORERR	  	;AN000;;FT. no
 38816 00006FB5 E99096                  	jmp	From_GetSet		;AN000;;FT. yes
 38817                                  NORERR: 				;AN000;
 38818                                  ; File Tagging DOS 4.00
 38819                                  
 38820 00006FB8 E98596                  	jmp	SYS_RET_ERR		; no free, return error
 38821                                  
 38822                                  ; MSDOS 2.11
 38823                                  ;BREAK <$CREAT - creat a new file and open him for input>
 38824                                  ;----------------------------------------------------------------------------
 38825                                  ;   Assembler usage:
 38826                                  ;           LDS     DX, name
 38827                                  ;           MOV     AH, Creat
 38828                                  ;           MOV     CX, access
 38829                                  ;           INT     21h
 38830                                  ;       ; AX now has the handle
 38831                                  ;
 38832                                  ;   Error returns:
 38833                                  ;           AX = error_access_denied
 38834                                  ;              = error_path_not_found
 38835                                  ;              = error_too_many_open_files
 38836                                  ;----------------------------------------------------------------------------
 38837                                  
 38838                                  ; MSDOS 6.0
 38839                                  ;	BREAK <$Creat - create a brand-new file>
 38840                                  ;----------------------------------------------------------------------------
 38841                                  ;
 38842                                  ;**	$Creat - Create a File
 38843                                  ;
 38844                                  ;	$Creat creates the directory entry specified in DS:DX and gives it the
 38845                                  ;	initial attributes contained in CX
 38846                                  ;
 38847                                  ;	ENTRY	(DS:DX) = ASCIZ path name
 38848                                  ;		(CX) = initial attributes
 38849                                  ;	EXIT	'C' set if error
 38850                                  ;		  (ax) = error code
 38851                                  ;		'C' clear if OK
 38852                                  ;		  (ax) = file handle
 38853                                  ;	USES	all
 38854                                  ;
 38855                                  ;----------------------------------------------------------------------------
 38856                                  
 38857                                  _$CREAT:
 38858 00006FBB 51                      	push	cx			; Save attributes on stack
 38859 00006FBC B9[582A]                	mov	CX,DOS_CREATE		; routine to call
 38860                                  AccessSet:
 38861                                  	;mov	byte [ss:SATTRIB],6
 38862 00006FBF 36C606[6D05]06          	mov	byte [ss:SATTRIB],attr_hidden+attr_system ;smr;SS Override
 38863                                  	; 10/08/2018
 38864 00006FC5 E927FF                  	JMP	AccessFile		; use good ol' open
 38865                                  
 38866                                  ; MSDOS 6.0 (MSDOS 3.3)
 38867                                  ;	BREAK <$CHMOD - change file attributes>
 38868                                  ;----------------------------------------------------------------------------
 38869                                  ;
 38870                                  ;**	$CHMOD - Change File Attributes
 38871                                  ;
 38872                                  ;   Assembler usage:
 38873                                  ;	    LDS     DX, name
 38874                                  ;	    MOV     CX, attributes
 38875                                  ;	    MOV     AL,func (0=get, 1=set)
 38876                                  ;	    INT     21h
 38877                                  ;   Error returns:
 38878                                  ;	    AX = error_path_not_found
 38879                                  ;	    AX = error_access_denied
 38880                                  ;
 38881                                  ;----------------------------------------------------------------------------
 38882                                  
 38883                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38884                                  _$CHMOD:
 38885                                  	; 05/08/2018 - Retro DOS v3.0
 38886                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6FCCh ,
 38887 00006FC8 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 38888 00006FCB 50                      	push	ax
 38889 00006FCC 51                      	push	cx			; save function and attributes
 38890 00006FCD 89D6                    	MOV	SI,DX			; get things in appropriate places
 38891 00006FCF E8A7FB                  	call	TransPathSet		; get correct path
 38892 00006FD2 59                      	pop	cx
 38893 00006FD3 58                      	pop	ax			; and get function and attrs back
 38894 00006FD4 7257                    	JC	short ChModErr		; errors get mapped to path not found
 38895 00006FD6 16                      	push	ss			; set up for later possible calls
 38896 00006FD7 1F                      	pop	ds
 38897 00006FD8 803E[7A05]FF            	CMP	byte [CMETA],-1
 38898 00006FDD 754E                    	JNZ	short ChModErr
 38899                                  	;mov	byte [SATTRIB],16h
 38900 00006FDF C606[6D05]16            	MOV	byte [SATTRIB],attr_hidden+attr_system+attr_directory
 38901 00006FE4 2C01                    	SUB	AL,1			; fast way to discriminate
 38902 00006FE6 720B                    	JB	short ChModGet		; 0 -> go get value
 38903 00006FE8 7417                    	JZ	short ChModSet		; 1 -> go set value
 38904                                  	;mov	byte [EXTERR_LOCUS],1
 38905 00006FEA C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 38906                                  	;mov	al,1
 38907 00006FEF B001                    	mov	al,error_invalid_function ; bad value
 38908                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38909                                  chmod_errj:	
 38910                                  	;;jmp	SYS_RET_ERR
 38911                                  	;jmp	short ChModE	
 38912 00006FF1 EBC5                    	jmp	short NORERR	; 06/12/2022
 38913                                  ChModGet:
 38914 00006FF3 E84CB9                  	call	GET_FILE_INFO		; suck out the ol' info
 38915 00006FF6 7237                    	JC	short ChModE		; error codes are already set for ret
 38916 00006FF8 E88694                  	call	Get_User_Stack		; point to user saved vaiables
 38917                                  	;mov	[SI+4],ax
 38918 00006FFB 894404                  	MOV	[SI+user_env.user_CX],AX ; return the attributes
 38919                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
 38920                                  OpenOkj2:
 38921                                  	; 17/12/2022
 38922                                  	;;jmp	SYS_RET_OK		; say sayonara
 38923                                  	;jmp	short OpenOkj
 38924                                  	; 25/06/2019
 38925 00006FFE E93996                  	jmp	SYS_RET_OK_clc
 38926                                  
 38927                                  ChModSet:
 38928 00007001 89C8                    	MOV	AX,CX			; get attrs in position
 38929 00007003 E89AB9                  	call	SET_FILE_ATTRIBUTE	; go set
 38930 00007006 7227                    	JC	short ChModE		; errors are set
 38931                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
 38932                                  	;jmp	SYS_RET_OK
 38933                                  OpenOkj3:
 38934                                  	;jmp	short OpenOkj2
 38935                                  	; 17/12/2022
 38936 00007008 E92C96                  	jmp	SYS_RET_OK
 38937                                  
 38938                                  ; 17/12/2022
 38939                                  %if 0
 38940                                  ChModErr:
 38941                                  NotFound:	; 17/12/2022
 38942                                  	;mov	al,3
 38943                                  	mov	al,error_path_not_found
 38944                                  ChModE:
 38945                                  UnlinkE:	; 17/12/2022
 38946                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38947                                  	;;jmp	SYS_RET_ERR
 38948                                  	;jmp	short chmod_errj
 38949                                  	; 17/12/2022
 38950                                  	jmp	short NORERR
 38951                                  %endif
 38952                                  
 38953                                  ; 22/05/2019 - Retro DOS v4.0
 38954                                  ; DOSCODE:B039h (MSDOS 6.21, MSDOS.SYS)
 38955                                  
 38956                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38957                                  ; DOSCODE:AFD6h (MSDOS 5.0, MSDOS.SYS)
 38958                                  
 38959                                  ;	BREAK <$UNLINK - delete a file entry>
 38960                                  ;----------------------------------------------------------------------------
 38961                                  ;
 38962                                  ;**	$UNLINK - Delete a File
 38963                                  ;
 38964                                  ;
 38965                                  ;	Assembler usage:
 38966                                  ;	    LDS     DX, name
 38967                                  ;	    IF VIA SERVER DOS CALL
 38968                                  ;	     MOV     CX,SEARCH_ATTRIB
 38969                                  ;	    MOV     AH, Unlink
 38970                                  ;	    INT     21h
 38971                                  ;
 38972                                  ;	ENTRY	(ds:dx) = path name
 38973                                  ;		(cx) = search_attribute, if via server_dos
 38974                                  ;	EXIT	'C' clear if no error
 38975                                  ;		'C' set if error
 38976                                  ;		  (ax) = error code
 38977                                  ;			= error_file_not_found
 38978                                  ;			= error_access_denied
 38979                                  ;
 38980                                  ;----------------------------------------------------------------------------
 38981                                  
 38982                                  _$UNLINK:
 38983 0000700B 51                      	push	cx			; Save possible CX input parm
 38984 0000700C 89D6                    	MOV	SI,DX			; Point at input string
 38985 0000700E BF[BE03]                	MOV	DI,OPENBUF		; temp spot for path
 38986 00007011 E865FB                  	call	TransPathSet		; go get normalized path
 38987 00007014 59                      	pop	cx
 38988 00007015 7216                    	JC	short ChModErr		; badly formed path
 38989 00007017 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1	; meta chars?	;smr;SS Override
 38990 0000701D 750E                    	JNZ	short NotFound
 38991 0000701F 16                      	push	ss
 38992 00007020 1F                      	pop	ds
 38993                                  	;mov	ch,6
 38994 00007021 B506                    	mov	ch,attr_hidden+attr_system ; unlink appropriate files
 38995 00007023 E81C01                  	call	SetAttrib
 38996 00007026 E809B5                  	call	DOS_DELETE		; remove that file
 38997                                  	;JC	short UnlinkE 		; error is there
 38998                                  	; 17/12/2022
 38999 00007029 728D                    	jc	short NORERR
 39000                                  
 39001                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39002                                  UnlinkOk:
 39003                                  	;jmp	SYS_RET_OK		; okey doksy
 39004 0000702B EBDB                    	jmp	short OpenOkj3
 39005                                  
 39006                                  	; 17/12/2022
 39007                                  ChModErr:	; 17/12/2022
 39008                                  NotFound:
 39009                                  	;mov	al,3
 39010 0000702D B003                    	MOV	AL,error_path_not_found
 39011                                  ChModE:		; 17/12/2022
 39012                                  UnlinkE:
 39013                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39014                                  	;;jmp	SYS_RET_ERR		; bye
 39015                                  	;jmp	short ChModE
 39016                                  	; 17/12/2022
 39017 0000702F EB87                    	jmp	short NORERR
 39018                                  
 39019                                  ;BREAK <$RENAME - move directory entries around>
 39020                                  ;----------------------------------------------------------------------------
 39021                                  ;
 39022                                  ;   Assembler usage:
 39023                                  ;	    LDS     DX, source
 39024                                  ;	    LES     DI, dest
 39025                                  ;	    IF VIA SERVER DOS CALL
 39026                                  ;	      MOV   CX,SEARCH_ATTRIB
 39027                                  ;	    MOV     AH, Rename
 39028                                  ;	    INT     21h
 39029                                  ;
 39030                                  ;   Error returns:
 39031                                  ;	    AX = error_file_not_found
 39032                                  ;	       = error_not_same_device
 39033                                  ;	       = error_access_denied
 39034                                  ;
 39035                                  ;----------------------------------------------------------------------------
 39036                                  
 39037                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39038                                  _$RENAME:
 39039                                  	; MSDOS 3.3 (& MSDOS 6.0)
 39040 00007031 51                      	push	cx
 39041 00007032 1E                      	push	ds
 39042 00007033 52                      	push	dx			; save source and possible CX arg
 39043 00007034 06                      	PUSH	ES
 39044 00007035 1F                      	POP	DS			; move dest to source
 39045 00007036 89FE                    	MOV	SI,DI			; save for offsets
 39046 00007038 BF[3E04]                	MOV	DI,RENBUF
 39047 0000703B E83BFB                  	call	TransPathSet		; munge the paths
 39048 0000703E 36FF36[B205]            	PUSH	word [ss:WFP_START]	; get pointer	;smr;SS Override
 39049 00007043 368F06[B405]            	POP	word [ss:REN_WFP]	; stash it	;smr;SS Override
 39050 00007048 5E                      	pop	si
 39051 00007049 1F                      	pop	ds
 39052 0000704A 59                      	pop	cx			; get back source and possible CX arg
 39053                                  epjc2:	
 39054 0000704B 72E0                    	JC	short ChModErr		; get old error
 39055 0000704D 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1			;smr;SS Override
 39056 00007053 75D8                    	JNZ	short NotFound
 39057 00007055 51                      	push	cx			; Save possible CX arg
 39058 00007056 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 39059 00007059 E81DFB                  	call	TransPathSet		; wham
 39060 0000705C 59                      	pop	cx
 39061 0000705D 72EC                    	JC	short epjc2
 39062 0000705F 16                      	push	ss
 39063 00007060 1F                      	pop	ds
 39064 00007061 803E[7A05]FF            	CMP	byte [CMETA],-1
 39065 00007066 72C5                    	JB	short NotFound
 39066                                  
 39067                                  	; MSDOS 6.0
 39068 00007068 FF36[A205]              	PUSH	WORD [THISCDS]		   ;AN000;;MS.save thiscds
 39069 0000706C FF36[A405]              	PUSH	WORD [THISCDS+2]	   ;AN000;;MS.
 39070 00007070 BF[BE03]                	MOV	DI,OPENBUF		   ;AN000;;MS.
 39071 00007073 16                      	PUSH	SS			   ;AN000;;MS.
 39072 00007074 07                      	POP	ES			   ;AN000;;MS.es:di-> source
 39073 00007075 30C0                    	XOR	AL,AL			   ;AN000;;MS.scan all CDS
 39074                                  rnloop: 				   ;AN000;
 39075 00007077 E879FA                  	call	GetCDSFromDrv		   ;AN000;;MS.
 39076 0000707A 7210                    	JC	short dorn		   ;AN000;;MS.	end of CDS
 39077 0000707C E832A1                  	call	StrCmp			   ;AN000;;MS.	current dir ?
 39078 0000707F 7404                    	JZ	short rnerr		   ;AN000;;MS.	yes
 39079 00007081 FEC0                    	INC	AL			   ;AN000;;MS.	next
 39080 00007083 EBF2                    	JMP	short rnloop		   ;AN000;;MS.
 39081                                  rnerr:					   ;AN000;
 39082 00007085 83C404                  	ADD	SP,4			   ;AN000;;MS. pop thiscds
 39083                                  	;error	error_current_directory    ;AN000;;MS.
 39084 00007088 B010                    	mov	al,error_current_directory 
 39085                                  	;jmp	SYS_RET_ERR
 39086                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39087 0000708A EBA3                    	jmp	short UnlinkE
 39088                                  dorn:					   ;AN000;
 39089 0000708C 368F06[A405]            	POP	WORD [SS:THISCDS+2]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 39090 00007091 368F06[A205]            	POP	WORD [SS:THISCDS]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 39091                                  
 39092 00007096 16                      	push	ss
 39093 00007097 1F                      	pop	ds
 39094                                  
 39095                                  	; MSDOS 3.3 (& MSDOS 6.0)
 39096                                  	;mov	ch,16h
 39097 00007098 B516                    	mov	ch,attr_directory+attr_hidden+attr_system
 39098                                  					; rename appropriate files
 39099 0000709A E8A500                  	call	SetAttrib
 39100 0000709D E870B6                  	call	DOS_RENAME		; do the deed
 39101 000070A0 728D                    	JC	short UnlinkE 		; errors
 39102                                  
 39103                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39104                                  	;jmp	SYS_RET_OK
 39105 000070A2 EB87                    	jmp	short UnlinkOk
 39106                                  
 39107                                  
 39108                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39109                                  
 39110                                  ; 14/07/2018 - Retro DOS v3.0
 39111                                  ; MSDOS 3.3 (& MSDOS 6.0)
 39112                                  
 39113                                  ;Break <$CreateNewFile - Create a new directory entry>
 39114                                  ;----------------------------------------------------------------------------
 39115                                  ;   CreateNew - Create a new directory entry.  Return a file handle if there
 39116                                  ;	was no previous directory entry, and fail if a directory entry with
 39117                                  ;	the same name existed previously.
 39118                                  ;
 39119                                  ;   Inputs:	DS:DX point to an ASCIZ file name
 39120                                  ;		CX contains default file attributes
 39121                                  ;   Outputs:	Carry Clear:
 39122                                  ;		    AX has file handle opened for read/write
 39123                                  ;		Carry Set:
 39124                                  ;		    AX has error code
 39125                                  ;   Registers modified: All
 39126                                  ;----------------------------------------------------------------------------
 39127                                  
 39128                                  _$CreateNewFile:
 39129 000070A4 51                      	push	cx			; Save attributes on stack
 39130 000070A5 B9[252B]                	MOV	CX,DOS_Create_New	; routine to call
 39131 000070A8 E914FF                  	JMP	AccessSet		; use good ol' open
 39132                                  
 39133                                  ;**	BinToAscii - convert a number to a string.
 39134                                  ;----------------------------------------------------------------------------
 39135                                  ;	BinToAscii converts a 16 bit number into a 4 ascii characters.
 39136                                  ;	This routine is used to generate temp file names so we don't spend
 39137                                  ;	the time and code needed for a true hex number, we just use
 39138                                  ;	A thorugh O.
 39139                                  ;
 39140                                  ;	ENTRY	(ax) = value
 39141                                  ;		(es:di) = destination
 39142                                  ;	EXIT	(es:di) updated by 4
 39143                                  ;	USES	cx, di, flags
 39144                                  ;----------------------------------------------------------------------------
 39145                                  
 39146                                  ; MSDOS 3.3
 39147                                  ;BinToAscii:
 39148                                  ;	mov     cx,4
 39149                                  ;bta5:
 39150                                  ;	push    cx
 39151                                  ;	mov     cl,4
 39152                                  ;	rol     ax,cl
 39153                                  ;	push    ax
 39154                                  ;	and     al,0Fh
 39155                                  ;	add     al,'0'
 39156                                  ;	cmp     al,'9'
 39157                                  ;	jbe     short bta6
 39158                                  ;	add     al,7
 39159                                  ;bta6: 
 39160                                  ;	stosb
 39161                                  ;	pop     ax
 39162                                  ;	pop     cx
 39163                                  ;	loop    bta5
 39164                                  ;	retn
 39165                                  
 39166                                  ; MSDOS 6.0
 39167                                  BinToAscii:
 39168 000070AB B90404                  	mov	cx,404h			; (ch) = digit counter, (cl) = shift cnt
 39169                                  bta5:	
 39170 000070AE D3C0                    	ROL	AX,CL			; move leftmost nibble into rightmost
 39171 000070B0 50                      	push	ax			; preserve remainder of digits
 39172 000070B1 240F                    	AND	AL,0Fh			; grab low nibble
 39173 000070B3 0441                    	ADD	AL,'A'			; turn into ascii
 39174 000070B5 AA                      	STOSB				; drop in the character
 39175 000070B6 58                      	pop	ax			; (ax) = shifted number
 39176 000070B7 FECD                    	dec	ch
 39177 000070B9 75F3                    	jnz	short bta5		; process 4 digits
 39178 000070BB C3                      	retn
 39179                                  
 39180                                  ;Break	<$CreateTempFile - create a unique name>
 39181                                  ;----------------------------------------------------------------------------
 39182                                  ;   $CreateTemp - given a directory, create a unique name in that directory.
 39183                                  ;	Method used is to get the current time, convert to a name and attempt
 39184                                  ;	a create new. Repeat until create new succeeds.
 39185                                  ;
 39186                                  ;   Inputs:	DS:DX point to a null terminated directory name.
 39187                                  ;		CX  contains default attributes
 39188                                  ;   Outputs:	Unique name is appended to DS:DX directory.
 39189                                  ;		AX has handle
 39190                                  ;   Registers modified: all
 39191                                  ;----------------------------------------------------------------------------
 39192                                  
 39193                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39194                                  
 39195                                  _$CreateTempFile:
 39196                                  	;Enter
 39197 000070BC 55                      	push	bp
 39198 000070BD 89E5                    	mov	bp,sp
 39199                                  
 39200                                  	;LocalVar  EndPtr,DWORD
 39201                                  	;LocalVar  FilPtr,DWORD
 39202                                  	;LocalVar  Attr,WORD
 39203                                  
 39204 000070BF 83EC0A                  	sub	sp,10
 39205                                  
 39206                                  	;test	cx,0FFD8h
 39207 000070C2 F7C1D8FF                	test	CX,~attr_changeable
 39208 000070C6 7405                    	JZ	short OKatts		; Ok if no non-changeable bits set
 39209                                  
 39210                                  ; We need this "hook" here to detect these cases (like user sets one both of
 39211                                  ; vol_id and dir bits) because of the structure of the or $CreateNewFile loop
 39212                                  ; below. The code loops on error_access_denied, but if one of the non
 39213                                  ; changeable attributes is specified, the loop COULD be infinite or WILL be
 39214                                  ; infinite because CreateNewFile will fail with access_denied always. Thus we
 39215                                  ; need to detect these cases before getting to the loop.
 39216                                  
 39217                                  	;mov	ax, 5
 39218 000070C8 B80500                  	MOV	AX,error_access_denied
 39219 000070CB EB69                    	JMP	SHORT SETTMPERR
 39220                                  
 39221                                  OKatts:
 39222                                  	;MOV	attr,CX 		; save attribute
 39223 000070CD 894EF6                  	mov     [bp-10],cx
 39224                                  	;MOV	FilPtrL,DX		; pointer to file
 39225 000070D0 8956F8                  	mov	[bp-8],dx
 39226                                  	;MOV	FilPtrH,DS
 39227 000070D3 8C5EFA                  	mov	[bp-6],ds
 39228                                  	;MOV	EndPtrH,DS		; seg pointer to end of dir
 39229 000070D6 8C5EFE                  	mov	[bp-2],ds
 39230 000070D9 1E                      	PUSH	DS
 39231 000070DA 07                      	POP	ES			; destination for nul search
 39232 000070DB 89D7                    	MOV	DI,DX
 39233 000070DD 89F9                    	MOV	CX,DI
 39234 000070DF F7D9                    	NEG	CX			; number of bytes remaining in segment
 39235                                  	; MSDOS 6.0
 39236 000070E1 09C9                    	OR	CX,CX			;AN000;MS. cx=0 ? ds:dx on segment boundary
 39237 000070E3 7501                    	JNZ	short okok		;AN000;MS. no
 39238                                  	;MOV	CX,-1			;AN000;MS.
 39239                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39240                                  	; 17/12/2022
 39241 000070E5 49                      	dec	cx  ; mov cx,-1
 39242                                  	;mov	cx,-1 ; 0FFFh
 39243                                  okok:					;AN000;
 39244 000070E6 31C0                    	XOR	AX,AX			;AN000;
 39245 000070E8 F2AE                    	REPNZ	SCASB			;AN000;
 39246                                  					;AN000;
 39247 000070EA 4F                      	DEC	DI			; point back to the null
 39248 000070EB 268A45FF                	MOV	AL,[ES:DI-1]		; Get char before the NUL
 39249 000070EF E8B0DF                  	call	PATHCHRCMP		; Is it a path separator?
 39250 000070F2 7403                    	JZ	short SETENDPTR		; Yes
 39251                                  STOREPTH:
 39252 000070F4 B05C                    	MOV	AL,'\'
 39253 000070F6 AA                      	STOSB				; Add a path separator (and INC DI)
 39254                                  SETENDPTR:
 39255                                  	;MOV	EndPtrL,DI		; pointer to the tail
 39256 000070F7 8856FC                  	mov	[bp-4],dl
 39257                                  CreateLoop:
 39258 000070FA 16                      	push	ss			; let ReadTime see variables
 39259 000070FB 1F                      	pop	ds
 39260 000070FC 55                      	push	bp
 39261 000070FD E81A9A                  	call	READTIME		; go get time
 39262 00007100 5D                      	pop	bp
 39263                                  ;
 39264                                  ; Time is in CX:DX. Go drop it into the string.
 39265                                  ;
 39266                                  	;les	di,EndPtr		; point to the string
 39267 00007101 C47EFC                  	les	di,[BP-4]
 39268 00007104 89C8                    	mov	ax,cx
 39269 00007106 E8A2FF                  	call	BinToAscii		; store upper word
 39270 00007109 89D0                    	mov	ax,dx
 39271 0000710B E89DFF                  	call	BinToAscii		; store lower word
 39272 0000710E 30C0                    	xor	al,al
 39273 00007110 AA                      	STOSB				; nul terminate
 39274                                  	;LDS	DX,FilPtr		; get name
 39275 00007111 C556F8                  	lds	dx,[bp-8]
 39276                                  	;MOV	CX,Attr 		; get attr
 39277 00007114 8B4EF6                  	mov	cx,[bp-10]
 39278 00007117 55                      	push	bp
 39279 00007118 E889FF                  	CALL	_$CreateNewFile		; try to create a new file
 39280 0000711B 5D                      	pop	bp
 39281 0000711C 7319                    	JNC	short CreateDone	; failed, go try again
 39282                                  
 39283                                  ; The operation failed and the error has been mapped in AX. Grab the extended
 39284                                  ; error and figure out what to do.
 39285                                  
 39286                                  	;; MSDOS 3.3			; M049 - start
 39287                                  ;;	mov	ax,[ss:EXTERR]				;smr;SS Override
 39288                                  ;;	cmp	al,error_file_exists
 39289                                  ;;	jz	short CreateLoop	; file existed => try with new name
 39290                                  ;;	cmp	al,error_access_denied
 39291                                  ;;	jz	short CreateLoop	; access denied (attr mismatch)
 39292                                  
 39293                                  	; MSDOS 6.0
 39294                                  	;cmp	al,50h
 39295 0000711E 3C50                    	CMP	AL,error_file_exists	; Q: did file already exist
 39296 00007120 74D8                    	JZ	short CreateLoop	; Y: try again
 39297                                  	;cmp	al,5
 39298 00007122 3C05                    	CMP	AL,error_access_denied	; Q: was it access denied
 39299 00007124 7510                    	JNZ	short SETTMPERR		; N: Error out
 39300                                  					; Y: Check to see if we got this due
 39301                                  					;    to the network drive. Note that
 39302                                  					;    the redir will set the exterr
 39303                                  					;    to error_cannot_make if this is 
 39304                                  					;    so. 
 39305 00007126 36803E[2403]41          	CMP	byte [SS:EXTERR],error_net_access_denied ; M069
 39306                                  					; See if it's REALLY an att mismatch
 39307 0000712C 7408                    	je	short SETTMPERR		; no, network error, stop
 39308                                  ;M070
 39309                                  ; If the user failed on an I24, we do not want to try again
 39310                                  ;
 39311 0000712E 36803E[2403]53          	cmp	byte [SS:EXTERR],error_FAIL_I24 ;User failed on I24? ;M070
 39312                                  	;je	short SETTMPERR		;yes, do not try again ;M070
 39313                                  
 39314                                  	;jmp	short CreateLoop	;attr mismatch, try again ;M070
 39315                                  	; 17/12/2022
 39316 00007134 75C4                    	jne	short CreateLoop ; 10/06/2019 
 39317                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39318                                  	;jz	short SETTMPERR
 39319                                  	;jmp	short CreateLoop
 39320                                  
 39321                                  ;;	MOV	AL,error_access_denied	; Return this "extended" error
 39322                                  					; M049 - end
 39323                                  SETTMPERR:
 39324 00007136 F9                      	STC
 39325                                  CreateDone:
 39326                                  	;Leave
 39327 00007137 89EC                    	mov	sp,bp
 39328 00007139 5D                      	pop	bp
 39329 0000713A 7203                    	JC	short CreateFail
 39330 0000713C E9F894                  	jmp	SYS_RET_OK		; success!
 39331                                  CreateFail:
 39332 0000713F E9FE94                  	jmp	SYS_RET_ERR
 39333                                  
 39334                                  ;   SetAttrib will set the search attribute (SAttrib) either to the normal
 39335                                  ;   (CH) or to the value in CL if the current system call is through
 39336                                  ;   serverdoscall.
 39337                                  ;
 39338                                  ;   Inputs:	fSharing == FALSE => set sattrib to CH
 39339                                  ;		fSharing == TRUE => set sattrib to CL
 39340                                  ;   Outputs:	none
 39341                                  ;   Registers changed:	CX
 39342                                  
 39343                                  SetAttrib:
 39344 00007142 36F606[7205]FF          	test	byte [SS:FSHARING],-1		;smr;SS Override
 39345 00007148 7502                    	jnz	short Set
 39346 0000714A 88E9                    	mov	cl,ch
 39347                                  Set:
 39348 0000714C 36880E[6D05]            	mov	byte [ss:SATTRIB],cl		;smr;SS Override
 39349 00007151 C3                      	retn
 39350                                  
 39351                                  ; 14/07/2018 - Retro DOS v3.0
 39352                                  ; MSDOS 6.0
 39353                                  
 39354                                  ; 29/04/2019 - Retro DOS v4.0
 39355                                  
 39356                                  ;Break	<Extended_Open- Extended open the file>
 39357                                  ;----------------------------------------------------------------------------
 39358                                  ; Input: AL= 0 reserved  AH=6CH
 39359                                  ;	 BX= mode
 39360                                  ;	 CL= create attribute  CH=search attribute (from server)
 39361                                  ;	 DX= flag
 39362                                  ;	 DS:SI = file name
 39363                                  ;	 ES:DI = parm list
 39364                                  ;			   DD  SET EA list (-1) null
 39365                                  ;			   DW  n  parameters
 39366                                  ;			   DB  type (TTTTTTLL)
 39367                                  ;			   DW  IOMODE
 39368                                  ; Function: Extended Open
 39369                                  ; Output: carry clear
 39370                                  ;		     AX= handle
 39371                                  ;		     CX=1 file opened
 39372                                  ;			2 file created/opened
 39373                                  ;			3 file replaced/opened
 39374                                  ;	  carry set: AX has error code
 39375                                  ;----------------------------------------------------------------------------
 39376                                  
 39377                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39378                                  _$Extended_Open:			  ;AN000;
 39379                                  	;ASSUME	CS:DOSCODE,SS:DOSDATA	  ;AN000;
 39380 00007152 368916[F405]            	MOV	[SS:EXTOPEN_FLAG],DX	  ;AN000;EO. save ext. open flag;smr;SS Override
 39381 00007157 36C706[F705]0000        	MOV	word [SS:EXTOPEN_IO_MODE],0 ;AN000;EO. initialize IO mode;smr;SS Override
 39382                                  	; 17/12/2022
 39383 0000715E F6C6FE                  	test	dh,0FEh ; 04/12/2022 
 39384                                  	;;test	dx,0FE00h
 39385                                  	;TEST	DX,RESERVED_BITS_MASK	  ;AN000;EO. reserved bits 0  ?
 39386 00007161 7545                    	JNZ	short ext_inval2	  ;AN000;EO. no
 39387 00007163 88D4                    	MOV	AH,DL			  ;AN000;EO. make sure flag is right
 39388 00007165 80FA00                  	CMP	DL,0			  ;AN000;EO. all fail ?
 39389 00007168 743E                    	JZ	short ext_inval2	  ;AN000;EO. yes, error
 39390                                  	;and	dl,0Fh
 39391 0000716A 80E20F                  	AND	DL,EXISTS_MASK		  ;AN000;EO. get exists action byte
 39392 0000716D 80FA02                  	CMP	DL,2			  ;AN000;EO, > 02
 39393 00007170 7736                    	JA	short ext_inval2	  ;AN000;EO. yes ,error
 39394                                  	;and	ah,0F0h
 39395 00007172 80E4F0                  	AND	AH,NOT_EXISTS_MASK	  ;AN000;EO. get no exists action byte
 39396 00007175 80FC10                  	CMP	AH,10H			  ;AN000;EO. > 10
 39397 00007178 772E                    	JA	short ext_inval2	  ;AN000;EO. yes error
 39398                                  
 39399 0000717A 368C06[FB05]            	MOV	[SS:SAVE_ES],ES		  ;AN000;EO. save API parms;smr;SS Override
 39400 0000717F 36893E[F905]            	MOV	[SS:SAVE_DI],DI		  ;AN000;EO.;smr;SS Override
 39401 00007184 36FF36[F405]            	PUSH	word [SS:EXTOPEN_FLAG]	  ;AN000;EO.;smr;SS Override
 39402 00007189 368F06[FD05]            	POP	word [SS:SAVE_DX]	  ;AN000;EO.;smr;SS Override
 39403 0000718E 36890E[FF05]            	MOV	[SS:SAVE_CX],CX		  ;AN000;EO.;smr;SS Override
 39404 00007193 36891E[0106]            	MOV	[SS:SAVE_BX],BX		  ;AN000;EO.;smr;SS Override
 39405 00007198 368C1E[0506]            	MOV	[SS:SAVE_DS],DS		  ;AN000;EO.;smr;SS Override
 39406 0000719D 368936[0306]            	MOV	[SS:SAVE_SI],SI		  ;AN000;EO.;smr;SS Override
 39407 000071A2 89F2                    	MOV	DX,SI			  ;AN000;EO. ds:dx points to file name
 39408 000071A4 89D8                    	MOV	AX,BX			  ;AN000;EO. ax= mode
 39409 000071A6 EB0A                    	JMP	SHORT goopen2		  ;AN000;;EO. do normal
 39410                                  ext_inval2:				  ;AN000;;EO.
 39411                                  	;mov	al,1
 39412 000071A8 B001                    	mov	al,error_invalid_function ;AN000;EO.. invalid function
 39413                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39414                                  eo_err:
 39415                                  	;jmp	SYS_RET_ERR
 39416 000071AA EB93                    	jmp	short CreateFail
 39417                                  
 39418                                  ext_inval_parm:				  ;AN000;EO..
 39419 000071AC 59                      	POP	CX			  ;AN000;EO..  pop up satck
 39420 000071AD 5E                      	POP	SI			  ;AN000;EO..
 39421                                  	;error	error_invalid_data	  ;AN000;EO..  invalid parms
 39422                                  	;mov	al,13
 39423 000071AE B00D                    	mov	al,error_invalid_data
 39424                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39425                                  	;;jmp	SYS_RET_ERR
 39426                                  	;jmp	short eo_err
 39427                                  	; 17/12/2022
 39428 000071B0 EB8D                    	jmp	short CreateFail
 39429                                  
 39430                                  	; 17/12/2022	
 39431                                  ;error_return:				  ;AN000;EO.
 39432                                  ;	retn				  ;AN000;EO.. return with error
 39433                                  
 39434                                  goopen2:				  ;AN000;
 39435                                  	; 17/12/2022
 39436                                  	;test	bh,20h				 
 39437 000071B2 F6C720                  	test	bh,INT_24_ERROR>>8 ; 04/12/2022
 39438                                  	;;test	bx,2000h
 39439                                  	;TEST	BX,INT_24_ERROR		  ;AN000;EO.. disable INT 24 error ?
 39440 000071B5 7406                    	JZ	short goopen		  ;AN000;EO.. no
 39441                                  	;or	byte [SS:EXTOPEN_ON],2
 39442 000071B7 36800E[F605]02          	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_I24_OFF ;AN000;EO.. set bit to disable;smr;SS Override
 39443                                  goopen:					  ;AN000;
 39444                                  	;or	byte [SS:EXTOPEN_ON],1 
 39445 000071BD 36800E[F605]01          	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_ON  ;AN000;EO.. set Extended Open active;smr;SS Override
 39446                                  	;AND	word [SS:EXTOPEN_FLAG],0FFh  ;AN000;EO.create new ?;smr;SS Override
 39447                                  	; 18/12/2022
 39448 000071C3 36C606[F505]00          	mov	byte [SS:EXTOPEN_FLAG+1],0 ; AND word [SS:EXTOPEN_FLAG],0FFh
 39449                                  	;cmp	word [SS:EXTOPEN_FLAG],10h
 39450 000071C9 36833E[F405]10          	CMP	word [SS:EXTOPEN_FLAG],EXT_EXISTS_FAIL+EXT_NEXISTS_CREATE ;AN000;FT.;smr;SS Override
 39451 000071CF 7516                    	JNZ	short chknext 		  ;AN000;;EO. no
 39452 000071D1 E8D0FE                  	call	_$CreateNewFile		  ;AN000;;EO. yes
 39453 000071D4 723F                    	JC	short error_return	  ;AN000;;EO. error
 39454                                  
 39455 000071D6 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 39456 000071DC 7438                    	JZ	short ok_return2	  ;AN000;;EO. yes
 39457                                  	;mov	word [SS:EXTOPEN_FLAG],2
 39458 000071DE 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. creted/opened;smr;SS Override
 39459 000071E5 EB7F                    	JMP	setXAttr		  ;AN000;;EO. set XAs
 39460                                  
 39461                                  	; 17/12/2022
 39462                                  ;ok_return2:
 39463                                  ;	jmp	SYS_RET_OK		  ;AN000;;EO.
 39464                                  
 39465                                  chknext:
 39466                                  	; 17/12/2022
 39467 000071E7 36F606[F405]01          	test	byte [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ; 1
 39468                                  	;;test	word [SS:EXTOPEN_FLAG],1
 39469                                  	;TEST	word [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ;AN000;;EO. exists open;smr;SS Override
 39470 000071ED 752A                    	JNZ	short exist_open	  ;AN000;;EO. yes
 39471 000071EF E8C9FD                  	call	_$CREAT			  ;AN000;;EO. must be replace open
 39472 000071F2 7221                    	JC	short error_return	  ;AN000;;EO. return with error
 39473 000071F4 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 39474 000071FA 741A                    	JZ	short ok_return2	  ;AN000;;EO. yes
 39475 000071FC 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. prsume create/open;smr;SS Override
 39476 00007203 36F606[F605]04          	TEST	byte [SS:EXTOPEN_ON],EXT_FILE_NOT_EXISTS ;AN000;;EO. file not exists ?;smr;SS Override
 39477 00007209 755B                    	JNZ	short setXAttr		  ;AN000;;EO. no
 39478 0000720B 36C706[F405]0300        	MOV	word [SS:EXTOPEN_FLAG],ACTION_REPLACED_OPENED ;AN000;;EO. replaced/opened;smr;SS Override
 39479 00007212 EB52                    	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 39480                                  error_return2:
 39481 00007214 F9                      	STC 				  ; Set Carry again to flag error ;AN001;
 39482                                  error_return:	 ;17/12/2022
 39483 00007215 C3                      	retn				  ;AN000;;EO. return with error
 39484                                  
 39485                                  	; 17/12/2022
 39486                                  ok_return:
 39487                                  ok_return2:
 39488 00007216 E91E94                  	jmp	SYS_RET_OK
 39489                                  
 39490                                  exist_open:				  ;AN000;
 39491 00007219 36F606[7205]FF          	test	byte [SS:FSHARING],-1	  ;AN000;;EO. server doscall?;smr;SS Override
 39492 0000721F 7402                    	jz	short noserver		  ;AN000;;EO. no
 39493 00007221 88E9                    	MOV	CL,CH			  ;AN000;;EO. cl=search attribute
 39494                                  noserver:
 39495 00007223 E8C0FC                  	call	_$Open2			  ;AN000;;EO. do open
 39496 00007226 732F                    	JNC	short ext_ok		  ;AN000;;EO.
 39497 00007228 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. error and IFS call;smr;SS Override
 39498 0000722E 74E4                    	JZ	short error_return2	  ;AN000;;EO. return with error
 39499                                  local_extopen:
 39500                                  	;cmp	ax,2
 39501 00007230 83F802                  	CMP	AX,error_file_not_found   ;AN000;;EO. file not found error
 39502 00007233 75DF                    	JNZ	short error_return2	  ;AN000;;EO. no,
 39503                                  	;;test	word [SS:EXTOPEN_FLAG],10h
 39504                                  	; 17/12/2022
 39505 00007235 36F606[F405]10          	test	byte [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ; 10h
 39506                                  	;TEST	word [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ;AN000;;EO. want to fail;smr;SS Override
 39507                                  	;JNZ	short do_creat		  ;AN000;;EO. yes
 39508                                  	;JMP	short extexit 		  ;AN000;;EO. yes
 39509                                  	; 17/12/2022
 39510 0000723B 745D                    	jz	short extexit ; 10/06/2019
 39511                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39512                                  	;jnz	short do_creat
 39513                                  	;jmp	short extexit
 39514                                  do_creat:
 39515 0000723D 368B0E[FF05]            	MOV	CX,[SS:SAVE_CX]		  ;AN000;;EO. get ds:dx for file name;smr;SS Override
 39516 00007242 36C536[0306]            	LDS	SI,[SS:SAVE_SI]		  ;AN000;;EO. cx = attribute;smr;SS Override
 39517 00007247 89F2                    	MOV	DX,SI			  ;AN000;;EO.
 39518 00007249 E86FFD                  	call	_$CREAT			  ;AN000;;EO. do create
 39519 0000724C 724C                    	JC	short extexit 		  ;AN000;;EO. error
 39520                                  	;mov	word [SS:EXTOPEN_FLAG],2
 39521 0000724E 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
 39522                                  					  ;AN000;;EO. is created/opened;smr;SS Override
 39523 00007255 EB0F                    	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 39524                                  
 39525                                  ext_ok:
 39526 00007257 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS call ?;smr;SS Override
 39527 0000725D 74B7                    	JZ	short ok_return		  ;AN000;;EO. yes
 39528                                  	;mov	word [SS:EXTOPEN_FLAG],1
 39529 0000725F 36C706[F405]0100        	MOV	word [SS:EXTOPEN_FLAG],ACTION_OPENED ;AN000;;EO. opened;smr;SS Override
 39530                                  setXAttr:
 39531                                  	; 29/04/2019
 39532 00007266 50                      	push	ax
 39533 00007267 E81792                  	call	Get_User_Stack		  ;AN000;;EO.
 39534 0000726A 36A1[F405]              	MOV	AX,[SS:EXTOPEN_FLAG]	  ;AN000;;EO.;smr;SS Override
 39535                                  	;mov	[si+4],ax
 39536 0000726E 894404                  	MOV	[SI+user_env.user_CX],AX  ;AN000;;EO. set action code for cx
 39537 00007271 58                      	pop	ax			  ;AN000;;EO.
 39538 00007272 8904                    	mov	[si],ax
 39539                                  	;MOV	[SI+user_env.user_AX],AX  ;AN000;;EO. set handle for ax
 39540                                  	; 17/12/2022
 39541 00007274 EBA0                    	jmp	short ok_return
 39542                                  ;ok_return:				  ;AN000;
 39543                                  	;jmp	SYS_RET_OK		  ;AN000;;EO.
 39544                                  
 39545                                  extexit2:				  ;AN000; ERROR RECOVERY
 39546 00007276 5B                      	POP	BX			  ;AN000;EO. close the handle
 39547 00007277 50                      	PUSH	AX			  ;AN000;EO. save error code from set XA
 39548                                  	;cmp	word [SS:EXTOPEN_FLAG],2
 39549 00007278 36833E[F405]02          	CMP	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
 39550                                  					  ;AN000;EO. from create;smr;SS Override
 39551 0000727E 750C                    	JNZ	short justopen		  ;AN000;EO.
 39552 00007280 36C536[0306]            	LDS	SI,[SS:SAVE_SI]		  ;AN000;EO. cx = attribute;smr;SS Override
 39553 00007285 C514                    	LDS	DX,[SI]			  ;AN000;EO.
 39554 00007287 E881FD                  	call	_$UNLINK 		  ;AN000;EO. delete the file
 39555 0000728A EB03                    	JMP	SHORT reserror		  ;AN000;EO.
 39556                                  
 39557                                  justopen:				  ;AN000;
 39558 0000728C E886F4                  	call	_$CLOSE			  ;AN000;EO. pretend never happend
 39559                                  reserror:				  ;AN000;
 39560 0000728F 58                      	POP	AX			  ;AN000;EO. restore error code from set XA
 39561 00007290 EB08                    	JMP	SHORT extexit		  ;AN000;EO.
 39562                                  
 39563                                  ext_file_unfound:			  ;AN000;
 39564                                  	;mov	ax,2
 39565 00007292 B80200                  	MOV	AX,error_file_not_found   ;AN000;EO.
 39566 00007295 EB03                    	JMP	SHORT extexit		  ;AN000;EO.
 39567                                  ext_inval:				  ;AN000;
 39568                                  	;mov	ax,1
 39569 00007297 B80100                  	MOV	AX,error_invalid_function ;AN000;EO.
 39570                                  lockoperr:	; 17/12/2022
 39571                                  extexit:
 39572 0000729A E9A393                  	jmp	SYS_RET_ERR		  ;AN000;EO.
 39573                                  
 39574                                  ;============================================================================
 39575                                  ; LOCK.ASM, MSDOS 6.0, 1991
 39576                                  ;============================================================================
 39577                                  ; 14/07/2018 - Retro DOS v3.0
 39578                                  ; 22/05/2019 - Retro DOS v4.0
 39579                                  
 39580                                  ;BREAK <$LockOper - Lock Calls>
 39581                                  ;----------------------------------------------------------------------------
 39582                                  ;
 39583                                  ;   Assembler usage:
 39584                                  ;	    MOV     BX, Handle	       (DOS 3.3)
 39585                                  ;	    MOV     CX, OffsetHigh
 39586                                  ;	    MOV     DX, OffsetLow
 39587                                  ;	    MOV     SI, LengthHigh
 39588                                  ;	    MOV     DI, LengthLow
 39589                                  ;	    MOV     AH, LockOper
 39590                                  ;	    MOV     AL, Request
 39591                                  ;	    INT     21h
 39592                                  ;
 39593                                  ;   Error returns:
 39594                                  ;	    AX = error_invalid_handle
 39595                                  ;	       = error_invalid_function
 39596                                  ;	       = error_lock_violation
 39597                                  ;
 39598                                  ;   Assembler usage:
 39599                                  ;	    MOV     AX, 5C??	       (DOS 4.00)
 39600                                  ;
 39601                                  ;				    0? lock all
 39602                                  ;				    8? lock write
 39603                                  ;				    ?2 lock multiple
 39604                                  ;				    ?3 unlock multiple
 39605                                  ;				    ?4 lock/read
 39606                                  ;				    ?5 write/unlock
 39607                                  ;				    ?6 add (lseek EOF/lock/write/unlock)
 39608                                  ;	    MOV     BX, Handle
 39609                                  ;	    MOV     CX, count or size
 39610                                  ;	    LDS     DX, buffer
 39611                                  ;	    INT     21h
 39612                                  ;
 39613                                  ;   Error returns:
 39614                                  ;	    AX = error_invalid_handle
 39615                                  ;	       = error_invalid_function
 39616                                  ;	       = error_lock_violation
 39617                                  ;
 39618                                  ;----------------------------------------------------------------------------
 39619                                  
 39620                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39621                                  _$LockOper:
 39622 0000729D 3C01                    	CMP	AL,1
 39623 0000729F 770B                    	JA	short lock_bad_func
 39624                                  
 39625 000072A1 57                      	PUSH	DI			       ; Save LengthLow
 39626 000072A2 E8D5F3                  	call	SFFromHandle		       ; ES:DI -> SFT
 39627 000072A5 731D                    	JNC	short lock_do 		       ; have valid handle
 39628 000072A7 5F                      	POP	DI			       ; Clean stack
 39629                                  	;mov	al,6
 39630 000072A8 B006                    	mov	al,error_invalid_handle
 39631                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39632                                  ;lockoperr:
 39633                                  	;jmp	SYS_RET_ERR
 39634                                  	; 17/12/2022
 39635 000072AA EBEE                    	jmp	short lockoperr ; jmp SYS_RET_ERR
 39636                                  
 39637                                  lock_bad_func:
 39638                                  	;mov	byte [ss:EXTERR_LOCUS],1
 39639 000072AC 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus;smr;SS Override
 39640                                  	;mov	al,1
 39641 000072B2 B001                    	mov	al,error_invalid_function
 39642                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39643                                  lockoperrj:
 39644                                  	;jmp	SYS_RET_ERR
 39645 000072B4 EBE4                    	jmp	short lockoperr
 39646                                  
 39647                                  	; 22/05/2019 - Retro DOS v4.0
 39648                                  
 39649                                  	; MSDOS 6.0 
 39650                                  ; Align_buffer call has been deleted, since it corrupts the DTA (6/5/88) P5013
 39651                                  ; Dead code deleted, MD, 23 Mar 90
 39652                                  
 39653                                  ;lock_do:
 39654                                  ;	; MSDOS 3.3
 39655                                  ;	or	al,al
 39656                                  ;	pop	ax
 39657                                  ;	jz	short DOS_Lock
 39658                                  ;DOS_Unlock:
 39659                                  ;	;test	word [es:di+5],8000h
 39660                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 39661                                  ;	JZ	short LOCAL_UNLOCK
 39662                                  ;	push    ax
 39663                                  ;	mov     ax,110Bh
 39664                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 39665                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39666                                  ;			; STACK: WORD low word of size, ES:DI -> SFT for file
 39667                                  ;			; SFT DPB field -> DPB of drive containing file
 39668                                  ;			; Return: CF set error
 39669                                  ;	pop     bx
 39670                                  ;	jmp     short ValChk
 39671                                  ;
 39672                                  ;LOCAL_UNLOCK:
 39673                                  ;	Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39674                                  ;ValChk:
 39675                                  ;	JNC	short Lock_OK
 39676                                  ;lockerror:
 39677                                  ;	jmp	SYS_RET_ERR
 39678                                  ;Lock_OK:
 39679                                  ;	;MOV	AX,[SS:Temp_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 39680                                  ;	jmp	SYS_RET_OK
 39681                                  ;DOS_Lock:
 39682                                  ;	;test	word [es:di+5],8000h
 39683                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 39684                                  ;	JZ	short LOCAL_LOCK
 39685                                  ;	;CallInstall NET_XLock,MultNET,10
 39686                                  ;	mov     ax, 110Ah
 39687                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 39688                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39689                                  ;			; STACK: WORD low word of size, ES:DI -> SFT
 39690                                  ;			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 39691                                  ;			; Return: CF set error
 39692                                  ;	JMP	short ValChk
 39693                                  ;
 39694                                  ;LOCAL_LOCK:
 39695                                  ;	Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 39696                                  ;	JMP	short ValChk
 39697                                  
 39698                                  ; 17/12/2022
 39699                                  LOCAL_UNLOCK:
 39700                                  	; MSDOS 3.3
 39701                                  	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39702                                  	; MSDOS 6.0
 39703 000072B6 FF1E[AC00]              	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39704                                  ValChk:
 39705 000072BA 7302                    	JNC	short Lock_OK
 39706                                  lockerror:
 39707                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39708                                  	;;jmp	SYS_RET_ERR
 39709                                  	;jmp	short lockoperrj
 39710                                  	; 17/12/2022
 39711 000072BC EBDC                    	jmp	short lockoperr	; jmp SYS_RET_ERR
 39712                                  Lock_OK:
 39713                                  	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 39714                                  	; 10/06/2019
 39715 000072BE A1[0C06]                	mov	ax,[TEMP_VAR]
 39716 000072C1 E97393                  	jmp	SYS_RET_OK
 39717                                  
 39718                                  	; 22/05/2019
 39719                                  lock_do:
 39720                                  	; MSDOS 6.0
 39721 000072C4 89C3                    	MOV	BX,AX				; save AX
 39722 000072C6 BD[A903]                	MOV	BP,Lock_Buffer			; get DOS LOCK buffer
 39723                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39724                                  	;;mov	[bp+0],dx
 39725                                  	;MOV	[BP+LockBuf.Lock_position],DX	; set low offset
 39726                                  	; 15/12/2022
 39727 000072C9 895600                  	mov	[bp],dx
 39728                                  	;mov	[bp+2],cx
 39729 000072CC 894E02                  	MOV	[BP+LockBuf.Lock_position+2],CX; set high offset
 39730 000072CF 59                      	POP	CX				; get low length
 39731                                  	;mov	[bp+4],cx
 39732 000072D0 894E04                  	MOV	[BP+LockBuf.Lock_length],CX	; set low length
 39733                                  	;mov	[bp+6],si
 39734 000072D3 897606                  	MOV	[BP+LockBuf.Lock_length+2],SI	; set high length
 39735 000072D6 B90100                  	MOV	CX,1				; one range
 39736                                  
 39737                                  ;	PUSH	CS				;
 39738                                  ;	POP	DS				; DS:DX points to
 39739                                  
 39740 000072D9 16                      	push	ss
 39741 000072DA 1F                      	pop	ds
 39742                                  
 39743 000072DB 89EA                    	MOV	DX,BP				; Lock_Buffer
 39744                                  	;test	al,1
 39745 000072DD A801                    	TEST	AL,UNLOCK_ALL			; function 1
 39746                                  	;JNZ	short DOS_Unlock		; yes
 39747                                  	;JMP	short DOS_Lock			; function 0
 39748                                  	; 17/12/2022
 39749                                  	; 10/06/2019
 39750 000072DF 740E                    	jz	short DOS_Lock
 39751                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39752                                  	;JNZ	short DOS_Unlock
 39753                                  	;JMP	short DOS_Lock
 39754                                  
 39755                                  DOS_Unlock:
 39756                                  	;;test	word [es:di+5],8000h
 39757                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 39758 000072E1 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 39759 000072E6 74CE                    	JZ	short LOCAL_UNLOCK
 39760                                  
 39761                                  lock_unlock: ; 22/05/2019
 39762                                  	
 39763                                  	;CallInstall Net_Xlock,MultNET,10
 39764                                  	
 39765                                  	; MSDOS 3.3
 39766                                  	;mov     ax,110Bh
 39767                                  	;int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 39768                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39769                                  			; STACK: WORD low word of size, ES:DI -> SFT for file
 39770                                  			; SFT DPB field -> DPB of drive containing file
 39771                                  			; Return: CF set error
 39772                                  	; MSDOS 6.0
 39773 000072E8 B80A11                  	mov     ax,110Ah
 39774 000072EB CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 39775                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39776                                  			; STACK: WORD low word of size, ES:DI -> SFT
 39777                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 39778                                  			; Return: CF set error
 39779                                  
 39780 000072ED EBCB                    	JMP	SHORT ValChk
 39781                                  
 39782                                  ; 17/12/2022
 39783                                  %if 0
 39784                                  LOCAL_UNLOCK:
 39785                                  	; MSDOS 3.3
 39786                                  	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39787                                  	; MSDOS 6.0
 39788                                  	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39789                                  ValChk:
 39790                                  	JNC	short Lock_OK
 39791                                  lockerror:
 39792                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39793                                  	;jmp	SYS_RET_ERR
 39794                                  	jmp	short lockoperrj
 39795                                  Lock_OK:
 39796                                  	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 39797                                  	; 10/06/2019
 39798                                  	mov	ax,[TEMP_VAR]
 39799                                  	jmp	SYS_RET_OK
 39800                                  %endif
 39801                                  
 39802                                  DOS_Lock:
 39803                                  	;;test	word [es:di+5],8000h
 39804                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 39805 000072EF 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 39806 000072F4 7407                    	JZ	short LOCAL_LOCK
 39807                                  
 39808                                  	;CallInstall NET_XLock,MultNET,10
 39809                                  
 39810 000072F6 B80A11                  	mov     ax,110Ah
 39811 000072F9 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 39812                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39813                                  			; STACK: WORD low word of size, ES:DI -> SFT
 39814                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 39815                                  			; Return: CF set error
 39816                                  
 39817 000072FB EBBD                    	JMP	short ValChk
 39818                                  
 39819                                  LOCAL_LOCK:
 39820                                  	; MSDOS 3.3
 39821                                  	;Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 39822                                  	; MSDOS 6.0
 39823 000072FD FF1E[A800]              	Call	far [JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 39824                                  
 39825 00007301 EBB7                    	JMP	short ValChk
 39826                                  
 39827                                  ; 14/07/2018 - Retro DOS v3.0
 39828                                  ; LOCK_CHECK
 39829                                  ;MSDOS 6.0 (& MSDOS 3.3)
 39830                                  
 39831                                  ;----------------------------------------------------------------------------
 39832                                  ; Inputs:
 39833                                  ;	Outputs of SETUP
 39834                                  ;	[USER_ID] Set
 39835                                  ;	[PROC_ID] Set
 39836                                  ; Function:
 39837                                  ;	Check for lock violations on local I/O
 39838                                  ;	Retries are attempted with sleeps in between
 39839                                  ; Outputs:
 39840                                  ;    Carry clear
 39841                                  ;	Operation is OK
 39842                                  ;    Carry set
 39843                                  ;	A lock violation detected
 39844                                  ; Outputs of SETUP preserved
 39845                                  ;----------------------------------------------------------------------------
 39846                                  
 39847                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39848                                  	; 22/05/2019 - Retro DOS v4.0
 39849                                  LOCK_CHECK:
 39850 00007303 8B1E[1A00]              	MOV	BX,[RetryCount]	; Number retries
 39851                                  LockRetry:
 39852 00007307 53                      	push	bx		; save regs
 39853 00007308 50                      	push	ax ; MSDOS 6.0
 39854                                  
 39855                                  	;MSDOS 3.3
 39856                                  	;Call	far [ss:JShare+(8*4)]	; 8 = chk_block
 39857                                  	;MSDOS 6.0
 39858 00007309 FF1E[B000]              	Call	far [JShare+(8*4)]	; 8 = chk_block
 39859                                  
 39860 0000730D 58                      	pop	ax ; MSDOS 6.0
 39861 0000730E 5B                      	pop	bx		; restrore regs
 39862 0000730F 7307                    	jnc	short lc_ret_label ; There are no locks (retnc)
 39863                                  LockN:
 39864 00007311 E8F29E                  	call	Idle		; wait a while
 39865 00007314 4B                      	DEC	BX		; remember a retry
 39866 00007315 75F0                    	JNZ	short LockRetry	; more retries left...
 39867 00007317 F9                      	STC
 39868                                  lc_ret_label:
 39869 00007318 C3                      	retn
 39870                                  
 39871                                  ; 14/07/2018 - Retro DOS v3.0
 39872                                  ; LOCK_VIOLATION
 39873                                  ;MSDOS 6.0 (& MSDOS 3.3)
 39874                                  
 39875                                  ;----------------------------------------------------------------------------
 39876                                  ; Inputs:
 39877                                  ;	[THISDPB] set
 39878                                  ;	[READOP] indicates whether error on read or write
 39879                                  ; Function:
 39880                                  ;	Handle Lock violation on compatibility (FCB) mode SFTs
 39881                                  ; Outputs:
 39882                                  ;	Carry set if user says FAIL, causes error_lock_violation
 39883                                  ;	Carry clear if user wants a retry
 39884                                  ;
 39885                                  ; DS, ES, DI, CX preserved, others destroyed
 39886                                  ;----------------------------------------------------------------------------
 39887                                  
 39888                                  LOCK_VIOLATION:
 39889 00007319 1E                      	PUSH	DS
 39890 0000731A 06                      	PUSH	ES
 39891 0000731B 57                      	PUSH	DI
 39892 0000731C 51                      	PUSH	CX
 39893                                  	;mov	ax,21h
 39894 0000731D B82100                  	MOV	AX,error_lock_violation
 39895                                  	;mov	byte [ALLOWED],18h
 39896 00007320 C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 39897 00007325 C42E[8A05]              	LES	BP,[THISDPB]
 39898 00007329 BF0100                  	MOV	DI,1		; Fake some registers
 39899 0000732C 89F9                    	MOV	CX,DI
 39900                                  	;mov	dx,[es:bp+11]
 39901 0000732E 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 39902 00007332 E8D6DF                  	call	HARDERR
 39903 00007335 59                      	POP	CX
 39904 00007336 5F                      	POP	DI
 39905 00007337 07                      	POP	ES
 39906 00007338 1F                      	POP	DS
 39907 00007339 3C01                    	CMP	AL,1
 39908 0000733B 74DB                    	jz	short lc_ret_label ; 1 = retry, carry clear
 39909 0000733D F9                      	STC
 39910 0000733E C3                      	retn
 39911                                  
 39912                                  ; 14/07/2018 - Retro DOS v3.0
 39913                                  
 39914                                  ;----------------------------------------------------------------------------
 39915                                  
 39916                                  ;	do a retz to return error
 39917                                  
 39918                                  	; 22/05/2019 - Retro DOS v4.0
 39919                                  CheckShare:
 39920                                  	; MSDOS 3.3
 39921                                  	;cmp	byte [cs:fShare],0
 39922                                  	;retn
 39923                                  
 39924                                  	; MSDOS 6.0
 39925 0000733F 1E                      	push	ds			;smr;
 39926                                  	;getdseg <ds>			; ds -> dosdata
 39927 00007340 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 39928 00007345 803E[0303]00            	cmp	byte [fShare],0
 39929 0000734A 1F                      	pop	ds			;smr;
 39930 0000734B C3                      	retn
 39931                                  	
 39932                                  ;============================================================================
 39933                                  ; SHARE.ASM, MSDOS 6.0, 1991
 39934                                  ;============================================================================
 39935                                  ; 14/07/2018 - Retro DOS v3.0
 39936                                  ; 22/05/2019 - Retro DOS v4.0
 39937                                  
 39938                                  ; SHARE_CHECK
 39939                                  ;----------------------------------------------------------------------------
 39940                                  ; Inputs:
 39941                                  ;       [THISSFT] Points to filled in local file/device SFT for new
 39942                                  ;               instance of file sf_mode ALWAYS has mode (even on FCB SFTs)
 39943                                  ;       [WFP_START] has full path of name
 39944                                  ;       [USER_ID] Set
 39945                                  ;       [PROC_ID] Set
 39946                                  ; Function:
 39947                                  ;       Check for sharing violations on local file/device access
 39948                                  ; Outputs:
 39949                                  ;    Carry clear
 39950                                  ;       Sharing approved
 39951                                  ;    Carry set
 39952                                  ;       A sharing violation detected
 39953                                  ;           AX is error code
 39954                                  ; USES    ALL but DS
 39955                                  ;----------------------------------------------------------------------------
 39956                                  
 39957                                  	; 22/05/2019 - Retro DOS v4.0
 39958                                  SHARE_CHECK:
 39959                                  	; 26/07/2019
 39960 0000734C FF1E[9400]              	call	far [JShare+(1*4)] 	; 1 = MFT_Enter
 39961                                  shchk_retn:
 39962 00007350 C3                      	retn
 39963                                  
 39964                                  ; SHARE_VIOLATION
 39965                                  ;----------------------------------------------------------------------------
 39966                                  ; Inputs:
 39967                                  ;       [THISDPB] Set
 39968                                  ;       AX has error code
 39969                                  ; Function:
 39970                                  ;       Handle Sharing errors
 39971                                  ; Outputs:
 39972                                  ;       Carry set if user says FAIL, causes error_sharing_violation
 39973                                  ;       Carry clear if user wants a retry
 39974                                  ;
 39975                                  ; DS, ES, DI preserved, others destroyed
 39976                                  ;----------------------------------------------------------------------------
 39977                                  
 39978                                  SHARE_VIOLATION:
 39979 00007351 1E                      	PUSH    DS
 39980 00007352 06                      	PUSH	ES
 39981 00007353 57                      	PUSH    DI
 39982 00007354 C606[7505]00            	MOV     byte [READOP],0		; All share errors are reading
 39983                                  	;mov	byte [ALLOWED],18h
 39984 00007359 C606[4B03]18            	MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 39985 0000735E C42E[8A05]              	LES     BP,[THISDPB]
 39986 00007362 BF0100                  	MOV     DI,1			; Fake some registers
 39987 00007365 89F9                    	MOV     CX,DI
 39988                                  	;mov	dx,[es:bp+17]
 39989 00007367 268B5611                	MOV     DX,[ES:BP+DPB.DIR_SECTOR]
 39990 0000736B E89DDF                  	call	HARDERR
 39991 0000736E 5F                      	POP     DI
 39992 0000736F 07                      	POP	ES
 39993 00007370 1F                      	POP     DS
 39994 00007371 3C01                    	CMP     AL,1
 39995 00007373 74DB                    	jz	short shchk_retn	; 1 = retry, carry clear
 39996 00007375 F9                      	STC
 39997 00007376 C3                      	retn
 39998                                  
 39999                                  ;----------------------------------------------------------------------------
 40000                                  ;   ShareEnd - terminate sharing info on a particular SFT/UID/PID. This does
 40001                                  ;       NOT perform a close, it merely asserts that the sharing information
 40002                                  ;       for the SFT/UID/PID may be safely released.
 40003                                  ;
 40004                                  ;   Inputs:     ES:DI points to an SFT
 40005                                  ;   Outputs:    None
 40006                                  ;   Registers modified: all except DS,ES,DI
 40007                                  ;----------------------------------------------------------------------------
 40008                                  
 40009                                  ShareEnd:
 40010                                  	; 26/07/2019
 40011 00007377 FF1E[9800]              	call	far [JShare+(2*4)]	; 2 = MFTClose
 40012 0000737B C3                      	retn
 40013                                  
 40014                                  ;Break <ShareEnter - attempt to enter a node into the sharing set>
 40015                                  ;----------------------------------------------------------------------------
 40016                                  ;   ShareEnter - perform a retried entry of a nodde into the sharing set. If
 40017                                  ;   the max number of retries is exceeded, we notify the user via int 24.
 40018                                  ;
 40019                                  ;   Inputs:     ThisSFT points to the SFT
 40020                                  ;               WFP_Start points to the WFP
 40021                                  ;   Outputs:    Carry clear => successful entry
 40022                                  ;               Carry set => failed system call
 40023                                  ;   Registers modified: all
 40024                                  ;----------------------------------------------------------------------------
 40025                                  
 40026                                  ShareEnter:
 40027 0000737C 51                      	push	cx
 40028                                  retry:
 40029 0000737D 8B0E[1A00]              	mov     cx,[RetryCount]
 40030                                  attempt:
 40031 00007381 C43E[9E05]              	les     di,[THISSFT]		; grab sft
 40032 00007385 31C0                    	XOR     AX,AX
 40033                                   	;mov	[es:di+51],axfff
 40034 00007387 26894533                	MOV     [ES:DI+SF_ENTRY.sf_MFT],AX ; indicate free SFT
 40035 0000738B 51                      	push	cx
 40036 0000738C E8BDFF                  	call    SHARE_CHECK             ; attempt to enter into the sharing set
 40037 0000738F 59                      	pop	cx
 40038 00007390 730A                    	jnc	short done		; success, let the user see this
 40039 00007392 E8719E                  	call	Idle                    ; wait a while
 40040 00007395 E2EA                    	loop    attempt                 ; go back for another attempt
 40041 00007397 E8B7FF                  	call    SHARE_VIOLATION         ; signal the problem to the user
 40042 0000739A 73E1                    	jnc	short retry		; user said to retry, go do it
 40043                                  done:
 40044 0000739C 59                      	pop	cx
 40045 0000739D C3                      	retn
 40046                                  
 40047                                  ;============================================================================
 40048                                  ; EXEPATCH.ASM (MSDOS 6.0, 1991)
 40049                                  ;============================================================================
 40050                                  ; 29/04/2019 - Retro DOS 4.0
 40051                                  
 40052                                  ;** EXEPATCH.ASM 
 40053                                  ;----------------------------------------------------------------------------
 40054                                  ;	Contains the foll:
 40055                                  ;
 40056                                  ;		- code to find and overlay buggy unpack code
 40057                                  ;		- new code to be overlayed on buggy unpack code 
 40058                                  ;		- old code sequence to identify buggy unpack code
 40059                                  ;
 40060                                  ;	Revision history:
 40061                                  ;
 40062                                  ;		Created: 5/14/90
 40063                                  ;----------------------------------------------------------------------------
 40064                                  
 40065                                  ;----------------------------------------------------------------------------
 40066                                  ;
 40067                                  ; M020 : Fix for rational bug - for details see routine header
 40068                                  ; M028 : 4b04 implementation
 40069                                  ; M030 : Fixing bug in EXEPACKPATCH (EXEC_CS is an un-relocated value)
 40070                                  ; M032 : set turnoff bit only if DOS in HMA.
 40071                                  ; M033 : if IP < 2 then not exepacked.
 40072                                  ; M046 : support for a 4th version of exepacked files.
 40073                                  ; M068 : support for copy protected apps.
 40074                                  ; M071 : use A20OFF_COUNT of 10.
 40075                                  ;
 40076                                  ;----------------------------------------------------------------------------
 40077                                  
 40078                                  PATCH1_COM_OFFSET	EQU	06CH
 40079                                  PATCH1_OFFSET		EQU	028H
 40080                                  PATCH1_CHKSUM		EQU	0EF4EH
 40081                                  CHKSUM1_LEN		EQU	11CH/2 ; 142
 40082                                  
 40083                                  PATCH2_COM_OFFSET	EQU	076H
 40084                                  PATCH2_OFFSET		EQU	032H
 40085                                  
 40086                                  	; The strings that start at offset 076h have two possible 
 40087                                  	; check sums that are defined as PATCH2_CHKSUM PATCH2A_CHKSUM
 40088                                  
 40089                                  PATCH2_CHKSUM		EQU	78B2H
 40090                                  CHKSUM2_LEN		EQU	119H/2
 40091                                  PATCH2A_CHKSUM		EQU	1C47H		; M046
 40092                                  CHKSUM2A_LEN		EQU	103H/2		; M046
 40093                                  
 40094                                  PATCH3_COM_OFFSET	EQU	074H
 40095                                  PATCH3_OFFSET		EQU	032H
 40096                                  PATCH3_CHKSUM		EQU	4EDEH
 40097                                  CHKSUM3_LEN		EQU	117H/2
 40098                                  
 40099                                  ;**	Data structure passed for ExecReady call
 40100                                  ;
 40101                                  ;struc ERStruc
 40102                                  ; .ER_Reserved:	resw	1	; reserved, should be zero
 40103                                  ; .ER_Flags:	resw	1
 40104                                  ; .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
 40105                                  ; .ER_PSP:	resw	1	; PSP of the program
 40106                                  ; .ER_StartAddr: resd	1	; Start CS:IP of the program
 40107                                  ; .ER_ProgSize:	resd	1	; Program size including PSP
 40108                                  ; .size:
 40109                                  ;endstruc
 40110                                  
 40111                                  ;DOSCODE SEGMENT
 40112                                  
 40113                                  	; 22/05/2019 - Retro DOS v4.0
 40114                                  	; DOSCODE:B3DDh (MSDOS 6.21, MSDOS.SYS)
 40115                                  
 40116                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40117                                  	; DOSCODE:B37Ah (MSDOS 5.0, MSDOS.SYS)
 40118                                  
 40119                                  ; M028 - BEGIN
 40120                                  
 40121                                  ;--------------------------------------------------------------------------
 40122                                  ;
 40123                                  ;	Procedure Name		: ExecReady
 40124                                  ;
 40125                                  ;	Input			: DS:DX -> ERStruc (see exe.inc)
 40126                                  ;
 40127                                  ;--------------------------------------------------------------------------
 40128                                  
 40129                                  ExecReady:
 40130 0000739E 89D6                    	mov	si,dx			; move the pointer into a friendly one
 40131                                  	;;test	word [si+2],1
 40132                                  	; 17/12/2022
 40133 000073A0 F6440201                	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
 40134                                  	;test	word [si+ERStruc.ER_Flags],ER_EXE ; COM or EXE ?
 40135 000073A4 7413                    	jz	short er_setver		; only setver for .COM files
 40136                                  
 40137                                  	;mov	ax,[si+8]
 40138 000073A6 8B4408                  	mov	ax,[si+ERStruc.ER_PSP]
 40139 000073A9 83C010                  	add	ax,10h
 40140 000073AC 8EC0                    	mov	es,ax
 40141                                  
 40142                                  	;mov	cx,[si+10]
 40143 000073AE 8B4C0A                  	mov	cx,[si+ERStruc.ER_StartAddr]   ; M030
 40144                                  	;mov	cx,[si+12]
 40145 000073B1 8B440C                  	mov	ax,[si+ERStruc.ER_StartAddr+2] ; M030
 40146                                  
 40147                                  	;call	[ss:FixExePatch]
 40148 000073B4 36FF16[F311]            	call	word [ss:FixExePatch] ; 28/12/2022
 40149                                  	
 40150                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40151                                  	;call	[ss:Rational386PatchPtr]
 40152                                  
 40153                                  er_setver:
 40154                                  	;;test	word [si+2],2		; Q: is this an overlay
 40155                                  	; 17/12/2022
 40156 000073B9 F6440202                	test	byte [si+ERStruc.ER_Flags],ER_OVERLAY ; 2
 40157                                  	;test	word [si+ERStruc.ER_Flags],ER_OVERLAY
 40158 000073BD 7518                    	jnz	short er_chkdoshi	; Y: set A20OFF_COUNT if DOS high
 40159                                  					; N: set up lie version first
 40160 000073BF 1E                      	push	ds
 40161 000073C0 56                      	push	si
 40162                                  	;lds	si,[si+4]
 40163 000073C1 C57404                  	lds	si,[si+ERStruc.ER_ProgName]
 40164 000073C4 E876ED                  	call	Scan_Execname1
 40165 000073C7 E887ED                  	call	Scan_Special_Entries
 40166 000073CA 5E                      	pop	si
 40167 000073CB 1F                      	pop	ds
 40168                                  	;mov	es,[si+8]
 40169 000073CC 8E4408                  	mov	es,[si+ERStruc.ER_PSP]
 40170 000073CF 36A1[BD0E]              	mov	ax,[ss:SPECIAL_VERSION]
 40171 000073D3 26A34000                	mov	[es:PDB.Version],ax
 40172                                  
 40173                                  er_chkdoshi:
 40174 000073D7 36803E[F211]00          	cmp	byte [ss:DosHasHMA],0	; M032: Q: is dos in HMA (M021)
 40175 000073DD 741F                    	je	short er_done		; M032: N: done
 40176                                  
 40177                                  					; M068 - Start
 40178                                  	;mov	ax,[si+8]
 40179 000073DF 8B4408                  	mov	ax,[si+ERStruc.ER_PSP]	; ax = PSP
 40180                                  
 40181                                  	;or	byte [ss:DOS_FLAG],4
 40182 000073E2 36800E[8600]04          	or	byte [ss:DOS_FLAG],EXECA20OFF ; Set bit to signal int 21
 40183                                  					; ah = 25 & ah= 49. See dossym.inc 
 40184                                  					; under TAG M003 & M009 for 
 40185                                  					; explanation
 40186                                  	;;test	word [si+2],1
 40187                                  	; 17/12/2022
 40188 000073E8 F6440201                	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
 40189                                  	;test	word [si+ERStruc.ER_Flags],ER_EXE ; Q: COM file
 40190 000073EC 7507                    	jnz	short er_setA20		; N: inc a20off_count, set 
 40191                                  					;    a20off_psp and ret
 40192 000073EE 1E                         	push	ds
 40193 000073EF 8ED8                    	mov	ds,ax			; DS = load segment of com file.
 40194 000073F1 E88E02                  	call	IsCopyProt		; check if copy protected
 40195 000073F4 1F                      	pop	ds
 40196                                  
 40197                                  er_setA20:
 40198                                  	; We need to inc the A20OFF_COUNT here. Note that if the count
 40199                                  	; is non-zero at this point it indicates that the A20 is to be 
 40200                                  	; turned off for that many int 21 calls made by the app. In 
 40201                                  	; addition the A20 has to be turned off when we exit from this 
 40202                                  	; call. Hence the inc.
 40203                                  
 40204 000073F5 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]		
 40205 000073FA 36A3[6300]              	mov	[ss:A20OFF_PSP],ax	; set the PSP for which A20 is to be
 40206                                  					; turned OFF.
 40207                                  er_done:				; M068 - End
 40208 000073FE 31C0                    	xor	ax,ax
 40209 00007400 C3                      	retn
 40210                                  
 40211                                  ; M028 - END
 40212                                  
 40213                                  
 40214                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40215                                  %if 0
 40216                                  
 40217                                  ;----------------------------------------------------------------------------
 40218                                  ;
 40219                                  ; procedure : Rational386Patch
 40220                                  ;
 40221                                  ; Older versions of the Rational DOS Extender have several bugs which trash
 40222                                  ; 386 registers (usually just the high word of 32 bit registers) during
 40223                                  ; interrupt processing. Lotus 123 3.1+ is a popular application that uses a
 40224                                  ; version of the Rational extender with the 32 bit register trashing bugs.
 40225                                  ;
 40226                                  ; This routine applies patches to the Rational DOS Extender to work around
 40227                                  ; most of the register trashing bugs.
 40228                                  ;
 40229                                  ; Note that there are additional register trashing bugs not fixed by these
 40230                                  ; patches. In particular, the high word of ESP and the FS and GS registers
 40231                                  ; may be modified on interrupts.
 40232                                  ;
 40233                                  ; There are two different Rational DOS Extender patchs in this module.
 40234                                  ; Rational386Patch is to correct 386 register trashing bugs on 386 or later
 40235                                  ; processors. This patch code is executed when MS-DOS is running on a 386
 40236                                  ; or later processor, regardless of whether MS-DOS is running in the HMA
 40237                                  ; or not.
 40238                                  ;
 40239                                  ; The other Rational patch routine (RationalPatch, below) fixes a register
 40240                                  ; trashing problem on 286 processors, and is only executed if MS-DOS is
 40241                                  ; running in the HMA.
 40242                                  ;
 40243                                  ; This patch detection and replacement is based on an example supplied by
 40244                                  ; Ben Williams at Rational.
 40245                                  ;
 40246                                  ;----------------------------------------------------------------------------
 40247                                  
 40248                                  ; 22/05/2019 - Retro DOS v4.0
 40249                                  ; DOSCODE:B448h (MSDOS 6.21, MSDOS.SYS)
 40250                                  
 40251                                  ;----------------------------------------------------------------------------
 40252                                  ;
 40253                                  ; INPUT : ES = segment where program got loaded
 40254                                  ;
 40255                                  ;----------------------------------------------------------------------------
 40256                                  
 40257                                  rpFind1:
 40258                                  	db	0FAh, 0E4h, 21h, 60h, 33h, 0C0h, 0E6h, 43h, 8Bh, 16h
 40259                                  
 40260                                  rpFind1Len equ	$ - rpFind1
 40261                                  
 40262                                  ;	cli
 40263                                  ;	in	al, 21h
 40264                                  ;	pusha
 40265                                  ;	xor	ax, ax
 40266                                  ;	out	43h, al
 40267                                  ;	mov	dx, ...
 40268                                  
 40269                                  rpFind1a:
 40270                                  	db	0B0h, 0Eh, 0E6h, 37h, 33h, 0C0h, 0E6h, 0F2h
 40271                                  
 40272                                  rpFind1aLen equ	$ - rpFind1a
 40273                                  
 40274                                  ;	mov	al, 0Eh
 40275                                  ;	out	37h, al
 40276                                  ;	xor	ax, ax
 40277                                  ;	out	0F2h, al
 40278                                  
 40279                                  ; bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI
 40280                                  
 40281                                  rpFind2:
 40282                                  	db	0Fh, 20h, 0C0h
 40283                                  
 40284                                  rpFind2Len equ	$ - rpFind2
 40285                                  
 40286                                  ;	mov	eax, cr0	;may be preceeded by PUSH CX (51h)
 40287                                  
 40288                                  rpFind3:
 40289                                  	db	0Fh, 22h, 0C0h, 0EAh
 40290                                  
 40291                                  rpFind3Len equ	$ - rpFind3
 40292                                  
 40293                                  ;	mov	cr0, eax	;may be preceeded by POP CX (59h)
 40294                                  ;	jmp	far ptr xxx	;change far ptr to go to replace3
 40295                                  ;	mov	ss, bx		;8E D3 ... and come back at or after this
 40296                                  
 40297                                  ; note, there is no rpRepl1 string
 40298                                  
 40299                                  rpRepl2:
 40300                                   	db	66h, 50h, 51h, 0Fh, 20h, 0C0h
 40301                                  
 40302                                  rpRepl2Len equ	$ - rpRepl2
 40303                                  
 40304                                  ;	push	eax
 40305                                  ;	push	cx
 40306                                  ;	mov	eax, cr0
 40307                                  
 40308                                  rpRepl3:
 40309                                  	db	8Eh, 0D3h, 59h, 66h, 58h
 40310                                  
 40311                                  rpRepl3Len equ	$ - rpRepl3
 40312                                  
 40313                                  ;	mov	ss, bx
 40314                                  ;	pop	cx
 40315                                  ;	pop	eax
 40316                                  
 40317                                  ; bug # 2 -- loss of high EAX and ESI on 386+ only if VCPI
 40318                                  
 40319                                  rpFind4:
 40320                                  	db	93h, 58h, 8Bh, 0CCh
 40321                                  
 40322                                  rpFind4Len equ	$ - rpFind4
 40323                                  
 40324                                  ;	xchg	bx, ax
 40325                                  ;	pop	ax
 40326                                  ;	mov	cx, sp
 40327                                  
 40328                                  rpFind5:
 40329                                  	db	0B8h, 0Ch, 0DEh, 0CDh, 67h, 8Bh, 0E1h, 0FFh, 0E3h
 40330                                  
 40331                                  rpFind5Len equ	$ - rpFind5
 40332                                  
 40333                                  ;	mov	ax, DE0Ch
 40334                                  ;	int	67h
 40335                                  ;	mov	sp, cx
 40336                                  ;	jmp	bx
 40337                                  
 40338                                  rpRepl4:
 40339                                  	db	93h, 58h, 8Bh, 0CCh
 40340                                  	db	02Eh, 066h, 0A3h
 40341                                  
 40342                                  rpRepl4o1Len equ $ - rpRepl4
 40343                                  
 40344                                  	db	00h, 00h
 40345                                  	db	02Eh, 066h, 89h, 36h
 40346                                  
 40347                                  rpRepl4o2Len equ $ - rpRepl4
 40348                                  
 40349                                  	db	00h, 00h
 40350                                  
 40351                                  rpRepl4Len equ	$ - rpRepl4
 40352                                  
 40353                                  ;	xchg	bx, ax
 40354                                  ;	pop	ax
 40355                                  ;	mov	cx, sp
 40356                                  ;	mov	dword ptr cs:[xxxx], eax
 40357                                  ;	mov	dword ptr cs:[xxxx], esi
 40358                                  
 40359                                  rpRepl5:
 40360                                  	db	8Bh, 0E1h
 40361                                  	db	2Eh, 66h, 0A1h
 40362                                  
 40363                                  rpRepl5o1Len equ $ - rpRepl5
 40364                                  
 40365                                  	db	00h, 00h
 40366                                  	db	2Eh, 66h, 8Bh, 36h
 40367                                  
 40368                                  rpRepl5o2Len equ $ - rpRepl5
 40369                                  
 40370                                  	db	00h, 00h
 40371                                  	db	0FFh, 0E3h
 40372                                  
 40373                                  rpRepl5Len equ	$ - rpRepl5
 40374                                  
 40375                                  ;	mov	sp, cx
 40376                                  ;	mov	eax, dword ptr cs:[xxxx]
 40377                                  ;	mov	esi, dword ptr cs:[xxxx]
 40378                                  ;	jmp	bx
 40379                                  
 40380                                  ; bug # 3 -- loss of high EAX, EBX, ECX, EDX on 386+ only if VCPI
 40381                                  
 40382                                  rpFind6:
 40383                                  	db	0FAh, 52h, 51h
 40384                                  
 40385                                  rpFind6Len equ	$ - rpFind6
 40386                                  
 40387                                  ;	cli
 40388                                  ;	push	dx
 40389                                  ;	push	cx
 40390                                  
 40391                                  rpFind7a:
 40392                                  	db	0B8h, 0Ch, 0DEh, 66h, 26h, 0FFh, 1Eh
 40393                                  
 40394                                  rpFind7aLen equ	$ - rpFind7a
 40395                                  
 40396                                  ;	mov	ax, 0DE0Ch
 40397                                  ;	call	fword ptr es:[xxxx]
 40398                                  
 40399                                  rpFind7b:
 40400                                  	db	59h, 5Ah, 5Bh
 40401                                  
 40402                                  rpFind7bLen equ	$ - rpFind7b
 40403                                  
 40404                                  ;	pop	cx
 40405                                  ;	pop	dx
 40406                                  ;	pop	bx
 40407                                  
 40408                                  rpRepl6 :
 40409                                  	db	0FAh, 66h, 50h, 66h, 53h, 66h, 51h, 66h, 52h
 40410                                  
 40411                                  rpRepl6Len equ	$ - rpRepl6
 40412                                  
 40413                                  ;	cli
 40414                                  ;	push	eax
 40415                                  ;	push	ebx
 40416                                  ;	push	ecx
 40417                                  ;	push	edx
 40418                                  
 40419                                  rpRepl7:
 40420                                  	db	66h, 5Ah, 66h, 59h, 66h, 5Bh, 66h, 58h, 5Bh
 40421                                  
 40422                                  rpRepl7Len equ	$ - rpRepl7
 40423                                  
 40424                                  ;	pop	edx
 40425                                  ;	pop	ecx
 40426                                  ;	pop	ebx
 40427                                  ;	pop	eax
 40428                                  ;	pop	bx
 40429                                  
 40430                                  ; bug # 4 -- loss of high EAX and EBX on 386+ only if VCPI
 40431                                  
 40432                                  rpFind8:
 40433                                   	db	60h, 06h, 1Eh, 0B8h, 00h, 00h, 8Eh, 0D8h
 40434                                  
 40435                                  rpFind8Len equ	$ - rpFind8
 40436                                  
 40437                                  ;	pusha
 40438                                  ;	push	es
 40439                                  ;	push	ds
 40440                                  ;	mov	ax, dgroup	;jump back to here from replace8
 40441                                  ;	mov	ds, ax
 40442                                  
 40443                                  rpFind9 :
 40444                                  	db	1Fh, 07h, 61h
 40445                                  
 40446                                  rpFind9Len equ	$ - rpFind9
 40447                                  
 40448                                  ;	pop	ds
 40449                                  ;	pop	es
 40450                                  ;	popa
 40451                                  
 40452                                  rpRepl8:
 40453                                   	db	66h, 60h, 06h, 1Eh
 40454                                  
 40455                                  rpRepl8Len equ	$ - rpRepl8
 40456                                  
 40457                                  ;	pushad
 40458                                  ;	push	es
 40459                                  ;	push	ds
 40460                                  
 40461                                  rpRepl9:
 40462                                  	db	1Fh, 07h, 66h, 61h, 0C3h
 40463                                  
 40464                                  rpRepl9Len equ	$ - rpRepl9
 40465                                  
 40466                                  ;	pop	ds
 40467                                  ;	pop	es
 40468                                  ;	popad
 40469                                  ;	retn			;no need to jmp back to main-line
 40470                                  
 40471                                  ;----------------------------------------------------------------------------
 40472                                  
 40473                                  struc SearchPair
 40474                                   .sp_off1: resw 1	; offset of 1st search string
 40475                                   .sp_len1: resw 1	; length of 1st search string
 40476                                   .sp_off2: resw 1	; 2nd string
 40477                                   .sp_len2: resw 1	; 2nd string
 40478                                   .sp_diff: resw 1	; max difference between offsets
 40479                                   .size:
 40480                                  endstruc
 40481                                  
 40482                                  ;rpBug1Strs SearchPair	<offset rpFind2, rpFind2Len, offset rpFind3, rpFind3Len, 20h>
 40483                                  
 40484                                  rpBug1Strs:
 40485                                  	dw	rpFind2
 40486                                  	dw	rpFind2Len ; 3
 40487                                  	dw	rpFind3
 40488                                  	dw	rpFind3Len ; 4
 40489                                  	dw	20h
 40490                                  
 40491                                  ;rpBug2Strs SearchPair	<offset rpFind4, rpFind4Len, offset rpFind5, rpFind5Len, 80h>
 40492                                  
 40493                                  rpBug2Strs:
 40494                                  	dw	rpFind4
 40495                                  	dw	rpFind4Len ; 4
 40496                                  	dw	rpFind5
 40497                                  	dw	rpFind5Len ; 9
 40498                                  	dw	80h
 40499                                  
 40500                                  ;rpBug3Strs SearchPair	<offset rpFind6, rpFind6Len, offset rpFind7a, rpFind7aLen, 80h>
 40501                                  
 40502                                  rpBug3Strs:
 40503                                  	dw	rpFind6
 40504                                  	dw	rpFind6Len ; 3
 40505                                  	dw	rpFind7a
 40506                                  	dw	rpFind7aLen ; 7
 40507                                  	dw	80h
 40508                                  
 40509                                  ;rpBug4Strs SearchPair	<offset rpFind8, 4, offset rpFind9, rpFind9Len, 80h>
 40510                                  
 40511                                  rpBug4Strs:
 40512                                  	dw	rpFind8
 40513                                  	dw	4
 40514                                  	dw	rpFind9
 40515                                  	dw	rpFind9Len ; 3
 40516                                  	dw	80h
 40517                                  
 40518                                  ;----------------------------------------------------------------------------
 40519                                  
 40520                                  struc StackVars
 40521                                   .sv_wVersion:	resw 1		; Rational extender version #
 40522                                   .sv_cbCodeSeg: resw 1		; code seg size to scan
 40523                                   .sv_pPatch:	resw 1		; offset of next avail patch byte
 40524                                   .size:
 40525                                  endstruc
 40526                                  
 40527                                  ;----------------------------------------------------------------------------
 40528                                  
 40529                                  ; 22/05/2019 - Retro DOS v4.0
 40530                                  
 40531                                  Rational386Patch:
 40532                                  	; Do a few quick checks to see if this looks like a Rational
 40533                                  	; Extended application. Hopefully this will quickly weed out
 40534                                  	; most non Rational apps.
 40535                                  
 40536                                  	cmp	word [es:0],395		; version number goes here - versions
 40537                                  	jae	short rp3QuickOut	;   3.95+ don't need patching
 40538                                  
 40539                                  	cmp	word [es:0Ch],20h	; always has this value here
 40540                                  	jne	short rp3QuickOut
 40541                                  
 40542                                  	push	ax
 40543                                  
 40544                                  	mov	ax,18h 			; extender has 18h at
 40545                                  	cmp	[es:24],ax		;   offsets 24, 28, & 36
 40546                                  	jne	short rp3QO_ax
 40547                                  	cmp	[es:28],ax
 40548                                  	jne	short rp3QO_ax
 40549                                  	cmp	[es:36],ax
 40550                                  	je	short rp3Maybe
 40551                                  rp3QO_ax:
 40552                                  	pop	ax
 40553                                  rp3QuickOut:
 40554                                  	retn
 40555                                  
 40556                                  ; It might be the rational extender, do more extensive checking
 40557                                  
 40558                                  rp3Maybe:
 40559                                  	cld
 40560                                  	push	bx			; note ax pushed above
 40561                                  	push	cx
 40562                                  	push	dx
 40563                                  	push	si
 40564                                  	push	di
 40565                                  	push	es
 40566                                  	push	ds			; we use all of them
 40567                                  	push	bp
 40568                                  	sub	sp,StackVars.size  ; 6	; make space for stack variables
 40569                                  	mov	bp,sp
 40570                                  
 40571                                  	push	cs
 40572                                  	pop	ds
 40573                                  
 40574                                  	mov	ax,[es:0]		; save version #
 40575                                  	;mov	[bp+StackVars.sv_wVersion],ax
 40576                                  	mov	[bp],ax	
 40577                                  					; check that binary version # matches
 40578                                  	call	VerifyVersion		;   ascii string
 40579                                  	jne	short rp3Exit_j
 40580                                  
 40581                                  ; Looks like this is it, find where to put the patch code.  The
 40582                                  ; patch will be located on top of Rational code specific to 80286
 40583                                  ; processors, so these patchs MUST NOT be applied if running on
 40584                                  ; an 80286 system.
 40585                                  
 40586                                  	; Rational says the code to patch will never be beyond offset 46xxh
 40587                                  
 40588                                  	mov	cx,4500h		; force search len to 4700h (searches
 40589                                  	;mov	[bp+2],cx
 40590                                  	mov	[bp+StackVars.sv_cbCodeSeg],cx	; start at offset 200h)
 40591                                  
 40592                                  	mov	es,[es:20h]		; es=code segment
 40593                                  
 40594                                  	mov	si,rpFind1		; string to find
 40595                                  	mov	dx,rpFind1Len ; 10	; length to match
 40596                                  	call	ScanCodeSeq		; look for code seq
 40597                                  	jz	short rpGotPatch
 40598                                  
 40599                                  ; According to Rational, some very old versions of the extender may not
 40600                                  ; have the find1 code sequence. If the find1 code wasn't found above,
 40601                                  ; try an alternative patch area which is on top of NEC 98xx switching code.
 40602                                  
 40603                                  	mov	si,rpFind1a
 40604                                  	mov	dx,rpFind1aLen  ;8
 40605                                  	call	ScanCodeSeq
 40606                                  	jz	short rpGotPatch
 40607                                  
 40608                                  rp3Exit_j:
 40609                                  	jmp	rp3Exit
 40610                                  
 40611                                  ; Found the location to write patch code! DI = offset in code seg.
 40612                                  
 40613                                  rpGotPatch:
 40614                                  	;mov	[bp+4],di
 40615                                  	mov	[bp-StackVars.sv_pPatch],di	; save patch pointer
 40616                                  
 40617                                  ;----------------------------------------------------------------------------
 40618                                  ; Bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI
 40619                                  
 40620                                  	;cmp	word [bp+0],381
 40621                                  	;cmp	word [bp+StackVars.sv_wVersion],381 ; only need bug 1 if version
 40622                                  	cmp	word [bp],381
 40623                                  	jae	short rpBug2			;   < 3.81
 40624                                  
 40625                                  	mov	bx,rpBug1Strs			; locate find2 & find3 code
 40626                                  	call	FindBadCode
 40627                                  	jc	short rpBug2
 40628                                  
 40629                                  ; si = rpFind2 offset, di = rpFind3 offset
 40630                                  
 40631                                  	push	di
 40632                                  	mov	di,si				; rpFind2 offset
 40633                                  	mov	dx,rpFind2Len ; 3
 40634                                  
 40635                                  	cmp	byte [es:di-1],51h	 	; find2 preceeded by push cx?
 40636                                  	jne	short rp_no_cx
 40637                                  
 40638                                  	dec	di				;   yes, gobble up push cx too
 40639                                  	inc	dx
 40640                                  rp_no_cx:
 40641                                  	mov	si,rpRepl2			; patch out find2 sequence
 40642                                  	mov	cx,rpRepl2Len  ; 6
 40643                                  	call	GenPatch
 40644                                  
 40645                                  	pop	di				; rpFind3 offset
 40646                                  	cmp	byte [es:di-1],59h 		; find3 preceeded by pop cx?
 40647                                  	jne	short rp_no_cx2
 40648                                  
 40649                                  	mov	byte [es:di-1],90h		;   yes, no-op it
 40650                                  rp_no_cx2:
 40651                                  	;mov	ax,[bp+4]
 40652                                  	mov	ax,[bp+StackVars.sv_pPatch]	; change offset of far jmp
 40653                                  	;mov	[es:di+4],ax
 40654                                  	mov	[es:di+rpFind3Len],ax		;   to go to patch code
 40655                                  
 40656                                  	push	di				; save find3 offset
 40657                                  	mov	si,rpRepl3			; copy repl3 to patch area
 40658                                  	mov	cx,rpRepl3Len ; 5
 40659                                  	call	CopyPatch
 40660                                  
 40661                                  	pop	bx				; find3 offset
 40662                                  	add	bx,rpFind3Len+4	 ; 8		; skip over find3 and far jmp
 40663                                  	call	GenJump 			; jmp back from patch area
 40664                                  	;mov	[bp+4],di
 40665                                  	mov	[bp+StackVars.sv_pPatch], di	;   to main-line, update patch
 40666                                  						;   area pointer
 40667                                  
 40668                                  ;----------------------------------------------------------------------------
 40669                                  ; Bug # 2 -- loss of high regs on 386+ under VCPI only
 40670                                  
 40671                                  rpBug2:
 40672                                  	mov	bx,rpBug2Strs			; locate find4 & find5 code
 40673                                  	call	FindBadCode
 40674                                  	jc	short rpBug3
 40675                                  
 40676                                  ; si = rpFind4 offset, di = rpFind5 offset
 40677                                  
 40678                                  	;push	word [bp+4]
 40679                                  	push	word [bp+StackVars.sv_pPatch]	; save current patch pointer
 40680                                  						;   (where repl4 goes)
 40681                                  	push	di				; save find5 offset
 40682                                  
 40683                                  	mov	di,si
 40684                                  	mov	dx,rpFind4Len ; 4
 40685                                  	mov	si,rpRepl4
 40686                                  	mov	cx,rpRepl4Len ; 15
 40687                                  	call	GenPatch			; patch out find4 code
 40688                                  
 40689                                  	pop	di				; find5 offset
 40690                                  	add	di,5				; keep 5 bytes of find5 code
 40691                                  	;mov	bx,[bp+4]
 40692                                  	mov	bx,[bp+StackVars.sv_pPatch]	; jump to patch area
 40693                                  	push	bx				; save repl5 location
 40694                                  	call	GenJump
 40695                                  
 40696                                  	mov	si,rpRepl5			; copy repl5 code to patch
 40697                                  	mov	cx,rpRepl5Len  ; 15		;   area -- it has a jmp bx
 40698                                  	call	CopyPatch			;   so no need to jmp back to
 40699                                  						;   main-line code
 40700                                  
 40701                                  ; patches have been made, now update the patch code to store/load dwords just
 40702                                  ; after the code in the patch area
 40703                                  
 40704                                  	pop	di				; repl5 location
 40705                                  	pop	si				; repl4 location
 40706                                  
 40707                                  	;mov	ax,[bp+4]
 40708                                  	mov	ax,[bp+StackVars.sv_pPatch]	; (where dwords go)
 40709                                  
 40710                                  	;mov	[es:si+7],ax
 40711                                  	mov	[es:si+rpRepl4o1Len],ax		; offset for EAX
 40712                                  	;mov	[es:di+5],ax
 40713                                  	mov	[es:di+rpRepl5o1Len],ax
 40714                                  	add	ax,4
 40715                                  	;mov	[es:si+0Dh],ax
 40716                                  	mov	[es:si+rpRepl4o2Len],ax		; offset for ESI
 40717                                  	;mov	[es:di+0Bh],ax
 40718                                  	mov	[es:di+rpRepl5o2Len],ax
 40719                                  
 40720                                  	;add	word [bp+4],8
 40721                                  	add	word [bp+StackVars.sv_pPatch],8	; reserve space for 2 dwords in
 40722                                  						; patch area
 40723                                  
 40724                                  ;----------------------------------------------------------------------------
 40725                                  ; Bug # 3 -- loss of high regs on 386+ under VCPI only
 40726                                  
 40727                                  rpBug3:
 40728                                  	mov	bx,rpBug3Strs			; locate find6 & find7a code
 40729                                  	call	FindBadCode
 40730                                  	jc	short rpBug4
 40731                                  
 40732                                  	;add	di,9
 40733                                  	add	di,rpFind7aLen + 2		; skip over offset in find7a
 40734                                  	push	si				;   code and locate find7b
 40735                                  	mov	si,rpFind7b			;   sequence
 40736                                  	mov	dx,rpFind7bLen ; 3
 40737                                  	call	ScanCodeSeq_di
 40738                                  	pop	si
 40739                                  	jnz	short rpBug4
 40740                                  
 40741                                  	push	di				; save find7b code offset
 40742                                  
 40743                                  	mov	di,si
 40744                                  	mov	dx,rpFind6Len ; 3
 40745                                  	mov	si,rpRepl6
 40746                                  	mov	cx,rpRepl6Len ; 9
 40747                                  	call	GenPatch			; patch out find6 code
 40748                                  
 40749                                  	pop	di
 40750                                  	mov	dx,rpFind7bLen ; 3
 40751                                  	mov	si,rpRepl7
 40752                                  	mov	cx,rpRepl7Len ; 9
 40753                                  	call	GenPatch			; patch out find7b code
 40754                                  
 40755                                  ;----------------------------------------------------------------------------
 40756                                  ; Bug # 4 -- loss of high regs on 386+ under VCPI only
 40757                                  
 40758                                  rpBug4:
 40759                                  	;cmp	word [bp+0],360
 40760                                  	;cmp	word [bp+StackVars.sv_wVersion],360 ; only applies if 
 40761                                  	cmp	word [bp],360
 40762                                  	jbe	short rp3Exit 			; version > 3.60 and < 3.95
 40763                                  
 40764                                  	mov	bx,rpBug4Strs			; locate find8 & find9 code
 40765                                  	call	FindBadCode
 40766                                  	jc	short rp3Exit
 40767                                  
 40768                                  	push	di				; save find9 code offset
 40769                                  
 40770                                  	mov	di,si
 40771                                  	mov	dx,3
 40772                                  	mov	si,rpRepl8
 40773                                  	mov	cx,rpRepl8Len ; 4
 40774                                  	call	GenPatch			; patch out find8 code
 40775                                  
 40776                                  	pop	di				; find9 offset
 40777                                  	;mov	bx,[bp+4]
 40778                                  	mov	bx,[bp+StackVars.sv_pPatch]	; patch find9 to jmp to
 40779                                  	call	GenJump 			;   patch area
 40780                                  
 40781                                  	mov	si,rpRepl9			; copy replacement code to
 40782                                  	mov	cx,rpRepl9Len ; 5		;   patch area--it does a RET
 40783                                  	call	CopyPatch			;   so no jmp back to main-line
 40784                                  
 40785                                  rp3Exit:
 40786                                  	add	sp,StackVars.size
 40787                                  	pop	bp
 40788                                  	pop	ds
 40789                                  	pop	es
 40790                                  	pop	di
 40791                                  	pop	si
 40792                                  	pop	dx
 40793                                  	pop	cx
 40794                                  	pop	bx
 40795                                  	pop	ax
 40796                                  	retn
 40797                                  
 40798                                  ;----------------------------------------------------------------------------
 40799                                  ;
 40800                                  ; FindBadCode
 40801                                  ;
 40802                                  ; Searches Rational code segment looking for a pair of find strings (all
 40803                                  ; patches have at least two find strings).
 40804                                  ;
 40805                                  ; Entry:
 40806                                  ;	ES    = code segment to search
 40807                                  ;	DS:BX = search pair structure for this search
 40808                                  ;	[bp].sv_cbCodeSeg = length of code seg to search
 40809                                  ;
 40810                                  ; Exit:
 40811                                  ;	CY flag clear if both strings found, and
 40812                                  ;	SI    = offset in ES of 1st string
 40813                                  ;	DI    = offset in ES of 2nd string
 40814                                  ;	CY set if either string not found, or strings too far apart
 40815                                  ;
 40816                                  ; Used:
 40817                                  ;	CX
 40818                                  ;
 40819                                  ;----------------------------------------------------------------------------
 40820                                  
 40821                                  ;struc SearchPair
 40822                                  ; .sp_off1: resw 1	; offset of 1st search string
 40823                                  ; .sp_len1: resw 1	; length of 1st search string
 40824                                  ; .sp_off2: resw 1	; 2nd string
 40825                                  ; .sp_len2: resw 1	; 2nd string
 40826                                  ; .sp_diff: resw 1	; max difference between offsets
 40827                                  ; .size:
 40828                                  ;endstruc
 40829                                  
 40830                                  FindBadCode:
 40831                                  	;mov	cx,[bp+2]
 40832                                  	mov	cx,[bp+StackVars.sv_cbCodeSeg]	; search length
 40833                                  
 40834                                  	mov	si,[bx]	; mov si,[bx+0]
 40835                                  	;mov	si,[bx+Searchpair.sp_off1] ; ds:si -> search string
 40836                                  	
 40837                                  	;mov	dx,[bx+2]
 40838                                  	mov	dx,[bx+SearchPair.sp_len1] ; dx = search len
 40839                                  	call	ScanCodeSeq
 40840                                  	jnz	short fbc_error		; done if 1st not found
 40841                                  
 40842                                  	push	di			; save 1st string offset
 40843                                  
 40844                                  	;mov	si,[bx+4]
 40845                                  	mov	si,[bx+SearchPair.sp_off2]
 40846                                  	;mov	dx,[bx+6]
 40847                                  	mov	dx,[bx+SearchPair.sp_len2]
 40848                                  	call	ScanCodeSeq_di		; don't change flags after this!
 40849                                  
 40850                                  	pop	si			; restore 1st string offset
 40851                                  	jnz	short fbc_error
 40852                                  
 40853                                  	mov	ax,di			; sanity check that
 40854                                  	sub	ax,si			;   si < di && di - si <= allowed diff
 40855                                  	jc	short fbc_error
 40856                                  	;cmp	ax,[bx+8]
 40857                                  	cmp	ax,[bx+SearchPair.sp_diff]
 40858                                  	ja	short fbc_error
 40859                                  
 40860                                  	clc
 40861                                  	retn
 40862                                  
 40863                                  fbc_error:
 40864                                  	stc
 40865                                  	retn
 40866                                  
 40867                                  ;----------------------------------------------------------------------------
 40868                                  ;
 40869                                  ; GenPatch
 40870                                  ;
 40871                                  ; Generate a patch sequence. 1) insert a jump at the buggy code location
 40872                                  ; (jumps to the patch code area), 2) copy the selected patch code to the
 40873                                  ; patch area, 3) insert a jump from the patch area back to the main-line
 40874                                  ; code.
 40875                                  ;
 40876                                  ; Entry:
 40877                                  ;	ES:DI = start of buggy code to be patched
 40878                                  ;	DX    = length of buggy code to be patched
 40879                                  ;	DS:SI = replacement patch code
 40880                                  ;	CX    = length of replacement patch code
 40881                                  ;	[bp].sv_pPatch = offset in ES of where to copy patch code
 40882                                  ;
 40883                                  ; Exit:
 40884                                  ;	DI, [bp].sv_pPatch = byte after generated patch code
 40885                                  ;
 40886                                  ; Used:
 40887                                  ;	AX, BX, SI, Flags
 40888                                  ;
 40889                                  ;----------------------------------------------------------------------------
 40890                                  
 40891                                  GenPatch:
 40892                                  	push	di			;save offset of buggy code
 40893                                  
 40894                                  	;mov	bx,[bp+4]
 40895                                  	mov	bx,[bp+StackVars.sv_pPatch]
 40896                                  					;jump from buggy code to patch area
 40897                                  	call	GenJump
 40898                                  
 40899                                  	call	CopyPatch		;copy replacement code to patch area
 40900                                  
 40901                                  	pop	bx			;offset of buggy code + buggy code
 40902                                  	add	bx,dx			;  length = return from patch offset
 40903                                  
 40904                                  	call	GenJump 		;jump from patch area back to main-
 40905                                  	;mov	[bp+4],di
 40906                                  	mov	[bp+StackVars.sv_pPatch],di
 40907                                  					;  line code, update patch pointer
 40908                                  	retn
 40909                                  
 40910                                  ;----------------------------------------------------------------------------
 40911                                  ;
 40912                                  ; CopyPatch
 40913                                  ;
 40914                                  ; Copies patch code to patch location.
 40915                                  ;
 40916                                  ; Entry:
 40917                                  ;	DS:SI = patch code to be copied
 40918                                  ;	ES    = segment of code to patch
 40919                                  ;	CX    = length of code to copy
 40920                                  ;	[bp].sv_pPatch = offset in ES of where to copy patch code
 40921                                  ;
 40922                                  ; Exit:
 40923                                  ;	DI, [bp].sv_pPatch = byte after copied patch code
 40924                                  ;
 40925                                  ; Used:
 40926                                  ;	SI, Flags
 40927                                  ;
 40928                                  ;----------------------------------------------------------------------------
 40929                                  
 40930                                  CopyPatch:
 40931                                  	push	cx
 40932                                  	;mov	di,[bp+4]
 40933                                  	mov	di,[bp+StackVars.sv_pPatch] ;patch pointer is the dest offset
 40934                                  	cld
 40935                                  	rep movsb
 40936                                  	pop	cx
 40937                                  	;mov	[bp+4],di
 40938                                  	mov	[bp+StackVars.sv_pPatch],di ;update net pointer location
 40939                                  	retn
 40940                                  
 40941                                  ;----------------------------------------------------------------------------
 40942                                  ;
 40943                                  ; GenJump
 40944                                  ;
 40945                                  ; Generates a rel16 JMP instruction at location 'from' to location 'to'.
 40946                                  ;
 40947                                  ; Entry:
 40948                                  ;	ES:DI = from location (where to put jmp instruction)
 40949                                  ;	BX    = to location (where to jump to)
 40950                                  ;
 40951                                  ; Exit:
 40952                                  ;	DI = byte after generated jump
 40953                                  ;
 40954                                  ; Used:
 40955                                  ;	AX
 40956                                  ;
 40957                                  ;----------------------------------------------------------------------------
 40958                                  
 40959                                  GenJump:
 40960                                  	mov	al,0E9h		; jmp rel16 opcode
 40961                                  	stosb
 40962                                  
 40963                                  	mov	ax,bx		; calc offset to 'to' location
 40964                                  	sub	ax,di
 40965                                  	sub	ax,2
 40966                                  
 40967                                  	stosw			; output offset
 40968                                  
 40969                                  	retn
 40970                                  
 40971                                  ;----------------------------------------------------------------------------
 40972                                  ;
 40973                                  ; ScanCodeSeq
 40974                                  ;
 40975                                  ; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
 40976                                  ;
 40977                                  ; returns in ES:DI the start of the pattern if Zero flag is set
 40978                                  ;
 40979                                  ;----------------------------------------------------------------------------
 40980                                  
 40981                                  ScanCodeSeq:
 40982                                  	mov	di,200h
 40983                                  ScanCodeSeq_di:
 40984                                  	push	cx
 40985                                  	sub	cx,dx
 40986                                  	inc	cx
 40987                                  scsagain:
 40988                                  	push	si
 40989                                  	push	di
 40990                                  	push	cx
 40991                                  	mov	cx,dx
 40992                                  	rep	cmpsb
 40993                                  	pop	cx
 40994                                  	pop	di
 40995                                  	pop	si
 40996                                  	je	short scsfound
 40997                                  	inc	di
 40998                                  	loop	scsagain
 40999                                  scsfound:
 41000                                  	pop	cx
 41001                                  vvexit:		; 18/12/2022
 41002                                  	retn
 41003                                  	
 41004                                  ;----------------------------------------------------------------------------
 41005                                  ;
 41006                                  ; VerifyVersion
 41007                                  ;
 41008                                  ; Checks whether the binary version from ES:0 matches the ASCII version
 41009                                  ; from ES:2A.
 41010                                  ;
 41011                                  ;       Entry: AX = binary version number 
 41012                                  ;       Exit : Z flag set if version numbers match
 41013                                  ;
 41014                                  ;----------------------------------------------------------------------------
 41015                                  
 41016                                  VerifyVersion:
 41017                                  	mov	si,[es:2Ah]		; offset of version number
 41018                                  					;  in ascii
 41019                                  	mov	bl,10
 41020                                  	add	si,3			; point to last digit
 41021                                  
 41022                                  	call	VVDigit
 41023                                  	jne	short vvexit
 41024                                  	call	VVDigit
 41025                                  	jne	short vvexit
 41026                                  	cmp	byte [es:si],'.'
 41027                                  	jne	short vvexit
 41028                                  	dec	si
 41029                                  	;call	VVDigit
 41030                                  	; 18/12/2022
 41031                                  	;jmp	short VVDigit
 41032                                  ;vvexit:
 41033                                  	;retn
 41034                                  VVDigit:
 41035                                  	div	bl
 41036                                  	add	ah,'0'
 41037                                  	dec	si
 41038                                  	cmp	[es:si+1],ah
 41039                                  	mov	ah,0			; do not xor or sub we need Z
 41040                                  	retn
 41041                                  
 41042                                  %endif
 41043                                  
 41044                                  ;-----------------------------------------------------------------------
 41045                                  
 41046                                  ; 23/05/2019 - Retro DOS v4.0
 41047                                  ; DOSCODE:B702h (MSDOS 6.21, MSDOS.SYS)
 41048                                  
 41049                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41050                                  ; DOSCODE:B3E0h (MSDOS 5.0, MSDOS.SYS)
 41051                                  
 41052                                  exepatch_start:	 ; label byte
 41053                                  
 41054                                  	; The following is the code that'll be layed over the buggy unpack
 41055                                  	; code.
 41056                                  str1:
 41057 00007401 06                      	db  06h	  		;push	es		 
 41058 00007402 8CD8                    	db  8Ch,0D8h		;mov	ax,ds 
 41059                                  
 41060                                  first_stop equ	$-str1
 41061                                  			
 41062 00007404 2BC2                    	db  2Bh, 0C2h		;sub	ax, dx			
 41063                                  
 41064                                  first:  ; label	byte
 41065                                  
 41066 00007406 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 41067 00007408 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 41068 0000740A BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 41069 0000740D 57                      	db  57h	    		;push	di
 41070 0000740E B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 41071 00007411 B0FF                    	db  0B0h,0FFh 		;mov	al,0FFH 		
 41072 00007413 F3AE                    	db  0F3h,0AEh 		;repz	scasb			
 41073 00007415 47                      	db  47h	    		;inc	di			
 41074 00007416 8BF7                    	db  8Bh,0F7h  		;mov	si,di			
 41075 00007418 5F                      	db  5Fh	    		;pop	di
 41076 00007419 58                      	db  58h	    		;pop	ax
 41077                                  
 41078                                  second_stop equ	$-first
 41079                                  
 41080 0000741A 2BC2                    	db  2Bh,0C2h  		;sub	ax, dx			
 41081                                  
 41082                                  second: ; label	byte
 41083                                  
 41084 0000741C 8EC0                    	db  8Eh,0C0h  		;mov	es,ax			
 41085                                  		    		;NextRec:				
 41086 0000741E B90402                  	db  0B9h,04h,02h	;mov	cx, 0204h
 41087                                  		    		;norm_agn:				
 41088 00007421 8BC6                    	db  8Bh,0C6h		;mov	ax,si			
 41089 00007423 F7D0                    	db  0F7h,0D0h		;not	ax		
 41090 00007425 D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 41091 00007427 7413                    	db  74h,13h		;jz	short SI_ok			
 41092 00007429 8CDA                    	db  8Ch,0DAh		;mov	dx,ds			
 41093 0000742B 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H
 41094 0000742E 2BD0                    	db  2Bh,0D0h		;sub	dx,ax			
 41095 00007430 7308                    	db  73h,08h		;jnc	short SItoDS			
 41096 00007432 F7DA                    	db  0F7h,0DAh		;neg	dx			
 41097 00007434 D3E2                    	db  0D3h,0E2h		;shl	dx,cl			
 41098 00007436 2BF2                    	db  2Bh,0F2h		;sub	si,dx			
 41099 00007438 33D2                    	db  33h,0D2h		;xor	dx,dx			
 41100                                  				;SItoDS: 				
 41101 0000743A 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 41102                                  				;SI_ok:					
 41103 0000743C 87F7                    	db  87h,0F7h		;xchg	si,di			
 41104 0000743E 1E                      	db  1Eh			;push	ds			
 41105 0000743F 06                      	db  06h			;push	es			
 41106 00007440 1F                      	db  1Fh			;pop	ds			
 41107 00007441 07                      	db  07h			;pop	es			
 41108 00007442 FECD                    	db  0FEh,0CDh		;dec	ch			
 41109 00007444 75DB                    	db  75h,0DBh		;jnz	short norm_agn		
 41110 00007446 AC                      	db  0ACh		;lodsb			
 41111 00007447 92                      	db  92h			;xchg	dx,ax
 41112 00007448 4E                      	db  4Eh			;dec	si
 41113 00007449 AD                      	db  0ADh		;lodsw			
 41114 0000744A 8BC8                    	db  8Bh,0C8h		;mov	cx,ax		
 41115 0000744C 46                      	db  46h			;inc	si		
 41116 0000744D 8AC2                    	db  8Ah,0C2h		;mov	al,dl		
 41117 0000744F 24FE                    	db  24h,0FEh		;and	al,0FEH		
 41118 00007451 3CB0                    	db  3Ch,0B0h		;cmp	al,RPTREC
 41119 00007453 7505                    	db  75h,05h		;jne	short TryEnum
 41120 00007455 AC                      	db  0ACh		;lodsb				
 41121 00007456 F3AA                    	db  0F3h,0AAh		;rep stosb			
 41122                                  
 41123                                  ;	db  0EBh,07h,90h	;jmp	short TryNext
 41124 00007458 EB06                    	db  0EBh,06h		;jmp	short TryNext
 41125                                  
 41126                                  				;TryEnum:
 41127 0000745A 3CB2                    	db  3Ch,0B2h		;cmp	al,ENMREC
 41128 0000745C 756C                    	db  75h,6Ch		;jne	short CorruptExe		
 41129 0000745E F3A4                    	db  0F3h,0A4h		;rep movsb			
 41130                                  				;TryNext:
 41131                                  
 41132 00007460 92                      	db  92h			;xchg	dx,ax
 41133                                  ;	db  8Ah,0C2h		;mov	al,dl			
 41134                                  
 41135 00007461 A801                    	db  0A8h,01h		;test	al,1			
 41136 00007463 74B9                    	db  74h,0B9h		;jz	short NextRec			
 41137 00007465 9090                    	db  90h,90h		;nop,nop
 41138                                  	
 41139                                  last_stop equ $-second
 41140                                  size_str1 equ $-str1
 41141                                  
 41142                                  	; The following is the code that we need to look for in the exe
 41143                                  	; file.
 41144                                  
 41145                                  scan_patch1: ; label byte
 41146                                  
 41147 00007467 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 41148 00007469 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 41149 0000746B 2BC2                    	db  2Bh,0C2h		;sub	ax,dx
 41150 0000746D 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 41151 0000746F 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 41152 00007471 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 41153 00007474 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 41154 00007477 B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 41155 00007479 F3AE                    	db  0F3h,0AEh		;repz	scasb			
 41156 0000747B 47                      	db  47h			;inc	di			
 41157 0000747C 8BF7                    	db  8Bh,0F7h		;mov	si,di
 41158 0000747E 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 41159 00007480 2BC2                    	db  2Bh,0C2h		;sub	ax, dx
 41160 00007482 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 41161 00007484 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 41162                                  				;NextRec:
 41163 00007487 B104                    	db  0B1h,04h		;mov	cl,4
 41164 00007489 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 41165 0000748B F7D0                    	db  0F7h,0D0h		;not	ax		
 41166 0000748D D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 41167 0000748F 7409                    	db  74h,09h		;jz	short SI_ok
 41168 00007491 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 41169 00007493 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41170 00007495 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 41171 00007497 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H	       
 41172                                  	       			;SI_ok:
 41173 0000749A 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 41174 0000749C F7D0                    	db  0F7h,0D0h		;not	ax
 41175 0000749E D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 41176 000074A0 7409                    	db  74h,09h		;jz	short DI_ok
 41177 000074A2 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 41178 000074A4 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41179 000074A6 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 41180 000074A8 83CFF0                  	db  83h,0CFh,0F0h	;or	di,0FFF0H
 41181                                  				;DI_ok:
 41182                                  
 41183                                  size_scan_patch1 equ $-scan_patch1
 41184                                  
 41185                                  scan_patch2: ; label byte
 41186                                  			
 41187 000074AB 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 41188 000074AD 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 41189 000074AF 48                      	db  48h			;dec	ax
 41190 000074B0 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 41191 000074B2 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 41192 000074B4 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 41193 000074B7 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 41194 000074BA B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 41195 000074BC F3AE                    	db  0F3h,0AEh		;repz	scasb			
 41196 000074BE 47                      	db  47h			;inc	di			
 41197 000074BF 8BF7                    	db  8Bh,0F7h		;mov	si,di
 41198 000074C1 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 41199 000074C3 48                      	db  48h			;dec	ax
 41200 000074C4 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 41201 000074C6 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH		
 41202                                  				;NextRec:
 41203 000074C9 B104                    	db  0B1h,04h		;mov	cl,4
 41204 000074CB 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 41205 000074CD F7D0                    	db  0F7h,0D0h		;not	ax		
 41206 000074CF D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 41207 000074D1 740A                    	db  74h,0Ah		;jz	short SI_ok
 41208 000074D3 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 41209 000074D5 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41210 000074D7 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 41211 000074D9 81CEF0FF                	db  81h,0CEh,0F0h,0FFh
 41212                                  				;or	si,0FFF0H
 41213                                  				;SI_ok:
 41214 000074DD 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 41215 000074DF F7D0                    	db  0F7h,0D0h		;not	ax
 41216 000074E1 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 41217 000074E3 740A                    	db  74h,0Ah		;jz	short DI_ok
 41218 000074E5 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 41219 000074E7 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41220 000074E9 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 41221 000074EB 81CFF0FF                	db  81h,0CFh,0F0h,0FFh
 41222                                  				;or	di,0FFF0H
 41223                                  				;DI_ok:
 41224                                  
 41225                                  size_scan_patch2 equ $-scan_patch2
 41226                                  
 41227                                  scan_patch3: ; label byte
 41228                                  
 41229 000074EF 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 41230 000074F1 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 41231 000074F3 48                      	db  48h			;dec	ax
 41232 000074F4 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 41233 000074F6 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 41234 000074F8 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 41235 000074FB B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 41236 000074FE B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 41237 00007500 F3AE                    	db  0F3h,0AEh		;repz	scasb			
 41238 00007502 47                      	db  47h			;inc	di			
 41239 00007503 8BF7                    	db  8Bh,0F7h		;mov	si,di
 41240 00007505 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 41241 00007507 48                      	db  48h			;dec	ax
 41242 00007508 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 41243 0000750A BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH		
 41244                                  				;NextRec:
 41245 0000750D B104                    	db  0B1h,04h		;mov	cl,4
 41246 0000750F 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 41247 00007511 F7D0                    	db  0F7h,0D0h		;not	ax		
 41248 00007513 D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 41249 00007515 7409                    	db  74h,09h		;jz	short SI_ok
 41250 00007517 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 41251 00007519 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41252 0000751B 8EDA                    	db  8Eh,0DAh		;mov	ds,dx	
 41253 0000751D 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H	
 41254                                  				;SI_ok:
 41255 00007520 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 41256 00007522 F7D0                    	db  0F7h,0D0h		;not	ax
 41257 00007524 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 41258 00007526 7409                    	db  74h,09h		;jz	short DI_ok
 41259 00007528 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 41260 0000752A 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41261 0000752C 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 41262 0000752E 83CFF0                  	db  83h,0CFh,0F0h	;or	di,0FFF0H
 41263                                  				;DI_ok:
 41264                                  
 41265                                  size_scan_patch3 equ $-scan_patch3
 41266                                  
 41267                                  scan_com: ; label byte
 41268                                  
 41269 00007531 AC                      	db  0ACh		;lodsb			
 41270 00007532 8AD0                    	db  8Ah,0D0h		;mov	dl,al		
 41271 00007534 4E                      	db  4Eh			;dec	si
 41272 00007535 AD                      	db  0ADh		;lodsw			
 41273 00007536 8BC8                    	db  8Bh,0C8h		;mov	cx,ax		
 41274 00007538 46                      	db  46h			;inc	si		
 41275 00007539 8AC2                    	db  8Ah,0C2h		;mov	al,dl		
 41276 0000753B 24FE                    	db  24h,0FEh		;and	al,0FEH		
 41277 0000753D 3CB0                    	db  3Ch,0B0h		;cmp	al,RPTREC
 41278 0000753F 7506                    	db  75h,06h		;jne	short TryEnum
 41279 00007541 AC                      	db  0ACh		;lodsb				
 41280 00007542 F3AA                    	db  0F3h,0AAh		;rep stosb			
 41281 00007544 EB0790                  	db  0EBh,07h,90h	;jmp	short TryNext
 41282                                  				;TryEnum:
 41283 00007547 3CB2                    	db  3Ch,0B2h		;cmp	al,ENMREC
 41284 00007549 756B                    	db  75h,6Bh		;jne	short CorruptExe		
 41285 0000754B F3A4                    	db  0F3h,0A4h		;rep movsb			
 41286                                  				;TryNext:
 41287 0000754D 8AC2                    	db  8Ah,0C2h		;mov	al,dl			
 41288 0000754F A801                    	db  0A8h,01h		;test	al,1			
 41289                                  ;	db  74h,0BAh		;jz	short NextRec			
 41290                                  
 41291                                  size_scan_com	equ	$-scan_com
 41292                                  
 41293                                  ;-----------------------------------------------------------------------
 41294                                  
 41295                                  ; 23/05/2019 - Retro DOS v4.0
 41296                                  ; DOSCODE:B852h (MSDOS 6.21, MSDOS.SYS)
 41297                                  
 41298                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41299                                  ; DOSCODE:B530h (MSDOS 5.0, MSDOS.SYS)
 41300                                  
 41301                                  ExePatch:
 41302                                  	; 28/12/2022 - Retro DOS v4.1
 41303                                  	;call	ExePackPatch
 41304                                  	;;call	word [ss:RationalPatchPtr]
 41305                                  	;retn
 41306                                  	; 28/12/2022
 41307                                  	;jmp	short ExePackPatch
 41308                                  
 41309                                  ;-----------------------------------------------------------------------
 41310                                  ;
 41311                                  ; Procedure Name 	: ExePackPatch
 41312                                  ;
 41313                                  ; Inputs	 	: DS 			-> DOSDATA
 41314                                  ;			  ES:0 			-> read in image
 41315                                  ;			  ax:cx = start cs:ip of program
 41316                                  ; Output		:		
 41317                                  ;
 41318                                  ;	1. If ES <= 0fffh
 41319                                  ;	   2. if exepack signature ('RB') found
 41320                                  ;	      3. if common code to patch compares (for 3 diff. versions)
 41321                                  ;	       	 4. if rest of the code & checksum compares
 41322                                  ;	  	    5. overlay buggy code with code in 
 41323                                  ;		       doscode:str1.
 41324                                  ;		 6. endif
 41325                                  ;	      7. endif
 41326                                  ;	   8. endif
 41327                                  ;	9. endif
 41328                                  ;
 41329                                  ;
 41330                                  ; Uses			: NONE
 41331                                  ;
 41332                                  ;-----------------------------------------------------------------------
 41333                                  		
 41334                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41335                                  	; 23/05/2019 - Retro DOS v4.0	
 41336                                  ExePackPatch:
 41337 00007551 53                      	push	bx
 41338 00007552 8CC3                    	mov	bx,es			; bx has load segment
 41339 00007554 81FBFF0F                	cmp	bx,0FFFh		; Q: is the load segment > 64K
 41340 00007558 7602                    	jbe	short ep_cont		; N: 
 41341 0000755A 5B                      	pop	bx			; Y: no need to patch
 41342 0000755B C3                      	retn
 41343                                  ep_cont:
 41344 0000755C 1E                      	push	ds
 41345 0000755D 06                      	push	es
 41346 0000755E 50                      	push	ax
 41347 0000755F 51                      	push	cx
 41348 00007560 56                      	push	si
 41349 00007561 57                      	push	di
 41350                                  	
 41351                                  		; M033 - start
 41352                                  		; exepacked programs have an IP of 12h (>=2)
 41353                                  
 41354 00007562 83E902                  	sub	cx,2			; Q: is IP >=2 
 41355 00007565 7303                    	jnb	short epp_1		; N: exit
 41356 00007567 E9C500                  	jmp	ep_notpacked
 41357                                  					; ax:cx now points to location of
 41358                                  					; 'RB' if this is an exepacked file.
 41359                                  		; M033 - end
 41360                                  epp_1:
 41361 0000756A 89CF                    	mov	di,cx
 41362 0000756C 8EC0                    	mov	es,ax
 41363 0000756E 36893E[8700]            	mov	[ss:UNPACK_OFFSET],di	; save pointer to 'RB' in 
 41364                                  					; unpack_offset
 41365                                  
 41366 00007573 26813D5242              	cmp	word [es:di],'RB' ; 4252h
 41367                                  	;ljne	ep_notpacked
 41368 00007578 7403                    	je	short epp_2
 41369 0000757A E9B200                  	jmp	ep_notpacked
 41370                                  epp_2:
 41371 0000757D 0E                      	push	cs
 41372 0000757E 1F                      	pop	ds			; set ds to cs
 41373                                  
 41374                                  	;add	di,6Ch
 41375 0000757F 83C76C                  	add	di,PATCH1_COM_OFFSET	; es:di -> points to place in packed 
 41376                                  					;          file where we hope to find
 41377                                  					;	   scan string. 
 41378                                  
 41379 00007582 E8B200                  	call	chk_common_str		; check for match
 41380                                  
 41381 00007585 7524                    	jnz	short ep_chkpatch2	; Q: does the patch match
 41382                                  					; N: check at patch2_offset
 41383                                  					; Y: check for rest of patch string
 41384 00007587 BE[6774]                	mov	si,scan_patch1
 41385                                  					; ds:si -> scan string 
 41386 0000758A 368B3E[8700]            	mov	di,[ss:UNPACK_OFFSET]	; restore di to point to 'RB'
 41387                                  
 41388                                  	;add	di,28h
 41389                                  	; 07/12/2022
 41390 0000758F 83C728                  	add	di,PATCH1_OFFSET	; es:di -> points to place in packed 
 41391                                  					;          file where we hope to find
 41392                                  					;	   scan string. 
 41393                                  	;mov	cx,68
 41394 00007592 B94400                  	mov	cx,size_scan_patch1
 41395                                  	;mov	bx,142
 41396 00007595 BB8E00                  	mov	bx,CHKSUM1_LEN
 41397                                  	;mov	ax,0EF4Eh
 41398 00007598 B84EEF                  	mov	ax,PATCH1_CHKSUM
 41399 0000759B E8AD00                  	call	chk_patchsum		; check if patch and chk sum compare
 41400 0000759E 7208                    	jc	short ep_done1		; Q: did we pass the test
 41401                                  					; N: exit
 41402                                  					; Y: overlay code with new 
 41403 000075A0 BE[0174]                	mov	si,str1
 41404                                  	;mov	cx,102
 41405 000075A3 B96600                  	mov	cx,size_str1
 41406                                  	
 41407 000075A6 F3A4                    	rep	movsb
 41408                                  ep_done1:
 41409 000075A8 E98400                  	jmp	ep_done
 41410                                  
 41411                                  ep_chkpatch2:
 41412                                  	;mov	di,76h
 41413 000075AB BF7600                  	mov	di,PATCH2_COM_OFFSET	; es:di -> possible location of patch
 41414                                  					; in another version of unpack
 41415 000075AE E88600                  	call	chk_common_str		; check for match
 41416                                  
 41417 000075B1 7544                    	jnz	short ep_chkpatch3	; Q: does the patch match
 41418                                  					; N: check for patch3_offset
 41419                                  					; Y: check for rest of patch string
 41420                                  
 41421 000075B3 BE[AB74]                	mov	si,scan_patch2
 41422                                  					; ds:si -> scan string 
 41423                                  	;mov	di,32h
 41424 000075B6 BF3200                  	mov	di,PATCH2_OFFSET	; es:di -> points to place in packed 
 41425                                  					;          file where we hope to find
 41426                                  	;mov	cx,68			;	   scan string. 
 41427 000075B9 B94400                  	mov	cx,size_scan_patch2
 41428                                  	;mov	bx,140
 41429 000075BC BB8C00                  	mov	bx,CHKSUM2_LEN
 41430                                  	;mov	ax,78B2h
 41431 000075BF B8B278                  	mov	ax,PATCH2_CHKSUM
 41432 000075C2 E88600                  	call	chk_patchsum		; check if patch and chk sum compare
 41433                                  
 41434                                  					; M046 - Start
 41435                                  					; Q: did we pass the test
 41436 000075C5 7311                    	jnc	short ep_patchcode2		; Y: overlay code with new 
 41437                                  					; N: try with a different chksum
 41438                                  
 41439 000075C7 BE[AB74]                	mov	si,scan_patch2
 41440                                  					; ds:si -> scan string 
 41441                                  	;mov	cx,68
 41442 000075CA B94400                  	mov	cx,size_scan_patch2
 41443                                  	;mov	bx,129
 41444 000075CD BB8100                  	mov	bx,CHKSUM2A_LEN
 41445                                  	;mov	ax,1C47h
 41446 000075D0 B8471C                  	mov	ax,PATCH2A_CHKSUM
 41447 000075D3 E87500                  	call	chk_patchsum		; check if patch and chk sum compare
 41448                                  					; Q: did we pass the test
 41449 000075D6 7257                    	jc	short ep_notpacked		; N: try with a different chksum
 41450                                  					; Y: overlay code with new 
 41451                                  						
 41452                                  ep_patchcode2:			       	; M046 - End
 41453 000075D8 BE[0174]                	mov	si,str1
 41454                                  	;mov	cx,3
 41455 000075DB B90300                  	mov	cx,first_stop
 41456 000075DE F3A4                    	rep	movsb
 41457 000075E0 B89048                  	mov	ax,4890h		; ax = opcodes for dec ax, nop
 41458 000075E3 AB                      	stosw
 41459 000075E4 83C602                  	add	si,2
 41460                                  	;mov	cx,20
 41461 000075E7 B91400                  	mov	cx,second_stop
 41462 000075EA F3A4                    	rep	movsb
 41463 000075EC AB                      	stosw				; put in dec ax and nop
 41464 000075ED 83C602                  	add	si,2
 41465                                  	;mov	cx,75
 41466 000075F0 B94B00                  	mov	cx,last_stop
 41467 000075F3 F3A4                    	rep	movsb
 41468 000075F5 EB38                    	jmp	short ep_done
 41469                                  
 41470                                  ep_chkpatch3:
 41471                                  	;mov	di,74h
 41472 000075F7 BF7400                  	mov	di,PATCH3_COM_OFFSET	; es:di -> possible location of patch
 41473                                  					; in another version of unpack
 41474 000075FA E83A00                  	call	chk_common_str		; check for match
 41475                                  
 41476 000075FD 7530                    	jnz	short ep_notpacked	; Q: does the patch match
 41477                                  					; N: exit
 41478                                  					; Y: check for rest of patch string
 41479 000075FF BE[EF74]                	mov	si,scan_patch3
 41480                                  					; ds:si -> scan string 
 41481                                  	;mov	di,32h
 41482 00007602 BF3200                  	mov	di,PATCH3_OFFSET	; es:di -> points to place in packed 
 41483                                  					;          file where we hope to find
 41484                                  					;	   scan string. 
 41485                                  	;mov	cx,66
 41486 00007605 B94200                  	mov	cx,size_scan_patch3
 41487                                  	;mov	bx,139
 41488 00007608 BB8B00                  	mov	bx,CHKSUM3_LEN
 41489                                  	;mov	ax,4EDEh
 41490 0000760B B8DE4E                  	mov	ax,PATCH3_CHKSUM
 41491 0000760E E83A00                  	call	chk_patchsum		; check if patch and chk sum compare
 41492 00007611 721C                    	jc	short ep_notpacked	; Q: did we pass the test
 41493                                  					; N: exit
 41494                                  					; Y: overlay code with new 
 41495 00007613 BE[0174]                	mov	si,str1
 41496                                  	;mv	cx,3
 41497 00007616 B90300                  	mov	cx,first_stop
 41498 00007619 F3A4                    	rep	movsb
 41499 0000761B B048                    	mov	al,48h			; al = opcode for dec ax
 41500 0000761D AA                      	stosb
 41501 0000761E 83C602                  	add	si,2
 41502                                  	;mov	cx,20
 41503 00007621 B91400                  	mov	cx,second_stop
 41504 00007624 F3A4                    	rep	movsb
 41505 00007626 AA                      	stosb				; put in dec ax
 41506 00007627 83C602                  	add	si,2
 41507                                  	;mov	cx,75
 41508 0000762A B94B00                  	mov	cx,last_stop
 41509 0000762D F3A4                    	rep	movsb
 41510                                  
 41511                                  ep_notpacked:
 41512                                  	;stc
 41513                                  ep_done:
 41514 0000762F 5F                      	pop	di
 41515 00007630 5E                      	pop	si
 41516 00007631 59                      	pop	cx
 41517 00007632 58                      	pop	ax
 41518 00007633 07                      	pop	es
 41519 00007634 1F                      	pop	ds
 41520 00007635 5B                      	pop	bx
 41521 00007636 C3                      	retn
 41522                                  
 41523                                  ;-------------------------------------------------------------------------
 41524                                  ;
 41525                                  ; 	Procedure Name	: chk_common_str
 41526                                  ;
 41527                                  ;	Input		: DS = DOSCODE
 41528                                  ;			; ES:DI points to string in packed file
 41529                                  ;
 41530                                  ;	Output		; Z if match else NZ
 41531                                  ;
 41532                                  ;-------------------------------------------------------------------------
 41533                                  
 41534                                  	; 23/05/2019 - Retro DOS v4.0
 41535                                  chk_common_str:
 41536 00007637 BE[3175]                	mov	si,scan_com
 41537                                  					; ds:si -> scan string 
 41538                                  	;mov	cx,32
 41539 0000763A B92000                  	mov	cx,size_scan_com
 41540                                  
 41541 0000763D F3A6                    	repe	cmpsb	       
 41542                                  
 41543                                  					; M046 - start
 41544                                  	; a fourth possible version of these exepacked programs have a 
 41545                                  	; 056h instead of 06Bh. See scan_com above
 41546                                  	;
 41547                                  	; 	db  75h, 6Bh		;jne CorruptExe		
 41548                                  	;
 41549                                  	; If the mismatch at this point is due to a 56h instead of 6Bh 
 41550                                  	; we shall try to match the rest of the string
 41551                                  	;
 41552                                  
 41553 0000763F 7409                    	jz	short ccs_done
 41554 00007641 26807DFF56              	cmp	byte [es:di-1],56h
 41555 00007646 7502                    	jnz	short ccs_done
 41556                                  
 41557 00007648 F3A6                    	repe	cmpsb	    
 41558                                  ccs_done:				; M046 - end
 41559 0000764A C3                      	retn
 41560                                  
 41561                                  ;-------------------------------------------------------------------------
 41562                                  ;
 41563                                  ;	Procedure Name	: chk_patchsum
 41564                                  ;
 41565                                  ;	Input		: DS:SI -> string we're looking for
 41566                                  ;			: ES:DI -> offset in packed file
 41567                                  ;			: CX 	= scan length
 41568                                  ;			: BX	= length of check sum
 41569                                  ;			: AX 	= value of check sum
 41570                                  ;
 41571                                  ;	Output		: if patch & check sum compare
 41572                                  ;				NC
 41573                                  ;			  else
 41574                                  ;				CY
 41575                                  ;
 41576                                  ;	Uses		: AX, BX, CX, SI
 41577                                  ;
 41578                                  ;-------------------------------------------------------------------------
 41579                                  
 41580                                  	; 23/05/2019 - Retro DOS v4.0
 41581                                  chk_patchsum:
 41582 0000764B 57                      	push	di
 41583                                  
 41584 0000764C F3A6                    	repe	cmpsb			   
 41585                                  
 41586 0000764E 7518                    	jnz	short cp_fail		; Q: does the patch match
 41587                                  					; N: exit
 41588                                  					; Y:	
 41589                                  
 41590                                  		; we do a check sum starting from the location of the 
 41591                                  		; exepack signature 'RB' up to 11c/2 bytes, the end of the
 41592                                  		; unpacking code.
 41593                                  
 41594 00007650 368B3E[8700]            	mov	di,[ss:UNPACK_OFFSET]	; di -> start of unpack code
 41595 00007655 89D9                    	mov	cx,bx			; cx = length of check sum
 41596                                  
 41597 00007657 89C3                    	mov	bx,ax			; save check sum passed to us in bx
 41598 00007659 31C0                    	xor	ax,ax
 41599                                  ep_chksum:
 41600 0000765B 260305                  	add	ax,[es:di]
 41601 0000765E 83C702                  	add	di,2
 41602 00007661 E2F8                    	loop	ep_chksum
 41603                                  
 41604 00007663 5F                      	pop	di			; restore di
 41605                                  
 41606 00007664 39D8                    	cmp	ax,bx		 	; Q: does the check sum match
 41607                                  	;jne	short cp_fail		; N: exit
 41608                                  					; Y: 
 41609                                  	; 25/09/2023
 41610                                  	;clc	
 41611                                  	;retn
 41612 00007666 74E2                    	je	short ccs_done ; cf=0
 41613                                  	
 41614                                  cp_fail:
 41615 00007668 F9                      	stc
 41616 00007669 C3                      	retn
 41617                                  
 41618                                  ; 28/12/2022 - Retro DOS v4.1
 41619                                  %if 0
 41620                                  ;--------------------------------------------------------------------------- 
 41621                                  
 41622                                  
 41623                                  ; M020 : BEGIN
 41624                                  ;
 41625                                  ;---------------------------------------------------------------------------
 41626                                  ;
 41627                                  ; procedure : RationalPatch
 41628                                  ;
 41629                                  ; A routine (in Ration DOS extender) which is invoked at hardware interrupts
 41630                                  ; clobbers CX register on 286 machines. (123 release 3 uses Rational DOS
 41631                                  ; extender). This routine identifies Buggy Rational EXEs and fixes the bug.
 41632                                  ;
 41633                                  ; THE BUG is in the following code sequence:
 41634                                  ;
 41635                                  ;8b 0e 10 00	mov	cx, ds:[10h]		; delay count
 41636                                  ;90		even				; word align
 41637                                  ;e2 fe		loop	$			; wait		CLOBBERS CX
 41638                                  ;e8 xx xx	call	set_A20			; enable A20
 41639                                  ;
 41640                                  ; This patch routine replaces the mov & the loop with a far call into a
 41641                                  ; routine in DOS data segment which is in low memory (because A20 line
 41642                                  ; is off). The routine (RatBugCode) in DOS data saves & restores CX around
 41643                                  ; a mov & loop.
 41644                                  ;
 41645                                  ; Identification of Buggy Rational EXE
 41646                                  ; ====================================
 41647                                  ;
 41648                                  ; (ALL OFFSETS ARE IN THE PROGRAM SECTION - EXCLUDING THE EXE HEADER)
 41649                                  ;
 41650                                  ; OFFSET				Contains
 41651                                  ; ------				--------
 41652                                  ; 0000h			100 times Version number in binary
 41653                                  ;			bug exists in version 3.48 thru 3.83 (both inclusive)
 41654                                  ;
 41655                                  ; 000ah			the WORDS : 0000h, 0020h, 0000h, 0040h, 0001h
 41656                                  ;
 41657                                  ; 002ah			offset where version number is stored in ASCII
 41658                                  ;				e.g. '3.48A'
 41659                                  ;
 41660                                  ; 0030h			offset of copyright string. Copyright strings either
 41661                                  ;			start with "DOS/16M Copyright...." or
 41662                                  ;			"Copyright.....". The string contains
 41663                                  ;			"Rational Systems, Inc."
 41664                                  ;
 41665                                  ; 0020h			word : Paragraph offset of the buggy code segment
 41666                                  ;				from the program image
 41667                                  ; 0016h			word : size of buggy code segment
 41668                                  ;
 41669                                  ;	Buggy code is definite to start after offset 200h in its segment
 41670                                  ;
 41671                                  ;----------------------------------------------------------------------------
 41672                                  
 41673                                  ; 23/05/2019 - Retro DOS v4.0
 41674                                  ; DOSCODE:B976h (MSDOS 6.21, MSDOS.SYS)
 41675                                  
 41676                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41677                                  ; DOSCODE:B654h (MSDOS 5.0, MSDOS.SYS)
 41678                                  
 41679                                  RScanPattern1:
 41680                                  	db	0, 0, 20h, 0, 0, 0, 40h, 0, 1, 0
 41681                                  
 41682                                  RLen1 equ $ - RScanPattern1
 41683                                  
 41684                                  RScanPattern2:
 41685                                  	db	8Bh, 0Eh, 10h, 00h, 90h, 0E2h, 0FEh, 0E8h
 41686                                  
 41687                                  RLen2 equ $ - RScanPattern2
 41688                                  
 41689                                  RScanPattern3:
 41690                                  	db	8Bh, 0Eh, 10h, 00h, 0E2h, 0FEh, 0E8h
 41691                                  
 41692                                  RLen3 equ $ - RScanPattern2
 41693                                  
 41694                                  ; DOSCODE:B98Fh (MSDOS 6.21, MSDOS.SYS)
 41695                                  ; DOSCODE:B66Dh (MSDOS 5.0, MSDOS.SYS)
 41696                                  
 41697                                  ;----------------------------------------------------------------------------
 41698                                  ;
 41699                                  ; INPUT : ES = segment where program got loaded
 41700                                  ;
 41701                                  ;----------------------------------------------------------------------------
 41702                                  
 41703                                  RationalPatch:
 41704                                  	cld
 41705                                  	push	ax
 41706                                  	push	bx
 41707                                  	push	cx
 41708                                  	push	dx
 41709                                  	push	si
 41710                                  	push	di
 41711                                  	push	es
 41712                                  	push	ds			; we use all of them
 41713                                  	mov	di,0Ah			; look for pat1 at offset 0Ah
 41714                                  	push	cs
 41715                                  	pop	ds
 41716                                  	
 41717                                  	mov	si,RScanPattern1
 41718                                  	;mov	cx,10
 41719                                  	mov	cx,RLen1
 41720                                  	rep	cmpsb			; do we have the pattern ?
 41721                                  	jne	short rpexit
 41722                                  	mov	ax,[es:0]
 41723                                  	cmp	ax,348			; is it a buggy version ?
 41724                                  	jb	short rpexit
 41725                                  	cmp	ax,383			; is it a buggy version
 41726                                  	ja	short rpexit
 41727                                  
 41728                                  	call	VerifyVersion
 41729                                  	jne	short rpexit
 41730                                  
 41731                                  	mov	cx,[es:16h]		; Length of buggy code seg
 41732                                  	sub	cx,200h			; Length we search (we start
 41733                                  					;  at offset 200h)
 41734                                  	mov	es,[es:20h]		; es=buggy code segment
 41735                                  	mov	si,RScanPattern2
 41736                                  	;mov	dx,8	
 41737                                  	mov	dx,RLen2
 41738                                  	call	ScanCodeSeq		; look for code seq with nop
 41739                                  	jz	short rpfound
 41740                                  
 41741                                  	mov	si,RScanPattern3
 41742                                  	;mov	dx,15
 41743                                  	mov	dx,RLen3
 41744                                  	call	ScanCodeSeq		; look for code seq w/o nop
 41745                                  	jnz	short rpexit
 41746                                  
 41747                                  rpfound:
 41748                                  	
 41749                                  ;	we set up a far call into DOS data
 41750                                  ;	dx has the length of the code seq we were searching for
 41751                                  
 41752                                  	mov	al,9Ah			; far call opcode
 41753                                  	stosb
 41754                                  	mov	ax,RatBugCode
 41755                                  	stosw
 41756                                  	mov	ax,ss
 41757                                  	stosw
 41758                                  	mov	cx,dx
 41759                                  	sub	cx,6			; filler (with NOPs)
 41760                                  	mov	al,90h
 41761                                  	rep	stosb
 41762                                  rpexit:
 41763                                  	pop	ds
 41764                                  	pop	es
 41765                                  	pop	di
 41766                                  	pop	si
 41767                                  	pop	dx
 41768                                  	pop	cx
 41769                                  	pop	bx
 41770                                  	pop	ax
 41771                                  	retn
 41772                                  
 41773                                  ; M020 END
 41774                                  
 41775                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41776                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
 41777                                  
 41778                                  ; DOSCODE:B6D8h (MSDOS 5.0, MSDOS.SYS)
 41779                                  
 41780                                  ;----------------------------------------------------------------------------
 41781                                  ;
 41782                                  ; ScanCodeSeq
 41783                                  ;
 41784                                  ; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
 41785                                  ;
 41786                                  ; returns in ES:DI the start of the pattern if Zero flag is set
 41787                                  ;
 41788                                  ;----------------------------------------------------------------------------
 41789                                  
 41790                                  ScanCodeSeq:
 41791                                  	; 17/12/2022
 41792                                  	mov	di,200h
 41793                                  ;ScanCodeSeq_di:
 41794                                  	push	cx
 41795                                  	sub	cx,dx
 41796                                  	inc	cx
 41797                                  	; 17/12/2022
 41798                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41799                                  	;mov	di,200h
 41800                                  scsagain:
 41801                                  	push	si
 41802                                  	push	di
 41803                                  	push	cx
 41804                                  	mov	cx,dx
 41805                                  	rep	cmpsb
 41806                                  	pop	cx
 41807                                  	pop	di
 41808                                  	pop	si
 41809                                  	je	short scsfound
 41810                                  	inc	di
 41811                                  	loop	scsagain
 41812                                  scsfound:
 41813                                  	pop	cx
 41814                                  vvexit:		; 18/12/2022
 41815                                  	retn
 41816                                  
 41817                                  
 41818                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41819                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
 41820                                  
 41821                                  ; DOSCODE:B6F0h (MSDOS 5.0, MSDOS.SYS)
 41822                                  
 41823                                  ;----------------------------------------------------------------------------
 41824                                  ;
 41825                                  ; VerifyVersion
 41826                                  ;
 41827                                  ; Checks whether the binary version from ES:0 matches the ASCII version
 41828                                  ; from ES:2A.
 41829                                  ;
 41830                                  ;       Entry: AX = binary version number 
 41831                                  ;       Exit : Z flag set if version numbers match
 41832                                  ;
 41833                                  ;----------------------------------------------------------------------------
 41834                                  
 41835                                  VerifyVersion:
 41836                                  	mov	si,[es:2Ah]		; offset of version number
 41837                                  					;  in ascii
 41838                                  	mov	bl,10
 41839                                  	add	si,3			; point to last digit
 41840                                  
 41841                                  	call	VVDigit
 41842                                  	jne	short vvexit
 41843                                  	call	VVDigit
 41844                                  	jne	short vvexit
 41845                                  	cmp	byte [es:si],'.' ; 2Eh
 41846                                  	jne	short vvexit
 41847                                  	dec	si
 41848                                  	;call	VVDigit
 41849                                  	; 18/12/2022
 41850                                  	;jmp	short VVDigit
 41851                                  ;vvexit:
 41852                                  	;retn
 41853                                  VVDigit:
 41854                                  	div	bl
 41855                                  	add	ah,'0' ; 30h
 41856                                  	dec	si
 41857                                  	cmp	[es:si+1],ah
 41858                                  	mov	ah,0			; do not xor or sub we need Z
 41859                                  	retn
 41860                                  
 41861                                  ;--------------------------------------------------------------------------- 
 41862                                  %endif	; 28/12/2022
 41863                                  
 41864                                  ;---------------------------------------------------------------------------
 41865                                  ;
 41866                                  ;	M068
 41867                                  ;
 41868                                  ; 	Procedure Name	: IsCopyProt
 41869                                  ;
 41870                                  ;	Inputs		: DS:100 -> start of com file just read in
 41871                                  ;
 41872                                  ;	Outputs		: sets the A20OFF_COUNT variable to 10 if 
 41873                                  ;			  the program loaded in DS:100 uses a MICROSOFT
 41874                                  ;			  copy protect scheme that relies on the A20 line
 41875                                  ;			  being turned off for it's scheme to work.
 41876                                  ;
 41877                                  ;			  Note: The int 21 function dispatcher will turn 
 41878                                  ;				a20 off, if the A20OFF_COUNT is non-zero 
 41879                                  ;				and dec the A20OFF_COUNT before	iretting 
 41880                                  ;				to the user. 
 41881                                  ;
 41882                                  ;	Uses		: ES, DI, SI, CX
 41883                                  ;
 41884                                  ;---------------------------------------------------------------------------
 41885                                  
 41886                                  ; 23/05/2019 - Retro DOS v4.0
 41887                                  
 41888                                  CPStartOffset	EQU	0175h
 41889                                  CPID1Offset	EQU	011Bh
 41890                                  CPID2Offset	EQU	0173h
 41891                                  CPID3Offset	EQU	0146h
 41892                                  CPID4Offset	EQU	0124h
 41893                                  ID1		EQU	05343h
 41894                                  ID2		EQU	05044h
 41895                                  ID3		EQU	0F413h
 41896                                  ID4		EQU	08000h
 41897                                  
 41898                                  ; DOSCODE:B9FAh (MSDOS 6.21, MSDOS.SYS)
 41899                                  
 41900                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41901                                  ; DOSCODE:B71Ch (MSDOS 5.0, MSDOS.SYS)
 41902                                  
 41903                                  CPScanPattern:
 41904 0000766A 89264801                	db	89h,26h,48h,01h		 ; mov [148],sp
 41905 0000766E 8C0E4C01                	db	8Ch,0Eh,4Ch,01h		 ; mov [14C],cs
 41906 00007672 C7064A010001            	db	0C7h,06h,4Ah,01h,00h,01h ; mov [14A],100h 
 41907 00007678 8C0E1301                	db 	8Ch,0Eh,13h,01h		 ; mov [113],cs
 41908 0000767C B82001                  	db	0B8h,20h,01h		 ; mov ax,120h
 41909 0000767F BE0001                  	db	0BEh,00h,01h		 ; mov si,100h
 41910                                  
 41911                                  CPSPlen	EQU $ - CPScanPattern
 41912                                  
 41913                                  ; DOSCODE:BA12h (MSDOS 6.21, MSDOS.SYS)
 41914                                  ; DOSCODE:B734h (MSDOS 5.0, MSDOS.SYS)
 41915                                  
 41916                                  IsCopyProt:
 41917 00007682 813E1B014353            	cmp	word [CPID1Offset],ID1
 41918 00007688 752D                    	jne	short CP_done
 41919                                  
 41920 0000768A 813E73014450            	cmp	word [CPID2Offset],ID2
 41921 00007690 7525                    	jne	short CP_done
 41922                                  
 41923 00007692 813E460113F4            	cmp	word [CPID3Offset],ID3
 41924 00007698 751D                    	jne	short CP_done
 41925                                  
 41926 0000769A 813E24010080            	cmp	word [CPID4Offset],ID4
 41927 000076A0 7515                    	jne	short CP_done
 41928                                  
 41929 000076A2 0E                      	push	cs
 41930 000076A3 07                      	pop	es
 41931 000076A4 BF[6A76]                	mov	di,CPScanPattern	; es:di -> Pattern to find
 41932                                  
 41933 000076A7 BE7501                  	mov	si,CPStartOffset	; ds:si -> possible location 
 41934                                  					; of pattern
 41935                                  
 41936 000076AA B91800                  	mov	cx,CPSPlen ; 24		; cx = length of pattern
 41937 000076AD F3A6                    	repe	cmpsb
 41938 000076AF 7506                    	jnz	short CP_done
 41939                                  
 41940 000076B1 36C606[8500]0A          	mov	byte [ss:A20OFF_COUNT],0Ah ; M071
 41941                                  CP_done:
 41942 000076B7 C3                      	retn
 41943                                  	
 41944                                  ;DOSCODE ENDS
 41945                                  
 41946                                  	;END
 41947                                  
 41948                                  ;----------------------------------------------------------------------------
 41949                                  
 41950                                  ;align 2 ; 05/09/2018 (Error!)
 41951                                  
 41952                                  ; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41953                                  ;align 16 ; 08/09/2018 (OK.)
 41954                                  align 2
 41955                                  
 41956                                  ; 06/08/2018 - Retro DOS v3.0
 41957                                  ;============================================================================
 41958                                  ; MSINIT.ASM
 41959                                  ;============================================================================
 41960                                  ; 22/04/2019 - Retro DOS v4.0 (MSINIT.ASM, MSDOS 6.0, 1991)
 41961                                  ;
 41962                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 41963                                  ;
 41964                                  	; 15/07/2018 - Retro DOS v3.0
 41965                                  	; (MSDOS 3.3, IBMDOS.COM, 1987)
 41966                                  
 41967                                  ; temp iret instruction
 41968                                  
 41969                                  
 41970                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41971                                  ; DOSCODE:B76Ah (MSDOS 5.0, MSDOS.SYS)
 41972                                  
 41973                                  initiret: ; MSDOS 6.0
 41974                                  SYSBUF:
 41975                                  ;IRETT: ; 06/05/2019
 41976 000076B8 CF                      	iret
 41977                                  
 41978                                  ; 22/04/2019 - Retro DOS v4.0
 41979                                  
 41980                                  ; pointer to the BIOS data segment that will be available just to the
 41981                                  ; initialization code
 41982                                  
 41983 000076B9 7000                    InitBioDataSeg:	dw 70h ; KERNEL_SEGMENT = 0070h
 41984                                  
 41985                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41986                                  ; DOSCODE:B76Dh (MSDOS 5.0, MSDOS.SYS)
 41987                                  
 41988                                  ; Convert AX from a number of bytes to a number of paragraphs (round up).
 41989                                  
 41990                                  ParaRound:
 41991 000076BB 83C00F                  	add	ax, 15
 41992 000076BE D1D8                    	rcr	ax, 1
 41993 000076C0 D1E8                    	shr	ax, 1
 41994 000076C2 D1E8                    	shr	ax, 1
 41995 000076C4 D1E8                    	shr	ax, 1
 41996 000076C6 C3                      	retn
 41997                                  
 41998                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 41999                                  
 42000                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42001                                  	; DOSCODE:B779h (MSDOS 5.0, MSDOS.SYS)
 42002                                  	
 42003                                  	; 30/05/2019
 42004                                  	; 22/04/2019 - Retro DOS v4.0
 42005                                  	; 07/07/2018 - Retro DOS v3.0
 42006                                  	; Retro DOS v2.0 - 03/03/2018
 42007                                  	; 03/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42008                                  	; MSDOS 5.0 - MSDOS.SYS, offset 79A9h
 42009                                  DOSINIT:
 42010                                  	; MSDOS 6.21 - MSDOS.SYS, offset 7C77h
 42011                                  	;
 42012                                  	; Far call from SYSINIT
 42013                                  	; DX = Memory size in paragraphs
 42014                                  	; DS:SI = [DEVICE_LIST] (SYSINIT.S) 
 42015                                  	;	  (Retro DOS v2.0, 16/03/2018)
 42016                                  	;
 42017                                  	; ES:DI = ptr to BIOS communication block (sysinit3.s)
 42018                                  	;	  (Retro DOS v4.0, 20/04/2019)
 42019                                  
 42020 000076C7 FA                              CLI
 42021 000076C8 FC                              CLD
 42022                                  
 42023                                  	; 03/11/2022
 42024                                  	;push	dx ; 30/05/2019		; save parameters from BIOS
 42025                                  	
 42026                                  	; 17/12/2022
 42027                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42028                                  	;push	dx ; =*=		; save parameters from BIOS
 42029                                  	
 42030 000076C9 56                      	push	si
 42031 000076CA 1E                      	push	ds
 42032 000076CB 57                      	push	di			;save di (ptr to BiosComBlock)
 42033                                  
 42034 000076CC 8CC3                    	mov	bx,es			;bx:di = ptr to BiosComBlock
 42035                                  
 42036                                  ; First, move the DOS data segment to its final location in low memory
 42037                                  
 42038                                  	;;mov	ax,0BF69h ; MSDOS 6.21 MSDOS.SYS, file offset 7C7Fh
 42039                                  	;mov	ax,0BC77h ; MSDOS 5.0 MSDOS.SYS, file offset 79B1h	
 42040 000076CE B8[487B]                	mov	ax,MEMSTRT		; get offset of end of init code
 42041                                  
 42042                                  	;add	ax,15	; 0Fh		; round to nearest paragraph
 42043                                  	;and	ax,~15	; 0FFF0h	; boundary
 42044                                  
 42045                                  	;mov	si,ax			; si = offset of DOSDATA in current 
 42046                                  					; code segment
 42047                                  
 42048                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42049 000076D1 83C00F                  	add	ax,15			; round to nearest paragraph
 42050 000076D4 83E0F0                  	and	ax,~15			; boundary
 42051                                  
 42052 000076D7 89C6                    	mov	si,ax			; si = offset of DOSDATA in current 
 42053                                  					; code segment
 42054                                  	; 05/12/2022
 42055                                  	; 30/04/2019 - Retro DOS v4.0
 42056                                  	;xor	si,si
 42057                                  	
 42058 000076D9 8CC8                    	mov	ax,cs
 42059 000076DB 8ED8                    	mov	ds,ax			; ds = current code segment
 42060                                  					; DS:SI now points to dosdata
 42061                                  
 42062                                  	;mov	es,[cs:0BA49h] ; MSDOS 6.21 IO.SYS, offset 7C8Eh 
 42063                                  	;mov	es,[cs:InitBioDataSeg]	; First access to DosDataSg in
 42064                                  					;  BData segment. Cannot use
 42065                                  					;  getdseg macro here!!!
 42066                                  	; 17/12/2022
 42067 000076DD 8E06[B976]              	mov	es,[InitBioDataSeg]
 42068                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42069                                  	;mov	es,[cs:InitBioDataSeg]  ; ds = cs !
 42070                                  
 42071                                  	;mov	es,[es:3]
 42072 000076E1 268E060300              	mov	es,[es:DosDataSg]	; Get free location in low memory
 42073                                  
 42074 000076E6 31FF                    	xor	di,di			; ES:DI now points to RAM data
 42075                                  
 42076                                  	;mov	cx,4970  ; Offset 0BA78h in MSDOS 6.21 MSDOS.SYS)
 42077                                  	;mov	cx,4976  ; 25/05/2019
 42078                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42079                                  	;mov	cx,4962
 42080                                  	;mov	cx,MSDAT001E		; get end of dosdata = size of dosdata
 42081 000076E8 B9A512                  	mov	cx,DOSDATASIZE ; = 4962 for MSDOS 5.0 MSDOS.SYS
 42082 000076EB F3A4                    	rep	movsb			; move data to final location
 42083                                  	
 42084 000076ED 5F                      	pop	di			; restore ptr to BiosComBlock
 42085 000076EE 1F                      	pop	ds			; restore parms from BIOS
 42086 000076EF 5E                      	pop	si
 42087                                  	; 17/12/2022
 42088                                  	;pop	dx ; 30/05/2019	
 42089                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42090                                  	;pop	dx ; =*=		
 42091                                  
 42092 000076F0 06                      	push	es
 42093 000076F1 1E                      	push	ds
 42094 000076F2 07                      	pop	es			; es:si -> device chain
 42095 000076F3 1F                      	pop	ds			; ds points to dosdata
 42096                                  
 42097                                  ;SR;
 42098                                  ;We get a ptr to the BIOS exchange data block. This has been setup right 
 42099                                  ;now so that the EXEC call knows when SysInit is present to do the special
 42100                                  ;lie table handling for device drivers. This can be expanded later on to
 42101                                  ;establish a communication block from the BIOS to the DOS.
 42102                                  
 42103                                  	;mov	[1040h],di	; Offset 0BA87h in MSDOS 6.21 MSDOS.SYS)
 42104                                  	;mov	[1042h],bx
 42105 000076F4 893E[4010]              	mov	[BiosDataPtr],di
 42106 000076F8 891E[4210]              	mov	[BiosDataPtr+2],bx	; save ptr to BiosComBlock
 42107                                  
 42108 000076FC 2E8C1E[0700]            	mov	[cs:DosDSeg],ds		; set pointer to dosdata in code seg
 42109                                  
 42110                                  	; Set the segment of Lowint23/24/28Addr in msctrlc.asm to dosdata
 42111                                  
 42112 00007701 2E8C1E[B150]            	mov	[cs:LowInt23Addr+2],ds	; set pointers in code seg
 42113 00007706 2E8C1E[B550]            	mov	[cs:LowInt24Addr+2],ds
 42114 0000770B 2E8C1E[B950]            	mov	[cs:LowInt28Addr+2],ds
 42115                                  
 42116                                  	;mov	[346h],dx	; MSDOS 6.21 DOSDATA addresses
 42117                                  	;mov	[584h],sp
 42118                                  	;mov	[586h],ss
 42119 00007710 8916[4603]                  	mov	[ENDMEM],dx	; =*=
 42120 00007714 8926[8405]              	mov	[USER_SP],sp
 42121 00007718 8C16[8605]              	mov	[USER_SS],ss
 42122                                  
 42123 0000771C 8CD8                    	mov	ax,ds		; set up ss:sp to dosdata:dskstack
 42124 0000771E 8ED0                    	mov	ss,ax
 42125                                  
 42126                                  	;mov	sp,920h		; MSDOS 6.21 DOSDATA address
 42127                                  	;mov	sp,offset dosdata:dskstack
 42128 00007720 BC[2009]                	mov	sp,DSKSTACK
 42129                                  
 42130                                  ;M023
 42131                                  ; Init patch ptrs to default values
 42132                                  
 42133                                  	;mov	word [1212h],RetExePatch
 42134                                  	;mov	word [1214h],RetExePatch
 42135                                  	;mov	word [61h],RetExePatch
 42136 00007723 C706[F311][2362]        	mov	word [FixExePatch],RetExePatch	; M023
 42137                                  	; 28/12/2022 - Retro DOS v4.1
 42138                                  	;mov	word [RationalPatchPtr],RetExePatch ; M023
 42139 00007729 C706[6100][2362]        	mov	word [ChkCopyProt],RetExePatch	; M068
 42140                                  
 42141                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42142                                  %if 0	; 19/09/2023
 42143                                  
 42144                                  ; Setup to call 386 Rational DOS Extender patch routine if running on
 42145                                  ; a 386 or later. Unlike other patches, this is not dependent on MS-DOS
 42146                                  ; running in the HMA.
 42147                                  
 42148                                  	call	WhatCPUType	; get cpu type (0 < 286,1==286,2 >= 386)
 42149                                  	cmp	al,2		;   386 or later?
 42150                                  	mov	ax,Rational386Patch
 42151                                  	jae	short di_set_patch
 42152                                  	mov	ax,RetExePatch	; < 386, don't need this patch
 42153                                  di_set_patch:
 42154                                  	mov	[Rational386PatchPtr],ax ; patch routine or RET instr.
 42155                                  
 42156                                  %endif
 42157                                  	; Set up the variable temp_dosloc to point to the dos code segment
 42158                                  
 42159 0000772F 8CC8                    	mov	ax,cs		; ax = current segment of DOS code
 42160                                  
 42161                                  	; ax now holds segment of DOS code
 42162 00007731 A3[AA0A]                	mov	[TEMP_DOSLOC],ax   ; store temp location of DOS
 42163                                  
 42164 00007734 8C06[4A00]              	mov	word [NULDEV+2],es ; nuldev -> points to device chain
 42165 00007738 8936[4800]              	mov	word [NULDEV],si
 42166                                  ;SR;
 42167                                  ; There are some locations in the Win386 instance data structures
 42168                                  ; which need to be set up with the DOS data segment. First, initialize
 42169                                  ; the segment part of the instance table pointer in the SIS.
 42170                                  
 42171                                  	;mov	[0FF2h],ds ; [Win386_Info+14+2]	
 42172 0000773C 8C1E[F20F]              	mov	[Win386_Info+Win386_SIS.Instance_Data_Ptr+2],ds
 42173                                  
 42174                                  ; Now initialize the segment part of the pointer to the data in each
 42175                                  ; instance table entry.
 42176                                  
 42177 00007740 56                      	push	si		; preserve pointer to device chain
 42178                                  	; 18/12/2022
 42179                                  	; cx = 0
 42180 00007741 B107                    	mov	cl,7
 42181                                  	;mov	cx,7		; There are 7 entries in the instance table
 42182                                  				; M019
 42183                                  	;mov	si,0FF6h ; offset (dosdata:Instance_Table+2)
 42184 00007743 BE[F60F]                	mov	si,Instance_Table+2 ; point si to segment field
 42185                                  Instance_init_loop:
 42186 00007746 8C1C                    	mov	[si],ds		; set offset in instance entry
 42187                                  	;add	si,6
 42188 00007748 83C606                  	add	si,size_of_Win386_IIS ; move on to next entry
 42189 0000774B E2F9                    	loop	Instance_init_loop
 42190                                  
 42191                                  ;Initialize the WIN386 2.xx instance table with the DOS data segment value
 42192                                  
 42193                                  	; 18/12/2022
 42194 0000774D B105                    	mov	cl,5
 42195                                  	;mov	cx,5		; There are five entries in the instance table
 42196                                  
 42197                                  	;mov	si,(offset dosdata:OldInstanceJunk) + 6
 42198                                  	;mov	si,11EDh	; point si to segment field
 42199 0000774F BE[CE11]                	mov	si,OldInstanceJunk+6
 42200                                  OldInstance_init_loop:
 42201 00007752 8C1C                    	mov	[si],ds		; set offset in instance entry
 42202 00007754 83C606                  	add	si,6		; move on to next entry
 42203 00007757 E2F9                    	loop	OldInstance_init_loop
 42204 00007759 5E                      	pop	si		; restore pointer to device chain
 42205                                  
 42206                                  ; End of WIN386 2.xx compatibility bullshit
 42207                                  
 42208                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42209                                  %if 0	
 42210                                     	; 30/04/2019
 42211                                  	;push	es
 42212                                  	;pop	ds
 42213                                  			; ds:si points to console device
 42214                                  
 42215                                  	; 24/04/2019 - Retro DOS v4.0
 42216                                  
 42217                                  	; 15/07/2018
 42218                                  	; MSDOS 3.3 (IBMDOS.COM, 1987)
 42219                                  	; (Set INT 2Ah handler address to an 'IRET')
 42220                                  
 42221                                  	; need crit vector inited to use deviocall
 42222                                  	;push	ds			; preserve segment of device chain
 42223                                  	push	es ; 30/04/2019
 42224                                  
 42225                                  %endif
 42226                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42227 0000775A 06                      	push	es
 42228                                  	; 17/12/2022
 42229                                  	;pop	ds
 42230                                  	;push	ds
 42231                                  
 42232 0000775B 31C0                    	xor	ax,ax
 42233 0000775D 8ED8                    	mov	ds,ax			; point DS to int vector table
 42234 0000775F B8[B876]                	mov	ax,initiret
 42235                                  	;mov	[0A8h],ax  ; [2Ah*4]
 42236 00007762 A3A800                  	mov	[addr_int_ibm],ax
 42237 00007765 8CC8                    	mov	ax,cs
 42238                                  	;mov	[0AAh],ax  ; [(2Ah*4)+2] 		
 42239 00007767 A3AA00                  	mov	[addr_int_ibm+2],ax
 42240 0000776A 1F                      	pop	ds			; restore segment of device chain
 42241                                  
 42242 0000776B E81C02                  	call	CHARINIT  		; initialize console driver
 42243 0000776E 56                      	push	si			; save pointer to header
 42244                                  
 42245 0000776F 16                      	push	ss			; move pointer to dos data...
 42246 00007770 07                      	pop	es			; ...into ES
 42247                                  
 42248                                  	;initialize sft for file 0 (CON)
 42249                                  
 42250                                          ; 07/07/2018 - Retro DOS v3.0
 42251                                  	; 24/04/2019 - Retro DOS v4.0
 42252                                  	;mov	di,SFTABL+6 
 42253 00007771 BF[D200]                	MOV     DI,SFTABL+SFT.SFTable	; Point to sft 0
 42254 00007774 B80300                          MOV     AX,3
 42255 00007777 AB                              STOSW           	; Refcount
 42256 00007778 FEC8                            DEC     AL
 42257 0000777A AB                              STOSW           	; Access rd/wr, compatibility
 42258 0000777B 30C0                            XOR     AL,AL
 42259 0000777D AA                              STOSB           	; attribute
 42260                                  	;mov	al,0C3h
 42261 0000777E B0C3                    	mov	al,devid_device_EOF|devid_device|ISCIN|ISCOUT
 42262 00007780 AB                      	STOSW			; flags
 42263 00007781 89F0                            mov	ax,si
 42264 00007783 AB                              stosw			; device pointer in devptr	
 42265 00007784 8CD8                            mov	ax,ds
 42266 00007786 AB                      	stosw
 42267 00007787 31C0                    	xor	ax,ax	; 0
 42268 00007789 AB                      	stosw			; firclus
 42269 0000778A AB                      	stosw			; time
 42270 0000778B AB                      	stosw			; date
 42271 0000778C 48                      	dec	ax	; -1
 42272 0000778D AB                      	stosw			; size
 42273 0000778E AB                      	stosw
 42274 0000778F 40                      	inc	ax	; 0
 42275 00007790 AB                      	stosw			; position
 42276 00007791 AB                      	stosw
 42277                                  	;add	di,7
 42278 00007792 83C707                  	add	di,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 42279                                  				; point at name
 42280                                  	;add	si,10
 42281 00007795 83C60A                  	add	si,SYSDEV.NAME	; sdevname
 42282                                  				; point to name
 42283 00007798 B90400                  	mov	cx,4
 42284 0000779B F3A5                    	rep	movsw		; name
 42285 0000779D B103                    	mov	cl,3
 42286 0000779F B020                    	mov	al," "
 42287 000077A1 F3AA                    	rep	stosb		; extension
 42288                                  
 42289 000077A3 5E                      	pop	si		; get back pointer to header
 42290                                  
 42291                                  				; mark device as CON I/O
 42292                                  	; 15/07/2018
 42293                                          ;OR	BYTE [SI+4],ISCIN|ISCOUT ; or byte [si+4],3
 42294 000077A4 804C0403                	OR	BYTE [SI+SYSDEV.ATT],ISCIN|ISCOUT
 42295                                  	; 12/03/2018
 42296                                  	;mov	[ss:32h],si
 42297 000077A8 368936[3200]            	MOV     [SS:BCON],SI
 42298                                  	;mov	[ss:34h],ds
 42299 000077AD 368C1E[3400]                    MOV     [SS:BCON+2],DS
 42300                                  
 42301                                  	; initialize each device until the clock device is found
 42302                                  
 42303                                  CHAR_INIT_LOOP:
 42304 000077B2 C534                            LDS     SI,[SI]			; AUX device
 42305 000077B4 E8D301                  	call	CHARINIT 
 42306                                         	;15/07/2018
 42307                                  	;test	byte [SI+4],8
 42308 000077B7 F6440408                	TEST    BYTE [SI+SYSDEV.ATT],ISCLOCK
 42309 000077BB 74F5                            JZ      SHORT CHAR_INIT_LOOP
 42310                                  	; 12/03/2018
 42311                                  	;mov	[ss:2Eh],si
 42312 000077BD 368936[2E00]                    MOV     [SS:BCLOCK],SI
 42313                                  	;mov	[ss:30h],ds
 42314 000077C2 368C1E[3000]                    MOV     [SS:BCLOCK+2],DS
 42315                                          ;MOV	BP,MEMSTRT ; Retro DOS 3.0 ; ES:BP points to DPB
 42316                                  
 42317                                  	;mov	bp,4970			; bp = pointer to free mem
 42318                                  	;mov	bp,4976  ; 25/05/2019 - Retro DOS v4.0
 42319                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
 42320                                  	;mov	bp,4962 ; (MSDOS 5.0 MSDOS.SYS)
 42321 000077C7 BDA512                  	mov	bp,MSDAT001E		; es:bp points to dpb area
 42322                                  
 42323 000077CA 36892E[2600]            	mov	[ss:DPBHEAD],bp		; set offset of pointer to DPB's
 42324 000077CF 368C06[2800]            	mov	[ss:DPBHEAD+2],es	; set segment of pointer to DPB's
 42325                                  PERDRV:
 42326                                  	;lds	si,[SI+SYSDEV.NEXT] ; 15/07/2018
 42327 000077D4 C534                            LDS	SI,[SI]			; Next device
 42328 000077D6 83FEFF                          CMP	SI,-1	; 0FFFFh
 42329 000077D9 7479                    	JZ	SHORT CONTINIT
 42330                                  
 42331 000077DB E8AC01                          call	CHARINIT
 42332                                  
 42333                                  	; Retro DOS v2.0 - 16/03/2018 (NOTE for 'CHARINIT' return):
 42334                                  	; [CALLUNIT] = Number of drives for (Disk) Block Dev Driver ([DRVMAX])
 42335                                  	;           (..When the command is 'DSK$INIT', as in 'CHARINIT')
 42336                                  	; [CALLBPB] = [DEVCALL.COUNT] = Address of the BPB (DEVCALL offset 18) 
 42337                                  	; (REF: MSDOS 3.3 MSBIO2.ASM, MSDATA.INC, MSDISK.ASM, MSBIO1.ASM)
 42338                                  	; (.. !DSK$IN' in MSBIO1.ASM)
 42339                                  	; DEVCALL.MEDIA = CALLUNIT (DEVCALL offset 13)
 42340                                  
 42341                                          ; 15/07/2018
 42342                                  	;test	word [SI+4],8000h		; DEVTYP
 42343                                          ; 17/12/2022
 42344                                  	;test	byte [SI+5],80h
 42345 000077DE F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8) ; 80h
 42346                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP ; 8000h
 42347 000077E2 75F0                    	JNZ     SHORT PERDRV			; Skip any other character devs
 42348                                  
 42349 000077E4 368A0E[6703]                    MOV	CL,[SS:CALLUNIT] ; 12/03/2018
 42350 000077E9 30ED                    	XOR     CH,CH
 42351                                          ; 07/07/2018
 42352                                  	;MOV	[SI+10],CL		; Number of units in name field
 42353 000077EB 884C0A                  	mov	[si+SYSDEV.NAME],cl	; sdevname        
 42354 000077EE 368A16[4600]            	MOV     DL,[SS:NUMIO]	; 15/03/2018
 42355 000077F3 30F6                    	XOR     DH,DH
 42356 000077F5 36000E[4600]            	ADD	[SS:NUMIO],CL	; 12/03/2018
 42357 000077FA 1E                      	PUSH    DS
 42358 000077FB 56                              PUSH    SI
 42359 000077FC 36C51E[6C03]            	LDS	BX,[SS:CALLBPB]	; 12/03/2018
 42360                                  
 42361                                  PERUNIT:
 42362 00007801 8B37                            MOV     SI,[BX]                 ; DS:SI Points to BPB
 42363 00007803 43                              INC     BX
 42364 00007804 43                              INC     BX                      ; On to next BPB
 42365                                  	; 15/12/2022
 42366                                  	; 07/07/2018
 42367                                          ;mov	[ES:BP+DPB.DRIVE],DL
 42368 00007805 26885600                	MOV     [ES:BP],DL
 42369                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42370                                  	;;mov	[ES:BP+0],DL
 42371                                  	;mov	[ES:BP+DPB.DRIVE],DL
 42372                                  
 42373                                  	;MOV	[ES:BP+1],DH
 42374 00007809 26887601                	MOV	[ES:BP+DPB.UNIT],DH
 42375 0000780D 53                              PUSH    BX
 42376 0000780E 51                              PUSH    CX
 42377 0000780F 52                              PUSH    DX
 42378                                  
 42379                                          ;invoke	$SETDPB
 42380 00007810 E8BD97                          CALL	_$SETDPB		; build DPB!
 42381                                  
 42382                                  	; 07/07/2018
 42383                                  	;MOV	AX,[ES:BP+2]
 42384 00007813 268B4602                	mov	ax,[ES:BP+DPB.SECTOR_SIZE]
 42385                                          ; 12/03/2018
 42386 00007817 363B06[3600]            	CMP	AX,[SS:MAXSEC]		; Q:is this the largest sector so far
 42387 0000781C 7604                    	JBE     SHORT NOTMAX		; N:
 42388 0000781E 36A3[3600]              	MOV	[SS:MAXSEC],AX		; Y: save it in maxsec
 42389                                  NOTMAX:					
 42390                                  	; set the next dpb field in the currently built bpb
 42391                                  	; and mark as never accessed
 42392                                          
 42393                                  	; 24/04/2019
 42394 00007822 89E8                    	mov	ax,bp			; get pointer to DPB
 42395                                  	;add	ax,33
 42396 00007824 83C021                  	add	ax,DPBSIZ		; advance pointer to next DPB
 42397                                  					; set seg & offset of next DPB
 42398                                  	;mov	[es:bp+25],ax
 42399 00007827 26894619                	mov	[es:bp+DPB.NEXT_DPB],ax
 42400                                  	;mov	[es:bp+27],es
 42401 0000782B 268C461B                	mov	[es:bp+DPB.NEXT_DPB+2],es
 42402                                  					; mark as never accessed
 42403                                  	;mov	byte [es:bp+24],0FFh
 42404 0000782F 26C64618FF              	mov	byte [es:bp+DPB.FIRST_ACCESS],-1
 42405                                  
 42406 00007834 5A                      	POP     DX
 42407 00007835 59                              POP     CX
 42408 00007836 5B                              POP     BX
 42409 00007837 8CD8                            MOV     AX,DS                   ; save segment of bpb array
 42410 00007839 5E                              POP     SI
 42411 0000783A 1F                              POP     DS
 42412                                  					; ds:si -> device header
 42413                                  					; store it in the corresponding dpb
 42414                                  	; 07/07/2018
 42415                                          ;MOV	[ES:BP+19],SI ; 24/04/2019
 42416 0000783B 26897613                	mov	[ES:BP+DPB.DRIVER_ADDR],si
 42417                                          ;MOV	[ES:BP+21],DS ; 24/04/2019
 42418 0000783F 268C5E15                	mov	[ES:BP+DPB.DRIVER_ADDR+2],ds
 42419                                  
 42420 00007843 1E                              PUSH    DS			; save pointer to device header
 42421 00007844 56                              PUSH    SI
 42422 00007845 FEC6                            INC     DH			; inc unit #
 42423 00007847 FEC2                            INC     DL			; inc drive #
 42424 00007849 8ED8                            MOV     DS,AX			; restore segment of BPB array
 42425                                          ;add	bp,33 ; 24/04/2019
 42426 0000784B 83C521                  	ADD     BP,DPBSIZ		; advance pointer to next dpb
 42427 0000784E E2B1                    	LOOP    PERUNIT			; process all units in each driver
 42428                                          
 42429 00007850 5E                      	POP     SI			; restore pointer to device header
 42430 00007851 1F                              POP     DS
 42431 00007852 EB80                    	JMP	PERDRV			; process all drivers in chain
 42432                                  
 42433                                  CONTINIT:
 42434                                  	; 24/04/2019
 42435                                  	;sub	bp,33			; set link in last DPB to -1
 42436 00007854 83ED21                  	sub	bp,DPBSIZ		; back up to last dpb
 42437                                  					; set last link offset & segment
 42438                                  	;mov	word [bp+25],0FFFFh
 42439 00007857 C74619FFFF              	mov	word [bp+DPB.NEXT_DPB],-1
 42440                                  	;mov	word [bp+27],0FFFFh
 42441 0000785C C7461BFFFF              	mov	word [bp+DPB.NEXT_DPB+2],-1
 42442                                  	;add	bp,33
 42443 00007861 83C521                  	add	BP,DPBSIZ		; advance to free memory again
 42444                                  					; the DPB chain is done.  
 42445 00007864 16                      	push	ss
 42446 00007865 1F                      	pop	ds
 42447                                  
 42448 00007866 89E8                    	mov	ax,bp
 42449 00007868 E850FE                  	call	ParaRound		; round up to segment
 42450                                  
 42451 0000786B 8CDA                    	mov	dx,ds			; dx = dosdata segment
 42452 0000786D 01C2                    	add	dx,ax			; dx = ds+ax first free segment
 42453                                  
 42454 0000786F BB0F00                  	mov	bx,0Fh
 42455                                  	
 42456                                  	; 24/05/2019
 42457                                  	;mov	cx,[ENDMEM]
 42458                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42459                                  	; 17/12/2022
 42460                                  	;mov	cx,[ENDMEM] 
 42461                                  					; set seg inpacketto dosdata					
 42462 00007872 8C1E[A203]              	mov	[DSKCHRET+3],ds ; mov [DOSSEG_INIT],ds 
 42463                                  
 42464                                  ; Patch in the segments of the interrupt vectors with current code segment.
 42465                                  ; Also patch in the segment of the pointers in the dosdata area.
 42466                                  ;
 42467                                  ; Note: Formerly, temp_dosloc was initialized to -1 until after these
 42468                                  ; calls were done. The procedure patch_misc_segments is called multiple
 42469                                  ; times, and relies on temp_dosloc being initialized to -1 as a flag
 42470                                  ; for the first invocation. Thus, we must set it to -1 for this call.
 42471                                  
 42472 00007876 52                      	push	dx			; preserve first free segment
 42473                                  
 42474 00007877 A1[AA0A]                	mov	ax,[TEMP_DOSLOC]	; ax = segment to patch in 
 42475 0000787A 8EC0                    	mov	es,ax			; es = segment of DOS
 42476 0000787C C706[AA0A]FFFF          	mov	word [TEMP_DOSLOC],-1	; -1 means first call to patch_misc_segments
 42477                                  
 42478 00007882 E8AF01                  	call	patch_vec_segments	; uses AX as doscode segment
 42479 00007885 E8E401                  	call	patch_misc_segments	; patch in segments for sharer and 
 42480                                  					; other tables with seg in ES.
 42481                                  	; 17/12/2022
 42482                                  	; cx = 0
 42483 00007888 8C06[AA0A]              	mov	[TEMP_DOSLOC],es	; put back segment of dos code
 42484                                  
 42485 0000788C 5A                      	pop	dx			; restore first free segment
 42486                                  
 42487                                  ; We shall now proceed to set the offsets of the interrupt vectors handled
 42488                                  ; by DOS to their appropriate values in DOSCODE. In case the DOS loads in
 42489                                  ; HIMEM the offsets also will be patched to their appropriate values in the
 42490                                  ; low_mem_stub by seg_reinit.
 42491                                  
 42492                                  	;xor	ax,ax ; 0
 42493                                  	;mov	ds,ax
 42494                                  	;mov	es,ax
 42495                                  	; 17/12/2022
 42496                                  	; cx = 0
 42497                                  	;xor	cx,cx ; 0
 42498 0000788D 8ED9                    	mov	ds,cx
 42499 0000788F 8EC1                    	mov	es,cx
 42500                                  
 42501                                  	; set the segment of int 24 vector that was 
 42502                                  	; left out by patch_vec_segments above.
 42503                                  
 42504                                  	; 17/12/2022
 42505                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42506                                  ;%if 0
 42507                                  	; 24/05/2019
 42508                                  	;;mov	di,90h
 42509                                  	;;mov	di,4*int_fatal_abort
 42510                                  	;mov	di,addr_int_fatal_abort
 42511 00007891 BF9200                  	mov	di,addr_int_fatal_abort+2 ; 24/05/2019
 42512                                  
 42513 00007894 36A1[AA0A]              	mov	ax,[ss:TEMP_DOSLOC]
 42514                                  	;mov	[di+2],ax  ; int 24h segment
 42515 00007898 8905                    	mov	[di],ax ; 24/05/2019
 42516                                  
 42517                                  	;;mov	di,82h
 42518                                  	;mov	di,INTBASE+2
 42519                                  
 42520                                  ;%endif
 42521                                  	; 17/12/2022
 42522                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42523                                  	;;mov	di,90h
 42524                                  	;;mov	di,4*int_fatal_abort
 42525                                  	;mov	di,addr_int_fatal_abort
 42526                                  	;mov	ax,[ss:TEMP_DOSLOC]
 42527                                  	;mov	[di+2],ax  ; int 24h segment
 42528                                  	;;mov	di,82h
 42529                                  	;mov	di,INTBASE+2
 42530                                  
 42531                                  	; set default divide trap offset
 42532                                  
 42533                                  	;mov	word ptr ds:[0],offset doscode:divov
 42534 0000789A C7060000[8C52]          	mov	word [0],DIVOV	
 42535                                  
 42536                                  	; set vectors 20-28 and 2a-3f to point to iret.
 42537                                  
 42538                                  	;mov	di,80h
 42539 000078A0 BF8000                  	mov	di,INTBASE
 42540                                  	;mov	ax,offset doscode:irett
 42541 000078A3 B8[E202]                	mov	ax,IRETT
 42542                                  
 42543                                  	; 17/12/2022
 42544                                  	; cx = 0
 42545 000078A6 B109                    	mov	cl,9
 42546                                  	;mov	cx,9			; set 9 offsets (skip 2 between each)
 42547                                  					;   sets offsets for ints 20h-28h
 42548                                  iset1:
 42549 000078A8 AB                      	stosw
 42550                                  	;add	di,2
 42551                                  	; 20/09/2023
 42552 000078A9 47                      	inc	di
 42553 000078AA 47                      	inc	di
 42554 000078AB E2FB                    	loop	iset1
 42555                                  
 42556 000078AD 83C704                  	add	di,4			; skip vector 29h
 42557                                  
 42558                                  ;	mov	cx,6			; set 6 offsets (skip 2 between each)
 42559                                  ;					;   sets offsets for ints 2ah-2fh
 42560                                  ;iset2:
 42561                                  ;	stosw
 42562                                  ;	add	di,2
 42563                                  ;	loop	iset2
 42564                                  
 42565                                  ; 30h & 31H is the CPM call entry point whose segment address is set up by
 42566                                  ; patch_vec_segments above. So skip it.
 42567                                  
 42568                                  ;	add	di,8			; skip vector 30h & 31h 
 42569                                  
 42570                                  	;;;
 42571                                  	; 06/05/2019 - Retro DOS v4.0
 42572                                  	;mov	cx,5			; set offsets for int 2Ah-2Eh
 42573                                  	; 17/12/2022
 42574 000078B0 B105                    	mov	cl,5 ; 28/06/2019
 42575                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42576                                  	;mov	cx,6
 42577                                  iset2:
 42578 000078B2 AB                      	stosw
 42579                                  	;add	di,2
 42580                                  	; 20/09/2023
 42581 000078B3 47                      	inc	di
 42582 000078B4 47                      	inc	di
 42583 000078B5 E2FB                    	loop	iset2
 42584                                  
 42585                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42586                                  	; 17/12/2022
 42587 000078B7 83C70C                  	add	di,12			; skip vectors 2Fh, 30h & 31h
 42588                                  	;add	di,8
 42589                                  	;;;
 42590                                  
 42591                                  	; 17/12/2022
 42592 000078BA B10E                    	mov	cl,14
 42593                                  	;mov	cx,14			; set 14 offsets (skip 2 between each)
 42594                                  					;   sets offsets for ints 32h-3fh
 42595                                  iset3:
 42596 000078BC AB                      	stosw
 42597                                  	;add	di,2
 42598                                  	; 20/09/2023
 42599 000078BD 47                      	inc	di
 42600 000078BE 47                      	inc	di
 42601 000078BF E2FB                    	loop	iset3
 42602                                  
 42603                                  ;if installed
 42604                                  	; set the offset of int2f handler
 42605                                  	;mov	word [0BCh],INT2F
 42606 000078C1 C706BC00[0307]          	mov	word [02Fh*4],INT2F
 42607                                  	; set segment to doscode as we have to do int 2f to check for XMS
 42608 000078C7 36A1[AA0A]              	mov	ax,[ss:TEMP_DOSLOC]	; get segment of doscode
 42609                                  	;mov	[0BEh],ax
 42610 000078CB A3BE00                  	mov	[(02Fh*4)+2],ax
 42611                                  ;endif
 42612                                  	; set up entry point call at vectors 30-31h. Note the segment of the 
 42613                                  	; long jump will be patched in by seg_reinit
 42614                                  
 42615                                  	;mov	byte [C0h],0EAh
 42616 000078CE C606C000EA              	mov	byte [ENTRYPOINT],mi_long_jmp
 42617                                  	;mov	byte [C1h],CALL_ENTRY
 42618 000078D3 C706C100[E302]          	mov	word [ENTRYPOINT+1],CALL_ENTRY
 42619                                  
 42620 000078D9 C7068000[DC02]          	mov	word [addr_int_abort],QUIT	; INT 20h
 42621 000078DF C7068400[0803]          	mov	word [addr_int_command],COMMAND ; INT 21h
 42622 000078E5 C70688000001            	mov	word [addr_int_terminate],100h	; INT 22h
 42623 000078EB 89168A00                	mov	word [addr_int_terminate+2],dx	
 42624 000078EF C7069400[2D05]          	mov	word [addr_int_disk_read],ABSDRD   ; INT 25h
 42625 000078F5 C7069800[B405]          	mov	word [addr_int_disk_write],ABSDWRT ; INT 26h 
 42626 000078FB C7069C00[C661]          	mov	word [addr_int_keep_process],STAY_RESIDENT ; INT 27h
 42627                                  
 42628 00007901 16                      	push	ss
 42629 00007902 1F                      	pop	ds
 42630                                  	
 42631                                  	; 24/05/2019
 42632                                  	;push	ss
 42633                                  	;pop	es
 42634                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42635                                  	; 17/12/2022
 42636                                  	;push	ss
 42637                                  	;pop	es
 42638                                  
 42639 00007903 52                      	push	dx			; remember address of arena
 42640                                  
 42641 00007904 42                      	inc	dx			; leave room for arena header
 42642                                  	;mov	[330h],dx
 42643 00007905 8916[3003]              	mov     [CurrentPDB],dx		; set current pdb
 42644                                  
 42645 00007909 31FF                    	xor	di,di			; point es:di at end of memory
 42646 0000790B 8EC2                    	mov	es,dx			; ...where psp will be
 42647 0000790D 31C0                    	xor	ax,ax
 42648                                  	;mov	cx,80h			; psp is 128 words
 42649                                  	; 17/12/2022
 42650 0000790F B180                    	mov	cl,128 ; 28/06/2019
 42651                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42652                                  	;mov	cx,128
 42653                                  
 42654 00007911 F3AB                    	rep	stosw			; zero out psp area
 42655 00007913 A1[4603]                        mov     ax,[ENDMEM]
 42656                                  	
 42657                                  	; 17/12/2022
 42658                                  	; cx = 0
 42659 00007916 E80598                  	call	SETMEM         	 	; build psp at dx; ax is memory size
 42660                                  
 42661                                  	; ds, es now point to PSP
 42662                                  
 42663 00007919 16                      	push	ss
 42664 0000791A 1F                      	pop	ds
 42665                                  
 42666                                  	;mov	di,24
 42667 0000791B BF1800                  	mov	di,PDB.JFN_TABLE	; es:di -> pdb_jfn_table in psp
 42668 0000791E 31C0                    	xor	ax,ax
 42669 00007920 AB                      	stosw
 42670 00007921 AA                      	stosb				; 0,1 and 2 are con device
 42671 00007922 B0FF                    	mov	al,0FFh
 42672                                  	;mov	cx,FILPERPROC-3 ; 17
 42673                                  	; 17/12/2022
 42674                                  	; cx = 4
 42675 00007924 B111                    	mov	cl,FILPERPROC-3 ; 17
 42676 00007926 F3AA                    	rep	stosb			; rest are unused
 42677                                  
 42678 00007928 16                      	push	ss
 42679 00007929 07                      	pop	es
 42680                                  					; must be set to print messages
 42681 0000792A 8C1E[2C00]              	mov	[SFT_ADDR+2],ds     
 42682                                  
 42683                                  ; after this point the char device functions for con will work for
 42684                                  ; printing messages
 42685                                  
 42686                                  	; 24/04/2019 - Retro DOS v4.0
 42687                                  
 42688                                  ; 12/05/2019
 42689                                  ;
 42690                                  ;write_version_msg:
 42691                                  ;
 42692                                  ;	;if	(not ibm)
 42693                                  ;	;mov	si,offset doscode:header
 42694                                  ;	mov	si,HEADER
 42695                                  ;outmes:
 42696                                  ;	;lods	cs:byte ptr [si]
 42697                                  ;	cs
 42698                                  ;	lodsb
 42699                                  ;	cmp	al,"$"
 42700                                  ;	je	short outdone
 42701                                  ;	call	OUTT
 42702                                  ;	jmp	short outmes
 42703                                  ;outdone:
 42704                                  ;	push	ss			; out stomps on segments
 42705                                  ;	pop	ds
 42706                                  ;	push	ss
 42707                                  ;	pop	es
 42708                                  ;	;endif
 42709                                  
 42710                                  	; at this point es is dosdata
 42711                                  
 42712                                  	; Fill in the segment addresses of sysinitvar and country_cdpg 
 42713                                  	; in sysinittable (ms_data.asm)
 42714                                  
 42715                                  	;mov	si,0D28h
 42716 0000792E BE[280D]                	mov	si,SysInitTable
 42717                                  
 42718                                  	; 17/12/2022
 42719                                  	; ds = es = ss
 42720                                  
 42721                                  	; 17/12/2022
 42722                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42723                                  ;%if 0
 42724                                  	;;mov	[es:si+6],es
 42725                                  	;mov	[es:si+SYSI_EXT.Country_Tab+2],es
 42726                                  	;;mov	[es:si+2],es
 42727                                  	;mov	[es:si+SYSI_EXT.SysInitVars+2],es
 42728                                  	
 42729 00007931 8C4406                  	mov	[si+SYSI_EXT.Country_Tab+2],es
 42730 00007934 8C4402                  	mov	[si+SYSI_EXT.SysInitVars+2],es
 42731                                  
 42732                                  	; buffhead -> dosdata:hashinitvar 
 42733                                  
 42734                                  	;mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
 42735 00007937 8C06[3A00]              	mov	[BUFFHEAD+2],es
 42736                                  	;mov	si,offset dosdata:hashinitvar ; and all other references
 42737                                  	;mov	si,6Dh
 42738 0000793B BE[6D00]                	mov	si,HASHINITVAR
 42739                                  	;mov	[es:BUFFHEAD],si
 42740 0000793E 8936[3800]              	mov	[BUFFHEAD],si
 42741                                  
 42742 00007942 5A                              pop     dx                      ; restore address of arena
 42743                                  
 42744                                  	;mov	[032Ch+2],dx
 42745 00007943 8916[2E03]                      mov     [DMAADD+2],dx
 42746                                  
 42747                                  	;mov	[es:arena_head],dx
 42748 00007947 8916[2400]              	mov	[arena_head],dx
 42749                                  
 42750                                  ;%endif
 42751                                  
 42752                                  ; 17/12/2022
 42753                                  %if 0
 42754                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42755                                  	;;;
 42756                                  	;mov	[es:si+6],es
 42757                                  	mov	[es:si+SYSI_EXT.Country_Tab+2],es
 42758                                  	;mov	[es:si+2],es
 42759                                  	mov	[es:si+SYSI_EXT.SysInitVars+2],es
 42760                                  
 42761                                  	; buffhead -> dosdata:hashinitvar 
 42762                                  
 42763                                  	mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
 42764                                  	;mov	si,offset dosdata:hashinitvar ; and all other references
 42765                                  	;mov	si,6Dh
 42766                                  	mov	si,HASHINITVAR
 42767                                  	mov	[es:BUFFHEAD],si
 42768                                  
 42769                                          pop     dx                      ; restore address of arena
 42770                                  
 42771                                  	;mov	[032Ch+2],dx
 42772                                          mov     [DMAADD+2],dx
 42773                                  
 42774                                  	mov	[es:arena_head],dx
 42775                                  	;;;
 42776                                  %endif
 42777                                  
 42778 0000794B 8EDA                            mov     ds,dx
 42779                                  
 42780                                  	;mov	byte [0],'Z'
 42781 0000794D C60600005A              	mov     byte [ARENA.SIGNATURE],arena_signature_end
 42782                                          ;mov	word [1],0
 42783 00007952 C70601000000            	mov     word [ARENA.OWNER],arena_owner_system
 42784                                  
 42785 00007958 36A1[4603]                      mov     ax,[ss:ENDMEM]
 42786 0000795C 29D0                    	sub	ax,dx
 42787 0000795E 48                              dec     ax
 42788 0000795F A30300                          mov     [ARENA.SIZE],ax
 42789                                  
 42790                                  	; point to sft 0
 42791                                  
 42792                                  	;mov	di,offset dosdata:sftabl + sftable
 42793                                  	;mov	di,SFTABL+6
 42794 00007962 BF[D200]                	mov	di,SFTABL+SFT.SFTable
 42795 00007965 B80300                          mov     ax,3
 42796 00007968 AB                              stosw           		; adjust refcount
 42797                                  
 42798                                  	; es:di is shared data area i.e., es:di -> dosdata:sysinttable
 42799                                  
 42800                                          ;mov	di,offset dosdata:sysinittable
 42801                                  	;mov	di,0D28h
 42802 00007969 BF[280D]                	mov	di,SysInitTable	
 42803                                  
 42804 0000796C 42                      	inc	dx			; advance dx from arena to psp
 42805 0000796D 8EDA                    	mov	ds,dx			; point ds to psp
 42806                                  
 42807                                  					; pass the address os seg_reinit 
 42808                                  					; in dx
 42809 0000796F BA[DD79]                	mov	dx,seg_reinit
 42810 00007972 B9[0174]                	mov	cx,exepatch_start
 42811 00007975 81E9[0000]              	sub	cx,_$STARTCODE		; cx = (doscode - exepatch) - dosinit
 42812                                  
 42813 00007979 B8[B876]                	mov	ax,SYSBUF
 42814 0000797C 2D[0000]                	sub	ax,_$STARTCODE		; ax = size of doscode - dosinit
 42815                                  	
 42816 0000797F 368B26[8405]                    mov     sp,[ss:USER_SP]		; use ss override for next 2
 42817 00007984 368E16[8605]                    mov     ss,[ss:USER_SS]
 42818                                  
 42819 00007989 CB                              retf
 42820                                  
 42821                                  ;
 42822                                  ; END OF DOSINIT
 42823                                  ;
 42824                                  ;--------------------------------------------------------------------------
 42825                                  
 42826                                  CHARINIT:
 42827                                  	; 24/04/2019 - Retro DOS v4.0
 42828                                  	; 07/07/2018 - Retro DOS v3.0
 42829                                  	;mov	byte [ss:035Ah],26 ; 1Ah
 42830 0000798A 36C606[5A03]1A                  MOV	BYTE [SS:DEVCALL_REQLEN],DINITHL
 42831                                  	;mov	byte [ss:035Bh],0
 42832 00007990 36C606[5B03]00                  MOV	BYTE [SS:DEVCALL_REQUNIT],0
 42833                                  	;mov	byte [ss:035Ch],0
 42834 00007996 36C606[5C03]00                  MOV	BYTE [SS:DEVCALL_REQFUNC],DEVINIT
 42835                                  	;mov	word [ss:035BD],0
 42836 0000799C 36C706[5D03]0000                MOV	WORD [SS:DEVCALL_REQSTAT],0
 42837 000079A3 06                              PUSH	ES
 42838 000079A4 53                              PUSH	BX
 42839 000079A5 50                              PUSH	AX
 42840 000079A6 BB[5A03]                        MOV	BX,DEVCALL
 42841                                          ;PUSH	CS
 42842 000079A9 16                      	PUSH	SS ; 30/04/2019
 42843 000079AA 07                              POP	ES
 42844 000079AB E8CACC                          CALL	DEVIOCALL2	
 42845 000079AE 58                      	POP	AX
 42846 000079AF 5B                              POP	BX
 42847 000079B0 07                              POP	ES
 42848 000079B1 C3                              RETN
 42849                                  
 42850                                  ; 25/04/2019 - Retro DOS v4.0
 42851                                  
 42852                                  ;-----------------------------------------------------------------------------
 42853                                  ;
 42854                                  ;	check_XMM: routine to check presence of XMM driver
 42855                                  ;
 42856                                  ;	Exit:   Sets up the XMM entry point in XMMcontrol in DOSDATA
 42857                                  ;
 42858                                  ;	USED:	none
 42859                                  ;
 42860                                  ;-----------------------------------------------------------------------------
 42861                                  
 42862                                  check_XMM: ; proc near
 42863                                  ;
 42864                                  ; determine whether or not an XMM driver is installed
 42865                                  ;
 42866 000079B2 50                      	push	ax
 42867                                  	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_INSTALL_CHECK
 42868 000079B3 B80043                  	mov	ax,4300h
 42869 000079B6 CD2F                    	int	2Fh
 42870                                  		; - Multiplex - XMS - INSTALLATION CHECK
 42871                                  		; Return: AL = 80h XMS driver installed
 42872                                  		; AL <> 80h no driver
 42873 000079B8 3C80                    	cmp	al,80h			; Q: installed
 42874 000079BA 751D                    	jne	short cXMM_no_driver	; N: set error, quit
 42875                                  ;
 42876                                  ; get the XMM control functions entry point, save it, we
 42877                                  ; need to call it later.
 42878                                  ;
 42879 000079BC 53                      	push	bx
 42880 000079BD 52                      	push	dx
 42881 000079BE 1E                      	push	ds
 42882 000079BF 06                      	push	es
 42883                                  	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_FUNCTION_ADDR
 42884 000079C0 B81043                  	mov	ax,4310h
 42885 000079C3 CD2F                    	int	2Fh
 42886                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
 42887                                  		; Return: ES:BX -> driver entry point
 42888                                  
 42889 000079C5 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 42890                                  
 42891 000079CA 891E[4911]              	mov	[XMMcontrol],bx
 42892 000079CE 8C06[4B11]              	mov	[XMMcontrol+2],es
 42893                                  cXMMexit:
 42894 000079D2 F8                      	clc
 42895 000079D3 07                      	pop	es
 42896 000079D4 1F                      	pop	ds
 42897 000079D5 5A                      	pop	dx
 42898 000079D6 5B                      	pop	bx
 42899 000079D7 58                      	pop	ax
 42900 000079D8 C3                      	retn				; done
 42901                                  ;
 42902                                  ; set carry if XMM driver not present
 42903                                  ;
 42904                                  cXMM_no_driver:
 42905 000079D9 F9                      	stc
 42906 000079DA 58                      	pop	ax
 42907 000079DB C3                      	retn
 42908                                  
 42909                                  ;-----------------------------------------------------------------------------
 42910                                  ;
 42911                                  ; Procedure Name : seg_reinit
 42912                                  ;
 42913                                  ; Inputs	 : ES has final dos code location
 42914                                  ;		   AX = 0 / 1
 42915                                  ;
 42916                                  ; Outputs	 : Patch in the sharer and other tables with seg in ES
 42917                                  ;		   if AX =0
 42918                                  ;		      if first entry
 42919                                  ;			 patch segment & offset of vectors with stub
 42920                                  ;			 and stub with segment in ES
 42921                                  ;		      else
 42922                                  ;			 patch stub with segment in ES
 42923                                  ;
 42924                                  ;		   else if AX = 1
 42925                                  ;			patch segment of vectors with segment in ES	
 42926                                  ;
 42927                                  ; NOTE		 : This routine can be called at most twice!
 42928                                  ;
 42929                                  ; Regs Mod.	 : es, ax, di, cx, bx
 42930                                  ;-----------------------------------------------------------------------------
 42931                                  
 42932 000079DC 00                      num_entry: db	0		; keeps track of the # of times this routine
 42933                                  				; has been called. (0 or 1)
 42934                                  
 42935                                  	; 04/11/2022 - Retro DOS v4.0 (ref: MSDOS 5.0)
 42936                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BAB7h
 42937                                  	; 25/05/2019 - Retro DOS v4.0 (ref: MSDOS 6.21)
 42938                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDA5h
 42939                                  
 42940                                  seg_reinit:	; proc	far
 42941 000079DD 1E                      	push	ds
 42942                                  
 42943 000079DE 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 42944                                  
 42945 000079E3 E88600                  	call	patch_misc_segments	; patch in segments for sharer and 
 42946                                  					; other tables with seg in ES.
 42947                                  	; 17/12/2022
 42948                                  	; cx = 0
 42949 000079E6 39C8                    	cmp	ax,cx ; 0
 42950                                  	;cmp	ax,0
 42951 000079E8 753D                    	jne	short patch_vec_seg	; patch vectors with segment in es
 42952                                  
 42953                                  	; 17/12/2022
 42954 000079EA 2E380E[DC79]            	cmp	[cs:num_entry],cl ; 0
 42955                                  	;cmp	byte [cs:num_entry],0	; Q: is it the first call to this 
 42956 000079EF 7508                    	jne	short second_entry	; N: just patch the stub with 
 42957                                  					;    segment in ES
 42958                                  					; Y: patch the vectors with stub 
 42959 000079F1 8CD8                    	mov	ax,ds
 42960 000079F3 E83E00                  	call	patch_vec_segments	; patch the segment of vectors
 42961 000079F6 E8BD00                  	call	patch_offset		; patch the offsets of vectors 
 42962                                  					; with those in the stub.
 42963                                  	; 17/12/2022
 42964                                  	; cx = 0
 42965                                  second_entry:
 42966 000079F9 8CC0                    	mov	ax,es			; patch the stub with segment in es
 42967                                  
 42968                                  	;mov	di,OFFSET DOSDATA:DOSINTTABLE
 42969                                  	;mov	di,1062h	; (same table addr for MSDOS 5.0 and MSDOS 6.21)
 42970 000079FB BF[4810]                	mov	di,DOSINTTABLE
 42971                                  	; 17/12/2022
 42972                                  	; cx = 0
 42973                                  	;mov	cx,9
 42974 000079FE B109                    	mov	cl,9
 42975 00007A00 1E                      	push	ds			
 42976 00007A01 07                      	pop	es			; es:di -> DOSINTTABLE
 42977                                  
 42978                                  dosinttabloop:
 42979                                  	;add	di,2
 42980                                  	; 19/06/2023
 42981 00007A02 47                      	inc	di
 42982 00007A03 47                      	inc	di
 42983 00007A04 AB                      	stosw
 42984 00007A05 E2FB                    	loop	dosinttabloop	
 42985                                  
 42986                                  ; For ROMDOS, this routine will only be called when the DOS wants to
 42987                                  ; use the HMA, so we don't want to check CS
 42988                                  
 42989                                  ;ifndef ROMDOS
 42990 00007A07 3D00F0                  	cmp	ax,0F000h		; Q: is the DOS running in the HMA
 42991 00007A0A 7220                    	jb	short sr_done		; N: done
 42992                                  ;endif
 42993 00007A0C E8A3FF                  	call	check_XMM		; Y: set up the XMS entry point
 42994 00007A0F 721B                    	jc	short sr_done		; failed to set up XMS do not do
 42995                                  					; A20 toggling in the stub.
 42996                                  	; 17/12/2022
 42997                                  	; cx = 0
 42998 00007A11 E81D01                  	call	patch_in_nops		; enable the stub to check A20 state
 42999                                  ; M021-
 43000                                  	;mov	byte [1211h],1
 43001 00007A14 C606[F211]01            	mov	byte [DosHasHMA],1	; set flag telling DOS control of HMA 
 43002                                  				
 43003                                  					; set pointer to the routine that 
 43004                                  					; patches buggy exepacked code.
 43005                                  	;mov	[FixExePatch],offset DOSCODE:ExePatch
 43006 00007A19 C706[F311][5175]        	mov	word [FixExePatch],ExePatch
 43007                                  					; M068: set pointer to the routine 
 43008                                  					; M068: that detects copy protected
 43009                                  					; M068: apps
 43010                                  	;mov	[ChkCopyProt],offset DOSCODE:IsCopyProt
 43011 00007A1F C706[6100][8276]        	mov	word [ChkCopyProt],IsCopyProt
 43012                                  
 43013                                  	; 19/09/2023
 43014 00007A25 EB05                    	jmp	short sr_done
 43015                                  
 43016                                  ; 28/12/2022 - Retro DOS v4.1
 43017                                  %if 0
 43018                                  ;----------------------------------------------------------------------------
 43019                                  
 43020                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDF1h
 43021                                  
 43022                                  ;	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43023                                  ;
 43024                                  ;; M020 - begin
 43025                                  ;
 43026                                  ;	call	WhatCPUType
 43027                                  ;	cmp	al,1
 43028                                  ;	jne	short sr_done 		; we need Rational Patch only
 43029                                  ;					;  on 286 systems
 43030                                  ;	;mov	[RationalPatchPtr],offset DOSCODE:RationalPatch
 43031                                  ;	mov	word [RationalPatchPtr],RationalPatch
 43032                                  ;
 43033                                  ;; M020 - end
 43034                                  ;
 43035                                  ;	jmp	short sr_done
 43036                                  ;
 43037                                  ;patch_vec_seg:				; patch vectors with segment in es
 43038                                  ;	mov	ax,es
 43039                                  ;	call	patch_vec_segments	; patch in DOSCODE for the segments
 43040                                  ;					; NOTE we don't have to patch the 
 43041                                  ;					; offsets as they have been already
 43042                                  ;					; set to the doscode offsets at
 43043                                  ;					; DOSINIT.
 43044                                  ;sr_done:
 43045                                  ;	mov	byte [cs:num_entry],1
 43046                                  ;	pop	ds
 43047                                  ;	retf	; ! far return !
 43048                                  
 43049                                  ;----------------------------------------------------------------------------
 43050                                  ;
 43051                                  ; Procedure Name : WhatCPUType
 43052                                  ;
 43053                                  ; Inputs	 : none
 43054                                  ;
 43055                                  ; Outputs	 : AL = 0 if CPU <  286
 43056                                  ;		      = 1 if CPU == 286
 43057                                  ;		      = 2 if CPU >= 386
 43058                                  ;
 43059                                  ; Regs. Mod.	 : AX
 43060                                  ;
 43061                                  ;----------------------------------------------------------------------------
 43062                                  
 43063                                  WhatCPUType:
 43064                                  	; 25/04/2019 - Retro DOS v4.0
 43065                                  	;get_cpu_type	; done with a MACRO which can't be generated > once
 43066                                  
 43067                                  	;CPUTYPE.INC (MSDOS 6.0, 1991)
 43068                                  
 43069                                  ; Note: this must be a macro, and not a subroutine in the BIOS since
 43070                                  ; 	it is called from both CODE and SYSINITSEG.
 43071                                  ;
 43072                                  ;------GET_CPU_TYPE-----------------------------------May, 88 by M.Williamson
 43073                                  ;  Returns: AX = 0 if 8086 or 8088
 43074                                  ;              = 1 if 80286
 43075                                  ;              = 2 if 80386
 43076                                  
 43077                                  	; 04/11/2022
 43078                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB03h
 43079                                  
 43080                                  Get_CPU_Type:	;macro
 43081                                  	pushf
 43082                                  	push	bx			; preserve bx
 43083                                  	xor	bx,bx			; init bx to zero
 43084                                  
 43085                                  	xor	ax,ax			; 0000 into AX
 43086                                  	push	ax			; put it on the stack...
 43087                                  	popf				; ...then shove it into the flags
 43088                                  	pushf				; get it back out of the flags...
 43089                                  	pop	ax			; ...and into ax
 43090                                  	and	ax,0F000h		; mask off high four bits
 43091                                  	cmp	ax,0F000h		; was it all 1's?
 43092                                  	je	short cpu_8086		; aye; it's an 8086 or 8088
 43093                                  
 43094                                  	mov	ax,0F000h		; now try to set the high four bits..
 43095                                  	push	ax
 43096                                  	popf
 43097                                  	pushf
 43098                                  	pop	ax			; ...and see what happens
 43099                                  	and	ax,0F000h		; any high bits set ?
 43100                                  	jz	short cpu_286		; nay; it's an 80286
 43101                                  
 43102                                  cpu_386:				; bx starts as zero
 43103                                  	inc	bx			; inc twice if 386
 43104                                  cpu_286:				; just inc once if 286
 43105                                  	inc	bx
 43106                                  cpu_8086:				; don't inc at all if 086
 43107                                  	mov	ax,bx			; put CPU type value in ax
 43108                                  	pop	bx			; restore original bx
 43109                                  	popf
 43110                                  	
 43111                                  	;endm
 43112                                  
 43113                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS)
 43114                                  	retn	; 19/09/2023
 43115                                  
 43116                                  ; 19/09/2023
 43117                                  ;	; 04/11/2022
 43118                                  ;	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB27h
 43119                                  ;	cmp	al,1
 43120                                  ;	jne	short sr_done 		; we need Rational Patch only
 43121                                  ;					;  on 286 systems
 43122                                  ;	mov	word [RationalPatchPtr],RationalPatch
 43123                                  
 43124                                  ;----------------------------------------------------------------------------
 43125                                  %endif	; 28/12/2022
 43126                                  
 43127                                  	; 19/09/2023
 43128                                  	;jmp	short sr_done
 43129                                  
 43130                                  patch_vec_seg:				; patch vectors with segment in es
 43131 00007A27 8CC0                    	mov	ax,es
 43132 00007A29 E80800                  	call	patch_vec_segments	; patch in DOSCODE for the segments
 43133                                  					; NOTE we don't have to patch the 
 43134                                  					; offsets as they have been already
 43135                                  					; set to the doscode offsets at
 43136                                  					; DOSINIT.
 43137                                  sr_done:
 43138 00007A2C 2EC606[DC79]01          	mov	byte [cs:num_entry],1
 43139 00007A32 1F                      	pop	ds
 43140 00007A33 CB                      	retf	; ! far return !
 43141                                  
 43142                                  ;----------------------------------------------------------------------------
 43143                                  ;
 43144                                  ; Procedure Name : patch_vec_segments
 43145                                  ;
 43146                                  ; Inputs	 : ax -> has segment address to patch in
 43147                                  ;		   ds -> DOSDATA
 43148                                  ;
 43149                                  ; Outputs	 : Patches in AX as the segment for the following vectors:
 43150                                  ;			
 43151                                  ;			0,20-28,3a-3f
 43152                                  ;
 43153                                  ; Regs. Mod.	 : DI,CX,DX,AX
 43154                                  ;
 43155                                  ;----------------------------------------------------------------------------
 43156                                  
 43157                                  patch_vec_segments:
 43158                                  
 43159 00007A34 06                      	push	es
 43160                                  
 43161 00007A35 31C9                    	xor	cx,cx ; 0
 43162 00007A37 8EC1                    	mov	es,cx
 43163                                  
 43164                                  	;mov	di,82h
 43165 00007A39 BF8200                  	mov	di,INTBASE+2		; di -> segment of int 20 vector
 43166                                  
 43167 00007A3C 26A30200                	mov	[es:2],ax		; segment of default divide trap handler
 43168                                  
 43169                                  					; set vectors 20 & 21
 43170                                  	; 04/11/2022
 43171                                  	;mov	cx,2
 43172                                  	; 17/12/2022
 43173                                  	;mov	cl,2
 43174                                  ps_set1:
 43175 00007A40 AB                      	stosw	; int 20h segment
 43176                                  	;add	di,2
 43177                                  	; 17/12/2022
 43178 00007A41 47                      	inc	di
 43179 00007A42 47                      	inc	di
 43180                                  	;loop	ps_set1
 43181                                  
 43182                                  	; 17/12/2022
 43183 00007A43 AB                      	stosw	; int 21h segment
 43184                                  	;inc	di
 43185                                  	;inc	di
 43186                                  
 43187                                  	;add	di,4			; skip int 22h vector
 43188 00007A44 83C706                  	add	di,6 ; *
 43189                                  
 43190 00007A47 AB                      	stosw				; set int 23h
 43191 00007A48 83C706                  	add	di,6			; skip int 24h
 43192                                  
 43193                                  					; set vectors 25-28 and 2a-3f 
 43194                                  	; 04/11/2022
 43195                                  	;mov	cx,4			; set 4 segments
 43196                                  	; 17/12/2022
 43197 00007A4B B104                    	mov	cl,4
 43198                                  ps_set2:
 43199 00007A4D AB                      	stosw				
 43200                                  	;add	di,2
 43201                                  	; 17/12/2022
 43202 00007A4E 47                      	inc	di
 43203 00007A4F 47                      	inc	di
 43204 00007A50 E2FB                    	loop	ps_set2
 43205                                  
 43206 00007A52 83C704                  	add	di,4			; skip int 29h vector (fast con) as it may
 43207                                  					;   already be set.
 43208                                  	; 04/11/2022
 43209                                  	;mov	cx,6			; set 6 segs (skip 2 between each)
 43210                                  	; 17/12/2022
 43211 00007A55 B106                    	mov	cl,6			;  set segs for ints 2ah-2fh
 43212                                  ps_set3:
 43213 00007A57 AB                      	stosw
 43214                                  	;add	di,2
 43215                                  	; 17/12/2022
 43216 00007A58 47                      	inc	di
 43217 00007A59 47                      	inc	di
 43218 00007A5A E2FB                    	loop	ps_set3
 43219                                  
 43220                                  ; 30h & 31H is the CPM call entry point whose segment address is set up by
 43221                                  ; below. So skip it.
 43222                                  
 43223 00007A5C 83C708                  	add	di,8			; skip vector 30h & 31h 
 43224                                  	
 43225                                  	; 04/11/2022
 43226                                  	;mov	cx,14			; set 14 segs (skip 2 between each)
 43227                                  	; 17/12/2022
 43228 00007A5F B10E                    	mov	cl,14			;   sets segs for ints 32h-3fh
 43229                                  ps_set4:
 43230 00007A61 AB                      	stosw
 43231                                  	;add	di,2
 43232                                  	; 17/12/2022
 43233 00007A62 47                      	inc	di
 43234 00007A63 47                      	inc	di
 43235 00007A64 E2FB                    	loop	ps_set4
 43236                                  
 43237                                  ; set offset of int2f
 43238                                  
 43239                                  ;if installed
 43240                                  ;	mov	word ptr es:[02fh * 4],offset doscode:int2f
 43241                                  ;endif
 43242                                  	;mov	[es:0C3h],ax
 43243 00007A66 26A3C300                	mov	[es:ENTRYPOINT+3],ax
 43244                                  	; 17/12/2022
 43245                                  	; cx = 0
 43246 00007A6A 07                      	pop	es
 43247 00007A6B C3                      	retn
 43248                                  
 43249                                  ;---------------------------------------------------------------------------
 43250                                  ;
 43251                                  ; Procedure Name : patch_misc_segments
 43252                                  ;
 43253                                  ; Inputs	 : es = segment to patch in
 43254                                  ;		   ds = dosdata
 43255                                  ;
 43256                                  ; outputs	 : patches in the sharer and other tables in the dos
 43257                                  ;		   with right dos code segment in es
 43258                                  ;
 43259                                  ; Regs Mod	 : DI,SI,CX
 43260                                  ;
 43261                                  ;---------------------------------------------------------------------------
 43262                                  
 43263                                  patch_misc_segments:
 43264                                  
 43265 00007A6C 53                      	push	bx
 43266 00007A6D 06                      	push	es
 43267 00007A6E 50                      	push	ax
 43268                                  
 43269 00007A6F 8CC0                    	mov	ax,es			; ax - > DOS segment
 43270                                  	
 43271 00007A71 1E                      	push	ds
 43272 00007A72 07                      	pop	es			; es -> DOSDATA
 43273                                  	
 43274                                  ; initialize the jump table for the sharer...
 43275                                  
 43276                                  	;mov	di,offset dosdata:jshare
 43277                                  	;mov	di,90h
 43278 00007A73 BF[9000]                	mov	di,JShare
 43279                                  	;mov	bx,[0AAAh]
 43280 00007A76 8B1E[AA0A]              	mov	bx,[TEMP_DOSLOC]	; bx = location to which the share
 43281                                  					; table was patched during the first
 43282                                  					; call to this routine
 43283 00007A7A B90F00                  	mov	cx,15
 43284                                  jumptabloop:
 43285                                  	;add	di,2			; skip offset
 43286                                  	; 17/12/2022
 43287 00007A7D 47                      	inc	di
 43288 00007A7E 47                      	inc	di
 43289 00007A7F 83FBFF                  	cmp	bx,-1 ; 0FFFFh		; Q: is this called for the 1st time
 43290 00007A82 7405                    	je	short share_patch	; Y: patch in sharer table
 43291                                  					; N: 
 43292 00007A84 263B1D                  	cmp	bx,[es:di]		; Q: has share been installed
 43293 00007A87 7501                    	jne	short no_share_patch	; Y: don't patch in sharer table
 43294                                  share_patch:
 43295 00007A89 AB                      	stosw				; drop in segment
 43296                                  no_share_patch:
 43297 00007A8A E2F1                    	loop	jumptabloop
 43298                                  					; BUGBUG patching the country info 
 43299                                  					; with dosdata can be done inline
 43300                                  					; in dosinit.
 43301                                  					; for dos 3.3 country info
 43302                                  					; table address
 43303                                  
 43304                                  	;mov	si,offset dosdata:country_cdpg
 43305                                  	;mov	si,122Ah   
 43306 00007A8C BE[0012]                	mov	si,COUNTRY_CDPG
 43307                                  					; initialize double word
 43308                                  					; pointers with dosdata in ds
 43309                                  	;mov	[si+4Fh],ds
 43310                                  	;mov	[si+54h],ds
 43311                                  	;mov	[si+59h],ds
 43312                                  	;mov	[si+5Eh],ds
 43313                                  	;mov	[si+80h],ds
 43314                                  	;mov	[si+63h],ds
 43315 00007A8F 8C5C4F                  	mov	[si+DOS_CCDPG.ccUcase_ptr+2],ds    
 43316 00007A92 8C5C54                  	mov	[si+DOS_CCDPG.ccFileUcase_ptr+2],ds 
 43317 00007A95 8C5C59                  	mov	[si+DOS_CCDPG.ccFileChar_ptr+2],ds
 43318 00007A98 8C5C5E                  	mov	[si+DOS_CCDPG.ccCollate_ptr+2],ds
 43319 00007A9B 8C9C8000                	mov	[si+DOS_CCDPG.ccMono_ptr+2],ds
 43320 00007A9F 8C5C63                  	mov	[si+DOS_CCDPG.ccDBCS_ptr+2],ds	
 43321                                  
 43322                                  					; fastopen routines are in doscode
 43323                                  					; so patch with doscode seg in ax
 43324                                  
 43325                                  	;mov	si,offset dosdata:fastopentable
 43326                                  	;mov	si,0D30h
 43327 00007AA2 BE[300D]                	mov	si,FastOpenTable
 43328                                  
 43329                                  	; 17/12/2022
 43330                                  	; bx = [TEMP_DOSLOC]
 43331 00007AA5 83FBFF                  	cmp	bx,-1
 43332                                  	;cmp	word [TEMP_DOSLOC],-1	; Q: first time 
 43333 00007AA8 7405                    	je	short fast_patch	; Y: patch segment
 43334                                  	;mov	cx,[TEMP_DOSLOC]
 43335                                  					; Q: has fastopen patched in it's
 43336                                  					;    segment
 43337                                  	; 17/12/2022
 43338 00007AAA 3B5C04                  	cmp	bx,[si+fastopen_entry.name_caching+2]
 43339                                  	;;cmp	cx,[si+4]
 43340                                  	;cmp	cx,[si+fastopen_entry.name_caching+2]
 43341 00007AAD 7503                    	jne	short no_fast_patch	; Y: don't patch in doscode seg
 43342                                  
 43343                                  fast_patch:
 43344                                  	;mov	[si+4],ax
 43345 00007AAF 894404                  	mov	[si+fastopen_entry.name_caching+2],ax
 43346                                  no_fast_patch:
 43347                                  	; 17/12/2022
 43348                                  	; cx = 0
 43349 00007AB2 58                      	pop	ax
 43350 00007AB3 07                      	pop	es
 43351 00007AB4 5B                      	pop	bx
 43352                                  
 43353 00007AB5 C3                      	retn
 43354                                  
 43355                                  ;--------------------------------------------------------------------------
 43356                                  ;
 43357                                  ; Procedure Name : patch_offset
 43358                                  ; 
 43359                                  ; Inputs	 : NONE
 43360                                  ;
 43361                                  ; Outputs	 : Patches in the offsets in the low_mem_stub for vectors
 43362                                  ;		   0,20-28,3a-3f, and 30,31
 43363                                  ;
 43364                                  ;
 43365                                  ; Regs. Mod	 : AX,DI,CX
 43366                                  ;--------------------------------------------------------------------------
 43367                                  
 43368                                  patch_offset:
 43369 00007AB6 06                      	push	es		; preserve es
 43370                                  
 43371 00007AB7 31C0                    	xor	ax,ax
 43372 00007AB9 8EC0                    	mov	es,ax
 43373                                  				; set default divide trap address
 43374                                  	;mov	word ptr es:[0],offset dosdata:ldivov	
 43375                                  	;mov	word [es:0],108Ah
 43376 00007ABB 26C7060000[7010]        	mov	word [es:0],ldivov
 43377                                  
 43378                                  	;mov	di,80h
 43379 00007AC2 BF8000                  	mov	di,INTBASE	; di-> offset of int 20 handler
 43380                                  	;mov	ax,offset dosdata:lirett
 43381                                  	;mov	ax,10DAh
 43382 00007AC5 B8[C010]                	mov	ax,lirett
 43383                                  				; set vectors 20 & 21 to point to iret.
 43384                                  	; 17/12/2022
 43385                                  	; cx = 0
 43386                                  
 43387                                  	;mov	cx,2		; set 2 offsets (skip 2 between each)
 43388                                  po_iset1:
 43389 00007AC8 AB                      	stosw	; int 20h offset
 43390                                  	;add	di,2 ; *
 43391                                  	;loop	po_iset1
 43392                                  	; 17/12/2022
 43393 00007AC9 47                      	inc	di
 43394 00007ACA 47                      	inc	di
 43395 00007ACB AB                      	stosw	; int 21h offset
 43396                                  
 43397                                  	;add	di,4		; skip vector 22h
 43398                                  	; 17/12/2022
 43399 00007ACC 83C706                  	add	di,6 ; *	
 43400                                  
 43401 00007ACF AB                      	stosw			; set offset of 23h
 43402                                  	;add	di,6		; skip 24h
 43403                                  	; 19/09/2023
 43404 00007AD0 83C712                  	add	di,18		; skip 23h segment and int 24-25-26-27h
 43405                                  
 43406                                  				; set vectors 25-28 and 2a-3f to iret.
 43407                                  	; 04/11/2022
 43408                                  	;mov	cx,4		; set 4 offsets (skip 2 between each)
 43409                                  	; 19/09/2023
 43410                                  	; 17/12/2022
 43411                                  	;mov	cl,4		;   sets offsets for ints 25h-28h
 43412                                  po_iset2:
 43413 00007AD3 AB                      	stosw		; set offset for int 28h ; 19/09/2023
 43414                                  	;add	di,2
 43415                                  	; 19/09/2023
 43416                                  	; 17/12/2022
 43417                                  	;inc	di
 43418                                  	;inc	di
 43419                                  	; 19/09/2023
 43420                                  	;loop	po_iset2
 43421                                  
 43422                                  	;add	di,4		; skip vector 29h
 43423                                  	; 19/09/2023
 43424 00007AD4 83C706                  	add	di,6	; skip int 28h segment and int 29h ; 19/09/2023
 43425                                  
 43426                                  	; 04/11/2022
 43427                                  	;mov	cx,6		; set 6 offsets (skip 2 between each)
 43428                                  	; 17/12/2022
 43429                                  	;mov	cl,6		;   sets offsets for ints 2ah-2fh
 43430 00007AD7 B105                    	mov	cl,5		; sets offsets for ints 2Ah-2Eh
 43431                                  po_iset3:
 43432 00007AD9 AB                      	stosw
 43433                                  	;add	di,2
 43434                                  	; 17/12/2022
 43435 00007ADA 47                      	inc	di
 43436 00007ADB 47                      	inc	di
 43437 00007ADC E2FB                    	loop	po_iset3
 43438                                  
 43439                                  ; 30h & 31H is the CPM call entry point whose offset address is set up by
 43440                                  ; below. So skip it.
 43441                                  
 43442                                  	;add	di,8		; skip vector 30h & 31h 
 43443                                  	; 17/12/2022
 43444 00007ADE 83C70C                  	add	di,12		; skip vector 2Fh, 30h & 31h
 43445                                  
 43446                                  	; 04/11/2022
 43447                                  	;mov	cx,14		; set 14 offsets (skip 2 between each)
 43448                                  				;   sets offsets for ints 32h-3fh
 43449                                  	; 17/12/2022
 43450 00007AE1 B10E                    	mov	cl,14 ; 26/06/2019
 43451                                  po_iset4:
 43452 00007AE3 AB                      	stosw
 43453                                  	;add	di,2
 43454                                  	; 17/12/2022
 43455 00007AE4 47                      	inc	di
 43456 00007AE5 47                      	inc	di
 43457 00007AE6 E2FB                    	loop	po_iset4
 43458                                  
 43459                                  ;if installed
 43460                                  	;mov	word ptr es:[02fh * 4],offset dosdata:lint2f
 43461                                  	;mov	word [es:0BCh],10C6h ; (MSDOS 5.0 & 6.21)
 43462 00007AE8 26C706BC00[AC10]        	mov	word [es:(2Fh*4)],lint2f
 43463                                  ;endif
 43464                                  
 43465                                  ; set up entry point call at vectors 30-31h
 43466                                  	;mov	byte [es:0C0h],0EAh
 43467 00007AEF 26C606C000EA            	mov	byte [es:ENTRYPOINT],mi_long_jmp
 43468                                  	;mov	word [es:0C1h],10D0h
 43469                                  
 43470 00007AF5 26C706C100[B610]        	mov	word [es:ENTRYPOINT+1],lcall_entry
 43471                                  
 43472                                  							; 19/09/2023
 43473                                  	;mov	word [es:80h],1094h
 43474 00007AFC 26C7068000[7A10]        	mov	word [es:addr_int_abort],lquit		; int 20h
 43475                                  	;mov	word [es:84h],109Eh
 43476 00007B03 26C7068400[8410]        	mov	word [es:addr_int_command],lcommand	; int 21h
 43477                                  	;mov	word [es:94h],10A8h
 43478 00007B0A 26C7069400[8E10]        	mov	word [es:addr_int_disk_read],labsdrd	; int 25h  
 43479                                  	;mov	word [es:98h],10B2h
 43480 00007B11 26C7069800[9810]        	mov	word [es:addr_int_disk_write],labsdwrt	; int 26h
 43481                                  	;mov	word [es:9Ch],10BCh
 43482 00007B18 26C7069C00[A210]        	mov	word [es:addr_int_keep_process],lstay_resident	; int 27h
 43483                                  
 43484                                  	; 17/12/2022
 43485                                  	; CX = 0
 43486 00007B1F 07                      	pop	es		; restore es
 43487 00007B20 C3                      	retn
 43488                                  
 43489                                  ;--------------------------------------------------------------------------
 43490                                  ;
 43491                                  ; 	Procedure Name	:	patch_in_nops
 43492                                  ;
 43493                                  ; 	Entry		: 	ES -> DOSDATA
 43494                                  ;
 43495                                  ;	Regs Mod	: 	cx, di
 43496                                  ;
 43497                                  ;	Description:
 43498                                  ;		This routine patches in 2 nops at the offsets specified in 
 43499                                  ;	patch_table. This basically enables the low mem stub to start 
 43500                                  ;	making XMS calls.
 43501                                  ;
 43502                                  ;--------------------------------------------------------------------------
 43503                                  
 43504                                  	; 04/11/2022
 43505                                  	; (MSDOS 5.0 MSDOS.SYS)
 43506                                  	; DOSCODE:0BC50h
 43507                                  
 43508                                  patch_table:	; label	byte
 43509                                  	;dw	offset dosdata:i0patch
 43510                                  	;dw	offset dosdata:i20patch
 43511                                  	;dw	offset dosdata:i21patch
 43512                                  	;dw	offset dosdata:i25patch
 43513                                  	;dw	offset dosdata:i26patch
 43514                                  	;dw	offset dosdata:i27patch
 43515                                  	;dw	offset dosdata:i2fpatch
 43516                                  	;dw	offset dosdata:cpmpatch
 43517 00007B21 [7010]                  	dw	i0patch
 43518 00007B23 [7A10]                  	dw	i20patch
 43519 00007B25 [8410]                  	dw	i21patch
 43520 00007B27 [8E10]                  	dw	i25patch
 43521 00007B29 [9810]                  	dw	i26patch
 43522 00007B2B [A210]                  	dw	i27patch
 43523 00007B2D [AC10]                  	dw	i2fpatch
 43524 00007B2F [B610]                  	dw	cpmpatch
 43525                                  
 43526                                  patch_table_size equ ($-patch_table)/2
 43527                                  
 43528                                  patch_in_nops:
 43529 00007B31 50                      	push	ax
 43530 00007B32 56                      	push	si
 43531 00007B33 BE[217B]                	mov	si,patch_table
 43532 00007B36 B89090                  	mov	ax,9090h ; nop, nop
 43533                                  	; 17/12/2022
 43534                                  	; cx = 0
 43535                                  	;mov	cx,8
 43536                                  	;mov	cx,patch_table_size ; 8
 43537 00007B39 B108                    	mov	cl,patch_table_size ; 8
 43538                                  pin_loop:
 43539 00007B3B 2E8B3C                  	mov	di,[cs:si]
 43540 00007B3E AB                      	stosw
 43541                                  	;add	si,2
 43542                                  	; 17/12/2022
 43543 00007B3F 46                      	inc	si
 43544 00007B40 46                      	inc	si
 43545 00007B41 E2F8                    	loop	pin_loop
 43546 00007B43 5E                      	pop	si
 43547 00007B44 58                      	pop	ax
 43548 00007B45 C3                      	retn
 43549                                  
 43550                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43551                                  ; ---------------------------------------------------------------------------
 43552                                  ; MSDOS 5.0 - MSDOS.SYS offset BC77h, file offset 7EA7h
 43553                                  ; ---------------------------------------------------------------------------
 43554                                  
 43555                                  	; 05/12/2022 - temporary ; (paragraph alinment)
 43556                                  DOSCODE_END:
 43557                                  	;times	9 db 0	; db 9 dup(0)
 43558                                  	; 18/12/2022
 43559 00007B46 0000                    	dw	0  ;	times 2 db 0
 43560                                  
 43561                                  ;align 16
 43562                                  	; DOSCODE:BC80h	(MSDOS 5.0 MSDOS.SYS file offset 7EB0h)
 43563                                  	; MSDOS.SYS file offset: 32432 (start of DOSDATA)
 43564                                  
 43565                                  ; ---------------------------------------------------------------------------
 43566                                  
 43567                                  
 43568                                  ;memstrt label word
 43569                                  ; ---------------------------------------------------------------------------
 43570                                  ; MSDOS 6.21 - MSDOS.SYS offset BF69h, file offset 8189h
 43571                                  ; ---------------------------------------------------------------------------
 43572                                  
 43573                                  MEMSTRT: ; 25/04/2019 - Retro DOS v4.0
 43574                                  
 43575                                  ; if not ROMDOS, then we close the dos code segment, otherwise we close
 43576                                  ; the dos initialization segment
 43577                                  
 43578                                  ;ifndef ROMDOS
 43579                                  
 43580                                  ;doscode ends
 43581                                  
 43582                                  ;else
 43583                                  
 43584                                  ;;dosinitseg ends
 43585                                  
 43586                                  ;endif ; ROMDOS
 43587                                  
 43588                                  ;============================================================================
 43589                                  
 43590                                  ; DPUBLIC <ParaRound, cXMM_no_driver, cXMMexit, char_init_loop, charinit>
 43591                                  ; DPUBLIC <check_XMM, continit, dosinttabloop, endlist>
 43592                                  ; DPUBLIC <initiret, iset1, iset2, jumptabloop, nxtentry>
 43593                                  ; DPUBLIC <notmax,  patch_offset, perdrv>
 43594                                  ; DPUBLIC <perunit, po_iset1, po_iset2, po_iset3>
 43595                                  ; DPUBLIC <ps_set1, ps_set2, ps_set3, seg_reinit>
 43596                                  ; DPUBLIC <sr_done, version_fake_table, xxx>
 43597                                  
 43598                                  ;; burasý doscode sonu
 43599                                  
 43600                                  ;============================================================================
 43601                                  ; DOSDATA
 43602                                  ;============================================================================
 43603                                  ; 29/04/2019 - Retro DOS 4.0
 43604                                  
 43605                                  ;[BITS 16]
 43606                                  
 43607                                  ;[ORG 0]
 43608                                  
 43609                                  ; 25/04/2019 - Retro DOS v4.0
 43610                                  
 43611                                  ;============================================================================
 43612                                  ; DOSDATA - MSDOS 6.21 - MSDOS.SYS Offset 0BF70h, file offset 8190h
 43613                                  ;============================================================================
 43614                                  
 43615                                  ;align 16
 43616                                  	; DOSDATA (MSDOS.SYS kernel DATA) segment starts here...
 43617                                  	; (4970 bytes for MSDOS 6.21)
 43618                                  	; (4976 bytes for Retro DOS v4.0, 25/05/2019 modification.)
 43619                                  
 43620                                  ;============================================================================
 43621                                  ; MSCONST.ASM (MSDOS 6.0, 1991)
 43622                                  ;============================================================================
 43623                                  ; 03/11/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43624                                  ; 25/04/2019 - Retro DOS 4.0 (MSDOS 6.21)
 43625                                  ; 16/07/2018 - Retro DOS 3.0	
 43626                                  
 43627                                  ;Break <Initialized data and data used at DOS initialization>
 43628                                  ;----------------------------------------------------------------------------
 43629                                  
 43630                                  ; We need to identify the parts of the data area that are relevant to tasks
 43631                                  ; and those that are relevant to the system as a whole. Under 3.0, the system
 43632                                  ; data will be gathered with the system code. The process data under 2.x will
 43633                                  ; be available for swapping and under 3.0 it will be allocated per-process.
 43634                                  ;
 43635                                  ; The data that is system data will be identified by [SYSTEM] in the comments
 43636                                  ; describing that data item.
 43637                                  
 43638                                  ;DOSDATA SEGMENT
 43639                                  
 43640                                  ; 04/11/2022
 43641                                  ;[ORG 0]
 43642                                  
 43643                                  ; ----------------------------------------------------------------------------
 43644                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43645                                  ; ----------------------------------------------------------------------------
 43646                                  ; DOSDATA segment start offset from beginning of MSDOS.SYS file: 32432 (7EB0h)
 43647                                  ; (3DD0h+7EB0h = 0BC80h) - for MSDOS 5.0 kernel file -
 43648                                  ; ----------------------------------------------------------------------------
 43649                                  
 43650                                  ; 04/11/2022
 43651                                  
 43652                                  ;DOSDATA:0000h
 43653                                  
 43654 00007B48 90<rep 8h>              align 16
 43655                                  
 43656                                  ; ----------------------------------------------------------------------------
 43657                                  ; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43658                                  ; ----------------------------------------------------------------------------
 43659                                  
 43660                                  segment .data  vstart=0 ; 06/12/2022
 43661                                  								
 43662                                  ; ============================================================================
 43663                                  
 43664                                  ; 06/12/2022
 43665                                  ;DOSDATASTART equ $
 43666                                  DOSDATASTART:
 43667                                  
 43668                                  
 43669                                  ;hkn; add 4 bytes to get correct offsets since jmp has been removed in START
 43670                                  
 43671                                  	;; 03/11/2022
 43672                                  	;jmp	DOSINIT		; MSDOS 5.0 - MSDOS.SYS (DOSDATA:0000h)
 43673                                  
 43674                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43675                                  	;db	4 dup (?)	
 43676 00000000 00<rep 4h>              	times	4 db 0
 43677                                  
 43678                                  	; 29/04/2019 - Retro DOS v4.0 modification
 43679                                  	;dw 	_$STARTCODE ; DOSCODE offset and/or size of DOSDATA
 43680                                  	;dw	0
 43681                                  
 43682                                  	;EVEN
 43683                                  
 43684                                  ;align 2
 43685                                  
 43686                                  ; WANGO!!! The following word is used by SHARE and REDIR to determin data
 43687                                  ; area compatability. This location must be incremented EACH TIME the data
 43688                                  ; area here gets mucked with.
 43689                                  ;
 43690                                  ; Also, do NOT change this position relative to DOSDATA:0.
 43691                                  
 43692                                  MSCT001S:	; LABEL BYTE
 43693                                  	
 43694                                  DataVersion:	
 43695 00000004 0100                    	dw	1	;AC000; [SYSTEM] version number for DOS DATA
 43696                                  
 43697                                  ;hkn; add 8 bytes to get correct offsets since BugTyp, BugLev and "BUG " has 
 43698                                  ;hkn; been removed to DOSCODE above
 43699                                  
 43700                                  ;M044
 43701                                  ; First part of save area for saving last para of Window memory
 43702                                  
 43703                                  WinoldPatch1:	; db 8 dup (?)	;M044
 43704 00000006 00<rep 8h>              	times	8 db 0
 43705                                  
 43706                                  	; MSDOS 6.21 DOSDATA:000Eh
 43707                                  MYNUM:			; Offset 000Eh
 43708 0000000E 0000                    	dw	0	; [SYSTEM] A number that goes with MYNAME
 43709                                  FCBLRU: 		; [SYSTEM] LRU count for FCB cache
 43710 00000010 0000                    	dw	0
 43711                                  OpenLRU:
 43712 00000012 0000                    	dw	0	; [SYSTEM] LRU count for FCB cache opens
 43713                                  OEM_HANDLER: 		
 43714 00000014 FFFFFFFF                	dd	-1	; [SYSTEM] Pointer to OEM handler code	
 43715                                  
 43716                                  ;	BUGBUG - who uses LeaveAddr?  What if we want to rework the
 43717                                  ;;			way that we leave DOS???? - jgl
 43718                                  
 43719                                  LeaveAddr:
 43720 00000018 [0404]                  	dw	LeaveDOS  ; <<OFFSET DOSCODE:LeaveDOS>> ; [SYSTEM]
 43721                                  RetryCount:		
 43722 0000001A 0300                    	dw	3	; [SYSTEM] Share retries
 43723                                  RetryLoop:
 43724 0000001C 0100                    	dw	1	; [SYSTEM] Share retries
 43725                                  LastBuffer:
 43726 0000001E FFFFFFFF                	dd	-1	; [SYSTEM] Buffer queue recency pointer
 43727                                  CONTPOS:
 43728 00000022 0000                    	dw	0	; [SYSTEM] location in buffer of next read
 43729                                  arena_head:
 43730 00000024 0000                    	dw	0	; [SYSTEM] Segment # of first arena in memory
 43731                                  
 43732                                  ;; 16/07/2018
 43733                                  ;;***************************************************************************
 43734                                  ;; NOTE: INT 21H AH=52H !  (http://stanislavs.org/helppc/int_21-52.html)
 43735                                  ;;***************************************************************************
 43736                                  ;; INT 21,52 - Get Pointer to DOS "INVARS" (Undocumented)
 43737                                  ;;
 43738                                  ;;	AH = 52h
 43739                                  ;;
 43740                                  ;;	on return:
 43741                                  ;;	ES:BX = pointer to DOS "invars", a table of pointers used by DOS.
 43742                                  ;;		Known "invars" fields follow (varies with DOS version):
 43743                                  ;;
 43744                                  ;;	Offset Size		 Description
 43745                                  ;;
 43746                                  ;;	 -12   word   sharing retry count (DOS 3.1-3.3)
 43747                                  ;;	 -10   word   sharing retry delay  (DOS 3.1-3.3)
 43748                                  ;;	  -8   dword  pointer to current disk buffer (DOS 3.x)
 43749                                  ;;	  -4   word   pointer in DOS code segment of unread CON input;
 43750                                  ;;		      0 indicates no unread input (DOS 3.x)
 43751                                  ;;	  -2   word   segment of first Memory Control Block (MCB)
 43752                                  ;;	  00   dword  pointer to first DRIVE PARAMETER TABLE (A:) in chain
 43753                                  ;;	  04   dword  pointer to DOS System File Table (SFT)
 43754                                  ;;	  08   dword  pointer to $CLOCK device driver
 43755                                  ;;	  0C   dword  pointer to CON device driver
 43756                                  ;;	  10   byte   number of logical drives in system
 43757                                  ;;	  11   word   maximum bytes/block of any block device
 43758                                  ;;	  13   dword  pointer to DOS cache buffer header
 43759                                  ;;	  17 18bytes  NUL device header, first 4 bytes of device header
 43760                                  ;;		      point to the next device in device chain
 43761                                  ;;
 43762                                  ;;***************************************************************************
 43763                                  
 43764                                  ; The following block of data is used by SYSINIT. 
 43765                                  ; Do not change the order or size of this block
 43766                                  
 43767                                  ;SYSINITVAR:
 43768                                  ;----------------------------------------------------------------------------
 43769                                  SYSINITVARS:
 43770                                  DPBHEAD:
 43771 00000026 00000000                	dd	0	; [SYSTEM] Pointer to head of DPB-FAT list
 43772                                  SFT_ADDR:
 43773 0000002A [CC000000]              	dd	SFTABL	; [SYSTEM] Pointer to first SFT table
 43774                                  BCLOCK:
 43775 0000002E 00000000                	dd	0	; [SYSTEM] The CLOCK device
 43776                                  BCON:
 43777 00000032 00000000                	dd	0	; [SYSTEM] Console device entry points
 43778                                  MAXSEC:
 43779 00000036 8000                    	dw	128	; [SYSTEM] Maximum allowed sector size
 43780                                  BUFFHEAD:
 43781 00000038 00000000                	dd	0	; [SYSTEM] Pointer to head of buffer queue
 43782                                  CDSADDR:
 43783 0000003C 00000000                	dd	0	; [SYSTEM] Pointer to curdir structure table
 43784                                  SFTFCB:
 43785 00000040 00000000                	dd	0	; [SYSTEM] pointer to FCB cache table
 43786                                  KEEPCOUNT:
 43787 00000044 0000                    	dw	0	; [SYSTEM] count of FCB opens to keep
 43788                                  NUMIO:
 43789 00000046 00                      	db	0	; [SYSTEM] Number of disk tables
 43790                                  CDSCOUNT:
 43791 00000047 00                      	db	0	; [SYSTEM] Number of CDS structures in above
 43792                                  
 43793                                  ; A fake header for the NUL device
 43794                                  NULDEV:
 43795 00000048 00000000                	dd	0	; [SYSTEM] Link to rest of device list
 43796                                  	;dw	8004h
 43797 0000004C 0480                    	dw	DEVTYP|ISNULL ; [SYSTEM] Null device attributes
 43798 0000004E [C60D]                  	dw	SNULDEV	; [SYSTEM] Strategy entry point
 43799 00000050 [CC0D]                  	dw	INULDEV	; [SYSTEM] Interrupt entry point
 43800 00000052 4E554C2020202020        	db	"NUL     " ; [SYSTEM] Name of null device
 43801                                  SPLICES:
 43802 0000005A 00                      	db	0	; [SYSTEM] TRUE => splices being done
 43803                                  
 43804                                  Special_Entries:
 43805 0000005B 0000                    	dw	0	; [SYSTEM] address of special entries ;AN000;
 43806                                  UU_IFS_DOS_CALL:
 43807 0000005D 00000000                	dd	0	; [SYSTEM] entry for IFS DOS service ;AN000;
 43808                                  ; 
 43809                                  ; UU_IFS_HEADER:
 43810                                  ; 	dd	0	; [SYSTEM] IFS header chain ;AN000;
 43811                                  
 43812                                  ChkCopyProt:
 43813 00000061 0000                    	dw	0	; M068
 43814                                  A20OFF_PSP:
 43815 00000063 0000                    	dw	0	; M068
 43816                                  BUFFERS_PARM1:
 43817 00000065 0000                    	dw	0	; [SYSTEM] value of BUFFERS= ,m	;AN000;
 43818                                  BUFFERS_PARM2:
 43819 00000067 0000                    	dw	0	; [SYSTEM] value of BUFFERS= ,n ;AN000;
 43820                                  BOOTDRIVE:
 43821 00000069 00                      	db	0	; [SYSTEM] the boot drive ;AN000;
 43822                                  DDMOVE:
 43823 0000006A 00                      	db	0 	; [SYSTEM] 1 if we need DWORD move ;AN000;
 43824                                  EXT_MEM_SIZE:
 43825 0000006B 0000                    	dw	0	; [SYSTEM] extended memory size	;AN000;
 43826                                  
 43827                                  HASHINITVAR: ; LABEL   WORD	; AN000;
 43828                                  ;
 43829                                  ; Replaced by next two declarations
 43830                                  ;
 43831                                  ;UU_BUF_HASH_PTR:
 43832                                  ;	dd	0	; [SYSTEM] buffer Hash table addr
 43833                                  ;UU_BUF_HASH_COUNT:
 43834                                  ;	dw	1	; [SYSTEM] number of Hash entries
 43835                                  
 43836                                  BufferQueue:
 43837 0000006D 00000000                	dd	0	; [SYSTEM] Head of the buffer Queue
 43838                                  DirtyBufferCount:
 43839 00000071 0000                    	dw	0	; [SYSTEM] Count of Dirty buffers in the Que
 43840                                  			; BUGBUG ---- change to byte
 43841                                  SC_CACHE_PTR:
 43842 00000073 00000000                	dd	0	; [SYSTEM] secondary cache pointer
 43843                                  SC_CACHE_COUNT:
 43844 00000077 0000                    	dw	0 	; [SYSTEM] secondary cache count
 43845                                  BuffInHMA:
 43846 00000079 00                      	db	0	; Flag to indicate that buffs are in HMA
 43847                                  LoMemBuff:
 43848 0000007A 00000000                	dd	0	; Ptr to intermediate buffer
 43849                                  			;  in Low mem when buffs are in HMA
 43850                                  ;
 43851                                  ; All variables which have UU_ as prefix can be reused for other
 43852                                  ; purposes and can be renamed. All these variables were used for
 43853                                  ; EMS support of Buffer Manager. Now they are useless for Buffer
 43854                                  ; manager ---- MOHANS
 43855                                  ;
 43856                                  	;I_am	UU_BUF_EMS_FIRST_PAGE,3,<0,0,0>  
 43857                                  UU_BUF_EMS_FIRST_PAGE:	
 43858 0000007E 000000                  	db	0,0,0	; holds the first page above 640K
 43859                                  
 43860                                  	;;I_am	UU_BUF_EMS_NPA640,WORD,<0> ; holds the number of pages 
 43861                                  ;UU_BUF_EMS_NPA640:			   ; above 640K	
 43862                                  ;	dw	0			
 43863                                  
 43864                                  CL0FATENTRY:
 43865 00000081 FFFF                    	dw	-1	; M014:	Holds the data that
 43866                                  			; is used in pack/unpack rts.
 43867                                  			; in fat.asm if cluster 0 is specified.
 43868                                  			; SR;
 43869                                  IoStatFail:
 43870 00000083 00                      	db	0	; IoStatFail has been added to 
 43871                                  			; record a fail on an I24 
 43872                                  			; issued from IOFUNC on a status call. 
 43873                                  
 43874                                  ;***	I_am	UU_BUF_EMS_MODE,BYTE,<-1>	; EMS mode 	;AN000;
 43875                                  ;***	I_am	UU_BUF_EMS_HANDLE,BYTE		; buffer EMS handle ;AN000;
 43876                                  ;***	I_am	UU_BUF_EMS_PAGE_FRAME,WORD ,<-1>; EMS page frame # ;AN000;
 43877                                  ;***	I_am	UU_BUF_EMS_SEG_CNT,WORD,<1>	; EMS seg count	;AN000;
 43878                                  ;***	I_am	UU_BUF_EMS_PFRAME,WORD		; EMS page frame seg address ;AN000;
 43879                                  ;***	I_am	UU_BUF_EMS_RESERV,WORD,<0> 	; reserved	;AN000;
 43880                                  ;
 43881                                  ;***	I_am	UU_BUF_EMS_MAP_BUFF,1,<0>	; this is not used to save the 
 43882                                  						; state of the 	buffers page.
 43883                                  						; This one byte is retained to 
 43884                                  						; keep the size of this data 
 43885                                  						; block the same.;
 43886                                  ALLOCMSAVE:
 43887 00000084 00                      	db	0	; M063: temp var. used to 
 43888                                  			; M063: save alloc method in
 43889                                  			; M063: msproc.asm
 43890                                  A20OFF_COUNT:
 43891 00000085 00                      	db	0	; M068: indiactes the # of 
 43892                                  			; M068: int 21 calls for 
 43893                                  			; M068: which A20 is off
 43894                                  DOS_FLAG:
 43895 00000086 00                      	db	0	; see DOSSYM.INC for Bit 
 43896                                  			; definitions
 43897                                  UNPACK_OFFSET:
 43898 00000087 0000                    	dw	0	; saves pointer to the start
 43899                                  			; of unpack code in exepatch.
 43900                                  			; asm.
 43901                                  UMBFLAG:
 43902 00000089 00                      	db	0 	; M003: bit 0 indicates the 
 43903                                  			; M003: link state of the UMBs
 43904                                  			; M003: whether linked or not 
 43905                                  			; M003: to the DOS arena chain
 43906                                  SAVE_AX:
 43907 0000008A 0000                    	dw	0	; M000: temp varibale to store ax
 43908                                  			; M000: in msproc.asm
 43909                                  UMB_HEAD:
 43910 0000008C FFFF                    	dw	-1	; M000: this is initialized to  
 43911                                  			; M000: the first umb arena by 
 43912                                  			; M000: BIOS sysinit.
 43913                                  START_ARENA:
 43914 0000008E 0100                    	dw	1	; M000: this is the first arena 
 43915                                  			; M000: from which DOS will 
 43916                                  			; M000: start its scan for alloc.
 43917                                  
 43918                                  ; End of SYSINITVar block
 43919                                  ;----------------------------------------------------------------------------
 43920                                  
 43921                                  ; 25/04/2019 - Retro DOS v4.0
 43922                                  
 43923                                  ; 16/07/2018
 43924                                  ; MSDOS 3.3 (& MDOS 6.0)
 43925                                  
 43926                                  ;
 43927                                  ; Sharer jump table
 43928                                  ;
 43929                                  
 43930                                  ;PUBLIC	JShare
 43931                                  	;EVEN
 43932                                  
 43933                                  ;JShare	LABEL	DWORD
 43934                                  ;	DW	OFFSET DOSCODE:BadCall, 0
 43935                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	1   MFT_enter
 43936                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	2   MFTClose
 43937                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	3   MFTclU
 43938                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	4   MFTCloseP
 43939                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	5   MFTCloN
 43940                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	6   set_block
 43941                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	7   clr_block
 43942                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	8   chk_block
 43943                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	9   MFT_get
 43944                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	10  ShSave
 43945                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	11  ShChk
 43946                                  ;	DW	OFFSET DOSCODE:OKCall , 0  ;	12  ShCol
 43947                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	13  ShCloseFile
 43948                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	14  ShSU
 43949                                  
 43950                                  align 2
 43951                                  
 43952                                  JShare:
 43953 00000090 [FD06]0000              		DW	BadCall,0
 43954 00000094 [0107]0000              MFT_enter:	DW	OKCall, 0  ; 1   MFT_enter
 43955 00000098 [0107]0000              MFTClose:	DW	OKCall, 0  ; 2   MFTClose
 43956 0000009C [FD06]0000              MFTclU:		DW	BadCall,0  ; 3   MFTclU
 43957 000000A0 [FD06]0000              MFTCloseP:	DW	BadCall,0  ; 4   MFTCloseP
 43958 000000A4 [FD06]0000              MFTCloN:	DW	BadCall,0  ; 5   MFTCloN
 43959 000000A8 [FD06]0000              set_block:	DW	BadCall,0  ; 6   set_block
 43960 000000AC [FD06]0000              clr_block:	DW	BadCall,0  ; 7   clr_block
 43961 000000B0 [0107]0000              chk_block:	DW	OKCall, 0  ; 8   chk_block
 43962 000000B4 [FD06]0000              MFT_get:	DW	BadCall,0  ; 9   MFT_get
 43963 000000B8 [FD06]0000              ShSave:		DW	BadCall,0  ; 10  ShSave
 43964 000000BC [FD06]0000              ShChk:		DW	BadCall,0  ; 11  ShChk
 43965 000000C0 [0107]0000              ShCol:		DW	OKCall, 0  ; 12  ShCol
 43966 000000C4 [FD06]0000              ShCloseFile:	DW	BadCall,0  ; 13  ShCloseFile
 43967 000000C8 [FD06]0000              ShSU:		DW	BadCall,0  ; 14  ShSU
 43968                                  
 43969                                  
 43970                                  ;============================================================================
 43971                                  ; CONST2.ASM (MSDOS 6.0, 1991)
 43972                                  ;============================================================================
 43973                                  ; 25/04/2019 - Retro DOS 4.0 
 43974                                  ; 16/07/2018 - Retro DOS 3.0	
 43975                                  
 43976                                  ;Break <Initialized data and data used at DOS initialization>
 43977                                  ;----------------------------------------------------------------------------
 43978                                  
 43979                                  ; We need to identify the parts of the data area that are relevant to tasks
 43980                                  ; and those that are relevant to the system as a whole.  Under 3.0, the system
 43981                                  ; data will be gathered with the system code.  The process data under 2.x will
 43982                                  ; be available for swapping and under 3.0 it will be allocated per-process.
 43983                                  ;
 43984                                  ; The data that is system data will be identified by [SYSTEM] in the comments
 43985                                  ; describing that data item.
 43986                                  
 43987                                  ;DOSDATA SEGMENT WORD PUBLIC 'DATA'
 43988                                  
 43989                                  ;
 43990                                  ; Table of routines for assignable devices
 43991                                  ;
 43992                                  ; MSDOS allows assignment if the following standard devices:
 43993                                  ;   stdin  (usually CON input)
 43994                                  ;   stdout (usually CON output)
 43995                                  ;   auxin  (usually AUX input)
 43996                                  ;   auxout (usually AUX output)
 43997                                  ;   stdlpt (usually PRN output)
 43998                                  ;
 43999                                  ; SPECIAL NOTE:
 44000                                  ;   Status of a file is a strange idea. We choose to handle it in this manner:
 44001                                  ;   If we're not at end-of-file, then we always say that we have a character.
 44002                                  ;   Otherwise, we return ^Z as the character and set the ZERO flag. In this
 44003                                  ;   manner we can support program written under the old DOS (they use ^Z as EOF
 44004                                  ;   on devices) and programs written under the new DOS (they use the ZERO flag
 44005                                  ;   as EOF).
 44006                                  
 44007                                  ; Default SFTs for boot up
 44008                                  
 44009                                  		;PUBLIC	SFTABL
 44010                                  
 44011                                  SFTABL:	   ; LABEL   DWORD		; [SYSTEM] file table
 44012 000000CC FFFF                    		DW -1			; [SYSTEM] link to next table
 44013 000000CE FFFF                    		DW -1			; [SYSTEM] link seg to next table
 44014 000000D0 0500                    		DW sf_default_number	; [SYSTEM] Number of entries in table
 44015                                  		;times 295 db 0 ; MSDOS 6.0
 44016 000000D2 00<rep 127h>            		times (sf_default_number*sf_entry_size) db 0
 44017                                  
 44018                                  ; the next two variables relate to the position of the logical stdout/stdin
 44019                                  ; cursor. They are only meaningful when stdin/stdout are assigned to the
 44020                                  ; console.
 44021                                  		; DOSDATA:01F9h (MSDOS 6.21)
 44022 000001F9 00                      CARPOS:		db 0			; [SYSTEM] cursor position in stdin
 44023 000001FA 00                      STARTPOS:	db 0			; [SYSTEM] position of cursor at beginning
 44024                                  					;	   of buffered input call
 44025 000001FB 00<rep 80h>             INBUF:		times 128 db 0		; [SYSTEM] general device input buffer
 44026 0000027B 00<rep 83h>             CONBUF:		times 131 db 0		; [SYSTEM] The rest of INBUF and console buffer
 44027                                  		; DOSDATA:02FEh (MSDOS 6.21)
 44028 000002FE 00                      PFLAG:		db 0			; [SYSTEM] printer echoing flag
 44029 000002FF 00                      VERFLG:		db 0			; [SYSTEM] Initialize with verify off
 44030 00000300 03                      CHARCO:		db 00000011b		; [SYSTEM] Allows statchks every 4 chars...
 44031                                  switch_character:
 44032 00000301 2F                      chSwitch:	db '/'			; UNUSED - obsolete datum, can be reused
 44033 00000302 00                      AllocMethod:	db 0			; [SYSTEM] how to alloc first(best)last
 44034 00000303 00                      fShare:		db 0			; [SYSTEM] TRUE => sharing installed
 44035 00000304 01                      DIFFNAM:	db 1			; [SYSTEM] Indicates when MYNAME has changed
 44036 00000305 20<rep 10h>             MYNAME:		times 16 db 20h		; [SYSTEM] My network name
 44037                                  
 44038                                  ; The following table is a list of addresses that the sharer patches to be
 44039                                  ; PUSH AX to enable the critical sections
 44040                                  
 44041                                  		; DOSDATA:0315h (MSDOS 6.21)
 44042                                  
 44043                                  ;PUBLIC	CritPatch
 44044                                  
 44045                                  CritPatch:	; LABEL WORD
 44046                                  
 44047                                  ;IRP sect,<critDisk,critDevice>
 44048                                  
 44049                                  ;IF (NOT REDIRECTOR) AND (NOT SHAREF)
 44050                                  ;
 44051                                  ;SR; Change code patch address to a variable in data segment
 44052                                  ;
 44053                                  ;       dw OFFSET DOSDATA: redir_patch
 44054                                  ;       dw OFFSET DOSDATA: redir_patch
 44055                                  ;
 44056                                  ;;hkn	Short_Addr  E&sect
 44057                                  ;;hkn	Short_Addr  L&sect
 44058                                  ;
 44059                                  ;ELSE
 44060                                  ;	DW	0
 44061                                  ;	DW	0
 44062                                  ;ENDIF
 44063                                  ;ENDM
 44064                                  ;	DW	0
 44065                                  
 44066                                  	; 25/07/2019 - Retro DOS v4.0 (MSDOS 6.21)
 44067                                   
 44068 00000315 [0C0D]                  	dw 	redir_patch
 44069 00000317 [0C0D]                  	dw 	redir_patch			
 44070 00000319 [0C0D]                  	dw	redir_patch
 44071 0000031B [0C0D]                  	dw 	redir_patch
 44072                                  
 44073 0000031D 0000                    	dw	0
 44074                                  
 44075                                  ; WARNING!!! PRINT and PSPRINT *REQUIRE* ErrorMode to precede INDOS.
 44076                                  ; Also, IBM server 1.0 requires this also.
 44077                                  
 44078                                  	;EVEN			; Force swap area to start on word boundry
 44079 0000031F 90                      align 2
 44080                                  	;PUBLIC	SWAP_START
 44081                                  SWAP_START:	; LABEL BYTE
 44082 00000320 00                      ERRORMODE:	db 0		; Flag for INT 24 processing
 44083 00000321 00                      INDOS:		db 0		; DOS status for interrupt processing
 44084 00000322 FF                      WPERR:		db -1		; Write protect error flag
 44085 00000323 00                      EXTERR_LOCUS:	db 0		; Extended Error Locus
 44086 00000324 0000                    EXTERR:		dw 0		; Extended Error code
 44087                                  
 44088                                  ;WARNING Following two bytes Accessed as word in $GetExtendedError
 44089 00000326 00                      EXTERR_ACTION:	db 0		; Extended Error Action
 44090 00000327 00                      EXTERR_CLASS:	db 0		; Extended Error Class
 44091                                  ; end warning
 44092                                   
 44093 00000328 00000000                EXTERRPT:	dd 0		; Extended Error pointer
 44094                                  
 44095 0000032C 80000000                DMAADD:		dd 80h		; User's disk transfer address (disp/seg)
 44096 00000330 0000                    CurrentPDB:	dw 0		; Current process identifier
 44097 00000332 0000                    ConC_Spsave:	dw 0		; saved SP before ^C
 44098 00000334 0000                    exit_code:	dw 0		; exit code of last proc.
 44099 00000336 00                      CURDRV:		db 0		; Default drive (init A)
 44100 00000337 00                      CNTCFLAG:	db 0		; ^C check in dispatch disabled
 44101                                  ;				; F.C. 2/17/86
 44102 00000338 00                      CPSWFLAG:	db 0		; Code Page Switching Flag  DOS 4.00
 44103 00000339 00                      CPSWSAVE:	db 0		; copy of above in case of ABORT
 44104                                  ;align 2
 44105                                  SWAP_ALWAYS:	; 05/08/2018
 44106 0000033A 0000                    USER_IN_AX:	dw 0		; User INPUT AX value (used for
 44107                                  				;   extended error type stuff.
 44108                                  				;   NOTE: does not have Correct value on
 44109                                  				;   1-12, OEM, Get/Set CurrentPDB,
 44110                                  				;   GetExtendedError system calls)
 44111 0000033C 0000                    PROC_ID:	dw 0		; PID for sharing (0 = local)
 44112 0000033E 0000                    USER_ID:	dw 0		; Machine for sharing (0 = local)
 44113 00000340 0000                    FirstArena:	dw 0		; first free block found
 44114 00000342 0000                    BestArena:	dw 0		; best free block found
 44115 00000344 0000                    LastArena:	dw 0		; last free block found
 44116 00000346 0000                    ENDMEM:		dw 0		; End of memory used in DOSINIT
 44117 00000348 0000                    LASTENT:	dw 0		; Last entry for directory search
 44118 0000034A 00                      FAILERR:	db 0		; NZ if user did FAIL on I 24
 44119 0000034B 00                      ALLOWED:	db 0		; Allowed I 24 answers (see allowed_)
 44120 0000034C 00                      NoSetDir:	db 0		; true -> do not set directory
 44121 0000034D 00                      DidCTRLC:	db 0		; true -> we did a ^C exit
 44122 0000034E 00                      SpaceFlag:	db 0		; true -> embedded spaces are allowed in FC
 44123                                  
 44124                                  ; Warning!  The following items are accessed as a WORD in TIME.ASM
 44125                                  	;EVEN
 44126 0000034F 90                      align 2
 44127                                  		; DOSDATA:0350h (MSDOS 6.21)
 44128 00000350 00                      DAY:		db 0		; Day of month
 44129 00000351 00                      MONTH:		db 0		; Month of year
 44130 00000352 0000                    YEAR:		dw 0		; Year (with century)
 44131 00000354 FFFF                    DAYCNT:		dw -1		; Day count from beginning of year
 44132 00000356 00                      WEEKDAY:	db 0		; Day of week
 44133                                  ; end warning
 44134                                  
 44135 00000357 00                      CONSWAP:	db 0		; TRUE => console was swapped during device read
 44136 00000358 01                      IDLEINT:	db 1		; TRUE => idle int is allowed
 44137 00000359 00                      fAborting:	db 0		; TRUE => abort in progress
 44138                                  
 44139                                  ; Combination of all device call parameters
 44140                                  	;PUBLIC	DEVCALL 	;
 44141                                  ;DEVCALL SRHEAD	<>		; basic header for disk packet
 44142                                  DEVCALL: ; 08/08/2018
 44143 0000035A 00                      DEVCALL_REQLEN:  db 0 		;Length in bytes of request block
 44144 0000035B 00                      DEVCALL_REQUNIT: db 0		;Device unit number
 44145 0000035C 00                      DEVCALL_REQFUNC: db 0		;Type of request
 44146 0000035D 0000                    DEVCALL_REQSTAT: dw 0		;Status Word
 44147 0000035F 00<rep 8h>                       times 8 db 0		;Reserved for queue links
 44148                                  
 44149                                  	;PUBLIC	CALLUNIT
 44150                                  CALLUNIT: ; LABEL   BYTE	; unit number for disk
 44151                                  CALLFLSH: ; LABEL   WORD	;
 44152 00000367 00                      CALLMED:	db 0		; media byte
 44153                                  CALLBR:	  ; LABEL   DWORD	;
 44154                                  	;PUBLIC	CALLXAD 	;
 44155                                  CALLXAD:  ; LABEL   DWORD	;
 44156 00000368 00                      CALLRBYT:	db 0		;
 44157                                  	;PUBLIC	CALLVIDM	;
 44158                                  CALLVIDM: ; LABEL   DWORD	;
 44159 00000369 00<rep 3h>              	times 3 db 0	;
 44160                                  	;PUBLIC CallBPB		;
 44161                                  CALLBPB:  ; LABEL   DWORD	;
 44162                                  CALLSCNT:			;
 44163 0000036C 0000                    		dw 0		;
 44164                                  	;PUBLIC	CALLSSEC	;
 44165                                  CALLSSEC: ; LABEL   WORD	;
 44166 0000036E 0000                    		dw 0		;
 44167 00000370 00000000                CALLVIDRW:	dd 0		;
 44168                                  ;MSDOS 6.0
 44169 00000374 00000000                CALLNEWSC:	dd 0		; starting sector for >32mb
 44170 00000378 00000000                CALLDEVAD:	dd 0		; stash for device entry point
 44171                                  
 44172                                  ; Same as above for I/O calls	;
 44173                                  				;
 44174                                  	;PUBLIC	IOCall		;
 44175                                  ;IOCALL	SRHEAD	<>		;
 44176                                  IOCALL:	; 07/08/2018
 44177 0000037C 00                      IOCALL_REQLEN:	db 0		;Length in bytes of request block	
 44178 0000037D 00                      IOCALL_REQUNIT:	db 0		;Device unit number
 44179 0000037E 00                      IOCALL_REQFUNC: db 0		;Type of request
 44180 0000037F 0000                    IOCALL_REQSTAT: dw 0		;Status Word
 44181 00000381 00<rep 8h>              	times 8	db 0		;Reserved for queue links
 44182                                  IOFLSH:	  ; LABEL   WORD	;
 44183                                          ;PUBLIC  IORCHR		;
 44184                                  IORCHR:	  ; LABEL   BYTE	;
 44185 00000389 00                      IOMED:		db 0		;
 44186 0000038A 00000000                IOXAD:		dd 0		;
 44187 0000038E 0000                    IOSCNT:		dw 0		;	
 44188 00000390 0000                    IOSSEC:		dw 0		;
 44189                                  
 44190                                  ; Call struct for DSKSTATCHK	;
 44191 00000392 0E                      DSKSTCALL:	db DRDNDHL 	; = 14
 44192 00000393 00                      		db 0
 44193 00000394 05                      DSKSTCOM:	db DEVRDND	; = 5
 44194 00000395 0000                    DSKSTST:	dw 0		;
 44195 00000397 00<rep 8h>              	times 8	db 0		;
 44196 0000039F 00                      DSKCHRET:	db 0		;
 44197                                  
 44198                                  ;hkn; short_addr has been changed to provide offset in DOSCODE.
 44199                                  ;hkn; deviobuf is in DATA seg (DOSDATA)
 44200                                  ;hkn   short_addr  DEVIOBUF	;
 44201                                  	
 44202 000003A0 [BC03]                  DEVIOBUF_PTR	dw DEVIOBUF
 44203 000003A2 0000                    DOSSEG_INIT	dw 0		; DOS segment set at Init
 44204 000003A4 0100                    DSKSTCNT:	dw 1		;
 44205 000003A6 0000                    		dw 0		;
 44206                                  
 44207 000003A8 00                      CreatePDB:	db 0		; flag for creating a process
 44208                                  
 44209                                  ;MSDOS 6.0
 44210                                  Lock_Buffer:	; LABEL  DWORD	;MS. DOS Lock Buffer for Ext Lock
 44211 000003A9 00000000                		dd 0		;MS. position
 44212 000003AD 00000000                		dd 0		;MS. length
 44213                                  
 44214                                  ;hkn; the foll. was moved from dosmes.asm.
 44215                                  
 44216                                  	;EVEN
 44217 000003B1 90                      align 2				; needed to maintain offsets
 44218                                  
 44219                                  		; DOSDATA:03B2h (MSDOS 6.21)
 44220                                  USERNUM:
 44221 000003B2 0000                     		dw 0		; 24 bit user number
 44222 000003B4 00                      		db 0
 44223                                  ;IF IBM
 44224                                  ;IF IBMCOPYRIGHT
 44225                                  ;OEMNUM:	DB 0		; 8 bit OEM number
 44226                                  ;ELSE
 44227                                  ;OEMNUM:	DB 0FFh		; 8 bit OEM number
 44228                                  ;ENDIF
 44229                                  ;ELSE
 44230 000003B5 FF                      OEMNUM:		DB 0FFh
 44231                                  ;ENDIF
 44232                                  
 44233                                  ;============================================================================
 44234                                  ; MS_DATA.ASM (MSDOS 6.0, 1991)
 44235                                  ;============================================================================
 44236                                  ; 25/04/2019 - Retro DOS 4.0
 44237                                  
 44238                                  ; Retro DOS v4.0 NOTE: (by Erdogan Tan, 25/04/2019)
 44239                                  ; ----------------------------------------------------------
 44240                                  ; This data section which was named as uninitialized data
 44241                                  ; (as overlayed by initialization code) but follows 
 44242                                  ; initialized data section from DOSDATA:03B6h address
 44243                                  ; (in otherwords, the method is different than MSDOS 3.3,
 44244                                  ; and there is not overlaying..)
 44245                                  ; **********************************************************
 44246                                  ; Reference: MSDOS 6.21 kernel DOSDATA section (4970 bytes)
 44247                                  ; follows DOSCODE section in the kernel file (MSDOS.SYS) 
 44248                                  ; (it is located at offset 0BF70h, file offset 0BF70h-3DE0h) 
 44249                                  ; but starts from offset 0 (ORG 0) and ends at offset 1370h.
 44250                                  ; TIMEBUF is at offset 03B6h.
 44251                                  ; **********************************************************	
 44252                                  
 44253                                  ;Break <Uninitialized data overlayed by initialization code>
 44254                                  ;----------------------------------------------------------------------------
 44255                                  ;DOSDATA    SEGMENT WORD PUBLIC 'DATA'
 44256                                  ; Init code overlaps with data area below
 44257                                  
 44258                                  ; 	ORG     0
 44259                                  
 44260                                  MSDAT001S:	; label byte
 44261                                  
 44262                                  ; DOSDATA:03B6h	; MSDOS 6.21 (MSDOS.SYS, file offset 0BF70h-3DE0h+3B6h)
 44263                                  TIMEBUF: ;	times 6 db 0
 44264 000003B6 0000<rep 3h>            	times 3 dw	0		; Time read from clock device
 44265 000003BC 0000                    DEVIOBUF:	dw	0		; Buffer for I/O under file assignment
 44266                                  
 44267                                  ; The following areas are used as temp buffer in EXEC system call
 44268                                  
 44269                                  ; DOSDATA:03BEh
 44270                                  OPENBUF: ;times 64  dw	0
 44271 000003BE 00<rep 80h>             	times	128 db	0		; buffer for name operations
 44272                                  RENBUF:	
 44273 0000043E 00<rep 80h>             	times	128 db	0		; buffer for rename destination
 44274                                  
 44275                                  ; Buffer for search calls
 44276                                  SEARCHBUF:	
 44277 000004BE 00<rep 35h>             	times	53  db	0		; internal search buffer
 44278                                  DUMMYCDS:  ;times 88 db 0
 44279 000004F3 00<rep 58h>             	times	curdirLen db 0
 44280                                  
 44281                                  ; End of contiguous buffer
 44282                                   
 44283                                  ; Temporary directory entry for use by many routines. Device directory
 44284                                  ; entries (bogus) are built here.
 44285                                  
 44286                                  ; DOSDATA:054Bh
 44287                                  
 44288                                  DEVFCB:	; LABEL   BYTE			; Uses NAME1, NAME2, combined
 44289                                  
 44290                                  ; WARNING..  do not alter position of NAME1 relative to DEVFCB
 44291                                  ; without first examining BUILD_DEVICE_ENT. Look carefully at DOS_RENAME
 44292                                  ; as well as it is the only guy who uses NAME2 and DESTSTART.
 44293                                  
 44294                                  NAME1:	
 44295 0000054B 00<rep Ch>                      times 	12 db	0		; File name buffer
 44296                                  NAME2:
 44297 00000557 00<rep Dh>              	times	13 db	0 		;
 44298                                  DESTSTART:
 44299 00000564 0000                    	dw	0			;
 44300                                          ;DB      ((SIZE DIR_ENTRY) - ($ - DEVFCB)) DUP (?)
 44301                                  	;times	5  db	0
 44302 00000566 00<rep 5h>              	times	((dir_entry.size)-($-DEVFCB)) db 0
 44303                                  
 44304                                  ; End Temporary directory entry.
 44305                                  
 44306 0000056B 00                      ATTRIB:	db	0		; storage for file attributes
 44307                                  EXTFCB:	
 44308 0000056C 00                      	db	0		; TRUE => extended FCB in use
 44309                                  SATTRIB:
 44310 0000056D 00                      	db	0		; Storage for search attributes
 44311                                  OPEN_ACCESS:
 44312 0000056E 00                      	db	0		; access of open system call
 44313                                  FOUNDDEL:
 44314 0000056F 00                      	db	0		; true => file was deleted
 44315                                  FOUND_DEV:
 44316 00000570 00                      	db	0		; true => search found a device
 44317                                  FSPLICE:
 44318 00000571 00                      	db	0		; true => do a splice in transpath
 44319                                  FSHARING:
 44320 00000572 00                      	db	0		; TRUE => no redirection
 44321                                  SECCLUSPOS:
 44322 00000573 00                      	db	0		; Position of first sector within cluster
 44323 00000574 00                      TRANS:	db	0		;
 44324 00000575 00                      READOP:	db	0		;
 44325                                  THISDRV:
 44326 00000576 00                      	db	0		;
 44327                                  CLUSFAC:
 44328 00000577 00                      	db	0		;
 44329                                  CLUSSPLIT:
 44330 00000578 00                      	db	0		;
 44331                                  INSMODE:
 44332 00000579 00                      	db	0		; true => insert mode in buffered read
 44333 0000057A 00                      CMETA:	db	0		; count of meta'ed components found
 44334 0000057B 00                      VOLID:	db	0		;
 44335                                  EXIT_TYPE:
 44336 0000057C 00                      	db	0		; type of exit...
 44337                                   
 44338                                  	;EVEN
 44339                                  
 44340 0000057D 90                      align 2
 44341                                  
 44342                                  ; DOSDATA:057Eh
 44343                                  
 44344                                  ; WARNING - the following two items are accessed as a word
 44345                                  
 44346                                  CREATING:
 44347 0000057E 00                      	db	0		; true => creating a file
 44348 0000057F 00                      DELALL:	db	0		; = 0 iff BUGBUG
 44349                                  				; = DIRFREE iff BUGBUG
 44350                                  EXITHOLD:
 44351 00000580 00000000                	dd	0		; Temp location for proc terminate
 44352                                  USER_SP:
 44353 00000584 0000                    	dw	0		; User SP for system call
 44354                                  USER_SS:
 44355 00000586 0000                    	dw	0		; User SS for system call
 44356                                  CONTSTK:
 44357 00000588 0000                    	dw	0		;
 44358                                  THISDPB:
 44359 0000058A 00000000                	dd	0		;
 44360                                  CLUSSAVE:
 44361 0000058E 0000                    	dw	0		;
 44362                                  CLUSSEC:
 44363 00000590 00000000                	dd	0		;>32mb			AC0000
 44364                                  PREREAD:
 44365 00000594 0000                    	dw	0		; 0 means preread; 1 means optional
 44366 00000596 0000                    FATBYT:	dw	0		; Used by ALLOCATE
 44367                                  FATBYTE:
 44368 00000598 0000                    	dw	0		; Used by $SLEAZEFUNC
 44369                                  ; DOSDATA:059Ah
 44370 0000059A 00000000                DEVPT:	dd	0		;
 44371                                  THISSFT:
 44372 0000059E 00000000                	dd	0		; Address of user SFT
 44373                                  THISCDS:
 44374 000005A2 00000000                	dd	0		; Address of current CDS
 44375                                  THISFCB:
 44376 000005A6 00000000                	dd	0		; Address of user FCB
 44377 000005AA FFFF                    SFN:	dw	-1		; SystemFileNumber found for accessfile
 44378 000005AC 0000                    JFN:	dw	0		; JobFileNumber found for accessfile
 44379 000005AE 00000000                PJFN:	dd	0		; PointerJobFileNumber found for accessfile
 44380                                  WFP_START:
 44381 000005B2 0000                    	dw	0		;
 44382                                  REN_WFP:
 44383 000005B4 0000                    	dw	0		;
 44384                                  CURR_DIR_END:
 44385 000005B6 0000                    	dw	0		;
 44386                                  NEXTADD:
 44387 000005B8 0000                    	dw	0		;
 44388                                  LASTPOS:
 44389 000005BA 0000                    	dw	0		;
 44390                                  CLUSNUM:
 44391 000005BC 0000                    	dw	0		;
 44392 000005BE 00000000                DIRSEC:	dd	0		;>32mb			AC0000
 44393                                  DIRSTART:
 44394 000005C2 0000                    	dw	0		;
 44395 000005C4 00000000                SECPOS:	dd	0		;>32mb Position of first sector accessed
 44396 000005C8 00000000                VALSEC:	dd	0		;>32mb Number of valid (previously written)
 44397                                                                  ; sectors
 44398                                  BYTSECPOS:
 44399 000005CC 0000                    	dw	0		; Position of first byte within sector
 44400                                  BYTPOS: ;times	4 db 0		; Byte position in file of access
 44401 000005CE 0000<rep 2h>                    times	2 dw 0
 44402                                  BYTCNT1:
 44403 000005D2 0000                    	dw	0		; No. of bytes in first sector
 44404                                  BYTCNT2:
 44405 000005D4 0000                    	dw	0		; No. of bytes in last sector
 44406 000005D6 0000                    SECCNT:	dw	0		; No. of whole sectors
 44407                                  ; DOSDATA:05D8h
 44408                                  ENTFREE:
 44409 000005D8 0000                    	dw	0		;
 44410                                  ENTLAST:
 44411 000005DA 0000                    	dw	0		;
 44412                                  NXTCLUSNUM:
 44413 000005DC 0000                    	dw	0		;
 44414                                  GROWCNT:
 44415 000005DE 00000000                	dd	0		;
 44416 000005E2 00000000                CURBUF:	dd	0		;
 44417 000005E6 00000000                CONSFT:	dd	0		; SFT of console swapped guy.
 44418 000005EA 0000                    SAVEBX:	dw	0		;
 44419 000005EC 0000                    SAVEDS:	dw	0		;
 44420                                  RESTORE_TMP:
 44421 000005EE 0000                    	dw	0		; return address for restore world
 44422 000005F0 0000                    NSS:	dw	0
 44423 000005F2 0000                    NSP:	dw	0
 44424                                  ; DOSDATA:05F4h
 44425                                  EXTOPEN_FLAG:
 44426 000005F4 0000                    	dw	0		;FT. extended open input flag	;AN000;
 44427                                  EXTOPEN_ON:
 44428 000005F6 00                      	db	0		;FT. extended open conditional flag ;AN000;
 44429                                  EXTOPEN_IO_MODE:
 44430 000005F7 0000                    	dw	0		;FT. extended open io mode	;AN000;
 44431                                  SAVE_DI:
 44432 000005F9 0000                    	dw	0		;FT. extended open saved DI	;AN000;
 44433                                  SAVE_ES:
 44434 000005FB 0000                    	dw	0		;FT. extended open saved ES	;AN000;
 44435                                  SAVE_DX:
 44436 000005FD 0000                    	dw	0		;FT. extended open saved DX	;AN000;
 44437                                  SAVE_CX:
 44438 000005FF 0000                    	dw	0		;FT. extended open saved CX	;AN000;
 44439                                  SAVE_BX:
 44440 00000601 0000                    	dw	0		;FT. extended open saved BX	;AN000;
 44441                                  SAVE_SI:
 44442 00000603 0000                    	dw	0		;FT. extended open saved SI	;AN000;
 44443                                  SAVE_DS:
 44444 00000605 0000                    	dw	0		;FT. extended open saved DS	;AN000;
 44445                                  
 44446                                  ; DOSDATA:0607h
 44447                                  
 44448                                  ; HIGH_SECTOR is a hack to allow passing 32-bit sector numbers where
 44449                                  ; we used to just pass 16 bits in a register. Now High_SECTOR holds
 44450                                  ; the high 16, the low 16 are still in the register.
 44451                                  
 44452                                  HIGH_SECTOR:	
 44453 00000607 0000                    	dw	0		;>32mb higher sector #		;AN000;
 44454                                  	; 25/09/2023
 44455                                  OffsetMagicPatch:
 44456                                  	;dw	MagicPatch	;scottq 8/6/92
 44457                                  	; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 44458 00000609 0000                    	dw	0
 44459                                  				;see dos\mpatch.asm
 44460                                  DISK_FULL:
 44461 0000060B 00                      	db	0		;>32mb indicating disk full when 1 ;AN000;
 44462                                  TEMP_VAR:
 44463 0000060C 0000                    	dw	0		; temporary variable for everyone ;AN000;
 44464                                  TEMP_VAR2:
 44465 0000060E 0000                    	dw	0		; temporary variable 2 for everyone ;AN000;
 44466 00000610 00                      DrvErr:	db	0		; used to save drive error	;AN000;
 44467                                  DOS34_FLAG:
 44468 00000611 0000                    	dw	0		; common flag for DOS 3.4	;AN000;
 44469                                  NO_FILTER_PATH:
 44470 00000613 00000000                	dd	0		; pointer to original path	;AN000;
 44471                                  NO_FILTER_DPATH:
 44472 00000617 00000000                	dd	0		; pointer to original path of destination ;AN000;
 44473                                  ; M008
 44474                                  AbsRdWr_SS:
 44475 0000061B 0000                    	dw	0		; INT 25/26 user stack segment
 44476                                  AbsRdWr_SP:
 44477 0000061D 0000                    	dw	0		; INT 25/26 user stack offset
 44478                                  
 44479                                  	; I_am   UU_Callback_flag,BYTE,<0>  ; Unused
 44480                                  ; M008
 44481                                   
 44482                                   
 44483                                  ; make those pushes fast!!!
 44484                                  
 44485                                  ;EVEN
 44486                                  
 44487 0000061F 90                      align 2
 44488                                  
 44489                                  StackSize   equ 180h  ; 384	; gross but effective
 44490                                  
 44491                                  ;StackSize  equ 300h  ;	768	; This is a "trial" change IBM hasn't
 44492                                  ;				; made up their minds about
 44493                                   
 44494                                  ; WARNING!!!! DskStack may grow into AUXSTACK due to interrupt service.
 44495                                  ; This is NO problem as long as AUXSTACK comes immediately before DSKSTACK
 44496                                  
 44497                                  RENAMEDMA:	; LABEL   BYTE	; See DOS_RENAME
 44498                                   
 44499 00000620 00<rep 180h>                    times	StackSize db	0	;
 44500                                  AUXSTACK:			; LABEL   BYTE
 44501                                   
 44502 000007A0 00<rep 180h>                    times	StackSize db 	0	;
 44503                                  DSKSTACK:			; LABEL   BYTE
 44504                                   
 44505 00000920 00<rep 180h>                    times	StackSize db	0	;
 44506                                  IOSTACK:			; LABEL   BYTE
 44507                                  
 44508                                  ; DOSDATA:0AA0h 
 44509                                   
 44510                                  ; patch space for Boca folks.
 44511                                  ; Say What????!!! This does NOT go into the swappable area!
 44512                                  ; NOTE: We include the decl of ibmpatch in ms-dos even though it is not needed.
 44513                                  ;       This allows the REDIRector to work on either IBM or MS-DOS.
 44514                                   
 44515                                  IBMPATCH: ; label byte
 44516                                  PRINTER_FLAG:
 44517 00000AA0 00                      	db	0		; [SYSTEM] status of PRINT utility
 44518                                  VOLCHNG_FLAG:
 44519 00000AA1 00                      	db	0		; [SYSTEM] true if volume label created
 44520                                  VIRTUAL_OPEN:
 44521 00000AA2 00                      	db	0		; [SYSTEM] non-zero if we opened a virtual file
 44522                                   
 44523                                  ; Following 4 variables moved to MSDATA.asm from MSTABLE.asm (P4986)
 44524                                  
 44525                                  FSeek_drive:
 44526 00000AA3 00                      	db	0		;AN000; fastseek drive #
 44527                                  FSeek_firclus:
 44528 00000AA4 0000                    	dw	0		;AN000; fastseek first cluster #
 44529                                  FSeek_logclus:
 44530 00000AA6 0000                    	dw	0		;AN000; fastseek logical cluster #
 44531                                  FSeek_logsave:
 44532 00000AA8 0000                    	dw	0		;AN000; fastseek returned log clus #
 44533                                  
 44534                                  ; DOSDATA:0AAAh
 44535                                  
 44536                                  TEMP_DOSLOC:
 44537 00000AAA FFFF                    	dw	-1		;stores the temporary location of dos
 44538                                  				;at SYSINIT time.
 44539                                  SWAP_END:  ; LABEL   BYTE
 44540                                   
 44541                                  ; THE FOLLOWING BYTE MUST BE HERE, IMMEDIATELY FOLLOWING SWAP_END. IT CANNOT
 44542                                  ; BE USED. If the size of the swap data area is ODD, it will be rounded up
 44543                                  ; to include this byte.
 44544                                   
 44545 00000AAC 00                      	db	0
 44546                                  
 44547                                  ; DOSDATA:0AADh
 44548                                   
 44549                                  ;hkn;	DB	(512+80+32-(SWAP_END-ibmpatch)) DUP (?)
 44550                                  
 44551                                  ;DOSDATA    ENDS
 44552                                  
 44553                                  ;============================================================================
 44554                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
 44555                                  ;============================================================================
 44556                                  ; 27/04/2019 - Retro DOS 4.0
 44557                                  ; 16/07/2018 - Retro DOS 3.0
 44558                                  
 44559                                  ;DOSDATA Segment
 44560                                  
 44561                                  ; DOSDATA:0AADh (MSDOS 6.21, MSDOS.SYS)
 44562                                  
 44563                                  ;
 44564                                  ; upper case table
 44565                                  ; ---------------------------------------------------------------------------
 44566                                  UCASE_TAB:	; label   byte
 44567 00000AAD 8000                    	dw	128
 44568 00000AAF 809A45418E418F80        	db	128,154,069,065,142,065,143,128 
 44569 00000AB7 4545454949498E8F        	db	069,069,069,073,073,073,142,143
 44570 00000ABF 9092924F994F5555        	db	144,146,146,079,153,079,085,085
 44571 00000AC7 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
 44572 00000ACF 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
 44573 00000AD7 A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
 44574 00000ADF B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 44575 00000AE7 B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 44576 00000AEF C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 44577 00000AF7 C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 44578 00000AFF D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 44579 00000B07 D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 44580 00000B0F E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
 44581 00000B17 E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 44582 00000B1F F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 44583 00000B27 F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 44584                                  ;
 44585                                  ; file upper case table
 44586                                  ; ---------------------------------------------------------------------------
 44587                                  FILE_UCASE_TAB:	; label  byte
 44588 00000B2F 8000                    	dw	128
 44589 00000B31 809A45418E418F80        	db	128,154,069,065,142,065,143,128
 44590 00000B39 4545454949498E8F        	db	069,069,069,073,073,073,142,143
 44591 00000B41 9092924F994F5555        	db	144,146,146,079,153,079,085,085
 44592 00000B49 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
 44593 00000B51 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
 44594 00000B59 A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
 44595 00000B61 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 44596 00000B69 B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 44597 00000B71 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 44598 00000B79 C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 44599 00000B81 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 44600 00000B89 D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 44601 00000B91 E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
 44602 00000B99 E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 44603 00000BA1 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 44604 00000BA9 F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 44605                                  ;
 44606                                  ; file char list
 44607                                  ; ---------------------------------------------------------------------------
 44608                                  FILE_CHAR_TAB:	; label  byte
 44609 00000BB1 1600                    	dw	22				; length
 44610 00000BB3 0100FF                  	db	1,0,255 			; include all
 44611 00000BB6 000020                  	db	0,0,20h 			; exclude 0 - 20h
 44612 00000BB9 020E2E222F5C5B5D3A-     	db	2,14,'."/\[]:|<>+=;,'           ; exclude 14 special
 44612 00000BC2 7C3C3E2B3D3B2C     
 44613                                  	;db	24 dup (?)			; reserved
 44614 00000BC9 00<rep 18h>             	times	24 db 0
 44615                                  
 44616                                  ;
 44617                                  ; collate table
 44618                                  ; ---------------------------------------------------------------------------
 44619                                  COLLATE_TAB:	; label   byte
 44620 00000BE1 0001                    	dw	256
 44621 00000BE3 0001020304050607        	db	0,1,2,3,4,5,6,7
 44622 00000BEB 08090A0B0C0D0E0F        	db	8,9,10,11,12,13,14,15
 44623 00000BF3 1011121314151617        	db	16,17,18,19,20,21,22,23
 44624 00000BFB 18191A1B1C1D1E1F        	db	24,25,26,27,28,29,30,31
 44625 00000C03 2021222324252627        	db	" ","!",'"',"#","$","%","&","'"
 44626 00000C0B 28292A2B2C2D2E2F        	db	"(",")","*","+",",","-",".","/"
 44627 00000C13 3031323334353637        	db	"0","1","2","3","4","5","6","7"
 44628 00000C1B 38393A3B3C3D3E3F        	db	"8","9",":",";","<","=",">","?"
 44629 00000C23 4041424344454647        	db	"@","A","B","C","D","E","F","G"
 44630 00000C2B 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
 44631 00000C33 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
 44632 00000C3B 58595A5B5C5D5E5F        	db	"X","Y","Z","[","\","]","^","_"
 44633 00000C43 6041424344454647        	db	"`","A","B","C","D","E","F","G"
 44634 00000C4B 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
 44635 00000C53 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
 44636 00000C5B 58595A7B7C7D7E7F        	db	"X","Y","Z","{","|","}","~",127
 44637 00000C63 4355454141414143        	db	"C","U","E","A","A","A","A","C"
 44638 00000C6B 4545454949494141        	db	"E","E","E","I","I","I","A","A"
 44639 00000C73 4541414F4F4F5555        	db	"E","A","A","O","O","O","U","U"
 44640 00000C7B 594F552424242424        	db	"Y","O","U","$","$","$","$","$"
 44641 00000C83 41494F554E4EA6A7        	db	"A","I","O","U","N","N",166,167
 44642 00000C8B 3FA9AAABAC212222        	db	"?",169,170,171,172,"!",'"','"'
 44643 00000C93 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 44644 00000C9B B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 44645 00000CA3 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 44646 00000CAB C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 44647 00000CB3 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 44648 00000CBB D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 44649 00000CC3 E053                    	db	224,"S"
 44650 00000CC5 E2E3E4E5E6E7            	db	226,227,228,229,230,231
 44651 00000CCB E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 44652 00000CD3 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 44653 00000CDB F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 44654                                  
 44655                                  ; ------------------------------------------------<MSKK01>----------------------
 44656                                  
 44657                                  ; DOSDATA:0CE3h
 44658                                  
 44659                                  ; 29/04/2019
 44660                                  
 44661                                  ; dbcs is not supported in DOS 3.3
 44662                                  ;		   DBCS_TAB	    CC_DBCS <>
 44663                                  ;
 44664                                  ; DBCS for DOS 4.00			   2/12/KK
 44665                                  
 44666                                  DBCS_TAB:	; label byte		;AN000;  2/12/KK
 44667                                  ; ------------------------------------------------<MSKK01>----------------------
 44668                                  ;ifdef	DBCS
 44669                                  ; ifdef	  JAPAN
 44670                                  ;		dw	6		; <MSKK01>
 44671                                  ;		db	081h,09fh	; <MSKK01>
 44672                                  ;		db	0e0h,0fch	; <MSKK01>
 44673                                  ;		db	0,0		; <MSKK01>
 44674                                  ;
 44675                                  ;		db	0,0,0,0,0,0,0,0,0,0	; <MSKK01>
 44676                                  ; endif
 44677                                  ; ifdef	  TAIWAN
 44678                                  ;		dw	4		; <TAIWAN>
 44679                                  ;		db	081h,0FEh	; <TAIWAN>
 44680                                  ;		db	0,0		; <TAIWAN>
 44681                                  ;
 44682                                  ;		db	0,0,0,0,0,0,0,0,0,0,0,0
 44683                                  ; endif
 44684                                  ; ifdef   KOREA                         ; Keyl
 44685                                  ;               dw      4               ; <KOREA>
 44686                                  ;               db      0A1h,0FEh       ; <KOREA>
 44687                                  ;               db      0,0             ; <KOREA>
 44688                                  ;
 44689                                  ;		db	0,0,0,0,0,0,0,0,0,0,0,0
 44690                                  ;  endif
 44691                                  ;else
 44692 00000CE3 0000                    		dw	0		;AN000;  2/12/KK      max number
 44693                                  		;db	16 dup(0)	;AN000;  2/12/KK
 44694 00000CE5 00<rep 10h>             		times	16 db 0
 44695                                  
 44696                                  ;		dw	6		;  2/12/KK
 44697                                  ;		db	081h,09Fh	;  2/12/KK
 44698                                  ;		db	0E0h,0FCh	;  2/12/KK
 44699                                  ;		db	0,0		;  2/12/KK
 44700                                  ;
 44701                                  ;endif
 44702                                  ; ------------------------------------------------<MSKK01>----------------------
 44703                                  
 44704                                  ; DOSDATA:0CF5h
 44705                                  
 44706                                  ; ---------------------------------------------------------------------------
 44707                                  ;
 44708                                  ;CASE MAPPER ROUTINE FOR 80H-FFH character range, DOS 3.3
 44709                                  ;     ENTRY: AL = Character to map
 44710                                  ;     EXIT:  AL = The converted character
 44711                                  ; Alters no registers except AL and flags.
 44712                                  ; The routine should do nothing to chars below 80H.
 44713                                  ; ---------------------------------------------------------------------------
 44714                                  ; Example:
 44715                                  
 44716                                  MAP_CASE:
 44717                                  ;Procedure MAP_CASE,FAR
 44718                                  
 44719 00000CF5 3C80                    	CMP	AL,80h
 44720 00000CF7 7301                    	JAE	short Map1	;Map no chars below 80H ever
 44721 00000CF9 CB                      	RETF
 44722                                  Map1:
 44723 00000CFA 2C80                    	SUB	AL,80h		;Turn into index value
 44724 00000CFC 1E                      	PUSH	DS
 44725 00000CFD 53                      	PUSH	BX
 44726 00000CFE BB[AF0A]                	MOV	BX,UCASE_TAB+2
 44727                                  FINISH:
 44728 00000D01 0E                      	PUSH	CS		;Move to DS
 44729 00000D02 1F                      	POP	DS
 44730 00000D03 D7                      	XLAT			;Get upper case character
 44731 00000D04 5B                      	POP	BX
 44732 00000D05 1F                      	POP	DS
 44733                                  L_RET:	
 44734 00000D06 CB                      	RETF
 44735                                  
 44736                                  ;EndProc MAP_CASE
 44737                                  
 44738                                  ; ---------------------------------------------------------------------------
 44739                                  
 44740                                  ; The variables for ECS version are moved here for the same data alignments
 44741                                  ; as IBM-DOS and MS-DOS.
 44742                                  
 44743                                  InterChar:
 44744 00000D07 00                      	db	0	; Interim character flag ( 1= interim)  ;AN000;
 44745                                  ;------- NOTE: NEXT TWO BYTES SOMETIMES USED AS A WORD !! -------------------
 44746                                  DUMMY:	; LABEL   WORD
 44747                                  InterCon:  
 44748 00000D08 00                      	db	0	; Console in Interim mode ( 1= interim) ;AN000;
 44749                                  SaveCurFlg:
 44750 00000D09 00                      	db	0	; Print, do not advance cursor flag     ;AN000;
 44751                                  
 44752                                  ; ---------------------------------------------------------------------------
 44753                                  
 44754 00000D0A 0000                    TEMPSEG:  dw	0	;hkn; used to store ds.
 44755                                  redir_patch:
 44756 00000D0C 00                      	  db	0
 44757                                  
 44758                                  ; DOSDATA:0D0Dh
 44759                                  
 44760                                  Mark1:	; label byte
 44761                                  
 44762                                  ;IF2
 44763                                  ;	IF ((OFFSET MARK1) GT (OFFSET MSVERSION) )
 44764                                  ;		%OUT !DATA CORRUPTION!MARK1 OFFSET TOO BIG. RE-ORGANIZE DATA.
 44765                                  ;	ENDIF
 44766                                  ;ENDIF
 44767                                  
 44768 00000D0D 00<rep 5h>              	  times 5 db 0
 44769                                  
 44770                                  ;############################################################################
 44771                                  ;
 44772                                  ; ** HACK FOR DOS 4.0 REDIR **
 44773                                  ; 
 44774                                  ; The redir requires the following:
 44775                                  ;
 44776                                  ;	MSVERS	offset D12H
 44777                                  ;	YRTAB	offset D14H
 44778                                  ; 	MONTAB	offset D1CH
 44779                                  ;
 44780                                  ; WARNING! WARNING!
 44781                                  ; 
 44782                                  ; MARK1 SHOULD NOT BE >= 0D12H. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
 44783                                  ; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
 44784                                  ;
 44785                                  ; CURRENTLY MARK1 = 0D0DH
 44786                                  ;
 44787                                  ;############################################################################
 44788                                  
 44789                                  	;ORG	0D12h
 44790                                  
 44791                                  ; DOSDATA:0D12h (MSDOS 6.21, MSDOS.SYS)
 44792                                  
 44793                                  	;db	6
 44794                                  	;db	20
 44795                                  
 44796                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
 44797                                  MSVERSION:				; MS-DOS version in hex for $GET_VERSION
 44798 00000D12 06                      MSMAJORV: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
 44799 00000D13 16                      MSMINORV: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
 44800                                  
 44801                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
 44802                                  ;
 44803                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
 44804                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 
 44805                                  
 44806                                  ; Days in year
 44807                                  
 44808                                  YRTAB:   
 44809 00000D14 C8A6                    	DB	200,166			; Leap year
 44810 00000D16 C8A5                    	DB	200,165
 44811 00000D18 C8A5                    	DB	200,165
 44812 00000D1A C8A5                    	DB	200,165
 44813                                  
 44814                                  ; Days of each month
 44815                                  
 44816                                  MONTAB:        
 44817 00000D1C 1F                      	DB      31                      ; January
 44818                                  february:
 44819 00000D1D 1C                      	DB	28 			; February--reset each 
 44820                                  					; time year changes
 44821 00000D1E 1F                              DB      31                      ; March
 44822 00000D1F 1E                              DB      30                      ; April
 44823 00000D20 1F                              DB      31                      ; May
 44824 00000D21 1E                              DB      30                      ; June
 44825 00000D22 1F                              DB      31                      ; July
 44826 00000D23 1F                              DB      31                      ; August
 44827 00000D24 1E                              DB      30                      ; September
 44828 00000D25 1F                              DB      31                      ; October
 44829 00000D26 1E                              DB      30                      ; November
 44830 00000D27 1F                              DB      31                      ; December
 44831                                  
 44832                                  ;----------------THE FOLL. BLOCK MOVED FROM TABLE SEG IN MS_TABLE.ASM-------
 44833                                  
 44834                                  ; SYS init extended table,   DOS 3.3   F.C. 5/29/86
 44835                                  
 44836                                  SysInitTable:
 44837                                  	;dw	SYSINITVAR
 44838 00000D28 [2600]                  	dw	SYSINITVARS	; pointer to sysinit var
 44839 00000D2A 0000                            dw      0		; segment
 44840 00000D2C [0012]                          dw	COUNTRY_CDPG	; pointer to country tabl
 44841 00000D2E 0000                            dw      0		; segment of pointer
 44842                                  
 44843                                  ; DOS 3.3 F.C. 6/12/86
 44844                                  ; FASTOPEN communications area DOS 3.3   F.C. 5/29/86
 44845                                  
 44846                                  FastTable:				; a better name
 44847                                  FastOpenTable:
 44848 00000D30 0200                    	dw      2                       ; number of entries
 44849 00000D32 [A412]                  	dw      FastRet			; pointer to ret instr.
 44850 00000D34 0000                    	dw      0                       ; and will be modified by
 44851 00000D36 [A412]                  	dw      FastRet			; FASTxxx when loaded in
 44852 00000D38 0000                    	dw      0                       
 44853                                  
 44854                                  ; DOS 3.3 F.C. 6/12/86
 44855                                  
 44856                                  FastFlg:				; flags
 44857                                  FastOpenFlg:
 44858 00000D3A 00                      	db	0			; don't change the foll: order  
 44859                                  
 44860                                  ; FastOpen_Ext_Info is used as a temporary storage for saving dirpos,dirsec
 44861                                  ; and clusnum which are filled by DOS 3.nc when calling FastOpen Insert
 44862                                  ; or filled by FastOPen when calling FastOpen Lookup
 44863                                  
 44864                                  FastOpen_Ext_Info: ; label  byte	;dirpos
 44865                                  	;db	SIZE FASTOPEN_EXTENDED_INFO dup(0)
 44866                                  	;times	11 db 0
 44867 00000D3B 00<rep Bh>              	times	FEI.size db 0
 44868                                  
 44869                                  ; Dir_Info_Buff is a dir entry buffer which is filled by FastOPen
 44870                                  ; when calling FastOpen Lookup
 44871                                  
 44872                                  Dir_Info_Buff:	; label  byte
 44873                                  	;db   	SIZE dir_entry dup (0)
 44874                                  	;times	32 db 0
 44875 00000D46 00<rep 20h>             	times	dir_entry.size db 0
 44876                                  
 44877                                  Next_Element_Start:
 44878 00000D66 0000                    	dw	0			; save next element start offset
 44879                                  Del_ExtCluster:
 44880 00000D68 0000                    	dw	0			; for dos_delete                       
 44881                                  
 44882                                  ; The following is a stack and its pointer for interrupt 2F which is used
 44883                                  ; by NLSFUNC. There is no significant use of this stack, we are just trying
 44884                                  ; not to destroy the INT 21 stack saved for the user.
 44885                                  
 44886                                  USER_SP_2F:	; LABEL  WORD
 44887 00000D6A [6C0D]                  	dw    	FAKE_STACK_2F
 44888                                  
 44889                                  Packet_Temp:	; label  word		; temporary packet used by readtime
 44890                                  DOS_TEMP:	; label  word		; temporary word
 44891                                  FAKE_STACK_2F:  
 44892                                  	; dw  14 dup (0)		; 12 register temporary storage
 44893 00000D6C 0000<rep Eh>            	times 14 dw 0
 44894                                  
 44895                                  Hash_Temp: 	;label  word		; temporary word             
 44896                                  	;dw   4 dup (0)			; temporary hash table during config.sys
 44897 00000D88 0000<rep 4h>            	times 4 dw 0
 44898                                              	
 44899                                  SCAN_FLAG:	
 44900 00000D90 00                      	db     0			; flag to indicate key ALT_Q
 44901                                  DATE_FLAG:
 44902 00000D91 0000                    	dw     0                	; flag to update the date
 44903                                  
 44904                                  FETCHI_TAG:	; label  word		; OBSOLETE - no longer used
 44905 00000D93 0000                    	dw     0			; formerly part of IBM's piracy protection
 44906                                  
 44907                                  MSG_EXTERROR:	; label  DWORD   ; for system message addr                                                       
 44908 00000D95 00000000                	dd     0               		; for extended error                   
 44909 00000D99 00000000                	dd     0			; for parser                           
 44910 00000D9D 00000000                	dd     0			; for critical errror                  
 44911 00000DA1 00000000                	dd     0			; for IFS                              
 44912 00000DA5 00000000                	dd     0			; for code reduction                   
 44913                                  
 44914                                  SEQ_SECTOR:	; label  DWORD 		; last sector read                                                     
 44915 00000DA9 FFFFFFFF                	dd     -1                                                        
 44916                                  SC_SECTOR_SIZE:
 44917 00000DAD 0000                    	dw	0			; sector size for SC                 
 44918                                  SC_DRIVE:
 44919 00000DAF 00                      	db	0			; drive # for secondary cache        
 44920                                  CurSC_DRIVE:
 44921 00000DB0 FF                      	db	-1			; current SC drive                   
 44922                                  CurSC_SECTOR:
 44923 00000DB1 00000000                	dd	0			; current SC starting sector         
 44924                                  SC_STATUS:
 44925 00000DB5 0000                    	dw	0			; SC status word                     
 44926                                  SC_FLAG:
 44927 00000DB7 00                      	db	0			; SC flag                            
 44928                                  AbsDskErr:
 44929 00000DB8 0000                    	dw	0			; Storage for Abs dsk read/write err
 44930                                                                                            
 44931                                  NO_NAME_ID:	; label byte                                                           
 44932 00000DBA 4E4F204E414D452020-     	db	'NO NAME    '		; null media id                      
 44932 00000DC3 2020               
 44933                                  
 44934                                  ;hkn; moved from TABLE segment in kstrin.asm
 44935                                  
 44936                                  KISTR001S:	; label	byte		; 2/17/KK
 44937 00000DC5 00                      LOOKSIZ: DB	0			; 0 if byte, NZ if word	2/17/KK
 44938                                  KISTR001E:	; label	byte		; 2/17/KK
 44939                                  
 44940                                  ; the nul device driver used to be part of the code. However, since the 
 44941                                  ; header is in the data, and the entry points are only given as an offset,
 44942                                  ; the strategy and interrupt entry points must also be in the data now.
 44943                                  
 44944                                  ; DOSDATA:0DC6h
 44945                                  
 44946                                  SNULDEV:
 44947                                  ;procedure snuldev,far
 44948                                  	;or	word [es:bx+3],100h
 44949                                  	; 17/12/2022
 44950                                  	;or	byte [es:bx+4],01h
 44951                                  	; 05/01/2024 (Original MSDOS and RetroDOS DATA address compatibility)
 44952                                  	;or	byte [es:bx+SRHEAD.REQSTAT+1],(STDON>>8)
 44953 00000DC6 26814F030001            	or	word [es:bx+SRHEAD.REQSTAT],STDON ; set done bit
 44954                                  INULDEV:
 44955 00000DCC CB                      	retf				; must not be a return!
 44956                                  ;endproc snuldev
 44957                                  
 44958                                  ;M044
 44959                                  ; Second part of save area for saving last para of Windows memory
 44960                                  
 44961                                  WinoldPatch2:
 44962                                  	;db	8 dup (?)	; M044
 44963 00000DCD 00<rep 8h>              	times	8 db 0	
 44964                                  UmbSave2:
 44965                                  	;db	5 dup (?)	; M062
 44966 00000DD5 00<rep 5h>              	times	5 db 0
 44967                                  UmbSaveFlag:
 44968 00000DDA 00                      	db	0		; M062
 44969                                  
 44970                                  ; DOSDATA:0DDBh
 44971                                  
 44972                                  Mark2:	; label byte
 44973                                  
 44974                                  ;IF2
 44975                                  ;	IF ((OFFSET MARK2) GT (OFFSET ERR_TABLE_21) )
 44976                                  ;		%OUT !DATA CORRUPTION!MARK2 OFFSET TOO BIG. RE-ORGANIZE DATA.
 44977                                  ;	ENDIF
 44978                                  ;ENDIF
 44979                                  
 44980                                  ;############################################################################
 44981                                  ;
 44982                                  ; ** HACK FOR DOS 4.0 REDIR **
 44983                                  ; 
 44984                                  ; The redir requires the following:
 44985                                  ;
 44986                                  ;	ERR_TABLE_21	offset DDBH
 44987                                  ;	ERR_TABLE_24	offset E5BH
 44988                                  ; 	ErrMap24	offset EABH
 44989                                  ;
 44990                                  ; WARNING! WARNING!
 44991                                  ;
 44992                                  ; MARK2 SHOULD NOT BE >= 0DDBH. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
 44993                                  ; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
 44994                                  ;
 44995                                  ; CURRENTLY MARK2 = 0DD0H
 44996                                  ;
 44997                                  ;############################################################################
 44998                                  
 44999                                  	;ORG	0DDBh
 45000                                  
 45001                                  ; DOSDATA:0DDBh (MSDOS 6.21, MSDOS.SYS)
 45002                                  
 45003                                  ; ---------------------------------------------------------------------------
 45004                                  ;
 45005                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 21H
 45006                                  ; errors. Each entry is 4 bytes long:
 45007                                  ;
 45008                                  ;       Err#,Class,Action,Locus
 45009                                  ;
 45010                                  ; A value of 0FFh indicates a call specific value (ie. should already
 45011                                  ; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
 45012                                  ; THE END, IT IS ASSUMES THAT CLASS, ACTION, LOCUS IS ALREADY SET.
 45013                                  ;
 45014                                  ; ---------------------------------------------------------------------------
 45015                                  
 45016                                  ;ErrTab  Macro   err,class,action,locus
 45017                                  ;ifidn <locus>,<0FFh>
 45018                                  ;    DB  error_&err,errCLASS_&class,errACT_&action,0FFh
 45019                                  ;ELSE
 45020                                  ;    DB  error_&err,errCLASS_&class,errACT_&action,errLOC_&locus
 45021                                  ;ENDIF
 45022                                  ;ENDM
 45023                                  
 45024                                  ERR_TABLE_21: ; LABEL   BYTE
 45025 00000DDB 010704FF                    DB  error_invalid_function,       errCLASS_Apperr,    errACT_Abort,    0FFh
 45026 00000DDF 02080302                    DB  error_file_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 45027 00000DE3 03080302                    DB  error_path_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 45028 00000DE7 04010401                    DB  error_too_many_open_files,    errCLASS_OutRes,    errACT_Abort,    errLOC_Unk
 45029 00000DEB 050303FF                    DB  error_access_denied,          errCLASS_Auth,      errACT_User,     0FFh
 45030 00000DEF 06070401                    DB  error_invalid_handle,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 45031 00000DF3 07070505                    DB  error_arena_trashed,          errCLASS_Apperr,    errACT_Panic,    errLOC_Mem
 45032 00000DF7 08010405                    DB  error_not_enough_memory,      errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 45033 00000DFB 09070405                    DB  error_invalid_block,          errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
 45034 00000DFF 0A070405                    DB  error_bad_environment,        errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
 45035 00000E03 0B090301                    DB  error_bad_format,             errCLASS_BadFmt,    errACT_User,     errLOC_Unk
 45036 00000E07 0C070401                    DB  error_invalid_access,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 45037 00000E0B 0D090401                    DB  error_invalid_data,           errCLASS_BadFmt,    errACT_Abort,    errLOC_Unk
 45038 00000E0F 0F080302                    DB  error_invalid_drive,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 45039 00000E13 10030302                    DB  error_current_directory,      errCLASS_Auth,      errACT_User,     errLOC_Disk
 45040 00000E17 110D0302                    DB  error_not_same_device,        errCLASS_Unk,       errACT_User,     errLOC_Disk
 45041 00000E1B 12080302                    DB  error_no_more_files,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 45042 00000E1F 500C0302                    DB  error_file_exists,            errCLASS_Already,   errACT_User,     errLOC_Disk
 45043 00000E23 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 45044 00000E27 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 45045 00000E2B 540104FF                    DB  error_out_of_structures,      errCLASS_OutRes,    errACT_Abort,    0FFh
 45046 00000E2F 56030301                    DB  error_invalid_password,       errCLASS_Auth,      errACT_User,     errLOC_Unk
 45047 00000E33 52010402                    DB  error_cannot_make,            errCLASS_OutRes,    errACT_Abort,    errLOC_Disk
 45048 00000E37 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
 45049 00000E3B 550C0303                    DB  error_already_assigned,       errCLASS_Already,   errACT_User,     errLOC_Net
 45050 00000E3F 57090301                    DB  error_invalid_parameter,      errCLASS_BadFmt,    errACT_User,     errLOC_Unk
 45051 00000E43 530D0401                    DB  error_FAIL_I24,               errCLASS_Unk,       errACT_Abort,    errLOC_Unk
 45052 00000E47 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 45053                                      ; MSDOS 6.0
 45054 00000E4B 26010401                    DB  error_handle_EOF,             errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
 45055 00000E4F 27010401                    DB  error_handle_Disk_Full,       errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
 45056 00000E53 5A0D0402                    DB  error_sys_comp_not_loaded,    errCLASS_Unk,       errACT_Abort,    errLOC_Disk ;AN001;
 45057 00000E57 FFFFFFFF                    DB  0FFh,                         0FFH,       	  0FFH,       	   0FFh
 45058                                  
 45059                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D2Ah
 45060                                  ;ERR_TABLE_21:	db 1,7,4,0FFh
 45061                                  ;		db 2,8,3,2
 45062                                  ;		db 3,8,3,2
 45063                                  ;		db 4,1,4,1
 45064                                  ;		db 5,3,3,0FFh
 45065                                  ;		db 6,7,4,1
 45066                                  ;		db 7,7,5,5
 45067                                  ;		db 8,1,4,5
 45068                                  ;		db 9,7,4,5
 45069                                  ;		db 0Ah,7,4,5
 45070                                  ;		db 0Bh,9,3,1
 45071                                  ;		db 0Ch,7,4,1
 45072                                  ;		db 0Dh,9,4,1
 45073                                  ;		db 0Fh,8,3,2
 45074                                  ;		db 10h,3,3,2
 45075                                  ;		db 11h,0Dh,3,2
 45076                                  ;		db 12h,8,3,2
 45077                                  ;		db 50h,0Ch,3,2
 45078                                  ;		db 20h,0Ah,2,2
 45079                                  ;		db 21h,0Ah,2,2
 45080                                  ;		db 54h,1,4,0FFh
 45081                                  ;		db 56h,3,3,1
 45082                                  ;		db 52h,1,4,2
 45083                                  ;		db 32h,9,3,3
 45084                                  ;		db 55h,0Ch,3,3
 45085                                  ;		db 57h,9,3,1
 45086                                  ;		db 53h,0Dh,4,1
 45087                                  ;		db 24h,1,4,5
 45088                                  ; MSDOS 6.0 (MSDOS 6.21)
 45089                                  ;		db 26h,1,4,1
 45090                                  ;		db 27h,1,4,1
 45091                                  ;		db 5Ah,0Dh,4,2
 45092                                  ; MSDOS 6.0 & MSDOS 3.3
 45093                                  ;		db 0FFh,0FFh,0FFh,0FFh
 45094                                  
 45095                                  ; DOSDATA:0E5Bh (MSDOS 6.21, MSDOS.SYS)
 45096                                  
 45097                                  ; ---------------------------------------------------------------------------
 45098                                  ;
 45099                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 24H
 45100                                  ; errors. Each entry is 4 bytes long:
 45101                                  ;
 45102                                  ;       Err#,Class,Action,Locus
 45103                                  ;
 45104                                  ; A Locus value of 0FFh indicates a call specific value (ie. should already
 45105                                  ; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
 45106                                  ; THE END.
 45107                                  ;
 45108                                  ; ---------------------------------------------------------------------------
 45109                                  
 45110                                  ERR_TABLE_24: ; LABEL   BYTE
 45111 00000E5B 130B0702                    DB  error_write_protect,          errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 45112 00000E5F 14040501                    DB  error_bad_unit,               errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 45113 00000E63 150507FF                    DB  error_not_ready,              errCLASS_HrdFail,   errACT_IntRet,   0FFh
 45114 00000E67 16040501                    DB  error_bad_command,            errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 45115 00000E6B 170B0402                    DB  error_CRC,                    errCLASS_Media,     errACT_Abort,    errLOC_Disk
 45116 00000E6F 18040501                    DB  error_bad_length,             errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 45117 00000E73 19050102                    DB  error_seek,                   errCLASS_HrdFail,   errACT_Retry,    errLOC_Disk
 45118 00000E77 1A0B0702                    DB  error_not_DOS_disk,           errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 45119 00000E7B 1B0B0402                    DB  error_sector_not_found,       errCLASS_Media,     errACT_Abort,    errLOC_Disk
 45120 00000E7F 1C020704                    DB  error_out_of_paper,           errCLASS_TempSit,   errACT_IntRet,   errLOC_SerDev
 45121 00000E83 1D0504FF                    DB  error_write_fault,            errCLASS_HrdFail,   errACT_Abort,    0FFh
 45122 00000E87 1E0504FF                    DB  error_read_fault,             errCLASS_HrdFail,   errACT_Abort,    0FFh
 45123 00000E8B 1F0D04FF                    DB  error_gen_failure,            errCLASS_Unk,       errACT_Abort,    0FFh
 45124 00000E8F 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 45125 00000E93 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 45126 00000E97 220B0702                    DB  error_wrong_disk,             errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 45127 00000E9B 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
 45128 00000E9F 23070401                    DB  error_FCB_unavailable,        errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 45129 00000EA3 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 45130 00000EA7 FF0D05FF                    DB	0FFh,                         errCLASS_Unk,       errACT_Panic,    0FFh
 45131                                  
 45132                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D9Eh
 45133                                  ;ERR_TABLE_24:	db 13h,0Bh,7,2
 45134                                  ;		db 14h,4,5,1
 45135                                  ;		db 15h,5,7,0FFh
 45136                                  ;		db 16h,4,5,1
 45137                                  ;		db 17h,0Bh,4,2
 45138                                  ;		db 18h,4,5,1
 45139                                  ;		db 19h,5,1,2
 45140                                  ;		db 1Ah,0Bh,7,2
 45141                                  ;		db 1Bh,0Bh,4,2
 45142                                  ;		db 1Ch,2,7,4
 45143                                  ;		db 1Dh,5,4,0FFh
 45144                                  ;		db 1Eh,5,4,0FFh
 45145                                  ;		db 1Fh,0Dh,4,0FFh
 45146                                  ;		db 20h,0Ah,2,2
 45147                                  ;		db 21h,0Ah,2,2
 45148                                  ;		db 22h,0Bh,7,2
 45149                                  ;		db 32h,9,3,3
 45150                                  ;		db 23h,7,4,1
 45151                                  ;		db 24h,1,4,5
 45152                                  ;		db 0FFh,0Dh,5,0FFh
 45153                                  
 45154                                  ; DOSDATA:0EABh (MSDOS 6.21, MSDOS.SYS)
 45155                                  
 45156                                  ; ---------------------------------------------------------------------------
 45157                                  ;
 45158                                  ; We need to map old int 24 errors and device driver errors into the new set
 45159                                  ; of errors. The following table is indexed by the new errors
 45160                                  ;
 45161                                  ; ---------------------------------------------------------------------------
 45162                                  
 45163                                  ;Public  ErrMap24
 45164                                  ErrMap24: ; Label   BYTE
 45165 00000EAB 13                          DB  error_write_protect	; 0
 45166 00000EAC 14                          DB  error_bad_unit		; 1
 45167 00000EAD 15                          DB  error_not_ready		; 2
 45168 00000EAE 16                          DB  error_bad_command	; 3
 45169 00000EAF 17                          DB  error_CRC		; 4
 45170 00000EB0 18                          DB  error_bad_length	; 5
 45171 00000EB1 19                          DB  error_seek		; 6
 45172 00000EB2 1A                          DB  error_not_DOS_disk	; 7
 45173 00000EB3 1B                          DB  error_sector_not_found	; 8
 45174 00000EB4 1C                          DB  error_out_of_paper	; 9
 45175 00000EB5 1D                          DB  error_write_fault	; A
 45176 00000EB6 1E                          DB  error_read_fault	; B
 45177 00000EB7 1F                          DB  error_gen_failure	; C
 45178 00000EB8 1F                          DB  error_gen_failure	; D  RESERVED
 45179 00000EB9 1F                          DB  error_gen_failure	; E  RESERVED
 45180 00000EBA 22                          DB  error_wrong_disk	; F
 45181                                  
 45182                                  ;ErrMap24: db 13h, 14h, 15h, 16h, 17h, 18h, 19h, 1Ah
 45183                                  ;	   db 1Bh, 1Ch, 1Dh, 1Eh, 1Fh, 1Fh, 1Fh, 22h
 45184                                  	
 45185                                  ErrMap24End: ; LABEL   BYTE
 45186                                  
 45187                                  ; DOSDATA:0E5Bh (MSDOS 6.21, MSDOS.SYS)
 45188                                  
 45189                                  ; ---------------------------------------------------------------------------
 45190                                  
 45191                                  ; 27/04/2019 - Retro DOS v4.0
 45192                                  
 45193                                  FIRST_BUFF_ADDR:
 45194 00000EBB 0000                    	dw	0			; first buffer address               
 45195                                  SPECIAL_VERSION:
 45196 00000EBD 0000                    	dw	0			;AN006; used by INT 2F 47H
 45197                                  FAKE_COUNT:
 45198 00000EBF 00<rep FFh>             	times 255 db 0			;AN008; fake version count
 45199                                  OLD_FIRSTCLUS:
 45200 00000FBE 0000                    	dw	0			;AN011; save old first cluster for fastopen
 45201                                  
 45202                                  ; ---------------------------------------------------------------------------
 45203                                  
 45204                                  ;smr; moved from TABLE segment in exec.asm
 45205                                  
 45206 00000FC0 0000                    exec_init_SP: dw 0
 45207 00000FC2 0000                    exec_init_SS: dw 0
 45208 00000FC4 0000                    exec_init_IP: dw 0
 45209 00000FC6 0000                    exec_init_CS: dw 0
 45210                                  
 45211                                  exec_signature:
 45212 00000FC8 0000                    	dw	0	; must contain 4D5A (yay zibo!)
 45213                                  exec_len_mod_512:
 45214 00000FCA 0000                    	dw	0	; low 9 bits of length
 45215                                  exec_pages:
 45216 00000FCC 0000                    	dw	0	; number of 512b pages in file
 45217                                  exec_rle_count:
 45218 00000FCE 0000                    	dw	0	; count of reloc entries
 45219                                  exec_par_dir:
 45220 00000FD0 0000                    	dw	0	; number of paragraphs before image
 45221                                  exec_min_BSS:
 45222 00000FD2 0000                    	dw	0	; minimum number of para of BSS
 45223                                  exec_max_BSS:
 45224 00000FD4 0000                    	dw	0	; max number of para of BSS
 45225                                  exec_SS:
 45226 00000FD6 0000                    	dw	0	; stack of image
 45227                                  exec_SP:
 45228 00000FD8 0000                    	dw	0	; SP of image
 45229                                  exec_chksum:
 45230 00000FDA 0000                    	dw	0	; checksum of file (ignored)
 45231                                  exec_IP:
 45232 00000FDC 0000                    	dw	0	; IP of entry
 45233                                  exec_CS:
 45234 00000FDE 0000                    	dw	0	; CS of entry
 45235                                  exec_rle_table:
 45236 00000FE0 0000                    	dw	0	; byte offset of reloc table
 45237                                  
 45238                                  exec_header_len	equ $-exec_signature			;PBUGBUG
 45239                                  
 45240                                  ;smr; eom
 45241                                  
 45242                                  ; ---------------------------------------------------------------------------
 45243                                  
 45244                                  ;SR;
 45245                                  ; WIN386 instance table for DOS
 45246                                  
 45247                                  Win386_Info:
 45248 00000FE2 0300                    	db	3, 0
 45249 00000FE4 000000000000000000-     	dd	0, 0, 0
 45249 00000FED 000000             
 45250 00000FF0 [F40F]0000              	dw	Instance_Table, 0
 45251                                  
 45252                                  Instance_Table:
 45253 00000FF4 [2200]00000200          	dw	CONTPOS, 0, 2
 45254 00000FFA [3200]00000400          	dw	BCON, 0, 4
 45255 00001000 [F901]00000601          	dw	CARPOS, 0, 106h
 45256 00001006 [0003]00000100          	dw	CHARCO, 0, 1
 45257 0000100C [C00F]00002200          	dw	exec_init_SP, 0, 34	; M074
 45258 00001012 [8900]00000100          	dw	UMBFLAG,0,1		; M019
 45259 00001018 [8C00]00000200          	dw	UMB_HEAD,0,2		; M019
 45260 0000101E 00000000                	dw	0, 0
 45261                                  
 45262                                  ; M001; SR;
 45263                                  ; M001; On DOSMGR call ( cx == 0 ), we need to return a table of offsets of 
 45264                                  ; M001; some DOS variables. Note that the only really important variable in 
 45265                                  ; M001; this is User_Id. The other variables are needed only to patch stuff 
 45266                                  ; M001; which does not need to be done in DOS 5.0. 
 45267                                  
 45268                                  ; 29/12/2022
 45269                                  ; (MSDOS 6.21 MSDOS.SYS DOSDATA:1022h)
 45270                                  
 45271                                  Win386_DOSVars:
 45272 00001022 05                      	db	5	;Major version 5 ; M001
 45273 00001023 00                      	db	0	;Minor version 0 ; M001
 45274 00001024 [EC05]                  	dw	SAVEDS	; M001
 45275 00001026 [EA05]                  	dw	SAVEBX	; M001
 45276 00001028 [2103]                  	dw	INDOS	; M001
 45277 0000102A [3E03]                  	dw	USER_ID	; M001
 45278 0000102C [1503]                  	dw	CritPatch ; M001
 45279 0000102E [8C00]                  	dw	UMB_HEAD ; M012
 45280                                  
 45281                                  ;SR;
 45282                                  ; Flag to indicate whether WIN386 is running or not
 45283                                  
 45284 00001030 00                      IsWin386: db	0
 45285                                  
 45286                                  ;M018
 45287                                  ; This variable contains the path to the VxD device needed for Win386
 45288                                  
 45289 00001031 633A5C77696E613230-     VxDpath:  db	'c:\wina20.386',0	;M018
 45289 0000103A 2E33383600         
 45290                                  
 45291                                  ;End WIN386 support
 45292                                  
 45293                                  ; ---------------------------------------------------------------------------
 45294                                  
 45295                                  ;SR;
 45296                                  ; These variables have been added for the special lie support for device
 45297                                  ;drivers.
 45298                                  ;
 45299                                  
 45300                                  DriverLoad:	
 45301 0000103F 01                      	db	1	;initialized to do special handling
 45302                                  BiosDataPtr:
 45303 00001040 00000000                	dd	0
 45304                                  
 45305                                  ; 29/12/2022 - Retro DOS v4.1
 45306                                  %if 0
 45307                                  
 45308                                  ; 27/04/2019 - Retro DOS v4.0
 45309                                  ; 04/11/2022
 45310                                  ; DOSDATA:1044h (MSDOS 6.21 & MSDOS 5.0, MSDOS.SYS)
 45311                                  
 45312                                  ;------------------------------------------------------------------------
 45313                                  ; Patch for Sidekick
 45314                                  ;
 45315                                  ; A documented method for finding the offset of the Errormode flag in the 
 45316                                  ; dos swappable data area if for the app to scan in the dos segment (data) 
 45317                                  ; for the following sequence of instructions.
 45318                                  ;
 45319                                  ; Ref: Part C, Article 11, pg 356 of MSDOS Encyclopedia
 45320                                  ;
 45321                                  ; The Offset of Errormode flag is 0320h
 45322                                  ;
 45323                                  ;------------------------------------------------------------------------
 45324                                  
 45325                                  	db	036h, 0F6h, 06h, 020h, 03h, 0FFh ; test ss:[errormode], -1
 45326                                  	db	075h, 0Ch			 ; jnz  NearLabel
 45327                                  	db	036h, 0FFh, 036h, 058h, 03h	 ; push ss:[NearWord]
 45328                                  	db	0CDh, 028h			 ; int  28h
 45329                                  
 45330                                  ;--------------------------------------------------------------------------
 45331                                  ; Patch for PortOfEntry - M036
 45332                                  ;
 45333                                  ; PortOfEntry by Sector Technology uses an un documented way of determining
 45334                                  ; the offset of Errormode flag. The following patch is to support them in 
 45335                                  ; DOS 5.0. The corresponding code is actually in msdisp.asm
 45336                                  ;
 45337                                  ;---------------------------------------------------------------------------
 45338                                  
 45339                                  	db 	080h, 03Eh, 020h, 03h, 00h 	 ; cmp 	[errormode], 0
 45340                                  	db	075h, 037h			 ; jnz	NearLabel
 45341                                  	db 	0BCh, 0A0h, 0Ah		  	 ; mov	sp, dosdata:iostack
 45342                                  
 45343                                  %endif ; 29/12/2022
 45344                                  
 45345                                  ; DOSDATA:105Dh (MSDOS 6.21, MSDOS.SYS)
 45346                                  
 45347                                  ;--------------------------------------------------------------------------
 45348                                  
 45349                                  ;*** New FCB Implementation
 45350                                  ; This variable is used as a cache in the new FCB implementation to remember
 45351                                  ;the address of a local SFT that can be recycled for a regenerate operation
 45352                                  
 45353 00001044 00000000                LocalSFT: dd	0		; 0 to indicate invalid pointer
 45354                                  
 45355                                  ;DOSDATA ENDS
 45356                                  
 45357                                  ;============================================================================
 45358                                  ; LMSTUB.ASM (MSDOS 6.0, 1991)
 45359                                  ;============================================================================
 45360                                  ; 27/04/2019 - Retro DOS 4.0
 45361                                  
 45362                                  ;DOSDATA  SEGMENT WORD PUBLIC 'DATA'
 45363                                  
 45364                                  ;---------------------------------------------------------------------------
 45365                                  ;	Low Memory Stub for DOS when DOS runs in HMA
 45366                                  ;----------------------------------------------------------------------------
 45367                                  	
 45368                                  	;db	90h
 45369                                  
 45370                                  	;EVEN
 45371                                  align 2
 45372                                  
 45373                                  ; DOSDATA:1062h (MSDOS 6.21, MSDOS.SYS)
 45374                                  
 45375                                  DOSINTTABLE:	; LABEL	DWORD
 45376                                  
 45377                                  	;DW	OFFSET DOSCODE:DIVOV 		, 0
 45378                                  	;DW	OFFSET DOSCODE:QUIT 		, 0
 45379                                  	;DW	OFFSET DOSCODE:COMMAND		, 0
 45380                                  	;DW	OFFSET DOSCODE:ABSDRD		, 0
 45381                                  	;DW	OFFSET DOSCODE:ABSDWRT		, 0
 45382                                  	;DW	OFFSET DOSCODE:Stay_resident	, 0
 45383                                  	;DW	OFFSET DOSCODE:INT2F		, 0
 45384                                  	;DW	OFFSET DOSCODE:CALL_ENTRY	, 0
 45385                                  	;DW	OFFSET DOSCODE:IRETT		, 0
 45386                                  	
 45387 00001048 [8C52]0000              	dw	DIVOV 		, 0  ; DOSINTTABLE+0
 45388 0000104C [DC02]0000              	dw	QUIT 		, 0  ; DOSINTTABLE+4	
 45389 00001050 [0803]0000              	dw	COMMAND		, 0  ; DOSINTTABLE+8
 45390 00001054 [2D05]0000              	dw	ABSDRD		, 0  ; DOSINTTABLE+12
 45391 00001058 [B405]0000              	dw	ABSDWRT		, 0  ; DOSINTTABLE+16
 45392 0000105C [C661]0000              	dw	STAY_RESIDENT	, 0  ; DOSINTTABLE+20
 45393 00001060 [0307]0000              	dw	INT2F		, 0  ; DOSINTTABLE+24
 45394 00001064 [E302]0000              	dw	CALL_ENTRY	, 0  ; DOSINTTABLE+28
 45395 00001068 [E202]0000              	dw	IRETT		, 0  ; DOSINTTABLE+32
 45396                                  
 45397 0000106C 0000                    SS_Save: dw	0		; save user's stack segment
 45398 0000106E 0000                    SP_Save: dw	0		; save user's stack offset
 45399                                  
 45400                                  ;-------------------------------------------------------------------------
 45401                                  ;
 45402                                  ; LOW MEM STUB:
 45403                                  ;
 45404                                  ; The low mem stub contains the entry points into DOS for all interrupts 
 45405                                  ; handled by DOS. This stub is installed if the user specifies that the 
 45406                                  ; DOS load in HIMEM. Each entry point does this.
 45407                                  ;
 45408                                  ; 	1. if jmp to 8 has been patched out
 45409                                  ;	   2. if A20 OFF
 45410                                  ;	      3. Enable A20
 45411                                  ;	   4. else 
 45412                                  ;	      5. just go to dos entry
 45413                                  ;	   6. endif
 45414                                  ;	7. else
 45415                                  ;	   8. just go to dos entry
 45416                                  ;	9. endif
 45417                                  ;
 45418                                  ;--------------------------------------------------------------------------
 45419                                  
 45420                                  ; 27/04/2019 - Retro DOS v4.0
 45421                                  
 45422                                  ; DOSDATA:108Ah (MSDOS 6.21, MSDOS.SYS)
 45423                                  
 45424                                  ;--------------------------------------------------------------------------
 45425                                  ;
 45426                                  ; DIVIDE BY 0 handler
 45427                                  ;
 45428                                  ;--------------------------------------------------------------------------
 45429                                  
 45430                                  ldivov:
 45431                                  	; The following jump, skipping the XMS calls will be patched to 
 45432                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45433                                  	; needed because the stub is installed even before the XMS driver
 45434                                  	; is loaded if the user specifies dos=high in the config.sys
 45435                                  i0patch:
 45436 00001070 EB03                    	jmp	short divov_cont	
 45437                                  
 45438 00001072 E8D800                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45439                                  divov_cont:
 45440 00001075 2EFF2E[4810]            	jmp	far [cs:DOSINTTABLE]	; jmp to DOS
 45441                                  
 45442                                  ;------------------------------------------------------------------------
 45443                                  ;
 45444                                  ; INT 20 Handler
 45445                                  ;
 45446                                  ; Here we do not have to set up the stack to return here as the abort call
 45447                                  ; will return to the address after the int 21 ah=4b call. This would be the
 45448                                  ; common exit point if A20 had been OFF (for TOGGLE DOS) and the A20 line
 45449                                  ; will be restored then.
 45450                                  ;
 45451                                  ;-------------------------------------------------------------------------
 45452                                  
 45453                                  lquit:
 45454                                  	; The following jump, skipping the XMS calls will be patched to 
 45455                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45456                                  	; needed because the stub is installed even before the XMS driver
 45457                                  	; is loaded if the user specifies dos=high in the config.sys
 45458                                  i20patch:
 45459 0000107A EB03                    	jmp	short quit_cont	
 45460                                  
 45461 0000107C E8CE00                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45462                                  quit_cont:
 45463 0000107F 2EFF2E[4C10]            	jmp	far [cs:DOSINTTABLE+4]	; jump to DOS
 45464                                  
 45465                                  ;--------------------------------------------------------------------------
 45466                                  ;
 45467                                  ; INT 21 Handler
 45468                                  ;
 45469                                  ;--------------------------------------------------------------------------
 45470                                  
 45471                                  lcommand:
 45472                                  	; The following jump, skipping the XMS calls will be patched to 
 45473                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45474                                  	; needed because the stub is installed even before the XMS driver
 45475                                  	; is loaded if the user specifies dos=high in the config.sys
 45476                                  i21patch:
 45477 00001084 EB03                    	jmp	short command_cont	
 45478                                  
 45479 00001086 E8C400                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45480                                  command_cont:
 45481 00001089 2EFF2E[5010]            	jmp	far [cs:DOSINTTABLE+8]	; jmp to DOS
 45482                                  
 45483                                  ;------------------------------------------------------------------------
 45484                                  ;
 45485                                  ; INT 25 
 45486                                  ;
 45487                                  ;----------------------------------------------------------------------------
 45488                                  
 45489                                  labsdrd:
 45490                                  	; The following jump, skipping the XMS calls will be patched to 
 45491                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45492                                  	; needed because the stub is installed even before the XMS driver
 45493                                  	; is loaded if the user specifies dos=high in the config.sys
 45494                                  i25patch:
 45495 0000108E EB03                    	jmp	short absdrd_cont	
 45496                                  
 45497 00001090 E8BA00                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45498                                  absdrd_cont:
 45499 00001093 2EFF2E[5410]            	jmp	far [cs:DOSINTTABLE+12]	; jmp to DOS
 45500                                  
 45501                                  ;-------------------------------------------------------------------------
 45502                                  ;
 45503                                  ; INT 26
 45504                                  ;
 45505                                  ;-----------------------------------------------------------------------
 45506                                  
 45507                                  labsdwrt:
 45508                                  	; The following jump, skipping the XMS calls will be patched to 
 45509                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45510                                  	; needed because the stub is installed even before the XMS driver
 45511                                  	; is loaded if the user specifies dos=high in the config.sys
 45512                                  i26patch:
 45513 00001098 EB03                    	jmp	short absdwrt_cont	
 45514                                  
 45515 0000109A E8B000                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45516                                  absdwrt_cont:
 45517 0000109D 2EFF2E[5810]            	jmp	far [cs:DOSINTTABLE+16]	; jmp to DOS
 45518                                  
 45519                                  ;------------------------------------------------------------------------
 45520                                  ;
 45521                                  ; INT 27
 45522                                  ;
 45523                                  ;-----------------------------------------------------------------------
 45524                                  
 45525                                  lstay_resident:
 45526                                  	; The following jump, skipping the XMS calls will be patched to 
 45527                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45528                                  	; needed because the stub is installed even before the XMS driver
 45529                                  	; is loaded if the user specifies dos=high in the config.sys
 45530                                  i27patch:
 45531 000010A2 EB03                    	jmp	short sr_cont	
 45532                                  
 45533 000010A4 E8A600                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45534                                  sr_cont:
 45535 000010A7 2EFF2E[5C10]            	jmp	far [cs:DOSINTTABLE+20]	; jmp to DOS
 45536                                  
 45537                                  ;-----------------------------------------------------------------------------
 45538                                  ;
 45539                                  ; INT 2f
 45540                                  ;
 45541                                  ;-------------------------------------------------------------------------
 45542                                  
 45543                                  lint2f:
 45544                                  	; The following jump, skipping the XMS calls will be patched to 
 45545                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45546                                  	; needed because the stub is installed even before the XMS driver
 45547                                  	; is loaded if the user specifies dos=high in the config.sys
 45548                                  i2fpatch:
 45549 000010AC EB03                    	jmp	short int2f_cont	
 45550                                  
 45551 000010AE E89C00                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45552                                  int2f_cont:
 45553 000010B1 2EFF2E[6010]            	jmp	far [cs:DOSINTTABLE+24]	; jmp to DOS
 45554                                  
 45555                                  ;-----------------------------------------------------------------------------
 45556                                  ;
 45557                                  ; CPM entry
 45558                                  ;
 45559                                  ;------------------------------------------------------------------------
 45560                                  
 45561                                  lcall_entry:
 45562                                  	; The following jump, skipping the XMS calls will be patched to 
 45563                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45564                                  	; needed because the stub is installed even before the XMS driver
 45565                                  	; is loaded if the user specifies dos=high in the config.sys
 45566                                  cpmpatch:
 45567 000010B6 EB03                    	jmp	short callentry_cont	
 45568                                  
 45569 000010B8 E89200                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45570                                  callentry_cont:
 45571 000010BB 2EFF2E[6410]            	jmp	far [cs:DOSINTTABLE+28]	; jmp to DOS
 45572                                  
 45573                                  ;--------------------------------------------------------------------------
 45574                                  
 45575                                  lirett:
 45576 000010C0 CF                      	iret
 45577                                  
 45578                                  ;---------------------------------------------------------------------------
 45579                                  ;
 45580                                  ; LowIntXX:
 45581                                  ;
 45582                                  ; Interrupts from DOS that pass control to a user program must be done from
 45583                                  ; low memory, as the user program may change the state of the A20 line or
 45584                                  ; they may require that the A20 line be OFF. The following piece of code is
 45585                                  ; far call'd from the following places in DOS:
 45586                                  ;
 45587                                  ;	1. msctrlc.asm where dos issues an int 23h (ctrlc)
 45588                                  ;	2. msctrlc.asm where dos issues an int 24h (critical error)
 45589                                  ;	3. msctrlc.asm where dos issues an int 28h (idle int)
 45590                                  ;
 45591                                  ; The int 23 and int 24 handlers may decide to do a far return instead of an
 45592                                  ; IRET ane leave the flags on the stack. Therefore we save the return address
 45593                                  ; before doing the ints and then do a far junp back into DOS.
 45594                                  ;
 45595                                  ;---------------------------------------------------------------------------
 45596                                  
 45597 000010C1 00000000                DosRetAddr23:	dd	0
 45598 000010C5 00000000                DosRetAddr24:	dd	0
 45599 000010C9 00000000                DosRetAddr28:	dd	0
 45600                                  
 45601                                  	; Execute int 23h from low memory
 45602                                  LowInt23:
 45603                                  					; save the return address that is on
 45604                                  					; the stack
 45605 000010CD 2E8F06[C110]            	pop	word [cs:DosRetAddr23]
 45606 000010D2 2E8F06[C310]            	pop	word [cs:DosRetAddr23+2]
 45607                                  
 45608 000010D7 CD23                    	int	23h			; ctrl C
 45609                                  					; turn on A20 it has been turned OFF
 45610                                  					; by int 28/23/24 handler.
 45611                                  
 45612 000010D9 E87100                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF 
 45613                                  
 45614 000010DC 2EFF2E[C110]            	jmp	far [cs:DosRetAddr23]	; jump back to DOS
 45615                                  
 45616                                  
 45617                                  	; Execute int 24h from low memory
 45618                                  LowInt24:
 45619                                  					; save the return address that is on
 45620                                  					; the stack
 45621 000010E1 2E8F06[C510]            	pop	word [cs:DosRetAddr24]
 45622 000010E6 2E8F06[C710]            	pop	word [cs:DosRetAddr24+2]
 45623                                  
 45624 000010EB CD24                    	int	24h			; crit error
 45625                                  					; turn on A20 it has been turned OFF
 45626                                  					; by int 28/23/24 handler.
 45627                                  
 45628 000010ED E85D00                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF	
 45629                                  
 45630 000010F0 2EFF2E[C510]            	jmp	far [cs:DosRetAddr24]	; jump back to DOS
 45631                                  
 45632                                  
 45633                                   
 45634                                  	; Execute int 28h from low memory
 45635                                  LowInt28:
 45636 000010F5 CD28                    	int	28h			; idle int
 45637                                  					; turn on A20 it has been turned OFF
 45638                                  					; by int 28/23/24 handler.
 45639                                  
 45640 000010F7 E85300                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF	
 45641                                  
 45642 000010FA CB                      	retf
 45643                                  
 45644                                  ; DOSDATA:1115h (MSDOS 6.21, MSDOS.SYS)
 45645                                  
 45646                                  ;-------------------------------------------------------------------------
 45647                                  ;
 45648                                  ; int 21 ah=4b (exec) call will jump to the following label before xferring
 45649                                  ; control to the exec'd program. We turn off A20 inorder to allow programs
 45650                                  ; that have been packed by the faulty exepack utility to unpack correctly.
 45651                                  ; This is so because exepac'd programs rely on address wrap.
 45652                                  ;
 45653                                  ;------------------------------------------------------------------------- 
 45654                                  
 45655                                  disa20_xfer:
 45656 000010FB E83F00                  	call	XMMDisableA20		; disable A20
 45657                                  
 45658                                  	; Look at msproc.asm at label exec_go for understanding the following:
 45659                                  
 45660                                  	; DS:SI points to entry point
 45661                                  	; AX:DI points to initial stack
 45662                                  	; DX has PDB pointer
 45663                                  	; BX has initial AX value
 45664                                  
 45665 000010FE FA                      	cli
 45666 000010FF 2EC606[2103]00          	mov	byte [cs:INDOS],0	; SS Override
 45667                                  
 45668 00001105 8ED0                    	mov	SS,AX			; set up user's stack
 45669 00001107 89FC                    	mov	SP,DI			; and SP
 45670 00001109 FB                      	sti
 45671                                  
 45672 0000110A 1E                      	push	DS			; fake long call to entry
 45673 0000110B 56                      	push	SI
 45674 0000110C 8EC2                    	mov	ES,DX			; set up proper seg registers
 45675 0000110E 8EDA                    	mov	DS,DX
 45676 00001110 89D8                    	mov	AX,BX			; set up proper AX
 45677 00001112 CB                      	retf
 45678                                  
 45679                                  ;-------------------------------------------------------------------------
 45680                                  ;
 45681                                  ; M003:
 45682                                  ;
 45683                                  ; If an int 21 ah=25 call is made immediately after an exec call, DOS will
 45684                                  ; come here, turn A20 OFF restore user stack and registers before returning 
 45685                                  ; to user. This is done in dos\msdisp.asm. This has been done to support 
 45686                                  ; programs compiled with MS PASCAL 3.2. See under TAG M003 in DOSSYM.INC for 
 45687                                  ; more info.	
 45688                                  ;
 45689                                  ; Also at this point DS is DOSDATA. So we can assume DS DOSDATA. Note that 
 45690                                  ; SS is also DOS stack. It is important that we do the XMS call on DOS's 
 45691                                  ; stack to avoid additional stack overhead for the user.
 45692                                  ;
 45693                                  ; -------------------------------------------------------------------------
 45694                                  
 45695                                  disa20_iret:
 45696 00001113 E82700                  	call	XMMDisableA20
 45697 00001116 FE0E[2103]              	dec	byte [INDOS]
 45698 0000111A 8E16[8605]              	mov	SS,[USER_SS]		; restore user stack
 45699 0000111E 8B26[8405]              	mov	SP,[USER_SP]
 45700 00001122 89E5                    	mov	BP,SP
 45701                                  	;mov	[BP+user_env.user_AX],AL
 45702 00001124 884600                  	mov	[bp],al
 45703 00001127 A1[F205]                	mov	AX,[NSP]
 45704 0000112A A3[8405]                	mov	[USER_SP],AX
 45705 0000112D A1[F005]                	mov	AX,[NSS]
 45706 00001130 A3[8605]                	mov	[USER_SS],AX
 45707                                  
 45708 00001133 58                      	pop	AX			; restore user regs
 45709 00001134 5B                      	pop	BX
 45710 00001135 59                      	pop	CX
 45711 00001136 5A                      	pop	DX
 45712 00001137 5E                      	pop	SI
 45713 00001138 5F                      	pop	DI
 45714 00001139 5D                      	pop	BP
 45715 0000113A 1F                      	pop	DS
 45716 0000113B 07                      	pop	ES
 45717 0000113C CF                      	iret
 45718                                  
 45719                                  ;**************************************************************************
 45720                                  ;***	XMMDisableA20 - switch 20th address line			      
 45721                                  ;									      
 45722                                  ;	This routine is used to disable the 20th address line in 	      
 45723                                  ;	the system using XMM calls.					      
 45724                                  ;									      
 45725                                  ;	ENTRY	none		;ds = _DATA				      
 45726                                  ;	EXIT	A20 line disabled					      
 45727                                  ;	USES	NOTHING					      
 45728                                  ;									      
 45729                                  ;**************************************************************************
 45730                                  
 45731                                  XMMDisableA20:
 45732 0000113D 53                      	push	bx
 45733 0000113E 50                      	push	ax
 45734                                  	;mov	ah,XMM_LOCAL_DISABLE_A20
 45735 0000113F B406                    	mov	ah,6
 45736 00001141 2EFF1E[4911]            	call	far [cs:XMMcontrol]
 45737 00001146 58                      	pop	ax
 45738 00001147 5B                      	pop	bx
 45739 00001148 C3                      	retn
 45740                                  
 45741                                  ; The entry point in the BIOS XMS driver is defined here.
 45742                                  
 45743                                  XMMcontrol:
 45744 00001149 00000000                	dd	0
 45745                                  
 45746                                  ;--------------------------------------------------------------------------
 45747                                  ;
 45748                                  ;***	EnsureA20ON - Ensures that A20 is ON
 45749                                  ;									      
 45750                                  ;	This routine is used to query the A20 state in		 	      
 45751                                  ;	the system using XMM calls.					      
 45752                                  ;									      
 45753                                  ;	ENTRY: none		
 45754                                  ;
 45755                                  ;	EXIT : A20 will be ON
 45756                                  ;		
 45757                                  ; 	USES : NONE								      
 45758                                  ;									      
 45759                                  ;--------------------------------------------------------------------------
 45760                                  
 45761                                  ; 19/09/2023
 45762                                  ;LowMemory:	; label dword		; Set equal to 0000:0080
 45763                                  ;	dw	00080h
 45764                                  ;	dw	00000h
 45765                                  ;
 45766                                  ;HighMemory:	; label dword
 45767                                  ;	dw	00090h			; Set equal to FFFF:0090
 45768                                  ;	dw	0FFFFh
 45769                                  
 45770                                  EnsureA20ON:
 45771 0000114D 9C                      	pushf
 45772 0000114E 1E                      	push    ds
 45773 0000114F 06                      	push	es
 45774 00001150 51                      	push	cx
 45775 00001151 56                      	push	si
 45776 00001152 57                      	push	di
 45777                                  
 45778                                  	; 19/09/2023
 45779                                  	;lds	si,[cs:LowMemory]	; Compare the 4 words at 0000:0080
 45780                                  	;les	di,[cs:HighMemory]	; with the 4 at FFFF:0090
 45781                                  
 45782 00001153 31FF                    	xor	di,di
 45783 00001155 8EC7                    	mov	es,di
 45784 00001157 4F                      	dec	di
 45785 00001158 BE9000                  	mov	si,90h	; 0FFFFh:0090h	; HighMemory
 45786 0000115B 8EDF                    	mov	ds,di
 45787 0000115D BF8000                  	mov	di,80h ; 0000h:0080h	; LowMemory
 45788                                  	
 45789 00001160 B90400                  	mov	cx,4
 45790 00001163 FC                      	cld
 45791 00001164 F3A7                    	repe    cmpsw
 45792                                  
 45793 00001166 7407                    	jz	short EA20_OFF
 45794                                  EA20_RET:
 45795 00001168 5F                      	pop	di
 45796 00001169 5E                      	pop	si
 45797 0000116A 59                      	pop	cx
 45798 0000116B 07                      	pop	es
 45799 0000116C 1F                      	pop	ds
 45800 0000116D 9D                      	popf
 45801 0000116E C3                      	retn
 45802                                  
 45803                                  EA20_OFF:
 45804                                  	; We are going to do the XMS call on the DOS's AuxStack.
 45805                                  	; NOTE: ints are disabled at this point.
 45806                                  
 45807 0000116F 53                      	push	bx
 45808 00001170 50                      	push	ax
 45809                                  
 45810 00001171 8CD0                    	mov	ax,ss			; save user's stack pointer
 45811 00001173 2EA3[6C10]              	mov	[cs:SS_Save],ax
 45812 00001177 2E8926[6E10]            	mov	[cs:SP_Save],sp
 45813 0000117C 8CC8                    	mov	ax,cs
 45814 0000117E 8ED0                    	mov	ss,ax
 45815 00001180 BC[A007]                	mov	sp,AUXSTACK
 45816                                  					; ss:sp -> DOSDATA:AuxStack
 45817                                  	;mov	ah,XMM_LOCAL_ENABLE_A20
 45818 00001183 B405                    	mov	ah,5
 45819 00001185 2EFF1E[4911]            	call	far [cs:XMMcontrol]
 45820 0000118A 09C0                    	or	ax,ax
 45821 0000118C 740F                    	jz	short XMMerror		; AX = 0 fatal error
 45822                                  
 45823 0000118E 2EA1[6C10]              	mov	ax,[cs:SS_Save]		; restore user stack
 45824 00001192 8ED0                    	mov	ss,ax
 45825 00001194 2E8B26[6E10]            	mov	sp,[cs:SP_Save]
 45826                                  
 45827 00001199 58                      	pop	ax
 45828 0000119A 5B                      	pop	bx
 45829                                  
 45830 0000119B EBCB                    	jmp	short EA20_RET
 45831                                  
 45832                                  XMMerror:				; M006 - Start
 45833 0000119D B40F                    	mov	ah,0Fh			; get video mode
 45834 0000119F CD10                    	int	10h
 45835 000011A1 3C07                    	cmp	al,7			; Q: are we an MDA
 45836 000011A3 7406                    	je	short XMMcont			; Y: do not change mode
 45837 000011A5 30E4                    	xor	ah,ah ; 0			; set video mode
 45838 000011A7 B002                    	mov	al,02h			; 80 X 25 text
 45839 000011A9 CD10                    	int	10h
 45840                                  XMMcont:
 45841 000011AB B405                    	mov	ah,05h			; set display page
 45842 000011AD 30C0                    	xor	al,al			; page 0
 45843 000011AF CD10                    	int	10h
 45844                                  	
 45845 000011B1 BE[8E12]                	mov	si,XMMERRMSG
 45846 000011B4 0E                      	push	cs
 45847 000011B5 1F                      	pop	ds
 45848 000011B6 FC                      	cld				; clear direction flag
 45849                                  XMMprnt:
 45850 000011B7 AC                      	lodsb
 45851 000011B8 3C24                    	cmp	al,'$'			; indicates end of XMMERRMSG
 45852 000011BA 7409                    	jz	short XMMStall		; function 0Eh	
 45853 000011BC B40E                    	mov	ah,0Eh
 45854 000011BE BB0700                  	mov	bx,7
 45855 000011C1 CD10                    	int	10h
 45856 000011C3 EBF2                    	jmp	short XMMprnt
 45857                                  
 45858                                  XMMStall:
 45859 000011C5 FB                      	sti				; allow the user to warm boot
 45860 000011C6 EBFD                    	jmp	short XMMStall		; M006 - End
 45861                                  
 45862                                  ;---------------------------------------------------------------------------
 45863                                  
 45864                                  ; 27/04/2019 - Retro DOS v4.0
 45865                                  
 45866                                  ; retrodos4.s ; offset 0Ch in BIOS segment (0070h)
 45867                                  ALTAH	equ 0Ch
 45868                                  
 45869                                  ;This has been put in for WIN386 2.XX support. The format of the instance 
 45870                                  ;table was different for this. Segments will be patched in at init time.
 45871                                  
 45872                                  OldInstanceJunk:
 45873 000011C8 7000                    	dw	70h	;segment of BIOS
 45874 000011CA 0000                    	dw	0	;indicate stacks in SYSINIT area
 45875 000011CC 0600                    	dw	6	;5 instance items
 45876                                  
 45877                                  	;dw	0,offset dosdata:contpos, 2
 45878                                  	;dw	0,offset dosdata:bcon, 4
 45879                                  	;dw	0,offset dosdata:carpos,106h
 45880                                  	;dw	0,offset dosdata:charco, 1
 45881                                  	;dw	0,offset dosdata:exec_init_sp, 34               ;M032
 45882                                  	;dw	070h,offset BData:altah, 1	 ; altah byte in bios
 45883                                  
 45884 000011CE 0000[2200]0200          	dw	0,CONTPOS,2
 45885 000011D4 0000[3200]0400          	dw	0,BCON,4
 45886 000011DA 0000[F901]0601          	dw	0,CARPOS,106h
 45887 000011E0 0000[0003]0100          	dw	0,CHARCO,1
 45888 000011E6 0000[C00F]2200          	dw	0,exec_init_SP,34
 45889 000011EC 70000C000100            	dw	70h,ALTAH,1	; altah byte in bios
 45890                                  
 45891                                  ;---------------------------------------------------------------------------
 45892                                  
 45893                                  ; M021-
 45894                                  ;
 45895                                  ; DosHasHMA - This flag is set by seg_reinit when the DOS actually
 45896                                  ; 	takes control of the HMA. When running, this word is a reliable
 45897                                  ;	indicator that the DOS is actually using HMA. You can't just use
 45898                                  ;	CS, because ROMDOS uses HMA with CS < F000.
 45899                                  
 45900                                  DosHasHMA:
 45901 000011F2 00                      	db	0
 45902                                  FixExePatch:
 45903 000011F3 0000                    	dw	0		; M012
 45904                                  
 45905                                  ; 28/12/2022 - Retro DOS v4.1
 45906                                  ;RationalPatchPtr:
 45907                                  ;	dw	0		; M012
 45908                                  
 45909                                  ; End M021
 45910                                  
 45911                                  ;---------------------------------------------------------------------------
 45912                                  
 45913                                  ; 28/12/2022 - Retro DOS v4.1
 45914                                  %if 0
 45915                                  
 45916                                  ; M020 Begin
 45917                                  
 45918                                  RatBugCode:	; proc	far
 45919                                  	push	cx
 45920                                  	mov	cx,[10h]
 45921                                  rbc_loop:
 45922                                  	;loop	$
 45923                                  	loop	rbc_loop
 45924                                  	pop	cx
 45925                                  	retf
 45926                                  		
 45927                                  ; M020 End
 45928                                  
 45929                                  %endif
 45930                                  
 45931                                  ;---------------------------------------------------------------------------
 45932                                  	
 45933                                  UmbSave1:
 45934                                  	;db	11 dup (?)	; M023
 45935 000011F5 00<rep Bh>              	times	11 db 0	
 45936                                  
 45937                                  ; DOSDATA:122Ah
 45938                                  
 45939                                  Mark3:	; label byte
 45940                                  
 45941                                  ;IF2
 45942                                  ;	IF ((OFFSET MARK3) GT (OFFSET COUNTRY_CDPG) )
 45943                                  ;		%OUT !DATA CORRUPTION!MARK3 OFFSET TOO BIG. RE-ORGANIZE DATA.
 45944                                  ;	ENDIF
 45945                                  ;ENDIF
 45946                                  
 45947                                  ;############################################################################
 45948                                  ;
 45949                                  ; ** HACK FOR DOS 4.0 REDIR **
 45950                                  ;
 45951                                  ; The dos 4.X redir requires that country_cdpg is at offset 0122ah. Any new
 45952                                  ; data variable that is to be added to DOSDATA must go in between Mark3
 45953                                  ; COUNTRY_CDPG if it can. 
 45954                                  ;
 45955                                  ; MARK3 SHOULD NOT BE > 122AH 
 45956                                  ;
 45957                                  ; As of 9/6/90, this area is FULL!
 45958                                  ;
 45959                                  ;############################################################################
 45960                                   
 45961                                  	;ORG	0122Ah
 45962                                  
 45963                                  ; DOSDATA:122Ah (MSDOS 6.21, MSDOS.SYS)
 45964                                  
 45965                                  ; The following table is used for DOS 3.3
 45966                                  ;DOS country and code page information is defined here for DOS 3.3.
 45967                                  ;The initial value for ccDosCountry is 1 (USA).
 45968                                  ;The initial value for ccDosCodepage is 850.
 45969                                  
 45970                                  ; country and code page information
 45971                                  ; ---------------------------------------------------------------------------
 45972                                  COUNTRY_CDPG:	; label  byte
 45973 00001200 0000000000000000        	db   0,0,0,0,0,0,0,0		; reserved words
 45974 00001208 5C434F554E5452592E-     	db   '\COUNTRY.SYS',0		; path name of country.sys
 45974 00001211 53595300           
 45975                                  	;db   51 dup (?)
 45976 00001215 00<rep 33h>             	times 51 db 0
 45977                                  ; ------------------------------------------------<MSKK01>-------------------
 45978                                  ;ifdef	DBCS
 45979                                  ;  ifdef JAPAN
 45980                                  ;	dw   932			; system code page id (JAPAN)
 45981                                  ;  endif
 45982                                  ;  ifdef TAIWAN
 45983                                  ;	dw   938			; system code page id (TAIWAN)
 45984                                  ;  endif
 45985                                  ;  ifdef KOREA
 45986                                  ;	dw   934			; system code page id (KOREA IBM)
 45987                                  ;  endif
 45988                                  ;else
 45989 00001248 B501                    	dw   437			; system code page id
 45990                                  ;endif
 45991                                  ; ------------------------------------------------<MSKK01>-------------------
 45992 0000124A 0600                    	dw   6				; number of entries
 45993 0000124C 02                      	db   SetUcase  ; 2		; Ucase type
 45994 0000124D [AD0A]                  	dw   UCASE_TAB			;pointer to upper case table
 45995 0000124F 0000                    	dw   0				; segment of poiter
 45996 00001251 04                      	db   SetUcaseFile  ; 4		; Ucase file char type
 45997 00001252 [2F0B]                  	dw   FILE_UCASE_TAB 		;pointer to file upper case table
 45998 00001254 0000                    	dw   0				; segment of poiter
 45999 00001256 05                      	db   SetFileList ; 5		; valid file chars type
 46000 00001257 [B10B]                  	dw   FILE_CHAR_TAB 		;pointer to valid file char tab
 46001 00001259 0000                    	dw   0				; segment of poiter
 46002 0000125B 06                      	db   SetCollate	; 6		; collate type
 46003 0000125C [E10B]                  	dw   COLLATE_TAB		;pointer to collate table
 46004 0000125E 0000                    	dw   0				; segment of poiter
 46005 00001260 07                      	db   SetDBCS	; 7		;AN000; DBCS Ev			2/12/KK
 46006 00001261 [E30C]                  	dw   DBCS_TAB			;AN000;pointer to DBCS Ev table	2/12/KK
 46007 00001263 0000                    	dw   0				;AN000; segment of pointer	2/12/KK
 46008 00001265 01                      	db   SetCountryInfo  ; 1	; country info type
 46009 00001266 2600                    	dw   NEW_COUNTRY_SIZE		; extended country info size
 46010                                  ; ------------------------------------------------<MSKK01>-------------------
 46011                                  ;ifdef	DBCS
 46012                                  ;	...... 
 46013                                  ;else
 46014 00001268 0100                    	dw   1				; USA country id
 46015 0000126A B501                    	dw   437			; USA system code page id
 46016 0000126C 0000                    	dw   0 				; date format
 46017 0000126E 2400000000              	db   '$',0,0,0,0		; currency symbol
 46018 00001273 2C00                    	db   ',',0			; thousand separator
 46019 00001275 2E00                    	db   '.',0			; decimal separator
 46020 00001277 2D00                    	db   '-',0			; date separator
 46021 00001279 3A00                    	db   ':',0			; time separator
 46022 0000127B 00                      	db   0				; currency format flag
 46023 0000127C 02                      	db   2				; # of digits in currency
 46024 0000127D 00                      	db   0 				; time format
 46025 0000127E [F50C]                  	dw   MAP_CASE			; mono case routine entry point
 46026 00001280 0000                    	dw   0				; segment of entry point
 46027 00001282 2C00                    	db   ',',0			; data list separator
 46028 00001284 000000000000000000-     	dw   0,0,0,0,0			; reserved
 46028 0000128D 00                 
 46029                                  ;endif
 46030                                  ; ------------------------------------------------<MSKK01>-------------------
 46031                                  
 46032                                  ; 27/04/2019 - Retro DOS v4.0
 46033                                  
 46034                                  ;include msdos.cl2			; XMMERRMSG
 46035                                  
 46036                                  ; DOSDATA:122Ah (MSDOS 6.21, MSDOS.SYS)
 46037                                  
 46038                                  XMMERRMSG:
 46039 0000128E 0D0A                    	db	0Dh,0Ah
 46040 00001290 413230204861726477-     	db	'A20 Hardware Error',0Dh,0Ah,'$'
 46040 00001299 617265204572726F72-
 46040 000012A2 0D0A24             
 46041                                  
 46042                                  ; DOSDATA ends
 46043                                  
 46044                                  ; 05/11/2022
 46045                                  ;----------------------------------------------------------------------------
 46046                                  ; End of MSDOS 5.0 MSDOS.SYS /// Retro DOS v4.0 (2022) - 05/11/2022
 46047                                  ;----------------------------------------------------------------------------
 46048                                  
 46049                                  ; 28/12/2022 - Retro DOS v4.1
 46050                                  ; (windows 3.1 and Rational Extender patches are removed/disabled)
 46051                                  ; (Windows 3.1 does not use the patches below if DOS version is MSDOS 5.0)
 46052                                  ;----------------------------------------------------------------------------
 46053                                  %if 0
 46054                                  
 46055                                  ;----------------------------------------------------------------------------
 46056                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 46057                                  
 46058                                  ;============================================================================
 46059                                  ; WPATCH.INC (MSDOS 6.0, 1991)  ;;; Windows 3.1 patches ;;;
 46060                                  ;============================================================================
 46061                                  ; 27/04/2019 - Retro DOS 4.0
 46062                                  
 46063                                  ;DOSDATA Segment
 46064                                  
 46065                                  ; DOSDATA:12CFh (MSDOS 6.21, MSDOS.SYS)
 46066                                  
 46067                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 46068                                  ; DOSDATA:12CFh (MSDOS 5.0, MSDOS.SYS)
 46069                                  
 46070                                  ; first and second DOS patches
 46071                                  ;	Non-console device read/write (system calls 3Fh and 40h)
 46072                                  ;
 46073                                  ; Code in disk.asm, 2 locations, one for read, one for write
 46074                                  ;	DVRDLP:
 46075                                  ;	DVWRTLP:
 46076                                  ;
 46077                                  ;
 46078                                  ; 036h	lds	si,SS:[????]				  ; ThisSFT
 46079                                  ;	lds	si,si+7 				  ; sf_devptr
 46080                                  ; 0E8h	call	????		<- "simulate" int28 event ; DSKSTATCHK
 46081                                  
 46082                                  DOSP1_ID:	db	036h,0C5h,036h
 46083                                  DOSP1_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 46084                                  DOSP1_ID_LEN	equ	$-DOSP1_ID
 46085                                  
 46086                                  		db	90h, 90h
 46087                                  
 46088                                  DOSP12_ID:	db	036h,0C5h,036h
 46089                                  DOSP12_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 46090                                  DOSP12_ID_LEN	equ	$-DOSP1_ID
 46091                                  
 46092                                  ; DOSDATA:12E3h
 46093                                  
 46094                                  ; Third/Fourth DOS patch - System call 3Fh (Read) from console
 46095                                  ;
 46096                                  ; Code in disk.asm, 1 location
 46097                                  ;	GETBUF:
 46098                                  ;
 46099                                  ; 051h	push	cx	<- begin special int28 mode
 46100                                  ;	push	es
 46101                                  ;	push	di
 46102                                  ;	mov	dx,???? ; offset dosgroup:CONBUF
 46103                                  ;	call	????	; $STD_CON_STRING_INPUT
 46104                                  ;	pop	di
 46105                                  ;	pop	es
 46106                                  ; 059h	pop	cx	<- end special int28 mode
 46107                                  
 46108                                  DOSP3_ID:	db	051h,006h,057h,0BAh
 46109                                  DOSP3_CONBUF:	db	029h,002h,0E8h
 46110                                  DOSP3_ID_LEN	equ	$-DOSP3_ID
 46111                                  		db	09Ah,0E3h,05Fh,007h	; ???? , pop di, pop es
 46112                                  DOSP4_ID:	db	059h			; pop cx
 46113                                  DOSP4_ID_OFF	equ	(DOSP4_ID - DOSP3_ID)
 46114                                  	
 46115                                  ; DOSDATA:12EFh
 46116                                  
 46117                                  ; Fifth DOS patch - System call 40h (Write) to console
 46118                                  ;
 46119                                  ; Code in disk.asm, 1 location
 46120                                  ;
 46121                                  ;		push	cx
 46122                                  ;      WRCONLP: lodsb
 46123                                  ;		cmp	al,1Ah
 46124                                  ;		jz	????
 46125                                  ;		call	????	<- "simulate" int28 event
 46126                                  ;		loop	WRCONLP
 46127                                  ;      CONEOF:	pop	ax
 46128                                  
 46129                                  DOSP5_ID:	db	051h			; push cx
 46130                                  		db	0ACh,03Ch,01Ah,074h,005h
 46131                                  		db	0E8h			; call
 46132                                  DOSP5_ID_LEN	equ	$-DOSP5_ID
 46133                                  
 46134                                  ; DOSDATA:12F6h
 46135                                  
 46136                                  ; Seventh DOS patch - System call entry, patch USER_ID with VMid for share
 46137                                  ;
 46138                                  ; Code in disp.asm, 1 location
 46139                                  ;
 46140                                  ;
 46141                                  ;	mov [SaveDS],ds
 46142                                  ;	mov [SaveBX],bx
 46143                                  ;	mov bx,cs
 46144                                  ;	mov ds,bx
 46145                                  ;	inc [indos]
 46146                                  ;	xor ax,ax
 46147                                  ;	mov [USER_ID],AX	<- Patch to set USER_ID to VMID
 46148                                  
 46149                                  DOSP7_ID:	db	02Eh,08Ch,01Eh
 46150                                  DOSP7_SAVEDS:	db	07Eh,05h		; mov [SaveDS],ds
 46151                                  		db	02Eh,089h,01Eh
 46152                                  DOSP7_SAVEBX:	db	07Ch,05h		; mov [SaveBX],bx
 46153                                  		db	08Ch,0CBh		; mov bx,cs
 46154                                  		db	08Eh,0DBh		; mov ds,bx
 46155                                  		db	0FEh,006h
 46156                                  DOSP7_INDOS:	db	0CFh,002h		; inc [indos]
 46157                                  		db	033h,0C0h		; xor ax,ax
 46158                                  DOSP7_ID_LEN	equ	$-DOSP7_ID
 46159                                  
 46160                                  ; DOSDATA:130Ah
 46161                                  
 46162                                  ; Eighth DOS patch - OWNER check in handle calls. For share, need to NOP test
 46163                                  ;
 46164                                  ; Code in handle.asm, 1 location in routine CheckOwner
 46165                                  ;
 46166                                  ;
 46167                                  ;
 46168                                  ;	push	ax
 46169                                  ;	mov	ax,ss:[USER_ID]     <- patch to XOR AX,AX to set zero
 46170                                  ;	cmp	ax,es:[di.sf_UID]   <- NOP
 46171                                  ;	pop	ax
 46172                                  ;	jz	????
 46173                                  
 46174                                  DOSP8_ID:	db	050h			; push ax
 46175                                  		db	036h,0A1h
 46176                                  DOSP8_USER_ID:	db	0EAh,002h		; mov  ax,ss:[USER_ID]
 46177                                  		db	026h,03Bh,045h		; cmp  ax,es:[di+2F]
 46178                                  DOSP8_ID_LEN	equ	$-DOSP8_ID
 46179                                  		db	02Fh,058h		; pop  ax
 46180                                  
 46181                                  ; DOSDATA:1314h
 46182                                  
 46183                                  ; 10th, 11th, 12th DOS patch - System call 3Fh (Read) in raw mode
 46184                                  ;
 46185                                  ;   Take RAW read to STDIN SFT and turn it into a polling loop doing
 46186                                  ;   a yeild when a character is not ready to be read.
 46187                                  ;
 46188                                  ; Code in disk.asm, 3 locations
 46189                                  ;
 46190                                  ;   DVRDRAW:
 46191                                  ;	    PUSH    ES
 46192                                  ;	    POP     DS
 46193                                  ;   ReadRawRetry:				<- Patch 10
 46194                                  ;	    MOV     BX,DI
 46195                                  ;	    XOR     AX,AX			<- Reenter #2
 46196                                  ;	    MOV     DX,AX
 46197                                  ;	    call    SETREAD
 46198                                  ;	    PUSH    DS				<- Reenter #1
 46199                                  ;	    LDS     SI,[THISSFT]
 46200                                  ;	    call    DEVIOCALL
 46201                                  ;	    MOV     DX,DI
 46202                                  ;	    MOV     AH,86H
 46203                                  ;	    MOV     DI,[DEVCALL.REQSTAT]
 46204                                  ;	    TEST    DI,STERR
 46205                                  ;	    JZ	    CRDROK
 46206                                  ;	    call    CHARHARD
 46207                                  ;	    MOV     DI,DX
 46208                                  ;	    OR	    AL,AL
 46209                                  ;	    JZ	    CRDROK
 46210                                  ;	    CMP     AL,3
 46211                                  ;	    JZ	    CRDFERR
 46212                                  ;	    POP     DS
 46213                                  ;	    JMP     ReadRawRetry
 46214                                  ;
 46215                                  ;   CRDFERR:
 46216                                  ;	    POP     DI				<- Patch 11
 46217                                  ;   DEVIOFERR:
 46218                                  ;	    LES     DI,[THISSFT]
 46219                                  ;	    jmp     SET_ACC_ERR_DS
 46220                                  ;
 46221                                  ;   CRDROK:
 46222                                  ;	    POP     DI				<- Patch 12
 46223                                  ;	    MOV     DI,DX
 46224                                  ;	    ADD     DI,[CALLSCNT]
 46225                                  ;	    JMP     SHORT ENDRDDEVJ3
 46226                                  
 46227                                  DOSP10_ID:		db	006H,01FH
 46228                                  DOSP10_LOC_OFFSET	equ	$-DOSP10_ID
 46229                                  DOSP10_LOC:		db	08BH,0DFH
 46230                                  DOSP10_REENT2_OFFSET	equ	$-DOSP10_LOC
 46231                                  			db	033H,0C0H,08BH,0D0H,0E8H
 46232                                  DOSP10_ID_LEN		equ	$-DOSP10_ID
 46233                                  			db	0DFH,00EH
 46234                                  DOSP10_REENT1_OFFSET	equ	$-DOSP10_LOC
 46235                                  			db	01EH,036H,0C5H,036H,036H,005H,0E8H,0AFH,00EH
 46236                                  			db	08BH,0D7H,0B4H,086H,036H,08BH,03EH
 46237                                  DOSP10_PACKVAL_OFFSET	equ	$-DOSP10_ID
 46238                                  			db	009H,003H
 46239                                  			db	0F7H,0C7H,000H,080H,074H,019H,0E8H,047H,017H
 46240                                  			db	08BH,0FAH,00AH,0C0H,074H,010H,03CH,003H,074H,003H
 46241                                  			db	01FH,0EBH,0CFH
 46242                                  DOSP11_LOC_OFFSET	equ	$-DOSP10_ID
 46243                                  			db	05FH
 46244                                  DOSP11_REENT_OFFSET	equ	$-DOSP10_LOC
 46245                                  			db	036H,0C4H,03EH,036H,005H,0E9H,0A1H,004H
 46246                                  
 46247                                  DOSP12_LOC_OFFSET	equ	$-DOSP10_ID
 46248                                  			db	05FH,08BH,0FAH
 46249                                  ; DOSDATA:1353h
 46250                                  
 46251                                  ; 13th DOS patch - Actually a SYSINIT patch. Patches the stack fault code
 46252                                  ;		which prints the fatal stack fault error on DOS >= 3.20.
 46253                                  ;
 46254                                  ;	    Sets focus to current VM so user can see fatal message.
 46255                                  ;
 46256                                  ;
 46257                                  ;	l0: lodsb		<- Setfocus here
 46258                                  ;	    cmp al, '$'
 46259                                  ;	    je l1
 46260                                  ;	    mov bl, 7
 46261                                  ;	    mov ah, 0Eh
 46262                                  ;	    int 10h
 46263                                  ;	    jmp l0
 46264                                  ;	l1: jmp $
 46265                                  
 46266                                  DOSP13_ID:	db	0ACh			; l0: lodsb
 46267                                  		db	03Ch,024h		;     cmp al, '$'
 46268                                  		db	074h,008h		;     je l1
 46269                                  		db	0B3h,007h		;     mov bl, 7
 46270                                  		db	0B4h,00Eh		;     mov ah, 0Eh
 46271                                  		db	0CDh,010h		;     int 10h
 46272                                  		db	0EBh,0F3h		;     jmp l0
 46273                                  		db	0EBh,0FEh		; l1: jmp $
 46274                                  DOSP13_ID_LEN	equ	$-DOSP13_ID
 46275                                  
 46276                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 46277                                  ; DOSDATA:1362h (MSDOS 5.0 MSDOS.SYS)
 46278                                  
 46279                                  ; 06/12/2022
 46280                                  ;DOSDATASIZE	equ  $ - DOSDATASTART ; 4962 bytes (1362h)
 46281                                  
 46282                                  ; DOSDATA ends
 46283                                  
 46284                                  ;============================================================================
 46285                                  ; MPATCH.ASM (MSDOS 6.0, 1993)
 46286                                  ;============================================================================
 46287                                  ; 27/04/2019 - Retro DOS 4.0
 46288                                  
 46289                                  ;mpatch.asm -- holds data patch location for callouts 
 46290                                  ; -- allocate cluster in rom.asm
 46291                                  ;
 46292                                  ; This area is pointed to by OffsetMagicPatch[609h] in fixed DOS data.
 46293                                  ; Currently, this location is used only by magicdrv.sys's patch to
 46294                                  ; cluster allocation, however it can be expanded to be used by other
 46295                                  ; patches. This is important since we have an easy-access pointer to
 46296                                  ; this location in OffsetMagicPatch. Magicdrv.sys is guaranteed to
 46297                                  ; only patch out a far call/retf, so any space after that could be
 46298                                  ; used as a patch by using OffsetMagicPatch+6. See rom.asm on how
 46299                                  ; to call out here.
 46300                                  ;
 46301                                  ; Currently, we allocate only the minimum space required for the 6
 46302                                  ; byte magicdrv patch, so if you change the dos data, you may want
 46303                                  ; to reserve space here if your new data will be position dependent
 46304                                  ; and would prohibit growing of this table.
 46305                                  ;       
 46306                                  ;history	-	created 8-7-92 by scottq
 46307                                  ;		-	added Rational386PatchPtr 2-1-93 by jimmat
 46308                                  ;
 46309                                  ;Exported Functions
 46310                                  ;==================
 46311                                  ;MagicPatch     -       callout patched by magidrv.sys for cluster allocations
 46312                                  
 46313                                  ; DosData Segment
 46314                                  
 46315                                  ; DOSDATA:1362h (MSDOS 6.21, MSDOS.SYS)
 46316                                  
 46317                                  ; ---------------------------------------------------------------------------
 46318                                  
 46319                                  ; Rational386PatchPtr points to either a RET instruction (80286 or less) or
 46320                                  ; a routine to fix buggy versions of the Rational DOS Extender (80386 or
 46321                                  ; greater). Added to this file because it needed to be somewhere and is
 46322                                  ; 'patch' related.
 46323                                  
 46324                                  Rational386PatchPtr:
 46325                                  	dw	0	; points to patch routine or RET instr.
 46326                                  ; ---------------------------------------------------------------------------
 46327                                  
 46328                                  MagicPatch:
 46329                                  ;MagicPatch proc far
 46330                                          retf            ;default is to just return to allocate
 46331                                          nop             ;however, this code will be patched
 46332                                          nop             ;by magicdrv.sys to
 46333                                          nop             ; call far ?:?     
 46334                                          nop             ; retf or perhaps just jmp far
 46335                                          nop             ;retf/nop take one byte, so we need six instructions
 46336                                                          ;for 6 byte patch
 46337                                  ;MagicPatch endp
 46338                                  
 46339                                  ; ---------------------------------------------------------------------------
 46340                                  
 46341                                  ;DosData Ends
 46342                                  
 46343                                  ; DOSDATA:136Ah
 46344                                  
 46345                                  ;----------------------------------------------------------------------------
 46346                                  
 46347                                  ;DOSDATALAST SEGMENT
 46348                                  
 46349                                  ; 29/04/2019 - Retro DOS v4.0
 46350                                  
 46351                                  ;----------------------------------------------------------------------------
 46352                                  ; 25/05/2019 - Retro DOS v4.0 Modification (paragraph alignment)
 46353                                  
 46354                                  ;db 0,1,12,64,19,0 ; ! Magic numbers !
 46355                                  
 46356                                  ;align 16
 46357                                  
 46358                                  ; !!! DOSDATA:1370h ; Retro DOS v4.0 only!
 46359                                  
 46360                                  ;----------------------------------------------------------------------------
 46361                                  
 46362                                  %endif	; 05/11/2022
 46363                                  
 46364                                  ; 05/12/2022
 46365                                  ;MSDAT001E:	; label byte
 46366                                  
 46367                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 46368                                  DOSDATAEND equ $
 46369                                  DOSDATASIZE equ DOSDATAEND - DOSDATASTART ; = 4962 for MSDOS 5.0 MSDOS.SYS
 46370                                  MSDAT001E equ DOSDATAEND - DOSDATASTART
 46371                                  
 46372                                  ;DOSDATALAST ENDS
 46373                                  
 46374                                  ; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 5.0 KERNEL via NASM)
 46375                                  ; DECEMBER 2022, ISTANBUL - TURKIYE.
 46376                                  ;============================================================================
 46377                                  ;	END
 46378                                  ;============================================================================
 46379                                  ; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 6.21 KERNEL via NASM)
 46380                                  ; -----------------------------
 46381                                  ; MAY 2019, ISTANBUL - TURKIYE.
