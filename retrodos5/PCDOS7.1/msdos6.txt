     1                                  ;*****************************************************************************
     2                                  ; MSDOS6.BIN (MSDOS 6.0 Kernel) - RETRO DOS v4.0 by ERDOGAN TAN - 03/11/2022
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 09/01/2024 - Retro DOS v4.2 ((Previous: 29/09/2023))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 07/07/2018 (Retro DOS 3.0), 22/04/2019 (Retro DOS 4.0)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	   ((nasm msdos6.s -l msdos6.lst -o MSDOS6.BIN -Z error.txt)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Modified from 'msdos3.s' file of Retro DOS 3.0 source code (10/09/2018)
    13                                  ; ----------------------------------------------------------------------------
    14                                  ; Derived from 'msdos2.s' file of Retro DOS 2.0 source code (04/05/2018)
    15                                  ; ----------------------------------------------------------------------------
    16                                  ; Derived from 'MSCODE.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
    17                                  ; by Microsoft, 25/08/1983 (DOSLINK - 'MSDOS.ASM')
    18                                  ;*****************************************************************************
    19                                  ; main file: 'retrodos4.s'
    20                                  ; incbin 'MSDOS5.BIN'
    21                                  ;=============================================================================
    22                                  ; Modified from 'msdos6.s' (modified MSDOS 6.21 kernel src as Retro DOS v4.0)
    23                                  ; 28/07/2019  /// Retro DOS v4.0 (2022) -> Modified MSDOS 5.0 IO.SYS+MSDOS.SYS
    24                                  ;=============================================================================
    25                                  
    26                                  ; 30/12/2022 - Retro DOS v4.2 Kernel ('msdos6.s')
    27                                  ; Modified from 'msdos5.s' (29/12/2022, Retro DOS v4.1 Kernel) file
    28                                  ; as below:
    29                                  ;	1) MS-DOS version has been changed to 6.22 (It was 5.0) 
    30                                  ;	2) Retro DOS version has been changed to 4.2 (It was 4.1)
    31                                  ; (The content has not been changed except kernel version because the kernel
    32                                  ;  code is already compatible with MSDOS 6.x and it is optimized before.
    33                                  ;	(But IO.SYS part of the kernel is not same with Retro DOS v4.1 code.)	
    34                                  
    35                                  ; ----------------------------------------------------------------------------
    36                                  
    37                                  ; 03/11/2022 - Erdogan Tan (Istanbul)
    38                                  
    39                                  ; Note:	This code is a part of Retro DOS 4.0 kernel source code
    40                                  ;	(as included binary, 'MSDOS5.BIN') 
    41                                  ;	Equivalent of MSDOS 5.0 MSDOS.SYS kernel file 
    42                                  ;	
    43                                  ;	((MSDOS 6.0 kernel source code has been modified by using disassembled
    44                                  ;	MSDOS 5.0 MSDOS.SYS)) -- Disassembler: HEX-RAYS IDA Pro --
    45                                  ;	((Disassembly -Reverse engineering- reference: MSDOS 6.0 kernel src))
    46                                        
    47                                  ;------ Retro DOS v2 (v3) boot sector loads RETRODOS.SYS (MSDOS.SYS)
    48                                  ;	at 1000h:0000h and loader (initialization) part of RETRODOS kernel
    49                                  ;	moves IO.SYS (DOSBIOSCODE & DOSBIOSDATA, 'IOSYS5.BIN') to 70h:0000h.
    50                                  ;	Then SYSINIT code to the next segment (4D6h for current version)..
    51                                  ;	SYSINIT code relocates itself and DOSBIOSCODE and MSDOS.SYS
    52                                  ;	(MSDOS5.BIN) according to request/setting in 'config.sys' file.
    53                                  
    54                                  ;=============================================================================
    55                                  ; Most of comments in this file are from the original MSDOS 6.0 source code
    56                                  ;-----------------------------------------------------------------------------
    57                                  
    58                                  ; MSDOS 6.0 Kernel source files:
    59                                  ;	MSDATA.ASM, 
    60                                  ; 		(MSHEAD.ASM, MSCONST.ASM,CONST2.ASM, MS_DATA.ASM,
    61                                  ;		DOSTAB.ASM, LMSTUB.ASM, WPATCH.INC, MPATCH.ASM)
    62                                  ;	MSTABLE.ASM, MSCODE.ASM, MSDOSME.ASM (DOSMES.INC), TIME.ASM,
    63                                  ;	GETSET.ASM, PARSE.ASM, MISC.ASM, MISC2.ASM, CRIT.ASM, CPMIO.ASM,
    64                                  ;	CPMIO2.ASM, FCBIO.ASM, FCBIO2.ASM, SEARCH.ASM, PATH.ASM, IOCTL.ASM,
    65                                  ;	DELETE.ASM, RENAME.ASM, FINFO.ASM, DUP.ASM, CREATE.ASM, OPEN.ASM,
    66                                  ;	DINFO.ASM, ISEARCH.ASM, BUF.ASM, ABORT.ASM,CLOSE.ASM, DIRCALL.ASM,
    67                                  ;	DISK.ASM, DISK2.ASM, DISK3.ASM, DIR.ASM, DIR2.ASM, DEV.ASM,
    68                                  ;	MKNODE.ASM, ROM.ASM, FCB.ASM, MSCTRLC.ASM, FAT.ASM, MSPROC.ASM
    69                                  ;	ALLOC.ASM, SRVCALL.ASM, UTIL.ASM, MACRO.ASM, MACRO2.ASM, HANDLE.ASM
    70                                  ;	FILE.ASM, LOCK.ASM, ROMFIND.ASM, SHARE.ASM, MSINIT.ASM, ORIGIN.ASM
    71                                  ;
    72                                  ; MSDOS 2.0 Kernel source files:
    73                                  ; 	MSDOS.ASM (STDSW.ASM + MSHEAD.ASM + MSDATA.ASM)
    74                                  ;	MSCODE.ASM
    75                                  ;	DOSMES.ASM ... STDIO.ASM, TIME.ASM, XENIX.ASM, XENIX2.ASM
    76                                  
    77                                  ;============================================================================
    78                                  ; DOSLINK
    79                                  ;============================================================================
    80                                  ;msdos mscode dosmes misc getset dircall alloc dev dir +
    81                                  ;disk fat rom stdbuf stdcall stdctrlc stdfcb stdproc +
    82                                  ;stdio time xenix xenix2
    83                                  
    84                                  ;============================================================================
    85                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    86                                  ; output in TASM syntax (July 2018 -> NASM syntax) [ IBMDOS.COM, 17/03/1987 ]
    87                                  ;============================================================================
    88                                  ;
    89                                  ; ###########################################################################
    90                                  ; #	This file is generated by The Interactive Disassembler (IDA)	    #
    91                                  ; #	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    #
    92                                  ; #			 Licensed to: Freeware version			    #
    93                                  ; ###########################################################################
    94                                  ;
    95                                  ; Input	MD5   :	75959BC417C19135B982F7959EE9C92A
    96                                  
    97                                  ; ---------------------------------------------------------------------------
    98                                  ; File Name   :	C:\Documents and Settings\Erdoðan Tan\Desktop\MSDOS621.BIN
    99                                  ; Format      :	Binary file
   100                                  ;============================================================================
   101                                  ; MSDOS621.BIN = MSDOS.SYS, 13/02/1994, 38138 bytes (MSDOS 6.21 kernel) 2019
   102                                  ;----------------------------------------------------------------------------
   103                                  ; MSDOS5.BIN = MSDOS.SYS, 11/11/1991, 37394 bytes (MSDOS 5.0 kernel) 2022
   104                                  
   105                                  ;============================================================================
   106                                  ; MSDOS.ASM
   107                                  ;============================================================================
   108                                  
   109                                  ;TITLE   Standard MSDOS
   110                                  ;NAME    MSDOS_2
   111                                  
   112                                  ; Number of disk I/O buffers
   113                                  
   114                                  ;	INCLUDE STDSW.ASM
   115                                  ;       INCLUDE MSHEAD.ASM
   116                                  ;       INCLUDE MSDATA.ASM
   117                                  
   118                                  ;	END
   119                                  
   120                                  ;============================================================================
   121                                  ; STDSW.ASM
   122                                  ;============================================================================
   123                                  
   124                                  TRUE    EQU     0FFFFH
   125                                  FALSE   EQU     ~TRUE ; NOT TRUE
   126                                  
   127                                  ; Use the switches below to produce the standard Microsoft version or the IBM
   128                                  ; version of the operating system
   129                                  ;MSVER   EQU	false
   130                                  ;IBM     EQU	true
   131                                  ;WANG    EQU	FALSE
   132                                  ;ALTVECT EQU	FALSE
   133                                  
   134                                  ; Set this switch to cause DOS to move itself to the end of memory
   135                                  ;HIGHMEM EQU     FALSE
   136                                  
   137                                  ;	IF      IBM
   138                                  ESCCH    EQU	 0			;character to begin escape seq.
   139                                  CANCEL   EQU	 27			;Cancel with escape
   140                                  TOGLINS  EQU	TRUE			;One key toggles insert mode
   141                                  TOGLPRN  EQU	TRUE			;One key toggles printer echo
   142                                  ZEROEXT  EQU	TRUE
   143                                  ;       ELSE
   144                                  ;       IF      WANG			;Are we assembling for WANG?
   145                                  ;ESCCH	 EQU	1FH			;Yes. Use 1FH for escape character
   146                                  ;       ELSE
   147                                  ;ESCCH	 EQU	1BH
   148                                  ;       ENDIF
   149                                  ;CANCEL  EQU	"X"-"@"			;Cancel with Ctrl-X
   150                                  ;TOGLINS EQU	WANG			;Separate keys for insert mode on
   151                                  					;and off if not WANG
   152                                  ;TOGLPRN EQU	FALSE			;Separate keys for printer echo on
   153                                  					;and off
   154                                  ;ZEROEXT EQU	TRUE
   155                                  ;        ENDIF
   156                                  
   157                                  ;============================================================================
   158                                  ; MSHEAD.ASM
   159                                  ;============================================================================
   160                                  
   161                                  ;--------------------------------------------------------------
   162                                  ; TITLE   MSHEAD.ASM -- MS-DOS DEFINITIONS
   163                                  ;--------------------------------------------------------------
   164                                  
   165                                  ; MS-DOS High-performance operating system for the 8086  version 1.28
   166                                  ;        by Microsoft MSDOS development group:
   167                                  ;           Tim Paterson (Ret.)
   168                                  ;           Aaron Reynolds
   169                                  ;           Nancy Panners (Parenting)
   170                                  ;           Mark Zbikowski
   171                                  ;           Chris Peters (BIOS) (ret.)
   172                                  
   173                                  ; ****************** Revision History *************************
   174                                  ;          >> EVERY change must noted below!! <<
   175                                  ;
   176                                  ; 0.34 12/29/80 General release, updating all past customers
   177                                  ; 0.42 02/25/81 32-byte directory entries added
   178                                  ; 0.56 03/23/81 Variable record and sector sizes
   179                                  ; 0.60 03/27/81 Ctrl-C exit changes, including register save on user stack
   180                                  ; 0.74 04/15/81 Recognize I/O devices with file names
   181                                  ; 0.75 04/17/81 Improve and correct buffer handling
   182                                  ; 0.76 04/23/81 Correct directory size when not 2^N entries
   183                                  ; 0.80 04/27/81 Add console input without echo, Functions 7 & 8
   184                                  ; 1.00 04/28/81 Renumber for general release
   185                                  ; 1.01 05/12/81 Fix bug in `STORE'
   186                                  ; 1.10 07/21/81 Fatal error trapping, NUL device, hidden files, date & time,
   187                                  ;               RENAME fix, general cleanup
   188                                  ; 1.11 09/03/81 Don't set CURRENT BLOCK to 0 on open; fix SET FILE SIZE
   189                                  ; 1.12 10/09/81 Zero high half of CURRENT BLOCK after all (CP/M programs don't)
   190                                  ; 1.13 10/29/81 Fix classic "no write-through" error in buffer handling
   191                                  ; 1.20 12/31/81 Add time to FCB; separate FAT from DPT; Kill SMALLDIR; Add
   192                                  ;               FLUSH and MAPDEV calls; allow disk mapping in DSKCHG; Lots
   193                                  ;               of smaller improvements
   194                                  ; 1.21 01/06/82 HIGHMEM switch to run DOS in high memory
   195                                  ; 1.22 01/12/82 Add VERIFY system call to enable/disable verify after write
   196                                  ; 1.23 02/11/82 Add defaulting to parser; use variable escape character Don't
   197                                  ;               zero extent field in IBM version (back to 1.01!)
   198                                  ; 1.24 03/01/82 Restore fcn. 27 to 1.0 level; add fcn. 28
   199                                  ; 1.25 03/03/82 Put marker (00) at end of directory to speed searches
   200                                  ; 1.26 03/03/82 Directory buffers searched as a circular queue, current buffer
   201                                  ;               is searched first when possible to minimize I/O
   202                                  ;      03/03/82 STORE routine optimized to tack on partial sector tail as
   203                                  ;               full sector write when file is growing
   204                                  ;      03/09/82 Multiple I/O buffers
   205                                  ;      03/29/82 Two bugs:  Delete all case resets search to start at beginning
   206                                  ;               of directory (infinite loop possible otherwise), DSKRESET
   207                                  ;               must invalidate all buffers (disk and directory).
   208                                  ; 1.27 03/31/82 Installable device drivers
   209                                  ;                 Function call 47 - Get pointer to device table list
   210                                  ;                 Function call 48 - Assign CON AUX LIST
   211                                  ;      04/01/82 Spooler interrupt (INT 28) added.
   212                                  ; 1.28 04/15/82 DOS retructured to use ASSUMEs and PROC labels around system
   213                                  ;               call entries.  Most CS relative references changed to SS
   214                                  ;               relative with an eye toward putting a portion of the DOS in
   215                                  ;               ROM.  DOS source also broken into header, data and code pieces
   216                                  ;      04/15/82 GETDMA and GETVECT calls added as 24 and 32.  These calls
   217                                  ;               return the current values.
   218                                  ;      04/15/82 INDOS flag implemented for interrupt processing along with
   219                                  ;               call to return flag location (call 29)
   220                                  ;      04/15/82 Volume ID attribute added
   221                                  ;      04/17/82 Changed ABORT return to user to a long ret from a long jump to
   222                                  ;               avoid a CS relative reference.
   223                                  ;      04/17/82 Put call to STATCHK in dispatcher to catch ^C more often
   224                                  ;      04/20/82 Added INT int_upooler into loop ^S wait
   225                                  ;      04/22/82 Dynamic disk I/O buffer allocation and call to manage them
   226                                  ;               call 49.
   227                                  ;      04/23/82 Added GETDSKPTDL as call 50, similar to GETFATPT(DL), returns
   228                                  ;               address of DPB
   229                                  ;      04/29/82 Mod to WRTDEV to look for ^C or ^S at console input when
   230                                  ;               writting to console device via file I/O.  Added a console
   231                                  ;               output attribute to devices.
   232                                  ;      04/30/82 Call to en/dis able ^C check in dispatcher Call 51
   233                                  ;      04/30/82 Code to allow assignment of func 1-12 to disk files as well
   234                                  ;               as devices....  pipes, redirection now possible
   235                                  ;      04/30/82 Expanded GETLIST call to 2.0 standard
   236                                  ;      05/04/82 Change to INT int_fatal_abort callout int HARDERR.  DOS SS
   237                                  ;               (data segment) stashed in ES, INT int_fatal_abort routines must
   238                                  ;               preserve ES.  This mod so HARDERR can be ROMed.
   239                                  ; 1.29 06/01/82 Installable block and character devices as per 2.0 spec
   240                                  ;      06/04/82 Fixed Bug in CLOSE regarding call to CHKFATWRT.  It got left
   241                                  ;               out back about 1.27 or so (oops).  ARR
   242                                  ; 1.30 06/07/82 Directory sector buffering added to main DOS buffer queue
   243                                  ; 1.40 06/15/82 Tree structured directories.  XENIX Path Parser MKDIR CHDIR
   244                                  ;               RMDIR Xenix calls
   245                                  ; 1.41 06/13/82 Made GETBUFFR call PLACEBUF
   246                                  ; 1.50 06/17/82 FATs cached in buffer pool, get FAT pointer calls disappear
   247                                  ;               Frees up lots of memory.
   248                                  ; 1.51 06/24/82 BREAKDOWN modified to do EXACT one sector read/write through
   249                                  ;               system buffers
   250                                  ; 1.52 06/30/82 OPEN, CLOSE, READ, WRITE, DUP, DUP2, LSEEK implemented
   251                                  ; 1.53 07/01/82 OPEN CLOSE mod for Xenix calls, saves and gets remote dir
   252                                  ; 1.54 07/11/82 Function calls 1-12 make use of new 2.0 PDB. Init code
   253                                  ;               changed to set file handle environment.
   254                                  ; 2.00 08/01/82 Number for IBM release
   255                                  ;      01/19/83 No environ bug in EXEC
   256                                  ;      01/19/83 MS-DOS OEM INT 21 extensions (SET_OEM_HANDLER)
   257                                  ;      01/19/83 Performance bug fix in cooked write to NUL
   258                                  ;      01/27/83 Growcnt fixed for 32-bits
   259                                  ;      01/27/83 Find-first problem after create
   260                                  ; 2.01 02/17/83 International DOS
   261                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   262                                  ;               an IBM PC
   263                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
   264                                  ; (MSHEAD.ASM, MSDOS 6.0, 1991) - mshead.asm 1.1 85/04/10 -
   265                                  ; 2.10 03/09/83 Start of NETWORK support
   266                                  ;		New Buffer structure
   267                                  ;		New Sytem file table structure
   268                                  ;		FCB moved to internal representation
   269                                  ;		DOS re-organized
   270                                  ; 2.11 04/21/83 Continuation of 2.10, preliminary Network
   271                                  ;		device interface.
   272                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   273                                  ;               an IBM PC
   274                                  ; 2.50 09/12/83 More network stuff
   275                                  ;
   276                                  ; *************************************************************
   277                                  
   278                                  ; ----------------------------------------------------------------------------
   279                                  ; EQUATES
   280                                  
   281                                  ; Interrupt Entry Points:
   282                                  
   283                                  ; INTBASE:      ABORT
   284                                  ; INTBASE+4:    COMMAND
   285                                  ; INTBASE+8:    BASE EXIT ADDRESS
   286                                  ; INTBASE+C:    CONTROL-C ABORT
   287                                  ; INTBASE+10H:  FATAL ERROR ABORT
   288                                  ; INTBASE+14H:  BIOS DISK READ
   289                                  ; INTBASE+18H:  BIOS DISK WRITE
   290                                  ; INTBASE+1CH:  END BUT STAY RESIDENT (NOT SET BY DOS)
   291                                  ; INTBASE+20H:  SPOOLER INTERRUPT
   292                                  ; INTBASE+40H:  Long jump to CALL entry point
   293                                  
   294                                  ENTRYPOINTSEG   EQU     0Ch
   295                                  MAXDIF          EQU     0FFFh
   296                                  SAVEXIT         EQU     10
   297                                  ; 06/05/2019
   298                                  WRAPOFFSET	EQU	0FEF0h  ; (MISC.ASM, MSDOS 6.0, 1991)
   299                                  
   300                                         ; INCLUDE DOSSYM.ASM
   301                                         ; INCLUDE DEVSYM.ASM
   302                                  
   303                                  ; SUBTTL ^C, terminate/abort/exit and Hard error actions
   304                                  ; PAGE
   305                                  ; There are three kinds of context resets that can occur during normal DOS
   306                                  ; functioning:  ^C trap, terminate/abort/exit, and Hard-disk error.  These must
   307                                  ; be handles in a clean fashion that allows nested executions along with the
   308                                  ; ability to trap one's own errors.
   309                                  ;
   310                                  ; ^C trap - A process may elect to catch his own ^Cs.  This is achieved by
   311                                  ;           using the $GET_INTERRUPT_VECTOR and $SET_INTERRUPT_VECTOR as
   312                                  ;           follows:
   313                                  ;
   314                                  ;           $GET_INTERRUPT_VECTOR for INT int_ctrl_c
   315                                  ;           Save it in static memory.
   316                                  ;           $SET_INTERRUPT_VECTOR for INT int_ctrl_c
   317                                  ;
   318                                  ;           The interrupt service routine must preserve all registers and
   319                                  ;           return carry set iff the operation is to be aborted (via abort
   320                                  ;           system call), otherwise, carry is reset and the operation is
   321                                  ;           restarted.  ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE
   322                                  ;           RESULTS.
   323                                  ;
   324                                  ;           To restore original ^C processing (done on terminate/abort/exit),
   325                                  ;           restore INT int_ctrl_c from the saved vector.
   326                                  ;
   327                                  ; Hard-disk error -- The interrupt service routine for INT int_fatal_abort must
   328                                  ;           also preserve registers and return one of three values in AL: 0 and
   329                                  ;           1 imply retry and ignore (???)  and 2 indicates an abort.  The user
   330                                  ;           himself is not to issue the abort, rather, the dos will do it for
   331                                  ;           him by simulating a normal abort/exit system call.  ANY DEVIATION
   332                                  ;           FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   333                                  ;
   334                                  ; terminate/abort/exit -- The user may not, under any circumstances trap an
   335                                  ;           abort call.  This is reserved for knowledgeable system programs.
   336                                  ;           ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   337                                  
   338                                  ;SUBTTL SEGMENT DECLARATIONS
   339                                  
   340                                  ; The following are all of the segments used.  They are declared in the order
   341                                  ; that they should be placed in the executable
   342                                  
   343                                  ;
   344                                  ; segment ordering for MSDOS
   345                                  ;
   346                                  
   347                                  ;START           SEGMENT BYTE PUBLIC 'START'
   348                                  ;START           ENDS
   349                                  
   350                                  ;CONSTANTS       SEGMENT BYTE PUBLIC 'CONST'
   351                                  ;CONSTANTS       ENDS
   352                                  
   353                                  ;DATA            SEGMENT WORD PUBLIC 'DATA'
   354                                  ;DATA            ENDS
   355                                  
   356                                  ;CODE            SEGMENT BYTE PUBLIC 'CODE'
   357                                  ;CODE            ENDS
   358                                  
   359                                  ;LAST            SEGMENT BYTE PUBLIC 'LAST'
   360                                  ;LAST            ENDS
   361                                  
   362                                  ;DOSGROUP    GROUP   CODE,CONSTANTS,DATA,LAST
   363                                  
   364                                  ; The following segment is defined such that the data/const classes appear
   365                                  ; before the code class for ROMification
   366                                  
   367                                  ;START		SEGMENT BYTE PUBLIC 'START'
   368                                  ;           	ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
   369                                  ;		JMP     DOSINIT
   370                                  ;START		ENDS
   371                                  
   372                                  ;============================================================================
   373                                  ; BPB.INC, MSDOS 6.0, 1991
   374                                  ;============================================================================
   375                                  ; 09/07/2018 - Retro DOS v3.0
   376                                  
   377                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   378                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   379                                  ;									   ;
   380                                  
   381                                  ;**	BIOS PARAMETER BLOCK DEFINITION
   382                                  ;
   383                                  ;	The BPB contains information about the disk structure. It dates
   384                                  ;	back to the earliest FAT systems and so FAT information is
   385                                  ;	intermingled with physical driver information.
   386                                  ;
   387                                  ;	A boot sector contains a BPB for its device; for other disks
   388                                  ;	the driver creates a BPB. DOS keeps copies of some of this
   389                                  ;	information in the DPB.
   390                                  ;
   391                                  ;	The BDS structure contains a BPB within it. 
   392                                  
   393                                  struc A_BPB
   394 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
   395 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
   396 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
   397 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
   398 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
   399 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
   400 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
   401 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
   402 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
   403 0000000F ????                    .BPB_HEADS:		resw	1
   404 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
   405 00000013 ????                    			resw	1
   406 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
   407 00000017 ????                    			resw	1
   408 00000019 ????????????            			resb	6	; NOTE:  many times these
   409                                  ;					; 	 6 bytes are omitted
   410                                  ;					;	 when BPB manipulations
   411                                  ;					;	 are performed!
   412                                  .size:
   413                                  endstruc
   414                                  
   415                                  ;                                                                          ;
   416                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   417                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   418                                  
   419                                  ;============================================================================
   420                                  ; BUFFER.INC, MSDOS 6.0, 1991
   421                                  ;============================================================================
   422                                  ; 04/05/2019 - Retro DOS v4.0
   423                                  
   424                                  ; <Disk I/O Buffer Header>
   425                                  
   426                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   427                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   428                                  ;									   ;
   429                                  
   430                                  ; Field definition for I/O buffer information
   431                                  
   432                                  struc BUFFINFO
   433 00000000 ????                    .buf_next:	resw 1		; Pointer to next buffer in list
   434 00000002 ????                    .buf_prev:	resw 1		; Pointer to prev buffer in list
   435 00000004 ??                      .buf_ID:	resb 1		; Drive of buffer (bit 7 = 0)
   436                                  				; SFT table index (bit 7 = 1)
   437                                  				; = FFH if buffer free
   438 00000005 ??                      .buf_flags:	resb 1		; Bit 7 = 1 if Remote file buffer
   439                                  				;	= 0 if Local device buffer
   440                                  				; Bit 6 = 1 if buffer dirty
   441                                  				; Bit 5 = Reserved
   442                                  				; Bit 4 = Search bit (bit 7 = 1)
   443                                  				; Bit 3 = 1 if buffer is DATA
   444                                  				; Bit 2 = 1 if buffer is DIR
   445                                  				; Bit 1 = 1 if buffer is FAT
   446                                  				; Bit 0 = Reserved
   447 00000006 ????????                .buf_sector:	resd 1		; Sector number of buffer (flags bit 7 = 0)
   448                                  ; The next two items are often refed as a word (flags bit 7 = 0)
   449 0000000A ??                      .buf_wrtcnt:	resb 1		; For FAT sectors, # times sector written out
   450 0000000B ????                    .buf_wrtcntinc:	resw 1		; "   "     "   , # sectors between each write
   451 0000000D ????????                .buf_DPB:	resd 1		; Pointer to drive parameters
   452 00000011 ????                    .buf_fill:	resw 1		; How full buffer is (flags bit 7 = 1)
   453 00000013 ??                      .buf_reserved:	resb 1		; make DWORD boundary for 386
   454                                  .size:	; 20 bytes
   455                                  endstruc
   456                                  
   457                                  %define buf_offset	BUFFINFO.buf_sector ; 22/07/2019
   458                                  				;For buf_flags bit 7 = 1, this is the byte
   459                                  				;offset of the start of the buffer in
   460                                  				;the file pointed to by buf_ID. Thus
   461                                  				;the buffer starts at location
   462                                  				;buf_offset in the file and contains
   463                                  				;buf_fill bytes.
   464                                  
   465                                  BUFINSIZ        EQU     BUFFINFO.size
   466                                  
   467                                  buf_Free	EQU	0FFh	; buf_id of free buffer
   468                                  
   469                                  ;Flag byte masks
   470                                  buf_isnet	EQU	10000000B
   471                                  buf_dirty	EQU	01000000B
   472                                  ;***
   473                                  buf_visit	EQU	00100000B
   474                                  ;***
   475                                  buf_snbuf	EQU	00010000B
   476                                  
   477                                  buf_isDATA	EQU	00001000B
   478                                  buf_isDIR	EQU	00000100B
   479                                  buf_isFAT	EQU	00000010B
   480                                  buf_type_0	EQU	11110001B	; AND sets type to "none"
   481                                  
   482                                  buf_NetID	EQU	BUFINSIZ
   483                                  
   484                                  ;                                                                          ;
   485                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   486                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   487                                  
   488                                  ;============================================================================
   489                                  ; DOSSSYM.INC, MSDOS 6.0, 1991
   490                                  ;============================================================================
   491                                  ; 04/05/2019 - Retro DOS v4.0
   492                                  
   493                                  ; <Control character definitions>
   494                                  
   495                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   496                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   497                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   498                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   499                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   500                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   501                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   502                                  c_HT	    EQU     09h 	; ^I ASCII tab
   503                                  
   504                                  ; <User stack inside of system call>
   505                                  ; Location of user registers relative user stack pointer
   506                                  
   507                                  struc	user_env   ; user_environ
   508 00000000 ????                    .user_AX: resw 1
   509 00000002 ????                    .user_BX: resw 1
   510 00000004 ????                    .user_CX: resw 1
   511 00000006 ????                    .user_DX: resw 1
   512 00000008 ????                    .user_SI: resw 1
   513 0000000A ????                    .user_DI: resw 1
   514 0000000C ????                    .user_BP: resw 1
   515 0000000E ????                    .user_DS: resw 1
   516 00000010 ????                    .user_ES: resw 1
   517 00000012 ????                    .user_IP: resw 1
   518 00000014 ????                    .user_CS: resw 1
   519 00000016 ????                    .user_F:  resw 1
   520                                  .size:
   521                                  endstruc
   522                                  
   523                                  ; ---- <Disk map> ----
   524                                  
   525                                  ;	MSDOS partitions the disk into 4 sections:
   526                                  ;
   527                                  ;  phys sector 0:   +-------------------+
   528                                  ;	|	    | boot/reserved	|
   529                                  ;	|	    +-------------------+
   530                                  ;	|	    |  File allocation	|
   531                                  ;	v	    |	   table(s)	|
   532                                  ;		    |  (multiple copies |
   533                                  ;		    |	  are kept)	|
   534                                  ;		    +-------------------+
   535                                  ;		    |	  Directory	|
   536                                  ;		    +-------------------+
   537                                  ;		    |	  File space	|
   538                                  ;		    +-------------------+
   539                                  ;		    |	Unaddressable	|
   540                                  ;		    |  (to end of disk) |
   541                                  ;		    +-------------------+
   542                                  ;
   543                                  ; All partition boundaries are sector boundaries.  The size of the FAT is
   544                                  ; adjusted to maximize the file space addressable.
   545                                  
   546                                  ; <File allocation Table information>
   547                                  
   548                                  ; The File Allocation Table uses a 12-bit entry for each allocation unit on
   549                                  ; the disk.  These entries are packed, two for every three bytes.  The contents
   550                                  ; of entry number N is found by 1) multiplying N by 1.5; 2) adding the result
   551                                  ; to the base address of the Allocation Table; 3) fetching the 16-bit word
   552                                  ; at this address; 4) If N was odd (so that N*1.5 was not an integer), shift
   553                                  ; the word right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry
   554                                  ; number zero is used as an end-of-file trap in the OS and is passed to the
   555                                  ; BIOS to help determine disk format.  Entry 1 is reserved for future use.
   556                                  ; The first available allocation unit is assigned entry number two, and even
   557                                  ; though it is the first, is called cluster 2.	Entries greater than 0FF8H
   558                                  ; (12-bit fats) or 0FFF8H (16-bit fats) are end of file marks; entries of zero
   559                                  ; are unallocated.  Otherwise, the contents of a FAT entry is the number of
   560                                  ; the next cluster in the file.
   561                                  ;
   562                                  ; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would
   563                                  ; do because these clusters show as allocated, but are not part of any
   564                                  ; allocation chain and thus will never be allocated to a file.	A particular
   565                                  ; number is selected so that disk checking programs know what to do (ie.  a
   566                                  ; cluster with entry FF7H which is not in a chain is not an error).
   567                                  
   568                                  ;**	Character Type Flags
   569                                  ;
   570                                  ;	These flags are used in a lookup table indexed by the character code.
   571                                  ;	They're used to quickly classify characters when parsing paths.
   572                                  ;	I think that these are only used to parse FCBs - jgl
   573                                  
   574                                  FCHK	equ 1		; I think this means "normal name char, no chks needed" -jgl
   575                                  FDELIM	equ 2		; is a delimiter
   576                                  FSPCHK	equ 4		; set if character is not a space or equivalent
   577                                  FFCB	equ 8		; is valid in an FCB
   578                                  
   579                                  ;** Bit definitions for DOS_FLAG
   580                                  ;
   581                                  ; Bit 0 - this is set when a $open call is made from $exec. This is used in
   582                                  ;	  $open to indicate to the redirector that this open is being made
   583                                  ;	  by an exec call.
   584                                  ;
   585                                  ; Bit 2
   586                                  ;
   587                                  ; M003, M027:
   588                                  ;
   589                                  ; The start up code of MS PASCAL 3.2 programs depend on the 1M address wrap 
   590                                  ; if they load below 64K. This is a likely possiblity in DOS 5.x with DOS in
   591                                  ; the HMA. By default DOS will turn A20 OFF before Xferring control to the
   592                                  ; user program in the case of an Exec call. The next call to DOS will turn
   593                                  ; A20 line ON. It has been observed that MS PASCAL 3.2 start up does an int
   594                                  ; 21 ah=25h call before executing the faulty code. This will turn A20 On. 
   595                                  ; In order to support this we will set Bit 2 of this flag in the DOS exec
   596                                  ; call (msproc.asm) if DOS is running in the HMA. In $set_interrupt_vector in
   597                                  ; getset.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
   598                                  ; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
   599                                  ; is non zero then A20 will be turned OFF before returning to the user. 
   600                                  ; Bit 2 will be unconditionally cleared here.
   601                                  ;
   602                                  ; M009, M027:
   603                                  ;
   604                                  ; Mace utilities MKEYRATE.COM version 1.0 copyright 1987 is an execpacked 
   605                                  ; program converted to a com file. Therefore if DOS is loaded high and if 
   606                                  ; this program is loaded below 64K it will blurt out "packed file is corrupt".
   607                                  ; This program does an int 21 ah=49h before executing the buggy execpacked
   608                                  ; code. This int21 call turns a20 on and hence the problem. In $dealloc
   609                                  ; alloc.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
   610                                  ; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
   611                                  ; is non zero then A20 will be turned OFF before returning to the user. 
   612                                  ; Bit 2 will be unconditionally cleared here.
   613                                  
   614                                  EXECOPEN	EQU	00000001b	; bit 0 of DOS_FLAG
   615                                  SUPPRESS_WINA20	EQU	00000010b	; M025
   616                                  EXECA20OFF	EQU	00000100b	; bit 2 of DOS_FLAG
   617                                  
   618                                  ;============================================================================
   619                                  ; VECTOR.INC, MSDOS 6.0, 1991
   620                                  ;============================================================================
   621                                  ; 04/05/2019 - Retro DOS v4.0
   622                                  
   623                                  ; 09/07/2018 - Retro DOS v3.0 (VECTOR.INC, MSDOS 3.3, 1987)
   624                                  
   625                                  ; <interrupt definitions>
   626                                  
   627                                  INTTAB          EQU     20H
   628                                  INTBASE         EQU     4 * INTTAB
   629                                  ENTRYPOINT      EQU     INTBASE+40H
   630                                  
   631                                  ;	IF      ALTVECT
   632                                  ;ALTTAB  EQU     0F0H
   633                                  ;ALTBASE EQU     4 * ALTTAB
   634                                  ;	ENDIF
   635                                  
   636                                  ;
   637                                  ; interrupt assignments
   638                                  ;
   639                                  ;	IF	NOT ALTVECT
   640                                  int_abort	    EQU     INTTAB	; abort process
   641                                  int_command	    EQU     int_abort+1 ; call MSDOS
   642                                  int_terminate	    EQU     int_abort+2 ; int to terminate address
   643                                  int_ctrl_c	    EQU     int_abort+3 ; ^c trapper
   644                                  int_fatal_abort     EQU     int_abort+4 ; hard disk error
   645                                  int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   646                                  int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   647                                  int_keep_process    EQU     int_abort+7 ; terminate program and stay
   648                                  					; resident
   649                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   650                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   651                                  ;									   ;
   652                                  int_spooler	    EQU     int_abort+8 ; spooler call
   653                                  int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   654                                  int_IBM 	    EQU     int_abort+10; critical section maintenance
   655                                  ;									   ;
   656                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   657                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   658                                  ;	ELSE
   659                                  ;int_abort	    EQU     INTTAB	; abort process
   660                                  ;int_command	    EQU     int_abort+1 ; call MSDOS
   661                                  ;int_terminate	    EQU     ALTTAB	; int to terminate address
   662                                  ;int_ctrl_c	    EQU     int_terminate+1 ; ^c trapper
   663                                  ;int_fatal_abort    EQU     int_terminate+2 ; hard disk error
   664                                  ;int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   665                                  ;int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   666                                  ;int_keep_process   EQU     int_abort+7 ; terminate program and stay resident
   667                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   668                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   669                                  ;									   ;
   670                                  ;int_spooler	    EQU     int_terminate+3 ; spooler call
   671                                  ;int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   672                                  ;									   ;
   673                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   674                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   675                                  ;	ENDIF
   676                                  
   677                                  addr_int_abort		EQU    4 * int_abort
   678                                  addr_int_command	EQU    4 * int_command
   679                                  addr_int_terminate	EQU    4 * int_terminate
   680                                  addr_int_ctrl_c 	EQU    4 * int_ctrl_c
   681                                  addr_int_fatal_abort	EQU    4 * int_fatal_abort
   682                                  addr_int_disk_read	EQU    4 * int_disk_read
   683                                  addr_int_disk_write	EQU    4 * int_disk_write
   684                                  addr_int_keep_process	EQU    4 * int_keep_process
   685                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   686                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   687                                  ;									   ;
   688                                  addr_int_spooler	EQU    4 * int_spooler
   689                                  addr_int_fastcon	EQU    4 * int_fastcon
   690                                  addr_int_ibm		EQU    4 * int_IBM
   691                                  ;									   ;
   692                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   693                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   694                                  
   695                                  ;============================================================================
   696                                  ; DIRENT.INC, MSDOS 6.0, 1991
   697                                  ;============================================================================
   698                                  ; 04/05/2019 - Retro DOS v4.0
   699                                  
   700                                  ; BREAK <Directory entry>
   701                                  
   702                                  ;
   703                                  ;       +---------------------------+
   704                                  ;       |  (12 BYTE) filename/ext   |       0       0
   705                                  ;       +---------------------------+
   706                                  ;       |     (BYTE) attributes     |       11      B
   707                                  ;       +---------------------------+
   708                                  ;       |    (10 BYTE) reserved     |       12      C
   709                                  ;       +---------------------------+
   710                                  ;       | (WORD) time of last write |       22      16
   711                                  ;       +---------------------------+
   712                                  ;       | (WORD) date of last write |       24      18
   713                                  ;       +---------------------------+
   714                                  ;       |   (WORD) First cluster    |       26      1A
   715                                  ;       +---------------------------+
   716                                  ;       |     (DWORD) file size     |       28      1C
   717                                  ;       +---------------------------+
   718                                  ;
   719                                  ;   First byte of filename  = E5 -> free directory entry
   720                                  ;                           = 00 -> end of allocated directory
   721                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   722                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   723                                  ;
   724                                  struc dir_entry
   725 00000000 <res Bh>                .dir_name:	resb 11			; file name
   726 0000000B ??                      .dir_attr:	resb 1			; attribute bits
   727 0000000C ????                    .dir_codepg:	resw 1			; code page DOS 4.00
   728 0000000E ????                    .dir_extcluster: resw 1			; extended attribute starting cluster
   729 00000010 ??                      .dir_attr2:	resb 1			; reserved
   730 00000011 ??????????              .dir_pad:	resb 5			; reserved for expansion
   731 00000016 ????                    .dir_time:	resw 1			; time of last write
   732 00000018 ????                    .dir_date:	resw 1			; date of last write
   733 0000001A ????                    .dir_first:	resw 1			; first allocation unit of file
   734 0000001C ????                    .dir_size_l:	resw 1			; low 16 bits of file size
   735 0000001E ????                    .dir_size_h:	resw 1			; high 16 bits of file size
   736                                  .size:
   737                                  endstruc
   738                                  
   739                                  attr_read_only      EQU      1h
   740                                  attr_hidden         EQU      2h
   741                                  attr_system         EQU      4h
   742                                  attr_volume_id      EQU      8h
   743                                  attr_directory      EQU     10h
   744                                  attr_archive        EQU     20h
   745                                  attr_device	    EQU     40h	; This is a VERY special bit.
   746                                  				;   NO directory entry on a disk EVER
   747                                  				;   has this bit set. It is set non-zero
   748                                  				;   when a device is found by GETPATH
   749                                  
   750                                  attr_all            EQU     attr_hidden+attr_system+attr_directory
   751                                                                          ; OR of hard attributes for FINDENTRY
   752                                  
   753                                  attr_ignore         EQU     attr_read_only+attr_archive
   754                                                                          ; ignore this(ese) attribute(s)
   755                                                                          ; during search first/next
   756                                  
   757                                  attr_changeable     EQU     attr_read_only+attr_hidden+attr_system+attr_archive
   758                                                                          ; changeable via CHMOD
   759                                  
   760                                  DIRFREE		equ	0E5h	; stored in dir_name[0] to indicate free slot
   761                                  
   762                                  ;============================================================================
   763                                  ; DPB.INC, MSDOS 6.0, 1991
   764                                  ;============================================================================
   765                                  ; 24/04/2019 - Retro DOS v4.0
   766                                  
   767                                  ; 19/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 3.3, 1987)
   768                                  ; 07/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 6.0, 1991)
   769                                  
   770                                  ; ---------------------------------------------------------------------------
   771                                  ;**	DPB - Drive Parameter Block
   772                                  ;
   773                                  ;	BUGBUG - this isn't authorative - it's my probably incomplete and
   774                                  ;	possibly inaccurate deductions from code study... - jgl
   775                                  ;
   776                                  ;	The DPB is DOS's main structure for describing block devices.
   777                                  ;	It contains info about the "Drive" intermingled with info about
   778                                  ;	the FAT file system which is presumably on the drive.  I don't know
   779                                  ;	how those fields are used if it's not the FAT file system - BUGBUG
   780                                  ;
   781                                  ;	The DPBs are statically allocated and chained off of DPBHead.
   782                                  ;	Users scan this chain looking for a match on DPB_DRIVE.
   783                                  ;	The DPBs are built at init time from info in the SYSDEV structure.
   784                                  ; ---------------------------------------------------------------------------
   785                                  
   786                                  struc	DPB
   787 00000000 ??                      .DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
   788 00000001 ??                      .UNIT:		resb 1		; Driver unit number of DPB
   789 00000002 ????                    .SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
   790 00000004 ??                      .CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
   791 00000005 ??                      .CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
   792 00000006 ????                    .FIRST_FAT:	resw 1		; Starting record of FATs
   793 00000008 ??                      .FAT_COUNT:	resb 1		; Number of FATs for this drive
   794 00000009 ????                    .ROOT_ENTRIES:	resw 1		; Number of directory entries
   795 0000000B ????                    .FIRST_SECTOR:	resw 1		; First sector of first cluster
   796 0000000D ????                    .MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
   797                                  ; MSDOS 3.3
   798                                  ;.FAT_SIZE:	resb 1		; Number of records occupied by FAT
   799                                  ; MSDOS 6.0
   800 0000000F ????                    .FAT_SIZE:	resw 1		; Number of records occupied by FAT
   801 00000011 ????                    .DIR_SECTOR:	resw 1		; Starting record of directory
   802 00000013 ????????                .DRIVER_ADDR:	resd 1		; Pointer to driver
   803 00000017 ??                      .MEDIA:		resb 1		; Media byte
   804 00000018 ??                      .FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
   805                                  				; check the first time this DPB is used
   806 00000019 ????????                .NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
   807 0000001D ????                    .NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
   808 0000001F ????                    .FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
   809                                  .size:
   810                                  endstruc
   811                                  
   812                                  DPBSIZ  EQU     DPB.size	; Size of the structure in bytes
   813                                  
   814                                  DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)
   815                                  
   816                                  ;                                                                          ;
   817                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   818                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   819                                  
   820                                  ;============================================================================
   821                                  ; SF.INC, MSDOS 6.0, 1991
   822                                  ;============================================================================
   823                                  ; 25/04/2019 - Retro DOS v4.0
   824                                  ; 07/07/2018 - Retro DOS v3.0
   825                                  
   826                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   827                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   828                                  ;                                                                          ;
   829                                  
   830                                  ; ---------------------------------------------------------------------------
   831                                  ;**	SF.INC - System File Table
   832                                  ;
   833                                  ;   AN000   version 4.00   Jan. 1988
   834                                  ;   AN003   PTM 3680 --  make NAME offset the same as before (<=3.30)
   835                                  ;   AN009   PTM 3839	 reorder SFT for MS WINDOWS
   836                                  ; ---------------------------------------------------------------------------
   837                                  ;**	System File Table SuperStructure
   838                                  ;
   839                                  ;	The system file table entries are allocated in contiguous groups.
   840                                  ;	There may be more than one such groups; the SF "superstructure"
   841                                  ;	tracks the groups.
   842                                  ; ---------------------------------------------------------------------------
   843                                  
   844                                  struc	SFT
   845 00000000 ????????                .SFLink:	resd 1
   846 00000004 ????                    .SFCount:	resw 1		; number of entries
   847 00000006 ????                    .SFTable:	resw 1		; beginning of array of the following
   848                                  .size:
   849                                  endstruc
   850                                  
   851                                  ; ---------------------------------------------------------------------------
   852                                  ;**	System file table entry
   853                                  ;
   854                                  ;	These are the structures which are at SFTABLE in the SF structure.
   855                                  ; ---------------------------------------------------------------------------
   856                                  
   857                                  ; 25/04/2019 - Retro DOS v4.0
   858                                  
   859                                  struc SF_ENTRY
   860 00000000 ????                    .sf_ref_count:	resw 1		; number of processes sharing entry
   861                                  				;   if FCB then ref count
   862 00000002 ????                    .sf_mode:	resw 1		; mode of access or high bit on if FCB
   863 00000004 ??                      .sf_attr:	resb 1		; attribute of file
   864 00000005 ????                    .sf_flags:	resw 1		;Bits 8-15
   865                                  				; Bit 15 = 1 if remote file
   866                                  				;	 = 0 if local file or device
   867                                  				; Bit 14 = 1 if date/time is not to be
   868                                  				;   set from clock at CLOSE.  Set by
   869                                  				;   FILETIMES and FCB_CLOSE.  Reset by
   870                                  				;   other reseters of the dirty bit
   871                                  				;   (WRITE)
   872                                  				; Bit 13 = Pipe bit (reserved)
   873                                  				;
   874                                  				; Bits 0-7 (old FCB_devid bits)
   875                                  				; If remote file or local file, bit
   876                                  				; 6=0 if dirty Device ID number, bits
   877                                  				; 0-5 if local file.
   878                                  				; bit 7=0 for local file, bit 7
   879                                  				;      =1 for local I/O device
   880                                  				; If local I/O device, bit 6=0 if EOF (input)
   881                                  				;		Bit 5=1 if Raw mode
   882                                  				;		Bit 0=1 if console input device
   883                                  				;		Bit 1=1 if console output device
   884                                  				;		Bit 2=1 if null device
   885                                  				;		Bit 3=1 if clock device
   886 00000007 ????????                .sf_devptr:	resd	1	; Points to DPB if local file, points
   887                                  				; to device header if local device,
   888                                  				; points to net device header if
   889                                  				; remote
   890 0000000B ????                    .sf_firclus:	resw	1	; First cluster of file (bit 15 = 0)
   891 0000000D ????                    .sf_time:	resw	1	; Time associated with file
   892 0000000F ????                    .sf_date:	resw	1	; Date associated with file
   893 00000011 ????????                .sf_size:	resd 	1	; Size associated with file
   894 00000015 ????????                .sf_position:	resd	1	; Read/Write pointer or LRU count for FCBs
   895                                  
   896                                  ; Starting here, the next 7 bytes may be used by the file system to store
   897                                  ; an ID
   898                                  
   899                                  ; 09/07/2018 - Retro DOS v3.0
   900                                  
   901                                  ; MSDOS 3.3 SF.INC, 1987
   902                                  ;.sf_cluspos:	resw	1	; Position of last cluster accessed
   903                                  ;.sf_lstclus	resw	1	; Last cluster accessed
   904                                  ;.sf_dirsec:	resw	1	; Sector number of directory sector
   905                                  ;				; for this file
   906                                  ;.sf_dirpos:	resb	1	; Offset of this entry in the above
   907                                  
   908                                  ; MSDOS 6.0, SF.INC, 1991
   909 00000019 ????                    .sf_cluspos:	resw	1	; Position of last cluster accessed
   910 0000001B ????????                .sf_dirsec:	resd	1	; Sector number of directory sector
   911                                  				; for this file
   912 0000001F ??                      .sf_dirpos:	resb	1	; Offset of this entry in the above
   913                                  
   914                                  ; End of 7 bytes of file-system specific info.
   915                                  
   916 00000020 <res Bh>                .sf_name:	resb	11	; 11 character name that is in the
   917                                  				; directory entry.  This is used by
   918                                  				; close to detect file deleted and
   919                                  				; disk changed errors.
   920                                  ; SHARING INFO
   921 0000002B ????????                .sf_chain:	resd	1	; link to next SF
   922 0000002F ????                    .sf_UID:	resw	1
   923 00000031 ????                    .sf_PID:	resw	1
   924 00000033 ????                    .sf_MFT:	resw	1
   925                                  
   926                                  ; MSDOS 6.0, SF.INC, 1991
   927 00000035 ????                    .sf_lstclus:	resw	1	;AN009; Last cluster accessed
   928 00000037 ????????                .sf_IFS_HDR:	resd	1
   929                                  
   930                                  .size:
   931                                  endstruc
   932                                  
   933                                  ; 20/07/2018
   934                                  ; MSDOS 3.3, SF.INC, 1987
   935                                  %define sf_netid   SF_ENTRY.sf_cluspos    ; byte
   936                                  %define sf_OpenAge SF_ENTRY.sf_position+2 ; word
   937                                  %define sf_LRU	   SF_ENTRY.sf_position	  ; word
   938                                  ; MSDOS 6.0, SF.INC, 1991
   939                                  %define sf_fsda	     SF_ENTRY.sf_cluspos  ; byte ;DOS 4.00
   940                                  %define sf_serial_ID SF_ENTRY.sf_firclus  ; word ;DOS 4.00
   941                                  
   942                                  ; 19/07/2018
   943                                  ; MSDOS 3.3, SF.INC, 1987
   944                                  
   945                                  sf_default_number  EQU	5
   946                                  
   947                                  ; Note that we need to mark an SFT as being busy for OPEN/CREATE.  This is
   948                                  ; because an INT 24 may prevent us from 'freeing' it.  We mark this as such
   949                                  ; by placing a -1 in the ref_count field.
   950                                  
   951                                  sf_busy EQU -1
   952                                  
   953                                  ; mode mask for FCB detection
   954                                  sf_isFCB		EQU	1000000000000000B
   955                                  
   956                                  ; Flag word masks
   957                                  sf_isnet		EQU	1000000000000000B
   958                                  sf_close_nodate 	EQU	0100000000000000B
   959                                  sf_pipe 		EQU	0010000000000000B
   960                                  sf_no_inherit		EQU	0001000000000000B
   961                                  sf_net_spool		EQU	0000100000000000B
   962                                  
   963                                  ; 25/04/2019
   964                                  sf_entry_size equ SF_ENTRY.size ; 59 (MSDOS 6.0)
   965                                  
   966                                  ; ---------------------------------------------------------------------------
   967                                  ; Local file/device flag masks
   968                                  ; ---------------------------------------------------------------------------
   969                                  
   970                                  devid_file_clean        EQU     40h     ; true if file and not written
   971                                  devid_file_mask_drive   EQU     3Fh     ; mask for drive number
   972                                  
   973                                  devid_device            EQU     80h     ; true if a device
   974                                  devid_device_EOF        EQU     40h     ; true if end of file reached
   975                                  devid_device_raw        EQU     20h     ; true if in raw mode
   976                                  devid_device_special    EQU     10h     ; true if special device
   977                                  devid_device_clock      EQU     08h     ; true if clock device
   978                                  devid_device_null       EQU     04h     ; true if null device
   979                                  devid_device_con_out    EQU     02h     ; true if console output
   980                                  devid_device_con_in     EQU     01h     ; true if consle input
   981                                  
   982                                  ; ---------------------------------------------------------------------------
   983                                  ; structure of devid field as returned by IOCTL is:
   984                                  ;
   985                                  ;       BIT     7   6   5   4   3   2   1   0
   986                                  ;             |---|---|---|---|---|---|---|---|
   987                                  ;             | I | E | R | S | I | I | I | I |
   988                                  ;             | S | O | A | P | S | S | S | S |
   989                                  ;             | D | F | W | E | C | N | C | C |
   990                                  ;             | E |   |   | C | L | U | O | I |
   991                                  ;             | V |   |   | L | K | L | T | N |
   992                                  ;             |---|---|---|---|---|---|---|---|
   993                                  ;       ISDEV = 1 if this channel is a device
   994                                  ;             = 0 if this channel is a disk file
   995                                  ;
   996                                  ;       If ISDEV = 1
   997                                  ;
   998                                  ;             EOF = 0 if End Of File on input
   999                                  ;             RAW = 1 if this device is in Raw mode
  1000                                  ;                 = 0 if this device is cooked
  1001                                  ;             ISCLK = 1 if this device is the clock device
  1002                                  ;             ISNUL = 1 if this device is the null device
  1003                                  ;             ISCOT = 1 if this device is the console output
  1004                                  ;             ISCIN = 1 if this device is the console input
  1005                                  ;
  1006                                  ;       If ISDEV = 0
  1007                                  ;             EOF = 0 if channel has been written
  1008                                  ;             Bits 0-5  are  the  block  device  number  for
  1009                                  ;                 the channel (0 = A, 1 = B, ...)
  1010                                  ; ---------------------------------------------------------------------------
  1011                                  
  1012                                  devid_ISDEV     EQU     80h
  1013                                  devid_EOF       EQU     40h
  1014                                  devid_RAW       EQU     20h
  1015                                  devid_SPECIAL   EQU     10H
  1016                                  devid_ISCLK     EQU     08h
  1017                                  devid_ISNUL     EQU     04h
  1018                                  devid_ISCOT     EQU     02h
  1019                                  devid_ISCIN     EQU     01h
  1020                                  
  1021                                  devid_block_dev EQU     1Fh             ; mask for block device number
  1022                                  
  1023                                  ;============================================================================
  1024                                  ; PDB.INC, MSDOS 6.0, 1991
  1025                                  ;============================================================================
  1026                                  ; 04/05/2019 - Retro DOS v4.0
  1027                                  ; 08/07/2018 - Retro DOS v3.0
  1028                                  
  1029                                  ; ---------------------------------------------------------------------------
  1030                                  ; BREAK <Process data block>
  1031                                  ; ---------------------------------------------------------------------------
  1032                                  ;**	Process data block (otherwise known as program header)
  1033                                  ;
  1034                                  
  1035                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
  1036                                  ;	can be rearranged here, ever. Reserved areas are probably safe
  1037                                  ;	for use.
  1038                                  ; ---------------------------------------------------------------------------
  1039                                  
  1040                                  FILPERPROC	EQU     20
  1041                                  
  1042                                  struc PDB	; Process_data_block
  1043 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
  1044 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
  1045 00000004 ??                                      resb 1
  1046 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
  1047 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
  1048 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
  1049 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
  1050 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
  1051 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
  1052 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
  1053 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
  1054 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
  1055 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
  1056 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
  1057 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
  1058 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
  1059 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
  1060 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
  1061 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
  1062 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
  1063 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
  1064                                  				;  an extended FCB
  1065                                  ;endstruc 	; MSDOS 3.3
  1066                                  	  	; MSDOS 6.0
  1067 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
  1068 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
  1069 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
  1070 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
  1071                                  endstruc
  1072                                  
  1073                                  ;============================================================================
  1074                                  ; EXE.INC, MSDOS 6.0, 1991
  1075                                  ;============================================================================
  1076                                  ; 04/05/2019 - Retro DOS v4.0
  1077                                  
  1078                                  ;**	EXE.INC - Definitions for the EXEC command and EXE files
  1079                                  ; ---------------------------------------------------------------------------
  1080                                  ; The following get used as arguments to the EXEC system call.  They indicate
  1081                                  ; whether or not the program is executed or whether or not a program header
  1082                                  ; gets created.
  1083                                  
  1084                                  exec_func_no_execute EQU 1	; no execute bit
  1085                                  exec_func_overlay    EQU 2	; overlay bit
  1086                                  
  1087                                  struc EXEC0
  1088 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
  1089 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
  1090 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
  1091 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
  1092                                  .size:
  1093                                  endstruc
  1094                                  
  1095                                  struc EXEC1
  1096 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
  1097 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
  1098 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
  1099 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
  1100 0000000E ????                    .SP:		resw 1		; stack pointer of program
  1101 00000010 ????                    .SS:		resw 1		; stack seg register of program
  1102 00000012 ????                    .IP:		resw 1		; entry point IP
  1103 00000014 ????                    .CS:		resw 1		; entry point CS
  1104                                  .size:
  1105                                  endstruc
  1106                                  
  1107                                  struc EXEC3
  1108 00000000 ????                    .load_addr:	resw 1		; seg address of load point
  1109 00000002 ????                    .reloc_fac:	resw 1		; relocation factor
  1110                                  endstruc
  1111                                  
  1112                                  ;**	Exit codes (in upper byte) for terminating programs
  1113                                  
  1114                                  EXIT_TERMINATE		EQU	0
  1115                                  EXIT_ABORT		EQU	0
  1116                                  EXIT_CTRL_C		EQU	1
  1117                                  EXIT_HARD_ERROR 	EQU	2
  1118                                  EXIT_KEEP_PROCESS	EQU	3
  1119                                  
  1120                                  ;**	EXE File Header Description
  1121                                  
  1122                                  struc EXE
  1123 00000000 ????                    .signature:   resw 1		; must contain 4D5A (yay zibo!)
  1124 00000002 ????                    .len_mod_512: resw 1		; low 9 bits of length
  1125 00000004 ????                    .pages:       resw 1		; number of 512b pages in file
  1126 00000006 ????                    .rle_count:   resw 1		; count of reloc entries
  1127 00000008 ????                    .par_dir:     resw 1		; number of paragraphs before image
  1128 0000000A ????                    .min_BSS:     resw 1		; minimum number of para of BSS
  1129 0000000C ????                    .max_BSS:     resw 1		; max number of para of BSS
  1130 0000000E ????                    .SS:          resw 1		; stack of image
  1131 00000010 ????                    .SP:          resw 1		; SP of image
  1132 00000012 ????                    .chksum:      resw 1		; checksum of file (ignored)
  1133 00000014 ????                    .IP:          resw 1		; IP of entry
  1134 00000016 ????                    .CS:          resw 1		; CS of entry
  1135 00000018 ????                    .rle_table:   resw 1		; byte offset of reloc table
  1136 0000001A ????                    .iov:         resw 1		; overlay number (0 for root)
  1137 0000001C ????????                .sym_tab:     resd 1		; offset of symbol table in file
  1138                                  .size:
  1139                                  endstruc
  1140                                  
  1141                                  exe_valid_signature     EQU 5A4Dh
  1142                                  exe_valid_old_signature EQU 4D5Ah
  1143                                  
  1144                                  ;**	EXE file symbol info definitions
  1145                                  
  1146                                  struc symbol_entry
  1147 00000000 ????????                .value:	resd 1
  1148 00000004 ????                    .type:	resw 1
  1149 00000006 ??                      .len:	resb 1
  1150 00000007 <res FFh>               .name:	resb 255
  1151                                  endstruc
  1152                                  
  1153                                  ;**	Data structure passed for ExecReady call
  1154                                  
  1155                                  struc ERStruc
  1156 00000000 ????                     .ER_Reserved:	resw	1	; reserved, should be zero
  1157 00000002 ????                     .ER_Flags:	resw	1
  1158 00000004 ????????                 .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
  1159 00000008 ????                     .ER_PSP:	resw	1	; PSP of the program
  1160 0000000A ????????                 .ER_StartAddr:	resd	1	; Start CS:IP of the program
  1161 0000000E ????????                 .ER_ProgSize:	resd	1	; Program size including PSP
  1162                                   .size:
  1163                                  endstruc
  1164                                  
  1165                                  ;** bit fields in ER_Flags
  1166                                  
  1167                                  ER_EXE		equ	0001h
  1168                                  ER_OVERLAY	equ	0002h
  1169                                  
  1170                                  
  1171                                  ;============================================================================
  1172                                  ; ARENA.INC, MSDOS 6.0, 1991
  1173                                  ;============================================================================
  1174                                  ; 24/04/2019 - Retro DOS v4.0
  1175                                  ; 04/08/2018 - Retro DOS v3.0
  1176                                  
  1177                                  ;BREAK <Memory arena structure>
  1178                                  
  1179                                  ;**	Arena Header
  1180                                  
  1181                                  struc ARENA
  1182 00000000 ??                      .SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
  1183 00000001 ????                    .OWNER:		resw 1		; owner of arena item
  1184 00000003 ????                    .SIZE:		resw 1		; size in paragraphs of item
  1185 00000005 ??????                  .RESERVED:	resb 3		; reserved
  1186 00000008 ????????????????        .NAME:		resb 8		; owner file name
  1187                                  .headersize:			
  1188                                  endstruc
  1189                                  
  1190                                  ; 20/05/2019 - Retro DOS v4.0
  1191                                  ARENAHEADERSIZE equ ARENA.headersize 
  1192                                  
  1193                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
  1194                                  ; and arena_owner_system are all equal to zero and are contained in DI.
  1195                                  ; Change them and change ALLOC.ASM.
  1196                                  
  1197                                  arena_owner_system  EQU 0               ; free block indication
  1198                                  
  1199                                  arena_signature_normal	EQU 4Dh		; valid signature, not end of arena
  1200                                  arena_signature_end     EQU 5Ah         ; valid signature, last block in arena
  1201                                  
  1202                                  FIRST_FIT	EQU	00000000B
  1203                                  BEST_FIT	EQU	00000001B
  1204                                  LAST_FIT	EQU	00000010B
  1205                                  
  1206                                  ; MSDOS 6.0
  1207                                  LOW_FIRST	EQU	00000000B	; M001
  1208                                  HIGH_FIRST	EQU	10000000B	; M001
  1209                                  HIGH_ONLY	EQU	01000000B	; M001
  1210                                  
  1211                                  LINKSTATE	EQU	00000001B	; M002
  1212                                  
  1213                                  HF_MASK		EQU	~HIGH_FIRST	; M001
  1214                                  HO_MASK		EQU	~HIGH_ONLY	; M001
  1215                                  
  1216                                  STRAT_MASK	EQU	HF_MASK & HO_MASK	; M001;
  1217                                  						; M026: used to mask of bits
  1218                                  						; M026: 6 & 7 of AllocMethod
  1219                                  
  1220                                  ;============================================================================
  1221                                  ; MI.INC, MSDOS 6.0, 1991
  1222                                  ;============================================================================
  1223                                  ; 07/07/2018 - Retro DOS v3.0
  1224                                  
  1225                                  ;BREAK <Machine instruction, flag definitions and character types>
  1226                                  
  1227                                  mi_INT		EQU	0CDh
  1228                                  mi_long_jmp	EQU	0EAh
  1229                                  mi_Long_CALL	EQU	09Ah
  1230                                  mi_Long_RET	EQU	0CBh
  1231                                  mi_Near_RET	EQU	0C3h
  1232                                  
  1233                                  ;			xxxxoditszxaxpxc
  1234                                  f_Overflow	EQU	0000100000000000B
  1235                                  f_Direction	EQU	0000010000000000B
  1236                                  f_Interrupt	EQU	0000001000000000B
  1237                                  f_Trace 	EQU	0000000100000000B
  1238                                  f_Sign		EQU	0000000010000000B
  1239                                  f_Zero		EQU	0000000001000000B
  1240                                  f_Aux		EQU	0000000000010000B
  1241                                  f_Parity	EQU	0000000000000100B
  1242                                  f_Carry 	EQU	0000000000000001B
  1243                                  
  1244                                  ;============================================================================
  1245                                  ; FILEMODE.INC, MSDOS 6.0, 1991
  1246                                  ;============================================================================
  1247                                  ; 13/07/2018 - Retro DOS v3.0
  1248                                  ; 29/04/2019 - Retro DOS v4.0
  1249                                  
  1250                                  ;**	Standard I/O file handles
  1251                                  
  1252                                  stdin       EQU     0
  1253                                  stdout      EQU     1
  1254                                  stderr      EQU     2
  1255                                  stdaux      EQU     3
  1256                                  stdprn      EQU     4
  1257                                  
  1258                                  ;**	File Modes
  1259                                  ; <Xenix subfunction assignments>  ; MSDOS 3.3 FILEMODE.INC
  1260                                  
  1261                                  open_for_read   EQU 0
  1262                                  open_for_write  EQU 1
  1263                                  open_for_both   EQU 2
  1264                                  
  1265                                  ; MSDOS 6.0
  1266                                  OPEN_FOR_BOTH	equ 2
  1267                                  EXEC_OPEN	equ 3	; access code of 3 indicates that open was 
  1268                                  				; made from exec
  1269                                  
  1270                                  access_mask	EQU 0Fh ; 09/08/2018
  1271                                  
  1272                                  SHARING_MASK	    equ 0F0h
  1273                                  SHARING_COMPAT	    equ 000h
  1274                                  SHARING_DENY_BOTH   equ 010h
  1275                                  SHARING_DENY_WRITE  equ 020h
  1276                                  SHARING_DENY_READ   equ 030h
  1277                                  SHARING_DENY_NONE   equ 040h
  1278                                  SHARING_NET_FCB     equ 070h
  1279                                  SHARING_NO_INHERIT  equ 080h
  1280                                  
  1281                                  ; 29/04/2019
  1282                                  
  1283                                  ;**	Extended Open Definitions
  1284                                  
  1285                                  RESERVED_BITS_MASK equ 0FE00h	; reserved bits for extended open flags
  1286                                  EXISTS_MASK	   equ 0Fh 	; "file exists" action field
  1287                                  NOT_EXISTS_MASK    equ 0F0h
  1288                                  
  1289                                  ;*	SF_MODE values
  1290                                  
  1291                                  AUTO_COMMIT_WRITE	equ 4000h
  1292                                  INT_24_ERROR		equ 2000h
  1293                                  
  1294                                  ;*	Flags in EXTOPEN_ON
  1295                                  
  1296                                  EXT_OPEN_ON		equ 01h
  1297                                  EXT_FILE_NOT_EXISTS	equ 04h
  1298                                  EXT_OPEN_I24_OFF	equ 02h
  1299                                  
  1300                                  ;*	Flags in EXTOPEN_FLAG
  1301                                  
  1302                                  ACTION_OPENED		equ 01h
  1303                                  ACTION_CREATED_OPENED	equ 02h
  1304                                  ACTION_REPLACED_OPENED	equ 03h
  1305                                  EXT_EXISTS_OPEN 	equ 01h
  1306                                  EXT_EXISTS_FAIL 	equ 00h
  1307                                  EXT_NEXISTS_CREATE	equ 10h
  1308                                  
  1309                                  ;**	Extended Open Structure
  1310                                  
  1311                                  struc EXT_OPEN_PARM
  1312 00000000 ????????                .SET_LIST:	resd 1
  1313 00000004 ????                    .NUM_OF_PARM:	resw 1
  1314                                  endstruc
  1315                                  
  1316                                  ;============================================================================
  1317                                  ; SYSCALL.INC, MSDOS 6.0, 1991
  1318                                  ;============================================================================
  1319                                  ; 29/04/2019 - Retro DOS v4.0
  1320                                  ; 09/07/2018 - Retro DOS v3.0 (SYSCALL.INC, MSDOS 3.3, 1987)
  1321                                  
  1322                                  ; <system call definitions>
  1323                                  
  1324                                  ABORT                           EQU 0   ;  0      0
  1325                                  STD_CON_INPUT                   EQU 1   ;  1      1
  1326                                  STD_CON_OUTPUT                  EQU 2   ;  2      2
  1327                                  STD_AUX_INPUT                   EQU 3   ;  3      3
  1328                                  STD_AUX_OUTPUT                  EQU 4   ;  4      4
  1329                                  STD_PRINTER_OUTPUT              EQU 5   ;  5      5
  1330                                  RAW_CON_IO                      EQU 6   ;  6      6
  1331                                  RAW_CON_INPUT                   EQU 7   ;  7      7
  1332                                  STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
  1333                                  STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
  1334                                  STD_CON_STRING_INPUT            EQU 10  ; 10      A
  1335                                  STD_CON_INPUT_STATUS            EQU 11  ; 11      B
  1336                                  STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
  1337                                  DISK_RESET                      EQU 13  ; 13      D
  1338                                  SET_DEFAULT_DRIVE               EQU 14  ; 14      E
  1339                                  FCB_OPEN                        EQU 15  ; 15      F
  1340                                  FCB_CLOSE                       EQU 16  ; 16     10
  1341                                  DIR_SEARCH_FIRST                EQU 17  ; 17     11
  1342                                  DIR_SEARCH_NEXT                 EQU 18  ; 18     12
  1343                                  FCB_DELETE                      EQU 19  ; 19     13
  1344                                  FCB_SEQ_READ                    EQU 20  ; 20     14
  1345                                  FCB_SEQ_WRITE                   EQU 21  ; 21     15
  1346                                  FCB_CREATE                      EQU 22  ; 22     16
  1347                                  FCB_RENAME                      EQU 23  ; 23     17
  1348                                  GET_DEFAULT_DRIVE               EQU 25  ; 25     19
  1349                                  SET_DMA                         EQU 26  ; 26     1A
  1350                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1351                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1352                                  ;                                                                          ;
  1353                                  GET_DEFAULT_DPB                 EQU 31  ; 31     1F
  1354                                  ;                                                                          ;
  1355                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1356                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1357                                  FCB_RANDOM_READ                 EQU 33  ; 33     21
  1358                                  FCB_RANDOM_WRITE                EQU 34  ; 34     22
  1359                                  GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
  1360                                  GET_FCB_POSITION                EQU 36  ; 36     24
  1361                                  SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
  1362                                  CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
  1363                                  FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
  1364                                  FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
  1365                                  PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
  1366                                  GET_DATE                        EQU 42  ; 42     2A
  1367                                  SET_DATE                        EQU 43  ; 43     2B
  1368                                  GET_TIME                        EQU 44  ; 44     2C
  1369                                  SET_TIME                        EQU 45  ; 45     2D
  1370                                  SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
  1371                                  ; Extended functionality group
  1372                                  GET_DMA                         EQU 47  ; 47     2F
  1373                                  GET_VERSION                     EQU 48  ; 48     30
  1374                                  KEEP_PROCESS                    EQU 49  ; 49     31
  1375                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1376                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1377                                  ;                                                                          ;
  1378                                  GET_DPB                         EQU 50  ; 50     32
  1379                                  ;                                                                          ;
  1380                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1381                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1382                                  SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
  1383                                  GET_INDOS_FLAG                  EQU 52  ; 52     34
  1384                                  GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
  1385                                  GET_DRIVE_FREESPACE             EQU 54  ; 54     36
  1386                                  CHAR_OPER                       EQU 55  ; 55     37
  1387                                  INTERNATIONAL                   EQU 56  ; 56     38
  1388                                  ; XENIX CALLS
  1389                                  ;   Directory Group
  1390                                  MKDIR                           EQU 57  ; 57     39
  1391                                  RMDIR                           EQU 58  ; 58     3A
  1392                                  CHDIR                           EQU 59  ; 59     3B
  1393                                  ;   File Group
  1394                                  CREAT                           EQU 60  ; 60     3C
  1395                                  OPEN                            EQU 61  ; 61     3D
  1396                                  CLOSE                           EQU 62  ; 62     3E
  1397                                  READ                            EQU 63  ; 63     3F
  1398                                  WRITE                           EQU 64  ; 64     40
  1399                                  UNLINK                          EQU 65  ; 65     41
  1400                                  LSEEK                           EQU 66  ; 66     42
  1401                                  CHMOD                           EQU 67  ; 67     43
  1402                                  IOCTL                           EQU 68  ; 68     44
  1403                                  XDUP                            EQU 69  ; 69     45
  1404                                  XDUP2                           EQU 70  ; 70     46
  1405                                  CURRENT_DIR                     EQU 71  ; 71     47
  1406                                  ;    Memory Group
  1407                                  ALLOC                           EQU 72  ; 72     48
  1408                                  DEALLOC                         EQU 73  ; 73     49
  1409                                  SETBLOCK                        EQU 74  ; 74     4A
  1410                                  ;    Process Group
  1411                                  EXEC                            EQU 75  ; 75     4B
  1412                                  EXIT                            EQU 76  ; 76     4C
  1413                                  _WAIT				EQU 77  ; 77     4D
  1414                                  FIND_FIRST                      EQU 78  ; 78     4E
  1415                                  ;   Special Group
  1416                                  FIND_NEXT                       EQU 79  ; 79     4F
  1417                                  ; SPECIAL SYSTEM GROUP
  1418                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1419                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1420                                  ;                                                                          ;
  1421                                  SET_CURRENT_PDB                 EQU 80  ; 80     50
  1422                                  GET_CURRENT_PDB                 EQU 81  ; 81     51
  1423                                  GET_IN_VARS                     EQU 82  ; 82     52
  1424                                  SETDPB                          EQU 83  ; 83     53
  1425                                  ;                                                                          ;
  1426                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1427                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1428                                  GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
  1429                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1430                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1431                                  ;                                                                          ;
  1432                                  DUP_PDB                         EQU 85  ; 85     55
  1433                                  ;                                                                          ;
  1434                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1435                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1436                                  RENAME                          EQU 86  ; 86     56
  1437                                  FILE_TIMES                      EQU 87  ; 87     57
  1438                                  ALLOCOPER			EQU 88	; 88	 58
  1439                                  ; Network extention system calls
  1440                                  GETEXTENDEDERROR		EQU 89	; 89	 59
  1441                                  CREATETEMPFILE			EQU 90	; 90	 5A
  1442                                  CREATENEWFILE			EQU 91	; 91	 5B
  1443                                  LOCKOPER			EQU 92	; 92	 5C Lock and Unlock
  1444                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1445                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1446                                  ;									   ;
  1447                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
  1448                                  					;	    CloseByName, CloseUser,
  1449                                  					;	    CloseUserProcess,
  1450                                  					;	    GetOpenFileList
  1451                                  ;									   ;
  1452                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1453                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1454                                  USEROPER			EQU 94	; 94	 5E Get and Set
  1455                                  ASSINGOPER			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
  1456                                  XNAMETRANS			EQU 96	; 96	 60
  1457                                  PATHPARSE			EQU 97	; 97	 61
  1458                                  GETCURRENTPSP			EQU 98	; 98	 62
  1459                                  HONGEUL 			EQU 99	; 99	 63
  1460                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1461                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1462                                  ;									   ;
  1463                                  SET_PRINTER_FLAG		EQU 100 ; 100	 64
  1464                                  ;									   ;
  1465                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1466                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1467                                  GETEXTCNTRY			EQU 101 ; 101	 65 
  1468                                  GETSETCDPG			EQU 102 ; 102	 66
  1469                                  EXTHANDLE			EQU 103 ; 103	 67
  1470                                  COMMIT				EQU 104 ; 104	 68
  1471                                  
  1472                                  ; 29/04/2019 - Retro DOS v4.0
  1473                                  ; (MSDOS 6.0, SYSCALL.INC, 1987)
  1474                                  
  1475                                  GetSetMediaID			EQU 105 ; 105	 69
  1476                                  IFS_IOCTL			EQU 107 ; 107	 6B
  1477                                  ExtOpen 			EQU 108 ; 108	 6C
  1478                                  
  1479                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1480                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1481                                  ;                                                                          ;
  1482                                  ;ifdef ROMEXEC
  1483                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
  1484                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
  1485                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
  1486                                  ;endif
  1487                                  ;                                                                          ;
  1488                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1489                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1490                                  
  1491                                  SET_OEM_HANDLER			EQU 248 ; 248    F8
  1492                                  ;OEM_C1				EQU 249 ; 249    F9
  1493                                  ;OEM_C2				EQU 250 ; 250    FA
  1494                                  ;OEM_C3				EQU 251 ; 251    FB
  1495                                  ;OEM_C4				EQU 252 ; 252    FC
  1496                                  ;OEM_C5				EQU 253 ; 253    FD
  1497                                  ;OEM_C6				EQU 254 ; 254    FE
  1498                                  ;OEM_C7				EQU 255 ; 255    FF
  1499                                  
  1500                                  ;============================================================================
  1501                                  ; VERSIONA.INC (MSDOS 6.0, 1991)
  1502                                  ;============================================================================
  1503                                  ; 24/04/2019 - Retro DOS 4.0
  1504                                  
  1505                                  ;MAJOR_VERSION	EQU     6
  1506                                  ;;MINOR_VERSION	EQU	00
  1507                                  ;MINOR_VERSION	EQU     21  ; MSDOS 6.21
  1508                                  
  1509                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  1510                                  ;MAJOR_VERSION	EQU     5
  1511                                  ;MINOR_VERSION	EQU     0
  1512                                  
  1513                                  ; 30/12/2022 - Retro DOS v4.2
  1514                                  MAJOR_VERSION	EQU     6
  1515                                  MINOR_VERSION	EQU     22
  1516                                  
  1517                                  ;============================================================================
  1518                                  ; INTNAT.INC, MSDOS 3.3, 1987
  1519                                  ;============================================================================
  1520                                  ; 09/07/2018 - Retro DOS 3.0
  1521                                  
  1522                                  ; Current structure of the data returned by the international call
  1523                                  
  1524                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  1525                                  .Date_tim_format:
  1526 00000000 ????                    		RESW 1		; 0-USA, 1-EUR, 2-JAP
  1527                                  .Currency_sym:
  1528 00000002 ??????????              		RESB 5		; Currency Symbol 5 bytes
  1529                                  .Thous_sep:
  1530 00000007 ????                    		RESB 2		; Thousands separator 2 bytes
  1531                                  .Decimal_sep:
  1532 00000009 ????                    		RESB 2		; Decimal separator 2 bytes
  1533                                  .Date_sep:
  1534 0000000B ????                    		RESB 2		; Date separator 2 bytes
  1535                                  .Time_sep:
  1536 0000000D ????                    		RESB 2		; Time separator 2 bytes
  1537                                  .Bit_field:	
  1538 0000000F ??                      		RESB 1		; Bit values
  1539                                                                     ;   Bit 0 = 0 if currency symbol first
  1540                                                                     ;         = 1 if currency symbol last
  1541                                                                     ;   Bit 1 = 0 if No space after currency symbol
  1542                                                                     ;         = 1 if space after currency symbol
  1543                                  .Currency_cents:
  1544 00000010 ??                      		RESB 	1	; Number of places after currency dec point
  1545                                  .Time_24:
  1546 00000011 ??                      		RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
  1547                                  .Map_call:
  1548 00000012 ????                    		RESW	1	; Address of case mapping call (DWORD)
  1549 00000014 ????                                    RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
  1550                                  				;  in pieces.
  1551                                  .Data_sep:
  1552 00000016 ????                    		RESB	2	; Data list separator character
  1553                                  .size:		
  1554                                  endstruc
  1555                                  
  1556                                  ; Max size of the block returned by the INTERNATIONAL call
  1557                                  
  1558                                  internat_block_max	EQU	32
  1559                                  
  1560                                  ;============================================================================
  1561                                  ; SYSVAR.INC (MSDOS 6.0, 1991)
  1562                                  ;============================================================================
  1563                                  ; 08/07/2018 - Retro DOS v3.0
  1564                                  
  1565                                  ;SysInitVars STRUC
  1566                                  struc SYSI
  1567 00000000 ????????                .DPB:	    resd 1		; DPB chain
  1568 00000004 ????????                .SFT:	    resd 1		; SFT chain
  1569 00000008 ????????                .CLOCK:	    resd 1		; CLOCK device
  1570 0000000C ????????                .CON:	    resd 1		; CON device
  1571 00000010 ????                    .MAXSEC:    resw 1		; maximum sector size
  1572 00000012 ????????                .BUF:	    resd 1		; points to Hashinitvar
  1573 00000016 ????????                .CDS:	    resd 1		; CDS list
  1574 0000001A ????????                .FCB:	    resd 1		; FCB chain
  1575 0000001E ????                    .Keep:	    resw 1		; keep count
  1576 00000020 ??                      .NUMIO:	    resb 1		; Number of block devices
  1577 00000021 ??                      .NCDS:	    resb 1		; number of CDS's
  1578 00000022 ????????                .DEV:	    resd 1		; device list
  1579                                  ; 09/07/2018
  1580                                  ; Above parameters are described in MSDOS 3.3 SYSVAR.INC (85/04/10)
  1581                                  ; Following parameters are used with MSDOS 6.0 (Retro DOS v4.0)
  1582 00000026 ????                    .ATTR:	    resw 1		; null device attribute word
  1583 00000028 ????                    .STRAT:	    resw 1		; null device strategy entry point
  1584 0000002A ????                    .INTER:	    resw 1		; null device interrupt entry point
  1585 0000002C ????????????????        .NAME:	    resb 8		; null device name
  1586 00000034 ??                      .SPLICE:    resb 1		; TRUE -> splicees being done
  1587 00000035 ????                    .IBMDOS_SIZE: resw 1		; DOS size in paragraphs
  1588 00000037 ????????                .IFS_DOSCALL@: resd 1		; IFS DOS service rountine entry
  1589 0000003B ????????                .IFS:	    resd 1		; IFS header chain
  1590 0000003F ????????                .BUFFERS:   resw 2		; BUFFERS= values (m,n)
  1591 00000043 ??                      .BOOT_DRIVE: resb 1		; boot drive A=1 B=2,..
  1592 00000044 ??                      .DWMOVE:    resb 1		; 1 if 386 machine
  1593 00000045 ????                    .EXT_MEM:   resw 1		; Extended memory size in KB.
  1594                                  endstruc
  1595                                  ;SysInitVars ENDS
  1596                                  
  1597                                  ;This is added for more information exchange between DOS, BIOS.
  1598                                  ;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
  1599                                  
  1600                                  ;SysInitVars_Ext struc
  1601                                  struc SYSI_EXT
  1602 00000000 ????????                .SysInitVars:	resd 1		; Points to the above structure.
  1603 00000004 ????????                .Country_Tab:	resd 1		; DOS_Country_cdpg_info
  1604                                  endstruc
  1605                                  ;SysInitVars_Ext ends
  1606                                  
  1607                                  ;============================================================================
  1608                                  ; IOCTL.INC - MSDOS 6.0 - 1991
  1609                                  ;============================================================================
  1610                                  ; 09/07/2018 - Retro DOS v3.0
  1611                                  
  1612                                  ;*** J.K.
  1613                                  ;General Guide -
  1614                                  ;Category Code:
  1615                                  ; 0... .... DOS Defined
  1616                                  ; 1... .... User defined
  1617                                  ; .xxx xxxx Code
  1618                                  
  1619                                  ;Function Code:
  1620                                  ; 0... .... Return error if unsupported
  1621                                  ; 1... .... Ignore if unsupported
  1622                                  ; .0.. .... Intercepted by DOS
  1623                                  ; .1.. .... Passed to driver
  1624                                  ; ..0. .... Sends data/commands to device
  1625                                  ; ..1. .... Quries data/info from device
  1626                                  ; ...x .... Subfunction
  1627                                  ;
  1628                                  ; Note that "Sends/queries" data bit is intended only to regularize the
  1629                                  ; function set.  It plays no critical role; some functions may contain both
  1630                                  ; command and query elements. The convention is that such commands are
  1631                                  ; defined as "sends data".
  1632                                  
  1633                                  ;*****************************;*
  1634                                  ; BLOCK DRIVERS 	      ;*
  1635                                  ;*****************************;*
  1636                                  
  1637                                  ; IOCTL SUB-FUNCTIONS
  1638                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1639                                  IOCTL_GET_DEVICE_INFO	EQU	0
  1640                                  IOCTL_SET_DEVICE_INFO	EQU	1
  1641                                  IOCTL_READ_HANDLE	EQU	2
  1642                                  IOCTL_WRITE_HANDLE	EQU	3
  1643                                  IOCTL_READ_DRIVE	EQU	4
  1644                                  IOCTL_WRITE_DRIVE	EQU	5
  1645                                  IOCTL_GET_INPUT_STATUS	EQU	6
  1646                                  IOCTL_GET_OUTPUT_STATUS EQU	7
  1647                                  IOCTL_CHANGEABLE?	EQU	8
  1648                                  IOCTL_DeviceLocOrRem?	EQU	9
  1649                                  IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
  1650                                  IOCTL_SHARING_RETRY	EQU	0Bh   ;11
  1651                                  GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
  1652                                  GENERIC_IOCTL		EQU	0Dh   ;13
  1653                                  ; (MSDOS 6.0 + MSDOS 3.3)
  1654                                  IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
  1655                                  IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
  1656                                  ; (MSDOS 6.0)
  1657                                  IOCTL_QUERY_HANDLE	EQU	10h   ;16
  1658                                  IOCTL_QUERY_BLOCK	EQU	11h   ;17
  1659                                  
  1660                                  ; GENERIC IOCTL CATEGORY CODES
  1661                                  IOC_OTHER		EQU	0	; Other device control J.K. 4/29/86
  1662                                  IOC_SE			EQU	1	; SERIAL DEVICE CONTROL
  1663                                  IOC_TC			EQU	2	; TERMINAL CONTROL
  1664                                  IOC_SC			EQU	3	; SCREEN CONTROL
  1665                                  IOC_KC			EQU	4	; KEYBOARD CONTROL
  1666                                  IOC_PC			EQU	5	; PRINTER CONTROL
  1667                                  IOC_DC			EQU	8	; DISK CONTROL (SAME AS RAWIO)
  1668                                  
  1669                                  ; GENERIC IOCTL SUB-FUNCTIONS
  1670                                  RAWIO			EQU	8
  1671                                  
  1672                                  ; RAWIO SUB-FUNCTIONS
  1673                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1674                                  GET_DEVICE_PARAMETERS	EQU	60H
  1675                                  SET_DEVICE_PARAMETERS	EQU	40H
  1676                                  READ_TRACK		EQU	61H
  1677                                  WRITE_TRACK		EQU	41H
  1678                                  VERIFY_TRACK		EQU	62H
  1679                                  FORMAT_TRACK		EQU	42H
  1680                                  ; (MSDOS 6.0)
  1681                                  GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
  1682                                  SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
  1683                                  GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
  1684                                  SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
  1685                                  SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00
  1686                                  
  1687                                  ; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
  1688                                  BUILD_DEVICE_BPB	EQU	000000001B
  1689                                  
  1690                                  ; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
  1691                                  INSTALL_FAKE_BPB	EQU	000000001B
  1692                                  ONLY_SET_TRACKLAYOUT	EQU	000000010B
  1693                                  TRACKLAYOUT_IS_GOOD	EQU	000000100B
  1694                                  
  1695                                  ; SPECIAL FUNCTION FOR FORMAT TRACK
  1696                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1697                                  STATUS_FOR_FORMAT	EQU	000000001B
  1698                                  ; (MSDOS 6.0)
  1699                                  DO_FAST_FORMAT		EQU	000000010B ;AN001;
  1700                                  
  1701                                  ; CODES RETURNED FROM FORMAT STATUS CALL
  1702                                  FORMAT_NO_ROM_SUPPORT	EQU	000000001B
  1703                                  FORMAT_COMB_NOT_SUPPORTED EQU	000000010B
  1704                                  
  1705                                  ; DEVICETYPE VALUES
  1706                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1707                                  MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
  1708                                  DEV_5INCH		EQU	0
  1709                                  DEV_5INCH96TPI		EQU	1
  1710                                  DEV_3INCH720KB		EQU	2
  1711                                  DEV_8INCHSS		EQU	3
  1712                                  DEV_8INCHDS		EQU	4
  1713                                  DEV_HARDDISK		EQU	5
  1714                                  DEV_OTHER		EQU	7
  1715                                  ; (MSDOS 6.0)
  1716                                  ;DEV_3INCH1440KB	EQU	7
  1717                                  DEV_3INCH2880KB		EQU	9
  1718                                  ; Retro DOS v2.0 - 26/03/2018
  1719                                  ;;DEV_TAPE		EQU	6
  1720                                  ;;DEV_ERIMO		EQU	8
  1721                                  ;DEV_3INCH2880KB	EQU	9
  1722                                  DEV_3INCH1440KB		EQU	10
  1723                                  
  1724                                  ; (MSDOS 3.3)
  1725                                  ;MAX_DEV_TYPE		EQU	7
  1726                                  
  1727                                  ; (MSDOS 6.0)
  1728                                  MAX_DEV_TYPE		EQU	10	; MAXIMUM DEVICE TYPE THAT WE
  1729                                  					; CURRENTLY SUPPORT.
  1730                                  struc A_SECTORTABLE
  1731 00000000 ????                    .ST_SECTORNUMBER:	resw	1
  1732 00000002 ????                    .ST_SECTORSIZE:		resw	1
  1733                                  .size:
  1734                                  endstruc
  1735                                  
  1736                                  ;============================================================================
  1737                                  ; DEVSYM.INC
  1738                                  ;============================================================================
  1739                                  ; 07/07/2018 - Retro DOS v3.0
  1740                                  ; 30/04/2019 - Retro DOS v4.0 (DEVSYM.INC, MSDOS 6.0, 1991)
  1741                                  
  1742                                  ;**	DevSym.inc - Device Symbols
  1743                                  
  1744                                  ; The device table list has the form:
  1745                                  struc	SYSDEV
  1746 00000000 ????????                .NEXT:		resd 1		;Pointer to next device header
  1747 00000004 ????                    .ATT:		resw 1		;Attributes of the device
  1748 00000006 ????                    .STRAT:		resw 1		;Strategy entry point
  1749 00000008 ????                    .INT:		resw 1		;Interrupt entry point
  1750 0000000A ????????????????        .NAME:		resb 8		;Name of device (only first byte used for block)
  1751                                  .size:
  1752                                  endstruc
  1753                                  
  1754                                  ;
  1755                                  ; ATTRIBUTE BIT MASKS
  1756                                  ;
  1757                                  ; CHARACTER DEVICES:
  1758                                  ;
  1759                                  ; BIT 15 -> MUST BE 1
  1760                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1761                                  ;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
  1762                                  ;     12 -> UNUSED
  1763                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
  1764                                  ;     10 -> MUST BE 0
  1765                                  ;      9 -> MUST BE 0
  1766                                  ;      8 -> UNUSED
  1767                                  ;      7 -> UNUSED
  1768                                  ;      6 -> UNUSED
  1769                                  ;      5 -> UNUSED
  1770                                  ;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
  1771                                  ;      3 -> 1 IF DEVICE IS CLOCK DEVICE
  1772                                  ;      2 -> 1 IF DEVICE IS NULL DEVICE
  1773                                  ;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
  1774                                  ;      0 -> 1 IF DEVICE IS CONSOLE INPUT
  1775                                  ;
  1776                                  ; BLOCK DEVICES:
  1777                                  ;
  1778                                  ; BIT 15 -> MUST BE 0
  1779                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1780                                  ;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
  1781                                  ;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
  1782                                  ;	    THE SAME PLACE.
  1783                                  ;     12 -> UNUSED
  1784                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
  1785                                  ;     10 -> MUST BE 0
  1786                                  ;      9 -> MUST BE 0
  1787                                  ;      8 -> UNUSED
  1788                                  ;      7 -> UNUSED
  1789                                  ;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
  1790                                  ;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
  1791                                  ;      5 -> UNUSED
  1792                                  ;      4 -> UNUSED
  1793                                  ;      3 -> UNUSED
  1794                                  ;      2 -> UNUSED
  1795                                  ;      1 -> UNUSED
  1796                                  ;      0 -> UNUSED
  1797                                  ;
  1798                                  
  1799                                  ;Attribute bit masks
  1800                                  DEVTYP	EQU     8000H           ;Bit 15 - 1 if Char, 0 if block
  1801                                  DEVIOCTL EQU    4000H           ;Bit 14 - CONTROL mode bit
  1802                                  ISFATBYDEV EQU  2000H           ;Bit 13 - Device uses FAT ID bytes, comp media.
  1803                                  
  1804                                  ; 09/07/2018 - Retro DOS (DEVSYM.INC, MSDOS 3.3, 1987) 
  1805                                  
  1806                                  OUTTILBUSY EQU	2000H		; OUTPUT UNTIL BUSY IS ENABLED
  1807                                  ISNET	   EQU	1000H		; BIT 12 - 1 IF A NET DEVICE, 0 IF
  1808                                  				;  NOT.  CURRENTLY BLOCK ONLY.
  1809                                  DEVOPCL    EQU	0800H		; BIT 11 - 1 IF THIS DEVICE HAS
  1810                                  				;  OPEN,CLOSE AND REMOVABLE MEDIA
  1811                                  				;  ENTRY POINTS, 0 IF NOT
  1812                                  
  1813                                  EXTENTBIT  EQU	0400H		; BIT 10 - CURRENTLY 0 ON ALL DEVS
  1814                                  				;  THIS BIT IS RESERVED FOR FUTURE USE
  1815                                  				;  TO EXTEND THE DEVICE HEADER BEYOND
  1816                                  				;  ITS CURRENT FORM.
  1817                                  
  1818                                  ; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
  1819                                  ;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
  1820                                  ;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
  1821                                  ;    MACHINES (FORMAT,CHKDSK,RECOVER,..).
  1822                                  
  1823                                  IOQUERY	EQU	0080H		;Bit 7 - Supports generic IOCtl query
  1824                                  
  1825                                  DEV320	EQU	0040H		;BIT 6 - FOR BLOCK DEVICES, THIS
  1826                                  				;DEVICE SUPPORTS SET/GET MAP OF
  1827                                  				;LOGICAL DRIVES, AND SUPPORTS
  1828                                  				;GENERIC IOCTL CALLS.
  1829                                  				;FOR CHARACTER DEVICES, THIS
  1830                                  				;DEVICE SUPPORTS GENERIC IOCTL.
  1831                                  				;THIS IS A DOS 3.2 DEVICE DRIVER.
  1832                                  
  1833                                  ISSPEC	EQU     0010H		;Bit 4 - This device is special ; 15/03/2018
  1834                                  ;ISIBM	EQU     0010H		;Bit 4 - This device is special
  1835                                  ISCLOCK EQU     0008H           ;Bit 3 - This device is the clock device.
  1836                                  ISNULL  EQU     0004H           ;Bit 2 - This device is the null device.
  1837                                  ISCOUT  EQU     0002H           ;Bit 1 - This device is the console output.
  1838                                  ISCIN   EQU     0001H           ;Bit 0 - This device is the console input.
  1839                                  
  1840                                  EXTDRVR	EQU	0002h		;BIT 1 - BLOCK DEVICE EXTENDED DRIVER
  1841                                  				; (MSDOS 6.0, DEVSYM.INC, 1991) ; 30/04/2019
  1842                                  
  1843                                  ;Static Reguest Header
  1844                                  struc	SRHEAD
  1845 00000000 ??                      .REQLEN:	resb 1		;Length in bytes of request block
  1846 00000001 ??                      .REQUNIT:	resb 1		;Device unit number
  1847 00000002 ??                      .REQFUNC:	resb 1		;Type of request
  1848 00000003 ????                    .REQSTAT:	resw 1		;Status Word
  1849 00000005 ????????????????                	resb 8		;Reserved for queue links
  1850                                  .size:
  1851                                  endstruc
  1852                                  
  1853                                  ;Status word masks
  1854                                  STERR   EQU     8000H           ;Bit 15 - Error
  1855                                  STBUI   EQU     0200H           ;Bit 9 - Buisy
  1856                                  STDON   EQU     0100H           ;Bit 8 - Done
  1857                                  STECODE EQU     00FFH           ;Error code
  1858                                  WRECODE EQU     0
  1859                                  
  1860                                  ;Function codes
  1861                                  DINITHL EQU     26              ;Size of init header
  1862                                  DMEDHL  EQU     15              ;Size of media check header
  1863                                  DBPBHL  EQU     22              ;Size of Get BPB header
  1864                                  DRDWRHL EQU     22              ;Size of RD/WR header
  1865                                  DRDNDHL EQU     14              ;Size of non destructive read header
  1866                                  DSTATHL EQU     13              ;Size of status header
  1867                                  DFLSHL  EQU     15              ;Size of flush header
  1868                                  
  1869                                  DEVINIT EQU     0               ;Initialization
  1870                                  DEVMDCH EQU     1               ;Media check
  1871                                  DEVBPB  EQU     2               ;Get BPB
  1872                                  DEVRDIOCTL EQU  3               ;IOCTL read
  1873                                  DEVRD   EQU     4               ;Read
  1874                                  DEVRDND EQU     5               ;Non destructive read no wait (character devs)
  1875                                  DEVIST  EQU     6               ;Input status
  1876                                  DEVIFL  EQU     7               ;Input flush
  1877                                  DEVWRT  EQU     8               ;Write
  1878                                  DEVWRTV EQU     9               ;Write with verify
  1879                                  DEVOST  EQU     10              ;Output status
  1880                                  DEVOFL  EQU     11              ;Output flush
  1881                                  DEVWRIOCTL EQU  12              ;IOCTL write
  1882                                  
  1883                                  ; 09/07/2018 - Retro DOS v3.0 (DEVSYM.INC, MSDOS 3.3, 1987) 
  1884                                  DEVOPN	EQU	13		;DEVICE OPEN
  1885                                  DEVCLS	EQU	14		;DEVICE CLOSE
  1886                                  DOPCLHL EQU	13		;SIZE OF OPEN/CLOSE HEADER
  1887                                  DEVRMD	EQU	15		;REMOVABLE MEDIA
  1888                                  ; 07/08/2018 - Retro DOS v3.0
  1889                                  REMHL	EQU	13		;SIZE OF REMOVABLE MEDIA HEADER
  1890                                  GENIOCTL EQU	19
  1891                                  
  1892                                  ; THE NEXT THREE ARE USED IN DOS 4.0
  1893                                  ;		     20
  1894                                  ;		     21
  1895                                  ;		     22
  1896                                  
  1897                                  DEVGETOWN      EQU   23		;GET DEVICE OWNER
  1898                                  DEVSETOWN      EQU   24		;SET DEVICE OWNER
  1899                                  ; 18/05/2019 - Retro DOS v4.0
  1900                                  IOCTL_QUERY    EQU   25		;Query generic ioctl support
  1901                                  
  1902                                  OWNHL	       EQU   13		;SIZE OF DEVICE OWNER HEADER
  1903                                  
  1904                                  DEVOUT	       EQU   16		; OUTPUT UNTIL BUSY.
  1905                                  DEVOUTL        EQU   DEVWRT	; LENGTH OF OUTPUT UNTIL BUSY
  1906                                  
  1907                                  ; ADDED FOR DOS 5.00
  1908                                  
  1909                                  ; GENERIC IOCTL REQUEST STRUCTURE
  1910                                  ;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
  1911                                  
  1912                                  struc IOCTL_REQ
  1913 00000000 <res Dh>                .SRHEAD:	resb SRHEAD.size
  1914                                  				; GENERIC IOCTL ADDITION.
  1915 0000000D ??                      .MAJORFUNCTION: resb 1		;FUNCTION CODE
  1916 0000000E ??                      .MINORFUNCTION: resb 1		;FUNCTION CATEGORY
  1917 0000000F ????                    .REG_SI:	resw 1
  1918 00000011 ????                    .REG_DI:	resw 1
  1919 00000013 ????????                .GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
  1920                                  .size: ; 07/08/2018
  1921                                  endstruc
  1922                                  
  1923                                  ; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
  1924                                  GEN_IOCTL_WRT_TRK EQU	40H
  1925                                  GEN_IOCTL_RD_TRK  EQU	60H
  1926                                  GEN_IOCTL_FN_TST  EQU	20H	; USED TO DIFF. BET READS AND WRTS
  1927                                  
  1928                                  ;; 32-bit absolute read/write input list structure
  1929                                  
  1930                                  struc ABS_32RW
  1931 00000000 ????????                .SECTOR_RBA:	resd 1		; relative block address
  1932 00000004 ????                    .ABS_RW_COUNT:	resw 1		; number of sectors to be transferred
  1933 00000006 ????????                .BUFFER_ADDR:	resd 1		; data addrress
  1934                                  .size:
  1935                                  endstruc
  1936                                  
  1937                                  ;; media ID info
  1938                                  
  1939                                  struc MEDIA_ID_INFO
  1940 00000000 ????                    .MEDIA_level:	resw	1	; info level
  1941 00000002 ????????                .MEDIA_Serial:	resd	1	; serial #
  1942 00000006 <res Bh>                .MEDIA_Label:	resb	11	; volume label
  1943 00000011 ????????????????        .MEDIA_System:	resb	8	; system type
  1944                                  .size:
  1945                                  endstruc
  1946                                  
  1947                                  ; equates for DOS34_FLAG
  1948                                  ; (BUGBUG: why are bits 0,1,3 and 4 not defined.)
  1949                                  
  1950                                  FROM_DISK_RESET       EQU   000000000100b   ;from disk reset
  1951                                  Force_I24_Fail	      EQU   000000100000b   ;form IFS CALL BACK
  1952                                  Disable_EOF_I24       EQU   000001000000b   ;disable EOF int24 for input status
  1953                                  DBCS_VOLID	      EQU   000010000000b   ;indicate from volume id
  1954                                  DBCS_VOLID2	      EQU   000100000000b   ;indicate 8th char is DBCS
  1955                                  CTRL_BREAK_FLAG       EQU   001000000000b   ;indicate control break is input
  1956                                  SEARCH_FASTOPEN       EQU   010000000000b   ;set fastopen flag for search
  1957                                  EXEC_AWARE_REDIR      EQU   100000000000b   ;M018: this bit is set by a redir 
  1958                                  					    ;M018: that knows how to handle 
  1959                                  					    ;M018: open for exec
  1960                                  
  1961                                  NO_FROM_DISK_RESET    EQU   ~FROM_DISK_RESET	;not from disk reset
  1962                                  NO_Force_I24_Fail     EQU   ~Force_I24_Fail	;not form IFS CALL BACK
  1963                                  NO_Disable_EOF_I24    EQU   ~Disable_EOF_I24
  1964                                  
  1965                                  ;============================================================================
  1966                                  ; ERROR.INC (MSDOS 6.0, 1991)
  1967                                  ;============================================================================
  1968                                  ; 16/07/2018 - Retro DOS v3.0 
  1969                                  
  1970                                  ;**	ERROR.INC - DOS Error Codes
  1971                                  ;
  1972                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
  1973                                  ;    return error codes through AX. If an error occurred then
  1974                                  ;    the carry bit will be set and the error code is in AX. If no error
  1975                                  ;    occurred then the carry bit is reset and AX contains returned info.
  1976                                  ;
  1977                                  ;    Since the set of error codes is being extended as we extend the operating
  1978                                  ;    system, we have provided a means for applications to ask the system for a
  1979                                  ;    recommended course of action when they receive an error.
  1980                                  ;
  1981                                  ;    The GetExtendedError system call returns a universal error, an error
  1982                                  ;    location and a recommended course of action. The universal error code is
  1983                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
  1984                                  ;    is issued.
  1985                                  
  1986                                  ;	2.0 error codes
  1987                                  
  1988                                  error_invalid_function		EQU	1
  1989                                  error_file_not_found		EQU	2
  1990                                  error_path_not_found		EQU	3
  1991                                  error_too_many_open_files	EQU	4
  1992                                  error_access_denied		EQU	5
  1993                                  error_invalid_handle		EQU	6
  1994                                  error_arena_trashed		EQU	7
  1995                                  error_not_enough_memory 	EQU	8
  1996                                  error_invalid_block		EQU	9
  1997                                  error_bad_environment		EQU	10
  1998                                  error_bad_format		EQU	11
  1999                                  error_invalid_access		EQU	12
  2000                                  error_invalid_data		EQU	13
  2001                                  ;**** reserved			EQU	14	; *****
  2002                                  error_invalid_drive		EQU	15
  2003                                  error_current_directory 	EQU	16
  2004                                  error_not_same_device		EQU	17
  2005                                  error_no_more_files		EQU	18
  2006                                  
  2007                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
  2008                                  
  2009                                  error_write_protect		EQU	19
  2010                                  error_bad_unit			EQU	20
  2011                                  error_not_ready 		EQU	21
  2012                                  error_bad_command		EQU	22
  2013                                  error_CRC			EQU	23
  2014                                  error_bad_length		EQU	24
  2015                                  error_seek			EQU	25
  2016                                  error_not_DOS_disk		EQU	26
  2017                                  error_sector_not_found		EQU	27
  2018                                  error_out_of_paper		EQU	28
  2019                                  error_write_fault		EQU	29
  2020                                  error_read_fault		EQU	30
  2021                                  error_gen_failure		EQU	31
  2022                                  
  2023                                  ;	the new 3.0 error codes reported through INT 24
  2024                                  
  2025                                  error_sharing_violation 	EQU	32
  2026                                  error_lock_violation		EQU	33
  2027                                  error_wrong_disk		EQU	34
  2028                                  error_FCB_unavailable		EQU	35
  2029                                  error_sharing_buffer_exceeded	EQU	36
  2030                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00  ;AN000;
  2031                                  error_handle_EOF		EQU	38    ; DOS 4.00  ;AN000;
  2032                                  error_handle_Disk_Full		EQU	39    ; DOS 4.00  ;AN000;
  2033                                  
  2034                                  ;	New OEM network-related errors are 50-79
  2035                                  
  2036                                  error_not_supported		EQU	50
  2037                                  
  2038                                  error_net_access_denied		EQU	65	;M028
  2039                                  
  2040                                  ;	End of INT 24 reportable errors
  2041                                  
  2042                                  error_file_exists		EQU	80
  2043                                  error_DUP_FCB			EQU	81	; *****
  2044                                  error_cannot_make		EQU	82
  2045                                  error_FAIL_I24			EQU	83
  2046                                  
  2047                                  ;	New 3.0 network related error codes
  2048                                  
  2049                                  error_out_of_structures 	EQU	84
  2050                                  error_already_assigned		EQU	85
  2051                                  error_invalid_password		EQU	86
  2052                                  error_invalid_parameter 	EQU	87
  2053                                  error_NET_write_fault		EQU	88
  2054                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00  ;AN000;
  2055                                  
  2056                                  ;	BREAK <Interrupt 24 error codes>
  2057                                  
  2058                                  ;**	Int24 Error Codes
  2059                                  
  2060                                  error_I24_write_protect 	EQU	0
  2061                                  error_I24_bad_unit		EQU	1
  2062                                  error_I24_not_ready		EQU	2
  2063                                  error_I24_bad_command		EQU	3
  2064                                  error_I24_CRC			EQU	4
  2065                                  error_I24_bad_length		EQU	5
  2066                                  error_I24_Seek			EQU	6
  2067                                  error_I24_not_DOS_disk		EQU	7
  2068                                  error_I24_sector_not_found	EQU	8
  2069                                  error_I24_out_of_paper		EQU	9
  2070                                  error_I24_write_fault		EQU	0Ah
  2071                                  error_I24_read_fault		EQU	0Bh
  2072                                  error_I24_gen_failure		EQU	0Ch
  2073                                  ; NOTE: Code 0DH is used by MT-DOS.
  2074                                  error_I24_wrong_disk		EQU	0Fh
  2075                                  
  2076                                  ;	THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
  2077                                  ;
  2078                                  ;	NOTE: ABORT is ALWAYS allowed
  2079                                  
  2080                                  Allowed_FAIL			EQU	00001000B
  2081                                  Allowed_RETRY			EQU	00010000B
  2082                                  Allowed_IGNORE			EQU	00100000B
  2083                                  
  2084                                  I24_operation			EQU	00000001B  ;Z if READ,NZ if Write
  2085                                  I24_area			EQU	00000110B  ; 00 if DOS
  2086                                  						   ; 01 if FAT
  2087                                  						   ; 10 if root DIR
  2088                                  						   ; 11 if DATA
  2089                                  I24_class			EQU	10000000B  ;Z if DISK, NZ if FAT or char
  2090                                  
  2091                                  ;	BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>
  2092                                  
  2093                                  ;**	The GetExtendedError call takes an error code and returns CLASS,
  2094                                  ;	ACTION and LOCUS codes to help programs determine the proper action
  2095                                  ;	to take for error codes that they don't explicitly understand.
  2096                                  
  2097                                  ;	Values for error CLASS
  2098                                  
  2099                                  errCLASS_OutRes 	EQU	1	; Out of Resource
  2100                                  errCLASS_TempSit	EQU	2	; Temporary Situation
  2101                                  errCLASS_Auth		EQU	3	; Permission problem
  2102                                  errCLASS_Intrn		EQU	4	; Internal System Error
  2103                                  errCLASS_HrdFail	EQU	5	; Hardware Failure
  2104                                  errCLASS_SysFail	EQU	6	; System Failure
  2105                                  errCLASS_Apperr 	EQU	7	; Application Error
  2106                                  errCLASS_NotFnd 	EQU	8	; Not Found
  2107                                  errCLASS_BadFmt 	EQU	9	; Bad Format
  2108                                  errCLASS_Locked 	EQU	10	; Locked
  2109                                  errCLASS_Media		EQU	11	; Media Failure
  2110                                  errCLASS_Already	EQU	12	; Collision with Existing Item
  2111                                  errCLASS_Unk		EQU	13	; Unknown/other
  2112                                  
  2113                                  ;	Values for error ACTION
  2114                                  
  2115                                  errACT_Retry		EQU	1	; Retry
  2116                                  errACT_DlyRet		EQU	2	; Delay Retry, retry after pause
  2117                                  errACT_User		EQU	3	; Ask user to regive info
  2118                                  errACT_Abort		EQU	4	; abort with clean up
  2119                                  errACT_Panic		EQU	5	; abort immediately
  2120                                  errACT_Ignore		EQU	6	; ignore
  2121                                  errACT_IntRet		EQU	7	; Retry after User Intervention
  2122                                  
  2123                                  ;	Values for error LOCUS
  2124                                  
  2125                                  errLOC_Unk		EQU	1	; No appropriate value
  2126                                  errLOC_Disk		EQU	2	; Random Access Mass Storage
  2127                                  errLOC_Net		EQU	3	; Network
  2128                                  errLOC_SerDev		EQU	4	; Serial Device
  2129                                  errLOC_Mem		EQU	5	; Memory
  2130                                  
  2131                                  ;============================================================================
  2132                                  ; INT2A.INC (MSDOS 6.0, 1991)
  2133                                  ;============================================================================
  2134                                  ; 04/05/2019 - Retro DOS v4.0
  2135                                  
  2136                                  ;**	Int 2A functions
  2137                                  ; ---------------------------------------------------------------------------
  2138                                  ;	Int 2A is an interface to the network code; it's also overloaded
  2139                                  ;		as a critical section handler since critical sections
  2140                                  ;		were originally created to support the net.
  2141                                  ; ---------------------------------------------------------------------------
  2142                                  
  2143                                  ; ---------------------------------------------------------------------------
  2144                                  ;**	This table was created by examining the source and may not be
  2145                                  ;	complete or completely accurate - JGL
  2146                                  ;
  2147                                  ;	M010	MD	8/31/90 - Added definition for AH = 5
  2148                                  
  2149                                  ;	(ah) = 0	installation check
  2150                                  ;			   (returns ah !=0 if installed)
  2151                                  ;	(ah) = 1	cooked net bios call
  2152                                  ;	(ah) = 3	query drive shared
  2153                                  ;			   (ds:si) = "n:" asciz string
  2154                                  ;	(ah) = 4	net bios
  2155                                  ;	       (al) = 0	   cooked net bios call
  2156                                  ;	       (al) = 1	   raw net bios call
  2157                                  ;	       (al) = 2	   ???
  2158                                  ;
  2159                                  ;	(ah) = 5	Get Net Adaptor Resources. CX returns the number of
  2160                                  ;			NCBs available/outstanding. DX returns the number of
  2161                                  ;			sessions. Supposedly, this is documented in an old
  2162                                  ;			IBM PC-LAN reference. Lotus Notes uses it. DOS LAN
  2163                                  ;			Manager 2.0 Enhanced responds to it. But it should
  2164                                  ;			not be used, as it is a hack, only to get Lotus
  2165                                  ;			Notes running.
  2166                                  ;
  2167                                  ;	(ah) = 80h	enter critical section
  2168                                  ;	(ah) = 81h	leave critical section
  2169                                  ;	(ah) = 82h	free all critical sections (Leave-all)
  2170                                  ;	(ah) = 84h	entering idle loop (don't understand how this works)
  2171                                  ; ---------------------------------------------------------------------------
  2172                                  
  2173                                  ;**	Critical section definitions
  2174                                  ; ---------------------------------------------------------------------------
  2175                                  ;	Although DOS is not designed to be reentrant there are some hacks
  2176                                  ;	which various programs use to make it so, in a limited fashion.
  2177                                  ;	Both WIN386 and some servers block copy a section of the DOS data
  2178                                  ;	area so that DOS can be reentered on behalf of another thread/program.
  2179                                  ;	DOS's global data structures, such as the memory arena, are not
  2180                                  ;	in this area, so critical section indicators are used to protect
  2181                                  ;	those areas.  DOS flags a critical section by issuing an INT_IBM
  2182                                  ;	(int 2Ah) at each critical section entry and exit.  Some clients
  2183                                  ;	(such as WIN386) just don't "context switch" the DOS when one
  2184                                  ;	of these is in effect, others, such as the IBM server, go ahead
  2185                                  ;	and reenter the DOS and if they get an int 2A to reenter the same
  2186                                  ;	critical section they then switch away from that second thread and
  2187                                  ;	let the first one finish and exit the section.
  2188                                  ; ---------------------------------------------------------------------------
  2189                                  
  2190                                  ; These below are subject to leave-all sections
  2191                                  critDisk    EQU     1			; Disk I/O critical section
  2192                                  critShare   EQU     1			; Sharer I/O critical section
  2193                                  critMem     EQU     1			; memory maintenance critical section
  2194                                  critSFT     EQU     1			; sft table allocation
  2195                                  critDevice  EQU     2			; Device I/O critical section
  2196                                  critNet     EQU     5			; network critical section
  2197                                  critIFS     EQU     6			; ifsfunc critical section
  2198                                  ; These below are not subject to leave-all sections
  2199                                  critASSIGN  EQU     8			; Assign has munged a system call
  2200                                  
  2201                                  ;============================================================================
  2202                                  ; MULT.INC (MSDOS 6.0, 1991)
  2203                                  ;============================================================================
  2204                                  ; 04/05/2019 - Retro DOS v4.0
  2205                                  
  2206                                  ;Break <Multiplex channels>
  2207                                  
  2208                                  ; ---------------------------------------------------------------------------
  2209                                  ; The current set of defined multiplex channels is (* means documented):
  2210                                  ;
  2211                                  ;   Channel(h)  Issuer          Receiver    Function
  2212                                  ;      00       server          PSPRINT     print job control
  2213                                  ;     *01       print/apps      PRINT       Queueing of files
  2214                                  ;      02       BIOS            REDIR       signal open/close of printers
  2215                                  ;
  2216                                  ;      05       command         REDIR       obtain text of net int 24 message
  2217                                  ;     *06       server/assign   ASSIGN      Install check
  2218                                  ;
  2219                                  ;      08       external driver IBMBIO      interface to internal routines
  2220                                  ;
  2221                                  ;      10       sharer/server   Sharer      install check
  2222                                  ;      11       DOS/server      Redir       install check/redirection funcs
  2223                                  ;      12       sharer/redir    DOS         dos functions and structure maint
  2224                                  ;      13       MSNET           MSNET       movement of NCBs
  2225                                  ;      13       external driver IBMBIO      Reset_Int_13, allows installation
  2226                                  ;                                           of alternative INT_13 drivers after
  2227                                  ;                                           boot_up
  2228                                  ;      14 (IBM) DOS             NLSFUNC     down load NLS country info,DOS 3.3
  2229                                  ;      14 (MS)  APPS            POPUP       MSDOS 4 popup screen functions
  2230                                  ;      15       APPS            MSCDEX      CD-ROM extensions interface
  2231                                  ;      16       WIN386          WIN386      Windows communications
  2232                                  ;      17       Clipboard       WINDOWS     Clipboard interface
  2233                                  ;     *18       Applications    MS-Manger   Toggle interface to manager
  2234                                  ;      19       Shell
  2235                                  ;      1A       Ansi.sys
  2236                                  ;      1B       Fastopen,Vdisk   IBMBIO     EMS INT 67H stub handler
  2237                                  ;
  2238                                  ;      40h      OS/2
  2239                                  ;      41h      Lanman
  2240                                  ;      42h      Lanman
  2241                                  ;      43h      Himem
  2242                                  ;                               AL = 20h    reserved for Mach 20 Himem support
  2243                                  ;                               AL = 30h    reserved for Himem external A20 code
  2244                                  ;      44h      Dosextender
  2245                                  ;      45H      Windows profiler
  2246                                  ;      46h      Windows/286 DOS extender
  2247                                  ;      47h      Basic Compiler Vn. 7.0
  2248                                  ;      48h      Doskey
  2249                                  ;      49h      DOS 5.x install 
  2250                                  ;      4Ah      Multi Purpose
  2251                                  ;                multMULTSWPDSK         0 - Swap Disk in drive A (BIOS)
  2252                                  ;                multMULTGETHMAPTR      1 - Get available HMA & ptr
  2253                                  ;                multMULTALLOCHMA       2 - Allocate HMA (bx == no of bytes)
  2254                                  ;                multMULTTASKSHELL      5 - Shell/switcher API
  2255                                  ;                multMULTRPLTOM         6 - Top Of Memory for RPL support
  2256                                  ;
  2257                                  ;                multSmartdrv           10h
  2258                                  ;                multMagicdrv           11h
  2259                                  ;      4Bh      Task Switcher API
  2260                                  ;
  2261                                  ;      4Ch      APPS            APM         Advanced power management
  2262                                  ;      4Dh      Kana Kanji Converter, MSKK
  2263                                  ;
  2264                                  ;      51h      ODI real mode support driver (for Chicago)
  2265                                  ;
  2266                                  ;      53h      POWER.EXE - used for broadcasting APM events    ; M036
  2267                                  ;      54h      POWER.EXE - used for POWER API                  ; M036
  2268                                  ;
  2269                                  ;      55h      COMMAND.COM
  2270                                  ;                multCOMFIRST           0 - API to determine whether 1st
  2271                                  ;                                           instance of command.com
  2272                                  ;                multCOMFIRSTROM        1 - API to determine whether 1st
  2273                                  ;                                           instance of ROM COMMAND
  2274                                  ;      56h      Sewell Development
  2275                                  ;               INTERLNK
  2276                                  ;
  2277                                  ;      57h      Iomega Corp.
  2278                                  ;
  2279                                  ;      ABh      Unspecified IBM use
  2280                                  ;      ACh      Graphics
  2281                                  ;      ADh      NLS (toronto)
  2282                                  ;      AEh
  2283                                  ;      AFh      Mode
  2284                                  ;      B0h      GRAFTABL        GRAFTABL
  2285                                  ;
  2286                                  ;      D7h      Banyan VINES
  2287                                  ; ---------------------------------------------------------------------------
  2288                                  
  2289                                  ;MUX 00-3F reserverd for IBM
  2290                                  ;MUX 80-BF reserverd for IBM
  2291                                  
  2292                                  ;MUX 40-7F reserved for Microsoft
  2293                                  
  2294                                  ;MUX C0-FF users
  2295                                  
  2296                                  MultSHARE   EQU     10h 		; sharer
  2297                                      ;	1   MFT_enter
  2298                                      ;	2   MFTClose
  2299                                      ;	3   MFTclU
  2300                                      ;	4   MFTCloseP
  2301                                      ;	5   MFTCloN
  2302                                      ;	6   set_block
  2303                                      ;	7   clr_block
  2304                                      ;	8   chk_block
  2305                                      ;	9   MFT_get
  2306                                      ;	10  ShSave
  2307                                      ;	11  ShChk
  2308                                      ;	12  ShCol
  2309                                      ;	13  ShCloseFile
  2310                                  
  2311                                  MultNET     EQU     11h 		; Network support
  2312                                  MultIFS     EQU     11h                 ; Network support
  2313                                      ;   1   IFS_RMDIR
  2314                                      ;   2   IFS_SEQ_RMDIR
  2315                                      ;   3   IFS_MKDIR
  2316                                      ;   4   IFS_SEQ_MKDIR
  2317                                      ;   5   IFS_CHDIR
  2318                                      ;   6   IFS_CLOSE
  2319                                      ;   7   IFS_COMMIT
  2320                                      ;   8   IFS_READ
  2321                                      ;   9   IFS_WRITE
  2322                                      ;   10  IFS_LOCK
  2323                                      ;   11  IFS_UNLOCK
  2324                                      ;   12  IFS_DISK_INFO
  2325                                      ;   13  IFS_SET_FILE_ATTRIBUTE
  2326                                      ;   14  IFS_SEQ_SET_FILE_ATTRIBUTE
  2327                                      ;   15  IFS_GET_FILE_INFO
  2328                                      ;   16  IFS_SEQ_GET_FILE_INFO
  2329                                      ;   17  IFS_RENAME
  2330                                      ;   18  IFS_SEQ_RENAME
  2331                                      ;   19  IFS_DELETE
  2332                                      ;   20  IFS_SEQ_DELETE
  2333                                      ;   21  IFS_OPEN
  2334                                      ;   22  IFS_SEQ_OPEN
  2335                                      ;   23  IFS_CREATE
  2336                                      ;   24  IFS_SEQ_CREATE
  2337                                      ;   25  IFS_SEQ_SEARCH_FIRST
  2338                                      ;   26  IFS_SEQ_SEARCH_NEXT
  2339                                      ;   27  IFS_SEARCH_FIRST
  2340                                      ;   28  IFS_SEARCH_NEXT
  2341                                      ;   29  IFS_ABORT
  2342                                      ;   30  IFS_ASSOPER
  2343                                      ;   31  Printer_SET_STRING
  2344                                      ;   32  IFSFlushBuf
  2345                                      ;   33  IFSBufWrite
  2346                                      ;   34  IFSResetEnvironment
  2347                                      ;   35  IFSSpoolCheck
  2348                                      ;   36  IFSSpoolClose
  2349                                      ;   37  IFSDeviceOper
  2350                                      ;   38  IFSSpoolEchoCheck
  2351                                      ;   39      - - -   Unused   - - -
  2352                                      ;   40      - - -   Unused   - - -
  2353                                      ;   41      - - -   Unused   - - -
  2354                                      ;   42  SERVER_DOSCALL_CLOSEFILES_FOR_UID
  2355                                      ;   43  DEVICE_IOCTL
  2356                                      ;   44  IFS_UPDATE_CB
  2357                                      ;   45  IFS_FILE_XATTRIBUTES
  2358                                      ;   46  IFS_XOPEN
  2359                                      ;   47  IFS_DEPENDENT_IOCTL
  2360                                  
  2361                                  MultDOS     EQU     12h 		; DOS call back
  2362                                      ;	1   DOS_CLOSE
  2363                                      ;	2   RECSET
  2364                                      ;	3   Get DOSGROUP
  2365                                      ;	4   PATHCHRCMP
  2366                                      ;	5   OUT
  2367                                      ;	6   NET_I24_ENTRY
  2368                                      ;	7   PLACEBUF
  2369                                      ;	8   FREE_SFT
  2370                                      ;	9   BUFWRITE
  2371                                      ;	10  SHARE_VIOLATION
  2372                                      ;	11  SHARE_ERROR
  2373                                      ;	12  SET_SFT_MODE
  2374                                      ;	13  DATE16
  2375                                      ;	14  SETVISIT
  2376                                      ;	15  SCANPLACE
  2377                                      ;	16  SKIPVISIT
  2378                                      ;	17  StrCpy
  2379                                      ;	18  StrLen
  2380                                      ;	19  UCase
  2381                                      ;	20  POINTCOMP
  2382                                      ;	21  CHECKFLUSH
  2383                                      ;	22  SFFromSFN
  2384                                      ;	23  GetCDSFromDrv
  2385                                      ;	24  Get_User_Stack
  2386                                      ;	25  GetThisDrv
  2387                                      ;	26  DriveFromText
  2388                                      ;	27  SETYEAR
  2389                                      ;	28  DSUM
  2390                                      ;	29  DSLIDE
  2391                                      ;	30  StrCmp
  2392                                      ;	31  initcds
  2393                                      ;	32  pjfnfromhandle
  2394                                      ;	33  $NameTrans
  2395                                      ;	34  CAL_LK
  2396                                      ;	35  DEVNAME
  2397                                      ;	36  Idle
  2398                                      ;   37  DStrLen
  2399                                      ;   38  NLS_OPEN      DOS 3.3
  2400                                      ;   39  $CLOSE        DOS 3.3
  2401                                      ;   40  NLS_LSEEK     DOS 3.3
  2402                                      ;   41  $READ         DOS 3.3
  2403                                      ;   42  FastInit      DOS 4.0
  2404                                      ;   43  NLS_IOCTL     DOS 3.3
  2405                                      ;   44  GetDevList    DOS 3.3
  2406                                      ;   45  NLS_GETEXT    DOS 3.3
  2407                                      ;   46  MSG_RETRIEVAL DOS 4.0
  2408                                      ;   47  FAKE_VERSION  DOS 4.0
  2409                                  
  2410                                  NLSFUNC     EQU     14h 		; NLSFUNC CALL , DOS 3.3
  2411                                      ;	0   NLSInstall
  2412                                      ;	1   ChgCodePage
  2413                                      ;	2   GetExtInfo
  2414                                      ;	3   SetCodePage
  2415                                      ;	4   GetCntry
  2416                                  
  2417                                  multANSI    EQU     1Ah                 ; ANSI multiplex number
  2418                                      ;   0   INSTALL_CHECK               ; install check for ANSI
  2419                                      ;   1   IOCTL_2F                    ; 2F interface to IOCTL
  2420                                      ;   2   DA_INFO_2F                  ; J.K. Information passing to ANSI.
  2421                                  
  2422                                  multMULT        EQU     4Ah
  2423                                  multMAGIC       EQU     256*multMULT + 11h
  2424                                  multMULTRPLTOM  EQU     06h
  2425                                  
  2426                                      ;   0   swap disk function for single floppy drive m/cs
  2427                                      ;       BIOS broadcasts with cx==0, and apps who handle
  2428                                      ;       swap disk messaging set cx == -1. BIOS sets dl == requested
  2429                                      ;       drive
  2430                                      ;
  2431                                      ;   1   Get available HMA & pointer to it. Returns in BX & ES:DI
  2432                                      ;   2   Allocate HMA. BX == number of bytes in HMA to be allocated
  2433                                      ;       returns pointer in ES:DI
  2434                                      ;
  2435                                      ;   3-4 currently used by nobody
  2436                                      ;   5   Switcher API
  2437                                      ;   6   Top of Memory for RPL.
  2438                                      ;           BIOS issues INT 2f AX=4a06 & DX = Top of Mem and any RPL
  2439                                      ;           code present in TOM should respond with a new TOM in DX
  2440                                      ;           to protect itself from MSLOAD & SYSINIT tromping over it.
  2441                                      ;           SYSINIT builds an arena with owner type 8 & name 'RPL' to
  2442                                      ;           protect the RPL code from COMMAND.COM transient protion.
  2443                                      ;           It is the responsibility of RPL program to release the mem.
  2444                                      ;   7   Reserved for PROTMAN support.
  2445                                      ;  10   smartdrv 4.0
  2446                                      ;  11   dblspace api
  2447                                      ;  12   MRCI     api
  2448                                      ;  13   dblspace/mrci stealth packet api
  2449                                  
  2450                                  MultAPM     EQU     4ch             ; Obselete ???
  2451                                      ;       00h     APM_VER_CHK
  2452                                      ;       01h     APM_SUS_SYS_REQ
  2453                                      ;       FFh     APM_SUS_RES_BATT_NOTIFY
  2454                                  
  2455                                  MultPWR_BRDCST  EQU     53h     ; Used by POWER.EXE to broadcast      ; M036
  2456                                  				;  APM events                         ; M036
  2457                                  MultPWR_API     EQU     54h     ; Used for accessing POWER.EXE's API  ; M036
  2458                                  
  2459                                  ;FASTOPEN is not chained through INT 2F   ; DOS 3.3 F.C.
  2460                                  ;	  it calls Multdos 42 to set up an entry routine address
  2461                                      ;	0   Install status  (reserved)
  2462                                      ;	1   Lookup
  2463                                      ;	2   Insert
  2464                                      ;	3   Delete
  2465                                      ;	4   Purge	    (reserved)
  2466                                  
  2467                                  ;============================================================================
  2468                                  ; FIND.INC (MSDOS 6.0, 1991)
  2469                                  ;============================================================================
  2470                                  ; 17/05/2019 - Retro DOS v4.0
  2471                                  ; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)
  2472                                  
  2473                                  ;Break	<find first/next buffer>
  2474                                  
  2475                                  struc find_buf
  2476 00000000 ??                      .drive:	    resb 1		; drive of search
  2477 00000001 <res Bh>                .name:	    resb 11		; formatted name
  2478 0000000C ??                      .sattr:	    resb 1		; attribute of search
  2479 0000000D ????                    .LastEnt:   resw 1		; LastEnt
  2480 0000000F ????                    .DirStart:  resw 1		; DirStart
  2481 00000011 ????????                .NETID:	    resb 4 ; MSDOS 6.0 	; Reserved for NET
  2482 00000015 ??                      .attr:	    resb 1		; attribute found
  2483 00000016 ????                    .time:	    resw 1		; time
  2484 00000018 ????                    .date:	    resw 1		; date
  2485 0000001A ????                    .size_l:    resw 1		; low(size)
  2486 0000001C ????                    .size_h:    resw 1		; high(size)
  2487 0000001E <res Dh>                .pname:	    resb 13		; packed name
  2488                                  .size:
  2489                                  endstruc
  2490                                  
  2491                                  ;============================================================================
  2492                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2493                                  ;============================================================================
  2494                                  ; 29/04/2019 - Retro DOS v4.0
  2495                                  ; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)
  2496                                  
  2497                                  ;Equates for COUNTRY INFORMATION.
  2498                                  SetCountryInfo	EQU	1	;country info
  2499                                  SetUcase	EQU	2	;uppercase table
  2500                                  SetLcase	EQU	3	;lowercase table (Reserved)
  2501                                  SetUcaseFile	EQU	4	;uppercase file spec table
  2502                                  SetFileList	EQU	5	;valid file character list
  2503                                  SetCollate	EQU	6	;collating sequence
  2504                                  SetDBCS 	EQU	7	;double byte character set
  2505                                  SetALL		EQU	-1	;all the entries
  2506                                  
  2507                                  ;DOS country and code page information table structure.
  2508                                  ;Internally, IBMDOS gives a pointer to this table.
  2509                                  ;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
  2510                                  ;this structure.
  2511                                  
  2512                                  struc  DOS_CCDPG	; DOS_country_cdpg_info
  2513 00000000 ????????????????        .ccInfo_reserved: 	resb 8	;reserved for internal use
  2514 00000008 <res 40h>               .ccPath_CountrySys:	resb 64 ;path and filename for country info
  2515 00000048 ????                    .ccSysCodePage:		resw 1	;system code page id
  2516 0000004A ????                    .ccNumber_of_entries:	resw 1  ; (default value = 6)
  2517 0000004C ??                      .ccSetUcase:		resb 1  ; (default value = SetUcase)
  2518 0000004D ????????                .ccUcase_ptr:		resd 1	;pointer to Ucase table
  2519                                  
  2520 00000051 ??                      .ccSetUcaseFile:	resb 1	; (default value = SetUcaseFile)
  2521 00000052 ????????                .ccFileUcase_ptr: 	resd 1	;pointer to File Ucase table
  2522                                  
  2523 00000056 ??                      .ccSetFileList:		resb 1 	; (default value = SetFileList)
  2524 00000057 ????????                .ccFileChar_ptr:	resd 1	;pointer to File char list table
  2525                                  
  2526 0000005B ??                      .ccSetCollate:		resb 1	; (default value = SetCollate)
  2527 0000005C ????????                .ccCollate_ptr:		resd 1	;pointer to collate table
  2528                                  
  2529                                  ; MSDOS 6.0
  2530 00000060 ??                      .ccSetDBCS:		resb 1	; (default value = SetDBCS)
  2531 00000061 ????????                .ccDBCS_ptr:		resd 1	; pointer to DBCS table
  2532                                  
  2533 00000065 ??                      .ccSetCountryInfo:	resb 1  ; (default value = SetCountryInfo)
  2534 00000066 ????                    .ccCountryInfoLen:	resw 1	;length of country info
  2535 00000068 ????                    .ccDosCountry:		resw 1	;system country code id
  2536 0000006A ????                    .ccDosCodePage:		resw 1	;system code page id
  2537 0000006C ????                    .ccDFormat:		resw 1	;date format
  2538 0000006E ??????????              .ccCurSymbol:		resb 5	;5 byte of (currency symbol+0)
  2539 00000073 ????                    .cc1000Sep:		resb 2	;2 byte of (1000 sep. + 0)
  2540 00000075 ????                    .ccDecSep:		resb 2	;2 byte of (Decimal sep. + 0)
  2541 00000077 ????                    .ccDateSep:		resb 2	;2 byte of (date sep. + 0)
  2542 00000079 ????                    .ccTimeSep:		resb 2	;2 byte of (time sep. + 0)
  2543 0000007B ??                      .ccCFormat:		resb 1	;currency format flags
  2544 0000007C ??                      .ccCSigDigits:		resb 1	;# of digits in currency
  2545 0000007D ??                      .ccTFormat:		resb 1	;time format
  2546 0000007E ????????                .ccMono_ptr:		resd 1	;monocase routine entry point
  2547 00000082 ????                    .ccListSep:		resb 2	;data list separator
  2548 00000084 <res Ah>                .ccReserved_area: 	resw 5	;reserved
  2549                                  .size:
  2550                                  endstruc
  2551                                  
  2552                                  ;Ucase table
  2553                                  struc CC_UCASE_TAB
  2554 00000000 ????                    .ccUcase_leng:		resw 1	; (default value = 128)
  2555 00000002 <res 80h>               .ccUcase_data:		resb 128
  2556                                  endstruc
  2557                                  
  2558                                  ;File Ucase table
  2559                                  struc CC_FILE_UCASE_TAB
  2560 00000000 ????                    .ccFileucase_leng:	resw 1	; (default value = 128)
  2561 00000002 <res 80h>               .ccFileucase_data:	resb 128
  2562                                  endstruc
  2563                                  
  2564                                  ;File char list
  2565                                  struc CC_FILE_CHAR_TAB
  2566 00000000 ????                    .ccFilechar_leng:	resw 1
  2567 00000002 <res 2Eh>               .ccFilechar_data:	resb 46
  2568                                  endstruc
  2569                                  
  2570                                  ;collate table
  2571                                  struc CC_COLLATE_TAB
  2572 00000000 ????                    .ccCollate_leng:	resw 1	; (default value = 128)
  2573 00000002 <res 100h>              .ccCollate_data:	resb 256
  2574                                  endstruc
  2575                                  
  2576                                  OLD_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDFormat - 10)
  2577                                  NEW_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDosCountry) ; 38
  2578                                  
  2579                                  ; 06/08/2018
  2580                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2581                                  
  2582                                  ;CAPITALIZATION equates
  2583                                  CAP_ONE_CHAR	equ	20H
  2584                                  CAP_STRING	equ	21H
  2585                                  CAP_ASCIIZ	equ	22H
  2586                                  CHECK_YES_NO	equ	23H
  2587                                  UPPER_TABLE	equ	80H
  2588                                  
  2589                                  ;NLS_YES	equ	59H  ; 'Y'
  2590                                  ;NLS_yes2	equ	79H  ; 'y' 	
  2591                                  ;NLS_NO		equ	4EH  ; 'N'	
  2592                                  ;NLS_no2	equ	6EH  ; 'n'	
  2593                                  
  2594                                  ;============================================================================
  2595                                  ; CURDIR.INC (MSDOS 6.0, 1991)
  2596                                  ;============================================================================
  2597                                  ; 25/04/2019 - Retro DOS v4.0
  2598                                  ; 09/07/2018 - Retro DOS v3.0 (CURDIR.INC, MSDOS 3.3, 1987)
  2599                                  
  2600                                  ;BREAK <Current directory list structure>
  2601                                  
  2602                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2603                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2604                                  ;									   ;
  2605                                  ; CDS items are used bu the internal routines to store cluster numbers and ;
  2606                                  ; network identifiers for each logical name.  The ID field is used dually, ;
  2607                                  ; both as net ID and for a cluster number for local devices.  In the case  ;
  2608                                  ; of local devices, the cluster number will be -1 if there is a potential  ;
  2609                                  ; of the disk being changed or if the path must be recracked.		   ;
  2610                                  ;
  2611                                  ;	Some pathnames have special preambles, such as
  2612                                  ;
  2613                                  ;		\\machine\sharename\...
  2614                                  ;	For these pathnames we can't allow ".." processing to back us
  2615                                  ;	up into the special front part of the name.  The CURDIR_END field
  2616                                  ;	holds the address of the seperator character which marks
  2617                                  ;	the split between the special preamble and the regular
  2618                                  ;	path list; ".." processing isn't allowed to back us up past
  2619                                  ;	(i.e., before) CURDIR_END
  2620                                  ;	For the root, it points at the leading /.  For net
  2621                                  ;	assignments it points at the end (nul) of the initial assignment:
  2622                                  ;	A:/	\\foo\bar	    \\foo\bar\blech\bozo
  2623                                  ;	  ^		 ^		     ^
  2624                                  
  2625                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
  2626                                  TEMPLEN 	EQU	DIRSTRLEN*2
  2627                                  
  2628                                  struc curdir	; curdir_list
  2629 00000000 <res 43h>               .text:		resb DIRSTRLEN		; text of assignment and curdir
  2630 00000043 ????                    .flags:		resw 1			; various flags
  2631 00000045 ????????                .devptr:	resd 1			; local pointer to DPB or net device
  2632 00000049 ????????                .ID:		resw 2			; cluster of current dir (net ID)
  2633 0000004D ????                    .user_word:	resw 1
  2634 0000004F ????                    .end:		resw 1			; index to ".." backup limit - see above
  2635                                  ; MSDOS 6.0
  2636 00000051 ??                      .type:		resb 1			; IFS drive (2=ifs, 4=netuse)
  2637 00000052 ????????                .ifs_hdr:	resd 1			; Ptr to File System Header
  2638 00000056 ????                    .fsda:		resb 2			; File System Dependent Data Area
  2639                                  .size:
  2640                                  endstruc
  2641                                  
  2642                                  curdirLen	EQU curdir.size	; 88	; Needed for screwed up
  2643                                  
  2644                                  %define curdir_netID curdir_ID  ; dword
  2645                                  
  2646                                  ;**	Flag values for CURDIR_FLAGS
  2647                                  
  2648                                  curdir_isnet	EQU	1000000000000000B
  2649                                  CURDIR_isifs	EQU	1000000000000000B ; MSDOS 6.0	
  2650                                  curdir_inuse	EQU	0100000000000000B
  2651                                  curdir_splice	EQU	0010000000000000B
  2652                                  curdir_local	EQU	0001000000000000B
  2653                                  
  2654                                  ;									   ;
  2655                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2656                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2657                                  
  2658                                  ;============================================================================
  2659                                  ; CPMFCB.INC (MSDOS 3.3, 1987)
  2660                                  ;============================================================================
  2661                                  ; 09/07/2018 - Retro DOS v3.0
  2662                                  
  2663                                  ;BREAK <File Control Block definition>
  2664                                  
  2665                                  ;
  2666                                  ; Field definition for FCBs
  2667                                  ; The FCB has the following structure:
  2668                                  ;
  2669                                  ;	+---------------------------+
  2670                                  ;	|   Drive indicator(byte)   |
  2671                                  ;	+---------------------------+
  2672                                  ;	|    Filename (8 chars)     |
  2673                                  ;	+---------------------------+
  2674                                  ;	|    Extension (3 chars)    |
  2675                                  ;	+---------------------------+
  2676                                  ;	|   Current Extent(word)    |
  2677                                  ;	+---------------------------+
  2678                                  ;	|    Record size (word)     |
  2679                                  ;	+---------------------------+
  2680                                  ;	|    File Size (2 words)    |
  2681                                  ;	+---------------------------+
  2682                                  ;	|	Date of write	    |
  2683                                  ;	+---------------------------+
  2684                                  ;	|	Time of write	    |
  2685                                  ;	+---------------------------+
  2686                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2687                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2688                                  ;									   ;
  2689                                  ;	+---------------------------+
  2690                                  ;	|   8 bytes reserved	    |
  2691                                  ;	+---------------------------+
  2692                                  ;									   ;
  2693                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2694                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2695                                  ;	|    next record number     |
  2696                                  ;	+---------------------------+
  2697                                  ;	|   random record number    |
  2698                                  ;	+---------------------------+
  2699                                  ;
  2700                                  
  2701                                  struc	SYS_FCB
  2702 00000000 ??                      .drive:	resb 1
  2703 00000001 ????????????????        .name:	resb 8
  2704 00000009 ??????                  .ext:	resb 3
  2705 0000000C ????                    .EXTENT: resw 1
  2706 0000000E ????                    .RECSIZ: resw 1			; Size of record (user settable)
  2707 00000010 ????                    .FILSIZ: resw 1			; Size of file in bytes; used with the
  2708                                  				; following word
  2709 00000012 ????                    .DRVBP:	resw 1			; BP for SEARCH FIRST and SEARCH NEXT
  2710 00000014 ????                    .FDATE:	resw 1			; Date of last writing
  2711 00000016 ????                    .FTIME:	resw 1			; Time of last writing
  2712                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2713                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2714                                  ;									   ;
  2715 00000018 ????????????????        .reserved: resb 8		; RESERVED
  2716                                  ;									   ;
  2717                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2718                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2719 00000020 ??                      .NR:	resb 1			; Next record
  2720 00000021 ????????                .RR:	resb 4			; Random record
  2721                                  .size:
  2722                                  endstruc
  2723                                  
  2724                                  FILDIRENT EQU SYS_FCB.FILSIZ	; Used only by SEARCH FIRST and SEARCH
  2725                                  				; NEXT
  2726                                  ; 20/07/2018
  2727                                  %define fcb_sfn	SYS_FCB.reserved ; byte
  2728                                  
  2729                                  ; Note that fcb_net_handle, fcb_nsl_drive, fcb_nsld_drive and fcb_l_drive
  2730                                  ; all must point to the same byte.  Otherwise, the FCBRegen will fail.
  2731                                  ; NOTE about this byte (fcb_nsl_drive)
  2732                                  ;   The high two bits of this byte are used as follows to indicate the FCB type
  2733                                  ;	00 means a local file or device with sharing loaded
  2734                                  ;	10 means a remote (network) file
  2735                                  ;	01 means a local file with no sharing loaded
  2736                                  ;	11 means a local device with no sharing loaded
  2737                                  
  2738                                  ; 20/07/2018
  2739                                  
  2740                                  ;
  2741                                  ; Network FCB
  2742                                  ;
  2743                                  
  2744                                  %define fcb_net_drive	SYS_FCB.reserved+1  ; byte
  2745                                  %define fcb_net_handle	SYS_FCB.reserved+2  ; word
  2746                                  %define fcb_netID	SYS_FCB.reserved+4  ; dword		
  2747                                  
  2748                                  ;
  2749                                  ; No sharing local file FCB
  2750                                  ;
  2751                                  
  2752                                  %define fcb_nsl_drive	SYS_FCB.reserved+1  ; byte
  2753                                  %define fcb_nsl_bits	SYS_FCB.reserved+2  ; byte	
  2754                                  %define fcb_nsl_firclus SYS_FCB.reserved+3  ; word	
  2755                                  %define fcb_nsl_dirsec	SYS_FCB.reserved+5  ; word
  2756                                  %define fcb_nsl_dirpos  SYS_FCB.reserved+7  ; byte
  2757                                  
  2758                                  ;
  2759                                  ; No sharing local device FCB
  2760                                  ;
  2761                                  
  2762                                  %define fcb_nsld_drive	SYS_FCB.reserved+1  ; byte	
  2763                                  %define fcb_nsld_drvptr SYS_FCB.reserved+2  ; dword
  2764                                  
  2765                                  ;
  2766                                  ; Sharing local FCB
  2767                                  ;
  2768                                  
  2769                                  %define fcb_l_drive	SYS_FCB.reserved+1  ; byte
  2770                                  %define fcb_l_firclus	SYS_FCB.reserved+2  ; word
  2771                                  %define fcb_l_mfs	SYS_FCB.reserved+4  ; word
  2772                                  %define fcb_l_attr	SYS_FCB.reserved+6  ; byte
  2773                                  
  2774                                  ;
  2775                                  ; Bogusness:  the four cases are:
  2776                                  ;
  2777                                  ;   local file	    00
  2778                                  ;   local device    40
  2779                                  ;   local sharing   C0
  2780                                  ;   network	    80
  2781                                  ;
  2782                                  ; Since sharing and network collide, we cannot use a test instruction for
  2783                                  ; deciding whether a network or a share check in involved
  2784                                  ;
  2785                                  FCBDEVICE   EQU 040h
  2786                                  FCBNETWORK  EQU 080h
  2787                                  FCBSHARE    EQU 0C0h
  2788                                  
  2789                                  ; FCBSPECIAL must be able to mask off both net and share
  2790                                  FCBSPECIAL  EQU 080h
  2791                                  FCBMASK     EQU 0C0h
  2792                                  
  2793                                  ;============================================================================
  2794                                  ; FASTOPEN.INC, MSDOS 6.0, 1991
  2795                                  ;============================================================================
  2796                                  ; 11/07/2018 - Retro DOS v3.0
  2797                                  ; 25/04/2019 - Retro DOS v4.0
  2798                                  
  2799                                  struc FEI	; FASTOPEN_EXTENDED_INFO
  2800 00000000 ??                      .dirpos:	resb 1
  2801 00000001 ????????                .dirsec:	resd 1 ; MSDOS 6.0
  2802                                  ;.dirsec:	resw 1 ; MSDOS 3.3
  2803 00000005 ????                    .clusnum:	resw 1
  2804 00000007 ????                    .lastent:	resw 1	; for search first ; MSDOS 6.0
  2805 00000009 ????                    .dirstart:	resw 1	; for search first ; MSDOS 6.0
  2806                                  .size:
  2807                                  endstruc
  2808                                  
  2809                                  ; 23/07/2018
  2810                                  ;FASTOPEN NAME CACHING Subfunctions
  2811                                  FONC_Look_up	equ	1
  2812                                  FONC_insert	equ	2
  2813                                  FONC_delete	equ	3
  2814                                  FONC_update	equ	4
  2815                                  FONC_purge	equ	5	;reserved for the future use.
  2816                                  FONC_Rename	equ	6	;AN001
  2817                                  
  2818                                  ; 27/07/2018
  2819                                  ;FastOpen Data Structure
  2820                                  struc fastopen_entry	;Fastopen Entry pointer in DOS
  2821 00000000 ????                    .entry_size:	resw 1	; = 4	; size of the following
  2822 00000002 ????????                .name_caching:	resd 1
  2823                                  ; MSDOS 6.0
  2824                                  ;.fatchain_caching: resd 1	;reserved for future use
  2825                                  .size:
  2826                                  endstruc
  2827                                  
  2828                                  ; 27/07/2018
  2829                                  ;Equates used in DOS.
  2830                                  FastOpen_Set	       equ     00000001b
  2831                                  FastOpen_Reset	       equ     11111110b
  2832                                  Lookup_Success	       equ     00000010b
  2833                                  Lookup_Reset	       equ     11111101b
  2834                                  Special_Fill_Set       equ     00000100b
  2835                                  Special_Fill_Reset     equ     11111011b
  2836                                  No_Lookup	       equ     00001000b
  2837                                  Set_For_Search	       equ     00010000b	;DCR 167
  2838                                  
  2839                                  ; 09/08/2018 
  2840                                  ; (FASTXXXX.INC, MSDOS 6.0, 1991)
  2841                                  ; Fastxxx equates
  2842                                  FastOpen_ID	   equ	   1
  2843                                  FastSeek_ID	   equ	   2
  2844                                  Fast_yes	   equ	   10000000B	 ; fastxxx flag
  2845                                  
  2846                                  ;Structure definitions
  2847                                  ;
  2848                                  struc Fasttable_Entry	 ; Fastxxx  Entry pointer in DOS
  2849 00000000 ????                    .Fast_Entry_Num: resw 1	 ; number of entries
  2850 00000002 ????????                .FastOpen_Seek:	 resd 1	 ; fastopen & fastseek entry address
  2851                                  endstruc
  2852                                  
  2853                                  ;============================================================================
  2854                                  ; LOCK.INC, MSDOS 6.0, 1991
  2855                                  ;============================================================================
  2856                                  ; 14/07/2018 - Retro DOS v3.0
  2857                                  
  2858                                  ;**	LOCK.INC - Definitions for Record Locking
  2859                                  
  2860                                  ;**	LOCK functions
  2861                                  
  2862                                  LOCK_ALL	    equ    0
  2863                                  UNLOCK_ALL	    equ    1
  2864                                  LOCK_MUL_RANGE	    equ    2
  2865                                  UNLOCK_MUL_RANGE    equ    3
  2866                                  LOCK_READ	    equ    4
  2867                                  WRITE_UNLOCK	    equ    5
  2868                                  LOCK_ADD	    equ    6
  2869                                  
  2870                                  ;**	Structure for Lock buffer
  2871                                  
  2872                                  struc LockBuf
  2873 00000000 ????????                .Lock_position:	resd 1		; file position for LOCK
  2874 00000004 ????????                .Lock_length:	resd 1		; number of bytes to LOCK
  2875                                  endstruc
  2876                                  
  2877                                  ;============================================================================
  2878                                  ; DPL.ASM, MSDOS 6.0, 1991
  2879                                  ;============================================================================
  2880                                  ; 04/08/2018 - Retro DOS v3.0
  2881                                  
  2882                                  ; (SRVCALL.ASM)
  2883                                  
  2884                                  struc DPL
  2885 00000000 ????                    .AX:	resw	1	; AX register
  2886 00000002 ????                    .BX:	resw	1	; BX register
  2887 00000004 ????                    .CX:	resw	1	; CX register
  2888 00000006 ????                    .DX:	resw	1	; DX register
  2889 00000008 ????                    .SI:	resw	1	; SI register
  2890 0000000A ????                    .DI:	resw	1	; DI register
  2891 0000000C ????                    .DS:	resw	1	; DS register
  2892 0000000E ????                    .ES:	resw	1	; ES register
  2893 00000010 ????                    .rsrvd: resw	1	; Reserved
  2894 00000012 ????                    .UID:	resw	1	; User (Machine) ID (0 = local macine)
  2895 00000014 ????                    .PID:	resw	1	; Process ID (0 = local user PID)
  2896                                  .size:
  2897                                  endstruc
  2898                                   
  2899                                  ;----------------------------------------------------------------------------
  2900                                  ; DOSDATA
  2901                                  ;----------------------------------------------------------------------------
  2902                                  ;============================================================================
  2903                                  ; 24/04/2019 - Retro DOS v4.0
  2904                                  
  2905                                  DosDataSg equ 3 ; DOS Data Segment address (dw in 'retrodos4.s')
  2906                                  		; ((just after resident IO.SYS code&data))
  2907                                  
  2908                                  ;============================================================================
  2909                                  ; WIN386.INC, MSDOS 6.0, 1991
  2910                                  ;============================================================================
  2911                                  ; 24/04/2019 - Retro DOS 4.0
  2912                                  
  2913                                  ;
  2914                                  ;  Symbols and structures relating to WIN386 support.
  2915                                  ;
  2916                                  ;  Used by files in both the DOS and the BIOS.
  2917                                  ;
  2918                                  ;  Created: 7-13-89 by MRW
  2919                                  ;
  2920                                  
  2921                                  ; WIN386 broadcast int 2fh multiplex number and subfunction numbers
  2922                                  
  2923                                  MultWin386		equ     16h	; Int 2f multiplex number
  2924                                  
  2925                                  Win386_Init		equ	05h	; Win386 initialization
  2926                                  Win386_Exit		equ	06h	; Win386 exit
  2927                                  Win386_Devcall		equ	07h	; Win386 device call out
  2928                                  Win386_InitDone		equ	08h	; Win386 initialization is complete
  2929                                  
  2930                                  ; When Win386_Devcall is broadcast, BX is the Device ID. DOS must 
  2931                                  ; answer call outs from the DOSMGR
  2932                                  
  2933                                  Win386_DOSMGR		equ	15H
  2934                                  
  2935                                  ; The following structures are used to communicate instance data to 
  2936                                  ; Win386 from the DOS and the BIOS. See Win386 API documentation
  2937                                  ; (chapter 3, "Call Out Interfaces") for further description.
  2938                                  
  2939                                  struc Win386_SIS	; Startup Info Structure
  2940 00000000 ????                     .Version:		resb	2	; db 3, 0
  2941 00000002 ????????                 .Next_Dev_Ptr:		resd	1	; pointer to next SIS in list
  2942 00000006 ????????                 .Virt_Dev_File_Ptr:	resd	1
  2943 0000000A ????????                 .Reference_Data:	resd	1
  2944 0000000E ????????                 .Instance_Data_Ptr:	resd	1	; pointer to instance data array
  2945                                  endstruc
  2946                                  
  2947                                  size_of_Win386_SIS equ 18 ; 24/04/2019 - Retro DOS v4.0
  2948                                  
  2949                                  struc Win386_IIS	; Instance Item Structure
  2950 00000000 ????????                .Ptr:			resd	1	; pointer to an instance item
  2951 00000004 ????                    .Size:			resw	1	; size of an instance item
  2952                                  endstruc
  2953                                  
  2954                                  size_of_Win386_IIS equ 6 ; 24/04/2019 - Retro DOS v4.0
  2955                                  
  2956                                  ;Win386 DOSMGR function return values to indicate operation done
  2957                                  
  2958                                  WIN_OP_DONE		equ	0B97Ch	; 
  2959                                  DOSMGR_OP_DONE		equ	0A2ABh	;
  2960                                  
  2961                                  ;M021
  2962                                  ; WInoldap callout multiplex number
  2963                                  
  2964                                  WINOLDAP		equ	46h	;
  2965                                  
  2966                                  ;============================================================================
  2967                                  ;----------------------------------------------------------------------------
  2968                                  ; DOSCODE
  2969                                  ;----------------------------------------------------------------------------
  2970                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  2971                                  
  2972                                  ;============================================================================
  2973                                  ; MSHEAD.ASM (MSDOS 6.0, 1991)
  2974                                  ;============================================================================
  2975                                  ; 16/07/2018 - Retro DOS 3.0
  2976                                  ;----------------------------------------------------------------------------
  2977                                  ; 24/04/2019 - Retro DOS 4.0
  2978                                  
  2979                                  ; MSDOS 6.0
  2980                                  ;----------------------------------------------------------------------------
  2981                                  ; FILE : ORIGIN.INC
  2982                                  ;----------------------------------------------------------------------------
  2983                                  ; This is included in origin.asm and mshead.asm. Contains the equate that
  2984                                  ; is used for ORGing the DOS code.
  2985                                  ;
  2986                                  ; Brief Description of the necessacity of this ORG:
  2987                                  ; -------------------------------------------------
  2988                                  ;
  2989                                  ; A special problem exits when running out of the HMA. The HMA starts at 
  2990                                  ; address FFFF:10. There is no place in the HMA with an offset of zero.
  2991                                  ; This means programs running out off the HMA must use non-zero offset base
  2992                                  ; addresses. It also means that if we're running multiple programs from the
  2993                                  ; HMA, the base offset of each segment must atleast be as big as all of the
  2994                                  ; HMA segments that precede it.
  2995                                  ; 
  2996                                  ; One solution to this problem to ORG each module at 64K minus its size.
  2997                                  ; For instance a code segment 1234h bytes in length would org'd at edcbh.
  2998                                  ; This gives max. flexibility regarding it's location in the HMA. By 
  2999                                  ; selecting segment values between f124h and ffffh it could be located 
  3000                                  ; anywhere in the HMA. The problem with this is that programs with such 
  3001                                  ; high ORGs would not be able to run in low RAM.
  3002                                  ;
  3003                                  ; A compromise solution is to set the ORG address somewhere between 0010h
  3004                                  ; and ffffh - their size. In the particular case of the BIOS and the DOS 
  3005                                  ; the following solution has been implemented:
  3006                                  ;
  3007                                  ; The Bios Code segment will have a very small offset and run at the very
  3008                                  ; front of the HMA, after the VDISK header. THE Dos Code segment will have 
  3009                                  ; a base offset of (700+<min. size off RAM based BIOS>+<min. size of the DOS
  3010                                  ; DATA segment when DOS is running low>). This will reflect the lowest 
  3011                                  ; possible physical address at which DOS code will run, while still providing
  3012                                  ; max. possible flexibility in HMA positioning. This offset MUST NOT be 
  3013                                  ; smaller then that 20+size of Bios Code segment when running high. This is 
  3014                                  ; mostly true.
  3015                                  ;
  3016                                  ; Also this ORG'd value must be communicated to the BIOS. This is done by
  3017                                  ; putting this value after the first jmp instruction in the DOS code in
  3018                                  ; mshead.asm. 
  3019                                  ;
  3020                                  ; In order for the stripz utility to know how many zeroes to be stripped 
  3021                                  ; out, this value is placed at the beginning of the binary in origin.asm.
  3022                                  ;
  3023                                  ; Revision History:
  3024                                  ;
  3025                                  ; Currently this is being done manually. Therefore any change in the DOS DATA
  3026                                  ; Size or the BIOS size should be reflected here. --- Feb 90
  3027                                  ;
  3028                                  ; BDSIZE.INC contains the equates for BIODATASIZE, BIOCODESIZ and DOSDATASIZ.
  3029                                  ; A utility called getsize will obtain the corresponding values from msdos
  3030                                  ; and msbio.map and update the values in BDSIZ.INC if they are different. 
  3031                                  ; DOS should now be built using the batch file makedos.bat which invokes this
  3032                                  ; utility. The FORMAT of BDSIZE.INC should not be changed as getsize is 
  3033                                  ; dependant on that.				  --- Apr 3 '90
  3034                                  ;
  3035                                  ; For ROMDOS, however, there is no need to org the doscode to any location
  3036                                  ; other than zero.  Therefore the stripz utility will not need to be used,
  3037                                  ; so the offset will not need to be included at the beginning of the code
  3038                                  ; segment.  Also, the BIOS can just assume that the resident code begins
  3039                                  ; at offset zero within the segment.
  3040                                  ; 
  3041                                  ;
  3042                                  ;--------------------------------------------------------------------------
  3043                                  
  3044                                  BIODATASTART	EQU	00700h
  3045                                  ;include	bdsize.inc	; this sets the values:
  3046                                  				;	BIODATASIZ
  3047                                  				;	BIOCODESIZ
  3048                                  				;	DOSDATASIZ
  3049                                  
  3050                                  ; 05/12/2022
  3051                                  ;BIODATASIZ EQU 00910H	; 0900h for MSDOS 6.21 IO.SYS
  3052                                  			; 0900h for MSDOS 5.0 IO.SYS
  3053                                  ;BIOCODESIZ EQU 01A70H	; 1A70h for MSDOS 6.21 IO.SYS
  3054                                  			; 1A60h for MSDOS 5.0 IO.SYS
  3055                                  ;DOSDATASIZ EQU 01370H	; 1370h for MSDOS 6.21 IO.SYS
  3056                                  			; 1370h for MSDOS 5.0 IO.SYS
  3057                                  ;ifndef ROMDOS
  3058                                  ;
  3059                                  ;BYTSTART	EQU    	BIODATASTART+BIODATASIZ+BIOCODESIZ+DOSDATASIZ
  3060                                  ;PARASTART	EQU	(BYTSTART + 0FH) AND (NOT 0FH)	
  3061                                  ;
  3062                                  ;else
  3063                                  ;
  3064                                  ;BYTSTART	EQU	0
  3065                                  ;PARASTART	EQU	0
  3066                                  ;
  3067                                  ;endif ; ROMDOS
  3068                                  
  3069                                  ; 24/04/2019 - Retro DOS v4.0 - Modification
  3070                                  ; -----------------------------------------------------------------
  3071                                  ;MSDAT001E equ 136Ah ; 4970 ; for MSDOS 6.21	
  3072                                  ;MSDAT001E equ 1370h ; 4976 ; for Retro DOS v4.0 modif. 25/05/2019	
  3073                                  ;DOSDATASIZE equ MSDAT001E
  3074                                  ; 05/12/2022
  3075                                  ;DOSDATASIZE equ $ ; 29/04/2019 ; -only- for RETRO DOS v4.0 :
  3076                                  ;_PARASTART_ equ DOSDATASIZE ; segment value will point to start of
  3077                                  			    ; of DOSDATA (in low memory) while
  3078                                  			    ; dos/kernel code starts just after 
  3079                                  			    ; this data block ((org = DOSDATASIZE))
  3080                                  			    ; (in low memory or in HMA)	
  3081                                  ; -----------------------------------------------------------------
  3082                                  
  3083                                  ; 04/11/2022	
  3084                                  ; -----------------------------------------------------------------	
  3085                                  ; NOTE:
  3086                                  ; Microsoft dos programmers were calling 'IO.SYS' as dos 'BIOS'
  3087                                  ; (Also, they were calling 'ROMBIOS' as 'ROM' only!)
  3088                                  ; -----------------------------------------------------------------
  3089                                  
  3090                                  ; ----------------------------------------------------------------------------
  3091                                  ; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3092                                  ; ----------------------------------------------------------------------------
  3093                                  
  3094                                  ;segment .code vstart=3DD0h ; 06/12/2022
  3095                                  ; 29/09/2023
  3096                                  segment .code vstart=3DE0h ; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22)
  3097                                  								
  3098                                  ; ============================================================================
  3099                                  
  3100                                  
  3101                                  ;[ORG 3DE0h]
  3102                                  
  3103                                  ;[ORG _PARASTART_]     ; [org 136Ah]
  3104                                  
  3105                                  ;[ORG 1370h] ; 25/05/2019 - Retro DOS v4.0
  3106                                  
  3107                                  	; 05/12/2022 - RetroDOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3108                                  	;PARASTART equ 3DD0h ; BIOSDATASTART+BIOSDATASIZE
  3109                                  			     ; +BIOSCODESIZE+DOSDATASIZE (rounded up)
  3110                                  	
  3111                                  	; 29/09/2023 
  3112                                  	; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
  3113                                  	PARASTART equ 3DE0h	; (MSDOS 6.22 MSDOS.SYS)
  3114                                  
  3115                                  	[ORG PARASTART]	
  3116                                  
  3117                                  _$STARTCODE:
  3118                                  
  3119                                  ;PARASTART:
  3120 00000000 E9DE76                          JMP     DOSINIT
  3121                                  
  3122                                  	;dw	PARASTART	; PARASTART = 3DE0h for MSDOS 6.0, 6.22
  3123                                  	; 04/11/2022
  3124 00000003 [0000]                  	dw	_$STARTCODE	; PARASTART = 3DD0h for MSDOS 5.0
  3125                                  
  3126                                  BioDataSeg:
  3127 00000005 7000                    	dw	0070h		; Bios data segment fixed at 70h
  3128                                  
  3129                                  ; DosDSeg is a data word in the DOSCODE segment that is loaded with
  3130                                  ; the segment address of DOSDATA. This is purely an optimization, that
  3131                                  ; allows getting the DOS data segment without going through the 
  3132                                  ; BIOS data segment. It is used by the "getdseg" macro.
  3133                                  
  3134                                  DosDSeg:
  3135 00000007 0000                    	dw	0
  3136                                  	
  3137                                  ;============================================================================
  3138                                  ; MSTABLE.ASM (MSDOS 6.0, 1991)
  3139                                  ;============================================================================
  3140                                  ; 16/07/2018 - Retro DOS 3.0
  3141                                  ; 29/04/2019 - Retro DOS 4.0
  3142                                  
  3143                                  	; (MSDOS version)
  3144                                  	; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
  3145                                  	;db	6
  3146                                  	;db	20
  3147                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 
  3148                                  	; DOSCODE:3DD9h (MSDOS 5.0, MSDOS.SYS)
  3149                                  	;db	5
  3150                                  	;db	0	
  3151                                  
  3152                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
  3153                                  MSVERS:				; MS-DOS version in hex for $GET_VERSION
  3154 00000009 06                      MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  3155 0000000A 16                      MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  3156                                  
  3157                                  ;;hkn YRTAB & MONTAB moved to DOSDATA in ms_data.asm
  3158                                  ;	I_am	YRTAB,8,<200,166,200,165,200,165,200,165>   ; [SYSTEM]
  3159                                  ;	I_am	MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> ; [SYSTEM]
  3160                                  
  3161                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
  3162                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
  3163                                  ;
  3164                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
  3165                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 
  3166                                  
  3167                                  ; This is the error code mapping table for INT 21 errors. This table defines
  3168                                  ; those error codes which are "allowed" for each system call. If the error
  3169                                  ; code ABOUT to be returned is not "allowed" for the call, the correct action
  3170                                  ; is to return the "real" error via Extended error, and one of the allowed
  3171                                  ; errors on the actual call.
  3172                                  ;
  3173                                  ; The table is organized as follows:
  3174                                  ;
  3175                                  ;    Each entry in the table is of variable size, but the first
  3176                                  ;       two bytes are always:
  3177                                  ;
  3178                                  ;       Call#,Cnt of bytes following this byte
  3179                                  ;
  3180                                  ; EXAMPLE:
  3181                                  ;       Call 61 (OPEN)
  3182                                  ;
  3183                                  ;       DB      61,5,12,3,2,4,5
  3184                                  ;
  3185                                  ;       61 is the AH INT 21 call value for OPEN.
  3186                                  ;        5 indicates that there are 5 bytes after this byte (12,3,2,4,5).
  3187                                  ;       Next five bytes are those error codes which are "allowed" on OPEN.
  3188                                  ;       The order of these values is not important EXCEPT FOR THE LAST ONE (in
  3189                                  ;       this case 5).  The last value will be the one returned on the call if
  3190                                  ;       the "real" error is not one of the allowed ones.
  3191                                  ;
  3192                                  ; There are a number of calls (for instance all of the FCB calls) for which
  3193                                  ;   there is NO entry.  This means that NO error codes are returned on this
  3194                                  ;   call, so set up an Extended error and leave the current error code alone.
  3195                                  ;
  3196                                  ; The table is terminated by a call value of 0FFh
  3197                                  
  3198                                  ;PUBLIC I21_MAP_E_TAB
  3199                                  	; 10/08/2018
  3200                                  
  3201                                  ; 29/04/2019
  3202                                  ; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
  3203                                  ; 04/11/2022
  3204                                  ; DOSCODE:3DDBh	(MSDOS 5.0 MSDOS.SYS)
  3205                                  
  3206                                  I21_MAP_E_TAB:	; LABEL	BYTE
  3207 0000000B 38020102                    DB  INTERNATIONAL,2,error_invalid_function,error_file_not_found
  3208 0000000F 3903030205                  DB  MKDIR,3,error_path_not_found,error_file_not_found,error_access_denied
  3209 00000014 3A041003                    DB  RMDIR,4,error_current_directory,error_path_not_found
  3210 00000018 0205                        DB          error_file_not_found,error_access_denied
  3211 0000001A 3B020203                    DB  CHDIR,2,error_file_not_found,error_path_not_found
  3212 0000001E 3C040302                    DB  CREAT,4,error_path_not_found,error_file_not_found
  3213 00000022 04                          DB          error_too_many_open_files
  3214 00000023 05                          DB          error_access_denied
  3215                                      ; MSDOS 6.0
  3216 00000024 3D0603020C                  DB	OPEN,6,error_path_not_found,error_file_not_found,error_invalid_access
  3217 00000029 04                          DB          error_too_many_open_files
  3218 0000002A 1A05                        DB          error_not_DOS_disk,error_access_denied
  3219                                      ; MSDOS 3.3
  3220                                      ;DB	OPEN,5,error_path_not_found,error_file_not_found,error_invalid_access
  3221                                      ;DB		error_too_many_open_files,error_access_denied
  3222 0000002C 3E0106                      DB  CLOSE,1,error_invalid_handle
  3223 0000002F 3F020605                    DB  READ,2,error_invalid_handle,error_access_denied
  3224 00000033 40020605                    DB  WRITE,2,error_invalid_handle,error_access_denied
  3225 00000037 4103030205                  DB  UNLINK,3,error_path_not_found,error_file_not_found,error_access_denied
  3226 0000003C 42020601                    DB  LSEEK,2,error_invalid_handle,error_invalid_function
  3227 00000040 4304030201                  DB  CHMOD,4,error_path_not_found,error_file_not_found,error_invalid_function
  3228 00000045 05                          DB          error_access_denied
  3229 00000046 44050F0D01                  DB  IOCTL,5,error_invalid_drive,error_invalid_data,error_invalid_function
  3230 0000004B 0605                        DB          error_invalid_handle,error_access_denied
  3231 0000004D 45020604                    DB  XDUP,2,error_invalid_handle,error_too_many_open_files
  3232 00000051 46020604                    DB  XDUP2,2,error_invalid_handle,error_too_many_open_files
  3233                                      ; MSDOS 6.0	
  3234 00000055 47021A0F                    DB  CURRENT_DIR,2,error_not_DOS_disk,error_invalid_drive
  3235                                      ; MSDOS 3.3	
  3236                                      ;DB  CURRENT_DIR,1,error_invalid_drive
  3237 00000059 48020708                    DB  ALLOC,2,error_arena_trashed,error_not_enough_memory
  3238 0000005D 49020709                    DB  DEALLOC,2,error_arena_trashed,error_invalid_block
  3239 00000061 4A03070908                  DB  SETBLOCK,3,error_arena_trashed,error_invalid_block,error_not_enough_memory
  3240 00000066 4B08030102                  DB  EXEC,8,error_path_not_found,error_invalid_function,error_file_not_found
  3241 0000006B 040B0A                      DB          error_too_many_open_files,error_bad_format,error_bad_environment
  3242 0000006E 0805                        DB          error_not_enough_memory,error_access_denied
  3243 00000070 4E03030212                  DB  FIND_FIRST,3,error_path_not_found,error_file_not_found,error_no_more_files
  3244 00000075 4F0112                      DB  FIND_NEXT,1,error_no_more_files
  3245                                      ; MSDOS 6.0
  3246 00000078 5605110302                  DB  RENAME,5,error_not_same_device,error_path_not_found,error_file_not_found
  3247 0000007D 1005                        DB		error_current_directory,error_access_denied
  3248                                      ; MSDOS 3.3
  3249                                      ;DB  RENAME,4,error_not_same_device,error_path_not_found,error_file_not_found
  3250                                      ;DB		error_access_denied
  3251                                      ; MSDOS 6.0	
  3252 0000007F 57040608                    DB  FILE_TIMES,4,error_invalid_handle,error_not_enough_memory
  3253 00000083 0D01                        DB		error_invalid_data,error_invalid_function
  3254                                      ; MSDOS 3.3	
  3255                                      ;DB  FILE_TIMES,2,error_invalid_handle,error_invalid_function
  3256 00000085 580101                      DB  ALLOCOPER,1,error_invalid_function
  3257 00000088 5A040302                    DB  CREATETEMPFILE,4,error_path_not_found,error_file_not_found
  3258 0000008C 0405                        DB          error_too_many_open_files,error_access_denied
  3259 0000008E 5B055003                    DB  CREATENEWFILE,5,error_file_exists,error_path_not_found
  3260 00000092 020405                      DB          error_file_not_found,error_too_many_open_files,error_access_denied
  3261 00000095 5C040601                    DB  LOCKOPER,4,error_invalid_handle,error_invalid_function
  3262 00000099 2421                        DB          error_sharing_buffer_exceeded,error_lock_violation
  3263 0000009B 65020102                    DB  GETEXTCNTRY,2,error_invalid_function,error_file_not_found	;DOS 3.3
  3264 0000009F 66020102                    DB  GETSETCDPG,2,error_invalid_function,error_file_not_found        ;DOS 3.3
  3265 000000A3 680106                      DB  COMMIT,1,error_invalid_handle                                   ;DOS 3.3
  3266 000000A6 67030408                    DB  EXTHANDLE,3,error_too_many_open_files,error_not_enough_memory
  3267 000000AA 01                          DB              error_invalid_function
  3268                                      ; MSDOS 6.0		
  3269 000000AB 6C0A                        DB	ExtOpen,10
  3270 000000AD 03020C                      DB	  error_path_not_found,error_file_not_found,error_invalid_access
  3271 000000B0 045008                      DB		error_too_many_open_files,error_file_exists,error_not_enough_memory
  3272 000000B3 1A0D                        DB		error_not_DOS_disk,error_invalid_data
  3273 000000B5 0105                        DB		error_invalid_function,error_access_denied
  3274 000000B7 69040F0D                    DB	GetSetMediaID,4,error_invalid_drive,error_invalid_data
  3275 000000BB 0105                        DB		error_invalid_function,error_access_denied
  3276 000000BD FF                          DB  0FFh
  3277                                  
  3278                                  ;19/09/2023
  3279                                  ;22/12/2022
  3280                                  ;04/11/2022	
  3281                                  ;29/04/2019 - Retro DOS v4.0
  3282                                  ;============================================================================
  3283                                  ; 	Retro DOS v4.0
  3284                                  ;============================================================================
  3285 000000BE 00                      	db 	0
  3286                                  RETRODOSMSG:
  3287 000000BF 0D0A                    	db	13,10
  3288                                  	;;;;;db	"Retro DOS v4.0 by Erdogan Tan [2019]"
  3289                                  	;;;;db	"Retro DOS v4.0 by Erdogan Tan [2022]"
  3290                                  	;;;db	"Retro DOS v4.1 by Erdogan Tan [2022]"	; 28/12/2022
  3291                                  	;;db	"Retro DOS v4.2 by Erdogan Tan [2022]"	; 30/12/2022
  3292                                  	;db	"Retro DOS v4.2 by Erdogan Tan [2023]"
  3293 000000C1 526574726F20444F53-     	db	"Retro DOS v4.2 by Erdogan Tan [2024]"	; 05/01/2024
  3293 000000CA 2076342E3220627920-
  3293 000000D3 4572646F67616E2054-
  3293 000000DC 616E205B323032345D 
  3294 000000E5 0D0A2400                	db	13,10,"$", 0 
  3295                                  
  3296                                  ;============================================================================
  3297                                  ; MSTABLE.ASM, MSDOS 6.0, 1991
  3298                                  ;============================================================================
  3299                                  ; 11/07/2018 - Retro DOS v3.0
  3300                                  
  3301                                  	%define short_addr dw  ; 03/03/2018 - Retro DOS v2.0
  3302 000000E9 90                      align 2
  3303                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0E00h
  3304                                  
  3305                                  ; Standard Functions
  3306                                  ;DISPATCH  LABEL WORD
  3307                                  DISPATCH:
  3308                                  	; 16/07/2018 - Retro DOS v3.0
  3309                                  	; (MSDOS 3.3)
  3310                                  
  3311                                  ; 29/04/2019
  3312                                  ; DOSCODE:3E9Eh (MSDOS 6.21, MSDOS.SYS)
  3313                                  
  3314                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3315                                  ; DOSCODE:3E8Eh (MSDOS 5.0, MSDOS.SYS)
  3316                                  
  3317 000000EA [1262]                          short_addr  _$ABORT			    ;  0      0
  3318 000000EC [6216]                          short_addr  _$STD_CON_INPUT		    ;  1      1
  3319 000000EE [6B16]                          short_addr  _$STD_CON_OUTPUT		    ;  2      2
  3320 000000F0 [1D17]                          short_addr  _$STD_AUX_INPUT		    ;  3      3
  3321 000000F2 [3817]                          short_addr  _$STD_AUX_OUTPUT		    ;  4      4
  3322 000000F4 [3E17]                          short_addr  _$STD_PRINTER_OUTPUT	    ;  5      5
  3323 000000F6 [AA15]                          short_addr  _$RAW_CON_IO		    ;  6      6
  3324 000000F8 [D615]                          short_addr  _$RAW_CON_INPUT		    ;  7      7
  3325 000000FA [7B13]                          short_addr  _$STD_CON_INPUT_NO_ECHO	    ;  8      8
  3326 000000FC [D413]                          short_addr  _$STD_CON_STRING_OUTPUT	    ;  9      9
  3327 000000FE [E013]                          short_addr  _$STD_CON_STRING_INPUT	    ; 10      A
  3328 00000100 [5217]                          short_addr  _$STD_CON_INPUT_STATUS	    ; 11      B
  3329 00000102 [5C17]                          short_addr  _$STD_CON_INPUT_FLUSH	    ; 12      C
  3330 00000104 [9E0F]                          short_addr  _$DISK_RESET		    ; 13      D
  3331 00000106 [820E]                          short_addr  _$SET_DEFAULT_DRIVE		    ; 14      E
  3332 00000108 [381E]                          short_addr  _$FCB_OPEN			    ; 15      F
  3333 0000010A [0218]                          short_addr  _$FCB_CLOSE			    ; 16     10
  3334 0000010C [4A1F]                          short_addr  _$DIR_SEARCH_FIRST		    ; 17     11
  3335 0000010E [DC1F]                          short_addr  _$DIR_SEARCH_NEXT		    ; 18     12
  3336 00000110 [A117]                          short_addr  _$FCB_DELETE		    ; 19     13
  3337 00000112 [361F]                          short_addr  _$FCB_SEQ_READ		    ; 20     14
  3338 00000114 [3B1F]                          short_addr  _$FCB_SEQ_WRITE	            ; 21     15
  3339 00000116 [1C1F]                          short_addr  _$FCB_CREATE		    ; 22     16
  3340 00000118 [7218]                          short_addr  _$FCB_RENAME		    ; 23     17
  3341                                  	; 16/07/2018
  3342                                          ;short_addr _CPMFUNC			    ; 24     18	
  3343 0000011A [5306]                          short_addr  NO_OP			    ; 24     18
  3344 0000011C [7D0E]                          short_addr  _$GET_DEFAULT_DRIVE		    ; 25     19
  3345 0000011E [720E]                          short_addr  _$SET_DMA			    ; 26     1A
  3346                                  
  3347                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3348                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3349                                  ;                                                                          ;
  3350 00000120 [2A0F]                          short_addr  _$SLEAZEFUNC		    ; 27     1B
  3351 00000122 [2C0F]                          short_addr  _$SLEAZEFUNCDL		    ; 28     1C
  3352                                  ;                                                                          ;
  3353                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3354                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3355                                  
  3356                                          ;short_addr  _CPMFUNC			    ; 29     1D
  3357                                          ;short_addr  _CPMFUNC			    ; 30     1E
  3358                                  
  3359                                  ; 08/07/2018 - Retro DOS v3.0
  3360                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3361                                  
  3362 00000124 [5306]                  	short_addr  NO_OP			    ; 29     1D
  3363 00000126 [5306]                  	short_addr  NO_OP			    ; 30     1E
  3364                                  
  3365                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3366                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3367                                  ;                                                                          ;
  3368 00000128 [6E0F]                          short_addr  _$GET_DEFAULT_DPB               ; 31     1F
  3369                                  ;                                                                          ;
  3370                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3371                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3372                                          ;short_addr _CPMFUNC			    ; 32     20
  3373                                  
  3374                                  ; 08/07/2018 - Retro DOS v3.0
  3375                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3376                                  
  3377 0000012A [5306]                  	short_addr  NO_OP			    ; 32     20
  3378                                  
  3379 0000012C [401F]                          short_addr  _$FCB_RANDOM_READ               ; 33     21
  3380 0000012E [451F]                          short_addr  _$FCB_RANDOM_WRITE              ; 34     22
  3381 00000130 [B317]                          short_addr  _$GET_FCB_FILE_LENGTH	    ; 35     23
  3382 00000132 [8917]                          short_addr  _$GET_FCB_POSITION		    ; 36     24
  3383                                  
  3384                                  ;MAXCALL = ($-DISPATCH)/2 - 1
  3385                                  MAXCALL EQU ($-DISPATCH)/2 - 1
  3386                                  
  3387                                  ; Extended Functions
  3388 00000134 [A30E]                          short_addr  _$SET_INTERRUPT_VECTOR	    ; 37     25
  3389                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3390                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3391                                  ;                                                                          ;
  3392 00000136 [AA10]                          short_addr  _$CREATE_PROCESS_DATA_BLOCK	    ; 38     26
  3393                                  ;                                                                          ;
  3394                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3395                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3396 00000138 [311F]                          short_addr  _$FCB_RANDOM_READ_BLOCK	    ; 39     27
  3397 0000013A [2C1F]                          short_addr  _$FCB_RANDOM_WRITE_BLOCK        ; 40     28
  3398 0000013C [1F0F]                          short_addr  _$PARSE_FILE_DESCRIPTOR	    ; 41     29
  3399 0000013E [5E0A]                          short_addr  _$GET_DATE                      ; 42     2A
  3400 00000140 [7B0A]                          short_addr  _$SET_DATE                      ; 43     2B
  3401 00000142 [9A0A]                          short_addr  _$GET_TIME                      ; 44     2C
  3402 00000144 [AB0A]                          short_addr  _$SET_TIME                      ; 45     2D
  3403 00000146 [630C]                          short_addr  _$SET_VERIFY_ON_WRITE           ; 46     2E
  3404                                  
  3405                                  ; Extended functionality group
  3406 00000148 [5F0E]                          short_addr  _$GET_DMA                       ; 47     2F
  3407 0000014A [3A0C]                          short_addr  _$GET_VERSION                   ; 48     30
  3408 0000014C [B661]                          short_addr  _$KEEP_PROCESS		    ; 49     31
  3409                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3410                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3411                                  ;                                                                          ;
  3412 0000014E [700F]                          short_addr  _$GET_DPB			    ; 50     32
  3413                                  ;                                                                          ;
  3414                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3415                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3416 00000150 [6702]                          short_addr  _$SET_CTRL_C_TRAPPING           ; 51     33
  3417 00000152 [560F]                          short_addr  _$GET_INDOS_FLAG                ; 52     34
  3418 00000154 [940E]                          short_addr  _$GET_INTERRUPT_VECTOR          ; 53     35
  3419 00000156 [3C0E]                          short_addr  _$GET_DRIVE_FREESPACE           ; 54     36
  3420 00000158 [D00E]                          short_addr  _$CHAR_OPER                     ; 55     37
  3421 0000015A [6A0C]                          short_addr  _$INTERNATIONAL                 ; 56     38
  3422                                  ; XENIX CALLS
  3423                                  ;   Directory Group
  3424 0000015C [3622]                          short_addr  _$MKDIR			    ; 57     39
  3425 0000015E [8221]                          short_addr  _$RMDIR			    ; 58     3A
  3426 00000160 [BD21]                          short_addr  _$CHDIR			    ; 59     3B
  3427                                  ;   File Group
  3428 00000162 [D46F]                          short_addr  _$CREAT			    ; 60     3C
  3429 00000164 [FD6E]                          short_addr  _$OPEN			    ; 61     3D
  3430 00000166 [2E67]                          short_addr  _$CLOSE		 	    ; 62     3E
  3431 00000168 [3F68]                          short_addr  _$READ			    ; 63     3F
  3432 0000016A [A568]                          short_addr  _$WRITE			    ; 64     40
  3433 0000016C [2470]                          short_addr  _$UNLINK			    ; 65     41
  3434 0000016E [AA68]                          short_addr  _$LSEEK			    ; 66     42
  3435 00000170 [E16F]                          short_addr  _$CHMOD			    ; 67     43
  3436 00000172 [9722]                          short_addr  _$IOCTL			    ; 68     44
  3437 00000174 [5F69]                          short_addr  _$DUP			    ; 69     45
  3438 00000176 [7D69]                          short_addr  _$DUP2			    ; 70     46
  3439 00000178 [1321]                          short_addr  _$CURRENT_DIR		    ; 71     47
  3440                                  ;   Memory Group
  3441 0000017A [A962]                          short_addr  _$ALLOC			    ; 72     48
  3442 0000017C [2364]                          short_addr  _$DEALLOC                       ; 73     49
  3443 0000017E [FF63]                          short_addr  _$SETBLOCK                      ; 74     4A
  3444                                  ;   Process Group
  3445 00000180 [905B]                          short_addr  _$EXEC			    ; 75     4B
  3446 00000182 [EE61]                          short_addr  _$EXIT			    ; 76     4C
  3447 00000184 [865B]                          short_addr  _$WAIT			    ; 77     4D
  3448 00000186 [4F20]                          short_addr  _$FIND_FIRST		    ; 78     4E
  3449                                  ;   Special Group
  3450 00000188 [A520]                          short_addr  _$FIND_NEXT			    ; 79     4F
  3451                                  ; SPECIAL SYSTEM GROUP
  3452                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3453                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3454                                  ;                                                                          ;
  3455 0000018A [B902]                          short_addr  _$SET_CURRENT_PDB		    ; 80     50
  3456 0000018C [C502]                          short_addr  _$GET_CURRENT_PDB               ; 81     51
  3457 0000018E [620F]                          short_addr  _$GET_IN_VARS                   ; 82     52
  3458 00000190 [D30F]                          short_addr  _$SETDPB			    ; 83     53
  3459                                  ;                                                                          ;
  3460                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3461                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3462 00000192 [5E0C]                          short_addr  _$GET_VERIFY_ON_WRITE	    ; 84     54
  3463                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3464                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3465                                  ;                                                                          ;
  3466 00000194 [9910]                          short_addr  _$DUP_PDB                       ; 85     55
  3467                                  ;                                                                          ;
  3468                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3469                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3470 00000196 [4A70]                          short_addr  _$RENAME			    ; 86     56
  3471 00000198 [1169]                          short_addr  _$FILE_TIMES                    ; 87     57
  3472 0000019A [5864]                          short_addr  _$ALLOCOPER                     ; 88     58
  3473                                  
  3474                                  ; 08/07/2018 - Retro DOS v3.0
  3475                                  ; -------------------------------------------------------------------------;
  3476                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3477                                  
  3478                                  ; Network extention system calls
  3479 0000019C [E40E]                          short_addr  _$GetExtendedError              ; 89     59
  3480 0000019E [D570]                          short_addr  _$CreateTempFile                ; 90     5A
  3481 000001A0 [BD70]                          short_addr  _$CreateNewFile                 ; 91     5B
  3482 000001A2 [B672]                          short_addr  _$LockOper                      ; 92     5C
  3483 000001A4 [3E65]                          short_addr  _$ServerCall                    ; 93     5D
  3484 000001A6 [476A]                          short_addr  _$UserOper                      ; 94     5E
  3485 000001A8 [AC69]                          short_addr  _$AssignOper                    ; 95     5F
  3486 000001AA [986E]                          short_addr  _$NameTrans                     ; 96     60
  3487 000001AC [5306]                  	short_addr  NO_OP			    ; 97     61
  3488 000001AE [C502]                          short_addr  _$GET_CURRENT_PDB		    ; 98     62
  3489                                  ; the next call is reserved for hangool sys call
  3490                                  	; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
  3491 000001B0 [040F]                  	short_addr  _$ECS_Call			    ; 99     63
  3492                                  	;short_addr  NO_OP  ;  MSDOS 3.3	    ; 99     63
  3493                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3494                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3495                                  ;                                                                          ;
  3496 000001B2 [D102]                          short_addr  _$SET_PRINTER_FLAG              ; 100    64
  3497                                  ;                                                                          ;
  3498                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3499                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3500 000001B4 [ED0C]                          short_addr  _$GetExtCntry                   ; 101    65
  3501 000001B6 [EA0D]                          short_addr  _$GetSetCdPg                    ; 102    66
  3502 000001B8 [7B67]                          short_addr  _$ExtHandle                     ; 103    67
  3503 000001BA [6167]                          short_addr  _$COMMIT                        ; 104    68
  3504                                  
  3505                                  ; 08/07/2018
  3506                                  ; Above system calls are valid for Retro DOS v3.0 (MSDOS 3.3) 
  3507                                  ; Following system calls are valid for Retro DOS v4.0 (MSDOS 6.0)
  3508                                  
  3509                                  ; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
  3510 000001BC [9C11]                  	short_addr  _$GSetMediaID                   ; 105    69   ;AN000;
  3511 000001BE [6167]                  	short_addr  _$COMMIT                        ; 106    6A   ;AN000;
  3512 000001C0 [5306]                  	short_addr  NO_OP                           ; 107    6B   
  3513                                  						    ; IFS_IOCTL no longer 
  3514                                  						    ; supported
  3515 000001C2 [6B71]                  	short_addr  _$Extended_Open                 ; 108    6C   ;AN000;
  3516                                  
  3517                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3518                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3519                                  ;                                                                          ;
  3520                                  ;ifdef ROMEXEC
  3521                                  ;       short_addr  $ROM_FIND_FIRST	   	    ; 109    6D
  3522                                  ;       short_addr  $ROM_FIND_NEXT	   	    ; 110    6E
  3523                                  ;	short_addr  $ROM_EXCLUDE		    ; 111    6F	  ; M078
  3524                                  ;endif
  3525                                  ;                                                                          ;
  3526                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3527                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3528                                  
  3529                                  ;MAXCOM  = ($-DISPATCH)/2 - 1
  3530                                  
  3531                                  MAXCOM  EQU ($-DISPATCH)/2 - 1
  3532                                  
  3533                                  ; 08/07/2018 - Retro DOS v3.0
  3534                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3535                                  
  3536                                  ;	If 	Installed
  3537                                  
  3538                                  align 2
  3539                                  
  3540                                  ;PUBLIC FOO
  3541                                  
  3542                                  FOO:	; LABEL WORD
  3543 000001C4 [1007]                          short_addr  Leave2F
  3544                                  
  3545 000001C6 [C801]                  DTab:	DW  DOSTable
  3546                                  
  3547                                  	;PUBLIC FOO,DTAB
  3548                                  
  3549                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0ED6h
  3550                                  
  3551                                  ; 29/04/2019
  3552                                  ; DOSCODE:3F7Ch (MSDOS 6.21, MSDOS.SYS)
  3553                                  
  3554                                  
  3555                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3556                                  ; DOSCODE:3F6Ch (MSDOS 5.0, MSDOS.SYS)
  3557                                         
  3558                                  DOSTable:  ; LABEL  WORD
  3559 000001C8 30                              DB      (DOSTableEnd-DOSTable-1)/2 ; db  48
  3560 000001C9 [3509]                          short_addr  DOSInstall          ;   0 install check
  3561 000001CB [542F]                          short_addr  DOS_CLOSE           ;   1   DOS_CLOSE
  3562 000001CD [C50E]                          short_addr  RECSET              ;   2   RECSET
  3563 000001CF [2F09]                          short_addr  DosGetGroup         ;   3   Get DOSGROUP
  3564 000001D1 [BB50]                          short_addr  PATHCHRCMP          ;   4   PATHCHRCMP
  3565 000001D3 [6D16]                          short_addr  OUTT                ;   5   OUT
  3566 000001D5 [9153]                          short_addr  NET_I24_ENTRY       ;   6   NET_I24_ENTRY
  3567 000001D7 [1059]                          short_addr  PLACEBUF            ;   7   PLACEBUF
  3568 000001D9 [5230]                          short_addr  FREE_SFT            ;   8   FREE_SFT
  3569 000001DB [D55A]                          short_addr  BUFWRITE            ;   9   BUFWRITE
  3570 000001DD [6A73]                          short_addr  SHARE_VIOLATION     ;   10  SHARE_VIOLATION
  3571 000001DF [9D2C]                          short_addr  SHARE_ERROR         ;   11  SHARE_ERROR
  3572 000001E1 [872C]                          short_addr  SET_SFT_MODE        ;   12  SET_SFT_MODE
  3573 000001E3 [F00A]                          short_addr  DATE16              ;   13  DATE16
  3574 000001E5 [0812]                          short_addr  Idle		;   14      empty slot
  3575 000001E7 [0959]                          short_addr  SCANPLACE           ;   15  SCANPLACE
  3576 000001E9 [0812]                          short_addr  Idle		;   16      empty slot
  3577 000001EB [D511]                          short_addr  StrCpy              ;   17  StrCpy
  3578 000001ED [ED11]                          short_addr  StrLen              ;   18  StrLen
  3579 000001EF [6650]                          short_addr  UCase		;   19  UCase
  3580 000001F1 [4D59]                          short_addr  POINTCOMP           ;   20  POINTCOMP
  3581 000001F3 [AC5A]                          short_addr  CHECKFLUSH          ;   21  CHECKFLUSH
  3582 000001F5 [A966]                          short_addr  SFFromSFN           ;   22  SFFromSFN
  3583 000001F7 [0C6B]                          short_addr  GetCDSFromDrv       ;   23  GetCDSFromDrv
  3584 000001F9 [8104]                          short_addr  Get_User_Stack      ;   24  Get_User_Stack
  3585 000001FB [B76A]                          short_addr  GETTHISDRV          ;   25  GetThisDrv
  3586 000001FD [BD6E]                          short_addr  DriveFromText       ;   26  DriveFromText
  3587 000001FF [970B]                          short_addr  SETYEAR             ;   27  SETYEAR
  3588 00000201 [300C]                          short_addr  DSUM                ;   28  DSUM
  3589 00000203 [8D0B]                          short_addr  DSLIDE              ;   29  DSLIDE
  3590 00000205 [B311]                          short_addr  StrCmp              ;   30  StrCmp
  3591 00000207 [FA69]                          short_addr  InitCDS             ;   31  initcds
  3592 00000209 [7666]                          short_addr  pJFNFromHandle      ;   32  pJfnFromHandle
  3593 0000020B [986E]                          short_addr  _$NameTrans		;   33  $NameTrans
  3594 0000020D [7A06]                          short_addr  CAL_LK              ;   34  CAL_LK
  3595 0000020F [F441]                          short_addr  DEVNAME             ;   35  DEVNAME
  3596 00000211 [0812]                          short_addr  Idle                ;   36  Idle
  3597 00000213 [FB11]                          short_addr  DStrLen             ;   37  DStrLen
  3598 00000215 [AC12]                          short_addr  NLS_OPEN            ;   38  NLS_OPEN      DOS 3.3
  3599 00000217 [2E67]                          short_addr  _$CLOSE		;   39  $CLOSE        DOS 3.3
  3600 00000219 [B212]                          short_addr  NLS_LSEEK           ;   40  NLS_LSEEK     DOS 3.3
  3601 0000021B [3F68]                          short_addr  _$READ		;   41  $READ         DOS 3.3
  3602 0000021D [6C12]                          short_addr  FastInit            ;   42  FastInit      DOS 3.4  ;AN000;
  3603 0000021F [EF12]                          short_addr  NLS_IOCTL           ;   43  NLS_IOCTL     DOS 3.3
  3604 00000221 [DE12]                          short_addr  GetDevList          ;   44  GetDevList    DOS 3.3
  3605 00000223 [0C13]                          short_addr  NLS_GETEXT          ;   45  NLS_GETEXT    DOS 3.3
  3606                                          
  3607                                  	; 29/04/2019 - Retro DOS v4.0
  3608 00000225 [1013]                  	short_addr  MSG_RETRIEVAL	;   46  MSG_RETRIEVAL DOS 4.0  ;AN000;
  3609                                  
  3610 00000227 [5306]                  	short_addr  NO_OP		;   M006: 47  no longer supported
  3611                                  ;*** 	short_addr  Fake_Version	;   47  Fake_Version  DOS 4.0  ;AN006;
  3612                                  
  3613                                  DOSTableEnd:  ; LABEL BYTE
  3614                                  
  3615                                  	;ENDIF
  3616                                  
  3617                                  ; ----------------------------------------------------------------------------
  3618                                  ; BREAK   <Copyright notice and version>
  3619                                  ; ----------------------------------------------------------------------------
  3620                                  
  3621                                  ;CODSTRT EQU	$
  3622                                  
  3623                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
  3624                                  ; (MSTABLE.ASM, MSDOS 6.0, 1991)
  3625                                  
  3626                                  ; NOTE WARNING: This declaration of HEADER must be THE LAST thing in this
  3627                                  ;       module. The reason is so that the data alignments are the same in
  3628                                  ;       IBM-DOS and MS-DOS up through header.
  3629                                  
  3630                                  	;PUBLIC	HEADER
  3631                                  
  3632                                  HEADER:	; LABEL	BYTE
  3633                                          ;IF	DEBUG
  3634                                          ;DB	13,10,"Debugging DOS version "
  3635                                          ;DB	MAJOR_VERSION + "0"
  3636                                          ;DB	"."
  3637                                          ;DB	(MINOR_VERSION / 10) + "0"
  3638                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  3639                                          ;ENDIF
  3640                                  
  3641                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3642                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
  3643                                  %if 0
  3644                                          ;IF	NOT IBM
  3645                                          DB	13,10,"MS-DOS version "
  3646                                          DB	MAJOR_VERSION + "0"
  3647                                          DB	"."
  3648                                          DB	(MINOR_VERSION / 10) + "0"
  3649                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  3650                                          DB	(MINOR_VERSION % 10) + "0"
  3651                                  
  3652                                          ;IF	HIGHMEM
  3653                                          ;DB	"H"
  3654                                          ;ENDIF
  3655                                  
  3656                                  	;DB	13,10,"Copyright 1981,82,83,84,88 Microsoft Corp.",13,10,"$"
  3657                                  	; 30/04/2019 - Retro DOS v4.0
  3658                                  	DB	13,10,"Copyright 1981-1993 Microsoft Corp.",13,10,"$"	
  3659                                  
  3660                                  	;ENDIF
  3661                                  
  3662                                  %endif
  3663                                  
  3664                                  ;IF DEBUG
  3665                                  ;	DB	13,10,"$"
  3666                                  ;ENDIF
  3667                                  
  3668                                  ;include copyrigh.inc
  3669                                  
  3670                                  ; DOSCODE:3FDDh (MSDOS 6.21, MSDOS.SYS)
  3671                                  
  3672                                  	;DB	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
  3673                                  	;DB	"Licensed Material - Property of Microsoft "
  3674                                  	;DB	"All rights reserved "
  3675                                  
  3676                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3677                                  ; DOSCODE:3FCDh (MSDOS 5.0, MSDOS.SYS)
  3678                                  
  3679                                  ; 28/12/2022 - Retro DOS v4.1
  3680                                  %if 0
  3681                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  3682                                  ms_copyright:
  3683                                  	db	'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp '
  3684                                  	db	'Licensed Material - Property of Microsoft '
  3685                                  	db	'All rights reserved '
  3686                                  
  3687                                  %endif
  3688                                  	;; 28/12/2022 - Retro DOS v4.1
  3689                                  ;ms_copyright:	
  3690                                    	;db	13,10,"MS DOS Version 5.0"
  3691                                  	;db	13,10,"Copyright 1981-1991 Microsoft Corp.",13,10,"$",0	
  3692                                  
  3693                                  ;	; 21/09/2023 - Retro DOS v4.2 MSDOS.SYS
  3694                                  ;	; (MSDOS 6.22 MSDOS.SYS - DOSCODE:3FDDh (File offset: 509))
  3695                                  ;ms_copyright:
  3696                                  ;	db 'MS DOS Version 6 (C)Copyright 1981-1994 Microsoft Corp '
  3697                                  ;	db 'Licensed Material - Property of Microsoft All rights reserved '
  3698                                  
  3699                                  	; 20/09/2023 - Retro DOS v4.2
  3700                                  ms_copyright:	
  3701 00000229 0D0A4D5320444F5320-       	db	13,10,"MS DOS Version 6.22"
  3701 00000232 56657273696F6E2036-
  3701 0000023B 2E3232             
  3702 0000023E 0D0A436F7079726967-     	db	13,10,"Copyright 1981-1994 Microsoft Corp.",13,10,"$",0	
  3702 00000247 687420313938312D31-
  3702 00000250 393934204D6963726F-
  3702 00000259 736F667420436F7270-
  3702 00000262 2E0D0A2400         
  3703                                  
  3704                                  ;============================================================================
  3705                                  ; MSCODE.ASM
  3706                                  ;============================================================================
  3707                                  
  3708                                  ; Retro DOS v2.0 (NASM 2.11) source code modifications by Erdogan Tan
  3709                                  ; 03/03/2018
  3710                                  
  3711                                  ;
  3712                                  ; MSCODE.ASM -- MSDOS code
  3713                                  ;
  3714                                  
  3715                                  ;INCLUDE DOSSEG.ASM
  3716                                  ;INCLUDE STDSW.ASM
  3717                                  
  3718                                  ;CODE    SEGMENT BYTE PUBLIC  'CODE'
  3719                                  ;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  3720                                  
  3721                                  ;.xcref
  3722                                  ;INCLUDE DOSSYM.ASM
  3723                                  ;INCLUDE DEVSYM.ASM
  3724                                  ;.cref
  3725                                  ;.list
  3726                                  
  3727                                  ;IFNDEF  KANJI
  3728                                  ;KANJI   EQU     0       ; FALSE
  3729                                  ;ENDIF
  3730                                  
  3731                                  ;IFNDEF  IBM
  3732                                  ;IBM     EQU     0
  3733                                  ;ENDIF
  3734                                  
  3735                                  ;IFNDEF  HIGHMEM
  3736                                  ;HIGHMEM  EQU     0
  3737                                  ;ENDIF
  3738                                  
  3739                                          ;i_need  USER_SP,WORD
  3740                                          ;i_need  USER_SS,WORD
  3741                                          ;i_need  SAVEDS,WORD
  3742                                          ;i_need  SAVEBX,WORD
  3743                                          ;i_need  INDOS,BYTE
  3744                                          ;i_need  NSP,WORD
  3745                                          ;i_need  NSS,WORD
  3746                                          ;i_need  CURRENTPDB,WORD
  3747                                          ;i_need  AUXSTACK,BYTE
  3748                                          ;i_need  CONSWAP,BYTE
  3749                                          ;i_need  IDLEINT,BYTE
  3750                                          ;i_need  NOSETDIR,BYTE
  3751                                          ;i_need  ERRORMODE,BYTE
  3752                                          ;i_need  IOSTACK,BYTE
  3753                                          ;i_need  WPERR,BYTE
  3754                                          ;i_need  DSKSTACK,BYTE
  3755                                          ;i_need  CNTCFLAG,BYTE
  3756                                          ;i_need  LEAVEADDR,WORD
  3757                                          ;i_need  NULLDEVPT,DWORD
  3758                                  
  3759                                          ;IF NOT IBM
  3760                                          ;i_need  OEM_HANDLER,DWORD
  3761                                          ;ENDIF
  3762                                  
  3763                                          ;EXTRN   DSKSTATCHK:NEAR,GETBP:NEAR,DSKREAD:NEAR,DSKWRITE:NEAR
  3764                                  
  3765                                  ;============================================================================
  3766                                  ; MSDISP.ASM, MSDOS 6.0, 1991
  3767                                  ;============================================================================
  3768                                  ; 11/07/2018 - Retro DOS v3.0
  3769                                  ; 01/05/2019 - Retro DOS v4.0
  3770                                  
  3771                                  ; DosCode SEGMENT
  3772                                  
  3773                                  ; ==========================================================================
  3774                                  ;
  3775                                  ; $Set_CTRL_C_Trapping
  3776                                  ;
  3777                                  ; Function:
  3778                                  ;	Enable disable ^C checking in dispatcher
  3779                                  ;
  3780                                  ; Inputs:
  3781                                  ;		AL = 0 read ^C status
  3782                                  ;		AL = 1 Set ^C status, DL = 0/1 for ^C off/on
  3783                                  ;		AL = 2 Set ^C status to contents of DL.	Output is old state.
  3784                                  ;		AL = 5 get DOS boot drive
  3785                                  ;		AL = 6 Get version number
  3786                                  ;			RETURNS:
  3787                                  ;				BH = Minor version number
  3788                                  ;				BL = Major version number
  3789                                  ;				DL = DOS internal revision
  3790                                  ;				DH = DOS type flags
  3791                                  ;					Bit 3 	- DOS in ROM
  3792                                  ;					Bit 4 	- DOS in HMA
  3793                                  ;					Bit 0-2, 5-7 - Reserved
  3794                                  ; Outputs:
  3795                                  ;		If AL = 0 then DL = 0/1 for ^C off/on
  3796                                  ;
  3797                                  ; History:
  3798                                  ;      removed	AL = 3 Get CPSW state to DL	    DOS 3.4
  3799                                  ;      removed	AL = 4 Set CPSW state from DL	    DOS 3.4
  3800                                  ; ==========================================================================
  3801                                  
  3802                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3803                                  ; DOSCODE:4045h (MSDOS 5.0, MSDOS.SYS)
  3804                                  
  3805                                  ; 01/01/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
  3806                                  ; DOSCODE:4052h (MSDOS 6.21, MSDOS.SYS)
  3807                                  ; DOSCODE:4052h (MSDOS 6.22, MSDOS.SYS)
  3808                                  ; DOSCODE:4123h (PCDOS 7.1, IBMDOS.COM)
  3809                                  
  3810                                  _$SET_CTRL_C_TRAPPING:
  3811                                  	; 01/05/2019 - Retro DOS v4.0
  3812                                  
  3813 00000267 3C06                    	cmp	AL,6			; Is this a valid subfunction?
  3814 00000269 7603                    	jbe	short scct_1		; If yes continue processing
  3815                                  
  3816 0000026B B0FF                    	mov	AL,0FFh			; Else set AL to -1 and
  3817 0000026D CF                      	iret
  3818                                  scct_1:
  3819 0000026E 1E                      	push	DS
  3820                                  
  3821                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3822 0000026F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3823                                  	
  3824 00000274 50                      	push	AX			; DL only register that can change
  3825 00000275 56                      	push	SI
  3826                                  
  3827 00000276 BE[3703]                	mov	SI,CNTCFLAG		; DS:SI --> Ctrl C Status byte
  3828 00000279 30E4                    	xor	AH,AH			; Clear high byte of AX
  3829 0000027B 09C0                    	or	AX,AX			; Check for subfunction 0
  3830 0000027D 7504                    	jnz	short scct_2		; If not 0 jmp to next check
  3831                                  
  3832 0000027F 8A14                    	mov	DL,[SI]			; Else move current ctrl C status
  3833 00000281 EB30                    	jmp	SHORT scct_9s		; into DL and jmp to exit
  3834                                  scct_2:
  3835 00000283 48                      	dec	AX			; Now dec AX and see if it was 1
  3836 00000284 7507                    	jnz	short scct_3		; If not 0 it wasn't 1 so do next chk
  3837                                  
  3838 00000286 80E201                  	and	DL,1			; Else mask off bit 0 of DL and
  3839 00000289 8814                    	mov	[SI],DL			; save it as new Ctrl C status
  3840 0000028B EB26                    	jmp	SHORT scct_9s		; Jmp to exit
  3841                                  scct_3:
  3842 0000028D 48                      	dec	AX			; Dec AX again to see if it was 2
  3843 0000028E 7507                    	jnz	short scct_4		; If not 0 wasn't 2 so go to next chk
  3844                                  
  3845 00000290 80E201                  	and	DL,1			; Else mask off bit 0 of DL and
  3846 00000293 8614                    	xchg	[SI],DL			; Exchange DL with old status byte
  3847 00000295 EB1C                    	jmp	SHORT scct_9s		; Jump to exit (returning old status)
  3848                                  scct_4:
  3849 00000297 3C03                    	cmp	al,3 ; 01/01/2024 (PCDOS 7.1 IBMDOS.COM)
  3850                                  	;cmp	AX,3 			; Test for 5 after it was dec twice
  3851 00000299 7506                    	jne	short scct_5		; If not equal then not get boot drv
  3852 0000029B 8A16[6900]              	mov	DL,[BOOTDRIVE]		; Else return boot drive in DL
  3853 0000029F EB12                    	jmp	SHORT scct_9s		; Jump to exit (returning boot drive)
  3854                                  scct_5:
  3855 000002A1 3C04                    	cmp	al,4 ; 01/01/2024 (PCDOS 7.1 IBMDOS.COM)
  3856                                  	;cmp	AX,4 			; Test for 6 after it was dec twice
  3857 000002A3 750E                    	jne	short scct_9s		; If not equal then not get version
  3858                                  	
  3859                                  	;mov	BX,(Minor_Version SHL 8) + Major_Version
  3860                                  	;mov	bx,1406h	; DOSCODE:4092h (MSDOS 6.21, MSDOS.SYS)
  3861 000002A5 BB0616                  	mov	bx,(MINOR_VERSION<<8)+MAJOR_VERSION
  3862                                  	
  3863                                  	;mov	dl,0
  3864                                  	;mov	DL,DOSREVNM ; 0
  3865                                  
  3866                                  	;xor	dh,dh			; assume vanilla DOS
  3867                                  	; 01/01/2024
  3868 000002A8 BA0000                  	mov	dx,0
  3869 000002AB 3836[F211]              	cmp	byte [DosHasHMA],dh ; 0
  3870                                  	;cmp	byte [DosHasHMA],0	; is DOS in HMA?  (M021)
  3871                                  	;je	short @F
  3872 000002AF 7402                    	je	short scct_6
  3873                                  	; 01/01/2024
  3874 000002B1 B610                    	mov	dh,10h
  3875                                  	;or	dh,10h
  3876                                  	;;or	DH,DOSINHMA ; 10h
  3877                                  ;@@:
  3878                                  scct_6:
  3879                                  
  3880                                  ;ifdef ROMDOS
  3881                                  ;	or	DH,DOSINROM ; 08h
  3882                                  ;endif ; ROMDOS
  3883                                  
  3884                                  scct_9s:
  3885 000002B3 5E                      	pop	SI
  3886 000002B4 58                      	pop	AX
  3887 000002B5 1F                      	pop	DS
  3888                                  scct_9f:
  3889 000002B6 CF                      	iret
  3890                                  
  3891                                  SetCtrlShortEntry:			; This allows a conditional entry
  3892                                  					; from main dispatch code
  3893 000002B7 EBAE                    	jmp	SHORT _$SET_CTRL_C_TRAPPING
  3894                                  
  3895                                  ; ==========================================================================
  3896                                  ;									   
  3897                                  ; The following two routines are dispatched to directly with ints disabled
  3898                                  ; immediately after the int 21h entry.	no DIS state is set.
  3899                                  ;
  3900                                  ; $Set_current_PDB takes BX and sets it to be the current process
  3901                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  3902                                  ;
  3903                                  ; ==========================================================================
  3904                                  
  3905                                  _$SET_CURRENT_PDB:
  3906 000002B9 1E                      	push	DS
  3907                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3908 000002BA 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3909 000002BF 891E[3003]              	mov	[CurrentPDB],BX		; Set new PSP segment from caller's BX
  3910 000002C3 1F                      	pop	DS
  3911 000002C4 CF                      	iret
  3912                                  
  3913                                  ; ==========================================================================
  3914                                  ;
  3915                                  ; $get_current_PDB returns in BX the current process
  3916                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  3917                                  ;
  3918                                  ; ==========================================================================
  3919                                  
  3920                                  _$GET_CURRENT_PDB:
  3921 000002C5 1E                      	push	DS
  3922                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3923 000002C6 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3924 000002CB 8B1E[3003]              	mov	BX,[CurrentPDB]		; Return current PSP segment in BX
  3925 000002CF 1F                      	pop	DS
  3926 000002D0 CF                      	iret
  3927                                  
  3928                                  ; ==========================================================================
  3929                                  ;
  3930                                  ; Sets the Printer Flag to whatever is in AL.
  3931                                  ; NOTE: THIS PROCEDURE IS SUBJECT TO CHANGE!!!
  3932                                  ;
  3933                                  ; ==========================================================================
  3934                                  
  3935                                  _$SET_PRINTER_FLAG:
  3936 000002D1 1E                      	push	ds
  3937                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3938 000002D2 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3939 000002D7 A2[A00A]                	mov	[PRINTER_FLAG],AL 	; Set printer flag from caller's AL
  3940 000002DA 1F                      	pop	ds
  3941 000002DB CF                      	iret
  3942                                  
  3943                                  ; 01/05/2019 - Retro DOS v4.0
  3944                                  ; 08/07/2018 - Retro DOS v3.0
  3945                                  ; (MSDISP.ASM, MSDOS 6.0, 1991)
  3946                                  
  3947                                  ; ----------------------------------------------------------------------------
  3948                                  ; BREAK   <System call entry points and dispatcher>
  3949                                  ; ----------------------------------------------------------------------------
  3950                                  
  3951                                  ; DOSCODE:40CCh (MSDOS 6.21, MSDOS.SYS)
  3952                                  
  3953                                  ; ==========================================================================
  3954                                  ;
  3955                                  ; The Quit entry point is where all INT 20h's come from. These are old- style
  3956                                  ; exit system calls. The CS of the caller indicates which Process is dying.
  3957                                  ; The error code is presumed to be 0. We simulate an ABORT system call.
  3958                                  ;
  3959                                  ; ==========================================================================
  3960                                  
  3961                                  SYSTEM_CALL:    ; PROC NEAR
  3962                                  
  3963                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3964                                  ; DOSCODE:40BFh (MSDOS 5.0, MSDOS.SYS)
  3965                                  
  3966                                  ;entry	QUIT				
  3967                                  QUIT:				; INT 20H entry point	
  3968                                  	;MOV	AH,0
  3969 000002DC 30E4                    	xor	ah,ah ; 08/07/2018
  3970 000002DE EB36                    	JMP     SHORT SAVREGS
  3971                                  
  3972                                  ; ---------------------------------------------------------------------------
  3973                                  
  3974                                  	; The system call in AH is out of the range that we know how
  3975                                  	; to handle. We arbitrarily set the contents of AL to 0 and
  3976                                  	; IRET. Note that we CANNOT set the carry flag to indicate an
  3977                                  	; error as this may break some programs compatability.
  3978                                  
  3979                                  BADCALL:
  3980                                          ;MOV	AL,0
  3981 000002E0 30C0                    	xor	al,al ; 08/07/2018
  3982                                  IRETT:	; 06/05/2019
  3983                                  _IRET:
  3984 000002E2 CF                              IRET
  3985                                  
  3986                                  ; ---------------------------------------------------------------------------
  3987                                  
  3988                                  ; 01/05/2019 - Retro DOS v4.0
  3989                                  ; DOSCODE:40D3h (MSDOS 6.21 MSDOS.SYS)
  3990                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3991                                  ; DOSCODE:40C6h (MSDOS 5.0 MSDOS.SYS)
  3992                                  
  3993                                  	; An alternative method of entering the system is to perform a
  3994                                  	; CALL 5 in the program segment prefix with the contents of CL
  3995                                  	; indicating what system call the user would like. A subset of
  3996                                  	; the possible system calls is allowed here only the
  3997                                  	; CPM-compatible calls may get dispatched.
  3998                                  
  3999                                  		; System call entry point and dispatcher
  4000                                  CALL_ENTRY:
  4001 000002E3 1E                      	push	DS
  4002                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4003 000002E4 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4004 000002E9 8F06[EC05]              	pop	word [SAVEDS]		; Save original DS
  4005                                  
  4006 000002ED 58                              POP     AX                      ; IP from the long call at 5
  4007 000002EE 58                              POP     AX                      ; Segment from the long call at 5
  4008 000002EF 8F06[8405]              	POP	WORD [USER_SP]		; IP from the CALL 5
  4009                                  
  4010                                  		; Re-order the stack to simulate an interrupt 21.
  4011                                  
  4012 000002F3 9C                      	PUSHF				; Start re-ordering the stack
  4013 000002F4 FA                      	CLI
  4014 000002F5 50                              PUSH    AX                      ; Save segment
  4015 000002F6 FF36[8405]                      PUSH	WORD [USER_SP]		; Stack now ordered as if INT had been used
  4016                                  	; 04/11/2022
  4017                                  	; DOSCODE:40EAh (MSDOS 6.21 MSDOS.SYS)
  4018                                  	; DOSCODE:40DDh (MSDOS 5.0 MSDOS.SYS)
  4019 000002FA FF36[EC05]              	push	word [SAVEDS]
  4020 000002FE 1F                      	pop	ds
  4021                                  	;
  4022                                  	;cmp	cl,36
  4023 000002FF 80F924                          CMP     CL,MAXCALL              ; This entry point doesn't get as many calls
  4024 00000302 77DC                            JA      SHORT BADCALL
  4025 00000304 88CC                            MOV     AH,CL
  4026                                  	; 08/07/2018
  4027 00000306 EB0E                    	jmp	short SAVREGS
  4028                                  
  4029                                  ; ---------------------------------------------------------------------------
  4030                                  
  4031                                  ; 01/05/2019 - Retro DOS v4.0
  4032                                  
  4033                                  	; This is the normal INT 21 entry point. We first perform a
  4034                                  	; quick test to see if we need to perform expensive DOS-entry
  4035                                  	; functions. Certain system calls are done without interrupts
  4036                                  	; being enabled.
  4037                                  
  4038                                  	;entry	COMMAND 		; Interrupt call entry point (int 21h)
  4039                                  
  4040                                  ; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
  4041                                  ; 04/11/2022
  4042                                  ; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)
  4043                                  
  4044                                  COMMAND:
  4045                                  	; 22/12/2022
  4046 00000308 FA                      	cli
  4047                                  
  4048                                  	; 01/05/2019 - Retro DOS v4.0
  4049                                  	; 08/07/2018 - Retro DOS v3.0
  4050                                  
  4051                                  ; 22/12/2022
  4052                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4053                                  	;IF	NOT IBM
  4054 00000309 80FCF8                  	CMP	AH,SET_OEM_HANDLER
  4055 0000030C 7203                    	JB	SHORT NOTOEM
  4056 0000030E E97A01                  	JMP	_$SET_OEM_HANDLER
  4057                                  
  4058                                  NOTOEM:
  4059                                  	;ENDIF
  4060                                  
  4061                                  ; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
  4062                                  ; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)
  4063                                  
  4064                                  	; 22/12/2022
  4065                                  	;cli	; 08/07/2018
  4066                                  
  4067                                  _COMMAND: ; MSDOS 3.3 (IBM)
  4068                                  	;cmp	ah,6Ch   ; MSDOS 6.21 ; Max int 21h function call number
  4069                                  	; 04/11/2022
  4070 00000311 80FC6C                  	CMP     AH,MAXCOM  ; 6Ch for MSDOS 6.0 (6.21,6.22) & MSDOS 5.0
  4071                                  	;JBE	SHORT SAVREGS
  4072 00000314 77CA                            JA	SHORT BADCALL ; 08/07/2018
  4073                                  
  4074                                  	; 31/05/2019
  4075                                  
  4076                                  	; The following set of calls are issued by the server at
  4077                                  	; *arbitrary* times and, therefore, must be executed on
  4078                                  	; the user's entry stack and executed with interrupts off.
  4079                                  
  4080                                  SAVREGS:
  4081                                  	; 01/05/2019 - Retro DOS v4.0
  4082                                  	; 10/08/2018
  4083                                  	; 08/07/2018 - Retro DOS v3.0
  4084 00000316 80FC33                  	cmp	ah,33h			; Check Minimum special case #
  4085                                  	;;je	_$SET_CTRL_C_TRAPPING
  4086                                  	;je	short SetCtrlShortEntry ; If equal jmp directly to function
  4087 00000319 7218                    	jb	short SaveAllRegs	; Not special case so continue	
  4088                                  	; 04/11/2022
  4089 0000031B 749A                    	je	short SetCtrlShortEntry ; If equal jmp directly to function
  4090 0000031D 80FC64                  	cmp	ah,64h			; Check Max case number
  4091 00000320 7711                    	ja	short SaveAllRegs	; Not special case so continue
  4092 00000322 74AD                    	je	short _$SET_PRINTER_FLAG ; If equal jmp directly to function
  4093 00000324 80FC51                  	cmp	ah,51h			; Is this a Get PSP call (51h)?
  4094 00000327 749C                    	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
  4095 00000329 80FC62                  	cmp	ah,62h			; Is this a Get PSP call (62h)?
  4096 0000032C 7497                    	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
  4097 0000032E 80FC50                  	cmp     ah,50h			; Is this a Set PSP call (50h) ?
  4098 00000331 7486                    	je	short _$SET_CURRENT_PDB	; Yes, jmp directly to function
  4099                                  
  4100                                  SaveAllRegs:
  4101                                  	; 01/05/2019 - Retro DOS v4.0
  4102                                  
  4103 00000333 06                              push	ES
  4104 00000334 1E                      	push	DS
  4105 00000335 55                      	push	BP
  4106 00000336 57                      	push	DI
  4107 00000337 56                      	push	SI
  4108 00000338 52                      	push	DX
  4109 00000339 51                      	push	CX
  4110 0000033A 53                      	push	BX
  4111 0000033B 50                      	push	AX
  4112                                  
  4113 0000033C 8CD8                    	mov	AX,DS
  4114                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4115 0000033E 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4116 00000343 A3[EC05]                	mov	[SAVEDS],AX		; save caller's DS
  4117 00000346 891E[EA05]              	mov	[SAVEBX],BX
  4118                                  
  4119                                          ;INC     BYTE [INDOS]		; Flag that we're in the DOS
  4120                                  	
  4121                                  	; 08/07/2018 - Retro DOS v3.0        
  4122                                  	;xor     ax,ax
  4123                                  	;mov     [USER_ID],ax
  4124                                  	;mov     ax,[CurrentPDB]
  4125                                  	;mov     [PROC_ID],ax
  4126                                  
  4127                                  	; 01/05/2019
  4128                                  
  4129                                  	; Note: Nsp and Nss have to be unconditionally initialized here 
  4130                                  	; even if InDOS is zero. Programs like CROSSTALK 3.7 depend on
  4131                                  	; this!!!
  4132                                  
  4133 0000034A A1[8405]                	MOV     AX,[USER_SP]
  4134 0000034D A3[F205]                        MOV     [NSP],AX
  4135 00000350 A1[8605]                        MOV     AX,[USER_SS]
  4136 00000353 A3[F005]                        MOV     [NSS],AX
  4137                                  
  4138 00000356 31C0                    	xor	AX,AX ; 0
  4139 00000358 A2[7205]                	mov	[FSHARING],AL		; allow redirection
  4140                                  
  4141 0000035B F606[3010]01            	test	byte [IsWin386],1	; WIN386 patch. Do not update USER_ID
  4142 00000360 7503                    	jnz	short set_indos_flag	; if win386 present
  4143 00000362 A3[3E03]                	mov	[USER_ID],AX
  4144                                  set_indos_flag:
  4145 00000365 FE06[2103]              	INC     BYTE [INDOS]		; Flag that we're in the DOS
  4146                                  
  4147 00000369 8926[8405]                      MOV     [USER_SP],SP
  4148 0000036D 8C16[8605]                      MOV     [USER_SS],SS
  4149                                  
  4150 00000371 A1[3003]                	mov	AX,[CurrentPDB]
  4151 00000374 A3[3C03]                	mov	[PROC_ID],AX
  4152 00000377 8ED8                    	mov	DS,AX
  4153 00000379 58                      	pop	AX
  4154 0000037A 50                      	push	AX
  4155                                  
  4156                                  	; save user stack in his area for later returns (possibly from EXEC)
  4157                                  
  4158 0000037B 89262E00                        MOV     [PDB.USER_STACK],SP
  4159 0000037F 8C163000                        MOV     [PDB.USER_STACK+2],SS
  4160                                  
  4161                                  	; 18/07/2018
  4162                                  	;mov	byte [CS:FSHARING], 0
  4163                                  
  4164                                  	;MOV     BX,CS			; no holes here.
  4165                                  	;MOV     SS,BX
  4166                                  
  4167                                  	;getdseg <ss>			; ss -> dosdat, already flag is CLI
  4168 00000383 2E8E16[0700]            	mov	ss,[cs:DosDSeg]
  4169                                  					;entry	REDISP
  4170                                  REDISP:
  4171 00000388 BC[A007]                        MOV     SP,AUXSTACK		; Enough stack for interrupts
  4172 0000038B FB                              STI                             ; stack is in our space now...
  4173                                  
  4174 0000038C 8CD3                    	mov	bx,ss
  4175 0000038E 8EDB                    	mov	ds,bx
  4176                                  
  4177 00000390 93                      	xchg	ax,bx
  4178                                  
  4179 00000391 31C0                    	xor	ax,ax ; 0
  4180                                  
  4181                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4182                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:416Eh  (from org 3DD0h)
  4183                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:417Bh (from org 3DE0h)
  4184                                  
  4185                                  	; (Note: ss: segment prefix was not needed here! ds=ss ! -04/11/2022-)
  4186                                  
  4187                                  	;mov	[ss:EXTOPEN_ON],al ; 0	; Clear extended open flag
  4188                                  	;;and	word [ss:DOS34_FLAG],EXEC_AWARE_REDIR
  4189                                  	;and	word [ss:DOS34_FLAG],800h ; clear all bits except bit 11
  4190                                  	;mov	[ss:CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
  4191                                  	;mov	[ss:NoSetDir],al ; 0	; set directories on search
  4192                                  	;mov	[ss:FAILERR],al ; 0	; FAIL not in progress
  4193                                  	;inc	ax
  4194                                  	;;inc	AL			; AL = 1
  4195                                  	;mov	[ss:IDLEINT],al		; presume that we can issue INT 28
  4196                                  
  4197                                  	; 15/12/2022
  4198 00000393 A2[F605]                	mov	[EXTOPEN_ON],al ; 0	; Clear extended open flag
  4199                                  	;and	word [DOS34_FLAG],EXEC_AWARE_REDIR
  4200 00000396 8126[1106]0008          	and	word [DOS34_FLAG],800h	; clear all bits except bit 11
  4201 0000039C A2[5703]                	mov	[CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
  4202                                  	;mov	byte [IDLEINT],1
  4203 0000039F A2[4C03]                	mov	[NoSetDir],al ; 0	; set directories on search
  4204 000003A2 A2[4A03]                	mov	[FAILERR],al ; 0	; FAIL not in progress
  4205 000003A5 40                      	inc	ax
  4206                                  	;inc	al			; AL = 1
  4207 000003A6 A2[5803]                	mov	[IDLEINT],al		; presume that we can issue INT 28
  4208                                  
  4209 000003A9 93                      	XCHG	AX,BX			; Restore AX and BX = 1		
  4210                                  
  4211 000003AA 88E3                    	MOV     BL,AH			
  4212 000003AC D1E3                            SHL     BX,1			; 2 bytes per call in table
  4213                                         
  4214 000003AE FC                      	CLD
  4215                                  		; Since the DOS maintains mucho state information across system
  4216                                  		; calls, we must be very careful about which stack we use.
  4217                                  		; First, all abort operations must be on the disk stack. This
  4218                                  		; is due to the fact that we may be hitting the disk (close
  4219                                  		; operations, flushing) and may need to report an INT 24.
  4220                                          
  4221 000003AF 08E4                    	OR      AH,AH
  4222 000003B1 7416                            JZ      SHORT DSKROUT		; ABORT
  4223                                  
  4224                                          ;CMP	AH,12
  4225                                          ;JBE	SHORT IOROUT		; Character I/O
  4226                                          ;CMP	AH,GET_CURRENT_PDB      ; INT 24 needs GET,SET PDB
  4227                                          ;JZ	SHORT IOROUT
  4228                                          ;CMP	AH,SET_CURRENT_PDB
  4229                                          ;JNZ	SHORT DSKROUT
  4230                                  
  4231                                  		; Second, PRINT and PSPRINT and the server issue
  4232                                  		; GetExtendedError calls at INT 28 and INT 24 time.
  4233                                  		; This call MUST, therefore, use the AUXSTACK.
  4234                                  
  4235                                  	; 10/08/2018
  4236 000003B3 80FC59                  	cmp     ah,GETEXTENDEDERROR ; 59h
  4237 000003B6 7434                    	je      short DISPCALL
  4238                                  	
  4239                                  	; 01/05/2019
  4240                                  	
  4241                                  		; Old 1-12 system calls may be either on the IOSTACK (normal
  4242                                  		; operation) or on the AUXSTACK (at INT 24 time).
  4243                                  
  4244 000003B8 80FC0C                  	cmp     ah,12 ; STD_CON_INPUT_FLUSH ; 0Ch
  4245 000003BB 770C                    	ja      short DSKROUT
  4246                                  
  4247                                  IOROUT:
  4248                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4249                                  	; (ss: prefix was not needed here! ds=ss)
  4250                                  	;cmp	byte [ss:ERRORMODE],0	; Are we in an INT 24? 
  4251                                  	; 15/12/2022
  4252 000003BD 803E[2003]00            	cmp     BYTE [ERRORMODE],0	; Are we in an INT 24?
  4253 000003C2 7528                            JNZ     SHORT DISPCALL		; Stay on AUXSTACK if INT 24
  4254 000003C4 BC[A00A]                        MOV     SP,IOSTACK
  4255 000003C7 EB23                            JMP     SHORT DISPCALL
  4256                                  
  4257                                  		; We are on a system call that is classified as "the rest".
  4258                                  		; We place ourselves onto the DSKSTACK and away we go.
  4259                                  		; We know at this point:
  4260                                  		; *  An INT 24 cannot be in progress. Therefore we reset
  4261                                  		;    ErrorMode and WpErr
  4262                                  		; *  That there can be no critical sections in effect.
  4263                                  		;    We signal the server to remove all the resources.
  4264                                  
  4265                                  DSKROUT:
  4266                                  	; 01/01/2024
  4267                                  	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4268                                  	; 08/07/2018 - Retro DOS v3.0
  4269 000003C9 A3[3A03]                	mov     [USER_IN_AX],ax		; Remember what user is doing
  4270                                  	; 01/01/2024
  4271                                  	;mov	byte [EXTERR_LOCUS],1	; errLOC_Unk (Default)
  4272                                  	;MOV	BYTE [WPERR],-1		; error mode, so good place to
  4273                                  	                   		; make sure flags are reset
  4274 000003CC C706[2203]FF01          	mov	word [WPERR],1FFh ; (PCDOS 7.1 IBMDOS.COM))
  4275                                  
  4276                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4277                                  	; (ss: prefix was not needed here! ds=ss)
  4278                                  
  4279                                  	;mov	[ss:USER_IN_AX],ax	; Remember what user is doing
  4280                                  	;mov	byte [ss:EXTERR_LOCUS],1 ; errLOC_Unk (Default)
  4281                                  	;mov	byte [ss:ERRORMODE],0	; Cannot make non 1-12 calls in
  4282                                  	;mov	byte [ss:WPERR],-1	; error mode, so good place to
  4283                                                                          ; make sure flags are reset
  4284 000003D2 50                      	push    ax
  4285 000003D3 B482                    	mov     ah,82h			; Release all resource information
  4286 000003D5 CD2A                    	int     2Ah 		; Microsoft Networks 
  4287                                  				; END DOS CRITICAL SECTIONS 0 THROUGH 7
  4288 000003D7 58                      	pop     ax
  4289                                  
  4290                                  		; Since we are going to be running on the DSKStack and since
  4291                                  		; INT 28 people will use the DSKStack, we must turn OFF the
  4292                                  		; generation of INT 28's.
  4293                                  
  4294                                  	; 15/12/2022
  4295                                  	;mov     byte [ss:IDLEINT],0
  4296                                  	;
  4297                                          ;mov	sp,DSKSTACK
  4298                                  	;test	byte [ss:CNTCFLAG],-1  ; 0FFh
  4299                                          ;jz	short DISPCALL
  4300                                  
  4301 000003D8 C606[5803]00            	mov     byte [IDLEINT],0
  4302                                  
  4303 000003DD BC[2009]                	MOV     SP,DSKSTACK
  4304 000003E0 F606[3703]FF            	TEST    BYTE [CNTCFLAG],-1
  4305 000003E5 7405                    	JZ      SHORT DISPCALL
  4306                                  
  4307 000003E7 50                              PUSH    AX
  4308                                          ;invoke	DSKSTATCHK
  4309 000003E8 E8E94C                          CALL	DSKSTATCHK
  4310 000003EB 58                      	POP     AX
  4311                                  DISPCALL:
  4312                                  	; 01/05/2019 - Retro DOS v4.0
  4313 000003EC 2E8B9F[EA00]            	mov	bx,[CS:BX+DISPATCH]
  4314                                  
  4315                                  	; 15/12/2022
  4316 000003F1 871E[EA05]              	xchg	bx,[SAVEBX]
  4317 000003F5 8E1E[EC05]              	MOV	DS,[SAVEDS]
  4318                                  
  4319                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4320                                  	; (ss: prefix was not needed here! ds=ss)        
  4321                                  	;xchg	bx,[ss:SAVEBX]
  4322                                  	;mov	ds,[ss:SAVEDS]
  4323                                  
  4324 000003F9 36FF16[EA05]            	call	word [SS:SAVEBX] ; near call
  4325                                  
  4326                                  	; The EXEXA20OFF bit of DOS_FLAG will now be unconditionally cleared
  4327                                  	; here. Please see under M003, M009 and M068 tags in dossym.inc
  4328                                  	; for explanation. Also NOTE that a call to ExecReady (ax=4b05) will
  4329                                  	; return to LeaveDos and hence will not clear this bit. This is 
  4330                                  	; because this bit is used to indicate to the next int 21 call that
  4331                                  	; the previous int 21 was an exec.
  4332                                  	;
  4333                                  	; So do not add any code between the call above and the label 
  4334                                  	; LeaveDOS if it needs to be executed even for ax=4b05
  4335                                  
  4336                                  	;and	byte [ss:DOS_FLAG],~EXECA20OFF
  4337 000003FE 368026[8600]FB          	and	byte [ss:DOS_FLAG],0FBh
  4338                                  
  4339                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4340                                  ; DOSCODE:41F7h
  4341                                  
  4342                                  ; 01/01/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
  4343                                  ; DOSCODE:4204h
  4344                                  
  4345                                  ;entry LEAVE
  4346                                  ;;;_LEAVE:				; Exit from a system call
  4347                                  LeaveDOS: ; 18/07/2018 
  4348                                  ;ASSUME	SS:NOTHING			; User routines may misbehave
  4349 00000404 FA                      	CLI
  4350                                  
  4351                                  	; 01/05/2019
  4352                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4353 00000405 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4354 0000040A 803E[8500]00            	cmp	byte [A20OFF_COUNT],0	; M068: Q: is count 0
  4355 0000040F 7526                    	jne	short disa20		; M068: N: dec count and turn a20 off
  4356                                  
  4357                                  LeaveA20On:
  4358 00000411 FE0E[2103]                      DEC     BYTE [INDOS]
  4359                                          ; 04/11/2022
  4360 00000415 8E16[8605]              	mov	ss,[USER_SS]
  4361 00000419 8B26[8405]              	MOV     SP,[USER_SP]
  4362                                  	;MOV	SS,[USER_SS]
  4363 0000041D 89E5                    	MOV     BP,SP
  4364                                  	;MOV	[BP.user_AX],AL	
  4365                                          ; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4366                                  	;;mov	[bp+0],al ; MSDOS 5.0 MSDOS.SYS - DOSCODE:4212h
  4367                                  	;MOV	[BP+user_env.user_AX],AL  ; user_env.user_AX = 0
  4368                                  
  4369                                  	; 15/12/2022
  4370 0000041F 884600                  	MOV	[BP],AL	; mov [bp+0],al
  4371                                  	
  4372                                  	;MOV	AX,[NSP]
  4373                                          ;MOV	[USER_SP],AX
  4374                                          ;MOV	AX,[NSS]
  4375                                          ;MOV	[USER_SS],AX
  4376                                  	; 01/01/2024
  4377 00000422 C406[F005]              	les	ax,[NSS] ; (PCDOS 7.1 IBMDOS.COM)
  4378 00000426 A3[8605]                	mov	[USER_SS],ax
  4379 00000429 8C06[8405]              	mov	[USER_SP],es
  4380                                  
  4381 0000042D 58                      	pop	AX
  4382 0000042E 5B                      	pop	BX
  4383 0000042F 59                      	pop	CX
  4384 00000430 5A                      	pop	DX
  4385 00000431 5E                      	pop	SI
  4386 00000432 5F                      	pop	DI
  4387 00000433 5D                      	pop	BP
  4388 00000434 1F                      	pop	DS
  4389 00000435 07                      	pop	ES
  4390                                  
  4391 00000436 CF                              IRET
  4392                                  
  4393                                  disa20:	   				; M068 - Start
  4394 00000437 8B1E[6300]              	mov	bx,[A20OFF_PSP]		; bx = PSP for which a20 to be off'd
  4395 0000043B 3B1E[3003]              	cmp	bx,[CurrentPDB]		; Q: do the PSP's match
  4396 0000043F 75D0                    	jne	short LeaveA20On	; N: don't clear bit and don't turn 
  4397                                  					;    a20 off
  4398                                  					; Y: turn a20 off and dec a20off_count
  4399 00000441 FE0E[8500]              	dec	byte [A20OFF_COUNT]	; M068 - End
  4400                                   					; Start - M004
  4401 00000445 1E                      	push	ds			; segment of stub
  4402 00000446 BB[1311]                	mov	bx,disa20_iret		; offset in stub
  4403 00000449 53                      	push	bx
  4404 0000044A CB                      	retf	  			; go to stub
  4405                                  					; End - M004
  4406                                  ;SYSTEM_CALL ENDP
  4407                                  
  4408                                  ; DOSCODE:424Ch (MSDOS 6.21, MSDOS.SYS)
  4409                                  ; 04/11/2022
  4410                                  ; DOSCODE:423Fh (MSDOS 5.0, MSDOS.SYS)
  4411                                  
  4412                                  ; ==========================================================================
  4413                                  ;
  4414                                  ; Restore_World restores all registers ('cept SS:SP, CS:IP, flags) from
  4415                                  ; the stack prior to giving the user control
  4416                                  ;
  4417                                  ; ==========================================================================
  4418                                  
  4419                                  ; 01/05/2019 - Retro DOS v4.0
  4420                                  
  4421                                          ;procedure restore_world,NEAR
  4422                                  restore_world:
  4423                                  	;getdseg <es>		; es -> dosdata
  4424 0000044B 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4425                                  
  4426 00000450 268F06[EE05]                    POP	WORD [ES:RESTORE_TMP]
  4427                                  
  4428 00000455 58                              POP     AX
  4429 00000456 5B                              POP     BX
  4430 00000457 59                              POP     CX
  4431 00000458 5A                              POP     DX
  4432 00000459 5E                              POP     SI
  4433 0000045A 5F                              POP     DI
  4434 0000045B 5D                              POP     BP
  4435 0000045C 1F                              POP     DS
  4436                                  
  4437 0000045D 26FF26[EE05]                   	jmp	word [ES:RESTORE_TMP]
  4438                                  
  4439                                  ;restore_world	ENDP
  4440                                  
  4441                                  ; 01/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDISP.ASM, 1991)
  4442                                  
  4443                                  ; DOSCODE:4263h (MSDOS 6.21, MSDOS.SYS)
  4444                                  ; 04/11/2022
  4445                                  ; DOSCODE:4256h (MSDOS 5.0, MSDOS.SYS)
  4446                                  
  4447                                  ; ==========================================================================
  4448                                  ;
  4449                                  ; Save_World saves complete registers on the stack
  4450                                  ;
  4451                                  ; ==========================================================================
  4452                                  
  4453                                          ;procedure save_world,NEAR
  4454                                  save_world:
  4455                                  	;getdseg <es>		; es -> dosdata
  4456 00000462 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4457                                  
  4458 00000467 268F06[EE05]                    POP	WORD [ES:RESTORE_TMP]
  4459                                  
  4460                                  	; 12/05/2019
  4461                                          
  4462 0000046C 1E                      	PUSH    DS
  4463 0000046D 55                              PUSH    BP
  4464 0000046E 57                              PUSH    DI
  4465 0000046F 56                              PUSH    SI
  4466 00000470 52                              PUSH    DX
  4467 00000471 51                              PUSH    CX
  4468 00000472 53                              PUSH    BX
  4469 00000473 50                              PUSH    AX
  4470                                  
  4471 00000474 26FF36[EE05]            	push	word [ES:RESTORE_TMP]
  4472                                  
  4473 00000479 55                      	push	BP		
  4474 0000047A 89E5                    	mov	BP,SP
  4475 0000047C 8E4614                  	mov	ES,[BP+20]	; es was pushed before call
  4476 0000047F 5D                      	pop	BP
  4477                                  	
  4478 00000480 C3                      	retn
  4479                                  
  4480                                  ;save_world	ENDP
  4481                                  
  4482                                  ; 01/05/2019
  4483                                  
  4484                                  ; DOSCODE:4282h (MSDOS 6.21, MSDOS.SYS)
  4485                                  ; 04/11/2022
  4486                                  ; DOSCODE:4275h (MSDOS 5.0, MSDOS.SYS)
  4487                                  
  4488                                  ; ==========================================================================
  4489                                  ;
  4490                                  ; Get_User_Stack returns the user's stack (and hence registers) in DS:SI
  4491                                  ;
  4492                                  ; ==========================================================================
  4493                                  
  4494                                          ;procedure get_user_stack,NEAR
  4495                                  Get_User_Stack:
  4496                                          ;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4497 00000481 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4498 00000486 C536[8405]                      lds	si,[USER_SP]
  4499 0000048A C3                      	retn
  4500                                  
  4501                                  ;get_user_stack  ENDP
  4502                                  
  4503                                  ; 22/12/2022
  4504                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
  4505                                  ;%if 0
  4506                                  
  4507                                  ; ---------------------------------------------------------------------------
  4508                                  ;
  4509                                  ; Set_OEM_Handler -- Set OEM sys call address and handle OEM Calls
  4510                                  ; Inputs:
  4511                                  ;	User registers, User Stack, INTS disabled
  4512                                  ;	If CALL F8, DS:DX is new handler address
  4513                                  ; Function:
  4514                                  ;	Process OEM INT 21 extensions
  4515                                  ; Outputs:
  4516                                  ;	Jumps to OEM_HANDLER if appropriate
  4517                                  ;
  4518                                  ; ---------------------------------------------------------------------------
  4519                                  
  4520                                  ;IF	NOT IBM
  4521                                  
  4522                                  _$SET_OEM_HANDLER:
  4523                                  	; 01/05/2019 - Retro DOS v4.0
  4524                                  	
  4525                                  	;(cmp	ah,SET OEM HANDLER  ; 0F8h)
  4526                                  	;(jb	short NOTOOEM)
  4527                                  
  4528 0000048B 06                      	push	es ; *
  4529                                  	;getdseg <es>			; es -> dosdata
  4530 0000048C 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4531                                  
  4532 00000491 750C                    	jne	short check_trueversion_request ; check Retro DOS true version
  4533                                  						; (message) request	
  4534                                  	; AH = 0F8h = SET OEM HANDLER
  4535                                  
  4536 00000493 268916[1400]            	MOV     [es:OEM_HANDLER],DX	; Set Handler
  4537 00000498 268C1E[1600]            	MOV     [es:OEM_HANDLER+2],DS
  4538                                  
  4539 0000049D 07                      	pop	es ; *
  4540                                  
  4541 0000049E CF                      	IRET                            ; Quick return, Have altered no registers
  4542                                  
  4543                                  check_trueversion_request:
  4544                                  	; 18/07/2019 - Retro DOS v3.0
  4545                                  
  4546                                  	; Retro DOS v2.0 - 20/04/2018
  4547 0000049F 83F8FF                  	CMP	AX,0FFFFh
  4548                                  	; 18/07/2018
  4549 000004A2 7520                    	jne	short DO_OEM_FUNC ; 01/05/2019
  4550                                  
  4551                                  	; 01/05/2019
  4552 000004A4 07                      	pop	es ; *
  4553                                  
  4554 000004A5 B40E                    	mov	ah,0Eh
  4555                                  
  4556                                  	; Retro DOS v4.0 feature only!
  4557 000004A7 81FBA101                	cmp	bx,417  ; Signature to bypass
  4558                                  			; Retro DOS true version message	
  4559 000004AB 7414                    	je	short true_version_iret
  4560                                  
  4561 000004AD 56                      	push	si
  4562 000004AE 53                      	push	bx
  4563                                  
  4564 000004AF BE[BF00]                	mov	si,RETRODOSMSG
  4565                                  wrdosmsg:
  4566                                  	;movb	ah,0Eh
  4567 000004B2 BB0700                  	mov	bx,7
  4568                                  wrdosmsg_nxt:
  4569 000004B5 2EAC                    	cs	lodsb
  4570 000004B7 3C24                    	cmp	al,'$'
  4571 000004B9 7404                    	je	short wrdosmsg_ok		
  4572 000004BB CD10                    	int	10h
  4573 000004BD EBF6                    	jmp	short wrdosmsg_nxt
  4574                                  
  4575                                  wrdosmsg_ok:
  4576 000004BF 5B                      	pop	bx
  4577 000004C0 5E                      	pop	si
  4578                                  
  4579                                  true_version_iret:
  4580                                  	; ah = 0Eh
  4581                                  	;mov	al,40h ; Retro DOS v4.0
  4582                                  	; 
  4583                                  	;mov	al,41h ; Retro DOS v4.1 
  4584                                  	; 30/12/2022
  4585 000004C1 B042                    	mov	al,42h ; Retro DOS v4.2
  4586 000004C3 CF                      	iret
  4587                                  
  4588                                  	; If above F8 try to jump to handler
  4589                                  
  4590                                  DO_OEM_FUNC:
  4591                                  	; 01/05/2019
  4592 000004C4 26833E[1400]FF          	cmp     word [es:OEM_HANDLER],-1
  4593 000004CA 7504                    	JNE     short OEM_JMP
  4594 000004CC 07                      	pop	es ; *
  4595 000004CD E910FE                  	JMP     BADCALL                 ; Handler not initialized
  4596                                  OEM_JMP:
  4597 000004D0 06                      	push	es
  4598 000004D1 1F                      	pop	ds ; DOSDATA segment !
  4599 000004D2 07                      	pop	es ; *
  4600                                  
  4601                                  	; 22/12/2022
  4602 000004D3 FB                      	sti	; (enable interrupts before jumping to private handler)  
  4603                                  
  4604 000004D4 FF2E[1400]              	JMP     FAR [OEM_HANDLER]
  4605                                  
  4606                                  ;       ENDIF
  4607                                  
  4608                                  ; ---------------------------------------------------------------------------
  4609                                  
  4610                                  ;%endif
  4611                                  
  4612                                  ;============================================================================
  4613                                  ; MCODE.ASM, MSDOS 6.0, 1991
  4614                                  ;============================================================================
  4615                                  ; 17/07/2018 - Retro DOS v3.0
  4616                                  
  4617                                  ;	TITLE	MISC DOS ROUTINES - Int 25 and 26 handlers and other
  4618                                  ;	NAME	IBMCODE
  4619                                  
  4620                                  ;BREAK <NullDev -- Driver for null device>
  4621                                  
  4622                                  ; ROMDOS note:
  4623                                  ;	NUL device driver used to be here, but it was removed and placed in
  4624                                  ;	DOSDATA, because the entry points have to be in the segment as the
  4625                                  ;	header, which is also in DOSDATA.
  4626                                  
  4627                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>
  4628                                  
  4629                                  ;----------------------------------------------------------------------------
  4630                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
  4631                                  ;----------------------------------------------------------------------------
  4632                                  ; DOSCODE:428Ch (MSDOS 6.21 MSDOS.SYS)
  4633                                  ; DOSCODE:427Fh (MSDOS 5.0 MSDOS.SYS)
  4634                                  
  4635                                  ;Public MSC001S,MSC001E
  4636                                  ;MSC001S label byte
  4637                                  	;IF	IBM
  4638                                  ; Codes returned by BIOS
  4639                                  ERRIN:
  4640 000004D8 02                      	DB	2			; NO RESPONSE
  4641 000004D9 06                      	DB	6			; SEEK FAILURE
  4642 000004DA 0C                      	DB	12			; GENERAL ERROR
  4643 000004DB 04                      	DB	4			; BAD CRC
  4644 000004DC 08                      	DB	8			; SECTOR NOT FOUND
  4645 000004DD 00                      	DB	0			; WRITE ATTEMPT ON WRITE-PROTECT DISK
  4646                                  ERROUT:
  4647                                  ; DISK ERRORS RETURNED FROM INT 25 and 26
  4648 000004DE 80                      	DB	80H			; NO RESPONSE
  4649 000004DF 40                      	DB	40H			; Seek failure
  4650 000004E0 02                      	DB	2			; Address Mark not found
  4651 000004E1 10                      	DB	10H			; BAD CRC
  4652 000004E2 04                      	DB	4			; SECTOR NOT FOUND
  4653 000004E3 03                      	DB	3			; WRITE ATTEMPT TO WRITE-PROTECT DISK
  4654                                  
  4655                                  NUMERR	EQU	$-ERROUT
  4656                                  	;ENDIF
  4657                                  ;MSC001E label byte
  4658                                  ;----------------------------------------------------------------------------
  4659                                  
  4660                                  ;============================================================================
  4661                                  ; MSCODE.ASM - MSDOS 6.0 - 1991
  4662                                  ;============================================================================
  4663                                  ; 18/07/2018 - Retro DOS v3.0
  4664                                  ; 15/05/2019 - Retro DOS v4.0
  4665                                  
  4666                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>>
  4667                                  
  4668                                  ;   AbsSetup - setup for abs disk functions
  4669                                  ;----------------------------------------------------------------------------
  4670                                  
  4671                                  AbsSetup:
  4672                                  	; 02/01/2024
  4673 000004E4 1E                      	push	ds ; *
  4674 000004E5 16                      	push	ss
  4675 000004E6 1F                      	pop	ds
  4676 000004E7 FE06[2103]              	inc	byte [INDOS]
  4677                                  	;INC	byte [SS:INDOS]		; SS override
  4678 000004EB FB                      	STI
  4679 000004EC FC                      	CLD
  4680                                  	; 02/01/2024
  4681                                  	;PUSH	DS
  4682                                  	;push	ss
  4683                                  	;pop	ds
  4684 000004ED E80901                  	CALL	GETBP
  4685                                  	; 02/01/2024
  4686 000004F0 1F                      	pop	ds ; *
  4687 000004F1 7239                    	JC	short errdriv 		; PM. error drive ;AN000;
  4688                                  	;mov	word [es:bp+1Fh]
  4689 000004F3 26C7461FFFFF            	MOV	WORD [ES:BP+DPB.FREE_CNT],-1 ; do not trust user at all.
  4690                                  
  4691                                  	; 02/01/2024
  4692                                  ;errdriv:
  4693                                  ;	POP	DS
  4694                                  ;	jnc	short AbsSetup2
  4695                                  ;AbsSetup_retn:
  4696                                  ;	retn
  4697                                  
  4698                                  AbsSetup2:
  4699                                  	; 15/05/2019 - Retro DOS v4.0
  4700                                  	; MSDOS 6.0
  4701                                  					; SS override
  4702 000004F9 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0 ;>32mb	from API		;AN000;
  4703 00000500 E83504                  	CALL	RW32_CONVERT		;>32mb convert 32bit format to 16bit ;AN000;
  4704 00000503 7227                    	jc	short AbsSetup_retn
  4705 00000505 E85756                  	call	SET_RQ_SC_PARMS 	;LB. set up SC parms		;AN000;
  4706                                  
  4707                                  	; MSDOS 3.3 (& MSDOS 6.0)
  4708 00000508 1E                      	PUSH	DS
  4709 00000509 56                      	PUSH	SI
  4710 0000050A 50                      	PUSH	AX
  4711                                  
  4712 0000050B 16                      	push	ss
  4713 0000050C 1F                      	pop	ds
  4714                                  	
  4715 0000050D BE[BE03]                	MOV	SI,OPENBUF
  4716 00000510 8804                    	MOV	[SI],AL
  4717 00000512 800441                  	ADD	BYTE [SI],"A"
  4718 00000515 C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
  4719 0000051A B80003                  	MOV	AX,0300H
  4720 0000051D F8                      	CLC
  4721 0000051E CD2A                    	INT	int_IBM ; int 2Ah	; Will set carry if shared
  4722                                  		
  4723                                  		; 04/11/2022
  4724                                  		; (INT 2Ah - AX = 0300h)
  4725                                  		; Microsoft Networks - CHECK DIRECT I/O
  4726                                  		; DS:SI -> ASCIIZ disk device name (may be full path or
  4727                                  		;    only drive specifier--must include the colon)
  4728                                  		; Return: CF clear if absolute disk access allowed
  4729                                  
  4730 00000520 58                      	POP	AX
  4731 00000521 5E                      	POP	SI
  4732 00000522 1F                      	POP	DS
  4733 00000523 7307                    	jnc	short AbsSetup_retn
  4734                                  
  4735                                  	;mov	word [ss:EXTERR],32h
  4736 00000525 36C706[2403]3200        	MOV	word [ss:EXTERR],error_not_supported
  4737                                  errdriv:	; 02/01/2024
  4738                                  AbsSetup_retn:
  4739 0000052C C3                      	retn
  4740                                  
  4741                                  ;---------------------------------------------------------------------------
  4742                                  ;
  4743                                  ; Procedure Name : ABSDRD
  4744                                  ;
  4745                                  ; Interrupt 25 handler. Performs absolute disk read.
  4746                                  ; Inputs:	AL - 0-based drive number
  4747                                  ;		DS:BX point to destination buffer
  4748                                  ;		CX number of logical sectors to read
  4749                                  ;		DX starting logical sector number (0-based)
  4750                                  ; Outputs:	Original flags still on stack
  4751                                  ;		Carry set
  4752                                  ;		    AH error from BIOS
  4753                                  ;		    AL same as low byte of DI from INT 24
  4754                                  ;
  4755                                  ;---------------------------------------------------------------------------
  4756                                          ;procedure   ABSDRD,FAR
  4757                                  ABSDRD:
  4758                                  	; 15/05/2019 - Retro DOS v4.0
  4759                                  	; MSDOS 6.21 (DOSCODE:42E5h)
  4760                                  	; 04/11/2022
  4761                                  	; MSDOS 5.0 (DOSCODE:42D8h)
  4762                                  	
  4763                                  	; MSDOS 6.0
  4764 0000052D FA                      	CLI
  4765                                  	
  4766                                  ;	set up ds to point to DOSDATA
  4767                                  
  4768 0000052E 50                      	push	ax			; preserve AX value
  4769 0000052F 8CD8                    	mov	ax,ds			; store DS value in AX
  4770                                  	;getdseg <ds>
  4771 00000531 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4772 00000536 A3[0A0D]                	mov	[TEMPSEG],ax		; store DS value in TEMPSEG
  4773 00000539 58                      	pop	ax			; restore AX value
  4774                                  
  4775                                  	; M072:
  4776                                  	; We shall save es on the user stack here. We need to use ES in
  4777                                  	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
  4778                                  	; time in order to restore the user stack.
  4779                                  
  4780 0000053A 06                      	push	es  ; ****		; M072
  4781                                  
  4782 0000053B 8C16[1B06]              	MOV	[AbsRdWr_SS],SS		; M013
  4783 0000053F 8926[1D06]              	MOV	[AbsRdWr_SP],SP		; M013
  4784                                  
  4785                                  ; 	set up ss to point to DOSDATA
  4786                                  ;
  4787                                  ; NOTE! Due to an obscure bug in the 80286, you cannot use the ROMDOS
  4788                                  ; version of the getdseg macro with the SS register! An interrupt will
  4789                                  ; sneak through.
  4790                                  
  4791                                  ;ifndef ROMDOS
  4792                                  	;getdseg <ss>			; cli in entry of routine
  4793 00000543 2E8E16[0700]            	mov     ss,[cs:DosDSeg]
  4794                                  ;else
  4795                                  ;	mov	ds, cs:[BioDataSeg]
  4796                                  ;	assume	ds:bdata
  4797                                  ;
  4798                                  ;	mov	ss, ds:[DosDataSg]
  4799                                  ;	assume	ss:DOSDATA
  4800                                  ;
  4801                                  ;endif ; ROMDOS
  4802                                  
  4803 00000548 BC[2009]                	MOV	SP,DSKSTACK
  4804                                  
  4805 0000054B 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore DS value
  4806                                  
  4807 0000054F 06                      	push	es ; *** (MSDOS 6.21)
  4808 00000550 E80FFF                  	call	save_world		; save all regs
  4809                                  
  4810 00000553 06                      	PUSH	ES ; **
  4811 00000554 E88DFF                  	CALL	AbsSetup
  4812 00000557 723D                    	JC	short ILEAVE
  4813                                  
  4814                                  	; Here is a gross temporary fix to get around a serious design flaw in
  4815                                  	;  the secondary cache. The secondary cache does not check for media
  4816                                  	;  changed (it should). Hence, you can change disks, do an absolute
  4817                                  	;  read, and get data from the previous disk. To get around this,
  4818                                  	;  we just won't use the secondary cache for absolute disk reads.
  4819                                  	;                                                      -mw 8/5/88
  4820                                  
  4821                                  	;EnterCrit critDisk
  4822 00000559 E8B50D                  	call	ECritDisk
  4823 0000055C 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC  ;AN000;
  4824                                  	;LeaveCrit critDisk
  4825 00000562 E8C70D                  	call	LCritDisk
  4826                                  
  4827                                          ;invoke	DSKREAD
  4828 00000565 E81732                  	CALL	DSKREAD
  4829 00000568 7513                            jnz	short ERR_LEAVE		;Jump if read unsuccessful.
  4830                                  
  4831 0000056A 89F9                            mov     cx,di
  4832 0000056C 368C1E[0E06]                    mov     [ss:TEMP_VAR2],ds
  4833 00000571 36891E[0C06]                    mov     [ss:TEMP_VAR],bx
  4834                                  
  4835                                  ;       CX = # of contiguous sectors read. (These constitute a block of
  4836                                  ;            sectors, also termed an "Extent".)
  4837                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
  4838                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
  4839                                  ;       ES:BP -> Drive Parameter Block (DPB).
  4840                                  ;
  4841                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
  4842                                  ;	buffers must be "read" into the transfer memory block, so that the
  4843                                  ;       transfer memory reflects the most recent data.
  4844                                  
  4845                                  	;invoke	DskRdBufScan		;This trashes DS, but don't care.
  4846 00000576 E85634                          call	DskRdBufScan
  4847 00000579 EB1B                    	jmp     short ILEAVE
  4848                                  
  4849                                  TLEAVE:
  4850 0000057B 7419                    	JZ	short ILEAVE
  4851                                  
  4852                                  ERR_LEAVE:				; M039
  4853                                  	; 15/07/2018 - Retro DOS v3.0
  4854                                          ;IF	IBM
  4855                                  ; Translate the error code to ancient 1.1 codes
  4856 0000057D 06                              PUSH    ES ; *
  4857 0000057E 0E                              PUSH    CS
  4858 0000057F 07                              POP     ES
  4859 00000580 30E4                            XOR     AH,AH			; Nul error code
  4860                                  	;mov	cx,6
  4861 00000582 B90600                          MOV     CX,NUMERR		; Number of possible error conditions
  4862 00000585 BF[D804]                        MOV     DI,ERRIN		; Point to error conditions
  4863 00000588 F2AE                            REPNE   SCASB
  4864 0000058A 7504                            JNZ     SHORT LEAVECODE		; Not found
  4865                                  	;mov	ah,[ES:DI+5]
  4866 0000058C 268A6505                        MOV     AH,[ES:DI+NUMERR-1]	; Get translation
  4867                                  LEAVECODE:
  4868 00000590 07                              POP     ES ; *
  4869                                  	; 15/05/2019 - Retro DOS v4.0
  4870 00000591 36A3[B80D]              	mov	[ss:AbsDskErr],ax
  4871                                          ;ENDIF
  4872                                  
  4873 00000595 F9                              STC
  4874                                  ILEAVE:
  4875                                  	; 15/05/2019
  4876 00000596 07                              POP     ES ; **
  4877 00000597 E8B1FE                  	call	restore_world
  4878 0000059A 07                              pop	es ; *** (MSDOS 6.21)
  4879 0000059B FA                      	CLI
  4880 0000059C 36A1[B80D]              	mov     ax,[ss:AbsDskErr]	; restore error
  4881 000005A0 36FE0E[2103]            	DEC	BYTE [SS:INDOS]
  4882 000005A5 16                              push	ss			; M072 - Start
  4883 000005A6 07                      	pop	es			; es - dosdata
  4884 000005A7 268E16[1B06]                    mov	ss,[es:AbsRdWr_SS]	; M013
  4885 000005AC 268B26[1D06]            	mov	sp,[es:AbsRdWr_SP]	; M013
  4886 000005B1 07                      	pop	es  ; ****		; Note es was saved on user
  4887                                  					; stack at entry 
  4888                                  					; M072 - End
  4889 000005B2 FB                              STI
  4890 000005B3 CB                      	RETF   ; ! FAR return !
  4891                                  
  4892                                  ;ABSDRD	ENDP
  4893                                  
  4894                                  ;---------------------------------------------------------------------------
  4895                                  ;
  4896                                  ; Procedure Name : ABSDWRT
  4897                                  ;
  4898                                  ; Interrupt 26 handler. Performs absolute disk write.
  4899                                  ; Inputs:	AL - 0-based drive number
  4900                                  ;		DS:BX point to source buffer
  4901                                  ;		CX number of logical sectors to write
  4902                                  ;		DX starting logical sector number (0-based)
  4903                                  ; Outputs:	Original flags still on stack
  4904                                  ;		Carry set
  4905                                  ;		    AH error from BIOS
  4906                                  ;		    AL same as low byte of DI from INT 24
  4907                                  ;
  4908                                  ;---------------------------------------------------------------------------
  4909                                          ;procedure   ABSDWRT,FAR
  4910                                  ABSDWRT:
  4911                                  	; 15/05/2019 - Retro DOS v4.0
  4912                                  	; MSDOS 6.21 (DOSCODE:436Ch)
  4913                                  	; 04/11/2022
  4914                                  	; MSDOS 5.0 (DOSCODE:435Fh)
  4915                                  
  4916 000005B4 FA                      	CLI
  4917                                  
  4918                                  ;	set up ds to point to DOSDATA
  4919                                  
  4920 000005B5 50                      	push	ax
  4921 000005B6 8CD8                    	mov	ax,ds
  4922                                  	;getdseg <ds>
  4923 000005B8 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4924 000005BD A3[0A0D]                	mov	[TEMPSEG],ax
  4925 000005C0 58                      	pop	ax
  4926                                  
  4927                                  	; M072:
  4928                                  	; We shall save es on the user stack here. We need to use ES in
  4929                                  	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
  4930                                  	; time in order to restore the user stack.
  4931                                  
  4932 000005C1 06                      	push	es ; ****		; M072
  4933                                  
  4934 000005C2 8C16[1B06]              	MOV	[AbsRdWr_SS],SS		; M013
  4935 000005C6 8926[1D06]              	MOV	[AbsRdWr_SP],SP		; M013
  4936                                  
  4937                                  	; set up ss to point to DOSDATA
  4938                                  	;
  4939                                  	; NOTE! Due to an obscure bug in the 80286, you cannot use the 
  4940                                  	; ROMDOS version of the getdseg macro with the SS register!
  4941                                  	; An interrupt will sneak through.
  4942                                  
  4943                                  ;ifndef ROMDOS
  4944                                  	;getdseg <ss>			; cli in entry of routine
  4945 000005CA 2E8E16[0700]            	mov     ss,[cs:DosDSeg]
  4946                                  ;else
  4947                                  ;	mov	ds, cs:[BioDataSeg]
  4948                                  ;	assume	ds:bdata
  4949                                  ;
  4950                                  ;	mov	ss, ds:[DosDataSg]
  4951                                  ;	assume	ss:DOSDATA
  4952                                  ;
  4953                                  ;endif ; ROMDOS
  4954                                  
  4955 000005CF BC[2009]                	MOV	SP,DSKSTACK
  4956                                  		; we are now switched to DOS's disk stack
  4957                                  
  4958 000005D2 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore user's ds
  4959                                  
  4960 000005D6 06                      	push	es ; *** (MSDOS 6.21)
  4961                                  
  4962 000005D7 E888FE                  	call	save_world	      	; save all regs
  4963                                  
  4964 000005DA 06                      	PUSH	ES ; **
  4965 000005DB E806FF                  	CALL	AbsSetup
  4966 000005DE 72B6                    	JC	short ILEAVE
  4967                                  
  4968                                  	;EnterCrit critDisk
  4969 000005E0 E82E0D                  	call	ECritDisk
  4970 000005E3 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC ;AN000;
  4971 000005E9 E89103                  	CALL	Fastxxx_Purge		 ; purge fatopen ;AN000;
  4972                                  	;LeaveCrit critDisk
  4973 000005EC E83D0D                  	call	LCritDisk
  4974                                  
  4975                                  ;M039
  4976                                  ;       DS:BX = transfer address (source data address).
  4977                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
  4978                                  ;	     sectors, also termed an "Extent".)
  4979                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
  4980                                  ;       ES:BP -> Drive Parameter Block (DPB).
  4981                                  ;       [CURSC_DRIVE] = -1 (invalid drive).
  4982                                  ;
  4983                                  ;       Free any buffered sectors which are in Extent; they are being over-
  4984                                  ;       written. Note that all the above registers are preserved for
  4985                                  ;       DSKWRITE.
  4986                                  
  4987 000005EF 1E                              push    ds
  4988                                  	;invoke	DskWrtBufPurge          ;This trashes DS.
  4989 000005F0 E8F336                  	call	DskWrtBufPurge
  4990 000005F3 1F                              pop     ds
  4991                                  ;M039
  4992                                  	;invoke	DSKWRITE
  4993 000005F4 E8B131                  	call	DSKWRITE
  4994 000005F7 EB82                    	JMP	short TLEAVE
  4995                                  
  4996                                  ;ABSDWRT ENDP
  4997                                  
  4998                                  ;----------------------------------------------------------------------------
  4999                                  ;
  5000                                  ; Procedure Name : GETBP
  5001                                  ;
  5002                                  ; Inputs:
  5003                                  ;	AL = Logical unit number (A = 0)
  5004                                  ; Function:
  5005                                  ;	Find Drive Parameter Block
  5006                                  ; Outputs:
  5007                                  ;	ES:BP points to DPB
  5008                                  ;	[THISDPB] = ES:BP
  5009                                  ;	Carry set if unit number bad or unit is a NET device.
  5010                                  ;		Later case sets extended error error_I24_not_supported
  5011                                  ; No other registers alteredjjj
  5012                                  ;
  5013                                  ;----------------------------------------------------------------------------
  5014                                  
  5015                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5016                                  GETBP:
  5017                                  	; 15/05/2019 - Retro DOS v4.0
  5018                                  	; 11/07/2018 - Retro DOS v3.0
  5019 000005F9 50                      	PUSH	AX
  5020 000005FA 0401                    	ADD	AL, 1		; No increment; need carry flag
  5021 000005FC 7216                    	JC	SHORT SKIPGET
  5022 000005FE E8B664                  	CALL	GETTHISDRV
  5023                                  	; MSDOS 6.0
  5024 00000601 7311                    	JNC	SHORT SKIPGET		;PM. good drive		;AN000;
  5025 00000603 30E4                    	XOR	AH,AH			;DCR. ax= error code 	;AN000;
  5026 00000605 83F81A                  	CMP	AX,error_not_DOS_disk	;DCR. is unknown media ? ;AN000;
  5027 00000608 740A                    	JZ	SHORT SKIPGET 		;DCR. yes, let it go 	;AN000;
  5028 0000060A F9                      	STC				;DCR.			;AN000;
  5029 0000060B A3[2403]                	MOV	[EXTERR],AX	;PM. invalid drive or Non DOS drive ;AN000;
  5030 0000060E C706[B80D]0102          	MOV	WORD [AbsDskErr],201h
  5031                                  SKIPGET:
  5032 00000614 58                      	POP	AX
  5033 00000615 7212                    	JC	SHORT GETBP_RETN ; 15/12/2022
  5034                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  5035                                  	;jnc	short getbp_t
  5036                                  	;retn
  5037                                  getbp_t:
  5038 00000617 C42E[A205]              	LES	BP,[THISCDS]
  5039                                  	; 15/12/2022
  5040 0000061B 26F6464480              	test	byte [es:bp+curdir.flags+1],curdir_isnet>>8
  5041                                  	; 07/12/2022
  5042                                  	;TEST	WORD [ES:BP+43H],8000H
  5043                                  	;TEST	WORD [ES:BP+curdir.flags],curdir_isnet ; Clears carry
  5044 00000620 7408                    	JZ	SHORT GETBP_CDS
  5045 00000622 C706[2403]3200          	MOV	WORD [EXTERR],error_not_supported  ; 32h
  5046 00000628 F9                      	STC
  5047                                  GETBP_RETN:
  5048 00000629 C3                      	RETN
  5049                                  
  5050                                  GETBP_CDS:
  5051                                  	;LES	BP,[ES:BP+45H]
  5052 0000062A 26C46E45                	LES	BP,[ES:BP+curdir.devptr]
  5053                                  GOTDPB:
  5054                                  	; Load THISDPB from ES:BP
  5055 0000062E 892E[8A05]              	MOV	[THISDPB],BP
  5056 00000632 8C06[8C05]              	MOV	[THISDPB+2],ES
  5057 00000636 C3                      	RETN
  5058                                  
  5059                                  ;BREAK <SYS_RET_OK SYS_RET_ERR CAL_LK ETAB_LK set system call returns>
  5060                                  
  5061                                  ;----------------------------------------------------------------------------
  5062                                  ;
  5063                                  ; Procedure Name : SYS_RETURN
  5064                                  ;
  5065                                  ; These are the general system call exit mechanisms. All internal system
  5066                                  ; calls will transfer (jump) to one of these at the end. Their sole purpose
  5067                                  ; is to set the user's flags and set his AX register for return.
  5068                                  ;
  5069                                  ;----------------------------------------------------------------------------
  5070                                  
  5071                                          ;procedure   SYS_RETURN,NEAR
  5072                                  SYS_RETURN:        
  5073                                          ;entry	SYS_RET_OK
  5074                                  SYS_RET_OK:   
  5075 00000637 E847FE                  	call    Get_User_Stack
  5076                                  		; turn off user's carry flag
  5077                                  SYS_RET_OK_clc: ; 25/06/2019 
  5078                                          ;;and	word [SI+16h],0FFFEh 
  5079                                  	;and	word [SI+user_env.user_F],~f_Carry 
  5080                                          ; 25/06/2019
  5081 0000063A 806416FE                	and	byte [SI+user_env.user_F],~f_Carry ; 0FEh
  5082 0000063E EB10                    	JMP     SHORT DO_RET
  5083                                  
  5084                                          ;entry   SYS_RET_ERR
  5085                                  SYS_RET_ERR:        
  5086 00000640 30E4                    	XOR     AH,AH 		; hack to allow for smaller error rets
  5087 00000642 E86C00                  	call	ETAB_LK 	; Make sure code is OK, EXTERR gets set
  5088 00000645 E81A00                  	CALL	ErrorMap
  5089                                  
  5090                                  	;entry	From_GetSet
  5091                                  From_GetSet:
  5092 00000648 E836FE                          call    Get_User_Stack
  5093                                  		 ; signal carry to user
  5094                                  	;;or	word [SI+16h],1
  5095                                  	;OR	word [SI+user_env.user_F],f_Carry
  5096                                  	; 25/06/2019
  5097 0000064B 804C1601                	or	byte [SI+user_env.user_F],f_Carry
  5098 0000064F F9                      	STC			; also, signal internal error
  5099                                  DO_RET:
  5100                                          ;MOV	[SI+user_env.user_AX],AX ; Really only sets AH
  5101 00000650 8904                    	MOV	[SI],AX
  5102 00000652 C3                      	RETN
  5103                                  
  5104                                  	;entry	FCB_RET_OK
  5105                                  FCB_RET_OK:
  5106                                  	;entry	NO_OP		; obsolete system calls dispatch to here
  5107                                  NO_OP:
  5108 00000653 30C0                    	XOR	AL,AL
  5109 00000655 C3                      	retn
  5110                                  
  5111                                  	;entry	FCB_RET_ERR
  5112                                  FCB_RET_ERR:
  5113 00000656 30E4                    	XOR	AH,AH
  5114 00000658 36A3[2403]              	mov	[ss:EXTERR],AX
  5115 0000065C E80300                  	CALL	ErrorMap
  5116 0000065F B0FF                    	MOV	AL,-1
  5117 00000661 C3                      	retn
  5118                                  
  5119                                  	;entry	ErrorMap
  5120                                  ErrorMap:
  5121 00000662 56                      	PUSH	SI
  5122                                  				; ERR_TABLE_21 is now in DOSDATA
  5123 00000663 BE[DB0D]                	MOV	SI,ERR_TABLE_21
  5124                                  				; SS override for FAILERR and EXTERR
  5125 00000666 36803E[4A03]00          	CMP	byte [SS:FAILERR],0 ; Check for SPECIAL case.
  5126 0000066C 7407                    	JZ	short EXTENDED_NORMAL ; All is OK.
  5127                                  		 ; Ooops, this is the REAL reason
  5128                                  	;mov	word [SS:EXTERR],53h
  5129 0000066E 36C706[2403]5300        	MOV	word [SS:EXTERR],error_FAIL_I24
  5130                                  EXTENDED_NORMAL:
  5131 00000675 E80200                  	call	CAL_LK		; Set CLASS,ACTION,LOCUS for EXTERR
  5132 00000678 5E                      	POP	SI
  5133 00000679 C3                      	retn
  5134                                  
  5135                                  	;EndProc SYS_RETURN
  5136                                  
  5137                                  ;---------------------------------------------------------------------------
  5138                                  ;
  5139                                  ; Procedure Name : CAL_LK
  5140                                  ;
  5141                                  ; Inputs:
  5142                                  ;	SI is OFFSET in DOSDATA of CLASS,ACTION,LOCUS Table to use
  5143                                  ;		(DS NEED not be DOSDATA)
  5144                                  ;	[EXTERR] is set with error
  5145                                  ; Function:
  5146                                  ;	Look up and set CLASS ACTION and LOCUS values for GetExtendedError
  5147                                  ; Outputs:
  5148                                  ;	[EXTERR_CLASS] set
  5149                                  ;	[EXTERR_ACTION] set
  5150                                  ;	[EXTERR_LOCUS] set  (EXCEPT on certain errors as determined by table)
  5151                                  ; Destroys SI, FLAGS
  5152                                  ;
  5153                                  ;---------------------------------------------------------------------------
  5154                                  
  5155                                  	;procedure CAL_LK,NEAR
  5156                                  CAL_LK:
  5157 0000067A 1E                      	PUSH	DS
  5158 0000067B 50                      	PUSH	AX
  5159 0000067C 53                      	PUSH	BX
  5160                                  
  5161                                  ;M048	Context DS		; DS:SI -> Table
  5162                                  ;
  5163                                  ; Since this function can be called thru int 2f we shall not assume that SS
  5164                                  ; is DOSDATA
  5165                                  
  5166                                  	;getdseg  <ds>	; M048: DS:SI -> Table
  5167                                  	; 15/05/2019 - Retro DOS v4.0
  5168 0000067D 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5169                                  
  5170                                  	; 18/07/2018
  5171                                  	;push	ss
  5172                                  	;pop	ds
  5173                                  
  5174 00000682 8B1E[2403]              	MOV	BX,[EXTERR]	; Get error in BL
  5175                                  TABLK1:
  5176 00000686 AC                      	LODSB
  5177                                  
  5178 00000687 3CFF                    	CMP	AL,0FFH
  5179 00000689 7409                    	JZ	short GOT_VALS	; End of table
  5180 0000068B 38D8                    	CMP	AL,BL
  5181 0000068D 7405                    	JZ	short GOT_VALS	; Got entry
  5182 0000068F 83C603                  	ADD	SI,3		; Next table entry
  5183                                  	; 15/08/2018
  5184 00000692 EBF2                    	JMP	short TABLK1
  5185                                  
  5186                                  GOT_VALS:
  5187 00000694 AD                      	LODSW			; AL is CLASS, AH is ACTION
  5188                                  
  5189 00000695 80FCFF                  	CMP	AH,0FFH
  5190 00000698 7404                    	JZ	short NO_SET_ACT
  5191 0000069A 8826[2603]              	MOV	[EXTERR_ACTION],AH ; Set ACTION
  5192                                  NO_SET_ACT:
  5193 0000069E 3CFF                    	CMP	AL,0FFH
  5194 000006A0 7403                    	JZ	short NO_SET_CLS
  5195 000006A2 A2[2703]                	MOV	[EXTERR_CLASS],AL ; Set CLASS
  5196                                  NO_SET_CLS:
  5197 000006A5 AC                      	LODSB			; Get LOCUS
  5198                                  
  5199 000006A6 3CFF                    	CMP	AL,0FFH
  5200 000006A8 7403                    	JZ	short NO_SET_LOC
  5201 000006AA A2[2303]                	MOV	[EXTERR_LOCUS],AL
  5202                                  NO_SET_LOC:
  5203 000006AD 5B                      	POP	BX
  5204 000006AE 58                      	POP	AX
  5205 000006AF 1F                      	POP	DS
  5206 000006B0 C3                      	retn
  5207                                  
  5208                                  	;EndProc CAL_LK
  5209                                  
  5210                                  ;---------------------------------------------------------------------------
  5211                                  ;
  5212                                  ; Procedure Name : ETAB_LK
  5213                                  ;
  5214                                  ; Inputs:
  5215                                  ;	AX is error code
  5216                                  ;	[USER_IN_AX] has AH value of system call involved
  5217                                  ; Function:
  5218                                  ;	Make sure error code is appropriate to this call.
  5219                                  ; Outputs:
  5220                                  ;	AX MAY be mapped error code
  5221                                  ;	[EXTERR] = Input AX
  5222                                  ; Destroys ONLY AX and FLAGS
  5223                                  ;
  5224                                  ;---------------------------------------------------------------------------
  5225                                  
  5226                                  	;procedure ETAB_LK,NEAR
  5227                                  
  5228                                  ETAB_LK: ; 10/08/2018 - Retro DOS v3.0
  5229 000006B1 1E                      	PUSH	DS
  5230 000006B2 56                      	PUSH	SI
  5231 000006B3 51                      	PUSH	CX
  5232 000006B4 53                      	PUSH	BX
  5233                                  
  5234                                  	;Context DS			; SS is DOSDATA
  5235                                  
  5236 000006B5 16                      	push	ss
  5237 000006B6 1F                      	pop	ds
  5238                                  
  5239 000006B7 A3[2403]                	MOV	[EXTERR],AX		; Set EXTERR with "real" error
  5240                                  
  5241                                  					; I21_MAP_E_TAB is now in DOSCODE
  5242 000006BA BE[0B00]                	MOV	SI,I21_MAP_E_TAB
  5243 000006BD 88C7                    	MOV	BH,AL			; Real code to BH
  5244 000006BF 8A1E[3B03]              	MOV	BL,[USER_IN_AX+1]	; Sys call to BL
  5245                                  TABLK2:
  5246                                  	; 15/05/2019 - Retro DOS v4.0
  5247 000006C3 2E                      	cs
  5248 000006C4 AD                      	lodsw	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:447Dh)
  5249                                  	
  5250                                  	; 18/07/2018 - Retro DOS v3.0
  5251                                  	;lodsw		; IBMDOS.COM (MSDOS 3.3) - Offset 16F7h
  5252                                  
  5253 000006C5 3CFF                    	CMP	AL,0FFH 		; End of table?
  5254 000006C7 740C                    	JZ	short NOT_IN_TABLE	; Yes
  5255 000006C9 38D8                    	CMP	AL,BL			; Found call?
  5256 000006CB 740C                    	JZ	short GOT_CALL		; Yes
  5257 000006CD 86E0                    	XCHG	AH,AL			; Count to AL
  5258 000006CF 30E4                    	XOR	AH,AH			; Make word for add
  5259 000006D1 01C6                    	ADD	SI,AX			; Next table entry
  5260 000006D3 EBEE                    	JMP	short TABLK2
  5261                                  
  5262                                  NOT_IN_TABLE:
  5263 000006D5 88F8                    	MOV	AL,BH			; Restore original code
  5264 000006D7 EB0C                    	JMP	SHORT NO_MAP
  5265                                  
  5266                                  GOT_CALL:
  5267 000006D9 88E1                    	MOV	CL,AH
  5268 000006DB 30ED                    	XOR	CH,CH			; Count of valid err codes to CX
  5269                                  CHECK_CODE:
  5270                                  	; 15/05/2019 - Retro DOS v4.0
  5271 000006DD 2E                      	cs
  5272 000006DE AC                      	lodsb	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:4497h)
  5273                                  
  5274                                  	; 18/07/2018
  5275                                  	;lodsb		; IBMDOS.COM (MSDOS 3.3) - Offset 1710h
  5276                                  
  5277 000006DF 38F8                    	CMP	AL,BH			; Code OK?
  5278 000006E1 7402                    	JZ	short NO_MAP		; Yes
  5279 000006E3 E2F8                    	LOOP	CHECK_CODE
  5280                                  NO_MAP:
  5281 000006E5 30E4                    	XOR	AH,AH			; AX is now valid code
  5282 000006E7 5B                      	POP	BX
  5283 000006E8 59                      	POP	CX
  5284 000006E9 5E                      	POP	SI
  5285 000006EA 1F                      	POP	DS
  5286 000006EB C3                      	retn
  5287                                  
  5288                                  	;EndProc ETAB_LK
  5289                                  
  5290                                  ; 18/07/2018 - Retro DOS v3.0
  5291                                  ;---------------------------------------------------------------------------
  5292                                  ; BREAK <DOS 2F Handler and default NET 2F handler>
  5293                                  
  5294                                  ;IF installed ; (*)
  5295                                  
  5296                                  ;---------------------------------------------------------------------------
  5297                                  ;
  5298                                  ; Procedure Name : SetBad
  5299                                  ;
  5300                                  ; SetBad sets up info for bad functions
  5301                                  ;
  5302                                  ;---------------------------------------------------------------------------
  5303                                  
  5304                                  SetBad:
  5305                                  	;mov	ax,1
  5306 000006EC B80100                  	MOV	AX,error_invalid_function ; ALL NET REQUESTS get inv func
  5307                                  
  5308                                  	; MSDOS 3.3
  5309                                  	;;mov	byte [cs:EXTERR_LOCUS],1
  5310                                  	;MOV	byte [CS:EXTERR_LOCUS],errLOC_Unk
  5311                                  
  5312                                  ;	set up ds to point to DOSDATA
  5313                                  
  5314                                  	; 15/05/2019 - Retro DOS v4.0
  5315                                  	; MSDOS 6.0
  5316 000006EF 1E                      	push	ds
  5317                                  
  5318                                  	;getdseg <ds>
  5319 000006F0 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5320                                  
  5321 000006F5 C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1	
  5322                                  
  5323 000006FA 1F                      	pop	ds	  	;hkn; restore ds
  5324                                  
  5325 000006FB F9                      	STC
  5326 000006FC C3                      	retn
  5327                                  
  5328                                  ;--------------------------------------------------------------------------
  5329                                  ;
  5330                                  ; Procedure Name : BadCall
  5331                                  ;
  5332                                  ; BadCall is the initial routine for bad function calls
  5333                                  ;
  5334                                  ;--------------------------------------------------------------------------
  5335                                  
  5336                                  BadCall:
  5337 000006FD E8ECFF                  	call	SetBad
  5338 00000700 CB                      	retf
  5339                                  
  5340                                  ;--------------------------------------------------------------------------
  5341                                  ;
  5342                                  ; OKCall always sets carry to off.
  5343                                  ;
  5344                                  ;-----------------------------------------------------------------------
  5345                                  
  5346                                  OKCall:
  5347 00000701 F8                      	CLC
  5348 00000702 CB                      	retf
  5349                                  
  5350                                  ;---------------------------------------------------------------------------
  5351                                  ;
  5352                                  ; Procedure Name : INT2F
  5353                                  ;
  5354                                  ; INT 2F handler works as follows:
  5355                                  ;   PUSH    AX
  5356                                  ;   MOV     AX,multiplex:function
  5357                                  ;   INT     2F
  5358                                  ;   POP     ...
  5359                                  ; The handler itself needs to make the AX available for the various routines.
  5360                                  ;
  5361                                  ;----------------------------------------------------------------------------
  5362                                  
  5363                                  ; 15/05/2019 - Retro DOS v4.0
  5364                                  
  5365                                  ;KERNEL_SEGMENT equ 70h
  5366                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5367                                  DOSBIODATASEG equ 70h
  5368                                  
  5369                                  ; retrodos4.s - offset in BIOSDATA
  5370                                  bios_i2f equ 5
  5371                                  
  5372                                  ;PUBLIC	Int2F
  5373                                  ;INT2F	PROC	FAR
  5374                                  
  5375                                  ; 15/05/2019
  5376                                  ; DOSCODE:44BDh (MSDOS 6.21, MSDOS.SYS)
  5377                                  
  5378                                  ; 04/11/2022
  5379                                  ; DOSCODE:44B0h (MSDOS 5.0, MSDOS.SYS)
  5380                                  
  5381                                  	; 05/01/2024
  5382                                  	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5383                                  	; 18/07/2018 - Retro DOS v3.0
  5384                                  INT2F:
  5385                                  	; Offset 172Fh in IBMDOS.COM (MSDOS 3.3), 1987
  5386                                  INT2FNT:
  5387                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5388 00000703 FB                      	STI
  5389                                  	;cmp	ah,11h
  5390 00000704 80FC11                  	CMP	AH,MultNET
  5391 00000707 750A                    	JNZ	short INT2FSHR
  5392                                  TestInstall:
  5393 00000709 08C0                    	OR	AL,AL
  5394 0000070B 7403                    	JZ	short Leave2F
  5395                                  BadFunc:
  5396 0000070D E8DCFF                  	CALL	SetBad
  5397                                  
  5398                                  	;entry	Leave2F
  5399                                  Leave2F:
  5400 00000710 CA0200                  	RETF	2			; long return + clear flags off stack
  5401                                  
  5402                                  INT2FSHR:
  5403                                  	;cmp	ah,10h
  5404 00000713 80FC10                  	CMP	AH,MultSHARE		; is this a share request
  5405 00000716 74F1                    	JZ	short TestInstall	; yes, check for installation
  5406                                  INT2FNLS:
  5407                                  	;cmp	ah,14h
  5408 00000718 80FC14                  	CMP	AH,NLSFUNC		; is this a DOS 3.3 NLSFUNC request
  5409 0000071B 74EC                    	JZ	short TestInstall	; yes check for installation
  5410                                  INT2FDOS:
  5411                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5412                                  
  5413                                  	; 18/07/2018
  5414                                  	; MSDOS 3.3
  5415                                  	;;cmp	ah,12h	
  5416                                  	;CMP	AH,MultDOS
  5417                                  	;jz	short DispatchDOS
  5418                                  	;iret
  5419                                  
  5420                                  	; 15/05/2019
  5421                                  	; MSDOS 6.0
  5422                                  	;cmp	ah,12h	; 07/12/2022
  5423 0000071D 80FC12                  	CMP	AH,MultDOS
  5424 00000720 7503                    	JNZ	short check_win		;check if win386 broadcast
  5425 00000722 E9F201                  	jmp	DispatchDOS
  5426                                  
  5427                                  	; .... win386 .... 
  5428                                  
  5429                                  check_win:
  5430                                  	;cmp	ah,16h
  5431 00000725 80FC16                  	cmp	ah,MultWin386		; Is this a broadcast from Win386?
  5432 00000728 7408                    	je	short Win386_Msg
  5433                                  
  5434                                  	; M044
  5435                                  	; Check if the callout is from Winoldap indicating swapping out or in 
  5436                                  	; of Windows. If so, do special action of going and saving last para
  5437                                  	; of the Windows memory arena which Winoldap does not save due to a 
  5438                                  	; bug
  5439                                  
  5440 0000072A 80FC46                  	cmp	ah,WINOLDAP ; 46h	; from Winoldap?
  5441                                  	;jne	short next_i2f		; no, chain on
  5442                                  	; 15/12/2022
  5443                                  	;jmp	winold_swap		; yes, do desired action
  5444 0000072D 7442                    	je	short winold_swap
  5445 0000072F E90501                  	jmp	next_i2f
  5446                                  
  5447                                  	; 15/12/2022
  5448                                  ;next_i2f:
  5449                                  ;	;;;jmp	bios_i2f
  5450                                  ;	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
  5451                                  ;	;jmp	KERNEL_SEGMENT:bios_i2f
  5452                                  ;	; 04/11/2022
  5453                                  ;	jmp	DOSBIODATASEG:bios_i2f
  5454                                  
  5455                                  ;	IRET				; This assume that we are at the head
  5456                                  					; of the list
  5457                                  ;INT2F	ENDP
  5458                                  
  5459                                  ; 15/05/2019 - Retro DOS v4.0
  5460                                  
  5461                                  ; We have received a message from Win386. There are three possible
  5462                                  ; messages we could get from Win386:
  5463                                  ;
  5464                                  ; Init 		- for this, we set the IsWin386 flag and return a pointer
  5465                                  ;		  to the Win386 startup info structure.
  5466                                  ; Exit		- for this, we clear the IsWin386 flag.
  5467                                  ; DOSMGR query 	- for this, we need to indicate that instance data
  5468                                  ;		  has already been handled. this is indicated by setting
  5469                                  ;		  CX to a non-zero value.
  5470                                  
  5471                                  Win386_Msg:
  5472 00000732 1E                      	push	ds
  5473                                  
  5474                                  	;getdseg <DS>			; ds is DOSDATA
  5475 00000733 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5476                                  
  5477                                  	; For WIN386 2.xx instance data
  5478                                  
  5479 00000738 3C03                    	cmp	al,3			; win386 2.xx instance data call?
  5480 0000073A 7503                    	jne	short Win386_Msg_exit
  5481 0000073C E92A01                  	jmp	OldWin386Init		; yes, return instance data
  5482                                  Win386_Msg_exit:
  5483 0000073F 3C06                    	cmp	al,Win386_Exit	 ; 6	; is it an exit call?
  5484 00000741 7503                    	jne	short Win386_Msg_devcall
  5485 00000743 E92C01                  	jmp	Win386_Leaving
  5486                                  Win386_Msg_devcall:
  5487 00000746 3C07                    	cmp	al,Win386_Devcall ; 7	; is it call from DOSMGR?
  5488 00000748 7503                    	jne	short Win386_Msg_init
  5489 0000074A E96001                  	jmp	Win386_Query
  5490                                  Win386_Msg_init:
  5491 0000074D 3C05                    	cmp	al,Win386_Init	; 5	; is it an init call?
  5492 0000074F 7403                    	je	short Win386_Starting
  5493 00000751 E9E200                  	jmp	win_nexti2f		; no, return
  5494                                  Win386_Starting:
  5495                                  	; 17/12/2022
  5496 00000754 F6C201                  	test	dl,1
  5497                                  	;test	dx,1			; is this really win386?
  5498 00000757 7403                    	jz	short Win386_vchk	; YES! go and handle it
  5499 00000759 E9DA00                  	jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
  5500                                  Win386_vchk:
  5501                                  	; M018 -- start of block changes
  5502                                  	; The VxD needs to be loaded only for Win 3.0. If version is greater 
  5503                                  	; than 030Ah, we skip the VxD presence check
  5504                                  
  5505                                  ;M067 -- Begin changes
  5506                                  ; If Win 3.0 is run, the VxD ptr has been initialized. If Win 3.1 is now
  5507                                  ;run, it tries to unnecesarily load the VxD even though it is not needed.
  5508                                  ;So, we null out the VxD ptr before the check.
  5509                                  
  5510                                  	;mov	word [Win386_Info+6],0
  5511 0000075C C706[E80F]0000          	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],0
  5512                                  	;mov	word [Win386_Info+8],0
  5513 00000762 C706[EA0F]0000          	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],0
  5514                                  
  5515                                  ;M067 -- End changes
  5516                                  
  5517                                  ;ifdef JAPAN
  5518                                  ;	cmp	di,0300h		; version >= 300 i.e 3.10 ;M037
  5519                                  ;else
  5520 00000768 81FF0A03                	cmp	di,030Ah		; version >= 30a i.e 3.10 ;M037
  5521                                  ;endif
  5522                                  	;ljae	noVxD31			; yes, VxD not needed 	 ;M037
  5523 0000076C 724E                    	jb	short Win386_vxd
  5524 0000076E E9DD00                  	jmp	noVxD31
  5525                                  
  5526                                  	; 15/12/2022
  5527                                  winold_swap:
  5528 00000771 1E                      	push	ds
  5529 00000772 06                      	push	es
  5530 00000773 56                      	push	si
  5531 00000774 57                      	push	di
  5532 00000775 51                      	push	cx
  5533                                  
  5534                                  	;getdseg <ds>			;ds = DOSDATA
  5535 00000776 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5536                                  
  5537 0000077B 3C01                    	cmp	al,1			;swap Windows out call
  5538 0000077D 751B                    	jne	short swapin		;no, check if Swap in call
  5539 0000077F E88801                  	call	getwinlast
  5540 00000782 1E                      	push	ds
  5541 00000783 07                      	pop	es
  5542 00000784 8EDE                    	mov	ds,si			;ds = memory arena of Windows
  5543 00000786 31F6                    	xor	si,si
  5544 00000788 BF[0600]                	mov	di,WinoldPatch1
  5545 0000078B B90800                  	mov	cx,8
  5546 0000078E FC                      	cld
  5547 0000078F 51                      	push	cx
  5548 00000790 F3A4                    	rep	movsb			;save first 8 bytes
  5549 00000792 59                      	pop	cx
  5550 00000793 BF[CD0D]                	mov	di,WinoldPatch2
  5551 00000796 F3A4                    	rep	movsb			;save next 8 bytes
  5552 00000798 EB1B                    	jmp	short winold_done
  5553                                  swapin:
  5554 0000079A 3C02                    	cmp	al,2			;swap Windows in call?
  5555 0000079C 7517                    	jne	short winold_done	;no, something else, pass it on
  5556 0000079E E86901                  	call	getwinlast
  5557 000007A1 8EC6                    	mov	es,si
  5558 000007A3 31FF                    	xor	di,di
  5559 000007A5 BE[0600]                	mov	si,WinoldPatch1
  5560 000007A8 B90800                  	mov	cx,8
  5561 000007AB FC                      	cld
  5562 000007AC 51                      	push	cx
  5563 000007AD F3A4                    	rep	movsb			;restore first 8 bytes
  5564 000007AF 59                      	pop	cx
  5565 000007B0 BE[CD0D]                	mov	si,WinoldPatch2
  5566 000007B3 F3A4                    	rep	movsb			;restore next 8 bytes
  5567                                  winold_done:
  5568 000007B5 59                      	pop	cx
  5569 000007B6 5F                      	pop	di
  5570 000007B7 5E                      	pop	si
  5571 000007B8 07                      	pop	es
  5572 000007B9 1F                      	pop	ds
  5573 000007BA EB7B                    	jmp	short next_i2f		;chain on
  5574                                  	; 15/12/2022
  5575                                  	;jmp	next_i2f	
  5576                                  
  5577                                  Win386_vxd:
  5578 000007BC 50                      	push	ax
  5579 000007BD 53                      	push	bx
  5580 000007BE 51                      	push	cx
  5581 000007BF 52                      	push	dx
  5582 000007C0 56                      	push	si
  5583 000007C1 57                      	push	di			; save regs !!dont change order!!
  5584                                  
  5585 000007C2 8B1E[8C00]              	mov	bx,[UMB_HEAD]		; M062 - Start
  5586 000007C6 83FBFF                  	cmp	bx,0FFFFh    		; Q: have umbs been initialized
  5587 000007C9 741F                    	je	short Vxd31		; N: continue
  5588                                  					; Y: save arena associated with 
  5589                                  					;    umb_head
  5590                                  
  5591 000007CB C606[DA0D]01            	mov	byte [UmbSaveFlag],1	; indicate that we're saving 
  5592                                  					; umb_arena
  5593 000007D0 1E                      	push	ds
  5594 000007D1 06                      	push	es
  5595                                  
  5596                                  	;mov	ax,ds
  5597                                  	;mov	es,ax			; es - > dosdata
  5598                                  	; 05/01/2024
  5599 000007D2 1E                      	push	ds
  5600 000007D3 07                      	pop	es
  5601                                  
  5602 000007D4 8EDB                    	mov	ds,bx
  5603 000007D6 31F6                    	xor	si,si			; ds:si -> umb_head
  5604                                  
  5605 000007D8 FC                      	cld
  5606                                  
  5607 000007D9 BF[F511]                	mov	di,UmbSave1
  5608 000007DC B90B00                  	mov	cx,11
  5609 000007DF F3A4                    	rep	movsb
  5610                                  
  5611 000007E1 BF[D50D]                	mov	di,UmbSave2
  5612                                  	;mov	cx,5
  5613                                  	; 18/12/2022
  5614 000007E4 B105                    	mov	cl,5
  5615 000007E6 F3A4                    	rep	movsb	
  5616                                  
  5617 000007E8 07                      	pop	es
  5618 000007E9 1F                      	pop	ds			; M062 - End
  5619                                  
  5620                                  Vxd31:
  5621                                  	;test	byte [DOS_FLAG],2
  5622 000007EA F606[8600]02            	test	byte [DOS_FLAG],SUPPRESS_WINA20	; M066
  5623 000007EF 7408                    	jz	short Dont_Supress		; M066
  5624 000007F1 5F                      	pop	di				; M066
  5625 000007F2 5E                      	pop	si				; M066
  5626 000007F3 5A                      	pop	dx				; M066
  5627 000007F4 59                      	pop	cx				; M066
  5628 000007F5 5B                      	pop	bx				; M066
  5629 000007F6 58                      	pop	ax				; M066
  5630 000007F7 EB55                    	jmp	short noVxD31			; M066
  5631                                  
  5632                                  	; We check here if the VxD is available in the root of the boot drive. 
  5633                                  	; We do an extended open to suppress any error messages
  5634                                  	
  5635                                  Dont_Supress:
  5636 000007F9 A0[6900]                	mov	al,[BOOTDRIVE]
  5637 000007FC 0440                    	add	al,'A' - 1		; get drive letter
  5638 000007FE A2[3110]                	mov	[VxDpath],al		; path is root of bootdrive
  5639                                  	;mov	ah,ExtOpen  ;6Ch	; extended open
  5640                                  	;mov	al,0			; no extended attributes
  5641                                  	; 18/12/2022
  5642 00000801 B8006C                  	mov	ax,ExtOpen<<8 ; 6C00h
  5643 00000804 BB8020                  	mov	bx,2080h		; read access, compatibility mode
  5644                                  					; no inherit, suppress crit err
  5645 00000807 B90700                  	mov	cx,7			; hidden,system,read-only attr
  5646 0000080A BA0100                  	mov	dx,1			; fail if file does not exist
  5647 0000080D BE[3110]                	mov	si,VxDpath	
  5648                                  					; path of VxD file
  5649 00000810 BFFFFF                  	mov	di,0FFFFh		; no extended attributes
  5650                                  
  5651 00000813 CD21                    	int	21h			; do extended open
  5652                                  
  5653 00000815 5F                      	pop	di
  5654 00000816 5E                      	pop	si
  5655 00000817 5A                      	pop	dx
  5656 00000818 59                      	pop	cx
  5657                                  
  5658 00000819 7321                    	jnc	short VxDthere		; we found the VxD, go ahead
  5659                                  
  5660                                  	; We could not find the VxD. Cannot let windows load. Return cx != 0 
  5661                                  	; to indicate error to Windows after displaying message to user that 
  5662                                  	; VxD needs to be present to run Windows in enhanced mode.
  5663                                  
  5664 0000081B 52                      	push	dx
  5665 0000081C 1E                      	push	ds
  5666 0000081D 56                      	push	si
  5667 0000081E BE[B209]                	mov	si,NoVxDErrMsg
  5668 00000821 0E                      	push	cs
  5669 00000822 1F                      	pop	ds
  5670 00000823 B96300                  	mov	cx,VxDMesLen ; 99	;
  5671 00000826 B402                    	mov	ah,2			; write char to console
  5672 00000828 FC                      	cld
  5673                                  vxdlp:
  5674 00000829 AC                      	lodsb
  5675 0000082A 86D0                    	xchg	dl,al			; get char in dl
  5676 0000082C CD21                    	int	21h
  5677 0000082E E2F9                    	loop	vxdlp
  5678                                  
  5679 00000830 5E                      	pop	si
  5680 00000831 1F                      	pop	ds
  5681 00000832 5A                      	pop	dx
  5682 00000833 5B                      	pop	bx
  5683 00000834 58                      	pop	ax			;all registers restored
  5684 00000835 41                      	inc	cx			;cx != 0 to indicate error
  5685                                  	; 15/12/22022
  5686                                  	;jmp	win_nexti2f		;chain on
  5687                                  	;jmp	short win_nexti2f
  5688                                  
  5689                                  	; 15/12/2022
  5690                                  win_nexti2f:
  5691 00000836 1F                      	pop	ds
  5692                                  	;jmp	short next_i2f		; go to BIOS i2f handler
  5693                                  	; 15/12/2022
  5694                                  next_i2f:
  5695                                  	;;;jmp	bios_i2f
  5696                                  	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
  5697                                  	;jmp	KERNEL_SEGMENT:bios_i2f
  5698                                  	; 04/11/2022
  5699 00000837 EA05007000              	jmp	DOSBIODATASEG:bios_i2f
  5700                                  
  5701                                  VxDthere:
  5702 0000083C 89C3                    	mov	bx,ax
  5703 0000083E B43E                    	mov	ah,CLOSE ; 3Eh
  5704 00000840 CD21                    	int	21h			;close the file
  5705                                  
  5706                                  	; Update the VxD ptr in the instance data structure with path to VxD
  5707                                  
  5708                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  5709                                  	;mov	bx,Win386_Info
  5710                                  	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
  5711                                  	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr+2],ds
  5712                                  	; 15/12/2022
  5713 00000842 C706[E80F][3110]        	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
  5714 00000848 8C1E[EA0F]              	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],ds
  5715                                  
  5716 0000084C 5B                      	pop	bx
  5717 0000084D 58                      	pop	ax
  5718                                  noVxD31:
  5719                                  	; M018; End of block changes
  5720                                  
  5721 0000084E 800E[3010]01            	or	byte [IsWin386],1 	; Indicate WIN386 present
  5722 00000853 800E[0C0D]01            	or	byte [redir_patch],1	; Enable critical sections; M002
  5723                                  
  5724                                  	; M002;
  5725                                  	; Save the previous es:bx (instance data ptr) into our instance table
  5726                                  
  5727 00000858 52                      	push	dx			; M002
  5728 00000859 89DA                    	mov	dx,bx			; M002
  5729                                  					; point ES:BX to Win386_Info ; M002
  5730 0000085B BB[E20F]                	mov	bx,Win386_Info 
  5731 0000085E 895702                  	mov	[bx+2],dx		; M002
  5732 00000861 8C4704                  	mov	[bx+4],es		; M002
  5733 00000864 5A                      	pop	dx			; M002
  5734 00000865 1E                      	push	ds			; M002
  5735 00000866 07                      	pop	es			; M002
  5736                                  	;jmp	win_nexti2f		; M002
  5737                                  	; 15/12/2022
  5738 00000867 EBCD                    	jmp	short win_nexti2f
  5739                                  
  5740                                  	; 15/12/2022
  5741                                  	; Code to return Win386 2.xx instance table
  5742                                  OldWin386Init:
  5743 00000869 58                      	pop	ax			; discard ds pushed on stack
  5744 0000086A BE[C811]                	mov	si,OldInstanceJunk 
  5745                                  					; ds:si = instance table
  5746 0000086D B84852                  	mov	ax,5248h ; 'HR'		; indicate instance data present
  5747                                  	;jmp	next_i2f
  5748                                  	; 15/12/2022
  5749 00000870 EBC5                    	jmp	short next_i2f
  5750                                  
  5751                                  Win386_Leaving:
  5752                                  	; 15/12/2022
  5753 00000872 F6C201                  	test 	dl,1
  5754                                  	;test	dx,1			; is this really win386?
  5755                                  	;jz	short Win386_Leaving_c
  5756                                  	;jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
  5757                                  	; 15/12/2022
  5758 00000875 75BF                    	jnz	short win_nexti2f	
  5759                                  
  5760                                  Win386_Leaving_c:
  5761                                  					; M062 - Start
  5762 00000877 803E[DA0D]01            	cmp	byte [UmbSaveFlag],1	; Q: was umb_arena saved at win start
  5763                                  					;    up.
  5764 0000087C 7523                    	jne	short noumb		; N: not saved 
  5765 0000087E C606[DA0D]00            	mov	byte [UmbSaveFlag],0	; Y: clear UmbSaveFlag and restore 
  5766                                  					;    previously saved umb_head
  5767                                  	; 05/01/2024
  5768                                  	;push	ax ; (not necessary)
  5769 00000883 06                      	push	es
  5770 00000884 51                      	push	cx
  5771 00000885 56                      	push	si
  5772 00000886 57                      	push	di
  5773                                  
  5774                                  	;mov	ax,[UMB_HEAD]
  5775                                  	;mov	es,ax
  5776                                  	; 05/01/2024
  5777 00000887 8E06[8C00]              	mov	es,[UMB_HEAD]
  5778 0000088B 31FF                    	xor	di,di			; es:di -> umb_head
  5779                                  
  5780 0000088D FC                      	cld
  5781                                  
  5782 0000088E BE[F511]                	mov	si,UmbSave1
  5783 00000891 B90B00                  	mov	cx,11
  5784 00000894 F3A4                    	rep	movsb
  5785 00000896 BE[D50D]                	mov	si,UmbSave2
  5786                                  	;mov	cx,5
  5787                                  	; 18/12/2022
  5788 00000899 B105                    	mov	cl,5
  5789 0000089B F3A4                    	rep	movsb
  5790                                  
  5791 0000089D 5F                      	pop	di
  5792 0000089E 5E                      	pop	si
  5793 0000089F 59                      	pop	cx
  5794 000008A0 07                      	pop	es
  5795                                  	; 05/01/2024
  5796                                  	;pop	ax
  5797                                  noumb:					; M062 - End
  5798 000008A1 8026[3010]00            	and	byte [IsWin386],0	; Win386 is gone
  5799 000008A6 8026[0C0D]00            	and	byte [redir_patch],0	; Disable critical sections ; M002
  5800 000008AB EB89                    	jmp	short win_nexti2f
  5801                                  
  5802                                  ;	; 15/12/2022
  5803                                  ;	; Code to return Win386 2.xx instance table
  5804                                  ;OldWin386Init:
  5805                                  ;	pop	ax			; discard ds pushed on stack
  5806                                  ;	mov	si,OldInstanceJunk 
  5807                                  ;					; ds:si = instance table
  5808                                  ;	mov	ax,5248h ; 'RH'		; indicate instance data present
  5809                                  ;	;jmp	next_i2f
  5810                                  ;	; 15/12/2022
  5811                                  ;	jmp	short _next_i2f
  5812                                  
  5813                                  Win386_Query:
  5814 000008AD 83FB15                  	cmp	bx,Win386_DOSMGR ; 15h	; is this from DOSMGR?
  5815 000008B0 7584                    	jne	short win_nexti2f     	; no, ignore it & chain to next
  5816 000008B2 09C9                    	or	cx,cx			; is it an instance query?
  5817 000008B4 7508                    	jne	short dosmgr_func	; no, some DOSMGR query
  5818 000008B6 41                      	inc	cx			; indicate that data is instanced
  5819                                  ;
  5820                                  ; M001; We were previously returning a null ptr in es:bx. This will not work.
  5821                                  ; M001; WIN386 needs a ptr to a table in es:bx with the following offsets:
  5822                                  ; M001;  
  5823                                  ; M001; OFFSETS STRUC
  5824                                  ; M001; 	Major_version	db	?
  5825                                  ; M001; 	Minor_version	db	?
  5826                                  ; M001; 	SaveDS		dw	?
  5827                                  ; M001; 	SaveBX		dw	?
  5828                                  ; M001; 	Indos		dw	?
  5829                                  ; M001; 	User_id		dw	?
  5830                                  ; M001; 	CritPatch	dw	?
  5831                                  ; M001; OFFSETS	ENDS
  5832                                  ; M001; 
  5833                                  ; M001; User_Id is the only variable really important for proper functioning  
  5834                                  ; M001; of Win386. The other variables are used at init time to patch stuff
  5835                                  ; M001; out. In DOS 5.0, we do the patching ourselves. But we still need to 
  5836                                  ; M001; pass this table because Win386 depends on this table to get the 
  5837                                  ; M001; User_Id offset.
  5838                                  ; M001; 
  5839 000008B7 BB[2210]                	mov	bx,Win386_DOSVars	; M001 
  5840 000008BA 1E                      	push	ds			; M001
  5841 000008BB 07                      	pop	es			; es:bx points at offset table ; M001
  5842 000008BC EB40                    	jmp	short PopIret		; M001
  5843                                  
  5844                                  ; 15/12/2022
  5845                                  ;	; Code to return Win386 2.xx instance table
  5846                                  ;OldWin386Init:
  5847                                  ;	pop	ax			; discard ds pushed on stack
  5848                                  ;	mov	si,OldInstanceJunk 
  5849                                  ;					; ds:si = instance table
  5850                                  ;	mov	ax,5248h ; 'RH'		; indicate instance data present
  5851                                  ;	;jmp	next_i2f
  5852                                  ;	; 15/12/2022
  5853                                  ;	jmp	short _next_i2f
  5854                                  
  5855                                  dosmgr_func:
  5856 000008BE 49                      	dec	cx
  5857 000008BF 7435                    	jz	short win386_patch	; call to patch DOS
  5858 000008C1 49                      	dec	cx
  5859 000008C2 743A                    	jz	short PopIret		; remove DOS patches, ignore
  5860 000008C4 49                      	dec	cx
  5861 000008C5 7439                    	jz	short win386_size	; get size of DOS data structures
  5862 000008C7 49                      	dec	cx
  5863 000008C8 7428                    	jz	short win386_inst	; instance more data
  5864                                  	;dec	cx
  5865                                  	;jnz	short PopIret		; no functions above this
  5866                                  	; 05/01/2024 (PCDOS 7.1 IBMDOS.COM DOSCODE:4771h)
  5867 000008CA E232                    	loop	PopIret
  5868                                  
  5869                                  	; Get DOS device driver size -- es:di points at device driver header
  5870                                  	; In DOS 4.x, the para before the device header contains an arena 
  5871                                  	; header for the driver.
  5872                                  
  5873 000008CC 8CC0                    	mov	ax,es			; ax = device header segment
  5874                                  
  5875                                  	; We check to see if we have a memory arena for this device driver. 
  5876                                  	; The way to do this would be to look at the previous para to see if
  5877                                  	; it has a 'D' marking it as an arena and also see if the owner-field 
  5878                                  	; in the arena is the same as the device header segment. These two 
  5879                                  	; checks together should take care of all cases
  5880                                  
  5881 000008CE 48                      	dec	ax			; get arena header
  5882 000008CF 06                      	push	es
  5883 000008D0 8EC0                    	mov	es,ax			; arena header for device driver
  5884                                  
  5885 000008D2 26803D44                	cmp	byte [es:di],'D'	; is it a device arena?
  5886 000008D6 7517                    	jnz	short cantsize		; no, cant size this driver
  5887 000008D8 40                      	inc	ax			; get back device header segment
  5888 000008D9 26394501                	cmp	[es:di+1],ax		; owner field pointing at driver?
  5889 000008DD 7510                    	jnz	short cantsize		; no, not a proper arena
  5890                                  
  5891 000008DF 268B4503                	mov	ax,[es:di+3]		; get arena size in paras
  5892 000008E3 07                      	pop	es
  5893                                  
  5894                                  	; We have to multiply by 16 to get the number of bytes in (bx:cx)
  5895                                  	; Speed is not critical and so we choose the shortest method 
  5896                                  	; -- use "mul"
  5897                                  
  5898 000008E4 BB1000                  	mov	bx,16
  5899 000008E7 F7E3                    	mul	bx
  5900 000008E9 89C1                    	mov	cx,ax
  5901 000008EB 89D3                    	mov	bx,dx
  5902 000008ED EB09                    	jmp	short win386_done	; return with device driver size
  5903                                  cantsize:
  5904 000008EF 07                      	pop	es
  5905 000008F0 31C0                    	xor	ax,ax
  5906                                  win386_inst:	; 05/01/2024
  5907 000008F2 31D2                    	xor	dx,dx			; ask DOSMGR to use its methods
  5908 000008F4 EB08                    	jmp	short PopIret		; return
  5909                                  
  5910                                  win386_patch:
  5911                                  	; dx contains bits marking the patches to be applied. We return 
  5912                                  	; the field with all bits set to indicate that all patches have been
  5913                                  	; done
  5914                                  
  5915 000008F6 89D3                    	mov	bx,dx			; move patch bitfield to bx
  5916                                   	;jmp	short win386_done	; done, return
  5917                                  	; 15/12/2022
  5918                                  	; 15/12/2022
  5919                                  win386_done:
  5920 000008F8 B87CB9                  	mov	ax,WIN_OP_DONE		; 0B97Ch
  5921 000008FB BAABA2                  	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
  5922                                  PopIret:
  5923 000008FE 1F                      	pop	ds
  5924 000008FF CF                      	iret	
  5925                                  
  5926                                  win386_size:
  5927                                  	; Return the size of DOS data structures -- currently only CDS size
  5928                                  
  5929                                  	; 17/12/2022
  5930 00000900 F6C201                  	test	dl,1
  5931                                  	;test	dx,1			; check for CDS size bit
  5932 00000903 74F9                    	jz	short PopIret		; no, unknown structure -- return
  5933                                  
  5934 00000905 B95800                  	mov	cx,curdirLen	; 88 	; cx = CDS size
  5935 00000908 EBEE                    	jmp	short win386_done	; return with the size
  5936                                  
  5937                                  ; 05/01/2024
  5938                                  %if 0
  5939                                  win386_inst:
  5940                                  	; WIN386 check to see if DOS has identified the CDS,SFT and device
  5941                                  	; chain as instance data. Currently, we let the WIN386 DOSMGR handle
  5942                                  	; this by returning a status of not previously instanced. The basic
  5943                                  	; structure of these things have not changed and so the current
  5944                                  	; DOSMGR code should be able to work it out
  5945                                  
  5946                                  	xor	dx,dx			; make sure dx has a not done value
  5947                                  	jmp	short PopIret		; skip done indication
  5948                                  %endif
  5949                                  
  5950                                  	; 15/12/2022
  5951                                  ;win386_done:
  5952                                  ;	mov	ax,WIN_OP_DONE		; 0B97Ch
  5953                                  ;	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
  5954                                  ;PopIret:
  5955                                  ;	pop	ds
  5956                                  ;	iret				; return back up the chain
  5957                                  
  5958                                  	; 15/12/2022
  5959                                  ;win_nexti2f:
  5960                                  	;pop	ds
  5961                                  	;jmp	next_i2f		; go to BIOS i2f handler
  5962                                  
  5963                                  ;End WIN386 support
  5964                                  
  5965                                  ; 15/05/2019
  5966                                  
  5967                                  ;M044; Start of changes
  5968                                  ; Winoldap has a bug in that its calculations for the Windows memory image
  5969                                  ; to save is off by 1 para. This para can happen to be a Windows arena if the
  5970                                  ; DOS top of memory happens to be at an odd boundary (as is the case when
  5971                                  ; UMBs are present). This is because Windows builds its arenas only at even
  5972                                  ; para boundaries. This arena now gets trashed when Windows is swapped back
  5973                                  ; in leading to a crash. Winoldap issues callouts when it swaps Windows out
  5974                                  ; and back in. We sit on these callouts. On the Windows swapout, we save the
  5975                                  ; last para of the Windows memory block and then restore this para on the
  5976                                  ; Windows swapin callout. 
  5977                                  
  5978                                  getwinlast:
  5979                                  	; 07/12/2022
  5980 0000090A 8B36[3003]              	mov	si,[CurrentPDB]
  5981 0000090E 4E                      	dec	si
  5982 0000090F 8EC6                    	mov	es,si
  5983 00000911 2603360300              	add	si,[es:3]
  5984 00000916 C3                      	retn
  5985                                  
  5986                                  ; 15/12/2022
  5987                                  %if 0
  5988                                  winold_swap:
  5989                                  	push	ds
  5990                                  	push	es
  5991                                  	push	si
  5992                                  	push	di
  5993                                  	push	cx
  5994                                  
  5995                                  	;getdseg <ds>			;ds = DOSDATA
  5996                                  	mov	ds,[cs:DosDSeg]
  5997                                  
  5998                                  	cmp	al,1			;swap Windows out call
  5999                                  	jne	short swapin		;no, check if Swap in call
  6000                                  	call	getwinlast
  6001                                  	push	ds
  6002                                  	pop	es
  6003                                  	mov	ds,si			;ds = memory arena of Windows
  6004                                  	xor	si,si
  6005                                  	mov	di,WinoldPatch1
  6006                                  	mov	cx,8
  6007                                  	cld
  6008                                  	push	cx
  6009                                  	rep	movsb			;save first 8 bytes
  6010                                  	pop	cx
  6011                                  	mov	di,WinoldPatch2
  6012                                  	rep	movsb			;save next 8 bytes
  6013                                  	jmp	short winold_done
  6014                                  swapin:
  6015                                  	cmp	al,2			;swap Windows in call?
  6016                                  	jne	short winold_done	;no, something else, pass it on
  6017                                  	call	getwinlast
  6018                                  	mov	es,si
  6019                                  	xor	di,di
  6020                                  	mov	si,WinoldPatch1
  6021                                  	mov	cx,8
  6022                                  	cld
  6023                                  	push	cx
  6024                                  	rep	movsb			;restore first 8 bytes
  6025                                  	pop	cx
  6026                                  	mov	si,WinoldPatch2
  6027                                  	rep	movsb			;restore next 8 bytes
  6028                                  winold_done:
  6029                                  	pop	cx
  6030                                  	pop	di
  6031                                  	pop	si
  6032                                  	pop	es
  6033                                  	pop	ds
  6034                                  	jmp	next_i2f		;chain on
  6035                                  
  6036                                  %endif
  6037                                  
  6038                                  ;M044; End of changes
  6039                                  
  6040                                  ; 15/05/2019
  6041                                  
  6042                                  DispatchDOS:
  6043 00000917 2EFF36[C401]            	PUSH	word [CS:FOO]		; push return address
  6044 0000091C 2EFF36[C601]            	PUSH	word [CS:DTab]		; push table address
  6045 00000921 50                      	PUSH	AX			; push index
  6046 00000922 55                      	PUSH	BP
  6047 00000923 89E5                    	MOV	BP,SP
  6048                                  		; stack looks like:
  6049                                  		;   0	BP
  6050                                  		;   2	DISPATCH
  6051                                  		;   4	TABLE
  6052                                  		;   6	RETURN
  6053                                  		;   8	LONG-RETURN
  6054                                  		;   C	FLAGS
  6055                                  		;   E	AX
  6056                                  	
  6057 00000925 8B460E                  	MOV	AX,[BP+0Eh]		; get AX value
  6058 00000928 5D                      	POP	BP
  6059 00000929 E8F608                  	call	TableDispatch
  6060 0000092C E9DEFD                  	JMP	BadFunc 		; return indicates invalid function
  6061                                  
  6062                                  INT2F_etcetera:
  6063                                  	;entry	DosGetGroup
  6064                                  DosGetGroup:
  6065                                  	; MSDOS 3.3
  6066                                  	;push	cs
  6067                                  	;pop	ds
  6068                                  	;retn
  6069                                  
  6070                                  	; MSDOS 6.0
  6071                                  ;SR; Cannot use CS now
  6072                                  ;
  6073                                  ;	PUSH	CS
  6074                                  ;	POP	DS
  6075                                  
  6076                                  	; 04/11/2022
  6077                                  	; (MSDOS 5.0 MSDOS.SYS - DOSCODE:46FBh)
  6078                                  
  6079                                  	;getdseg <ds>
  6080 0000092F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6081 00000934 C3                      	retn
  6082                                  
  6083                                  	;entry	DOSInstall
  6084                                  DOSInstall:
  6085 00000935 B0FF                    	MOV	AL,0FFh
  6086 00000937 C3                      	retn
  6087                                  
  6088                                  ;ENDIF ; (*)
  6089                                  
  6090                                  
  6091                                  ; 15/05/2019 - Retro DOS v4.0
  6092                                  
  6093                                  ;------------------------------------------------------------------------
  6094                                  ;
  6095                                  ; Procedure Name : RW32_CONVERT
  6096                                  ;
  6097                                  ;Input: same as ABSDRD and ABSDWRT
  6098                                  ;	 ES:BP -> DPB
  6099                                  ;Functions: convert 32bit absolute RW input parms to 16bit input parms
  6100                                  ;Output: carry set when CX=-1 and drive is less then 32mb
  6101                                  ;	 carry clear, parms ok
  6102                                  ;
  6103                                  ;------------------------------------------------------------------------
  6104                                  
  6105                                  	; 06/01/2024
  6106                                  RW32_CONVERT:
  6107                                  	;inc	cx ; *	; 01 -> 0
  6108 00000938 83F9FF                  	CMP	CX,-1			   ;>32mb  new format ?	;AN000;
  6109 0000093B 7429                    	JZ	short new32format	   ;>32mb  yes		;AN000;
  6110                                  	;dec	cx ; *
  6111 0000093D 50                      	PUSH	AX			   ;>32mb  save ax	;AN000;
  6112 0000093E 52                      	PUSH	DX			   ;>32mb  save dx	;AN000;
  6113                                  	;mov	ax,[es:bp+0Dh]
  6114 0000093F 268B460D                	MOV	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  get max cluster # ;AN000;
  6115                                  	;mov	dl,[es:bp+4]
  6116 00000943 268A5604                	MOV	DL,[ES:BP+DPB.CLUSTER_MASK] ;>32mb		;AN000;
  6117 00000947 80FAFE                  	CMP	DL,0FEh ; 254		;>32mb  removable ?	;AN000;
  6118 0000094A 7407                    	JZ	short letold		;>32mb  yes		;AN000;
  6119                                  	;INC	DL			;>32mb			;AN000;
  6120                                  	; 17/12/2022
  6121 0000094C 42                      	inc	dx
  6122 0000094D 30F6                    	XOR	DH,DH			;>32mb  dx = sector/cluster ;AN000;
  6123 0000094F F7E2                    	MUL	DX			;>32mb  dx:ax= max sector # ;AN000;
  6124 00000951 09D2                    	OR	DX,DX	; (clears CF)	;>32mb  > 32mb ?	;AN000;
  6125                                  letold:
  6126 00000953 5A                      	POP	DX			;>32mb  restore dx	;AN000;
  6127 00000954 58                      	POP	AX			;>32mb  restore ax 	;AN000;
  6128 00000955 7425                    	JZ	short old_style	; cf=0	;>32mb  no 		;AN000;
  6129                                  
  6130 00000957 1E                      	push	ds
  6131                                  	;getdseg <ds>
  6132 00000958 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6133 0000095D C706[B80D]0702          	mov	word [AbsDskErr],207h	;>32mb  bad address mark
  6134 00000963 1F                      	pop	ds
  6135                                  
  6136 00000964 F9                      	STC				;>32mb			;AN000;
  6137 00000965 C3                      	retn				;>32mb			;AN000;
  6138                                  
  6139                                  new32format:
  6140                                  	;mov	dx,[bx+2]
  6141 00000966 8B5702                  	MOV	DX,[BX+ABS_32RW.SECTOR_RBA+2] ;>32mb		;AN000;
  6142                                  
  6143 00000969 1E                      	push	ds			; set up ds to DOSDATA
  6144                                  	;getdseg <ds>
  6145 0000096A 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6146 0000096F 8916[0706]              	MOV	[HIGH_SECTOR],DX	;>32mb			;AN000;
  6147 00000973 1F                      	pop	ds
  6148                                  
  6149 00000974 8B17                    	mov	dx,[bx]
  6150                                  	;MOV	DX,[BX+ABS_32RW.SECTOR_RBA]  ;>32mb		;AN000;
  6151                                  	;mov	cx,[bx+4]
  6152 00000976 8B4F04                  	MOV	CX,[BX+ABS_32RW.ABS_RW_COUNT] ;>32mb		;AN000;
  6153                                  	;lds	bx,[bx+6]
  6154 00000979 C55F06                  	LDS	BX,[BX+ABS_32RW.BUFFER_ADDR] ;>32mb		;AN000;
  6155                                  old_style:				;>32mb			;AN000;
  6156                                  	; 06/01/2024
  6157                                  	; cf=0
  6158                                  	;CLC				;>32mb			;AN000;
  6159 0000097C C3                      	retn				;>32mb			;AN000;
  6160                                  
  6161                                  ;------------------------------------------------------------------------
  6162                                  ;
  6163                                  ; Procedure Name : Fastxxx_Purge
  6164                                  ;
  6165                                  ; Input: None
  6166                                  ; Functions: Purge Fastopen/ Cache Buffers
  6167                                  ; Output: None
  6168                                  ;
  6169                                  ;------------------------------------------------------------------------
  6170                                  
  6171                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6172                                  
  6173                                  Fastxxx_Purge:
  6174 0000097D 50                      	PUSH	AX			; save regs.	;AN000;
  6175 0000097E 56                      	PUSH	SI						;AN000;
  6176 0000097F 52                      	PUSH	DX						;AN000;
  6177                                  topen:
  6178 00000980 1E                      	push	ds			; set up ds to DOSDATA
  6179                                  	;getdseg <ds>
  6180 00000981 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6181                                  
  6182 00000986 F606[3A0D]80            	TEST	byte [FastOpenFlg],Fast_yes ; 80h 
  6183                                  					; fastopen installed ?	;AN000;
  6184 0000098B 1F                      	pop	ds
  6185 0000098C 740B                    	JZ	short nofast		; no			;AN000;
  6186 0000098E B401                    	MOV	AH,FastOpen_ID	; 1				;AN000;
  6187                                  dofast:
  6188 00000990 B005                    	MOV	AL,FONC_purge  ;5	; purge			;AN000;
  6189                                  	;;mov	dl,[es:bp+0]
  6190                                  	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  6191                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; set up drive number	;AN000;
  6192                                  	; 15/12/2022
  6193 00000992 268A5600                	mov	dl,[es:bp]
  6194                                  	;invoke	Fast_Dispatch		; call fastopen/seek	;AN000;
  6195 00000996 E8891D                  	call	Fast_Dispatch
  6196                                  nofast:
  6197 00000999 5A                      	POP	DX						;AN000;
  6198 0000099A 5E                      	POP	SI			; restore regs		;AN000;
  6199 0000099B 58                      	POP	AX			 			;AN000;
  6200 0000099C C3                      	retn				; exit
  6201                                  
  6202                                  ;============================================================================
  6203                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6204                                  ;============================================================================
  6205                                  ; 29/04/2019 - Retro DOS v4.0
  6206                                  
  6207                                  ;include dossym.inc
  6208                                  ;include dosmac.inc
  6209                                  ;include doscntry.inc
  6210                                  
  6211                                  ; DOSCODE Segment
  6212                                  
  6213                                  ; 17/07/2018 - Retro DOS v3.0  [ DOSMES.INC (MSDOS 3.3, 1987) ]
  6214                                  ; ---------------------------------------------------------------------------
  6215                                  ;include divmes.inc
  6216                                  
  6217                                  ; DOSCODE:4778h (MSDOS 6.21, MSDOS.SYS)
  6218                                  ; -------------------------------------
  6219                                  ; DOSCODE:476Bh (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6220                                  
  6221                                  ; THIS IS THE ONLY DOS "MESSAGE". IT DOES NOT NEED A TERMINATOR.
  6222                                  	;PUBLIC	DIVMES
  6223                                  
  6224 0000099D 0D0A44697669646520-     DIVMES:	DB	13,10,"Divide overflow",13,10
  6224 000009A6 6F766572666C6F770D-
  6224 000009AF 0A                 
  6225                                  
  6226                                  	;PUBLIC	DivMesLen
  6227                                  DivMesLen:
  6228 000009B0 1300                    	DW	$-DIVMES  ; 19	; Length of the above message in bytes
  6229                                  
  6230                                  ; DOSCODE:478Dh (MSDOS 6.21, MSDOS.SYS)
  6231                                  ; -------------------------------------
  6232                                  ; DOSCODE:4780h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6233                                  
  6234                                  ; (MSDOS 6.0)
  6235                                  ; VxD not found error message
  6236                                  
  6237                                  NoVxDErrMsg:
  6238 000009B2 596F75206D75737420-     	db  'You must have the file WINA20.386 in the root of your boot drive'
  6238 000009BB 686176652074686520-
  6238 000009C4 66696C652057494E41-
  6238 000009CD 32302E33383620696E-
  6238 000009D6 2074686520726F6F74-
  6238 000009DF 206F6620796F757220-
  6238 000009E8 626F6F742064726976-
  6238 000009F1 65                 
  6239 000009F2 0D0A746F2072756E20-     	db  0Dh,0Ah,'to run Windows in Enhanced Mode',0Dh,0Ah
  6239 000009FB 57696E646F77732069-
  6239 00000A04 6E20456E68616E6365-
  6239 00000A0D 64204D6F64650D0A   
  6240                                  
  6241                                  VxDMesLen equ $ - NoVxDErrMsg  ; 99
  6242                                  
  6243                                  ; 13/05/2019 - Retro DOS v4.0
  6244                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6245                                  
  6246                                  ;include yesno.asm  (MNSDOS 6.0)
  6247                                  ; -------------------------------------
  6248                                  ; DOSCODE:47F0h (MSDOS 6.21, MSDOS.SYS)
  6249                                  ; DOSCODE:47E3h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6250                                  
  6251                                  ; This is for country Yes and No
  6252                                  
  6253 00000A15 59                      NLS_YES:	db 'Y'
  6254 00000A16 4E                      NLS_NO:		db 'N'
  6255 00000A17 79                      NLS_yes2:	db 'y'
  6256 00000A18 6E                      NLS_no2:	db 'n'
  6257                                  
  6258                                  ; ---------------------------------------------------------------------------
  6259                                  
  6260                                  ; DOSCODE:47F4h (MSDOS 6.21, MSDOS.SYS)
  6261                                  ; DOSCODE:47E7h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6262                                  
  6263                                  ;SUBTTL EDIT FUNCTION ASSIGNMENTS AND HEADERS
  6264                                  
  6265                                  ; The following two tables implement the current buffered input editing
  6266                                  ; routines. The tables are pairwise associated in reverse order for ease
  6267                                  ; in indexing. That is; The first entry in ESCTAB corresponds to the last
  6268                                  ; entry in ESCFUNC, and the last entry in ESCTAB to the first entry in ESCFUNC.
  6269                                  
  6270                                  	;PUBLIC	CANCHAR
  6271                                  CANCHAR:
  6272 00000A19 1B                      	DB	CANCEL	; 1Bh	;Cancel line character
  6273                                  	
  6274                                  	;PUBLIC	ESCCHAR
  6275                                  ESCCHAR:
  6276 00000A1A 00                      	DB	ESCCH	; 0	;Lead-in character for escape sequences
  6277                                  	
  6278                                  	;IF	NOT Rainbow
  6279                                  
  6280                                  ESCTAB:	; LABEL BYTE
  6281                                  
  6282                                  	;IF	IBM
  6283 00000A1B 40                      	DB	64		; Ctrl-Z - F6
  6284 00000A1C 4D                      	DB	77		; Copy one char - -->
  6285 00000A1D 3B                      	DB	59		; Copy one char - F1
  6286 00000A1E 53                      	DB	83		; Skip one char - DEL
  6287 00000A1F 3C                      	DB	60		; Copy to char - F2
  6288 00000A20 3E                      	DB	62		; Skip to char - F4
  6289 00000A21 3D                      	DB	61		; Copy line - F3
  6290 00000A22 3D                      	DB	61		; Kill line (no change to template ) - Not used
  6291 00000A23 3F                      	DB	63		; Reedit line (new template) - F5
  6292 00000A24 4B                      	DB	75		; Backspace - <--
  6293 00000A25 52                      	DB	82		; Enter insert mode - INS (toggle)
  6294 00000A26 52                      	DB	82		; Exit insert mode - INS (toggle)
  6295 00000A27 41                      	DB	65		; Escape character - F7
  6296 00000A28 41                      	DB	65		; End of table
  6297                                  	;ENDIF
  6298                                  
  6299                                  ESCEND: ; LABEL BYTE
  6300                                  
  6301                                  ESCTABLEN EQU ESCEND-ESCTAB
  6302                                  
  6303                                  ESCFUNC: ; LABEL WORD
  6304                                  	
  6305 00000A29 [1B14]                  	short_addr  GETCH	; Ignore the escape sequence
  6306 00000A2B [0B15]                  	short_addr  TWOESC
  6307 00000A2D [9315]                  	short_addr  EXITINS
  6308 00000A2F [9315]                  	short_addr  ENTERINS
  6309 00000A31 [9514]                  	short_addr  BACKSP
  6310 00000A33 [7F15]                  	short_addr  REEDIT
  6311 00000A35 [8214]                  	short_addr  KILNEW
  6312 00000A37 [1215]                  	short_addr  COPYLIN
  6313 00000A39 [4515]                  	short_addr  SKIPSTR
  6314 00000A3B [1815]                  	short_addr  COPYSTR
  6315 00000A3D [3B15]                  	short_addr  SKIPONE
  6316 00000A3F [1D15]                  	short_addr  COPYONE
  6317 00000A41 [1D15]                  	short_addr  COPYONE
  6318 00000A43 [9B15]                  	short_addr  CTRLZ
  6319                                  
  6320                                  	;ENDIF
  6321                                  
  6322                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6323                                  ; ---------------------------------------------------------------------------
  6324                                  ; DOSMES.ASM (MSDOS 2.11, 1983)
  6325                                  
  6326                                  ; OEMFunction key is expected to process a single function
  6327                                  ;   key input from a device and dispatch to the proper
  6328                                  ;   routines leaving all registers UNTOUCHED.
  6329                                  ;
  6330                                  ; Inputs:   CS, SS are DOSGROUP
  6331                                  ; Outputs:  None. This function is expected to JMP to onw of
  6332                                  ;           the following labels:
  6333                                  ;
  6334                                  ;           GetCh       - ignore the sequence
  6335                                  ;           TwoEsc      - insert an ESCChar in the buffer
  6336                                  ;           ExitIns     - toggle insert mode
  6337                                  ;           EnterIns    - toggle insert mode
  6338                                  ;           BackSp      - move backwards one space
  6339                                  ;           ReEdit      - reedit the line with a new template
  6340                                  ;           KilNew      - discard the current line and start from scratch
  6341                                  ;           CopyLin     - copy the rest of the template into the line
  6342                                  ;           SkipStr     - read the next character and skip to it in the template
  6343                                  ;           CopyStr     - read next char and copy from template to line until char
  6344                                  ;           SkipOne     - advance position in template one character
  6345                                  ;           CopyOne     - copy next character in template into line
  6346                                  ;           CtrlZ       - place a ^Z into the template
  6347                                  ; Registers that are allowed to be modified by this function are:
  6348                                  ;           AX, CX, BP
  6349                                  
  6350                                  ; 13/05/2019 - Retro DOS v4.0
  6351                                  ; -------------------------------------
  6352                                  ; DOSCODE:4820h (MSDOS 6.21, MSDOS.SYS)
  6353                                  
  6354                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6355                                  ; -------------------------------------
  6356                                  ; DOSCODE:4813h (MSDOS 5.0, MSDOS.SYS)
  6357                                  
  6358                                  OEMFunctionKey:
  6359 00000A45 E83309                  	CALL	_$STD_CON_INPUT_NO_ECHO	; Get the second byte of the sequence
  6360 00000A48 B10E                    	MOV     CL,ESCTABLEN ; 14	; length of table for scan
  6361 00000A4A 57                      	PUSH    DI                      ; save DI (cannot change it!)
  6362 00000A4B BF[1B0A]                	MOV     DI,ESCTAB		; offset of second byte table
  6363 00000A4E 06                      	push	es
  6364 00000A4F 0E                      	push	cs
  6365 00000A50 07                      	pop	es
  6366 00000A51 F2AE                    	REPNE   SCASB                   ; Look it up in the table
  6367 00000A53 07                      	pop	es
  6368 00000A54 5F                      	POP     DI                      ; restore DI
  6369 00000A55 D1E1                    	SHL     CX,1                    ; convert byte offset to word
  6370 00000A57 89CD                    	MOV     BP,CX                   ; move to indexable register
  6371                                  	;JMP	word [BP+ESCFUNC]	; Go to the right routine
  6372 00000A59 2EFFA6[290A]            	JMP	word [CS:BP+ESCFUNC]
  6373                                  
  6374                                  ;DOSCODE ENDS
  6375                                  	
  6376                                  ;============================================================================
  6377                                  ; TIME.ASM (MSDOS 6.0, 1991)
  6378                                  ;============================================================================
  6379                                  ; Retro DOS v3.0 - 18/07/2018
  6380                                  
  6381                                  ; SYSCALL.ASM (MSDOS 2.11, 1983)
  6382                                  ;----------------------------------------------------------------------------
  6383                                  ; Retro DOS v2.0 - 13/03/2018
  6384                                  
  6385                                  ;**	TIME.ASM - System Calls and low level routines for DATE and TIME
  6386                                  
  6387                                  	;BREAK <DATE AND TIME - SYSTEM CALLS 42,43,44,45>
  6388                                  
  6389                                  ;**	$GET_DATE - Get Current Date
  6390                                  ;----------------------------------------
  6391                                  ;	ENTRY	none
  6392                                  ;	EXIT	(cx:dx) = current date
  6393                                  ;	USES	all
  6394                                  
  6395                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6396                                  
  6397                                  _$GET_DATE:	;System call 42
  6398                                  
  6399 00000A5E 16                      	PUSH	SS
  6400 00000A5F 1F                      	POP	DS
  6401 00000A60 E8B700                  	CALL	READTIME	;Check for rollover to next day
  6402 00000A63 A1[5203]                	MOV	AX,[YEAR]
  6403                                  
  6404                                  ;	WARNING!!!! DAY and MONTH must be adjacently allocated!
  6405                                  
  6406 00000A66 8B1E[5003]              	MOV	BX,[DAY]	; fetch both day and month
  6407 00000A6A E814FA                  	CALL	Get_User_Stack	;Get pointer to user registers
  6408                                  	;MOV	[SI+6],BX	;DH=month, DL=day
  6409 00000A6D 895C06                  	MOV	[SI+user_env.user_DX],BX
  6410 00000A70 05BC07                  	ADD	AX,1980		;Put bias back
  6411                                  	;MOV	[SI+4],AX	;CX=year
  6412 00000A73 894404                  	MOV	[SI+user_env.user_CX],AX
  6413 00000A76 36A0[5603]              	MOV	AL,[SS:WEEKDAY]	;hkn; SS override
  6414                                  RET20:	; 05/11/2022
  6415                                  RET24:	; 18/12/2022
  6416 00000A7A C3                      	RETN
  6417                                  
  6418                                  ;**	$SET_DATE - Set Current Date
  6419                                  ;----------------------------------------
  6420                                  ;	ENTRY	(cx:dx) = current date
  6421                                  ;	EXIT	(al) = -1 iff bad date
  6422                                  ;		(al) = 0 if ok
  6423                                  ;	USES	all
  6424                                  
  6425                                  _$SET_DATE:	;System call 43
  6426                                  
  6427 00000A7B B0FF                    	MOV	AL,-1		;Be ready to flag error
  6428 00000A7D 81E9BC07                	SUB	CX,1980		;Fix bias in year
  6429                                  	;JC	SHORT RET24	;Error if not big enough
  6430                                  	; 05/11/2022
  6431 00000A81 72F7                    	jc	short RET20
  6432 00000A83 83F977                  	CMP	CX,119		;Year must be less than 2100
  6433 00000A86 77F2                    	JA	SHORT RET24
  6434 00000A88 08F6                    	OR	DH,DH
  6435                                  	;JZ	SHORT RET24
  6436                                   	; 05/11/2022
  6437 00000A8A 74EE                    	jz	short RET20
  6438 00000A8C 08D2                    	OR	DL,DL
  6439                                  	;JZ	SHORT RET24	;Error if either month or day is 0
  6440                                  	; 05/11/2022
  6441 00000A8E 74EA                    	jz	short RET20
  6442 00000A90 80FE0C                  	CMP	DH,12		;Check against max. month
  6443 00000A93 77E5                    	JA	SHORT RET24
  6444 00000A95 16                      	PUSH	SS
  6445 00000A96 1F                      	POP	DS
  6446                                  	;CALL	DODATE
  6447                                  	; 18/12/2022
  6448 00000A97 E91301                  	jmp	DODATE
  6449                                  ;RET24:  
  6450                                  	;RETN
  6451                                  
  6452                                  ;**	$GET_TIME - Get Current Time
  6453                                  ;----------------------------------------
  6454                                  ;	ENTRY	none
  6455                                  ;	EXIT	(cx:dx) = current time
  6456                                  ;	USES	all
  6457                                  
  6458                                  _$GET_TIME:			;System call 44
  6459                                  
  6460 00000A9A 16                      	PUSH	SS
  6461 00000A9B 1F                      	POP	DS
  6462 00000A9C E87B00                  	CALL	READTIME
  6463 00000A9F E8DFF9                  	CALL	Get_User_Stack	;Get pointer to user registers
  6464                                  	;MOV	[SI+6],DX
  6465 00000AA2 895406                  	MOV	[SI+user_env.user_DX],DX
  6466                                  	;MOV	[SI+4],CX
  6467 00000AA5 894C04                  	MOV	[SI+user_env.user_CX],CX
  6468                                  set_time_ok:	; 06/01/2024
  6469 00000AA8 30C0                    	XOR	AL,AL
  6470                                  RET26:  
  6471 00000AAA C3                      	RETN
  6472                                  
  6473                                  ;**	$SET_TIME - Set Current Time
  6474                                  ;----------------------------------------
  6475                                  ;	ENTRY	(cx:dx) = time
  6476                                  ;	EXIT	(al) = 0 if 0k
  6477                                  ;		(al) = -1 if invalid
  6478                                  ;	USES	ALL
  6479                                  
  6480                                  _$SET_TIME:			;System call 45
  6481                                  
  6482 00000AAB B0FF                    	MOV	AL,-1		;Flag in case of error
  6483 00000AAD 80FD18                  	CMP	CH,24		;Check hours
  6484 00000AB0 73F8                    	JAE	SHORT RET26
  6485 00000AB2 80F93C                  	CMP	CL,60		;Check minutes
  6486 00000AB5 73F3                    	JAE	SHORT RET26
  6487 00000AB7 80FE3C                  	CMP	DH,60		;Check seconds
  6488 00000ABA 73EE                    	JAE	SHORT RET26
  6489 00000ABC 80FA64                  	CMP	DL,100		;Check 1/100's
  6490 00000ABF 73E9                    	JAE	SHORT RET26
  6491 00000AC1 51                      	PUSH	CX
  6492 00000AC2 52                      	PUSH	DX
  6493 00000AC3 16                      	PUSH	SS
  6494 00000AC4 1F                      	POP	DS
  6495 00000AC5 BB[B603]                	MOV	BX,TIMEBUF
  6496 00000AC8 B90600                  	MOV	CX,6
  6497                                  	;XOR	DX,DX
  6498                                  	;MOV	AX,DX
  6499 00000ACB 31C0                    	xor	ax,ax
  6500 00000ACD 99                      	cwd	; 06/01/2024
  6501 00000ACE 53                      	PUSH	BX
  6502 00000ACF E8353C                  	CALL	SETREAD
  6503 00000AD2 1E                      	PUSH	DS
  6504 00000AD3 C536[2E00]              	LDS	SI,[BCLOCK]
  6505 00000AD7 E8B73B                  	CALL	DEVIOCALL2	;Get correct day count
  6506 00000ADA 1F                      	POP	DS
  6507 00000ADB 5B                      	POP	BX
  6508 00000ADC E85B3C                  	CALL	SETWRITE
  6509 00000ADF 8F06[BA03]              	POP	WORD [TIMEBUF+4]
  6510 00000AE3 8F06[B803]              	POP	WORD [TIMEBUF+2]
  6511 00000AE7 C536[2E00]              	LDS	SI,[BCLOCK]
  6512 00000AEB E8A33B                  	CALL	DEVIOCALL2	;Set the time
  6513                                  	; 06/01/2024
  6514                                  	;XOR	AL,AL
  6515                                  	;RETN
  6516 00000AEE EBB8                    	jmp	short set_time_ok
  6517                                  
  6518                                  ; 11/07/2018 - Retro DOS v3.0
  6519                                  ; Retro DOS v2.0 - 14/03/2018
  6520                                  
  6521                                  FOURYEARS EQU 3*365 + 366  ; = 1461 
  6522                                  
  6523                                  ;SUBTTL DATE16, READTIME, DODATE -- GUTS OF TIME AND DATE
  6524                                  ;----------------------------------------------------------
  6525                                  ; Date16 returns the current date in AX, current time in DX
  6526                                  ;   AX - YYYYYYYMMMMDDDDD  years months days
  6527                                  ;   DX - HHHHHMMMMMMSSSSS  hours minutes seconds/2
  6528                                  
  6529                                  DATE16:
  6530                                  	
  6531                                  ;M048	Context DS
  6532                                  ;
  6533                                  ; Since this function can be called thru int 2f we shall not assume that SS
  6534                                  ; is DOSDATA
  6535                                  
  6536                                  	;push	ss
  6537                                  	;pop	ds
  6538                                  
  6539                                  	;getdseg <ds>		; M048
  6540                                  
  6541                                  	; 13/05/2019 - Retro DOS v4.0
  6542 00000AF0 2E8E1E[0700]            	mov	ds, [cs:DosDSeg]	
  6543                                  
  6544 00000AF5 51                      	PUSH	CX
  6545 00000AF6 06                      	PUSH	ES
  6546 00000AF7 E82000                  	CALL	READTIME
  6547 00000AFA 07                      	POP	ES
  6548 00000AFB D0E1                    	SHL	CL,1		;Minutes to left part of byte
  6549 00000AFD D0E1                    	SHL	CL,1
  6550 00000AFF D1E1                    	SHL	CX,1		;Push hours and minutes to left end
  6551 00000B01 D1E1                    	SHL	CX,1
  6552 00000B03 D1E1                    	SHL	CX,1
  6553 00000B05 D0EE                    	SHR	DH,1		;Count every two seconds
  6554 00000B07 08F1                    	OR	CL,DH		;Combine seconds with hours and minutes
  6555 00000B09 89CA                    	MOV	DX,CX
  6556                                  
  6557                                  ;	WARNING! MONTH and YEAR must be adjacently allocated
  6558                                  
  6559 00000B0B A1[5103]                	MOV	AX,[MONTH]	;Fetch month and year
  6560 00000B0E B104                    	MOV	CL,4
  6561 00000B10 D2E0                    	SHL	AL,CL		;Push month to left to make room for day
  6562 00000B12 D1E0                    	SHL	AX,1
  6563 00000B14 59                      	POP	CX
  6564 00000B15 0A06[5003]              	OR	AL,[DAY]
  6565                                  RET21:
  6566 00000B19 C3                      	RETN
  6567                                  
  6568                                  ;----------------------------------------------------------
  6569                                  
  6570                                  READTIME:
  6571                                  
  6572                                  ;Gets time in CX:DX. Figures new date if it has changed.
  6573                                  ;Uses AX, CX, DX.
  6574                                  
  6575 00000B1A C706[910D]0000          	MOV	word [DATE_FLAG],0 ; reset date flag for CPMIO
  6576 00000B20 56                      	PUSH	SI
  6577 00000B21 53                      	PUSH	BX
  6578                                  
  6579 00000B22 BB[B603]                	MOV	BX,TIMEBUF
  6580                                  
  6581 00000B25 B90600                  	MOV	CX,6
  6582                                  	;XOR	DX,DX
  6583                                  	;MOV	AX,DX
  6584                                  	; 06/01/2024
  6585 00000B28 31C0                    	xor	ax,ax
  6586 00000B2A 99                      	cwd
  6587 00000B2B E8D93B                  	CALL	SETREAD
  6588 00000B2E 1E                      	PUSH	DS
  6589 00000B2F C536[2E00]              	LDS	SI,[BCLOCK]
  6590 00000B33 E85B3B                  	CALL	DEVIOCALL2	;Get correct date and time
  6591 00000B36 1F                      	POP	DS
  6592 00000B37 5B                      	POP	BX
  6593 00000B38 5E                      	POP	SI
  6594 00000B39 A1[B603]                	MOV	AX,[TIMEBUF]
  6595 00000B3C 8B0E[B803]              	MOV	CX,[TIMEBUF+2]
  6596 00000B40 8B16[BA03]              	MOV	DX,[TIMEBUF+4]
  6597 00000B44 3B06[5403]              	CMP	AX,[DAYCNT]	;See if day count is the same
  6598                                  	;JZ	SHORT RET22
  6599 00000B48 74CF                    	JZ	SHORT RET21 ; 18/07/2018
  6600                                  	;cmp	ax,43830
  6601 00000B4A 3D36AB                  	CMP	AX,FOURYEARS*30 ;Number of days in 120 years
  6602 00000B4D 733D                    	JAE	SHORT RET22	;Ignore if too large
  6603 00000B4F A3[5403]                	MOV	[DAYCNT],AX
  6604 00000B52 56                      	PUSH	SI
  6605 00000B53 51                      	PUSH	CX
  6606 00000B54 52                      	PUSH	DX		;Save time
  6607 00000B55 31D2                    	XOR	DX,DX
  6608                                  	;mov	cx,1461
  6609 00000B57 B9B505                  	MOV	CX,FOURYEARS	;Number of days in 4 years
  6610 00000B5A F7F1                    	DIV	CX		;Compute number of 4-year units
  6611 00000B5C D1E0                    	SHL	AX,1
  6612 00000B5E D1E0                    	SHL	AX,1
  6613 00000B60 D1E0                    	SHL	AX,1		;Multiply by 8 (no. of half-years)
  6614 00000B62 89C1                    	MOV	CX,AX		;<240 implies AH=0
  6615                                  
  6616 00000B64 BE[140D]                	MOV	SI,YRTAB	;Table of days in each year
  6617                                  
  6618 00000B67 E82300                  	CALL	DSLIDE		;Find out which of four years we're in
  6619 00000B6A D1E9                    	SHR	CX,1		;Convert half-years to whole years
  6620 00000B6C 7304                    	JNC	SHORT SK	;Extra half-year?
  6621 00000B6E 81C2C800                	ADD	DX,200
  6622                                  SK:
  6623 00000B72 E82200                  	CALL	SETYEAR
  6624 00000B75 B101                    	MOV	CL,1		;At least at first month in year
  6625                                  
  6626 00000B77 BE[1C0D]                	MOV	SI,MONTAB	;Table of days in each month
  6627                                  	
  6628 00000B7A E81000                  	CALL	DSLIDE		;Find out which month we're in
  6629 00000B7D 880E[5103]              	MOV	[MONTH],CL
  6630 00000B81 42                      	INC	DX		;Remainder is day of month (start with one)
  6631 00000B82 8816[5003]              	MOV	[DAY],DL
  6632 00000B86 E89400                  	CALL	WKDAY		;Set day of week
  6633 00000B89 5A                      	POP	DX
  6634 00000B8A 59                      	POP	CX
  6635 00000B8B 5E                      	POP	SI
  6636                                  RET22:  
  6637 00000B8C C3                      	RETN
  6638                                  
  6639                                  ;----------------------------------------------------------
  6640                                  
  6641                                  DSLIDE:
  6642                                  	;MOV	AH,0
  6643                                  	; 06/01/2024
  6644                                  	; (AH=0)
  6645                                  DSLIDE1:
  6646 00000B8D AC                      	LODSB			;Get count of days
  6647 00000B8E 39C2                    	CMP	DX,AX		;See if it will fit
  6648                                  	;JB	SHORT RET23	;If not, done
  6649 00000B90 72FA                    	jb	short RET22 ; 13/05/2019 - Retro DOS v4.0
  6650 00000B92 29C2                    	SUB	DX,AX
  6651 00000B94 41                      	INC	CX		;Count one more month/year
  6652 00000B95 EBF6                    	JMP	SHORT DSLIDE1
  6653                                  
  6654                                  ;----------------------------------------------------------
  6655                                  
  6656                                  SETYEAR:
  6657                                  
  6658                                  ;Set year with value in CX. Adjust length of February for this year.
  6659                                  
  6660                                  ; NOTE: This can also be called thru int 2f. If this is called then it will
  6661                                  ;	  set DS to DOSDATA. Since the only guy calling this should be the DOS
  6662                                  ;	redir, DS will be DOSDATA anyway. It is going to be in-efficient to
  6663                                  ;	preserve DS as CHKYR is also called as a routine.
  6664                                  
  6665                                  	; MSDOS 6.0 (18/07/2018) ; *
  6666                                  
  6667                                  	;GETDSEG DS
  6668                                  
  6669                                  	;PUSH	CS  ; *
  6670                                  	;POP	DS  ; *
  6671                                  
  6672                                  	; 13/05/2019 - Retro DOS v4.0
  6673 00000B97 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6674                                  
  6675                                  	; Offset 18CEh in IBMDOS.COM (MSDOS 3.3), 1987
  6676                                  	; 05/11/2022 
  6677                                  	; DOSCODE:4970h in MSDOS.SYS (MSDOS 5.0), 1991 
  6678                                  
  6679 00000B9C 880E[5203]              	MOV	[YEAR],CL
  6680                                  CHKYR:
  6681 00000BA0 F6C103                  	TEST	CL,3		;Check for leap year
  6682 00000BA3 B01C                    	MOV	AL,28
  6683 00000BA5 7502                    	JNZ	SHORT SAVFEB	;28 days if no leap year
  6684 00000BA7 FEC0                    	INC	AL		;Add leap day
  6685                                  SAVFEB:
  6686 00000BA9 A2[1D0D]                	mov	[february],al
  6687                                  	;MOV	[MONTAB+1],AL	;Store for February
  6688                                  RET23:  
  6689 00000BAC C3                      	RETN
  6690                                  
  6691                                  ;----------------------------------------------------------
  6692                                  
  6693                                  DODATE:
  6694 00000BAD E8F0FF                  	CALL	CHKYR		;Set Feb. up for new year
  6695 00000BB0 88F0                    	MOV	AL,DH
  6696                                  
  6697 00000BB2 BB[1B0D]                	MOV	BX,MONTAB-1	;DOSDATA:0D1Bh for MSDOS 6.21
  6698                                  
  6699 00000BB5 D7                      	XLAT			;Look up days in month
  6700 00000BB6 38D0                    	CMP	AL,DL
  6701 00000BB8 B0FF                    	MOV	AL,-1		;Restore error flag, just in case
  6702                                  	;JB	SHORT RET25	;Error if too many days
  6703 00000BBA 72F0                    	jb	short RET23 ; 18/07/2018
  6704 00000BBC E8D8FF                  	CALL	SETYEAR
  6705                                  ;
  6706                                  ; WARNING! DAY and MONTH must be adjacently allocated
  6707                                  ;
  6708 00000BBF 8916[5003]              	MOV	[DAY],DX	;Set both day and month
  6709 00000BC3 D1E9                    	SHR	CX,1
  6710 00000BC5 D1E9                    	SHR	CX,1
  6711                                  	;mov	ax,1461
  6712 00000BC7 B8B505                  	MOV	AX,FOURYEARS
  6713 00000BCA 89D3                    	MOV	BX,DX
  6714 00000BCC F7E1                    	MUL	CX
  6715 00000BCE 8A0E[5203]              	MOV	CL,[YEAR]
  6716 00000BD2 80E103                  	AND	CL,3
  6717                                  
  6718 00000BD5 BE[140D]                	MOV	SI,YRTAB
  6719                                  
  6720 00000BD8 89C2                    	MOV	DX,AX
  6721 00000BDA D1E1                    	SHL	CX,1		;Two entries per year, so double count
  6722 00000BDC E85100                  	CALL	DSUM		;Add up the days in each year
  6723 00000BDF 88F9                    	MOV	CL,BH		;Month of year
  6724                                  
  6725 00000BE1 BE[1C0D]                	MOV	SI,MONTAB
  6726                                  
  6727 00000BE4 49                      	DEC	CX		;Account for months starting with one
  6728 00000BE5 E84800                  	CALL	DSUM		;Add up days in each month
  6729 00000BE8 88D9                    	MOV	CL,BL		;Day of month
  6730 00000BEA 49                      	DEC	CX		;Account for days starting with one
  6731 00000BEB 01CA                    	ADD	DX,CX		;Add in to day total
  6732 00000BED 92                      	XCHG	AX,DX		;Get day count in AX
  6733 00000BEE A3[5403]                	MOV	[DAYCNT],AX
  6734 00000BF1 56                      	PUSH	SI
  6735 00000BF2 53                      	PUSH	BX
  6736 00000BF3 50                      	PUSH	AX
  6737                                  
  6738 00000BF4 BB[B603]                	MOV	BX,TIMEBUF
  6739                                  
  6740 00000BF7 B90600                  	MOV	CX,6
  6741                                  	;XOR	DX,DX
  6742                                  	;MOV	AX,DX
  6743                                  	; 06/01/2024
  6744 00000BFA 31C0                    	xor	ax,ax
  6745 00000BFC 99                      	cwd
  6746 00000BFD 53                      	PUSH	BX
  6747 00000BFE E8063B                  	CALL	SETREAD
  6748                                  
  6749 00000C01 1E                      	PUSH	DS
  6750 00000C02 C536[2E00]              	LDS	SI,[BCLOCK]
  6751 00000C06 E8883A                  	CALL	DEVIOCALL2	;Get correct date and time
  6752 00000C09 1F                      	POP	DS
  6753 00000C0A 5B                      	POP	BX
  6754 00000C0B E82C3B                  	CALL	SETWRITE
  6755 00000C0E 8F06[B603]              	POP	WORD [TIMEBUF]
  6756 00000C12 1E                      	PUSH	DS
  6757 00000C13 C536[2E00]              	LDS	SI,[BCLOCK]
  6758 00000C17 E8773A                  	CALL	DEVIOCALL2	;Set the date
  6759 00000C1A 1F                      	POP	DS
  6760 00000C1B 5B                      	POP	BX
  6761 00000C1C 5E                      	POP	SI
  6762                                  WKDAY:
  6763 00000C1D A1[5403]                	MOV	AX,[DAYCNT]
  6764 00000C20 31D2                    	XOR	DX,DX
  6765 00000C22 B90700                  	MOV	CX,7
  6766 00000C25 40                      	INC	AX
  6767 00000C26 40                      	INC	AX		;First day was Tuesday
  6768 00000C27 F7F1                    	DIV	CX		;Compute day of week
  6769 00000C29 8816[5603]              	MOV	[WEEKDAY],DL
  6770 00000C2D 30C0                    	XOR	AL,AL		;Flag OK
  6771                                  RET25:
  6772 00000C2F C3                      	RETN
  6773                                  
  6774                                  ;----------------------------------------------------------
  6775                                  
  6776                                  ;**	DSUM - Compute the sum of a string of bytes
  6777                                  ;
  6778                                  ;	ENTRY	(cx) = byte count
  6779                                  ;		(ds:si) = byte address
  6780                                  ;		(dx) = sum register, initialized by caller
  6781                                  ;	EXIT	(dx) updated
  6782                                  ;	USES	ax, cx, dx, si, flags
  6783                                  
  6784                                  DSUM:
  6785 00000C30 B400                    	MOV	AH,0
  6786 00000C32 E305                    	JCXZ	DSUM9 ; 13/05/2019 - Retro DOS v4.0
  6787                                  	;JCXZ	RET25 ; 18/07/2018
  6788                                  DSUM1:
  6789 00000C34 AC                      	LODSB
  6790 00000C35 01C2                    	ADD	DX,AX
  6791 00000C37 E2FB                    	LOOP	DSUM1
  6792                                  DSUM9:
  6793 00000C39 C3                      	RETN
  6794                                  
  6795                                  ;============================================================================
  6796                                  ; GETSET.ASM (MSDOS 6.0, 1991)
  6797                                  ;============================================================================
  6798                                  ; 29/04/2019 - Retro DOS v4.0
  6799                                  ; 18/07/2018 - Retro DOS v3.0 (GETSET.ASM, MSDOS 6.0, 1991)
  6800                                  
  6801                                  ; 12/03/2018 - Retro DOS v2.0 
  6802                                  
  6803                                  ;TITLE	GETSET - GETting and SETting MS-DOS system calls
  6804                                  ;NAME	GETSET
  6805                                  
  6806                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
  6807                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
  6808                                  
  6809                                  ;USERNUM:
  6810                                  ;	DW	0			; 24 bit user number
  6811                                  ;       DB      0
  6812                                  ;;	IF      IBM
  6813                                  ;;OEMNUM: DB    0			; 8 bit OEM number
  6814                                  ;;	ELSE
  6815                                  ;OEMNUM: DB     0FFH			; 8 bit OEM number
  6816                                  ;;	ENDIF
  6817                                  
  6818                                  ;MSVERS:		; MS-DOS version in hex for $GET_VERSION
  6819                                  ;; 08/07/2018 - Retro DOS v3.0
  6820                                  ;MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  6821                                  ;MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  6822                                  
  6823                                  ;BREAK <$Get_Version -- Return MSDOS version number>
  6824                                  ;----------------------------------------------------------------------------
  6825                                  
  6826                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6827                                  ; DOSCODE:4A0Fh (MSDOS 5.0 MSDOS.SYS)
  6828                                  
  6829                                  _$GET_VERSION:
  6830                                  
  6831                                  ; Inputs:
  6832                                  ;       None
  6833                                  ; Function:
  6834                                  ;       Return MS-DOS version number
  6835                                  ; Outputs:
  6836                                  ;       OEM number in BH
  6837                                  ;       User number in BL:CX (24 bits)
  6838                                  ;       Version number as AL.AH in binary
  6839                                  ;       NOTE: On pre 1.28 DOSs AL will be zero
  6840                                  
  6841                                  ; MSDOS 6.0
  6842                                  ;
  6843                                  ;	Fake_Count is used to lie about the version numbers to support
  6844                                  ;	old binarys. See ms_table.asm for more info.
  6845                                  ;
  6846                                  ;		if input al = 00
  6847                                  ;		  (bh) = OEM number			
  6848                                  ;		else if input al = 01
  6849                                  ;		  (bh) = version flags
  6850                                  ;		 
  6851                                  ;		       	 bits 0-2 = DOS internal revision
  6852                                  ;		       	 bits 3-7 = DOS type flags
  6853                                  ;		              bit 3    = DOS is in ROM
  6854                                  ;		              bit 4    = DOS in in HMA
  6855                                  ;		              bits 5-7 = reserved
  6856                                  ;               M007 change - only bit 3 is now valid. Other bits
  6857                                  ;               are 0 when AL = 1
  6858                                  
  6859                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  6860 00000C3A 36C50E[B203]            	lds	cx, [ss:USERNUM]
  6861 00000C3F 8CDB                    	mov	bx, ds
  6862                                  
  6863                                  	; MSDOS 3.3 (IBMDOS.COM, offset 196Dh)
  6864                                  	;--------------------------------------
  6865                                  	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:4A1Ch)
  6866                                  
  6867 00000C41 16                              PUSH    SS
  6868 00000C42 1F                              POP     DS
  6869                                          
  6870                                  	; 06/01/2024
  6871                                  	;MOV	BX,[USERNUM+2]
  6872                                          ;MOV	CX,[USERNUM]
  6873                                  
  6874                                  	; 13/05/2019 - Retro DOS v4.0
  6875                                  
  6876                                  	;If AL == 1, ROMDOS will return BH = dos internal version # &
  6877                                  	;DOS flags
  6878                                  
  6879 00000C43 3C01                    	cmp	AL,1
  6880 00000C45 7502                    	jne	short Norm_Vers
  6881                                  
  6882                                  ;ifdef ROMDOS
  6883                                  ;	mov	BH,DOSINROM 	; Just set the bit for ROM version
  6884                                  ;				(DOSINROM = 8)
  6885                                  ;else
  6886 00000C47 30FF                            xor     bh,bh		; Otherwise return 0
  6887                                  ;endif				;M007 end
  6888                                  
  6889                                  Norm_Vers:
  6890                                  	;MOV	AX,[MSVERS]  ; MSDOS 3.3
  6891                                  
  6892                                          	; MSDOS 6.0	; MSVERS is a label in TABLE segment	
  6893                                  	; 13/05/2019 - Retro DOS v4.0
  6894 00000C49 1E                      	push	ds		; Get the version number from the
  6895 00000C4A 8E1E[3003]              	mov	ds,[CurrentPDB]	; current app's PSP segment
  6896                                  	;mov	ax,[40h]
  6897 00000C4E A14000                  	mov	ax,[PDB.Version] ; AX = DOS version number	
  6898                                  	; 07/12/2022
  6899 00000C51 1F                      	pop	ds
  6900 00000C52 E82CF8                  	call	Get_User_Stack
  6901                                  				; Put values for return registers
  6902                                  				; in the proper place on the user's	 
  6903                                  				; stack addressed by DS:SI
  6904                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  6905                                  gdrvfspc_ret:
  6906                                          ;MOV	[SI+user_env.user_AX],AX
  6907 00000C55 8904                            MOV	[SI],AX
  6908                                          ;MOV	[SI+4],CX
  6909 00000C57 894C04                  	mov	[SI+user_env.user_CX],CX
  6910                                  set_user_bx:
  6911                                  	;MOV	[SI+2],BX
  6912 00000C5A 895C02                  	mov	[SI+user_env.user_BX],BX
  6913                                  
  6914 00000C5D C3                      	RETN
  6915                                  
  6916                                  ; 18/07/2018 - Retro DOS v3.0
  6917                                  
  6918                                  ;BREAK <$Get/Set_Verify_on_Write - return/set verify-after-write flag>
  6919                                  ;----------------------------------------------------------------------------
  6920                                  
  6921                                  ;**	$Get_Verify_On_Write - Get Status of Verify on write flag
  6922                                  ;
  6923                                  ;	ENTRY	none
  6924                                  ;	EXIT	(al) = value of VERIFY flag
  6925                                  ;	USES	all
  6926                                  
  6927                                  
  6928                                  _$GET_VERIFY_ON_WRITE:
  6929                                  
  6930                                  ;hkn; SS override
  6931 00000C5E 36A0[FF02]              	MOV	AL,[SS:VERFLG]	; Retro DOS v2.0 - 12/03/2018
  6932 00000C62 C3                      	retn
  6933                                  
  6934                                  ;**	$Set_Verify_On_Write - Set Status of Verify on write flag
  6935                                  ;
  6936                                  ;	ENTRY	(al) = value of VERIFY flag
  6937                                  ;	EXIT	none
  6938                                  ;	USES	all
  6939                                  
  6940                                  _$SET_VERIFY_ON_WRITE:
  6941                                  
  6942 00000C63 2401                    	AND	AL,1
  6943                                  ;hkn; SS override
  6944 00000C65 36A2[FF02]              	MOV	[SS:VERFLG],AL	; Retro DOS v2.0 - 12/03/2018
  6945                                  RET27:	; 18/07/2018
  6946 00000C69 C3                      	retn
  6947                                  
  6948                                  ; 19/07/2018 - Retro DOS v3.0
  6949                                  
  6950                                  ;BREAK <$International - return country-dependent information>
  6951                                  ;----------------------------------------------------------------------------
  6952                                  ;
  6953                                  ; Procedure Name : $INTERNATIONAL
  6954                                  ;
  6955                                  ; Inputs:
  6956                                  ;	MOV	AH,International
  6957                                  ;	MOV	AL,country	(al = 0 => current country)
  6958                                  ;      [MOV	BX,country]
  6959                                  ;	LDS	DX,block
  6960                                  ;	INT	21
  6961                                  ; Function:
  6962                                  ;	give users an idea of what country the application is running
  6963                                  ; Outputs:
  6964                                  ;	IF DX != -1 on input (get country)
  6965                                  ;	  AL = 0 means return current country table.
  6966                                  ;	  0<AL<0FFH means return country table for country AL
  6967                                  ;	  AL = 0FF means return country table for country BX
  6968                                  ;	  No Carry:
  6969                                  ;	     Register BX will contain the 16-bit country code.
  6970                                  ;	     Register AL will contain the low 8 bits of the country code.
  6971                                  ;	     The block pointed to by DS:DX is filled in with the information
  6972                                  ;	     for the particular country.
  6973                                  ;		BYTE  Size of this table excluding this byte and the next
  6974                                  ;		BYTE  Country code represented by this table
  6975                                  ;			A sequence of n bytes, where n is the number specified
  6976                                  ;			by the first byte above and is not > internat_block_max,
  6977                                  ;			in the correct order for being returned by the
  6978                                  ;			INTERNATIONAL call as follows:
  6979                                  ;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
  6980                                  ;		5 BYTE	Currency symbol null terminated
  6981                                  ;		2 BYTE	thousands separator null terminated
  6982                                  ;		2 BYTE	Decimal point null terminated
  6983                                  ;		2 BYTE	Date separator null terminated
  6984                                  ;		2 BYTE	Time separator null terminated
  6985                                  ;		1 BYTE	Bit field.  Currency format.
  6986                                  ;			Bit 0.	=0 $ before #  =1 $ after #
  6987                                  ;			Bit 1.	no. of spaces between # and $ (0 or 1)
  6988                                  ;		1 BYTE	No. of significant decimal digits in currency
  6989                                  ;		1 BYTE	Bit field.  Time format.
  6990                                  ;			Bit 0.	=0 12 hour clock  =1 24 hour
  6991                                  ;		DWORD	Call address of case conversion routine
  6992                                  ;		2 BYTE	Data list separator null terminated.
  6993                                  ;	  Carry:
  6994                                  ;	     Register AX has the error code.
  6995                                  ;	IF DX = -1 on input (set current country)
  6996                                  ;	  AL = 0 is an error
  6997                                  ;	  0<AL<0FFH means set current country to country AL
  6998                                  ;	  AL = 0FF means set current country to country BX
  6999                                  ;	  No Carry:
  7000                                  ;	    Current country SET
  7001                                  ;	    Register AL will contain the low 8 bits of the country code.
  7002                                  ;	  Carry:
  7003                                  ;	     Register AX has the error code.
  7004                                  ;-----------------------------------------------------------------------------
  7005                                  
  7006                                  ;procedure   $INTERNATIONAL,NEAR   ; DOS 3.3
  7007                                  
  7008                                  ; 13/05/2019 - Retro DOS v4.0
  7009                                  ; DOSCODE:4A4Dh (MSDOS 6.21, MSDOS.SYS)
  7010                                  
  7011                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7012                                  ; DOSCODE:4A40h (MSDOS 5.0, MSDOS.SYS)
  7013                                  
  7014                                  _$INTERNATIONAL:  ; IBMDOS.COM (MSDOS 3.3), offset 1992h
  7015                                  	 
  7016 00000C6A 3CFF                    	CMP	AL,0FFH
  7017 00000C6C 7404                    	JZ	short BX_HAS_CODE	; -1 means country code is in BX
  7018 00000C6E 88C3                    	MOV	BL,AL			; Put AL country code in BX
  7019 00000C70 30FF                    	XOR	BH,BH
  7020                                  BX_HAS_CODE:
  7021 00000C72 1E                      	PUSH	DS
  7022 00000C73 07                      	POP	ES
  7023 00000C74 52                      	PUSH	DX
  7024 00000C75 5F                      	POP	DI			; User buffer to ES:DI
  7025                                  
  7026                                  ;hkn; SS is DOSDATA
  7027                                  ;	context DS
  7028                                  
  7029 00000C76 16                      	push	ss
  7030 00000C77 1F                      	pop	ds
  7031                                  
  7032 00000C78 83FFFF                  	CMP	DI,-1
  7033 00000C7B 745D                    	JZ	short international_set
  7034 00000C7D 09DB                    	OR	BX,BX
  7035 00000C7F 7505                    	JNZ	short international_find
  7036                                  
  7037                                  ;hkn; country_cdpg is in DOSDATA segment.
  7038 00000C81 BE[0012]                	MOV	SI,COUNTRY_CDPG
  7039                                  
  7040 00000C84 EB39                    	JMP	SHORT international_copy
  7041                                  
  7042                                  international_find:
  7043                                  	;MOV	BP,0			 ; flag it for GetCntry only
  7044                                  	; 06/01/2024
  7045 00000C86 31ED                    	xor	bp,bp ; 0
  7046 00000C88 E80A00                  	CALL	international_get
  7047 00000C8B 7255                    	JC	short errtn
  7048                                  	;CMP	BX,0			 ; nlsfunc finished it ?
  7049                                  	; 06/01/2024
  7050 00000C8D 09DB                    	or	bx,bx
  7051 00000C8F 752E                    	JNZ	SHORT international_copy ; no, copy by myself
  7052 00000C91 89D3                    	MOV	BX,DX			 ; put country back
  7053 00000C93 EB3A                    	JMP	SHORT international_ok3
  7054                                  
  7055                                  international_get:
  7056 00000C95 BE[0012]                	MOV	SI,COUNTRY_CDPG
  7057                                  
  7058                                  ;hkn; country_cdpg is in DOSDATA segment.
  7059                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  7060                                  
  7061                                  	; MSDOS 3.3
  7062                                  	;;cmp	bx,[SI+63h]
  7063                                  	;CMP	BX,[SI+DOS_CCDPG.ccDosCountry]
  7064                                  	;jz	short RET27
  7065                                  
  7066                                  	; 13/05/2019 - Retro DOS v4.0
  7067                                  
  7068                                  	; MSDOS 6.0
  7069                                  	;cmp	bx,[ss:si+68h]
  7070 00000C98 363B5C68                	CMP	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
  7071 00000C9C 74CB                    	jz	short RET27			; return if equal
  7072                                  
  7073 00000C9E 89DA                    	MOV	DX,BX
  7074 00000CA0 31DB                    	XOR	BX,BX			; bx = 0, default code page
  7075                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7076 00000CA2 B80014                  	mov	ax,1400h
  7077 00000CA5 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7078                                  			; Return: AL = 00h not installed, OK to install
  7079                                  			; 01h not installed, not OK
  7080                                  			; FFh installed
  7081 00000CA7 3CFF                    	CMP	AL,0FFH
  7082 00000CA9 7510                    	JNZ	short interr		; not in memory
  7083                                  	
  7084                                  	; 06/01/2024
  7085 00000CAB B80314                  	mov	ax,1403h		; set country info
  7086                                  
  7087                                  	;cmp	bp,0
  7088 00000CAE 09ED                    	or	bp,bp			; GetCntry ?
  7089 00000CB0 7501                    	JNZ	short stcdpg
  7090                                  	
  7091                                  	;CallInstall GetCntry,NLSFUNC,4	; get country info
  7092                                  	;mov	ax,1404h
  7093 00000CB2 40                      	inc	ax	; AX = 1404h ; get country info
  7094                                  
  7095                                  	; 06/01/2024
  7096                                  	;int	2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  7097                                  	;		; BX = code page, DX = country code,
  7098                                  	;		; DS:SI -> internal code page structure
  7099                                  	;		; ES:DI -> user buffer
  7100                                  	;		; Return: AL = status
  7101                                  	;
  7102                                  	;JMP	short chkok
  7103                                  	
  7104                                  	;nop
  7105                                  
  7106                                  stcdpg:
  7107                                  	;CallInstall SetCodePage,NLSFUNC,3  ; set country info
  7108                                  	; 06/01/2024
  7109                                  	;mov     ax,1403h
  7110                                  gscdpg:
  7111 00000CB3 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - SET COUNTRY INFO
  7112                                  			; DS:SI -> internal code page structure
  7113                                  			; BX = code page, DX = country code
  7114                                  			; Return: AL = status
  7115                                  chkok:
  7116 00000CB5 08C0                    	or	al,al			; success ?
  7117                                  	;retz				; yes
  7118 00000CB7 74B0                    	jz	short RET27
  7119                                  
  7120                                  setcarry:
  7121 00000CB9 F9                      	STC				; set carry
  7122 00000CBA C3                      	retn
  7123                                  interr:
  7124 00000CBB B0FF                    	MOV	AL,0FFH			; flag nlsfunc error
  7125 00000CBD EBFA                    	JMP	short setcarry
  7126                                  
  7127                                  international_copy:
  7128                                  
  7129                                  ;hkn; country_cdpg is in DOSDATA segment.
  7130                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  7131                                  
  7132                                  	; MSDOS 3.3
  7133                                  	;;mov	bx,[SI+63h]
  7134                                  	;mov	BX,[SI+DOS_CCDPG.ccDosCountry]
  7135                                  	;mov	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; 08/09/2018
  7136                                  
  7137                                  	; 13/05/2019 - Retro DOS v4.0
  7138                                  
  7139                                  	; MSDOS 6.0
  7140                                  	;mov	bx,[ss:si+68h]
  7141 00000CBF 368B5C68                	MOV	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
  7142 00000CC3 BE[6C12]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; COUNTRY_CDPG + 108
  7143                                  
  7144                                  	;mov	cx,24
  7145 00000CC6 B91800                  	MOV	CX,OLD_COUNTRY_SIZE
  7146                                  
  7147                                  	; MSDOS 6.0
  7148                                  
  7149                                  ;hkn;	must set up DS to SS so that international info can be copied
  7150                                  	
  7151 00000CC9 1E                      	push	ds
  7152                                  
  7153 00000CCA 16                      	push	ss			; cs -> ss
  7154 00000CCB 1F                      	pop	ds
  7155                                  
  7156 00000CCC F3A4                    	REP	MOVSB			; copy country info
  7157                                  
  7158                                  	; MSDOS 6.0
  7159                                  
  7160 00000CCE 1F                      	pop	ds	;hkn;	restore ds
  7161                                  
  7162                                  international_ok3:
  7163 00000CCF E8AFF7                  	call	Get_User_Stack
  7164                                  ;ASSUME	DS:NOTHING
  7165                                  	;MOV	[SI+2],BX
  7166 00000CD2 895C02                  	MOV	[SI+user_env.user_BX],BX
  7167                                  international_ok:
  7168 00000CD5 89D8                    	MOV	AX,BX			; Return country code in AX too.
  7169                                  ;SYS_RET_OK_jmp:
  7170                                  	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7171                                  nono:	; 15/12/2022
  7172                                  SYS_RET_OK_jmp:
  7173 00000CD7 E95DF9                  	jmp	SYS_RET_OK
  7174                                  
  7175                                  international_set:
  7176                                  
  7177                                  ;hkn; ASSUME	DS:DOSGROUP
  7178                                  ;ASSUME	DS:DOSDATA
  7179                                  
  7180 00000CDA BD0100                  	MOV	BP,1			; flag it for SetCodePage only
  7181 00000CDD E8B5FF                  	CALL	international_get
  7182 00000CE0 73F3                    	JNC	short international_ok
  7183                                  errtn:
  7184 00000CE2 3CFF                    	CMP	AL,0FFH
  7185 00000CE4 7403                    	JZ	short errtn2
  7186                                  errtn1:
  7187 00000CE6 E957F9                  	jmp	SYS_RET_ERR		; return what we got from NLSFUNC
  7188                                  errtn2:
  7189                                  	;error	error_invalid_function	; NLSFUNC not existent
  7190                                  
  7191                                  	;mov	al,1
  7192 00000CE9 B001                    	mov	al,error_invalid_function 
  7193 00000CEB EBF9                    	jmp	short errtn1 ; 13/05/2019 - Retro DOS v4.0
  7194                                  ;errtn3:
  7195                                  ;	jmp	SYS_RET_ERR
  7196                                  
  7197                                  ;EndProc $INTERNATIONAL
  7198                                  
  7199                                  ; 19/07/2018
  7200                                  
  7201                                  ;BREAK <$GetExtCntry - return extended country-dependent information>
  7202                                  
  7203                                  ;----------------------------------------------------------------------------
  7204                                  ;
  7205                                  ; Procedure Name : $GetExtCntry
  7206                                  ;
  7207                                  ; Inputs:
  7208                                  ;	if AL >= 20H
  7209                                  ;	  AL= 20H    capitalize single char, DL= char
  7210                                  ;	      21H    capitalize string, CX= string length
  7211                                  ;	      22H    capitalize ASCIIZ string
  7212                                  ;	      23H    YES/NO check, DL=1st char DH= 2nd char (DBCS)
  7213                                  ;	      80H bit 0 = use normal upper case table
  7214                                  ;		      1 = use file upper case table
  7215                                  ;	   DS:DX points to string
  7216                                  ;
  7217                                  ;	else
  7218                                  ;
  7219                                  ;	MOV	AH,GetExtCntry	 ; DOS 3.3
  7220                                  ;	MOV	AL,INFO_ID	( info type,-1 selects all )
  7221                                  ;	MOV	BX,CODE_PAGE	( -1 = active code page )
  7222                                  ;	MOV	DX,COUNTRY_ID	( -1 = active country )
  7223                                  ;	MOV	CX,SIZE 	( amount of data to return )
  7224                                  ;	LES	DI,COUNTRY_INFO ( buffer for returned data )
  7225                                  ;	INT	21
  7226                                  ; Function:
  7227                                  ;	give users extended country dependent information
  7228                                  ;	or capitalize chars
  7229                                  ; Outputs:
  7230                                  ;	  No Carry:
  7231                                  ;	     extended country info is succesfully returned
  7232                                  ;	  Carry:
  7233                                  ;	     Register AX has the error code.
  7234                                  ;	     AX=0, NO	 for YES/NO CHECK
  7235                                  ;		1, YES
  7236                                  ;----------------------------------------------------------------------------
  7237                                  
  7238                                  ;procedure   $GetExtCntry,NEAR	; DOS 3.3
  7239                                  
  7240                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7241                                  
  7242                                  	; MSDOS 6.0
  7243                                  _$GetExtCntry:
  7244 00000CED 3C20                    	CMP	AL,CAP_ONE_CHAR 	; < 20H ?
  7245 00000CEF 7269                    	JB	short notcap
  7246                                  capcap: 				;
  7247 00000CF1 A880                    	TEST	AL,UPPER_TABLE	; 80h	; which upper case table
  7248 00000CF3 7505                    	JNZ	short fileupper		; file upper case
  7249                                  
  7250                                  ;hkn; UCASE_TAB in DOSDATA
  7251 00000CF5 BB[AF0A]                	MOV	BX,UCASE_TAB+2		; get normal upper case
  7252 00000CF8 EB05                    	JMP	SHORT capit
  7253                                  
  7254                                  fileupper:
  7255                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM - DOSCODE:4C57h)
  7256                                  	; ((Note: This must be a bugfix, because bit 7 of AX is 1 here!))
  7257                                  	; AL >= 80h
  7258 00000CFA 247F                    	and	al,7Fh 
  7259                                  
  7260                                  ;hkn; FILE_UCASE_TAB in DOSDATA
  7261 00000CFC BB[310B]                	MOV	BX,FILE_UCASE_TAB+2 ; get file upper case
  7262                                  capit:					;
  7263 00000CFF 3C20                    	CMP	AL,CAP_ONE_CHAR 	; cap one char ?
  7264 00000D01 750D                    	JNZ	short chkyes		; no
  7265 00000D03 88D0                    	MOV	AL,DL			; set up AL
  7266 00000D05 E88343                  	call	GETLET3 		; upper case it
  7267 00000D08 E876F7                  	call	Get_User_Stack		; get user stack
  7268                                  	;mov	[si+6],al
  7269 00000D0B 884406                  	MOV	[SI+user_env.user_DX],AL ; user's DL=AL
  7270 00000D0E EBC7                    	JMP	SHORT nono		; done
  7271                                  chkyes: 				;
  7272 00000D10 3C23                    	CMP	AL,CHECK_YES_NO	; 23h	; check YES or NO ?
  7273 00000D12 7522                    	JNZ	short capstring		; no
  7274                                  
  7275 00000D14 31C0                    	XOR	AX,AX			; presume NO
  7276                                  		      
  7277                                  ;hkn; NLS_YES, NLS_NO, NLS_yes2, NLS_no2 is defined in msdos.cl3 which is
  7278                                  ;hkn; included in yesno.asm in the DOSCODE segment.
  7279                                  
  7280                                  	; 06/08/2018 - Retro DOS v3.0
  7281                                  	; 13/05/2019 - Retro DOS v4.0
  7282                                  	;cmp	dl,'Y'
  7283 00000D16 2E3A16[150A]            	CMP	DL,[cs:NLS_YES]		; is 'Y' ?
  7284 00000D1B 7416                    	JZ	short yesyes		; yes
  7285                                  	;cmp	dl,'y'
  7286 00000D1D 2E3A16[170A]            	CMP	DL,[cs:NLS_yes2]	; is 'y' ?
  7287 00000D22 740F                    	JZ	short yesyes		; yes
  7288                                  	;cmp	dl,'N'
  7289 00000D24 2E3A16[160A]            	CMP	DL,[cs:NLS_NO]		; is  'N'?
  7290 00000D29 74AC                    	JZ	short nono		; no
  7291                                  	;cmp	dl,'n'
  7292 00000D2B 2E3A16[180A]            	CMP	DL,[cs:NLS_no2]		; is 'n' ?
  7293 00000D30 74A5                    	JZ	short nono		; no
  7294                                  ;dbcs_char:				;
  7295 00000D32 40                      	INC	AX			; not YES or NO
  7296                                  yesyes: 				;
  7297 00000D33 40                      	INC	AX			; return 1
  7298                                  	; 15/12/2022
  7299                                  ;nono:	
  7300 00000D34 EBA1                    	jmp	short SYS_RET_OK_jmp	;
  7301                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7302                                  	;jmp	SYS_RET_OK		; done
  7303                                  
  7304                                  capstring:				;
  7305 00000D36 89D6                    	MOV	SI,DX			; si=dx
  7306 00000D38 3C21                    	CMP	AL,CAP_STRING	; 21h	; cap string ?
  7307 00000D3A 750D                    	JNZ	short capascii		; no
  7308                                  	;OR	CX,CX			; check count 0
  7309                                  	;JZ	short nono		; yes finished
  7310                                  	; 06/01/2024
  7311 00000D3C E399                    	jcxz	nono
  7312                                  concap: 				;
  7313 00000D3E AC                      	LODSB				; get char
  7314 00000D3F E84943                  	call	GETLET3 		; upper case it
  7315 00000D42 8844FF                  	MOV	byte [SI-1],AL		; store back
  7316                                  ;next99: 				;
  7317 00000D45 E2F7                    	LOOP	concap			; continue
  7318 00000D47 EB8E                    	JMP	short nono		; done
  7319                                  capascii:				;
  7320 00000D49 3C22                    	CMP	AL,CAP_ASCIIZ	; 22h	; cap ASCIIZ string ?
  7321 00000D4B 7545                    	JNZ	short capinval		; no
  7322                                  concap2:				;
  7323 00000D4D AC                      	LODSB				; get char
  7324 00000D4E 08C0                    	or	al,al			; end of string ?
  7325 00000D50 7485                    	JZ	short nono		; yes
  7326 00000D52 E83643                  	call	GETLET3 		; upper case it
  7327 00000D55 8844FF                  	MOV	[SI-1],AL		; store back
  7328 00000D58 EBF3                    	JMP	short concap2 		; continue
  7329                                  
  7330                                  	; MSDOS 3.3 (& MSDOS 6.0)
  7331                                  
  7332                                  ; Offset 1A19h in IBMDOS.COM (MSDOS 3.3), 1987 	
  7333                                  ; _$GetExtCntry:
  7334                                  
  7335                                  notcap:
  7336 00000D5A 83F905                  	CMP	CX,5			; minimum size is 5
  7337 00000D5D 7277                    	jb	short sizeerror
  7338                                  
  7339                                  GEC_CONT:
  7340                                  ;hkn; SS is DOSDATA
  7341                                  	;context DS
  7342                                  
  7343 00000D5F 16                      	push	ss
  7344                                  	;pop	es  ; ! (Retro DOS v3.0 BUG) !
  7345 00000D60 1F                      	pop	ds  ; 13/05/2019 - Retro DOS v4.0	
  7346                                  	
  7347                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  7348 00000D61 BE[0012]                	MOV	SI,COUNTRY_CDPG
  7349                                  
  7350 00000D64 83FAFF                  	CMP	DX,-1			; active country ?
  7351 00000D67 7503                    	JNZ	short GETCDPG 		; no
  7352                                  
  7353                                  ;hkn; use DS override to accesss country_cdpg fields
  7354                                  	;;mov	dx,[si+63h] ; MSDOS 3.3
  7355                                  	;mov	dx,[si+68h] ; MSDOS 6.0
  7356 00000D69 8B5468                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]
  7357                                  					; get active country id;smr;use DS
  7358                                  GETCDPG:
  7359 00000D6C 83FBFF                  	CMP	BX,-1			; active code page?
  7360 00000D6F 7503                    	JNZ	short CHKAGAIN		; no, check again
  7361                                  
  7362                                  ;hkn; use DS override to accesss country_cdpg fields
  7363                                  	;;mov	bx,[si+65h] ; MSDOS 3.3	
  7364                                  	;mov	bx,[si+6Ah] ; MSDOS 6.0
  7365 00000D71 8B5C6A                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  7366                                  					; get active code page id;smr;Use DS
  7367                                  CHKAGAIN:
  7368                                  	;cmp	dx,[si+68h] ; MSDOS 6.0
  7369 00000D74 3B5468                  	CMP	DX,[SI+DOS_CCDPG.ccDosCountry]
  7370                                  					; same as active country id?;smr;use DS
  7371 00000D77 7550                    	JNZ	short CHKNLS		; no
  7372                                  	;cmp	bx,[si+6Ah] ; MSDOS 6.0	
  7373 00000D79 3B5C6A                  	CMP	BX,[SI+DOS_CCDPG.ccDosCodePage]	
  7374                                  					; same as active code pg id?;smr;use DS
  7375 00000D7C 754B                    	JNZ	short CHKNLS		; no
  7376                                  CHKTYPE:
  7377                                  	;mov	bx,[si+48h]
  7378 00000D7E 8B5C48                  	MOV	BX,[SI+DOS_CCDPG.ccSysCodePage]	
  7379                                  					; bx = sys code page id;smr;use DS
  7380 00000D81 51                      	PUSH	CX			; save cx
  7381                                  	;mov	cx,[si+4Ah]
  7382 00000D82 8B4C4A                  	MOV	CX,[SI+DOS_CCDPG.ccNumber_of_entries]  ;smr;use DS
  7383                                  	;mov	si,COUNTRY_CDPG+76
  7384 00000D85 BE[4C12]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccSetUcase   ;smr;CDPG in DOSDATA
  7385                                  NXTENTRY:
  7386 00000D88 3A04                    	CMP	AL,[SI] 		; compare info type;smr;use DS
  7387 00000D8A 740B                    	JZ	short FOUNDIT
  7388 00000D8C 83C605                  	ADD	SI,5			; next entry
  7389 00000D8F E2F7                    	LOOP	NXTENTRY
  7390 00000D91 59                      	POP	CX
  7391                                  capinval:
  7392                                  	;error	error_invalid_function	; info type not found
  7393                                  	;mov	al,1
  7394 00000D92 B001                    	mov	al,error_invalid_function
  7395                                  ;SYS_RET_ERR_jmp:
  7396                                  	;jmp	SYS_RET_ERR
  7397                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7398                                  SYS_RET_ERR_jmp:
  7399 00000D94 E9A9F8                  	jmp	SYS_RET_ERR	
  7400                                  
  7401                                  FOUNDIT:
  7402 00000D97 A4                      	MOVSB				; move info id byte
  7403 00000D98 59                      	POP	CX			; restore char count
  7404                                  	;cmp	al,1
  7405 00000D99 3C01                    	CMP	AL,SetCountryInfo	; select country info type ?
  7406 00000D9B 7415                    	JZ	short setsize
  7407 00000D9D B90400                  	MOV	CX,4			; 4 bytes will be moved
  7408 00000DA0 B80500                  	MOV	AX,5			; 5 bytes will be returned in CX
  7409                                  OK_RETN:
  7410 00000DA3 F3A4                    	REP	MOVSB			; copy info
  7411 00000DA5 89C1                    	MOV	CX,AX			; CX = actual length returned
  7412 00000DA7 89D8                    	MOV	AX,BX			; return sys code page in ax
  7413                                  GETDONE:
  7414 00000DA9 E8D5F6                  	call	Get_User_Stack		; return actual length to user's CX
  7415                                  	;mov	[si+4],cx 
  7416 00000DAC 894C04                  	MOV	[SI+user_env.user_CX],CX
  7417                                  	;jmp	SYS_RET_OK
  7418                                  	; 15/12/2022
  7419                                  	; 25/06/2019
  7420 00000DAF E988F8                  	jmp	SYS_RET_OK_clc
  7421                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7422                                  	; 15/12/2022
  7423                                  ;nono_jmp:
  7424                                  	;jmp	short nono
  7425                                  setsize:
  7426 00000DB2 83E903                  	SUB	CX,3			; size after length field
  7427 00000DB5 390C                    	CMP	[SI],CX			; less than table size ;smr;use ds
  7428 00000DB7 7302                    	JAE	short setsize2		; no
  7429 00000DB9 8B0C                    	MOV	CX,[SI]			; truncate to table size ;smr;use ds
  7430                                  setsize2:
  7431 00000DBB 26890D                  	MOV	[ES:DI],CX		; copy actual length to user's
  7432                                  	;ADD	DI,2			; update index
  7433                                  	;ADD	SI,2
  7434                                  	; 06/01/2024
  7435 00000DBE 47                      	inc	di
  7436 00000DBF 47                      	inc	di
  7437 00000DC0 46                      	inc	si
  7438 00000DC1 46                      	inc	si
  7439 00000DC2 89C8                    	MOV	AX,CX
  7440 00000DC4 83C003                  	ADD	AX,3			; AX has the actual length
  7441 00000DC7 EBDA                    	JMP	short OK_RETN 		; go move it
  7442                                  CHKNLS:
  7443 00000DC9 30E4                    	XOR	AH,AH
  7444                                  	;PUSH	AX			; save info type
  7445                                  	;POP	BP			; bp = info type
  7446                                  	; 06/01/2024
  7447 00000DCB 89C5                    	mov	bp,ax
  7448                                  	
  7449                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7450 00000DCD B80014                  	mov     ax,1400h
  7451 00000DD0 CD2F                    	int     2Fh     ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7452                                  			; Return: AL = 00h not installed, OK to install
  7453                                  			; 01h not installed, not OK
  7454                                  			; FFh installed
  7455 00000DD2 3CFF                    	CMP	AL,0FFH
  7456 00000DD4 7404                    	JZ	short NLSNXT		; in memory
  7457                                  
  7458                                  sizeerror:
  7459                                  	;error	error_invalid_function
  7460                                  	;mov	al,1
  7461 00000DD6 B001                    	mov	al,error_invalid_function
  7462                                  	;jmp	SYS_RET_ERR
  7463                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7464                                  sys_ret_err_jmp2:
  7465 00000DD8 EBBA                    	jmp	short SYS_RET_ERR_jmp
  7466                                  
  7467                                  NLSNXT: 
  7468                                  	;CallInstall GetExtInfo,NLSFUNC,2 ;get extended info
  7469 00000DDA B80214                  	mov     ax,1402h
  7470 00000DDD CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  7471                                  			; BP = subfunction, BX = code page
  7472                                  			; DX = country code, DS:SI -> internal code page structure
  7473                                  			; ES:DI -> user buffer, CX = size of user buffer
  7474                                  			; Return: AL = status
  7475                                  			; 00h successful
  7476                                  			; else DOS error code
  7477                                  
  7478 00000DDF 3C00                    	CMP	AL,0			; success ?
  7479 00000DE1 7505                    	JNZ	short NLSERROR
  7480                                  	;mov	ax,[si+48h] ; 13/05/2019
  7481 00000DE3 8B4448                  	MOV	AX,[SI+DOS_CCDPG.ccSysCodePage]
  7482                                  			; ax = sys code page id;smr;use ds;
  7483                                  			;BUGBUG;check whether DS is OK after the above calls
  7484 00000DE6 EBC1                    	JMP	short GETDONE
  7485                                  seterr:
  7486                                  	; 15/12/2022
  7487                                  NLSERROR:
  7488                                  	;jmp	SYS_RET_ERR		; return what is got from NLSFUNC
  7489                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7490                                  	;jmp	short sys_ret_err_jmp2
  7491                                  	; 15/12/2022
  7492 00000DE8 EBAA                    	jmp	short SYS_RET_ERR_jmp
  7493                                  
  7494                                  ;EndProc $GetExtCntry
  7495                                  
  7496                                  ; 13/05/2019 - Retro DOS v4.0
  7497                                  ; DOSCODE:4BD6h (MSDOS 6.21, MSDOS.SYS)
  7498                                  
  7499                                  ;BREAK <$GetSetCdPg - get or set global code page>
  7500                                  ;----------------------------------------------------------------------------
  7501                                  ;**	$GetSetCdPg - Get or Set Global Code Page
  7502                                  ;
  7503                                  ;   System call format:
  7504                                  ;
  7505                                  ;	MOV	AH,GetSetCdPg	; DOS 3.3
  7506                                  ;	MOV	AL,n		; n = 1 : get code page, n = 2 : set code page
  7507                                  ;	MOV	BX,CODE_PAGE	(set code page only)
  7508                                  ;	INT	21
  7509                                  ;
  7510                                  ;	ENTRY	(al) = n
  7511                                  ;		(bx) = code page
  7512                                  ;	EXIT	'C' clear
  7513                                  ;		  global code page is set	(set global code page)
  7514                                  ;		  (BX) = active code page id	(get global code page)
  7515                                  ;		  (DX) = system code page id	(get global code page)
  7516                                  ;		'C' set
  7517                                  ;		  (AX) = error code
  7518                                  
  7519                                  ;procedure  $GetSetCdPg,NEAR   ; DOS 3.3
  7520                                  
  7521                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7522                                  	; DOSCODE:4BC9h
  7523                                  
  7524                                  _$GetSetCdPg:
  7525                                  
  7526                                  ;hkn; SS is DOSDATA
  7527                                  	;context DS
  7528                                  
  7529 00000DEA 16                      	push	ss
  7530 00000DEB 1F                      	pop	ds
  7531                                  
  7532                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  7533 00000DEC BE[0012]                	MOV	SI,COUNTRY_CDPG	  ; (DOSDATA:122Ah for MSDOS 6.21)
  7534                                  
  7535 00000DEF 3C01                    	CMP	AL,1		       ; get global code page
  7536 00000DF1 7512                    	JNZ	short setglpg 	       ; set global code page
  7537                                  	
  7538                                  	;;mov	bx,[si+65h] ; MSDOS 3.3
  7539                                  	;mov	bx,[si+6Ah] ; MSDOS 6.0
  7540 00000DF3 8B5C6A                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  7541                                  					; get active code page id;smr;use ds
  7542                                  	;mov	dx,[si+48h]
  7543 00000DF6 8B5448                  	MOV	DX,[SI+DOS_CCDPG.ccSysCodePage]
  7544                                  				  	; get sys code page id;smr;use ds
  7545 00000DF9 E885F6                  	call	Get_User_Stack
  7546                                  ;ASSUME DS:NOTHING
  7547                                  	;;mov	[si+2],bx
  7548                                  	;MOV	[SI+user_env.user_BX],BX ; update returned bx
  7549                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7550 00000DFC E85BFE                  	call    set_user_bx	; MOV [SI+user_env.user_BX],BX 
  7551                                  	;mov	[si+6],dx
  7552 00000DFF 895406                  	MOV	[SI+user_env.user_DX],DX ; update returned dx
  7553                                  OK_RETURN:
  7554                                  	; 15/12/2022
  7555                                  	;transfer SYS_RET_OK
  7556 00000E02 E932F8                  	jmp	SYS_RET_OK
  7557                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7558                                  	;jmp	short nono_jmp
  7559                                  
  7560                                  ;hkn; ASSUME DS:DOSGROUP
  7561                                  ;ASSUME	DS:DOSDATA
  7562                                  
  7563                                  setglpg:
  7564 00000E05 3C02                    	CMP	AL,2
  7565 00000E07 752F                    	JNZ	short nomem
  7566                                  	
  7567                                  	;;mov	dx,[si+63h] ; MSDOS 3.3
  7568                                  	;mov	dx,[si+68h] ; MSDOS 6.0
  7569 00000E09 8B5468                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]	;smr;use ds
  7570                                  	
  7571                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7572 00000E0C B80014                  	mov     ax,1400h
  7573 00000E0F CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7574                                  			; Return: AL = 00h not installed, OK to install
  7575                                  			; 01h not installed, not OK
  7576                                  			; FFh installed
  7577 00000E11 3CFF                    	CMP	AL,0FFH
  7578 00000E13 7523                    	JNZ	short nomem		; not in memory
  7579                                  
  7580                                  	;CallInstall SetCodePage,NLSFUNC,1 ;set the code page
  7581 00000E15 B80114                  	mov     ax,1401h
  7582 00000E18 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - CHANGE CODE PAGE
  7583                                  			; DS:SI -> internal code page structure
  7584                                  			; BX = new code page, DX = country code???
  7585                                  			; Return: AL = status
  7586                                  			; 00h successful
  7587                                  			; else DOS error code
  7588                                  	;cmp	al,0
  7589 00000E1A 08C0                    	or	al,al			; success ?
  7590 00000E1C 74E4                    	JZ	short OK_RETURN		; yes
  7591                                  
  7592 00000E1E 3C41                    	CMP	AL,65			; set device code page failed
  7593 00000E20 75C6                    	JNZ	short seterr
  7594                                  	;MOV	AX,65
  7595                                  	; 06/01/2024
  7596 00000E22 98                      	cbw
  7597 00000E23 A3[2403]                	MOV	[EXTERR],AX
  7598                                  	;mov	byte [EXTERR_ACTION],6
  7599                                  	;mov	byte [EXTERR_CLASS],5
  7600                                  	;mov	byte [EXTERR_LOCUS],4
  7601 00000E26 C606[2603]06            	MOV	byte [EXTERR_ACTION],errACT_Ignore
  7602 00000E2B C606[2703]05            	MOV	byte [EXTERR_CLASS],errCLASS_HrdFail
  7603 00000E30 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
  7604                                  	;transfer From_GetSet
  7605 00000E35 E910F8                  	jmp	From_GetSet
  7606                                  
  7607                                  	; 15/12/2022
  7608                                  ;seterr:
  7609                                  	;;;transfer SYS_RET_ERR
  7610                                  	;;jmp	SYS_RET_ERR
  7611                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7612                                  	;jmp	short NLSERROR
  7613                                  
  7614                                  nomem:
  7615                                  	;error	error_invalid_function	; function not defined
  7616                                  	;mov	al,1
  7617 00000E38 B001                    	mov	al,error_invalid_function
  7618 00000E3A EBAC                    	jmp	short seterr
  7619                                  
  7620                                  ;EndProc $GetSetCdPg
  7621                                  
  7622                                  ; 09/01/2024
  7623                                  ; 13/05/2019 - Retro DOS v4.0
  7624                                  ; DOSCODE:4C2Bh (MSDOS 6.21, MSDOS.SYS)
  7625                                  
  7626                                  ;BREAK <$Get_Drive_Freespace -- Return bytes of free disk space on a drive>
  7627                                  ;----------------------------------------------------------------------------
  7628                                  ;**	$Get_Drive_Freespace - Return amount of drive free space
  7629                                  ;
  7630                                  ;	$Get_Drive_Freespace returns the # of free allocation units on a
  7631                                  ;		drive.
  7632                                  ;
  7633                                  ;	This call returns the same info in the same registers (except for the
  7634                                  ;	FAT pointer) as the old FAT pointer calls
  7635                                  ;
  7636                                  ;	ENTRY	DL = Drive number
  7637                                  ;	EXIT	AX = Sectors per allocation unit
  7638                                  ;		   = -1 if bad drive specified
  7639                                  ;		On User Stack
  7640                                  ;		    BX = Number of free allocation units
  7641                                  ;		    DX = Total Number of allocation units on disk
  7642                                  ;		    CX = Sector size
  7643                                  
  7644                                  ;procedure   $GET_DRIVE_FREESPACE,NEAR
  7645                                  
  7646                                  _$GET_DRIVE_FREESPACE:
  7647                                  
  7648                                  ;hkn; SS is DOSDATA
  7649                                  	;context DS
  7650 00000E3C 16                      	push	ss
  7651 00000E3D 1F                      	pop	ds
  7652                                  
  7653 00000E3E 88D0                    	MOV	AL,DL
  7654                                  	;invoke	GetThisDrv		; Get drive
  7655 00000E40 E8745C                  	call	GETTHISDRV
  7656                                  SET_AX_RET:
  7657 00000E43 7212                    	JC	short BADFDRV
  7658                                  	;invoke	DISK_INFO
  7659 00000E45 E8BB1E                  	call	DISK_INFO
  7660 00000E48 87D3                    	XCHG	DX,BX
  7661                                  	;JC	short SET_AX_RET	; User FAILed to I 24
  7662                                  	; 06/01/2024
  7663 00000E4A 720B                    	jc	short BADFDRV
  7664 00000E4C 30E4                    	XOR	AH,AH			; Chuck Fat ID byte
  7665                                  DoSt:
  7666 00000E4E E830F6                  	call	Get_User_Stack
  7667                                  ;ASSUME	DS:NOTHING
  7668                                  	;mov	[si+6],dx
  7669                                  	;;mov	[si+4],cx
  7670                                  	;;mov	[si+2],bx
  7671                                  	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7672 00000E51 895406                  	MOV	[SI+user_env.user_DX],DX ; total clusters
  7673                                  	;MOV	[SI+user_env.user_CX],CX
  7674                                  	;MOV	[SI+user_env.user_BX],BX
  7675                                  	;;MOV	[SI+user_env.user_AX],AX
  7676                                  	;mov	[si],ax
  7677                                  	;;return
  7678                                  	;retn
  7679                                  	; 09/01/2024
  7680 00000E54 E9FEFD                  	jmp     gdrvfspc_ret    ; ax = sectors per cluster (modified)
  7681                                  
  7682                                  BADFDRV:
  7683                                  	; MSDOS 3.3
  7684                                  	;;mov	al,0Fh
  7685                                  	;mov	al,error_invalid_drive	; Assume error
  7686                                  
  7687                                  	; 13/05/2019 - Retro DOS v4.0
  7688                                  
  7689                                  	; MSDOS 6.0 & MSDOS 3.3
  7690                                  	;invoke	FCB_RET_ERR
  7691 00000E57 E8FCF7                  	call	FCB_RET_ERR
  7692                                  	
  7693 00000E5A B8FFFF                  	MOV	AX,-1
  7694 00000E5D EBEF                    	JMP	short DoSt
  7695                                  
  7696                                  ;EndProc $GET_DRIVE_FREESPACE
  7697                                  
  7698                                  ;	BREAK <$Get_DMA, $Set_DMA -- Get/Set current DMA address>
  7699                                  ;----------------------------------------------------------------------------
  7700                                  ;**	$Get_DMA - Get Disk Transfer Address
  7701                                  ;
  7702                                  ;	ENTRY	none
  7703                                  ;	EXIT	ES:BX is current transfer address
  7704                                  ;	USES	all
  7705                                  
  7706                                  	; 09/01/2024
  7707                                  _$GET_DMA:
  7708 00000E5F 368B1E[2C03]            	MOV	BX,[SS:DMAADD]
  7709 00000E64 368B0E[2E03]            	MOV	CX,[SS:DMAADD+2]
  7710 00000E69 E815F6                  	call	Get_User_Stack
  7711                                  	;mov	[si+2],bx
  7712                                  	;mov	[si+10h],cx
  7713                                  	; 09/01/2024
  7714                                  	;MOV	[SI+user_env.user_BX],BX
  7715 00000E6C 894C10                  	MOV	[SI+user_env.user_ES],CX
  7716                                  	;retn
  7717                                  	; 09/01/2024
  7718 00000E6F E9E8FD                  	jmp	set_user_bx ; (PCDOS 7.1 IBMDOS.COM)
  7719                                  
  7720                                  ;**	$Set_DMA - Set Disk Transfer Address
  7721                                  ;----------------------------------------------------------------------------
  7722                                  ;	ENTRY	DS:DX is current transfer address
  7723                                  ;	EXIT	none
  7724                                  ;	USES	all
  7725                                  
  7726                                  _$SET_DMA:
  7727 00000E72 368916[2C03]            	MOV	[SS:DMAADD],DX
  7728 00000E77 368C1E[2E03]            	MOV	[SS:DMAADD+2],DS
  7729 00000E7C C3                      	retn
  7730                                  
  7731                                  ;	BREAK <$Get_Default_Drive, $Set_Default_Drive -- Set/Get default drive>
  7732                                  ;------------------------------------------------------------------------------
  7733                                  
  7734                                  ;**	$Get_Default_Drive - Get Current Default Drive
  7735                                  ;-----------------------------------------------------
  7736                                  ;	ENTRY	none
  7737                                  ;	EXIT	(AL) = drive number
  7738                                  ;	USES	all
  7739                                  
  7740                                  _$GET_DEFAULT_DRIVE:
  7741 00000E7D 36A0[3603]              	MOV	AL,[SS:CURDRV]
  7742 00000E81 C3                      	retn
  7743                                  
  7744                                  ;**	$Set_Default_Drive - Specify new Default Drive
  7745                                  ;-----------------------------------------------------
  7746                                  ;	ENTRY	(DL) = Drive number for new default drive
  7747                                  ;	EXIT	(AL) = Number of drives, NO ERROR RETURN IF DRIVE NUMBER BAD
  7748                                  
  7749                                  _$SET_DEFAULT_DRIVE:
  7750 00000E82 88D0                    	MOV	AL,DL
  7751 00000E84 FEC0                    	INC	AL			; A=1, B=2...
  7752 00000E86 E8125C                  	call	GetVisDrv		; see if visible drive
  7753 00000E89 7204                    	JC	short SETRET		; errors do not set
  7754 00000E8B 36A2[3603]              	MOV	[SS:CURDRV],AL		; no, set
  7755                                  
  7756                                  SETRET:
  7757 00000E8F 36A0[4700]              	MOV	AL,[SS:CDSCOUNT]	; let user see what the count really is
  7758 00000E93 C3                      	retn
  7759                                  
  7760                                  ;BREAK <$Get/Set_Interrupt_Vector - Get/Set interrupt vectors>
  7761                                  ;----------------------------------------------------------------------------
  7762                                  
  7763                                  ;**	$Get_Interrupt_Vector - Get Interrupt Vector
  7764                                  ;---------------------------------------------------
  7765                                  ;	$Get_Interrupt_Vector is the official way for user pgms to get the
  7766                                  ;	contents of an interrupt vector.
  7767                                  ;
  7768                                  ;	ENTRY	(AL) = interrupt number
  7769                                  ;	EXIT	(ES:BX) = current interrupt vector
  7770                                  
  7771                                  _$GET_INTERRUPT_VECTOR:
  7772 00000E94 E82E00                  	CALL	RECSET
  7773 00000E97 26C41F                  	LES	BX,[ES:BX]
  7774 00000E9A E8E4F5                  	call	Get_User_Stack
  7775                                  set_user_es_bx:
  7776                                  	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7777                                  	;;mov	[si+2],bx
  7778                                  	;mov	[si+10h],es
  7779                                  	;MOV	[SI+user_env.user_BX],BX
  7780 00000E9D 8C4410                  	MOV	[SI+user_env.user_ES],ES
  7781                                  	;retn
  7782 00000EA0 E9B7FD                  	jmp	set_user_bx
  7783                                  
  7784                                  ;**	$Set_Interrupt_Vector - Set Interrupt Vector
  7785                                  ;---------------------------------------------------
  7786                                  ;	$Set_Interrupt_Vector is the official way for user pgms to set the
  7787                                  ;	contents of an interrupt vector.
  7788                                  ;
  7789                                  ;	M004, M068: Also set A20OFF_COUNT to 1 if EXECA20OFF bit has been set 
  7790                                  ;	and if A20OFF_COUNT is non-zero. See under tag M003 in inc\dossym.inc 
  7791                                  ;	for explanation.
  7792                                  ;
  7793                                  ;	ENTRY	(AL) = interrupt number
  7794                                  ;		(ds:dx) = desired new vector value
  7795                                  ;	EXIT	none
  7796                                  ;	USES	all
  7797                                  
  7798                                  ; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7799                                  ; 13/05/2019 - Retro DOS v4.0
  7800                                  
  7801                                  _$SET_INTERRUPT_VECTOR:
  7802 00000EA3 E81F00                  	CALL	RECSET
  7803 00000EA6 FA                      	CLI				; Watch out!!!!! Folks sometimes use
  7804 00000EA7 268917                  	MOV	[ES:BX],DX		;   this for hardware ints (like timer).
  7805 00000EAA 268C5F02                	MOV	[ES:BX+2],DS
  7806 00000EAE FB                      	STI
  7807                                  					; M004, M068 - Start
  7808                                  	; MSDOS 6.0
  7809 00000EAF 36F606[8600]04          	test	byte [ss:DOS_FLAG],EXECA20OFF ; 4
  7810                                  					; Q: was the previous call an int 21h
  7811                                  					;    exec call
  7812                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7813                                  	;jnz	short siv_1		; Y: go set count
  7814                                  	;retn				; N: return
  7815                                  	; 15/12/2022
  7816 00000EB5 740D                    	jz	short siv_2
  7817                                  siv_1:	
  7818 00000EB7 36803E[8500]00          	cmp	byte [ss:A20OFF_COUNT],0 ; Q: is count 0
  7819 00000EBD 7505                    	jnz	short siv_2		 ; N: done
  7820                                  	; 20/09/2023
  7821 00000EBF 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]
  7822                                  	;mov	byte [ss:A20OFF_COUNT],1 ; Y: set it to 1 to indicate to dos
  7823                                  					 ; dispatcher to turn A20 Off before
  7824                                  					 ; returning to user.
  7825                                  siv_2:
  7826                                  	; 07/12/2022
  7827 00000EC4 C3                      	retn				; M004, M068 - End
  7828                                  	
  7829                                  RECSET:
  7830 00000EC5 31DB                    	XOR	BX,BX
  7831 00000EC7 8EC3                    	MOV	ES,BX
  7832 00000EC9 88C3                    	MOV	BL,AL
  7833 00000ECB D1E3                    	SHL	BX,1
  7834 00000ECD D1E3                    	SHL	BX,1
  7835 00000ECF C3                      	retn
  7836                                  
  7837                                  ;	BREAK <$Char_Oper - hack on paths, switches so that xenix can look like PCDOS>
  7838                                  ;-------------------------------------------------------------------------------------
  7839                                  
  7840                                  ;**	$Char_Oper - Manipulate Switch Character
  7841                                  ;
  7842                                  ;	This function was put in to facilitate XENIX path/switch compatibility
  7843                                  ;
  7844                                  ;	ENTRY	AL = function:
  7845                                  ;		    0 - read switch char
  7846                                  ;		    1 - set switch char (char in DL)
  7847                                  ;		    2 - read device availability
  7848                                  ;			Always returns available
  7849                                  ;		    3 - set device availability
  7850                                  ;			No longer supported (NOP)
  7851                                  ;	EXIT	(al) = 0xff iff error
  7852                                  ;		(al) != 0xff if ok
  7853                                  ;		  (dl) = character/flag, if "read switch char" subfunction
  7854                                  ;	USES	AL, DL
  7855                                  ;
  7856                                  ;	NOTE	This already obsolete function has been deactivated in DOS 5.0
  7857                                  ;		The character / is always returned for subfunction 0,
  7858                                  ;		subfunction 2 always returns -1, all other subfunctions are ignored.
  7859                                  
  7860                                  ; 13/05/2019 - Retro DOS v4.0
  7861                                  ; DOSCODE:4CC9h (MSDOS 6.21, MSDOS.SYS)
  7862                                  
  7863                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7864                                  ; DOSCODE:4CBCh (MSDOS 5.0, MSDOS.SYS)
  7865                                  
  7866                                  _$CHAR_OPER:
  7867                                  	; MSDOS 6.0
  7868 00000ED0 08C0                    	or	al,al				; get switch?
  7869 00000ED2 B22F                    	mov	dl,'/'				; assume yes
  7870 00000ED4 7407                    	jz	short chop_1			; jump if yes
  7871 00000ED6 3C02                    	cmp	al,2				; check device availability?
  7872 00000ED8 B2FF                    	mov	dl,-1				; assume yes
  7873 00000EDA 7401                    	jz	short chop_1			; jump if yes
  7874 00000EDC C3                      	retn					; otherwise just quit
  7875                                  
  7876                                  ; subfunctions requiring return of value to user come here. DL holds
  7877                                  ; value to return
  7878                                  
  7879                                  chop_1:
  7880 00000EDD E8A1F5                  	call	Get_User_Stack
  7881 00000EE0 895406                  	mov	[SI+user_env.user_DX],dx	; store value for user
  7882 00000EE3 C3                      	retn
  7883                                  
  7884                                  	; MSDOS 3.3
  7885                                  	; Offset 1B87h in IBMDOS.COM (MSDOS 3.3), 1987
  7886                                  	;push	ss
  7887                                  	;pop	ds
  7888                                  	;cmp	al,1
  7889                                  	;jb	short chop_1
  7890                                  	;jz	short chop_2
  7891                                  	;cmp	al,3
  7892                                  	;jb	short chop_3
  7893                                  	;jz	short chop_5
  7894                                  	;mov	al,0FFh
  7895                                  	;retn
  7896                                  ;chop_1:
  7897                                  	;mov	dl,[chSwitch]
  7898                                  	;jmp	short chop_4
  7899                                  ;chop_2:
  7900                                  	;mov	[chSwitch],dl
  7901                                  	;retn
  7902                                  ;chop_3:
  7903                                  	;mov	dl, FFh
  7904                                  ;chop_4:
  7905                                  	;call	Get_User_Stack
  7906                                  	;mov	[si+6],dx
  7907                                  ;chop_5:
  7908                                  	;retn
  7909                                  
  7910                                  ;**	$GetExtendedError - Return Extended error code
  7911                                  ;----------------------------------------------------------------------------
  7912                                  ;	This function reads up the extended error info from the static
  7913                                  ;	variables where it was stored.
  7914                                  ;
  7915                                  ;	ENTRY	none
  7916                                  ;	EXIT	AX = Extended error code (0 means no extended error)
  7917                                  ;		BL = recommended action
  7918                                  ;		BH = class of error
  7919                                  ;		CH = locus of error
  7920                                  ;		ES:DI = may be pointer
  7921                                  ;	USES	ALL
  7922                                  
  7923                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7924                                  
  7925                                  _$GetExtendedError:
  7926 00000EE4 16                      	push	ss
  7927 00000EE5 1F                      	pop	ds
  7928 00000EE6 A1[2403]                	MOV	AX,[EXTERR]
  7929 00000EE9 C43E[2803]              	LES	DI,[EXTERRPT]
  7930 00000EED 8B1E[2603]              	MOV	BX,[EXTERR_ACTION]	; BL = Action, BH = Class
  7931 00000EF1 8A2E[2303]              	MOV	CH,[EXTERR_LOCUS]
  7932 00000EF5 E889F5                  	call	Get_User_Stack
  7933                                  	;mov	[si+0Ah],di
  7934 00000EF8 897C0A                  	MOV	[SI+user_env.user_DI],DI
  7935                                  
  7936                                  	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7937                                  	;;mov	[si+10h],es
  7938                                  	;MOV	[SI+user_env.user_ES],ES
  7939                                  	;;mov	[si+2],bx
  7940                                  	;MOV	[SI+user_env.user_BX],BX
  7941 00000EFB E89FFF                  	call	set_user_es_bx
  7942                                  
  7943                                  	;mov	[si+4],cx
  7944 00000EFE 894C04                  	MOV	[SI+user_env.user_CX],CX
  7945                                  jmp_SYS_RET_OK:
  7946                                  	; 15/12/2022
  7947                                  	;jmp	SYS_RET_OK
  7948                                  	; 25/06/2019
  7949 00000F01 E936F7                  	jmp	SYS_RET_OK_clc ; 15/12/2022
  7950                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7951                                  ;jmp_SYS_RET_OK:
  7952                                  	;jmp	SYS_RET_OK
  7953                                  
  7954                                  ; --------------------------------------------------------------------------
  7955                                  ; 09/01/2024
  7956                                  %if 0
  7957                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7958                                  	; DOSCODE:4CF3h
  7959                                  ;patch_or_unknown:
  7960                                  ;get_code_page:
  7961                                  	push    si
  7962                                  	mov     si, COUNTRY_CDPG
  7963                                  	;mov	ax, [si+DOS_CCDPG.ccDosCodePage]
  7964                                  	mov     ax, [ss:si+6Ah]
  7965                                  	pop     si
  7966                                  	retn
  7967                                  %endif
  7968                                  ; --------------------------------------------------------------------------
  7969                                  
  7970                                  ; 29/04/2019 - Retro DOS v4.0
  7971                                  
  7972                                  ;BREAK	<ECS_call - Extended Code System support function>
  7973                                  ;---------------------------------------------------------------------------
  7974                                  ; Inputs:
  7975                                  ;	AL = 0	get lead byte table
  7976                                  ;		on return DS:SI has the table location
  7977                                  ;
  7978                                  ;	AL = 1	set / reset interim console flag
  7979                                  ;		DL = flag (00H or 01H)
  7980                                  ;		no return
  7981                                  ;
  7982                                  ;	AL = 2	get interim console flag
  7983                                  ;		on return DL = current flag value
  7984                                  ;
  7985                                  ;	AL = OTHER then error, and returns with:
  7986                                  ;		AX = error_invalid_function
  7987                                  ;
  7988                                  ;  NOTE: THIS CALL DOES GUARANTEE THAT REGISTER OTHER THAN
  7989                                  ;	 SS:SP WILL BE PRESERVED!
  7990                                  ;---------------------------------------------------------------------------
  7991                                  
  7992                                  _$ECS_Call:
  7993 00000F04 08C0                    	or	al,al			; AL = 0 (get table)?
  7994                                  	;jnz	short _okok
  7995                                  	; 15/12/2022
  7996 00000F06 7403                    	jz	short get_lbt
  7997                                  ;_okok:
  7998 00000F08 E92CF7                  	jmp	SYS_RET_OK
  7999                                  get_lbt:
  8000 00000F0B E873F5                  	call	Get_User_Stack		; *
  8001                                  
  8002                                  ;hkn; dbcs_table moved low to dosdata
  8003                                  	;mov	word [si+8],DBCS_TAB+2
  8004 00000F0E C74408[E50C]            	mov	word [si+user_env.user_SI],DBCS_TAB+2
  8005                                  
  8006 00000F13 06                      	push	es
  8007                                  	;getdseg <es>			; es = DOSDATA
  8008 00000F14 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  8009                                  	;mov	[si+14],es
  8010 00000F19 8C440E                  	mov	[SI+user_env.user_DS],es
  8011 00000F1C 07                      	pop	es
  8012                                  
  8013                                  	; 15/12/2022
  8014 00000F1D EBE2                    	jmp	short jmp_SYS_RET_OK ; jmp SYS_RET_OK_clc ; *
  8015                                  ;_okok:
  8016                                  	; 15/12/2022	
  8017                                  	;;transfer SYS_RET_OK
  8018                                  	;jmp	short jmp_SYS_RET_OK
  8019                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8020                                  	;;jmp	SYS_RET_OK
  8021                                  	;jmp	short jmp_SYS_RET_OK
  8022                                  
  8023                                  ;============================================================================
  8024                                  ; PARSE.ASM, MSDOS 6.0, 1991
  8025                                  ;============================================================================
  8026                                  ; 19/07/2018 - Retro DOS v3.0
  8027                                  ; 15/05/2019 - Retro DOS v4.0
  8028                                  
  8029                                  ; System calls for parsing command lines
  8030                                  ;
  8031                                  ;   $PARSE_FILE_DESCRIPTOR
  8032                                  ;
  8033                                  ;   Modification history:
  8034                                  ;
  8035                                  ;       Created: ARR 30 March 1983
  8036                                  ;               EE PathParse 10 Sept 1983
  8037                                  ;
  8038                                  
  8039                                  ;BREAK <$Parse_File_Descriptor -- Parse an arbitrary string into an FCB>
  8040                                  ;---------------------------------------------------------------------------
  8041                                  ; Inputs:
  8042                                  ;       DS:SI Points to a command line
  8043                                  ;       ES:DI Points to an empty FCB
  8044                                  ;       Bit 0 of AL = 1 At most one leading separator scanned off
  8045                                  ;                   = 0 Parse stops if separator encountered
  8046                                  ;       Bit 1 of AL = 1 If drive field blank in command line - leave FCB
  8047                                  ;                   = 0  "    "    "     "         "      "  - put 0 in FCB
  8048                                  ;       Bit 2 of AL = 1 If filename field blank - leave FCB
  8049                                  ;                   = 0  "       "      "       - put blanks in FCB
  8050                                  ;       Bit 3 of AL = 1 If extension field blank - leave FCB
  8051                                  ;                   = 0  "       "      "        - put blanks in FCB
  8052                                  ; Function:
  8053                                  ;       Parse command line into FCB
  8054                                  ; Returns:
  8055                                  ;       AL = 1 if '*' or '?' in filename or extension, 0 otherwise
  8056                                  ;       DS:SI points to first character after filename
  8057                                  ;---------------------------------------------------------------------------
  8058                                  
  8059                                  _$PARSE_FILE_DESCRIPTOR:
  8060 00000F1F E80B40                  	call	MAKEFCB
  8061 00000F22 56                      	PUSH    SI
  8062 00000F23 E85BF5                  	call	Get_User_Stack
  8063                                  	;pop	word [si+8]
  8064 00000F26 8F4408                  	POP     word [SI+user_env.user_SI]
  8065 00000F29 C3                      	retn
  8066                                  
  8067                                  ;============================================================================
  8068                                  ; MISC.ASM, MSDOS 6.0, 1991
  8069                                  ;============================================================================
  8070                                  ; 19/07/2018 - Retro DOS v3.0
  8071                                  
  8072                                  ; 29/04/2019 - Retro DOS v4.0
  8073                                  
  8074                                  ;ENTRYPOINTSEG	EQU	0CH
  8075                                  ;MAXDIF		EQU	0FFFH
  8076                                  ;SAVEXIT 	EQU	10
  8077                                  ;WRAPOFFSET	EQU	0FEF0h
  8078                                  
  8079                                  ;
  8080                                  ;----------------------------------------------------------------------------
  8081                                  ;
  8082                                  ;**	$SLEAZEFUNC - Get a Pointer to the Media Byte
  8083                                  ;
  8084                                  ;	Return Stuff sort of like old get fat call
  8085                                  ;
  8086                                  ;	ENTRY	none
  8087                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  8088                                  ;			GOD help anyone who tries to do ANYTHING except
  8089                                  ;			READ this ONE byte.
  8090                                  ;		DX = Total Number of allocation units on disk
  8091                                  ;		CX = Sector size
  8092                                  ;		AL = Sectors per allocation unit
  8093                                  ;		   = -1 if bad drive specified
  8094                                  ;	USES	all
  8095                                  ;
  8096                                  ;**	$SLEAZEFUNCDL - Get a Pointer to the Media Byte
  8097                                  ;
  8098                                  ;	Identical to $SLEAZEFUNC except (dl) = drive
  8099                                  ;
  8100                                  ;	ENTRY	(dl) = drive (0=default, 1=A, 2=B, etc.)
  8101                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  8102                                  ;			GOD help anyone who tries to do ANYTHING except
  8103                                  ;			READ this ONE byte.
  8104                                  ;		DX = Total Number of allocation units on disk
  8105                                  ;		CX = Sector size
  8106                                  ;		AL = Sectors per allocation unit
  8107                                  ;		   = -1 if bad drive specified
  8108                                  ;	USES	all
  8109                                  ;
  8110                                  ;----------------------------------------------------------------------------
  8111                                  ;
  8112                                  
  8113                                  _$SLEAZEFUNC:
  8114                                  	; 15/05/2019 - Retro DOS v4.0
  8115 00000F2A B200                    	MOV	DL,0
  8116                                  _$SLEAZEFUNCDL:
  8117 00000F2C 16                      	push	ss
  8118 00000F2D 1F                      	pop	ds
  8119                                  	
  8120 00000F2E 88D0                    	MOV	AL,DL
  8121 00000F30 E8845B                  	call	GETTHISDRV		; Get CDS structure
  8122                                  SET_AL_RET:
  8123                                  	; MSDOS 3.3
  8124                                  	;;mov	al, 0Fh
  8125                                  	;MOV	AL,error_invalid_drive	; Assume error	;AC000;
  8126                                  	
  8127                                  	; MSDOS 6.0 & MSDOS 3.3
  8128 00000F33 721E                    	JC	short BADSLDRIVE
  8129                                  
  8130 00000F35 E8CB1D                  	call	DISK_INFO
  8131                                  	;JC	short SET_AL_RET	; User FAILed to I 24
  8132 00000F38 7219                    	jc	short BADSLDRIVE
  8133 00000F3A 8826[9805]              	MOV	[FATBYTE],AH
  8134                                  
  8135                                  ; NOTE THAT A FIXED MEMORY CELL IS USED --> THIS CALL IS NOT
  8136                                  ; RE-ENTRANT. USERS BETTER GET THE ID BYTE BEFORE THEY MAKE THE
  8137                                  ; CALL AGAIN
  8138                                  
  8139 00000F3E BF[9805]                	MOV	DI,FATBYTE
  8140 00000F41 30E4                    	XOR	AH,AH			; AL has sectors/cluster
  8141 00000F43 E83BF5                  	call	Get_User_Stack
  8142                                  	;mov	[si+4],cx
  8143                                  	;mov	[si+6],bx
  8144                                  	;mov	[si+2],di
  8145 00000F46 894C04                  	MOV	[SI+user_env.user_CX],CX
  8146 00000F49 895C06                  	MOV	[SI+user_env.user_DX],BX
  8147 00000F4C 897C02                  	MOV	[SI+user_env.user_BX],DI
  8148                                  	
  8149                                  	;mov	[si+0Eh],ss
  8150 00000F4F 8C540E                  	MOV     [SI+user_env.user_DS],SS ; stash correct pointer
  8151                                  
  8152 00000F52 C3                      	retn
  8153                                  
  8154                                  BADSLDRIVE:
  8155 00000F53 E900F7                  	jmp	FCB_RET_ERR
  8156                                  
  8157                                  ;
  8158                                  ;----------------------------------------------------------------------------
  8159                                  ;
  8160                                  ;**	$Get_INDOS_Flag - Return location of DOS Critical Section Flag
  8161                                  ;
  8162                                  ;	Returns location of DOS status for interrupt routines
  8163                                  ;									   ;
  8164                                  ;	ENTRY	none
  8165                                  ;	EXIT	(es:bx) = flag location
  8166                                  ;	USES	all
  8167                                  ;
  8168                                  ;----------------------------------------------------------------------------
  8169                                  ;
  8170                                  
  8171                                  _$GET_INDOS_FLAG:
  8172 00000F56 E828F5                          CALL	Get_User_Stack
  8173                                          ;MOV	WORD [SI+2],INDOS
  8174 00000F59 C74402[2103]            	MOV     word [SI+user_env.user_BX],INDOS
  8175                                          ;MOV	[SI+10H],SS
  8176 00000F5E 8C5410                  	MOV	[SI+user_env.user_ES],SS
  8177 00000F61 C3                      	RETN 
  8178                                  
  8179                                  ;
  8180                                  ;----------------------------------------------------------------------------
  8181                                  ;
  8182                                  ;**	$Get_IN_Vars - Return Pointer to DOS Variables
  8183                                  ;
  8184                                  ;	Return a pointer to interesting DOS variables This call is version
  8185                                  ;	dependent and is subject to change without notice in future versions.
  8186                                  ;	Use at risk.
  8187                                  ;
  8188                                  ;	ENTRY	none
  8189                                  ;	EXIT	(es:bx) = address of SYSINITVAR
  8190                                  ;	uses	ALL
  8191                                  ;
  8192                                  ;----------------------------------------------------------------------------
  8193                                  ;
  8194                                  
  8195                                  _$GET_IN_VARS:
  8196 00000F62 E81CF5                          CALL	Get_User_Stack
  8197                                          ;MOV	WORD [SI+2],SYSINITVAR
  8198                                  	;MOV	word [SI+user_env.user_BX],SYSINITVAR
  8199 00000F65 C74402[2600]            	MOV	word [SI+user_env.user_BX],SYSINITVARS
  8200                                          ;MOV	[SI+10H],SS
  8201 00000F6A 8C5410                  	MOV	[SI+user_env.user_ES],SS
  8202 00000F6D C3                      	RETN
  8203                                  
  8204                                  ;
  8205                                  ;----------------------------------------------------------------------------
  8206                                  ;
  8207                                  ;**	$Get_Default_DPB - Return a pointer to the Default DPB
  8208                                  ;
  8209                                  ;	Return pointer to drive parameter table for default drive
  8210                                  ;
  8211                                  ;	ENTRY	none
  8212                                  ;	EXIT	(ds:bx) = DPB address
  8213                                  ;	USES	all
  8214                                  ;
  8215                                  ;**	$Get_DPB - Return a pointer to a specified DPB
  8216                                  ;
  8217                                  ;	Return pointer to a specified drive parameter table
  8218                                  ;
  8219                                  ;	ENTRY	(dl) = drive # (0 = default, 1=A, 2=B, etc.)
  8220                                  ;	EXIT	(al) = 0 iff ok
  8221                                  ;		  (ds:bx) = DPB address
  8222                                  ;		(al) = -1 if bad drive
  8223                                  ;	USES	all
  8224                                  ;
  8225                                  ;----------------------------------------------------------------------------
  8226                                  ;
  8227                                  
  8228                                  ; 15/05/2019 - Retro DOS v4.0
  8229                                  
  8230                                  _$GET_DEFAULT_DPB:
  8231 00000F6E B200                    	MOV	DL,0
  8232                                  _$GET_DPB:
  8233 00000F70 16                      	push	ss
  8234 00000F71 1F                      	pop	ds
  8235                                  
  8236 00000F72 88D0                    	MOV	AL,DL
  8237 00000F74 E8405B                  	call	GETTHISDRV		; Get CDS structure
  8238 00000F77 7222                    	JC	short ISNODRV 		; no valid drive
  8239 00000F79 C43E[A205]              	LES	DI,[THISCDS]		; check for net CDS
  8240                                  	;;test	word [es:di+43h],8000h
  8241                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
  8242                                  	;test	byte [es:di+44h],80h
  8243 00000F7D 26F6454480              	test	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
  8244 00000F82 7517                    	JNZ	short ISNODRV 		; No DPB to point at on NET stuff
  8245 00000F84 E88A03                  	call	ECritDisk
  8246 00000F87 E86A47                  	call	FATREAD_CDS		; Force Media Check and return DPB
  8247 00000F8A E89F03                  	call	LCritDisk
  8248 00000F8D 720C                    	JC	short ISNODRV 		; User FAILed to I 24, only error we
  8249                                  					;   have.
  8250 00000F8F E8EFF4                  	call	Get_User_Stack
  8251                                  	;mov	[si+2],bp
  8252 00000F92 896C02                  	MOV	[SI+user_env.user_BX],BP
  8253                                  	;mov	[si+0Eh],es
  8254 00000F95 8C440E                  	MOV	[SI+user_env.user_DS],ES
  8255 00000F98 30C0                    	XOR	AL,AL
  8256 00000F9A C3                      	retn
  8257                                  ISNODRV:
  8258 00000F9B B0FF                    	MOV	AL,-1
  8259 00000F9D C3                      	retn
  8260                                  
  8261                                  ;
  8262                                  ;----------------------------------------------------------------------------
  8263                                  ;
  8264                                  ;**	$Disk_Reset - Flush out Dirty Buffers
  8265                                  ;
  8266                                  ;	$DiskReset flushes and invalidates all buffers.  BUGBUG - do
  8267                                  ;		we really invalidate?  SHould we?  THis screws non-removable
  8268                                  ;		caching.  Maybe CHKDSK relies upon it, though....
  8269                                  ;
  8270                                  ;	ENTRY	none
  8271                                  ;	EXIT	none
  8272                                  ;	USES	all
  8273                                  ;
  8274                                  ;----------------------------------------------------------------------------
  8275                                  ;
  8276                                  
  8277                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8278                                  	; DOSCODE:4D94h
  8279                                  _$DISK_RESET:
  8280                                  	; 15/05/2019 - Retro DOS v4.0
  8281 00000F9E B0FF                    	mov	al,0FFh	; -1
  8282 00000FA0 16                      	push	ss
  8283 00000FA1 1F                      	pop	ds
  8284                                  	; 06/11/2022
  8285                                  	;MOV	AL,-1
  8286 00000FA2 E86C03                  	call	ECritDisk
  8287                                  	; MSDOS 6.0
  8288                                  	;;or	word [DOS34_FLAG],4
  8289                                  	;or	word [DOS34_FLAG],FROM_DISK_RESET    ;AN000;
  8290 00000FA5 800E[1106]04            	or	byte [DOS34_FLAG],FROM_DISK_RESET ; 4 ; 15/05/2019
  8291 00000FAA E8C04A                  	call	FLUSHBUF
  8292                                  	; MSDOS 6.0
  8293                                  	;and	word [DOS34_FLAG],0FFFBh
  8294                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8295                                  	;and	word [DOS34_FLAG],NO_FROM_DISK_RESET ;AN000;
  8296                                  	; 15/12/2022
  8297 00000FAD 8026[1106]FB            	and	byte [DOS34_FLAG],NO_FROM_DISK_RESET ; 0FBh ; 15/05/2019
  8298 00000FB2 C706[B50D]0000          	mov	word [SC_STATUS],0	; Throw out secondary cache M041
  8299                                  ;
  8300                                  ; We will "ignore" any errors on the flush, and go ahead and invalidate.  This
  8301                                  ; call doesn't return any errors and it is supposed to FORCE a known state, so
  8302                                  ; let's do it.
  8303                                  ;
  8304                                  ; Invalidate 'last-buffer' used
  8305                                  ;
  8306 00000FB8 BBFFFF                  	MOV	BX,-1 ; 0FFFFh	
  8307 00000FBB 891E[2000]              	MOV	[LastBuffer+2],BX
  8308 00000FBF 891E[1E00]              	MOV	[LastBuffer],BX
  8309                                  
  8310                                  	; MSDOS 3.3 
  8311                                  	; IBMDOS.COM, Offset 1C66h
  8312                                  	;;;;
  8313                                  	;lds	si,[BUFFHEAD]
  8314                                  	;mov	ax,20FFh	; .buf_ID,    AL = FFh (Free buffer)
  8315                                  				; .buf_flags, AH = 0, reset/clear
  8316                                  ;DRST_1:
  8317                                  	;;mov	[si+4],ax
  8318                                  	;mov	[si+BUFFINFO.buf_ID],ax
  8319                                  	;lds	si,[SI]
  8320                                  	;cmp	si,bx ; -1
  8321                                  	;je	short DRST_2
  8322                                  	;;mov	[si+4],ax
  8323                                  	;mov	[si+BUFFINFO.buf_ID],ax
  8324                                  	;lds	si,[SI]
  8325                                  	;cmp	si,bx
  8326                                  	;jne	short DRST_1
  8327                                  	;;;;
  8328                                  ;DRST_2:
  8329 00000FC3 E86603                  	call	LCritDisk
  8330 00000FC6 B8FFFF                  	MOV	AX,-1
  8331                                  	; 07/12/2022
  8332                                  	;mov	ax,0FFFFh
  8333                                  	;CallInstall NetFlushBuf,MultNET,32,AX,AX
  8334 00000FC9 50                      	push	ax ; * MSDOS 6.0 ; 15/05/2019
  8335 00000FCA B82011                  	mov     ax,1120h
  8336 00000FCD CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
  8337                                  			; DS = DOS CS
  8338                                  			; Return: CF clear (successful)
  8339 00000FCF 58                      	pop	ax ; * MSDOS 6.0 ; 15/05/2019
  8340                                  	
  8341 00000FD0 C3                      	retn
  8342                                  
  8343                                  	; 19/07/2018 - Retro DOS v3.0
  8344                                  
  8345                                  ;
  8346                                  ;	BREAK <$SetDPB - Create a valid DPB from a user-specified BPB>
  8347                                  ;
  8348                                  ;----------------------------------------------------------------------------
  8349                                  ;
  8350                                  ;**	$SetDPB - Create a DPB
  8351                                  ;
  8352                                  ;	SetDPB Creates a valid DPB from a user-specified BPB
  8353                                  ;
  8354                                  ;	ENTRY	ES:BP Points to DPB
  8355                                  ;		DS:SI Points to BPB
  8356                                  ;	EXIT	DPB setup
  8357                                  ;	USES	ALL but BP, DS, ES
  8358                                  ;
  8359                                  ;----------------------------------------------------------------------------
  8360                                  ;
  8361                                  
  8362                                  ; 10/05/2019 - Retro DOS v4.0
  8363                                  
  8364                                  ; DOSCODE:4DD6h (MSDOS 6.21, MSDOS.SYS)
  8365                                  
  8366                                  ; MSDOS 6.0
  8367 00000FD1 0300                    word3:	dw	3			; M008 -- word value for divides
  8368                                  
  8369                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8370                                  ; DOSCODE:4DC9h (MSDOS 5.0, MSDOS.SYS)
  8371                                  
  8372                                  ;procedure   $SETDPB,NEAR
  8373                                  
  8374                                  _$SETDPB:
  8375 00000FD3 89EF                    	MOV	DI,BP
  8376 00000FD5 83C702                  	ADD	DI,2			; Skip over dpb_drive and dpb_UNIT
  8377 00000FD8 AD                      	LODSW
  8378 00000FD9 AB                      	STOSW				; dpb_sector_size
  8379                                  	; MSDOS 6.0
  8380                                  	;cmp	byte [si+3],0
  8381 00000FDA 807C0300                	CMP	BYTE [SI+A_BPB.BPB_NUMBEROFFATS-2],0 ; FAT file system drive ;AN000;
  8382 00000FDE 7507                    	JNZ	short yesfat			     ; yes		;AN000;
  8383                                  	;mov	byte [es:di+4],0
  8384 00000FE0 26C6450400              	MOV	BYTE [ES:DI+DPB.FAT_COUNT-4],0
  8385 00000FE5 EB70                    	JMP	short setend			     ; NO		;AN000;
  8386                                  
  8387                                  yesfat: ; 10/08/2018
  8388 00000FE7 89C2                    	MOV	DX,AX
  8389 00000FE9 AC                      	LODSB
  8390                                  	;DEC	AL
  8391                                  	; 17/12/2022
  8392 00000FEA 48                      	dec	ax
  8393 00000FEB AA                      	STOSB				; dpb_cluster_mask
  8394                                  	;INC	AL
  8395 00000FEC 40                      	inc	ax
  8396 00000FED 30E4                    	XOR	AH,AH
  8397                                  LOG2LOOP:
  8398 00000FEF A801                    	test	AL,1
  8399 00000FF1 7506                    	JNZ	short SAVLOG
  8400 00000FF3 FEC4                    	INC	AH
  8401 00000FF5 D0E8                    	SHR	AL,1
  8402 00000FF7 EBF6                    	JMP	SHORT LOG2LOOP
  8403                                  SAVLOG:
  8404 00000FF9 88E0                    	MOV	AL,AH
  8405 00000FFB AA                      	STOSB				; dpb_cluster_shift
  8406 00000FFC 88C3                    	MOV	BL,AL
  8407 00000FFE A5                      	MOVSW				; dpb_first_FAT Start of FAT (# of reserved sectors)
  8408 00000FFF AC                      	LODSB
  8409 00001000 AA                      	STOSB				; dpb_FAT_count Number of FATs
  8410                                  ;	OR	AL,AL			; NONFAT ?				;AN000;
  8411                                  ;	JZ	short setend		; yes, don't do anything                ;AN000;
  8412 00001001 88C7                    	MOV	BH,AL
  8413 00001003 AD                      	LODSW
  8414 00001004 AB                      	STOSW				; dpb_root_entries Number of directory entries
  8415 00001005 B105                    	MOV	CL,5
  8416 00001007 D3EA                    	SHR	DX,CL			; Directory entries per sector
  8417 00001009 48                      	DEC	AX
  8418 0000100A 01D0                    	ADD	AX,DX			; Cause Round Up
  8419 0000100C 89D1                    	MOV	CX,DX
  8420 0000100E 31D2                    	XOR	DX,DX
  8421 00001010 F7F1                    	DIV	CX
  8422 00001012 89C1                    	MOV	CX,AX			; Number of (root) directory sectors
  8423 00001014 47                      	INC	DI
  8424 00001015 47                      	INC	DI			; Skip dpb_first_sector
  8425 00001016 A5                      	MOVSW			; Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
  8426 00001017 AC                      	LODSB
  8427                                  	;mov	[es:bp+17h],al
  8428 00001018 26884617                	MOV	[ES:BP+DPB.MEDIA],AL	; Media byte
  8429 0000101C AD                      	LODSW				; Number of sectors in a FAT
  8430                                  	
  8431                                  	;;;
  8432                                  	;MSDOS 3.3
  8433                                  	;
  8434                                  	;STOSB		; DPB.FAT_SIZE
  8435                                  	;MUL	BH
  8436                                  	
  8437                                  	;MSDOS 6.0
  8438                                  	;
  8439 0000101D AB                      	STOSW		; DPB.FAT_SIZE	;AC000;;>32mb dpb_FAT_size
  8440 0000101E 88FA                    	MOV	DL,BH			;AN000;;>32mb
  8441 00001020 30F6                    	XOR	DH,DH			;AN000;;>32mb
  8442 00001022 F7E2                    	MUL	DX			;AC000;;>32mb Space occupied by all FATs
  8443                                  	;;;
  8444                                  	
  8445                                  	;add	ax,[es:bp+6]
  8446 00001024 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
  8447 00001028 AB                      	STOSW				; dpb_dir_sector
  8448 00001029 01C8                    	ADD	AX,CX			; Add number of (root) directory sectors
  8449                                  	;mov	[es:bp+0Bh],ax
  8450 0000102B 2689460B                	MOV	[ES:BP+DPB.FIRST_SECTOR],AX
  8451                                  	
  8452                                  	; MSDOS 6.0
  8453 0000102F 88D9                    	MOV	CL,BL			;F.C. >32mb				;AN000;
  8454                                  	;;cmp	word [es:bp+0Dh],0
  8455                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
  8456                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8457                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8458                                  	; 15/12/2022
  8459                                  	; 28/07/2019
  8460 00001031 268B5E0D                	mov	bx,[ES:BP+DSKSIZ]
  8461 00001035 09DB                    	or	bx,bx
  8462 00001037 751A                    	JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8463                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
  8464                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8465                                  	
  8466                                  
  8467 00001039 30ED                    	XOR	CH,CH			;F.C. >32mb				;AN000;
  8468                                  	;mov	bx,[si+8]
  8469 0000103B 8B5C08                  	MOV	BX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK]	;AN000;
  8470                                  	;mov	dx,[si+10]
  8471 0000103E 8B540A                  	MOV	DX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK+2]	;AN000;
  8472 00001041 29C3                    	SUB	BX,AX			;AN000;;F.C. >32mb
  8473 00001043 83DA00                  	SBB	DX,0			;AN000;;F.C. >32mb
  8474 00001046 09C9                    	OR	CX,CX			;AN000;;F.C. >32mb
  8475 00001048 7407                    	JZ	short norot		;AN000;;F.C. >32mb
  8476                                  rott:					;AN000;;F.C. >32mb
  8477 0000104A F8                      	CLC				;AN000;;F.C. >32mb
  8478 0000104B D1DA                    	RCR	DX,1			;AN000;;F.C. >32mb
  8479 0000104D D1DB                    	RCR	BX,1			;AN000;;F.C. >32mb
  8480 0000104F E2F9                    	LOOP	rott			;AN000;;F.C. >32mb
  8481                                  norot:					;AN000;
  8482                                  	; 15/12/2022
  8483                                  	;MOV	AX,BX			;AN000;;F.C. >32mb
  8484 00001051 EB04                    	JMP	short setend		;AN000;;F.C. >32mb
  8485                                  normal_dpb:
  8486                                  	;;sub	ax,[es:bp+0Dh]
  8487                                  	;SUB	AX,[ES:BP+DSKSIZ]
  8488                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8489                                  	; 15/12/2022
  8490                                  	; bx = [es:bp+DSKSIZ]
  8491                                  	;sub	ax,bx ; 28/07/2019
  8492                                  	;;SUB	AX,[ES:BP+DSKSIZ]
  8493                                  	; 15/12/2022
  8494 00001053 29C3                    	sub	bx,ax
  8495                                  	;NEG	AX			; Sectors in data area
  8496                                  ;;	MOV	CL,BL			; dpb_cluster_shift
  8497                                  	; 15/12/2022
  8498                                  	; CL = cluster shift
  8499                                  	; BX = number of data sectors 
  8500                                  	;SHR	AX,CL			; Div by sectors/cluster
  8501 00001055 D3EB                    	shr	bx,cl 
  8502                                  setend:
  8503                                  ;	M008 - CAS
  8504                                  ;
  8505                                  	; 15/12/2022
  8506 00001057 43                      	inc	bx
  8507                                  	;INC	AX			; +2 (reserved), -1 (count -> max)
  8508                                  ;
  8509                                  ;	There has been a bug in our fatsize calculation for so long
  8510                                  ;	  that we can't correct it now without causing some user to
  8511                                  ;	  experience data loss. There are even cases where allowing
  8512                                  ;	  the number of clusters to exceed the fats is the optimal
  8513                                  ;	  case -- where adding 2 more fat sectors would make the
  8514                                  ;	  data field smaller so that there's nothing to use the extra
  8515                                  ;	  fat sectors for.
  8516                                  ;
  8517                                  ;	Note that this bug had very minor known symptoms. CHKDSK would
  8518                                  ;	  still report that there was a cluster left when the disk was
  8519                                  ;	  actually full. Very graceful failure for a corrupt system
  8520                                  ;	  configuration. There may be worse cases that were never
  8521                                  ;	  properly traced back to this bug. The problem cases only
  8522                                  ;	  occurred when partition sizes were very near FAT sector
  8523                                  ;	  rounding boundaries, which were rare cases.
  8524                                  ;
  8525                                  ;	Also, it's possible that some third-party partition program might
  8526                                  ;	  create a partition that had a less-than-perfect FAT calculation
  8527                                  ;	  scheme. In this hypothetical case, the number of allocation
  8528                                  ;	  clusters which don't actually have FAT entries to represent
  8529                                  ;	  them might be larger and might create a more catastrophic
  8530                                  ;	  failure. So we'll provide the safeguard of limiting the
  8531                                  ;	  max_cluster to the amount that will fit in the FATs.
  8532                                  ;
  8533                                  ;	ax = maximum legal cluster, ES:BP -> dpb
  8534                                  
  8535                                  ;	make sure the number of fat sectors is actually enough to
  8536                                  ;	  hold that many clusters. otherwise, back the number of
  8537                                  ;	  clusters down
  8538                                  
  8539                                  	; 15/12/2022
  8540                                  	; bx = number of clusters
  8541                                  
  8542                                  	; 19/07/2018 - Retro DOS v3.0
  8543                                  	; MSDOS 6.0
  8544                                  	; 15/12/2022
  8545                                  	;mov	bx,ax			; remember calculated # clusters
  8546                                  
  8547                                  	; 01/08/2018 (MSDOS 3.3)
  8548                                  	;mov	al,[ES:BP+DPB.FAT_SIZE]
  8549                                  	;xor	ah,ah 
  8550                                  
  8551                                  	; 10/05/2019 - Retro DOS v4.0
  8552                                  	;mov	ax,[ES:BP+0Fh]
  8553 00001058 268B460F                	mov	ax,[ES:BP+DPB.FAT_SIZE]
  8554                                  
  8555                                  	;mul	word [es:bp+2]	
  8556 0000105C 26F76602                	mul	word [ES:BP+DPB.SECTOR_SIZE] ; how big is the FAT?
  8557 00001060 81FBF60F                	cmp	bx,4096-10  ; 0FF6h	; test for 12 vs. 16 bit fat
  8558 00001064 720D                    	jb	short setend_fat12
  8559 00001066 D1EA                    	shr	dx,1
  8560                                  
  8561                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8562                                  	; 15/12/2022
  8563                                  ;cs3 7/2/92
  8564 00001068 751C                    	jnz	short setend_faterr	; some bonehead gave us more fatspace
  8565                                  					; than enough for the maximum FAT,
  8566                                  					; so go ahead and use the calculated
  8567                                  					; number of clusters.
  8568                                  ;cs3 7/2/92
  8569                                  
  8570 0000106A D1D8                    	rcr	ax,1			; find number of entries
  8571 0000106C 3DF70F                  	cmp	ax,4096-10+1		; would this truncation move us
  8572                                  ;					;  into 12-bit fatland?
  8573 0000106F 7215                    	jb	short setend_faterr	; then go ahead and let the
  8574                                  ;					;  inconsistency pass through
  8575                                  ;					;  rather than lose data by
  8576                                  ;					;  correcting the fat type
  8577 00001071 EB0E                    	jmp	short setend_fat16
  8578                                  
  8579                                  setend_fat12:
  8580 00001073 01C0                    	add	ax,ax			; (fatsiz*2)/3 = # of fat entries
  8581 00001075 11D2                    	adc	dx,dx
  8582                                  
  8583                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8584                                  ;cs3 7/2/92
  8585                                  	; 15/12/2022
  8586 00001077 83FA03                  	cmp	dx,3			; if our fatspace is WAY more than
  8587 0000107A 730A                    	jnb	short setend_faterr	; we need, we may get an overflow
  8588                                  					; here. Check for it and use
  8589                                  					; the calculated size in this case.
  8590                                  ;cs3 7/2/92
  8591                                  
  8592 0000107C 2EF736[D10F]            	div	word [cs:word3]
  8593                                  
  8594                                  setend_fat16:
  8595 00001081 48                      	dec	ax			; limit at 1
  8596 00001082 39D8                    	cmp	ax,bx			; is fat big enough?
  8597 00001084 7602                    	jbe	short setend_fat	; use max value that'll fit
  8598                                  
  8599                                  setend_faterr:
  8600 00001086 89D8                    	mov	ax,bx			; use calculated value
  8601                                  
  8602                                  setend_fat:
  8603                                  
  8604                                  ;	now ax = maximum legal cluster
  8605                                  
  8606                                  ;	end M008
  8607                                  
  8608                                  	;mov	[es:bp+0Dh], ax
  8609 00001088 2689460D                	MOV	[ES:BP+DPB.MAX_CLUSTER],AX
  8610                                  	;;mov	word [es:bp+1Ch],0  ; MSDOS 3.3
  8611                                  	;mov	word [es:bp+1Dh],0  ; MSDOS 6.0
  8612 0000108C 26C7461D0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 
  8613                                  					; Init so first ALLOC starts at
  8614                                  					; begining of FAT
  8615                                  	;;mov	word [es:bp+1Eh],-1 ; MSDOS 3.3
  8616                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
  8617 00001092 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; current count is invalid.
  8618                                  
  8619 00001098 C3                      	retn
  8620                                  
  8621                                  ;EndProc $SETDPB
  8622                                  
  8623                                  ;BREAK <$Create_Process_Data_Block,SetMem -- Set up process data block>
  8624                                  
  8625                                  ;
  8626                                  ;----------------------------------------------------------------------------
  8627                                  ;
  8628                                  ;**	$Dup_PDB
  8629                                  ;
  8630                                  ; Inputs:   DX is new segment address of process
  8631                                  ;	    SI is end of new allocation block
  8632                                  ;
  8633                                  ;----------------------------------------------------------------------------
  8634                                  ;
  8635                                  
  8636                                  _$DUP_PDB:
  8637                                  
  8638                                  ;hkn;	CreatePDB would have a CS override. This is not valid.
  8639                                  ;hkn;	Must set up ds in order to acess CreatePDB. Also SS is 
  8640                                  ;hkn;	has been assumed to be NOTHING. It may not have DOSDATA.
  8641                                  
  8642                                  	; MSDOS 3.3
  8643                                  	;MOV	byte [CS:CreatePDB],0FFh  ; indicate a new process
  8644                                  	;MOV	DS,[CS:CurrentPDB]
  8645                                  
  8646                                  	; 15/05/2019 - Retro DOS v4.0
  8647                                  	; MSDOS 6.0
  8648 00001099 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  8649 0000109E C606[A803]FF            	MOV	byte [CreatePDB],0FFh
  8650 000010A3 8E1E[3003]              	MOV	DS,[CurrentPDB]
  8651                                  
  8652 000010A7 56                      	PUSH	SI
  8653 000010A8 EB0A                    	JMP	SHORT CreateCopy
  8654                                  
  8655                                  ;
  8656                                  ;----------------------------------------------------------------------------
  8657                                  ;
  8658                                  ; Inputs:
  8659                                  ;	DX = Segment number of new base
  8660                                  ; Function:
  8661                                  ;	Set up program base and copy term and ^C from int area
  8662                                  ; Returns:
  8663                                  ;	None
  8664                                  ; Called at DOS init
  8665                                  ;
  8666                                  ;----------------------------------------------------------------------------
  8667                                  ;
  8668                                  
  8669                                  ; 15/05/2019 - Retro DOS v4.0
  8670                                  ; DOSCODE:4EB6h (MSDOS 6.21, MSDOS.SYS)
  8671                                  
  8672                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8673                                  ; DOSCODE:4EA2h (MSDOS 5.0, MSDOS.SYS)
  8674                                  
  8675                                  _$CREATE_PROCESS_DATA_BLOCK:
  8676                                  			; Offset 1D02h in IBMDOS.COM (MSDOS 3.3), 1987
  8677 000010AA E8D4F3                  	CALL	Get_User_Stack
  8678                                  	;mov	ds,[si+14h]
  8679 000010AD 8E5C14                  	MOV	DS,[SI+user_env.user_CS]
  8680                                  	;push	word [2]
  8681 000010B0 FF360200                	PUSH	word [PDB.BLOCK_LEN] ;*
  8682                                  CreateCopy:
  8683 000010B4 8EC2                    	MOV	ES,DX
  8684                                  
  8685 000010B6 31F6                    	XOR	SI,SI			; copy entire PDB
  8686 000010B8 89F7                    	MOV	DI,SI
  8687 000010BA B98000                  	MOV	CX,128
  8688 000010BD F3A5                    	REP	MOVSW
  8689                                  
  8690                                  ; DOS 3.3 7/9/86
  8691                                  	;mov	cx,20
  8692                                  	;MOV	CX,FILPERPROC		; copy handles in case of
  8693                                  	; 15/12/2022
  8694 000010BF B114                    	mov	cl,FILPERPROC ; 06/07/2019
  8695                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8696                                  	;mov	cx,FILPERPROC
  8697                                  
  8698                                  	;mov	di,18h
  8699 000010C1 BF1800                  	MOV	DI,PDB.JFN_TABLE	; Set Handle Count has been issued
  8700                                  	;;PUSH	DS ; * 15/05/2019
  8701                                  	;;lds	si,[34h]
  8702                                  	;LDS	SI,[PDB.JFN_Pointer]
  8703                                  	;REP	MOVSB
  8704                                  	;;POP	DS ; * 15/05/2019
  8705                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8706                                  	; 05/12/2022
  8707                                  	; (push ds then pop ds is not needed here!)
  8708                                  	;push	ds
  8709                                  	;lds	si,[34h]
  8710 000010C4 C5363400                	lds	si,[PDB.JFN_Pointer]
  8711 000010C8 F3A4                    	rep	movsb
  8712                                  	;pop	ds
  8713                                  
  8714                                  ; DOS 3.3 7/9/86
  8715                                  	;hkn ;CreatePDB would have a CS override. This is not valid.
  8716                                  	;hkn ;Must set up ds in order to access CreatePDB. Also SS is 
  8717                                  	;hkn ;has been assumed to be NOTHING. It may not have DOSDATA.
  8718                                  
  8719 000010CA 2E8E1E[0700]            	mov	ds,[cs:DosDSeg] ; 15/05/2019
  8720                                  
  8721                                  	;;test	byte [cs:CreatePDB],0FFh
  8722                                  	;cmp	byte [CS:CreatePDB],0	; Shall we create a process?
  8723                                  	; 17/12/2022
  8724 000010CF 380E[A803]              	cmp	[CreatePDB],cl ; 0
  8725                                  	;cmp	byte [CreatePDB],0 ; 15/05/2019
  8726 000010D3 744A                    	JZ	short Create_PDB_cont 	; nope, old style call
  8727                                  
  8728                                  ; Here we set up for a new process...
  8729                                  
  8730                                  	;PUSH	CS			; Called at DOSINIT time, NO SS
  8731                                  	;POP	DS
  8732                                  
  8733                                  	; MSDOS 6.0
  8734                                  	;;getdseg <ds>			; ds -> dosdata
  8735                                  	;mov	ds,[cs:DosDSeg] ; 15/05/2019
  8736                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8737                                  	; (nonsense! but i put this for addr compatibility as temporary)
  8738                                  	; 15/12/2022
  8739                                  	;mov	ds,[cs:DosDSeg] ; 15/05/2019
  8740                                  
  8741 000010D5 31DB                    	XOR	BX,BX			; dup all jfns
  8742                                  	;mov	cx,20
  8743                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8744                                  	;MOV	CX,FILPERPROC		; only 20 of them
  8745                                  	; 15/12/2022
  8746 000010D7 B114                    	mov	cl,FILPERPROC ; 06/07/2019
  8747                                  
  8748                                  Create_dup_jfn:
  8749 000010D9 06                      	PUSH	ES ;**			; save new PDB
  8750 000010DA E8B655                  	call	SFFromHandle		; get sf pointer
  8751 000010DD B0FF                    	MOV	AL,-1			; unassigned JFN
  8752 000010DF 7224                    	JC	short CreateStash	; file was not really open
  8753                                  	;;test	word [es:di+5],1000h
  8754                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_no_inherit
  8755                                  	; 15/05/2019
  8756                                  	;test	byte [es:di+6],10h
  8757 000010E1 26F6450610              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_no_inherit>>8)
  8758 000010E6 751D                    	JNZ	short CreateStash	; if no-inherit bit is set, skip dup.
  8759                                  
  8760                                  ; We do not inherit network file handles.
  8761                                  
  8762                                  	;mov	ah,[es:di+2]
  8763 000010E8 268A6502                	MOV	AH,[ES:DI+SF_ENTRY.sf_mode]
  8764                                  	;and	ah,0F0h
  8765 000010EC 80E4F0                  	AND	AH,SHARING_MASK
  8766                                  	;cmp	ah,70h
  8767 000010EF 80FC70                  	CMP	AH,SHARING_NET_FCB
  8768 000010F2 7411                    	jz	short CreateStash
  8769                                  
  8770                                  ; The handle we have found is duplicatable (and inheritable). Perform
  8771                                  ; duplication operation.
  8772                                  
  8773 000010F4 893E[9E05]              	MOV	[THISSFT],DI
  8774 000010F8 8C06[A005]              	MOV	[THISSFT+2],ES
  8775 000010FC E85C19                  	call	DOS_DUP 		; signal duplication
  8776                                  
  8777                                  ; get the old sfn for copy
  8778                                  
  8779 000010FF E87455                  	call	pJFNFromHandle		; ES:DI is jfn
  8780 00001102 268A05                  	MOV	AL,[ES:DI]		; get sfn
  8781                                  
  8782                                  ; Take AL (old sfn or -1) and stash it into the new position
  8783                                  
  8784                                  CreateStash:
  8785 00001105 07                      	POP	ES ;**
  8786                                  	;mov	[es:bx+18h],al
  8787 00001106 26884718                	MOV	[ES:BX+PDB.JFN_TABLE],AL ; copy into new place!
  8788 0000110A 43                      	INC	BX			; next jfn...
  8789 0000110B E2CC                    	LOOP	Create_dup_jfn
  8790                                  
  8791 0000110D 8B1E[3003]              	MOV	BX,[CurrentPDB]		; get current process
  8792                                  	; 06/11/2022
  8793                                  	;mov	[es:16h],bx
  8794 00001111 26891E1600              	MOV	[ES:PDB.PARENT_PID],BX	; stash in child
  8795 00001116 8C06[3003]              	MOV	[CurrentPDB],ES
  8796                                  	;MOV	DS,BX ; 28/07/2019
  8797                                  	; 07/12/2022
  8798                                  	;mov	ds,[cs:DosDSeg]
  8799                                  	; 15/12/2022
  8800                                  	; ds = [cs:DosDSeg]
  8801 0000111A C606[A803]00            	mov	byte [CreatePDB],0	; reset flag
  8802                                  	;mov	ds,bx
  8803                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8804                                  	; 15/12/2022
  8805                                  	;mov	ds,bx
  8806                                  
  8807                                  ; end of new process create
  8808                                  
  8809                                  Create_PDB_cont:
  8810                                  	;MOV	BYTE [CS:CreatePDB],0	; reset flag
  8811                                  
  8812                                  ;hkn; It comes to this point from 2 places. So, change to DOSDATA temporarily	
  8813                                  
  8814                                  	;; 28/07/2019
  8815                                  	;;push	ds
  8816                                  	;;mov	ds,[cs:DosDSeg]
  8817                                  	;mov	byte [CreatePDB],0
  8818                                  	;;pop	ds
  8819                                  
  8820                                  ; 05/12/2022
  8821                                  ;	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8822                                  ;	; (push-pop ds is nonsense here! 
  8823                                  ;	;  but i am using same code with original MSDOS.SYS
  8824                                  ;	;  for address compatibility.)
  8825                                  ;	push	ds
  8826                                  ;	; ds = [cs:DosDSeg] !
  8827                                  ;	mov	ds,[cs:DosDSeg]  ; again !
  8828                                  ;	mov	byte [CreatePDB],0
  8829                                  ;	pop	ds
  8830                                  
  8831 0000111F 58                      	POP	AX ;*
  8832                                  
  8833                                  	;entry	SETMEM
  8834                                  
  8835                                  	; 17/12/2022
  8836                                  	; cx = 0
  8837                                  
  8838                                  ;---------------------------------------------------------------------------
  8839                                  ; Inputs:
  8840                                  ;	AX = Size of memory in paragraphs
  8841                                  ;	DX = Segment
  8842                                  ; Function:
  8843                                  ;	Completely prepares a program base at the
  8844                                  ;	specified segment.
  8845                                  ; Called at DOS init
  8846                                  ; Outputs:
  8847                                  ;	DS = DX
  8848                                  ;	ES = DX
  8849                                  ;	[0] has INT int_abort
  8850                                  ;	[2] = First unavailable segment
  8851                                  ;	[5] to [9] form a long call to the entry point
  8852                                  ;	[10] to [13] have exit address (from int_terminate)
  8853                                  ;	[14] to [17] have ctrl-C exit address (from int_ctrl_c)
  8854                                  ;	[18] to [21] have fatal error address (from int_fatal_abort)
  8855                                  ; DX,BP unchanged. All other registers destroyed.
  8856                                  ;---------------------------------------------------------------------------
  8857                                  
  8858                                  SETMEM:
  8859                                  	;XOR	CX,CX
  8860                                  	; 17/12/2022
  8861                                  	; cx = 0
  8862 00001120 8ED9                    	MOV	DS,CX
  8863 00001122 8EC2                    	MOV	ES,DX
  8864                                  	;mov	si,88h
  8865 00001124 BE8800                  	MOV	SI,addr_int_terminate
  8866                                  	;mov	di,10 ; 0Ah
  8867 00001127 BF0A00                  	MOV	DI,SAVEXIT
  8868                                  	;MOV	CX,6
  8869                                  	; 15/12/2022
  8870 0000112A B106                    	mov	cl,6
  8871 0000112C F3A5                    	REP	MOVSW
  8872 0000112E 26A30200                	MOV	[ES:2],AX
  8873 00001132 29D0                    	SUB	AX,DX
  8874 00001134 3DFF0F                  	CMP	AX,MAXDIF ; 0FFFh
  8875 00001137 7603                    	JBE	short HAVDIF
  8876 00001139 B8FF0F                  	MOV	AX,MAXDIF
  8877                                  HAVDIF:
  8878 0000113C 83E810                  	SUB	AX,10h			; Allow for 100h byte "stack"
  8879 0000113F BB0C00                  	MOV	BX,ENTRYPOINTSEG ; 0Ch	;	in .COM files
  8880 00001142 29C3                    	SUB	BX,AX
  8881 00001144 B104                    	MOV	CL,4
  8882 00001146 D3E0                    	SHL	AX,CL
  8883 00001148 8EDA                    	MOV	DS,DX
  8884                                  
  8885                                  	; (MSDOS 6.0 note)
  8886                                  	;
  8887                                  	; The address in BX:AX will be F01D:FEF0 if there is 64K or more 
  8888                                  	; memory in the system. This is equivalent to 0:c0 if A20 is OFF.
  8889                                  	; If DOS is in HMA this equivalence is no longer valid as A20 is ON.
  8890                                  	; But the BIOS which now resides in FFFF:30 has 5 bytes in FFFF:D0
  8891                                  	; (F01D:FEF0) which is the same as the ones in 0:C0, thereby 
  8892                                  	; making this equvalence valid for this particular case. If however
  8893                                  	; there is less than 64K remaining the address in BX:AX will not 
  8894                                  	; be the same as above. We will then stuff 0:c0, the call 5 address
  8895                                  	; into the PSP.
  8896                                  	;
  8897                                  	; Therefore for the case where there is less than 64K remaining in 
  8898                                  	; the system old CPM Apps that look at PSP:6 to determine memory
  8899                                  	; requirements will not work. Call 5, however will continue to work
  8900                                  	; for all cases.
  8901                                  	;
  8902                                  
  8903                                  	;mov	[6],ax
  8904                                  	;mov	[8],bx
  8905                                  
  8906 0000114A A30600                  	MOV	[PDB.CPM_CALL+1],AX
  8907 0000114D 891E0800                	MOV	[PDB.CPM_CALL+3],BX
  8908                                  
  8909                                  	; 06/05/2019 - Retro DOS v4.0
  8910 00001151 3DF0FE                  	cmp	ax,WRAPOFFSET ; 0FEF0h	; Q: does the system have >= 64k of
  8911                                  					;    memory left
  8912 00001154 740C                    	je	short addr_ok		; Y: the above calculated address is
  8913                                  					;    OK
  8914                                  					; N: 
  8915                                  
  8916 00001156 C7060600C000            	MOV	WORD [PDB.CPM_CALL+1],0C0h
  8917 0000115C C70608000000            	MOV	WORD [PDB.CPM_CALL+3],0
  8918                                  addr_ok:
  8919                                  	;mov	word [0],20CDh
  8920 00001162 C7060000CD20            	MOV	word [PDB.EXIT_CALL],(int_abort*256) + mi_INT
  8921                                  	;mov	byte [5],9Ah
  8922 00001168 C60605009A              	MOV	BYTE [PDB.CPM_CALL],mi_Long_CALL
  8923                                  	;mov	word [50h],21CDh
  8924 0000116D C7065000CD21            	MOV	WORD [PDB.CALL_SYSTEM],(int_command*256) + mi_INT
  8925                                  	;mov	byte [52h],0CBh
  8926 00001173 C6065200CB              	MOV	BYTE [PDB.CALL_SYSTEM+2],mi_Long_RET
  8927                                  	;mov	word [34h],18h
  8928 00001178 C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE
  8929                                  	;mov	word [36h],ds
  8930 0000117E 8C1E3600                	MOV	WORD [PDB.JFN_Pointer+2],DS
  8931                                  	;mov	word [32h],20
  8932 00001182 C70632001400            	MOV	WORD [PDB.JFN_Length],FILPERPROC
  8933                                  ;
  8934                                  ; The server runs several PDB's without creating them VIA EXEC.  We need to
  8935                                  ; enumerate all PDB's at CPS time in order to find all references to a
  8936                                  ; particular SFT.  We perform this by requiring that the server link together
  8937                                  ; for us all sub-PDB's that he creates. The requirement for us, now, is to
  8938                                  ; initialize this pointer.
  8939                                  ;
  8940                                   	;mov	word [38h],-1
  8941 00001188 C7063800FFFF            	MOV	word [PDB.Next_PDB],-1
  8942                                  	;mov	word [3Ah],-1
  8943 0000118E C7063A00FFFF            	MOV	word [PDB.Next_PDB+2],-1
  8944                                  
  8945                                  	; 06/05/2019
  8946                                  	; Set the real version number in the PSP - 5.00
  8947                                  
  8948                                  	;mov	word [es:PDB.Version],1406h ; MSDOS 6.21 (DOSCODE:4FB6h)
  8949                                  	; 07/12/2022
  8950 00001194 26C70640000616          	mov	word [ES:PDB.Version],(MINOR_VERSION*256)+MAJOR_VERSION
  8951                                  
  8952 0000119B C3                      	retn
  8953                                  
  8954                                  ; 29/04/2019 - Retro DOS v4.0
  8955                                  
  8956                                  ;BREAK <$GSetMediaID -- get set media ID>
  8957                                  
  8958                                  ;---------------------------------------------------------------------------
  8959                                  ; Inputs:
  8960                                  ;	BL= drive number as defined in IOCTL
  8961                                  ;	AL= 0 get media ID
  8962                                  ;	    1 set media ID
  8963                                  ;	DS:DX= buffer containing information
  8964                                  ;		DW  0  info level (set on input)
  8965                                  ;		DD  ?  serial #
  8966                                  ;		DB  11 dup(?)  volume id
  8967                                  ;		DB   8 dup(?)  file system type
  8968                                  ; Function:
  8969                                  ;	Get or set media ID
  8970                                  ; Returns:
  8971                                  ;	carry clear, DS:DX is filled
  8972                                  ;	carry set, error
  8973                                  ;---------------------------------------------------------------------------
  8974                                  
  8975                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8976                                  _$GSetMediaID:
  8977                                  	; RAWIO - GET_MEDIA_ID
  8978 0000119C B96608                  	mov	cx,0866h	      ;AN000;MS.; assume get  for IOCTL
  8979 0000119F 3C00                    	cmp	al,0		      ;AN001;MS.; get ?
  8980 000011A1 7406                    	je	short doioctl 	      ;AN000;MS.; yes
  8981                                  	;cmp	al,1		      ;AN000;MS.; set ?
  8982                                  	;jne	short errorfunc	      ;AN000;MS.; no
  8983                                  	; 15/12/2022
  8984 000011A3 FEC8                    	dec	al
  8985 000011A5 7507                    	jnz	short errorfunc ; al > 1
  8986                                  	; RAWIO - SET_MEDIA_ID
  8987                                  	;mov	cx,0846h	      ;AN001;MS.;
  8988                                  	; 15/12/2022
  8989 000011A7 B146                    	mov	cl,46h	; cx = 0846h 
  8990                                  doioctl:			      ;AN000;
  8991 000011A9 B00D                    	mov	al,0Dh		      ;AN000;MS.; generic IOCTL
  8992                                  	;invoke	$IOCTL		      ;AN000;MS.; let IOCTL take care of it
  8993                                  	;call	_$IOCTL
  8994                                  	;retn			      ;AN000;MS.;
  8995                                  	; 15/12/2022
  8996 000011AB E9E910                  	jmp	_$IOCTL
  8997                                  errorfunc:			      ;AN000;
  8998                                  	;error	error_invalid_function;AN000;MS. ; invalid function
  8999                                  	;mov	al,1
  9000 000011AE B001                    	mov	al,error_invalid_function
  9001 000011B0 E98DF4                  	jmp	SYS_RET_ERR
  9002                                  
  9003                                  ; 16/05/2019 - Retro DOS v4.0
  9004                                  
  9005                                  ;============================================================================
  9006                                  ; MISC2.ASM, MSDOS 6.0, 1991
  9007                                  ;============================================================================
  9008                                  ; 20/07/2018 - Retro DOS v3.0
  9009                                  ; 29/04/2019 - Retro DOS v4.0
  9010                                  
  9011                                  ; Break <STRCMP - compare two ASCIZ strings DS:SI to ES:DI>
  9012                                  ;----------------------------------------------------------------------------
  9013                                  ;
  9014                                  ;   Strcmp - compare ASCIZ DS:SI to ES:DI. Case INSENSITIVE. '/' = '\'
  9015                                  ;	     Strings of different lengths don't match.
  9016                                  ;   Inputs:  DS:SI - pointer to source string  ES:DI - pointer to dest string
  9017                                  ;   Outputs: Z if strings same, NZ if different
  9018                                  ;   Registers modified: NONE
  9019                                  ;----------------------------------------------------------------------------
  9020                                  
  9021                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  9022                                  StrCmp:
  9023 000011B3 56                      	push	si
  9024 000011B4 57                      	push	di
  9025 000011B5 50                      	push	ax
  9026                                  
  9027                                  Cmplp:
  9028 000011B6 AC                      	LODSB
  9029 000011B7 E8AC3E                  	call	UCase			; convert to upper case
  9030 000011BA E8FE3E                  	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
  9031 000011BD 88C4                    	MOV	AH,AL
  9032 000011BF 268A05                  	MOV	AL,[ES:DI]
  9033 000011C2 47                      	INC	DI
  9034 000011C3 E8A03E                  	call	UCase			; convert to upper case
  9035 000011C6 E8F23E                  	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
  9036 000011C9 38C4                    	CMP	AH,AL
  9037 000011CB 7504                    	JNZ	short PopRet		; Strings dif
  9038                                  
  9039 000011CD 08C0                    	OR	AL,AL
  9040 000011CF 75E5                    	JNZ	short Cmplp		; More string
  9041                                  PopRet:
  9042 000011D1 58                      	pop	ax
  9043 000011D2 5F                      	pop	di
  9044 000011D3 5E                      	pop	si
  9045 000011D4 C3                      	retn
  9046                                  
  9047                                  ;Break <STRCPY - copy ASCIZ string from DS:SI to ES:DI>
  9048                                  ;----------------------------------------------------------------------------
  9049                                  ;
  9050                                  ;   Strcpy - copy an ASCIZ string from DS:SI to ES:DI and make uppercase
  9051                                  ;   FStrcpy - copy an ASCIZ string from DS:SI to ES:DI. no modification of
  9052                                  ;	characters.
  9053                                  ;
  9054                                  ;   Inputs:	DS:SI - pointer to source string
  9055                                  ;		ES:DI - pointer to destination string
  9056                                  ;   Outputs:	ES:DI point byte after nul byte at end of dest string
  9057                                  ;		DS:SI point byte after nul byte at end of source string
  9058                                  ;   Registers modified: SI,DI
  9059                                  ;----------------------------------------------------------------------------
  9060                                  
  9061                                  StrCpy:
  9062 000011D5 50                      	push	ax
  9063                                  CPYLoop:
  9064 000011D6 AC                      	LODSB
  9065 000011D7 E88C3E                  	call	UCase			; convert to upper case
  9066 000011DA E8DE3E                  	call	PATHCHRCMP		; convert / to \ ;
  9067 000011DD AA                      	STOSB
  9068                                  
  9069 000011DE 08C0                    	OR	AL,AL
  9070 000011E0 75F4                    	JNZ	short CPYLoop
  9071 000011E2 58                      	pop	ax
  9072 000011E3 C3                      	retn
  9073                                  
  9074                                  ;----------------------------------------------------------------------------
  9075                                  ; Procedure Name : FStrCpy
  9076                                  ;----------------------------------------------------------------------------
  9077                                  
  9078                                  FStrCpy:
  9079 000011E4 50                      	push	ax
  9080                                  FCPYLoop:
  9081 000011E5 AC                      	LODSB
  9082 000011E6 AA                      	STOSB
  9083 000011E7 08C0                    	OR	AL,AL
  9084 000011E9 75FA                    	JNZ	short FCPYLoop
  9085 000011EB 58                      	pop	ax
  9086 000011EC C3                      	retn
  9087                                  
  9088                                  ; 20/07/2018 - Retro DOS v3.0
  9089                                  ;----------------------------------------------------------------------------
  9090                                  ; UCase, IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1E2Fh
  9091                                  ;----------------------------------------------------------------------------
  9092                                  ;
  9093                                  ;UCase:	
  9094                                  ;	call	_UCase	 ; Offset 5518h (GetLet, Offset 5517h)
  9095                                  ;	retn
  9096                                  
  9097                                  ;Break <StrLen - compute length of string ES:DI>
  9098                                  ;----------------------------------------------------------------------------
  9099                                  ;**	StrLen - Compute Length of String
  9100                                  ;
  9101                                  ;	StrLen computes the length of a string, including the trailing 00
  9102                                  ;
  9103                                  ;	ENTRY	(es:di) = address of string
  9104                                  ;	EXIT	(cx) = size of string
  9105                                  ;	USES	cx, flags
  9106                                  ;----------------------------------------------------------------------------
  9107                                  
  9108                                  StrLen:
  9109 000011ED 57                      	push	di
  9110 000011EE 50                      	push	ax
  9111                                  	;MOV	CX,-1
  9112 000011EF B9FFFF                  	mov	cx,65535
  9113 000011F2 30C0                    	XOR	AL,AL
  9114 000011F4 F2AE                    	REPNE	SCASB
  9115 000011F6 F7D1                    	NOT	CX
  9116 000011F8 58                      	pop	ax
  9117 000011F9 5F                      	pop	di
  9118 000011FA C3                      	retn
  9119                                  
  9120                                  ;----------------------------------------------------------------------------
  9121                                  ;**	DStrLen - Compute Length of String
  9122                                  ;
  9123                                  ;	ENTRY	(ds:si) = address of string
  9124                                  ;	EXIT	(cx) = size of string, including trailing NUL
  9125                                  ;	USES	cx, flags
  9126                                  ;----------------------------------------------------------------------------
  9127                                  
  9128                                  DStrLen:	; BUGBUG - this guy is a pig, who uses him?
  9129 000011FB E80300                  	CALL	XCHGP
  9130 000011FE E8ECFF                  	CALL	StrLen
  9131                                  	;CALL	XCHGP
  9132                                  	;retn
  9133                                  	; 18/12/2022
  9134                                  	;jmp	short XCHGP
  9135                                  
  9136                                  ;----------------------------------------------------------------------------
  9137                                  ;**	XCHGP - Exchange Source and Destination Pointers
  9138                                  ;
  9139                                  ;	XCHGP exchanges (DS:SI) and (ES:DI)
  9140                                  ;
  9141                                  ;	ENTRY	none
  9142                                  ;	EXIT	pairs exchanged
  9143                                  ;	USES	SI, DI, DS, ES
  9144                                  ;----------------------------------------------------------------------------
  9145                                  
  9146                                  XCHGP:
  9147 00001201 1E                      	push	ds
  9148 00001202 06                      	push	es
  9149 00001203 1F                      	pop	ds
  9150 00001204 07                      	pop	es
  9151 00001205 87F7                    	XCHG	SI,DI
  9152                                  xchgp_retn:
  9153 00001207 C3                      	retn
  9154                                  
  9155                                  ;Break	<Idle - wait for a specified amount of time>
  9156                                  ;----------------------------------------------------------------------------
  9157                                  ;
  9158                                  ;   Idle - when retrying an operation due to a lock/sharing violation,
  9159                                  ;   	   we spin until RetryLoop is exhausted.
  9160                                  ;
  9161                                  ;   Inputs:	RetryLoop is the number of times we spin
  9162                                  ;   Outputs:	Wait
  9163                                  ;   Registers modified: none
  9164                                  ;----------------------------------------------------------------------------
  9165                                  
  9166                                  Idle:
  9167                                  	;test	byte [SS:FSHARING],0FFh
  9168 00001208 36803E[7205]00          	cmp	byte [SS:FSHARING],0	;hkn; SS override
  9169                                  	;retnz
  9170 0000120E 75F7                    	jnz	short xchgp_retn
  9171                                  	;SAVE	<CX>
  9172 00001210 51                      	push	cx
  9173 00001211 368B0E[1C00]            	MOV	CX,[ss:RetryLoop]	;hkn; SS override
  9174 00001216 E308                    	JCXZ	Idle3
  9175                                  Idle1:	
  9176 00001218 51                      	PUSH	CX
  9177 00001219 31C9                    	XOR	CX,CX
  9178                                  Idle2:	
  9179 0000121B E2FE                    	LOOP	Idle2
  9180 0000121D 59                      	POP	CX
  9181 0000121E E2F8                    	LOOP	Idle1
  9182                                  Idle3:	
  9183                                  	;RESTORE <CX>
  9184 00001220 59                      	pop	cx
  9185 00001221 C3                      	retn
  9186                                  
  9187                                  ;Break	<TableDispatch - dispatch to a table>
  9188                                  ;----------------------------------------------------------------------------
  9189                                  ;
  9190                                  ;   TableDispatch - given a table and an index, jmp to the approptiate
  9191                                  ;   routine. Preserve all input registers to the routine.
  9192                                  ;
  9193                                  ;   Inputs:	Push	return address
  9194                                  ;		Push	Table address
  9195                                  ;		Push	index (byte)
  9196                                  ;   Outputs:	appropriate routine gets jumped to.
  9197                                  ;		return indicates invalid index
  9198                                  ;   Registers modified: none.
  9199                                  ;----------------------------------------------------------------------------
  9200                                  
  9201                                  struc TFrame	 ; TableFrame
  9202 00000000 ????                    .OldBP:	 resw 1  ; 0
  9203 00000002 ????                    .OldRet: resw 1  ; 2
  9204 00000004 ??                      .Index:	 resb 1  ; 4
  9205 00000005 ??                      .Pad:	 resb 1  ; 5  
  9206 00000006 ????                    .Tab:	 resw 1  ; 6
  9207 00000008 ????                    .NewRet: resw 1  ; 8
  9208                                  endstruc
  9209                                  
  9210                                  TableDispatch:
  9211 00001222 55                      	PUSH	BP
  9212 00001223 89E5                    	MOV	BP,SP
  9213 00001225 53                      	PUSH	BX			; save BX
  9214                                  	;mov	bx,[bp+6]
  9215 00001226 8B5E06                  	MOV	BX,[BP+TFrame.Tab]	; get pointer to table
  9216 00001229 2E8A1F                  	MOV	BL,[CS:BX]		; maximum index
  9217                                  	;cmp	[bp+4],bl
  9218 0000122C 385E04                  	CMP	[BP+TFrame.Index],BL	; table error?
  9219 0000122F 7317                    	JAE	short TableError	; yes
  9220                                  	;mov	bl,[bp+4]
  9221 00001231 8A5E04                  	MOV	BL,[BP+TFrame.Index]	; get desired table index
  9222 00001234 30FF                    	XOR	BH,BH			; convert to word
  9223 00001236 D1E3                    	SHL	BX,1			; convert to word pointer
  9224 00001238 43                      	INC	BX			; point past first length byte
  9225                                  	; 17/08/2018
  9226                                  	;add	bx,[bp+6]
  9227 00001239 035E06                  	ADD	BX,[BP+TFrame.Tab]	; get real offset
  9228 0000123C 2E8B1F                  	MOV	BX,[CS:BX]		; get contents of table entry
  9229                                  	;mov	[bp+6],bx
  9230 0000123F 895E06                  	MOV	[BP+TFrame.Tab],BX	; put table entry into return address
  9231 00001242 5B                      	POP	BX			; restore BX
  9232 00001243 5D                      	POP	BP			; restore BP
  9233 00001244 83C404                  	ADD	SP,4			; clean off Index and our return addr
  9234 00001247 C3                      	retn				; do operation
  9235                                  TableError:
  9236 00001248 5B                      	POP	BX			; restore BX
  9237 00001249 5D                      	POP	BP			; restore BP
  9238 0000124A C20600                  	RETN	6			; clean off Index, Table and RetAddr
  9239                                  
  9240                                  
  9241                                  ;Break	<TestNet - determine if a CDS is for the network>
  9242                                  ;----------------------------------------------------------------------------
  9243                                  ;
  9244                                  ;   TestNet - examine CDS pointed to by ThisCDS and see if it indicates a
  9245                                  ;	network CDS. This will handle NULL cds also.
  9246                                  ;
  9247                                  ;   Inputs:	ThisCDS points to CDS or NULL
  9248                                  ;   Outputs:	ES:DI = ThisCDS
  9249                                  ;		carry Set => network
  9250                                  ;		carry Clear => local
  9251                                  ;   Registers modified: none.
  9252                                  ;----------------------------------------------------------------------------
  9253                                  
  9254                                  TestNet:
  9255                                  	;LES	DI,[CS:THISCDS]
  9256                                  
  9257                                  	; 16/05/2019 - Retro DOS v4.0
  9258 0000124D 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  9259 00001252 26C43E[A205]            	LES	DI,[ES:THISCDS]
  9260 00001257 83FFFF                  	CMP	DI,-1
  9261 0000125A 7408                    	JZ	short CMCRet		; UNC? carry is clear
  9262                                  	;;test	word [es:di+43h],8000h
  9263                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
  9264                                  	;test	byte [es:di+44h],80h
  9265 0000125C 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
  9266 00001261 7501                    	JNZ	short CMCRet		; jump has carry clear
  9267 00001263 C3                      	retn				; carry is clear
  9268                                  CMCRet: 
  9269 00001264 F5                      	CMC
  9270 00001265 C3                      	retn
  9271                                  
  9272                                  ;Break	<IsSFTNet - see if an sft is for the network>
  9273                                  ;----------------------------------------------------------------------------
  9274                                  ;
  9275                                  ;   IsSFTNet - examine SF pointed to by ES:DI and see if it indicates a
  9276                                  ;	network file.
  9277                                  ;
  9278                                  ;   Inputs:	ES:DI point to SFT
  9279                                  ;   Outputs:	Zero set if not network sft
  9280                                  ;		zero reset otherwise
  9281                                  ;		Carry CLEAR!!!
  9282                                  ;   Registers modified: none.
  9283                                  ;----------------------------------------------------------------------------
  9284                                  
  9285                                  IsSFTNet:
  9286                                  	;;test	word [es:di+5],8000h
  9287                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
  9288                                  	; 16/05/2019 
  9289                                  	;test	byte [es:di+6],80h
  9290 00001266 26F6450680              	TEST	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
  9291 0000126B C3                      	retn
  9292                                  
  9293                                  ;Break	<FastInit - Initialize FastTable entries >
  9294                                  ;----------------------------------------------------------------------------
  9295                                  ;   DOS 4.00   2/9/87
  9296                                  ;   FastInit  - initialize the FASTXXX routine entry
  9297                                  ;		  in the FastTable
  9298                                  ;
  9299                                  ;   Inputs:	BX = FASTXXX ID ( 1=fastopen )
  9300                                  ;		DS:SI = address of FASTXXX routine entry
  9301                                  ;		   SI = -1 for query only
  9302                                  ;   Outputs:	Carry flag clear, if success
  9303                                  ;		Carry flag set,   if failure
  9304                                  ;
  9305                                  ;
  9306                                  ;----------------------------------------------------------------------------
  9307                                  
  9308                                  ;Procedure FastInit,NEAR
  9309                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
  9310                                  
  9311                                  ;	; MSDOS 3.3
  9312                                  ;	; IBMDOS.COM (1987) - Offset 1EB3h
  9313                                  ;FastInit:
  9314                                  ;	mov	di,FastTable ; FastOpenTable
  9315                                  ;	mov	ax,[cs:di+4]		; Entry segment
  9316                                  ;	mov	bx,cs			; get DOS segment
  9317                                  ;	cmp	ax,bx			; first time installed ?	
  9318                                  ;	je	short ok_install	; yes
  9319                                  ;	stc				; set carry
  9320                                  ;	retn				; (cf=1 means) already installed !
  9321                                  ;
  9322                                  ;ok_install:
  9323                                  ;	mov	bx,FastTable ; FastOpenTable
  9324                                  ;	mov	cx,ds
  9325                                  ;	; set address of FASTXXX (FASTOPEN) routine entry
  9326                                  ;	mov	[cs:bx+4],cx
  9327                                  ;	mov	[cs:bx+2],si
  9328                                  ;	retn
  9329                                  
  9330                                  ; 16/05/2019 - Retro DOS v4.0
  9331                                  
  9332                                  FastInit:
  9333                                  	; MSDOS 6.0
  9334                                  	;hkn; set up es to dosdataseg.
  9335 0000126C 06                      	push	es
  9336                                  	;getdseg <es>			; es -> dosdata
  9337 0000126D 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  9338                                  
  9339                                  	;hkn; FastTable is in DOSDATA
  9340 00001272 BF[320D]                	MOV	DI,FastTable+2		;AN000;FO. points to fastxxx entry
  9341 00001275 4B                      	DEC	BX			;AN000;FO.;; decrement index
  9342 00001276 89DA                    	MOV	DX,BX			;AN000;FO.;; save bx
  9343 00001278 D1E3                    	SHL	BX,1			;AN000;FO.;; times 4 , each entry is DWORD
  9344 0000127A D1E3                    	SHL	BX,1			;AN000;FO.
  9345 0000127C 01DF                    	ADD	DI,BX			;AN000;FO. index to the entry
  9346 0000127E 268B4502                	MOV	AX,[ES:DI+2]		;AN000;FO. get entry segment
  9347                                  fcheck: 				;AN000;
  9348 00001282 8CC9                    	MOV	CX,CS			;AN000;FO.;; get DOS segment
  9349 00001284 39C8                    	CMP	AX,CX			;AN000;FO.;; first time installed ?
  9350 00001286 7407                    	JZ	short ok_install	;AN000;FO.;; yes
  9351 00001288 09C0                    	OR	AX,AX			;AN000;FO.;
  9352 0000128A 7403                    	JZ	short ok_install	;AN000;FO.;
  9353 0000128C F9                      	STC				;AN000;FO.;; already installed !
  9354 0000128D EB17                    	JMP	SHORT FSret		;AN000;FO. set carry
  9355                                  ok_install:				;AN000;
  9356 0000128F 83FEFF                  	CMP	SI,-1			;AN000;FO.; Query only ?
  9357 00001292 7412                    	JZ	short FSret		;AN000;FO.; yes
  9358 00001294 8CD9                    	MOV	CX,DS			;AN000;FO.; get FASTXXX entry segment
  9359 00001296 26894D02                	MOV	[ES:DI+2],CX		;AN000;FO.; initialize routine entry
  9360 0000129A 268935                  	MOV	[ES:DI],SI		;AN000;FO.; initialize routine offset
  9361                                  
  9362                                  ;hkn; FastFlg moved to DOSDATA
  9363 0000129D BF[3A0D]                	MOV	DI,FastFlg		;AN000;FO.; get addr of FASTXXX flags
  9364 000012A0 01D7                    	ADD	DI,DX			;AN000;FO.; index to a FASTXXX flag
  9365                                  	;or	byte [es:di],80h
  9366 000012A2 26800D80                	OR	byte [ES:DI],Fast_yes	;AN000;FO.; indicate installed
  9367                                  FSret:					;AN000;
  9368 000012A6 07                      	pop	es
  9369 000012A7 C3                      	retn				;AN000;FO.
  9370                                  
  9371                                  ;EndProc FastInit
  9372                                  
  9373                                  ;Break	<FastRet - initial routine in FastOpenTable >
  9374                                  ;----------------------------------------------------------------------------
  9375                                  ;   DOS 3.3   6/10/86
  9376                                  ;   FastRet	- indicate FASTXXXX  not in memory
  9377                                  ;
  9378                                  ;   Inputs:	None
  9379                                  ;   Outputs:	AX = -1 and carry flag set
  9380                                  ;
  9381                                  ;   Registers modified: none.
  9382                                  ;----------------------------------------------------------------------------
  9383                                  
  9384                                  FastRet:
  9385                                  	;mov	ax,-1
  9386                                  	;stc
  9387                                  	;retf
  9388 000012A8 F9                      	STC
  9389 000012A9 19C0                    	sbb	ax,ax		; (ax) = -1, 'C' set
  9390 000012AB CB                      	RETF
  9391                                  
  9392                                  ;Break	<NLS_OPEN - do $open for NLSFUNC>
  9393                                  ;----------------------------------------------------------------------------
  9394                                  ;   DOS 3.3   6/10/86
  9395                                  ;   NLS_OPEN	- call $OPEN for NLSFUNC
  9396                                  ;
  9397                                  ;   Inputs:	Same input as $OPEN except CL = mode
  9398                                  ;   Outputs:	same output as $OPEN
  9399                                  ;
  9400                                  ;----------------------------------------------------------------------------
  9401                                  
  9402                                  ;hkn; NOTE! SS MUST HAVE BEEN SET UP TO DOSDATA BY THE TIME THESE
  9403                                  ;hkn; NLS FUNCTIONS ARE CALLED!!! THERE FORE WE WILL USE SS OVERRIDES
  9404                                  ;hkn; IN ORDER TO ACCESS DOS DATA VARIABLES!
  9405                                  
  9406                                  NLS_OPEN:
  9407                                  ;	MOV	BL,[CPSWFLAG]	 ; disable code page matching logic
  9408                                  ;	MOV	BYTE [CPSWFLAG],0
  9409                                  ;	PUSH	BX		 ; save current state
  9410                                  
  9411 000012AC 88C8                    	MOV	AL,CL		 ; set up correct interface for $OPEN
  9412 000012AE E84C5C                  	call	_$OPEN
  9413                                  
  9414                                  ;	POP	BX		 ; restore current state
  9415                                  ;	MOV	[CPSWFLAG],BL
  9416                                  
  9417 000012B1 C3                      	RETN
  9418                                  
  9419                                  ;Break	<NLS_LSEEK - do $LSEEK for NLSFUNC>
  9420                                  ;----------------------------------------------------------------------------
  9421                                  ;   DOS 3.3   6/10/86
  9422                                  ;   NLS_LSEEK	- call $LSEEK for NLSFUNC
  9423                                  ;
  9424                                  ;   Inputs:	BP = open mode
  9425                                  ;   Outputs:	same output as $LSEEK
  9426                                  ;
  9427                                  ;----------------------------------------------------------------------------
  9428                                  
  9429                                  ; 16/05/2019 - Retro DOS v4.0
  9430                                  
  9431                                  NLS_LSEEK:
  9432 000012B2 36FF36[8405]            	PUSH	word [SS:USER_SP] ; save user stack
  9433 000012B7 36FF36[8605]            	PUSH	word [SS:USER_SS]
  9434 000012BC E81000                  	CALL	Fake_User_Stack
  9435 000012BF 89E8                    	MOV	AX,BP		; set up correct interface for $LSEEK
  9436 000012C1 E8E655                  	call	_$LSEEK
  9437 000012C4 368F06[8605]            	POP	word [SS:USER_SS] ; restore user stack
  9438 000012C9 368F06[8405]            	POP	word [SS:USER_SP]
  9439 000012CE C3                      	RETN
  9440                                  
  9441                                  ;Break	<Fake_User_Stack - save user stack>
  9442                                  ;----------------------------------------------------------------------------
  9443                                  ;   DOS 3.3   6/10/86
  9444                                  ;   Fake_User_Stack - save user stack pointer
  9445                                  ;
  9446                                  ;----------------------------------------------------------------------------
  9447                                  
  9448                                  Fake_User_Stack:
  9449 000012CF 36A1[6A0D]              	MOV	AX,[SS:USER_SP_2F] ; replace with INT 2F stack
  9450 000012D3 36A3[8405]              	MOV	[SS:USER_SP],AX
  9451 000012D7 8CD0                    	MOV	AX,SS
  9452 000012D9 36A3[8605]              	MOV	[SS:USER_SS],AX
  9453 000012DD C3                      	RETN
  9454                                  
  9455                                  ;Break	<GetDevList - get device header list pointer>
  9456                                  ;----------------------------------------------------------------------------
  9457                                  ;   DOS 3.3   7/25/86
  9458                                  ;   GetDevList - get device header list pointer
  9459                                  ;
  9460                                  ;   Output: AX:BX points to the device header list
  9461                                  ;----------------------------------------------------------------------------
  9462                                  
  9463                                  GetDevList:
  9464                                  	; 16/05/2019 - Retro DOS v4.0
  9465 000012DE BE[280D]                	MOV	SI,SysInitTable
  9466 000012E1 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  9467 000012E6 C534                    	LDS	SI,[SI]
  9468                                  	;mov	ax,[si+34]  ; SSYSINITVARS offset 34 = [SI+SYSI.DEV]
  9469 000012E8 8B4422                  	MOV	AX,[SI+SYSI.DEV]
  9470                                  	;mov	bx,[si+36]  ; SSYSINITVARS offset 36 = [SI+SYSI.DEV+2]
  9471 000012EB 8B5C24                  	MOV	BX,[SI+SYSI.DEV+2]
  9472 000012EE C3                      	RETN
  9473                                  
  9474                                  ;Break	<NLS_IOCTL - do $IOCTL for NLSFUNC   >
  9475                                  ;----------------------------------------------------------------------------
  9476                                  ;   DOS 3.3   7/25/86
  9477                                  ;   NLS_IOCTL	- call $IOCTL for NLSFUNC
  9478                                  ;
  9479                                  ;   Inputs:	BP = function code 0CH
  9480                                  ;   Outputs:	same output as generic $IOCTL
  9481                                  ;
  9482                                  ;----------------------------------------------------------------------------
  9483                                  
  9484                                  NLS_IOCTL:
  9485                                  	; 16/05/2019 - Retro DOS v4.0
  9486 000012EF 36FF36[8405]            	PUSH	word [SS:USER_SP] ; save user stack
  9487 000012F4 36FF36[8605]            	PUSH	word [SS:USER_SS]
  9488 000012F9 E8D3FF                  	CALL	Fake_User_Stack
  9489 000012FC 89E8                    	MOV	AX,BP	     ; set up correct interface for $LSEEK
  9490 000012FE E8960F                  	call	_$IOCTL
  9491 00001301 368F06[8605]            	POP	word [SS:USER_SS] ; restore user stack
  9492 00001306 368F06[8405]            	POP	word [SS:USER_SP]
  9493 0000130B C3                      	RETN
  9494                                  
  9495                                  ;Break	<NLS_GETEXT- get extended error for NLSFUNC>
  9496                                  ;----------------------------------------------------------------------------
  9497                                  ;   DOS 3.3   7/25/86
  9498                                  ;   NLS_GETEXT	-
  9499                                  ;
  9500                                  ;   Inputs:	none
  9501                                  ;   Outputs:	AX = extended error
  9502                                  ;
  9503                                  ;----------------------------------------------------------------------------
  9504                                  
  9505                                  NLS_GETEXT:
  9506                                  	; 16/05/2019 - Retro DOS v4.0
  9507 0000130C 36A1[2403]              	MOV	AX,[SS:EXTERR]	 ; return extended error
  9508                                  	; 23/09/2023
  9509                                  MSG_RETRIEVAL:
  9510 00001310 C3                      	RETN
  9511                                  
  9512                                  ; 29/04/2019 - Retro DOS v4.0
  9513                                  
  9514                                  ;Break	<MSG_RETRIEVAL- get beginning addr of system and parser messages>
  9515                                  
  9516                                  ;----------------------------------------------------------------------------
  9517                                  ;   DOS 4.00
  9518                                  ;
  9519                                  ;   Inputs:	DL=0 get extended error message addr
  9520                                  ;		  =1 set extended error message addr
  9521                                  ;		  =2 get parser error message addr
  9522                                  ;		  =3 set parser error message addr
  9523                                  ;		  =4 get critical error message addr
  9524                                  ;		  =5 set critical error message addr
  9525                                  ;		  =6 get file system error message addr
  9526                                  ;		  =7 set file system error message addr
  9527                                  ;		  =8 get address for code reduction
  9528                                  ;		  =9 set address for code reduction
  9529                                  ;   Function:	get/set message address
  9530                                  ;   Outputs:	ES:DI points to addr when get
  9531                                  ;----------------------------------------------------------------------------
  9532                                  
  9533                                  ;Procedure MSG_RETRIEVAL,NEAR
  9534                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
  9535                                  
  9536                                  ; 23/09/2023
  9537                                  ;MSG_RETRIEVAL:
  9538                                  
  9539                                  ;;	NOTE:  This function lives in command.com resident code now.
  9540                                  ;;	If the int 2F ever gets this far, we'll return registers
  9541                                  ;;	unchanged, which produces the same result as before, if
  9542                                  ;;	command.com wasn't present (and therefore no messages available).
  9543                                  ;;
  9544                                  ;;	I didn't point the entry in the 2F table to No_Op because
  9545                                  ;;	No_Op zeroes AL.
  9546                                  ;;
  9547                                  ;;;hkn; set up ds to point to DOSDATA
  9548                                  ;;	push	ds
  9549                                  ;;	getdseg	<ds>			; ds -> dosdata
  9550                                  ;;
  9551                                  ;;	PUSH	AX		    ;AN000;;MS. save regs
  9552                                  ;;	PUSH	SI		    ;AN000;;MS. save regs
  9553                                  ;;	MOV	AX,DX		    ;AN000;;MS.
  9554                                  ;;	MOV	SI,OFFSET DOSDATA:MSG_EXTERROR ;AN000;;MS.
  9555                                  ;;	test	AL,1		    ;AN000;;MS. get ?
  9556                                  ;;	JZ	toget		    ;AN000;;MS. yes
  9557                                  ;;	DEC	AL		    ;AN000;;MS.
  9558                                  ;;toget:				    ;AN000;
  9559                                  ;;	SHL	AL,1		    ;AN000;;MS. times 2
  9560                                  ;;	XOR	AH,AH		    ;AN000;;MS.
  9561                                  ;;	ADD	SI,AX		    ;AN000;;MS. position to the entry
  9562                                  ;;	test	DL,1		    ;AN000;;MS. get ?
  9563                                  ;;	JZ	getget			     ;AN000;;MS. yes
  9564                                  ;;	MOV	WORD PTR DS:[SI],DI    ;AN000;;MS. set MSG
  9565                                  ;;	MOV	WORD PTR DS:[SI+2],ES  ;AN000;;MS. address to ES:DI
  9566                                  ;;	JMP	SHORT MSGret		     ;AN000;;MS. exit
  9567                                  ;;getget: 				     ;AN000;
  9568                                  ;;	LES	DI,DWORD PTR DS:[SI]	     ;AN000;;MS. get msg addr
  9569                                  ;;MSGret: 				     ;AN000;
  9570                                  ;;	POP	SI			     ;AN000;;MS.
  9571                                  ;;	POP	AX			     ;AN000;;MS.
  9572                                  ;;
  9573                                  ;;	pop	ds
  9574                                  
  9575                                  ;	return				     ;AN000;;MS. exit
  9576                                  
  9577                                  ; 23/09/2023
  9578                                  ;	retn	; 29/04/2019
  9579                                  
  9580                                  ;============================================================================
  9581                                  ; ECritDisk, LCritDisk, ECritDevice, LCritDevice
  9582                                  ; IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1F36h
  9583                                  ;============================================================================
  9584                                  ; 20/07/2018 - Retro DOS v3.0
  9585                                  
  9586                                  ;	; MSDOS 3.3
  9587                                  ;	; 08/08/2018 - Retro DOS v3.0
  9588                                  ;ECritMEM:
  9589                                  ;ECritSFT:
  9590                                  ;	;
  9591                                  ;ECritDisk:
  9592                                  ;	retn
  9593                                  ;	;push	ax
  9594                                  ;	
  9595                                  ;	mov	ax,8001h
  9596                                  ;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9597                                  ;			; AL = critical section number (00h-0Fh)
  9598                                  ;	pop	ax
  9599                                  ;	retn
  9600                                  ;
  9601                                  ;	; MSDOS 3.3
  9602                                  ;	; 08/08/2018 - Retro DOS v3.0
  9603                                  ;LCritMEM:
  9604                                  ;LCritSFT:
  9605                                  ;	;
  9606                                  ;LCritDisk:
  9607                                  ;	retn
  9608                                  ;	;push	ax
  9609                                  ;	
  9610                                  ;	mov	ax,8101h
  9611                                  ;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9612                                  ;			; AL = critical section number (00h-0Fh)
  9613                                  ;	pop	ax
  9614                                  ;	retn
  9615                                  ;
  9616                                  ;ECritDevice:
  9617                                  ;	retn
  9618                                  ;	;push	ax
  9619                                  ;	
  9620                                  ;	mov	ax,8002h
  9621                                  ;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9622                                  ;			; AL = critical section number (00h-0Fh)
  9623                                  ;	pop	ax
  9624                                  ;	retn
  9625                                  ;
  9626                                  ;LCritDevice:
  9627                                  ;	retn
  9628                                  ;	;push	ax
  9629                                  ;	
  9630                                  ;	mov	ax,8102h
  9631                                  ;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9632                                  ;			; AL = critical section number (00h-0Fh)
  9633                                  ;	pop	ax
  9634                                  ;	retn
  9635                                  
  9636                                  ;============================================================================
  9637                                  ; CRIT.ASM, MSDOS 6.0, 1991
  9638                                  ;============================================================================
  9639                                  ; 12/05/2019 - Retro DOS v4.0
  9640                                  
  9641                                  ; Critical Section Routines
  9642                                  
  9643                                  ; MSDOS 6.21 - MSDOS.SYS - DOSCODE:513Ah
  9644                                  
  9645                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  9646                                  ; DOSCODE:5126h (MSDOS 5.0 MSDOS.SYS)
  9647                                  
  9648                                  ; ---------------------------------------------------------------------------
  9649                                  ; Each handler must leave everything untouched; including flags!
  9650                                  ;
  9651                                  ; Sleaze for time savings:  first instruction is a return. This is patched
  9652                                  ; by the sharer to be a PUSH AX to complete the correct routines.
  9653                                  ; ---------------------------------------------------------------------------
  9654                                  
  9655                                  ; (DOSMAC.INC, MSDOS 6.0, 1991)
  9656                                  ; ---------------------------------------------------------------------------
  9657                                  ; Some old versions of the 80286 have a bug in the chip. The popf instruction
  9658                                  ; will enable interrupts. Therefore in a section of code with interrupts
  9659                                  ; disabled and you need a popf instruction use the 'popff' macro instead.
  9660                                  ; ---------------------------------------------------------------------------
  9661                                  
  9662                                  ;%macro POPFF 0
  9663                                  ;	jmp	$+3
  9664                                  ;	iret
  9665                                  ;	push	cs
  9666                                  ;	call	$-2
  9667                                  ;%endmacro
  9668                                  
  9669                                  ; ---------------------------
  9670                                  
  9671                                  ;Procedure  ECritDisk,NEAR
  9672                                  	;public  ECritMEM
  9673                                  	;public  ECritSFT
  9674                                  ECritMEM:
  9675                                  ECritSFT:
  9676                                  ;
  9677                                  ECritDisk:
  9678                                  
  9679                                  ;SR; Check if critical section is to be entered
  9680                                  
  9681 00001311 9C                      	pushf
  9682 00001312 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9683 00001318 740D                    	jz	short ECritDisk_2
  9684                                  
  9685                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9686                                  ;	;popff  ; * (macro)
  9687                                  ;	jmp	short ECritDisk_1 ; *
  9688                                  ;
  9689                                  ;ECritDisk_iret: ; *
  9690                                  ;	iret ; *
  9691                                  
  9692                                  	; 16/12/2022
  9693                                  	; 13/11/2022
  9694                                  	;jmp	short ECritDisk_1
  9695                                  	; 06/11/2022
  9696                                  ;ECritDisk_iret:
  9697                                  ;	iret	
  9698                                  
  9699                                  	; 06/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9700                                  ECritDisk_1:
  9701 0000131A 0E                      	push	cs ; *
  9702 0000131B E80800                  	call	ECritDisk_iret ; *		
  9703                                  	
  9704                                  ECritDisk_0:
  9705 0000131E 50                      	PUSH    AX
  9706                                  	;MOV	AX,8000h+critDisk
  9707                                  	;INT	int_IBM
  9708 0000131F B80180                  	mov	ax,8001h
  9709 00001322 CD2A                    	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9710                                  			; AL = critical section number (00h-0Fh)
  9711 00001324 58                      	POP     AX
  9712 00001325 C3                      	retn
  9713                                  
  9714                                  	; 16/12/2022
  9715                                  	; 13/11/2022
  9716                                  ECritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0
  9717                                  LCritDisk_iret: 
  9718 00001326 CF                      	iret
  9719                                  
  9720                                  ECritDisk_2:
  9721                                  	;;popff ; *
  9722                                  	;;retn
  9723                                  ;	jmp	short ECritDisk_3 ; *
  9724                                  ;ECritDisk_iret2: ; *
  9725                                  ;	iret
  9726                                  	
  9727                                  	; 16/12/2022
  9728                                  	; 13/11/2022
  9729                                  	;jmp	short ECritDisk_3
  9730                                  ;ECritDisk_iret2:
  9731                                  	;iret
  9732                                  
  9733                                  ECritDisk_3:
  9734 00001327 0E                      	push    cs ; *
  9735                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9736                                  	;call	ECritDisk_iret2 ; *
  9737                                  	;retn
  9738                                  	; 16/12/2022
  9739 00001328 E8FBFF                  	call	ECritDisk_iret
  9740 0000132B C3                      	retn
  9741                                  
  9742                                  ;EndProc ECritDisk
  9743                                  
  9744                                  ; ---------------------------
  9745                                  
  9746                                  ;Procedure   LCritDisk,NEAR
  9747                                  	;public  LCritMEM
  9748                                  	;public  LCritSFT
  9749                                  LCritMEM:
  9750                                  LCritSFT:
  9751                                  ;
  9752                                  LCritDisk:
  9753                                  
  9754                                  ;SR; Check if critical section is to be entered
  9755                                  
  9756 0000132C 9C                      	pushf
  9757 0000132D 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9758 00001333 740C                    	jz	short LCritDisk_2
  9759                                  	;popff  ; * (macro)
  9760                                  ;	jmp	short LCritDisk_1 ; *
  9761                                  ;
  9762                                  ;LCritDisk_iret: ; *
  9763                                  ;	iret ; *
  9764                                  
  9765                                  	; 16/12/2022
  9766                                  	; 13/11/2022
  9767                                  	;jmp	short LCritDisk_1
  9768                                  ;LCritDisk_iret:
  9769                                  	;iret
  9770                                  
  9771                                  LCritDisk_1:
  9772 00001335 0E                      	push	cs ; *
  9773 00001336 E8EDFF                  	call	LCritDisk_iret ; *		
  9774                                  	
  9775                                  LCritDisk_0:
  9776 00001339 50                      	PUSH	AX
  9777                                  	;MOV	AX,8100h+critDisk
  9778                                  	;INT	int_IBM
  9779 0000133A B80181                  	mov	ax,8101h
  9780 0000133D CD2A                    	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9781                                  			; AL = critical section number (00h-0Fh)
  9782 0000133F 58                      	POP	AX
  9783 00001340 C3                      	retn
  9784                                  
  9785                                  ;LCritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0 
  9786                                  ;	iret
  9787                                  
  9788                                  LCritDisk_2:
  9789                                  	;;popff ; *
  9790                                  	;;retn
  9791                                  ;	jmp	short LCritDisk_3 ; *
  9792                                  ;LCritDisk_iret2: ; *
  9793                                  ;	iret
  9794                                  
  9795                                  	; 16/12/2022
  9796                                  	; 13/11/2022
  9797                                  	;jmp	short LCritDisk_3
  9798                                  ;LCritDisk_iret2:
  9799                                  	;iret
  9800                                  
  9801                                  LCritDisk_3:
  9802 00001341 0E                      	push    cs ; *
  9803                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9804                                  	;call	LCritDisk_iret2 ; *
  9805                                  	;retn
  9806                                  	; 16/12/2022
  9807 00001342 E8E1FF                  	call	LCritDisk_iret
  9808 00001345 C3                      	retn
  9809                                  
  9810                                  ;EndProc LCritDisk
  9811                                  
  9812                                  ; ---------------------------
  9813                                  
  9814                                  ;Procedure   ECritDevice,NEAR
  9815                                  
  9816                                  ECritDevice:
  9817                                  
  9818                                  ;SR; Check if critical section is to be entered
  9819                                  
  9820 00001346 9C                      	pushf
  9821 00001347 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9822 0000134D 740D                    	jz	short ECritDevice_2
  9823                                  	;popff  ; * (macro)
  9824                                  ;	jmp	short ECritDevice_1 ; *
  9825                                  ;
  9826                                  ;ECritDevice_iret: ; *
  9827                                  ;	iret ; *
  9828                                  
  9829                                  	; 16/12/2022	
  9830                                  	; 13/11/2022
  9831                                  	;jmp	short ECritDevice_1
  9832                                  ;ECritDevice_iret:
  9833                                  	;iret
  9834                                  
  9835                                  ECritDevice_1:
  9836 0000134F 0E                      	push	cs ; *
  9837 00001350 E80800                  	call	ECritDevice_iret ; *		
  9838                                  	
  9839                                  ECritDevice_0:
  9840 00001353 50                      	PUSH	AX
  9841                                  	;MOV	AX,8000h+critDevice
  9842                                  	;INT	int_IBM
  9843 00001354 B80280                  	mov	ax,8002h
  9844 00001357 CD2A                    	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9845                                  			; AL = critical section number (00h-0Fh)
  9846 00001359 58                      	POP     AX
  9847 0000135A C3                      	retn
  9848                                  
  9849                                  	; 16/12/2022
  9850                                  	; 06/12/2022
  9851                                  ECritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0
  9852                                  LCritDevice_iret: 
  9853 0000135B CF                      	iret
  9854                                  
  9855                                  ECritDevice_2:
  9856                                  	;;popff ; *
  9857                                  	;;retn
  9858                                  ;	jmp	short ECritDevice_3 ; *
  9859                                  ;ECritDevice_iret2: ; *
  9860                                  ;	iret
  9861                                  
  9862                                  	; 16/12/2022
  9863                                  	; 13/11/2022
  9864                                  	;jmp	short ECritDevice_3
  9865                                  ;ECritDevice_iret2:
  9866                                  	;iret
  9867                                  
  9868                                  ECritDevice_3:
  9869 0000135C 0E                      	push    cs ; *
  9870                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9871                                  	;call	ECritDevice_iret2 ; *
  9872                                  	;retn
  9873                                  	; 16/12/2022
  9874 0000135D E8FBFF                  	call	ECritDevice_iret
  9875 00001360 C3                      	retn
  9876                                  
  9877                                  ;EndProc ECritDevice
  9878                                  
  9879                                  ; ---------------------------
  9880                                  
  9881                                  ;Procedure   LCritDevice,NEAR
  9882                                  
  9883                                  LCritDevice:
  9884                                  
  9885                                  ;SR; Check if critical section is to be entered
  9886                                  
  9887 00001361 9C                      	pushf
  9888 00001362 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9889 00001368 740C                    	jz	short LCritDevice_2
  9890                                  	;popff  ; * (macro)
  9891                                  ;	jmp	short LCritDevice_1 ; *
  9892                                  ;
  9893                                  ;LCritDevice_iret: ; *
  9894                                  ;	iret ; *
  9895                                  
  9896                                  	; 16/12/2022
  9897                                  	; 13/11/2022
  9898                                  	;jmp	short LCritDevice_1
  9899                                  ;LCritDevice_iret:
  9900                                  	;iret
  9901                                  
  9902                                  LCritDevice_1:
  9903 0000136A 0E                      	push	cs ; *
  9904 0000136B E8EDFF                  	call	LCritDevice_iret ; *		
  9905                                  	
  9906                                  LCritDevice_0:
  9907 0000136E 50                      	PUSH	AX
  9908                                  	;MOV	AX,8100h+critDevice
  9909                                  	;INT	int_IBM
  9910 0000136F B80281                  	mov	ax,8102h
  9911 00001372 CD2A                    	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9912                                  			; AL = critical section number (00h-0Fh)
  9913 00001374 58                      	POP     AX
  9914 00001375 C3                      	retn
  9915                                  
  9916                                  ;LCritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0 
  9917                                  ;	iret
  9918                                  
  9919                                  LCritDevice_2:
  9920                                  	;;popff ; *
  9921                                  	;;retn
  9922                                  ;	jmp	short LCritDevice_3 ; *
  9923                                  ;LCritDevice_iret2: ; *
  9924                                  ;	iret
  9925                                  
  9926                                  	; 16/12/2022
  9927                                  	; 13/11/2022
  9928                                  	;jmp	short LCritDevice_3
  9929                                  ;LCritDevice_iret2:
  9930                                  	;iret
  9931                                  
  9932                                  LCritDevice_3:
  9933 00001376 0E                      	push    cs ; *
  9934                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9935                                  	;call	LCritDevice_iret2 ; *
  9936                                  	;retn
  9937                                  	; 16/12/2022
  9938 00001377 E8E1FF                  	call	LCritDevice_iret
  9939 0000137A C3                      	retn
  9940                                  
  9941                                  ;EndProc LCritDevice
  9942                                  
  9943                                  ;============================================================================
  9944                                  ; CPMIO.ASM, MSDOS 6.0, 1991
  9945                                  ;============================================================================
  9946                                  ; 20/07/2018 - Retro DOS v3.0
  9947                                  
  9948                                  ;============================================================================
  9949                                  ; STDIO.ASM - (MSDOS 2.0)
  9950                                  ;============================================================================
  9951                                  
  9952                                  ;
  9953                                  ; Standard device IO for MSDOS (first 12 function calls)
  9954                                  ;
  9955                                  
  9956                                  ;.xlist
  9957                                  ;.xcref
  9958                                  ;INCLUDE STDSW.ASM
  9959                                  ;INCLUDE DOSSEG.ASM
  9960                                  ;.cref
  9961                                  ;.list
  9962                                  
  9963                                  ;TITLE   STDIO - device IO for MSDOS
  9964                                  ;NAME    STDIO
  9965                                  
  9966                                  ;INCLUDE IO.ASM
  9967                                  
  9968                                  ; ---------------------------------------------------------------------------
  9969                                  ;
  9970                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
  9971                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
  9972                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
  9973                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
  9974                                  ;			    to restore MSDOS 2.0 device IO source code 
  9975                                  ;
  9976                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)	
  9977                                  	
  9978                                  ;============================================================================
  9979                                  ; STDIO.ASM - (MSDOS 2.0)
  9980                                  ;============================================================================
  9981                                  
  9982                                  ;
  9983                                  ; Standard device IO for MSDOS (first 12 function calls)
  9984                                  ;
  9985                                  
  9986                                  ;.xlist
  9987                                  ;.xcref
  9988                                  ;INCLUDE STDSW.ASM
  9989                                  ;INCLUDE DOSSEG.ASM
  9990                                  ;.cref
  9991                                  ;.list
  9992                                  
  9993                                  ;TITLE   STDIO - device IO for MSDOS
  9994                                  ;NAME    STDIO
  9995                                  
  9996                                  ;INCLUDE IO.ASM
  9997                                  
  9998                                  ; ---------------------------------------------------------------------------
  9999                                  ;
 10000                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
 10001                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
 10002                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
 10003                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
 10004                                  ;			    to restore MSDOS 2.0 device IO source code 
 10005                                  ;
 10006                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)		
 10007                                  ;
 10008                                  ;============================================================================
 10009                                  ; IO.ASM (MSDOS 2.0) (IBMDOS.COM 2.0) - STRIN.ASM (MSDOS 2.0, 19/08/1983)
 10010                                  ;============================================================================
 10011                                  ; Retro DOS v2.0 by Erdogan Tan, 13/03/2018 - 14/03/2018
 10012                                  
 10013                                  ; (Disassembled code of IBMDOS.COM, 08/03/1983) - Dissassembler: IDA Pro Free
 10014                                  ; (Comments are from CPMIO.ASM - 1991, MSDOS 6.0) 
 10015                                  
 10016                                  ;============================================================================
 10017                                  ; CPMIO.ASM (MSDOS 6.0, 1991)
 10018                                  ;============================================================================
 10019                                  ; Retro DOS v4.0 by Erdogan Tan, 04/05/2019
 10020                                  
 10021                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10022                                  
 10023                                  ;**	Standard device IO for MSDOS (first 12 function calls)
 10024                                  ;
 10025                                  ;	TITLE	IBMCPMIO - device IO for MSDOS
 10026                                  ;	NAME	IBMCPMIO
 10027                                  
 10028                                  ;	Old style CP/M 1-12 system calls to talk to reserved devices
 10029                                  ;
 10030                                  ;	$Std_Con_Input_No_Echo
 10031                                  ;	$Std_Con_String_Output
 10032                                  ;	$Std_Con_String_Input
 10033                                  ;	$RawConIO
 10034                                  ;	$RawConInput
 10035                                  ;	RAWOUT
 10036                                  ;	RAWOUT2
 10037                                  ;
 10038                                  
 10039                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
 10040                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
 10041                                  ; references to be SS or CS relative which is desired.
 10042                                  
 10043                                  ; ---------------------------------------------------------------------------
 10044                                  
 10045                                  ;	TITLE	CPMIO2 - device IO for MSDOS
 10046                                  ;	NAME	CPMIO2
 10047                                  
 10048                                  ;
 10049                                  ;	Microsoft Confidential
 10050                                  ;	Copyright (C) Microsoft Corporation 1991
 10051                                  ;	All Rights Reserved.
 10052                                  ;
 10053                                  
 10054                                  ;**	Old style CP/M 1-12 system calls to talk to reserved devices
 10055                                  ;
 10056                                  ;	$Std_Con_Input
 10057                                  ;	$Std_Con_Output
 10058                                  ;	OUTT
 10059                                  ;	TAB
 10060                                  ;	BUFOUT
 10061                                  ;	$Std_Aux_Input
 10062                                  ;	$Std_Aux_Output
 10063                                  ;	$Std_Printer_Output
 10064                                  ;	$Std_Con_Input_Status
 10065                                  ;	$Std_Con_Input_Flush
 10066                                  ;
 10067                                  ;	Revision History:
 10068                                  ;
 10069                                  ;	  AN000	 version 4.00 - Jan. 1988
 10070                                  
 10071                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
 10072                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
 10073                                  ; references to be SS or CS relative which is desired.
 10074                                  
 10075                                  ;DOSCODE SEGMENT
 10076                                  ;	ASSUME	SS:DOSDATA,CS:DOSCODE
 10077                                  
 10078                                  
 10079                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
 10080                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
 10081                                  ;hkn;	not valid. 
 10082                                  
 10083                                  ; DOSCODE:51BAh (MSDOS 6.21, MSDOS.SYS)
 10084                                  ; 08/11/2022
 10085                                  ; DOSCODE:51A6h (MSDOS 5.0, MSDOS.SYS)
 10086                                  
 10087                                  ;
 10088                                  ;----------------------------------------------------------------------------
 10089                                  ;
 10090                                  ; Procedure : $Std_Con_Input_No_Echo
 10091                                  ;
 10092                                  ;----------------------------------------------------------------------------
 10093                                  ;
 10094                                  
 10095                                  _$STD_CON_INPUT_NO_ECHO:   ;System call 8
 10096                                  
 10097                                  ; Inputs:
 10098                                  ;	None
 10099                                  ; Function:
 10100                                  ;	Input character from console, no echo
 10101                                  ; Returns:
 10102                                  ;	AL = character
 10103                                  
 10104 0000137B 1E                      	push	ds
 10105 0000137C 56                      	push	si
 10106                                  INTEST:
 10107 0000137D E8053E                  	call	STATCHK
 10108 00001380 753B                    	jnz	short GET ; 08/09/2018
 10109                                  ;*************************************************************************
 10110                                  ;hkn; SS override
 10111 00001382 36803E[A00A]00          	cmp	byte [SS:PRINTER_FLAG],0  ; is printer idle?
 10112 00001388 7505                    	jnz	short no_sys_wait
 10113 0000138A B405                    	mov	ah,5			; get input status with system wait
 10114 0000138C E82D31                  	call	IOFUNC
 10115                                  no_sys_wait:
 10116                                  ;**************************************************************************
 10117 0000138F B484                    	MOV	AH,84h
 10118 00001391 CD2A                    	INT	int_IBM	 ; int 2Ah
 10119                                  
 10120                                  ;;; 7/15/86  update the date in the idle loop
 10121                                  ;;; Dec 19, 1986 D.C.L. changed following CMP to Byte Ptr from Word Ptr
 10122                                  ;;;;		 to shorten loop in consideration of the PC Convertible
 10123                                  
 10124                                  ;hkn; SS override
 10125 00001393 36803E[910D]FF          	CMP	byte [SS:DATE_FLAG],-1	; date is updated may be every
 10126 00001399 751B                    	JNZ	short NoUpdate		; 65535 x ? ms if no one calls
 10127                                  
 10128 0000139B 50                      	PUSH	AX
 10129 0000139C 53                      	PUSH	BX			; following is tricky,
 10130 0000139D 51                      	PUSH	CX			; it may be called by critical handler
 10131 0000139E 52                      	PUSH	DX			; at that time, DEVCALL is used by
 10132                                  					; other's READ or WRITE
 10133 0000139F 1E                      	PUSH	DS			; save DS = SFT's segment
 10134                                  
 10135                                  ;hkn; READTIME must use ds = DOSDATA
 10136                                  ;hkn;	PUSH	CS			; READTIME must use DS=CS
 10137                                  
 10138 000013A0 16                      	PUSH	SS ; 04/05/2019
 10139 000013A1 1F                      	POP	DS
 10140                                  
 10141 000013A2 B80000                  	MOV	AX,0			; therefore, we save DEVCALL
 10142 000013A5 E89A02                  	CALL	Save_Restore_Packet	; save DEVCALL packet
 10143                                  	;invoke	READTIME		; readtime
 10144 000013A8 E86FF7                  	call	READTIME
 10145 000013AB B80100                  	MOV	AX,1
 10146 000013AE E89102                  	CALL	Save_Restore_Packet	; restore DEVCALL packet
 10147                                  
 10148                                  ;	; MSDOS 3.3 (IBMDOS.COM, Offset 1F8Ch)
 10149                                  ;	; (MSDOS 6.0 code does not contain IBM DOS FETCHI_TAG check)
 10150                                  ;	push	bx
 10151                                  ;	mov	bx,DATE_FLAG
 10152                                  ;	add	bx,2  ; mov bx,FETCHI_FLAG
 10153                                  ;	cmp	word [cs:bx],5872h
 10154                                  ;	jz	short FETCHI_TAG_chk_ok
 10155                                  ;	call	DOSINIT
 10156                                  ;FETCHI_TAG_chk_ok:
 10157                                  ;	pop	bx
 10158                                  
 10159 000013B1 1F                      	POP	DS			; restore DS
 10160 000013B2 5A                      	POP	DX
 10161 000013B3 59                      	POP	CX
 10162 000013B4 5B                      	POP	BX
 10163 000013B5 58                      	POP	AX
 10164                                  NoUpdate:
 10165                                  
 10166                                  ;hkn; SS override
 10167 000013B6 36FF06[910D]            	INC	word [SS:DATE_FLAG]
 10168                                  
 10169                                  ;;; 7/15/86 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 10170 000013BB EBC0                    	JMP	short INTEST
 10171                                  GET:
 10172 000013BD 30E4                    	XOR	AH,AH
 10173 000013BF E8FA30                  	call	IOFUNC
 10174 000013C2 5E                      	POP	SI
 10175 000013C3 1F                      	POP	DS
 10176                                  ;;; 7/15/86
 10177                                  
 10178                                  ;hkn; SS override
 10179                                  	; MSDOS 6.0
 10180 000013C4 36C606[900D]00          	MOV	BYTE [SS:SCAN_FLAG],0
 10181                                  	;
 10182 000013CA 3C00                    	CMP	AL,0	    ; extended code ( AL )
 10183 000013CC 7505                    	JNZ	short noscan
 10184                                  
 10185                                  ;hkn; SS override
 10186                                  	;MOV	BYTE [SS:SCAN_FLAG],1 ; set this flag for ALT_Q key
 10187                                  	; 20/06/2023
 10188 000013CE 36FE06[900D]            	inc	byte [SS:SCAN_FLAG]
 10189                                  noscan:
 10190 000013D3 C3                      	retn
 10191                                  ;
 10192                                  ;----------------------------------------------------------------------------
 10193                                  ;
 10194                                  ;**	$STD_CON_STRING_OUTPUT - Console String Output
 10195                                  ;
 10196                                  ;
 10197                                  ;	ENTRY	(DS:DX) Point to output string '$' terminated
 10198                                  ;	EXIT	none
 10199                                  ;	USES	ALL
 10200                                  ;
 10201                                  ;----------------------------------------------------------------------------
 10202                                  ;
 10203                                  
 10204                                  _$STD_CON_STRING_OUTPUT:	;System call 9
 10205                                  
 10206 000013D4 89D6                    	mov	si,dx
 10207                                  STRING_OUT1:	
 10208 000013D6 AC                      	lodsb
 10209 000013D7 3C24                    	cmp	al,'$'
 10210 000013D9 74F8                    	je	short noscan
 10211                                  NEXT_STR1:
 10212 000013DB E88F02                  	call	OUTT
 10213 000013DE EBF6                    	jmp	short STRING_OUT1
 10214                                  
 10215                                  ;----------------------------------------------------------------------------
 10216                                  ;
 10217                                  ;**	$STD_CON_STRING_INPUT - Input Line from Console
 10218                                  ;
 10219                                  ;	$STD_CON_STRING_INPUT Fills a buffer from console input until CR
 10220                                  ;
 10221                                  ;	ENTRY	(ds:dx) = input buffer
 10222                                  ;	EXIT	none
 10223                                  ;	USES	ALL
 10224                                  ;
 10225                                  ;----------------------------------------------------------------------------
 10226                                  
 10227                                  _$STD_CON_STRING_INPUT:		;System call 10
 10228                                  
 10229 000013E0 8CD0                    	mov	ax,ss
 10230 000013E2 8EC0                    	mov	es,ax
 10231 000013E4 89D6                    	mov	si,dx
 10232 000013E6 30ED                    	xor	ch,ch
 10233 000013E8 AD                      	lodsw
 10234                                  
 10235                                  ;	(AL) = the buffer length
 10236                                  ;	(AH) = the template length
 10237                                  
 10238 000013E9 08C0                            or	al,al
 10239 000013EB 74E6                            jz	short noscan	;Buffer is 0 length!!?
 10240 000013ED 88E3                    	mov	bl,ah		;Init template counter
 10241 000013EF 88EF                            mov	bh,ch		;Init template counter
 10242                                  
 10243                                  ;	(BL) = the number of bytes in the template
 10244                                  
 10245 000013F1 38D8                            cmp	al,bl
 10246 000013F3 7605                            jbe	short NOEDIT	;If length of buffer inconsistent with contents
 10247 000013F5 80380D                          cmp	byte [bx+si],c_CR ; 0Dh
 10248 000013F8 7402                            jz	short EDITON	;If CR correctly placed EDIT is OK
 10249                                  
 10250                                  ; The number of chars in the template is >= the number of chars in buffer or
 10251                                  ; there is no CR at the end of the template.  This is an inconsistant state
 10252                                  ; of affairs.  Pretend that the template was empty:
 10253                                  ;
 10254                                  
 10255                                  NOEDIT:	
 10256 000013FA 88EB                    	mov	bl,ch		;Reset buffer
 10257                                  EDITON: 
 10258 000013FC 88C2                    	mov	dl,al
 10259 000013FE 4A                      	dec	dx		;DL is # of bytes we can put in the buffer
 10260                                  
 10261                                  ;	Top level. We begin to read a line in.
 10262                                  
 10263                                  NEWLIN: 
 10264 000013FF 36A0[F901]              	mov	al,[SS:CARPOS]
 10265 00001403 36A2[FA01]              	mov	[SS:STARTPOS],al ;Remember position in raw buffer
 10266                                  
 10267 00001407 56                      	push	si
 10268 00001408 BF[FB01]                	mov	di,INBUF ;Build the new line here
 10269 0000140B 36882E[7905]            	mov	byte [SS:INSMODE],ch ;Insert mode off
 10270 00001410 88EF                    	mov	bh,ch		;No chars from template yet
 10271 00001412 88EE                    	mov	dh,ch		;No chars to new line yet
 10272 00001414 E864FF                  	call	_$STD_CON_INPUT_NO_ECHO ;Get first char
 10273 00001417 3C0A                    	cmp	al,c_LF		; 0Ah	;Linefeed 
 10274 00001419 7503                    	jnz	short GOTCH
 10275                                  
 10276                                  ;	This is the main loop of reading in a character and processing it.
 10277                                  ;
 10278                                  ;	(BH) = the index of the next byte in the template
 10279                                  ;	(BL) = the length of the template
 10280                                  ;	(DH) = the number of bytes in the buffer
 10281                                  ;	(DL) = the length of the buffer
 10282                                  
 10283                                  GETCH:
 10284 0000141B E85DFF                  	call	_$STD_CON_INPUT_NO_ECHO
 10285                                  GOTCH:
 10286                                  ;
 10287                                  ; Brain-damaged Tim Patterson ignored ^F in case his BIOS did not flush the
 10288                                  ; input queue.
 10289                                  ;
 10290 0000141E 3C06                            cmp	al,"F"-"@"  ; CMP AL, 6  ; Ignore ^F
 10291 00001420 74F9                    	jz	short GETCH
 10292                                  
 10293                                  ;	If the leading char is the function-key lead byte
 10294                                  
 10295                                  	;cmp	al,[SS:ESCCHAR]
 10296                                  
 10297                                  	; 04/05/2019 - Retro DOS v4.0
 10298                                  
 10299                                  ;hkn; 	ESCCHAR is in TABLE seg (DOSCODE)
 10300                                  
 10301 00001422 2E3A06[1A0A]            	CMP	AL,[cs:ESCCHAR]
 10302 00001427 743B                            jz	short ESCAPE	;change reserved keyword DBM 5-7-87
 10303                                  
 10304                                  ;	Rubout and ^H are both destructive backspaces.
 10305                                  
 10306 00001429 3C7F                            cmp	al,c_DEL ; 7FH
 10307 0000142B 742E                            jz	short BACKSPJ
 10308 0000142D 3C08                            cmp	al,c_BS  ; 8
 10309 0000142F 742A                            jz	short BACKSPJ
 10310                                  
 10311                                  	; 04/05/2019 -	MSDOS 6.0, also MSDOS 6.21 has bug (bullshit) here. 
 10312                                  	;		Two NOPs -instead of a JMP short, as two bytes-
 10313                                  	;	   	after CMP and a CMP again!
 10314                                  	;		
 10315                                  	;		-It would be better if they use a 'JMP short' to 
 10316                                  	;	      	DOSCODE:5279h from DOSCODE:5271h and leave NOPs
 10317                                  	;		between them. Then, they would be able use a patch
 10318                                  	;		between 5271h and 5279h when if it will be required.
 10319                                  	;		I think Tim Patterson would not do this CMP mistake!-
 10320                                  	;	
 10321                                  	; (MSDOS.SYS, from DOSCODE:5271h to DOSCODE:5279h)
 10322                                  
 10323                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10324                                  	;
 10325                                  	; (Note: nops below might be used for patching code for Windows 3.1)
 10326                                  
 10327                                  ;DOSCODE:526D	cmp     al, 8
 10328                                  ;DOSCODE:526F	jz      short BACKSPJ
 10329                                  ;DOSCODE:5271	cmp     al, 17h
 10330                                  ;DOSCODE:5273	nop
 10331                                  ;DOSCODE:5274	nop
 10332                                  ;DOSCODE:5275	cmp     al, 15h
 10333                                  ;DOSCODE:5277	nop
 10334                                  ;DOSCODE:5278	nop
 10335                                  ;DOSCODE:5279	cmp     al, 0Dh
 10336                                  ;DOSCODE:527B	jz      short ENDLIN
 10337                                  ;DOSCODE:527D	cmp     al, 0Ah
 10338                                  ;DOSCODE:527F	jz      short PHYCRLF
 10339                                  	
 10340                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10341                                  	; DOSCODE:525Dh
 10342                                  
 10343                                  ; 16/12/2022
 10344                                  %if 0
 10345                                  	; MSDOS 6.0
 10346                                  ;	^W deletes backward once and then backs up until a letter is before the
 10347                                  ;	cursor
 10348                                  
 10349                                  	CMP     AL,"W"-"@" ; 17h
 10350                                  
 10351                                  ;	The removal of the comment characters before the jump statement will
 10352                                  ;	cause ^W to backup a word.
 10353                                  
 10354                                  ;***	JZ	short WordDel
 10355                                  	NOP
 10356                                  	NOP
 10357                                  
 10358                                  	CMP     AL,"U"-"@" ; 15h
 10359                                  
 10360                                  ;	The removal of the comment characters before the jump statement will
 10361                                  ;	cause ^U to clear a line.
 10362                                  
 10363                                  ;***	JZ	short LineDel
 10364                                  	NOP
 10365                                  	NOP
 10366                                  
 10367                                  %endif
 10368                                  
 10369                                  ;	CR terminates the line.
 10370                                  
 10371 00001431 3C0D                            cmp	al,c_CR ; 0Dh
 10372 00001433 7432                            jz	short ENDLIN
 10373                                  
 10374                                  ;	LF goes to a new line and keeps on reading.
 10375                                  
 10376 00001435 3C0A                            cmp	al,c_LF ; 0Ah
 10377 00001437 7444                    	jz	short PHYCRLF
 10378                                  
 10379                                  ;	^X (or ESC) deletes the line and starts over
 10380                                  
 10381                                  	; MSDOS 3.3
 10382                                  	;cmp	al,[ss:CANCHAR] ; 1Bh
 10383                                  	;jz	short KILNEW
 10384                                  
 10385                                  	; MSDOS 6.0 (& MSDOS 6.21)
 10386                                  
 10387                                  ;hkn; 	CANCHAR is in TABLE seg (DOSCODE), so CS override
 10388                                  
 10389 00001439 2E3A06[190A]            	cmp	al,[cs:CANCHAR] ; 1Bh
 10390 0000143E 7442                    	jz	short KILNEW
 10391                                  	
 10392                                  	;cmp	al,CANCEL ; 1Bh	; Retro DOS v3.0
 10393                                  	;jz	short KILNEW
 10394                                  
 10395                                  ; Otherwise, we save the input character.
 10396                                  
 10397                                  SAVCH:	
 10398 00001440 38D6                    	cmp	dh,dl
 10399 00001442 7319                    	jnb	short BUFFUL		; buffer is full.
 10400 00001444 AA                              stosb
 10401 00001445 FEC6                    	inc	dh                      ; increment count in buffer.
 10402 00001447 E8B702                  	call	BUFOUT			; Print control chars nicely
 10403                                  
 10404 0000144A 36803E[7905]00                  cmp	byte [SS:INSMODE], 0
 10405 00001450 75C9                    	jnz	short GETCH		; insertmode => don't advance template
 10406 00001452 38DF                            cmp	bh,bl
 10407 00001454 73C5                            jnb	short GETCH		; no more characters in template
 10408 00001456 46                              inc	si                      ; Skip to next char in template
 10409 00001457 FEC7                            inc	bh                      ; remember position in template
 10410 00001459 EBC0                            jmp	short GETCH
 10411                                  
 10412                                  BACKSPJ: 
 10413 0000145B EB38                    	jmp	short BACKSP
 10414                                  
 10415                                  BUFFUL: 
 10416 0000145D B007                    	mov	al, 7			; Bell to signal full buffer
 10417 0000145F E80B02                  	call	OUTT
 10418 00001462 EBB7                    	jmp	short GETCH
 10419                                  
 10420                                  ESCAPE: 
 10421                                  	;transfer OEMFunctionKey
 10422 00001464 E9DEF5                  	JMP	OEMFunctionKey		; let the OEM's handle the key dispatch
 10423                                  
 10424                                  ENDLIN:
 10425 00001467 AA                              stosb				; Put the CR in the buffer
 10426 00001468 E80202                  	call	OUTT                    ; Echo it
 10427 0000146B 5F                              pop	di                      ; Get start of user buffer
 10428 0000146C 8875FF                          mov	[di-1], dh		; Tell user how many bytes
 10429 0000146F FEC6                            inc	dh			; DH is length including CR
 10430                                  
 10431                                  COPYNEW:
 10432                                  	; (IBMDOS.COM, MSDOS 2.0, STRIN.ASM)
 10433                                  	;mov	bp, es
 10434                                  	;mov	bx, ds
 10435                                  	;mov	es, bx
 10436                                  	;mov	ds, bp
 10437                                  	;mov	si, INBUF
 10438                                  	;mov	cl, dh
 10439                                  	;rep	movsb
 10440                                  	;retn
 10441                                  
 10442                                  	; CPMIO.ASM (MSDOS 6.0)
 10443                                  	; (IBMDOS.COM, MSDOS 3.3, Offset 2061h) 
 10444                                  	;SAVE	<DS,ES>
 10445 00001471 1E                      	PUSH	DS
 10446 00001472 06                      	PUSH	ES
 10447                                  	;RESTORE <DS,ES>		; XCHG ES,DS
 10448 00001473 1F                      	POP	DS
 10449 00001474 07                      	POP	ES
 10450                                  
 10451                                  ;;hkn; INBUF is in DOSDATA
 10452 00001475 BE[FB01]                        MOV     SI,INBUF
 10453 00001478 88F1                            MOV     CL,DH                   ; set up count
 10454 0000147A F3A4                            REP     MOVSB                   ; Copy final line to user buffer
 10455                                  OLDBAK_RETN:
 10456 0000147C C3                              RETN
 10457                                  
 10458                                  ;	Output a CRLF to the user screen and do NOT store it into the buffer
 10459                                  
 10460                                  PHYCRLF:
 10461 0000147D E82001                  	CALL	CRLF
 10462 00001480 EB99                            JMP	short GETCH
 10463                                  
 10464                                  	; MSDOS 6.0 (& MSDOS 3.3, IBMDOS.COM, 1987)
 10465                                  
 10466                                  ; DOSCODE:52CAh (MSDOS 621, MSDOS.SYS)
 10467                                  
 10468                                  	; Note: Following routines were not used in IBMDOS.COM
 10469                                  	;	-CRTL+W, CRTL+U is not activated-
 10470                                  	;	but they were in the kernel code!?)
 10471                                  
 10472                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10473                                  	; DOSCODE:52B6h
 10474                                  
 10475                                  ;;;;;;;;
 10476                                  
 10477                                  ; 16/12/2022
 10478                                  %if 0
 10479                                  ;
 10480                                  ; Delete the previous line
 10481                                  ;
 10482                                  LineDel:
 10483                                  	OR      DH,DH
 10484                                  	JZ	short GETCH	 ; 06/12/2022
 10485                                  	Call    BackSpace
 10486                                  	JMP	short LineDel
 10487                                  
 10488                                  %endif
 10489                                  
 10490                                  ;
 10491                                  ; delete the previous word.
 10492                                  ;
 10493                                  WordDel:
 10494                                  WordLoop:
 10495                                  ;	Call    BackSpace               ; backspace the one spot
 10496                                  ;	OR      DH,DH
 10497                                  ;	JZ	short GetChj
 10498                                  ;	MOV     AL,[ES:DI-1]
 10499                                  ;	cmp     al,'0'
 10500                                  ;	jb	short GetChj
 10501                                  ;	cmp     al,'9'
 10502                                  ;	jbe	short WordLoop
 10503                                  ;	OR      AL,20h
 10504                                  ;	CMP     AL,'a'
 10505                                  ;	JB	short GetChj
 10506                                  ;	CMP     AL,'z'
 10507                                  ;	JBE	short WordLoop
 10508                                  ;GetChj: 
 10509                                  ;	JMP	GETCH
 10510                                  
 10511                                  ; 16/12/2022
 10512                                  %if 0
 10513                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10514                                  	; (Worddel is not called or jumped from anywhere!)
 10515                                  WordDel:
 10516                                  WordLoop:
 10517                                  	Call    BackSpace               ; backspace the one spot
 10518                                  	OR      DH,DH
 10519                                  	JZ	short GetChj
 10520                                  	MOV     AL,[ES:DI-1]
 10521                                  	cmp     al,'0'
 10522                                  	jb	short GetChj
 10523                                  	cmp     al,'9'
 10524                                  	jbe	short WordLoop
 10525                                  	OR      AL,20h
 10526                                  	CMP     AL,'a'
 10527                                  	JB	short GetChj
 10528                                  	CMP     AL,'z'
 10529                                  	JBE	short WordLoop
 10530                                  GetChj: 
 10531                                  	JMP	GETCH
 10532                                  
 10533                                  %endif
 10534                                  
 10535                                  ;;;;;;;;
 10536                                  
 10537                                  ; DOSCODE:52F3h (MSDOS 621, MSDOS.SYS)
 10538                                  
 10539                                  ; The user wants to throw away what he's typed in and wants to start over.
 10540                                  ; We print the backslash and then go to the next line and tab to the correct
 10541                                  ; spot to begin the buffered input.
 10542                                  
 10543                                  KILNEW:
 10544 00001482 B05C                            mov	al,'\'
 10545 00001484 E8E601                          call	OUTT            ;Print the CANCEL indicator
 10546 00001487 5E                              pop	si		;Remember start of edit buffer
 10547                                  PUTNEW:
 10548 00001488 E81501                  	call	CRLF            ;Go to next line on screen
 10549 0000148B 36A0[FA01]              	mov	al,[SS:STARTPOS]
 10550 0000148F E84F02                  	call	TAB             ;Tab over
 10551 00001492 E96AFF                          JMP     NEWLIN		;Start over again
 10552                                  
 10553                                  ;	Destructively back up one character position
 10554                                  
 10555                                  BACKSP:
 10556                                  	; 09/09/2018
 10557 00001495 E80200                  	Call    BackSpace
 10558 00001498 EB81                    	JMP     GETCH
 10559                                  
 10560                                  BackSpace:
 10561 0000149A 08F6                    	or	dh,dh
 10562 0000149C 7419                    	jz	short OLDBAK	;No chars in line, do nothing to line
 10563 0000149E E85800                  	call	BACKUP          ;Do the backup
 10564 000014A1 268A05                  	mov	al,[es:di]	;Get the deleted char
 10565 000014A4 3C20                            cmp	al,20h	; ' '
 10566 000014A6 730F                    	jnb	short OLDBAK	;Was a normal char
 10567 000014A8 3C09                            cmp	al,c_HT ; 9
 10568 000014AA 741B                    	jz	short BAKTAB	;Was a tab, fix up users display
 10569                                  ;; 9/27/86 fix for ctrl-U backspace
 10570 000014AC 3C15                    	CMP     AL,"U"-"@" ; 15h ; ctrl-U is a section symbol not ^U
 10571 000014AE 7407                    	JZ	short OLDBAK
 10572 000014B0 3C14                           	CMP     AL,"T"-"@" ; 14h ; ctrl-T is a paragraphs symbol not ^T
 10573 000014B2 7403                    	JZ	short OLDBAK
 10574                                  ;; 9/27/86 fix for ctrl-U backspace
 10575 000014B4 E84500                          call	BACKMES         ;Was a control char, zap the '^'
 10576                                  OLDBAK:
 10577 000014B7 36803E[7905]00                  cmp	byte [SS:INSMODE], 0
 10578 000014BD 75BD                    	jnz	short OLDBAK_RETN ;In insert mode, done
 10579 000014BF 08FF                    	or	bh,bh
 10580 000014C1 74B9                            jz	short OLDBAK_RETN 
 10581                                  				;Not advanced in template, stay where we are
 10582 000014C3 FECF                    	dec	bh		;Go back in template
 10583 000014C5 4E                              dec	si
 10584 000014C6 C3                      	retn
 10585                                  BAKTAB:
 10586 000014C7 57                              push	di
 10587 000014C8 4F                              dec	di		;Back up one char
 10588 000014C9 FD                              std			;Go backward
 10589 000014CA 88F1                            mov	cl,dh		;Number of chars currently in line
 10590 000014CC B020                            mov	al,20h	; ' '
 10591 000014CE 53                              push	bx
 10592 000014CF B307                            mov	bl,7		;Max
 10593 000014D1 E30E                            jcxz	FIGTAB		;At start, do nothing
 10594                                  FNDPOS:
 10595 000014D3 AE                              scasb			;Look back
 10596 000014D4 7609                    	jbe	short CHKCNT
 10597 000014D6 26807D0109              	cmp	byte [es:di+1],9
 10598 000014DB 7409                    	jz	short HAVTAB	;Found a tab
 10599 000014DD FECB                    	dec	bl		;Back one char if non tab control char
 10600                                  CHKCNT:
 10601 000014DF E2F2                            loop	FNDPOS
 10602                                  FIGTAB:		
 10603 000014E1 362A1E[FA01]            	sub	bl,[SS:STARTPOS]
 10604                                  HAVTAB:
 10605 000014E6 28F3                    	sub	bl,dh
 10606 000014E8 00D9                    	add	cl,bl
 10607 000014EA 80E107                  	and	cl,7		;CX has correct number to erase
 10608 000014ED FC                      	cld			;Back to normal
 10609 000014EE 5B                      	pop	bx
 10610 000014EF 5F                      	pop	di
 10611 000014F0 74C5                    	jz	short OLDBAK	;Nothing to erase
 10612                                  TABBAK:
 10613 000014F2 E80700                  	call	BACKMES
 10614 000014F5 E2FB                    	loop	TABBAK		;Erase correct number of chars
 10615 000014F7 EBBE                    	jmp	short OLDBAK
 10616                                  
 10617                                  BACKUP:
 10618 000014F9 FECE                            dec	dh		;Back up in line
 10619 000014FB 4F                              dec	di
 10620                                  BACKMES:
 10621 000014FC B008                            mov	al,c_BS ; 8	;Backspace
 10622 000014FE E86C01                          call	OUTT
 10623 00001501 B020                            mov	al,20h ; ' '	;Erase
 10624 00001503 E86701                          call	OUTT
 10625 00001506 B008                            mov	al,c_BS ; 8	;Backspace
 10626 00001508 E96201                  	jmp	OUTT		;Done
 10627                                  
 10628                                  ;User really wants an ESC character in his line
 10629                                  TWOESC:	
 10630 0000150B 2EA0[1A0A]              	mov	al,[cs:ESCCHAR] ; 10/06/2019
 10631 0000150F E92EFF                  	jmp	SAVCH
 10632                                  
 10633                                  ;Copy the rest of the template
 10634                                  COPYLIN:
 10635 00001512 88D9                            mov	cl,bl		;Total size of template
 10636 00001514 28F9                    	sub	cl,bh		;Minus position in template, is number to move
 10637 00001516 EB07                            jmp	short COPYEACH
 10638                                  
 10639                                  COPYSTR:
 10640 00001518 E83400                  	call	FINDOLD         ;Find the char
 10641 0000151B EB02                    	jmp	short COPYEACH  ;Copy up to it
 10642                                  
 10643                                  ;Copy one char from template to line
 10644                                  COPYONE:
 10645 0000151D B101                            mov	cl,1
 10646                                  ;Copy CX chars from template to line
 10647                                  COPYEACH:
 10648 0000151F 36C606[7905]00                  mov	byte [SS:INSMODE],0	;All copies turn off insert mode
 10649 00001525 38D6                    	cmp	dh,dl
 10650 00001527 740F                            jz	short GETCH2		;At end of line, can't do anything
 10651 00001529 38DF                            cmp	bh,bl
 10652 0000152B 740B                            jz	short GETCH2		;At end of template, can't do anything
 10653 0000152D AC                              lodsb
 10654 0000152E AA                              stosb
 10655 0000152F E8CF01                  	call	BUFOUT
 10656 00001532 FEC7                            inc	bh			;Ahead in template
 10657 00001534 FEC6                            inc	dh			;Ahead in line
 10658 00001536 E2E7                            loop	COPYEACH
 10659                                  GETCH2:
 10660 00001538 E9E0FE                          jmp	GETCH
 10661                                  
 10662                                  ;Skip one char in template
 10663                                  SKIPONE:
 10664 0000153B 38DF                    	cmp	bh,bl
 10665 0000153D 74F9                    	jz	short GETCH2		;At end of template
 10666 0000153F FEC7                    	inc	bh			;Ahead in templat
 10667 00001541 46                      	inc	si
 10668 00001542 E9D6FE                  	jmp	GETCH
 10669                                  
 10670                                  SKIPSTR:
 10671 00001545 E80700                  	call	FINDOLD                 ;Find out how far to go
 10672 00001548 01CE                            add	si,cx			;Go there
 10673 0000154A 00CF                            add	bh,cl
 10674 0000154C E9CCFE                          jmp	GETCH
 10675                                  
 10676                                  ;Get the next user char, and look ahead in template for a match
 10677                                  ;CX indicates how many chars to skip to get there on output
 10678                                  ;NOTE: WARNING: If the operation cannot be done, the return
 10679                                  ;       address is popped off and a jump to GETCH is taken.
 10680                                  ;       Make sure nothing extra on stack when this routine
 10681                                  ;       is called!!! (no PUSHes before calling it).
 10682                                  
 10683                                  FINDOLD:
 10684 0000154F E829FE                          call	_$STD_CON_INPUT_NO_ECHO
 10685                                  
 10686                                  	; STRIN.ASM (MSDOS 2.11, 19/07/2018) 
 10687                                  
 10688                                  	;CMP     AL,[SS:ESCCHAR]	
 10689                                  	;JNZ     SHORT FINDSETUP
 10690                                  
 10691                                  	; CPMIO.ASM (MSDOS 6.0, 04/05/2019 - Retro DOS v4.0)
 10692                                  
 10693                                  ;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override
 10694                                  
 10695 00001552 2E3A06[1A0A]            	CMP	AL,[CS:ESCCHAR]		; did he type a function key?
 10696 00001557 7505                    	JNZ     SHORT FINDSETUP		; no, set up for scan
 10697                                  
 10698 00001559 E81FFE                  	CALL	_$STD_CON_INPUT_NO_ECHO	; eat next char
 10699 0000155C EB1D                            JMP     SHORT NOTFND		; go try again
 10700                                  FINDSETUP:
 10701 0000155E 88D9                    	mov	cl,bl
 10702 00001560 28F9                            sub	cl,bh		;CX is number of chars to end of template
 10703 00001562 7417                    	jz	short NOTFND	;At end of template
 10704 00001564 49                              dec	cx		;Cannot point past end, limit search
 10705 00001565 7414                            jz	short NOTFND	 ;If only one char in template, forget it
 10706 00001567 06                      	push	es
 10707 00001568 1E                      	push	ds
 10708 00001569 07                      	pop	es
 10709 0000156A 57                      	push	di
 10710 0000156B 89F7                    	mov	di,si		;Template to ES:DI
 10711 0000156D 47                      	inc	di
 10712 0000156E F2AE                    	repne	scasb		;Look
 10713 00001570 5F                      	pop	di
 10714 00001571 07                      	pop	es
 10715 00001572 7507                    	jnz	short NOTFND	;Didn't find the char
 10716 00001574 F6D1                            not	cl		;Turn how far to go into how far we went
 10717 00001576 00D9                            add	cl,bl		;Add size of template
 10718 00001578 28F9                            sub	cl,bh		;Subtract current pos, result distance to skip
 10719                                  FINDOLD_RETN:
 10720 0000157A C3                      	retn
 10721                                  
 10722                                  NOTFND:
 10723 0000157B 5D                              pop	bp              ;Chuck return address
 10724 0000157C E99CFE                          jmp	GETCH
 10725                                  
 10726                                  REEDIT:
 10727 0000157F B040                    	mov	al,'@'		;Output re-edit character
 10728 00001581 E8E900                  	call	OUTT
 10729 00001584 5F                      	pop	di
 10730 00001585 57                      	push	di
 10731 00001586 06                      	push	es
 10732 00001587 1E                      	push	ds
 10733 00001588 E8E6FE                  	call	COPYNEW		;Copy current line into template
 10734 0000158B 1F                      	pop	ds
 10735 0000158C 07                      	pop	es
 10736 0000158D 5E                      	pop	si
 10737 0000158E 88F3                    	mov	bl,dh		;Size of line is new size template
 10738 00001590 E9F5FE                  	jmp	PUTNEW		;Start over again
 10739                                  
 10740                                  EXITINS:
 10741                                  ENTERINS:
 10742 00001593 36F616[7905]            	not	byte [SS:INSMODE]
 10743 00001598 E980FE                  	jmp	GETCH
 10744                                  
 10745                                  ;Put a real live ^Z in the buffer (embedded)
 10746                                  CTRLZ:
 10747 0000159B B01A                    	mov	al,"Z"-"@" ; 1Ah
 10748 0000159D E9A0FE                          jmp	SAVCH
 10749                                  
 10750                                  ;Output a CRLF
 10751                                  CRLF:
 10752 000015A0 B00D                    	mov	al,c_CR ; 0Dh 
 10753 000015A2 E8C800                  	call	OUTT
 10754 000015A5 B00A                    	mov	al,c_LF ; 0Ah
 10755 000015A7 E9C300                  	jmp	OUTT
 10756                                  
 10757                                  ;
 10758                                  ;----------------------------------------------------------------------------
 10759                                  ;
 10760                                  ;**	$RAW_CON_IO - Do Raw Console I/O
 10761                                  ;
 10762                                  ;	Input or output raw character from console, no echo
 10763                                  ;
 10764                                  ;	ENTRY	DL = -1 if input
 10765                                  ;		   =  output character if output
 10766                                  ;	EXIT	(AL) = input character if input
 10767                                  ;	USES	all
 10768                                  ;
 10769                                  ;----------------------------------------------------------------------------
 10770                                  ; 20/07/2018 - Retro DOS v3.0
 10771                                  
 10772                                  ; 04/05/2019 - Retro DOS v4.0
 10773                                  ; DOSCODE:541Ch (MSDOS 6.21, MSDOS.SYS)
 10774                                  
 10775                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10776                                  ; DOSCODE:5408h (MSDOS 5.0, MSDOS.SYS)
 10777                                  
 10778                                  _$RAW_CON_IO:			; System call 6
 10779                                  
 10780 000015AA 88D0                            MOV     AL,DL
 10781 000015AC 3CFF                            CMP     AL,-1
 10782 000015AE 7541                    	JNZ	SHORT RAWOUT ; 16/12/2022
 10783                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10784                                  	;jz	short rci1
 10785                                  	;jmp	short RAWOUT
 10786                                  	; 16/12/202
 10787                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10788                                  	;nop
 10789                                  rci1:	        
 10790                                  			; Get pointer to register save area
 10791 000015B0 36C43E[8405]                    LES     DI,[SS:USER_SP] ; 12/03/2018
 10792 000015B5 31DB                    	XOR     BX,BX
 10793                                      	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10794 000015B7 E8BD20                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10795                                          ;JC	SHORT RET17
 10796 000015BA 72BE                            jc	short FINDOLD_RETN
 10797 000015BC B401                    	MOV     AH,1
 10798 000015BE E8FB2E                          CALL	IOFUNC
 10799 000015C1 750B                            JNZ     SHORT RESFLG
 10800 000015C3 E8913B                          CALL	SPOOLINT
 10801                                          ;OR	BYTE [ES:DI+16H],40H
 10802 000015C6 26804D1640              	OR	BYTE [ES:DI+user_env.user_F],40H ; Set user's zero flag
 10803 000015CB 30C0                            XOR     AL,AL
 10804                                  RET17:
 10805 000015CD C3                              RETN
 10806                                  
 10807                                  RESFLG:
 10808                                  	;AND	BYTE [ES:DI+16H],0FFH-40H  ; 0BFh
 10809 000015CE 26806516BF              	AND	BYTE [ES:DI+user_env.user_F],0FFH-40H
 10810                                  				; Reset user's zero flag
 10811                                  ;RILP:
 10812                                  rci0:
 10813 000015D3 E8813B                       	CALL	SPOOLINT
 10814                                  ;
 10815                                  ;----------------------------------------------------------------------------
 10816                                  ;
 10817                                  ;**	$Raw_CON_INPUT - Raw Console Input
 10818                                  ;
 10819                                  ;	Input raw character from console, no echo
 10820                                  ;
 10821                                  ;	ENTRY	none
 10822                                  ;	EXIT	(al) = character
 10823                                  ;	USES	all
 10824                                  ;
 10825                                  ;----------------------------------------------------------------------------
 10826                                  ;
 10827                                  
 10828                                  ;rci0:	invoke	SPOOLINT
 10829                                  
 10830                                  	;entry	$RAW_CON_INPUT
 10831                                  
 10832                                  	; 04/05/2019 - Retro DOS v4.0
 10833                                  
 10834                                  ; DOSCODE:544Bh (MSDOS 6.21, MSDOS.SYS)
 10835                                  
 10836                                  _$RAW_CON_INPUT:		; System call 7
 10837 000015D6 53                      	push	bx
 10838 000015D7 31DB                            XOR     BX,BX
 10839                                          ;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10840 000015D9 E89B20                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10841 000015DC 5B                              pop	bx
 10842 000015DD 72EE                    	JC	SHORT RET17
 10843 000015DF B401                            MOV     AH,1
 10844 000015E1 E8D82E                          CALL	IOFUNC
 10845                                  	;JZ	SHORT RILP	; MSDOS 2.11
 10846                                  	;XOR	AH,AH
 10847                                          ;CALL	IOFUNC
 10848                                          ;RETN
 10849 000015E4 7506                    	jnz	short rci5	; MSDOS 3.3 & MSDOS 6.0
 10850 000015E6 B484                    	MOV	AH,84h
 10851 000015E8 CD2A                    	INT	int_IBM  ; int 2Ah
 10852 000015EA EBE7                    	JMP	short rci0
 10853                                  rci5:	
 10854 000015EC 30E4                            XOR     AH,AH
 10855                                          ;CALL	IOFUNC
 10856                                          ;RETN
 10857                                  	; 18/12/2022
 10858 000015EE E9CB2E                  	jmp	IOFUNC
 10859                                  
 10860                                  ;       Output the character in AL to stdout
 10861                                  ;
 10862                                  	;entry   RAWOUT
 10863                                  RAWOUT:
 10864 000015F1 53                              PUSH    BX
 10865 000015F2 BB0100                          MOV     BX,1
 10866                                  
 10867                                          ;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10868 000015F5 E87F20                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10869 000015F8 721B                            JC      SHORT RAWRET1
 10870                                  
 10871                                  	;
 10872                                  	; MSDOS 2.11
 10873                                          ;TEST	BYTE [SI+18H],080H	; output to file?
 10874                                          ;JZ	SHORT RAWNORM		; if so, do normally
 10875                                          ;PUSH	DS
 10876                                          ;PUSH	SI
 10877                                          ;LDS	SI,[SI+19H]		; output to special?
 10878                                  	;TEST	BYTE [SI+4],ISSPEC
 10879                                  	;POP	SI
 10880                                  	;
 10881                                          
 10882                                  	; MSDOS 3.3 & MSDOS 6.0
 10883                                  	;mov	bx,[si+5]
 10884 000015FA 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags] ;hkn; DS set up by get_io_sft
 10885                                   ;
 10886                                   ; If we are a network handle OR if we are not a local device then go do the
 10887                                   ; output the hard way.
 10888                                   ;	
 10889                                  	;and	bx,8080h
 10890 000015FD 81E38080                	AND	BX,sf_isnet+devid_device
 10891                                  	;cmp	bx,80h
 10892 00001601 81FB8000                	CMP	BX,devid_device
 10893 00001605 7510                    	jnz     short RAWNORM
 10894 00001607 1E                      	push    ds
 10895                                  	;lds	bx,[si+7]
 10896 00001608 C55C07                  	LDS	BX,[SI+SF_ENTRY.sf_devptr] ; output to special?
 10897                                  	;test	byte [bx+4],10h
 10898 0000160B F6470410                	TEST	BYTE [BX+SYSDEV.ATT],ISSPEC
 10899                                  	;
 10900                                  
 10901 0000160F 1F                              POP     DS
 10902 00001610 7405                            JZ      SHORT RAWNORM		; if not, do normally
 10903                                  
 10904 00001612 CD29                            INT	int_fastcon  ; int 29h	; quickly output the char
 10905                                  
 10906                                          ;JMP	SHORT RAWRET
 10907                                  ;RAWNORM:
 10908                                  ;	CALL    RAWOUT3
 10909                                  RAWRET: 
 10910 00001614 F8                      	CLC
 10911                                  RAWRET1:
 10912 00001615 5B                              POP     BX
 10913                                  RAWRET2:
 10914 00001616 C3                      	RETN
 10915                                  RAWNORM:
 10916 00001617 E80700                  	CALL    RAWOUT3
 10917 0000161A EBF8                    	jmp	short RAWRET
 10918                                  
 10919                                  ;       Output the character in AL to handle in BX
 10920                                  ;
 10921                                  ;	entry   RAWOUT2
 10922                                  
 10923                                  RAWOUT2:
 10924                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10925                                  	;JC	SHORT RET18
 10926 0000161C E85820                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10927 0000161F 72F5                    	JC	SHORT RAWRET2
 10928                                  RAWOUT3:
 10929 00001621 50                              PUSH    AX
 10930 00001622 EB0C                            JMP     SHORT RAWOSTRT
 10931                                  ROLP:
 10932 00001624 E8303B                          CALL	SPOOLINT
 10933                                  
 10934                                  	; 01/05/2019 - Retro DOS v4.0
 10935                                  
 10936                                  	; MSDOS 6.0
 10937                                  	;OR	word [ss:DOS34_FLAG],CTRL_BREAK_FLAG ; 001000000000b
 10938                                  	; 17/12/2022
 10939 00001627 36800E[1206]02          	or	byte [ss:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8) ; 02h	
 10940                                  	;or	word [ss:DOS34_FLAG],200h
 10941                                  				;AN002; set control break
 10942                                  	;invoke DSKSTATCHK
 10943 0000162D E8A43A                  	call	DSKSTATCHK	;AN002; check control break
 10944                                  RAWOSTRT:
 10945 00001630 B403                            MOV     AH,3
 10946 00001632 E8872E                          CALL    IOFUNC
 10947 00001635 74ED                            JZ      SHORT ROLP
 10948                                  
 10949                                  	; MSDOS 6.0
 10950                                  ;SR;
 10951                                  ; IOFUNC now returns ax = 0ffffh if there was an I24 on a status call and
 10952                                  ;the user failed. We do not send a char if this happens. We however return 
 10953                                  ;to the caller with carry clear because this DOS call does not return any
 10954                                  ;status. 
 10955                                  ;
 10956 00001637 40                      	inc	ax		;fail on I24 if ax = -1
 10957 00001638 58                      	POP	AX
 10958 00001639 7405                    	jz	short nosend	;yes, do not send char
 10959 0000163B B402                    	MOV	AH,2
 10960 0000163D E87C2E                  	call	IOFUNC
 10961                                  nosend:
 10962 00001640 F8                      	CLC			; Clear carry indicating successful
 10963 00001641 C3                      	retn
 10964                                  
 10965                                  	; MSDOS 3.3 & MSDOS 2.11
 10966                                  	;POP	AX
 10967                                  	;MOV	AH,2
 10968                                          ;CALL	IOFUNC
 10969                                  	;CLC			; Clear carry indicating successful
 10970                                  ;RET18:    
 10971                                  	;RETN
 10972                                  
 10973                                  ;;10/08/2018
 10974                                  ; 20/07/2018 - Retro DOS v3.0
 10975                                  ; ---------------------------------------------------------------------------
 10976                                  ; Retro DOS v2.0 (MSDOS 2.11) - OUTMES
 10977                                  ; ---------------------------------------------------------------------------
 10978                                  
 10979                                  ; This routine is called at DOS init
 10980                                  
 10981                                  ;;	;procedure OUTMES,NEAR ; String output for internal messages
 10982                                  ;;OUTMES:
 10983                                  ;;	;LODS	CS:BYTE PTR [SI]
 10984                                  ;;	CS	LODSB
 10985                                  ;;	CMP     AL,"$" ; 24h
 10986                                  ;;	JZ	SHORT RET18
 10987                                  ;;	CALL	OUTT
 10988                                  ;;	JMP     SHORT OUTMES
 10989                                  
 10990                                  ; ---------------------------------------------------------------------------
 10991                                  
 10992                                  ; 20/07/2018 - Retro DOS v3.0
 10993                                  
 10994                                  ; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 2252h
 10995                                  
 10996                                  ;
 10997                                  ;----------------------------------------------------------------------------
 10998                                  ;
 10999                                  ; Inputs:
 11000                                  ;	AX=0 save the DEVCALL request packet
 11001                                  ;	  =1 restore the DEVCALL request packet
 11002                                  ; Function:
 11003                                  ;	save or restore the DEVCALL packet
 11004                                  ; Returns:
 11005                                  ;	none
 11006                                  ;
 11007                                  ;----------------------------------------------------------------------------
 11008                                  ;
 11009                                  
 11010                                  ; 04/05/2019 - Retro DOS v4.0
 11011                                  ; DOSCODE:54B9h (MSDOS 6.21, MSDOS.SYS)
 11012                                  
 11013                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11014                                  ; DOSCODE:54A5h (MSDOS 5.0, MSDOS.SYS)
 11015                                  
 11016                                  ; 12/05/2019
 11017                                  
 11018                                  Save_Restore_Packet:
 11019 00001642 1E                      	PUSH	DS
 11020 00001643 06                      	PUSH	ES
 11021 00001644 56                      	PUSH	SI
 11022 00001645 57                      	PUSH	DI
 11023                                  
 11024                                  	; 16/12/2022
 11025                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11026                                  	; 09/09/2018
 11027 00001646 BF[6C0D]                	mov	di,FAKE_STACK_2F 
 11028 00001649 BE[5A03]                	mov	si,DEVCALL
 11029                                  	;
 11030                                  	; 21/09/2023
 11031 0000164C 09C0                    	or	ax,ax 
 11032                                  	;CMP	AX,0		; save packet
 11033 0000164E 7402                    	JZ	short save_packet ; 16/12/2022
 11034                                  	;je	short set_seg
 11035                                  
 11036                                  	; MSDOS 6.0
 11037                                  restore_packet:
 11038                                  ;	MOV	SI,OFFSET DOSDATA:Packet_Temp	;source
 11039                                  ;	MOV	DI,OFFSET DOSDATA:DEVCALL	;destination
 11040                                  	; MSDOS 3.3
 11041                                  	;mov	si,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 11042                                  	;mov	di,DEVCALL  ; 09/09/2018
 11043                                  	;
 11044                                  	;JMP	short set_seg
 11045                                  
 11046                                  	; 16/12/2022	
 11047                                  	; 09/09/2018
 11048 00001650 87F7                    	xchg	si,di  ; DI = offset DEVCALL, SI = offset FAKE_STACK_2F
 11049                                  
 11050                                  ; 16/12/2022
 11051                                  %if 0
 11052                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11053                                  	cmp	ax,0		; save packet
 11054                                  	jz	short save_packet
 11055                                  	mov	si,FAKE_STACK_2F ; 07/12/2022
 11056                                  	mov	di,DEVCALL 
 11057                                  	jmp	short set_seg
 11058                                  
 11059                                  	; MSDOS 6.0
 11060                                  save_packet:
 11061                                  ;	MOV	DI,OFFSET DOSDATA:Packet_Temp	;destination
 11062                                  ;	MOV	SI,OFFSET DOSDATA:DEVCALL	;source
 11063                                  	; 09/09/2018
 11064                                  	; MSDOS 3.3
 11065                                  	;mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 11066                                  	;mov	si,DEVCALL ; 09/09/2018
 11067                                  
 11068                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11069                                  	mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 11070                                  	mov	si,DEVCALL
 11071                                  %endif
 11072                                  
 11073                                  ; 16/12/2022
 11074                                  save_packet:
 11075                                  ;set_seg:
 11076                                  	; MSDOS 3.3
 11077                                  	;mov	ax,cs
 11078                                  
 11079                                  	; MSDOS 6.0
 11080 00001652 8CD0                    	MOV	AX,SS		; set DS,ES to DOSDATA	
 11081                                  
 11082 00001654 8ED8                    	MOV	DS,AX
 11083 00001656 8EC0                    	MOV	ES,AX
 11084 00001658 B90B00                  	MOV	CX,11		; 11 words to move
 11085 0000165B F3A5                    	REP	MOVSW
 11086                                  
 11087 0000165D 5F                      	POP	DI
 11088 0000165E 5E                      	POP	SI
 11089 0000165F 07                      	POP	ES
 11090 00001660 1F                      	POP	DS
 11091 00001661 C3                      	retn
 11092                                  
 11093                                  ;============================================================================
 11094                                  ; CPMIO2.ASM, MSDOS 6.0, 1991
 11095                                  ;============================================================================
 11096                                  ; 20/07/2018 - Retro DOS v3.0
 11097                                  ; 01/05/2019 - Retro DOS v4.0
 11098                                  
 11099                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
 11100                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
 11101                                  ;hkn;	not valid. 
 11102                                  
 11103                                  ;
 11104                                  ;----------------------------------------------------------------------------
 11105                                  ;
 11106                                  ;**	$STD_CON_INPUT - System Call 1
 11107                                  ;
 11108                                  ;	Input character from console, echo
 11109                                  ;
 11110                                  ;	ENTRY	none
 11111                                  ;	EXIT	(al) = character
 11112                                  ;	USES	ALL
 11113                                  ;
 11114                                  ;----------------------------------------------------------------------------
 11115                                  ;
 11116                                  
 11117                                  _$STD_CON_INPUT:	;System call 1
 11118                                  	
 11119 00001662 E816FD                  	CALL	_$STD_CON_INPUT_NO_ECHO
 11120 00001665 50                      	PUSH	AX
 11121 00001666 E80400                  	CALL	OUTT
 11122 00001669 58                      	POP	AX
 11123                                  CON_INPUT_RETN:	
 11124 0000166A C3                      	RETN
 11125                                  
 11126                                  ;
 11127                                  ;----------------------------------------------------------------------------
 11128                                  ;
 11129                                  ;**	$STD_CON_OUTPUT - System Call 2
 11130                                  ;
 11131                                  ;	Output character to console
 11132                                  ;
 11133                                  ;	ENTRY	(dl) = character
 11134                                  ;	EXIT	none
 11135                                  ;	USES	all
 11136                                  ;
 11137                                  ;----------------------------------------------------------------------------
 11138                                  ;
 11139                                  
 11140                                  ; DOSCODE:54E9h (MSDOS 6.21, MSDOS.SYS)
 11141                                  
 11142                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11143                                  ; DOSCODE:54D5h (MSDOS 5.0, MSDOS.SYS)
 11144                                  
 11145                                  _$STD_CON_OUTPUT:	;System call 2
 11146                                  
 11147 0000166B 88D0                    	MOV	AL,DL
 11148                                  OUTT:
 11149 0000166D 3C20                    	CMP	AL,20H ; " "
 11150 0000166F 725C                    	JB	SHORT CTRLOUT
 11151 00001671 3C7F                    	CMP	AL,c_DEL ; 7Fh
 11152 00001673 7405                    	JZ	SHORT OUTCH
 11153                                  OUTCHA:	
 11154                                  	;INC	BYTE PTR [CARPOS]
 11155 00001675 36FE06[F901]            	INC	BYTE [SS:CARPOS]
 11156                                  OUTCH:
 11157 0000167A 1E                      	PUSH	DS
 11158 0000167B 56                      	PUSH	SI
 11159                                  	;INC	BYTE PTR [CHARCO]		;invoke  statchk...
 11160                                  	;AND	BYTE PTR [CHARCO],00111111B	;AN000; every 64th char
 11161 0000167C 36FE06[0003]            	INC	BYTE [SS:CHARCO]	
 11162                                  	;AND	BYTE [SS:CHARCO],00111111B
 11163                                  	; 01/05/2019 - Retro DOS v4.0
 11164 00001681 368026[0003]3F          	and	byte [SS:CHARCO],3Fh
 11165 00001687 7505                    	JNZ	SHORT OUTSKIP
 11166                                  
 11167 00001689 50                      	PUSH	AX
 11168 0000168A E8F83A                  	CALL	STATCHK
 11169 0000168D 58                      	POP	AX
 11170                                  OUTSKIP:
 11171 0000168E E860FF                  	CALL	RAWOUT				;output the character
 11172                                  
 11173 00001691 5E                      	POP	SI
 11174 00001692 1F                      	POP	DS
 11175                                  
 11176                                  	;TEST	BYTE PTR [PFLAG],-1
 11177                                  	;retz
 11178 00001693 36F606[FE02]FF          	TEST	BYTE [SS:PFLAG],0FFh
 11179 00001699 74CF                    	JZ	SHORT CON_INPUT_RETN
 11180                                  
 11181 0000169B 53                      	PUSH	BX
 11182 0000169C 1E                      	PUSH	DS
 11183 0000169D 56                      	PUSH	SI
 11184 0000169E BB0100                  	MOV	BX,1
 11185                                  	; 20/07/2018 - Retro DOS v3.0
 11186                                  	; MSDOS 3.3
 11187                                  	; MSDOS 6.0 (CPMIO2.ASM)
 11188 000016A1 E8D31F                  	CALL	GET_IO_SFT		;hkn; GET_IO_SFT will set up DS:SI 
 11189                                  					;hkn; to sft entry
 11190 000016A4 7224                    	JC	SHORT TRIPOPJ
 11191                                  
 11192                                  	; 01/05/2019 - Retro DOS v4.0
 11193                                  
 11194                                  	;mov	bx,[si+5]
 11195 000016A6 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags]
 11196                                  	;test	bx,8000h
 11197                                  	;TEST	BX,sf_isnet	; 8000h		; output to NET?
 11198 000016A9 F6C780                  	test	bh,(sf_isnet>>8) ; 80h
 11199 000016AC 751C                    	JNZ	short TRIPOPJ 			; if so, no echo
 11200                                  	;;test	bx,80h
 11201                                  	;TEST	BX,devid_device 		; output to file?
 11202 000016AE F6C380                  	test	bl,devid_device ; 80h
 11203 000016B1 7417                    	JZ	SHORT TRIPOPJ 			; if so, no echo
 11204                                  	; 14/03/2018
 11205                                  	;call	GET_IO_FCB	 	; IBMDOS.COM, MSDOS 2.11
 11206                                  	;jc	short TRIPOPJ
 11207                                  	; MSDOS 2.11
 11208                                  	;test	byte [SI+18H], 80h
 11209                                  	;jz	short TRIPOPJ
 11210 000016B3 BB0400                  	MOV	BX,4
 11211 000016B6 E8BE1F                  	CALL	GET_IO_SFT
 11212 000016B9 720F                    	JC	SHORT TRIPOPJ
 11213                                  	;;test	word [si+5], 800h
 11214                                  	;TEST	word [SI+SF_ENTRY.sf_flags],sf_net_spool ; 800H
 11215                                  	;test	byte [si+6],8 ; 08/11/2022
 11216 000016BB F6440608                	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8) ; 8 
 11217                                  						; StdPrn redirected?
 11218                                  	;;JZ	SHORT LISSTRT2J			; No, OK to echo
 11219                                  	;jz	LISSTRT2 ; 10/08/2018 
 11220                                  	; 16/12/2022
 11221 000016BF 7503                    	jnz	short outch1
 11222 000016C1 E98700                  	jmp	LISSTRT2
 11223                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11224                                  	;jz	short LISSTRT2J
 11225                                  outch1:
 11226                                  	;MOV	BYTE [PFLAG],0			
 11227 000016C4 36C606[FE02]00          	MOV	BYTE [SS:PFLAG],0		; If a spool, NEVER echo
 11228                                  	; MSDOS 2.11
 11229                                  	;mov	bx,4
 11230                                  	;jmp	short LISSTRT2
 11231                                  	
 11232                                  TRIPOPJ:
 11233                                  	; 20/07/2018
 11234 000016CA E98100                  	JMP	TRIPOP
 11235                                  
 11236                                  	; 16/12/2022
 11237                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11238                                  ;LISSTRT2J:
 11239                                  ;	JMP	LISSTRT2
 11240                                  
 11241                                  CTRLOUT:
 11242 000016CD 3C0D                    	CMP	AL,c_CR ; 0Dh
 11243 000016CF 7420                    	JZ	SHORT ZERPOS
 11244 000016D1 3C08                    	CMP	AL,c_BS ; 8
 11245 000016D3 7424                    	JZ	SHORT BACKPOS
 11246 000016D5 3C09                    	CMP	AL,c_HT ; 9
 11247 000016D7 75A1                    	JNZ	SHORT OUTCH
 11248                                  	;MOV	AL,[CARPOS]
 11249 000016D9 36A0[F901]              	MOV	AL,[SS:CARPOS]
 11250 000016DD 0CF8                    	OR	AL,0F8H
 11251 000016DF F6D8                    	NEG	AL
 11252                                  TAB:
 11253 000016E1 51                      	PUSH	CX
 11254 000016E2 88C1                    	MOV	CL,AL
 11255 000016E4 B500                    	MOV	CH,0
 11256 000016E6 E307                    	JCXZ	POPTAB
 11257                                  TABLP:
 11258 000016E8 B020                    	MOV	AL," "
 11259 000016EA E880FF                  	CALL	OUTT
 11260 000016ED E2F9                    	LOOP	TABLP
 11261                                  POPTAB:
 11262 000016EF 59                      	POP	CX
 11263                                  
 11264 000016F0 C3                      	RETN
 11265                                  
 11266                                  ZERPOS:
 11267                                  	;MOV	BYTE PTR [CARPOS],0
 11268 000016F1 36C606[F901]00          	MOV	BYTE [SS:CARPOS],0
 11269                                  	; 10/08/2018
 11270 000016F7 EB81                    	JMP	short OUTCH ; 04/05/2019
 11271                                  	
 11272                                  	; 18/12/2022
 11273                                  ;OUTJ:	
 11274                                  	;JMP	OUTT
 11275                                  
 11276                                  BACKPOS:
 11277                                  	;DEC	BYTE PTR [CARPOS]
 11278 000016F9 36FE0E[F901]            	DEC	BYTE [SS:CARPOS]
 11279 000016FE E979FF                  	JMP	OUTCH
 11280                                  
 11281                                  BUFOUT:
 11282 00001701 3C20                    	CMP	AL," "
 11283 00001703 7315                    	JAE	SHORT OUTJ		;Normal char
 11284 00001705 3C09                    	CMP	AL,9
 11285 00001707 7411                    	JZ	SHORT OUTJ		;OUT knows how to expand tabs
 11286                                  	;DOS 3.3  7/14/86
 11287 00001709 3C15                    	CMP	AL,"U"-"@" ; 15h	; turn ^U to section symbol
 11288 0000170B 740D                    	JZ	short CTRLU
 11289 0000170D 3C14                    	CMP	AL,"T"-"@" ; 14h	; turn ^T to paragraph symbol
 11290 0000170F 7409                    	JZ	short CTRLU
 11291                                  NOT_CTRLU:
 11292                                  	;DOS 3.3  7/14/86
 11293 00001711 50                      	PUSH	AX
 11294 00001712 B05E                    	MOV	AL,"^"
 11295 00001714 E856FF                  	CALL	OUTT		;Print '^' before control chars
 11296 00001717 58                      	POP	AX
 11297 00001718 0C40                    	OR	AL,40H		;Turn it into Upper case mate
 11298                                  CTRLU:
 11299                                  	;CALL	OUTT
 11300                                  	; 18/12/2022
 11301                                  OUTJ:
 11302 0000171A E950FF                  	jmp	OUTT
 11303                                  ;BUFOUT_RETN:
 11304                                  	;RETN
 11305                                  
 11306                                  ;
 11307                                  ;----------------------------------------------------------------------------
 11308                                  ;
 11309                                  ;**	$STD_AUX_INPUT - System Call 3
 11310                                  ;
 11311                                  ;	$STD_AUX_INPUT returns a character from Aux Input
 11312                                  ;
 11313                                  ;	ENTRY	none
 11314                                  ;	EXIT	(al) = character
 11315                                  ;	USES	all
 11316                                  ;
 11317                                  ;----------------------------------------------------------------------------
 11318                                  ;
 11319                                  
 11320                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11321                                  
 11322                                  _$STD_AUX_INPUT:	;System call 3
 11323                                  
 11324 0000171D E8653A                  	CALL	STATCHK
 11325 00001720 BB0300                  	MOV	BX,3
 11326 00001723 E8511F                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 11327                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 11328                                  	;retc
 11329                                  	; 16/12/2022
 11330                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11331                                  	;JC	SHORT BUFOUT_RETN
 11332                                  	;JMP	SHORT TAISTRT
 11333                                  	; 07/12/2022
 11334 00001726 7304                    	jnc	SHORT TAISTRT
 11335 00001728 C3                      	retn	
 11336                                  
 11337                                  AUXILP:
 11338 00001729 E82B3A                  	CALL	SPOOLINT
 11339                                  TAISTRT:
 11340 0000172C B401                    	MOV	AH,1
 11341 0000172E E88B2D                  	CALL	IOFUNC
 11342 00001731 74F6                    	JZ	SHORT AUXILP
 11343 00001733 30E4                    	XOR	AH,AH
 11344                                  	; 16/12/2022
 11345                                  	;CALL	IOFUNC
 11346                                  	;RETN
 11347                                  	; 07/12/2022
 11348 00001735 E9842D                  	jmp	IOFUNC
 11349                                  
 11350                                  ;
 11351                                  ;----------------------------------------------------------------------------
 11352                                  ;
 11353                                  ;**	$STD_AUX_OUTPUT - Output character to AUX
 11354                                  ;
 11355                                  ;	ENTRY	(dl) = character
 11356                                  ;	EXIT	none
 11357                                  ;	USES	all
 11358                                  ;
 11359                                  ;----------------------------------------------------------------------------
 11360                                  ;
 11361                                  
 11362                                  _$STD_AUX_OUTPUT:	;System call 4
 11363                                  
 11364 00001738 53                      	PUSH	BX
 11365 00001739 BB0300                  	MOV	BX,3
 11366 0000173C EB04                    	JMP	SHORT SENDOUT
 11367                                  
 11368                                  ;
 11369                                  ;----------------------------------------------------------------------------
 11370                                  ;
 11371                                  ;**	$STD_PRINTER_OUTPUT - Output character to printer
 11372                                  ;
 11373                                  ;	ENTRY	(dl) = character
 11374                                  ;	EXIT	none
 11375                                  ;	USES	all
 11376                                  ;
 11377                                  ;----------------------------------------------------------------------------
 11378                                  ;
 11379                                  
 11380                                  _$STD_PRINTER_OUTPUT:	;System call 5
 11381                                  
 11382 0000173E 53                      	PUSH	BX
 11383 0000173F BB0400                  	MOV	BX,4
 11384                                  
 11385                                  SENDOUT:
 11386 00001742 88D0                    	MOV	AL,DL
 11387 00001744 50                      	PUSH	AX
 11388 00001745 E83D3A                  	CALL	STATCHK
 11389 00001748 58                      	POP	AX
 11390 00001749 1E                      	PUSH	DS
 11391 0000174A 56                      	PUSH	SI
 11392                                  LISSTRT2:
 11393 0000174B E8CEFE                  	CALL	RAWOUT2
 11394                                  TRIPOP:
 11395 0000174E 5E                      	POP	SI
 11396 0000174F 1F                      	POP	DS
 11397 00001750 5B                      	POP	BX
 11398                                  SCIS_RETN:	; 20/07/2018
 11399 00001751 C3                      	RETN
 11400                                  ;
 11401                                  ;----------------------------------------------------------------------------
 11402                                  ;
 11403                                  ;**	$STD_CON_INPUT_STATUS - System Call 11
 11404                                  ;
 11405                                  ;	Check console input status
 11406                                  ;
 11407                                  ;	ENTRY	none
 11408                                  ;	EXIT	AL = -1 character available, = 0 no character
 11409                                  ;	USES	all
 11410                                  ;
 11411                                  ;----------------------------------------------------------------------------
 11412                                  ;
 11413                                  
 11414                                  _$STD_CON_INPUT_STATUS:		;System call 11
 11415                                  
 11416 00001752 E8303A                  	CALL	STATCHK
 11417 00001755 B000                    	MOV	AL,0		; no xor!!
 11418                                  	;retz
 11419 00001757 74F8                    	JZ	SHORT SCIS_RETN ; 15/04/2018
 11420 00001759 0CFF                    	OR	AL,-1
 11421                                  ;SCIS_RETN:
 11422 0000175B C3                      	RETN
 11423                                  
 11424                                  ;
 11425                                  ;----------------------------------------------------------------------------
 11426                                  ;
 11427                                  ;**	$STD_CON_INPUT_FLUSH - System Call 12
 11428                                  ;
 11429                                  ;	Flush console input buffer and perform call in AL
 11430                                  ;
 11431                                  ;	ENTRY	(AL) = DOS function to be called after flush (1,6,7,8,10)
 11432                                  ;	EXIT	(al) = 0 iff (al) was not one of the supported fcns
 11433                                  ;		return arguments for the fcn supplied in (AL)
 11434                                  ;	USES	all
 11435                                  ;
 11436                                  ;----------------------------------------------------------------------------
 11437                                  ;
 11438                                  
 11439                                  _$STD_CON_INPUT_FLUSH:		;System call 12
 11440                                  
 11441 0000175C 50                      	PUSH	AX
 11442 0000175D 52                      	PUSH	DX
 11443 0000175E 31DB                    	XOR	BX,BX
 11444 00001760 E8141F                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 11445                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 11446 00001763 7205                    	JC	SHORT BADJFNCON
 11447 00001765 B404                    	MOV	AH,4
 11448 00001767 E8522D                  	CALL	IOFUNC
 11449                                  
 11450                                  BADJFNCON:
 11451 0000176A 5A                      	POP	DX
 11452 0000176B 58                      	POP	AX
 11453 0000176C 88C4                    	MOV	AH,AL
 11454 0000176E 3C01                    	CMP	AL,1
 11455 00001770 7413                    	JZ	SHORT REDISPJ
 11456 00001772 3C06                    	CMP	AL,6
 11457 00001774 740F                    	JZ	SHORT REDISPJ
 11458 00001776 3C07                    	CMP	AL,7
 11459 00001778 740B                    	JZ	SHORT REDISPJ
 11460 0000177A 3C08                    	CMP	AL,8
 11461 0000177C 7407                    	JZ	SHORT REDISPJ
 11462 0000177E 3C0A                    	CMP	AL,10
 11463 00001780 7403                    	JZ	SHORT REDISPJ
 11464 00001782 B000                    	MOV	AL,0
 11465 00001784 C3                      	RETN
 11466                                  
 11467                                  REDISPJ:
 11468 00001785 FA                      	CLI
 11469                                  	;transfer REDISP
 11470 00001786 E9FFEB                  	JMP	REDISP
 11471                                  
 11472                                  ;============================================================================
 11473                                  ; FCBIO.ASM, MSDOS 6.0, 1991
 11474                                  ;============================================================================
 11475                                  ; 20/07/2018 - Retro DOS v3.0
 11476                                  ; 17/05/2019 - Retro DOS v4.0
 11477                                  
 11478                                  ;**	FCBIO.ASM - Ancient 1.0 1.1 FCB system calls
 11479                                  ;
 11480                                  ;	$GET_FCB_POSITION
 11481                                  ;	$FCB_DELETE
 11482                                  ;	$GET_FCB_FILE_LENGTH
 11483                                  ;	$FCB_CLOSE
 11484                                  ;	$FCB_RENAME
 11485                                  ;	SaveFCBInfo
 11486                                  ;	ResetLRU
 11487                                  ;	SetOpenAge
 11488                                  ;	LRUFCB
 11489                                  ;	FCBRegen
 11490                                  ;	BlastSFT
 11491                                  ;	CheckFCB
 11492                                  ;	SFTFromFCB
 11493                                  ;	FCBHardErr
 11494                                  ;
 11495                                  ;	Revision history:
 11496                                  ;
 11497                                  ;		Created: ARR 4 April 1983"
 11498                                  ;			 MZ  6 June  1983 completion of functions
 11499                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 11500                                  ;					  times.  Change so successive closes work by
 11501                                  ;					  always returning OK.	Also, detect I/O to
 11502                                  ;					  already closed FCB and return EOF.
 11503                                  ;			 MZ 16 Jan   1984 More braindamage.  Need to separate info
 11504                                  ;					  out of sft into FCB for reconnection
 11505                                  ;
 11506                                  ;		A000	 version 4.00  Jan. 1988
 11507                                  
 11508                                  ;Break <$Get_FCB_Position - set random record fields to current pos>
 11509                                  ;----------------------------------------------------------------------------
 11510                                  ;
 11511                                  ;   $Get_FCB_Position - look at an FCB, retrieve the current position from the
 11512                                  ;	extent and next record field and set the random record field to point
 11513                                  ;	to that record
 11514                                  ;
 11515                                  ;   Inputs:	DS:DX point to a possible extended FCB
 11516                                  ;   Outputs:	The random record field of the FCB is set to the current record
 11517                                  ;   Registers modified: all
 11518                                  ;
 11519                                  ;----------------------------------------------------------------------------
 11520                                  ;
 11521                                  
 11522                                  _$GET_FCB_POSITION:
 11523 00001789 E8F204                  	call	GetExtended		; point to FCB
 11524 0000178C E8C204                  	call	GetExtent		; DX:AX is current record
 11525                                  	;mov	[si+21h],ax
 11526 0000178F 894421                  	MOV	[SI+SYS_FCB.RR],AX 	; drop in low order piece
 11527                                  	;mov	[si+23h],dl
 11528 00001792 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; drop in high order piece
 11529                                  	;cmp	word [si+0Eh],64
 11530 00001795 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 11531 00001799 7303                    	JAE	short GetFCBBye
 11532                                  	;mov	[si+24h],dh
 11533 0000179B 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 11534                                  GoodPath:	; 16/12/2022
 11535                                  GetFCBBye:
 11536 0000179E E9B2EE                  	jmp	FCB_RET_OK
 11537                                  
 11538                                  ;Break <$FCB_Delete - remove several files that match the input FCB>
 11539                                  ;----------------------------------------------------------------------------
 11540                                  ;
 11541                                  ;**	$FCB_Delete - Delete from FCB Template
 11542                                  ;
 11543                                  ;	given an FCB, remove all directory entries in the current
 11544                                  ;	directory that have names that match the FCB's ?  marks.
 11545                                  ;
 11546                                  ;	ENTRY	(DS:DX) = address of FCB
 11547                                  ;	EXIT	entries matching the FCB are deleted
 11548                                  ;		(al) = ff iff no entries were deleted
 11549                                  ;	USES	all
 11550                                  ;
 11551                                  ;----------------------------------------------------------------------------
 11552                                  ;
 11553                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11554                                  
 11555                                  _$FCB_DELETE:		; System call 19
 11556                                  					; OpenBuf is in DOSDATA
 11557 000017A1 BF[BE03]                	MOV	DI,OPENBUF 		; appropriate place 
 11558                                  
 11559 000017A4 E88553                  	call	TransFCB		; convert FCB to path
 11560 000017A7 7207                    	JC	short BadPath 		; signal no deletions
 11561                                  
 11562 000017A9 16                      	push	SS
 11563 000017AA 1F                      	pop	DS			; SS is DOSDATA
 11564                                  
 11565 000017AB E89D0D                  	call	DOS_DELETE		; wham
 11566                                  	;JC	short BadPath
 11567                                  	; 16/12/2022
 11568 000017AE 73EE                    	jnc 	short GoodPath
 11569                                  ;GoodPath:
 11570                                  ;	;jmp	FCB_RET_OK		; do a good return
 11571                                  ;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11572                                  ;	jmp	short GetFCBBye
 11573                                  
 11574                                  BadPath:
 11575                                  	; Error code is in AX
 11576                                  
 11577 000017B0 E9A3EE                  	jmp	FCB_RET_ERR		; let someone else signal the error
 11578                                  
 11579                                  ;Break <$Get_FCB_File_Length - return the length of a file>
 11580                                  ;----------------------------------------------------------------------------
 11581                                  ;
 11582                                  ;   $Get_FCB_File_Length - set the random record field to the length of the
 11583                                  ;	file in records (rounded up if partial).
 11584                                  ;
 11585                                  ;   Inputs:	DS:DX - point to a possible extended FCB
 11586                                  ;   Outputs:	Random record field updated to reflect the number of records
 11587                                  ;   Registers modified: all
 11588                                  ;
 11589                                  ;----------------------------------------------------------------------------
 11590                                  ;
 11591                                  
 11592                                  _$GET_FCB_FILE_LENGTH:
 11593                                  
 11594 000017B3 E8C804                  	call	GetExtended		; get real FCB pointer
 11595                                  					; DX points to Input FCB
 11596                                  
 11597                                  					; OpenBuf is in DOSDATA
 11598 000017B6 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 11599                                  
 11600 000017B9 1E                      	push	ds			; save pointer to true FCB
 11601 000017BA 56                      	push	si
 11602 000017BB E86E53                  	call	TransFCB		; Trans name DS:DX, sets SATTRIB
 11603 000017BE 5E                      	pop	si
 11604 000017BF 1F                      	pop	ds
 11605 000017C0 72EE                    	JC	short BadPath
 11606 000017C2 1E                      	push	ds			; save pointer
 11607 000017C3 56                      	push	si
 11608 000017C4 16                      	push	ss		
 11609 000017C5 1F                      	pop	ds
 11610 000017C6 E89211                  	call	GET_FILE_INFO		; grab the info
 11611 000017C9 5E                      	pop	si			; get pointer back
 11612 000017CA 1F                      	pop	ds
 11613 000017CB 72E3                    	JC	short BadPath 		; invalid something
 11614 000017CD 89DA                    	MOV	DX,BX			; get high order size
 11615 000017CF 89F8                    	MOV	AX,DI			; get low order size
 11616                                  	;mov	bx,[si+0Eh]
 11617 000017D1 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 11618 000017D4 09DB                    	OR	BX,BX			; empty record => 0 size for file
 11619 000017D6 7503                    	JNZ	short GetSize 		; not empty
 11620 000017D8 BB8000                  	MOV	BX,128
 11621                                  GetSize:
 11622 000017DB 89C7                    	MOV	DI,AX			; save low order word
 11623 000017DD 89D0                    	MOV	AX,DX			; move high order for divide
 11624 000017DF 31D2                    	XOR	DX,DX			; clear out high
 11625 000017E1 F7F3                    	DIV	BX			; wham
 11626 000017E3 50                      	PUSH	AX			; save dividend
 11627 000017E4 89F8                    	MOV	AX,DI			; get low order piece
 11628 000017E6 F7F3                    	DIV	BX			; wham
 11629 000017E8 89D1                    	MOV	CX,DX			; save remainder
 11630 000017EA 5A                      	POP	DX			; get high order dividend
 11631 000017EB E306                    	JCXZ	LengthStore		; no roundup
 11632 000017ED 83C001                  	ADD	AX,1
 11633 000017F0 83D200                  	ADC	DX,0			; 32-bit increment
 11634                                  LengthStore:
 11635                                  	;mov	[si+21h],ax
 11636 000017F3 894421                  	MOV	[SI+SYS_FCB.RR],AX	; store low order
 11637                                  	;mov	[si+23h],dl
 11638 000017F6 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; store high order
 11639 000017F9 08F6                    	OR	DH,DH
 11640 000017FB 74A1                    	JZ	short GoodPath		; not storing insignificant zero
 11641                                  	;mov	[si+24h],dh
 11642 000017FD 887424                  	MOV	[SI+SYS_FCB.RR+3],DH	; save that high piece
 11643                                  	; 16/12/2022
 11644                                  GoodRet:
 11645                                  	;jmp	FCB_RET_OK
 11646 00001800 EB9C                    	jmp	short GoodPath
 11647                                  
 11648                                  ;Break <$FCB_Close - close a file>
 11649                                  ;----------------------------------------------------------------------------
 11650                                  ;
 11651                                  ;   $FCB_Close - given an FCB, look up the SFN and close it.  Do not free it
 11652                                  ;	as the FCB may be used for further I/O
 11653                                  ;
 11654                                  ;   Inputs:	DS:DX point to FCB
 11655                                  ;   Outputs:	AL = FF if file was not found on disk
 11656                                  ;   Registers modified: all
 11657                                  ;
 11658                                  ;----------------------------------------------------------------------------
 11659                                  ;
 11660                                  
 11661                                  _$FCB_CLOSE:		; System call 16
 11662                                  
 11663 00001802 30C0                    	XOR	AL,AL			; default search attributes
 11664 00001804 E87704                  	call	GetExtended		; DS:SI point to real FCB
 11665 00001807 7403                    	JZ	short NoAttr		; not extended
 11666 00001809 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 11667                                  NoAttr:
 11668                                  					; SS override
 11669 0000180C 36A2[6B05]              	MOV	[SS:ATTRIB],AL		; stash away found attributes
 11670 00001810 E8D903                  	call	SFTFromFCB
 11671 00001813 72EB                    	JC	short GoodRet 		; MZ 16 Jan Assume death
 11672                                  
 11673                                  	; If the sharer is present, then the SFT is not regenable. Thus, 
 11674                                  	; there is no need to set the SFT's attribute.
 11675                                  
 11676                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 11677                                  	;;; done
 11678                                  
 11679                                  	;mov	al,[es:di+4]
 11680 00001815 268A4504                	MOV	AL,[ES:DI+SF_ENTRY.sf_attr]
 11681 00001819 30E4                    	XOR	AH,AH
 11682 0000181B 50                      	PUSH	AX
 11683                                  
 11684                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 11685                                  	;;; done
 11686                                  
 11687 0000181C E8395B                  	call	CheckShare
 11688 0000181F 7508                    	JNZ	short NoStash
 11689 00001821 36A0[6B05]              	MOV	AL,[SS:ATTRIB]
 11690                                  	;mov	[es:di+4],al
 11691 00001825 26884504                	MOV	[ES:DI+SF_ENTRY.sf_attr],AL ; attempted attribute for close
 11692                                  NoStash:
 11693                                  	;mov	ax,[si+14h]
 11694 00001829 8B4414                  	MOV	AX,[SI+SYS_FCB.FDATE] ; move in the time and date
 11695                                  	;mov	[es:di+0Fh],ax
 11696 0000182C 2689450F                	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 11697                                  	;mov	ax,[si+16h]
 11698 00001830 8B4416                  	MOV	AX,[SI+SYS_FCB.FTIME]
 11699                                  	;mov	[es:di+0Dh],ax
 11700 00001833 2689450D                	MOV	[ES:DI+SF_ENTRY.sf_time],AX
 11701                                  	;mov	ax,[si+10h]
 11702 00001837 8B4410                  	MOV	AX,[SI+SYS_FCB.FILSIZ]
 11703                                  	;mov	[es:di+11h],ax
 11704 0000183A 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 11705                                  	;mov	ax,[si+12h]
 11706 0000183E 8B4412                  	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 11707                                  	;mov	[es:di+13h],ax
 11708 00001841 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 11709                                  	;or	word [es:di+5],4000h
 11710                                  	; 17/12/2022
 11711 00001845 26804D0640              	or	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8) ; 40h
 11712                                  	;OR	word [ES:DI+SF_ENTRY.sf_flags],sf_close_nodate
 11713 0000184A 16                      	push	ss
 11714 0000184B 1F                      	pop	ds
 11715 0000184C E80517                  	call	DOS_CLOSE	; wham
 11716 0000184F C43E[9E05]              	LES	DI,[THISSFT]
 11717                                  
 11718                                  	;;; 9/8/86 F.C. restore SFT attribute
 11719 00001853 59                      	POP	CX
 11720                                  	;mov	[es:di+4],cl
 11721 00001854 26884D04                	MOV	[ES:DI+SF_ENTRY.sf_attr],CL
 11722                                  	;;; 9/8/86 F.C. restore SFT attribute
 11723                                  
 11724 00001858 9C                      	PUSHF
 11725                                  	;test	word [es:di],0FFFFh
 11726                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],0
 11727                                  				; zero ref count gets blasted
 11728 00001859 26833D00                	cmp	word [ES:DI],0
 11729 0000185D 7507                    	jnz     short CloseOK
 11730 0000185F 50                      	PUSH	AX
 11731 00001860 B04D                    	MOV	AL,'M'
 11732 00001862 E8FC02                  	call	BlastSFT
 11733 00001865 58                      	POP	AX
 11734                                  CloseOK:
 11735 00001866 9D                      	POPF
 11736 00001867 7397                    	JNC	short GoodRet
 11737                                  	;cmp	al,6
 11738 00001869 3C06                    	CMP	AL,error_invalid_handle
 11739 0000186B 7493                    	JZ	short GoodRet
 11740                                  	;mov	al,2
 11741 0000186D B002                    	MOV	AL,error_file_not_found
 11742                                  fren90:
 11743                                  	; 16/12/2022
 11744                                  fcb_close_err:
 11745 0000186F E9E4ED                  	jmp	FCB_RET_ERR
 11746                                  
 11747                                  ;
 11748                                  ;----------------------------------------------------------------------------
 11749                                  ;
 11750                                  ;**	$FCB_Rename - Rename a File
 11751                                  ;
 11752                                  ;	$FCB_Rename - rename a file in place within a directory. Renames
 11753                                  ;	multiple files copying from the meta characters.
 11754                                  ;
 11755                                  ;	ENTRY	DS:DX point to an FCB. The normal name field is the source
 11756                                  ;		    name of the files to be renamed. Starting at offset 11h
 11757                                  ;		    in the FCB is the destination name.
 11758                                  ;	EXIT	AL = 0 -> no error occurred and all files were renamed
 11759                                  ;		AL = FF -> some files may have been renamed but:
 11760                                  ;			rename to existing file or source file not found
 11761                                  ;	USES	ALL
 11762                                  ;
 11763                                  ;----------------------------------------------------------------------------
 11764                                  ;
 11765                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11766                                  
 11767                                  _$FCB_RENAME:		; System call 23
 11768                                  
 11769 00001872 E80904                  	call	GetExtended		; get pointer to real FCB
 11770 00001875 52                      	push	dx
 11771 00001876 8A04                    	MOV	AL,[SI] 		; get drive byte
 11772 00001878 83C610                  	ADD	SI,10h			; point to destination
 11773                                  
 11774                                  					; RenBuf is in DOSDATA
 11775 0000187B BF[3E04]                	MOV	DI,RENBUF		; point to destination buffer
 11776 0000187E FF34                    	push	word [SI]
 11777 00001880 1E                      	push	ds
 11778 00001881 57                      	push	di			; save source pointer for TransFCB
 11779 00001882 8804                    	MOV	[SI],AL			; drop in real drive
 11780 00001884 89F2                    	MOV	DX,SI			; let TransFCB know where the FCB is
 11781 00001886 E8A352                  	call	TransFCB		; munch this pathname
 11782 00001889 5E                      	pop	si
 11783 0000188A 1F                      	pop	ds	
 11784 0000188B 8F04                    	pop	WORD [SI]		; get path back
 11785 0000188D 5A                      	pop	dx			; Original FCB pointer
 11786 0000188E 72DF                    	JC	short fren90		; bad path -> error
 11787                                  
 11788                                  					; SS override for WFP_Start & Ren_WFP
 11789 00001890 368B36[B205]            	MOV	SI,[ss:WFP_START]	; get pointer
 11790 00001895 368936[B405]            	MOV	[ss:REN_WFP],SI		; stash it
 11791                                  
 11792                                  					; OpenBuf is in DOSDATA
 11793 0000189A BF[BE03]                	MOV	DI,OPENBUF		; appropriate spot
 11794 0000189D E88C52                  	call	TransFCB		; wham
 11795                                  					; NOTE that this call is pointing
 11796                                  					;  back to the ORIGINAL FCB so
 11797                                  					;  SATTRIB gets set correctly
 11798 000018A0 72CD                    	JC	short fren90		; error
 11799 000018A2 E8840E                  	call	DOS_RENAME
 11800 000018A5 72C8                    	JC	short fren90
 11801                                  	; 16/12/2022
 11802 000018A7 E9A9ED                  	jmp	FCB_RET_OK
 11803                                  	
 11804                                  ;	Error -
 11805                                  ;
 11806                                  ;	(al) = error code
 11807                                  
 11808                                  	; 16/12/2022
 11809                                  ;fren90:	
 11810                                  ;	;jmp	FCB_RET_ERR
 11811                                  ;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11812                                  ;	jmp	short fcb_close_err
 11813                                  
 11814                                  ;Break <Misbehavior fixers>
 11815                                  ;
 11816                                  ;   FCBs suffer from several problems. First, they are maintained in the
 11817                                  ;   user's space so he may move them at will. Second, they have a small
 11818                                  ;   reserved area that may be used for system information. Third, there was
 11819                                  ;   never any "rules for behavior" for FCBs; there was no protocol for their
 11820                                  ;   usage.
 11821                                  ;
 11822                                  ;   This results in the following misbehavior:
 11823                                  ;
 11824                                  ;	infinite opens of the same file:
 11825                                  ;
 11826                                  ;	While (TRUE) {			While (TRUE) {
 11827                                  ;	    FCBOpen (FCB);		    FCBOpen (FCB);
 11828                                  ;	    Read (FCB); 		    Write (FCB);
 11829                                  ;	    }				    }
 11830                                  ;
 11831                                  ;	infinite opens of different files:
 11832                                  ;
 11833                                  ;	While (TRUE) {			While (TRUE) {
 11834                                  ;	    FCBOpen (FCB[i++]); 	    FCBOpen (FCB[i++]);
 11835                                  ;	    Read (FCB); 		    Write (FCB);
 11836                                  ;	    }				    }
 11837                                  ;
 11838                                  ;	multiple closes of the same file:
 11839                                  ;
 11840                                  ;	FCBOpen (FCB);
 11841                                  ;	while (TRUE)
 11842                                  ;	    FCBClose (FCB);
 11843                                  ;
 11844                                  ;	I/O after closing file:
 11845                                  ;
 11846                                  ;	FCBOpen (FCB);
 11847                                  ;	while (TRUE) {
 11848                                  ;	    FCBWrite (FCB);
 11849                                  ;	    FCBClose (FCB);
 11850                                  ;	    }
 11851                                  ;
 11852                                  ;   The following is am implementation of a methodology for emulating the
 11853                                  ;   above with the exception of I/O after close. We are NOT attempting to
 11854                                  ;   resolve that particular misbehavior. We will enforce correct behaviour in
 11855                                  ;   FCBs when they refer to a network file or when there is file sharing on
 11856                                  ;   the local machine.
 11857                                  ;
 11858                                  ;   The reserved fields of the FCB (10 bytes worth) is divided up into various
 11859                                  ;   structures depending on the file itself and the state of operations of the
 11860                                  ;   OS. The information contained in this reserved field is enough to
 11861                                  ;   regenerate the SFT for the local non-shared file. It is assumed that this
 11862                                  ;   regeneration procedure may be expensive. The SFT for the FCB is
 11863                                  ;   maintained in a LRU cache as the ONLY performance inprovement.
 11864                                  ;
 11865                                  ;   No regeneration of SFTs is attempted for network FCBs.
 11866                                  ;
 11867                                  ;   To regenerate the SFT for a local FCB, it is necessary to determine if the
 11868                                  ;   file sharer is working. If the file sharer is present then the SFT is not
 11869                                  ;   regenerated.
 11870                                  ;
 11871                                  ;   Finally, if there is no local sharing, the full name of the file is no
 11872                                  ;   longer available. We can make up for this by using the following
 11873                                  ;   information:
 11874                                  ;
 11875                                  ;	The Drive number (from the DPB).
 11876                                  ;	The physical sector of the directory that contains the entry.
 11877                                  ;	The relative position of the entry in the sector.
 11878                                  ;	The first cluster field.
 11879                                  ;	The last used SFT.
 11880                                  ;      OR In the case of a device FCB
 11881                                  ;	The low 6 bits of sf_flags (indicating device type)
 11882                                  ;	The pointer to the device header
 11883                                  ;
 11884                                  ;   We read in the particular directory sector and examine the indicated
 11885                                  ;   directory entry. If it matches, then we are kosher; otherwise, we fail.
 11886                                  ;
 11887                                  ;   Some key items need to be remembered:
 11888                                  ;
 11889                                  ;	Even though we are caching SFTs, they may contain useful sharing
 11890                                  ;	information. We enforce good behavior on the FCBs.
 11891                                  ;
 11892                                  ;	Network support must not treat FCBs as impacting the ref counts on
 11893                                  ;	open VCs. The VCs may be closed only at process termination.
 11894                                  ;
 11895                                  ;	If this is not an installed version of the DOS, file sharing will
 11896                                  ;	always be present.
 11897                                  ;
 11898                                  ;	We MUST always initialize lstclus to = firclus when regenerating a
 11899                                  ;	file. Otherwise we start allocating clusters up the wazoo.
 11900                                  ;
 11901                                  ;	Always initialize, during regeneration, the mode field to both isFCB
 11902                                  ;	and open_for_both. This is so the FCB code in the sharer can find the
 11903                                  ;	proper OI record.
 11904                                  ;
 11905                                  ;   The test bits are:
 11906                                  ;
 11907                                  ;	00 -> local file
 11908                                  ;	40 -> sharing local
 11909                                  ;	80 -> network
 11910                                  ;	C0 -> local device
 11911                                  
 11912                                  ;Break	<SaveFCBInfo - store pertinent information from an SFT into the FCB>
 11913                                  ;----------------------------------------------------------------------------
 11914                                  ;
 11915                                  ;   SaveFCBInfo - given an FCB and its associated SFT, copy the relevant
 11916                                  ;	pieces of information into the FCB to allow for subsequent
 11917                                  ;	regeneration. Poke LRU also.
 11918                                  ;
 11919                                  ;   Inputs:	ThisSFT points to a complete SFT.
 11920                                  ;		DS:SI point to the FCB (not an extended one)
 11921                                  ;   Outputs:	The relevant reserved fields in the FCB are filled in.
 11922                                  ;		DS:SI preserved
 11923                                  ;		ES:DI point to sft
 11924                                  ;   Registers modified: All
 11925                                  ;
 11926                                  ;
 11927                                  ;----------------------------------------------------------------------------
 11928                                  ;
 11929                                  
 11930                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11931                                  
 11932                                  SaveFCBInfo:
 11933                                  
 11934 000018AA 36C43E[9E05]            	LES	DI,[SS:THISSFT]		; SS override
 11935 000018AF E8B4F9                  	call	IsSFTNet
 11936 000018B2 740B                    	JZ	short SaveLocal		; if not network then save local info
 11937                                  ;
 11938                                  ;----- In net support -----
 11939                                  ;
 11940                                  	; 17/05/2019 - Retro DOS v4.0
 11941                                  
 11942                                  	; MSDOS 3.3
 11943                                  	;;mov	ax,[es:di+1Dh]
 11944                                  	;mov	ax,[es:di+SF_ENTRY.sf_dirsec]
 11945                                  	;;mov	[si+1Ah],ax
 11946                                  	;mov	[si+fcb_net_handle],ax
 11947                                  	;push	es
 11948                                  	;push	di
 11949                                  	;;les	di,[es:di+19h]
 11950                                  	;LES	DI,[ES:DI+sf_netid]
 11951                                  	;;mov	[si+1Ch],di
 11952                                  	;MOV	[SI+fcb_netID],DI	; save net ID
 11953                                  	;;mov 	[si+1Eh],es
 11954                                  	;MOV	[SI+fcb_netID+2],ES
 11955                                  	;pop	di
 11956                                  	;pop	es
 11957                                  
 11958                                  	; MSDOS 6.0
 11959                                  	;mov	ax,[es:di+0Bh]
 11960 000018B4 268B450B                	MOV	AX,[ES:DI+sf_serial_ID] ;AN000;;IFS. save IFS ID
 11961                                  	;mov	[si+1Ch],ax
 11962 000018B8 89441C                  	MOV	[SI+fcb_netID],ax	;AN000;;IFS.
 11963                                  	
 11964                                  	;mov	bl,80h
 11965 000018BB B380                    	MOV	BL,FCBNETWORK
 11966                                  ;
 11967                                  ;----- END In net support -----
 11968                                  ;
 11969 000018BD EB65                    	jmp	SHORT SaveSFN
 11970                                  
 11971                                  SaveLocal:
 11972                                  	;IF	Installed
 11973 000018BF E8965A                  	call	CheckShare
 11974                                  	;JZ	short SaveNoShare	; no sharer
 11975                                  	;JMP	short SaveShare		; sharer present
 11976                                  	; 16/12/2022
 11977                                  	; 28/07/2019
 11978 000018C2 755B                    	jnz	short SaveShare
 11979                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11980                                  	;JZ	short SaveNoShare	; no sharer
 11981                                  	;JMP	short SaveShare		; sharer present
 11982                                  
 11983                                  SaveNoShare:
 11984                                  	;;test 	word [es:di+5],80h
 11985                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 11986 000018C4 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 80h	
 11987 000018C9 7542                    	JNZ	short SaveNoShareDev	; Device
 11988                                  
 11989                                  	; Save no sharing local file information
 11990                                  
 11991                                  	;;mov	ax,[es:di+1Dh]  ; MSDOS 3.3
 11992                                  	;mov	ax,[es:di+1Bh]  ; MSDOS 6.0
 11993 000018CB 268B451B                	MOV	AX,[ES:DI+SF_ENTRY.sf_dirsec] ; get directory sector F.C.
 11994                                  	;mov	[si+1Dh],ax
 11995 000018CF 89441D                  	MOV	[SI+fcb_nsl_dirsec],AX
 11996                                  
 11997                                  	; MSDOS 6.0
 11998                                  
 11999                                  	;SR; Store high byte of directory sector
 12000                                  	;mov	ax,[es:di+1Dh]
 12001 000018D2 268B451D                	mov	ax,[es:di+SF_ENTRY.sf_dirsec+2] ; get high word
 12002                                  	
 12003                                  	; SR;
 12004                                  	; We have to store the read-only and archive attributes of the file.
 12005                                  	; We extract it from the SFT and store it in the top two bits of the 
 12006                                  	; sector number ( sector number == 22 bits only )
 12007                                  
 12008                                  	;mov	bl,[es:di+4]
 12009 000018D6 268A5D04                	mov	bl,[es:di+SF_ENTRY.sf_attr]
 12010 000018DA 88DF                    	mov	bh,bl
 12011 000018DC D0CB                    	ror	bl,1
 12012 000018DE D0E7                    	shl	bh,1
 12013 000018E0 08FB                    	or	bl,bh
 12014 000018E2 80E3C0                  	and	bl,0C0h
 12015 000018E5 08D8                    	or	al,bl
 12016                                  	;mov	[si+18h],al ; 08/11/2022
 12017 000018E7 884418                  	mov	[si+fcb_sfn],al	; sector number = 22 bits
 12018                                  
 12019                                  	; MSDOS 6.0 (& MSDOS 3.3)
 12020                                  	;mov	al,[es:di+1Fh]
 12021 000018EA 268A451F                	MOV	AL,[ES:DI+SF_ENTRY.sf_dirpos] ; location in sector
 12022                                  	;mov	[si+1Fh],al
 12023 000018EE 88441F                  	MOV	[SI+fcb_nsl_dirpos],AL
 12024                                  	;mov	ax,[es:di+0Bh]
 12025 000018F1 268B450B                	MOV	AX,[ES:DI+SF_ENTRY.sf_firclus] ; first cluster
 12026                                  	;mov	[si+1Bh],ax
 12027 000018F5 89441B                  	MOV	[SI+fcb_nsl_firclus],AX
 12028 000018F8 B300                    	MOV	BL,0
 12029                                  
 12030                                  	; Create the bits field from the dirty/device bits of the flags word 
 12031                                  	; and the mode byte
 12032                                  
 12033                                  SetFCBBits:
 12034                                  	;mov	ax,[es:di+5]
 12035 000018FA 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 12036 000018FE 24C0                    	AND	AL,0C0h 		; mask off drive bits
 12037                                  	;or	al,[es:di+2]
 12038 00001900 260A4502                	OR	AL,[ES:DI+SF_ENTRY.sf_mode] ; stick in open mode
 12039                                  	;mov	[si+1Ah], al
 12040 00001904 88441A                  	MOV	[SI+fcb_nsl_bits],AL	; save dirty info
 12041                                  
 12042                                  	; MSDOS 6.0
 12043                                  	
 12044                                  	; SR;
 12045                                  	; Check if we came here for local file or device. If for local file, 
 12046                                  	; skip setting of SFT index
 12047                                  	
 12048 00001907 08DB                    	or	bl,bl
 12049 00001909 742A                    	jz	short SaveNoSFN		; do not save SFN if local file
 12050                                  
 12051 0000190B EB17                    	JMP	short SaveSFN 		; go and save SFN
 12052                                  
 12053                                  	; Save no sharing local device information
 12054                                  
 12055                                  SaveNoShareDev:
 12056                                  	;mov	ax,[es:di+7]
 12057 0000190D 268B4507                	MOV	AX,[ES:DI+SF_ENTRY.sf_devptr]
 12058                                  	;mov	[si+1Ah],ax
 12059 00001911 89441A                  	MOV	[SI+fcb_nsld_drvptr],AX
 12060                                  	;mov	ax,[es:di+9]
 12061 00001914 268B4509                	MOV	AX,[ES:DI+SF_ENTRY.sf_devptr+2]
 12062 00001918 89441C                  	MOV	[SI+fcb_nsld_drvptr+2],AX
 12063                                  	;mov	bl,40h
 12064 0000191B B340                    	MOV	BL,FCBDEVICE
 12065                                  	; 28/12/2022
 12066 0000191D EBDB                    	JMP	short SetFCBBits	; go and save SFN
 12067                                  
 12068                                  SaveShare:
 12069                                  	;ENDIF
 12070                                  
 12071                                  ;----- In share support -----
 12072                                  
 12073                                  	;call	far [ss:ShSave]
 12074 0000191F 36FF1E[B800]            	Call	far [ss:JShare+(10*4)] ; 10 = ShSave ; SS Override
 12075                                  
 12076                                  ;----- end in share support -----
 12077                                  
 12078                                  	; 17/05/2019
 12079                                  
 12080                                  SaveSFN:
 12081                                  	;lea	ax,[di-6]
 12082 00001924 8D45FA                  	LEA	AX,[DI-SFT.SFTable]
 12083                                  	
 12084                                  	; Adjust for offset to table.
 12085                                  	
 12086 00001927 362B06[4000]            	SUB	AX,[SS:SFTFCB]		; SS override for SftFCB
 12087                                  
 12088 0000192C 53                      	push	bx			;bx = FCB type (net/Share or local)
 12089                                  	;;mov	bl,53 ; MSDOS 3.3
 12090                                  	;mov	bl,59 ; MSDOS 6.0
 12091 0000192D B33B                    	MOV	BL,SF_ENTRY.size
 12092 0000192F F6F3                    	DIV	BL
 12093                                  	;mov	[si+18h],al
 12094 00001931 884418                  	MOV	[SI+fcb_sfn],AL		; last used SFN
 12095 00001934 5B                      	pop	bx			;restore bx
 12096                                  
 12097                                  SaveNoSFN:
 12098                                  	;mov	ax,[es:di+5]
 12099 00001935 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 12100 00001939 243F                    	AND	AL,3Fh			; get real drive
 12101 0000193B 08D8                    	OR	AL,BL
 12102                                  	;mov	[si+19h],al
 12103 0000193D 884419                  	MOV	[SI+fcb_l_drive],AL
 12104                                  
 12105 00001940 36A1[1000]              	MOV	AX,[SS:FCBLRU]		; get lru count
 12106 00001944 40                      	INC	AX
 12107                                  	;mov	[es:di+15h],ax
 12108 00001945 26894515                	MOV	[ES:DI+sf_LRU],AX
 12109 00001949 7506                    	JNZ	short SimpleStuff
 12110                                  	
 12111                                  	; lru flag overflowed. Run through all FCB sfts and adjust:  
 12112                                  	; LRU < 8000H get set to 0. Others -= 8000h. This LRU = 8000h
 12113                                  	
 12114                                  	;mov	bx,15h
 12115 0000194B BB1500                  	MOV	BX,SF_ENTRY.sf_position
 12116 0000194E E80500                  	call	ResetLRU
 12117                                  
 12118                                  	; Set new LRU to AX
 12119                                  SimpleStuff:
 12120 00001951 36A3[1000]              	MOV	[SS:FCBLRU],AX
 12121 00001955 C3                      	retn
 12122                                  
 12123                                  ;Break	<ResetLRU - reset overflowed lru counts>
 12124                                  ;----------------------------------------------------------------------------
 12125                                  ;
 12126                                  ;   ResetLRU - during lru updates, we may wrap at 64K. We must walk the
 12127                                  ;   entire set of SFTs and subtract 8000h from their lru counts and truncate
 12128                                  ;   at 0.
 12129                                  ;
 12130                                  ;   Inputs:	BX is offset into SFT field where lru firld is kept
 12131                                  ;		ES:DI point to SFT currently being updated
 12132                                  ;   Outputs:	All FCB SFTs have their lru fields truncated
 12133                                  ;		AX has 8000h
 12134                                  ;   Registers modified: none
 12135                                  ;
 12136                                  ;----------------------------------------------------------------------------
 12137                                  ;
 12138                                  
 12139                                  	; 17/05/2019 - Retro DOS v4.0
 12140                                  ResetLRU:
 12141                                  	; ResetLRU is only called from fcbio.asm. So SS can be assumed to be 
 12142                                  	; DOSDATA
 12143                                  
 12144 00001956 B80080                  	MOV	AX,8000h
 12145 00001959 06                      	push	es
 12146 0000195A 57                      	push	di
 12147                                  	;LES	DI,[CS:SFTFCB]		; get pointer to head
 12148 0000195B 36C43E[4000]            	LES	DI,[SS:SFTFCB] ; MSDOS 6.0
 12149                                  	;mov	cx,[es:di+4]
 12150 00001960 268B4D04                	MOV	CX,[ES:DI+SFT.SFCount]
 12151                                  	;lea	di,[di+6]
 12152 00001964 8D7D06                  	LEA	DI,[DI+SFT.SFTable] 	; point at table
 12153                                  ovScan:
 12154 00001967 262901                  	SUB	[ES:DI+BX],AX		; decrement lru count
 12155 0000196A 7703                    	JA	short ovLoop
 12156 0000196C 268901                  	MOV	[ES:DI+BX],AX		; truncate at 0
 12157                                  ovLoop:
 12158                                  	;;add	di,53	; MSDOS 3.3
 12159                                  	;add	di,59	; MSDOS 6.0	
 12160 0000196F 83C73B                  	ADD	DI,SF_ENTRY.size	; advance to next
 12161 00001972 E2F3                    	LOOP	ovScan
 12162 00001974 5F                      	pop	di
 12163 00001975 07                      	pop	es
 12164 00001976 268901                  	MOV	[ES:DI+BX],AX
 12165 00001979 C3                      	retn
 12166                                  
 12167                                  ;IF  0  ; We dont need this routine any more.
 12168                                  ;
 12169                                  ;Break	<SetOpenAge - update the open age of a SFT>
 12170                                  ;----------------------------------------------------------------------------
 12171                                  ;
 12172                                  ;   SetOpenAge - In order to maintain the first N open files in the FCB cache,
 12173                                  ;   we keep the 'open age' or an LRU count based on opens. We update the
 12174                                  ;   count here and fill in the appropriate field.
 12175                                  ;
 12176                                  ;   Inputs:	ES:DI point to SFT
 12177                                  ;   Outputs:	ES:DI has the open age field filled in.
 12178                                  ;		If open age has wraparound, we will have subtracted 8000h
 12179                                  ;		    from all open ages.
 12180                                  ;   Registers modified: AX
 12181                                  ;
 12182                                  ;----------------------------------------------------------------------------
 12183                                  ;
 12184                                  ;SetOpenAge:
 12185                                  ;	; 20/07/2018 - Retro DOS v3.0
 12186                                  ;	; MSDOS 3.3 - IBMDOS.COM, Offset 2597h 
 12187                                  ;	; (& MSDOS 6.0, FCBIO.ASM)
 12188                                  ;
 12189                                  ;	; SetOpenAge is called from fcbio2.asm. SS can be assumed to be valid.
 12190                                  ;
 12191                                  ;	MOV	AX,[CS:OpenLRU]	; SS override
 12192                                  ;	INC	AX
 12193                                  ;	;mov	[es:di+17h],ax
 12194                                  ;	MOV	[ES:DI+sf_OpenAge],AX
 12195                                  ;	JNZ	short SetDone
 12196                                  ;	;mov	bx,17h
 12197                                  ;	MOV	BX,SF_ENTRY.sf_position+2 ; mov bx,sf_OpenAge
 12198                                  ;	call	ResetLRU
 12199                                  ;SetDone:
 12200                                  ;	MOV	[CS:OpenLRU],AX
 12201                                  ;	retn
 12202                                  ;
 12203                                  ;ENDIF	; SetOpenAge no longer needed
 12204                                  
 12205                                  ; 21/07/2018 - Retro DOS v3.0
 12206                                  ; LRUFCB for MSDOS 6.0 !
 12207                                  
 12208                                  ;Break	<LRUFCB - perform LRU on FCB sfts>
 12209                                  ;----------------------------------------------------------------------------
 12210                                  ;
 12211                                  ;   LRUFCB - find LRU fcb in cache. Set ThisSFT and return it. We preserve
 12212                                  ;	the first keepcount sfts if they are network sfts or if sharing is
 12213                                  ;	loaded.  If carry is set then NO BLASTING is NECESSARY.
 12214                                  ;
 12215                                  ;   Inputs:	none
 12216                                  ;   Outputs:	ES:DI point to SFT
 12217                                  ;		ThisSFT points to SFT
 12218                                  ;		SFT is zeroed
 12219                                  ;		Carry set of closes failed
 12220                                  ;   Registers modified: none
 12221                                  ;
 12222                                  ;----------------------------------------------------------------------------
 12223                                  ;
 12224                                  ; MSDOS 6.0
 12225                                  ;IF 0	; rewritten this routine
 12226                                  ;
 12227                                  ;LRUFCB: ; MSDOS 3.3 - IBMDOS.COM (1987) - Offset 25ADh
 12228                                  ;	call	save_world
 12229                                  ;	
 12230                                  ; Find nth oldest NET/SHARE FCB. We want to find its age for the second scan
 12231                                  ; to find the lease recently used one that is younger than the open age.  We
 12232                                  ; operate be scanning the list n times finding the least age that is greater
 12233                                  ; or equal to the previous minimum age.
 12234                                  ;
 12235                                  ;   BP is the count of times we need to go through this loop.
 12236                                  ;   AX is the current acceptable minimum age to consider
 12237                                  ;
 12238                                  ;	mov	bp,[CS:KEEPCOUNT]	; k = keepcount;
 12239                                  ;	XOR	AX,AX			; low = 0;
 12240                                  ;
 12241                                  ; If we've scanned the table n times, then we are done.
 12242                                  ;
 12243                                  ;lru1:
 12244                                  ;	CMP	bp,0			; while (k--) {
 12245                                  ;	JZ	short lru75
 12246                                  ;	DEC	bp
 12247                                  ;
 12248                                  ; Set up for scan.
 12249                                  ;
 12250                                  ;   AX is the minimum age for consideration
 12251                                  ;   BX is the minimum age found during the scan
 12252                                  ;   SI is the position of the entry that corresponds to BX
 12253                                  ;
 12254                                  ;	MOV	BX,-1			;     min = 0xffff;
 12255                                  ;	MOV	si,BX			;     pos = 0xffff;
 12256                                  ;	LES	DI,[CS:SFTFCB]		;     for (CX=FCBCount; CX>0; CX--)
 12257                                  ;	;mov	cx,[es:di+4]
 12258                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 12259                                  ;	;lea	di,[di+6]
 12260                                  ;	LEA	DI,[DI+SFT.SFTable]
 12261                                  ;
 12262                                  ; Innermost loop.  If the current entry is free, then we are done.  Or, if the
 12263                                  ; current entry is busy (indicating a previous aborted allocation), then we
 12264                                  ; are done.  In both cases, we use the found entry.
 12265                                  ;
 12266                                  ;lru2:
 12267                                  ;	cmp	word [es:di],0
 12268                                  ;	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0
 12269                                  ;	jz	short lru25
 12270                                  ;	;cmp	word [es:di],-1
 12271                                  ;	;cmp	word [es:di+SFT_ENTRY.sf_ref_count],sf_busy
 12272                                  ;	cmp	word [es:di],sf_busy
 12273                                  ;	jnz	short lru3
 12274                                  ;
 12275                                  ; The entry is usable without further scan.  Go and use it.
 12276                                  ;
 12277                                  ;lru25:
 12278                                  ;	MOV	si,DI			;	      pos = i;
 12279                                  ;	JMP	short lru11		;	      goto got;
 12280                                  ;
 12281                                  ; See if the entry is for the network or for the sharer.
 12282                                  ;
 12283                                  ;  If for the sharer or network then
 12284                                  ;	if the age < current minimum AND >= allowed minimum then
 12285                                  ;	    this entry becomes current minimum
 12286                                  ;
 12287                                  ;lru3:
 12288                                  ;	;test	word [es:di+5],8000h
 12289                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet 
 12290                                  ;					;	  if (!net[i]
 12291                                  ;	JNZ	short lru35
 12292                                  ;if installed
 12293                                  ;	call	CheckShare		;		&& !sharing)
 12294                                  ;	JZ	short lru5		;	  else
 12295                                  ;ENDIF
 12296                                  ;
 12297                                  ; This SFT is for the net or is for the sharer. See if it less than the
 12298                                  ; current minimum.
 12299                                  ;
 12300                                  ;lru35:
 12301                                  ;	;mov	dx,[es:di+17h]
 12302                                  ;	MOV	DX,[ES:DI+sf_OpenAge]
 12303                                  ;	CMP	DX,AX			;	  if (age[i] >= low &&
 12304                                  ;	JB	short lru5
 12305                                  ;	CMP	DX,BX
 12306                                  ;	JAE	short lru5		;	      age[i] < min) {
 12307                                  ;
 12308                                  ; entry is new minimum.  Remember his age.
 12309                                  ;
 12310                                  ;	mov	bx,DX			;	      min = age[i];
 12311                                  ;	mov	si,di			;	      pos = i;
 12312                                  ;
 12313                                  ; End of loop.	gp back for more
 12314                                  ;
 12315                                  ;lru5:
 12316                                  ;	;add	di,53
 12317                                  ;	add	di,SF_ENTRY.size
 12318                                  ;	loop	lru2			;	      }
 12319                                  ;
 12320                                  ; The scan is complete. If we have successfully found a new minimum (pos != -1)
 12321                                  ; set then threshold value to this new minimum + 1. Otherwise, the scan is
 12322                                  ; complete.  Go find LRU.
 12323                                  ;
 12324                                  ;lru6:	
 12325                                  ;	cmp	si,-1			; position not -1?
 12326                                  ;	jz	short lru75		; no, done with everything
 12327                                  ;	lea	ax,[bx+1]		; set new threshold age
 12328                                  ;	jmp	short lru1		; go and loop for more
 12329                                  ;lru65:	
 12330                                  ;	stc
 12331                                  ;	jmp	short LRUDead		;	  return -1;
 12332                                  ;
 12333                                  ; Main loop is done. We have AX being the age+1 of the nth oldest sharer or
 12334                                  ; network entry. We now make a second pass through to find the LRU entry
 12335                                  ; that is local-no-share or has age >= AX
 12336                                  ;
 12337                                  ;lru75:
 12338                                  ;	mov	bx,-1			; min = 0xffff;
 12339                                  ;	mov	si,bx			; pos = 0xffff;
 12340                                  ;	LES	DI,[CS:SFTFCB]		; for (CX=FCBCount; CX>0; CX--)
 12341                                  ;	;mov	cx,[es:di+4]
 12342                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 12343                                  ;	;lea	di,[di+6]
 12344                                  ;	LEA	DI,[DI+SFT.SFTable]
 12345                                  ;
 12346                                  ; If this is is local-no-share then go check for LRU else if age >= threshold
 12347                                  ; then check for lru.
 12348                                  ;
 12349                                  ;lru8:
 12350                                  ;	;test	word [es:di+5],8000h
 12351                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 12352                                  ;	jnz	short lru85		; is for network, go check age
 12353                                  ;	call	CheckShare		; sharer here?
 12354                                  ;	jz	short lru86		; no, go check lru
 12355                                  ;
 12356                                  ; Network or sharer.  Check age
 12357                                  ;
 12358                                  ;lru85:
 12359                                  ;	;cmp	[es:di+17h],ax
 12360                                  ;	cmp	[es:di+sf_OpenAge],ax
 12361                                  ;	jb	short lru9		; age is before threshold, skip it
 12362                                  ;
 12363                                  ; Check LRU
 12364                                  ;
 12365                                  ;lru86:
 12366                                  ;	;cmp	[es:di+15h],bx
 12367                                  ;	cmp	[es:di+sf_LRU],bx	; is LRU less than current LRU?
 12368                                  ;	jae	short lru9		; no, skip this
 12369                                  ;	mov	si,di			; remember position
 12370                                  ;	;mov	bx,[es:di+15h]
 12371                                  ;	mov	bx,[es:di+sf_LRU]	; remember new minimum LRU
 12372                                  ;
 12373                                  ; Done with this entry, go back for more.
 12374                                  ;
 12375                                  ;lru9:
 12376                                  ;	;add	di, 53
 12377                                  ;	add	di,SF_ENTRY.size
 12378                                  ;	loop	lru8
 12379                                  ;
 12380                                  ; Scan is complete. If we found NOTHING that satisfied us then we bomb
 12381                                  ; out. The conditions here are:
 12382                                  ;
 12383                                  ;  No local-no-shares AND all net/share entries are older than threshold
 12384                                  ;
 12385                                  ;lru10:
 12386                                  ;	cmp	si,-1			; if no one f
 12387                                  ;	jz	short lru65		;     return -1;
 12388                                  ;lru11:
 12389                                  ;	mov	di,si
 12390                                  ;	MOV	[CS:THISSFT],DI		; set thissft
 12391                                  ;	MOV	[CS:THISSFT+2],ES
 12392                                  ;
 12393                                  ; If we have sharing or thisSFT is a net sft, then close it until ref count
 12394                                  ; is 0.
 12395                                  ;
 12396                                  ;	;test	word [es:di+5],8000h
 12397                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 12398                                  ;	JNZ	short LRUClose
 12399                                  ;IF INSTALLED
 12400                                  ;	call	CheckShare
 12401                                  ;	JZ	short LRUDone
 12402                                  ;ENDIF
 12403                                  ;
 12404                                  ; Repeat close until ref count is 0
 12405                                  ;
 12406                                  ;LRUClose:
 12407                                  ;	push	ss
 12408                                  ;	pop	ds
 12409                                  ;	LES	DI,[THISSFT]
 12410                                  ;	cmp     word [es:di],0
 12411                                  ;	;CMP	word [ES:DI+SFT.sf_ref_count],0 ; is ref count still <> 0?
 12412                                  ;	JZ	short LRUDone 		; nope, all done
 12413                                  ;	call	DOS_CLOSE
 12414                                  ;	jnc	short LRUClose		; no error => clean up
 12415                                  ;	;cmp	al,6
 12416                                  ;	cmp	al,error_invalid_handle
 12417                                  ;	jz	short LRUClose
 12418                                  ;	stc
 12419                                  ;	JMP	short LRUDead
 12420                                  ;LRUDone:
 12421                                  ;	XOR	AL,AL
 12422                                  ;	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 12423                                  ;
 12424                                  ;LRUDead:
 12425                                  ;	call	restore_world
 12426                                  ;	LES     DI,[CS:THISSFT]
 12427                                  ;	jnc	short LRUFCB_retn
 12428                                  ;LRUFCB_err:
 12429                                  ;	; mov	al, 23h	
 12430                                  ;	MOV	AL,error_FCB_unavailable
 12431                                  ;LRUFCB_retn:	
 12432                                  ;	retn:
 12433                                  ;
 12434                                  ;ENDIF	; LRUFCB has been rewritten below.
 12435                                  
 12436                                  ; 17/05/2019 - Retro DOS v4.0
 12437                                  ; LRUFCB for MSDOS 6.0 !
 12438                                  ;----------------------------------------------------------------------------
 12439                                  ;
 12440                                  ; LruFCB -- allocate the LRU SFT from the SFT Table. The LRU scheme
 12441                                  ; maintains separate counts for net/Share and local SFTs. We allocate a 
 12442                                  ; net/Share SFT only if we do not find a local SFT. This helps keep
 12443                                  ; net/Share SFTs which cannot be regenerated for as long as possible. We
 12444                                  ; optimize regeneration operations by keeping track of the current local
 12445                                  ; SFT. This avoids scanning of the SFTs as long as we have at least one 
 12446                                  ; local SFT in the SFT Block.
 12447                                  ;
 12448                                  ; Inputs: al = 0 => Regenerate SFT operation
 12449                                  ;	    = 1 => Allocate new SFT for Open/Create
 12450                                  ;
 12451                                  ; Outputs: Carry clear
 12452                                  ;	 	es:di = Address of allocated SFT
 12453                                  ;	  	ThisSFT = Address of allocated SFT
 12454                                  ;
 12455                                  ;	  carry set if closes of net/Share files failed 
 12456                                  ;		al = error_FCB_unavailable
 12457                                  ;
 12458                                  ; Registers affected: None
 12459                                  ;
 12460                                  ;----------------------------------------------------------------------------
 12461                                  
 12462                                  ;LruFCB	PROC	NEAR
 12463                                  LRUFCB:
 12464                                  	; 17/05/2019 - Retro DOS v4.0
 12465                                  	; DOSCODE:5805h (MSDOS 6.21, MSDOS.SYS)
 12466                                  
 12467                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12468                                  	; DOSCODE:57F1h (MSDOS 5.0, MSDOS.SYS)
 12469                                  
 12470 0000197A 06                      	push	es	; * (MSDOS 6.21)
 12471                                  	
 12472 0000197B E8E4EA                  	call	save_world
 12473                                  	
 12474                                  	;getdseg <ds>		;ds = DOSDATA
 12475 0000197E 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 12476                                  
 12477 00001983 08C0                    	or	al,al		;Check if regenerate allocation
 12478 00001985 751A                    	jnz	short lru1	;Try to find SFT to use
 12479                                  
 12480                                  	; This is a regen call. If LocalSFT contains the address of a valid 
 12481                                  	; local SFT, just return that SFT to reuse
 12482                                  
 12483 00001987 8B3E[4410]              	mov	di,[LocalSFT]
 12484 0000198B 0B3E[4610]              	or	di,[LocalSFT+2]	;is address == 0?
 12485 0000198F 7410                    	jz	short lru1	;invalid local SFT, find one
 12486                                  
 12487                                  	; We have found a valid local SFT. Recycle this SFT
 12488                                  
 12489 00001991 C43E[4410]              	les	di,[LocalSFT]
 12490                                  
 12491                                  gotlocalSFT:
 12492 00001995 893E[9E05]              	mov	[THISSFT],di
 12493 00001999 8C06[A005]              	mov	[THISSFT+2],es
 12494 0000199D F8                      	clc
 12495 0000199E E9AD00                  	jmp	LRUDone		;clear up SFT and return
 12496                                  
 12497                                  lru1:
 12498 000019A1 C43E[4000]              	les	di,[SFTFCB]	;es:di = SF Table for FCBs
 12499                                  	;mov	cx,[es:di+4]
 12500 000019A5 268B4D04                	mov	cx,[es:di+SFT.SFCount]	;cx = number of SFTs
 12501                                  	;lea	di,[di+6]
 12502 000019A9 8D7D06                  	lea	di,[di+SFT.SFTable]	;es:di = first SFT
 12503                                  
 12504                                  	; We scan through all the SFTs scanning for a free one. It also 
 12505                                  	; remembers the LRU SFT for net/Share SFTs and local SFTs separately. 
 12506                                  	; bx = min. LRU for local SFTs
 12507                                  	; si = pos. of local SFT with min. LRU
 12508                                  	; dx = min. LRU for net/Share SFTs
 12509                                  	; bp = pos. of net/Share SFT with min. LRU
 12510                                  
 12511 000019AC BBFFFF                  	mov	bx,-1		; init. to 0xffff ( max. LRU value )
 12512 000019AF 89DE                    	mov	si,bx
 12513 000019B1 89DA                    	mov	dx,bx
 12514 000019B3 89DD                    	mov	bp,bx
 12515                                  
 12516                                  findSFT:
 12517                                  	;See if this SFT is a free one. If so, return it
 12518 000019B5 26830D00                	or	word [es:di],0
 12519                                  	;or	word [es:di+SF_ENTRY.sf_ref_count],0 ;reference count = 0 ?
 12520 000019B9 744D                    	jz	short gotSFT	;yes, SFT is free
 12521                                  	;;cmp	word [es:di],-1
 12522                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy ;Is it busy?
 12523 000019BB 26833DFF                	cmp	word [es:di],sf_busy ; -1 
 12524 000019BF 7447                    	jz	short gotSFT	;no, can use it
 12525                                  
 12526                                  	; Check if this SFT is local and store its address in LocalSFT. Can be 
 12527                                  	; used for a later regen.
 12528                                  
 12529                                  	; 16/12/2022
 12530                                  	; 08/11/2022
 12531                                  	;test	byte [es:di+6],80h
 12532 000019C1 26F6450680              	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
 12533                                  	; 08/11/2022 Retro DOS v4.0 (MSDOS 5.0 MSDOS.SYS compatibility)
 12534                                  	;;test	word [es:di+5],8000h
 12535                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; network SFT?
 12536 000019C6 7532                    	jnz	short lru5	;yes, get net/Share LRU
 12537                                  
 12538                                  ;IF installed
 12539 000019C8 E88D59                  	call	CheckShare	;Share present?
 12540                                  ;ENDIF
 12541 000019CB 752D                    	jnz	short lru5	;yes, get net/Share LRU
 12542                                  
 12543                                  	;Local SFT, register its address
 12544                                  
 12545                                  	; !!HACK!!!
 12546                                  	; There is a slightly dirty hack out here in a desperate bid to save  
 12547                                  	; code space. There is similar code duplicated at label 'gotSFT'. We 
 12548                                  	; enter from there if al = 0, update the LocalSFT variable, and since 
 12549                                  	; al = 0, we jump out of the loop to the exit point. I have commented 
 12550                                  	; out the code that previously existed at label 'gotSFT'
 12551                                  
 12552                                  hackpoint:
 12553 000019CD 893E[4410]              	mov	[LocalSFT],di
 12554 000019D1 8C06[4610]              	mov	[LocalSFT+2],es	;store local SFT address
 12555                                  
 12556 000019D5 08C0                    	or	al,al		;Is operation = REGEN?
 12557 000019D7 74BC                    	jz	short gotlocalSFT ;yes, return this SFT for reuse
 12558                                  
 12559                                  	;Get LRU for local files
 12560                                  	
 12561                                  	;cmp	[es:di+15h],bx
 12562 000019D9 26395D15                	cmp	[es:di+sf_LRU],bx ;SFT.LRU < min?
 12563 000019DD 7306                    	jae	short lru4	;no, skip 
 12564                                  
 12565                                  	;mov	bx,[es:di+15h]
 12566 000019DF 268B5D15                	mov	bx,[es:di+sf_LRU] ;yes, store new minimum
 12567 000019E3 89FE                    	mov	si,di		;store SFT position
 12568                                  lru4:
 12569                                  	;add	di,59
 12570 000019E5 83C73B                  	add	di,SF_ENTRY.size ;go to next SFT
 12571 000019E8 E2CB                    	loop	findSFT
 12572                                  
 12573                                  	; Check whether we got a net/Share or local SFT. If local SFT 
 12574                                  	; available, we will reuse it instead of net/Share LRU
 12575                                  
 12576 000019EA 89F7                    	mov	di,si
 12577 000019EC 83FEFF                  	cmp	si,-1		;local SFT available?
 12578 000019EF 7517                    	jnz	short gotSFT	;yes, return it
 12579                                  
 12580                                  	;No local SFT, see if we got a net/Share SFT
 12581                                  
 12582 000019F1 89EF                    	mov	di,bp
 12583 000019F3 83FDFF                  	cmp	bp,-1		;net/Share SFT available?
 12584 000019F6 7530                    	jnz	short gotnetSFT	;yes, return it
 12585                                  noSFT:
 12586                                  	; NB: This error should never occur. We always must have an LRU SFT. 
 12587                                  	; This error can occur only if the SFT has been corrupted or the LRU 
 12588                                  	; count is not maintained properly.
 12589                                  
 12590 000019F8 EB51                    	jmp	short errorbadSFT ;error, no FCB available.
 12591                                  
 12592                                  	; Handle the LRU for net/Share SFTs
 12593                                  lru5:
 12594                                  	;cmp	[es:di+15h],dx
 12595 000019FA 26395515                	cmp	[es:di+sf_LRU],dx ;SFT.LRU < min?
 12596 000019FE 73E5                    	jae	short lru4	;no, skip 
 12597                                  
 12598                                  	;mov	dx,[es:di+15h]
 12599 00001A00 268B5515                	mov	dx,[es:di+sf_LRU] ;yes, store new minimum
 12600                                  
 12601 00001A04 89FD                    	mov	bp,di		;store SFT position
 12602 00001A06 EBDD                    	jmp	short lru4	;continue with next SFT
 12603                                  
 12604                                  gotSFT:
 12605 00001A08 08C0                    	or	al,al
 12606 00001A0A 74C1                    	jz	short hackpoint	;save es:di in LocalSFT
 12607                                  
 12608                                  	; HACK!!!
 12609                                  	; The code here differs from the code at 'hackpoint' only in the 
 12610                                  	; order of the check for al. If al = 0, we can jump to 'hackpoint' 
 12611                                  	; and then from there jump out to 'gotlocalSFT'. The original code 
 12612                                  	; has been commented out below and replaced by the code just above.
 12613                                  
 12614                                  ;If regen, then this SFT can be registered as a local one ( even if free ).
 12615                                  ;
 12616                                  ;	or	al,al		  ;Regen?
 12617                                  ;	jnz	short notlocaluse ;yes, register it and return
 12618                                  ;
 12619                                  ;Register this SFT as a local one
 12620                                  ;
 12621                                  ;	mov	[LocalSFT],di
 12622                                  ;	mov	[LocalSFT+2],es
 12623                                  ;	jmp	gotlocalSFT	;return to caller
 12624                                  ;
 12625                                  ;notlocaluse:
 12626                                  
 12627                                  	; The caller is probably going to use this SFT for a net/Share file. 
 12628                                  	; We will come here only on a Open/Create when the caller($FCB_OPEN) 
 12629                                  	; does not really know whether it is a local file or not. We 
 12630                                  	; invalidate LocalSFT if the SFT we are going to use was previously 
 12631                                  	; registered as a local SFT that can be recycled.
 12632                                  
 12633 00001A0C 8CC0                    	mov	ax,es
 12634 00001A0E 393E[4410]              	cmp	[LocalSFT],di		;Offset same?
 12635 00001A12 7506                    	jne	short notinvalid
 12636 00001A14 3906[4610]              	cmp	[LocalSFT+2],ax		;Segments same?
 12637 00001A18 7403                    	je	short zerolocalSFT	;no, no need to invalidate
 12638                                  notinvalid:
 12639 00001A1A E978FF                  	jmp	gotlocalSFT
 12640                                  
 12641                                  	; The SFT we are going to use was registered in the LocalSFT variable. 
 12642                                  	; Invalidate this variable i.e LocalSFT = NULL
 12643                                  
 12644                                  zerolocalSFT:
 12645 00001A1D 31C0                    	xor	ax,ax ; 0
 12646 00001A1F A3[4410]                	mov	[LocalSFT],ax
 12647 00001A22 A3[4610]                	mov	[LocalSFT+2],ax
 12648                                  
 12649 00001A25 E96DFF                  	jmp	gotlocalSFT
 12650                                  
 12651                                  gotnetSFT:
 12652                                  	; We have an SFT that is currently net/Share. If it is going to be 
 12653                                  	; used for a regen, we know it has to be a local SFT. Update the 
 12654                                  	; LocalSFT variable
 12655                                  
 12656 00001A28 08C0                    	or	al,al
 12657 00001A2A 7508                    	jnz	short closenet
 12658                                  
 12659 00001A2C 893E[4410]              	mov	[LocalSFT],di
 12660 00001A30 8C06[4610]              	mov	[LocalSFT+2],es	;store local SFT address
 12661                                  closenet:
 12662 00001A34 893E[9E05]              	mov	[THISSFT],di	; set thissft
 12663 00001A38 8C06[A005]              	mov	[THISSFT+2],es	
 12664                                  
 12665                                  	; If we have sharing or thisSFT is a net sft, then close it until ref 
 12666                                  	; count is 0.
 12667                                  	; NB: We come here only if it is a net/Share SFT that is going to be 
 12668                                  	; recycled -- no need to check for this.
 12669                                  
 12670                                  LRUClose:
 12671 00001A3C 26833D00                	cmp	word [es:di],0
 12672                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0 ; is ref count still <> 0?
 12673 00001A40 740C                    	jz	short LRUDone	; nope, all done
 12674                                  
 12675 00001A42 E80F15                  	call	DOS_CLOSE
 12676 00001A45 73F5                    	jnc	short LRUClose	; no error => clean up
 12677                                  
 12678                                  	; Bugbug: I dont know why we are trying to close after we get an 
 12679                                  	; error closing. Seems like we could have a potential infinite loop  
 12680                                  	; here. This has to be verified.
 12681                                  
 12682 00001A47 3C06                    	cmp	al,error_invalid_handle ; 6
 12683 00001A49 74F1                    	je	short LRUClose
 12684                                  errorbadSFT:
 12685 00001A4B F9                      	stc
 12686 00001A4C EB05                    	JMP	short LRUDead
 12687                                  LRUDone:
 12688 00001A4E 30C0                    	XOR	AL,AL
 12689 00001A50 E80E01                  	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 12690                                  
 12691                                  LRUDead:
 12692 00001A53 E8F5E9                  	call	restore_world		; use macro
 12693                                  	
 12694 00001A56 07                      	pop	es ; * (MSDOS 6.21)
 12695                                  
 12696                                  	;getdseg <es>
 12697 00001A57 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 12698 00001A5C 26C43E[9E05]            	les	di,[es:THISSFT]		;es:di points at allocated SFT
 12699                                  
 12700                                  	;;retnc
 12701                                  	;jc	short LruFCB_err
 12702                                  	;retn
 12703                                  
 12704                                  	; 16/12/2022
 12705                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12706 00001A61 7302                    	jnc	short LruFCB_retn
 12707                                  	;jc	short LruFCB_err
 12708                                  	;retn
 12709                                  		
 12710                                  LruFCB_err:
 12711 00001A63 B023                    	MOV	AL,error_FCB_unavailable ; 23h
 12712                                  LruFCB_retn:
 12713 00001A65 C3                      	retn
 12714                                  	
 12715                                  ;LruFCB	ENDP
 12716                                  
 12717                                  ; 17/05/2019 - Retro DOS v4.0
 12718                                  
 12719                                  ; DOSCODE:58F3h (MSDOS 6.21, MSDOS.SYS)
 12720                                  
 12721                                  ; --------------------------------------------------------------------------
 12722                                  ;**** RegenCopyName -- This function copies the filename from the FCB to
 12723                                  ; SFT and also to DOS local buffers. There was duplicate code in FCBRegen
 12724                                  ; to copy the name to different destinations
 12725                                  ;
 12726                                  ; Inputs: ds:si = source string
 12727                                  ;	 es:di = destination string
 12728                                  ;	 cx = length of string
 12729                                  ;
 12730                                  ; Outputs: String copied to destination
 12731                                  ;
 12732                                  ; Registers affected: cx,di,si
 12733                                  ; --------------------------------------------------------------------------
 12734                                  
 12735                                  RegenCopyName:
 12736                                  CopyName:
 12737 00001A66 AC                      	lodsb			;load character
 12738 00001A67 E8FC35                  	call	UCase		; convert char to upper case
 12739                                  StuffChar2:
 12740 00001A6A AA                      	STOSB			;store converted character
 12741 00001A6B E2F9                    	LOOP	CopyName	;
 12742                                  DoneName:
 12743 00001A6D C3                      	retn
 12744                                  
 12745                                  ; --------------------------------------------------------------------------
 12746                                  
 12747                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12748                                  FCBRegen:
 12749                                  	; called from SFTFromFCB. SS already DOSDATA
 12750                                  
 12751                                  	; General data filling. Mode is sf_isFCB + open_for_both, date/time 
 12752                                  	; we do not fill, size we do no fill, position we do not fill,
 12753                                  	; bit 14 of flags = TRUE, other bits = FALSE
 12754                                  
 12755                                  	;mov	al,[si+19h]
 12756 00001A6E 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 12757                                  
 12758                                  	; We discriminate based on the first two bits in the reserved field.
 12759                                  	
 12760                                  	;test	al,80h
 12761 00001A71 A880                    	test	AL,FCBSPECIAL		; check for no sharing test
 12762 00001A73 741C                    	JZ	short RegenNoSharing	; yes, go regen from no sharing
 12763                                  
 12764                                  	; The FCB is for a network or a sharing based system. At this point 
 12765                                  	; we have already closed the SFT for this guy and reconnection is 
 12766                                  	; impossible.
 12767                                  	;
 12768                                  	; Remember that he may have given us a FCB with bogus information in
 12769                                  	; it. Check to see if sharing is present or if the redir is present.
 12770                                  	; If either is around, presume that we have cycled out the FCB and 
 12771                                  	; give the hard error. Otherwise, just return with carry set.
 12772                                  
 12773 00001A75 E8E058                  	call	CheckShare		; test for sharer
 12774 00001A78 7509                    	JNZ	short RegenFail		; yep, fail this.
 12775                                  	
 12776                                  	;mov	ax,1100h
 12777 00001A7A B80011                  	MOV	AX,MultNET<<8		; install check on multnet
 12778 00001A7D CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK
 12779                                  			; Return: AL = 00h  not installed, OK to install
 12780                                  			; 01h  not installed, not OK to install
 12781                                  			; FFh  installed
 12782 00001A7F 08C0                    	OR	AL,AL			; is it there?
 12783 00001A81 740C                    	JZ	short RegenDead		; no, just fail the operation
 12784                                  RegenFail:
 12785                                  	; 17/05/2019 - Retro DOS v4.0
 12786                                  	;MOV	AX,[CS:USER_IN_AX]	; SS override
 12787 00001A83 36A1[3A03]              	mov	ax,[SS:USER_IN_AX] ; MSDOS 6.0
 12788                                  
 12789                                  	;cmp	ah,10h
 12790 00001A87 80FC10                  	cmp	AH,FCB_CLOSE
 12791 00001A8A 7403                    	jz	short RegenDead
 12792 00001A8C E89301                  	call	FCBHardErr		; massive hard error.
 12793                                  RegenDead:
 12794 00001A8F F9                      	STC				; carry set
 12795                                  FCBRegen_retn:
 12796 00001A90 C3                      	retn
 12797                                  
 12798                                  	; Local FCB without sharing. Check to see if sharing is loaded. If 
 12799                                  	; so fail the operation.
 12800                                  
 12801                                  RegenNoSharing:
 12802 00001A91 E8C458                  	call	CheckShare		; Sharing around?
 12803 00001A94 75ED                    	JNZ	short RegenFail
 12804                                  	
 12805                                  	; Find an SFT for this guy.
 12806                                  	
 12807                                  	; 17/05/2019 - Retro DOS v4.0
 12808                                  
 12809                                  	; MSDOS 3.3
 12810                                  	;call	LRUFCB
 12811                                  	;jc	short FCBRegen_retn
 12812                                  	
 12813                                  	; MSDOS 6.0
 12814 00001A96 50                      	push	ax
 12815 00001A97 B000                    	mov	al,0			;indicate it is a regen operation
 12816 00001A99 E8DEFE                  	call	LRUFCB
 12817 00001A9C 58                      	pop	ax
 12818 00001A9D 72F1                    	jc	short FCBRegen_retn
 12819                                  
 12820                                  	;mov	word [es:di+2],8002h
 12821 00001A9F 26C745020280            	MOV	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB+open_for_both+SHARING_COMPAT
 12822 00001AA5 243F                    	AND	AL,3Fh			; get drive number for flags
 12823 00001AA7 98                      	CBW
 12824                                  	;or	ax,4000h
 12825 00001AA8 0D0040                  	OR	AX,sf_close_nodate	; normal FCB operation
 12826                                  
 12827                                  	; The bits field consists of the upper two bits (dirty and device) 
 12828                                  	; from the SFT and the low 4 bits from the open mode.
 12829                                  
 12830                                  	;mov	cl,[si+1Ah]
 12831 00001AAB 8A4C1A                  	MOV	CL,[SI+fcb_nsl_bits]	; stick in dirty bits.
 12832 00001AAE 88CD                    	MOV	CH,CL
 12833 00001AB0 80E5C0                  	AND	CH,0C0h 		; mask off the dirty/device bits
 12834 00001AB3 08E8                    	OR	AL,CH
 12835                                  	;and	cl,0Fh
 12836 00001AB5 80E10F                  	AND	CL,access_mask		; get the mode bits
 12837                                  	;mov	[es:di+2],cl
 12838 00001AB8 26884D02                	MOV	[ES:DI+SF_ENTRY.sf_mode],CL
 12839                                  	;mov	[es:di+5],ax
 12840 00001ABC 26894505                	MOV	[ES:DI+SF_ENTRY.sf_flags],AX ; initial flags
 12841                                  	;MOV	AX,[CS:PROC_ID]		; SS override
 12842 00001AC0 36A1[3C03]              	mov	ax,[ss:PROC_ID] ; MSDOS 6.0
 12843                                  	;mov	[es:di+31h],ax
 12844 00001AC4 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX
 12845 00001AC8 1E                      	push	ds
 12846 00001AC9 56                      	push	si
 12847 00001ACA 06                      	push	es
 12848 00001ACB 57                      	push	di
 12849 00001ACC 16                      	push	ss
 12850 00001ACD 07                      	pop	es
 12851 00001ACE BF[4B05]                	MOV	DI,NAME1		; NAME1 is in DOSDATA
 12852                                  
 12853 00001AD1 B90800                  	MOV	CX,8
 12854 00001AD4 46                      	INC	SI			; Skip past drive byte to name in FCB
 12855                                  
 12856                                  	; MSDOS 3.3
 12857                                  ;RegenCopyName:
 12858                                  	;lodsb
 12859                                  	;call	UCase
 12860                                  	;stosb
 12861                                  	;loop	RegenCopyName
 12862                                  
 12863                                  	; MSDOS 6.0
 12864 00001AD5 E88EFF                  	call	RegenCopyName		;copy the name to NAME1
 12865                                  
 12866 00001AD8 16                      	push	ss	; SS is DOSDATA
 12867 00001AD9 1F                      	pop	ds
 12868                                  
 12869                                  	;mov	byte [ATTRIB],16h
 12870 00001ADA C606[6B05]16            	MOV	byte [ATTRIB],attr_hidden+attr_system+attr_directory
 12871                                  					; Must set this to something interesting
 12872                                  					; to call DEVNAME.
 12873 00001ADF E81227                  	call	DEVNAME 		; check for device
 12874 00001AE2 5E                      	pop	si
 12875 00001AE3 07                      	pop	es
 12876 00001AE4 5E                      	pop	si
 12877 00001AE5 1F                      	pop	ds
 12878 00001AE6 7219                    	JC	short RegenFileNoSharing ; not found on device list => file
 12879                                  
 12880                                  	; Device found. We can ignore disk-specific info
 12881                                  
 12882                                  	;mov	[es:di+5],bh
 12883 00001AE8 26887D05                	MOV	[ES:DI+SF_ENTRY.sf_flags],BH ; device parms
 12884                                  	;mov	byte [es:di+4],0
 12885 00001AEC 26C6450400              	MOV	byte [ES:DI+SF_ENTRY.sf_attr],0 ; attribute
 12886                                  					; SS override
 12887                                  	;LDS	SI,[CS:DEVPT]		; get device driver
 12888 00001AF1 36C536[9A05]            	lds	si,[ss:DEVPT] ; MSDOS 6.0
 12889                                  	;mov	[es:di+7],si
 12890 00001AF6 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 12891                                  	;mov	[es:di+9],ds
 12892 00001AFA 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 12893 00001AFE C3                      	retn				; carry is clear
 12894                                  
 12895                                  RegenDeadJ:
 12896 00001AFF EB8E                    	JMP	short RegenDead
 12897                                  
 12898                                  	; File found. Just copy in the remaining pieces.
 12899                                  
 12900                                  RegenFileNoSharing:
 12901                                  	;mov	ax,[es:di+5]
 12902 00001B01 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 12903 00001B05 83E03F                  	AND	AX,03Fh
 12904 00001B08 1E                      	push	ds
 12905 00001B09 56                      	push	si
 12906 00001B0A E8D84E                  	call	FIND_DPB
 12907                                  	;mov	[es:di+7],si
 12908 00001B0D 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 12909                                  	;mov	[es:di+9],ds
 12910 00001B11 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 12911 00001B15 5E                      	pop	si
 12912 00001B16 1F                      	pop	ds
 12913 00001B17 72E6                    	jc	short RegenDeadJ	; if find DPB fails, then drive
 12914                                  					; indicator was bogus
 12915                                  	;mov	ax,[si+1Dh]
 12916 00001B19 8B441D                  	MOV	AX,[SI+fcb_nsl_dirsec]
 12917                                  	;;mov	[es:di+1Dh],ax ; MSDOS 3.3
 12918                                  	;mov	[es:di+1Bh],ax ; MSDOS 6.0
 12919 00001B1C 2689451B                	MOV	[ES:DI+SF_ENTRY.sf_dirsec],AX
 12920                                  
 12921                                  	; MSDOS 6.0
 12922                                  
 12923                                  	; SR;
 12924                                  	; Extract the read-only and archive bits from the top 2 bits of the sector
 12925                                  	; number
 12926                                  
 12927                                  	;mov	al,[si+18h]
 12928 00001B20 8A4418                  	mov	al,[si+fcb_sfn]
 12929 00001B23 24C0                    	and	al,0C0h		;get the 2 attribute bits
 12930 00001B25 88C4                    	mov	ah,al
 12931 00001B27 D0C4                    	rol	ah,1
 12932 00001B29 D0E8                    	shr	al,1
 12933 00001B2B 08E0                    	or	al,ah
 12934 00001B2D 243F                    	and	al,03Fh		;mask off unused bits
 12935                                  	;mov	[es:di+4],al
 12936 00001B2F 26884504                	mov	[es:di+SF_ENTRY.sf_attr],al
 12937                                  
 12938                                  	; SR;
 12939                                  	; Update the higher word of the directory sector from the FCB
 12940                                  
 12941                                  	;;mov	al,[si+18h]
 12942 00001B33 8A4418                  	mov	al,[si+fcb_sfn]
 12943 00001B36 243F                    	and	al,03Fh		;mask off top 2 bits -- attr bits
 12944 00001B38 28E4                    	sub	ah,ah
 12945                                  	;mov	[es:di+1Dh],ax
 12946 00001B3A 2689451D                	mov	[es:di+SF_ENTRY.sf_dirsec+2],ax ;update high word
 12947                                  
 12948                                  	; MSDOS 6.0 (& MSDOS 3.3)
 12949                                  	;mov	ax,[si+1Bh]
 12950 00001B3E 8B441B                  	MOV	AX,[SI+fcb_nsl_firclus]
 12951                                  	;mov	[es:di+0Bh],ax
 12952 00001B41 2689450B                	MOV	[ES:DI+SF_ENTRY.sf_firclus],AX
 12953                                  	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
 12954                                  	;mov	[es:di+35h],ax ; MSDOS 6.0
 12955 00001B45 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 12956                                  	;mov	al,[si+1Fh]
 12957 00001B49 8A441F                  	MOV	AL,[SI+fcb_nsl_dirpos]
 12958                                  	;mov  	[es:di+1Fh],al
 12959 00001B4C 2688451F                	MOV	[ES:DI+SF_ENTRY.sf_dirpos],AL
 12960                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 12961 00001B50 26FF05                  	inc	word [ES:DI]		; Increment reference count.
 12962                                  					; Existing FCB entries would be
 12963                                  					; flushed unnecessarily because of
 12964                                  					; check in CheckFCB of the ref_count.
 12965                                  					; July 22/85 - BAS
 12966                                  	;lea	si,[si+1]
 12967 00001B53 8D7401                  	LEA	SI,[SI+SYS_FCB.name]
 12968                                  	;lea	di,[di+20h]
 12969 00001B56 8D7D20                  	LEA	DI,[DI+SF_ENTRY.sf_name]
 12970                                  	;mov	cx,11
 12971 00001B59 B90B00                  	MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 12972                                  	
 12973                                  	; MSDOS 6.0
 12974 00001B5C E807FF                  	call	RegenCopyName	;copy name to SFT 
 12975                                  	
 12976                                  	; MSDOS 3.3
 12977                                  ;RegenCopyName2:
 12978                                  	;lodsb
 12979                                  	;call    UCase
 12980                                  	;stosb
 12981                                  	;loop    RegenCopyName2
 12982                                  
 12983 00001B5F F8                      	clc
 12984 00001B60 C3                      	retn
 12985                                  
 12986                                  ; 17/05/2019 - Retro DOS v4.0
 12987                                  
 12988                                  ;**	BlastSFT - FIll SFT with Garbage
 12989                                  ; --------------------------------------------------------------------------
 12990                                  ;	BlastSFT is used when an SFT is no longer needed; it's called with
 12991                                  ;	various garbage values to put into the SFT.  I don't know why,
 12992                                  ;	presumably to help with debugging (jgl).  We clear the few fields
 12993                                  ;	necessary to show that the SFT is free after filling it.
 12994                                  ;
 12995                                  ;	ENTRY	(es:di) = address of SFT
 12996                                  ;		(al) = fill character
 12997                                  ;	EXIT	(ax) = -1
 12998                                  ;		'C' clear
 12999                                  ;	USES	AX, CX, Flags
 13000                                  
 13001                                  BlastSFT:
 13002 00001B61 57                      	push	di
 13003                                  	;mov	cx,53 ; MSDOS 3.3
 13004                                  	;mov	cx,59 ; MSDOS 6.0
 13005 00001B62 B93B00                  	mov	cx,SF_ENTRY.size
 13006 00001B65 F3AA                    	rep	stosb
 13007 00001B67 5F                      	pop	di
 13008 00001B68 29C0                    	sub	ax,ax	; 0		; clear 'C'-----------------;
 13009 00001B6A 268905                  	mov	[es:di],ax
 13010                                  	;mov	[es:di+SFT_ENTRY.sf_ref_count],ax ; set ref count   ;
 13011                                  	;mov	[es:di+15h],ax
 13012 00001B6D 26894515                	mov	[es:di+sf_LRU],ax	; set lru		    ;
 13013 00001B71 48                      	dec	ax	; -1					    ;
 13014                                  	;mov	[es:di+17h],ax ; 0FFFFh ; -1
 13015 00001B72 26894517                	mov	[es:di+sf_OpenAge],ax	; set open age to -1	    ;
 13016                                  BlastSFT_retn:
 13017 00001B76 C3                      	retn				; return with 'C' clear     ;
 13018                                  
 13019                                  ;Break	<CheckFCB - see if the SFT pointed to by the FCB is still OK>
 13020                                  ; --------------------------------------------------------------------------
 13021                                  ;
 13022                                  ;   CheckFCB - examine an FCB and its contents to see if it needs to be
 13023                                  ;   regenerated.
 13024                                  ;
 13025                                  ;   Inputs:	DS:SI point to FCB (not extended)
 13026                                  ;		AL is SFT index
 13027                                  ;   Outputs:	Carry Set - FCB needs to be regened
 13028                                  ;		Carry clear - FCB is OK. ES:DI point to SFT
 13029                                  ;   Registers modified: AX and BX
 13030                                  ;
 13031                                  ; --------------------------------------------------------------------------
 13032                                  
 13033                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13034                                  	; DOSCODE:59F0h (MSDOS 5.0, MSDOS.SYS)
 13035                                  CheckFCB:
 13036                                  		
 13037                                  	; called from $fcb_open and sftfromfcb. SS already set up to DOSDATA
 13038                                  
 13039                                  	; MSDOS 3.3
 13040                                  
 13041                                  	; LES	DI,[CS:SFTFCB]
 13042                                  
 13043                                  	; MSDOS 6.0
 13044                                  	
 13045                                  	; SR;
 13046                                  	; We check if the given FCB is for a local file. If so, we return a 
 13047                                  	; bad SFT status forcing the caller to regenerate the SFT.
 13048                                  
 13049                                  	;test	byte [si+19h],0C0h
 13050 00001B77 F64419C0                	test	byte [si+fcb_l_drive],FCBNETWORK|FCBSHARE|FCBDEVICE
 13051 00001B7B 744F                    	jz	short BadSFT		;Local file, return bad SFT
 13052 00001B7D 36C43E[4000]            	LES     DI,[SS:SFTFCB]		; SS override
 13053                                  
 13054                                  	; MSDOS 6.0 (& MSDOS 3.3)
 13055                                  	;cmp	[es:di+4],al
 13056 00001B82 26384504                	CMP	[ES:DI+SFT.SFCount],AL
 13057 00001B86 7244                    	JC	short BadSFT
 13058                                  	;;mov	bl,53 ; MSDOS 3.3
 13059                                  	;mov	bl,59 ; MSDOS 6.0
 13060 00001B88 B33B                    	MOV	BL,SF_ENTRY.size
 13061 00001B8A F6E3                    	MUL	BL
 13062                                  	;lea	di,[di+6]
 13063 00001B8C 8D7D06                  	LEA	DI,[DI+SFT.SFTable]
 13064 00001B8F 01C7                    	ADD	DI,AX
 13065                                  	;MOV	AX,[CS:PROC_ID]	; MSDOS 3.3
 13066 00001B91 36A1[3C03]              	mov	ax,[SS:PROC_ID] ; MSDOS 6.0  ; SS override
 13067                                  	;cmp	[es:di+31h],ax
 13068 00001B95 26394531                	CMP	[ES:DI+SF_ENTRY.sf_PID],AX
 13069 00001B99 7531                    	JNZ	short BadSFT		; must match process
 13070 00001B9B 26833D00                	cmp	word [es:di],0
 13071                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],0
 13072 00001B9F 742B                    	JZ	short BadSFT		; must also be in use
 13073                                  	;mov	al,[si+19h]
 13074 00001BA1 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 13075                                  	;test	al,80h
 13076 00001BA4 A880                    	test	AL,FCBSPECIAL		; a special FCB?
 13077 00001BA6 7430                    	JZ	short CheckNoShare	; No. try local or device
 13078                                  
 13079                                  	; Since we are a special FCB, try NOT to use a bogus test instruction.
 13080                                  	; FCBSHARE is a superset of FCBNETWORK.
 13081                                  
 13082 00001BA8 50                      	PUSH	AX
 13083                                  	;and	al,0C0h
 13084 00001BA9 24C0                    	AND	AL,FCBMASK
 13085                                  	;cmp	al,0C0h
 13086 00001BAB 3CC0                    	CMP	AL,FCBSHARE		; net FCB?
 13087 00001BAD 58                      	POP	AX
 13088 00001BAE 751E                    	JNZ	short CheckNet		; yes
 13089                                  ;
 13090                                  ;----- In share support -----
 13091                                  ;
 13092                                  	;call	far [cs:JShare+(11*4)]
 13093 00001BB0 36FF1E[BC00]            	Call    far [ss:JShare+(11*4)] ; 11 = ShChk ; SS Override
 13094 00001BB5 7215                    	JC	short BadSFT
 13095 00001BB7 EB06                    	JMP	SHORT CheckD
 13096                                  ;
 13097                                  ;----- End in share support -----
 13098                                  ;
 13099                                  	; 09/11/2022
 13100                                  	; (There is not any procedure/sub
 13101                                  	;  which calls or jumps to CheckFirClus here)
 13102                                  	;;;
 13103                                  CheckFirClus:
 13104                                  	;cmp     bx,[es:di+0Bh]
 13105                                  	; 07/12/2022
 13106 00001BB9 263B5D0B                	CMP	BX,[ES:DI+SF_ENTRY.sf_firclus]
 13107 00001BBD 750D                    	JNZ	short BadSFT
 13108                                  	;;;
 13109                                  CheckD: 
 13110 00001BBF 243F                    	AND	AL,3Fh
 13111                                  	;mov	ah,[es:di+5]
 13112 00001BC1 268A6505                	MOV	AH,[ES:DI+SF_ENTRY.sf_flags]
 13113 00001BC5 80E43F                  	AND	AH,3Fh
 13114 00001BC8 38C4                    	CMP	AH,AL
 13115                                  	; 16/12/2022
 13116 00001BCA 74AA                    	jz	short BlastSFT_retn	; carry is clear
 13117                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13118                                  	;jnz	short BadSFT
 13119                                  ;CheckD_retn:
 13120                                  	;retn
 13121                                  BadSFT: 
 13122 00001BCC F9                      	STC
 13123 00001BCD C3                      	retn
 13124                                  				
 13125                                  CheckNet:
 13126                                  	; 17/05/2019 - Retro DOS v4.0
 13127                                  	
 13128                                  ;----- In net support -----
 13129                                  
 13130                                  	; MSDOS 3.3
 13131                                  	;;mov	ax,[si+1Ah]
 13132                                  	;mov	ax,[si+fcb_net_handle]
 13133                                  	;;cmp	ax,[es:di+1Dh]
 13134                                  	;cmp	ax,[ES:DI+SF_ENTRY.sf_dirsec]
 13135                                  	;jnz	short BadSFT
 13136                                  	;;cmp	ax,[es:di+19h]
 13137                                  	;cmp	ax,[ES:DI+sf_netid]
 13138                                  	;jnz     short BadSFT
 13139                                  	;;mov	ax,[si+1Eh]
 13140                                  	;mov	ax,[si+fcb_l_attr]
 13141                                  	;;cmp	ax,[es:di+1Bh]
 13142                                  	;cmp	ax,[es:di+SF_ENTRY.sf_lstclus]
 13143                                  	;jnz     short BadSFT
 13144                                  
 13145                                  	; MSDOS 6.0
 13146                                  	;mov	ax,[si+1Ch]
 13147 00001BCE 8B441C                  	MOV	AX,[SI+fcb_netID]	;AN000;IFS.DOS 4.00
 13148                                  	; 09/11/2022
 13149                                  	;cmp	ax,[es:di+0Bh] 
 13150 00001BD1 263B450B                	CMP	AX,[ES:DI+sf_serial_ID]	;AN000;IFS.DOS 4.00
 13151 00001BD5 75F5                    	JNZ	short BadSFT
 13152                                  
 13153                                  ;----- END In net support -----
 13154                                  
 13155                                  CheckNet_retn:
 13156 00001BD7 C3                      	retn
 13157                                  
 13158                                  CheckNoShare:
 13159                                  
 13160                                  ; 16/12/2022
 13161                                  ;	; 09/11/2022 (following test instruction is nonsense!)
 13162                                  ;	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)
 13163                                  ;	;test	al,40h
 13164                                  ;	test	AL,FCBDEVICE		; Device?
 13165                                  ;	;jnz	short $+2 ; 09/11/2022
 13166                                  ;	JNZ	short CheckNoShareDev 	; Yes
 13167                                  
 13168                                  	; MSDOS 3.3 - IBMDOS.COM - Offset 27EFh
 13169                                  	;;mov	bx,[si+1Dh]
 13170                                  	;MOV	BX,[SI+fcb_nsl_dirsec]
 13171                                  	;;cmp	bx,[es:di+1Dh]
 13172                                  	;cmp	bx,[ES:DI+SF_ENTRY.sf_dirsec]
 13173                                  	;jnz	short BadSFT
 13174                                  	;;mov	bl,[si+1Fh]
 13175                                  	;MOV	bl,[SI+fcb_nsl_dirpos]
 13176                                  	;;cmp	bl,[es:di+1Fh]
 13177                                  	;cmp	bl,[ES:DI+SF_ENTRY.sf_dirpos]
 13178                                  	;jnz	short BadSFT
 13179                                  	;;mov	bl,[si+1Ah]
 13180                                  	;MOV	bl,[SI+fcb_nsl_bits]
 13181                                  	;;mov	bh,[es:di+5]
 13182                                  	;MOV	bh,[ES:DI+SF_ENTRY.sf_flags]
 13183                                  	;xor	bh,bl
 13184                                  	;and	bh,0C0h
 13185                                  	;jnz	short BadSFT
 13186                                  	;;xor	bl,[es:di+2]
 13187                                  	;xor	bl,[ES:DI+SF_ENTRY.sf_mode]
 13188                                  	;and	bl,0Fh
 13189                                  	;jnz	short BadSFT
 13190                                  	;push	di
 13191                                  	;push	si
 13192                                  	;;lea	di,[di+20h]  ; MSDOS 3.3
 13193                                  	;LEA	DI,[DI+SF_ENTRY.sf_name]
 13194                                  	;;lea	si,[si+1]
 13195                                  	;LEA	SI,[SI+SYS_FCB.name]
 13196                                  	;;mov	cx,11
 13197                                  	;MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 13198                                  	;repe	cmpsb
 13199                                  	;pop	si
 13200                                  	;pop	di
 13201                                  	;jnz	short BadSFT
 13202                                  	;;mov	bx,[si+1Bh]
 13203                                  	;MOV	bX,[SI+fcb_nsl_firclus]
 13204                                  	;jmp	short CheckFirClus
 13205                                  
 13206                                  	; MSDOS 6.0
 13207                                  
 13208                                  	; SR;
 13209                                  	; The code below to match a local FCB with its SFT can no longer be
 13210                                  	; used. We just return a no-match status. This check is done right
 13211                                  	; at the top.
 13212                                  
 13213                                  CheckNoShareDev:
 13214                                  	;mov	bx,[si+1Ah]
 13215 00001BD8 8B5C1A                  	MOV	BX,[SI+fcb_nsld_drvptr]
 13216                                  	;cmp	bx,[es:di+7]
 13217 00001BDB 263B5D07                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr]
 13218 00001BDF 75EB                    	JNZ	short BadSFT
 13219                                  	;mov	bx,[si+1Ch]
 13220 00001BE1 8B5C1C                  	MOV	BX,[SI+fcb_nsld_drvptr+2]
 13221                                  	;cmp	bx,[es:di+9]
 13222 00001BE4 263B5D09                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr+2]
 13223 00001BE8 75E2                    	JNZ	short BadSFT
 13224 00001BEA EBD3                    	JMP	short CheckD
 13225                                  
 13226                                  ;Break	<SFTFromFCB - take a FCB and obtain a SFT from it>
 13227                                  ;----------------------------------------------------------------------------
 13228                                  ;
 13229                                  ;   SFTFromFCB - the workhorse of this compatability crap. Check to see if
 13230                                  ;	the SFT for the FCB is Good. If so, make ThisSFT point to it. If not
 13231                                  ;	good, get one from the cache and regenerate it. Overlay the LRU field
 13232                                  ;	with PID
 13233                                  ;
 13234                                  ;   Inputs:	DS:SI point to FCB
 13235                                  ;   Outputs:	ThisSFT point to appropriate SFT
 13236                                  ;		Carry clear -> OK ES:DI -> SFT
 13237                                  ;		Carry set -> error in ax
 13238                                  ;   Registers modified: ES,DI, AX
 13239                                  ;
 13240                                  ;----------------------------------------------------------------------------
 13241                                  
 13242                                  SFTFromFCB:
 13243                                  	; called from fcbio and $fcb_close. SS already set up to DOSDATA
 13244                                  
 13245                                  	; 17/05/2019 - Retro DOS v4.0
 13246                                  
 13247 00001BEC 50                      	push	ax
 13248 00001BED 53                      	push	bx
 13249                                  	;mov	al,[si+18h]
 13250 00001BEE 8A4418                  	MOV	AL,[SI+fcb_sfn] 	; set SFN for check
 13251 00001BF1 E883FF                  	call	CheckFCB
 13252 00001BF4 5B                      	pop	bx
 13253 00001BF5 58                      	pop	ax
 13254                                  	;MOV	[CS:THISSFT],DI		; SS override
 13255                                  	;MOV	[CS:THISSFT+2],ES
 13256 00001BF6 36893E[9E05]            	MOV	[SS:THISSFT],DI		; SS override
 13257 00001BFB 368C06[A005]            	MOV	[SS:THISSFT+2],ES
 13258 00001C00 7311                    	JNC	short Set_SFT		; no problems, just set thissft
 13259                                  	
 13260                                  	; 09/11/2022 (MSDOS 5.0)
 13261                                  	; 31/05/2019
 13262 00001C02 06                      	push	es ; * (MSDOS 6.21) & (MSDOS 5.0)
 13263 00001C03 E85CE8                  	call	save_world
 13264 00001C06 E865FE                  	call	FCBRegen
 13265 00001C09 E83FE8                  	call	restore_world		; use macro restore world
 13266 00001C0C 07                      	pop	es ; * (MSDOS 6.21) ; 31/05/2019 ; 09/11/2022 (MSDOS 5.0)	
 13267                                  
 13268                                  	;MOV	AX,[CS:EXTERR]		; SS override
 13269 00001C0D 36A1[2403]              	MOV	AX,[SS:EXTERR]		; SS override
 13270 00001C11 72C4                    	jc	short CheckNet_retn
 13271                                  
 13272                                  Set_SFT: 
 13273                                  	;LES	DI,[CS:THISSFT]		; SS override for THISSFT & PROC_ID
 13274 00001C13 36C43E[9E05]            	les	di,[ss:THISSFT]
 13275                                  	;PUSH	word [CS:PROC_ID]	; set process id
 13276 00001C18 36FF36[3C03]            	push	word [ss:PROC_ID]
 13277                                  	;pop	word [es:di+31h]
 13278 00001C1D 268F4531                	POP     word [ES:DI+SF_ENTRY.sf_PID]
 13279 00001C21 C3                      	retn				; carry is clear
 13280                                  
 13281                                  ;Break	<FCBHardErr - generate INT 24 for hard errors on FCBS>
 13282                                  ;----------------------------------------------------------------------------
 13283                                  ;
 13284                                  ;   FCBHardErr - signal to a user app that he is trying to use an
 13285                                  ;	unavailable FCB.
 13286                                  ;
 13287                                  ;   Inputs:	none.
 13288                                  ;   Outputs:	none.
 13289                                  ;   Registers modified: all
 13290                                  ;
 13291                                  ;----------------------------------------------------------------------------
 13292                                  
 13293                                  FCBHardErr:
 13294                                  	; 17/05/2019 - Retro DOS v4.0
 13295 00001C22 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 13296                                  	;
 13297                                  	;mov	ax,23h
 13298 00001C27 B82300                  	MOV	AX,error_FCB_unavailable
 13299                                  	;;mov	byte [cs:ALLOWED],8
 13300                                  	;MOV	byte [CS:ALLOWED],Allowed_FAIL
 13301 00001C2A 26C606[4B03]08          	mov	byte [es:ALLOWED],Allowed_FAIL	
 13302                                  	
 13303                                  	;LES	BP,[CS:THISDPB]
 13304 00001C30 26C42E[8A05]            	les	bp,[es:THISDPB]
 13305                                  	
 13306 00001C35 BF0100                  	MOV	DI,1			; Fake some registers
 13307 00001C38 89F9                    	MOV	CX,DI
 13308                                  	;mov	dx,[es:bp+0Bh]
 13309 00001C3A 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 13310 00001C3E E8E336                  	call	HARDERR
 13311 00001C41 F9                      	STC
 13312 00001C42 C3                      	retn
 13313                                  
 13314                                  ;============================================================================
 13315                                  ; FCBIO2.ASM, MSDOS 6.0, 1991
 13316                                  ;============================================================================
 13317                                  ; 21/07/2018 - Retro DOS v3.0
 13318                                  ; 17/05/2019 - Retro DOS v4.0
 13319                                  
 13320                                  ;**	FCBIO2.ASM - Ancient 1.0 1.1 FCB system calls
 13321                                  ;
 13322                                  ;	GetRR
 13323                                  ;	GetExtent
 13324                                  ;	SetExtent
 13325                                  ;	GetExtended
 13326                                  ;	GetRecSize
 13327                                  ;	FCBIO
 13328                                  ;	$FCB_OPEN
 13329                                  ;	$FCB_CREATE
 13330                                  ;	$FCB_RANDOM_WRITE_BLOCK
 13331                                  ;	$FCB_RANDOM_READ_BLOCK
 13332                                  ;	$FCB_SEQ_READ
 13333                                  ;	$FCB_SEQ_WRITE
 13334                                  ;	$FCB_RANDOM_READ
 13335                                  ;	$FCB_RANDOM_WRITE
 13336                                  ;
 13337                                  ;	Revision history:
 13338                                  ;
 13339                                  ;		Created: ARR 4 April 1983
 13340                                  ;			 MZ  6 June  1983 completion of functions
 13341                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 13342                                  ;				  times.  Change so successive closes work by
 13343                                  ;				  always returning OK.	Also, detect I/O to
 13344                                  ;				  already closed FCB and return EOF.
 13345                                  ;		 MZ 16 Jan   1984 More braindamage.  Need to separate info
 13346                                  ;				  out of sft into FCB for reconnection
 13347                                  ;
 13348                                  ;	    A000   version 4.00	Jan. 1988
 13349                                  
 13350                                  ; Defintions for FCBOp flags
 13351                                  
 13352                                  RANDOM	equ 2				; random operation
 13353                                  FCBREAD equ 4				; doing a read
 13354                                  BLOCK	equ 8				; doing a block I/O
 13355                                  
 13356                                  ;Break <GetRR - return the random record field in DX:AX>
 13357                                  ;---------------------------------------------------------------------------
 13358                                  ;
 13359                                  ;   GetRR - correctly load DX:AX with the random record field (3 or 4 bytes)
 13360                                  ;	from the FCB pointed to by DS:SI
 13361                                  ;
 13362                                  ;   Inputs:	DS:SI point to an FCB
 13363                                  ;		BX has record size
 13364                                  ;   Outputs:	DX:AX contain the contents of the random record field
 13365                                  ;   Registers modified: none
 13366                                  ;---------------------------------------------------------------------------
 13367                                  
 13368                                  GetRR:
 13369                                  	;mov	ax,[si+21h]
 13370 00001C43 8B4421                  	MOV	AX,[SI+SYS_FCB.RR]	; get low order part
 13371                                  	;mov	dx,[si+23h]
 13372 00001C46 8B5423                  	MOV	DX,[SI+SYS_FCB.RR+2]	; get high order part
 13373 00001C49 83FB40                  	CMP	BX,64			; ignore MSB of RR if recsiz > 64
 13374 00001C4C 7202                    	JB	short GetRRBye
 13375 00001C4E 30F6                    	XOR	DH,DH
 13376                                  GetRRBye:
 13377 00001C50 C3                      	retn
 13378                                  
 13379                                  ;Break <GetExtent - retrieve next location for sequential IO>
 13380                                  ;---------------------------------------------------------------------------
 13381                                  ;
 13382                                  ;   GetExtent - Construct the next record to perform I/O from the EXTENT and
 13383                                  ;	NR fields in the FCB.
 13384                                  ;
 13385                                  ;   Inputs:	DS:SI - point to FCB
 13386                                  ;   Outputs:	DX:AX contain the contents of the random record field
 13387                                  ;   Registers modified: none
 13388                                  ;---------------------------------------------------------------------------
 13389                                  
 13390                                  GetExtent:
 13391                                  	;mov	al,[si+20h]
 13392 00001C51 8A4420                  	MOV	AL,[SI+SYS_FCB.NR]	; get low order piece
 13393                                  	;mov	dx,[si+0Ch]
 13394 00001C54 8B540C                  	MOV	DX,[SI+SYS_FCB.EXTENT]	; get high order piece
 13395 00001C57 D0E0                    	SHL	AL,1
 13396 00001C59 D1EA                    	SHR	DX,1
 13397 00001C5B D0D8                    	RCR	AL,1	; move low order bit of DL to high order of AH
 13398 00001C5D 88D4                    	MOV	AH,DL
 13399 00001C5F 88F2                    	MOV	DL,DH
 13400 00001C61 30F6                    	XOR	DH,DH
 13401 00001C63 C3                      	retn
 13402                                  
 13403                                  ;Break <SetExtent - update the extent/NR field>
 13404                                  ;---------------------------------------------------------------------------
 13405                                  ;
 13406                                  ;   SetExtent - change the position of an FCB by filling in the extent/NR
 13407                                  ;	fields
 13408                                  ;
 13409                                  ;   Inputs:	DS:SI point to FCB
 13410                                  ;		DX:AX is a record location in file
 13411                                  ;   Outputs:	Extent/NR fields are filled in
 13412                                  ;   Registers modified: CX
 13413                                  ;---------------------------------------------------------------------------
 13414                                  
 13415                                  SetExtent:
 13416 00001C64 50                      	push	ax
 13417 00001C65 52                      	push	dx
 13418 00001C66 89C1                    	MOV	CX,AX
 13419 00001C68 247F                    	AND	AL,7FH			; next rec field
 13420                                  	;mov	[si+20h],al
 13421 00001C6A 884420                  	MOV	[SI+SYS_FCB.NR],AL
 13422 00001C6D 80E180                  	AND	CL,80H			; save upper bit
 13423 00001C70 D1E1                    	SHL	CX,1
 13424 00001C72 D1D2                    	RCL	DX,1			; move high bit of CX to low bit of DX
 13425 00001C74 88E8                    	MOV	AL,CH
 13426 00001C76 88D4                    	MOV	AH,DL
 13427                                  	;mov	[si+0Ch], ax
 13428 00001C78 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; all done
 13429 00001C7B 5A                      	pop	dx
 13430 00001C7C 58                      	pop	ax
 13431 00001C7D C3                      	retn
 13432                                  
 13433                                  ;Break <GetExtended - find FCB in potential extended fcb>
 13434                                  ;---------------------------------------------------------------------------
 13435                                  ;
 13436                                  ;   GetExtended - Make DS:SI point to FCB from DS:DX
 13437                                  ;
 13438                                  ;   Inputs:	DS:DX point to a possible extended FCB
 13439                                  ;   Outputs:	DS:SI point to the FCB part
 13440                                  ;		zeroflag set if not extended fcb
 13441                                  ;   Registers modified: SI
 13442                                  ;---------------------------------------------------------------------------
 13443                                  
 13444                                  GetExtended:
 13445 00001C7E 89D6                    	MOV	SI,DX			; point to Something
 13446 00001C80 803CFF                  	CMP	BYTE [SI],-1		; look for extention
 13447 00001C83 7503                    	JNZ	short GetBye		; not there
 13448 00001C85 83C607                  	ADD	SI,7			; point to FCB
 13449                                  GetBye:
 13450 00001C88 39D6                    	CMP	SI,DX			; set condition codes
 13451                                  getextd_retn:
 13452 00001C8A C3                      	retn
 13453                                  
 13454                                  ;Break <GetRecSize - return in BX the FCB record size>
 13455                                  ;---------------------------------------------------------------------------
 13456                                  ;
 13457                                  ;   GetRecSize - return in BX the record size from the FCB at DS:SI
 13458                                  ;
 13459                                  ;   Inputs:	DS:SI point to a non-extended FCB
 13460                                  ;   Outputs:	BX contains the record size
 13461                                  ;   Registers modified: None
 13462                                  ;---------------------------------------------------------------------------
 13463                                  
 13464                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13465                                  GetRecSize:
 13466                                  	;mov	bx,[si+0Eh]
 13467 00001C8B 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 13468 00001C8E 09DB                    	OR	BX,BX			; is it nul?
 13469 00001C90 74F8                    	jz	short getextd_retn
 13470 00001C92 BB8000                  	MOV	BX,128			; use default size
 13471                                  	;mov	[si+0Eh],bx
 13472 00001C95 895C0E                  	MOV	[SI+SYS_FCB.RECSIZ],BX	; stuff it back
 13473 00001C98 C3                      	retn
 13474                                  
 13475                                  ;BREAK <FCBIO - do internal FCB I/O>
 13476                                  ;---------------------------------------------------------------------------
 13477                                  ;
 13478                                  ;   FCBIO - look at FCBOP and merge all FCB operations into a single routine.
 13479                                  ;
 13480                                  ;   Inputs:	FCBOP flags which operations need to be performed
 13481                                  ;		DS:DX point to FCB
 13482                                  ;		CX may have count of number of records to xfer
 13483                                  ;   Outputs:	AL has error code
 13484                                  ;   Registers modified: all
 13485                                  ;---------------------------------------------------------------------------
 13486                                  
 13487                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13488                                  	; DOSCODE:5B17h (MSDOS 5.0 MSDOS.SYS)
 13489                                  FCBIO:
 13490                                  
 13491                                  FEOF	EQU	1
 13492                                  FTRIM	EQU	2
 13493                                  
 13494                                  %define	FCBErr	byte [bp-1]  ; byte	
 13495                                  %define	cRec	word [bp-3]  ; word	
 13496                                  ;%define RecPos	word [bp-7]  ; dword
 13497                                  %define RecPosL	word [bp-7]  ; word
 13498                                  %define RecPosH	word [bp-5]  ; word
 13499                                  %define	RecSize	word [bp-9]  ; word
 13500                                  ;%define bPos	word [bp-13] ; dword
 13501                                  %define bPosL	word [bp-13] ; word
 13502                                  %define bPosH	word [bp-11] ; word
 13503                                  %define cByte	word [bp-15] ; word	
 13504                                  %define cResult word [bp-17] ; word	
 13505                                  %define	cRecRes	word [bp-19] ; word
 13506                                  %define	FCBOp	byte [bp-20] ; byte
 13507                                  
 13508                                  	;Enter
 13509                                  
 13510 00001C99 55                      	push	bp
 13511 00001C9A 89E5                    	mov	bp,sp
 13512 00001C9C 83EC14                  	sub	sp,20
 13513                                  	;mov	[bp-20],al
 13514 00001C9F 8846EC                  	MOV	FCBOp,AL
 13515                                  	;mov	byte [bp-1],0
 13516 00001CA2 C646FF00                	MOV	FCBErr,0		;   FCBErr = 0;
 13517 00001CA6 E8D5FF                  	call	GetExtended		;   FCB = GetExtended ();
 13518                                  	;test	byte [bp-20],8
 13519 00001CA9 F646EC08                	TEST	FCBOp,BLOCK		;   if ((OP&BLOCK) == 0)
 13520 00001CAD 7503                    	JNZ	short GetPos
 13521 00001CAF B90100                  	MOV	CX,1			;	cRec = 1;
 13522                                  GetPos:
 13523                                  	;mov	[bp-3],cx
 13524 00001CB2 894EFD                  	MOV	cRec,CX 		;*Tail coalesce
 13525 00001CB5 E899FF                  	call	GetExtent		;   RecPos = GetExtent ();
 13526 00001CB8 E8D0FF                  	call	GetRecSize		;   RecSize = GetRecSize ();
 13527                                  	;mov	[bp-9],bx
 13528 00001CBB 895EF7                  	MOV	RecSize,BX
 13529                                  	;test	byte [bp-20],2
 13530 00001CBE F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&RANDOM) <> 0)
 13531 00001CC2 7403                    	JZ	short GetRec
 13532 00001CC4 E87CFF                  	call	GetRR			;	RecPos = GetRR ();
 13533                                  GetRec:
 13534                                  	;mov	[bp-7],ax
 13535 00001CC7 8946F9                  	MOV	RecPosL,AX		;*Tail coalesce
 13536                                  	;mov	[bp-5],dx
 13537 00001CCA 8956FB                  	MOV	RecPosH,DX
 13538 00001CCD E894FF                  	call	SetExtent		;   SetExtent (RecPos);
 13539                                  	;mov	ax,[bp-5]
 13540 00001CD0 8B46FB                  	MOV	AX,RecPosH		;   bPos = RecPos * RecSize;
 13541 00001CD3 F7E3                    	MUL	BX
 13542 00001CD5 89C7                    	MOV	DI,AX
 13543                                  	;mov	ax,[bp-7]
 13544 00001CD7 8B46F9                  	MOV	AX,RecPosL
 13545 00001CDA F7E3                    	MUL	BX
 13546 00001CDC 01FA                    	ADD	DX,DI
 13547                                  	;mov	[bp-13],ax
 13548 00001CDE 8946F3                  	MOV	bPosL,AX
 13549                                  	;mov	[bp-11],dx
 13550 00001CE1 8956F5                  	MOV	bPosH,DX
 13551                                  	;mov	ax,[bp-3]
 13552 00001CE4 8B46FD                  	MOV	AX,cRec 		;   cByte = cRec * RecSize;
 13553 00001CE7 F7E3                    	MUL	BX
 13554                                  	;mov	[bp-15],ax
 13555 00001CE9 8946F1                  	MOV	cByte,AX
 13556                                  
 13557                                  ;hkn; 	SS override
 13558 00001CEC 360306[2C03]            	ADD	AX,[SS:DMAADD]		;   if (cByte+DMA > 64K) {
 13559 00001CF1 83D200                  	ADC	DX,0
 13560 00001CF4 7419                    	JZ	short DoOper
 13561                                  	;mov	byte [bp-1],2
 13562 00001CF6 C646FF02                	MOV	FCBErr,FTRIM		;	FCBErr = FTRIM;
 13563                                  
 13564                                  ;hkn; 	SS override
 13565 00001CFA 36A1[2C03]              	MOV	AX,[SS:DMAADD]		;	cRec = (64K-DMA)/RecSize;
 13566 00001CFE F7D8                    	NEG	AX
 13567 00001D00 7501                    	JNZ	short DoDiv
 13568 00001D02 48                      	DEC	AX
 13569                                  DoDiv:
 13570 00001D03 31D2                    	XOR	DX,DX
 13571 00001D05 F7F3                    	DIV	BX
 13572                                  	;mov	[bp-3],ax
 13573 00001D07 8946FD                  	MOV	cRec,AX
 13574 00001D0A F7E3                    	MUL	BX			;	cByte = cRec * RecSize;
 13575                                  	;mov	[bp-15],ax
 13576 00001D0C 8946F1                  	MOV	cByte,AX		;	}
 13577                                  DoOper:
 13578 00001D0F 31DB                    	XOR	BX,BX
 13579                                  	;mov	[bp-17],bx
 13580 00001D11 895EEF                  	MOV	cResult,BX		;   cResult = 0;
 13581                                  	;cmp	[bp-15],bx
 13582 00001D14 395EF1                  	CMP	cByte,BX		;   if (cByte <> 0 ||
 13583 00001D17 7506                    	JNZ	short DoGetExt
 13584                                  	;test	byte [bp-1],2
 13585 00001D19 F646FF02                	TEST	FCBErr,FTRIM		;	(FCBErr&FTRIM) == 0) {
 13586                                  	;JZ	short DoGetExt
 13587                                  	;JMP	short SkipOp
 13588                                  	; 16/12/2022
 13589 00001D1D 7576                    	jnz	short SkipOp
 13590                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13591                                  	;JZ	short DoGetExt
 13592                                  	;JMP	short SkipOp
 13593                                  DoGetExt:
 13594 00001D1F E8CAFE                  	call	SFTFromFCB		;	if (!SFTFromFCB (SFT,FCB))
 13595 00001D22 730F                    	JNC	short ContinueOp
 13596                                  FCBDeath:
 13597 00001D24 E82FE9                  	call	FCB_RET_ERR		; signal error, map for extended
 13598                                  	;mov	word [bp-19],0
 13599 00001D27 C746ED0000              	MOV	cRecRes,0		; no bytes transferred
 13600                                  	;mov	byte [bp-1],1
 13601 00001D2C C646FF01                	MOV	FCBErr,FEOF		;	    return FTRIM;
 13602 00001D30 E9EF00                  	JMP	FCBSave 		; bam!
 13603                                  ContinueOp:
 13604                                  	;mov	ax,[si+10h]
 13605 00001D33 8B4410                  	MOV	AX,[SI+SYS_FCB.FILSIZ]
 13606                                  	;mov	[es:di+11h],ax
 13607 00001D36 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 13608                                  	;mov	ax,[si+12h]
 13609 00001D3A 8B4412                  	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 13610                                  	;mov	[es:di+13h],ax
 13611 00001D3D 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 13612                                  	;mov	ax,[bp-13]
 13613 00001D41 8B46F3                  	MOV	AX,bPosL
 13614                                  	;mov	dx,[bp-11]
 13615 00001D44 8B56F5                  	MOV	DX,bPosH
 13616                                  	;mov	[es:di+15h],ax
 13617 00001D47 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 13618                                  	;xchg	dx,[es:di+17h]
 13619 00001D4B 26875517                	XCHG	[ES:DI+SF_ENTRY.sf_position+2],DX
 13620 00001D4F 52                      	PUSH	DX			; save away Open age.
 13621                                  	;mov	cx,[bp-15]
 13622 00001D50 8B4EF1                  	MOV	CX,cByte		;	cResult =
 13623                                  
 13624                                  ;hkn; DOS_Read is in DOSCODE
 13625 00001D53 BF[FB32]                	MOV	DI,DOS_READ		;	    *(OP&FCBRead ? DOS_Read
 13626                                  	;test	byte [bp-20],4
 13627 00001D56 F646EC04                	TEST	FCBOp,FCBREAD		;		 : DOS_Write)(cRec);
 13628 00001D5A 7503                    	JNZ	short DoContext
 13629                                  
 13630                                  ;hkn; DOS_Write is in DOSCODE
 13631 00001D5C BF[2435]                	MOV	DI,DOS_WRITE
 13632                                  DoContext:
 13633 00001D5F 55                      	push	bp
 13634 00001D60 1E                      	push	ds
 13635 00001D61 56                      	push	si
 13636                                  
 13637                                  ;hkn; SS is DOSDATA
 13638 00001D62 16                      	push	ss
 13639 00001D63 1F                      	pop	ds
 13640                                  
 13641                                  ;; Fix for disk full
 13642 00001D64 FFD7                    	CALL	DI	; DOS_READ or DOS_WRITE	
 13643                                  	
 13644 00001D66 5E                      	pop	si
 13645 00001D67 1F                      	pop	ds
 13646 00001D68 5D                      	pop	bp
 13647 00001D69 72B9                    	JC	short FCBDeath
 13648                                  	
 13649 00001D6B 36803E[0B06]00          	CMP	BYTE [SS:DISK_FULL],0	; treat disk full as error
 13650 00001D71 740A                    	JZ	short NODSKFULL
 13651 00001D73 36C606[0B06]00          	MOV	BYTE [SS:DISK_FULL],0	; clear the flag
 13652                                  	;mov	byte [bp-1],1 
 13653 00001D79 C646FF01                	MOV	FCBErr,FEOF		; set disk full flag
 13654                                  NODSKFULL:
 13655                                  ;; Fix for disk full
 13656                                  	;mov	[bp-17],cx
 13657 00001D7D 894EEF                  	MOV	cResult,CX
 13658 00001D80 E827FB                  	call	SaveFCBInfo		;	SaveFCBInfo (FCB);
 13659                                  	;pop	word [es:di+17h]	
 13660 00001D83 268F4517                	POP	WORD [ES:DI+SF_ENTRY.sf_position+2] ; restore open age
 13661                                  			       ; (sf_OpenAge = SF_ENTRY.sf_position+2)			
 13662                                  	;mov	ax,[es:di+11h]
 13663 00001D87 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 13664                                  	;mov	[si+10h],ax
 13665 00001D8B 894410                  	MOV	[SI+SYS_FCB.FILSIZ],AX
 13666                                  	;mov	ax,[es:di+13h]
 13667 00001D8E 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 13668                                  	;mov	[si+12h],ax
 13669 00001D92 894412                  	MOV	[SI+SYS_FCB.FILSIZ+2],AX
 13670                                  					;	}
 13671                                  SkipOp:
 13672                                  	;mov	ax,[bp-17]
 13673 00001D95 8B46EF                  	MOV	AX,cResult		;   cRecRes = cResult / RecSize;
 13674 00001D98 31D2                    	XOR	DX,DX
 13675                                  	;div	word [bp-9]
 13676 00001D9A F776F7                  	DIV	RecSize
 13677                                  	;mov	[bp-19],ax
 13678 00001D9D 8946ED                  	MOV	cRecRes,AX
 13679                                  	;add	[bp-7],ax
 13680 00001DA0 0146F9                  	ADD	RecPosL,AX		;   RecPos += cRecResult;
 13681                                  	;adc	word [bp-5],0
 13682 00001DA3 8356FB00                	ADC	RecPosH,0
 13683                                  
 13684                                  ; If we have not gotten the expected number of records, we signal an EOF
 13685                                  ; condition. On input, this is EOF. On output this is usually disk full.
 13686                                  ; BUT... Under 2.0 and before, all device output IGNORED this condition. So
 13687                                  ; do we.
 13688                                  
 13689                                  	;cmp	ax,[bp-3]
 13690 00001DA7 3B46FD                  	CMP	AX,cRec 		;   if (cRecRes <> cRec)
 13691 00001DAA 7411                    	JZ	short TryBlank
 13692                                  	;test	byte [bp-20],4
 13693 00001DAC F646EC04                	TEST	FCBOp,FCBREAD		;	if (OP&FCBRead || !DEVICE)
 13694 00001DB0 7507                    	JNZ	short SetEOF
 13695                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13696                                  	; MSDOS 3.3
 13697                                  	;;test	word [es:di+5],80h
 13698                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 13699                                  	;JNZ	short TryBlank
 13700                                  	; MSDOS 5.0 & MSDOS 6.0
 13701                                  	;test	byte [es:di+5],80h
 13702 00001DB2 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 13703 00001DB7 7504                    	jnz	short TryBlank
 13704                                  
 13705                                  SetEOF:
 13706                                  	;mov	byte [bp-1],1
 13707 00001DB9 C646FF01                	MOV	FCBErr,FEOF		;	FCBErr = FEOF;
 13708                                  TryBlank:				;
 13709 00001DBD 09D2                    	OR	DX,DX			;   if (cResult%RecSize <> 0) {
 13710 00001DBF 7426                    	JZ	short SetExt
 13711                                  	;add	word [bp-7],1
 13712 00001DC1 8346F901                	ADD	RecPosL,1		;	RecPos++;
 13713                                  	;adc	word [bp-5],0
 13714 00001DC5 8356FB00                	ADC	RecPosH,0
 13715                                  	;test	byte [bp-20],4
 13716 00001DC9 F646EC04                	TEST	FCBOp,FCBREAD		;	if(OP&FCBRead) <> 0) {
 13717 00001DCD 7418                    	JZ	short SetExt
 13718                                  	;inc	word [bp-19]
 13719 00001DCF FF46ED                  	INC	cRecRes 		;	cRecRes++;
 13720                                  	;mov	byte [bp-1],3
 13721 00001DD2 C646FF03                	MOV	FCBErr,FTRIM+FEOF	;	FCBErr = FTRIM | FEOF;
 13722                                  	;mov	cx,[bp-9]
 13723 00001DD6 8B4EF7                  	MOV	CX,RecSize		;	Blank (RecSize-cResult%RecSize,
 13724 00001DD9 29D1                    	SUB	CX,DX			;	       DMA+cResult);
 13725 00001DDB 30C0                    	XOR	AL,AL
 13726                                  ;hkn; 	SS override
 13727 00001DDD 36C43E[2C03]            	les     di,[ss:DMAADD]
 13728                                  	;add	di,[bp-17]
 13729 00001DE2 037EEF                  	ADD	DI,cResult
 13730 00001DE5 F3AA                    	REP	STOSB			;   }	}
 13731                                  SetExt:
 13732                                  	;mov	dx,[bp-5]
 13733 00001DE7 8B56FB                  	MOV	DX,RecPosH
 13734                                  	;mov	ax,[bp-7]
 13735 00001DEA 8B46F9                  	MOV	AX,RecPosL
 13736                                  	;test	byte [bp-20],2
 13737 00001DED F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&Random) == 0 ||
 13738 00001DF1 7406                    	JZ	short DoSetExt
 13739                                  	;test	byte [bp-20],8
 13740 00001DF3 F646EC08                	TEST	FCBOp,BLOCK		;	(OP&BLOCK) <> 0)
 13741 00001DF7 7403                    	JZ	short TrySetRR
 13742                                  DoSetExt:
 13743 00001DF9 E868FE                  	call	SetExtent		;	SetExtent (RecPos, FCB);
 13744                                  TrySetRR:
 13745                                  	;test	byte [bp-20],8
 13746 00001DFC F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 13747 00001E00 740F                    	JZ	short TryReturn
 13748                                  	;mov	[si+21h],ax
 13749 00001E02 894421                  	MOV	[SI+SYS_FCB.RR],AX	;	FCB->RR = RecPos;
 13750                                  	;mov	[si+23h],dl
 13751 00001E05 885423                  	MOV	[SI+SYS_FCB.RR+2],DL
 13752                                  	;cmp	word [si+0Eh],64
 13753 00001E08 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 13754 00001E0C 7303                    	JAE	short TryReturn
 13755                                  	;mov	[si+24h],dh
 13756 00001E0E 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 13757                                  TryReturn: 
 13758                                  	;test	byte [bp-20],4
 13759 00001E11 F646EC04                	TEST	FCBOp,FCBREAD		;   if (!(FCBOP & FCBREAD)) {
 13760 00001E15 750B                    	JNZ	short FCBSave
 13761 00001E17 1E                      	push	ds			;	FCB->FDate = date;
 13762 00001E18 E8D5EC                  	call	DATE16			;	FCB->FTime = time;
 13763 00001E1B 1F                      	pop	ds
 13764                                  	;mov	[si+14h],ax
 13765 00001E1C 894414                  	MOV	[SI+SYS_FCB.FDATE],AX
 13766                                  	;mov	[si+16h],dx
 13767 00001E1F 895416                  	MOV	[SI+SYS_FCB.FTIME],DX	;	}
 13768                                  FCBSave: 
 13769                                  	;test	byte [bp-20],8
 13770 00001E22 F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 13771 00001E26 7409                    	jz	short DoReturn
 13772                                  	;mov	cx,[bp-19]
 13773 00001E28 8B4EED                  	MOV	CX,cRecRes		;	user_CX = cRecRes;
 13774 00001E2B E853E6                  	call    Get_User_Stack
 13775                                  	;mov	[si+4],cx
 13776 00001E2E 894C04                  	MOV	[SI+user_env.user_CX],CX
 13777                                  DoReturn:
 13778                                  	;mov	al,[bp-1]
 13779 00001E31 8A46FF                  	MOV	AL,FCBErr		;   return (FCBERR);
 13780                                  	;Leave	
 13781 00001E34 89EC                    	mov     sp,bp
 13782 00001E36 5D                      	pop     bp
 13783 00001E37 C3                      	retn
 13784                                  
 13785                                  ; 22/07/2018 - Retro DOS v3.0
 13786                                  
 13787                                  ;Break <$FCB_Open - open an old-style FCB>
 13788                                  ;---------------------------------------------------------------------------
 13789                                  ;
 13790                                  ;   $FCB_Open - CPM compatability file open. The user has formatted an FCB
 13791                                  ;	for us and asked to have the rest filled in.
 13792                                  ;
 13793                                  ;   Inputs:	DS:DX point to an unopenned FCB
 13794                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 13795                                  ;		FCB has the following fields filled in:
 13796                                  ;		    Time/Date Extent/NR Size
 13797                                  ;---------------------------------------------------------------------------
 13798                                  
 13799                                  _$FCB_OPEN:			; System call 15
 13800                                  
 13801 00001E38 B80200                  	MOV	AX,SHARING_COMPAT+open_for_both
 13802                                  
 13803                                  ;hkn; DOS_Open is in DOSCODE
 13804 00001E3B B9[9B2B]                	MOV	CX,DOS_OPEN
 13805                                  
 13806                                  ; The following is common code for Creation and openning of FCBs. AX is
 13807                                  ; either attributes (for create) or open mode (for open)... DS:DX points to
 13808                                  ; the FCB
 13809                                  
 13810                                  DoAccess:
 13811 00001E3E 1E                      	push	ds
 13812 00001E3F 52                      	push	dx
 13813 00001E40 51                      	push	cx
 13814 00001E41 50                      	push	ax			; save FCB pointer away
 13815                                  
 13816                                  ;hkn; 	OpenBuf is in DOSDATA
 13817 00001E42 BF[BE03]                	MOV	DI,OPENBUF
 13818 00001E45 E8E44C                  	call	TransFCB		; crunch the fcb
 13819 00001E48 58                      	pop	ax
 13820 00001E49 59                      	pop	cx
 13821 00001E4A 5A                      	pop	dx
 13822 00001E4B 1F                      	pop	ds			; get fcb
 13823 00001E4C 7303                    	JNC	short FindFCB		; everything seems ok
 13824                                  FCBOpenErr:
 13825                                  	; AL has error code
 13826 00001E4E E905E8                  	jmp	FCB_RET_ERR
 13827                                  FindFCB:
 13828 00001E51 E82AFE                  	call	GetExtended		; DS:SI will point to FCB
 13829                                  
 13830                                  	; 17/05/2019 - Retro DOS v4.0
 13831                                  
 13832                                  	; MSDOS 3.3
 13833                                  	;call	LRUFCB
 13834                                  	;jc	short HardMessage
 13835                                  
 13836                                  	; MSDOS 6.0
 13837 00001E54 50                      	push	ax
 13838 00001E55 B001                    	mov	al,1			;indicate Open/Create operation
 13839 00001E57 E820FB                  	call	LRUFCB			; get a sft entry (no error)
 13840 00001E5A 58                      	pop	ax
 13841 00001E5B 722A                    	jc	short HardMessage
 13842                                  	
 13843                                  	;mov	word [es:di+2],8000h
 13844 00001E5D 26C745020080            	mov	word [es:di+SF_ENTRY.sf_mode],sf_isFCB
 13845 00001E63 1E                      	push	ds
 13846 00001E64 56                      	push	si	
 13847 00001E65 53                      	push	bx			; save fcb pointer
 13848 00001E66 89CE                    	MOV	SI,CX
 13849                                  
 13850                                  ;hkn; SS is DOSDATA
 13851 00001E68 16                      	push	ss
 13852 00001E69 1F                      	pop	ds			    ; let DOS_Open see variables
 13853 00001E6A FFD6                    	CALL	SI ; DOS_OPEN or DOS_CREATE ; go open the file
 13854 00001E6C 5B                      	pop	bx
 13855 00001E6D 5E                      	pop	si
 13856 00001E6E 1F                      	pop	ds			; get fcb
 13857                                  
 13858                                  ;hkn; SS override
 13859 00001E6F 36C43E[9E05]            	LES	DI,[SS:THISSFT]		; get sf pointer
 13860 00001E74 7318                    	JNC	short FCBOK		; operation succeeded
 13861                                  failopen:
 13862 00001E76 50                      	PUSH	AX
 13863 00001E77 B052                    	MOV	AL,"R"	; 52h		; clear out field (free sft)
 13864 00001E79 E8E5FC                  	call	BlastSFT
 13865 00001E7C 58                      	POP	AX
 13866                                  	;cmp	ax,4
 13867 00001E7D 83F804                  	CMP	AX,error_too_many_open_files
 13868 00001E80 7405                    	JZ	short HardMessage
 13869                                  	;cmp	ax,24h
 13870 00001E82 83F824                  	CMP	AX,error_sharing_buffer_exceeded
 13871 00001E85 7505                    	jnz	short DeadFCB
 13872                                  HardMessage:
 13873 00001E87 50                      	PUSH	AX
 13874 00001E88 E897FD                  	call	FCBHardErr
 13875 00001E8B 58                      	POP	AX
 13876                                  DeadFCB:
 13877                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13878                                  	;jmp	FCB_RET_ERR
 13879 00001E8C EBC0                    	jmp	short FCBOpenErr
 13880                                  FCBOK:
 13881                                  	; MSDOS 6.0
 13882 00001E8E E8D5F3                  	call	IsSFTNet		;AN007;F.C. >32mb  Non Fat file?
 13883 00001E91 750F                    	JNZ	short FCBOK2		;AN007;F.C. >32mb  yes
 13884 00001E93 E8C254                  	call	CheckShare		;AN000;F.C. >32mb  share around?
 13885 00001E96 750A                    	JNZ	short FCBOK2		;AN000;F.C. >32mb  yes
 13886                                  ;SR;
 13887                                  ; If we reach here, we know we have got a local SFT. Let's update the 
 13888                                  ; LocalSFT variable to reflect this.
 13889                                  
 13890 00001E98 36893E[4410]            	mov	[ss:LocalSFT],di
 13891 00001E9D 368C06[4610]            	mov	[ss:LocalSFT+2],es; Store the SFT address
 13892                                  ;;SR;
 13893                                  ;; The check below is not valid anymore since we regenerate for media > 32M.
 13894                                  ;;
 13895                                  ;;	CMP	WORD [ES:DI+SF_ENTRY.sf_dirsec+2],0 
 13896                                  ;;					       ;AN000;F.C. >32mb  if dirsec >32mb
 13897                                  ;;	JZ	short FCBOK2		       ;AN000;F.C. >32mb    then error
 13898                                  ;;	MOV	AX,error_sys_comp_not_loaded   ;AN000;F.C. >32mb
 13899                                  ;;	JMP	short failopen		       ;AN000;F.C. >32mb
 13900                                  
 13901                                  FCBOK2:
 13902                                  	; MSDOS 6.0 (& MSDOS 3.3)
 13903 00001EA2 26FF05                  	inc	word [es:di]
 13904                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count] ; increment reference count
 13905 00001EA5 E802FA                  	call	SaveFCBInfo
 13906                                  	; MSDOS 3.3
 13907                                  	;call	SetOpenAge
 13908                                  	; MSDOS 6.0 (& MSDOS 3.3)
 13909                                  	;test	word [es:di+5],80h
 13910                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 13911 00001EA8 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device  ; 28/07/2019
 13912 00001EAD 7508                    	JNZ	short FCBNoDrive	; do not munge drive on devices
 13913 00001EAF 8A04                    	MOV	AL,[SI]			; get drive byte
 13914 00001EB1 E8034C                  	call	GETTHISDRV		; convert
 13915                                  	;INC	AL
 13916                                  	; 17/12/2022
 13917 00001EB4 40                      	inc	ax
 13918 00001EB5 8804                    	MOV	[SI],AL			; stash in good drive letter
 13919                                  FCBNoDrive:
 13920                                  	;mov	word [si+0Eh],128
 13921 00001EB7 C7440E8000              	MOV	word [SI+SYS_FCB.RECSIZ],80h ; stuff in default record size
 13922                                  
 13923                                  	;mov	ax,[es:di+0Dh]
 13924 00001EBC 268B450D                	MOV	AX,[ES:DI+SF_ENTRY.sf_time] ; set time
 13925                                  	;mov	[si+16h],ax
 13926 00001EC0 894416                  	MOV	[SI+SYS_FCB.FTIME],AX
 13927                                  	;mov	ax,[es:di+0Fh]
 13928 00001EC3 268B450F                	MOV	AX,[ES:DI+SF_ENTRY.sf_date] ; set date
 13929                                  	;mov	[si+14h],ax
 13930 00001EC7 894414                  	MOV	[SI+SYS_FCB.FDATE],AX
 13931                                  	;mov	ax,[es:di+11h]
 13932 00001ECA 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size] ; set sizes
 13933                                  	;mov	[si+10h],ax
 13934 00001ECE 894410                  	MOV	[SI+SYS_FCB.FILSIZ],AX
 13935                                  	;mov	ax,[es:di+13h]
 13936 00001ED1 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 13937                                  	;mov	[si+12h],ax
 13938 00001ED5 894412                  	MOV	[SI+SYS_FCB.FILSIZ+2],AX
 13939 00001ED8 31C0                    	XOR	AX,AX			; convenient zero
 13940                                  	;mov	[si+0Ch],ax
 13941 00001EDA 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; point to beginning of file
 13942                                  
 13943                                  ; We must scan the set of FCB SFTs for one that appears to match the current
 13944                                  ; one.	We cheat and use CheckFCB to match the FCBs.
 13945                                  
 13946                                  ;hkn; 	SS override
 13947 00001EDD 36C43E[4000]            	LES	DI,[SS:SFTFCB]		; get the pointer to head of the list
 13948                                  	;mov	ah,[es:di+4]
 13949 00001EE2 268A6504                	MOV	AH,[ES:DI+SFT.SFCount]	; get number of SFTs to scan
 13950                                  OpenScan:
 13951                                  	;cmp	al,[si+18h]
 13952 00001EE6 3A4418                  	CMP	AL,[SI+fcb_sfn]		; don't compare ourselves
 13953 00001EE9 7407                    	JZ	short SkipCheck
 13954 00001EEB 50                      	push	ax			; preserve count
 13955 00001EEC E888FC                  	call	CheckFCB		; do they match
 13956 00001EEF 58                      	pop	ax			; get count back
 13957 00001EF0 7309                    	JNC	short OpenFound		; found a match!
 13958                                  SkipCheck:
 13959 00001EF2 FEC0                    	INC	AL			; advance to next FCB
 13960 00001EF4 38E0                    	CMP	AL,AH			; table full?
 13961 00001EF6 75EE                    	JNZ	short OpenScan		; no, go for more
 13962                                  OpenDone:
 13963 00001EF8 30C0                    	xor	al,al			; return success
 13964 00001EFA C3                      	retn
 13965                                  
 13966                                  ; The SFT at ES:DI is the one that is already in use for this FCB. We set the
 13967                                  ; FCB to use this one. We increment its ref count. We do NOT close it at all.
 13968                                  ; Consider:
 13969                                  ;
 13970                                  ;   open (foo)	delete (foo) open (bar)
 13971                                  ;
 13972                                  ; This causes us to recycle (potentially) bar through the same local SFT as
 13973                                  ; foo even though foo is no longer needed; this is due to the server closing
 13974                                  ; foo for us when we delete it. Unfortunately, we cannot see this closure.
 13975                                  ; If we were to CLOSE bar, the server would then close the only reference to
 13976                                  ; bar and subsequent I/O would be lost to the redirector.
 13977                                  ;
 13978                                  ; This gets solved by NOT closing the sft, but zeroing the ref count
 13979                                  ; (effectively freeing the SFT) and informing the sharer (if relevant) that
 13980                                  ; the SFT is no longer in use. Note that the SHARER MUST keep its ref counts
 13981                                  ; around. This will allow us to access the same file through multiple network
 13982                                  ; connections and NOT prematurely terminate when the ref count on one
 13983                                  ; connection goes to zero.
 13984                                  
 13985                                  OpenFound:
 13986                                  	;mov	[si+18h],al
 13987 00001EFB 884418                  	MOV	[SI+fcb_sfn],AL 	; assign with this
 13988 00001EFE 26FF05                  	inc	word [es:di]
 13989                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 13990                                  					; remember this new invocation
 13991 00001F01 36A1[1000]              	MOV	AX,[SS:FCBLRU]		; update LRU counts
 13992                                  	;mov	[es:di+15h],ax
 13993 00001F05 26894515                	MOV	[ES:DI+sf_LRU],AX
 13994                                  ;
 13995                                  ; We have an FCB sft that is now of no use.  We release sharing info and then
 13996                                  ; blast it to prevent other reuse.
 13997                                  ;
 13998 00001F09 16                      	push	ss
 13999 00001F0A 1F                      	pop	ds
 14000 00001F0B C43E[9E05]              	LES	DI,[THISSFT]
 14001 00001F0F 26FF0D                  	dec	word [es:di]
 14002                                  	;DEC	word [ES:DI+SF_ENTRY.sf_ref_count]
 14003                                  					; free the newly allocated SFT
 14004 00001F12 E87B54                  	call	ShareEnd
 14005 00001F15 B043                    	MOV	AL,'C'	 ; 43h
 14006 00001F17 E847FC                  	call	BlastSFT
 14007 00001F1A EBDC                    	JMP	short OpenDone
 14008                                  
 14009                                  ;BREAK	<$FCB_Create - create a new directory entry>
 14010                                  ;----------------------------------------------------------------------------
 14011                                  ;
 14012                                  ;   $FCB_Create - CPM compatability file create. The user has formatted an
 14013                                  ;	FCB for us and asked to have the rest filled in.
 14014                                  ;
 14015                                  ;   Inputs:	DS:DX point to an unopenned FCB
 14016                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 14017                                  ;		FCB has the following fields filled in:
 14018                                  ;		    Time/Date Extent/NR Size
 14019                                  ;----------------------------------------------------------------------------
 14020                                  
 14021                                  _$FCB_CREATE:		; System call 22
 14022                                  
 14023                                  ;hkn; DOS_Create is in DOSCODE
 14024 00001F1C B9[712A]                	MOV	CX,DOS_CREATE		; routine to call
 14025 00001F1F 31C0                    	XOR	AX,AX			; attributes to create
 14026 00001F21 E85AFD                  	call	GetExtended		; get extended FCB
 14027 00001F24 7403                    	JZ	short DoAccessJ		; not an extended FCB
 14028 00001F26 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 14029                                  DoAccessJ:
 14030 00001F29 E912FF                  	JMP	DoAccess		; do dirty work
 14031                                  
 14032                                  ; 22/07/2018 - Retro DOS v3.0
 14033                                  
 14034                                  ;BREAK <$FCB_Random_write_Block - write a block of records to a file >
 14035                                  ;----------------------------------------------------------------------------
 14036                                  ;
 14037                                  ;   $FCB_Random_Write_Block - retrieve a location from the FCB, seek to it
 14038                                  ;	and write a number of blocks from it.
 14039                                  ;
 14040                                  ;   Inputs:	DS:DX point to an FCB
 14041                                  ;   Outputs:	AL = 0 write was successful and the FCB position is updated
 14042                                  ;		AL <> 0 Not enough room on disk for the output
 14043                                  ;
 14044                                  ;----------------------------------------------------------------------------
 14045                                  
 14046                                  _$FCB_RANDOM_WRITE_BLOCK:
 14047                                  	;mov	AL,0Ah	
 14048 00001F2C B00A                    	MOV	AL,RANDOM+BLOCK
 14049 00001F2E E968FD                  	JMP	FCBIO
 14050                                  
 14051                                  ;BREAK <$FCB_Random_Read_Block - read a block of records to a file >
 14052                                  ;----------------------------------------------------------------------------
 14053                                  ;
 14054                                  ;   $FCB_Random_Read_Block - retrieve a location from the FCB, seek to it
 14055                                  ;	and read a number of blocks from it.
 14056                                  ;
 14057                                  ;   Inputs:	DS:DX point to an FCB
 14058                                  ;   Outputs:	AL = error codes defined above
 14059                                  ;
 14060                                  ;----------------------------------------------------------------------------
 14061                                  
 14062                                  _$FCB_RANDOM_READ_BLOCK:
 14063                                  	;mov	AL,0Eh	
 14064 00001F31 B00E                    	MOV	AL,RANDOM+FCBREAD+BLOCK
 14065 00001F33 E963FD                  	JMP	FCBIO
 14066                                  
 14067                                  ;BREAK <$FCB_Seq_Read - read the next record from a file >
 14068                                  ;----------------------------------------------------------------------------
 14069                                  ;
 14070                                  ;   $FCB_Seq_Read - retrieve the next record from an FCB and read it into
 14071                                  ;	memory
 14072                                  ;
 14073                                  ;   Inputs:	DS:DX point to an FCB
 14074                                  ;   Outputs:	AL = error codes defined above
 14075                                  ;
 14076                                  ;----------------------------------------------------------------------------
 14077                                  
 14078                                  _$FCB_SEQ_READ:
 14079                                  	;mov	AL,4	
 14080 00001F36 B004                    	MOV	AL,FCBREAD
 14081 00001F38 E95EFD                  	JMP	FCBIO
 14082                                  
 14083                                  ;BREAK <$FCB_Seq_Write - write the next record to a file >
 14084                                  ;----------------------------------------------------------------------------
 14085                                  ;
 14086                                  ;   $FCB_Seq_Write - retrieve the next record from an FCB and write it to the
 14087                                  ;	file
 14088                                  ;
 14089                                  ;   Inputs:	DS:DX point to an FCB
 14090                                  ;   Outputs:	AL = error codes defined above
 14091                                  ;
 14092                                  ;----------------------------------------------------------------------------
 14093                                  
 14094                                  _$FCB_SEQ_WRITE:
 14095 00001F3B B000                    	MOV	AL,0
 14096 00001F3D E959FD                  	jmp	FCBIO
 14097                                  
 14098                                  ;BREAK <$FCB_Random_Read - Read a single record from a file >
 14099                                  ;----------------------------------------------------------------------------
 14100                                  ;
 14101                                  ;   $FCB_Random_Read - retrieve a location from the FCB, seek to it and read a
 14102                                  ;	record from it.
 14103                                  ;
 14104                                  ;   Inputs:	DS:DX point to an FCB
 14105                                  ;   Outputs:	AL = error codes defined above
 14106                                  ;
 14107                                  ;----------------------------------------------------------------------------
 14108                                  
 14109                                  _$FCB_RANDOM_READ:
 14110                                  	;mov	AL,6	
 14111 00001F40 B006                    	MOV	AL,RANDOM+FCBREAD
 14112 00001F42 E954FD                  	jmp	FCBIO			; single block
 14113                                  
 14114                                  ;BREAK <$FCB_Random_Write - write a single record to a file >
 14115                                  ;----------------------------------------------------------------------------
 14116                                  ;
 14117                                  ;   $FCB_Random_Write - retrieve a location from the FCB, seek to it and write
 14118                                  ;	a record to it.
 14119                                  ;
 14120                                  ;   Inputs:	DS:DX point to an FCB
 14121                                  ;   Outputs:	AL = error codes defined above
 14122                                  ;
 14123                                  ;----------------------------------------------------------------------------
 14124                                  
 14125                                  _$FCB_RANDOM_WRITE:
 14126                                  	;mov	AL,2	
 14127 00001F45 B002                    	MOV	AL,RANDOM
 14128 00001F47 E94FFD                  	jmp	FCBIO
 14129                                  
 14130                                  ;============================================================================
 14131                                  ; SEARCH.ASM, MSDOS 6.0, 1991
 14132                                  ;============================================================================
 14133                                  ; 22/07/2018 - Retro DOS v3.0
 14134                                  ; 17/05/2019 - Retro DOS v4.0
 14135                                  
 14136                                  ; DOSCODE:5DDFh (MSDOS 6.21, MSDOS.SYS)
 14137                                  
 14138                                  ; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14139                                  ; DOSCODE:5DCBh (MSDOS 5.0, MSDOS.SYS)
 14140                                  
 14141                                  ;**	Search.asm
 14142                                  ;----------------------------------------------------------------------------
 14143                                  ;	Directory search system calls.
 14144                                  ;	These will be passed direct text of the pathname from the user. 
 14145                                  ;	They will need to be passed through the macro expander prior to
 14146                                  ;	being sent through the low-level stuff. 
 14147                                  ;	I/O specs are defined in DISPATCH. The system calls are:
 14148                                  ;
 14149                                  ;	$Dir_Search_First	  written
 14150                                  ;	$Dir_Search_Next	  written
 14151                                  ;	$Find_First	  written
 14152                                  ;	$Find_Next		  written
 14153                                  ;	PackName		  written
 14154                                  ;
 14155                                  ;	Modification history:
 14156                                  ;
 14157                                  ;	  Created: ARR 4 April 1983
 14158                                  
 14159                                  ;----------------------------------------------------------------------------
 14160                                  ; Procedure Name : $DIR_SEARCH_FIRST
 14161                                  ;
 14162                                  ; Inputs:
 14163                                  ;	DS:DX Points to unopenned FCB
 14164                                  ; Function:
 14165                                  ;	Directory is searched for first matching entry and the directory
 14166                                  ;	entry is loaded at the disk transfer address
 14167                                  ; Returns:
 14168                                  ;	AL = -1 if no entries matched, otherwise 0
 14169                                  ;----------------------------------------------------------------------------
 14170                                  
 14171                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 2B88h
 14172                                  
 14173                                  _$DIR_SEARCH_FIRST:
 14174 00001F4A 368916[A605]            	MOV	[SS:THISFCB],DX
 14175 00001F4F 368C1E[A805]            	MOV	[SS:THISFCB+2],DS
 14176 00001F54 89D6                    	MOV	SI,DX
 14177 00001F56 803CFF                  	CMP	BYTE [SI],0FFH
 14178 00001F59 7503                    	JNZ	short NORMFCB4
 14179 00001F5B 83C607                  	ADD	SI,7			; Point to drive select byte
 14180                                  NORMFCB4:
 14181 00001F5E FF34                    	push	word [SI]		; Save original drive byte for later
 14182                                  
 14183 00001F60 16                      	push	ss
 14184 00001F61 07                      	pop	es			; get es to address DOSGroup
 14185                                  
 14186 00001F62 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 14187 00001F65 E8C44B                  	call	TransFCB		; convert the FCB, set SATTRIB EXTFCB
 14188 00001F68 7304                    	JNC	short SearchIt		; no error, go and look
 14189 00001F6A 5B                      	pop	bx			; Clean stack
 14190                                  
 14191                                  ; Error code is in AX
 14192                                  
 14193                                  	; 09/11/2022
 14194                                  dcf_errj:
 14195 00001F6B E9E8E6                  	jmp	FCB_RET_ERR		; error
 14196                                  
 14197                                  SearchIt:
 14198 00001F6E 16                      	push	ss
 14199 00001F6F 1F                      	pop	ds			; get ready for search
 14200 00001F70 FF36[2C03]              	push	word [DMAADD]
 14201 00001F74 FF36[2E03]              	push	word [DMAADD+2]
 14202 00001F78 C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14203 00001F7E 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14204                                  	; MSDOS 3.3
 14205                                  	;call	DOS_SEARCH_FIRST
 14206                                  	; MSDOS 6.0
 14207 00001F82 E88501                  	call	GET_FAST_SEARCH		; search
 14208 00001F85 8F06[2E03]              	pop	word [DMAADD+2]
 14209 00001F89 8F06[2C03]              	pop	word [DMAADD]
 14210 00001F8D 7303                    	JNC	short SearchSet		; no error, transfer info
 14211 00001F8F 5B                      	pop	bx			; Clean stack
 14212                                  
 14213                                  ; Error code is in AX
 14214                                  
 14215                                  	; 09/11/2022
 14216                                  	;jmp	FCB_RET_ERR
 14217 00001F90 EBD9                    	jmp	short dcf_errj
 14218                                  
 14219                                  ; The search was successful (or the search-next). We store the information
 14220                                  ; into the user's FCB for continuation.
 14221                                  
 14222                                  SearchSet:
 14223 00001F92 BE[BE04]                	MOV	SI,SEARCHBUF
 14224 00001F95 C43E[A605]              	LES	DI,[THISFCB]		; point to the FCB
 14225 00001F99 F606[6C05]FF            	TEST	byte [EXTFCB],0FFh		;
 14226 00001F9E 7403                    	JZ	short NORMFCB1
 14227 00001FA0 83C707                  	ADD	DI,7			; Point past the extension
 14228                                  NORMFCB1:
 14229 00001FA3 5B                      	pop	bx			; Get original drive byte
 14230 00001FA4 08DB                    	OR	BL,BL
 14231 00001FA6 7506                    	JNZ	short SearchDrv
 14232 00001FA8 8A1E[3603]              	MOV	BL,[CURDRV]
 14233 00001FAC FEC3                    	INC	BL
 14234                                  SearchDrv:
 14235 00001FAE AC                      	LODSB				; Get correct search contin drive byte
 14236 00001FAF 86C3                    	XCHG	AL,BL			; Search byte to BL, user byte to AL
 14237 00001FB1 47                      	INC	DI
 14238                                  	;STOSB				; Store the correct "user" drive byte
 14239                                  					;  at the start of the search info
 14240 00001FB2 B90A00                  	MOV	CX,20/2
 14241 00001FB5 F3A5                    	REP	MOVSW			; Rest of search cont info, SI -> entry
 14242 00001FB7 86C3                    	XCHG	AL,BL			; User drive byte back to BL, search
 14243                                  					;   byte to AL
 14244 00001FB9 AA                      	STOSB				; Search contin drive byte at end of
 14245                                  					;   contin info
 14246 00001FBA C43E[2C03]              	LES	DI,[DMAADD]
 14247 00001FBE F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 14248 00001FC3 740D                    	JZ	short NORMFCB2
 14249 00001FC5 B0FF                    	MOV	AL,0FFh
 14250 00001FC7 AA                      	STOSB
 14251 00001FC8 FEC0                    	INC	AL
 14252                                  	;MOV	CX,5
 14253                                  	; 17/12/2022
 14254 00001FCA B105                    	mov	cl,5
 14255 00001FCC F3AA                    	REP	STOSB
 14256 00001FCE A0[6D05]                	MOV	AL,[SATTRIB]
 14257 00001FD1 AA                      	STOSB
 14258                                  NORMFCB2:
 14259 00001FD2 88D8                    	MOV	AL,BL			; User Drive byte
 14260 00001FD4 AA                      	STOSB
 14261                                  	;MOV	CX,16			; 32 / 2 words of dir entry
 14262                                  	; 17/12/2022
 14263 00001FD5 B110                    	mov	cl,16
 14264 00001FD7 F3A5                    	REP	MOVSW
 14265 00001FD9 E977E6                  	jmp	FCB_RET_OK
 14266                                  
 14267                                  ;----------------------------------------------------------------------------
 14268                                  ;
 14269                                  ; Procedure Name : $DIR_SEARCH_NEXT
 14270                                  ;
 14271                                  ; Inputs:
 14272                                  ;	DS:DX points to unopenned FCB returned by $DIR_SEARCH_FIRST
 14273                                  ; Function:
 14274                                  ;	Directory is searched for the next matching entry and the directory
 14275                                  ;	entry is loaded at the disk transfer address
 14276                                  ; Returns:
 14277                                  ;	AL = -1 if no entries matched, otherwise 0
 14278                                  ;----------------------------------------------------------------------------
 14279                                  
 14280                                  _$DIR_SEARCH_NEXT:
 14281 00001FDC 368916[A605]            	MOV	[SS:THISFCB],DX
 14282 00001FE1 368C1E[A805]            	MOV	[SS:THISFCB+2],DS
 14283 00001FE6 36C606[6D05]00          	MOV	byte [SS:SATTRIB],0
 14284 00001FEC 36C606[6C05]00          	MOV	byte [SS:EXTFCB],0
 14285                                  
 14286 00001FF2 16                      	push	ss
 14287 00001FF3 07                      	pop	es
 14288                                  
 14289 00001FF4 BF[BE04]                	MOV	DI,SEARCHBUF
 14290                                  
 14291 00001FF7 89D6                    	MOV	SI,DX
 14292 00001FF9 803CFF                  	CMP	BYTE [SI],0FFh
 14293 00001FFC 750D                    	JNZ	short NORMFCB6
 14294 00001FFE 83C606                  	ADD	SI,6
 14295 00002001 AC                      	LODSB
 14296                                  
 14297 00002002 36A2[6D05]              	MOV	[SS:SATTRIB],AL
 14298 00002006 36FE0E[6C05]            	DEC	byte [SS:EXTFCB]
 14299                                  NORMFCB6:
 14300 0000200B AC                      	LODSB				; Get original user drive byte
 14301 0000200C 50                      	push	ax			; Put it on stack
 14302 0000200D 8A4414                  	MOV	AL,[SI+20]		; Get correct search contin drive byte
 14303 00002010 AA                      	STOSB				; Put in correct place
 14304 00002011 B90A00                  	MOV	CX,20/2
 14305 00002014 F3A5                    	REP	MOVSW			; Transfer in rest of search contin info
 14306                                  
 14307 00002016 16                      	push	ss
 14308 00002017 1F                      	pop	ds
 14309                                  
 14310 00002018 FF36[2C03]              	push	word [DMAADD]
 14311 0000201C FF36[2E03]              	push	word [DMAADD+2]
 14312 00002020 C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14313 00002026 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14314 0000202A E8220E                  	call	DOS_SEARCH_NEXT 	; Find it
 14315 0000202D 8F06[2E03]              	pop	word [DMAADD+2]
 14316 00002031 8F06[2C03]              	pop	word [DMAADD]
 14317 00002035 7203                    	JC	short SearchNoMore
 14318 00002037 E958FF                  	JMP	SearchSet		; Ok set return
 14319                                  
 14320                                  SearchNoMore:
 14321 0000203A C43E[A605]              	LES	DI,[THISFCB]
 14322 0000203E F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 14323 00002043 7403                    	JZ	short NORMFCB8
 14324 00002045 83C707                  	ADD	DI,7			; Point past the extension
 14325                                  NORMFCB8:
 14326 00002048 5B                      	pop	bx			; Get original drive byte
 14327 00002049 26881D                  	MOV	[ES:DI],BL		; Store the correct "user" drive byte
 14328                                  					;  at the right spot
 14329                                  ; error code is in AX
 14330                                  
 14331 0000204C E907E6                  	jmp	FCB_RET_ERR
 14332                                  
 14333                                  ; 17/05/2019 - Retro DOS v4.0
 14334                                  
 14335                                  ; DOSCODE:5EE6h (MSDOS 6.21, MSDOS.SYS)
 14336                                  
 14337                                  ;---------------------------------------------------------------------------
 14338                                  ;
 14339                                  ;   Procedure Name : $FIND_FIRST
 14340                                  ; 
 14341                                  ;   Assembler usage:
 14342                                  ;	    MOV AH, FindFirst
 14343                                  ;	    LDS DX, name
 14344                                  ;	    MOV CX, attr
 14345                                  ;	    INT 21h
 14346                                  ;	; DMA address has datablock
 14347                                  ;
 14348                                  ;   Error Returns:
 14349                                  ;	    AX = error_path_not_found
 14350                                  ;	       = error_no_more_files
 14351                                  ;---------------------------------------------------------------------------
 14352                                  
 14353                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14354                                  	; DOSCODE:5ED2h (MSDOS 5.0, MSDOS.SYS)
 14355                                  
 14356                                  _$FIND_FIRST:
 14357 0000204F 89D6                    	MOV	SI,DX			; get name in appropriate place
 14358 00002051 36880E[6D05]            	MOV	[SS:SATTRIB],CL		; Search attribute to correct loc
 14359                                  
 14360 00002056 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 14361                                  
 14362 00002059 E8364B                  	call	TransPathSet		; convert the path
 14363 0000205C 7305                    	JNC	short Find_it 		; no error, go and look
 14364                                  FindError:
 14365                                  	;mov	al,3
 14366 0000205E B003                    	mov	al, error_path_not_found ; error and map into one.
 14367                                  	; 09/11/2022
 14368                                  FF_errj:
 14369 00002060 E9DDE5                  	jmp	SYS_RET_ERR
 14370                                  Find_it:
 14371 00002063 16                      	push	ss
 14372 00002064 1F                      	pop	ds
 14373                                  
 14374 00002065 FF36[2C03]              	push	word [DMAADD]
 14375 00002069 FF36[2E03]              	push	word [DMAADD+2]
 14376 0000206D C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14377 00002073 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14378                                  	; MSDOS 3.3
 14379                                  	;call	DOS_SEARCH_FIRST
 14380                                  	; MSDOS 6.0
 14381 00002077 E89000                  	call	GET_FAST_SEARCH 	; search
 14382 0000207A 8F06[2E03]              	pop	word [DMAADD+2]
 14383 0000207E 8F06[2C03]              	pop	word [DMAADD]
 14384                                  	
 14385                                  	; 16/12/2022
 14386                                  	;JNC	short FindSet 		; no error, transfer info
 14387 00002082 72DC                    	jc	short FF_errj	; jmp SYS_RET_ERR
 14388                                  	;
 14389                                  	;jmp	SYS_RET_ERR
 14390                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14391                                  ;FFF_errj:
 14392                                  	;jmp	short FF_errj	; jmp SYS_RET_ERR
 14393                                  
 14394                                  FindSet:
 14395 00002084 BE[BE04]                	MOV	SI,SEARCHBUF
 14396 00002087 C43E[2C03]              	LES	DI,[DMAADD]
 14397 0000208B B91500                  	MOV	CX,21
 14398 0000208E F3A4                    	REP	MOVSB
 14399 00002090 56                      	PUSH	SI			; Save pointer to start of entry
 14400                                  	;mov	al,[si+0Bh]
 14401 00002091 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 14402 00002094 AA                      	STOSB
 14403                                  	;add	si,16h ; 22
 14404 00002095 83C616                  	ADD	SI,dir_entry.dir_time
 14405 00002098 A5                      	MOVSW				; dir_time
 14406 00002099 A5                      	MOVSW				; dir_date
 14407 0000209A 46                      	INC	SI
 14408 0000209B 46                      	INC	SI			; Skip dir_first
 14409 0000209C A5                      	MOVSW				; dir_size (2 words)
 14410 0000209D A5                      	MOVSW
 14411 0000209E 5E                      	POP	SI			; Point back to dir_name
 14412 0000209F E83500                   	CALL	PackName
 14413 000020A2 E992E5                  	jmp	SYS_RET_OK		; bye with no errors
 14414                                  
 14415                                  ;---------------------------------------------------------------------------
 14416                                  ;
 14417                                  ;   Procedure Name : $FIND_NEXT
 14418                                  ;
 14419                                  ;   Assembler usage:
 14420                                  ;	; dma points at area returned by find_first
 14421                                  ;	    MOV AH, findnext
 14422                                  ;	    INT 21h
 14423                                  ;	; next entry is at dma
 14424                                  ;
 14425                                  ;   Error Returns:
 14426                                  ;	    AX = error_no_more_files
 14427                                  ;---------------------------------------------------------------------------
 14428                                  
 14429                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14430                                  _$FIND_NEXT:
 14431 000020A5 16                      	push	ss
 14432 000020A6 07                      	pop	es
 14433                                  
 14434 000020A7 BF[BE04]                	MOV	DI,SEARCHBUF
 14435                                  
 14436 000020AA 36C536[2C03]            	LDS	SI,[SS:DMAADD]
 14437                                  
 14438 000020AF B91500                  	MOV	CX,21
 14439 000020B2 F3A4                    	REP	MOVSB			; Put the search continuation info
 14440                                  					;  in the right place
 14441 000020B4 16                      	push	ss
 14442 000020B5 1F                      	pop	ds			; get ready for search
 14443                                  	
 14444 000020B6 FF36[2C03]              	push	word [DMAADD]
 14445 000020BA FF36[2E03]              	push	word [DMAADD+2]
 14446 000020BE C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14447 000020C4 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14448 000020C8 E8840D                  	call	DOS_SEARCH_NEXT 	; Find it
 14449 000020CB 8F06[2E03]              	pop	word [DMAADD+2]
 14450 000020CF 8F06[2C03]              	pop	word [DMAADD]
 14451 000020D3 73AF                    	JNC	short FindSet 		; No error, set info
 14452                                  	;jmp	SYS_RET_ERR
 14453                                  	; 16/12/2022
 14454 000020D5 EB89                    	jmp	short FF_errj	; jmp SYS_RET_ERR
 14455                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14456                                  	;jmp	short FFF_errj	; jmp SYS_RET_ERR
 14457                                  
 14458                                  ;---------------------------------------------------------------------------
 14459                                  ;**	PackName - Convert file names from FCB to ASCIZ format.
 14460                                  ;
 14461                                  ;	PackName transfers a file name from DS:SI to ES:DI and converts it to
 14462                                  ;	the ASCIZ format.
 14463                                  ;
 14464                                  ;	ENTRY	(DS:SI) = 11 character FCB or dir entry name
 14465                                  ;		(ES:DI) = destination area (13 bytes)
 14466                                  ;	EXIT	(ds:SI) and (es:DI) advanced
 14467                                  ;	USES	al, CX, SI, DI, Flags  (BUGBUG - not verified - jgl)
 14468                                  ;---------------------------------------------------------------------------
 14469                                  
 14470                                  PackName:
 14471                                  ;	Move over 8 characters to cover the name component, then trim it's
 14472                                  ;	trailing blanks.
 14473                                  
 14474 000020D7 B90800                  	MOV	CX,8			; Pack the name
 14475 000020DA F3A4                    	REP	MOVSB			; Move all of it
 14476                                  main_kill_tail:
 14477 000020DC 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 14478 000020E1 7507                    	JNZ	short find_check_dot
 14479 000020E3 4F                      	DEC	DI			; Back up over trailing space
 14480 000020E4 41                      	INC	CX
 14481 000020E5 83F908                  	CMP	CX,8
 14482 000020E8 72F2                    	JB	short main_kill_tail
 14483                                  find_check_dot:
 14484                                  	;CMP	WORD [SI],(" " << 8) | " "
 14485 000020EA 813C2020                	cmp     word [si],2020h 
 14486 000020EE 7506                    	JNZ	short got_ext 		; Some chars in extension
 14487 000020F0 807C0220                	CMP	BYTE [SI+2]," "
 14488 000020F4 7410                    	JZ	short find_done		; No extension
 14489                                  got_ext:
 14490 000020F6 B02E                    	MOV	AL,"."	; 2Eh
 14491 000020F8 AA                      	STOSB
 14492                                  	;MOV	CX,3
 14493                                  	; 18/12/2022
 14494                                  	;mov	cl,3
 14495                                  	;REP	MOVSB
 14496 000020F9 A4                      	movsb
 14497 000020FA A4                      	movsb
 14498 000020FB A4                      	movsb
 14499                                  ext_kill_tail:
 14500 000020FC 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 14501 00002101 7503                    	JNZ	short find_done
 14502 00002103 4F                      	DEC	DI			; Back up over trailing space
 14503 00002104 EBF6                    	JMP	short ext_kill_tail
 14504                                  find_done:
 14505 00002106 31C0                    	XOR	AX,AX
 14506 00002108 AA                      	STOSB				; NUL terminate
 14507 00002109 C3                      	retn
 14508                                  
 14509                                  ;---------------------------------------------------------------------------
 14510                                  
 14511                                  	; 17/05/2019 - Retro DOS v4.0
 14512                                  GET_FAST_SEARCH:
 14513                                  	; 22/07/2018
 14514                                  	; MSDOS 6.0
 14515                                  	; 17/12/2022
 14516 0000210A 36800E[1206]04          	OR	byte [ss:DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)  ; 04h
 14517                                  	;OR	word [ss:DOS34_FLAG],SEARCH_FASTOPEN  ; 400h
 14518                                  					;FO.trigger fastopen ;AN000;
 14519                                  	;call	DOS_SEARCH_FIRST
 14520                                  	;retn
 14521                                  	; 17/12/2022
 14522 00002110 E9500C                  	jmp	DOS_SEARCH_FIRST
 14523                                  
 14524                                  ;============================================================================
 14525                                  ; PATH.ASM, MSDOS 6.0, 1991
 14526                                  ;============================================================================
 14527                                  ; 06/08/2018 - Retro DOS v3.0
 14528                                  ; 17/05/2019 - Retro DOS v4.0
 14529                                  
 14530                                  ; DOSCODE:5FB0h (MSDOS 6.21, MSDOS.SYS)
 14531                                  
 14532                                  ;**	Directory related system calls. These will be passed direct text of the
 14533                                  ;	pathname from the user. They will need to be passed through the macro
 14534                                  ;	expander prior to being sent through the low-level stuff. I/O specs are
 14535                                  ;	defined in DISPATCH. The system calls are:
 14536                                  ;
 14537                                  ;	$CURRENT_DIR  Written
 14538                                  ;	$RMDIR	  Written
 14539                                  ;	$CHDIR	  Written
 14540                                  ;	$MKDIR	  Written
 14541                                  ;
 14542                                  ;
 14543                                  ;	Modification history:
 14544                                  ;
 14545                                  ;	    Created: ARR 4 April 1983
 14546                                  ;		 MZ 10 May 1983     CurrentDir implemented
 14547                                  ;		 MZ 11 May 1983     RmDir, ChDir, MkDir implemented
 14548                                  ;		 EE 19 Oct 1983     RmDir no longer allows you to delete a
 14549                                  ;				    current directory.
 14550                                  ;		 MZ 19 Jan 1983     Brain damaged applications rely on success
 14551                                  
 14552                                  ;	I_Need	ThisCDS,DWORD		; pointer to Current CDS
 14553                                  ;	I_Need	WFP_Start,WORD		; pointer to beginning of directory text
 14554                                  ;	I_Need	Curr_Dir_End,WORD	; offset to end of directory part
 14555                                  ;	I_Need	OpenBuf,128		; temp spot for translated name
 14556                                  ;	I_need	fSplice,BYTE		; TRUE => do splice
 14557                                  ;	I_Need	NoSetDir,BYTE		; TRUE => no exact match on splice
 14558                                  ;	I_Need	cMeta,BYTE
 14559                                  ;	I_Need	DrvErr,BYTE					;AN000;
 14560                                  
 14561                                  ;BREAK <$CURRENT_DIR - dump the current directory into user space>
 14562                                  ;----------------------------------------------------------------------------
 14563                                  ;
 14564                                  ;   Procedure Name : $CURRENT_DIR
 14565                                  ;
 14566                                  ;   Assembler usage:
 14567                                  ;		LDS	SI,area
 14568                                  ;		MOV	DL,drive
 14569                                  ;		INT	21h
 14570                                  ;	    ; DS:SI is a pointer to 64 byte area that contains drive
 14571                                  ;	    ; current directory.
 14572                                  ;   Error returns:
 14573                                  ;	    AX = error_invalid_drive
 14574                                  ;
 14575                                  ;----------------------------------------------------------------------------
 14576                                  
 14577                                  _$CURRENT_DIR:
 14578                                  	;06/08/2018 - Retro DOS v3.0
 14579                                  	;IBMDOS.COM (MSDOS 3.3, 1987) - Offset 2D4Eh
 14580 00002113 E8FBF1                  	call	ECritDisk
 14581 00002116 88D0                    	MOV	AL,DL			; get drive number (0=def, 1=A)
 14582 00002118 E88049                  	call	GetVisDrv		; grab it
 14583 0000211B 7310                    	JNC	short CurrentValidate 	; no error -> go and validate dir
 14584                                  CurdirErr:
 14585 0000211D E80CF2                  	call	LCritDisk
 14586                                  
 14587                                  	; MSDOS 3.3
 14588                                  	;mov	al,0Fh
 14589                                  	
 14590                                  	; MSDOS 6.0
 14591 00002120 1E                      	push	ds
 14592 00002121 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 14593 00002126 A0[1006]                	mov	al,[DrvErr]		;IFS.			;AN000;
 14594 00002129 1F                      	pop	ds
 14595                                  
 14596                                  curdir_errj:
 14597 0000212A E913E5                  	jmp	SYS_RET_ERR		;IFS. make noise	;AN000;
 14598                                  
 14599                                  CurrentValidate:
 14600 0000212D 1E                      	push	ds			; save destination
 14601 0000212E 56                      	push	si
 14602                                  	
 14603                                  	;LDS	SI,[CS:THISCDS] ; MSDOS 3.3
 14604                                  	
 14605                                  	; MSDOS 6.0
 14606 0000212F 2E8E1E[0700]            	mov     ds,[cs:DosDSeg]
 14607 00002134 C536[A205]              	lds     si,[THISCDS]
 14608                                  
 14609                                  ; 16/12/2022
 14610                                  %if 0
 14611                                  	; 09/11/2022 (following test instruction is nonsense!)
 14612                                  	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)
 14613                                  
 14614                                  	;test	word [si+43h],8000h
 14615                                  	TEST	word [SI+curdir.flags],curdir_isnet
 14616                                  	;jnz	short $+2  ; 09/11/2022	
 14617                                  	jnz	short DoCheck
 14618                                  %endif
 14619                                  
 14620                                  ; Random optimization nuked due to some utilities using GetCurrentDir to do
 14621                                  ; media check.
 14622                                  ;	CMP	word [SI+curdir.ID],0
 14623                                  ;	JZ	short GetDst
 14624                                  DoCheck:
 14625                                  	;MOV	byte [cs:NoSetDir],0	; interested only in contents
 14626                                  
 14627                                  	; MSDOS 6.0
 14628 00002138 1E                      	push	ds
 14629 00002139 2E8E1E[0700]            	mov     ds,[cs:DosDSeg]
 14630 0000213E C606[4C03]00            	mov	byte [NoSetDir],0
 14631 00002143 1F                      	pop	ds
 14632                                  
 14633 00002144 BF[BE03]                	MOV	DI,OPENBUF
 14634 00002147 E83721                  	call	ValidateCDS		; output is ES:DI -> CDS
 14635                                  
 14636 0000214A 06                      	push	es	 		; swap source and destination
 14637 0000214B 57                      	push	di
 14638 0000214C 5E                      	pop	si
 14639 0000214D 1F                      	pop	ds
 14640                                  GetDst:
 14641 0000214E 5F                      	pop	di
 14642 0000214F 07                      	pop	es			; get real destination
 14643 00002150 72CB                    	JC	short CurdirErr
 14644                                  	;ADD	SI,curdir.text ; add si,0 ; 09/08/2018
 14645                                  	;
 14646                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14647                                  	; DOSCODE:5FE2h (MSDOS 5.0, MSDOS.SYS)
 14648                                  	; 16/12/2022
 14649                                  	;add	si,0  ; add si,curdir.text
 14650                                  	;
 14651                                  	;add	si,[si+4Fh] ; 17/05/2019
 14652 00002152 03744F                  	ADD	SI,[SI+curdir.end]
 14653 00002155 803C5C                  	CMP	BYTE [SI],'\'	; 5Ch	; root or subdirs present?
 14654 00002158 7501                    	JNZ	short CurrentCopy
 14655 0000215A 46                      	INC	SI
 14656                                  CurrentCopy:
 14657                                  ;	call	FStrCpy
 14658                                  ;; 10/29/86 E5 char
 14659 0000215B 50                      	PUSH	AX
 14660 0000215C AC                      	LODSB				; get char
 14661 0000215D 08C0                    	OR	AL,AL
 14662 0000215F 7413                    	JZ	short FOK
 14663 00002161 3C05                    	CMP	AL,05H
 14664 00002163 740D                    	JZ	short FCHANGE
 14665 00002165 EB01                    	JMP	short FFF
 14666                                  FCPYNEXT:
 14667 00002167 AC                      	LODSB				; get char
 14668                                  FFF:
 14669 00002168 3C5C                    	CMP	AL,'\'			; beginning of directory
 14670 0000216A 7508                    	JNZ	short FOK		; no
 14671 0000216C AA                      	STOSB				; put into user's buffer
 14672 0000216D AC                      	LODSB				; 1st char of dir is 05?
 14673 0000216E 3C05                    	CMP	AL,05H
 14674 00002170 7502                    	JNZ	short FOK		; no
 14675                                  FCHANGE:
 14676 00002172 B0E5                    	MOV	AL,0E5H			; make it E5
 14677                                  FOK:
 14678 00002174 AA                      	STOSB				; put into user's buffer
 14679 00002175 08C0                    	OR	AL,AL			; final char
 14680 00002177 75EE                    	JNZ	short FCPYNEXT		; no
 14681 00002179 58                      	POP	AX
 14682                                  
 14683                                  ;; 10/29/86 E5 char
 14684 0000217A 30C0                    	xor	AL,AL			; MZ 19 Jan 84
 14685 0000217C E8ADF1                  	call	LCritDisk
 14686 0000217F E9B5E4                  	jmp	SYS_RET_OK		; no more, bye!
 14687                                  
 14688                                  ; 17/05/2019 - Retro DOS v4.0
 14689                                  
 14690                                  ; DOSCODE:6029h (MSDOS 6.21, MSDOS.SYS)
 14691                                  
 14692                                  ;BREAK <$RmDir -- Remove a directory>
 14693                                  ;----------------------------------------------------------------------------
 14694                                  ;
 14695                                  ; Procedure Name : $RmDir
 14696                                  ;
 14697                                  ; Inputs:
 14698                                  ;	DS:DX Points to asciz name
 14699                                  ; Function:
 14700                                  ;	Delete directory if empty
 14701                                  ; Returns:
 14702                                  ;	STD XENIX Return
 14703                                  ;	AX = error_path_not_found If path bad
 14704                                  ;	AX = error_access_denied If
 14705                                  ;		Directory not empty
 14706                                  ;		Path not directory
 14707                                  ;		Root directory specified
 14708                                  ;		Directory malformed (. and .. not first two entries)
 14709                                  ;		User tries to delete a current directory
 14710                                  ;	AX = error_current_directory
 14711                                  ;
 14712                                  ;----------------------------------------------------------------------------
 14713                                  
 14714                                  	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14715                                  	; DOSCODE:6015h (MSDOS 5.0, MSDOS.SYS)
 14716                                  
 14717                                  _$RMDIR:
 14718 00002182 52                      	push	dx			; Save ptr to name
 14719 00002183 1E                      	push	ds
 14720 00002184 89D6                    	mov	si,dx			; Load ptr into si
 14721 00002186 BF[BE03]                	mov	di,OPENBUF		; di = ptr to buf for trans name
 14722 00002189 57                      	push	di
 14723 0000218A E80D4A                  	call	TransPathNoSet		; Translate the name
 14724 0000218D 5F                      	pop	di			; di = ptr to buf for trans name
 14725 0000218E 7306                    	jnc	short rmlset		; If transpath succeeded, continue
 14726 00002190 1F                      	pop	ds
 14727 00002191 5A                      	pop	dx			; Restore the name
 14728                                  	;mov	al,3
 14729 00002192 B003                    	mov	al,error_path_not_found ; Otherwise, return an error
 14730                                  	; 16/12/2022
 14731                                  rmdir_errj: ; 10/08/2018
 14732                                  chdir_errj:
 14733 00002194 EB94                    	jmp	short curdir_errj
 14734                                  	;jmp	SYS_RET_ERR
 14735                                  rmlset:
 14736 00002196 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1	;   if (cMeta >= 0)
 14737 0000219C 7512                    	Jnz	short rmerr		;	return (-1);
 14738 0000219E 16                      	push	ss
 14739 0000219F 07                      	pop	es
 14740 000021A0 30C0                    	xor	al,al			; al = 0 , ie drive a:
 14741                                  rmloop: 
 14742 000021A2 E86749                  	call	GetCDSFromDrv		; Get curdir for drive in al
 14743 000021A5 720F                    	jc	short rmcont		; If error, exit loop & cont normally
 14744 000021A7 E809F0                  	call	StrCmp			; Are the 2 paths the same?
 14745 000021AA 7404                    	jz	short rmerr		; Yes, report error.
 14746 000021AC FEC0                    	inc	al			; No, inc al to next drive number
 14747 000021AE EBF2                    	jmp	short rmloop		; Go check next drive.
 14748                                  rmerr:
 14749 000021B0 1F                      	pop	ds
 14750 000021B1 5A                      	pop	dx			; Restore the name
 14751                                  	;mov	al,10h
 14752 000021B2 B010                    	mov	al,error_current_directory ; error
 14753                                  	; 16/12/2022
 14754                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14755                                  ;chdir_errj:
 14756 000021B4 EBDE                    	jmp	short rmdir_errj
 14757                                  rmcont:
 14758 000021B6 1F                      	pop	ds
 14759 000021B7 5A                      	pop	dx			; Restore the name
 14760 000021B8 BE[2432]                	MOV	SI,DOS_RMDIR
 14761 000021BB EB7C                    	JMP	DoDirCall
 14762                                  
 14763                                  ; 17/05/2019 - Retro DOS v4.0
 14764                                  
 14765                                  ; DOSCODE:6065h (MSDOS 6.21, MSDOS.SYS)
 14766                                  
 14767                                  ;BREAK <$ChDir -- Change current directory on a drive>
 14768                                  ;----------------------------------------------------------------------------
 14769                                  ;
 14770                                  ; $ChDir - Top-level change directory system call.  This call is responsible
 14771                                  ; for setting up the CDS for the specified drive appropriately.  There are
 14772                                  ; several cases to consider:
 14773                                  ;
 14774                                  ;   o	Local, simple CDS.  In this case, we take the input path and convert
 14775                                  ;	it into a WFP.	We verify the existance of this directory and then
 14776                                  ;	copy the WFP into the CDS and set up the ID field to point to the
 14777                                  ;	directory cluster.
 14778                                  ;   o	Net CDS.  We form the path from the root (including network prefix)
 14779                                  ;	and verify its existance (via DOS_Chdir).  If successful, we copy the
 14780                                  ;	WFP back into the CDS.
 14781                                  ;   o	SUBST'ed CDS.  This is no different than the local, simple CDS.
 14782                                  ;   o	JOIN'ed CDS.  This is trouble as there are two CDS's at work.  If we
 14783                                  ;	call TransPath, we will get the PHYSICAL CDS that the path refers to
 14784                                  ;	and the PHYSICAL WFP that the input path refers to.  This is perfectly
 14785                                  ;	good for the validation but not for currency.  We call TransPathNoSet
 14786                                  ;	to process the path but to return the logical CDS and the logical
 14787                                  ;	path.  We then copy the logical path into the logical CDS.
 14788                                  ;
 14789                                  ; Inputs:
 14790                                  ;	DS:DX Points to asciz name
 14791                                  ; Returns:
 14792                                  ;	STD XENIX Return
 14793                                  ;	AX = chdir_path_not_found if error
 14794                                  ;
 14795                                  ;----------------------------------------------------------------------------
 14796                                  
 14797                                  _$CHDIR:
 14798 000021BD BF[BE03]                	MOV	DI,OPENBUF		; spot for translated name
 14799 000021C0 89D6                    	MOV	SI,DX			; get source
 14800 000021C2 E8C949                  	call	TransPath		; go munge the path and get real CDS
 14801 000021C5 7304                    	JNC	short ChDirCrack	; no errors, try path
 14802                                  ChDirErrP:
 14803                                  	;mov	al,3
 14804 000021C7 B003                    	MOV	AL,error_path_not_found
 14805                                  ChDirErr:
 14806                                  	;jmp	SYS_RET_ERR 	; oops!
 14807                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14808 000021C9 EBC9                    	jmp	short chdir_errj
 14809                                  
 14810                                  ChDirCrack:
 14811 000021CB 803E[7A05]FF            	CMP	byte [CMETA],-1		; No meta chars allowed.
 14812 000021D0 75F5                    	JNZ	short ChDirErrP
 14813                                  
 14814                                  ; We cannot do a ChDir (yet) on a raw CDS. This is treated as a path not
 14815                                  ; found.
 14816                                  
 14817 000021D2 C43E[A205]              	LES	DI,[THISCDS]
 14818 000021D6 83FFFF                  	CMP	DI,-1			;   if (ThisCDS == NULL)
 14819 000021D9 74EC                    	JZ	short ChDirErrP		;	error ();
 14820                                  
 14821                                  ; Find out if the directory exists.
 14822                                  
 14823 000021DB E80310                  	call	DOS_CHDIR
 14824                                  	;Jc	short ChDirErr
 14825                                  	; 16/12/2022
 14826 000021DE 72B4                    	jc	short chdir_errj
 14827                                  ;
 14828                                  ; Get back CDS to see if a join as seen. Set the currency pointer (only if
 14829                                  ; not network). If one was seen, all we need to do is copy in the text
 14830                                  ;
 14831 000021E0 C43E[A205]              	LES	DI,[THISCDS]
 14832                                  	;test	word [es:di+43h],2000h
 14833                                  	; 17/12/2022
 14834 000021E4 26F6454420              	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
 14835                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice
 14836 000021E9 7425                    	JZ	short GotCDS
 14837                                  
 14838                                  ; The CDS was joined. Let's go back and grab the logical CDS.
 14839                                  
 14840 000021EB 06                      	push	es	
 14841 000021EC 57                      	push	di
 14842 000021ED 51                      	push	cx			; save CDS and cluster...
 14843 000021EE E890E2                  	call	Get_User_Stack		; get original text
 14844                                  	
 14845                                  	;mov	di,[si+6]
 14846 000021F1 8B7C06                  	MOV	DI,[SI+user_env.user_DX]
 14847                                  	;mov	ds,[si+0Eh]
 14848 000021F4 8E5C0E                  	MOV	DS,[SI+user_env.user_DS]
 14849                                  	
 14850 000021F7 BE[BE03]                	MOV	SI,OPENBUF		; spot for translated name
 14851 000021FA 87F7                    	XCHG	SI,DI
 14852 000021FC 30C0                    	XOR	AL,AL			; do no splicing
 14853 000021FE 57                      	push	di
 14854 000021FF E89849                  	call	TransPathNoSet		; Munge path
 14855 00002202 5E                      	pop	si
 14856                                  
 14857                                  ; There should NEVER be an error here.
 14858                                  
 14859                                  ;IF FALSE
 14860                                  ;	JNC SKipErr
 14861                                  ;	fmt <>,<>,<"$p: Internal CHDIR error\n">
 14862                                  ;SkipErr:
 14863                                  ;ENDIF
 14864 00002203 C43E[A205]              	LES	DI,[THISCDS]		; get new CDS
 14865                                  	;mov	word [es:di+49h],-1
 14866 00002207 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],-1
 14867                                  					; no valid cluster here...
 14868 0000220D 59                      	pop	cx
 14869 0000220E 5F                      	pop	di
 14870 0000220F 07                      	pop	es
 14871                                  
 14872                                  ; ES:DI point to the physical CDS, CX is the ID (local only)
 14873                                  
 14874                                  GotCDS:
 14875                                  
 14876                                  ; wfp_start points to the text. See if it is long enough
 14877                                  
 14878                                  	; MSDOS 3.3
 14879                                  	;push	ss
 14880                                  	;pop	ds
 14881                                  	;mov	si,[WFP_START]
 14882                                  	;push	cx
 14883                                  	;call	DStrLen
 14884                                  	;cmp	cx,67 ; cmp cx,DIRSTRLEN
 14885                                  	;pop	cx
 14886                                  	;ja	short ChDirErrP
 14887                                  
 14888                                  	; MSDOS 6.0
 14889 00002210 E85000                  	CALL	Check_PathLen		;PTM.		;AN000;
 14890 00002213 77B2                    	JA	short ChDirErrP
 14891                                  	; MSDOS 3.3 & MSDOS 6.0
 14892                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
 14893                                  	; 17/12/2022
 14894 00002215 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8
 14895 0000221A 7512                    	JNZ	short SkipRecency
 14896                                  	; MSDOS 6.0
 14897                                  	;test	word [es:di+43h],2000h
 14898                                  	; 17/12/2022
 14899 0000221C 26F6454420              	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
 14900                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice 
 14901                                  					;PTM. for Join and Subst ;AN000;
 14902 00002221 7403                    	JZ	short setdirclus	;PTM.		;AN000;
 14903 00002223 B9FFFF                  	MOV	CX,-1			;PTM.		;AN000;
 14904                                  setdirclus:
 14905                                  	;mov	[es:di+49h],cx
 14906 00002226 26894D49                	MOV	[ES:DI+curdir.ID],CX
 14907 0000222A C43E[A205]              	LES	DI,[THISCDS]		; get logical CDS
 14908                                  SkipRecency:
 14909 0000222E E8B3EF                  	call	FStrCpy
 14910 00002231 30C0                    	XOR	AL,AL
 14911                                  mkdir_ok:
 14912 00002233 E901E4                  	jmp	SYS_RET_OK
 14913                                  
 14914                                  ; 17/05/2019 - Retro DOS v4.0
 14915                                  
 14916                                  ; DOSCODE:60E1h (MSDOS 6.21, MSDOS.SYS)
 14917                                  
 14918                                  ;BREAK <$MkDir - Make a directory entry>
 14919                                  ;---------------------------------------------------------------------------
 14920                                  ;
 14921                                  ; Procedure Name : $MkDir
 14922                                  ; Inputs:
 14923                                  ;	DS:DX Points to asciz name
 14924                                  ; Function:
 14925                                  ;	Make a new directory
 14926                                  ; Returns:
 14927                                  ;	STD XENIX Return
 14928                                  ;	AX = mkdir_path_not_found if path bad
 14929                                  ;	AX = mkdir_access_denied  If
 14930                                  ;		Directory cannot be created
 14931                                  ;		Node already exists
 14932                                  ;		Device name given
 14933                                  ;		Disk or directory(root) full
 14934                                  ;---------------------------------------------------------------------------
 14935                                  
 14936                                  	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14937                                  
 14938                                  _$MKDIR:
 14939 00002236 BE[F130]                	MOV	SI,DOS_MKDIR
 14940                                  DoDirCall:
 14941 00002239 BF[BE03]                	MOV	DI,OPENBUF		; spot for translated name
 14942                                  
 14943 0000223C 56                      	push	si
 14944 0000223D 89D6                    	MOV	SI,DX			; get source
 14945 0000223F E84C49                  	call	TransPath		; go munge the path
 14946 00002242 5E                      	pop	si
 14947 00002243 7305                    	JNC	short MkDirCrack	; no errors, try path
 14948                                  MkErrP:
 14949 00002245 B003                    	MOV	AL,error_path_not_found	; oops!
 14950                                  MkErr:
 14951 00002247 E9F6E3                  	jmp	SYS_RET_ERR
 14952                                  MkDirCrack:
 14953 0000224A 36803E[7A05]FF          	CMP	byte [SS:CMETA],-1
 14954 00002250 75F3                    	JNZ	short MkErrP
 14955                                  
 14956                                  	; MSDOS 3.3
 14957                                  	;push	ss
 14958                                  	;pop	ds
 14959                                  	;call	si
 14960                                  	;jb	short MkErr
 14961                                  	;;jmp	short mkdir_ok
 14962                                  	;jmp	SYS_RET_OK
 14963                                  
 14964                                  	; MSDOS 6.0
 14965 00002252 56                      	PUSH	SI			;PTM.			;AN000;
 14966 00002253 E80D00                  	CALL	Check_PathLen		;PTM. check path len > 67 ? ;AN000;
 14967 00002256 5E                      	POP	SI			;PTM.			;AN000;
 14968 00002257 7604                    	JBE	short pathok		;PTM.			;AN000;
 14969                                  	;mov	al,5
 14970 00002259 B005                    	MOV	AL,error_access_denied	;PTM. ops!
 14971                                  	;jmp	SYS_RET_ERR		;PTM.
 14972 0000225B EBEA                    	jmp	short MkErr
 14973                                  pathok:
 14974 0000225D FFD6                    	CALL	SI			; go get file
 14975 0000225F 72E6                    	JC	short MkErr		; no errors
 14976                                  	; 16/12/2022
 14977                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14978 00002261 EBD0                    	jmp	short mkdir_ok
 14979                                  	;jmp	SYS_RET_OK
 14980                                  
 14981                                  ;----------------------------------------------------------------------------
 14982                                  ;
 14983                                  ; Procedure Name : Check_PathLen
 14984                                  ;
 14985                                  ; Inputs:
 14986                                  ;	nothing
 14987                                  ; Function:
 14988                                  ;	check if final path length greater than 67
 14989                                  ; Returns:
 14990                                  ;	Above flag set if > 67
 14991                                  ;
 14992                                  ;---------------------------------------------------------------------------
 14993                                  
 14994                                  Check_PathLen:
 14995                                  	; 09/09/2018
 14996                                  	;mov	SI,[WFP_START]
 14997 00002263 368B36[B205]            	MOV	SI,[SS:WFP_START] ; MSDOS 6.0
 14998                                  Check_PathLen2:
 14999 00002268 16                      	push	ss
 15000 00002269 1F                      	pop	ds
 15001                                  	;mov	SI,[WFP_START]	  ; MSDOS 3.3
 15002 0000226A 51                      	push	CX	
 15003 0000226B E88DEF                  	CALL	DStrLen
 15004 0000226E 83F943                  	CMP	CX,DIRSTRLEN ; 67
 15005 00002271 59                      	POP	CX
 15006 00002272 C3                      	retn
 15007                                  
 15008                                  ;============================================================================
 15009                                  ; IOCTL.ASM, MSDOS 6.0, 1991
 15010                                  ;============================================================================
 15011                                  ; 07/08/2018 - Retro DOS v3.0
 15012                                  ; 17/05/2019 - Retro DOS v4.0
 15013                                  
 15014                                  ;**	IOCTL system call.
 15015                                  ;----------------------------------------------------------------------------
 15016                                  ;	$IOCTL
 15017                                  ;
 15018                                  ;	  Revision history:
 15019                                  ;
 15020                                  ;		Created: ARR 4 April 1983
 15021                                  ;
 15022                                  ;		GenericIOCTL added:		KGS	22 April 1985
 15023                                  ;
 15024                                  ;		A000	version 4.00	Jan. 1988
 15025                                  ;
 15026                                  ;		Used jump table to dispatch IOCTL functions. HKN 3/12/90
 15027                                  ;
 15028                                  
 15029                                  ;BREAK <IOCTL - munge on a handle to do device specific stuff>
 15030                                  ;---------------------------------------------------------------------------
 15031                                  ;
 15032                                  ;   Assembler usage:
 15033                                  ;	    MOV     BX, Handle
 15034                                  ;	    MOV     DX, Data
 15035                                  ;
 15036                                  ;	(or LDS     DX,BUF
 15037                                  ;	    MOV     CX,COUNT)
 15038                                  ;
 15039                                  ;	    MOV     AH, Ioctl
 15040                                  ;	    MOV     AL, Request
 15041                                  ;	    INT     21h
 15042                                  ;
 15043                                  ;   AH = 0  Return a combination of low byte of sf_flags and device driver
 15044                                  ;	    attribute word in DX, handle in BX:
 15045                                  ;	    DH = high word of device driver attributes
 15046                                  ;	    DL = low byte of sf_flags
 15047                                  ;	 1  Set the bits contained in DX to sf_flags.  DH MUST be 0.  Handle
 15048                                  ;	    in BX.
 15049                                  ;	 2  Read CX bytes from the device control channel for handle in BX
 15050                                  ;	    into DS:DX.  Return number read in AX.
 15051                                  ;	 3  Write CX bytes to the device control channel for handle in BX from
 15052                                  ;	    DS:DX.  Return bytes written in AX.
 15053                                  ;	 4  Read CX bytes from the device control channel for drive in BX
 15054                                  ;	    into DS:DX.  Return number read in AX.
 15055                                  ;	 5  Write CX bytes to the device control channel for drive in BX from
 15056                                  ;	    DS:DX.  Return bytes written in AX.
 15057                                  ;	 6  Return input status of handle in BX. If a read will go to the
 15058                                  ;	    device, AL = 0FFh, otherwise 0.
 15059                                  ;	 7  Return output status of handle in BX. If a write will go to the
 15060                                  ;	    device, AL = 0FFh, otherwise 0.
 15061                                  ;	 8  Given a drive in BX, return 1 if the device contains non-
 15062                                  ;	    removable media, 0 otherwise.
 15063                                  ;	 9  Return the contents of the device attribute word in DX for the
 15064                                  ;	    drive in BX.  0200h is the bit for shared.	1000h is the bit for
 15065                                  ;	    network. 8000h is the bit for local use.
 15066                                  ;	 A  Return 8000h if the handle in BX is for the network or not.
 15067                                  ;	 B  Change the retry delay and the retry count for the system. BX is
 15068                                  ;	    the count and CX is the delay.
 15069                                  ;
 15070                                  ;   Error returns:
 15071                                  ;	    AX = error_invalid_handle
 15072                                  ;	       = error_invalid_function
 15073                                  ;	       = error_invalid_data
 15074                                  ;
 15075                                  ;-------------------------------------------------------------------------------
 15076                                  ;
 15077                                  ;   This is the documentation copied from DOS 4.0 it is much better
 15078                                  ;   than the above
 15079                                  ;
 15080                                  ;	There are several basic forms of IOCTL calls:
 15081                                  ;
 15082                                  ;
 15083                                  ;	** Get/Set device information:	**
 15084                                  ;
 15085                                  ;	ENTRY	(AL) = function code
 15086                                  ;		  0 - Get device information
 15087                                  ;		  1 - Set device information
 15088                                  ;		(BX) = file handle
 15089                                  ;		(DX) = info for "Set Device Information"
 15090                                  ;	EXIT	'C' set if error
 15091                                  ;		  (AX) = error code
 15092                                  ;		'C' clear if OK
 15093                                  ;		  (DX) = info for "Get Device Information"
 15094                                  ;	USES	ALL
 15095                                  ;
 15096                                  ;
 15097                                  ;	**  Read/Write Control Data From/To Handle  **
 15098                                  ;
 15099                                  ;	ENTRY	(AL) = function code
 15100                                  ;		  2 - Read device control info
 15101                                  ;		  3 - Write device control info
 15102                                  ;		(BX) = file handle
 15103                                  ;		(CX) = transfer count
 15104                                  ;		(DS:DX) = address for data
 15105                                  ;	EXIT	'C' set if error
 15106                                  ;		  (AX) = error code
 15107                                  ;		'C' clear if OK
 15108                                  ;		  (AX) = count of bytes transfered
 15109                                  ;	USES	ALL
 15110                                  ;
 15111                                  ;
 15112                                  ;	**  Read/Write Control Data From/To Block Device  **
 15113                                  ;
 15114                                  ;	ENTRY	(AL) = function code
 15115                                  ;		  4 - Read device control info
 15116                                  ;		  5 - Write device control info
 15117                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 15118                                  ;		(CX) = transfer count
 15119                                  ;		(DS:DX) = address for data
 15120                                  ;	EXIT	'C' set if error
 15121                                  ;		  (AX) = error code
 15122                                  ;		'C' clear if OK
 15123                                  ;		  (AX) = count of bytes transfered
 15124                                  ;	USES	ALL
 15125                                  ;
 15126                                  ;
 15127                                  ;	**  Get Input/Output Status  **
 15128                                  ;
 15129                                  ;	ENTRY	(AL) = function code
 15130                                  ;		  6 - Get Input status
 15131                                  ;		  7 - Get Output Status
 15132                                  ;		(BX) = file handle
 15133                                  ;	EXIT	'C' set if error
 15134                                  ;		  (AX) = error code
 15135                                  ;		'C' clear if OK
 15136                                  ;		  (AL) = 00 if not ready
 15137                                  ;		  (AL) = FF if ready
 15138                                  ;	USES	ALL
 15139                                  ;
 15140                                  ;
 15141                                  ;	**  Get Drive Information  **
 15142                                  ;
 15143                                  ;	ENTRY	(AL) = function code
 15144                                  ;		  8 - Check for removable media
 15145                                  ;		  9 - Get device attributes
 15146                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 15147                                  ;	EXIT	'C' set if error
 15148                                  ;		  (AX) = error code
 15149                                  ;		'C' clear if OK
 15150                                  ;		  (AX) = 0/1 media is removable/fixed (func. 8)
 15151                                  ;		  (DX) = device attribute word (func. 9)
 15152                                  ;	USES	ALL
 15153                                  ;
 15154                                  ;
 15155                                  ;	**  Get Redirected bit	**
 15156                                  ;
 15157                                  ;	ENTRY	(AL) = function code
 15158                                  ;		  0Ah - Network stuff
 15159                                  ;		(BX) = file handle
 15160                                  ;	EXIT	'C' set if error
 15161                                  ;		  (AX) = error code
 15162                                  ;		'C' clear if OK
 15163                                  ;		  (DX) = SFT flags word, 8000h set if network file
 15164                                  ;	USES	ALL
 15165                                  ;
 15166                                  ;
 15167                                  ;	**  Change sharer retry parameters  **
 15168                                  ;
 15169                                  ;	ENTRY	(AL) = function code
 15170                                  ;		  0Bh - Set retry parameters
 15171                                  ;		(CX) = retry loop count
 15172                                  ;		(DX) = number of retries
 15173                                  ;	EXIT	'C' set if error
 15174                                  ;		  (AX) = error code
 15175                                  ;		'C' clear if OK
 15176                                  ;	USES	ALL
 15177                                  ;
 15178                                  ;
 15179                                  ;   =================================================================
 15180                                  ;
 15181                                  ;	**  New Standard Control  **
 15182                                  ;
 15183                                  ;	ALL NEW IOCTL FACILITIES SHOULD USE THIS FORM.	THE OTHER
 15184                                  ;	FORMS ARE OBSOLETE.
 15185                                  ;
 15186                                  ;   =================================================================
 15187                                  ;
 15188                                  ;	ENTRY	(AL) = function code
 15189                                  ;		  0Ch - Control Function subcode
 15190                                  ;		(BX) = File Handle
 15191                                  ;		(CH) = Category Indicator
 15192                                  ;		(CL) = Function within category
 15193                                  ;		(DS:DX) = address for data, if any
 15194                                  ;		(SI) = Passed to device as argument, use depends upon function
 15195                                  ;		(DI) = Passed to device as argument, use depends upon function
 15196                                  ;	EXIT	'C' set if error
 15197                                  ;		  (AX) = error code
 15198                                  ;		'C' clear if OK
 15199                                  ;		  (SI) = Return value, meaning is function dependent
 15200                                  ;		  (DI) = Return value, meaning is function dependent
 15201                                  ;		  (DS:DX) = Return address, use is function dependent
 15202                                  ;	USES	ALL
 15203                                  ;
 15204                                  ;    ============== Generic IOCTL Definitions for DOS 3.2 ============
 15205                                  ;     (See inc\ioctl.inc for more info)
 15206                                  ;
 15207                                  ;	ENTRY	(AL) = function code
 15208                                  ;		  0Dh - Control Function subcode
 15209                                  ;		(BL) = Drive Number (0 = Default, 1= 'A')
 15210                                  ;		(CH) = Category Indicator
 15211                                  ;		(CL) = Function within category
 15212                                  ;		(DS:DX) = address for data, if any
 15213                                  ;		(SI) = Passed to device as argument, use depends upon function
 15214                                  ;		(DI) = Passed to device as argument, use depends upon function
 15215                                  ;
 15216                                  ;	EXIT	'C' set if error
 15217                                  ;		  (AX) = error code
 15218                                  ;		'C' clear if OK
 15219                                  ;		  (DS:DX) = Return address, use is function dependent
 15220                                  ;	USES	ALL
 15221                                  ;
 15222                                  ;---------------------------------------------------------------------------
 15223                                  	
 15224                                  	; 17/05/2019 - Retro DOS v4.0
 15225                                  	; DOSCODE:611Eh (MSDOS 6.21, MSDOS.SYS)
 15226                                  
 15227                                  	; 11/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15228                                  	; DOSCODE:610Ah (MSDOS 5.0, MSDOS.SYS)
 15229                                  
 15230                                  IOCTLJMPTABLE:	;label	word
 15231                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15232 00002273 [B122]                  	dw	ioctl_getset_data	; 0
 15233 00002275 [B122]                  	dw	ioctl_getset_data   	; 1
 15234 00002277 [0123]                  	dw	ioctl_control_string	; 2
 15235 00002279 [0123]                  	dw	ioctl_control_string	; 3
 15236 0000227B [5524]                  	dw	ioctl_get_dev		; 4
 15237 0000227D [5524]                  	dw	ioctl_get_dev		; 5
 15238 0000227F [1B23]                  	dw	ioctl_status		; 6
 15239 00002281 [1B23]                  	dw	ioctl_status		; 7
 15240 00002283 [BC23]                  	dw	ioctl_rem_media		; 8
 15241 00002285 [FA23]                  	dw	ioctl_drive_attr	; 9
 15242 00002287 [4724]                  	dw	ioctl_handle_redir	; A
 15243 00002289 [3723]                  	dw	Set_Retry_Parameters	; B
 15244 0000228B [4523]                  	dw	GENERICIOCTLHANDLE	; C
 15245 0000228D [5C23]                  	dw	GENERICIOCTL		; D
 15246                                  	; MSDOS 6.0 (& MSDOS 3.3)
 15247 0000228F [0625]                  	dw	ioctl_drive_owner	; E
 15248 00002291 [0625]                  	dw	ioctl_drive_owner	; F
 15249                                  	; MSDOS 6.0
 15250 00002293 [4523]                  	dw	query_handle_support	; 10h
 15251 00002295 [5C23]                  	dw	query_device_support	; 11h
 15252                                  
 15253                                  	; 11/11/2022
 15254                                  _$IOCTL:
 15255 00002297 8CDE                    	MOV	SI,DS			; Stash DS for calls 2,3,4 and 5
 15256 00002299 16                      	push	ss
 15257 0000229A 1F                      	pop	ds			;hkn; SS is DOSDATA
 15258                                  
 15259                                  	; MSDOS 3.3
 15260                                  	;cmp	al,0Fh 
 15261                                  	; MSDOS 6.0
 15262 0000229B 3C11                    	cmp	al,11h			; al must be between 0 & 11h
 15263 0000229D 770F                    	ja	short ioctl_bad_funj2	; if not bad function #
 15264                                  
 15265                                  	; 28/05/2019
 15266 0000229F 50                      	push	AX			; Need to save AL for generic IOCTL
 15267 000022A0 89C7                    	mov	di,ax			; di NOT a PARM
 15268 000022A2 81E7FF00                	and	di,0FFh			; di = al
 15269 000022A6 D1E7                    	shl	di,1			; di = index into jmp table
 15270 000022A8 58                      	pop	AX			; Restore AL for generic IOCTL
 15271                                  
 15272 000022A9 2EFFA5[7322]            	jmp	word [CS:DI+IOCTLJMPTABLE]
 15273                                  
 15274                                  ioctl_bad_funj2:
 15275 000022AE E90301                  	JMP	ioctl_bad_fun  ; 10/08/2018
 15276                                  
 15277                                  ;--------------------------------------------------------------------------
 15278                                  ;
 15279                                  ; IOCTL: AL = 0,1
 15280                                  ;
 15281                                  ; ENTRY: DS = DOSDATA
 15282                                  ;
 15283                                  ;--------------------------------------------------------------------------
 15284                                  
 15285                                  ioctl_getset_data:
 15286                                  	; MSDOS 6.0
 15287 000022B1 E8DF43                  	call	SFFromHandle		; ES:DI -> SFT
 15288 000022B4 7305                    	JNC	short ioctl_check_permissions ; have valid handle
 15289                                  ioctl_bad_handle:
 15290                                  	;mov	al,6
 15291 000022B6 B006                    	mov	al,error_invalid_handle
 15292                                  ioctl_error:
 15293 000022B8 E985E3                  	jmp	SYS_RET_ERR
 15294                                  
 15295                                  ioctl_check_permissions:
 15296 000022BB 3C00                    	CMP	AL,0
 15297                                  	;mov	al,[es:di+5]
 15298 000022BD 268A4505                	MOV	AL,[ES:DI+SF_ENTRY.sf_flags]; Get low byte of flags
 15299 000022C1 741B                    	JZ	short ioctl_read	; read the byte
 15300                                  
 15301 000022C3 08F6                    	or	dh,dh
 15302 000022C5 7404                    	JZ	short ioctl_check_device ; can I set with this data?
 15303                                  	;mov	al,0Dh
 15304 000022C7 B00D                    	mov	al,error_invalid_data	; no DH <> 0
 15305                                  	;jmp	SYS_RET_ERR
 15306 000022C9 EBED                    	jmp	short ioctl_error
 15307                                  
 15308                                  ioctl_check_device:
 15309 000022CB A880                    	test	AL,devid_device  ; 80h	; can I set this handle?
 15310 000022CD 74DF                    	jz	short ioctl_bad_funj2
 15311 000022CF 80CA80                  	OR	DL,devid_device 	; Make sure user doesn't turn off the
 15312                                  					;   device bit!! He can muck with the
 15313                                  					;   others at will.
 15314 000022D2 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 15315 000022D7 26885505                	MOV	BYTE [ES:DI+SF_ENTRY.sf_flags],DL  ;AC000;MS.; Set flags
 15316                                  ioctl_ok:
 15317 000022DB E959E3                  	jmp	SYS_RET_OK
 15318                                  
 15319                                  ioctl_read:
 15320 000022DE C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk  ; 2
 15321 000022E3 30E4                    	XOR	AH,AH
 15322 000022E5 A880                    	test	AL,devid_device 	; Should I set high byte
 15323 000022E7 740D                    	JZ	short ioctl_no_high	; no
 15324 000022E9 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 15325                                  	;les	di,[es:di+7]
 15326 000022EE 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 15327                                  	;mov	ah,[es:di+5]
 15328 000022F2 268A6505                	MOV	AH,[ES:DI+SYSDEV.ATT+1] ; Get high byte
 15329                                  ioctl_no_high:
 15330 000022F6 89C2                    	MOV	DX,AX
 15331                                  ioctl_set_dx:	; 16/12/2022
 15332 000022F8 E886E1                  	call	Get_User_Stack
 15333                                  	;mov	[si+6],dx
 15334 000022FB 895406                  	MOV	[SI+user_env.user_DX],DX
 15335                                  	;;jmp	SYS_RET_OK
 15336                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15337                                  ioctl_ok_j:
 15338                                  	; 16/12/2022
 15339 000022FE E939E3                  	jmp	SYS_RET_OK_clc	 ; (after 'Get_User_Stack') 
 15340                                  	;jmp	short ioctl_ok
 15341                                  	; 26/07/2019
 15342                                  	;jmp	SYS_RET_OK_clc
 15343                                  
 15344                                  ;--------------------------------------------------------------------------
 15345                                  ;
 15346                                  ; IOCTL: AL = 2,3
 15347                                  ;
 15348                                  ; ENTRY: DS = DOSDATA
 15349                                  ;	 SI = user's DS
 15350                                  ;
 15351                                  ;--------------------------------------------------------------------------
 15352                                  
 15353                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15354                                  ioctl_control_string:
 15355 00002301 E88F43                  	call	SFFromHandle		; ES:DI -> SFT
 15356 00002304 72B0                    	JC	short ioctl_bad_handle	; invalid handle
 15357                                  	; 07/12/2022
 15358                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 15359                                  	;jz	short ioctl_bad_funj2			; No it is a file
 15360                                  	; MSDOS 5.0 & MSDOS 6.0
 15361 00002306 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 15362 0000230B 74A1                    	jz	short ioctl_bad_funj2			; No it is a file
 15363 0000230D C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 15364 00002312 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 15365 00002316 30DB                    	XOR	BL,BL			; Unit number of char dev = 0
 15366 00002318 E94201                  	JMP	ioctl_do_string
 15367                                  
 15368                                  ;--------------------------------------------------------------------------
 15369                                  ;
 15370                                  ; IOCTL: AL = 6,7
 15371                                  ;
 15372                                  ; ENTRY: DS = DOSDATA
 15373                                  ;
 15374                                  ;--------------------------------------------------------------------------
 15375                                  
 15376                                  ioctl_status:
 15377 0000231B B401                    	MOV	AH,1
 15378 0000231D 2C06                    	SUB	AL,6			; 6=0,7=1
 15379 0000231F 7402                    	JZ	short ioctl_get_status
 15380 00002321 B403                    	MOV	AH,3
 15381                                  ioctl_get_status:
 15382 00002323 50                      	PUSH	AX
 15383 00002324 E85013                  	call	GET_IO_SFT
 15384 00002327 58                      	POP	AX
 15385                                  	;JNC	short DO_IOFUNC
 15386                                  	;JMP	short ioctl_bad_handle	; invalid SFT
 15387                                  	; 16/12/2022
 15388 00002328 728C                    	jc	short ioctl_bad_handle
 15389                                  DO_IOFUNC:
 15390 0000232A E88F21                  	call	IOFUNC
 15391 0000232D 88C4                    	MOV	AH,AL
 15392 0000232F B0FF                    	MOV	AL,0FFH
 15393 00002331 7502                    	JNZ	short ioctl_status_ret
 15394 00002333 FEC0                    	INC	AL
 15395                                  ioctl_status_ret:
 15396                                  	;jmp	SYS_RET_OK
 15397                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15398                                  	;jmp	short ioctl_ok_j
 15399                                  	; 16/12/2022
 15400 00002335 EBA4                    	jmp	short ioctl_ok
 15401                                  
 15402                                  ;--------------------------------------------------------------------------
 15403                                  ;
 15404                                  ; IOCTL: AL = B
 15405                                  ;
 15406                                  ; ENTRY: DS = DOSDATA
 15407                                  ;
 15408                                  ;--------------------------------------------------------------------------
 15409                                  
 15410                                  Set_Retry_Parameters:
 15411                                  	; 09/09/2018
 15412 00002337 890E[1C00]              	MOV	[RetryLoop],CX		; 0 retry loop count allowed
 15413 0000233B 09D2                    	OR	DX,DX			; zero retries not allowed
 15414 0000233D 7475                    	JZ	short ioctl_bad_fun
 15415 0000233F 8916[1A00]              	MOV	[RetryCount],DX		; Set new retry count
 15416                                  doneok:
 15417                                  	;jmp	SYS_RET_OK		; Done
 15418                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15419                                  	;jmp	short ioctl_status_ret
 15420                                  	; 16/12/2022
 15421 00002343 EB96                    	jmp	short ioctl_ok	 ; jmp SYS_RET_OK
 15422                                  
 15423                                  ;--------------------------------------------------------------------------
 15424                                  ;
 15425                                  ; Generic IOCTL entry point. AL = C, D, 10h, 11h
 15426                                  ;
 15427                                  ;	here we invoke the Generic IOCTL using the IOCTL_Req structure.
 15428                                  ;	SI:DX -> Users Device Parameter Table
 15429                                  ;	IOCALL -> IOCTL_Req structure
 15430                                  ;
 15431                                  ; 	If on entry AL >= IOCTL_QUERY_HANDLE the function is a
 15432                                  ;	QueryIOCtlSupport call ELSE it's a standard generic IOCtl
 15433                                  ;	call.
 15434                                  ;
 15435                                  ; BUGBUG: Don't push anything on the stack between GENERIOCTL: and 
 15436                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15437                                  ;         return address off the stack if the drive is invalid.
 15438                                  ;
 15439                                  ;--------------------------------------------------------------------------
 15440                                  
 15441                                  query_handle_support:	; Entry point for handles
 15442                                  GENERICIOCTLHANDLE:
 15443 00002345 E84B43                  	call	SFFromHandle		; Get SFT for device.
 15444 00002348 726F                    	jc	short ioctl_bad_handlej
 15445                                  
 15446                                  	;test	word [es:di+5],8000h
 15447                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet	; M031;
 15448                                  	;test	byte [es:di+6],80h
 15449 0000234A 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 15450 0000234F 7563                    	jnz	short ioctl_bad_fun	; Cannot do this over net.
 15451                                  
 15452 00002351 C606[2303]04            	mov	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 15453                                  	;les	di,[es:di+7]
 15454 00002356 26C47D07                	les	di,[es:di+SF_ENTRY.sf_devptr]	; Get pointer to device.
 15455 0000235A EB0F                    	jmp	short Do_GenIOCTL
 15456                                  
 15457                                  query_device_support:	; Entry point for devices:
 15458                                  GENERICIOCTL:
 15459 0000235C C606[2303]02            	mov	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 15460 00002361 80FD08                  	cmp	ch,IOC_DC ; 8		; Only disk devices are allowed to use
 15461 00002364 754E                    	jne	short ioctl_bad_fun	; no handles with Generic IOCTL.
 15462                                  
 15463 00002366 E88101                  	CALL	Check_If_Net		; ES:DI := Get_hdr_block of device in BL
 15464 00002369 7549                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 15465                                  
 15466                                  Do_GenIOCTL:
 15467                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320 
 15468                                  					; Can device handle Generic IOCTL funcs
 15469                                  	; 09/09/2018
 15470                                  	;test	byte [es:di+4],40h
 15471 0000236B 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 15472 00002370 7442                    	jz	short ioctl_bad_fun
 15473                                  
 15474                                  	; 17/05/2019 - Retro DOS v4.0
 15475                                  
 15476                                  	; MSDOS 6.0
 15477                                  	;mov	byte [IOCALL_REQFUNC],19 ; 13h
 15478 00002372 C606[7E03]13            	mov	byte [IOCALL_REQFUNC],GENIOCTL ; Assume real Request
 15479                                  	;cmp	al,10h
 15480 00002377 3C10                    	cmp	AL,IOCTL_QUERY_HANDLE	; See if this is just a query
 15481 00002379 7C0C                    	jl	short SetIOCtlBlock
 15482                                  	
 15483                                  	;TEST	word [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 15484                                  	;test	byte [es:di+4],80h 
 15485 0000237B 26F6450480              	TEST	byte [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 15486 00002380 7432                    	jz	short ioctl_bad_fun	; No support for query 
 15487                                  	;
 15488                                  	;mov	byte [IOCALL_REQFUNC],19h	
 15489 00002382 C606[7E03]19            	mov	byte [IOCALL_REQFUNC],IOCTL_QUERY ; Just a query (5.00)
 15490                                  
 15491                                  SetIOCtlBlock:
 15492 00002387 06                      	PUSH	ES			; DEVIOCALL2 expects Device header block
 15493 00002388 57                      	PUSH	DI			; in DS:SI
 15494                                  					; Setup Generic IOCTL Request Block
 15495                                  	;mov	byte [IOCALL_REQLEN],23
 15496 00002389 C606[7C03]17            	mov	byte [IOCALL_REQLEN],IOCTL_REQ.size
 15497                                  	; 07/09/2018 (MSDOS 3.3)
 15498                                  	;;mov	byte [IOCALL_REQFUNC],19
 15499                                  	;mov	byte [IOCALL_REQFUNC],GENIOCTL ; 07/09/2018
 15500                                  	;
 15501 0000238E 881E[7D03]              	MOV	[IOCALL_REQUNIT],BL
 15502 00002392 882E[8903]              	MOV	[IOCALL+IOCTL_REQ.MAJORFUNCTION],CH
 15503 00002396 880E[8A03]              	MOV	[IOCALL+IOCTL_REQ.MINORFUNCTION],CL
 15504 0000239A 8936[8B03]              	MOV	[IOCALL+IOCTL_REQ.REG_SI],SI
 15505 0000239E 893E[8D03]              	MOV	[IOCALL+IOCTL_REQ.REG_DI],DI
 15506 000023A2 8916[8F03]              	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET],DX
 15507 000023A6 8936[9103]              	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2],SI
 15508                                  
 15509                                  ;hkn; IOCALL is in DOSDATA
 15510 000023AA BB[7C03]                	MOV	BX,IOCALL
 15511                                  
 15512 000023AD 16                      	PUSH	SS
 15513 000023AE 07                      	POP	ES
 15514                                  					; DS:SI -> Device header.
 15515 000023AF 5E                      	POP	SI
 15516 000023B0 1F                      	POP	DS
 15517                                  	; 10/08/2018
 15518 000023B1 E9E200                  	jmp	ioctl_do_IO		; Perform Call to device driver
 15519                                  
 15520                                  ioctl_bad_fun:
 15521 000023B4 B001                    	mov	al, error_invalid_function  ; 1
 15522 000023B6 E987E2                  	jmp	SYS_RET_ERR	
 15523                                  
 15524                                  ioctl_bad_handlej:
 15525 000023B9 E9FAFE                  	jmp	ioctl_bad_handle
 15526                                  
 15527                                  ;---------------------------------------------------------------------------
 15528                                  ;
 15529                                  ; IOCTL: AL = 8
 15530                                  ;
 15531                                  ; ENTRY: DS = DOSDATA
 15532                                  ;
 15533                                  ; BUGBUG: Don't push anything on the stack between ioctl_rem_media: and 
 15534                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15535                                  ;         return address off the stack if the drive is invalid.
 15536                                  ;
 15537                                  ;-------------------------------------------------------------------------
 15538                                  
 15539                                  ioctl_rem_media:
 15540                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15541 000023BC E82B01                  	CALL	Check_If_Net
 15542 000023BF 75F3                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 15543                                  					;   certainly don't know how to do this
 15544                                  					;   call.
 15545                                  	;test	word [es:di+4],800h
 15546                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL ; See if device can
 15547                                  	;test	byte [es:di+5],8
 15548 000023C1 26F6450508              	TEST	byte [es:di+SYSDEV.ATT+1],(DEVOPCL>>8)
 15549 000023C6 74EC                    	JZ	short ioctl_bad_fun		; NO
 15550                                  
 15551                                  ;hkn; SS override for IOCALL
 15552 000023C8 36C606[7E03]0F          	MOV	byte [SS:IOCALL_REQFUNC],DEVRMD ; 15
 15553 000023CE B00D                    	MOV	AL,REMHL  ; 13
 15554 000023D0 88DC                    	MOV	AH,BL			; Unit number
 15555 000023D2 36A3[7C03]              	MOV	[SS:IOCALL_REQLEN],AX
 15556 000023D6 31C0                    	XOR	AX,AX
 15557 000023D8 36A3[7F03]              	MOV	[SS:IOCALL_REQSTAT],AX
 15558 000023DC 06                      	PUSH	ES
 15559 000023DD 1F                      	POP	DS
 15560 000023DE 89FE                    	MOV	SI,DI			; DS:SI -> driver
 15561 000023E0 16                      	PUSH	SS
 15562 000023E1 07                      	POP	ES
 15563                                  
 15564                                  ;hkn; IOCALL is in DOSDATA (msconst.asm)
 15565 000023E2 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 15566 000023E5 1E                      	push	ds
 15567 000023E6 56                      	push	si
 15568 000023E7 E8A722                  	call	DEVIOCALL2
 15569 000023EA 5E                      	pop	si
 15570 000023EB 1F                      	pop	ds
 15571                                  
 15572                                  ;hkn; SS override
 15573 000023EC 36A1[7F03]              	MOV	AX,[SS:IOCALL_REQSTAT]	; Get Status word
 15574 000023F0 250002                  	AND	AX,STBUI ; 200h		; Mask to busy bit
 15575 000023F3 B109                    	MOV	CL,9
 15576 000023F5 D3E8                    	SHR	AX,CL			; Busy bit to bit 0
 15577                                  ioctl_da_ok_j:	; 11/11/2022
 15578 000023F7 E93DE2                  	jmp	SYS_RET_OK
 15579                                  
 15580                                  ;-------------------------------------------------------------------------
 15581                                  ;
 15582                                  ; IOCTL: AL = 9
 15583                                  ;
 15584                                  ; ENTRY: DS = DOSDATA
 15585                                  ;
 15586                                  ;-------------------------------------------------------------------------
 15587                                  
 15588                                  ioctl_drive_attr:
 15589                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15590 000023FA 88D8                    	mov	al,bl
 15591 000023FC E8B846                  	call	GETTHISDRV
 15592 000023FF 7241                    	jc	short ioctl_drv_err
 15593 00002401 E8B800                  	call	Get_Driver_BL
 15594                                  	; MSDOS 6.0
 15595 00002404 723C                    	JC	short ioctl_drv_err	; drive not valid
 15596                                  
 15597                                  	;mov	dx,[es:di+4]
 15598 00002406 268B5504                	mov	dx,[es:di+SYSDEV.ATT]	
 15599                                  					; get device attribute word
 15600 0000240A 88C3                    	MOV	BL,AL			; Phys letter to BL (A=0)
 15601                                  
 15602                                  ;hkn; SS override
 15603 0000240C 36C43E[A205]            	LES	DI,[SS:THISCDS]
 15604                                  	;test	word [es:di+43h],8000h
 15605                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 15606                                  	;test	byte [es:di+44h],80h
 15607 00002411 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 15608 00002416 7403                    	JZ	short IOCTLShare
 15609                                  
 15610                                  	;or	dx,1000h ; (MSDOS 3.3)
 15611                                  
 15612                                  ;	Net devices don't return a device attribute word.
 15613                                  ;	Bit 12 = 1, meaning net device, all others = 0.
 15614                                  
 15615 00002418 BA0010                  	MOV	DX,1000h ; MSDOS 6.0
 15616                                  IOCTLShare:
 15617 0000241B 16                      	push	ss
 15618 0000241C 1F                      	pop	ds
 15619 0000241D BE[BE03]                	MOV	SI,OPENBUF
 15620 00002420 80C341                  	ADD	BL,"A"	; 41h
 15621 00002423 881C                    	MOV	[SI],BL
 15622 00002425 C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
 15623 0000242A B80003                  	MOV	AX,0300h
 15624 0000242D F8                      	CLC
 15625                                  	;INT	int_IBM
 15626 0000242E CD2A                    	int     2Ah	; Microsoft Networks - CHECK DIRECT I/O
 15627                                  			; DS:SI -> ASCIZ disk device name 
 15628                                  			; (may be full path or only drive
 15629                                  			; specifier--must include the colon)
 15630                                  			; Return: CF clear if absolute disk access allowed
 15631 00002430 7303                    	JNC	short IOCTLLocal	; Not shared
 15632                                  	;OR	DX,0200H		; Shared, bit 9
 15633                                  	; 17/12/2022
 15634 00002432 80CE02                  	or	dh,02h
 15635                                  IOCTLLocal:
 15636                                  	;test	word [es:di+43h],1000h
 15637                                  	;TEST	word [ES:DI+curdir.flags],curdir_local
 15638                                  	;test	byte [es:di+44h],10h
 15639 00002435 26F6454410              	TEST	byte [ES:DI+curdir.flags+1],(curdir_local>>8)
 15640                                  	;JZ	short ioctl_set_DX
 15641                                  	; 16/12/2022
 15642 0000243A 7403                    	jz	short _ioctl_set_DX
 15643                                  	;OR	DX,8000h
 15644                                  	; 17/12/2022
 15645 0000243C 80CE80                  	or	dh,80h
 15646                                  ;ioctl_set_DX:
 15647                                  _ioctl_set_DX:
 15648                                  	; 16/12/2022
 15649 0000243F E9B6FE                  	jmp	ioctl_set_dx
 15650                                  ; 16/12/2022
 15651                                  %if 0	
 15652                                  	call	Get_User_Stack
 15653                                  	MOV	[SI+user_env.user_DX],DX
 15654                                  	;;jmp	SYS_RET_OK
 15655                                  	;; 25/06/2019
 15656                                  	;jmp	SYS_RET_OK_clc
 15657                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15658                                  ioctl_gd_ok_j:
 15659                                  	jmp	short ioctl_da_ok_j
 15660                                  %endif
 15661                                  
 15662                                  ioctl_drv_err:
 15663 00002442 B00F                    	mov	al,error_invalid_drive ; 0Fh
 15664                                  ioctl_gd_err_j:	; 11/11/2022
 15665 00002444 E9F9E1                  	jmp	SYS_RET_ERR
 15666                                  
 15667                                  ;--------------------------------------------------------------------------
 15668                                  ;
 15669                                  ; IOCTL: AL = A
 15670                                  ;
 15671                                  ; ENTRY: DS = DOSDATA
 15672                                  ;
 15673                                  ;--------------------------------------------------------------------------
 15674                                  
 15675                                  ioctl_handle_redir:
 15676 00002447 E84942                  	call	SFFromHandle		; ES:DI -> SFT
 15677 0000244A 7303                    	JNC	short ioctl_got_sft	; have valid handle
 15678 0000244C E967FE                  	jmp	ioctl_bad_handle ; 10/08/2018
 15679                                  
 15680                                  ioctl_got_sft:
 15681                                  	;mov	dx,[es:di+5]
 15682 0000244F 268B5505                	MOV	DX,[ES:DI+SF_ENTRY.sf_flags] ; Get flags
 15683                                  	;JMP	short ioctl_set_DX	; pass dx to user and return
 15684                                  	; 16/12/2022
 15685 00002453 EBEA                    	jmp	short _ioctl_set_DX
 15686                                  
 15687                                  	; 16/12/2022
 15688                                  ;ioctl_bad_funj:
 15689                                  	;JMP	ioctl_bad_fun
 15690                                  
 15691                                  ;--------------------------------------------------------------------------
 15692                                  ;
 15693                                  ; IOCTL: AL= 4,5
 15694                                  ;
 15695                                  ; ENTRY: DS = DOSDATA
 15696                                  ;	 SI = user's DS
 15697                                  ;
 15698                                  ;
 15699                                  ; BUGBUG: Don't push anything on the stack between ioctl_get_dev: and 
 15700                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15701                                  ;         return address off the stack if the drive is invalid.
 15702                                  ;
 15703                                  ;-------------------------------------------------------------------------
 15704                                  
 15705                                  ioctl_get_dev:
 15706 00002455 E89200                  	CALL	Check_If_Net
 15707                                  	;JNZ	short ioctl_bad_funj	; There are no "net devices", and they
 15708                                  					; certainly don't know how to do this
 15709                                  					; call.
 15710                                  	; 16/12/2022
 15711 00002458 7403                    	jz	short ioctl_do_string
 15712                                  ioctl_bad_funj:
 15713 0000245A E957FF                  	JMP	ioctl_bad_fun
 15714                                  
 15715                                  ioctl_do_string:
 15716                                  	;test	word [es:di+4],4000h
 15717                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVIOCTL; See if device accepts control
 15718                                  	;test	byte [es:di+5],40h
 15719 0000245D 26F6450540              	TEST	byte [ES:DI+SYSDEV.ATT+1],(DEVIOCTL>>8)
 15720 00002462 74F6                    	JZ	short ioctl_bad_funj		; NO
 15721                                  					; assume IOCTL read
 15722 00002464 C606[7E03]03            	MOV	byte [IOCALL_REQFUNC],DEVRDIOCTL  ; 3
 15723                                  
 15724 00002469 A801                    	TEST	AL,1			; is it func. 4/5 or 2/3
 15725 0000246B 7405                    	JZ	short ioctl_control_call ; it is read. goto ioctl_control_call
 15726                                  
 15727                                  					; it is an IOCTL write
 15728 0000246D C606[7E03]0C            	MOV	byte [IOCALL_REQFUNC],DEVWRIOCTL ; 12
 15729                                  
 15730                                  ioctl_control_call:
 15731 00002472 B016                    	MOV	AL,DRDWRHL ; 22
 15732                                  ioctl_setup_pkt:
 15733 00002474 88DC                    	MOV	AH,BL			; Unit number
 15734 00002476 A3[7C03]                	MOV	[IOCALL_REQLEN],AX
 15735 00002479 31C0                    	XOR	AX,AX
 15736 0000247B A3[7F03]                	MOV	[IOCALL_REQSTAT],AX
 15737 0000247E A2[8903]                	MOV	[IOMED],AL
 15738 00002481 890E[8E03]              	MOV	[IOSCNT],CX
 15739 00002485 8916[8A03]              	MOV	[IOXAD],DX
 15740 00002489 8936[8C03]              	MOV	[IOXAD+2],SI
 15741 0000248D 06                      	PUSH	ES
 15742 0000248E 1F                      	POP	DS
 15743 0000248F 89FE                    	MOV	SI,DI			; DS:SI -> driver
 15744 00002491 16                      	PUSH	SS
 15745 00002492 07                      	POP	ES
 15746                                  
 15747 00002493 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 15748                                  ioctl_do_IO:
 15749 00002496 E8F821                  	call	DEVIOCALL2
 15750                                  
 15751                                  ;hkn; SS override for IOCALL
 15752                                  	;test	word [SS:IOCALL_REQSTAT],8000h
 15753                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 15754                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 15755 00002499 36F606[8003]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 15756 0000249F 7507                    	JNZ	short ioctl_string_err
 15757                                  
 15758                                  ;hkn; SS override
 15759 000024A1 36A1[8E03]              	MOV	AX,[SS:IOSCNT]		; Get actual bytes transferred
 15760                                  	; 16/12/2022
 15761 000024A5 E98FE1                  	jmp	SYS_RET_OK
 15762                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15763                                  	;jmp	short ioctl_gd_ok_j
 15764                                  
 15765                                  ioctl_string_err:
 15766 000024A8 368B3E[7F03]            	MOV	DI,[SS:IOCALL_REQSTAT]	;Get Error
 15767                                  device_err:
 15768 000024AD 81E7FF00                	AND	DI,STECODE ; 00FFh	; mask out irrelevant bits
 15769 000024B1 89F8                    	MOV	AX,DI
 15770 000024B3 E86A30                  	call	SET_I24_EXTENDED_ERROR
 15771                                  
 15772                                  ;hkn; use SS override
 15773                                  ;hkn;	mov	ax,[CS:EXTERR]
 15774 000024B6 36A1[2403]              	mov	ax,[SS:EXTERR]
 15775                                  	;jmp	SYS_RET_ERR
 15776                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15777 000024BA EB88                    	jmp	short ioctl_gd_err_j
 15778                                  
 15779                                  ; 17/05/2019 - Retro DOS v4.0
 15780                                  
 15781                                  ;--------------------------------------------------------------------------
 15782                                  ; Proc name : Get_Driver_BL
 15783                                  ;
 15784                                  ;	DS is DOSDATA
 15785                                  ;	BL is drive number (0=default)
 15786                                  ;	Returns pointer to device in ES:DI, unit number in BL if carry clear
 15787                                  ;	No regs modified
 15788                                  ;
 15789                                  ;---------------------------------------------------------------------------
 15790                                  
 15791                                  Get_Driver_BL:
 15792 000024BC 50                      	PUSH	AX
 15793 000024BD 88D8                    	MOV	AL,BL			; Drive
 15794 000024BF E8F545                  	call	GETTHISDRV
 15795 000024C2 7224                    	jc	short ioctl_bad_drv
 15796 000024C4 30DB                    	XOR	BL,BL			; Unit zero on Net device
 15797 000024C6 C606[2303]03            	MOV	byte [EXTERR_LOCUS],errLOC_Net ; 3
 15798 000024CB C43E[A205]              	LES	DI,[THISCDS]
 15799                                  	;test	word [es:di+43h],8000h
 15800                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 15801                                  	;test	byte [es:di+44h],80h
 15802 000024CF 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 15803                                  	;les	di,[es:di+45h]
 15804 000024D4 26C47D45                	LES	DI,[ES:DI+curdir.devptr] ; ES:DI -> Dpb or net dev
 15805 000024D8 750D                    	JNZ	short got_dev_ptr	 ; Is net
 15806 000024DA C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 15807                                  	;mov	bl,[es:di+1]
 15808 000024DF 268A5D01                	MOV	BL,[ES:DI+DPB.UNIT]	; Unit number
 15809                                  	;les	di,[es:di+13h]
 15810 000024E3 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Driver addr
 15811                                  got_dev_ptr:
 15812 000024E7 F8                      	CLC
 15813                                  ioctl_bad_drv:
 15814 000024E8 58                      	POP	AX
 15815 000024E9 C3                      	retn
 15816                                  
 15817                                  ;-------------------------------------------------------------------------
 15818                                  ; Proc Name : Check_If_Net:
 15819                                  ;
 15820                                  ;
 15821                                  ; Checks if the device is over the net or not. Returns result in ZERO flag.
 15822                                  ; If no device is found, the return address is popped off the stack, and a
 15823                                  ; jump is made to ioctl_drv_err.
 15824                                  ;
 15825                                  ; On Entry:
 15826                                  ; Registers same as those for Get_Driver_BL
 15827                                  ;
 15828                                  ; On Exit:
 15829                                  ; ZERO flag	- set if not a net device
 15830                                  ;		- reset if net device
 15831                                  ; ES:DI -> the device
 15832                                  ;
 15833                                  ;
 15834                                  ; BUGBUG: This function assumes the following stack setup on entry
 15835                                  ;
 15836                                  ;	  SP+2 -> Error return address
 15837                                  ;	  SP   -> Normal return address
 15838                                  ;
 15839                                  ;-------------------------------------------------------------------------
 15840                                  
 15841                                  Check_If_Net:
 15842                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15843 000024EA E8CFFF                  	CALL	Get_Driver_BL
 15844 000024ED 720E                    	JC	short ioctl_drv_err_pop	; invalid drive letter
 15845 000024EF 06                      	PUSH	ES
 15846 000024F0 57                      	PUSH	DI
 15847 000024F1 C43E[A205]              	LES	DI,[THISCDS]
 15848                                  	;test	word [es:di+43h],8000h
 15849                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 15850                                  	;test	byte [es:di+44h],80h
 15851 000024F5 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 15852 000024FA 5F                      	POP	DI
 15853 000024FB 07                      	POP	ES
 15854 000024FC C3                      	retn
 15855                                  
 15856                                  ioctl_drv_err_pop:
 15857 000024FD 58                      	pop	ax			; pop off return address
 15858 000024FE E941FF                  	jmp	ioctl_drv_err
 15859                                  
 15860                                  ioctl_bad_funj3:
 15861 00002501 E9B0FE                  	jmp	ioctl_bad_fun
 15862                                  
 15863                                  ioctl_string_errj:
 15864 00002504 EBA2                    	jmp	short ioctl_string_err  ; 25/05/2019
 15865                                  
 15866                                  ;--------------------------------------------------------------------------
 15867                                  ;
 15868                                  ; IOCTL: AL = E, F
 15869                                  ;
 15870                                  ; ENTRY: DS = DOSDATA
 15871                                  ;
 15872                                  ;
 15873                                  ; BUGBUG: Don't push anything on the stack between ioctl_drive_owner: and 
 15874                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15875                                  ;         return address off the stack if the drive is invalid.
 15876                                  ;
 15877                                  ;--------------------------------------------------------------------------
 15878                                  
 15879                                  ioctl_drive_owner:
 15880                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15881 00002506 E8E1FF                  	Call	Check_If_Net
 15882 00002509 75F6                    	JNZ	short ioctl_bad_funj3 	; There are no "net devices", and they
 15883                                  					;   certainly don't know how to do this
 15884                                  					;   call.
 15885                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320	; See if device can handle this
 15886                                  	; 09/09/2018
 15887                                  	;test	byte [es:di+4],40h
 15888 0000250B 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 15889 00002510 74EF                    	JZ	short ioctl_bad_funj3 	; NO
 15890                                  	;mov	byte [IOCALL_REQFUNC],23
 15891 00002512 C606[7E03]17            	mov	byte [IOCALL_REQFUNC],DEVGETOWN	; default to get owner
 15892 00002517 3C0E                    	cmp	al,0Eh			; Get Owner ?
 15893 00002519 7405                    	jz	short GetOwner
 15894                                  SetOwner:
 15895 0000251B C606[7E03]18            	MOV	byte [IOCALL_REQFUNC],DEVSETOWN ; 24
 15896                                  GetOwner:
 15897 00002520 B00D                    	MOV	AL,OWNHL ; 13
 15898 00002522 88DC                    	MOV	AH,BL			; Unit number
 15899 00002524 A3[7C03]                	MOV	[IOCALL_REQLEN],AX
 15900 00002527 31C0                    	XOR	AX,AX
 15901 00002529 A3[7F03]                	MOV	[IOCALL_REQSTAT],AX
 15902 0000252C 06                      	PUSH	ES
 15903 0000252D 1F                      	POP	DS
 15904 0000252E 89FE                    	MOV	SI,DI			; DS:SI -> driver
 15905 00002530 16                      	PUSH	SS
 15906 00002531 07                      	POP	ES
 15907 00002532 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 15908 00002535 1E                      	push	ds
 15909 00002536 56                      	push	si
 15910 00002537 E85721                  	call	DEVIOCALL2
 15911 0000253A 5E                      	pop	si
 15912 0000253B 1F                      	pop	ds
 15913                                  ;hkn; SS override
 15914                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 15915                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 15916 0000253C 36F606[8003]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 15917 00002542 75C0                    	jnz	short ioctl_string_errj
 15918 00002544 36A0[7D03]              	MOV	AL,[SS:IOCALL_REQUNIT]	; Get owner returned by device
 15919                                  					; owner returned is 1-based.
 15920 00002548 E9ECE0                  	jmp	SYS_RET_OK
 15921                                  
 15922                                  ;============================================================================
 15923                                  ; DELETE.ASM, MSDOS 6.0, 1991
 15924                                  ;============================================================================
 15925                                  ; 07/08/2018 - Retro DOS v3.0
 15926                                  ; 17/05/2019 - Retro DOS v4.0
 15927                                  
 15928                                  ;	TITLE	DOS_DELETE - Internal DELETE call for MS-DOS
 15929                                  ;	NAME	DOS_DELETE
 15930                                  
 15931                                  ;
 15932                                  ;	Microsoft Confidential
 15933                                  ;	Copyright (C) Microsoft Corporation 1991
 15934                                  ;	All Rights Reserved.
 15935                                  ;
 15936                                  
 15937                                  ;**	DELETE.ASM - Low level routine for deleting files
 15938                                  ;----------------------------------------------------------------------------
 15939                                  ;		DOS_DELETE
 15940                                  ;		REN_DEL_Check
 15941                                  ;		FastOpen_Delete	       ; DOS 3.3
 15942                                  ;		FastOpen_Update	       ; DOS 3.3
 15943                                  
 15944                                  ;   Revision history:
 15945                                  ;
 15946                                  ;   A000  version 4.00	Jan. 1988
 15947                                  ;   A001  Fastopen Rename fix	April 1989
 15948                                  
 15949                                  ;Installed = TRUE
 15950                                  
 15951                                  ;	i_need	NoSetDir,BYTE
 15952                                  ;	i_need	Creating,BYTE
 15953                                  ;	i_need	DELALL,BYTE
 15954                                  ;	i_need	THISDPB,DWORD
 15955                                  ;	i_need	THISSFT,DWORD
 15956                                  ;	i_need	THISCDS,DWORD
 15957                                  ;	i_need	CURBUF,DWORD
 15958                                  ;	i_need	ATTRIB,BYTE
 15959                                  ;	i_need	SATTRIB,BYTE
 15960                                  ;	i_need	WFP_START,WORD
 15961                                  ;	i_need	REN_WFP,WORD			 ;BN001
 15962                                  ;	i_need	NAME1,BYTE			 ;BN001
 15963                                  ;	i_need	FoundDel,BYTE
 15964                                  ;	i_need	AUXSTACK,BYTE
 15965                                  ;	i_need	VOLCHNG_FLAG,BYTE
 15966                                  ;	i_need	JShare,DWORD
 15967                                  ;	i_need	FastOpenTable,BYTE		  ; DOS 3.3
 15968                                  ;	i_need	FastTable,BYTE			  ; DOS 4.00
 15969                                  ;
 15970                                  ;	i_need	Del_ExtCluster,WORD		  ; DOS 4.00
 15971                                  ;
 15972                                  ;	i_need	SAVE_BX,WORD			  ; DOS 4.00
 15973                                  ;	i_need	DMAADD,DWORD
 15974                                  ;	i_need	RENAMEDMA,BYTE
 15975                                  
 15976                                  ;----------------------------------------------------------------------------
 15977                                  ;
 15978                                  ; Procedure Name : DOS_DELETE
 15979                                  ;
 15980                                  ; Inputs:
 15981                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 15982                                  ;		terminated)
 15983                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 15984                                  ;		( = -1 if current dir not involved, else
 15985                                  ;		 Points to first char after last "/" of current dir part)
 15986                                  ;	[THISCDS] Points to CDS being used
 15987                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 15988                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 15989                                  ; Function:
 15990                                  ;	Delete the specified file(s)
 15991                                  ; Outputs:
 15992                                  ;	CARRY CLEAR
 15993                                  ;		OK
 15994                                  ;	CARRY SET
 15995                                  ;	    AX is error code
 15996                                  ;		error_file_not_found
 15997                                  ;			Last element of path not found
 15998                                  ;		error_path_not_found
 15999                                  ;			Bad path (not in curr dir part if present)
 16000                                  ;		error_bad_curr_dir
 16001                                  ;			Bad path in current directory part of path
 16002                                  ;		error_access_denied
 16003                                  ;			Attempt to delete device or directory
 16004                                  ;		***error_sharing_violation***
 16005                                  ;			Deny both access required, generates an INT 24.
 16006                                  ;			This error is NOT returned. The INT 24H is generated,
 16007                                  ;			  and the file is ignored (not deleted). Delete will
 16008                                  ;			  simply continue on looking for more files.
 16009                                  ;			  Carry will NOT be set in this case.
 16010                                  ; DS preserved, others destroyed
 16011                                  ;
 16012                                  ;----------------------------------------------------------------------------
 16013                                  
 16014                                  FILEFOUND   equ 01h
 16015                                  FILEDELETED equ 10h
 16016                                  
 16017                                  
 16018                                  	; 12/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16019                                  	; DOSCODE:63E9h (MSDOS 5.0, MSDOS.SYS)
 16020                                  
 16021                                  DOS_DELETE:
 16022                                  
 16023                                  ;hkn; DOS_Delete is called from file.asm and fcbio.asm. DS has been set up 
 16024                                  ;hkn; appropriately at this point.
 16025                                  
 16026 0000254B E8FFEC                  	call	TestNet
 16027 0000254E 7306                    	JNC	short LOCAL_DELETE
 16028                                  
 16029                                  ;IF NOT Installed
 16030                                  ;	transfer NET_DELETE
 16031                                  ;ELSE
 16032                                  	;MOV	AX,(MultNET SHL 8) | 19
 16033                                  	;INT	2FH
 16034                                  	;return
 16035                                  
 16036 00002550 B81311                  	mov	ax,1113h
 16037 00002553 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
 16038                                  			; SS = DS = DOS CS, SDA first filename pointer -> 
 16039                                  			;		fully-qualified filename in DOS CS
 16040                                  			; SDA CDS pointer -> current directory structure for drive with file
 16041                                  			; Return: CF set on error
 16042 00002555 C3                      	retn
 16043                                  ;ENDIF
 16044                                  
 16045                                  LOCAL_DELETE:
 16046 00002556 C606[6F05]00            	MOV	byte [FOUNDDEL],0	; No files found and no files deleted
 16047 0000255B E8B3ED                  	call	ECritDisk
 16048                                  	;mov	word [CREATING],0E500h
 16049 0000255E C706[7E05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Assume not del *.*
 16050 00002564 8B36[B205]              	MOV	SI,[WFP_START]
 16051                                  SKPNUL:
 16052 00002568 AC                      	LODSB
 16053 00002569 08C0                    	OR	AL,AL
 16054 0000256B 75FB                    	JNZ	short SKPNUL		; go to end
 16055 0000256D 83EE04                  	SUB	SI,4			; Back over possible "*.*"
 16056 00002570 813C2A2E                	CMP	WORD [SI],2E2Ah ; "*."
 16057 00002574 7506                    	JNZ	short TEST_QUEST
 16058 00002576 807C022A                	CMP	BYTE [SI+2],"*"
 16059 0000257A 741F                    	JZ	short CHECK_ATTS
 16060                                  TEST_QUEST:
 16061 0000257C 83EE09                  	SUB	SI,9		; Back over possible "????????.???"
 16062 0000257F 87FE                    	XCHG	DI,SI
 16063                                  
 16064 00002581 16                      	push	ss
 16065                                  	;pop	ds ; ! Retro DOS v3.0 BUG !
 16066 00002582 07                      	pop	es ; 17/05/2019
 16067                                  
 16068 00002583 B83F3F                  	MOV	AX,"??" ; 3F3Fh
 16069 00002586 B90400                  	MOV	CX,4		; four sets of "??"
 16070 00002589 F3AF                    	REPE	SCASW
 16071 0000258B 751C                    	JNZ	short NOT_ALL
 16072 0000258D 87FE                    	XCHG	DI,SI
 16073 0000258F AD                      	LODSW
 16074 00002590 3D2E3F                  	CMP	AX,3F2Eh ; ".?"
 16075 00002593 7514                    	JNZ	short NOT_ALL
 16076 00002595 AD                      	LODSW
 16077 00002596 3D3F3F                  	CMP	AX,"??"
 16078 00002599 750E                    	JNZ	short NOT_ALL
 16079                                  CHECK_ATTS:
 16080 0000259B A0[6D05]                	MOV	AL,[SATTRIB]
 16081                                  	;and	al,1Fh
 16082 0000259E 241F                    	AND	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 16083                                  					; Look only at hidden bits
 16084                                  	;cmp	al,1Fh
 16085 000025A0 3C1F                    	CMP	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 16086                                  					; All must be set
 16087 000025A2 7505                    	JNZ	short NOT_ALL
 16088                                  
 16089                                  ; NOTE WARNING DANGER-----
 16090                                  ;    This DELALL stuff is not safe. It allows directories to be deleted.
 16091                                  ;	It should ONLY be used by FORMAT in the ROOT directory.
 16092                                  
 16093 000025A4 C606[7F05]00            	MOV	byte [DELALL],0		; DEL *.* - flag deleting all
 16094                                  NOT_ALL:
 16095 000025A9 C606[4C03]01            	MOV	byte [NoSetDir],1
 16096 000025AE E89519                  	call	GetPathNoSet
 16097 000025B1 7312                    	JNC	short Del_found
 16098 000025B3 750B                    	JNZ	short _bad_path
 16099 000025B5 08C9                    	OR	CL,CL
 16100 000025B7 7407                    	JZ	short _bad_path
 16101                                  No_file:
 16102 000025B9 B80200                  	MOV	AX,error_file_not_found
 16103                                  ErrorReturn:
 16104 000025BC F9                      	STC
 16105                                  	;call	LCritDisk
 16106                                  	;retn
 16107                                  	; 18/12/2022
 16108 000025BD E96CED                  	jmp	LCritDisk
 16109                                  
 16110                                  _bad_path:
 16111 000025C0 B80300                  	MOV	AX,error_path_not_found
 16112 000025C3 EBF7                    	JMP	short ErrorReturn
 16113                                  
 16114                                  Del_found:
 16115 000025C5 750C                    	JNZ	short NOT_DIR		; Check for dir specified
 16116 000025C7 803E[7F05]00            	CMP	byte [DELALL],0		; DelAll = 0 allows delete of dir.
 16117 000025CC 7405                    	JZ	short NOT_DIR
 16118                                  Del_access_err:
 16119 000025CE B80500                  	MOV	AX,error_access_denied
 16120 000025D1 EBE9                    	JMP	short ErrorReturn
 16121                                  
 16122                                  NOT_DIR:
 16123 000025D3 08E4                    	OR	AH,AH			; Check if device name
 16124 000025D5 78F7                    	JS	short Del_access_err	; Can't delete I/O devices
 16125                                  
 16126                                  ; Main delete loop. CURBUF+2:BX points to a matching directory entry.
 16127                                  
 16128                                  DELFILE:
 16129 000025D7 800E[6F05]01            	OR	byte [FOUNDDEL],FILEFOUND ; file found, not deleted yet
 16130                                  
 16131                                  ; If we are deleting the Volume ID, then we set VOLUME_CHNG flag to make
 16132                                  ; DOS issue a build BPB call the next time this drive is accessed.
 16133                                  
 16134 000025DC 1E                      	PUSH	DS
 16135 000025DD 8A26[7F05]              	MOV	AH,[DELALL]
 16136 000025E1 C53E[E205]              	LDS	DI,[CURBUF]
 16137                                  	
 16138                                  ;hkn; SS override
 16139 000025E5 36F606[6B05]01          	TEST	byte [SS:ATTRIB],attr_read_only ; are we deleting RO files too?
 16140 000025EB 7509                    	JNZ	short DoDelete		; yes
 16141                                  
 16142 000025ED F6470B01                	TEST	byte [BX+dir_entry.dir_attr],attr_read_only
 16143 000025F1 7403                    	JZ	short DoDelete		; not read only
 16144                                  
 16145 000025F3 1F                      	POP	DS
 16146 000025F4 EB32                    	JMP	SHORT DELNXT		; Skip it (Note ES:BP not set)
 16147                                  
 16148                                  DoDelete:
 16149 000025F6 E88400                  	call	REN_DEL_Check		; Sets ES:BP = [THISDPB]
 16150 000025F9 7303                    	JNC	short DEL_SHARE_OK
 16151 000025FB 1F                      	POP	DS
 16152 000025FC EB2A                    	JMP	SHORT DELNXT		; Skip it
 16153                                  
 16154                                  DEL_SHARE_OK:
 16155                                  	; 17/05/2019 - Retro DOS v4.0
 16156                                  	; MSDOS 6.0
 16157                                  	;test	byte [di+5],40h
 16158 000025FE F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 16159                                  					;LB. if already dirty		  ;AN000;
 16160 00002602 7507                    	JNZ	short yesdirty		;LB.  don't increment dirty count ;AN000;
 16161 00002604 E86B35                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 16162                                  	;or	byte [di+5],40h
 16163 00002607 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty
 16164                                  yesdirty:
 16165 0000260B 8827                    	mov	[bx],ah 
 16166                                  	;MOV	[BX+dir_entry.dir_name],AH ; Put in E5H or 0
 16167 0000260D 8B1C                    	MOV	BX,[SI] 		; Get firclus pointer
 16168 0000260F 1F                      	POP	DS
 16169 00002610 800E[6F05]10            	OR	byte [FOUNDDEL],FILEDELETED ; 10h ; Deleted file
 16170                                  
 16171 00002615 83FB02                  	CMP	BX,2
 16172 00002618 720E                    	JB	short DELNXT		; File has invalid FIRCLUS (too small)
 16173                                  	;cmp	bx,[es:bp+0Dh]
 16174 0000261A 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 16175 0000261E 7708                    	JA	short DELNXT		; File has invalid FIRCLUS (too big)
 16176                                  
 16177 00002620 E8BD28                  	call	RELEASE 		; Free file data
 16178 00002623 7252                    	JC	short No_fileJ
 16179                                  
 16180                                  ; DOS 3.3  FastOpen
 16181                                  
 16182 00002625 E8C300                  	CALL	FastOpen_Delete 	; delete the dir info in fastopen
 16183                                  
 16184                                  ; DOS 3.3  FastOpen
 16185                                  
 16186                                  DELNXT:
 16187 00002628 C42E[8A05]              	LES	BP,[THISDPB]		; Possible to get here without this set
 16188 0000262C E88218                  	call	GETENTRY		; Registers need to be reset
 16189 0000262F 7246                    	JC	short No_fileJ
 16190 00002631 E8BB17                  	call	NEXTENT
 16191 00002634 73A1                    	JNC	short DELFILE
 16192 00002636 C42E[8A05]              	LES	BP,[THISDPB]		; NEXTENT sets ES=DOSGROUP
 16193                                  	; 12/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16194                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 16195                                  	;;mov	al,[es:bp+0]
 16196                                  	; 15/12/2022
 16197 0000263A 268A4600                	MOV	AL,[ES:BP]
 16198 0000263E E82C34                  	call	FLUSHBUF
 16199 00002641 7234                    	JC	short No_fileJ
 16200                                  ;
 16201                                  ; Now we need to test FoundDel for our flags. The cases to consider are:
 16202                                  ;
 16203                                  ;   not found not deleted		file not found
 16204                                  ;   not found	  deleted		*** impossible ***
 16205                                  ;	found not deleted		access denied (read-only)
 16206                                  ;	found	  deleted		no error
 16207                                  ;
 16208 00002643 F606[6F05]10            	TEST	byte [FOUNDDEL],FILEDELETED ; did we delete a file?
 16209 00002648 7426                    	JZ	short DelError		; no, figure out what's wrong.
 16210                                  ; We set VOLCHNG_FLAG to indicate that we have changed the volume label
 16211                                  ; and to force the DOS to issue a media check.
 16212 0000264A F606[6B05]08            	TEST	byte [ATTRIB],attr_volume_id ; 8
 16213 0000264F 741C                    	jz	short No_Set_Flag
 16214 00002651 50                      	PUSH	AX
 16215 00002652 06                      	PUSH	ES
 16216 00002653 57                      	PUSH	DI
 16217 00002654 C43E[A205]              	LES	DI,[THISCDS]
 16218 00002658 268A25                  	MOV	AH,[ES:DI]		; Get drive
 16219 0000265B 80EC41                  	SUB	AH,'A'                  ; Convert to 0-based
 16220 0000265E 8826[A10A]              	mov	[VOLCHNG_FLAG],AH
 16221                                  	
 16222                                  	; MSDOS 6.0
 16223 00002662 30FF                    	XOR	BH,BH			;>32mb delete volume id from boot record ;AN000;
 16224 00002664 E8DC04                  	call	Set_Media_ID		;>32mb set volumme id to boot record	 ;AN000;
 16225                                  	 
 16226 00002667 E88A30                  	call	FATREAD_CDS		; force media check
 16227 0000266A 5F                      	POP	DI
 16228 0000266B 07                      	POP	ES
 16229 0000266C 58                      	POP	AX
 16230                                  No_Set_Flag:
 16231                                  	;call	LCritDisk		; carry is clear
 16232                                  	;retn
 16233                                  	; 18/12/2022
 16234 0000266D E9BCEC                  	jmp	LCritDisk
 16235                                  DelError:
 16236 00002670 F606[6F05]01            	TEST	byte [FOUNDDEL],FILEFOUND ; not deleted. Did we find file?
 16237 00002675 7503                    	JNZ	short Del_access_errJ 	; yes. Access denied
 16238                                  No_fileJ:
 16239 00002677 E93FFF                  	JMP	No_file ; 10/08/2018 		; Nope
 16240                                  Del_access_errJ:
 16241 0000267A E951FF                  	JMP	Del_access_err ; 10/08/2018
 16242                                  
 16243                                  ; 08/08/2018 - Retro DOS v3.0
 16244                                  
 16245                                  ;Break	<REN_DEL_Check - check for access for rename and delete>
 16246                                  ;---------------------------------------------------------------------------
 16247                                  ; Procedure Name : REN_DEL_Check
 16248                                  ;
 16249                                  ; Inputs:
 16250                                  ;	[THISDPB] set
 16251                                  ;	[CURBUF+2]:BX points to entry
 16252                                  ;	[CURBUF+2]:SI points to firclus field of entry
 16253                                  ;	[WFP_Start] points to name
 16254                                  ; Function:
 16255                                  ;	Check for Exclusive access on given file.
 16256                                  ;	  Used by RENAME, SET_FILE_INFO, and DELETE.
 16257                                  ; Outputs:
 16258                                  ;	ES:BP = [THISDPB]
 16259                                  ;	NOTE: The WFP string pointed to by [WFP_Start] Will be Modified.  The
 16260                                  ;		last element will be loaded from the directory entry.  This is
 16261                                  ;		so the name given to the sharer doesn't have any meta chars in
 16262                                  ;		it.
 16263                                  ;	Carry set if sharing violation, INT 24H generated
 16264                                  ;	    NOTE THAT AX IS NOT error_sharing_violation.
 16265                                  ;		This is because input AX is preserved.
 16266                                  ;		Caller must set the error if needed.
 16267                                  ;	Carry clear
 16268                                  ;		OK
 16269                                  ; AX,DS,BX,SI,DI preserved
 16270                                  ;---------------------------------------------------------------------------
 16271                                  
 16272                                  REN_DEL_Check:
 16273                                  
 16274 0000267D 1E                      	PUSH	DS
 16275 0000267E 57                      	PUSH	DI
 16276 0000267F 50                      	PUSH	AX
 16277 00002680 53                      	PUSH	BX
 16278 00002681 56                      	PUSH	SI		; Save CURBUF pointers
 16279                                  	
 16280 00002682 16                      	push	ss
 16281 00002683 07                      	pop	es
 16282                                  
 16283                                  ;hkn; context ES will assume ES to DOSDATA
 16284                                  ;hkn; ASSUME	ES:DOSGROUP
 16285                                  
 16286                                  ;hkn; SS override
 16287 00002684 368B3E[B205]            	MOV	DI,[SS:WFP_START] ; ES:DI -> WFP
 16288 00002689 89DE                    	MOV	SI,BX
 16289                                  
 16290                                  ;hkn; SS override
 16291 0000268B 368E1E[E405]            	MOV	DS,[SS:CURBUF+2] ; DS:SI -> entry (FCB style name)
 16292 00002690 89FB                    	MOV	BX,DI		; Set backup limit for skipback
 16293 00002692 83C302                  	ADD	BX,2		; Skip over d: to point to leading '\'
 16294 00002695 E855EB                  	call	StrLen		; CX is length of ES:DI including NUL
 16295 00002698 49                      	DEC	CX		; Don't include nul in count
 16296 00002699 01CF                    	ADD	DI,CX		; Point to NUL at end of string
 16297 0000269B E8D346                  	call	SkipBack	; Back up one element
 16298 0000269E 47                      	INC	DI		; Point to start of last element
 16299                                  
 16300                                  	; 17/05/2019 - Retro DOS v4.0
 16301                                  ;hkn; SS override
 16302                                  	; MSDOS 6.0
 16303 0000269F 36893E[0106]            	MOV	[SS:SAVE_BX],DI	;IFS. save for DOS_RENAME   ;AN000;
 16304                                  	;
 16305 000026A4 E830FA                  	call	PackName	; Transfer name from entry to ASCIZ tail.
 16306 000026A7 5E                      	POP	SI		; Get back entry pointers
 16307 000026A8 5B                      	POP	BX
 16308 000026A9 53                      	PUSH	BX
 16309 000026AA 56                      	PUSH	SI		; Back on stack
 16310                                  	
 16311 000026AB 16                      	push	ss
 16312 000026AC 1F                      	pop	ds
 16313                                  
 16314                                  ;hkn; context DS will assume ES to DOSDATA
 16315                                  ;hkn; ASSUME	DS:DOSGROUP
 16316                                  
 16317                                  ; Close the file if possible by us.
 16318                                  ;
 16319                                  ;if installed
 16320 000026AD FF1E[C400]              	Call	far [JShare+(13*4)] ; 13 = ShCloseFile
 16321                                  ;else
 16322                                  ;	Call	ShCloseFile
 16323                                  ;endif
 16324 000026B1 8C1E[A005]              	MOV	[THISSFT+2],DS
 16325                                  
 16326                                  ;hkn; AUXSTACK is in DOSDATA
 16327 000026B5 C706[9E05][6507]        	MOV	word [THISSFT],AUXSTACK-SF_ENTRY.size  ; RENAMEDMA+(384-59)
 16328                                  				; Scratch space
 16329 000026BB 30E4                    	XOR	AH,AH		; Indicate file to DOOPEN (high bit off)
 16330 000026BD E8AA24                  	call	DOOPEN		; Fill in SFT for share check
 16331 000026C0 C43E[9E05]              	LES	DI,[THISSFT]
 16332                                  	;mov	word [es:di+2],10h
 16333 000026C4 26C745021000            	MOV	word [ES:DI+SF_ENTRY.sf_mode],SHARING_DENY_BOTH ; 10h
 16334                                  				; requires exclusive access
 16335                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],1 ; Pretend open
 16336 000026CA 26C7050100              	mov	word [ES:DI],1
 16337 000026CF E8C34C                  	call	ShareEnter
 16338 000026D2 720D                    	jc	short CheckDone
 16339 000026D4 C43E[9E05]              	LES	DI,[THISSFT]
 16340                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],0
 16341 000026D8 26C7050000              	mov	word [ES:DI],0	; Pretend closed and free
 16342                                  	
 16343 000026DD E8B04C                  	call	ShareEnd	; Tell sharer we're done with THISSFT
 16344 000026E0 F8                      	CLC
 16345                                  CheckDone:
 16346 000026E1 C42E[8A05]              	LES	BP,[THISDPB]
 16347 000026E5 5E                      	POP	SI
 16348 000026E6 5B                      	POP	BX
 16349 000026E7 58                      	POP	AX
 16350 000026E8 5F                      	POP	DI
 16351 000026E9 1F                      	POP	DS
 16352 000026EA C3                      	retn
 16353                                  
 16354                                  ;Break	<FastOpen_Delete - delete dir info in fastopen>
 16355                                  ;---------------------------------------------------------------------------
 16356                                  ; Procedure Name : FastOpen_Delete
 16357                                  ; Inputs:
 16358                                  ;	None
 16359                                  ; Function:
 16360                                  ;	Call FastOpen to delete the dir info.
 16361                                  ; Outputs:
 16362                                  ;	None
 16363                                  ;---------------------------------------------------------------------------
 16364                                  
 16365                                  FastOpen_Delete:
 16366 000026EB 9C                      	PUSHF			; save flag
 16367 000026EC 56                      	PUSH	SI		; save registers
 16368 000026ED 53                      	PUSH	BX
 16369 000026EE 50                      	PUSH	AX
 16370                                  	;mov	si,[WFP_START] ; MSDOS 3.3
 16371                                  ;hkn; SS override
 16372                                  	; 17/05/2019 - Retro DOS v4.0
 16373                                  	; MSDOS 6.0
 16374 000026EF 368B36[B205]            	MOV	SI,[ss:WFP_START] ; ds:si points to path name
 16375                                  	
 16376 000026F4 B003                    	MOV	AL,FONC_delete	; al = 3
 16377                                  fastinvoke:
 16378                                  ;hkn; FastTable is in DOSDATA
 16379 000026F6 BB[320D]                	MOV	BX,FastTable+2
 16380 000026F9 FF1F                    	CALL	far [BX]	; call fastopen
 16381 000026FB 58                      	POP	AX		; restore registers
 16382 000026FC 5B                      	POP	BX
 16383 000026FD 5E                      	POP	SI
 16384 000026FE 9D                      	POPF			; restore flag
 16385 000026FF C3                      	retn
 16386                                  
 16387                                  	; 13/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16388                                  	; DOSCODE:65A0h (MSDOS 5.0 MSDOS.SYS)
 16389                                  
 16390                                  ;Break	<FastOpen_Rename - Rename directory>	   ; PTR 5622
 16391                                  ;---------------------------------------------------------------------------
 16392                                  ; PROCEDURE Name : FastOpen_Rename
 16393                                  ;
 16394                                  ; Inputs:
 16395                                  ;	 REN_WFP   = Path Name
 16396                                  ;	 NAME1	   = New Name
 16397                                  ; Function:
 16398                                  ;	Call FastOpen to rename the dir entry in the cache
 16399                                  ; Outputs:
 16400                                  ;	None
 16401                                  ;---------------------------------------------------------------------------
 16402                                  
 16403                                  FastOpen_Rename:
 16404                                  	; 17/05/2019 - Retro DOS v4.0
 16405                                  	; 08/08/2018 - Retro DOS v3.0
 16406                                  	; MSDOS 6.0
 16407 00002700 9C                      	PUSHF			;AN001 save flag
 16408 00002701 56                      	PUSH	SI		;AN001 save registers
 16409 00002702 57                      	PUSH	DI		;AN001
 16410 00002703 53                      	PUSH	BX		;AN001
 16411 00002704 50                      	PUSH	AX		;AN001
 16412                                  	;
 16413                                  ;hkn; SS override
 16414 00002705 368B36[B405]            	MOV	SI,[SS:REN_WFP]	;AN001	;;AN001  ds:si-->Path name addrs
 16415                                  
 16416                                  ;hkn; NAME1 is in DOSDATA
 16417 0000270A BF[4B05]                	MOV	DI,NAME1	;;AN001  ds:di-->New name addrs
 16418                                  	;mov	al,6
 16419 0000270D B006                    	MOV	AL,FONC_Rename	;;AN001  al = 6
 16420                                  	
 16421                                  ;hkn; FastTable is in DOSDATA
 16422 0000270F BB[320D]                	MOV	BX,FastTable+2
 16423 00002712 FF1F                    	CALL	far [BX]	;;AN001  call fastopen
 16424                                  	
 16425 00002714 58                      	POP	AX		; restore registers  ;AN001
 16426 00002715 5B                      	POP	BX				     ;AN001
 16427 00002716 5F                      	POP	DI				     ;AN001
 16428 00002717 5E                      	POP	SI				     ;AN001
 16429 00002718 9D                      	POPF			; restore flag	     ;AN001
 16430 00002719 C3                      	retn					     ;AN001
 16431                                  
 16432                                  ;Break	<FastOpen_Update - update dir info in fastopen>
 16433                                  ;---------------------------------------------------------------------------
 16434                                  ; Procedure Name : FastOpen_Update
 16435                                  ;
 16436                                  ; Inputs:
 16437                                  ;	DL     drive number (A=0,B=1,,,)
 16438                                  ;	CX     first cluster #
 16439                                  ;	AH     0 updates dir entry
 16440                                  ;	       1 updates CLUSNUM , BP = new CLUSNUM
 16441                                  ;	ES:DI  directory entry
 16442                                  ; Function:
 16443                                  ;	Call FastOpen to update the dir info.
 16444                                  ; Outputs:
 16445                                  ;	None
 16446                                  ;---------------------------------------------------------------------------
 16447                                  
 16448                                  FastOpen_Update:
 16449 0000271A 9C                      	PUSHF			; save flag
 16450 0000271B 56                      	PUSH	SI
 16451 0000271C 53                      	PUSH	BX		; save regs
 16452 0000271D 50                      	PUSH	AX
 16453 0000271E B004                    	MOV	AL,FONC_update	; al = 4
 16454 00002720 EBD4                    	JMP	short fastinvoke
 16455                                  
 16456                                  	; 17/05/2019
 16457                                  
 16458                                  	; MSDOS 6.0
 16459                                  ;entry Fast_Dispatch		; future fastxxxx entry	;AN000;
 16460                                  ;---------------------------------------------------------------------------
 16461                                  Fast_Dispatch:
 16462                                  ;hkn; FastTable is in DOSDATA
 16463 00002722 BE[320D]                	MOV	SI,FastTable+2	; index to the	     ;AN000;
 16464                                  ;hkn; use SS override
 16465 00002725 36FF1C                  	CALL	far [SS:SI]	; RMFD call fastopen
 16466 00002728 C3                      	retn
 16467                                  
 16468                                  ;============================================================================
 16469                                  ; RENAME.ASM, MSDOS 6.0, 1991
 16470                                  ;============================================================================
 16471                                  ; 08/08/2018 - Retro DOS v3.0
 16472                                  ; 17/05/2019 - Retro DOS v4.0
 16473                                  
 16474                                  ;	TITLE	DOS_RENAME - Internal RENAME call for MS-DOS
 16475                                  ;	NAME	DOS_RENAME
 16476                                  
 16477                                  ;**	Low level routine for renaming files
 16478                                  ;----------------------------------------------------------------------------
 16479                                  ;	DOS_RENAME
 16480                                  ;
 16481                                  ;	Modification history:
 16482                                  ;
 16483                                  ;	    Created: ARR 30 March 1983
 16484                                  
 16485                                  ;----------------------------------------------------------------------------
 16486                                  ;
 16487                                  ; Procedure Name : DOS_RENAME
 16488                                  ;
 16489                                  ; Inputs:
 16490                                  ;	[WFP_START] Points to SOURCE WFP string ("d:/" must be first 3
 16491                                  ;		chars, NUL terminated)
 16492                                  ;	[CURR_DIR_END] Points to end of Current dir part of string [SOURCE]
 16493                                  ;		( = -1 if current dir not involved, else
 16494                                  ;		 Points to first char after last "/" of current dir part)
 16495                                  ;	[REN_WFP] Points to DEST WFP string ("d:/" must be first 3
 16496                                  ;		chars, NUL terminated)
 16497                                  ;	[THISCDS] Points to CDS being used
 16498                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 16499                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 16500                                  ; Function:
 16501                                  ;	Rename the specified file(s)
 16502                                  ;	NOTE: This routine uses most of AUXSTACK as a temp buffer.
 16503                                  ; Outputs:
 16504                                  ;	CARRY CLEAR
 16505                                  ;	    OK
 16506                                  ;	CARRY SET
 16507                                  ;	    AX is error code
 16508                                  ;		error_file_not_found
 16509                                  ;			No match for source, or dest path invalid
 16510                                  ;		error_not_same_device
 16511                                  ;			Source and dest are on different devices
 16512                                  ;		error_access_denied
 16513                                  ;			Directory specified (not simple rename),
 16514                                  ;			Device name given, Destination exists.
 16515                                  ;			NOTE: In third case some renames may have
 16516                                  ;			 been done if metas.
 16517                                  ;		error_path_not_found
 16518                                  ;			Bad path (not in curr dir part if present)
 16519                                  ;			SOURCE ONLY
 16520                                  ;		error_bad_curr_dir
 16521                                  ;			Bad path in current directory part of path
 16522                                  ;			SOURCE ONLY
 16523                                  ;		error_sharing_violation
 16524                                  ;			Deny both access required, generates an INT 24.
 16525                                  ; DS preserved, others destroyed
 16526                                  ;
 16527                                  ;----------------------------------------------------------------------------
 16528                                  
 16529                                  	; 14/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16530                                  
 16531                                  DOS_RENAME:
 16532                                  
 16533                                  ;hkn; DOS_RENAME is called from file.asm and fcbio.asm. DS has been set up
 16534                                  ;hkn; at this point to DOSDATA.
 16535                                  
 16536 00002729 E821EB                  	call	TestNet
 16537 0000272C 7306                    	JNC	short LOCAL_RENAME
 16538                                  
 16539                                  ;IF NOT Installed
 16540                                  ;	transfer NET_RENAME
 16541                                  ;ELSE
 16542                                  	;MOV	AX,(MultNET SHL 8) OR 17
 16543                                  	;INT	2FH
 16544                                  	;return
 16545                                  
 16546 0000272E B81111                  	mov     ax, 1111h
 16547 00002731 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
 16548                                  			; SS = DS = DOS CS, 
 16549                                  			; SDA first filename pointer = offset of fully-qualified old name
 16550                                  			; SDA CDS pointer -> current directory
 16551                                  			; Return: CF set on error
 16552 00002733 C3                      	retn
 16553                                  ;ENDIF
 16554                                  
 16555                                  LOCAL_RENAME:
 16556 00002734 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 16557 00002739 8B36[B205]              	MOV	SI,[WFP_START]
 16558 0000273D 8B3E[B405]              	MOV	DI,[REN_WFP]
 16559 00002741 8A04                    	MOV	AL,[SI]
 16560 00002743 8A25                    	MOV	AH,[DI]
 16561 00002745 0D2020                  	OR	AX,2020H		; Lower case
 16562 00002748 38E0                    	CMP	AL,AH
 16563 0000274A 7405                    	JZ	short SAMEDRV
 16564 0000274C B81100                  	MOV	AX,error_not_same_device ; 11h
 16565 0000274F F9                      	STC
 16566 00002750 C3                      	retn
 16567                                  
 16568                                  SAMEDRV:
 16569 00002751 FF36[2E03]              	PUSH	WORD [DMAADD+2]
 16570 00002755 FF36[2C03]              	PUSH	WORD [DMAADD]
 16571 00002759 8C1E[2E03]              	MOV	[DMAADD+2],DS
 16572                                  
 16573                                  ;hkn; RENAMEDMA is in DOSDATA
 16574 0000275D C706[2C03][2006]        	MOV	WORD [DMAADD],RENAMEDMA
 16575 00002763 C606[7005]00            	MOV	byte [FOUND_DEV],0	; Rename fails on DEVS, assume not a dev
 16576 00002768 E8A6EB                  	call	ECritDisk
 16577 0000276B E8F505                  	call	DOS_SEARCH_FIRST	; Sets [NoSetDir] to 1, [CURBUF+2]:BX
 16578                                  					;    points to entry
 16579 0000276E 7314                    	JNC	short Check_Dev
 16580 00002770 83F812                  	CMP	AX,error_no_more_files ; 12h
 16581 00002773 7503                    	JNZ	short GOTERR
 16582 00002775 B80200                  	MOV	AX,error_file_not_found ; 2
 16583                                  GOTERR:
 16584 00002778 F9                      	STC
 16585                                  RENAME_POP:
 16586 00002779 8F06[2C03]              	POP	WORD [DMAADD]
 16587 0000277D 8F06[2E03]              	POP	WORD [DMAADD+2]
 16588                                  	;call	LCritDisk
 16589                                  	;retn
 16590                                  	; 16/12/2022
 16591 00002781 E9A8EB                  	jmp	LCritDisk
 16592                                  
 16593                                  Check_Dev:
 16594                                  	; 17/05/2019 - Retro DOS v4.0
 16595                                  	;mov	ax,5
 16596 00002784 B80500                  	MOV	AX,error_access_denied	; Assume error
 16597                                  	
 16598                                  	; MSDOS 6.0
 16599 00002787 1E                      	PUSH	DS			      ;PTM.			    ;AN000;
 16600 00002788 C536[2C03]              	LDS	SI,[DMAADD]		      ;PTM.  chek if source a dir   ;AN000;
 16601                                  	;add	si,21
 16602 0000278C 83C615                  	ADD	SI,find_buf.attr	      ;PTM.			    ;AN000;
 16603                                  	;test	byte [si+11],10h
 16604 0000278F F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;PTM.	    ;AN000;
 16605 00002793 7407                    	JZ	short notdir		      ;PTM.			    ;AN000;
 16606 00002795 8B36[B405]              	MOV	SI,[REN_WFP]		      ;PTM.  if yes, make sure path ;AN000;
 16607 00002799 E8CCFA                  	call	Check_PathLen2		      ;PTM.   length < 67	    ;AN000;
 16608                                  notdir:
 16609 0000279C 1F                      	POP	DS			      ;PTM.			    ;AN000;
 16610 0000279D 77D9                    	JA	short GOTERR		      ;PTM.			    ;AN000;
 16611                                  
 16612                                  	; MSDOS 3.3 & MSDOS 6.0
 16613 0000279F 803E[7005]00            	CMP	byte [FOUND_DEV],0
 16614 000027A4 75D2                    	JNZ	short GOTERR
 16615                                  
 16616                                  ; At this point a source has been found. There is search continuation info (a
 16617                                  ; la DOS_SEARCH_NEXT) for the source at RENAMEDMA, together with the first
 16618                                  ; directory entry found.
 16619                                  ; [THISCDS], [THISDPB], and [THISDRV] are set and will remain correct
 16620                                  ; throughout the RENAME since it is known at this point that the source and
 16621                                  ; destination are both on the same device.
 16622                                  ; [SATTRIB] is also set.
 16623                                  
 16624 000027A6 89DE                    	MOV	SI,BX
 16625                                  	;add	si,26
 16626 000027A8 83C61A                  	ADD	SI,dir_entry.dir_first
 16627 000027AB E8CFFE                  	call	REN_DEL_Check
 16628 000027AE 7305                    	JNC	short REN_OK1
 16629 000027B0 B82000                  	MOV	AX,error_sharing_violation  ; 20h
 16630 000027B3 EBC4                    	JMP	short RENAME_POP
 16631                                  
 16632                                  ;------------------------------------------------------------------------------
 16633                                  ; Check if the source is a file or directory. If file, delete the entry
 16634                                  ; from the Fastopen cache. If directory, rename it later
 16635                                  ;------------------------------------------------------------------------------
 16636                                  
 16637                                  REN_OK1:				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 16638                                  	; MSDOS 6.0
 16639 000027B5 56                      	PUSH	SI
 16640 000027B6 C536[2C03]              	LDS	SI,[DMAADD]		;BN00X; PTM. check if source a dir ;AN000;
 16641                                  	;add	si,21
 16642 000027BA 83C615                  	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 16643                                  	;test	byte [si+11],10h
 16644 000027BD F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM. ;AN000;
 16645 000027C1 7403                    	JZ	short NOT_DIR1		;;BN00XPTM.			;AN000;
 16646 000027C3 5E                      	POP	SI			;BN00X
 16647 000027C4 EB04                    	JMP	SHORT SWAP_SOURCE	;BN00X
 16648                                  NOT_DIR1:				;;BN00X it is a file, delete the entry
 16649 000027C6 5E                      	POP	SI
 16650                                  
 16651                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 16652 000027C7 E821FF                  	call	FastOpen_Delete 	; delete dir info in fastopen DOS 3.3
 16653                                  SWAP_SOURCE:
 16654                                  	; MSDOS 3.3
 16655                                  	;MOV	SI,[REN_WFP]
 16656                                  	;MOV	[WFP_START],SI
 16657                                  	; MSDOS 6.0
 16658 000027CA A1[B205]                	MOV	AX,[WFP_START]		; Swap source and destination
 16659 000027CD 8B36[B405]              	MOV	SI,[REN_WFP]		; Swap source and destination
 16660 000027D1 8936[B205]              	MOV	[WFP_START],SI		; WFP_START = Destination path
 16661 000027D5 A3[B405]                	MOV	[REN_WFP],AX		; REN_WFP   = Source path
 16662                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16663 000027D8 C706[B605]FFFF          	MOV	word [CURR_DIR_END],-1	; No current dir on dest
 16664                                  	;mov	word [CREATING],0E5FFh
 16665 000027DE C706[7E05]FFE5          	MOV	WORD [CREATING],DIRFREE*256+0FFh  ; Creating, not DEL *.*
 16666                                  					; A rename is like a CREATE_NEW as far
 16667                                  					; as the destination is concerned.
 16668 000027E4 E85F17                  	call	GetPathNoSet
 16669                                  
 16670                                  ;   If this GETPATH fails due to file not found, we know all renames will work
 16671                                  ;   since no files match the destination name. If it fails for any other
 16672                                  ;   reason, the rename fails on a path not found, or whatever (also fails if
 16673                                  ;   we find a device or directory). If the GETPATH succeeds, we aren't sure
 16674                                  ;   if the rename should fail because we haven't built an explicit name by
 16675                                  ;   substituting for the meta chars in it. In this case the destination file
 16676                                  ;   spec with metas is in [NAME1] and the explicit source name is at RENAMEDMA
 16677                                  ;   in the directory entry part.
 16678                                  	
 16679 000027E7 7223                    	JC	short NODEST
 16680                                  	
 16681                                  	; MSDOS 6.0
 16682                                  	;JZ	short BAD_ACC 		; Dest string is a directory	;AC000;
 16683                                  	; !! MSDOS 3.3 !!
 16684                                  	;JZ	short BAD_ACC ; !!	; Dest string is a directory
 16685                                  
 16686 000027E9 08E4                    	OR	AH,AH			; Device?
 16687 000027EB 792C                    	JNS	short SAVEDEST		; No, continue
 16688                                  BAD_ACC:
 16689 000027ED B80500                  	MOV	AX,error_access_denied
 16690 000027F0 F9                      	STC
 16691                                  RENAME_CLEAN:
 16692 000027F1 9C                      	PUSHF				; Save carry state
 16693 000027F2 50                      	PUSH	AX			; and error code (if carry set)
 16694 000027F3 A0[7605]                	MOV	AL,[THISDRV]
 16695 000027F6 E87432                  	call	FLUSHBUF
 16696 000027F9 58                      	POP	AX
 16697 000027FA 803E[4A03]00            	CMP	byte [FAILERR],0
 16698 000027FF 7504                    	JNZ	short BAD_ERR		; User FAILed to I 24
 16699 00002801 9D                      	POPF
 16700 00002802 E974FF                  	JMP	RENAME_POP
 16701                                  
 16702                                  BAD_ERR:
 16703 00002805 58                      	POP	AX			; Saved flags
 16704                                  	; 16/12/202
 16705                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16706                                  BAD_PATH: ; *
 16707 00002806 B80300                  	MOV	AX,error_path_not_found
 16708 00002809 E96CFF                  	JMP	GOTERR
 16709                                  
 16710                                  NODEST:
 16711 0000280C 75F8                    	JNZ	short BAD_PATH
 16712 0000280E 803E[4A03]00            	CMP	byte [FAILERR],0
 16713 00002813 75F1                    	JNZ	short BAD_PATH		; Search for dest failed 
 16714                                  					; because user FAILed on I 24
 16715                                  	; 14/11/2022
 16716 00002815 08C9                    	OR	CL,CL
 16717                                  	;JNZ	short SAVEDEST
 16718                                  	; 17/05/2019
 16719 00002817 74ED                    	jz	short BAD_PATH ; *
 16720                                  ;BAD_PATH: ; *
 16721                                  ;	MOV	AX,error_path_not_found
 16722                                  ;	;STC
 16723                                  ;	;JMP	RENAME_POP
 16724                                  ;	; 17/05/2019
 16725                                  ;	jmp	GOTERR 
 16726                                  
 16727                                  ; 16/12/2022
 16728                                  %if 0
 16729                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16730                                  	or	cl,cl
 16731                                  	jnz	short SAVEDEST
 16732                                  	;jz	short BAD_PATH ; *
 16733                                  BAD_PATH: ; *
 16734                                  	;mov	ax,3
 16735                                  	mov	ax,error_path_not_found
 16736                                  	stc
 16737                                  	jmp	RENAME_POP
 16738                                  %endif
 16739                                  
 16740                                  SAVEDEST:
 16741 00002819 16                      	push	ss
 16742 0000281A 07                      	pop	es
 16743                                  
 16744                                  ;hkn; NAME1 & NAME2 is in DOSDATA
 16745 0000281B BF[5705]                	MOV	DI,NAME2
 16746 0000281E BE[4B05]                	MOV	SI,NAME1
 16747                                  
 16748 00002821 B90B00                  	MOV	CX,11
 16749 00002824 F3A4                    	REP	MOVSB			; Save dest with metas at NAME2
 16750 00002826 A1[C205]                	MOV	AX,[DIRSTART]
 16751 00002829 A3[6405]                	MOV	[DESTSTART],AX
 16752                                  BUILDDEST:
 16753 0000282C 16                      	push	ss
 16754 0000282D 07                      	pop	es			; needed due to JMP BUILDDEST below
 16755                                  
 16756                                  ;hkn; RENAMEDMA, NAME1, NAME2 in DOSDATA
 16757 0000282E BB[3506]                	MOV	BX,RENAMEDMA+21		; Source of replace chars
 16758 00002831 BF[4B05]                	MOV	DI,NAME1		; Real dest name goes here
 16759 00002834 BE[5705]                	MOV	SI,NAME2		; Raw dest
 16760                                  
 16761 00002837 B90B00                  	MOV	CX,11
 16762                                  
 16763                                  	; 17/05/2019 - Retro DOS v4.0
 16764                                  	
 16765                                  	; MSDOS 6.0
 16766 0000283A E81201                  	CALL	NEW_RENAME		;IFS. replace ? chars	;AN000;
 16767                                  
 16768                                  	; MSDOS 3.3
 16769                                  
 16770                                  ; 08/08/2018 - Retro DOS v3.0
 16771                                  ; MSDOS 6.0 
 16772                                  ;---------------------------------------------------------------------------
 16773                                  ;Procedure: NEW_RENAME
 16774                                  ;
 16775                                  ;Input: DS:SI -> raw string with ?
 16776                                  ;	ES:DI -> destination string
 16777                                  ;	DS:BX -> source string
 16778                                  ;Function: replace ? chars of raw string with chars in source string and
 16779                                  ;	   put in destination string
 16780                                  ;Output: ES:DI-> new string
 16781                                  ;---------------------------------------------------------------------------
 16782                                  ;
 16783                                  ;NEW_RENAME:
 16784                                  ;NEWNAM:
 16785                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 341Ah
 16786                                  ;	LODSB
 16787                                  ;	CMP	AL,"?"
 16788                                  ;	JNZ	short NOCHG
 16789                                  ;	MOV	AL,[BX] 		; Get replace char
 16790                                  ;NOCHG:
 16791                                  ;	STOSB
 16792                                  ;	INC	BX			; Next replace char
 16793                                  ;	LOOP	NEWNAM
 16794                                  ;	; MSDOS 6.0
 16795                                  ;	;retn
 16796                                  
 16797                                  	; MSDOS 3.3 & MSDOS 6.0
 16798                                  	;mov	byte [ATTRIB],16h
 16799 0000283D C606[6B05]16            	MOV	byte [ATTRIB],attr_all	; Stop duplicates with any attributes
 16800 00002842 C606[7E05]FF            	MOV	byte [CREATING],0FFH
 16801 00002847 E8AA19                  	call	DEVNAME 		; Check if we built a device name
 16802 0000284A 73A1                    	JNC	short BAD_ACC
 16803 0000284C 8B1E[6405]              	MOV	BX,[DESTSTART]
 16804 00002850 C42E[8A05]              	LES	BP,[THISDPB]
 16805 00002854 E88C16                  	call	SETDIRSRCH		; Reset search to start of dir
 16806 00002857 7294                    	JC	short BAD_ACC 		; Screw up
 16807 00002859 E84615                  	call	FINDENTRY		; See if new name already exists
 16808 0000285C 738F                    	JNC	short BAD_ACC 		; Error if found
 16809 0000285E 803E[4A03]00            	CMP	byte [FAILERR],0
 16810 00002863 752A                    	JNZ	short BAD_ACCJ		; Find failed because user FAILed to I 24
 16811 00002865 A1[6405]                	MOV	AX,[DESTSTART]		; DIRSTART of dest
 16812 00002868 3B06[2F06]              	CMP	AX,[RENAMEDMA+15]	; DIRSTART of source
 16813 0000286C 745D                    	JZ	short SIMPLE_RENAME	; If =, just give new name
 16814                                  
 16815                                  	;mov	al,[RENAMEDMA+32]
 16816 0000286E A0[4006]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr]
 16817 00002871 A810                    	TEST	AL,attr_directory ; 10h
 16818 00002873 751A                    	JNZ	short BAD_ACCJ		; Can only do a simple rename on dirs,
 16819                                  					; otherwise the . and .. entries get
 16820                                  					; wiped.
 16821 00002875 A2[6B05]                	MOV	[ATTRIB],AL
 16822 00002878 8C1E[A005]              	MOV	[THISSFT+2],DS
 16823                                  
 16824                                  ;hkn; AUXSTACK is in DOSDATA
 16825                                  	;mov	si,[RENAMEDMA+145h]
 16826 0000287C BE[6507]                	MOV	SI,AUXSTACK-SF_ENTRY.size  ; RENAMEDMA+325
 16827 0000287F 8936[9E05]              	MOV	[THISSFT],SI
 16828                                  	;mov	word [SI+2],2
 16829 00002883 C744020200              	MOV	word [SI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 16830 00002888 31C9                    	XOR	CX,CX			; Set "device ID" for call into makenode
 16831 0000288A E84521                  	call	RENAME_MAKE		; This is in mknode
 16832 0000288D 7303                    	JNC	short GOT_DEST
 16833                                  BAD_ACCJ:
 16834 0000288F E95BFF                  	JMP	BAD_ACC
 16835                                  
 16836                                  GOT_DEST:
 16837 00002892 53                      	push	bx
 16838 00002893 C43E[9E05]              	LES	DI,[THISSFT]		; RENAME_MAKE entered this into sharing
 16839 00002897 E8F64A                  	call	ShareEnd		; we need to remove it.
 16840 0000289A 5B                      	pop	bx
 16841                                  
 16842                                  ; A zero length entry with the correct new name has now been made at
 16843                                  ;   [CURBUF+2]:BX.
 16844                                  
 16845 0000289B C43E[E205]              	LES	DI,[CURBUF]
 16846                                  
 16847                                  	; MSDOS 6.0
 16848                                  	;test	byte [es:di+5],40h
 16849 0000289F 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 16850                                  					;LB. if already dirty		  ;AN000;
 16851 000028A4 7508                    	JNZ	short yesdirty1		;LB.  don't increment dirty count ;AN000;
 16852 000028A6 E8C932                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 16853                                  	;or	byte [es:di+5],40h
 16854 000028A9 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 16855                                  yesdirty1:
 16856 000028AE 89DF                    	MOV	DI,BX
 16857                                  	;add	di,11
 16858 000028B0 83C70B                  	ADD	DI,dir_entry.dir_attr	; Skip name
 16859                                  
 16860                                  ;hkn; RENAMEDMA is in DOSDATA
 16861                                  	;mov	si,[RENAMEDMA+32]
 16862 000028B3 BE[4006]                	MOV	SI,RENAMEDMA+21+dir_entry.dir_attr
 16863                                  	;mov	cx,21
 16864 000028B6 B91500                  	MOV	CX,dir_entry.size-dir_entry.dir_attr
 16865 000028B9 F3A4                    	REP	MOVSB
 16866 000028BB E87B00                  	CALL	GET_SOURCE
 16867 000028BE 7276                    	JC	short RENAME_OVER
 16868 000028C0 89DF                    	MOV	DI,BX
 16869 000028C2 8E06[E405]              	MOV	ES,[CURBUF+2]
 16870 000028C6 B0E5                    	MOV	AL,DIRFREE ; 0E5h
 16871 000028C8 AA                      	STOSB				; "free" the source
 16872 000028C9 EB13                    	JMP	SHORT DIRTY_IT
 16873                                  
 16874                                  SIMPLE_RENAME:
 16875 000028CB E86B00                  	CALL	GET_SOURCE		; Get the source back
 16876 000028CE 7266                    	JC	short RENAME_OVER
 16877 000028D0 89DF                    	MOV	DI,BX
 16878 000028D2 8E06[E405]              	MOV	ES,[CURBUF+2]
 16879                                  
 16880                                  ;hkn; NAME1 is in DOSDATA
 16881 000028D6 BE[4B05]                	MOV	SI,NAME1		; New Name
 16882 000028D9 B90B00                  	MOV	CX,11
 16883 000028DC F3A4                    	REP	MOVSB
 16884                                  DIRTY_IT:
 16885 000028DE 8B3E[E205]              	MOV	DI,[CURBUF]
 16886                                  
 16887                                  	; MSDOS 6.0
 16888 000028E2 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 16889                                  					;LB. if already dirty		  ;AN000;
 16890 000028E7 7508                    	JNZ	short yesdirty2		;LB.  don't increment dirty count ;AN000;
 16891 000028E9 E88632                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 16892                                  	
 16893 000028EC 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 16894                                  
 16895                                  ;------------------------------------------------------------------------------
 16896                                  ; Check if the source is a directory of file. If directory rename it to the
 16897                                  ; the new name in the Fastopen cache buffer. If file name it has been
 16898                                  ; previously deleted.
 16899                                  ;------------------------------------------------------------------------------
 16900                                  
 16901                                  yesdirty2:
 16902                                  	; MSDOS 6.0
 16903 000028F1 56                      	PUSH	SI
 16904 000028F2 C536[2C03]              	LDS	SI,[DMAADD]		;;BN00XPTM. chek if source a dir ;AN000;
 16905 000028F6 83C615                  	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 16906 000028F9 F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM.	;AN000;
 16907 000028FD 7406                    	JZ	short NOT_DIR2		;;BN00XPTM.			;AN000;
 16908 000028FF E8FEFD                  	call	FastOpen_Rename		;;BN00X rename dir entry in fastopen
 16909 00002902 5E                      	POP	SI
 16910 00002903 EB01                    	JMP	SHORT NOT_DIRTY1
 16911                                  NOT_DIR2:				;;BN00X it is a file, delete the entry
 16912 00002905 5E                      	POP	SI
 16913                                  NOT_DIRTY1:				;;BN00X
 16914                                  NEXT_SOURCE:
 16915                                  ;hkn; RENAMEDMA is in DOSDATA
 16916 00002906 BE[2106]                	MOV	SI,RENAMEDMA+1		;Name
 16917                                  
 16918                                  ; WARNING! Rename_Next leaves the disk critical section *ALWAYS*. We need
 16919                                  ; to enter it before going to RENAME_Next.
 16920                                  
 16921 00002909 E805EA                  	call	ECritDisk
 16922 0000290C C606[7E05]00            	MOV	byte [CREATING],0 ; Correct setting for search (we changed it
 16923                                  				  ;  to FF when we made the prev new file).
 16924 00002911 E88705                  	call	RENAME_NEXT
 16925                                  
 16926                                  ; Note, now, that we have exited the previous ENTER and so are back to where
 16927                                  ; we were before.
 16928                                  
 16929 00002914 7220                    	JC	short RENAME_OVER
 16930                                  
 16931                                  	;lea	si,[bx+26]
 16932 00002916 8D771A                  	LEA	SI,[BX+dir_entry.dir_first]
 16933 00002919 E861FD                  	call	REN_DEL_Check
 16934 0000291C 7306                    	JNC	short REN_OK2
 16935 0000291E B82000                  	MOV	AX,error_sharing_violation ; 20h
 16936                                  jmp_to_rename_clean: ; 28/12/2022
 16937 00002921 E9CDFE                  	JMP	RENAME_CLEAN ; 10/08/2018
 16938                                  
 16939                                  ;------------------------------------------------------------------------------
 16940                                  ; Check if file or directory. If file, delete file from the Fastopen cache,
 16941                                  ; if directory, rename directory name in the Fastopen cache.
 16942                                  ;-----------------------------------------------------------------------------
 16943                                  
 16944                                  REN_OK2:
 16945                                  	; MSDOS 6.0
 16946                                  	;mov	al,[RERNAMEDMA+32]
 16947 00002924 A0[4006]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr] ; PTR P5622
 16948                                  	;test	al,10h
 16949 00002927 A810                    	TEST	AL,attr_directory	;;BN00X directory
 16950 00002929 7406                    	JZ	short Ren_Directory	;;BN00X no - file, delete it
 16951                                  	
 16952                                  	; MSDOS 3.3 & MSDOS 6.0
 16953 0000292B E8BDFD                  	call	FastOpen_Delete 	;;BN00X delete dir info in fastopen DOS 3.3
 16954                                  jmp_to_builddest: ; 28/12/2022
 16955 0000292E E9FBFE                  	JMP	BUILDDEST		;;BN00X
 16956                                  
 16957                                  	; MSDOS 6.0
 16958                                  Ren_Directory:
 16959 00002931 E8CCFD                  	call	FastOpen_Rename 	;;BN00X delete dir info in fastopen DOS 3.3
 16960                                  	;JMP	BUILDDEST
 16961                                  	; 28/12/2022
 16962 00002934 EBF8                    	jmp	short jmp_to_builddest
 16963                                  
 16964                                  RENAME_OVER:
 16965 00002936 F8                      	CLC
 16966                                  	;JMP	RENAME_CLEAN ; 10/08/2018
 16967                                  	; 28/12/2022
 16968 00002937 EBE8                    	jmp	short jmp_to_rename_clean
 16969                                  
 16970                                  ;----------------------------------------------------------------------------
 16971                                  ; Procedure: GET_SOURCE
 16972                                  ;
 16973                                  ; Inputs:
 16974                                  ;	RENAMEDMA has source info
 16975                                  ; Function:
 16976                                  ;	Re-find the source
 16977                                  ; Output:
 16978                                  ;	[CURBUF] set
 16979                                  ;	[CURBUF+2]:BX points to entry
 16980                                  ;	Carry set if error (currently user FAILed to I 24)
 16981                                  ; DS preserved, others destroyed
 16982                                  ;----------------------------------------------------------------------------
 16983                                  
 16984                                  GET_SOURCE:
 16985 00002939 8B1E[2F06]              	MOV	BX,[RENAMEDMA+15]	; DirStart
 16986 0000293D C42E[8A05]              	LES	BP,[THISDPB]
 16987 00002941 E89F15                  	call	SETDIRSRCH
 16988 00002944 7214                    	JC	short gs_ret_label	; retc
 16989 00002946 E88A18                  	call	STARTSRCH
 16990 00002949 A1[2D06]                	MOV	AX,[RENAMEDMA+13]	; Lastent
 16991                                  	;call	GETENT
 16992                                  	; 18/12/2022
 16993 0000294C E96515                  	jmp	GETENT
 16994                                  ;gs_ret_label:
 16995                                  	;retn
 16996                                  
 16997                                  ; MSDOS 6.0 
 16998                                  ;---------------------------------------------------------------------------
 16999                                  ;Procedure: NEW_RENAME
 17000                                  ;
 17001                                  ;Input: DS:SI -> raw string with ?
 17002                                  ;	ES:DI -> destination string
 17003                                  ;	DS:BX -> source string
 17004                                  ;Function: replace ? chars of raw string with chars in source string and
 17005                                  ;	   put in destination string
 17006                                  ;Output: ES:DI-> new string
 17007                                  ;---------------------------------------------------------------------------
 17008                                  
 17009                                  NEW_RENAME:
 17010                                  	; 17/05/2019 - Retro DOS v4.0
 17011                                  NEWNAM:
 17012                                  	; DOSCODE:680Eh (MSDOS 6.21, MSDOS.SYS)
 17013 0000294F AC                      	LODSB
 17014 00002950 3C3F                    	CMP	AL,"?" ; 3Fh
 17015 00002952 7502                    	JNZ	short NOCHG
 17016 00002954 8A07                    	MOV	AL,[BX] 		; Get replace char
 17017                                  NOCHG:
 17018 00002956 AA                      	STOSB
 17019 00002957 43                      	INC	BX			; Next replace char
 17020 00002958 E2F5                    	LOOP	NEWNAM
 17021                                  	; MSDOS 6.0
 17022                                  gs_ret_label:	; 18/12/2022
 17023 0000295A C3                      	retn
 17024                                  
 17025                                  ;============================================================================
 17026                                  ; FINFO.ASM, MSDOS 6.0, 1991
 17027                                  ;============================================================================
 17028                                  ; 08/08/2018 - Retro DOS v3.0
 17029                                  ; 17/05/2019 - Retro DOS v4.0
 17030                                  
 17031                                  ;**	Low level routines for returning file information and setting file
 17032                                  ;	attributes
 17033                                  ;
 17034                                  ;	GET_FILE_INFO
 17035                                  ;	SET_FILE_ATTRIBUTE
 17036                                  ;
 17037                                  ;	Modification history:
 17038                                  ;
 17039                                  ;	    Created: ARR 30 March 1983
 17040                                  ;
 17041                                  ;	M025: Return access_denied if attempting to set
 17042                                  ;	      attribute of root directory.
 17043                                  ;
 17044                                  
 17045                                  ;SUBTTL GET_FILE_INFO -- Get File Information
 17046                                  
 17047                                  ;---------------------------------------------------------------------------
 17048                                  ; Procedure Name : GET_FILE_INFO
 17049                                  ;
 17050                                  ; Inputs:
 17051                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17052                                  ;		terminated)
 17053                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17054                                  ;		( = -1 if current dir not involved, else
 17055                                  ;		 Points to first char after last "/" of current dir part)
 17056                                  ;	[THISCDS] Points to CDS being used
 17057                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17058                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 17059                                  ; Function:
 17060                                  ;	Get Information about a file
 17061                                  ; Returns:
 17062                                  ;	CARRY CLEAR
 17063                                  ;	    AX = Attribute of file
 17064                                  ;	    CX = Time stamp of file
 17065                                  ;	    DX = Date stamp of file
 17066                                  ;	    BX:DI = Size of file (32 bit)
 17067                                  ;	CARRY SET
 17068                                  ;	    AX is error code
 17069                                  ;		error_file_not_found
 17070                                  ;			Last element of path not found
 17071                                  ;		error_path_not_found
 17072                                  ;			Bad path (not in curr dir part if present)
 17073                                  ;		error_bad_curr_dir
 17074                                  ;			Bad path in current directory part of path
 17075                                  ; DS preserved, others destroyed
 17076                                  ;---------------------------------------------------------------------------
 17077                                  
 17078                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17079                                  
 17080                                  GET_FILE_INFO:
 17081                                  
 17082                                  ;hkn; get_file_info is called from file.asm and fcbio.asm. DS has been set 
 17083                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 17084                                  
 17085 0000295B E8EFE8                  	call	TestNet
 17086 0000295E 7306                    	JNC	short LOCAL_INFO
 17087                                  
 17088                                  ;IF NOT Installed
 17089                                  ;	transfer NET_GET_FILE_INFO
 17090                                  ;ELSE
 17091                                  ;	MOV	AX,(MultNET SHL 8) OR 15
 17092                                  ;	INT	2FH
 17093                                  ;	return
 17094                                  
 17095 00002960 B80F11                  	mov     ax, 110Fh
 17096 00002963 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
 17097                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 17098                                  			; SDA CDS pointer -> current directory
 17099                                  			; Return: CF set on error, AX = file attributes
 17100 00002965 C3                      	retn
 17101                                  ;ENDIF
 17102                                  
 17103                                  LOCAL_INFO:
 17104 00002966 E8A8E9                  	call	ECritDisk
 17105 00002969 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 17106                                  	; MSDOS 3.3
 17107                                  	;call	GETPATH
 17108                                  	; MSDOS 6.0
 17109 0000296E E8D800                  	call	GET_FAST_PATH
 17110                                  	; MSDOS 3.3 & MSDOS 6.0
 17111 00002971 7312                    	JNC	short info_check_dev
 17112                                  NO_PATH:
 17113 00002973 750B                    	JNZ	short bad_path1
 17114 00002975 08C9                    	OR	CL,CL
 17115 00002977 7407                    	JZ	short bad_path1
 17116                                  info_no_file:
 17117 00002979 B80200                  	MOV	AX,error_file_not_found
 17118                                  BadRet:
 17119 0000297C F9                      	STC
 17120                                  JustRet:
 17121                                  	;call	LCritDisk
 17122                                  	;retn
 17123                                  	; 18/12/2022
 17124 0000297D E9ACE9                  	jmp	LCritDisk
 17125                                  
 17126                                  bad_path1:
 17127 00002980 B80300                  	MOV	AX,error_path_not_found
 17128 00002983 EBF7                    	jmp	short BadRet
 17129                                  
 17130                                  info_check_dev:
 17131 00002985 08E4                    	OR	AH,AH
 17132 00002987 78F0                    	JS	short info_no_file	; device
 17133                                  
 17134                                  	; MSDOS 6.0
 17135                                  ;SR;
 17136                                  ; If root dir then CurBuf == -1. Check for this case and return subdir attr
 17137                                  ;for a root dir
 17138                                  
 17139 00002989 833E[E205]FF            	cmp	word [CURBUF],-1	;is it a root dir?
 17140 0000298E 7506                    	jne	short not_root		;no, CurBuf ptr is valid
 17141                                  
 17142 00002990 30E4                    	xor	ah,ah
 17143 00002992 B010                    	mov	al,attr_directory ; 10h
 17144                                  	;clc
 17145                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17146                                  	; (DOSCODE:683Eh)
 17147                                  	; 16/12/2022
 17148                                  	;clc
 17149 00002994 EBE7                    	jmp	short JustRet
 17150                                  
 17151                                  not_root:
 17152                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17153 00002996 1E                      	PUSH	DS
 17154 00002997 8E1E[E405]              	MOV	DS,[CURBUF+2]
 17155 0000299B 89DE                    	MOV	SI,BX
 17156 0000299D 31DB                    	XOR	BX,BX			; Assume size=0 (dir)
 17157 0000299F 89DF                    	MOV	DI,BX
 17158                                  	;mov	cx,[si+16h]
 17159 000029A1 8B4C16                  	MOV	CX,[SI+dir_entry.dir_time]
 17160                                  	;mov	dx,[si+18h]
 17161 000029A4 8B5418                  	MOV	DX,[SI+dir_entry.dir_date]
 17162 000029A7 30E4                    	XOR	AH,AH
 17163                                  	;mov	al,[si+0Bh]
 17164 000029A9 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 17165                                  	;test	al,10h
 17166 000029AC A810                    	TEST	AL,attr_directory
 17167 000029AE 7506                    	JNZ	short NO_SIZE
 17168                                  	;mov	di,[si+1Ch]
 17169 000029B0 8B7C1C                  	MOV	DI,[SI+dir_entry.dir_size_l]
 17170                                  	;mov	bx,[si+1Eh]
 17171 000029B3 8B5C1E                  	MOV	BX,[SI+dir_entry.dir_size_h]
 17172                                  NO_SIZE:
 17173 000029B6 1F                      	POP	DS
 17174                                  	;CLC
 17175                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17176                                  	; (DOSCODE:6864h)
 17177                                  	; 16/12/2022
 17178                                  	;clc
 17179 000029B7 EBC4                    	jmp	short JustRet
 17180                                  
 17181                                  ;Break	<SET_FILE_ATTRIBUTE -- Set File Attribute>
 17182                                  ;-------------------------------------------------------------------------------
 17183                                  ; Procedure Name : SET_FILE_ATTRIBUTE
 17184                                  ; Inputs:
 17185                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17186                                  ;		terminated)
 17187                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17188                                  ;		( = -1 if current dir not involved, else
 17189                                  ;		 Points to first char after last "/" of current dir part)
 17190                                  ;	[THISCDS] Points to CDS being used
 17191                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17192                                  ;	[SATTRIB] is attribute of search (determines what files may be found)
 17193                                  ;	AX is new attributes to give to file
 17194                                  ; Function:
 17195                                  ;	Set File Attributes
 17196                                  ; Returns:
 17197                                  ;	CARRY CLEAR
 17198                                  ;	    No error
 17199                                  ;	CARRY SET
 17200                                  ;	    AX is error code
 17201                                  ;		error_file_not_found
 17202                                  ;			Last element of path not found
 17203                                  ;		error_path_not_found
 17204                                  ;			Bad path (not in curr dir part if present)
 17205                                  ;		error_bad_curr_dir
 17206                                  ;			Bad path in current directory part of path
 17207                                  ;		error_access_denied
 17208                                  ;			Attempt to set an attribute which cannot be set
 17209                                  ;			(attr_directory, attr_volume_ID)
 17210                                  ;		error_sharing_violation
 17211                                  ;			Sharing mode of file did not allow the change
 17212                                  ;			(this request requires exclusive write/read access)
 17213                                  ;			(INT 24H generated)
 17214                                  ; DS preserved, others destroyed
 17215                                  ;----------------------------------------------------------------------------
 17216                                  
 17217                                  SET_FILE_ATTRIBUTE:
 17218                                  
 17219                                  ;hkn; set_file_attr is called from file.asm. DS has been set 
 17220                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 17221                                  
 17222 000029B9 A9D8FF                  	TEST	AX,~attr_changeable ; 0FFD8h
 17223 000029BC 7414                    	JZ	short set_look
 17224                                  _BAD_ACC:
 17225 000029BE C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
 17226 000029C3 C606[2703]07            	MOV	byte [EXTERR_CLASS],errCLASS_Apperr ; 7
 17227 000029C8 C606[2603]04            	MOV	byte [EXTERR_ACTION],errACT_Abort ; 4
 17228 000029CD B80500                  	MOV	AX,error_access_denied ; 5
 17229 000029D0 F9                      	STC
 17230 000029D1 C3                      	retn
 17231                                  
 17232                                  set_look:
 17233 000029D2 E878E8                  	call	TestNet
 17234 000029D5 7308                    	JNC	short LOCAL_SET
 17235                                  
 17236                                  ;IF NOT Installed
 17237                                  ;	transfer NET_SEQ_SET_FILE_ATTRIBUTE
 17238                                  ;ELSE
 17239 000029D7 50                      	PUSH	AX
 17240                                  	
 17241                                  	;MOV	AX,(MultNET SHL 8) OR 14
 17242                                  	;INT	2FH
 17243                                  
 17244 000029D8 B80E11                  	mov     ax, 110Eh
 17245 000029DB CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
 17246                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 17247                                  			; SDA CDS pointer -> current directory
 17248                                  			; STACK: WORD new file attributes
 17249                                  			; Return: CF set on error
 17250                                  
 17251 000029DD 5B                      	POP	BX			; clean stack
 17252 000029DE C3                      	retn
 17253                                  ;ENDIF
 17254                                  
 17255                                  LOCAL_SET:
 17256 000029DF E82FE9                  	call	ECritDisk
 17257 000029E2 50                      	PUSH	AX			; Save new attributes
 17258 000029E3 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 17259 000029E8 E85515                  	call	GETPATH 		; get path through fastopen if there	;AC000;
 17260 000029EB 7303                    	JNC	short set_check_device
 17261 000029ED 5B                      	POP	BX			; Clean stack (don't zap AX)
 17262 000029EE EB83                    	JMP	short NO_PATH
 17263                                  
 17264                                  set_check_device:
 17265 000029F0 08E4                    	OR	AH,AH
 17266 000029F2 7906                    	JNS	short set_check_share
 17267 000029F4 58                      	POP	AX
 17268 000029F5 E834E9                  	call	LCritDisk
 17269 000029F8 EBC4                    	JMP	short _BAD_ACC 		; device
 17270                                  
 17271                                  set_check_share:
 17272 000029FA 58                      	POP	AX			; Get new attributes
 17273                                  
 17274                                  	; MSDOS 6.0
 17275 000029FB 833E[E205]FF            	cmp	word [CURBUF], -1	; M025: Q: is this the root dir
 17276 00002A00 740A                    	je	short cannot_set_root	; M025: Y: return error
 17277                                  
 17278                                  	; MSDOS 3.3 & MSDOS 6.0
 17279 00002A02 E878FC                  	call	REN_DEL_Check
 17280 00002A05 730B                    	JNC	short set_do
 17281 00002A07 B82000                  	MOV	AX,error_sharing_violation ; 32
 17282 00002A0A EB3A                    	jmp	short OK_BYE
 17283                                  
 17284                                  	; MSDOS 6.0
 17285                                  cannot_set_root:			; M025:
 17286 00002A0C B80500                  	mov	ax,error_access_denied	; M025: return error is attempting
 17287 00002A0F F9                      	stc				; M025: to set attr. of root
 17288 00002A10 EB34                    	jmp	short OK_BYE		; M025:
 17289                                  
 17290                                  set_do:
 17291                                  	; MSDOS 3.3 & MSDOS 6.0
 17292 00002A12 C43E[E205]              	LES	DI,[CURBUF]
 17293 00002A16 2680670BD8              	AND	BYTE [ES:BX+dir_entry.dir_attr],~attr_changeable ; 0D8h
 17294 00002A1B 2608470B                	OR	BYTE [ES:BX+dir_entry.dir_attr],AL
 17295                                  
 17296                                  	; MSDOS 6.0
 17297 00002A1F 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 17298                                  					;LB. if already dirty		  ;AN000;
 17299 00002A24 7508                    	JNZ	short yesdirty3		;LB.  don't increment dirty count ;AN000;
 17300 00002A26 E84931                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 17301                                  	
 17302 00002A29 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 17303                                  yesdirty3:
 17304 00002A2E A0[7605]                	MOV	AL,[THISDRV]
 17305                                  ;;;; 10/1/86 F.C update fastopen cache
 17306 00002A31 52                      	PUSH	DX
 17307 00002A32 57                      	PUSH	DI
 17308 00002A33 B400                    	MOV	AH,0		  ; dir entry update
 17309 00002A35 88C2                    	MOV	DL,AL		  ; drive number A=0,B=1,,
 17310 00002A37 89DF                    	MOV	DI,BX		  ; ES:DI -> dir entry
 17311 00002A39 E8DEFC                  	call	FastOpen_Update
 17312 00002A3C 5F                      	POP	DI
 17313 00002A3D 5A                      	POP	DX
 17314                                  ;;;; 9/11/86 F.C update fastopen cache
 17315 00002A3E E82C30                  	call	FLUSHBUF
 17316 00002A41 7303                    	JNC	short OK_BYE
 17317 00002A43 B80200                  	MOV	AX,error_file_not_found
 17318                                  OK_BYE:
 17319                                  	;call	LCritDisk
 17320                                  	;retn
 17321                                  	; 16/12/2022
 17322 00002A46 E9E3E8                  	jmp	LCritDisk
 17323                                  
 17324                                  	; 17/05/2019 - Retro DOS v4.0
 17325                                  
 17326                                  	; MSDOS 6.0
 17327                                  GET_FAST_PATH:
 17328                                  ;hkn; use SS override for FastOpenFlg
 17329 00002A49 36800E[3A0D]01          	OR	byte [ss:FastOpenFlg],FastOpen_Set
 17330                                  					;FO. trigger fastopen	;AN000;
 17331 00002A4F E8EE14                  	call	GETPATH
 17332 00002A52 9C                      	PUSHF			 	;FO.			;AN000;
 17333 00002A53 368026[3A0D]80          	AND	byte [ss:FastOpenFlg],Fast_yes 
 17334                                  					;FO. clear all fastopen flags ;AN000;
 17335 00002A59 9D                      	POPF				;FO.			;AN000;
 17336 00002A5A C3                      	retn
 17337                                  
 17338                                  ;============================================================================
 17339                                  ; DUP.ASM, MSDOS 6.0, 1991
 17340                                  ;============================================================================
 17341                                  ; 08/08/2018 - Retro DOS v3.0
 17342                                  ; 17/05/2019 - Retro DOS v4.0
 17343                                  
 17344                                  ;** 	Low level DUP routine for use by EXEC when creating a new process.
 17345                                  ;   	Exports the DUP to the server machine and increments the SFT ref count
 17346                                  ;
 17347                                  ;	DOS_DUP
 17348                                  ;
 17349                                  ;	Modification history:
 17350                                  ;
 17351                                  ;	  Created: ARR 30 March 1983
 17352                                  
 17353                                  ;BREAK <DOS_DUP -- DUP SFT across network>
 17354                                  ;---------------------------------------------------------------------------
 17355                                  ; Procedure Name : DOS_DUP
 17356                                  ;
 17357                                  ; Inputs:
 17358                                  ;	[THISSFT] set to the SFT for the file being DUPed
 17359                                  ;		(a non net SFT is OK, in this case the ref
 17360                                  ;		 count is simply incremented)
 17361                                  ; Function:
 17362                                  ;	Signal to the devices that a logical open is occurring
 17363                                  ; Returns:
 17364                                  ;	ES:DI point to SFT
 17365                                  ;    Carry clear
 17366                                  ;	SFT ref_count is incremented
 17367                                  ; Registers modified: None.
 17368                                  ; NOTE:
 17369                                  ;	This routine is called from $CREATE_PROCESS_DATA_BLOCK at DOSINIT
 17370                                  ;	time with SS NOT DOSGROUP. There will be no Network handles at
 17371                                  ;	that time.
 17372                                  ;---------------------------------------------------------------------------
 17373                                  
 17374                                  DOS_DUP:
 17375                                  	;LES	DI,[CS:THISSFT]  ; MSDOS 3.3
 17376                                  
 17377                                  	; MSDOS 6.0
 17378 00002A5B 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 17379 00002A60 26C43E[9E05]            	les	di,[es:THISSFT]
 17380                                  
 17381                                  	;Entry	Dos_Dup_Direct
 17382                                  DOS_Dup_Direct:
 17383 00002A65 E8FEE7                  	call	IsSFTNet
 17384 00002A68 7503                    	JNZ	short DO_INC
 17385 00002A6A E8A01B                  	call	DEV_OPEN_SFT
 17386                                  DO_INC:
 17387                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 17388 00002A6D 26FF05                  	inc	word [ES:DI]		; Clears carry (if this ever wraps
 17389                                  					;   we're in big trouble anyway)
 17390 00002A70 C3                      	retn
 17391                                  
 17392                                  ;============================================================================
 17393                                  ; CREATE.ASM, MSDOS 6.0, 1991
 17394                                  ;============================================================================
 17395                                  ; 08/08/2018 - Retro DOS v3.0
 17396                                  ; 18/05/2019 - Retro DOS v4.0
 17397                                  
 17398                                  ;TITLE	DOS_CREATE/DOS_CREATE_NEW - Internal CREATE calls for MS-DOS
 17399                                  ;NAME	DOS_CREATE
 17400                                  ;----------------------------------------------------------------------------
 17401                                  ;**	Internal Create and Create new to create a local or NET file and SFT.
 17402                                  ;
 17403                                  ;	DOS_CREATE
 17404                                  ;	DOS_CREATE_NEW
 17405                                  ;	SET_MKND_ERR
 17406                                  ;	SET_Media_ID
 17407                                  ;	SET_EXT_Mode
 17408                                  ;
 17409                                  ;	Revision history:
 17410                                  ;
 17411                                  ;	    A000 version 4.00	  Jan. 1988
 17412                                  ;	    A001  D490 -- Change IOCTL subfunctios from 63h,43h to 66h, 46h
 17413                                  
 17414                                  ;Installed = TRUE
 17415                                  
 17416                                  ;	i_need	THISSFT,DWORD
 17417                                  ;	i_need	THISCDS,DWORD
 17418                                  ;	I_need	EXTERR,WORD
 17419                                  ;	I_Need	ExtErr_locus,BYTE
 17420                                  ;	I_need	JShare,DWORD
 17421                                  ;	I_need	VOLCHNG_FLAG,BYTE
 17422                                  ;	I_need	SATTRIB,BYTE
 17423                                  ;	I_need	CALLVIDM,DWORD
 17424                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000; extended open
 17425                                  ;	I_need	NAME1,BYTE			  ;AN000;
 17426                                  ;	I_need	NO_NAME_ID,BYTE 		  ;AN000;
 17427                                  ;	I_need	Packet_Temp,WORD		  ;AN000;
 17428                                  ;	I_need	DOS34_FLAG,WORD 		  ;AN000;
 17429                                  ;	I_need	SAVE_BX,WORD			  ;AN000;
 17430                                  
 17431                                  ;***	DOS_CREATE - Create a File
 17432                                  ;----------------------------------------------------------------------------
 17433                                  ;	DOS_Create is called to create the specified file, truncating
 17434                                  ;	the old one if it exists.
 17435                                  ;
 17436                                  ;	ENTRY	AX is Attribute to create
 17437                                  ;		(ds) = DOSDATA
 17438                                  ;		[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17439                                  ;			terminated)
 17440                                  ;		[CURR_DIR_END] Points to end of Current dir part of string
 17441                                  ;			( = -1 if current dir not involved, else
 17442                                  ;			 Points to first char after last "/" of current dir part)
 17443                                  ;		[THISCDS] Points to CDS being used
 17444                                  ;			(Low word = -1 if NUL CDS (Net direct request))
 17445                                  ;		[THISSFT] Points to SFT to fill in if file created
 17446                                  ;			(sf_mode field set so that FCB may be detected)
 17447                                  ;		[SATTRIB] Is attribute of search, determines what files can be found
 17448                                  ;
 17449                                  ;	EXIT	sf_ref_count is NOT altered
 17450                                  ;		CARRY CLEAR
 17451                                  ;		    THISSFT filled in.
 17452                                  ;			sf_mode = unchanged for FCB, sharing_compat + open_for_both
 17453                                  ;		CARRY SET
 17454                                  ;		    AX is error code
 17455                                  ;			error_path_not_found
 17456                                  ;				Bad path (not in curr dir part if present)
 17457                                  ;			error_bad_curr_dir
 17458                                  ;				Bad path in current directory part of path
 17459                                  ;			error_access_denied
 17460                                  ;				Attempt to re-create read only file , or
 17461                                  ;				create a second volume id or create a dir
 17462                                  ;			error_sharing_violation
 17463                                  ;				The sharing mode was correct but not allowed
 17464                                  ;				generates an INT 24
 17465                                  ;	USES	all but DS
 17466                                  ;----------------------------------------------------------------------------
 17467                                  
 17468                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17469                                  	; DOSCODE:6920h (MSDOS 5.0, MSDOS.SYS)
 17470                                  
 17471                                  DOS_CREATE:
 17472                                  	; 18/05/2019 - Retro DOS v4.0
 17473                                  	; DOSCODE:6934h (MSDOS 6.21, MSDOS.SYS)
 17474                                  
 17475                                  ;hkn; dispatched to from file.asm and fcbio.asm. DS set up to DOSDATA at 
 17476                                  ;hkn; this point.
 17477                                  
 17478 00002A71 30E4                    	XOR	AH,AH		; Truncate is OK
 17479                                  
 17480                                  ;	Enter here from Dos_Create_New
 17481                                  ;
 17482                                  ;	(ah) = 0 iff truncate OK
 17483                                  
 17484                                  Create_inter:
 17485 00002A73 A8C0                    	TEST	AL,~(attr_all+attr_ignore+attr_volume_id) ; 80h
 17486                                  				; Mask out any meaningless bits
 17487 00002A75 7511                    	JNZ	short AttErr
 17488 00002A77 A808                    	TEST	AL,attr_volume_id
 17489 00002A79 7407                    	JZ	short NoReset
 17490                                  	
 17491                                  	; MSDOS 6.0
 17492                                  	; 16/12/2022
 17493 00002A7B 800E[1106]80            	OR	byte [DOS34_FLAG],DBCS_VOLID ; 80h ;AN000;FOR dbcs volid
 17494                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17495                                  	;or	word [DOS34_FLAG],DBCS_VOLID ; 80h 
 17496                                  	
 17497 00002A80 B008                    	MOV	AL,attr_volume_id ; 8
 17498                                  NoReset:
 17499 00002A82 0C20                    	OR	AL,attr_archive ; File changed  ; 20 h
 17500 00002A84 A850                    	TEST	AL,attr_directory+attr_device ; 50h
 17501 00002A86 740A                    	JZ	short ATT_OK
 17502                                  AttErr:
 17503 00002A88 B80500                  	MOV	AX,5		; Attribute problem
 17504 00002A8B C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
 17505 00002A90 EB66                    	JMP	SHORT SET_MKND_ERR ; Gotta use MKDIR to make dirs, NEVER allow
 17506                                  				   ;	attr_device to be set.
 17507                                  ATT_OK:
 17508 00002A92 C43E[9E05]              	LES	DI,[THISSFT]
 17509 00002A96 06                      	PUSH	ES
 17510 00002A97 C436[A205]              	LES	SI,[THISCDS]
 17511 00002A9B 83FEFF                  	CMP	SI,-1
 17512 00002A9E 751D                    	JNE	short TEST_RE_NET
 17513                                  
 17514                                  ;	No CDS, it must be redirected.
 17515                                  
 17516 00002AA0 07                      	POP	ES
 17517                                  
 17518                                  	; MSDOS 6.0
 17519                                  ;Extended open hooks
 17520                                  	;test	byte [EXTOPEN_ON],1
 17521 00002AA1 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 17522 00002AA6 740D                    	JZ	short NOEXTOP 		    ;AN000;EO. no, do normal
 17523                                  IFS_extopen:				    ;AN000;EO.
 17524 00002AA8 50                      	PUSH	AX			    ;AN000;EO. pass create attr
 17525                                  	;MOV	AX,(MultNET SHL 8) OR 46    ;AN000;EO. issue extended open verb
 17526 00002AA9 B82E11                  	mov	ax,112Eh
 17527 00002AAC CD2F                    	INT	2FH			    ;AN000;EO.
 17528 00002AAE 5B                      	POP	BX			    ;AN000;EO. trash bx
 17529 00002AAF C606[F605]00            	MOV	byte [EXTOPEN_ON],0	    ;AN000;EO.
 17530 00002AB4 C3                      	retn				    ;AN000;EO.
 17531                                  NOEXTOP:				    ;AN000;
 17532                                  ;Extended open hooks
 17533                                  
 17534                                  ;IF NOT Installed
 17535                                  ;	transfer NET_SEQ_CREATE
 17536                                  ;ELSE
 17537 00002AB5 50                      	PUSH	AX
 17538                                  
 17539                                  	;MOV	AX,(MultNET SHL 8) OR 24
 17540                                  	;INT	2FH
 17541                                  
 17542 00002AB6 B81811                  	mov     ax,1118h
 17543 00002AB9 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
 17544                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 17545                                  			; SDA first filename pointer -> fully-qualified name of file
 17546                                  			; STACK: WORD file creation mode???
 17547                                  
 17548 00002ABB 5B                      	POP	BX			; BX is trashed anyway
 17549 00002ABC C3                      	retn
 17550                                  ;ENDIF
 17551                                  
 17552                                  ;	We have a CDS. See if it's network
 17553                                  
 17554                                  TEST_RE_NET:
 17555                                  	;;test	word [es:si+43h],8000h
 17556                                  	;TEST	word [ES:SI+curdir.flags],curdir_isnet
 17557                                  	; 07/12/2022
 17558                                  	;test	byte [es:si+44h],80h
 17559                                  	; 17/12/2022
 17560 00002ABD 26F6444480              	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
 17561 00002AC2 07                      	POP	ES
 17562 00002AC3 7419                    	JZ	short LOCAL_CREATE
 17563                                  
 17564                                  	; MSDOS 6.0
 17565 00002AC5 E8BF00                  	CALL	Set_EXT_mode		    ;AN000;EO.
 17566 00002AC8 7205                    	JC	SHORT dochk		    ;AN000;EO.
 17567                                  	;;or	word [es:di+2],2
 17568                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 17569                                  	; 17/12/2022
 17570 00002ACA 26804D0202              	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 17571                                  
 17572                                  ;Extended open hooks
 17573                                  dochk:
 17574 00002ACF F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 17575 00002AD4 75D2                    	JNZ	short IFS_extopen	    ;AN000;EO. yes, issue extended open
 17576                                  ;Extended open hooks
 17577                                  
 17578                                  ;IF NOT Installed
 17579                                  ;	transfer NET_CREATE
 17580                                  ;ELSE
 17581 00002AD6 50                      	PUSH	AX
 17582                                  	
 17583                                  	;MOV	AX,(MultNET SHL 8) OR 23
 17584                                  	;INT	2FH
 17585                                  	
 17586 00002AD7 B81711                  	mov     ax,1117h
 17587 00002ADA CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
 17588                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 17589                                  			; SDA first filename pointer -> fully-qualified name of file to open
 17590                                  			; SDA CDS pointer -> current directory
 17591                                  			; Return: CF set on error
 17592                                  
 17593 00002ADC 5B                      	POP	BX			; BX is trashed anyway
 17594                                  ;nomore:
 17595 00002ADD C3                      	retn
 17596                                  ;ENDIF
 17597                                  
 17598                                  ;**	It's a local create. We have a local CDS for it.
 17599                                  
 17600                                  LOCAL_CREATE:
 17601                                  	; MSDOS 6.0
 17602 00002ADE E8A600                  	CALL	Set_EXT_mode	;AN000;EO. set mode if from extended open
 17603 00002AE1 7205                    	JC	short setdone	;AN000;EO.
 17604                                  	
 17605                                  	; MSDOS 3.3 & MSDOS 6.0
 17606                                  	; 17/12/2022
 17607                                  	;;or	word [es:di+2],2
 17608                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 17609                                  	;or	byte [es:di+2],2
 17610 00002AE3 26804D0202              	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both	
 17611                                  setdone:
 17612 00002AE8 E826E8                  	call	ECritDisk
 17613 00002AEB E8BE1E                  	call	MakeNode
 17614 00002AEE 7317                    	JNC	short Create_ok
 17615 00002AF0 C606[A10A]FF            	mov	byte [VOLCHNG_FLAG],-1	; indicate no change in volume label
 17616 00002AF5 E834E8                  	call	LCritDisk
 17617                                  
 17618                                  	;entry	SET_MKND_ERR
 17619                                  SET_MKND_ERR:
 17620                                  
 17621                                  ;	Looks up MakeNode errors and converts them. AL is MakeNode
 17622                                  ;	error, SI is GETPATH bad spot return if path_not_found error.
 17623                                  
 17624                                  ;hkn; CRTERRTAB is in TABLE seg (DOSCODE)
 17625 00002AF8 BB[FF2A]                	MOV     BX,CRTERRTAB
 17626                                  	;XLAT  ; MSDOS 3.3
 17627                                  	; 18/05/2019 - Retro DOS v4.0
 17628 00002AFB 2E                      	CS
 17629 00002AFC D7                      	XLAT
 17630                                  CreatBadRet:
 17631 00002AFD F9                      	STC
 17632 00002AFE C3                      	retn
 17633                                  
 17634                                  ; 13/05/2019 - Retro DOS v4.0
 17635                                  ; DOSCODE:69C4h (MSDOS 6.21, MSDOS.SYS)
 17636                                  ; ---------------------------------------------------------------------------
 17637                                  
 17638                                  ;** Internal Create and Create new to create a local or NET file and SFT.
 17639                                  
 17640                                  ; 17/07/2018 - Retro DOS v3.0
 17641                                  ; Offset 12B1h of IBMDOS.COM (MSDOS 3.3), 1987
 17642                                  
 17643                                  ;CRTERRTAB: ; 19/07/2018 - MSDOS 3.3	
 17644                                  ;	db	0,5,52h,50h,3,5,20h
 17645                                  
 17646                                  ;CRTERRTAB: ; 18/05/2019 - MSDOS 6.0	
 17647                                  ;	db	0,5,52h,50h,3,5,20h,2
 17648                                  
 17649                                  ; 08/08/2018
 17650                                  
 17651                                  CRTERRTAB:	;LABEL BYTE	; Lookup table for MakeNode returns
 17652 00002AFF 00                      	DB	0			; none
 17653 00002B00 05                      	DB	error_access_denied	; MakeNode error 1
 17654 00002B01 52                      	DB	error_cannot_make	; MakeNode error 2
 17655 00002B02 50                      	DB	error_file_exists	; MakeNode error 3
 17656 00002B03 03                      	DB	error_path_not_found	; MakeNode error 4
 17657 00002B04 05                      	DB	error_access_denied	; MakeNode error 5
 17658 00002B05 20                      	DB	error_sharing_violation ; MakeNode error 6
 17659                                  	; MSDOS 6.0
 17660 00002B06 02                      	DB	error_file_not_found	; MakeNode error 7
 17661                                  
 17662                                  ; ---------------------------------------------------------------------------
 17663                                  
 17664                                  ; We have just created a new file. This results in the truncation of old
 17665                                  ; files. We must inform the sharer to slash all the open SFT's for this
 17666                                  ; file to the current size.
 17667                                  
 17668                                  ; If we created a volume id on the diskette, set the VOLCHNG_FLAG to logical
 17669                                  ; drive number to force a Build BPB after Media Check.
 17670                                  
 17671                                  ;;; FASTOPEN 8/29/86
 17672                                  Create_ok:
 17673 00002B07 E8E1FB                  	call	FastOpen_Delete
 17674                                  ;;; FASTOPEN 8/29/86
 17675 00002B0A A0[6D05]                	mov	al,[SATTRIB]
 17676 00002B0D A808                    	test	al,attr_volume_id
 17677 00002B0F 741C                    	jz	short NoVolLabel
 17678 00002B11 C43E[A205]              	LES	DI,[THISCDS]
 17679                                  	;mov	ah,[ES:DI+curdir.text]	; get drive letter
 17680 00002B15 268A25                  	mov	ah,[ES:DI] ; 09/08/2018
 17681 00002B18 80EC41                  	sub	ah,'A'	; 41h		; convert to drive number
 17682 00002B1B 8826[A10A]              	mov	[VOLCHNG_FLAG],ah	;Set flag to indicate volid change
 17683                                  	
 17684                                  	; 18/05/2019 - Retro DOS v4.0
 17685                                  
 17686                                  	; MSDOS 6.0
 17687 00002B1F B701                    	MOV	BH,1			;AN000;>32mb set volume id to boot record
 17688 00002B21 E81F00                  	CALL	Set_Media_ID		;AN000;>32mb
 17689                                  	
 17690 00002B24 E8EAE7                  	call	ECritDisk
 17691 00002B27 E8CA2B                  	call	FATREAD_CDS		; force a media check
 17692 00002B2A E8FFE7                  	call	LCritDisk
 17693                                  
 17694                                  NoVolLabel:
 17695 00002B2D B80200                  	MOV	ax,2
 17696 00002B30 C43E[9E05]              	LES	DI,[THISSFT]
 17697                                  ;if installed
 17698                                  	;call	JShare + 14 * 4
 17699 00002B34 FF1E[C800]              	call	far [JShare+(14*4)] ; 14 = ShSU
 17700                                  ;else
 17701                                  ;	Call	ShSU
 17702                                  ;endif
 17703 00002B38 E8F1E7                  	call	LCritDisk
 17704 00002B3B E94901                  	jmp	SET_SFT_MODE
 17705                                  
 17706                                  ;---------------------------------------------------------------------------
 17707                                  ; Procedure Name : Dos_Create_New
 17708                                  ;
 17709                                  ; Inputs:
 17710                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17711                                  ;		terminated)
 17712                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17713                                  ;		( = -1 if current dir not involved, else
 17714                                  ;		 Points to first char after last "/" of current dir part)
 17715                                  ;	[THISCDS] Points to CDS being used
 17716                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17717                                  ;	[THISSFT] Points to SFT to fill in if file created
 17718                                  ;		(sf_mode field set so that FCB may be detected)
 17719                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 17720                                  ;	AX is Attribute to create
 17721                                  ; Function:
 17722                                  ;	Try to create the specified file truncating an old one that exists
 17723                                  ; Outputs:
 17724                                  ;	sf_ref_count is NOT altered
 17725                                  ;	CARRY CLEAR
 17726                                  ;	    THISSFT filled in.
 17727                                  ;		sf_mode = sharing_compat + open_for_both for Non-FCB SFT
 17728                                  ;	CARRY SET
 17729                                  ;	    AX is error code
 17730                                  ;		error_path_not_found
 17731                                  ;			Bad path (not in curr dir part if present)
 17732                                  ;		error_bad_curr_dir
 17733                                  ;			Bad path in current directory part of path
 17734                                  ;		error_access_denied
 17735                                  ;			Create a second volume id or create a dir
 17736                                  ;		error_file_exists
 17737                                  ;			Already a file by this name
 17738                                  ; DS preserved, others destroyed
 17739                                  ;---------------------------------------------------------------------------
 17740                                  
 17741                                  DOS_Create_New:
 17742 00002B3E B401                    	MOV	AH,1		; Truncate is NOT OK
 17743 00002B40 E930FF                  	JMP	Create_inter
 17744                                  
 17745                                  ; MSDOS 6.0
 17746                                  ;---------------------------------------------------------------------------
 17747                                  ; Procedure Name : Set_Media_ID
 17748                                  ;
 17749                                  ; Inputs:
 17750                                  ;	NAME1= Volume ID
 17751                                  ;	BH= 0, delete volume id
 17752                                  ;	    1, set new volume id
 17753                                  ;	DS= DOSGROUP
 17754                                  ; Function:
 17755                                  ;	Set Volume ID to DOS 4.00 Boot record.
 17756                                  ; Outputs:
 17757                                  ;	CARRY CLEAR
 17758                                  ;	    volume id set
 17759                                  ;	CARRY SET
 17760                                  ;	    AX is error code
 17761                                  ;---------------------------------------------------------------------------
 17762                                  
 17763                                  	; 18/05/2019 - Retro DOS v4.0
 17764                                  Set_Media_ID:
 17765 00002B43 50                      	PUSH	AX		;AN000;;>32mb
 17766 00002B44 06                      	PUSH	ES		;AN000;;>32mb
 17767 00002B45 57                      	PUSH	DI		;AN000;;>32mb
 17768                                  
 17769 00002B46 FEC4                    	INC	AH		;AN000;;>32mb  bl=drive #
 17770 00002B48 88E3                    	MOV	BL,AH		;AN000;;>32mb  bl=drive # (A=1,B=2,,,)
 17771 00002B4A B00D                    	MOV	AL,0DH		;AN000;;>32mb  generic IOCTL
 17772 00002B4C B96608                  	MOV	CX,0866H	;AN001;;>32mb  get media id
 17773                                  
 17774                                  ;hkn; PACKET_TEMP is in DOSDATA
 17775 00002B4F BA[6C0D]                	MOV	DX,Packet_Temp	;AN000;>32mb
 17776                                  
 17777 00002B52 53                      	PUSH	BX		;AN000;;>32mb
 17778 00002B53 52                      	PUSH	DX		;AN000;;>32mb
 17779 00002B54 30FF                    	XOR	BH,BH		;AN000;;>32mb
 17780                                  
 17781                                  	;invoke	$IOCTL		;AN000;;>32mb
 17782 00002B56 E83EF7                  	call	_$IOCTL	
 17783                                  
 17784 00002B59 5A                      	POP	DX		;AN000;;>32mb
 17785 00002B5A 5B                      	POP	BX		;AN000;;>32mb
 17786 00002B5B 7224                    	JC	short geterr	;AN000;;>32mb
 17787                                  
 17788 00002B5D 08FF                    	OR	BH,BH		;AN000;;>32mb delete volume id
 17789 00002B5F 7405                    	JZ	short NoName	;AN000;>32mb yes
 17790                                  
 17791                                  ;hkn; NAME1 is in DOSDATA
 17792 00002B61 BE[4B05]                	MOV	SI,NAME1	;AN000;>32mb
 17793                                  
 17794 00002B64 EB03                    	JMP	SHORT doset	;AN000;>32mb yes
 17795                                  NoName: 			;AN000;
 17796                                  
 17797                                  ;hkn; NO_NAME_ID is in DOSDATA
 17798 00002B66 BE[BA0D]                	MOV	SI,NO_NAME_ID	;AN000;>32mb
 17799                                  
 17800                                  doset:				;AN000;
 17801 00002B69 89D7                    	MOV	DI,DX		;AN000;;>32mb
 17802                                  	;add	di,6
 17803 00002B6B 83C706                  	ADD	DI,MEDIA_ID_INFO.MEDIA_Label ;AN000;;>32mb
 17804                                  
 17805                                  ;hkn; ES & DS must point to SS
 17806                                  ;hkn;	PUSH	CS		;AN000;;>32mb  move new volume id to packet
 17807 00002B6E 16                      	PUSH	SS		;AN000;;>32mb  move new volume id to packet
 17808                                  
 17809 00002B6F 1F                      	POP	DS		;AN000;;>32mb
 17810                                  
 17811                                  ;hkn;	PUSH	CS		;AN000;;>32mb
 17812 00002B70 16                      	PUSH	SS		;AN000;;>32mb
 17813                                  
 17814 00002B71 07                      	POP	ES		;AN000;;>32mb
 17815 00002B72 B90B00                  	MOV	CX,11		;AN000;;>32mb
 17816 00002B75 F3A4                    	REP	MOVSB		;AN000;;>32mb
 17817 00002B77 B94608                  	MOV	CX,0846H	;AN001;;>32mb
 17818 00002B7A B00D                    	MOV	AL,0DH		;AN000;;>32mb
 17819 00002B7C 30FF                    	XOR	BH,BH		;AN000;;>32mb
 17820                                  	;invoke	$IOCTL		;AN000;;>32mb  set volume id
 17821 00002B7E E816F7                  	call	_$IOCTL	
 17822                                  geterr: 			;AN000;
 17823                                  ;hkn;	PUSH	CS		;AN000;>32mb
 17824 00002B81 16                      	PUSH	SS		;AN000;>32mb
 17825                                  
 17826 00002B82 1F                      	POP	DS		;AN000;>32mb   ds= dosgroup
 17827                                  
 17828 00002B83 5F                      	POP	DI		;AN000;;>32mb
 17829 00002B84 07                      	POP	ES		;AN000;;>32mb
 17830 00002B85 58                      	POP	AX		;AN000;;>32mb
 17831 00002B86 C3                      	retn			;AN000;>32mb
 17832                                  
 17833                                  ; MSDOS 6.0
 17834                                  ;---------------------------------------------------------------------------
 17835                                  ; Procedure Name : Set_EXT_mode
 17836                                  ;
 17837                                  ; Inputs:
 17838                                  ;	[EXTOPEN_ON]= flag for extended open
 17839                                  ;	SAVE_BX= mode specified in Extended Open
 17840                                  ; Function:
 17841                                  ;	Set mode in ThisSFT
 17842                                  ; Outputs:
 17843                                  ;	carry set,mode is set if from Extended Open
 17844                                  ;	carry clear, mode not set yet
 17845                                  ;---------------------------------------------------------------------------
 17846                                  
 17847                                  ; 13/05/2019 - Retro DOS v4.0
 17848                                  
 17849                                  Set_EXT_mode:
 17850                                  
 17851                                  ;hkn; SS override
 17852 00002B87 36F606[F605]01          	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 17853 00002B8D 740B                    	JZ	short NOTEX		    ;AN000;EO. no, do normal
 17854 00002B8F 50                      	PUSH	AX			    ;AN000;EO.
 17855                                  
 17856                                  ;hkn; SS override
 17857 00002B90 36A1[0106]              	MOV	AX,[ss:SAVE_BX]		    ;AN000;EO.
 17858                                  	;or	[es:di+2],ax
 17859 00002B94 26094502                	OR	[ES:DI+SF_ENTRY.sf_mode],AX ;AN000;EO.
 17860 00002B98 58                      	POP	AX			    ;AN000;EO.
 17861 00002B99 F9                      	STC				    ;AN000;EO.
 17862                                  NOTEX:					    ;AN000;
 17863 00002B9A C3                      	retn				    ;AN000;EO.
 17864                                  
 17865                                  ;============================================================================
 17866                                  ; OPEN.ASM, MSDOS 6.0, 1991
 17867                                  ;============================================================================
 17868                                  ; 08/08/2018 - Retro DOS v3.0
 17869                                  ; 18/05/2019 - Retro DOS v4.0
 17870                                  
 17871                                  ;	TITLE	DOS_OPEN - Internal OPEN call for MS-DOS
 17872                                  ;	NAME	DOS_OPEN
 17873                                  
 17874                                  ;**	OPEN.ASM - File Open
 17875                                  ;----------------------------------------------------------------------------
 17876                                  ;	Low level routines for openning a file from a file spec.
 17877                                  ;	Also misc routines for sharing errors
 17878                                  ;
 17879                                  ;	DOS_Open
 17880                                  ;	Check_Access_AX
 17881                                  ;	SHARE_ERROR
 17882                                  ;	SET_SFT_MODE
 17883                                  ;	Code_Page_Mismatched_Error		   ; DOS 4.00
 17884                                  ;
 17885                                  ;	Revision history:
 17886                                  ;
 17887                                  ;	    Created: ARR 30 March 1983
 17888                                  ;	    A000	version 4.00   Jan. 1988
 17889                                  ;
 17890                                  ;	M034 - The value in save_bx must be pushed on to the stack for
 17891                                  ; 	       remote extended opens and not save_cx.
 17892                                  ;
 17893                                  ;	M035 - if open made from exec then we must set the appropriate bits
 17894                                  ;	       on the stack before calling off to the redir.
 17895                                  ;	M042 - Bit 11 of DOS34_FLAG set indicates that the redir knows how 
 17896                                  ;	       to handle open from exec. In this case set the appropriate bit
 17897                                  ;	       else do not.
 17898                                  ;----------------------------------------------------------------------------	
 17899                                  
 17900                                  ;Installed = TRUE
 17901                                  
 17902                                  ;	i_need	NoSetDir,BYTE
 17903                                  ;	i_need	THISSFT,DWORD
 17904                                  ;	i_need	THISCDS,DWORD
 17905                                  ;	i_need	CURBUF,DWORD
 17906                                  ;	i_need	CurrentPDB,WORD
 17907                                  ;	i_need	CURR_DIR_END,WORD
 17908                                  ;	I_need	RetryCount,WORD
 17909                                  ;	I_need	Open_Access,BYTE
 17910                                  ;	I_need	fSharing,BYTE
 17911                                  ;	i_need	JShare,DWORD
 17912                                  ;	I_need	FastOpenFlg,byte
 17913                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000;; DOS 4.00
 17914                                  ;	I_need	ALLOWED,BYTE			  ;AN000;; DOS 4.00
 17915                                  ;	I_need	EXTERR,WORD			  ;AN000;; DOS 4.00
 17916                                  ;	I_need	EXTERR_LOCUS,BYTE		  ;AN000;; DOS 4.00
 17917                                  ;	I_need	EXTERR_ACTION,BYTE		  ;AN000;; DOS 4.00
 17918                                  ;	I_need	EXTERR_CLASS,BYTE		  ;AN000;; DOS 4.00
 17919                                  ;	I_need	CPSWFLAG,BYTE			  ;AN000;; DOS 4.00
 17920                                  ;	I_need	EXITHOLD,DWORD			  ;AN000;; DOS 4.00
 17921                                  ;	I_need	THISDPB,DWORD			  ;AN000;; DOS 4.00
 17922                                  ;	I_need	SAVE_CX,WORD			  ;AN000;; DOS 4.00
 17923                                  ;	I_need	SAVE_BX,WORD			  ;M034
 17924                                  ;
 17925                                  ;	I_need	DOS_FLAG,BYTE
 17926                                  ;	I_need	DOS34_FLAG,WORD			  ;M042
 17927                                  
 17928                                  ;Break	<DOS_Open - internal file access>
 17929                                  ;---------------------------------------------------------------------------
 17930                                  ; Procedure Name : DOS_Open
 17931                                  ;
 17932                                  ; Inputs:
 17933                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17934                                  ;		terminated)
 17935                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17936                                  ;		( = -1 if current dir not involved, else
 17937                                  ;		 Points to first char after last "/" of current dir part)
 17938                                  ;	[THISCDS] Points to CDS being used
 17939                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17940                                  ;	[THISSFT] Points to SFT to fill in if file found
 17941                                  ;		(sf_mode field set so that FCB may be detected)
 17942                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 17943                                  ;	AX is Access and Sharing mode
 17944                                  ;	  High NIBBLE of AL (Sharing Mode)
 17945                                  ;		sharing_compat	   file is opened in compatibility mode
 17946                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 17947                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 17948                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 17949                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 17950                                  ;	  Low NIBBLE of AL (Access Mode)
 17951                                  ;		open_for_read	file is opened for reading
 17952                                  ;		open_for_write	file is opened for writing
 17953                                  ;		open_for_both	file is opened for both reading and writing.
 17954                                  ;
 17955                                  ;	  For FCB SFTs AL should = sharing_compat + open_for_both
 17956                                  ;		(not checked)
 17957                                  ; Function:
 17958                                  ;	Try to open the specified file
 17959                                  ; Outputs:
 17960                                  ;	sf_ref_count is NOT altered
 17961                                  ;	CARRY CLEAR
 17962                                  ;	    THISSFT filled in.
 17963                                  ;	CARRY SET
 17964                                  ;	    AX is error code
 17965                                  ;		error_file_not_found
 17966                                  ;			Last element of path not found
 17967                                  ;		error_path_not_found
 17968                                  ;			Bad path (not in curr dir part if present)
 17969                                  ;		error_bad_curr_dir
 17970                                  ;			Bad path in current directory part of path
 17971                                  ;		error_invalid_access
 17972                                  ;			Bad sharing mode or bad access mode or bad combination
 17973                                  ;		error_access_denied
 17974                                  ;			Attempt to open read only file for writting, or
 17975                                  ;			open a directory
 17976                                  ;		error_sharing_violation
 17977                                  ;			The sharing mode was correct but not allowed
 17978                                  ;			generates an INT 24 on compatibility mode SFTs
 17979                                  ; DS preserved, others destroyed
 17980                                  ;----------------------------------------------------------------------------
 17981                                  
 17982                                  ; 18/05/2019 - Retro DOS v4.0
 17983                                  ; DOSCODE:6A60h (MSDOS 6.21, MSDOS.SYS)
 17984                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17985                                  ; DOSCODE:6A4Ch (MSDOS 5.0, MSDOS.SYS)
 17986                                  
 17987                                  DOS_OPEN:
 17988                                  	; DS has been set up to DOSDATA in file.asm and fcbio2.asm. 
 17989                                  
 17990 00002B9B C606[4C03]00            	MOV	byte [NoSetDir],0
 17991 00002BA0 E83301                  	CALL	Check_Access_AX
 17992 00002BA3 722B                    	JC	short do_ret_label	    ; retc
 17993                                  
 17994 00002BA5 C43E[9E05]              	LES	DI,[THISSFT]
 17995 00002BA9 30E4                    	XOR	AH,AH
 17996                                  
 17997                                  	; sleaze! move only access/sharing mode in. Leave sf_isFCB unchanged
 17998                                  
 17999 00002BAB 26884502                	MOV	[ES:DI+SF_ENTRY.sf_mode],AL ; For moment do this on FCBs too
 18000 00002BAF 06                      	PUSH	ES
 18001 00002BB0 C436[A205]              	LES	SI,[THISCDS]
 18002                                  	; 18/08/2018
 18003 00002BB4 83FEFF                  	CMP	SI,-1
 18004 00002BB7 7530                    	JNZ	short TEST_RE_NET1
 18005 00002BB9 07                      	POP	ES
 18006                                  
 18007                                  	; MSDOS 6.0
 18008                                  ;Extended open hooks
 18009 00002BBA F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extnded open		;AN000;
 18010 00002BBF 7410                    	JZ	short _NOEXTOP 		    ;FT. no, do normal			;AN000;
 18011                                  _IFS_extopen:									;AN000;
 18012 00002BC1 A0[0106]                	MOV	AL,[SAVE_BX]		    ; M034 - save_bx has original bx  
 18013                                  					    ; with which call was made. This
 18014                                  					    ; has the open access bits. 
 18015                                  	;;MOV	AL,[SAVE_CX]		    ; M034 - FT. al= create attribute
 18016                                  	
 18017 00002BC4 50                      	PUSH	AX			    ;FT. pass create attr to IFS	;AN000;
 18018                                  	;mov	ax,112Eh
 18019                                  	;MOV	AX,(MultNET SHL 8) OR 46    ;FT. issue extended open verb	;AN000;
 18020 00002BC5 B82E11                  	mov	ax,(MultNET*256)+46 
 18021 00002BC8 CD2F                    	INT	2FH			    ;FT.				;AN000;
 18022 00002BCA 5B                      	POP	BX			    ;FT. trash bx			;AN000;
 18023 00002BCB C606[F605]00            	MOV	byte [EXTOPEN_ON],0	    ;FT.				;AN000;
 18024                                  
 18025                                  do_ret_label:
 18026 00002BD0 C3                      	retn				    ;FT.				;AN000;
 18027                                  _NOEXTOP:
 18028                                  ;Extended open hooks
 18029                                  	;
 18030                                  ;IF NOT Installed
 18031                                  	;transfer NET_SEQ_OPEN
 18032                                  ;ELSE
 18033                                  	
 18034                                  do_net_int2f:
 18035 00002BD1 F606[8600]01            	test	byte [DOS_FLAG],EXECOPEN ; Q: was this open call made from exec
 18036 00002BD6 7409                    	jz	short not_exec_open	; N: just do net open
 18037                                  					; Y: check to see if redir is aware
 18038                                  					;    of this 
 18039                                  	
 18040                                  					; M042 - start
 18041                                  	;test	word [DOS34_FLAG],EXEC_AWARE_REDIR ; 800h
 18042 00002BD8 F606[1206]08            	test	byte [DOS34_FLAG+1],(EXEC_AWARE_REDIR>>8)
 18043                                  					; Q: does this redir know how to 
 18044                                  					;    this
 18045 00002BDD 7402                    	jz	short not_exec_open	; N: just do net open
 18046                                  					; Y: set bit 3 of access byte and 
 18047                                  					;    set sharing mode to DENY_WRITE
 18048                                  					; M042 - end
 18049                                  	
 18050                                  	; NOTE: This specific mode has not been set for the code assembled
 18051                                  	; under the "NOT Installed" conditional. Currently Installed is 
 18052                                  	; always one.
 18053                                  					; M035 - set the bits on the stack
 18054                                  	;mov	al,23h
 18055 00002BDF B023                    	mov	AL,SHARING_DENY_WRITE+EXEC_OPEN
 18056                                  	
 18057                                  not_exec_open:
 18058                                  	; MSDOS 3.3 & MSDOS 6.0
 18059 00002BE1 50                      	PUSH	AX
 18060                                  
 18061                                  	;MOV	AX,(MultNET SHL 8) OR 22
 18062                                  	;INT	2FH
 18063                                  
 18064 00002BE2 B81611                  	mov     ax,1116h
 18065 00002BE5 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
 18066                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 18067                                  			; SDA first filename pointer -> fully-qualified name of file to open
 18068                                  			; STACK: WORD file open mode
 18069                                  			; Return: CF set on error
 18070                                  
 18071 00002BE7 5B                      	POP	BX			; clean stack
 18072                                  ;do_ret_label: ; 09/08/2018
 18073 00002BE8 C3                      	retn
 18074                                  ;ENDIF
 18075                                  
 18076                                  TEST_RE_NET1:
 18077                                  	;TEST	word [ES:SI+curdir.flags],curdir_isnet
 18078                                  	; 17/12/2022
 18079 00002BE9 26F6444480              	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
 18080 00002BEE 07                      	POP	ES
 18081                                  	; 18/05/2019
 18082 00002BEF 7409                    	JZ	short LOCAL_OPEN
 18083                                  
 18084                                  ;Extended open hooks
 18085                                  	; MSDOS 6.0
 18086 00002BF1 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extended open	;AN000;
 18087 00002BF6 75C9                    	JNZ	short _IFS_extopen	      ;FT. isuue extended open	;AN000;
 18088                                  ;Extended open hooks
 18089                                  
 18090                                  ;IF NOT Installed
 18091                                  ;	transfer NET_OPEN
 18092                                  ;ELSE
 18093 00002BF8 EBD7                    	jmp	short do_net_int2f
 18094                                  ;ENDIF
 18095                                  
 18096                                  LOCAL_OPEN:
 18097                                  	; MSDOS 3.3 & MSDOS 6.0
 18098 00002BFA E814E7                  	call	ECritDisk
 18099                                  
 18100                                  ; DOS 3.3 FastOPen 6/16/86
 18101                                  
 18102                                  	;or	byte [FastOpenFlg],5
 18103 00002BFD 800E[3A0D]05            	OR	byte [FastOpenFlg],FastOpen_Set+Special_Fill_Set ; only open can
 18104                                  
 18105 00002C02 E83B13                  	call	GETPATH
 18106                                  
 18107                                  ; DOS 3.3 FastOPen 6/16/86
 18108                                  
 18109 00002C05 731D                    	JNC	short Open_found
 18110 00002C07 7511                    	JNZ	short bad_path2
 18111 00002C09 08C9                    	OR	CL,CL
 18112 00002C0B 740D                    	JZ	short bad_path2
 18113                                  OpenFNF:
 18114 00002C0D B80200                  	MOV	AX,error_file_not_found	; 2
 18115                                  OpenBadRet:
 18116                                  ;hkn; FastOpenFlg is in DOSDATA use SS override
 18117                                  	; 12/08/2018
 18118                                  	;mov	byte [cs:FastOpenFlg],0 ; IBMDOS.COM (MSDOS 3.3) offset 36CAh
 18119                                  	; MSDOS 6.0
 18120 00002C10 368026[3A0D]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes    ;; DOS 3.3
 18121 00002C16 F9                      	STC
 18122                                  	;call	LCritDisk
 18123                                  	; 16/12/2022
 18124 00002C17 E912E7                  	jmp	LCritDisk
 18125                                  	;;JMP	Clear_FastOpen ; 10/08/2018
 18126                                  	;retn 	; 08/09/2018
 18127                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18128                                  	;jmp	Clear_FastOpen
 18129                                  
 18130                                  bad_path2:
 18131 00002C1A B80300                  	MOV	AX,error_path_not_found	; 3
 18132 00002C1D EBF1                    	JMP	short OpenBadRet
 18133                                  
 18134                                  Open_Bad_Access:
 18135 00002C1F B80500                  	MOV	AX,error_access_denied	; 5
 18136 00002C22 EBEC                    	JMP	short OpenBadRet
 18137                                  
 18138                                  Open_found:
 18139 00002C24 74F9                    	JZ	short Open_Bad_Access 	; test for directories
 18140 00002C26 08E4                    	OR	AH,AH
 18141 00002C28 783E                    	JS	short open_ok		; Devices don't have attributes
 18142 00002C2A 8E06[E405]              	MOV	ES,[CURBUF+2]		; get buffer location
 18143                                  	;mov	al,[es:bx+0Bh]
 18144 00002C2E 268A470B                	MOV	AL,[ES:BX+dir_entry.dir_attr]
 18145 00002C32 A808                    	TEST	AL,attr_volume_id	; can't open volume ids
 18146 00002C34 75E9                    	JNZ	short Open_Bad_Access
 18147 00002C36 A801                    	TEST	AL,attr_read_only	; check write on read only
 18148 00002C38 742E                    	JZ	short open_ok
 18149                                  
 18150                                  ; The file is marked READ-ONLY. We verify that the open mode allows access to
 18151                                  ; the read-only file. Unfortunately, with FCB's and net-FCB's we cannot
 18152                                  ; determine at the OPEN time if such access is allowed. Thus, we defer such
 18153                                  ; processing until the actual write operation:
 18154                                  ;
 18155                                  ; If FCB, then we change the mode to be read_only.
 18156                                  ; If net_FCB, then we change the mode to be read_only.
 18157                                  ; If not open for read then error.
 18158                                  
 18159 00002C3A 1E                      	push	ds
 18160 00002C3B 56                      	push	si
 18161 00002C3C C536[9E05]              	LDS	SI,[THISSFT]
 18162                                  	;mov	cx,[si+2]
 18163 00002C40 8B4C02                  	MOV	CX,[SI+SF_ENTRY.sf_mode]
 18164                                  	; 17/12/2022
 18165                                  	;test	ch,80h
 18166 00002C43 F6C580                  	test	ch,sf_isFCB>>8
 18167                                  	;TEST	CX,sf_isFCB ; 8000h	; is it FCB?
 18168 00002C46 750A                    	JNZ	short ResetAccess	; yes, reset the access
 18169 00002C48 88CA                    	MOV	DL,CL
 18170 00002C4A 80E2F0                  	AND	DL,SHARING_MASK	; 0F0h
 18171 00002C4D 80FA70                  	CMP	DL,SHARING_NET_FCB ; 70h ; is it net FCB?
 18172 00002C50 7508                    	JNZ	short NormalOpen	; no
 18173                                  ResetAccess:
 18174                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)	
 18175                                  	;AND	CX,~access_mask	; 0FFF0h ; clear access
 18176                                  	; 16/12/2022
 18177 00002C52 80E1F0                  	and	cl,0F0h ; 18/05/2019
 18178                                  ;	OR	CX,open_for_read ; 0	; stick in open_for_read
 18179 00002C55 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],CX
 18180 00002C58 EB0C                    	JMP	SHORT FillSFT
 18181                                  
 18182                                  ; The SFT is normal. See if the requested access is open_for_read
 18183                                  
 18184                                  NormalOpen:
 18185 00002C5A 80E10F                  	AND	CL,access_mask	;0Fh	; remove extras
 18186 00002C5D 80F900                  	CMP	CL,open_for_read ; 0	; is it open for read?
 18187 00002C60 7404                    	JZ	short FillSFT
 18188 00002C62 5E                      	pop	si
 18189 00002C63 1F                      	pop	ds
 18190 00002C64 EBB9                    	JMP	short Open_Bad_Access
 18191                                  ;
 18192                                  ; All done, restore registers and fill the SFT.
 18193                                  ;
 18194                                  FillSFT:
 18195 00002C66 5E                      	pop	si
 18196 00002C67 1F                      	pop	ds
 18197                                  open_ok:
 18198 00002C68 E8FF1E                  	call	DOOPEN			; Fill in SFT
 18199                                  
 18200                                  ;hkn; FastOpenFlg is in DOSDATA. use SS override
 18201                                  	; 18/05/2019
 18202                                  	;and	byte [ss:FastOpenFlag],80h
 18203 00002C6B 368026[3A0D]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes	;; DOS 3.3
 18204                                  	; 12/08/2018
 18205                                  	;and	byte [FastOpenFlg],Fast_yes	
 18206                                  
 18207                                  	; MSDOS 6.0
 18208 00002C71 E84300                  	CALL	DO_SHARE_CHECK
 18209 00002C74 7303                    	JNC	short SHARE_OK
 18210                                  	;call	LCritDisk
 18211                                  	; 16/12/2022
 18212 00002C76 E9B3E6                  	jmp	LCritDisk
 18213                                  	;;JMP	short Clear_FastOpen
 18214                                  	;retn	; 18/05/2019
 18215                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18216                                  	;jmp	short Clear_FastOpen	
 18217                                  
 18218                                  	; MSDOS 3.3
 18219                                  ;DO_SHARE_CHECK:
 18220                                  ;	MOV	CX,[RetryCount]		; Get # tries to do
 18221                                  ;OpenShareRetry:
 18222                                  ;	push	cx			; Save number left to do
 18223                                  ;	call	SHARE_CHECK		; Final Check
 18224                                  ;	pop	cx			; CX = # left
 18225                                  ;	JNC	short SHARE_OK		; No problem with access
 18226                                  ;	call	Idle
 18227                                  ;	LOOP	OpenShareRetry		; One more retry used up
 18228                                  ;OpenShareFail:
 18229                                  ;	LES	DI,[THISSFT]
 18230                                  ;	call	SHARE_ERROR
 18231                                  ;	JNC	short DO_SHARE_CHECK	; User wants more retry
 18232                                  	
 18233                                  	;12/08/2018
 18234                                  	;mov	byte [ss:FastOpenFlg],0
 18235                                  	;08/09/2018
 18236                                  	;mov	byte [FastOpenFlg],0
 18237                                  	;call	LCritDisk
 18238                                  	;JMP	short Clear_FastOpen
 18239                                  	;retn
 18240                                  
 18241                                  SHARE_OK:
 18242                                  	; MSDOS 3.3 & MSDOS 6.0
 18243 00002C79 B80300                  	MOV	AX,3
 18244 00002C7C C43E[9E05]              	LES	DI,[THISSFT]
 18245                                  ;if installed
 18246                                  	;call	JShare + 14 * 4
 18247 00002C80 FF1E[C800]              	call	far [JShare+(14*4)]  ; 14 = ShSU
 18248                                  ;else
 18249                                  ;	Call	ShSU
 18250                                  ;endif
 18251 00002C84 E8A5E6                  	call	LCritDisk
 18252                                  	
 18253                                  	;FallThru Set_SFT_Mode
 18254                                  
 18255                                  ;----------------------------------------------------------------------------
 18256                                  ; Procedure Name : SET_SFT_MODE
 18257                                  ;
 18258                                  ; Finish SFT initialization for new reference. Set the correct mode.
 18259                                  ;
 18260                                  ;   Inputs:
 18261                                  ;	ThisSFT points to SFT
 18262                                  ;
 18263                                  ;   Outputs:
 18264                                  ;	Carry clear
 18265                                  ;   Registers modified: AX.
 18266                                  ;---------------------------------------------------------------------------
 18267                                  
 18268                                  ;hkn; called from create. DS already set up to DOSDATA.
 18269                                  
 18270                                  SET_SFT_MODE:
 18271 00002C87 C43E[9E05]              	LES	DI,[THISSFT]
 18272 00002C8B E87F19                  	call	DEV_OPEN_SFT
 18273                                  	;test	word [es:di+2],8000h
 18274                                  	; 17/12/2022
 18275                                  	;test	byte [es:di+3],80h
 18276 00002C8E 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8
 18277                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; Clears carry
 18278 00002C93 7407                    	JZ	short Clear_FastOpen	; sf_mode correct (retz)
 18279 00002C95 A1[3003]                	MOV	AX,[CurrentPDB]
 18280                                  	;mov	[es:di+31h],ax
 18281 00002C98 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX ; For FCB sf_PID=PDB
 18282                                  
 18283                                  Clear_FastOpen:
 18284 00002C9C C3                      	retn			       ;;;;; DOS 3.3
 18285                                  
 18286                                  ;----------------------------------------------------------------------------
 18287                                  ; Procedure Name : SHARE_ERROR
 18288                                  ;
 18289                                  ; Called on sharing violations. ES:DI points to SFT. AX has error code
 18290                                  ; If SFT is FCB or compatibility mode gens INT 24 error.
 18291                                  ; Returns carry set AX=error_sharing_violation if user says ignore (can't
 18292                                  ; really ignore). Carry clear if user wants a retry. ES, DI, DS preserved
 18293                                  ;---------------------------------------------------------------------------
 18294                                  
 18295                                  SHARE_ERROR:
 18296                                  	; 17/12/2022
 18297                                  	;test	byte [es:di+3],80h
 18298 00002C9D 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8 ; 80h
 18299                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; 8000h
 18300 00002CA2 7509                    	JNZ	short _HARD_ERR
 18301 00002CA4 268A4D02                	MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 18302 00002CA8 80E1F0                  	AND	CL,SHARING_MASK  ; 0F0h
 18303                                  	;CMP	CL,SHARING_COMPAT ; 0
 18304                                  	;JNE	short _NO_HARD_ERR
 18305                                  	; 21/09/2023
 18306 00002CAB 7505                    	jnz	short _NO_HARD_ERR
 18307                                  _HARD_ERR:
 18308 00002CAD E8BA46                  	call	SHARE_VIOLATION
 18309                                  	;retnc				; User wants retry
 18310 00002CB0 73EA                    	jnc	short Clear_FastOpen
 18311                                  _NO_HARD_ERR:
 18312 00002CB2 B82000                  	MOV	AX,error_sharing_violation  ; 20h
 18313 00002CB5 F9                      	STC
 18314 00002CB6 C3                      	retn
 18315                                  
 18316                                  ; MSDOS 6.0
 18317                                  ;----------------------------------------------------------------------------
 18318                                  ; Procedure Name : DO_SHARE_CHECK
 18319                                  ;
 18320                                  ; Input: THISDPB, WFP_Start, THISSFT set
 18321                                  ; Functions: check file sharing mode is valid
 18322                                  ; Output: carry set, error
 18323                                  ;	  carry clear, share ok
 18324                                  ;----------------------------------------------------------------------------
 18325                                  
 18326                                  	; 18/05/2019 - Retro DOS v4.0
 18327                                  DO_SHARE_CHECK:
 18328 00002CB7 E857E6                  	call	ECritDisk		; enter critical section
 18329                                  OPN_RETRY:
 18330 00002CBA 8B0E[1A00]              	MOV	CX,[RetryCount]		; Get # tries to do
 18331                                  OpenShareRetry:
 18332 00002CBE 51                      	push	cx			; Save number left to do
 18333 00002CBF E8A346                  	call	SHARE_CHECK		; Final Check
 18334 00002CC2 59                      	pop	cx			; CX = # left
 18335 00002CC3 730E                    	JNC	short Share_Ok2		; No problem with access
 18336 00002CC5 E840E5                  	call	Idle
 18337 00002CC8 E2F4                    	LOOP	OpenShareRetry		; One more retry used up
 18338                                  OpenShareFail:
 18339 00002CCA C43E[9E05]              	LES	DI,[THISSFT]
 18340 00002CCE E8CCFF                  	call	SHARE_ERROR
 18341 00002CD1 73E7                    	JNC	short OPN_RETRY		; User wants more retry
 18342                                  Share_Ok2:
 18343                                  	;call	LCritDisk		; leave critical section
 18344                                  	;retn
 18345                                  	; 18/12/2022
 18346 00002CD3 E956E6                  	jmp	LCritDisk
 18347                                  
 18348                                  ;-----------------------------------------------------------------------------
 18349                                  ; Procedure Name : Check_Access
 18350                                  ;
 18351                                  ; Inputs:
 18352                                  ;	AX is mode
 18353                                  ;	  High NIBBLE of AL (Sharing Mode)
 18354                                  ;		sharing_compat	   file is opened in compatibility mode
 18355                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 18356                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 18357                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 18358                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 18359                                  ;	  Low NIBBLE of AL (Access Mode)
 18360                                  ;		open_for_read	file is opened for reading
 18361                                  ;		open_for_write	file is opened for writing
 18362                                  ;		open_for_both	file is opened for both reading and writing.
 18363                                  ; Function:
 18364                                  ;	Check this access mode for correctness
 18365                                  ; Outputs:
 18366                                  ;	[open_access] = AL input
 18367                                  ;	Carry Clear
 18368                                  ;		Mode is correct
 18369                                  ;		AX unchanged
 18370                                  ;	Carry Set
 18371                                  ;		Mode is bad
 18372                                  ;		AX = error_invalid_access
 18373                                  ; No other registers effected
 18374                                  ;----------------------------------------------------------------------------
 18375                                  
 18376                                  Check_Access_AX:
 18377 00002CD6 A2[6E05]                	MOV	[OPEN_ACCESS],AL
 18378 00002CD9 53                      	PUSH	BX
 18379                                  
 18380                                  ;	If sharing, then test for special sharing mode for FCBs
 18381                                  
 18382 00002CDA 88C3                    	MOV	BL,AL
 18383 00002CDC 80E3F0                  	AND	BL,SHARING_MASK ; 0F0h
 18384 00002CDF 803E[7205]FF            	CMP	byte [FSHARING],-1
 18385 00002CE4 7505                    	JNZ	short CheckShareMode	; not through server call, must be ok
 18386 00002CE6 80FB70                  	CMP	BL,SHARING_NET_FCB
 18387 00002CE9 7405                    	JZ	short CheckAccessMode	; yes, we have an FCB
 18388                                  CheckShareMode:
 18389 00002CEB 80FB40                  	CMP	BL,40h			; is this a good sharing mode?
 18390 00002CEE 770D                    	JA	short Make_Bad_Access
 18391                                  CheckAccessMode:
 18392 00002CF0 88C3                    	MOV	BL,AL
 18393 00002CF2 80E30F                  	AND	BL,access_mask
 18394 00002CF5 80FB02                  	CMP	BL,2
 18395 00002CF8 7703                    	JA	short Make_Bad_Access
 18396 00002CFA 5B                      	POP	BX
 18397 00002CFB F8                      	CLC
 18398 00002CFC C3                      	retn
 18399                                  
 18400                                  Make_Bad_Access:
 18401 00002CFD B80C00                  	MOV	AX,error_invalid_access ; 0Ch
 18402 00002D00 5B                      	POP	BX
 18403 00002D01 F9                      	STC
 18404 00002D02 C3                      	retn
 18405                                  
 18406                                  ;============================================================================
 18407                                  ; DINFO.ASM, MSDOS 6.0, 1991
 18408                                  ;============================================================================
 18409                                  ; 08/08/2018 - Retro DOS v3.0
 18410                                  ; 18/05/2019 - Retro DOS v4.0
 18411                                  
 18412                                  ;**	Low level routine for returning disk drive information from a local
 18413                                  ;	  or NET device
 18414                                  ;
 18415                                  ;	DISK_INFO
 18416                                  ;
 18417                                  ;	  Modification history:
 18418                                  ;
 18419                                  ;		Created: ARR 30 March 1983
 18420                                  
 18421                                  ;	Break	<DISK_INFO -- Get Disk Drive Information>
 18422                                  ;---------------------------------------------------------------------------
 18423                                  ; Procedure Name : DISK_INFO
 18424                                  ;
 18425                                  ; Inputs:
 18426                                  ;	[THISCDS] Points to the Macro List Structure of interest
 18427                                  ;		(It MAY NOT be NUL, error not detected)
 18428                                  ; Function:
 18429                                  ;	Get Interesting Drive Information
 18430                                  ; Returns:
 18431                                  ;	DX = Number of free allocation units
 18432                                  ;	BX = Total Number of allocation units on disk
 18433                                  ;	CX = Sector size
 18434                                  ;	AL = Sectors per allocation unit
 18435                                  ;	AH = FAT ID BYTE
 18436                                  ;	Carry set if error (currently user FAILed to I 24)
 18437                                  ; Segs except ES preserved, others destroyed
 18438                                  ;----------------------------------------------------------------------------
 18439                                  
 18440                                  ;hkn; called from getset.asm and misc.asm. DS has already been set up to 
 18441                                  ;hkn; DOSDATA. 
 18442                                  
 18443                                  DISK_INFO:
 18444                                  	; 08/08/2018 - Retro DOS v3.0
 18445                                  	; IBM DOS.COM (MSDOS 3.3, 1987) - Offset 37C5h
 18446                                  
 18447 00002D03 E847E5                  	call	TestNet
 18448 00002D06 7306                    	JNC	short LOCAL_DSK_INFO
 18449                                  
 18450                                  ;IF NOT Installed
 18451                                  ;	transfer NET_DISK_INFO
 18452                                  ;ELSE
 18453                                  	;MOV	AX,(MultNET SHL 8) OR 12
 18454                                  	;INT	2FH
 18455                                  	;return
 18456                                  
 18457 00002D08 B80C11                  	mov     ax,110Ch
 18458 00002D0B CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
 18459                                  			; ES:DI -> current directory
 18460                                  			; Return: AL = sectors per cluster, BX = total clusters
 18461                                  			; CX = bytes per sector, DX = number of available clusters
 18462 00002D0D C3                      	retn
 18463                                  ;ENDIF
 18464                                  
 18465                                  LOCAL_DSK_INFO:
 18466 00002D0E C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 18467 00002D13 E8FBE5                  	call	ECritDisk
 18468 00002D16 E8DB29                  	call	FATREAD_CDS		; perform media check.
 18469 00002D19 7241                    	JC	short CRIT_LEAVE
 18470 00002D1B BB0200                  	MOV	BX,2
 18471 00002D1E E83D28                  	call	UNPACK			; Get first FAT sector into CURBUF
 18472 00002D21 7239                    	JC	short CRIT_LEAVE
 18473 00002D23 C536[E205]              	LDS	SI,[CURBUF]
 18474                                  	;mov	ah,[si+20]
 18475 00002D27 8A6414                  	MOV	AH,[SI+BUFINSIZ]	; get FAT ID BYTE
 18476                                  
 18477                                  ;hkn; SS is DOSDATA
 18478 00002D2A 16                      	push	ss
 18479 00002D2B 1F                      	pop	ds
 18480                                  	;mov	cx,[es:bp+0Dh]
 18481 00002D2C 268B4E0D                	MOV	CX,[ES:BP+DPB.MAX_CLUSTER]
 18482                                  
 18483                                  ; Examine the current free count. If it indicates that we have an invalid
 18484                                  ; count, do the expensive calculation.
 18485                                  
 18486                                  	;mov	dx,[es:bp+1Fh]
 18487 00002D30 268B561F                	MOV	DX,[ES:BP+DPB.FREE_CNT] ; get free count
 18488 00002D34 83FAFF                  	CMP	DX,-1			; is it valid?
 18489 00002D37 7404                    	JZ	short DoScan
 18490                                  
 18491                                  ; Check to see if it is in a reasonable range. If so, trust it and return.
 18492                                  ; Otherwise, we need to blast out an internal error message and then recompute
 18493                                  ; the count.
 18494                                  
 18495 00002D39 39CA                    	CMP	DX,CX			; is it in a reasonable range?
 18496 00002D3B 7222                    	JB	short GotVal		; yes, trust it.
 18497                                  DoScan:
 18498 00002D3D 31D2                    	XOR	DX,DX
 18499 00002D3F 49                      	DEC	CX
 18500                                  SCANFREE:
 18501 00002D40 E81B28                  	call	UNPACK
 18502 00002D43 7217                    	JC	short CRIT_LEAVE
 18503 00002D45 7501                    	JNZ	short NOTFREECLUS
 18504 00002D47 42                      	INC	DX			; A free one
 18505                                  NOTFREECLUS:
 18506 00002D48 43                      	INC	BX			; Next cluster
 18507 00002D49 E2F5                    	LOOP	SCANFREE
 18508 00002D4B 4B                      	DEC	BX			; BX was next cluster. Convert to
 18509                                  ReturnVals:
 18510 00002D4C 4B                      	DEC	BX			; count
 18511                                  	;mov	al,[es:bp+4]
 18512 00002D4D 268A4604                	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 18513 00002D51 FEC0                    	INC	AL			; Sectors/cluster
 18514                                  	;mov	cx,[es:bp+2]
 18515 00002D53 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE] ; Bytes/sector
 18516                                  	;mov	[es:bp+1Fh],dx
 18517 00002D57 2689561F                	MOV	[ES:BP+DPB.FREE_CNT],DX
 18518 00002D5B F8                      	CLC
 18519                                  CRIT_LEAVE:
 18520                                  	;call	LCritDisk
 18521                                  	;retn
 18522                                  	; 17/12/2022
 18523 00002D5C E9CDE5                  	jmp	LCritDisk
 18524                                  
 18525                                  ; We have correctly computed everything previously. Load up registers for
 18526                                  ; return.
 18527                                  
 18528                                  GotVal: 
 18529 00002D5F 89CB                    	MOV	BX,CX			; get cluster count
 18530 00002D61 EBE9                    	JMP	short ReturnVals
 18531                                  
 18532                                  ;============================================================================
 18533                                  ; ISEARCH.ASM, MSDOS 6.0, 1991
 18534                                  ;============================================================================
 18535                                  ; 22/07/2018 - Retro DOS v3.0
 18536                                  
 18537                                  ;	TITLE	DOS_SEARCH - Internal SEARCH calls for MS-DOS
 18538                                  ;	NAME	DOS_SEARCH
 18539                                  
 18540                                  ;**	Low level routines for doing local and NET directory searches
 18541                                  ;
 18542                                  ;	DOS_SEARCH_FIRST
 18543                                  ;	DOS_SEARCH_NEXT
 18544                                  ;	RENAME_NEXT
 18545                                  ;
 18546                                  ;	Revision history:
 18547                                  ;
 18548                                  ;	    Created: ARR 30 March 1983
 18549                                  ;	    A000	version 4.00  Jan. 1988
 18550                                  ;	    A001	PTM 3564 -- search for fastopen
 18551                                  
 18552                                  ;Installed = TRUE
 18553                                  
 18554                                  ;--------------------------------------------------------------------------
 18555                                  ;
 18556                                  ; Procedure Name : DOS_SEARCH_FIRST
 18557                                  ;
 18558                                  ; Inputs:
 18559                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 18560                                  ;		terminated)
 18561                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 18562                                  ;		( = -1 if current dir not involved, else
 18563                                  ;		 Points to first char after last "/" of current dir part)
 18564                                  ;	[THISCDS] Points to CDS being used
 18565                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 18566                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 18567                                  ;	[DMAADD] Points to 53 byte buffer
 18568                                  ; Function:
 18569                                  ;	Initiate a search for the given file spec
 18570                                  ; Outputs:
 18571                                  ;	CARRY CLEAR
 18572                                  ;	    The 53 bytes ot DMAADD are filled in as follows:
 18573                                  ;
 18574                                  ;	LOCAL
 18575                                  ;	    Drive Byte (A=1, B=2, ...) High bit clear
 18576                                  ;		NEVER STORE DRIVE BYTE AFTER  found_it
 18577                                  ;	    11 byte search name with Meta chars in it
 18578                                  ;	    Search Attribute Byte, attribute of search
 18579                                  ;	    WORD LastEnt value
 18580                                  ;	    WORD DirStart
 18581                                  ;	    4 byte pad
 18582                                  ;	    32 bytes of the directory entry found
 18583                                  ;	NET
 18584                                  ;	    21 bytes First byte has high bit set
 18585                                  ;	    32 bytes of the directory entry found
 18586                                  ;
 18587                                  ;	CARRY SET
 18588                                  ;	    AX = error code
 18589                                  ;		error_no_more_files
 18590                                  ;			No match for this file
 18591                                  ;		error_path_not_found
 18592                                  ;			Bad path (not in curr dir part if present)
 18593                                  ;		error_bad_curr_dir
 18594                                  ;			Bad path in current directory part of path
 18595                                  ; DS preserved, others destroyed
 18596                                  ;---------------------------------------------------------------------------
 18597                                  
 18598                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 18599                                  	; DOSCODE:6C22h (MSDOS 5.0, MSDOS.SYS)
 18600                                  
 18601                                  DOS_SEARCH_FIRST:
 18602                                  	; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 3826h
 18603                                  
 18604 00002D63 C43E[A205]              	LES	DI,[THISCDS]
 18605 00002D67 83FFFF                  	CMP	DI,-1
 18606 00002D6A 7506                    	JNZ	short TEST_RE_NET2
 18607                                  
 18608                                  ;IF NOT Installed
 18609                                  ;	transfer NET_SEQ_SEARCH_FIRST
 18610                                  ;ELSE
 18611                                  	;mov	ax,1119h
 18612 00002D6C B81911                  	MOV	AX,(MultNET<<8)|25
 18613 00002D6F CD2F                    	INT	2Fh
 18614 00002D71 C3                      	retn
 18615                                  ;ENDIF
 18616                                  
 18617                                  TEST_RE_NET2:
 18618                                  	;test	word [es:di+43h],8000h
 18619                                  	; 17/12/2022
 18620                                  	;test	byte [es:di+44h],80h
 18621                                  	; 28/12/2022
 18622 00002D72 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8	
 18623                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 18624 00002D77 7406                    	JZ	short LOCAL_SEARCH_FIRST
 18625                                  
 18626                                  ;IF NOT Installed
 18627                                  ;	transfer NET_SEARCH_FIRST
 18628                                  ;ELSE
 18629                                  	;mov	ax,111Bh
 18630 00002D79 B81B11                  	MOV	AX,(MultNET<<8)|27
 18631 00002D7C CD2F                    	INT	2FH
 18632 00002D7E C3                      	retn
 18633                                  ;ENDIF
 18634                                  	; 18/05/2019 - Retro DOS v4.0
 18635                                  LOCAL_SEARCH_FIRST:
 18636 00002D7F E88FE5                  	call	ECritDisk
 18637                                  	; MSDOS 6.0
 18638                                  	;;test	word [DOS34_FLAG],400h
 18639                                  	; 17/12/2022
 18640                                  	;test	byte [DOS34_FLAG+1],04h
 18641 00002D82 F606[1206]04            	test	byte [DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)
 18642                                  	;TEST	word [DOS34_FLAG],SEARCH_FASTOPEN ;AN000;
 18643 00002D87 7405                    	JZ	short NOFN			;AN000;
 18644                                  	;or	byte [FastOpenFlg],1
 18645 00002D89 800E[3A0D]01            	OR	byte [FastOpenFlg],FastOpen_Set	;AN000;
 18646                                  NOFN:						;AN000;
 18647 00002D8E C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 18648                                  	; MSDOS 6.0
 18649 00002D93 E84101                  	CALL	CHECK_QUESTION		;AN000;;FO. is '?' in path
 18650 00002D96 7305                    	JNC	short norm_GETPATH	;AN000;;FO. no
 18651                                  	;and	byte [FastOpenFlg],80h
 18652 00002D98 8026[3A0D]80            	AND	byte [FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
 18653                                  norm_GETPATH:
 18654 00002D9D E8A011                  	call	GETPATH
 18655                                  	; BX = offset NAME1
 18656                                  ;_getdone:
 18657 00002DA0 7318                    	JNC	short find_check_dev
 18658 00002DA2 7511                    	JNZ	short bad_path3
 18659 00002DA4 08C9                    	OR	CL,CL
 18660 00002DA6 740D                    	JZ	short bad_path3
 18661                                  find_no_more:
 18662                                  	;mov	ax,12h
 18663 00002DA8 B81200                  	MOV	AX,error_no_more_files
 18664                                  BadBye:
 18665                                  	; MSDOS 6.0
 18666 00002DAB 368026[3A0D]80          	AND	byte [SS:FastOpenFlg],Fast_yes  ;AN000;;FO. reset fastopen
 18667                                  
 18668 00002DB1 F9                      	STC
 18669                                  	;call	LCritDisk
 18670                                  	;retn
 18671                                  	; 18/12/2022
 18672 00002DB2 E977E5                  	jmp	LCritDisk
 18673                                  
 18674                                  bad_path3:
 18675                                  	;mov	ax,3
 18676 00002DB5 B80300                  	MOV	AX,error_path_not_found
 18677 00002DB8 EBF1                    	JMP	short BadBye
 18678                                  
 18679                                  find_check_dev:
 18680 00002DBA 08E4                    	OR	AH,AH
 18681 00002DBC 790A                    	JNS	short found_entry
 18682 00002DBE C706[4803]FFFF          	MOV	word [LASTENT],-1	; Cause DOS_SEARCH_NEXT to fail
 18683 00002DC4 FE06[7005]              	INC	byte [FOUND_DEV]	; Tell DOS_RENAME we found a device
 18684                                  found_entry:
 18685                                  
 18686                                  ; We set the physical drive byte here Instead of after found_it; Doing
 18687                                  ; a search-next may not have wfp_start set correctly
 18688                                  
 18689 00002DC8 C43E[2C03]              	LES	DI,[DMAADD]
 18690 00002DCC 8B36[B205]              	MOV	SI,[WFP_START]		; get pointer to beginning
 18691 00002DD0 AC                      	LODSB
 18692 00002DD1 2C40                    	SUB	AL,'A'-1                ; logical drive
 18693 00002DD3 AA                      	STOSB				; High bit not set (local)
 18694                                  found_it:
 18695 00002DD4 C43E[2C03]              	LES	DI,[DMAADD]
 18696 00002DD8 47                      	INC	DI
 18697                                  
 18698                                  	; MSDOS 6.0
 18699 00002DD9 1E                      	PUSH	DS				  ;FO.;AN001; save ds
 18700                                  	;test	byte [FastOpenFlg],10h
 18701 00002DDA F606[3A0D]10            	TEST	byte [FastOpenFlg],Set_For_Search ;FO.;AN001; from fastopen
 18702 00002DDF 7408                    	JZ	short notfast			  ;FO.;AN001;
 18703 00002DE1 89DE                    	MOV	SI,BX				  ;FO.;AN001;
 18704 00002DE3 8E1E[E405]              	MOV	DS,[CURBUF+2]			  ;FO.;AN001;
 18705 00002DE7 EB03                    	JMP	SHORT movmov			  ;FO.;AN001;
 18706                                  
 18707                                  notfast:
 18708 00002DE9 BE[4B05]                	MOV	SI,NAME1		; find_buf 2 = formatted name
 18709                                  movmov:
 18710                                  ; Special E5 code
 18711 00002DEC A4                      	MOVSB
 18712 00002DED 26807DFF05              	CMP	BYTE [ES:DI-1],5
 18713 00002DF2 7505                    	JNZ	short NOTKANJB
 18714 00002DF4 26C645FFE5              	MOV	BYTE [ES:DI-1],0E5H
 18715                                  NOTKANJB:
 18716 00002DF9 B90A00                  	MOV	CX,10
 18717 00002DFC F3A4                    	REP	MOVSB
 18718                                  
 18719                                  	; 08/09/2018
 18720 00002DFE 1F                      	POP	DS			;FO.;AN001; restore ds
 18721                                  
 18722 00002DFF A0[6B05]                	MOV	AL,[ATTRIB]
 18723 00002E02 AA                      	STOSB
 18724 00002E03 50                      	PUSH	AX			; Save AH device info
 18725 00002E04 A1[4803]                	MOV	AX,[LASTENT]
 18726 00002E07 AB                      	STOSW
 18727 00002E08 A1[C205]                	MOV	AX,[DIRSTART]
 18728 00002E0B AB                      	STOSW
 18729                                  ; 4 bytes of 21 byte cont structure left for NET stuff
 18730 00002E0C 83C704                  	ADD	DI,4
 18731 00002E0F 58                      	POP	AX			; Recover AH device info
 18732 00002E10 08E4                    	OR	AH,AH
 18733 00002E12 781B                    	JS	short DOSREL		; Device entry is DOSGROUP relative
 18734 00002E14 833E[E205]FF            	CMP	WORD [CURBUF],-1
 18735 00002E19 7510                    	JNZ	short OKSTORE
 18736                                  
 18737                                  	; MSDOS 6.0
 18738 00002E1B F606[3A0D]10            	TEST	byte [FastOpenFlg],Set_For_Search
 18739                                  					;AN000;;FO. from fastopen and is good
 18740 00002E20 7509                    	JNZ	short OKSTORE		;AN000;;FO.
 18741                                  
 18742                                  	; The user has specified the root directory itself, rather than some
 18743                                  	; contents of it. We can't "find" that.
 18744                                  
 18745 00002E22 26C745F8FFFF            	MOV	WORD [ES:DI-8],-1	; Cause DOS_SEARCH_NEXT to fail by
 18746                                  					;   stuffing a -1 at Lastent
 18747 00002E28 E97DFF                  	JMP	find_no_more
 18748                                  
 18749                                  OKSTORE:
 18750 00002E2B 8E1E[E405]              	MOV	DS,[CURBUF+2]
 18751                                  DOSREL:
 18752                                  	; BX = offset NAME1 (from GETPATH)
 18753 00002E2F 89DE                    	MOV	SI,BX			; SI-> start of entry
 18754                                  
 18755                                  ; NOTE: DOS_RENAME depends on BX not being altered after this point
 18756                                  
 18757                                  	;mov	cx,32
 18758 00002E31 B92000                  	MOV	CX,dir_entry.size
 18759                                  ;;;;; 7/29/86
 18760 00002E34 89F8                    	MOV	AX,DI			; save the 1st byte addr
 18761 00002E36 F3A4                    	REP	MOVSB
 18762 00002E38 89C7                    	MOV	DI,AX			; restore 1st byte addr
 18763 00002E3A 26803D05                	CMP	BYTE [ES:DI],05H	; special char check
 18764 00002E3E 7504                    	JNZ	short NO05
 18765 00002E40 26C605E5                	MOV	BYTE [ES:DI],0E5H	; convert it back to E5
 18766                                  NO05:
 18767                                  
 18768                                  ;;;;; 7/29/86
 18769                                  
 18770                                  ;hkn; FastOpenflg is in DOSDATA use SS
 18771                                  	; 16/12/2022
 18772                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18773                                  	; MSDOS 6.0
 18774                                  	;AND	byte [SS:FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
 18775                                  	; 18/05/2019 - Retro DOS v4.0
 18776 00002E44 16                      	push	ss
 18777 00002E45 1F                      	pop	ds
 18778                                  	; 16/12/2022
 18779 00002E46 8026[3A0D]80            	AND	byte [FastOpenFlg],Fast_yes
 18780                                  
 18781                                  ;hkn; SS is DOSDATA
 18782                                  	;push	ss
 18783                                  	;pop	ds
 18784 00002E4B F8                      	CLC
 18785                                  	;call	LCritDisk
 18786                                  	;retn
 18787                                  	; 16/12/2022
 18788 00002E4C E9DDE4                  	jmp	LCritDisk
 18789                                  
 18790                                  ;BREAK <DOS_SEARCH_NEXT - scan for subsequent matches>
 18791                                  ;----------------------------------------------------------------------------
 18792                                  ;
 18793                                  ; Procedure Name : DOS_SEARCH_NEXT
 18794                                  ;
 18795                                  ; Inputs:
 18796                                  ;	[DMAADD] Points to 53 byte buffer returned by DOS_SEARCH_FIRST
 18797                                  ;	    (only first 21 bytes must have valid information)
 18798                                  ; Function:
 18799                                  ;	Look for subsequent matches
 18800                                  ; Outputs:
 18801                                  ;	CARRY CLEAR
 18802                                  ;	    The 53 bytes at DMAADD are updated for next call
 18803                                  ;		(see DOS_SEARCH_FIRST)
 18804                                  ;	CARRY SET
 18805                                  ;	    AX = error code
 18806                                  ;		error_no_more_files
 18807                                  ;			No more files to find
 18808                                  ; DS preserved, others destroyed
 18809                                  ;---------------------------------------------------------------------------
 18810                                  
 18811                                  ;hkn; called from search.asm. DS already set up at this point.
 18812                                  
 18813                                  DOS_SEARCH_NEXT:
 18814 00002E4F C43E[2C03]              	LES	DI,[DMAADD]
 18815 00002E53 268A05                  	MOV	AL,[ES:DI]
 18816 00002E56 A880                    	TEST	AL,80H			; Test for NET
 18817 00002E58 7406                    	JZ	short LOCAL_SEARCH_NEXT
 18818                                  ;IF NOT Installed
 18819                                  ;	transfer NET_SEARCH_NEXT
 18820                                  ;ELSE
 18821                                  	;mov	ax,111Ch
 18822 00002E5A B81C11                  	MOV	AX,(MultNET<<8)|28
 18823 00002E5D CD2F                    	INT	2FH  ; Multiplex - NETWORK REDIRECTOR - FINDNEXT
 18824                                  		     ; SS = DS = DOS CS, [DTA] = 21-byte findfirst search data
 18825                                  		     ; Return: CF set on error, AX = DOS error code
 18826                                  		     ; CF clear if successful
 18827 00002E5F C3                      	retn
 18828                                  ;ENDIF
 18829                                  
 18830                                  LOCAL_SEARCH_NEXT:
 18831                                  	;AL is drive A=1
 18832                                  	;mov	byte [EXTERR_LOCUS],2
 18833 00002E60 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 18834 00002E65 E8A9E4                  	call	ECritDisk
 18835                                  
 18836                                  ;hkn; DummyCDS is in DOSDATA
 18837 00002E68 C706[A205][F304]        	MOV     word [THISCDS],DUMMYCDS
 18838                                  ;hkn; Segment address is DOSDATA - use ds
 18839                                  ;hkn;	MOV     WORD [THISCDS+2],CS
 18840 00002E6E 8C1E[A405]              	mov	[THISCDS+2],DS
 18841                                  
 18842 00002E72 0440                    	ADD	AL,'A'-1
 18843 00002E74 E8833B                  	call	InitCDS
 18844                                  
 18845                                  ;	call	GETTHISDRV		; Set CDS pointer
 18846                                  
 18847 00002E77 7236                    	JC	short No_files		; Bogus drive letter
 18848 00002E79 C43E[A205]              	LES	DI,[THISCDS]		; Get CDS pointer
 18849                                  	;les	bp,[es:di+45h]
 18850 00002E7D 26C46D45                	LES	BP,[ES:DI+curdir.devptr] ; Get DPB pointer
 18851 00002E81 E8AAD7                  	call	GOTDPB			; [THISDPB] = ES:BP
 18852                                  
 18853                                  	 ;16/12/2022
 18854 00002E84 268A4600                	mov	al,[ES:BP]
 18855                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18856                                  	;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[ES:BP+0]
 18857 00002E88 A2[7605]                	mov	[THISDRV],AL
 18858                                  	;mov	word [CREATING],0E500h
 18859 00002E8B C706[7E05]00E5          	MOV	WORD [CREATING],(DIRFREE*256)+0
 18860 00002E91 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 18861 00002E96 C536[2C03]              	LDS	SI,[DMAADD]
 18862 00002E9A AC                      	LODSB				; Drive Byte
 18863                                  
 18864                                  	;entry	RENAME_NEXT		; Entry used by DOS_RENAME
 18865                                  RENAME_NEXT:
 18866                                  	;context ES
 18867 00002E9B 16                      	push	ss
 18868 00002E9C 07                      	pop	es			; THIS BLOWS ES:BP POINTER TO DPB
 18869                                  
 18870                                  ;hkn; NAME1 is in DOSDATA
 18871 00002E9D BF[4B05]                	MOV	DI,NAME1
 18872                                  
 18873 00002EA0 B90B00                  	MOV	CX,11
 18874 00002EA3 F3A4                    	REP	MOVSB			; Search name
 18875 00002EA5 AC                      	LODSB				; Attribute
 18876                                  
 18877                                  ;hkn; SS override
 18878 00002EA6 36A2[6B05]              	MOV	[SS:ATTRIB],AL
 18879 00002EAA AD                      	LODSW				; LastEnt
 18880 00002EAB 09C0                    	OR	AX,AX
 18881 00002EAD 7903                    	JNS	short cont_load
 18882                                  No_files:
 18883 00002EAF E9F6FE                  	JMP	find_no_more
 18884                                  
 18885                                  cont_load:
 18886 00002EB2 50                      	PUSH	AX			; Save LastEnt
 18887 00002EB3 AD                      	LODSW				; DirStart
 18888 00002EB4 89C3                    	MOV	BX,AX
 18889                                  
 18890                                  ;hkn; SS is DOSDATA
 18891                                  	;context DS
 18892 00002EB6 16                      	push	ss
 18893 00002EB7 1F                      	pop	ds
 18894 00002EB8 C42E[8A05]              	LES	BP,[THISDPB]		; Recover ES:BP
 18895                                  	;invoke	SetDirSrch
 18896 00002EBC E82410                  	call	SETDIRSRCH
 18897 00002EBF 7303                    	JNC	short SEARCH_GOON
 18898 00002EC1 58                      	POP	AX			; Clean stack
 18899 00002EC2 EBEB                    	JMP	short No_files
 18900                                  
 18901                                  SEARCH_GOON:
 18902 00002EC4 E80C13                  	call	STARTSRCH
 18903 00002EC7 58                      	POP	AX
 18904 00002EC8 E8E90F                  	call	GETENT
 18905 00002ECB 72E2                    	JC	short No_files
 18906 00002ECD E81F0F                  	call	NEXTENT
 18907 00002ED0 72DD                    	JC	short No_files
 18908 00002ED2 30E4                    	XOR	AH,AH			; If Search_Next, can't be a DEV
 18909 00002ED4 E9FDFE                  	JMP	found_it ; 10/08/2018
 18910                                  
 18911                                  ; MSDOS 6.0
 18912                                  ;---------------------------------------------------------------------------
 18913                                  ;
 18914                                  ; Procedure Name : CHECK_QUESTION
 18915                                  ;
 18916                                  ; Input: [WFP_START]= pointer to final path
 18917                                  ; Function: check '?' char
 18918                                  ; Output: carry clear, if no '?'
 18919                                  ;	 carry set, if '?' exists
 18920                                  ;---------------------------------------------------------------------------
 18921                                  
 18922                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 18923                                  CHECK_QUESTION:
 18924                                  ;hkn;	wfp_start is in DOSDATA;hkn;	MOV	WORD PTR ThisCDS+2,CS
 18925                                  ;hkn;	PUSH	CS			;AN000;;FO.
 18926 00002ED7 16                      	push	ss
 18927 00002ED8 1F                      	POP	DS			;AN000;;FO. ds:si -> final path
 18928                                  	; 16/12/2022
 18929                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18930 00002ED9 8B36[B205]              	MOV	SI,[WFP_START]		;AN000;;FO.
 18931                                  	;mov	si,[ss:WFP_START]
 18932                                  getnext:				;AN000;
 18933 00002EDD AC                      	LODSB				;AN000;;FO. get char
 18934 00002EDE 08C0                    	OR	AL,AL			;AN000;;FO. is it null
 18935 00002EE0 7405                    	JZ	short NO_Question	;AN000;;FO. yes
 18936 00002EE2 3C3F                    	CMP	AL,'?'                  ;AN000;;FO. is '?'
 18937 00002EE4 75F7                    	JNZ	short getnext 		;AN000;;FO. no
 18938 00002EE6 F9                      	STC				;AN000;;FO.
 18939                                  NO_Question:				;AN000;
 18940 00002EE7 C3                      	retn				;AN000;;FO.
 18941                                  
 18942                                  ;============================================================================
 18943                                  ; ABORT.ASM, MSDOS 6.0, 1991
 18944                                  ;============================================================================
 18945                                  ; 23/07/2018 - Retro DOS v3.0
 18946                                  ; 18/05/2019 - Retro DOS v4.0
 18947                                  
 18948                                  ;**
 18949                                  ;
 18950                                  ; Internal Abort call closes all handles and FCBs associated with a process.
 18951                                  ;  If process has NET resources a close all is sent out over the net.
 18952                                  ;
 18953                                  ;   DOS_ABORT
 18954                                  ;
 18955                                  ;   Modification history:
 18956                                  ;
 18957                                  ;       Created: ARR 30 March 1983
 18958                                  ;
 18959                                  ;	M038	SR	10/16/90	Free SFT with the PSP of the process
 18960                                  ;				being terminated only if it is busy.
 18961                                  ;
 18962                                  
 18963                                  ;Break   <DOS_ABORT -- CLOSE all files for process>
 18964                                  ;--------------------------------------------------------------------------
 18965                                  ;
 18966                                  ; Procedure Name : DOS_ABORT
 18967                                  ;
 18968                                  ; Inputs:
 18969                                  ;       [CurrentPDB] set to PID of process aborting
 18970                                  ; Function:
 18971                                  ;       Close all files and free all SFTs for this PID
 18972                                  ; Returns:
 18973                                  ;       None
 18974                                  ; All destroyed except stack
 18975                                  ;---------------------------------------------------------------------------
 18976                                  
 18977                                  DOS_ABORT:
 18978 00002EE8 368E06[3003]            	MOV     ES,[SS:CurrentPDB]	; SS override
 18979 00002EED 268B0E3200              	MOV     CX,[ES:PDB.JFN_Length]  ; Number of JFNs
 18980                                  reset_free_jfn:
 18981 00002EF2 89CB                    	MOV     BX,CX
 18982 00002EF4 51                      	PUSH    CX
 18983 00002EF5 4B                      	DEC     BX                      ; get jfn (start with last one)
 18984                                  
 18985 00002EF6 E83538                  	CALL	_$CLOSE
 18986 00002EF9 59                      	POP     CX
 18987 00002EFA E2F6                    	LOOP    reset_free_jfn          ; and do 'em all
 18988                                  
 18989                                  ; Note: We do need to explicitly close FCBs. Reasons are as follows: If we
 18990                                  ; are running in the no-sharing no-network environment, we are simulating the
 18991                                  ; 2.0 world and thus if the user doesn't close the file, that is his problem
 18992                                  ; BUT... the cache remains in a state with garbage that may be reused by the
 18993                                  ; next process. We scan the set and blast the ref counts of the FCBs we own.
 18994                                  ;
 18995                                  ; If sharing is loaded, then the following call to close process will
 18996                                  ; correctly close all FCBs. We will then need to walk the list AFTER here.
 18997                                  ;
 18998                                  ; Finally, the following call to NET_Abort will cause an EOP to be sent to all
 18999                                  ; known network resources. These resources are then responsible for cleaning
 19000                                  ; up after this process.
 19001                                  ;
 19002                                  ; Sleazy, eh?
 19003                                  
 19004                                  	;context DS			; SS is DOSDATA
 19005 00002EFC 16                      	push	ss
 19006 00002EFD 1F                      	pop	ds  ; 09/09/2018
 19007                                  
 19008                                  	;CallInstall Net_Abort, MultNET, 29
 19009 00002EFE B81D11                  	mov	ax, 111Dh
 19010 00002F01 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR 
 19011                                  			;	    - CLOSE ALL REMOTE FILES FOR PROCESS
 19012                                  			; DS???, SS = DOS CS
 19013                                  ;if installed
 19014 00002F03 FF1E[A000]              	call	far [JShare+(4*4)]	; 4 = MFTCloseP
 19015                                  ;else
 19016                                  ;	call 	MFTCloseP
 19017                                  ;endif
 19018                                  
 19019                                  ; Scan the FCB cache for guys that belong to this process and zap their ref
 19020                                  ; counts.
 19021                                  					; SS override
 19022 00002F07 36C43E[4000]            	les     di,[ss:SFTFCB]		; grab the pointer to the table
 19023                                  	;mov	cx,[es:di+4]
 19024 00002F0C 268B4D04                	mov     cx,[es:di+SFT.SFCount]
 19025 00002F10 E317                    	jcxz    FCBScanDone
 19026                                  	;lea	di,[di+6]
 19027 00002F12 8D7D06                  	LEA     DI,[DI+SFT.SFTable]	; point at table
 19028 00002F15 36A1[3C03]              	mov     ax,[SS:PROC_ID]		; SS override
 19029                                  FCBTest:
 19030                                  	;cmp	[es:di+31h],ax
 19031 00002F19 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax ; is this one of ours
 19032 00002F1D 7505                    	jnz	short FCBNext		; no, skip it
 19033 00002F1F 26C7050000              	mov	word [es:di],0
 19034                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0  ; yes, blast ref count
 19035                                  FCBNext:
 19036 00002F24 83C73B                  	add     di,SF_ENTRY.size ; 59 (for MSDOS 6.0)
 19037 00002F27 E2F0                    	loop    FCBTest
 19038                                  FCBScanDone:
 19039                                  
 19040                                  ; Walk the SFT to eliminate all busy SFT's for this process.
 19041                                  
 19042 00002F29 31DB                    	XOR     BX,BX
 19043                                  Scan:
 19044 00002F2B 53                      	push    bx
 19045 00002F2C E87A37                  	call	SFFromSFN
 19046 00002F2F 5B                      	pop     bx
 19047                                  	;jnc	short Scan1
 19048                                  	;retn
 19049                                  	; 18/12/2022
 19050 00002F30 72B5                    	jc	short NO_Question ; retn
 19051                                  
 19052                                  ;M038
 19053                                  ; Do what the comment above says, check for busy state
 19054                                  
 19055                                  Scan1:
 19056                                  	;cmp	word [es:di],0
 19057                                  	;jz	short scan_next  ; MSDOS 3.3
 19058                                  	; MSDOS 6.0
 19059 00002F32 26833DFF                	cmp	word [es:di],sf_busy ; -1
 19060                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
 19061                                  				; Is Sft busy? ;M038
 19062 00002F36 7519                    	jnz	short scan_next
 19063                                  ;
 19064                                  ; we have a SFT that is busy. See if it is for the current process
 19065                                  ;
 19066 00002F38 36A1[3C03]              	mov     ax,[SS:PROC_ID]		; SS override
 19067                                  	;cmp	[es:di+31h],ax
 19068 00002F3C 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax
 19069 00002F40 750F                    	jnz	short scan_next
 19070 00002F42 36A1[3E03]              	mov     ax,[SS:USER_ID]		; SS override
 19071                                  	;cmp	[es:di+2Fh],ax
 19072 00002F46 2639452F                	cmp	[es:di+SF_ENTRY.sf_UID],ax
 19073 00002F4A 7505                    	jnz	short scan_next
 19074                                  
 19075                                  ; This SFT is labelled as ours.
 19076                                  
 19077 00002F4C 26C7050000              	mov	word [es:di],0
 19078                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0
 19079                                  scan_next:
 19080 00002F51 43                      	inc     bx
 19081 00002F52 EBD7                    	jmp     short Scan
 19082                                  
 19083                                  ;============================================================================
 19084                                  ; CLOSE.ASM, MSDOS 6.0, 1991
 19085                                  ;============================================================================
 19086                                  ; 23/07/2018 - Retro DOS v3.0
 19087                                  ; 18/05/2019 - Retro DOS v4.0
 19088                                  
 19089                                  ;**	Internal Close and Commit calls to close a local or NET SFT.
 19090                                  ;
 19091                                  ;	DOS_CLOSE
 19092                                  ;	DOS_COMMIT
 19093                                  ;	FREE_SFT
 19094                                  ;	SetSFTTimes
 19095                                  ;
 19096                                  ;	Revision history:
 19097                                  ;
 19098                                  ;	   AN000  version 4.00	Jan. 1988
 19099                                  ;	   A005   PTM 3718 --- lost clusters when fastopen installed
 19100                                  ;	   A011   PTM 4766 --- C2 fastopen problem
 19101                                  
 19102                                  ;Installed = TRUE
 19103                                  
 19104                                  ;Break <DOS_CLOSE -- CLOSE FILE from SFT>
 19105                                  ;---------------------------------------------------------------------------
 19106                                  ;
 19107                                  ; Procedure Name : DOS_CLOSE
 19108                                  ;
 19109                                  ; Inputs:
 19110                                  ;	[THISSFT] set to the SFT for the file being used
 19111                                  ; Function:
 19112                                  ;	Close the indicated file via the SFT
 19113                                  ; Returns:
 19114                                  ;	sf_ref_count decremented otherwise
 19115                                  ;	ES:DI point to SFT
 19116                                  ;	Carry set if error
 19117                                  ;	    AX has error code
 19118                                  ; DS preserved, others destroyed
 19119                                  ;---------------------------------------------------------------------------
 19120                                  
 19121                                  ;hkn; DOS_CLOSE called from fcbio.asm and handle.asm. DS alreday set up.
 19122                                  
 19123                                  ; 18/05/2019 - Retro DOS v4.0
 19124                                  ; DOSCODE:6E2Eh (MSDOS 6.21, MSDOS.SYS)
 19125                                  
 19126                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19127                                  ; DOSCODE:6E1Ah (MSDOS 5.0, MSDOS.SYS)
 19128                                  
 19129                                  ; 23/07/2018 - IBMDOS.COM (MSDOS 3.3), 1987 - Offset 39D0h
 19130                                  
 19131                                  DOS_CLOSE:
 19132 00002F54 C43E[9E05]              	LES	DI,[THISSFT]
 19133                                  	;mov	bx,[ES:DI+5]
 19134 00002F58 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 19135                                  
 19136                                  ; Network closes are handled entirely by the net code.
 19137                                  
 19138                                  	;;test	bx,8000h
 19139                                  	;TEST	BX,sf_isnet
 19140                                  	; 17/12/2022
 19141                                  	;test	bh,80h
 19142 00002F5C F6C780                  	test	bh,(sf_isnet>>8)
 19143 00002F5F 7406                    	JZ	short LocalClose
 19144                                  
 19145                                  	;CallInstall Net_Close,MultNET,6
 19146 00002F61 B80611                  	mov     ax,1106h
 19147 00002F64 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE
 19148                                  			; ES:DI -> SFT
 19149                                  			; SFT DPB field -> DPB of drive containing file
 19150                                  			; Return: CF set on error, AX = DOS error code
 19151                                  			; CF clear if successful
 19152 00002F66 C3                      	retn
 19153                                  
 19154                                  ; All closes release the sharing information.
 19155                                  ; No commit releases sharing information
 19156                                  ;
 19157                                  ; All closes decrement the ref count.
 19158                                  ; No commit decrements the ref count.
 19159                                  
 19160                                  LocalClose:
 19161 00002F67 E8A7E3                  	call	ECritDisk
 19162 00002F6A E86401                  	CALL	SetSFTTimes
 19163 00002F6D E8E200                  	CALL	FREE_SFT		; dec ref count or mark as busy
 19164                                  
 19165                                  ;hkn; SS is DOSDATA
 19166                                  	;Context DS
 19167 00002F70 16                      	push	ss
 19168 00002F71 1F                      	pop	ds
 19169                                  
 19170 00002F72 50                      	push	ax
 19171 00002F73 53                      	push	bx
 19172 00002F74 E81944                  	call	ShareEnd
 19173 00002F77 5B                      	pop	bx
 19174 00002F78 58                      	pop	ax
 19175                                  
 19176                                  ; Commit enters here. AX from commit MUST be <> 1, BX is flags word
 19177                                  
 19178                                  CloseEntry:
 19179 00002F79 50                      	PUSH	AX
 19180                                  
 19181                                  ; File clean or device does not get stamped nor disk looked at.
 19182                                  
 19183                                  	;test	bx,0C0h
 19184                                  	; 17/12/2022
 19185 00002F7A F6C3C0                  	test	bl,devid_file_clean+devid_device
 19186                                  	;TEST	BX,devid_file_clean+devid_device
 19187 00002F7D 7403                    	JZ	short rdir
 19188                                  	; 14/11/2022
 19189 00002F7F E9BD00                  	JMP	FREE_SFT_OK		; either clean or device
 19190                                  	;jnz	short FREE_SFT_OK ; 24/07/2019	
 19191                                  
 19192                                  ; Retrieve the directory entry for the file
 19193                                  
 19194                                  rdir:
 19195 00002F82 E8DA00                  	CALL	DirFromSFT
 19196                                  	;mov	al,5
 19197 00002F85 B005                    	MOV	AL,error_access_denied
 19198 00002F87 7303                    	JNC	short clook
 19199                                  	; 14/11/2022
 19200 00002F89 E9B400                  	JMP	CloseFinish		; pretend the close worked.
 19201                                  	;jc	short CloseFinish ; 24/07/2019
 19202                                  clook:
 19203                                  
 19204                                  ; ES:DI points to entry
 19205                                  ; DS:SI points to SFT
 19206                                  ; ES:BX points to buffer header
 19207                                  
 19208 00002F8C 57                      	push	di
 19209 00002F8D 56                      	push	si
 19210                                  	;lea	si,[si+20h]
 19211 00002F8E 8D7420                  	LEA	SI,[SI+SF_ENTRY.sf_name]
 19212                                  
 19213                                  ; ES:DI point to directory entry
 19214                                  ; DS:SI point to unpacked name
 19215                                  
 19216 00002F91 E86DE2                  	call	XCHGP
 19217                                  
 19218                                  ; ES:DI point to unpacked name
 19219                                  ; DS:SI point to directory entry
 19220                                  
 19221 00002F94 E8B60E                  	call	MetaCompare
 19222 00002F97 E867E2                  	call	XCHGP
 19223 00002F9A 5E                      	pop	si
 19224 00002F9B 5F                      	pop	di
 19225 00002F9C 740C                    	JZ	short CLOSE_GO		; Name OK
 19226                                  Bye:	
 19227 00002F9E 89F7                    	MOV	DI,SI
 19228 00002FA0 1E                      	PUSH	DS
 19229 00002FA1 07                      	POP	ES			; ES:DI points to SFT
 19230 00002FA2 16                      	PUSH	SS
 19231 00002FA3 1F                      	POP	DS
 19232 00002FA4 F9                      	STC
 19233                                  	;mov	al,2
 19234 00002FA5 B002                    	MOV	AL,error_file_not_found
 19235 00002FA7 E99600                  	JMP	CloseFinish ; 24/07/2019
 19236                                  
 19237                                  	; 18/05/2019 - Retro DOS v4.0
 19238                                  CLOSE_GO:
 19239                                  	; MSDOS 6.0
 19240                                  	;test	word [si+2],8000h
 19241                                  	;TEST	word [SI+SF_ENTRY.sf_mode],sf_isFCB ; FCB ?
 19242                                  	; 17/12/2022
 19243                                  	;test	byte [si+3],80h
 19244 00002FAA F6440380                	test	byte [SI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8) ; FCB ?
 19245 00002FAE 740D                    	JZ	short nofcb		; no, set dir attr, sf_attr
 19246                                  	; MSDOS 3.3 & MSDOS 6.0
 19247                                  	;mov	ch,[es:di+0Bh]
 19248 00002FB0 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]
 19249                                  	;mov	al,[si+4]
 19250 00002FB4 8A4404                  	MOV	AL,[SI+SF_ENTRY.sf_attr]
 19251                                  
 19252                                  ;hkn; SS override
 19253 00002FB7 36A2[6B05]              	MOV	[SS:ATTRIB],AL
 19254                                  	; MSDOS 3.3
 19255                                  	;;call	MatchAttributes
 19256                                  	;;JNZ	short Bye		; attributes do not match
 19257                                  	; 18/05/2019
 19258 00002FBB EB07                    	JMP	SHORT setattr		;FT.
 19259                                  nofcb:
 19260                                  	; MSDOS 6.0
 19261                                  	;mov	al,[si+4]
 19262 00002FBD 8A4404                  	MOV	AL,[SI+SF_ENTRY.sf_attr] ;FT.		;AN000;
 19263 00002FC0 2688450B                	MOV	[ES:DI+dir_entry.dir_attr],AL ;FT.	;AN000;
 19264                                  setattr:
 19265                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19266                                  	;or	byte [es:di+0Bh],20h
 19267 00002FC4 26804D0B20              	OR	BYTE [ES:DI+dir_entry.dir_attr],attr_archive ;Set archive
 19268                                  	; MSDOS 6.0
 19269                                  	;mov	ax,[es:di+1Ah]
 19270 00002FC9 268B451A                	MOV	AX,[ES:DI+dir_entry.dir_first] ;AN011
 19271                                  					;F.O. save old first cluster
 19272                                  ;hkn; SS override
 19273 00002FCD 36A3[BE0F]              	MOV	[SS:OLD_FIRSTCLUS],AX	;AN011;F.O. save old first cluster
 19274                                  
 19275                                  	;mov	ax,[si+0Bh]
 19276 00002FD1 8B440B                  	MOV	AX,[SI+SF_ENTRY.sf_firclus]
 19277                                  	;mov	[es:di+1Ah],ax
 19278 00002FD4 2689451A                	MOV	[ES:DI+dir_entry.dir_first],AX	;Set firclus pointer
 19279                                  	;mov	ax,[si+11h]
 19280 00002FD8 8B4411                  	MOV	AX,[SI+SF_ENTRY.sf_size]
 19281                                  	;mov	[es:di+1Ch],ax
 19282 00002FDB 2689451C                	MOV	[ES:DI+dir_entry.dir_size_l],AX	;Set size
 19283                                  	;mov	ax,[si+13h]
 19284 00002FDF 8B4413                  	MOV	AX,[SI+SF_ENTRY.sf_size+2]
 19285                                  	;mov	[es:di+1Eh],ax
 19286 00002FE2 2689451E                	MOV	[ES:DI+dir_entry.dir_size_h],AX
 19287                                  	;mov	ax,[si+0Fh]
 19288 00002FE6 8B440F                  	MOV	AX,[SI+SF_ENTRY.sf_date]
 19289                                  	;mov	[es:di+18h],ax
 19290 00002FE9 26894518                	MOV	[ES:DI+dir_entry.dir_date],AX	;Set date
 19291                                  	;mov	ax,[si+0Dh]
 19292 00002FED 8B440D                  	MOV	AX,[SI+SF_ENTRY.sf_time]
 19293                                  	;mov	[es:di+16h],ax
 19294 00002FF0 26894516                	MOV	[ES:DI+dir_entry.dir_time],AX	;Set time
 19295                                  
 19296                                  	; MSDOS 6.0
 19297                                  ;; File Tagging
 19298 00002FF4 26F6470540              	TEST	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty  
 19299                                  				  ;LB. if already dirty		    ;AN000;
 19300 00002FF9 7508                    	JNZ	short yesdirty4	  ;LB.  don't increment dirty count ;AN000;
 19301                                  	; 02/06/2019
 19302 00002FFB E8742B                  	call	INC_DIRTY_COUNT   ;LB.				    ;AN000;
 19303                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19304                                  	;or	byte [es:bx+5],40h
 19305 00002FFE 26804F0540              	OR	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty
 19306                                  yesdirty4:
 19307 00003003 1E                      	push	ds
 19308 00003004 56                      	push	si
 19309                                  	; MSDOS 6.0
 19310                                  	;mov	cx,[si+0Bh]
 19311                                  	; 07/12/2022
 19312 00003005 8B4C0B                  	MOV	CX,[SI+SF_ENTRY.sf_firclus] ; do this for Fastopen
 19313                                  ;hkn; SS override
 19314 00003008 36A0[7605]              	MOV	AL,[SS:THISDRV]
 19315                                  	; MSDOS 3.3 
 19316                                  	;push	ss
 19317                                  	;pop	ds
 19318                                  	;MOV	AL,[THISDRV]
 19319                                  ;;; 10/1/86  update fastopen cache
 19320                                  	; MSDOS 3.3 & MSDOS 6.0
 19321 0000300C 52                      	PUSH	DX
 19322 0000300D B400                    	MOV	AH,0			; dir entry update
 19323 0000300F 88C2                    	MOV	DL,AL			; drive number A=0, B=1,,,
 19324                                  	; MSDOS 6.0
 19325 00003011 09C9                    	OR	CX,CX			;AN005; first cluster 0; may be truncated
 19326 00003013 750D                    	JNZ	short do_update2	;AN005; no, do update
 19327 00003015 B403                    	MOV	AH,3			;AN005; do a delete cache entry
 19328                                  	;mov	di,[si+1Bh]
 19329 00003017 8B7C1B                  	MOV	DI,[SI+SF_ENTRY.sf_dirsec] ;AN005; cx:di = dir sector
 19330                                  	;mov	cx,[si+1Dh]
 19331 0000301A 8B4C1D                  	MOV	CX,[SI+SF_ENTRY.sf_dirsec+2] ;AN005;
 19332                                  	;mov	dh,[si+1Fh]
 19333 0000301D 8A741F                  	MOV	DH,[SI+SF_ENTRY.sf_dirpos] ;AN005; dh = dir pos
 19334 00003020 EB0E                    	JMP	SHORT do_update 	;AN011;F.O.
 19335                                  do_update2:				;AN011;F.O.
 19336                                  ;hkn; SS override fort OLD_FIRSTCLUS
 19337                                  	; 
 19338 00003022 363B0E[BE0F]            	CMP	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O. same as old first clusetr?
 19339 00003027 7407                    	JZ	short do_update		;AN011;F.O. yes
 19340 00003029 B402                    	MOV	AH,2			;AN011;F.O. delete the old entry
 19341 0000302B 368B0E[BE0F]            	MOV	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O.
 19342                                  do_update:				;AN005;
 19343                                  ;hkn; SS is DOSDATA
 19344                                  	;Context DS
 19345 00003030 16                      	push	ss
 19346 00003031 1F                      	pop	ds	
 19347                                  	; MSDOS 3.3 & MSDOS 6.0
 19348 00003032 E8E5F6                  	call	FastOpen_Update 	; invoke fastopen
 19349 00003035 5A                      	POP	DX
 19350                                  
 19351                                  ;;; 10/1/86  update fastopen cache
 19352 00003036 E8342A                  	call	FLUSHBUF		; flush all relevant buffers
 19353 00003039 5F                      	pop	di
 19354 0000303A 07                      	pop	es
 19355                                  	;mov	al,5
 19356 0000303B B005                    	MOV	AL,error_access_denied
 19357 0000303D 7201                    	JC	short CloseFinish
 19358                                  FREE_SFT_OK:
 19359 0000303F F8                      	CLC				; signal no error.
 19360                                  CloseFinish:
 19361                                  
 19362                                  ; Indicate to the device that the SFT is being closed.
 19363                                  
 19364                                  ;;;; 7/21/86
 19365 00003040 9C                      	PUSHF				; save flag from DirFromSFT
 19366 00003041 E8D115                  	call	DEV_CLOSE_SFT
 19367 00003044 9D                      	POPF
 19368                                  ;;;; 7/21/86
 19369                                  ;
 19370                                  ; See if the ref count indicates that we have busied the SFT. If so, mark the
 19371                                  ; SFT as being free. Note that we do NOT need to be in critSFT as we are ONLY
 19372                                  ; going to be moving from busy to free.
 19373                                  ;
 19374 00003045 59                      	POP	CX			; get old ref count
 19375 00003046 9C                      	PUSHF
 19376 00003047 49                      	DEC	CX			; if cx != 1
 19377 00003048 7503                    	JNZ	short NoFree		; then do NOT free SFT
 19378 0000304A 26890D                  	mov	[es:di],cx
 19379                                  	;MOV	[ES:DI+SF_ENTRY.sf_ref_Count],CX ; mov [es:di+0],cx
 19380                                  NoFree:
 19381 0000304D E8DCE2                  	call	LCritDisk
 19382 00003050 9D                      	POPF
 19383 00003051 C3                      	retn
 19384                                  
 19385                                  ;---------------------------------------------------------------------------
 19386                                  ;
 19387                                  ; Procedure Name : FREE_SFT
 19388                                  ;
 19389                                  ; ES:DI -> SFT. Decs sft_ref_count. If the count goes to 0, mark it as busy.
 19390                                  ; Flags preserved. Return old ref count in AX
 19391                                  ;
 19392                                  ; Note that busy is indicated by the SFT ref count being -1.
 19393                                  ;
 19394                                  ;---------------------------------------------------------------------------
 19395                                  
 19396                                  FREE_SFT:
 19397 00003052 9C                      	PUSHF		; Save carry state
 19398 00003053 268B05                  	mov	ax,[es:di]
 19399                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 19400 00003056 48                      	DEC	AX
 19401 00003057 7501                    	JNZ	short SetCount
 19402 00003059 48                      	DEC	AX
 19403                                  SetCount:
 19404 0000305A 268705                  	xchg	ax,[es:di]
 19405                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 19406 0000305D 9D                      	POPF
 19407 0000305E C3                      	retn
 19408                                  
 19409                                  	; 18/05/2019 - Retro DOS v4.0
 19410                                  
 19411                                  ;----------------------------------------------------------------------------
 19412                                  ;
 19413                                  ; Procedure Name : DirFromSFT
 19414                                  ;
 19415                                  ;   DirFromSFT - locate a directory entry given an SFT.
 19416                                  ;
 19417                                  ;   Inputs:	ES:DI point to SFT
 19418                                  ;		DS = DOSDATA
 19419                                  ;   Outputs:
 19420                                  ;		EXTERR_LOCUS = errLOC_Disk
 19421                                  ;		CurBuf points to buffer
 19422                                  ;		Carry Clear -> operation OK
 19423                                  ;		    ES:DI point to entry
 19424                                  ;		    ES:BX point to buffer
 19425                                  ;		    DS:SI point to SFT
 19426                                  ;		Carry SET   -> operation failed
 19427                                  ;		    registers trashified
 19428                                  ;   Registers modified: ALL
 19429                                  ;----------------------------------------------------------------------------
 19430                                  
 19431                                  DirFromSFT:
 19432                                  	;mov	byte [EXTERR_LOCUS],2
 19433 0000305F C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 19434 00003064 06                      	push	es
 19435 00003065 57                      	push	di
 19436                                  	; MSDOS 3.3
 19437                                  	;;mov	dx,[es:di+1Dh]
 19438                                  	;MOV	dx,[ES:DI+SF_ENTRY.sf_dirsec]
 19439                                  	; MSDOS 6.0
 19440                                  	;mov	dx,[es:[di+1Dh]
 19441 00003066 268B551D                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec+2]  ;F.C. >32mb
 19442 0000306A 8916[0706]              	MOV	[HIGH_SECTOR],DX		 ;F.C. >32mb
 19443                                  	;mov	dx,[es:di+1Bh]
 19444 0000306E 268B551B                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec]
 19445                                  	; 19/05/2019
 19446 00003072 FF36[0706]              	PUSH	word [HIGH_SECTOR]	;F.C. >32mb
 19447                                  	; MSDOS 3.3 & MSDOS 6.0
 19448 00003076 52                      	PUSH	DX
 19449 00003077 E86A26                  	call	FATREAD_SFT		; ES:BP points to DPB, [THISDRV] set
 19450                                  					; [THISDPB] set
 19451 0000307A 5A                      	POP	DX
 19452 0000307B 8F06[0706]              	POP	word [HIGH_SECTOR]	;F.C. >32mb
 19453 0000307F 721E                    	JC	short PopDone
 19454                                  	; 22/09/2023
 19455                                  	;XOR	AL,AL	; *		; Pre read
 19456                                  	;;mov	byte [ALLOWED],18h
 19457                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 19458                                  	;call	GETBUFFR
 19459                                  	; 22/09/2023
 19460 00003081 E8E528                  	call	GETBUFFER ; * 		; Pre read
 19461 00003084 7219                    	JC	short PopDone
 19462 00003086 5E                      	pop	si
 19463 00003087 1F                      	pop	ds			; Get back SFT pointer
 19464                                  
 19465                                  ;hkn; SS override
 19466 00003088 36C43E[E205]            	LES	DI,[SS:CURBUF]
 19467                                  	;or	byte [es:di+5],4
 19468 0000308D 26804D0504              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 19469 00003092 89FB                    	MOV	BX,DI			; ES:BX point to buffer header
 19470                                  	;;lea	di,[di+16] ; MSDOS 3.3
 19471                                  	;lea	di,[di+20] ; MSDOS 6.0
 19472 00003094 8D7D14                  	LEA	DI,[DI+BUFINSIZ] 	; Point to buffer
 19473                                  	;mov	al,32
 19474 00003097 B020                    	MOV	AL,dir_entry.size
 19475                                  	;mul	byte [si+1Fh] ; MSDOS 6.0
 19476 00003099 F6641F                  	MUL	byte [SI+SF_ENTRY.sf_dirpos]
 19477 0000309C 01C7                    	ADD	DI,AX			; Point at the entry
 19478 0000309E C3                      	retn				; carry is clear
 19479                                  PopDone:
 19480 0000309F 5F                      	pop	di
 19481 000030A0 07                      	pop	es
 19482                                  PopDone_retn:
 19483 000030A1 C3                      	retn
 19484                                  
 19485                                  ;----------------------------------------------------------------------------
 19486                                  ;
 19487                                  ;**	DOS_Commit - UPdate Directory Entries
 19488                                  ;
 19489                                  ;	ENTRY	same as DOS_CLOSE (??? BUGBUG - update this jgl)
 19490                                  ;		(DS) = DOSGROUP
 19491                                  ;	EXIT	Same as DOS_CLOSE except ref_count field is not altered
 19492                                  ;	USES	all but DS
 19493                                  ;
 19494                                  ;----------------------------------------------------------------------------
 19495                                  
 19496                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19497                                  ; DOSCODE:6F72h (MSDOS 5.0, MSDOS.SYS)
 19498                                  
 19499                                  DOS_COMMIT:
 19500                                  	;hkn; called from srvcall. DS already set up.
 19501 000030A2 C43E[9E05]              	LES	DI,[THISSFT]
 19502                                  	;mov	bx,[es:di+5]
 19503 000030A6 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 19504                                  	;test	bx,0C0h
 19505                                  	; 17/12/2022
 19506 000030AA F6C3C0                  	test	bl,devid_file_clean+devid_device ;Clears carry
 19507                                  	;TEST	BX,devid_file_clean+devid_device ;Clears carry
 19508 000030AD 75F2                    	jnz	short PopDone_retn
 19509                                  	;test	bx,8000h
 19510                                  	; 17/12/2022
 19511                                  	;test	bh,80h
 19512 000030AF F6C780                  	test	bh,(sf_isnet>>8) ; 80h
 19513                                  	;TEST	BX,sf_isnet ; 8000h
 19514 000030B2 7406                    	JZ	short LOCAL_COMMIT
 19515                                  
 19516                                  ;IF NOT Installed
 19517                                  ;	transfer NET_COMMIT
 19518                                  ;ELSE
 19519                                  	;mov	ax,1107h
 19520 000030B4 B80711                  	MOV	AX,(MultNET<<8)|7
 19521 000030B7 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
 19522                                  			; ES:DI -> SFT
 19523                                  			; SFT DPB field -> DPB of drive containing file
 19524                                  			; Return: CF set on error, AX = DOS error code
 19525                                  			; CF clear if successful
 19526                                  localcommit_retn: ; 18/12/2022	
 19527 000030B9 C3                      	retn
 19528                                  ;ENDIF
 19529                                  
 19530                                  ; Perform local commit operation by doing a close but not releaseing the SFT.
 19531                                  ; There are three ways we can do this. One is to enter a critical section to
 19532                                  ; protect a potential free. The second is to increment the ref count to mask
 19533                                  ; the close decrementing.
 19534                                  ;
 19535                                  ; The proper way is to let the caller's of close decide if a decrement should
 19536                                  ; be done. We do this by providing another entry into close after the
 19537                                  ; decrement and after the share information release.
 19538                                  
 19539                                  ; DOSCODE:6FA0h (MSDOS 6.21, MSDOS.SYS)
 19540                                  ; DOSCODE:6F8Ch (MSDOS 5.0, MSDOS.SYS) 
 19541                                  
 19542                                  LOCAL_COMMIT:
 19543 000030BA E854E2                  	call	ECritDisk
 19544                                  	; MSDOS 6.0
 19545 000030BD E851E2                  	call	ECritDisk	;PTM.
 19546 000030C0 E80E00                  	call	SetSFTTimes
 19547 000030C3 B8FFFF                  	MOV	AX,-1
 19548 000030C6 E8B0FE                  	call	CloseEntry
 19549                                  	; MSDOS 6.0
 19550 000030C9 9C                      	PUSHF			;PTM.				;AN000;
 19551 000030CA E84015                  	call	DEV_OPEN_SFT	;PTM.  increment device count	;AN000;
 19552 000030CD 9D                      	POPF			;PTM.				;AN000;
 19553                                  	;call	LCritDisk	;PTM.				;AN000;
 19554                                  	; 18/12/2022
 19555 000030CE E95BE2                  	jmp	LCritDisk
 19556                                  ;localcommit_retn:
 19557                                  ;	retn
 19558                                  
 19559                                  ;Break	<SetSFTTimes - signal a change in the times for an SFT>
 19560                                  ;----------------------------------------------------------------------------
 19561                                  ;
 19562                                  ; Procedure Name : SetSFTTimes
 19563                                  ;
 19564                                  ;   SetSFTTimes - Examine the flags for a SFT and set the time appropriately.
 19565                                  ;   Reflect these times in other SFT's for the same file.
 19566                                  ;
 19567                                  ;   Inputs:	ES:DI point to SFT
 19568                                  ;		BX = sf_flags set apprpriately
 19569                                  ;   Outputs:	Set sft times to current time if File & dirty & !nodate
 19570                                  ;   Registers modified: All except ES:DI, BX, AX
 19571                                  ;
 19572                                  ;----------------------------------------------------------------------------
 19573                                  
 19574                                  SetSFTTimes:
 19575                                  ;	File clean or device does not get stamped nor disk looked at.
 19576                                  	
 19577                                  	;test	bx,0C0h
 19578                                  	; 17/12/2022
 19579 000030D1 F6C3C0                  	test	bl,devid_file_clean+devid_device
 19580                                  	;TEST	BX,devid_file_clean+devid_device
 19581                                  	;retnz				; clean or device => no timestamp
 19582 000030D4 75E3                    	jnz	short localcommit_retn
 19583                                  
 19584                                  ;	file and dirty. See if date is good
 19585                                  
 19586                                  	;test	bx,4000h
 19587                                  	; 17/12/2022
 19588                                  	;test	bh,40h
 19589 000030D6 F6C740                  	test	bh,(sf_close_nodate>>8)
 19590                                  	;TEST	BX,sf_close_nodate
 19591                                  	;retnz				; nodate => no timestamp
 19592 000030D9 75DE                    	jnz	short localcommit_retn
 19593                                  
 19594 000030DB 50                      	push	ax
 19595 000030DC 53                      	push	bx
 19596 000030DD E810DA                  	call	DATE16			; Date/Time to AX/DX
 19597                                  	;mov	[es:di+0Fh],ax
 19598 000030E0 2689450F                	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 19599                                  	;mov	[es:di+0Dh],dx
 19600 000030E4 2689550D                	MOV	[ES:DI+SF_ENTRY.sf_time],DX
 19601 000030E8 31C0                    	XOR	AX,AX
 19602                                  ;if installed
 19603                                  	;call	JShare + 14 * 4
 19604 000030EA FF1E[C800]              	call	far [JShare+(14*4)]	; 14 = ShSU
 19605                                  ;else
 19606                                  ;	call	ShSU
 19607                                  ;endif
 19608 000030EE 5B                      	pop	bx
 19609 000030EF 58                      	pop	ax
 19610 000030F0 C3                      	retn
 19611                                  
 19612                                  ;============================================================================
 19613                                  ; DIRCALL.ASM, MSDOS 6.0, 1991
 19614                                  ;============================================================================
 19615                                  ; 23/07/2018 - Retro DOS v3.0
 19616                                  ; 18/05/2019 - Retro DOS v4.0
 19617                                  
 19618                                  ; DOSCODE:6FDAh (MSDOS 6.21, MSDOS.SYS)
 19619                                  
 19620                                  ;TITLE DIRCALL - Directory manipulation internal calls
 19621                                  ;NAME  DIRCALL
 19622                                  
 19623                                  ;**	Low level directory manipulation routines for making removing and
 19624                                  ;	  verifying local or NET directories
 19625                                  ;
 19626                                  ;	DOS_MKDIR
 19627                                  ;	DOS_CHDIR
 19628                                  ;	DOS_RMDIR
 19629                                  ;
 19630                                  ;	Modification history:
 19631                                  ;
 19632                                  ;		Created: ARR 30 March 1983
 19633                                  
 19634                                  ;BREAK <DOS_MkDir - Make a directory entry>
 19635                                  ;---------------------------------------------------------------------------
 19636                                  ;
 19637                                  ; Procedure Name : DOS_MkDir
 19638                                  ;
 19639                                  ; Inputs:
 19640                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 19641                                  ;		terminated)
 19642                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 19643                                  ;		( = -1 if current dir not involved, else
 19644                                  ;		 Points to first char after last "/" of current dir part)
 19645                                  ;	[THISCDS] Points to CDS being used
 19646                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 19647                                  ; Function:
 19648                                  ;	Make a new directory
 19649                                  ; Returns:
 19650                                  ;	Carry Clear
 19651                                  ;		No error
 19652                                  ;	Carry Set
 19653                                  ;	    AX is error code
 19654                                  ;		error_path_not_found
 19655                                  ;			Bad path (not in curr dir part if present)
 19656                                  ;		error_bad_curr_dir
 19657                                  ;			Bad path in current directory part of path
 19658                                  ;		error_access_denied
 19659                                  ;			Already exists, device name
 19660                                  ; DS preserved, Others destroyed
 19661                                  ;---------------------------------------------------------------------------
 19662                                  
 19663                                  ;hkn; called from path.asm. DS already set up.
 19664                                  
 19665                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19666                                  ; DOSCODE:6FC6h (MSDOS 5.0, MSDOS.SYS)
 19667                                  
 19668                                  DOS_MKDIR:
 19669 000030F1 E859E1                  	call	TestNet
 19670 000030F4 7313                    	JNC	short LOCAL_MKDIR
 19671                                  
 19672                                  ;IF NOT Installed
 19673                                  ;	transfer NET_MKDIR
 19674                                  ;ELSE
 19675                                  	;mov	ax,1103h
 19676 000030F6 B80311                  	MOV	AX,(MultNET<<8)|3
 19677 000030F9 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
 19678                                  			; SS = DOS CS
 19679                                  			; SDA first filename pointer -> fully-qualified directory name
 19680                                  			; SDA CDS pointer -> current directory
 19681                                  			; Return: CF set on error, AX = DOS error code
 19682                                  			; CF clear if successful
 19683 000030FB C3                      	retn
 19684                                  ;ENDIF
 19685                                  
 19686                                  NODEACCERRJ:
 19687                                  	;mov	ax,5
 19688 000030FC B80500                  	MOV	AX,error_access_denied
 19689                                  _BadRet:
 19690 000030FF F9                      	STC
 19691                                  	;call	LCritDisk
 19692                                  	;retn
 19693                                  	; 18/12/2022
 19694 00003100 E929E2                  	jmp	LCritDisk
 19695                                  
 19696                                  PATHNFJ:
 19697 00003103 E826E2                  	call	LCritDisk
 19698 00003106 E9EFF9                  	jmp	SET_MKND_ERR	; Map the MakeNode error and return
 19699                                  
 19700                                  LOCAL_MKDIR:
 19701 00003109 E805E2                  	call	ECritDisk
 19702                                  
 19703                                  ; MakeNode requires an SFT to fiddle with. We Use a temp spot (RENBUF)
 19704                                  
 19705 0000310C 8C16[A005]              	MOV	[THISSFT+2],SS
 19706                                  
 19707                                  ;hkn; DOSDATA
 19708 00003110 C706[9E05][3E04]        	MOV	WORD [THISSFT],RENBUF
 19709                                  
 19710                                  ;  NOTE: Need WORD PTR because MASM takes type of
 19711                                  ;   TempSFT (byte) instead of type of sf_mft (word).
 19712                                  
 19713                                  	;mov	word [RENBUF+33h],0 ; MSDOS 6.0
 19714 00003116 C706[7104]0000          	MOV	WORD [RENBUF+SF_ENTRY.sf_MFT],0
 19715                                  				; make sure SHARER won't complain.
 19716                                  	;mov	al,10h
 19717 0000311C B010                    	MOV	AL,attr_directory
 19718 0000311E E88B18                  	call	MakeNode
 19719 00003121 72E0                    	JC	short PATHNFJ
 19720 00003123 83F803                  	CMP	AX,3
 19721 00003126 74D4                    	JZ	short NODEACCERRJ ; Can't make a device into a directory
 19722 00003128 C42E[8A05]              	LES	BP,[THISDPB]	; Makenode zaps this
 19723 0000312C C53E[E205]              	LDS	DI,[CURBUF]
 19724 00003130 29FE                    	SUB	SI,DI
 19725 00003132 56                      	PUSH	SI		; Pointer to dir_first
 19726                                  	; MSDOS 6.0
 19727                                  	;push	word [DI+8]
 19728 00003133 FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;F.C. >32mb
 19729                                  	; MSDOS 3.3 & MSDOS 6.0
 19730                                  	;push	word [di+6]
 19731 00003136 FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Sector of new node
 19732 00003139 16                      	push	ss
 19733 0000313A 1F                      	pop	ds
 19734 0000313B FF36[C205]              	PUSH	word [DIRSTART]	; Parent for .. entry
 19735 0000313F 31C0                    	XOR	AX,AX
 19736 00003141 A3[C205]                	MOV	[DIRSTART],AX	; Null directory
 19737 00003144 E8A117                  	call	NEWDIR
 19738 00003147 726F                    	JC	short NODEEXISTSPOPDEL ; No room
 19739 00003149 E8680D                  	call	GETENT		; First entry
 19740 0000314C 726A                    	JC	short NODEEXISTSPOPDEL ; Screw up
 19741 0000314E C43E[E205]              	LES	DI,[CURBUF]
 19742                                  
 19743                                  	; MSDOS 6.0
 19744 00003152 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 19745                                  				 ;LB. if already dirty		    ;AN000;
 19746 00003157 7508                    	JNZ	short yesdirty5	 ;LB.   don't increment dirty count ;AN000;
 19747 00003159 E8162A                  	call	INC_DIRTY_COUNT  ;LB.				    ;AN000;
 19748                                  	
 19749                                  	; MSDOS 3.3 & MSDOS 6.0
 19750                                  	;or	byte [es:di+5],40h  ; 07/12/2022
 19751 0000315C 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 19752                                  yesdirty5:
 19753                                  	;;add	di,16 ; MSDOS 3.3
 19754                                  	;add	di,20 ; MSDOS 6.0
 19755 00003161 83C714                  	ADD	DI,BUFINSIZ	; Point at buffer
 19756 00003164 B82E20                  	MOV	AX,202EH	; ". "
 19757 00003167 8B16[C205]              	MOV	DX,[DIRSTART]	; Point at itself
 19758 0000316B E81A18                  	call	SETDOTENT
 19759 0000316E B82E2E                  	MOV	AX,2E2EH	; ".."
 19760 00003171 5A                      	POP	DX		; Parent
 19761 00003172 E81318                  	call	SETDOTENT
 19762 00003175 C42E[8A05]              	LES	BP,[THISDPB]
 19763                                  	; 22/09/2023
 19764                                  	;;mov	byte [ALLOWED],18h
 19765                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 19766 00003179 5A                      	POP	DX		; Entry sector
 19767                                  	; MSDOS 6.0
 19768 0000317A 8F06[0706]              	POP	word [HIGH_SECTOR] ;F.C. >32mb
 19769                                  
 19770                                  	;XOR	AL,AL ; *	; Pre read
 19771                                  	;call	GETBUFFR
 19772                                  	; 22/09/2023
 19773 0000317E E8E827                  	call	GETBUFFER ; *	; Pre read
 19774 00003181 725B                    	JC	short NODEEXISTSP
 19775 00003183 8B16[C205]              	MOV	DX,[DIRSTART]
 19776 00003187 C53E[E205]              	LDS	DI,[CURBUF]
 19777                                  	;or	byte [di+5],4
 19778 0000318B 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 19779 0000318F 5E                      	POP	SI		; dir_first pointer
 19780 00003190 01FE                    	ADD	SI,DI
 19781 00003192 8914                    	MOV	[SI],DX
 19782 00003194 31D2                    	XOR	DX,DX
 19783 00003196 895402                  	MOV	[SI+2],DX	; Zero size
 19784 00003199 895404                  	MOV	[SI+4],DX
 19785                                  DIRUP:
 19786                                  	; MSDOS 6.0
 19787 0000319C F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 19788                                  	;			 ;LB. if already dirty 		   ;AN000;
 19789 000031A0 7507                    	JNZ	short yesdirty6	 ;LB.  don't increment dirty count ;AN000;
 19790 000031A2 E8CD29                  	call	INC_DIRTY_COUNT  ;LB.				   ;AN000;
 19791                                  	
 19792                                  	; MSDOS 3.3 & MSDOS 6.0
 19793                                  	;or	byte [di+5],40h
 19794 000031A5 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty	; Dirty buffer
 19795                                  yesdirty6:
 19796 000031A9 16                      	push	ss
 19797 000031AA 1F                      	pop	ds
 19798 000031AB 268A4600                	mov	al,[es:bp]
 19799                                  	;MOV	AL,[ES:BP+DPB.DRIVE]  ; mov al,[es:bp+0]
 19800 000031AF E8BB28                  	call	FLUSHBUF
 19801                                  	;mov	ax,5
 19802 000031B2 B80500                  	MOV	AX,error_access_denied
 19803                                  	;call	LCritDisk
 19804                                  	;retn
 19805                                  	; 18/12/2022
 19806 000031B5 E974E1                  	jmp	LCritDisk
 19807                                  
 19808                                  NODEEXISTSPOPDEL:
 19809 000031B8 5A                      	POP	DX		; Parent
 19810 000031B9 5A                      	POP	DX		; Entry sector
 19811                                  	; MSDOS 6.0 
 19812 000031BA 8F06[0706]              	POP	word [HIGH_SECTOR] ; F.C. >32mb
 19813 000031BE C42E[8A05]              	LES	BP,[THISDPB]
 19814                                  	; 22/09/2023
 19815                                  	;;mov	byte [ALLOWED],18h
 19816                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 19817                                  	;XOR	AL,AL ; *	; Pre read
 19818                                  	;call	GETBUFFR
 19819                                  	; 22/09/2023
 19820 000031C2 E8A427                  	call	GETBUFFER ; *	; Pre read
 19821 000031C5 7217                    	JC	short NODEEXISTSP
 19822 000031C7 C53E[E205]              	LDS	DI,[CURBUF]
 19823                                  	;or	byte [di+5],4
 19824 000031CB 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 19825 000031CF 5E                      	POP	SI		; dir_first pointer
 19826 000031D0 01FE                    	ADD	SI,DI
 19827                                  	;sub	si,1Ah ; 26
 19828 000031D2 83EE1A                  	SUB	SI,dir_entry.dir_first	;Point back to start of dir entry
 19829 000031D5 C604E5                  	MOV	BYTE [SI],0E5H	; Free the entry
 19830 000031D8 E8C1FF                  	CALL	DIRUP		; Error doesn't matter since erroring anyway
 19831                                  NODEEXISTS:
 19832 000031DB E91EFF                  	JMP	NODEACCERRJ ; 10/08/2018
 19833                                  
 19834                                  NODEEXISTSP:
 19835 000031DE 5E                      	POP	SI		; Clean stack
 19836 000031DF EBFA                    	JMP	short NODEEXISTS
 19837                                  
 19838                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19839                                  
 19840                                  ;BREAK <DOS_ChDir -- Verify a directory>
 19841                                  ;----------------------------------------------------------------------------
 19842                                  ;
 19843                                  ; Procedure Name : DOS_ChDir
 19844                                  ;
 19845                                  ; Inputs:
 19846                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 19847                                  ;		terminated)
 19848                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 19849                                  ;		( = -1 if current dir not involved, else
 19850                                  ;		 Points to first char after last "/" of current dir part)
 19851                                  ;	[THISCDS] Points to CDS being used May not be NUL
 19852                                  ; Function:
 19853                                  ;	Validate the path for potential new current directory
 19854                                  ; Returns:
 19855                                  ;	NOTE:
 19856                                  ;	    [SATTRIB] is modified by this call
 19857                                  ;	Carry Clear
 19858                                  ;	    CX is cluster number of the DIR, LOCAL CDS ONLY
 19859                                  ;		Caller must NOT set ID fields on a NET CDS.
 19860                                  ;	Carry Set
 19861                                  ;	    AX is error code
 19862                                  ;		error_path_not_found
 19863                                  ;			Bad path
 19864                                  ;		error_access_denied
 19865                                  ;			device or file name
 19866                                  ; DS preserved, Others destroyed
 19867                                  ;----------------------------------------------------------------------------
 19868                                  
 19869                                  ;hkn; called from path.asm and dir2.asm. DS already set up.
 19870                                  
 19871                                  ; 18/05/2019 - Retro DOS v4.0
 19872                                  ; DOSCODE:70DAh (MSDOS 6.21, MSDOS.SYS)
 19873                                  
 19874                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19875                                  ; DOSCODE:70C6h (MSDOS 5.0, MSDOS.SYS)
 19876                                  
 19877                                  DOS_CHDIR:
 19878 000031E1 E869E0                  	call	TestNet
 19879 000031E4 7306                    	JNC	short LOCAL_CHDIR
 19880                                  
 19881                                  ;IF NOT Installed
 19882                                  ;	transfer NET_CHDIR
 19883                                  ;ELSE
 19884                                  	;mov	ax,1105h
 19885 000031E6 B80511                  	MOV	AX,(MultNET<<8)|5
 19886 000031E9 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CHDIR
 19887                                  			; SS = DOS CS
 19888                                  			; SDA first filename pointer -> fully-qualified directory name
 19889                                  			; SDA CDS pointer -> current directory
 19890                                  			; Return: CF set on error, AX = DOS error code
 19891                                  			; CF clear if successful
 19892 000031EB C3                      	retn
 19893                                  ;ENDIF
 19894                                  
 19895                                  LOCAL_CHDIR:
 19896 000031EC E822E1                  	call	ECritDisk
 19897                                  	; MSDOS 6.0
 19898                                  	;;test	word [es:di+43h],2000h
 19899                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice ;PTM.
 19900                                  	; 17/12/2022
 19901                                  	;test	byte [es:di+44h],20h
 19902 000031EF 26F6454420              	test	byte [ES:DI+curdir.flags+1],(curdir_splice>>8) ;PTM.
 19903 000031F4 7406                    	JZ	short nojoin		   ;PTM.
 19904                                  	;mov	word [es:di+49h], 0FFFFh
 19905 000031F6 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],0FFFFH ;PTM.
 19906                                  nojoin:
 19907                                  	; MSDOS 3.3 & MSDOS 6.0
 19908 000031FC C606[4C03]00            	MOV	byte [NoSetDir],0 ; FALSE
 19909                                  	;mov	byte [SATTRIB],16h
 19910 00003201 C606[6D05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 19911                                  				; Dir calls can find these
 19912                                  ; DOS 3.3  6/24/86 FastOpen
 19913 00003206 800E[3A0D]01            	OR	byte [FastOpenFlg],FastOpen_Set	; set fastopen flag
 19914 0000320B E8320D                  	call	GETPATH
 19915 0000320E 9C                      	PUSHF						;AN000;
 19916 0000320F 8026[3A0D]80            	AND	byte [FastOpenFlg],Fast_yes ; clear it all ;AC000;
 19917 00003214 9D                      	POPF						;AN000;
 19918                                  ; DOS 3.3  6/24/86 FastOpen
 19919                                  
 19920                                  	; MSDOS 3.3
 19921                                  	;mov	byte [FastOpenFlg],0
 19922                                  	
 19923                                  	;mov	ax,3
 19924 00003215 B80300                  	MOV	AX,error_path_not_found
 19925 00003218 7207                    	JC	short ChDirDone
 19926 0000321A 753A                    	JNZ	short NOTDIRPATH	; Path not a DIR
 19927 0000321C 8B0E[C205]              	MOV	CX,[DIRSTART]		; Get cluster number
 19928 00003220 F8                      	CLC
 19929                                  ChDirDone:
 19930                                  	;call	LCritDisk
 19931                                  	;retn
 19932                                  	; 18/12/2022
 19933 00003221 E908E1                  	jmp	LCritDisk
 19934                                  
 19935                                  ;BREAK <DOS_RmDir -- Remove a directory>
 19936                                  ;----------------------------------------------------------------------------
 19937                                  ;
 19938                                  ; Procedure Name : DOS_RmDir
 19939                                  ;
 19940                                  ; Inputs:
 19941                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 19942                                  ;		terminated)
 19943                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 19944                                  ;		( = -1 if current dir not involved, else
 19945                                  ;		 Points to first char after last "/" of current dir part)
 19946                                  ;	[THISCDS] Points to CDS being used
 19947                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 19948                                  ; Function:
 19949                                  ;	Remove a directory
 19950                                  ;	NOTE: Attempt to remove current directory must be detected by caller
 19951                                  ; Returns:
 19952                                  ;	NOTE:
 19953                                  ;	    [SATTRIB] is modified by this call
 19954                                  ;	Carry Clear
 19955                                  ;		No error
 19956                                  ;	Carry Set
 19957                                  ;	    AX is error code
 19958                                  ;		error_path_not_found
 19959                                  ;			Bad path (not in curr dir part if present)
 19960                                  ;		error_bad_curr_dir
 19961                                  ;			Bad path in current directory part of path
 19962                                  ;		error_access_denied
 19963                                  ;			device or file name, root directory
 19964                                  ;			Bad directory ('.' '..' messed up)
 19965                                  ; DS preserved, Others destroyed
 19966                                  ;----------------------------------------------------------------------------
 19967                                  
 19968                                  ;hkn; called from path.asm. DS already set up.
 19969                                  
 19970                                  ; 18/05/2019 - Retro DOS v4.0
 19971                                  ; DOSCODE:711Fh (MSDOS 6.21, MSDOS.SYS)
 19972                                  
 19973                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19974                                  ; DOSCODE:710Bh (MSDOS 5.0, MSDOS.SYS)
 19975                                  
 19976                                  DOS_RMDIR:
 19977 00003224 E826E0                  	call	TestNet
 19978 00003227 7306                    	JNC	short LOCAL_RMDIR
 19979                                  
 19980                                  ;IF NOT Installed
 19981                                  ;	transfer NET_RMDIR
 19982                                  ;ELSE
 19983                                  	;mov	ax,1101h
 19984 00003229 B80111                  	MOV	AX,(MultNET<<8)|1
 19985 0000322C CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
 19986                                  			; SS = DOS CS
 19987                                  			; SDA first filename pointer -> fully-qualified directory name
 19988                                  			; SDA CDS pointer -> current directory
 19989                                  			; Return: CF set on error, AX = DOS error code
 19990                                  			; CF clear if successful
 19991 0000322E C3                      	retn
 19992                                  ;ENDIF
 19993                                  
 19994                                  LOCAL_RMDIR:
 19995 0000322F E8DFE0                  	call	ECritDisk
 19996 00003232 C606[4C03]00            	MOV	byte [NoSetDir],0
 19997                                  	;mov	byte [SATTRIB],16h
 19998 00003237 C606[6D05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 19999                                  					; Dir calls can find these
 20000 0000323C E8010D                  	call	GETPATH
 20001 0000323F 720C                    	JC	short NOPATH		; Path not found
 20002 00003241 7513                    	JNZ	short NOTDIRPATH	; Path not a DIR
 20003 00003243 8B3E[C205]              	MOV	DI,[DIRSTART]
 20004 00003247 09FF                    	OR	DI,DI			; Root ?
 20005 00003249 750E                    	JNZ	short rmdir_get_buf	; No
 20006 0000324B EB09                    	JMP	SHORT NOTDIRPATH
 20007                                  
 20008                                  NOPATH:
 20009                                  	;mov	ax,3
 20010 0000324D B80300                  	MOV	AX,error_path_not_found
 20011 00003250 E9ACFE                  	JMP	_BadRet
 20012                                  
 20013                                  NOTDIRPATHPOP:
 20014 00003253 58                      	POP	AX  ; MSDOS 6.0		;F.C. >32mb
 20015 00003254 58                      	POP	AX
 20016                                  NOTDIRPATHPOP2:
 20017 00003255 58                      	POP	AX
 20018                                  NOTDIRPATH:
 20019 00003256 E9A3FE                  	JMP	NODEACCERRJ
 20020                                  
 20021                                  rmdir_get_buf:
 20022 00003259 C53E[E205]              	LDS	DI,[CURBUF]
 20023 0000325D 29FB                    	SUB	BX,DI		; Compute true offset
 20024 0000325F 53                      	PUSH	BX		; Save entry pointer
 20025                                  	
 20026                                  	; MSDOS 6.0
 20027                                  	;push	word [di+8]
 20028 00003260 FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2] ;F.C. >32mb
 20029                                  	
 20030                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20031                                  	;push	word [di+6]
 20032 00003263 FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Save sector number
 20033                                  
 20034                                  ;hkn; SS is DOSDATA
 20035                                  	;context DS
 20036 00003266 16                      	push	ss
 20037 00003267 1F                      	pop	ds
 20038                                  	;context ES
 20039 00003268 16                      	push	ss
 20040 00003269 07                      	pop	es
 20041                                  
 20042                                  ;hkn; NAME1 is in DOSDATA
 20043 0000326A BF[4B05]                	MOV	DI,NAME1
 20044 0000326D B03F                    	MOV	AL,'?'
 20045 0000326F B90B00                  	MOV	CX,11
 20046 00003272 F3AA                    	REP	STOSB
 20047 00003274 30C0                    	XOR	AL,AL
 20048 00003276 AA                      	STOSB				; Nul terminate it
 20049 00003277 E8590F                  	call	STARTSRCH		; Set search
 20050 0000327A E8340C                  	call	GETENTRY		; Get start of directory
 20051 0000327D 72D4                    	JC	short NOTDIRPATHPOP	; Screw up
 20052 0000327F 8E1E[E405]              	MOV	DS,[CURBUF+2]
 20053 00003283 89DE                    	MOV	SI,BX
 20054 00003285 AD                      	LODSW
 20055                                  	;CMP	AX,(' ' SHL 8) OR '.'   ; First entry '.'?
 20056 00003286 3D2E20                  	cmp	ax,202Eh ; ". "
 20057 00003289 75C8                    	JNZ	short NOTDIRPATHPOP	; Nope
 20058                                  	;add	si,30
 20059 0000328B 83C61E                  	ADD	SI,dir_entry.size-2 ; Next entry
 20060 0000328E AD                      	LODSW
 20061                                  	;CMP	AX,('.' SHL 8) OR '.'   ; Second entry '..'?
 20062                                  	;cmp	ax, '..'
 20063 0000328F 3D2E2E                  	cmp	ax,2E2Eh
 20064 00003292 75BF                    	JNZ	short NOTDIRPATHPOP	; Nope
 20065                                  
 20066                                  ;hkn; SS is DOSDATA
 20067                                  	;context DS
 20068 00003294 16                      	push	ss
 20069 00003295 1F                      	pop	ds
 20070 00003296 C706[4803]0200          	MOV	word [LASTENT],2	; Skip . and ..
 20071 0000329C E8120C                  	call	GETENTRY		; Get next entry
 20072 0000329F 72B2                    	JC	short NOTDIRPATHPOP	; Screw up
 20073                                  	;mov	byte [ATTRIB],16h
 20074 000032A1 C606[6B05]16            	MOV	byte [ATTRIB],attr_directory+attr_hidden+attr_system
 20075 000032A6 E8100B                  	call	SRCH			; Do a search
 20076 000032A9 73A8                    	JNC	short NOTDIRPATHPOP	; Found another entry!
 20077 000032AB 803E[4A03]00            	CMP	byte [FAILERR],0
 20078 000032B0 75A1                    	JNZ	short NOTDIRPATHPOP	; Failure of search due to I 24 FAIL
 20079 000032B2 C42E[8A05]              	LES	BP,[THISDPB]
 20080 000032B6 8B1E[C205]              	MOV	BX,[DIRSTART]
 20081 000032BA E8231C                  	call	RELEASE 		; Release data in sub dir
 20082 000032BD 7294                    	JC	short NOTDIRPATHPOP	; Screw up
 20083 000032BF 5A                      	POP	DX			; Sector # of entry
 20084 000032C0 8F06[0706]              	POP	word [HIGH_SECTOR] ; MSDOS 6.0	; F.C. >32mb
 20085                                  	; 22/09/2023
 20086                                  	;;mov	byte [ALLOWED],18h
 20087                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 20088                                  	;XOR	AL,AL ; *		; Pre read
 20089                                  	;call	GETBUFFR		; Get sector back
 20090 000032C4 E8A226                  	call	GETBUFFER ; *		; Pre Read
 20091 000032C7 728C                    	JC	short NOTDIRPATHPOP2	; Screw up
 20092 000032C9 C53E[E205]              	LDS	DI,[CURBUF]
 20093                                  	;or	byte [di+5],4
 20094 000032CD 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 20095 000032D1 5B                      	POP	BX			; Pointer to start of entry
 20096 000032D2 01FB                    	ADD	BX,DI			; Corrected
 20097 000032D4 C607E5                  	MOV	BYTE [BX],0E5H		; Free the entry
 20098                                  
 20099                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 20100 000032D7 1E                      	PUSH	DS
 20101                                  
 20102                                  ;hkn; SS is DOSDATA
 20103                                  	;context DS
 20104 000032D8 16                      	push	ss
 20105 000032D9 1F                      	pop	ds
 20106                                  
 20107                                  	; MSDOS 6.0
 20108 000032DA E80EF4                  	call	FastOpen_Delete 	; call fastopen to delete an entry
 20109                                  
 20110                                  ;	; MSDOS 3.3
 20111                                  ;_FastOpen_Delete:
 20112                                  ;	push	ax
 20113                                  ;	mov	si,[WFP_START]
 20114                                  ;	mov	bx,FastTable
 20115                                  ;	;mov	al,3  ; FONC_delete
 20116                                  ;	mov	al,FONC_delete
 20117                                  ;	call	far [BX+2]  ; FastTable+2
 20118                                  ;	pop	ax
 20119                                  
 20120 000032DD 1F                      	POP	DS
 20121                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 20122                                  
 20123 000032DE E9BBFE                  	JMP	DIRUP			; In MKDIR, dirty buffer and flush
 20124                                  
 20125                                  ;============================================================================
 20126                                  ; DISK.ASM, MSDOS 6.0, 1991
 20127                                  ;============================================================================
 20128                                  ; 23/07/2018 - Retro DOS v3.0 
 20129                                  ; 04/05/2019 - Retro DOS v4.0
 20130                                  
 20131                                  ;	TITLE	DISK - Disk utility routines
 20132                                  ;	NAME	Disk
 20133                                  
 20134                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 20135                                  ;
 20136                                  ;	SWAPCON
 20137                                  ;	SWAPBACK
 20138                                  ;	DOS_READ
 20139                                  ;	DOS_WRITE
 20140                                  ;	get_io_sft
 20141                                  ;	DirRead
 20142                                  ;	FIRSTCLUSTER
 20143                                  ;	SET_BUF_AS_DIR
 20144                                  ;	FATSecRd
 20145                                  ;	DREAD
 20146                                  ;	CHECK_WRITE_LOCK
 20147                                  ;	CHECK_READ_LOCK
 20148                                  ;
 20149                                  ;	Revision history:
 20150                                  ;
 20151                                  ;		A000   version 4.00  Jan. 1988
 20152                                  ;
 20153                                  ;----------------------------------------------------------------------------
 20154                                  ;
 20155                                  ; M065 : B#5276. On raw read/write of a block of characters if a critical
 20156                                  ;		error happens, DOS retries the entire block assuming that
 20157                                  ;		zero characters were transferred. Modified the code to take
 20158                                  ;		into account the number of characters transfered before
 20159                                  ;		retrying the operation.
 20160                                  ;
 20161                                  ;----------------------------------------------------------------------------
 20162                                  ;
 20163                                  
 20164                                  ;Installed = TRUE
 20165                                  
 20166                                  ;Break	<SwapCon, Swap Back - Old-style I/O to files>
 20167                                  
 20168                                  ; **** Drivers for file input from devices ****
 20169                                  ;----------------------------------------------------------------------------
 20170                                  ;   Indicate that there is no more I/O occurring through another SFT outside
 20171                                  ;   of handles 0 and 1
 20172                                  ;
 20173                                  ;   Inputs:	DS is DOSDATA
 20174                                  ;   Outputs:	CONSWAP is set to false.
 20175                                  ;   Registers modified: none
 20176                                  ;----------------------------------------------------------------------------
 20177                                  
 20178                                  ; IBMDOS.COM (MSDOS 3.3) - Offset 3CF8h
 20179                                  
 20180                                  ; DOSCODE:71E3h (MSDOS 6.21, MSDOS.SYS)
 20181                                  ; 04/05/2019 - Retro DOS v4.0
 20182                                  
 20183                                  ; DOSCODE:71CFh (MSDOS 5.0, MSDOS.SYS)
 20184                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20185                                  
 20186                                  SWAPBACK:
 20187 000032E1 C606[5703]00            	MOV	BYTE [CONSWAP],0	; signal no conswaps
 20188 000032E6 C3                      	retn
 20189                                  
 20190                                  ;----------------------------------------------------------------------------
 20191                                  ;
 20192                                  ; Procedure Name : SWAPCON
 20193                                  ;
 20194                                  ;   Copy ThisSFT to CONSFT for use by the 1-12 primitives.
 20195                                  ;
 20196                                  ;   Inputs:	ThisSFT as the sft of the desired file
 20197                                  ;		DS is DOSDATA
 20198                                  ;   Outputs:	CONSWAP is set.  CONSFT = ThisSFT.
 20199                                  ;   Registers modified: none
 20200                                  ;--------------------------------------------------------------------------
 20201                                  
 20202                                  SWAPCON:
 20203                                  	; MSDOS 3.3
 20204                                  	;push	es
 20205                                  	;push	di
 20206                                  	;mov	byte [CONSWAP],1
 20207                                  	;les	di,[THISSFT]
 20208                                  	;mov	word [CONSFT],di
 20209                                  	;mov	word [CONSFT+2],es
 20210                                  	;pop	di
 20211                                  	;pop	es
 20212                                  	;retn
 20213                                  
 20214                                  	; MSDOS 6.0
 20215 000032E7 C606[5703]01            	mov	byte [CONSWAP],1	; ConSwap = TRUE
 20216 000032EC 50                      	push	ax
 20217 000032ED A1[9E05]                	mov	ax,[THISSFT]
 20218 000032F0 A3[E605]                	mov	[CONSFT],ax
 20219 000032F3 A1[A005]                	mov	ax,[THISSFT+2]
 20220 000032F6 A3[E805]                	mov	[CONSFT+2],ax
 20221 000032F9 58                      	pop	ax
 20222 000032FA C3                      	retn
 20223                                  
 20224                                  ; DOSCODE:71FDh (MSDOS 6.21, MSDOS.SYS)
 20225                                  ; 04/05/2019 - Retro DOS v4.0
 20226                                  
 20227                                  ;Break	<DOS_READ -- MAIN READ ROUTINE AND DEVICE IN ROUTINES>
 20228                                  ;-----------------------------------------------------------------------------
 20229                                  ;
 20230                                  ; Inputs:
 20231                                  ;	ThisSFT set to the SFT for the file being used
 20232                                  ;	[DMAADD] contains transfer address
 20233                                  ;	CX = No. of bytes to read
 20234                                  ;	DS = DOSDATA
 20235                                  ; Function:
 20236                                  ;	Perform read operation
 20237                                  ; Outputs:
 20238                                  ;    Carry clear
 20239                                  ;	SFT Position and cluster pointers updated
 20240                                  ;	CX = No. of bytes read
 20241                                  ;	ES:DI point to SFT
 20242                                  ;    Carry set
 20243                                  ;	AX is error code
 20244                                  ;	CX = 0
 20245                                  ;	ES:DI point to SFT
 20246                                  ; DS preserved, all other registers destroyed
 20247                                  ;
 20248                                  ;-----------------------------------------------------------------------------
 20249                                  
 20250                                  ;hkn; called from fcbio.asm, handle.asm and dev.asm. DS is be set up.
 20251                                  
 20252                                  ; DOSCODE:71E9h (MSDOS 5.0, MSDOS.SYS)
 20253                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20254                                  
 20255                                  DOS_READ:
 20256 000032FB C43E[9E05]              	LES	DI,[THISSFT]
 20257                                  
 20258                                  ; Verify that the sft has been opened in a mode that allows reading.
 20259                                  
 20260                                  	;mov	al,[es:di+2]
 20261 000032FF 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 20262                                  	;and	al,0Fh
 20263 00003303 240F                    	AND	AL,access_mask
 20264                                  	;cmp	al,1
 20265 00003305 3C01                    	CMP	AL,open_for_write
 20266 00003307 7503                    	JNE	short READ_NO_MODE	; Is read or both
 20267 00003309 E90306                  	jmp	SET_ACC_ERR
 20268                                  
 20269                                  READ_NO_MODE:
 20270 0000330C E8E104                  	call	SETUP
 20271 0000330F E30B                    	JCXZ	NoIORet 		; no bytes to read - fast return
 20272 00003311 E852DF                  	call	IsSFTNet
 20273 00003314 7408                    	JZ	short LOCAL_READ
 20274                                  
 20275                                  ;IF NOT Installed
 20276                                  ;	transfer NET_READ
 20277                                  ;ELSE
 20278                                  	;mov	ax,1108h
 20279 00003316 B80811                  	MOV	AX,(MultNET<<8)|8
 20280 00003319 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE
 20281                                  			; ES:DI -> SFT
 20282                                  			; SFT DPB field -> DPB of drive containing file
 20283                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 20284                                  			; Return: CF set on error, CX = bytes read
 20285 0000331B C3                      	retn
 20286                                  ;ENDIF
 20287                                  
 20288                                  ; The user ended up requesting 0 bytes of input. We do nothing for this case
 20289                                  ; except return immediately.
 20290                                  
 20291                                  NoIORet:
 20292 0000331C F8                      	CLC
 20293 0000331D C3                      	retn
 20294                                  
 20295                                  LOCAL_READ:
 20296                                  	;test	word [es:di+5],80h
 20297                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device  ; Check for named device I/O
 20298 0000331E 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 02/06/2019
 20299 00003323 750E                    	JNZ	short READDEV
 20300                                  
 20301                                  	;mov	byte [EXTERR_LOCUS],2
 20302 00003325 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 20303 0000332A E8E4DF                  	call	ECritDisk
 20304 0000332D E89B05                  	call	DISKREAD
 20305                                  
 20306                                  critexit:
 20307                                  	;call	LCritDisk
 20308                                  	;retn
 20309                                  	; 16/12/2022
 20310 00003330 E9F9DF                  	jmp	LCritDisk
 20311                                  
 20312                                  ; We are reading from a device. Examine the status of the device to see if we
 20313                                  ; can short-circuit the I/O. If the device in the EOF state or if it is the
 20314                                  ; null device, we can safely indicate no transfer.
 20315                                  
 20316                                  READDEV:
 20317                                  	;mov	byte [EXTERR_LOCUS],4
 20318 00003333 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 20319                                  	;mov	bl,[es:di+5]
 20320 00003338 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 20321 0000333C C43E[2C03]              	LES	DI,[DMAADD]
 20322                                  	;test	bl,40h
 20323 00003340 F6C340                  	test	BL,devid_device_EOF	; End of file?
 20324 00003343 7407                    	JZ	short ENDRDDEVJ3
 20325                                  	;test	bl,4
 20326 00003345 F6C304                  	test	BL,devid_device_null	; NUL device?
 20327 00003348 7405                    	JZ	short TESTRAW 		; NO
 20328 0000334A 30C0                    	XOR	AL,AL			; Indicate EOF by setting zero
 20329                                  ENDRDDEVJ3:
 20330                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 20331                                  	;JMP	short ENDRDDEVJ2
 20332                                  	; 16/12/2022
 20333 0000334C E96701                  	jmp	ENDRDDEV ; 04/05/2019
 20334                                  
 20335                                  ; We need to hit the device. Figure out if we do a raw read or we do the
 20336                                  ; bizarre std_con_string_input.
 20337                                  
 20338                                  TESTRAW:
 20339                                  	;test	bl,20h
 20340 0000334F F6C320                  	test	BL,devid_device_raw	; Raw mode?
 20341 00003352 7508                    	JNZ	short DVRDRAW 		; Yes, let the device do all local editing
 20342                                  	;test	bl,1
 20343 00003354 F6C301                  	test	BL,devid_device_con_in	; Is it console device?
 20344 00003357 7461                    	JZ	short NOTRDCON
 20345 00003359 E98F01                  	JMP	READCON
 20346                                  
 20347                                  DVRDRAW:
 20348 0000335C 06                      	PUSH	ES
 20349 0000335D 1F                      	POP	DS			; Xaddr to DS:DI
 20350                                  
 20351                                  	; 04/05/2019 - Retro DOS v4.0
 20352                                  
 20353                                  	; MSDOS 6.0
 20354                                  ;SR;
 20355                                  ;Check for win386 presence -- if present, do polled read of characters
 20356                                  
 20357 0000335E 36F606[3010]01          	test	byte [ss:IsWin386],1 ; 19/05/2019
 20358 00003364 7408                    	jz	short ReadRawRetry	;not present
 20359 00003366 F6C301                  	test	bl,devid_device_con_in	;is it console device
 20360 00003369 7403                    	jz	short ReadRawRetry	;no, do normal read
 20361 0000336B E9BA00                  	jmp	do_polling		;yes, do win386 polling loop
 20362                                  
 20363                                  ReadRawRetry:
 20364 0000336E 89FB                    	MOV	BX,DI			; DS:BX transfer addr
 20365 00003370 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 20366 00003372 89C2                    	MOV	DX,AX			; Start at 0
 20367 00003374 E89013                  	call	SETREAD
 20368 00003377 1E                      	PUSH	DS			; Save Seg part of Xaddr
 20369                                  
 20370                                  ;hkn; SS override
 20371 00003378 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 20372 0000337D E80E13                  	call	DEVIOCALL
 20373 00003380 89FA                    	MOV	DX,DI			; DS:DX is preserved by INT 24
 20374 00003382 B486                    	MOV	AH,86H			; Read error
 20375                                  
 20376                                  ;hkn; SS override
 20377 00003384 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 20378                                  	; MSDOS 3.3
 20379                                  	;test	di,8000h
 20380                                  	;jz	short CRDROK
 20381                                  	; MSDOS 6.0
 20382 00003389 09FF                    	or	di,di
 20383 0000338B 7923                    	jns	short CRDROK		; no errors
 20384                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20385 0000338D E8631F                  	call	CHARHARD
 20386 00003390 89D7                    	MOV	DI,DX			; DS:DI is Xaddr
 20387                                  
 20388                                  	; 04/05/2019
 20389                                  
 20390                                  	; MSDOS 6.0
 20391 00003392 36033E[6C03]            	add	di,[ss:CALLSCNT]	; update ptr and count to reflect the	M065
 20392 00003397 362B0E[6C03]            	sub	cx,[ss:CALLSCNT]	; number of chars xferred		M065
 20393                                  
 20394                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20395 0000339C 08C0                    	OR	AL,AL
 20396 0000339E 7410                    	JZ	short CRDROK		; Ignore
 20397 000033A0 3C03                    	CMP	AL,3
 20398 000033A2 7403                    	JZ	short CRDFERR 		; fail.
 20399 000033A4 1F                      	POP	DS			; Recover saved seg part of Xaddr
 20400 000033A5 EBC7                    	JMP	short ReadRawRetry	; Retry
 20401                                  
 20402                                  ; We have encountered a device-driver error. We have informed the user of it
 20403                                  ; and he has said for us to fail the system call.
 20404                                  
 20405                                  CRDFERR:
 20406 000033A7 5F                      	POP	DI			; Clean stack
 20407                                  DEVIOFERR:
 20408                                  
 20409                                  ;hkn; SS override
 20410 000033A8 36C43E[9E05]            	LES	DI,[SS:THISSFT]
 20411 000033AD E95D05                  	jmp	SET_ACC_ERR_DS
 20412                                  
 20413                                  CRDROK:
 20414 000033B0 5F                      	POP	DI			; Chuck saved seg of Xaddr
 20415 000033B1 89D7                    	MOV	DI,DX
 20416                                  
 20417                                  ;hkn; SS override
 20418 000033B3 36033E[6C03]            	ADD	DI,[ss:CALLSCNT]	; Amount transferred
 20419                                  	;JMP	SHORT ENDRDDEVJ3
 20420                                  	; 16/12/2022
 20421 000033B8 EB6B                    	jmp	short ENDRDDEVJ2
 20422                                  
 20423                                  ; We are going to do a cooked read on some character device. There is a
 20424                                  ; problem here, what does the data look like? Is it a terminal device, line
 20425                                  ; CR line CR line CR, or is it file data, line CR LF line CR LF? Does it have
 20426                                  ; a ^Z at the end which is data, or is the ^Z not data?  In any event we're
 20427                                  ; going to do this: Read in pieces up to CR (CRs included in data) or ^z (^z
 20428                                  ; included in data). this "simulates" the way con works in cooked mode
 20429                                  ; reading one line at a time. With file data, however, the lines will look
 20430                                  ; like, LF line CR. This is a little weird.
 20431                                  
 20432                                  NOTRDCON:
 20433 000033BA 8CC0                    	MOV	AX,ES
 20434 000033BC 8ED8                    	MOV	DS,AX
 20435 000033BE 89FB                    	MOV	BX,DI
 20436 000033C0 31D2                    	XOR	DX,DX
 20437 000033C2 89D0                    	MOV	AX,DX
 20438 000033C4 51                      	PUSH	CX
 20439 000033C5 B90100                  	MOV	CX,1
 20440 000033C8 E83C13                  	call	SETREAD
 20441 000033CB 59                      	POP	CX
 20442                                  
 20443                                  ;hkn; SS override
 20444 000033CC 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 20445                                  	;lds	si,[si+7]
 20446 000033D1 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 20447                                  DVRDLP:
 20448 000033D4 E8FD1C                  	call	DSKSTATCHK
 20449 000033D7 E8B712                  	call	DEVIOCALL2
 20450 000033DA 57                      	PUSH	DI		; Save "count" done
 20451 000033DB B486                    	MOV	AH,86H
 20452                                  
 20453                                  ;hkn; SS override
 20454 000033DD 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 20455                                  	
 20456                                  	; MSDOS 3.3
 20457                                  	;test	di,8000h
 20458                                  	;jz	short CRDOK
 20459                                  	; MSDOS 6.0
 20460 000033E2 09FF                    	or	di,di
 20461 000033E4 7917                    	jns	short CRDOK
 20462                                  	
 20463 000033E6 E80A1F                  	call	CHARHARD
 20464 000033E9 5F                      	POP	DI
 20465                                  
 20466                                  ;hkn; SS override
 20467 000033EA 36C706[6C03]0100        	MOV	word [SS:CALLSCNT],1
 20468 000033F1 3C01                    	CMP	AL,1
 20469 000033F3 74DF                    	JZ	short DVRDLP		;Retry
 20470 000033F5 3C03                    	CMP	AL,3
 20471 000033F7 74AF                    	JZ	short DEVIOFERR		; FAIL
 20472 000033F9 30C0                    	XOR	AL,AL			; Ignore, Pick some random character
 20473 000033FB EB12                    	JMP	SHORT DVRDIGN
 20474                                  
 20475                                  CRDOK:
 20476 000033FD 5F                      	POP	DI
 20477                                  
 20478                                  ;hkn; SS override
 20479 000033FE 36833E[6C03]01          	CMP	word [SS:CALLSCNT],1
 20480                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 20481 00003404 751F                    	JNZ	short ENDRDDEVJ2
 20482                                  	; 16/12/2022
 20483                                  	;jnz	short ENDRDDEV ; 24/07/2019
 20484                                  
 20485 00003406 1E                      	PUSH	DS
 20486                                  
 20487                                  ;hkn; SS override
 20488 00003407 368E1E[6A03]            	MOV	DS,[SS:CALLXAD+2]
 20489 0000340C 8A05                    	MOV	AL,[DI]			; Get the character we just read
 20490 0000340E 1F                      	POP	DS
 20491                                  DVRDIGN:
 20492                                  
 20493                                  ;hkn; SS override
 20494 0000340F 36FF06[6803]            	INC	WORD [SS:CALLXAD]	; Next character
 20495 00003414 36C706[5D03]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 20496 0000341B 47                      	INC	DI			; Next character
 20497 0000341C 3C1A                    	CMP	AL,1Ah			; ^Z?
 20498                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 20499 0000341E 7405                    	JZ	short ENDRDDEVJ2	; Yes, done zero set (EOF)
 20500                                  	; 16/12/2022
 20501                                  	;jz	short ENDRDDEV ; 24/07/2019	
 20502 00003420 3C0D                    	CMP	AL,c_CR  ; 0Dh		; CR?
 20503 00003422 E0B0                    	LOOPNZ	DVRDLP			; Loop if no, else done
 20504 00003424 40                      	INC	AX			; Resets zero flag so NOT EOF, unless
 20505                                  					;  AX=FFFF which is not likely
 20506                                  ENDRDDEVJ2:
 20507                                  	; 16/12/2022
 20508                                  	;JMP	short ENDRDDEV		; changed short to long for win386
 20509                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20510 00003425 E98E00                  	jmp	ENDRDDEV
 20511                                  
 20512                                  	; 04/05/2019
 20513                                  
 20514                                  	; MSDOS 6.0
 20515                                  ;SR;
 20516                                  ;Polling code for raw read on CON when WIN386 is present
 20517                                  ;
 20518                                  ;At this point -- ds:di is transfer address
 20519                                  ;		  cx is count
 20520                                  
 20521                                  do_polling:
 20522 00003428 89FB                    	mov	bx,di			;ds:bx is Xfer address
 20523 0000342A 31C0                    	xor	ax,ax
 20524 0000342C 89C2                    	mov	dx,ax
 20525 0000342E E8D612                  	call	SETREAD			;prepare device packet
 20526                                  
 20527                                  do_io:
 20528                                  ;Change read to a NON-DESTRUCTIVE READ, NO WAIT
 20529                                  
 20530 00003431 26C6470205              	mov	byte [es:bx+2],DEVRDND ; 5 ;Change command code
 20531 00003436 1E                      	push	ds
 20532 00003437 36C536[9E05]            	lds	si,[ss:THISSFT]		;get device header
 20533 0000343C E84F12                  	call	DEVIOCALL		;call device driver
 20534 0000343F 1F                      	pop	ds
 20535                                  	
 20536                                  	;test	word [es:bx+3],8000h
 20537                                  	; 16/12/2022
 20538                                  	;test	byte [es:bx+4],80h
 20539 00003440 26F6470480              	test	byte [es:bx+SRHEAD.REQSTAT+1],STERR>>8 
 20540                                  	;test	word [es:bx+SRHEAD.REQSTAT],STERR ;check if error
 20541 00003445 7413                    	jz	short check_busy	;no
 20542                                  
 20543 00003447 1E                      	push	ds
 20544 00003448 89FA                    	mov	dx,di
 20545                                  	;invoke charhard		;invoke int 24h handler
 20546 0000344A E8A61E                  	call	CHARHARD
 20547 0000344D 89D7                    	mov	di,dx
 20548 0000344F 08C0                    	or	al,al
 20549 00003451 745D                    	jz	short pop_done_read	;ignore by user, assume read done
 20550 00003453 3C03                    	cmp	al,3
 20551 00003455 7448                    	jz	short devrderr		;user asked to fail
 20552 00003457 1F                      	pop	ds
 20553 00003458 EBD7                    	jmp	short do_io		;user asked to retry
 20554                                  
 20555                                  check_busy:
 20556                                  	;test	word [es:bx+3],200h
 20557                                  	; 16/12/2022
 20558 0000345A 26F6470402              	test	byte [es:bx+SRHEAD.REQSTAT+1],02h
 20559                                  	;test	word [es:bx+SRHEAD.REQSTAT],0200h ;see if busy bit set
 20560 0000345F 7547                    	jnz	short no_char		;yes, no character available
 20561                                  
 20562                                  ;Character is available. Read in 1 character at a time until all characters
 20563                                  ;are read in or no character is available
 20564                                  
 20565 00003461 26C6470204              	mov	byte [es:bx+2],DEVRD ; 4 ;command code is READ now
 20566 00003466 26C747120100            	mov	word [es:bx+18],1	;change count to 1 character
 20567 0000346C 1E                      	push	ds
 20568 0000346D 36C536[9E05]            	lds	si,[ss:THISSFT]
 20569 00003472 E81912                  	call	DEVIOCALL
 20570                                  
 20571 00003475 89FA                    	mov	dx,di
 20572 00003477 B486                    	mov	ah,86h
 20573                                  	;mov	di,[es:bx+3]
 20574 00003479 268B7F03                	mov	di,[es:bx+SRHEAD.REQSTAT] ;get returned status
 20575 0000347D F7C70080                	test	di,STERR ; 8000h	;was there an error during read?
 20576 00003481 7410                    	jz	short next_char		;no,read next character
 20577                                  
 20578                                  	;invoke	charhard		;invoke int 24h handler
 20579 00003483 E86D1E                  	call	CHARHARD
 20580 00003486 89D7                    	mov	di,dx			;restore di
 20581 00003488 08C0                    	or	al,al			;
 20582 0000348A 7424                    	jz	short pop_done_read	;ignore by user,assume read is done
 20583 0000348C 3C03                    	cmp	al,3
 20584 0000348E 740F                    	jz	short devrderr		;user issued a 'fail',indicate error
 20585 00003490 1F                      	pop	ds
 20586 00003491 EB9E                    	jmp	short do_io		;user issued a retry
 20587                                  
 20588                                  next_char:
 20589 00003493 1F                      	pop	ds
 20590 00003494 89D7                    	mov	di,dx
 20591 00003496 49                      	dec	cx			;decrement count
 20592 00003497 E318                    	jcxz	done_read		;all characters read in
 20593 00003499 26FF470E                	inc	word [es:bx+14]		;update transfer address
 20594 0000349D EB92                    	jmp	short do_io			;read next character in
 20595                                  
 20596                                  devrderr:
 20597 0000349F 5F                      	pop	di			;discard segment address
 20598 000034A0 36C43E[9E05]            	les	di,[ss:THISSFT]
 20599                                  	;transfer SET_ACC_ERR_DS	;indicate error
 20600 000034A5 E96504                  	jmp     SET_ACC_ERR_DS
 20601                                  
 20602                                  no_char:
 20603                                  ;Since no character is available, we let win386 switch the VM out
 20604                                  
 20605 000034A8 50                      	push	ax
 20606 000034A9 B484                    	mov	ah,84h	; Microsoft Networks - KEYBOARD BUSY LOOP
 20607 000034AB CD2A                    	int	2Ah			;indicate idle to WIN386
 20608                                  
 20609                                  ;When control returns from WIN386, we continue the raw read
 20610                                  
 20611 000034AD 58                      	pop	ax
 20612 000034AE EB81                    	jmp	do_io
 20613                                  
 20614                                  pop_done_read:
 20615 000034B0 1F                      	pop	ds
 20616                                  done_read:
 20617 000034B1 36033E[6C03]            	add	di,[ss:CALLSCNT] ; 19/05/2019
 20618                                  
 20619                                  	; 16/12/2022
 20620                                  
 20621                                  	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 20622                                  	;jmp	ENDRDDEV ; 04/05/2019
 20623                                  
 20624                                  	; 04/05/2019 - Retro DOS v4.0
 20625                                  ENDRDDEV:
 20626 000034B6 16                      	push	ss
 20627 000034B7 1F                      	pop	ds
 20628 000034B8 EB1F                    	jmp	short endrddev1
 20629                                  
 20630                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20631                                  	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 20632                                  
 20633                                  TRANBUF:
 20634 000034BA AC                      	LODSB
 20635 000034BB AA                      	STOSB
 20636 000034BC 3C0D                    	CMP	AL,c_CR ; 0Dh	; Check for carriage return
 20637 000034BE 7503                    	JNZ	short NORMCH
 20638 000034C0 C6040A                  	MOV	BYTE [SI],c_LF ; 0Ah
 20639                                  NORMCH:
 20640 000034C3 3C0A                    	CMP	AL,c_LF ; 0Ah
 20641 000034C5 E0F3                    	LOOPNZ	TRANBUF
 20642 000034C7 7507                    	JNZ	short ENDRDCON
 20643 000034C9 31F6                    	XOR	SI,SI		; Cause a new buffer to be read
 20644 000034CB E89FE1                  	call	OUTT		; Transmit linefeed
 20645 000034CE 0C01                    	OR	AL,1		; Clear zero flag--not end of file
 20646                                  ENDRDCON:
 20647                                  ;hkn; SS is DOSDATA
 20648 000034D0 16                      	push	ss
 20649 000034D1 1F                      	pop	ds
 20650 000034D2 E80CFE                  	CALL	SWAPBACK
 20651 000034D5 8936[2200]              	MOV	[CONTPOS],SI
 20652                                  
 20653                                  	; 16/12/2022
 20654                                  ;ENDRDDEV:
 20655                                  ;;hkn; SS is DOSDATA
 20656                                  ;	push	ss
 20657                                  ;	pop	ds
 20658                                  endrddev1:	; 04/05/2019
 20659 000034D9 893E[B805]              	MOV	[NEXTADD],DI
 20660 000034DD 7509                    	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 20661 000034DF C43E[9E05]              	LES	DI,[THISSFT]
 20662                                  	;and	byte [es:di+5],0BFh
 20663 000034E3 26806505BF              	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF 
 20664                                  				; Mark as no more data available
 20665                                  SETSFTC:
 20666                                  	; 31/07/2019
 20667                                  	;call	SETSFT
 20668                                  	;retn
 20669 000034E8 E9B604                  	jmp	SETSFT
 20670                                  
 20671                                  ; 16/12/2022
 20672                                  %if 0
 20673                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20674                                  ENDRDDEV:
 20675                                  ;hkn; SS is DOSDATA
 20676                                  	push	ss
 20677                                  	pop	ds
 20678                                  	MOV	[NEXTADD],DI
 20679                                  	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 20680                                  	LES	DI,[THISSFT]
 20681                                  	;and	byte [es:di+5],0BFh
 20682                                  	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF 
 20683                                  				; Mark as no more data available
 20684                                  SETSFTC:
 20685                                  	;call	SETSFT
 20686                                  	;retn
 20687                                  	jmp	SETSFT	
 20688                                  %endif
 20689                                  
 20690                                  READCON:
 20691 000034EB E8F9FD                  	CALL	SWAPCON
 20692 000034EE 8B36[2200]              	MOV	SI,[CONTPOS]
 20693 000034F2 09F6                    	OR	SI,SI
 20694 000034F4 75C4                    	JNZ	short TRANBUF
 20695 000034F6 803E[7B02]80            	CMP	BYTE [CONBUF],128 ; 80h
 20696 000034FB 7406                    	JZ	short GETBUF
 20697 000034FD C706[7B02]80FF          	MOV	WORD [CONBUF],0FF80H ; Set up 128-byte buffer with no template
 20698                                  GETBUF:
 20699 00003503 51                      	PUSH	CX
 20700 00003504 06                      	PUSH	ES
 20701 00003505 57                      	PUSH	DI
 20702                                  
 20703                                  ;hkn; CONBUF is in DOSDATA
 20704 00003506 BA[7B02]                	MOV	DX,CONBUF
 20705                                  
 20706 00003509 E8D4DE                  	call	_$STD_CON_STRING_INPUT	; Get input buffer
 20707 0000350C 5F                      	POP	DI
 20708 0000350D 07                      	POP	ES
 20709 0000350E 59                      	POP	CX
 20710                                  
 20711                                  ;hkn; CONBUF is in DOSDATA
 20712 0000350F BE[7D02]                	MOV	SI,CONBUF+2
 20713                                  
 20714 00003512 803C1A                  	CMP	BYTE [SI],1AH	; Check for Ctrl-Z in first character
 20715 00003515 75A3                    	JNZ	short TRANBUF
 20716 00003517 B01A                    	MOV	AL,1AH
 20717 00003519 AA                      	STOSB
 20718 0000351A 4F                      	DEC	DI
 20719 0000351B B00A                    	MOV	AL,c_LF
 20720 0000351D E84DE1                  	call	OUTT		; Send linefeed
 20721 00003520 31F6                    	XOR	SI,SI
 20722 00003522 EBAC                    	JMP	short ENDRDCON ; 04/05/2019
 20723                                  
 20724                                  ; 24/07/2018 - Retro DOS v3.0
 20725                                  
 20726                                  ;Break	<DOS_WRITE -- MAIN WRITE ROUTINE AND DEVICE OUT ROUTINES>
 20727                                  ;---------------------------------------------------------------------------
 20728                                  ;
 20729                                  ; Procedure Name : DOS_WRITE
 20730                                  ;
 20731                                  ; Inputs:
 20732                                  ;	ThisSFT set to the SFT for the file being used
 20733                                  ;	[DMAADD] contains transfer address
 20734                                  ;	CX = No. of bytes to write
 20735                                  ; Function:
 20736                                  ;	Perform write operation
 20737                                  ;	NOTE: If CX = 0 on input, file is truncated or grown
 20738                                  ;		to current sf_position
 20739                                  ; Outputs:
 20740                                  ;    Carry clear
 20741                                  ;	SFT Position and cluster pointers updated
 20742                                  ;	CX = No. of bytes written
 20743                                  ;	ES:DI point to SFT
 20744                                  ;    Carry set
 20745                                  ;	AX is error code
 20746                                  ;	CX = 0
 20747                                  ;	ES:DI point to SFT
 20748                                  ; DS preserved, all other registers destroyed
 20749                                  ;---------------------------------------------------------------------------
 20750                                  
 20751                                  ;hkn; called from fcbio2.asm, handle.asm and dev.asm. DS is set up at this 
 20752                                  ;hkn; point to DOSDATA.
 20753                                  
 20754                                  ; 04/05/2019 - Retro DOS v4.0
 20755                                  ; DOSCODE:742Ch (MSDOS 6.21, MSDOS.SYS)
 20756                                  
 20757                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20758                                  ; DOSCODE:7418h (MSDOS 5.0, MSDOS.SYS)
 20759                                  
 20760                                  DOS_WRITE:
 20761 00003524 C43E[9E05]              	LES	DI,[THISSFT]
 20762                                  	;mov	al,[ES:DI+2]
 20763 00003528 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 20764                                  	;and	al,0Fh
 20765 0000352C 240F                    	AND	AL,access_mask
 20766                                  	;cmp	al,0
 20767 0000352E 3C00                    	CMP	AL,open_for_read
 20768 00003530 7503                    	JNE	short Check_FCB_RO		 ;Is write or both
 20769                                  BadMode:
 20770 00003532 E9DA03                  	jmp	SET_ACC_ERR
 20771                                  
 20772                                  ; NOTE: The following check for writting to a Read Only File is performed
 20773                                  ;	    ONLY on FCBs!!!!
 20774                                  ;	We ALLOW writes to Read Only files via handles to allow a CREATE
 20775                                  ;	    of a read only file which can then be written to.
 20776                                  ;	This is OK because we are NOT ALLOWED to OPEN a RO file via handles
 20777                                  ;	    for writting, or RE-CREATE an EXISTING RO file via handles. Thus,
 20778                                  ;	    CREATing a NEW RO file, or RE-CREATing an existing file which
 20779                                  ;	    is NOT RO to be RO, via handles are the only times we can write
 20780                                  ;	    to a read-only file.
 20781                                  
 20782                                  Check_FCB_RO:
 20783                                  	;;test	word [es:di+2],8000h
 20784                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 20785                                  	;JZ	short WRITE_NO_MODE	; Not an FCB
 20786                                  	
 20787                                  	;test	byte [es:di+3],80h
 20788 00003535 26F6450380              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 20789 0000353A 7407                    	JZ	short WRITE_NO_MODE	; Not an FCB
 20790                                  
 20791                                  	;test	byte [es:di+4],1
 20792 0000353C 26F6450401              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_read_only
 20793 00003541 75EF                    	JNZ	short BadMode 		; Can't write to Read_Only files via FCB
 20794                                  WRITE_NO_MODE:
 20795 00003543 E8AA02                  	call	SETUP
 20796 00003546 E81DDD                  	call	IsSFTNet
 20797 00003549 7406                    	JZ	short LOCAL_WRITE
 20798                                  
 20799                                  ;IF NOT Installed
 20800                                  ;	transfer NET_WRITE
 20801                                  ;ELSE
 20802                                  	;mov	ax,1109h
 20803 0000354B B80911                  	MOV	AX,(MultNET<<8)|9
 20804 0000354E CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
 20805                                  			; ES:DI -> SFT
 20806                                  			; SFT DPB field -> DPB of drive containing file
 20807                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 20808                                  			; Return: CF set on error, CX = bytes written
 20809 00003550 C3                      	retn
 20810                                  ;ENDIF
 20811                                  
 20812                                  LOCAL_WRITE:
 20813                                  	;;test	word [es:di+5],80h
 20814                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 20815                                  	;jnz	short WRTDEV
 20816                                  
 20817                                  	;test	byte [es:di+5],80h
 20818 00003551 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; Check for named device I/O
 20819 00003556 756E                    	jnz	short WRTDEV
 20820                                  
 20821                                  	;mov	byte [EXTERR_LOCUS],2
 20822 00003558 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 20823 0000355D E8B1DD                  	call	ECritDisk
 20824                                  
 20825 00003560 E8F404                  	call	DISKWRITE
 20826                                  
 20827                                  	; 04/05/2019 - Retro DOS v4.0
 20828                                  
 20829                                  	; MSDOS 6.0
 20830                                  ; Extended Open
 20831 00003563 7210                    	JC	short nocommit
 20832                                  	
 20833 00003565 C43E[9E05]              	LES	DI,[THISSFT]
 20834                                  	
 20835                                  	;;test	word [ES:DI+2],4000h
 20836                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],AUTO_COMMIT_WRITE
 20837                                  	;JZ	short nocommit
 20838                                  	
 20839                                  	;test	byte [ES:DI+3],40h
 20840 00003569 26F6450340              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(AUTO_COMMIT_WRITE>>8)
 20841 0000356E 7405                    	JZ	short nocommit
 20842                                  	
 20843 00003570 51                      	PUSH	CX
 20844 00003571 E82EFB                  	call	DOS_COMMIT
 20845 00003574 59                      	POP	CX
 20846                                  nocommit:
 20847                                  ; Extended Open
 20848                                  	;call	LCritDisk
 20849                                  	;retn
 20850                                  	; 18/12/2022
 20851 00003575 E9B4DD                  	jmp	LCritDisk
 20852                                  
 20853                                  DVWRTRAW:
 20854 00003578 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 20855 0000357A E8BD11                  	call	SETWRITE
 20856 0000357D 1E                      	PUSH	DS			; Save seg of transfer
 20857                                  
 20858                                  ;hkn; SS override
 20859 0000357E 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 20860 00003583 E80811                  	call	DEVIOCALL		; DS:SI -> DEVICE
 20861                                  
 20862 00003586 89FA                    	MOV	DX,DI			; Offset part of Xaddr saved in DX
 20863 00003588 B487                    	MOV	AH,87H
 20864                                  
 20865                                  ;hkn; SS override
 20866 0000358A 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 20867                                  
 20868                                  	; MSDOS 3.3
 20869                                  	;test	di,8000h
 20870                                  	;jz	short CWRTROK
 20871                                  
 20872                                  	; MSDOS 6.0
 20873 0000358F 09FF                    	or	di,di
 20874 00003591 7920                    	jns	short CWRTROK
 20875                                  	
 20876                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20877 00003593 E85D1D                  	call	CHARHARD
 20878                                  
 20879                                  	; 04/05/2019  - Retro DOS v4.0
 20880                                  
 20881                                  	; MSDOS 6.0
 20882 00003596 362B0E[6C03]            	sub	cx,[ss:CALLSCNT]	; update ptr & count to reflect	M065
 20883 0000359B 89D3                    	mov	bx,dx			; number of chars xferred	M065
 20884 0000359D 36031E[6C03]            	add	bx,[ss:CALLSCNT]	;				M065
 20885 000035A2 89DF                    	mov	di,bx			;				M065
 20886                                  	
 20887                                  	; MSDOS 3.3
 20888                                  	;MOV	BX,DX			; Recall transfer addr		M065
 20889                                  
 20890                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20891 000035A4 08C0                    	OR	AL,AL
 20892 000035A6 740B                    	JZ	short CWRTROK 		; Ignore
 20893 000035A8 3C03                    	CMP	AL,3
 20894 000035AA 7403                    	JZ	short CWRFERR
 20895 000035AC 1F                      	POP	DS			; Recover saved seg of transfer
 20896 000035AD EBC9                    	JMP	short DVWRTRAW		; Try again
 20897                                  CWRFERR:
 20898 000035AF 58                      	POP	AX			; Chuck saved seg of transfer
 20899 000035B0 E9F4FD                  	JMP	CRDFERR 		; Will pop one more stack element
 20900                                  CWRTROK:
 20901 000035B3 58                      	POP	AX			; Chuck saved seg of transfer
 20902 000035B4 1F                      	POP	DS
 20903 000035B5 A1[6C03]                	MOV	AX,[CALLSCNT]		; Get actual number of bytes transferred
 20904                                  ENDWRDEV:
 20905 000035B8 C43E[9E05]              	LES	DI,[THISSFT]
 20906 000035BC 89C1                    	MOV	CX,AX
 20907                                  	;call	ADDREC
 20908                                  	;retn
 20909                                  	; 16/12/2022
 20910                                  	; 10/06/2019
 20911 000035BE E90104                  	jmp	ADDREC
 20912                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20913                                  	;call	ADDREC
 20914                                  	;retn
 20915                                  	
 20916                                  WRTNUL:
 20917 000035C1 89CA                    	MOV	DX,CX			; Entire transfer done
 20918                                  WRTCOOKJ:
 20919 000035C3 E98D00                  	JMP	WRTCOOKDONE
 20920                                  WRTDEV:
 20921                                  	;mov	byte [EXTERR_LOCUS],4
 20922 000035C6 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 20923                                  	;or	byte [es:di+5],40h
 20924 000035CB 26804D0540              	OR	BYTE [ES:DI+SF_ENTRY.sf_flags],devid_device_EOF
 20925                                  					; Reset EOF for input
 20926                                  	;mov	bl,[es:di+5]
 20927 000035D0 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 20928 000035D4 31C0                    	XOR	AX,AX
 20929 000035D6 E3E0                    	JCXZ	ENDWRDEV		; problem of creating on a device.
 20930 000035D8 1E                      	PUSH	DS
 20931 000035D9 88D8                    	MOV	AL,BL
 20932 000035DB C51E[2C03]              	LDS	BX,[DMAADD]		; Xaddr to DS:BX
 20933 000035DF 89DF                    	MOV	DI,BX			; Xaddr to DS:DI
 20934 000035E1 31D2                    	XOR	DX,DX			; Set starting point
 20935                                  	;test	al,20h
 20936 000035E3 A820                    	test	AL,devid_device_raw	; Raw?
 20937                                  	;JZ	short TEST_DEV_CON
 20938                                  	;JMP	DVWRTRAW
 20939                                  	; 16/12/2022
 20940 000035E5 7591                    	jnz	short DVWRTRAW
 20941                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20942                                  	;JZ	short TEST_DEV_CON
 20943                                  	;JMP	short DVWRTRAW
 20944                                  
 20945                                  TEST_DEV_CON:
 20946                                  	;test	al,2
 20947 000035E7 A802                    	test	AL,devid_device_con_out ; Console output device?
 20948 000035E9 756E                    	jnz	short WRITECON
 20949                                  	;test	al,4
 20950 000035EB A804                    	test	AL,devid_device_null
 20951 000035ED 75D2                    	JNZ	short WRTNUL
 20952 000035EF 89D0                    	MOV	AX,DX
 20953 000035F1 803F1A                  	CMP	BYTE [BX],1Ah		; ^Z?
 20954 000035F4 74CD                    	JZ	short WRTCOOKJ		; Yes, transfer nothing
 20955 000035F6 51                      	PUSH	CX
 20956 000035F7 B90100                  	MOV	CX,1
 20957 000035FA E83D11                  	call	SETWRITE
 20958 000035FD 59                      	POP	CX
 20959                                  
 20960                                  ;hkn; SS override
 20961 000035FE 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 20962                                  ;
 20963                                  ;SR; Removed X25 support from here
 20964                                  ;
 20965                                  	;lds	si,[si+7]
 20966 00003603 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 20967                                  DVWRTLP:
 20968 00003606 E8CB1A                  	call	DSKSTATCHK
 20969 00003609 E88510                  	call	DEVIOCALL2
 20970 0000360C 57                      	PUSH	DI
 20971 0000360D B487                    	MOV	AH,87H
 20972                                  
 20973                                  ;hkn; SS override
 20974 0000360F 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 20975                                  	
 20976                                  	; MSDOS 3.3
 20977                                  	;test	di,8000h
 20978                                  	;jz	short CWROK
 20979                                  
 20980                                  	; MSDOS 6.0
 20981 00003614 09FF                    	or	di,di
 20982 00003616 7916                    	jns	short CWROK
 20983                                  	
 20984                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20985 00003618 E8D81C                  	call	CHARHARD
 20986 0000361B 5F                      	POP	DI
 20987                                  
 20988                                  ;hkn; SS override
 20989 0000361C 36C706[6C03]0100        	MOV	word [SS:CALLSCNT],1
 20990 00003623 3C01                    	CMP	AL,1
 20991 00003625 74DF                    	JZ	short DVWRTLP 	; Retry
 20992 00003627 08C0                    	OR	AL,AL
 20993 00003629 740C                    	JZ	short DVWRTIGN	; Ignore
 20994                                  	; 10/08/2018
 20995 0000362B E979FD                  	JMP	CRDFERR 	; Fail, pops one stack element
 20996                                  CWROK:
 20997 0000362E 5F                      	POP	DI
 20998                                  
 20999                                  ;hkn; SS override
 21000 0000362F 36833E[6C03]00          	CMP	word [SS:CALLSCNT],0
 21001 00003635 741C                    	JZ	short WRTCOOKDONE
 21002                                  DVWRTIGN:
 21003 00003637 42                      	INC	DX
 21004                                  
 21005                                  ;hkn; SS override for CALLXAD
 21006 00003638 36FF06[6803]            	INC	WORD [SS:CALLXAD]
 21007 0000363D 47                      	INC	DI
 21008 0000363E 1E                      	PUSH	DS
 21009 0000363F 368E1E[6A03]            	MOV	DS,[SS:CALLXAD+2]
 21010 00003644 803D1A                  	CMP	BYTE [DI],1Ah	; ^Z?
 21011 00003647 1F                      	POP	DS
 21012 00003648 7409                    	JZ	short WRTCOOKDONE
 21013                                  
 21014                                  ;hkn; SS override
 21015 0000364A 36C706[5D03]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 21016 00003651 E2B3                    	LOOP	DVWRTLP
 21017                                  WRTCOOKDONE:
 21018 00003653 89D0                    	MOV	AX,DX
 21019 00003655 1F                      	POP	DS
 21020 00003656 E95FFF                  	JMP	ENDWRDEV ; 10/08/2018
 21021                                  
 21022                                  WRITECON:
 21023 00003659 1E                      	PUSH	DS
 21024                                  
 21025                                  ;hkn; SS is DOSDATA
 21026 0000365A 16                      	push	ss
 21027 0000365B 1F                      	pop	ds
 21028 0000365C E888FC                  	CALL	SWAPCON
 21029 0000365F 1F                      	POP	DS
 21030 00003660 89DE                    	MOV	SI,BX
 21031 00003662 51                      	PUSH	CX
 21032                                  WRCONLP:
 21033 00003663 AC                      	LODSB
 21034 00003664 3C1A                    	CMP	AL,1Ah		; ^Z?
 21035 00003666 7405                    	JZ	short CONEOF
 21036 00003668 E802E0                  	call	OUTT
 21037 0000366B E2F6                    	LOOP	WRCONLP
 21038                                  CONEOF:
 21039 0000366D 58                      	POP	AX			; Count
 21040 0000366E 29C8                    	SUB	AX,CX			; Amount actually written
 21041 00003670 1F                      	POP	DS
 21042 00003671 E86DFC                  	CALL	SWAPBACK
 21043 00003674 E941FF                  	JMP	ENDWRDEV
 21044                                  
 21045                                  ;---------------------------------------------------------------------------
 21046                                  ;
 21047                                  ; Procedure Name : get_io_sft
 21048                                  ;
 21049                                  ;   Convert JFN number in BX to sf_entry in DS:SI We get the normal SFT if
 21050                                  ;   CONSWAP is FALSE or if the handle desired is 2 or more. Otherwise, we
 21051                                  ;   retrieve the sft from ConSFT which is set by SwapCon.
 21052                                  ;
 21053                                  ;---------------------------------------------------------------------------
 21054                                  
 21055                                  ; 04/05/2019 - Retro DOS v4.0
 21056                                  ; DOSCODE:7583h (MSDOS 6.21, MSDOS.SYS)
 21057                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21058                                  ; DOSCODE:756Fh (MSDOS 5.0, MSDOS.SYS)
 21059                                  
 21060                                  GET_IO_SFT:
 21061                                  	;test	byte [SS:CONSWAP],0FFh
 21062 00003677 36803E[5703]00          	cmp	byte [SS:CONSWAP],0			;smr;SS Override
 21063 0000367D 7512                    	JNZ	short GetRedir
 21064                                  GetNormal:
 21065 0000367F 16                      	push	ss
 21066 00003680 1F                      	pop	ds
 21067 00003681 06                      	PUSH	ES
 21068 00003682 57                      	PUSH	DI
 21069 00003683 E80D30                  	call	SFFromHandle
 21070 00003686 7206                    	JC	short RET44P
 21071 00003688 8CC6                    	MOV	SI,ES
 21072 0000368A 8EDE                    	MOV	DS,SI
 21073 0000368C 89FE                    	MOV	SI,DI
 21074                                  RET44P:
 21075 0000368E 5F                      	POP	DI
 21076 0000368F 07                      	POP	ES
 21077 00003690 C3                      	retn
 21078                                  GetRedir:
 21079 00003691 83FB01                  	CMP	BX,1
 21080 00003694 77E9                    	JA	short GetNormal
 21081 00003696 36C536[E605]            	LDS	SI,[SS:CONSFT]
 21082 0000369B F8                      	CLC
 21083                                  get_io_sft_retn:
 21084 0000369C C3                      	retn
 21085                                  
 21086                                  ;Break	<DIRREAD -- READ A DIRECTORY SECTOR>
 21087                                  ;---------------------------------------------------------------------------
 21088                                  ;
 21089                                  ; Procedure Name : DIRREAD
 21090                                  ;
 21091                                  ; Inputs:
 21092                                  ;	AX = Directory block number (relative to first block of directory)
 21093                                  ;	ES:BP = Base of drive parameters
 21094                                  ;	[DIRSEC] = First sector of first cluster of directory
 21095                                  ;	[CLUSNUM] = Next cluster
 21096                                  ;	[CLUSFAC] = Sectors/Cluster
 21097                                  ; Function:
 21098                                  ;	Read the directory block into [CURBUF].
 21099                                  ; Outputs:
 21100                                  ;	[NXTCLUSNUM] = Next cluster (after the one skipped to)
 21101                                  ;	[SECCLUSPOS] Set
 21102                                  ;	ES:BP unchanged
 21103                                  ;	[CURBUF] Points to Buffer with dir sector
 21104                                  ;	Carry set if error (user said FAIL to I 24)
 21105                                  ; DS preserved, all other registers destroyed.
 21106                                  ;---------------------------------------------------------------------------
 21107                                  
 21108                                  ;hkn; called from dir.asm. DS already set up to DOSDATA.
 21109                                  
 21110                                  DIRREAD:
 21111                                  
 21112                                  ; Note that ClusFac is the sectors per cluster. This is NOT necessarily
 21113                                  ; the same as what is in the DPB! In the case of the root directory, we have
 21114                                  ; ClusFac = # sectors in the root directory. The root directory is detected
 21115                                  ; by DIRStart = 0.
 21116                                  
 21117 0000369D 31D2                    	XOR	DX,DX
 21118                                  	;CMP	word [DIRSTART],0
 21119                                  	; 21/09/2023
 21120 0000369F 3916[C205]              	cmp	[DIRSTART],dx ; 0
 21121 000036A3 7503                    	jnz	short SubDir
 21122 000036A5 92                      	XCHG	AX,DX
 21123 000036A6 EB0C                    	JMP	short DoRead
 21124                                  
 21125                                  ; Convert the sector number in AX into cluster and sector-within-cluster pair
 21126                                  
 21127                                  SubDir:
 21128 000036A8 88C2                    	MOV	DL,AL
 21129                                  	;and	dl,[es:bp+4]
 21130 000036AA 26225604                	AND	DL,[ES:BP+DPB.CLUSTER_MASK]
 21131                                  
 21132                                  ;	(DX) = sector-in-cluster
 21133                                  
 21134                                  	;mov	cl,[es:bp+5]
 21135 000036AE 268A4E05                	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 21136 000036B2 D3E8                    	SHR	AX,CL
 21137                                  
 21138                                  ;	(DX) = position in cluster
 21139                                  ;	(AX) = number of clusters to skip
 21140                                  
 21141                                  DoRead:
 21142 000036B4 8816[7305]              	MOV	[SECCLUSPOS],DL
 21143 000036B8 89C1                    	MOV	CX,AX
 21144 000036BA 88D4                    	MOV	AH,DL
 21145                                  
 21146                                  ;	(CX) = number of clusters to skip.
 21147                                  ;	(AH) = remainder
 21148                                  
 21149                                  	; 04/05/2019 - Retro DOS v4.0
 21150                                  	 
 21151                                  	; MSDOS 6.0
 21152                                  	;MOV	DX,[DIRSEC+2]	     	  ;>32mb
 21153                                  	;MOV	[HIGH_SECTOR],DX	  ;>32mb
 21154                                  	;MOV	DX,[DIRSEC]
 21155                                  	;ADD	DL,AH
 21156                                  	;ADC	DH,0
 21157                                  	;ADC	word [HIGH_SECTOR],0	  ;>32mb
 21158                                  	; 21/09/2023
 21159 000036BC 31DB                    	xor	bx,bx ; 0
 21160 000036BE 8B16[BE05]              	mov	dx,[DIRSEC]
 21161 000036C2 00E2                    	add	dl,ah
 21162 000036C4 10DE                    	adc	dh,bl ; 0
 21163 000036C6 131E[C005]              	adc	bx,[DIRSEC+2]
 21164 000036CA 891E[0706]              	mov	[HIGH_SECTOR],bx
 21165                                  
 21166 000036CE 8B1E[BC05]              	MOV	BX,[CLUSNUM]
 21167 000036D2 891E[DC05]              	MOV	[NXTCLUSNUM],BX
 21168 000036D6 E319                    	JCXZ	FIRSTCLUSTER
 21169                                  SKPCLLP:
 21170 000036D8 E8831E                  	call	UNPACK
 21171 000036DB 72BF                    	jc	short get_io_sft_retn
 21172 000036DD 87DF                    	XCHG	BX,DI
 21173 000036DF E8651E                  	call	IsEOF			; test for eof based on fat size
 21174 000036E2 7302                    	JAE	short HAVESKIPPED
 21175 000036E4 E2F2                    	LOOP	SKPCLLP
 21176                                  HAVESKIPPED:
 21177 000036E6 891E[DC05]              	MOV	[NXTCLUSNUM],BX
 21178 000036EA 89FA                    	MOV	DX,DI
 21179 000036EC 88E3                    	MOV	BL,AH
 21180 000036EE E81617                  	call	FIGREC
 21181                                  
 21182                                  	;entry	FIRSTCLUSTER
 21183                                  
 21184                                  FIRSTCLUSTER:
 21185                                  	; 22/09/2023
 21186                                  	;;mov	byte [ALLOWED],18h
 21187                                  	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 21188                                  	;XOR	AL,AL ; *	; Indicate pre-read
 21189                                  	;call	GETBUFFR
 21190 000036F1 E87522                  	call	GETBUFFER ; *	; pre-read
 21191 000036F4 72A6                    	jc	short get_io_sft_retn
 21192                                  
 21193                                  	;entry	SET_BUF_AS_DIR
 21194                                  
 21195                                  SET_BUF_AS_DIR:
 21196                                  
 21197                                  ;	Set the type of CURBUF to be a directory sector.
 21198                                  ;	Only flags are modified.
 21199                                  
 21200 000036F6 1E                      	PUSH	DS
 21201 000036F7 56                      	PUSH	SI
 21202 000036F8 C536[E205]              	LDS	SI,[CURBUF]
 21203                                  	;or	byte [si+5],4
 21204 000036FC 804C0504                	OR	byte [SI+BUFFINFO.buf_flags],buf_isDIR	; Clears carry
 21205 00003700 5E                      	POP	SI
 21206 00003701 1F                      	POP	DS
 21207                                  dirread_retn:
 21208 00003702 C3                      	retn
 21209                                  
 21210                                  ;Break	<FATSECRD -- READ A FAT SECTOR>
 21211                                  ;----------------------------------------------------------------------------
 21212                                  ;
 21213                                  ; Procedure Name : FATSECRD
 21214                                  ; Inputs:
 21215                                  ;	Same as DREAD
 21216                                  ;	DS:BX = Transfer address
 21217                                  ;	CX = Number of sectors
 21218                                  ;	DX = Absolute record number
 21219                                  ;	ES:BP = Base of drive parameters
 21220                                  ; Function:
 21221                                  ;	Calls BIOS to perform FAT read.
 21222                                  ; Outputs:
 21223                                  ;	Same as DREAD
 21224                                  ;---------------------------------------------------------------------------
 21225                                  
 21226                                  	; 04/05/2019 - Retro DOS v4.0
 21227                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)	
 21228                                  
 21229                                  FATSECRD:
 21230                                  ;hkn; SS override
 21231                                  	;mov	byte [ss:ALLOWED],18h
 21232 00003703 36C606[4B03]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 21233 00003709 89CF                    	MOV	DI,CX
 21234                                  	;mov	cl,[es:bp+8]
 21235 0000370B 268A4E08                	MOV	CL,[ES:BP+DPB.FAT_COUNT]
 21236                                  	; MSDOS 3.3
 21237                                  	;;mov	al,[es:bp+0Fh]
 21238                                  	;MOV	AL,[ES:BP+DPB.FAT_SIZE] 				
 21239                                  	;XOR	AH,AH
 21240                                  	; MSDOS 6.0
 21241                                  	;mov	ax,[es:bp+0Fh]
 21242 0000370F 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE] ;>32mb
 21243 00003713 30ED                    	XOR	CH,CH	
 21244 00003715 52                      	PUSH	DX
 21245                                  NXTFAT:
 21246                                  	; MSDOS 6.0
 21247                                  ;hkn; SS override
 21248 00003716 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0	;>32mb FAT sectors cannot exceed
 21249 0000371D 51                      	PUSH	CX			;32mb
 21250 0000371E 50                      	PUSH	AX
 21251 0000371F 89F9                    	MOV	CX,DI
 21252 00003721 E85B00                  	call	DSKREAD
 21253 00003724 58                      	POP	AX
 21254 00003725 59                      	POP	CX
 21255 00003726 7420                    	JZ	short RET41P		; Carry clear
 21256 00003728 01C2                    	ADD	DX,AX
 21257 0000372A E2EA                    	LOOP	NXTFAT
 21258 0000372C 5A                      	POP	DX
 21259 0000372D 89F9                    	MOV	CX,DI
 21260                                  
 21261                                  ; NOTE FALL THROUGH
 21262                                  
 21263                                  ;Break	<DREAD -- DO A DISK READ>
 21264                                  ;---------------------------------------------------------------------------
 21265                                  ;
 21266                                  ; Procedure Name : DREAD
 21267                                  ;
 21268                                  ; Inputs:
 21269                                  ;	DS:BX = Transfer address
 21270                                  ;	CX = Number of sectors
 21271                                  ;	DX = Absolute record number	      (LOW)
 21272                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 21273                                  ;	ES:BP = Base of drive parameters
 21274                                  ;	[ALLOWED] must be set in case call to HARDERR needed
 21275                                  ; Function:
 21276                                  ;	Calls BIOS to perform disk read. If BIOS reports
 21277                                  ;	errors, will call HARDERRRW for further action.
 21278                                  ; Outputs:
 21279                                  ;	Carry set if error (currently user FAILED to INT 24)
 21280                                  ; DS,ES:BP preserved. All other registers destroyed.
 21281                                  ;---------------------------------------------------------------------------
 21282                                  
 21283                                  	;entry	DREAD
 21284                                  DREAD:
 21285 0000372F E84D00                  	call	DSKREAD
 21286 00003732 74CE                    	jz	short dirread_retn	; Carry clear
 21287                                  ;hkn; SS override
 21288 00003734 36C606[7505]00          	MOV	BYTE [SS:READOP],0
 21289 0000373A E89A00                  	call	HARDERRRW
 21290 0000373D 3C01                    	CMP	AL,1			; Check for retry
 21291 0000373F 74EE                    	JZ	short DREAD
 21292 00003741 3C03                    	CMP	AL,3			; Check for FAIL
 21293 00003743 F8                      	CLC
 21294 00003744 7501                    	JNZ	short NO_CAR		; Ignore
 21295 00003746 F9                      	STC
 21296                                  NO_CAR:
 21297 00003747 C3                      	retn
 21298                                  RET41P: 
 21299 00003748 5A                      	POP	DX
 21300 00003749 C3                      	retn
 21301                                  
 21302                                  ; 24/07/2018 - Retro DOS v3.0
 21303                                  
 21304                                  ;Break	<CHECK_WRITE_LOCK>
 21305                                  ;---------------------------------------------------------------------------
 21306                                  ;
 21307                                  ; Procedure Name : CHECK_WRITE_LOCK
 21308                                  ;
 21309                                  ; Inputs:
 21310                                  ;	output of SETUP
 21311                                  ;	ES:DI -> SFT
 21312                                  ; Function:
 21313                                  ;	check write lock
 21314                                  ; Outputs:
 21315                                  ;	Carry set if error
 21316                                  ;	Carry clear if ok
 21317                                  ;
 21318                                  ;----------------------------------------------------------------------------
 21319                                  
 21320                                  	; 04/05/2019 - Retro DOS v4.0
 21321                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21322                                  
 21323                                  CHECK_WRITE_LOCK:
 21324                                  	; MSDOS 6.0
 21325                                  	;test	byte [es:di+4],8
 21326 0000374A 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 21327                                  	;JZ	short write_cont			     ;no
 21328                                  	;;call	SET_ACC_ERR_DS
 21329                                  	;;retn
 21330                                  	;;jnz	SET_ACC_ERR_DS
 21331                                  	; 19/08/2018
 21332                                  	;jz	short write_cont
 21333                                  	;jmp	SET_ACC_ERR_DS
 21334                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21335 0000374F 7403                    	JZ	short write_cont
 21336                                  	;call	SET_ACC_ERR_DS
 21337                                  	;retn
 21338                                  	; 16/12/2022
 21339 00003751 E9B901                  	jmp	SET_ACC_ERR_DS
 21340                                  
 21341                                  write_cont:				;
 21342 00003754 51                      	PUSH	CX			;save reg
 21343 00003755 09C9                    	OR	CX,CX			;
 21344 00003757 7501                    	JNZ	short Not_Truncate	;
 21345 00003759 49                      	dec	cx			;(cx) = -1; check for lock on whole file
 21346                                  Not_Truncate:				;
 21347 0000375A B080                    	MOV	AL,80H			;check write access
 21348 0000375C E8BD3B                  	call	LOCK_CHECK		;check lock
 21349 0000375F 59                      	POP	CX			;restore reg
 21350 00003760 7305                    	JNC	short WRITE_OK		;lock ok
 21351 00003762 E85F01                  	call	WRITE_LOCK_VIOLATION	;issue I24
 21352 00003765 73ED                    	JNC	short write_cont	;retry
 21353                                  WRITE_OK:				;
 21354 00003767 C3                      	retn				;
 21355                                  
 21356                                  ;Break	<CHECK_READ_LOCK>
 21357                                  ;---------------------------------------------------------------------------
 21358                                  ;
 21359                                  ; Procedure Name : CHECK_READ_LOC
 21360                                  ;
 21361                                  ; Inputs:
 21362                                  ;	ES:DI -> SFT
 21363                                  ;	output of SETUP
 21364                                  ; Function:
 21365                                  ;	check read lock
 21366                                  ; Outputs:
 21367                                  ;	Carry set if error
 21368                                  ;	Carry clear if ok
 21369                                  ;----------------------------------------------------------------------------
 21370                                  
 21371                                  CHECK_READ_LOCK:
 21372                                  	; MSDOS 6.0
 21373                                  	;test	byte [es:di+4],8
 21374 00003768 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 21375                                  	;JZ	short do_retry			   	     ; no
 21376                                  	;;call	SET_ACC_ERR
 21377                                  	;;retn
 21378                                  	;;jnz	SET_ACC_ERR
 21379                                  	; 16/12/2022
 21380                                  	; 28/07/2019
 21381 0000376D 7403                    	jz	short do_retry
 21382 0000376F E99D01                  	jmp	SET_ACC_ERR
 21383                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21384                                  	;JZ	short do_retry
 21385                                  	;call	SET_ACC_ERR
 21386                                  	;retn
 21387                                  do_retry:				;
 21388 00003772 30C0                    	xor	al,al			;check read access
 21389 00003774 E8A53B                  	call	LOCK_CHECK		;check lock
 21390 00003777 7305                    	JNC	short READLOCK_OK 	;lock ok
 21391 00003779 E82801                  	call	READ_LOCK_VIOLATION	;issue I24
 21392 0000377C 73F4                    	JNC	short do_retry		;retry
 21393                                  READLOCK_OK:				;
 21394 0000377E C3                      	retn				;
 21395                                  
 21396                                  ;============================================================================
 21397                                  ; DISK2.ASM, MSDOS 6.0, 1991
 21398                                  ;============================================================================
 21399                                  ; 24/07/2018 - Retro DOS v3.0
 21400                                  ; 04/05/2019 - Retro DOS v4.0
 21401                                  
 21402                                  ;	TITLE	DISK2 - Disk utility routines
 21403                                  ;	NAME	Disk2
 21404                                  
 21405                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 21406                                  ;
 21407                                  ;	DskRead
 21408                                  ;	DWRITE
 21409                                  ;	DSKWRITE
 21410                                  ;	HarderrRW
 21411                                  ;	SETUP
 21412                                  ;	BREAKDOWN
 21413                                  ;	READ_LOCK_VIOLATION
 21414                                  ;	WRITE_LOCK_VIOLATION
 21415                                  ;	DISKREAD
 21416                                  ;	SET_ACC_ERR_DS
 21417                                  ;	SET_ACC_ERR
 21418                                  ;	SETSFT
 21419                                  ;	SETCLUS
 21420                                  ;	AddRec
 21421                                  ;
 21422                                  ;	Revision history:
 21423                                  ;
 21424                                  ;		AN000 version 4.00 Jan. 1988
 21425                                  ;		M039 DB 10/17/90 - Disk read/write optimization
 21426                                  
 21427                                  ; 04/05/2019 - Retro DOS v4.0
 21428                                  ; DOSCODE:7699h (MSDOS 6.21, MSDOS.SYS)
 21429                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21430                                  ; DOSCODE:7685h (MSDOS 5.0, MSDOS.SYS)
 21431                                  
 21432                                  ;Break	<DSKREAD -- PHYSICAL DISK READ>
 21433                                  ;---------------------------------------------------------------------------
 21434                                  ;
 21435                                  ; Procedure Name : DSKREAD
 21436                                  ;
 21437                                  ; Inputs:
 21438                                  ;	DS:BX = Transfer addr
 21439                                  ;	CX = Number of sectors
 21440                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 21441                                  ;	DX = Absolute record number	       (LOW)
 21442                                  ;	ES:BP = Base of drive parameters
 21443                                  ; Function:
 21444                                  ;	Call BIOS to perform disk read
 21445                                  ; Outputs:
 21446                                  ;	DI = CX on entry
 21447                                  ;	CX = Number of sectors unsuccessfully transfered
 21448                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 21449                                  ;	Zero set if OK (from BIOS) (carry clear)
 21450                                  ;	Zero clear if error (carry clear)
 21451                                  ; SI Destroyed, others preserved
 21452                                  ;---------------------------------------------------------------------------
 21453                                  
 21454                                  DSKREAD:
 21455 0000377F 51                      	PUSH	CX
 21456                                  	;mov	ah,[es:bp+17h] ; 04/05/2019
 21457 00003780 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 21458                                  	;mov	al,[es:bp+1]
 21459 00003784 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 21460 00003788 53                      	PUSH	BX
 21461 00003789 06                      	PUSH	ES
 21462 0000378A E87A0F                  	call	SETREAD
 21463 0000378D EB27                    	JMP	short DODSKOP
 21464                                  
 21465                                  ;Break	<DWRITE -- SEE ABOUT WRITING>
 21466                                  ;--------------------------------------------------------------------------
 21467                                  ;
 21468                                  ; Procedure Name : DWRITE
 21469                                  ;
 21470                                  ; Inputs:
 21471                                  ;	DS:BX = Transfer address
 21472                                  ;	CX = Number of sectors
 21473                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 21474                                  ;	DX = Absolute record number	       (LOW)
 21475                                  ;	ES:BP = Base of drive parameters
 21476                                  ;	[ALLOWED] must be set in case HARDERR called
 21477                                  ; Function:
 21478                                  ;	Calls BIOS to perform disk write. If BIOS reports
 21479                                  ;	errors, will call HARDERRRW for further action.
 21480                                  ; Output:
 21481                                  ;	Carry set if error (currently, user FAILed to I 24)
 21482                                  ; BP preserved. All other registers destroyed.
 21483                                  ;----------------------------------------------------------------------------
 21484                                  
 21485                                  	;entry	DWRITE
 21486                                  DWRITE:
 21487 0000378F E81600                  	CALL	DSKWRITE
 21488 00003792 7413                    	jz	short dw_ret_label	; Carry clear (retz)
 21489                                  
 21490                                  ;hkn; SS override
 21491 00003794 36C606[7505]01          	MOV	BYTE [SS:READOP],1
 21492 0000379A E83A00                  	call	HARDERRRW
 21493 0000379D 3C01                    	CMP	AL,1		; Check for retry
 21494 0000379F 74EE                    	JZ	short DWRITE
 21495 000037A1 3C03                    	CMP	AL,3		; Check for FAIL
 21496 000037A3 F8                      	CLC
 21497 000037A4 7501                    	JNZ	short NO_CAR2 	; Ignore
 21498 000037A6 F9                      	STC
 21499                                  NO_CAR2:
 21500                                  dw_ret_label:
 21501 000037A7 C3                      	retn
 21502                                  
 21503                                  ;Break	<DSKWRITE -- PHYSICAL DISK WRITE>
 21504                                  ;---------------------------------------------------------------------------
 21505                                  ;
 21506                                  ; Procedure Name : DSKWRITE
 21507                                  ;
 21508                                  ; Inputs:
 21509                                  ;	DS:BX = Transfer addr
 21510                                  ;	CX = Number of sectors
 21511                                  ;	DX = Absolute record number	       (LOW)
 21512                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 21513                                  ;	ES:BP = Base of drive parameters
 21514                                  ; Function:
 21515                                  ;	Call BIOS to perform disk read
 21516                                  ; Outputs:
 21517                                  ;	DI = CX on entry
 21518                                  ;	CX = Number of sectors unsuccessfully transfered
 21519                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 21520                                  ;	Zero set if OK (from BIOS) (carry clear)
 21521                                  ;	Zero clear if error (carry clear)
 21522                                  ; SI Destroyed, others preserved
 21523                                  ;
 21524                                  ;----------------------------------------------------------------------------
 21525                                  
 21526                                  	;entry	DSKWRITE
 21527                                  DSKWRITE:
 21528 000037A8 51                      	PUSH	CX
 21529                                  	;mov	ah,[es:bp+17h] ; 04/05/2019
 21530 000037A9 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 21531                                  	;mov	al,[es:bp+1]
 21532 000037AD 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 21533 000037B1 53                      	PUSH	BX
 21534 000037B2 06                      	PUSH	ES
 21535 000037B3 E8840F                  	call	SETWRITE
 21536                                  DODSKOP:
 21537 000037B6 8CD9                    	MOV	CX,DS		; Save DS
 21538 000037B8 1F                      	POP	DS		; DS:BP points to DPB
 21539 000037B9 1E                      	PUSH	DS
 21540                                  
 21541                                  	;lds	si,[ds:bp+13h] ; 04/05/2019
 21542 000037BA 3EC57613                	LDS	SI,[ds:BP+DPB.DRIVER_ADDR] ; 07/09/2018
 21543 000037BE E8D00E                  	call	DEVIOCALL2
 21544                                  
 21545 000037C1 8ED9                    	MOV	DS,CX		; Restore DS
 21546 000037C3 07                      	POP	ES		; Restore ES
 21547 000037C4 5B                      	POP	BX
 21548                                  
 21549                                  ;hkn; SS override
 21550 000037C5 368B0E[6C03]            	MOV	CX,[SS:CALLSCNT] ; Number of sectors transferred
 21551 000037CA 5F                      	POP	DI
 21552 000037CB 29F9                    	SUB	CX,DI
 21553 000037CD F7D9                    	NEG	CX		; Number of sectors not transferred
 21554                                  
 21555                                  ;hkn; SS override
 21556 000037CF 36A1[5D03]              	MOV	AX,[SS:DEVCALL_REQSTAT]
 21557                                  	;test	ax,8000h
 21558                                  	; 17/12/2022
 21559                                  	;test	ah,80h
 21560 000037D3 F6C480                  	test	ah,(STERR>>8)
 21561                                  	;test	AX,STERR
 21562 000037D6 C3                      	retn
 21563                                  
 21564                                  ;Break	<HardErrRW - map extended errors and call harderr>
 21565                                  ;---------------------------------------------------------------------------
 21566                                  ;
 21567                                  ; Procedure Name : HardErrRW
 21568                                  ;
 21569                                  ; Inputs:
 21570                                  ;	AX is error code from read or write
 21571                                  ;	Other registers set as per HARDERR
 21572                                  ; Function:
 21573                                  ;	Checks the error code for special extended
 21574                                  ;	errors and maps them if needed. Then invokes
 21575                                  ;	Harderr
 21576                                  ; Outputs:
 21577                                  ;	Of HARDERR
 21578                                  ; AX may be modified prior to call to HARDERR.
 21579                                  ; No other registers altered.
 21580                                  ;
 21581                                  ;---------------------------------------------------------------------------
 21582                                  
 21583                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21584                                  HARDERRRW:
 21585                                  	;cmp	al,0Fh
 21586 000037D7 3C0F                    	CMP	AL,error_I24_wrong_disk
 21587 000037D9 7512                    	JNZ	short DO_ERR				; Nothing to do
 21588                                  
 21589                                  	; MSDOS 3.3
 21590                                  	;push	ds
 21591                                  	;push	si
 21592                                  	;lds	si,[ss:CALLVIDRW]
 21593                                  	;mov	[ss:EXTERRPT+2], ds
 21594                                  	;mov	[ss:EXTERRPT], si
 21595                                  	;pop	si
 21596                                  	;pop	ds
 21597                                  
 21598                                  	; MSDOS 6.0
 21599 000037DB 50                      	push	ax
 21600 000037DC 36A1[7003]              	mov	ax,[SS:CALLVIDRW]		; get ptr lo  ;smr;SS Override
 21601 000037E0 36A3[2803]              	mov	[ss:EXTERRPT],ax		; set ext err ptr lo
 21602 000037E4 36A1[7203]              	mov	ax,[SS:CALLVIDRW+2]		; get ptr hi from dev
 21603 000037E8 36A3[2A03]              	mov	[ss:EXTERRPT+2],ax		; set ext err ptr hi
 21604 000037EC 58                      	pop	ax
 21605                                  DO_ERR:
 21606                                  	;;call	HARDERR
 21607                                  	;;retn
 21608                                  	; 16/12/2022
 21609                                  	; 10/06/2019
 21610 000037ED E9341B                  	jmp	HARDERR	
 21611                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21612                                  	;call	HARDERR
 21613                                  	;retn
 21614                                  
 21615                                  ; 24/07/2018 - Retro DOS v3.0
 21616                                  
 21617                                  ;Break	<SETUP -- SETUP A DISK READ OR WRITE FROM USER>
 21618                                  ;----------------------------------------------------------------------------
 21619                                  ;
 21620                                  ; Procedure Name : SETUP
 21621                                  ;
 21622                                  ; Inputs:
 21623                                  ;	ES:DI point to SFT (value also in THISSFT)
 21624                                  ;	DMAAdd contains transfer address
 21625                                  ;	CX = Byte count
 21626                                  ;	DS = DOSDATA
 21627                                  ;   WARNING Stack must be clean, two ret addrs on stack, 1st of caller,
 21628                                  ;		2nd of caller of caller.
 21629                                  ; Outputs:
 21630                                  ;	    CX = byte count
 21631                                  ;	    [THISDPB] = Base of drive parameters if file
 21632                                  ;		      = Pointer to device header if device or NET
 21633                                  ;	    ES:DI Points to SFT
 21634                                  ;	    [NEXTADD] = Displacement of disk transfer within segment
 21635                                  ;	    [TRANS] = 0 (No transfers yet)
 21636                                  ;	    BytPos = Byte position in file
 21637                                  ;
 21638                                  ;	The following fields are relevant to local files (not devices) only:
 21639                                  ;
 21640                                  ;	    SecPos = Position of first sector (local files only)
 21641                                  ;	    [BYTSECPOS] = Byte position in first sector (local files only)
 21642                                  ;	    [CLUSNUM] = First cluster (local files only)
 21643                                  ;	    [SECCLUSPOS] = Sector within first cluster (local files only)
 21644                                  ;	    [THISDRV] = Physical unit number (local files only)
 21645                                  ;
 21646                                  ;      RETURNS ONE LEVEL UP WITH:
 21647                                  ;	   CX = 0
 21648                                  ;	   CARRY = Clear
 21649                                  ;	IF AN ERROR IS DETECTED
 21650                                  ; All other registers destroyed
 21651                                  ;----------------------------------------------------------------------------
 21652                                  
 21653                                  ;hkn; called from disk.asm. DS has been set up to DOSDATA.
 21654                                  
 21655                                  ; DOSCODE:770Bh (MSDOS 6.21, MSDOS.SYS)
 21656                                  
 21657                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21658                                  ; DOSCODE:76F7h (MSDOS 5.0, MSDOS.SYS)
 21659                                  
 21660                                  SETUP:
 21661                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 411Bh
 21662                                  
 21663                                  	;lds 	si,[es:di+7]
 21664 000037F0 26C57507                	LDS	SI,[ES:DI+SF_ENTRY.sf_devptr]
 21665                                  
 21666                                  ;hkn; SS override
 21667 000037F4 368C1E[8C05]            	MOV	[SS:THISDPB+2],DS
 21668                                  
 21669                                  ;hkn; SS is DOSDATA
 21670 000037F9 16                      	push	ss
 21671 000037FA 1F                      	pop	ds
 21672                                  
 21673 000037FB 8936[8A05]              	MOV	[THISDPB],SI
 21674                                  
 21675 000037FF 8B1E[2C03]              	MOV	BX,[DMAADD]
 21676 00003803 891E[B805]              	MOV	[NEXTADD],BX		;Set NEXTADD to start of Xaddr
 21677 00003807 C606[7405]00            	MOV	BYTE [TRANS],0		;No transferes
 21678                                  	;mov	ax,[es:di+15h]
 21679 0000380C 268B4515                	MOV	AX,[ES:DI+SF_ENTRY.sf_position]
 21680                                  	;mov	dx,[es:di+17h]
 21681 00003810 268B5517                	MOV	DX,[ES:DI+SF_ENTRY.sf_position+2]
 21682 00003814 8916[D005]              	MOV	[BYTPOS+2],DX		;Set it
 21683 00003818 A3[CE05]                	MOV	[BYTPOS],AX
 21684                                  	;test	word [es:di+5],8080h
 21685 0000381B 26F745058080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet+devid_device
 21686 00003821 753C                    	JNZ	short NOSETSTUFF	;Following not done on devs or NET
 21687 00003823 06                      	PUSH	ES
 21688 00003824 C42E[8A05]              	LES	BP,[THISDPB]		;Point at the DPB
 21689                                  
 21690                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21691                                  	;;mov	bl,[es:bp+0]
 21692                                  	;MOV	BL,[ES:BP+DPB.DRIVE]
 21693                                  	; 05/12/2022
 21694 00003828 268A5E00                	mov	bl,[es:bp]
 21695                                  	
 21696 0000382C 881E[7605]              	MOV	[THISDRV],BL		;Set THISDRV
 21697                                  	;mov	bx,[es:bp+2]
 21698 00003830 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 21699                                  
 21700                                  	;; MSDOS 3.3
 21701                                  	;cmp	dx,bx
 21702                                  	;jnb	short EOFERR
 21703                                  	;div	bx
 21704                                  	;mov	[SECPOS],ax
 21705                                  	;mov	[BYTSECPOS],dx
 21706                                  	;mov	dx,ax
 21707                                  	;;and	al,[es:bp+4]
 21708                                  	;AND	AL,[ES:BP+DPB.CLUSTER_MASK]
 21709                                  	;mov	[SECCLUSPOS],al
 21710                                  	;mov	ax,cx
 21711                                  	;;mov	cl,[es:bp+5]
 21712                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 21713                                  	;shr	dx,cl
 21714                                  	;mov	[CLUSNUM],dx
 21715                                  	;pop	es
 21716                                  	;mov	cx,ax
 21717                                  
 21718                                  	; 04/05/2019 - Retro DOS v4.0
 21719                                  
 21720                                  	; MSDOS 6.0
 21721                                  ;M039: Optimized this section.
 21722 00003834 51                              PUSH    CX			;SHR32 and DIV32 use CX.
 21723 00003835 E83405                  	call	DIV32			;DX:AX/BX = CX:AX + DX (rem)
 21724 00003838 8916[CC05]              	MOV	[BYTSECPOS],DX
 21725 0000383C A3[C405]                	MOV	[SECPOS],AX
 21726 0000383F 890E[C605]              	MOV	[SECPOS+2],CX
 21727 00003843 89CA                    	MOV	DX,CX
 21728                                  
 21729 00003845 89C3                    	MOV	BX,AX
 21730                                  	;and	bl,[es:bp+4]
 21731 00003847 26225E04                	AND	BL,[ES:BP+DPB.CLUSTER_MASK]
 21732 0000384B 881E[7305]              	MOV	[SECCLUSPOS],BL
 21733                                  
 21734 0000384F E84105                  	call	SHR32			;(DX:AX SHR dpb_cluster_shift)
 21735 00003852 59                      	POP	CX			;CX = byte count.
 21736 00003853 751F                    	JNZ	short EOFERR		;cluster number above 64k
 21737                                  	;cmp	ax,[es:bp+0Dh]
 21738 00003855 263B460D                	CMP	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  if > disk size ;AN000;
 21739 00003859 7719                    	JA	short EOFERR		   ;>32mb  then EOF       ;AN000;
 21740                                  
 21741 0000385B A3[BC05]                	MOV	[CLUSNUM],AX
 21742 0000385E 07                      	POP	ES			; ES:DI point to SFT
 21743                                  ;M039
 21744                                  
 21745                                  NOSETSTUFF:
 21746 0000385F 89C8                    	MOV	AX,CX		; AX = Byte count.
 21747 00003861 0306[2C03]              	ADD	AX,[DMAADD]	; See if it will fit in one segment
 21748 00003865 730C                    	JNC	short setup_OK	; Must be less than 64
 21749 00003867 A1[2C03]                	MOV	AX,[DMAADD]
 21750 0000386A F7D8                    	NEG	AX		; Amount of room left in segment (know
 21751                                  				;    less than 64K since max value of CX
 21752                                  				;    is FFFF).
 21753 0000386C 7501                    	JNZ	short NoDec
 21754 0000386E 48                      	DEC	AX
 21755                                  NoDec:
 21756 0000386F 89C1                    	MOV	CX,AX		; Can do this much
 21757 00003871 E304                    	JCXZ	NOROOM		; Silly user gave Xaddr of FFFF in segment
 21758                                  setup_OK:
 21759 00003873 C3                      	retn
 21760                                  
 21761                                  EOFERR:
 21762 00003874 07                      	POP	ES		; ES:DI point to SFT
 21763 00003875 31C9                    	XOR	CX,CX		; No bytes read
 21764                                  ;;;;;;;;;;; 7/18/86
 21765                                  	; MSDOS 3.3
 21766                                  	;MOV	BYTE [DISK_FULL],1 ; set disk full flag
 21767                                  ;;;;;;;;;;;
 21768                                  NOROOM:
 21769 00003877 5B                      	POP	BX		; Kill return address
 21770 00003878 F8                      	CLC
 21771 00003879 C3                      	retn			; RETURN TO CALLER OF CALLER
 21772                                  
 21773                                  ;Break	<BREAKDOWN -- CUT A USER READ OR WRITE INTO PIECES>
 21774                                  ;---------------------------------------------------------------------------
 21775                                  ;
 21776                                  ; Procedure Name : BREAKDOWN
 21777                                  ;
 21778                                  ; Inputs:
 21779                                  ;	CX = Length of disk transfer in bytes
 21780                                  ;	ES:BP = Base of drive parameters
 21781                                  ;	[BYTSECPOS] = Byte position within first sector
 21782                                  ;	DS = DOSDATA
 21783                                  ; Outputs:
 21784                                  ;	[BYTCNT1] = Bytes to transfer in first sector
 21785                                  ;	[SECCNT] = No. of whole sectors to transfer
 21786                                  ;	[BYTCNT2] = Bytes to transfer in last sector
 21787                                  ; AX, BX, DX destroyed. No other registers affected.
 21788                                  ;---------------------------------------------------------------------------
 21789                                  
 21790                                  BREAKDOWN:
 21791 0000387A A1[CC05]                	MOV	AX,[BYTSECPOS]
 21792 0000387D 89CB                    	MOV	BX,CX
 21793 0000387F 09C0                    	OR	AX,AX
 21794 00003881 740E                    	JZ	short SAVFIR	; Partial first sector?
 21795                                  	;sub	ax,[es:bp+2]
 21796 00003883 262B4602                	SUB	AX,[ES:BP+DPB.SECTOR_SIZE]
 21797 00003887 F7D8                    	NEG	AX		; Max number of bytes left in first sector
 21798 00003889 29C3                    	SUB	BX,AX		; Subtract from total length
 21799 0000388B 7304                    	JAE	short SAVFIR
 21800 0000388D 01D8                    	ADD	AX,BX		; Don't use all of the rest of the sector
 21801 0000388F 31DB                    	XOR	BX,BX		; And no bytes are left
 21802                                  SAVFIR:
 21803 00003891 A3[D205]                	MOV	[BYTCNT1],AX
 21804 00003894 89D8                    	MOV	AX,BX
 21805 00003896 31D2                    	XOR	DX,DX
 21806                                  	;div	word [ES:BP+2]
 21807 00003898 26F77602                	DIV	word [ES:BP+DPB.SECTOR_SIZE]  ; How many whole sectors?
 21808 0000389C A3[D605]                	MOV	[SECCNT],AX
 21809 0000389F 8916[D405]              	MOV	[BYTCNT2],DX	; Bytes remaining for last sector
 21810                                  	; MSDOS 3.3
 21811                                  	;OR	DX,[BYTCNT1]	; SMR ONESECTORFIX BUGBUG
 21812                                  	;retnz			; NOT (BYTCNT1 = BYTCNT2 = 0)
 21813                                  	;CMP	AX,1
 21814                                  	;retnz
 21815                                  	;MOV	AX,[ES:BP+DPB.SECTOR_SIZE] ; Buffer EXACT one sector I/O
 21816                                  	;MOV	[BYTCNT2],AX
 21817                                  	;MOV	[SECCNT],DX	; DX = 0
 21818                                  _RET45:
 21819 000038A3 C3                      	retn
 21820                                  
 21821                                  ; DOSCODE:77BFh (MSDOS 6.21, MSDOS.SYS)
 21822                                  
 21823                                  ;----------------------------------------------------------------------------
 21824                                  ;
 21825                                  ; Procedure Name : READ_LOCK_VIOLATION
 21826                                  ;
 21827                                  ; ES:DI points to SFT. This entry used by NET_READ
 21828                                  ; Carry set if to return error (CX=0,AX=error_sharing_violation).
 21829                                  ; Else do retrys.
 21830                                  ; ES:DI,DS,CX preserved
 21831                                  ;
 21832                                  ;----------------------------------------------------------------------------
 21833                                  
 21834                                  READ_LOCK_VIOLATION:
 21835 000038A4 C606[7505]00            	MOV	byte [READOP],0
 21836                                  ERR_ON_CHECK:
 21837                                  	;;test	word [es:di+2],8000h
 21838                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 21839                                  	;JNZ	short HARD_ERR
 21840                                  
 21841                                  	; 04/05/2019
 21842                                  	;test	byte [es:di+3],80h
 21843 000038A9 26F6450380              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 21844 000038AE 7508                    	JNZ	short HARD_ERR
 21845                                  
 21846                                  	;PUSH	CX
 21847                                  	;;mov	cl,[es:di+2]
 21848                                  	;MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 21849                                  	;;and	cl,0F0h
 21850                                  	;AND	CL,SHARING_MASK
 21851                                  	;;cmp	cl,0
 21852                                  	;CMP	CL,SHARING_COMPAT
 21853                                  	;POP	CX
 21854                                  	;JNE	short NO_HARD_ERR
 21855                                  	; 21/09/2023
 21856 000038B0 268A4502                	mov	al,[ES:DI+SF_ENTRY.sf_mode]
 21857 000038B4 24F0                    	and	al,SHARING_MASK
 21858                                  	;cmp	al,SHARING_COMPAT
 21859                                  	;jne	short NO_HARD_ERR
 21860 000038B6 7505                    	jnz	short NO_HARD_ERR
 21861                                  HARD_ERR:
 21862 000038B8 E8773A                  	call	LOCK_VIOLATION
 21863 000038BB 73E6                    	jnc	short _RET45		; User wants Retrys
 21864                                  NO_HARD_ERR:
 21865 000038BD 31C9                    	XOR	CX,CX			;No bytes transferred
 21866                                  	;mov	ax,21h
 21867 000038BF B82100                  	MOV	AX,error_lock_violation
 21868 000038C2 F9                      	STC
 21869 000038C3 C3                      	retn
 21870                                  
 21871                                  ;----------------------------------------------------------------------------
 21872                                  ;
 21873                                  ; Procedure Name : WRITE_LOCK_VIOLATION
 21874                                  ;
 21875                                  ; Same as READ_LOCK_VIOLATION except for READOP.
 21876                                  ; This entry used by NET_WRITE
 21877                                  ;
 21878                                  ;----------------------------------------------------------------------------
 21879                                  
 21880                                  WRITE_LOCK_VIOLATION:
 21881 000038C4 C606[7505]01            	MOV	byte [READOP],1
 21882 000038C9 EBDE                    	JMP	short ERR_ON_CHECK
 21883                                  
 21884                                  ; 04/05/2019 - Retro DOS v4.0
 21885                                  
 21886                                  ; DOSCODE:77ECh (MSDOS 6.21, MSDOS.SYS)
 21887                                  
 21888                                  ;Break	<DISKREAD -- PERFORM USER DISK READ>
 21889                                  ;----------------------------------------------------------------------------
 21890                                  ;
 21891                                  ; Procedure Name : DISKREAD
 21892                                  ;
 21893                                  ; Inputs:
 21894                                  ;	Outputs of SETUP
 21895                                  ; Function:
 21896                                  ;	Perform disk read
 21897                                  ; Outputs:
 21898                                  ;    Carry clear
 21899                                  ;	CX = No. of bytes read
 21900                                  ;	ES:DI point to SFT
 21901                                  ;	SFT offset and cluster pointers updated
 21902                                  ;    Carry set
 21903                                  ;	CX = 0
 21904                                  ;	ES:DI point to SFT
 21905                                  ;	AX has error code
 21906                                  ;----------------------------------------------------------------------------
 21907                                  
 21908                                  ;hkn; called from disk.asm. DS already set up.
 21909                                  
 21910                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21911                                  ; DOSCODE:77D8h (MSDOS 5.0, MSDOS.SYS)
 21912                                  
 21913                                  DISKREAD:
 21914                                  	;mov	ax,[es:di+11h]
 21915 000038CB 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 21916                                  	;mov	bx,[es:di+13h]
 21917 000038CF 268B5D13                	MOV	BX,[ES:DI+SF_ENTRY.sf_size+2]
 21918 000038D3 2B06[CE05]              	SUB	AX,[BYTPOS]
 21919 000038D7 1B1E[D005]              	SBB	BX,[BYTPOS+2]
 21920 000038DB 7226                    	JB	short RDERR		;Read starts past EOF
 21921 000038DD 750A                    	JNZ	short ENUF		;More than 64k to EOF
 21922 000038DF 09C0                    	OR	AX,AX
 21923 000038E1 7420                    	JZ	short RDERR		;Read starts at EOF
 21924 000038E3 39C8                    	CMP	AX,CX
 21925 000038E5 7302                    	JAE	short ENUF		;I/O fits
 21926 000038E7 89C1                    	MOV	CX,AX			;Limit read to up til EOF
 21927                                  ENUF:
 21928                                  	; MSDOS 3.3
 21929                                  	;test	byte [es:di+4],8
 21930                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 21931                                  	;jnz	short SET_ACC_ERR
 21932                                  	;call	LOCK_CHECK
 21933                                  	;jnb	short _READ_OK
 21934                                  	;call	READ_LOCK_VIOLATION
 21935                                  	;jnb	short ENUF
 21936                                  	;retn
 21937                                  
 21938                                  	; MSDOS 6.0
 21939 000038E9 E87CFE                  	call	CHECK_READ_LOCK		;IFS. check read lock	;AN000;
 21940 000038EC 7301                    	JNC	short _READ_OK 		; There are no locks
 21941 000038EE C3                      	retn
 21942                                  
 21943                                  _READ_OK:
 21944 000038EF C42E[8A05]              	LES	BP,[THISDPB]
 21945 000038F3 E884FF                  	CALL	BREAKDOWN
 21946 000038F6 8B0E[BC05]              	MOV	CX,[CLUSNUM]
 21947                                  
 21948 000038FA E87013                  	call	FNDCLUS
 21949                                       	; MSDOS 6.0			;M022 conditional removed here
 21950 000038FD 720E                    	JC	short SET_ACC_ERR_DS	; fix to take care of I24 fail
 21951                                  					; migrated from 330a - HKN
 21952 000038FF 09C9                    	OR	CX,CX
 21953 00003901 7413                    	JZ	short SKIPERR
 21954                                  RDERR:
 21955 00003903 B40E                    	MOV	AH,0EH			;MS. read/data/fail ;AN000;
 21956 00003905 E92102                  	jmp	WRTERR22
 21957                                  
 21958                                  ;RDLASTJ: 
 21959                                  	;JMP	RDLAST                  ;M039
 21960                                  
 21961                                  SETSFTJ2: 
 21962 00003908 E99600                  	JMP	SETSFT
 21963                                  
 21964                                  CANOT_READ:
 21965                                  	; MSDOS 3.3
 21966                                  	;POP	CX		;M039.
 21967                                  	; MSDOS 3.3 & MSDOS 6.0
 21968 0000390B 59                      	POP	CX              ;Clean stack.
 21969 0000390C 5B                      	POP	BX
 21970                                  
 21971                                  	;entry	SET_ACC_ERR_DS
 21972                                  SET_ACC_ERR_DS:
 21973                                  
 21974                                  ;hkn; SS is DOSDATA
 21975                                  	;Context DS
 21976 0000390D 16                      	push	ss
 21977 0000390E 1F                      	pop	ds
 21978                                  
 21979                                  	;entry	SET_ACC_ERR
 21980                                  SET_ACC_ERR:
 21981 0000390F 31C9                    	XOR	CX,CX
 21982                                  	;mov	ax,5
 21983 00003911 B80500                  	MOV	AX,error_access_denied
 21984 00003914 F9                      	STC
 21985 00003915 C3                      	retn
 21986                                  
 21987                                  SKIPERR:
 21988 00003916 8916[BA05]              	MOV	[LASTPOS],DX
 21989 0000391A 891E[BC05]              	MOV	[CLUSNUM],BX
 21990 0000391E 833E[D205]00            	CMP	word [BYTCNT1],0
 21991 00003923 7405                    	JZ	short RDMID
 21992                                  
 21993 00003925 E8BB13                  	call	BUFRD
 21994 00003928 72E3                    	JC	short SET_ACC_ERR_DS
 21995                                  
 21996                                  RDMID:
 21997 0000392A 833E[D605]00            	CMP	word [SECCNT],0
 21998                                  	;JZ	RDLAST ; 10/08/2018
 21999 0000392F 7453                    	jz	short RDLAST
 22000                                  
 22001 00003931 E84414                  	call	NEXTSEC
 22002 00003934 72D2                    	JC	short SETSFTJ2
 22003                                  
 22004 00003936 C606[7405]01            	MOV	BYTE [TRANS],1		; A transfer is taking place
 22005                                  ONSEC:
 22006 0000393B 8A16[7305]              	MOV	DL,[SECCLUSPOS]	; (dx/DL = Extent start) ((dh = ?))
 22007 0000393F 8B0E[D605]              	MOV	CX,[SECCNT]
 22008 00003943 8B1E[BC05]              	MOV	BX,[CLUSNUM]
 22009                                  RDLP:
 22010 00003947 E85F14                  	call	OPTIMIZE
 22011 0000394A 72C1                    	JC	short SET_ACC_ERR_DS
 22012                                  
 22013 0000394C 57                      	PUSH	DI                      ;DI = Next physical cluster.
 22014 0000394D 50                      	PUSH	AX                      ;AX = # of sectors remaining.
 22015 0000394E 53                      	PUSH	BX			;[DMAADD+2]:BX = Transfer address.
 22016                                  	;mov	byte [ALLOWED],38h
 22017 0000394F C606[4B03]38            	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 22018 00003954 8E1E[2E03]              	MOV	DS,[DMAADD+2]
 22019                                  
 22020 00003958 52                      	PUSH	DX                      ;[HIGH_SECTOR]:DX = phys. sector #.
 22021 00003959 51                      	PUSH	CX                      ;CX = # of contiguous sectors to read.
 22022                                  
 22023                                  	; 04/05/2019 - Retro DOS v4.0
 22024                                  
 22025                                  	; MSDOS 6.0
 22026 0000395A E80222                  	call	SET_RQ_SC_PARMS		;LB. do this for SC ;AN000;
 22027                                  
 22028                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22029 0000395D E8CFFD                  	call	DREAD
 22030                                  
 22031                                  	; MSDOS 3.3 
 22032                                  	;pop	bx
 22033                                  	;pop	dx
 22034                                  	;jc	short CANOT_READ
 22035                                  	;add	bx,dx	; (bx = Extent end)
 22036                                  	;mov	al,[es:bp] ; mov al,[es:bp+0]
 22037                                  	;;mov	al,[ES:BP+DPB.DRIVE] 
 22038                                  	;call	SETVISIT
 22039                                  	; ->***
 22040                                  ;M039
 22041                                  	; MSDOS 6.0 
 22042 00003960 59                      	pop	cx
 22043 00003961 5A                      	pop	dx
 22044 00003962 368F06[0C06]            	pop	WORD [ss:TEMP_VAR]
 22045 00003967 72A2                    	jc	short CANOT_READ
 22046                                  
 22047 00003969 368C1E[0E06]            	mov	[ss:TEMP_VAR2],ds
 22048                                  
 22049                                  ;       CX = # of contiguous sectors read. (These constitute a block of
 22050                                  ;            sectors, also termed an "Extent".)
 22051                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 22052                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 22053                                  ;       ES:BP -> Drive Parameter Block (DPB).
 22054                                  ;
 22055                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
 22056                                  ;	buffers must be "read" into the transfer memory block, so that the
 22057                                  ;       transfer memory reflects the most recent data.
 22058                                  
 22059 0000396E E85E00                  	call	DskRdBufScan
 22060                                  
 22061                                  	;Context DS
 22062 00003971 16                      	push	ss
 22063 00003972 1F                      	pop	ds
 22064                                          
 22065 00003973 59                      	pop	cx
 22066 00003974 5B                              pop	bx
 22067                                  
 22068                                  ;       CX = # of sector remaining.
 22069                                  ;       BX = Next physical cluster.
 22070                                  
 22071                                  ;M039
 22072                                  
 22073                                  ;;;;;;;;
 22074                                  ;	; 25/07/2018 - Retro DOS v3.0
 22075                                  ;	; ***->
 22076                                  ;	; MSDOS 3.3
 22077                                  ;	; IBMDOS.COM (1987) - Offset 42BDh
 22078                                  ;bufq:
 22079                                  ;;	DX = Extent start.
 22080                                  ;;	BX = Extent end.
 22081                                  ;;	 AL = Drive #.
 22082                                  ;;     DS:DI-> 1st buffer in queue.
 22083                                  ;
 22084                                  ;	;or	byte [di+5],20h
 22085                                  ;	or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 22086                                  ;	;cmp	al,[di+4]	
 22087                                  ;	cmp	al,[DI+BUFFINFO.buf_ID]
 22088                                  ;	jnz	short bufq3
 22089                                  ;	;cmp	[di+6],dx
 22090                                  ;	cmp	[DI+BUFFINFO.buf_sector],dx
 22091                                  ;	jb	short bufq3	; Jump if Extent start > buffer sector.
 22092                                  ;	;cmp	[di+6],bx
 22093                                  ;	cmp	[DI+BUFFINFO.buf_sector],bx
 22094                                  ;	jnb	short bufq3	; Jump if Extent end >= buffer sector.
 22095                                  ;	
 22096                                  ;	; Buffer sector is in the Extent (contiguous sectors to read)
 22097                                  ;
 22098                                  ;;      Buffer's sector is in Extent: if it is dirty, copy its contents to
 22099                                  ;;      transfer memory; otherwise, just re-position it in the buffer queue
 22100                                  ;;      as MRU (Most Recently Used).
 22101                                  ;
 22102                                  ;	;test	byte [di+5],40h
 22103                                  ;	test	byte [DI+BUFFINFO.buf_flags],buf_dirty ; Bit 6 = dirty flag
 22104                                  ;	jz	short bufq2	; clear buffer, check the next buff sec
 22105                                  ;	pop	ax ; transfer address
 22106                                  ;	push	ax
 22107                                  ;	push	di
 22108                                  ;	push	dx
 22109                                  ;	;sub	dx,[di+6]
 22110                                  ;	sub	dx,[DI+BUFFINFO.buf_sector]
 22111                                  ;	neg	dx
 22112                                  ;
 22113                                  ;;      DX = offset (in sectors) of buffer sector within Transfer memory
 22114                                  ;;           block.
 22115                                  ;
 22116                                  ;	mov	si,di
 22117                                  ;	mov	di,ax
 22118                                  ;	mov	ax,dx
 22119                                  ;	;mov	cx,[es:bp+6]	
 22120                                  ;	mov     cx,[ES:BP+DPB.SECTOR_SIZE] ; CX = sector size (in bytes).
 22121                                  ;	mul	cx
 22122                                  ;	add	di,ax
 22123                                  ;
 22124                                  ;	lea	si,[si+16]
 22125                                  ;	lea	si,[SI+BUFINSIZ] ;DS:SI -> buffer data.
 22126                                  ;	shr	cx,1
 22127                                  ;	push	es
 22128                                  ;	mov	es,[SS:DMAADD+2]
 22129                                  ;
 22130                                  ;;      CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 22131                                  ;;      DS:SI-> Buffer sector data.
 22132                                  ;;      ES:DI-> Destination within Transfer memory block.
 22133                                  ;
 22134                                  ;	rep	movsw			;Copy buffer sector to Transfer memory
 22135                                  ;	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 22136                                  ;	;rep	movsb                   ;Copy last byte.
 22137                                  ;	jnc	short bufq1
 22138                                  ;	movsb
 22139                                  ;bufq1:
 22140                                  ;	pop	es
 22141                                  ;	pop	dx
 22142                                  ;	pop	di
 22143                                  ;	mov	al,[es:bp]  ; mov al,[es:bp+0]
 22144                                  ;	;mov	al,[ES:BP+DPB.DRIVE]
 22145                                  ;bufq2:
 22146                                  ;	call	SCANPLACE
 22147                                  ;bufq3:
 22148                                  ;	call	SKIPVISIT
 22149                                  ;	jnz	short bufq
 22150                                  ;	
 22151                                  ;	push	ss
 22152                                  ;	pop	ds
 22153                                  ;	pop	cx
 22154                                  ;	pop	cx
 22155                                  ;	pop	bx	
 22156                                  ;bufq4:
 22157                                  ;;;;;;;
 22158 00003975 E30D                    	JCXZ	RDLAST
 22159                                  
 22160 00003977 E8CD1B                  	call	IsEOF			; test for eof on fat size
 22161 0000397A 7325                    	JAE	short SETSFT
 22162                                  
 22163 0000397C B200                    	MOV	DL,0
 22164 0000397E FF06[BA05]              	INC	word [LASTPOS]		; We'll be using next cluster
 22165 00003982 EBC3                    	JMP	short RDLP ; 19/05/2019
 22166                                  
 22167                                  RDLAST:
 22168 00003984 A1[D405]                	MOV	AX,[BYTCNT2]
 22169 00003987 09C0                    	OR	AX,AX
 22170 00003989 7416                    	JZ	short SETSFT
 22171 0000398B A3[D205]                	MOV	[BYTCNT1],AX
 22172                                  
 22173 0000398E E8E713                  	call	NEXTSEC
 22174 00003991 720E                    	JC	short SETSFT
 22175                                  
 22176 00003993 C706[CC05]0000          	MOV	word [BYTSECPOS],0
 22177 00003999 E84713                  	call	BUFRD
 22178                                  	; 10/08/2018
 22179                                  
 22180 0000399C 7303                    	JNC	short SETSFT
 22181 0000399E E96CFF                  	JMP	SET_ACC_ERR_DS
 22182                                  
 22183                                  ;------------------------------------------------------------------------------
 22184                                  ;
 22185                                  ; Procedure Name : SETSFT
 22186                                  ; Inputs:
 22187                                  ;	[NEXTADD],[CLUSNUM],[LASTPOS] set to determine transfer size
 22188                                  ;		and set cluster fields
 22189                                  ; Function:
 22190                                  ;	Update [THISSFT] based on the transfer
 22191                                  ; Outputs:
 22192                                  ;	sf_position, sf_lstclus, and sf_cluspos updated
 22193                                  ;	ES:DI points to [THISSFT]
 22194                                  ;	CX No. of bytes transferred
 22195                                  ;	Carry clear
 22196                                  ;
 22197                                  ;----------------------------------------------------------------------------
 22198                                  
 22199                                  	;entry	SETSFT
 22200                                  
 22201                                  ; 26/07/2018 - Retro DOS v3.0
 22202                                  SETSFT:
 22203 000039A1 C43E[9E05]              	LES	DI,[THISSFT]
 22204                                  
 22205                                  ; Same as SETSFT except ES:DI already points to SFT
 22206                                  	;entry	SETCLUS
 22207                                  SETCLUS:	
 22208 000039A5 8B0E[B805]              	MOV	CX,[NEXTADD]
 22209 000039A9 2B0E[2C03]              	SUB	CX,[DMAADD]		; Number of bytes transfered
 22210                                  	;;test	word [es:di+5],80h
 22211                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 22212                                  	;JNZ	short ADDREC		; don't set clusters if device
 22213                                  
 22214                                  	; 04/05/2019 - Retro DOS v4.0
 22215                                  	;test	byte [es:di+5],80h
 22216 000039AD 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 22217 000039B2 750E                    	JNZ	short ADDREC		; don't set clusters if device
 22218                                  
 22219 000039B4 A1[BC05]                	MOV	AX,[CLUSNUM]
 22220                                  	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
 22221                                  	;mov	[es:di+35h],ax ; MSDOS 6.0 (& MSDOS 6.21)
 22222 000039B7 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 22223 000039BB A1[BA05]                	MOV	AX,[LASTPOS]
 22224                                  	;mov	[es:di+19h],ax
 22225 000039BE 26894519                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],AX
 22226                                  
 22227                                  ;----------------------------------------------------------------------------
 22228                                  ;
 22229                                  ; Procedure : AddRec
 22230                                  ; Inputs:
 22231                                  ;	ES:DI points to SFT
 22232                                  ;	CX is No. Bytes transferred
 22233                                  ; Function:
 22234                                  ;	Update the SFT offset based on the transfer
 22235                                  ; Outputs:
 22236                                  ;	sf_position updated to point to first byte after transfer
 22237                                  ;	ES:DI points to SFT
 22238                                  ;	CX No. of bytes transferred
 22239                                  ;	Carry clear
 22240                                  ;----------------------------------------------------------------------------
 22241                                  
 22242                                  	;entry	AddRec
 22243                                  ADDREC:
 22244 000039C2 E309                    	JCXZ	RET28		; If no records read,  don't change position
 22245                                  	;add	[es:di+15h],cx
 22246 000039C4 26014D15                	ADD	[ES:DI+SF_ENTRY.sf_position],CX  ; Update current position
 22247                                  	;adc	word [es:di+17h], 0
 22248 000039C8 2683551700              	ADC	WORD [ES:DI+SF_ENTRY.sf_position+2],0
 22249                                  RET28:	
 22250 000039CD F8                      	CLC
 22251 000039CE C3                      	retn
 22252                                  
 22253                                  ; 25/07/2018
 22254                                  ; MSDOS 6.0
 22255                                  ;Break   <DskRdBufScan -- Disk Read Buffer Scan>
 22256                                  ;----------------------------------------------------------------------------
 22257                                  ;
 22258                                  ; Procedure Name : DskRdBufScan
 22259                                  ;
 22260                                  ; Inputs:
 22261                                  ;       CX = # of contiguous sectors read. (These constitute a block of
 22262                                  ;            sectors, also termed an "Extent".)
 22263                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 22264                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 22265                                  ;       ES:BP -> Drive Parameter Block (DPB).
 22266                                  ;
 22267                                  ; Function:
 22268                                  ;	The Buffer Queue is scanned: the contents of any dirty buffers are
 22269                                  ;	"read" into the transfer memory block, so that the transfer memory
 22270                                  ;	reflects the most recent data.
 22271                                  ;
 22272                                  ; Outputs:
 22273                                  ;       Transfer memory updated as required.
 22274                                  ;
 22275                                  ; Uses:
 22276                                  ;       DS,AX,BX,CX,SI,DI destroyed.
 22277                                  ;       SS override for all global variables.
 22278                                  ;
 22279                                  ; Notes:
 22280                                  ;       FIRST_BUFF_ADDR is set-up to contain the LAST buffer to check, rather
 22281                                  ;	than the FIRST.
 22282                                  ;----------------------------------------------------------------------------
 22283                                  ;M039: Created
 22284                                  
 22285                                  ; 04/05/2019 - Retro DOS v4.0
 22286                                  ; DOSCODE:78F0h (MSDOS 6.21, MSDOS.SYS)
 22287                                  
 22288                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22289                                  ; DOSCODE:78DCh (MSDOS 5.0, MSDOS.SYS) 
 22290                                  
 22291                                  ;procedure DskRdBufScan,NEAR
 22292                                  ;
 22293                                  ;ASSUME  DS:NOTHING
 22294                                  
 22295                                  DskRdBufScan:
 22296 000039CF 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0 ; Any dirty buffers?
 22297 000039D5 743C                    	je	short bufx		     ; -no, skip all work.
 22298                                  
 22299 000039D7 368B1E[0706]            	mov     bx,[ss:HIGH_SECTOR]
 22300 000039DC 89DE                    	mov     si,bx
 22301 000039DE 01D1                    	add     cx,dx
 22302 000039E0 83D600                  	adc     si,0
 22303                                  
 22304 000039E3 E8111F                  	call	GETCURHEAD		;DS:DI -> 1st buf in queue.
 22305                                  	;mov	ax,[di+2]
 22306 000039E6 8B4502                  	mov     ax,[di+BUFFINFO.buf_prev]
 22307 000039E9 36A3[BB0E]              	mov     [ss:FIRST_BUFF_ADDR],ax
 22308                                  		
 22309                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22310                                  	;;mov	al,[es:bp+0]
 22311                                  	;mov	al,[es:bp+DPB.DRIVE]
 22312                                  	; 15/12/2022
 22313 000039ED 268A4600                	mov	al,[es:bp]
 22314                                  
 22315                                  ;       BX:DX = Extent start.
 22316                                  ;       SI:CX = Extent end + 1.
 22317                                  ;          AL = Drive #.
 22318                                  ;       DS:DI-> 1st buffer in queue.
 22319                                  ;[FIRST_BUFF_ADDR] = Address offset of last buffer in queue.
 22320                                  
 22321                                  bufq:	
 22322                                  	;cmp	al,[di+4]
 22323 000039F1 3A4504                  	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
 22324 000039F4 7514                    	jne	short bufq1        	;  -no, jump.
 22325                                  
 22326                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 22327                                  ;       ja	short bufq1		;Jump if Extent start > buffer sector.
 22328                                  
 22329                                  	;cmp	bx,[di+8]
 22330 000039F6 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 22331 000039F9 7503                    	jne	short bufq01
 22332                                  	;cmp	dx,[di+6]
 22333 000039FB 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 22334                                  bufq01:
 22335 000039FE 770A                    	ja	short bufq1
 22336                                  
 22337                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 22338                                  ;       ja	short bufq2		;Jump if Extent end >= buffer sector.
 22339                                  
 22340                                  	;cmp	si,[di+8]
 22341 00003A00 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 22342 00003A03 7503                    	jne	short bufq02
 22343                                  	;cmp	cx,[di+6]
 22344 00003A05 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 22345                                  bufq02:
 22346 00003A08 770A                    	ja	short bufq2
 22347                                  bufq1:	
 22348 00003A0A 363B3E[BB0E]            	cmp     di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
 22349 00003A0F 8B3D                    	mov	di,[di]
 22350                                  	;mov	di,[di+BUFFINFO.buf_next] ; Set-up for next buffer.
 22351 00003A11 75DE                    	jne	short bufq		; -no, do next buffer
 22352                                  bufx:
 22353 00003A13 C3                      	retn				;Exit.
 22354                                  
 22355                                  ;       Buffer's sector is in Extent: if it is dirty, copy its contents to
 22356                                  ;	transfer memory; otherwise, just re-position it in the buffer queue
 22357                                  ;       as MRU (Most Recently Used).
 22358                                  
 22359                                  bufq2:	
 22360 00003A14 50                      	push	ax
 22361                                  	;test	byte [di+5],40h
 22362 00003A15 F6450540                	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
 22363 00003A19 742D                    	jz	short bufq3                    ; -no, jump.
 22364                                  
 22365                                  ;       SaveReg <cx,dx,si,di,es>
 22366 00003A1B 51                      	push	cx
 22367 00003A1C 52                      	push	dx
 22368 00003A1D 56                      	push	si
 22369 00003A1E 57                      	push	di
 22370 00003A1F 06                      	push	es
 22371                                  
 22372 00003A20 89D0                    	mov     ax,dx
 22373                                  	;sub	ax,[di+6]
 22374 00003A22 2B4506                  	sub	ax,[di+BUFFINFO.buf_sector]
 22375 00003A25 F7D8                    	neg	ax
 22376                                  
 22377                                  ;       AX = offset (in sectors) of buffer sector within Transfer memory
 22378                                  ;            block. (Note: the upper word of the sector # may be ignored
 22379                                  ;	     since no more than 64k bytes will ever be read. This 64k limit
 22380                                  ;            is imposed by the input parameters of the disk read operation.)
 22381                                  
 22382                                  	;lea	si,[di+20]
 22383 00003A27 8D7514                  	lea	si,[di+BUFINSIZ]	;DS:SI -> buffer data.
 22384                                  	;mov	cx,[es:bp+2]
 22385 00003A2A 268B4E02                	mov     cx,[es:bp+DPB.SECTOR_SIZE] ;CX = sector size (in bytes).
 22386 00003A2E F7E1                    	mul     cx			;AX = offset (in bytes) of buf. sector
 22387 00003A30 368B3E[0C06]            	mov     di,[ss:TEMP_VAR]
 22388 00003A35 01C7                    	add	di,ax
 22389 00003A37 368E06[0E06]            	mov	es,[ss:TEMP_VAR2]
 22390 00003A3C D1E9                    	shr	cx,1
 22391                                  
 22392                                  ;	   CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 22393                                  ;       DS:SI-> Buffer sector data.
 22394                                  ;       ES:DI-> Destination within Transfer memory block.
 22395                                  
 22396 00003A3E F3A5                    	rep	movsw			;Copy buffer sector to Transfer memory
 22397                                  	;; 04/05/2019
 22398                                  	;;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 22399                                  	;;rep	movsb                   ;Copy last byte.
 22400                                  	;jnc	short bufq03	
 22401                                  	;movsb
 22402                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22403                                  	;adc	cx,0
 22404                                  	;rep	movsb
 22405                                  	; 22/09/2023
 22406 00003A40 7301                    	jnc	short bufq03
 22407 00003A42 A4                      	movsb
 22408                                  bufq03:
 22409                                  	;RestoreReg <es,di,si,dx,cx>
 22410 00003A43 07                      	pop	es
 22411 00003A44 5F                      	pop	di
 22412 00003A45 5E                      	pop	si
 22413 00003A46 5A                      	pop	dx
 22414 00003A47 59                      	pop	cx
 22415                                  
 22416                                  ;       DS:DI -> current buffer.
 22417                                  bufq3:	
 22418 00003A48 89F8                    	mov     ax,di			;DS:AX -> Current buffer.
 22419                                          ;invoke SCANPLACE
 22420 00003A4A E8BC1E                  	call	SCANPLACE
 22421 00003A4D 363B06[BB0E]            	cmp	ax,[ss:FIRST_BUFF_ADDR] ;Last buffer?
 22422 00003A52 58                      	pop	ax
 22423                                  	;jne	short bufq		; -no, jump.
 22424                                  	;;jmp	short bufx		; -yes, exit.
 22425                                  	;; 12/06/2019
 22426                                  	;retn
 22427                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compability)
 22428 00003A53 759C                    	jne	short bufq
 22429 00003A55 EBBC                    	jmp	short bufx
 22430                                  
 22431                                  ;EndProc DskRdBufScan
 22432                                  
 22433                                  ;============================================================================
 22434                                  ; DISK3.ASM, MSDOS 6.0, 1991
 22435                                  ;============================================================================
 22436                                  ; 04/05/2019 - Retro DOS v4.0
 22437                                  ; 24/07/2018 - Retro DOS v3.0
 22438                                  
 22439                                  ;Break   <DISKWRITE -- PERFORM USER DISK WRITE>
 22440                                  ;----------------------------------------------------------------------------
 22441                                  ;
 22442                                  ; Procedure Name : DISKWRITE
 22443                                  ;
 22444                                  ; Inputs:
 22445                                  ;       Outputs of SETUP
 22446                                  ; Function:
 22447                                  ;       Perform disk write
 22448                                  ; Outputs:
 22449                                  ;    Carry clear
 22450                                  ;       CX = No. of bytes written
 22451                                  ;       ES:DI point to SFT
 22452                                  ;       SFT offset and cluster pointers updated
 22453                                  ;    Carry set
 22454                                  ;       CX = 0
 22455                                  ;       ES:DI point to SFT
 22456                                  ;       AX has error code
 22457                                  ;----------------------------------------------------------------------------
 22458                                  
 22459                                  ;hkn; called by DOS_WRITE. DS already set up at this point.
 22460                                  
 22461                                  ; DOSCODE:797Ah (MSDOS 6.21, MSDOS.SYS)
 22462                                  
 22463                                  ; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22464                                  ; DOSCODE:7966h (MSDOS 5.0, MSDOS.SYS) 
 22465                                  
 22466                                  DISKWRITE:
 22467                                  	; MSDOS 3.3
 22468                                  	; IBMDOS.COM - Offset 436Dh
 22469                                  	;;test	byte [es:di+4],8
 22470                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 22471                                  	;jz	short write_cont
 22472                                  	;jmp	SET_ACC_ERR_DS
 22473                                  ;write_cont:
 22474                                  	;push	cx
 22475                                  	;or	cx,cx
 22476                                  	;jnz	short Not_Truncate
 22477                                  	;;mov	cx,-1
 22478                                  	;dec	cx
 22479                                  ;Not_Truncate:
 22480                                  	;call	LOCK_CHECK
 22481                                  	;pop	cx
 22482                                  	;jnb	short _WRITE_OK
 22483                                  	;call	WRITE_LOCK_VIOLATION
 22484                                  	;jnb	short DISKWRITE
 22485                                  	;retn
 22486                                  
 22487                                  	; MSDOS 6.0
 22488 00003A57 E8F0FC                  	call	CHECK_WRITE_LOCK	;IFS. check write lock	;AN000;
 22489                                  	; 19/08/2018
 22490 00003A5A 7304                    	JNC	short _WRITE_OK		;IFS. lock check ok	;AN000;
 22491 00003A5C C3                      	retn
 22492                                  
 22493                                  WRTEOFJ:
 22494 00003A5D E9DC01                  	JMP     WRTEOF
 22495                                  
 22496                                  _WRITE_OK:
 22497                                   	; 27/07/2018
 22498                                  	; IBMDOS.COM - Offset 438Eh
 22499                                  	
 22500                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22501                                  	;and	word [es:di+5],0BFBFh
 22502 00003A60 26816505BFBF            	AND     word [ES:DI+SF_ENTRY.sf_flags],~(sf_close_nodate|devid_file_clean)
 22503                                  				; Mark file as dirty, clear no date on close
 22504                                  
 22505                                  	; 04/05/2019 - Retro DOS v4.0	
 22506                                  
 22507                                  	; MSDOS 6.0
 22508                                  	; mov 	ax,[es:di+11h]
 22509 00003A66 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]		;M039
 22510 00003A6A A3[0C06]                        MOV	[TEMP_VAR],AX                           ;M039
 22511                                  	;mov	ax,[es:di+13h]
 22512 00003A6D 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]		;M039
 22513 00003A71 A3[0E06]                        MOV	[TEMP_VAR2],AX                          ;M039
 22514                                  
 22515                                  ;	TEMP_VAR2:TEMP_VAR = Current file size (sf_size);M039
 22516                                  
 22517                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22518 00003A74 C42E[8A05]              	LES     BP,[THISDPB]
 22519                                  
 22520 00003A78 E8FFFD                  	call	BREAKDOWN
 22521                                  
 22522 00003A7B A1[CE05]                	MOV     AX,[BYTPOS]
 22523 00003A7E 8B16[D005]              	MOV     DX,[BYTPOS+2]
 22524 00003A82 E3D9                    	JCXZ    WRTEOFJ                 ;Make the file length = sf_position
 22525 00003A84 01C8                    	ADD     AX,CX
 22526 00003A86 83D200                  	ADC     DX,0                    ;DX:AX = last byte to write + 1.
 22527                                  
 22528                                  	;mov	bx,[es:bp+2]
 22529 00003A89 268B5E02                	MOV     BX,[ES:BP+DPB.SECTOR_SIZE]
 22530                                  
 22531                                  	; MSDOS 3.3
 22532                                  	;cmp	dx,bx
 22533                                  	;jnb	short WRTERR33
 22534                                  	;div	bx
 22535                                  	;mov	bx,ax
 22536                                  	;OR	DX,DX
 22537                                  	;JNZ	short CALCLUS
 22538                                  	;dec	ax
 22539                                  ;CALCLUS:
 22540                                  	; MSDOS 3.3
 22541                                  	;mov	cl,[es:bp+5]
 22542                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 22543                                  	;shr	ax,cl
 22544                                  	;push	ax
 22545                                  	;push	dx
 22546                                  	;push	es
 22547                                  	;les	di,[THISSFT]
 22548                                  	;;mov	ax,[es:di+11h]
 22549                                  	;;mov	dx,[es:di+13h]
 22550                                  	;mov	ax,[ES:DI+SF_ENTRY.sf_size]
 22551                                  	;mov	dx,[ES:DI+SF_ENTRY.sf_size+2]
 22552                                  	;pop	es
 22553                                  	;;DX:AX = current file size (in bytes).
 22554                                  	;;div	word [es:bp+2]
 22555                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 22556                                  	;mov	cx,ax
 22557                                  	;or	dx,dx
 22558                                  	;jz	short NORND
 22559                                  	;inc	ax
 22560                                  ;NORND:
 22561                                  	; MSDOS 6.0
 22562 00003A8D E8DC02                  	CALL	DIV32                   ;DX:AX/BX = CX:AX + DX (rem.).
 22563 00003A90 89C6                    	MOV	SI,AX
 22564 00003A92 890E[0706]                      MOV	[HIGH_SECTOR],CX
 22565                                  
 22566                                  ;       [HIGH_SECTOR]:SI = Last full sector to write.
 22567                                  
 22568 00003A96 09D2                    	OR	DX,DX
 22569 00003A98 52                      	PUSH	DX			;M039: Free DX for use by SHR32
 22570 00003A99 89CA                    	MOV	DX,CX			;M039
 22571 00003A9B 7506                    	JNZ	short CALCLUS
 22572 00003A9D 83E801                  	SUB	AX,1                    ;AX must be zero base indexed	;AC000;
 22573 00003AA0 83DA00                  	SBB	DX,0			;M039 ;F.C. >32mb		;AN000;
 22574                                  
 22575                                  CALCLUS:
 22576                                  	; MSDOS 6.0
 22577 00003AA3 E8ED02                  	CALL	SHR32                   ;F.C. >32mb			;AN000;
 22578 00003AA6 5A                      	POP	DX
 22579                                  
 22580                                  ;       AX = Last cluster to write.
 22581                                  ;       DX = # of bytes in last sector to write (the "tail").
 22582                                  ;       BX = [ES:BP+DPB.SECTOR_SIZE]
 22583                                  
 22584 00003AA7 50                      	PUSH	AX
 22585 00003AA8 52                      	PUSH	DX
 22586                                  ;M039
 22587 00003AA9 8B16[0E06]              	mov	dx,[TEMP_VAR2]
 22588 00003AAD A1[0C06]                	mov	ax,[TEMP_VAR]           ;DX:AX = current file size (in bytes).
 22589 00003AB0 E8B902                  	call	DIV32           	;DX:AX/BX = CX:AX + DX (rem.)
 22590 00003AB3 890E[0E06]              	mov	[TEMP_VAR2],cx
 22591 00003AB7 890E[CA05]              	mov	[VALSEC+2],cx
 22592 00003ABB 89C1                    	mov	cx,ax
 22593 00003ABD 89F3                    	mov	bx,si
 22594                                  
 22595                                  ;       [HIGH_SECTOR]:BX = Last full sector to write.
 22596                                  ;          [VALSEC+2]:CX = Last full sector of current file.
 22597                                  ;         [TEMP_VAR2]:CX = Last full sector of current file.
 22598                                  ;                     DX = # of bytes in last sector of current file.
 22599                                  ;M039
 22600 00003ABF 09D2                    	OR	DX,DX
 22601 00003AC1 7407                    	JZ	short NORND
 22602                                  	;ADD	AX,1            	;Round up if any remainder	;AC000;
 22603                                  	;ADC	word [VALSEC+2],0
 22604                                  	; 22/09/2023
 22605 00003AC3 40                      	inc	ax  ; 0FFFFh -> 0
 22606 00003AC4 7504                    	jnz	short NORND
 22607 00003AC6 FF06[CA05]              	inc	word [VALSEC+2]
 22608                                  NORND:	
 22609                                  	; MSDOS 3.3 & MSDOS 6.0
 22610 00003ACA A3[C805]                	MOV     [VALSEC],AX
 22611                                  
 22612                                  ;       [VALSEC] = Last sector of current file.
 22613                                  
 22614 00003ACD 31C0                    	XOR     AX,AX
 22615 00003ACF A3[DE05]                	MOV     [GROWCNT],AX
 22616 00003AD2 A3[E005]                	MOV     [GROWCNT+2],AX
 22617 00003AD5 58                      	POP     AX
 22618                                  
 22619                                  	; MSDOS 6.0
 22620 00003AD6 8B3E[0706]              	MOV	DI,[HIGH_SECTOR]        ;F.C. >32mb			;AN000;
 22621 00003ADA 3B3E[0E06]              	CMP	DI,[TEMP_VAR2]		;M039; F.C. >32mb		;AN000;
 22622 00003ADE 7263                    	JB	short NOGROW		;F.C. >32mb                     ;AN000;
 22623 00003AE0 7408                    	JZ	short lowsec		;F.C. >32mb                     ;AN000;
 22624 00003AE2 29CB                    	SUB	BX,CX                   ;F.C. >32mb                     ;AN000;
 22625 00003AE4 1B3E[0E06]              	SBB	DI,[TEMP_VAR2]   	;M039; F.C. >32mb di:bx no. of sectors ;AN000;
 22626 00003AE8 EB08                    	JMP	short yesgrow           ;F.C. >32mb                     ;AN000;
 22627                                  lowsec:
 22628                                  	;MOV	DI,0			;F.C. >32mb
 22629                                  	; 22/09/2023
 22630 00003AEA 31FF                    	xor	di,di
 22631                                  	; MSDOS 3.3 & MSDOS 6.0
 22632 00003AEC 29CB                    	SUB	BX,CX			; Number of full sectors
 22633 00003AEE 7253                    	JB	short NOGROW
 22634 00003AF0 7444                    	JZ	short TESTTAIL
 22635                                  yesgrow:
 22636                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22637 00003AF2 89D1                    	MOV     CX,DX
 22638 00003AF4 93                      	XCHG    AX,BX
 22639                                  	;mul	word [es:bp+2]
 22640 00003AF5 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]  ; Bytes of full sector growth
 22641                                  	
 22642                                  	; MSDOS 6.0
 22643 00003AF9 8916[0706]              	MOV	[HIGH_SECTOR],DX         ;F.C. >32mb save dx                    ;AN000;
 22644 00003AFD A3[0E06]                	MOV	[TEMP_VAR2],AX    	 ;M039; F.C. >32mb save ax		;AN000;
 22645 00003B00 89F8                    	MOV	AX,DI                    ;F.C. >32mb                            ;AN000;
 22646                                  	;mul	word [es:bp+2]
 22647 00003B02 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE] ;F.C. >32mb do higher word multiply ;AN000;
 22648                                  	
 22649 00003B06 0306[0706]              	ADD	AX,[HIGH_SECTOR]         ;F.C. >32mb add lower value            ;AN000;
 22650 00003B0A 89C2                    	MOV	DX,AX                    ;F.C. >32mb DX:AX is the result of     ;AN000;
 22651 00003B0C A1[0E06]                	MOV	AX,[TEMP_VAR2]    	 ;M039; F.C. >32mb a 32 bit multiply	;AN000;
 22652                                  
 22653                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22654 00003B0F 29C8                    	SUB     AX,CX			; Take off current "tail"
 22655 00003B11 83DA00                  	SBB     DX,0			; 32-bit extension
 22656 00003B14 01D8                    	ADD     AX,BX			; Add on new "tail"
 22657 00003B16 83D200                  	ADC     DX,0			; ripple tim's head off
 22658 00003B19 EB21                    	JMP     SHORT SETGRW
 22659                                  
 22660                                  HAVSTART:
 22661                                  	;int 3
 22662 00003B1B 89C1                    	MOV     CX,AX
 22663 00003B1D E86D11                  	call	SKPCLP
 22664                                  	;JCXZ	DOWRTJ
 22665                                  	; 16/12/2022
 22666 00003B20 E357                    	jcxz	DOWRT
 22667                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22668                                  	;jcxz	DOWRTJ
 22669                                  
 22670 00003B22 E80F13                  	call	ALLOCATE
 22671                                  	;JNC	short DOWRTJ
 22672                                  	; 16/12/2022
 22673 00003B25 7352                    	jnc	short DOWRT
 22674                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22675                                  	;jnc	short DOWRTJ
 22676                                  
 22677                                  	;entry   WRTERR
 22678                                  WRTERR:
 22679 00003B27 B40F                    	MOV     AH,0FH			;MS. write/data/fail/abort      ;AN000;
 22680                                  
 22681                                  	;entry WRTERR22
 22682                                  WRTERR22:
 22683 00003B29 A0[7605]                	MOV     AL,[THISDRV]		;MS.                            ;AN000;
 22684                                  
 22685                                  	; 27/07/2018
 22686                                  WRTERR33:
 22687                                  	;MOV	CX,0			;No bytes transferred
 22688 00003B2C 31C9                    	XOR     CX,CX
 22689                                  					
 22690 00003B2E C43E[9E05]              	LES     DI,[THISSFT]
 22691                                  	;CLC ; 19/05/2019
 22692                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22693                                  	; 16/12/2022
 22694                                  	;clc
 22695 00003B32 C3                      	retn
 22696                                  
 22697                                  	; 16/12/2022
 22698                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22699                                  ;DOWRTJ:
 22700                                  	;JMP	short DOWRT
 22701                                  
 22702                                  ACC_ERRWJ:
 22703                                  	; 10/08/2018
 22704                                  	;JMP	SET_ACC_ERRW
 22705                                  	; 16/12/2022
 22706 00003B33 E9D7FD                  	jmp	SET_ACC_ERR_DS
 22707                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22708                                  	;jmp	SET_ACC_ERRW	
 22709                                  
 22710                                  TESTTAIL:
 22711 00003B36 29D0                    	SUB     AX,DX
 22712 00003B38 7609                    	JBE	short NOGROW
 22713 00003B3A 31D2                    	XOR     DX,DX
 22714                                  SETGRW:
 22715 00003B3C A3[DE05]                	MOV	[GROWCNT],AX
 22716 00003B3F 8916[E005]              	MOV	[GROWCNT+2],DX
 22717                                  NOGROW:
 22718 00003B43 58                      	POP     AX
 22719 00003B44 8B0E[BC05]              	MOV     CX,[CLUSNUM]    ; First cluster accessed
 22720 00003B48 E82211                  	call	FNDCLUS
 22721 00003B4B 72E6                    	JC	short ACC_ERRWJ
 22722 00003B4D 891E[BC05]              	MOV     [CLUSNUM],BX
 22723 00003B51 8916[BA05]              	MOV     [LASTPOS],DX
 22724                                  
 22725 00003B55 29D0                    	SUB     AX,DX           ; Last cluster minus current cluster
 22726 00003B57 7420                    	JZ	short DOWRT	; If we have last clus, we must have first
 22727 00003B59 E3C0                    	JCXZ    HAVSTART        ; See if no more data
 22728 00003B5B 51                      	PUSH    CX              ; No. of clusters short of first
 22729 00003B5C 89C1                    	MOV     CX,AX
 22730 00003B5E E8D312                  	call	ALLOCATE
 22731 00003B61 59                      	POP     CX
 22732 00003B62 72C3                    	JC	short WRTERR
 22733 00003B64 8B16[BA05]              	MOV     DX,[LASTPOS]
 22734 00003B68 42                      	INC     DX
 22735 00003B69 49                      	DEC     CX
 22736 00003B6A 7405                    	JZ	short NOSKIP
 22737 00003B6C E81E11                  	call	SKPCLP
 22738 00003B6F 72C2                    	JC	short ACC_ERRWJ
 22739                                  NOSKIP:
 22740 00003B71 891E[BC05]              	MOV     [CLUSNUM],BX
 22741 00003B75 8916[BA05]              	MOV     [LASTPOS],DX
 22742                                  DOWRT:
 22743 00003B79 833E[D205]00            	CMP     word [BYTCNT1],0
 22744 00003B7E 7409                    	JZ	short WRTMID
 22745 00003B80 8B1E[BC05]              	MOV     BX,[CLUSNUM]
 22746 00003B84 E89511                  	call	BUFWRT
 22747 00003B87 72AA                    	JC	short ACC_ERRWJ
 22748                                  WRTMID:
 22749 00003B89 A1[D605]                	MOV     AX,[SECCNT]
 22750 00003B8C 09C0                    	OR      AX,AX
 22751                                  	; 20/11/2022
 22752 00003B8E 746F                    	JZ	short WRTLAST	; 24/07/2019	;M039
 22753 00003B90 0106[C405]              	ADD     [SECPOS],AX
 22754                                  	; 19/05/2019
 22755                                  	; MSDOS 6.0
 22756 00003B94 8316[C605]00            	ADC	WORD [SECPOS+2],0	;F.C. >32mb 	;AN000;
 22757 00003B99 E8DC11                  	call	NEXTSEC
 22758                                  	; 16/12/2022
 22759 00003B9C 7295                    	JC	short ACC_ERRWJ
 22760                                  	;JC	short SET_ACC_ERRW	;M039
 22761 00003B9E C606[7405]01            	MOV     BYTE [TRANS],1		; A transfer is taking place
 22762 00003BA3 8A16[7305]              	MOV     DL,[SECCLUSPOS] 	; (dx/DL = Extent start) ((dh = ?))
 22763 00003BA7 8B1E[BC05]              	MOV     BX,[CLUSNUM]
 22764 00003BAB 8B0E[D605]              	MOV     CX,[SECCNT]
 22765                                  WRTLP:
 22766 00003BAF E8F711                  	call	OPTIMIZE
 22767 00003BB2 7248                    	JC	short SET_ACC_ERRW
 22768                                  	; 16/12/2022
 22769                                  	;JC	short ACC_ERRWJ
 22770                                  
 22771                                  ;M039
 22772                                  ;       DI = Next physical cluster.
 22773                                  ;       AX = # sectors remaining.
 22774                                  ;       [DMAADD+2]:BX = transfer address (source data address).
 22775                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 22776                                  ;	     sectors, also termed an "Extent".)
 22777                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 22778                                  ;       ES:BP -> Drive Parameter Block (DPB).
 22779                                  ;
 22780                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 22781                                  ;	are in Extent; they are being over-written.
 22782                                  
 22783 00003BB4 57                      	push    di
 22784 00003BB5 50                      	push    ax
 22785                                  
 22786                                  	; MSDOS 3.3
 22787                                  	; IBMDOS.COM (1987) - Offset 4497h
 22788                                  	;push	dx
 22789                                  	;push	bx
 22790                                  	;mov	al,[es:bp]
 22791                                  	;;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 22792                                  	;mov	bx,cx
 22793                                  	;add	bx,dx	; (bx = Extent end)
 22794                                  
 22795                                  ;	DX = Extent start.
 22796                                  ;	BX = Extent end.
 22797                                  ;	AL = Drive #.
 22798                                  
 22799                                  	;call	SETVISIT
 22800                                  
 22801                                  ;wbufq1:
 22802                                  	;;or	byte [di+5],20h
 22803                                  	;or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 22804                                  	;;cmp	al,[di+4]	
 22805                                  	;cmp	al,[DI+BUFFINFO.buf_ID]
 22806                                  	;jnz	short wbufq2	; Jump if Extent start > buffer sector.
 22807                                  	;;cmp	[di+6],dx
 22808                                  	;cmp	[DI+BUFFINFO.buf_sector],dx
 22809                                  	;jb	short wbufq2
 22810                                  	;;cmp	[di+6],bx
 22811                                  	;cmp	[DI+BUFFINFO.buf_sector],bx
 22812                                  	;jnb	short wbufq2	; Jump if Extent end >= buffer sector.
 22813                                  
 22814                                  	;; Buffer sector is in the Extent
 22815                                  
 22816                                  	;;mov	word [di+4],20FFh
 22817                                  	;mov	word [DI+BUFFINFO.buf_ID],20FFh
 22818                                  	;				; .buf_ID,    AL = FFh (Free buffer)
 22819                                  	;				; .buf_flags, AH = 0, reset/clear
 22820                                  	;call	SCANPLACE
 22821                                  ;wbufq2:
 22822                                  	;call	SKIPVISIT
 22823                                  	;jnz	short wbufq1
 22824                                  	;pop	bx
 22825                                  	;pop	dx
 22826                                  
 22827                                          ; MSDOS 6.0
 22828 00003BB6 E82D01                  	call	DskWrtBufPurge		;DS trashed.
 22829                                  
 22830                                  ;ASSUME DS:NOTHING
 22831                                  ;M039
 22832                                  	; MSDOS 3.3 & MSDOS 6.0
 22833                                  ;hkn; SS override for DMAADD and ALLOWED
 22834 00003BB9 368E1E[2E03]            	MOV     DS,[SS:DMAADD+2]
 22835                                  	;mov	byte [ss:ALLOWED],38h
 22836 00003BBE 36C606[4B03]38          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 22837                                  
 22838                                  ;	put logic from DWRITE in-line here so we can modify it
 22839                                  ;	for DISK FULL conditions.
 22840                                  
 22841                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22842                                  	; DOSCODE:7AD8h (MSDOS 5.0 MSDOS.SYS)
 22843                                  
 22844                                  	; 16/12/2022
 22845                                  	; MSDOS 3.3 (& MSDOS 5.0)
 22846                                  	;call	DWRITE
 22847                                  
 22848                                  ;DWRITE_OKAY:
 22849                                  
 22850                                  	; 16/12/2022
 22851                                  	; MSDOS 5.0 (& MSDOS 3.3)
 22852                                  	;pop     cx
 22853                                  	;pop     bx
 22854                                  	;push    ss
 22855                                  	;pop     ds
 22856                                  	;jc      short SET_ACC_ERRW
 22857                                  	;jcxz    WRTLAST
 22858                                  	;mov     dl, 0
 22859                                  	;inc     word [LASTPOS]
 22860                                  	;jmp     short WRTLP
 22861                                  
 22862                                  	; 16/12/2022
 22863                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22864                                  DWRITE_LUP:
 22865                                  	; 23/07/2019 - Retro DOS v3.2
 22866                                  
 22867                                  	; MSDOS 6.0
 22868 00003BC4 E8E1FB                  	call	DSKWRITE
 22869 00003BC7 7417                    	jz	short DWRITE_OKAY
 22870                                  
 22871                                  ;;	int	3
 22872                                  
 22873 00003BC9 3C27                    	cmp	al,error_handle_Disk_Full	; compressed volume full?
 22874 00003BCB 7423                    	jz	short DWRITE_DISK_FULL
 22875                                  
 22876                                  	; 16/12/2022
 22877                                  
 22878                                  ;;hkn; SS override
 22879 00003BCD 36C606[7505]01          	MOV	BYTE [SS:READOP],1
 22880 00003BD3 E801FC                  	call	HARDERRRW
 22881 00003BD6 3C01                    	CMP	AL,1		; Check for retry
 22882 00003BD8 74EA                    	JZ	short DWRITE_LUP
 22883                                  
 22884                                  	; 16/12/2022
 22885                                  	; 23/07/2019
 22886                                  	;POP	CX ; *4*
 22887                                  	;POP	BX ; *5*
 22888                                  	;
 22889                                  	;push	ss
 22890                                  	;pop	ds
 22891                                  	;
 22892                                  
 22893                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22894                                  
 22895                                  	; 16/12/2022
 22896 00003BDA 3C03                    	CMP	AL,3		; Check for FAIL
 22897 00003BDC F8                      	CLC
 22898 00003BDD 7501                    	JNZ	short DWRITE_OKAY ; Ignore
 22899 00003BDF F9                      	STC
 22900                                  
 22901                                  DWRITE_OKAY:
 22902                                  	; 16/12/2022
 22903                                  	; 23/07/2019
 22904                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22905 00003BE0 59                      	POP	CX ; *4*
 22906 00003BE1 5B                      	POP	BX ; *5*
 22907                                  
 22908                                  ;       CX = # sectors remaining.
 22909                                  ;       BX = Next physical cluster.
 22910                                  
 22911                                  ;hkn; SS override
 22912                                          ;Context DS
 22913                                  	; 16/12/2022
 22914                                  	;push	ss
 22915                                  	;pop	ds
 22916                                  
 22917                                  	; 16/12/2022
 22918 00003BE2 7218                    	jc	short SET_ACC_ERRW
 22919                                  
 22920                                  	; 16/12/2022
 22921 00003BE4 16                      	push	ss
 22922 00003BE5 1F                      	pop	ds
 22923                                  
 22924 00003BE6 E317                    	JCXZ    WRTLAST
 22925                                  
 22926                                  	;MOV	DL,0
 22927 00003BE8 30D2                    	xor	dl,dl ; 23/07/2019
 22928 00003BEA FF06[BA05]              	INC     word [LASTPOS]	; We'll be using next cluster
 22929 00003BEE EBBF                    	JMP     short WRTLP
 22930                                  
 22931                                  	; 23/07/2019 - Retro DOS v3.2
 22932                                  	; 09/08/2018
 22933                                  	; MSDOS 6.0
 22934                                  DWRITE_DISK_FULL:
 22935                                  	;Context DS		;SQ 3-5-93 DS must be setup on return!
 22936                                  	; 16/12/2022
 22937 00003BF0 16                      	push	ss
 22938 00003BF1 1F                      	pop	ds
 22939 00003BF2 59                      	pop	cx		; unjunk stack
 22940 00003BF3 5B                      	pop	bx
 22941 00003BF4 C606[0B06]01            	mov	byte [DISK_FULL],1
 22942                                  	;stc
 22943 00003BF9 E92BFF                  	jmp	WRTERR ; 24/07/2019 ; go to disk full exit
 22944                                  
 22945                                  	; 16/12/2022
 22946                                  SET_ACC_ERRW:
 22947 00003BFC E90EFD                  	jmp	SET_ACC_ERR_DS
 22948                                  
 22949                                  WRTLAST:
 22950 00003BFF A1[D405]                	MOV     AX,[BYTCNT2]
 22951 00003C02 09C0                    	OR      AX,AX
 22952 00003C04 7413                    	JZ	short FINWRT
 22953 00003C06 A3[D205]                	MOV     [BYTCNT1],AX
 22954 00003C09 E86C11                  	call	NEXTSEC
 22955 00003C0C 72EE                    	JC	short SET_ACC_ERRW
 22956 00003C0E C706[CC05]0000          	MOV     word [BYTSECPOS],0
 22957 00003C14 E80511                  	call	BUFWRT
 22958 00003C17 72E3                    	JC	short SET_ACC_ERRW
 22959                                  FINWRT:
 22960 00003C19 C43E[9E05]              	LES     DI,[THISSFT]
 22961 00003C1D A1[DE05]                	MOV     AX,[GROWCNT]
 22962 00003C20 8B0E[E005]              	MOV     CX,[GROWCNT+2]
 22963 00003C24 09C0                    	OR      AX,AX
 22964 00003C26 7502                    	JNZ	short UPDATE_size
 22965 00003C28 E30F                    	JCXZ    SAMSIZ
 22966                                  UPDATE_size:
 22967                                  	;add	[es:di+11h],ax
 22968 00003C2A 26014511                	ADD     [ES:DI+SF_ENTRY.sf_size],AX
 22969                                  	;adc	[es:di+13h],cx
 22970 00003C2E 26114D13                	ADC     [ES:DI+SF_ENTRY.sf_size+2],CX
 22971                                  
 22972                                  ; Make sure that all other SFT's see this growth also.
 22973                                  
 22974 00003C32 B80100                  	MOV     AX,1
 22975                                  ;if installed
 22976                                  	;Call	JShare + 14 * 4
 22977 00003C35 FF1E[C800]              	call    far [JShare+(14*4)]	; 14 = ShSU
 22978                                  ;else
 22979                                  ;	Call    ShSU
 22980                                  ;endif
 22981                                  
 22982                                  SAMSIZ:
 22983 00003C39 E969FD                  	jmp	SETCLUS	; ES:DI already points to SFT
 22984                                  
 22985                                  	; 16/12/2022
 22986                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22987                                  ;SET_ACC_ERRW:
 22988                                  	;jmp	SET_ACC_ERR_DS
 22989                                  
 22990                                  WRTEOF:
 22991 00003C3C 89C1                    	MOV     CX,AX
 22992 00003C3E 09D1                    	OR      CX,DX
 22993 00003C40 746C                    	JZ	short KILLFIL
 22994 00003C42 83E801                  	SUB     AX,1
 22995 00003C45 83DA00                  	SBB     DX,0
 22996                                  
 22997                                  	; MSDOS 3.3
 22998                                  	;;div	word [es:bp+2]
 22999                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 23000                                  	;;mov	cl,[es:bp+5]
 23001                                  	;mov	cl,[ES:BP+DPB.CLUSTER_SHIFT] 
 23002                                  	;shr	ax,cl
 23003                                  
 23004                                  	; MSDOS 6.0
 23005 00003C48 53                      	PUSH	BX
 23006                                  	;mov	bx,[es:bp+2]
 23007 00003C49 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]    ;F.C. >32mb                       ;AN000;
 23008 00003C4D E81C01                  	CALL	DIV32                         ;F.C. >32mb                       ;AN000;
 23009 00003C50 5B                      	POP	BX			      ;F.C. >32mb			;AN000;
 23010 00003C51 89CA                    	MOV	DX,CX			      ;M039
 23011 00003C53 890E[0706]                      MOV	[HIGH_SECTOR],CX              ;M039: Probably extraneous, but not sure.
 23012 00003C57 E83901                  	CALL	SHR32                         ;F.C. >32mb                       ;AN000;
 23013                                  
 23014 00003C5A 89C1                    	MOV     CX,AX
 23015 00003C5C E80E10                  	call	FNDCLUS
 23016                                  SET_ACC_ERRWJ2:
 23017 00003C5F 729B                    	JC	short SET_ACC_ERRW
 23018                                  
 23019 00003C61 E326                    	JCXZ    RELFILE
 23020 00003C63 E8CE11                  	call	ALLOCATE
 23021                                  	;JC	short WRTERRJ              ;;;;;;;;; disk full
 23022                                  	; 16/12/2022
 23023 00003C66 7303                    	jnc	short UPDATE
 23024 00003C68 E9BCFE                  	JMP	WRTERR
 23025                                  UPDATE:
 23026 00003C6B C43E[9E05]              	LES	DI,[THISSFT]
 23027 00003C6F A1[CE05]                	MOV	AX,[BYTPOS]
 23028                                  	;mov	[es:di+11h],ax
 23029 00003C72 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 23030 00003C76 A1[D005]                	MOV	AX,[BYTPOS+2]
 23031                                  	;mov	[es:di+13h],ax
 23032 00003C79 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 23033                                  ;
 23034                                  ; Make sure that all other SFT's see this growth also.
 23035                                  ;
 23036 00003C7D B80200                  	MOV     AX,2
 23037                                  ;if installed
 23038                                  	;Call	JShare + 14 * 4
 23039 00003C80 FF1E[C800]              	call    far [JShare+(14*4)]	; 14 = ShSU
 23040                                  ;else
 23041                                  ;	Call    ShSU
 23042                                  ;endif
 23043 00003C84 31C9                    	XOR     CX,CX
 23044 00003C86 E939FD                  	jmp	ADDREC
 23045                                  
 23046                                  	; 16/12/2022
 23047                                  ;WRTERRJ: 
 23048                                  	;JMP	WRTERR
 23049                                  
 23050                                  ;;;;;;;;;;;;;;;; 7/18/86
 23051                                  ;;;;;;;;;;;;;;;;
 23052                                  
 23053                                  RELFILE:
 23054                                  	; MSDOS 6.0
 23055 00003C89 06                      	PUSH    ES                    ;AN002; BL Reset Lstclus and cluspos to
 23056 00003C8A C43E[9E05]              	LES     DI,[THISSFT]          ;AN002; BL beginning of file if current
 23057                                  	;cmp	dx,[es:di+19h]
 23058 00003C8E 263B5519                	CMP     DX,[ES:DI+SF_ENTRY.sf_cluspos]	;AN002; BL cluspos is past EOF.
 23059 00003C92 730E                    	JAE	short SKIPRESET	      		;AN002; BL
 23060                                  	;mov	[es:di+19h],0
 23061 00003C94 26C745190000            	MOV     word [ES:DI+SF_ENTRY.sf_cluspos],0 ;AN002; BL
 23062                                  	;mov	dx,[es:di+0Bh]
 23063 00003C9A 268B550B                	MOV     DX,[ES:DI+SF_ENTRY.sf_firclus]	;AN002; BL
 23064                                  	;mov	[es:di+35h],dx
 23065 00003C9E 26895535                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],DX	;AN002; BL
 23066                                  SKIPRESET:                            		;AN002; BL
 23067 00003CA2 07                      	POP     ES                    		;AN002; BL
 23068                                  ;
 23069 00003CA3 BAFFFF                  	MOV     DX,0FFFFH
 23070 00003CA6 E83912                  	call	RELBLKS
 23071                                  	; 16/12/2022
 23072                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23073 00003CA9 73C0                    	jnc	short UPDATE
 23074                                  SET_ACC_ERRWJ:
 23075                                  	;JC	short SET_ACC_ERRWJ2
 23076                                  	;JMP	SHORT UPDATE
 23077                                  	; 16/12/2022
 23078 00003CAB E95FFC                  	jmp	SET_ACC_ERR_DS
 23079                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23080                                  	;JC	short SET_ACC_ERRWJ2
 23081                                  	;JMP	SHORT UPDATE
 23082                                  
 23083                                  KILLFIL:
 23084 00003CAE 31DB                    	XOR     BX,BX
 23085 00003CB0 06                      	PUSH    ES
 23086 00003CB1 C43E[9E05]              	LES     DI,[THISSFT]
 23087                                  	;mov	[es:di+19h],bx
 23088 00003CB5 26895D19                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],BX
 23089                                  	;mov	[es:di+35h],bx ; 04/05/2019
 23090 00003CB9 26895D35                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],BX
 23091                                  	;xchg	bx,[es:di+0Bh]
 23092 00003CBD 26875D0B                	XCHG    BX,[ES:DI+SF_ENTRY.sf_firclus]
 23093 00003CC1 07                      	POP	ES
 23094                                  
 23095 00003CC2 09DB                    	OR	BX,BX
 23096                                  	;JZ	short UPDATEJ
 23097                                  	; 16/12/2022
 23098 00003CC4 74A5                    	jz	short UPDATE
 23099                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23100                                  	;jz	short UPDATEJ
 23101                                  
 23102                                  ;; 10/23/86 FastOpen update
 23103 00003CC6 06                      	PUSH	ES              ; since first cluster # is 0
 23104 00003CC7 55                      	PUSH	BP              ; we must delete the old cache entry
 23105 00003CC8 50                      	PUSH	AX
 23106 00003CC9 51                      	PUSH	CX
 23107 00003CCA 52                      	PUSH	DX
 23108 00003CCB C42E[8A05]              	LES	BP,[THISDPB]             ; get current DPB
 23109                                  	; 15/12/2022
 23110 00003CCF 268A5600                	mov	dl,[ES:BP] ; mov dl,[es:bp+0]
 23111                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23112                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; get current drive
 23113 00003CD3 89D9                    	MOV	CX,BX                    ; first cluster #
 23114 00003CD5 B402                    	MOV	AH,2                     ; delete cache entry by drive:firclus
 23115 00003CD7 E840EA                  	call	FastOpen_Update          ; call fastopen
 23116 00003CDA 5A                      	POP	DX
 23117 00003CDB 59                      	POP	CX
 23118 00003CDC 58                      	POP	AX
 23119 00003CDD 5D                      	POP	BP
 23120 00003CDE 07                      	POP	ES
 23121                                  ;; 10/23/86 FastOpen update
 23122                                  
 23123 00003CDF E8FE11                  	call	RELEASE
 23124 00003CE2 72C7                    	JC	short SET_ACC_ERRWJ
 23125                                  UPDATEJ:
 23126                                  	; 20/11/2022
 23127 00003CE4 EB85                    	JMP	short UPDATE ; 10/08/2018
 23128                                  
 23129                                  ;Break   <DskWrtBufPurge -- Disk Write Buffer Purge>
 23130                                  ;----------------------------------------------------------------------------
 23131                                  ;
 23132                                  ; Procedure Name : DskWrtBufPurge
 23133                                  ;
 23134                                  ; Inputs:
 23135                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 23136                                  ;	     sectors, also termed an "Extent".)
 23137                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 23138                                  ;       ES:BP -> Drive Parameter Block (DPB).
 23139                                  ;
 23140                                  ; Function:
 23141                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 23142                                  ;	are in Extent; they are being over-written.
 23143                                  ;
 23144                                  ; Outputs:
 23145                                  ;       (Same as Input.)
 23146                                  ; Uses:
 23147                                  ;       All registers except DS,AX,SI,DI preserved.
 23148                                  ;       SS override for all global variables.
 23149                                  ;----------------------------------------------------------------------------
 23150                                  ;M039: Created
 23151                                  
 23152                                  ;procedure   DskWrtBufPurge,NEAR
 23153                                  ;
 23154                                  ;ASSUME  DS:NOTHING
 23155                                  
 23156                                  ; 04/05/2019 - Retro DOS v4.0
 23157                                  ; DOSCODE:7C0Eh (MSDOS 6.21, MSDOS.SYS)
 23158                                  
 23159                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23160                                  ; DOSCODE:7BD4h (MSDOS 5.0, MSDOS.SYS) 
 23161                                  
 23162                                  DskWrtBufPurge:
 23163                                  	;SaveReg <bx,cx>
 23164 00003CE6 53                      	push	bx
 23165 00003CE7 51                      	push	cx
 23166                                  
 23167 00003CE8 368B1E[0706]            	mov	bx,[ss:HIGH_SECTOR]	;BX:DX = Extent start (sector #).
 23168 00003CED 89DE                    	mov	si,bx
 23169 00003CEF 01D1                    	add	cx,dx
 23170 00003CF1 83D600                  	adc	si,0                    ;SI:CX = Extent end + 1.
 23171                                  
 23172                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23173                                  	;;mov	al,[es:bp+0]
 23174                                  	;mov	al,[es:bp+DPB.DRIVE]
 23175                                  	; 15/12/2022
 23176 00003CF4 268A4600                	mov	al,[es:bp]
 23177                                  
 23178                                  ;	BX:DX = Extent start.
 23179                                  ;	SI:CX = Extent end + 1.
 23180                                  ;	AL = Drive #
 23181                                  
 23182 00003CF8 36833E[7700]00          	cmp	word [ss:SC_CACHE_COUNT],0 ;Secondary cache in-use?
 23183 00003CFE 7431                    	je	short nosc		; -no, jump.
 23184                                  
 23185                                  ;	If any of the sectors to be written are in the secondary cache (SC),
 23186                                  ;	invalidate the entire SC. (This is an optimization; we really only
 23187                                  ;	need to invalidate those sectors which intersect, but that's slower.)
 23188                                  
 23189 00003D00 363A06[B00D]            	cmp	al,[ss:CurSC_DRIVE]	;Same drive?
 23190 00003D05 752A                    	jne	short nosc		; -no, jump.
 23191                                  
 23192 00003D07 50                      	push    ax
 23193 00003D08 36A1[B10D]              	mov     ax,[ss:CurSC_SECTOR]
 23194 00003D0C 368B3E[B30D]            	mov     di,[ss:CurSC_SECTOR+2]	;DI:AX = SC start.
 23195                                  
 23196                                  	;Cmp32	si,cx,di,ax		;Extent end < SC start?
 23197                                  	;jbe	short sc5		; -yes, jump.
 23198                                  
 23199 00003D11 39FE                    	cmp	si,di
 23200 00003D13 7502                    	jne	short sc01
 23201 00003D15 39C1                    	cmp	cx,ax
 23202                                  sc01: 
 23203 00003D17 7617                    	jbe	short sc5	
 23204                                  
 23205 00003D19 360306[7700]            	add	ax,[ss:SC_CACHE_COUNT]
 23206 00003D1E 83D700                  	adc	di,0                    ;DI:AX = SC end + 1.
 23207                                  	
 23208                                  	;Cmp32	bx,dx,di,ax             ;Extent start > SC end?
 23209                                  	;jae	short sc5		; -yes, jump.
 23210                                  
 23211 00003D21 39FB                    	cmp	bx,di
 23212 00003D23 7502                    	jne	short sc02
 23213 00003D25 39C2                    	cmp	dx,ax
 23214                                  sc02:
 23215 00003D27 7307                    	jnb	short sc5
 23216                                  
 23217 00003D29 36C706[B50D]0000        	mov	word [ss:SC_STATUS],0	;Extent intersects SC: invalidate SC.
 23218                                  sc5:	
 23219 00003D30 58                      	pop     ax
 23220                                  
 23221                                  ;	Free any buffered sectors which are in Extent; they are being over-
 23222                                  ;	written.
 23223                                  
 23224                                  nosc:	
 23225 00003D31 E8C31B                  	call	GETCURHEAD		;DS:DI -> first buffer in queue.
 23226                                  
 23227                                  _bufq:	
 23228                                  	;cmpo	al,[di+4]
 23229 00003D34 3A4504                  	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
 23230 00003D37 7527                    	jne	short bufq5		; -no, jump.
 23231                                  
 23232                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 23233                                  ;       ja	short bufq5		;Jump if Extent start > buffer sector.
 23234                                  
 23235                                  	;cmp	bx,[di+8]
 23236 00003D39 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 23237 00003D3C 7503                    	jne	short bufq04
 23238                                  	;cmp	dx,[di+6]
 23239 00003D3E 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 23240                                  bufq04:
 23241 00003D41 771D                    	ja	short bufq5
 23242                                  
 23243                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 23244                                  ;       jbe	short bufq5		;Jump if Extent end < buffer sector.
 23245                                  
 23246                                  	;cmp	si,[di+8]
 23247 00003D43 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 23248 00003D46 7503                    	jne	short bufq05
 23249                                  	;cmp	cx,[di+6]
 23250 00003D48 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 23251                                  bufq05:
 23252 00003D4B 7613                    	jbe	short bufq5
 23253                                  
 23254                                  ;	Buffer's sector is in Extent, so free it; it is being over-written.
 23255                                  
 23256                                  	;test	byte [di+5],40h
 23257 00003D4D F6450540                	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
 23258 00003D51 7403                    	jz	short bufq4		; -no, jump.
 23259 00003D53 E8221E                  	call	DEC_DIRTY_COUNT		; -yes, decrement dirty count.
 23260                                  bufq4:
 23261                                  	;mov	word [di+4],20FFh
 23262 00003D56 C74504FF20              	mov     word [di+BUFFINFO.buf_ID],((buf_visit<<8)|0FFh)
 23263                                  
 23264 00003D5B E8AB1B                  	call	SCANPLACE
 23265 00003D5E EB02                    	jmp     short bufq6
 23266                                  bufq5: 
 23267 00003D60 8B3D                    	mov     di,[di]
 23268                                  	;mov	di,[di+BUFFINFO.buf_next]
 23269                                  bufq6: 
 23270 00003D62 363B3E[BB0E]            	cmp	di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
 23271 00003D67 75CB                    	jne	short _bufq		; --no, go do next buffer.
 23272                                  	
 23273                                  	;RestoreReg <cx,bx>
 23274 00003D69 59                      	pop	cx
 23275 00003D6A 5B                      	pop	bx
 23276 00003D6B C3                      	retn
 23277                                  
 23278                                  ;EndProc DskWrtBufPurge
 23279                                  
 23280                                  ;Break   <DIV32 -- PERFORM 32 BIT DIVIDE>
 23281                                  ;----------------------------------------------------------------------------
 23282                                  ;
 23283                                  ; Procedure Name : DIV32
 23284                                  ;
 23285                                  ; Inputs:
 23286                                  ;       DX:AX = 32 bit dividend   BX= divisor
 23287                                  ; Function:
 23288                                  ;       Perform 32 bit division:  DX:AX/BX = CX:AX + DX (rem.)
 23289                                  ; Outputs:
 23290                                  ;       CX:AX = quotient , DX= remainder
 23291                                  ; Uses:
 23292                                  ;       All registers except AX,CX,DX preserved.
 23293                                  ;----------------------------------------------------------------------------
 23294                                  ;M039: DIV32 optimized for divisor of 512 (common sector size).
 23295                                  
 23296                                  ; 04/05/2019 - Retro DOS v4.0
 23297                                  ; DOSCODE:7C94h (MSDOS 6.21, MSDOS.SYS)
 23298                                  
 23299                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23300                                  ; DOSCODE:7C5Ah (MSDOS 5.0, MSDOS.SYS) 
 23301                                  
 23302                                  DIV32:
 23303 00003D6C 81FB0002                	cmp	bx,512
 23304 00003D70 7515                    	jne	short div5
 23305                                  
 23306 00003D72 89D1                    	mov	cx,dx
 23307 00003D74 89C2                    	mov	dx,ax           ; CX:AX = Dividend
 23308 00003D76 81E2FF01                	and	dx,(512-1)      ; DX = Remainder
 23309 00003D7A 88E0                    	mov	al,ah
 23310 00003D7C 88CC                    	mov	ah,cl
 23311 00003D7E 88E9                    	mov	cl,ch
 23312 00003D80 30ED                    	xor	ch,ch
 23313 00003D82 D1E9                    	shr	cx,1
 23314 00003D84 D1D8                    	rcr	ax,1
 23315 00003D86 C3                      	retn
 23316                                  div5:	
 23317 00003D87 89C1                    	mov	cx,ax
 23318 00003D89 89D0                    	mov	ax,dx
 23319 00003D8B 31D2                    	xor	dx,dx
 23320 00003D8D F7F3                    	div	bx              ; 0:AX/BX
 23321 00003D8F 91                      	xchg	cx,ax
 23322 00003D90 F7F3                    	div	bx              ; DX:AX/BX
 23323 00003D92 C3                      	retn
 23324                                  
 23325                                  ;Break   <SHR32 -- PERFORM 32 BIT SHIFT RIGHT>
 23326                                  ;----------------------------------------------------------------------------
 23327                                  ;
 23328                                  ; Procedure Name : SHR32
 23329                                  ;
 23330                                  ; Inputs:
 23331                                  ;	DX:AX = 32 bit sector number
 23332                                  ; Function:
 23333                                  ;       Perform 32 bit shift right
 23334                                  ; Outputs:
 23335                                  ;	AX = cluster number
 23336                                  ;	ZF = 1 if no error
 23337                                  ;	   = 0 if error (cluster number > 64k)
 23338                                  ; Uses:
 23339                                  ;       DX,CX
 23340                                  ;---------------------------------------------------------------------------
 23341                                  ; M017	- SHR32 rewritten for better performance
 23342                                  ; M039	- Additional optimization
 23343                                  
 23344                                  ; 04/05/2019 - Retro DOS v4.0
 23345                                  ; DOSCODE:7CBBh (MSDOS 6.21, MSDOS.SYS)
 23346                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23347                                  ; DOSCODE:7C81h (MSDOS 5.0, MSDOS.SYS) 
 23348                                  
 23349                                  SHR32:
 23350                                  	;mov	cl,[es:bp+5]
 23351 00003D93 268A4E05                	mov	cl,[ES:BP+DPB.CLUSTER_SHIFT]
 23352 00003D97 30ED                    	xor	ch,ch	    ;ZF=1
 23353 00003D99 E306                    	jcxz	norota
 23354                                  
 23355                                  rotashft2:
 23356 00003D9B D1EA                    	shr	dx,1	    ;ZF reflects state of DX.
 23357 00003D9D D1D8                    	rcr	ax,1	    ;ZF not affected.
 23358 00003D9F E2FA                    	loop	rotashft2
 23359                                  norota:
 23360 00003DA1 C3                      	retn
 23361                                  
 23362                                  ;============================================================================
 23363                                  ; DIR.ASM, MSDOS 6.0, 1991
 23364                                  ;============================================================================
 23365                                  ; 27/07/2018 - Retro DOS v3.0
 23366                                  ; 19/05/2019 - Retro DOS v4.0 
 23367                                  
 23368                                  ;	TITLE	DIR - Directory and path cracking
 23369                                  ;	NAME	Dir
 23370                                  
 23371                                  ;Break	<FINDENTRY -- LOOK FOR AN ENTRY>
 23372                                  ;---------------------------------------------------------------------------
 23373                                  ;
 23374                                  ; Procedure Name : FINDENTRY,SEARCH
 23375                                  ;
 23376                                  ; Inputs:
 23377                                  ;	[THISDPB] set
 23378                                  ;	[SECCLUSPOS] = 0
 23379                                  ;	[DIRSEC] = Starting directory sector number
 23380                                  ;	[CLUSNUM] = Next cluster of directory
 23381                                  ;	[CLUSFAC] = Sectors/Cluster
 23382                                  ;	[NAME1] = Name to look for
 23383                                  ; Function:
 23384                                  ;	Find file name in disk directory.
 23385                                  ;	"?" matches any character.
 23386                                  ; Outputs:
 23387                                  ;	Carry set if name not found
 23388                                  ;	ELSE
 23389                                  ;	Zero set if attributes match (always except when creating)
 23390                                  ;	AH = Device ID (bit 7 set if not disk)
 23391                                  ;	[THISDPB] = Base of drive parameters
 23392                                  ;	DS = DOSGROUP
 23393                                  ;	ES = DOSGROUP
 23394                                  ;	[CURBUF+2]:BX = Pointer into directory buffer
 23395                                  ;	[CURBUF+2]:SI = Pointer to First Cluster field in directory entry
 23396                                  ;	[CURBUF] has directory record with match
 23397                                  ;	[NAME1] has file name
 23398                                  ;	[LASTENT] is entry number of the entry
 23399                                  ; All other registers destroyed.
 23400                                  ;----------------------------------------------------------------------------
 23401                                  
 23402                                  ;hkn; called from rename.asm and dir2.asm. DS must be already set up at
 23403                                  ;hkn; this point.
 23404                                  
 23405                                  SEARCH:
 23406                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23407                                  	; DOSCODE:7C90h (MSDOS 5.0, MSDOS.SYS) 
 23408                                  
 23409                                  	; 19/05/2019 - Retro DOS v4.0
 23410                                  	; DOSCODE:7CCA (MSDOS 6.21, MSDOS.SYS)
 23411                                  
 23412                                  	; 27/07/2018 - Retro DOS v3.0
 23413                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 45B3h 
 23414                                  	; 15/03/2018 - Retro DOS v2.0
 23415                                  
 23416                                  	;entry	FindEntry
 23417                                  FINDENTRY:
 23418 00003DA2 E82E04                  	call	STARTSRCH
 23419 00003DA5 A0[6B05]                	MOV	AL,[ATTRIB]
 23420                                  	;and	al,9Eh
 23421 00003DA8 24DE                    	AND	AL,~attr_ignore		; Ignore useless bits
 23422                                  	;cmp	al,8
 23423 00003DAA 3C08                    	CMP	AL,attr_volume_id	; Looking for vol ID only ?
 23424 00003DAC 7503                    	JNZ	short NOTVOLSRCH	; No
 23425 00003DAE E86D01                  	CALL	SETROOTSRCH		; Yes force search of root
 23426                                  NOTVOLSRCH:
 23427 00003DB1 E8FD00                  	CALL	GETENTRY
 23428 00003DB4 7303                    	JNC	short SRCH
 23429 00003DB6 E99100                  	JMP	SETESRET
 23430                                  
 23431                                  	;entry	Srch
 23432                                  SRCH:
 23433 00003DB9 1E                      	PUSH	DS
 23434 00003DBA 8E1E[E405]              	MOV	DS,[CURBUF+2]
 23435                                  
 23436                                  ;	(DS:BX) = directory entry address
 23437                                  
 23438 00003DBE 8A27                    	mov	ah,[BX]
 23439                                  	;MOV	AH,[BX+dir_entry.dir_name] ; mov ah,[bx+0]
 23440 00003DC0 08E4                    	OR	AH,AH			; End of directory?
 23441 00003DC2 7436                    	JZ	short FREE
 23442                                  
 23443                                  ;hkn; SS override
 23444 00003DC4 363A26[7F05]            	CMP	AH,[SS:DELALL]		; Free entry?
 23445 00003DC9 742F                    	JZ	short FREE
 23446                                  	;test	byte [bx+0Bh],8
 23447 00003DCB F6470B08                	TEST	byte [BX+dir_entry.dir_attr],attr_volume_id
 23448                                  					; Volume ID file?
 23449 00003DCF 7405                    	JZ	short CHKFNAM 		; NO
 23450                                  
 23451                                  ;hkn; SS override
 23452 00003DD1 36FE06[7B05]            	INC	BYTE [SS:VOLID]
 23453                                  CHKFNAM:
 23454                                  ;	Context ES
 23455 00003DD6 8CD6                    	MOV	SI,SS
 23456 00003DD8 8EC6                    	MOV	ES,SI
 23457 00003DDA 89DE                    	MOV	SI,BX
 23458                                  
 23459                                  ;hkn; NAME1 is in DOSDATA
 23460 00003DDC BF[4B05]                	MOV	DI,NAME1
 23461                                  ;;;;; 7/29/86
 23462                                  
 23463                                  ;hkn; SS override for NAME1
 23464                                  	;CMP	BYTE [SS:NAME1],0E5H	; special char check
 23465                                  	;JNZ	short NO_E5
 23466                                  	;MOV	BYTE [SS:NAME1],05H
 23467                                  	; 22/09/2023
 23468 00003DDF 26803DE5                	cmp	byte [es:di],0E5h
 23469 00003DE3 7504                    	jnz	short NO_E5
 23470 00003DE5 26C60505                	mov	byte [es:di],05h
 23471                                  NO_E5:
 23472                                  ;;;;; 7/29/86
 23473 00003DE9 E86100                  	CALL	MetaCompare
 23474 00003DEC 7428                    	JZ	short FOUND
 23475 00003DEE 1F                      	POP	DS
 23476                                  
 23477                                  	;entry	NEXTENT
 23478                                  NEXTENT:
 23479 00003DEF C42E[8A05]              	LES	BP,[THISDPB]
 23480 00003DF3 E86600                  	CALL	NEXTENTRY
 23481 00003DF6 73C1                    	JNC	short SRCH
 23482 00003DF8 EB50                    	JMP	SHORT SETESRET
 23483                                  
 23484                                  FREE:
 23485 00003DFA 1F                      	POP	DS
 23486 00003DFB 8B0E[4803]              	MOV	CX,[LASTENT]
 23487 00003DFF 3B0E[D805]              	CMP	CX,[ENTFREE]
 23488 00003E03 7304                    	JAE	short TSTALL
 23489 00003E05 890E[D805]              	MOV	[ENTFREE],CX
 23490                                  TSTALL:
 23491 00003E09 3A26[7F05]              	CMP	AH,[DELALL]		; At end of directory?
 23492                                  NEXTENTJ:
 23493 00003E0D 74E0                    	je	short NEXTENT 		; No - continue search
 23494 00003E0F 890E[DA05]              	MOV	[ENTLAST],CX
 23495 00003E13 F9                      	STC
 23496 00003E14 EB34                    	JMP	SHORT SETESRET
 23497                                  
 23498                                  FOUND:
 23499                                  ; We have a file with a matching name. We must now consider the attributes:
 23500                                  ; ATTRIB	Action
 23501                                  ; ------	------
 23502                                  ; Volume_ID	Is Volume_ID in test?
 23503                                  ; Otherwise	If no create then Is ATTRIB+extra superset of test?
 23504                                  ;		If create then Is ATTRIB equal to test?
 23505                                  
 23506 00003E16 8A2C                    	MOV	CH,[SI] 		; Attributes of file
 23507 00003E18 1F                      	POP	DS
 23508 00003E19 8A26[6B05]              	MOV	AH,[ATTRIB]		; Attributes of search
 23509                                  	;and	ah,9Eh
 23510 00003E1D 80E4DE                  	AND	AH,~attr_ignore
 23511                                  	;lea	si,[si+15]
 23512 00003E20 8D740F                  	LEA	SI,[SI+dir_entry.dir_first-dir_entry.dir_attr]
 23513                                  					; point to first cluster field
 23514                                  	;test	ch,8
 23515 00003E23 F6C508                  	TEST	CH,attr_volume_id	; Volume ID file?
 23516 00003E26 7409                    	JZ	short check_one_volume_id ; Nope check other attributes
 23517                                  	;test	ah,8
 23518 00003E28 F6C408                  	TEST	AH,attr_volume_id	; Can we find Volume ID?
 23519                                  	;JZ	short NEXTENTJ		; Nope, (not even $FCB_CREATE)
 23520                                  	; 16/12/2022
 23521 00003E2B 74C2                    	jz	short NEXTENT ; 19/05/2019
 23522                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23523                                  	;JZ	short NEXTENTJ
 23524 00003E2D 30E4                    	XOR	AH,AH			; Set zero flag for $FCB_CREATE
 23525 00003E2F EB11                    	JMP	SHORT RETFF		; Found Volume ID
 23526                                  check_one_volume_id:
 23527                                  	;CMP	ah,8
 23528 00003E31 80FC08                  	CMP	AH,attr_volume_id	; Looking only for Volume ID?
 23529                                  	;JZ	short NEXTENTJ		; Yes, continue search
 23530                                  	; 16/12/2022
 23531 00003E34 74B9                    	je	short NEXTENT ; 19/05/2019
 23532                                  	;JZ	short NEXTENTJ
 23533 00003E36 E8AE03                  	CALL	MatchAttributes
 23534 00003E39 7407                    	JZ	SHORT RETFF
 23535 00003E3B F606[7E05]FF            	TEST	BYTE [CREATING],-1	; Pass back mismatch if creating
 23536                                  	; 16/12/2022
 23537                                  	;JZ	short NEXTENTJ		; Otherwise continue searching
 23538 00003E40 74AD                    	jz	short NEXTENT ; 19/05/2019
 23539                                  RETFF:
 23540 00003E42 C42E[8A05]              	LES	BP,[THISDPB]
 23541                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23542                                  	;MOV	AH,[ES:BP+DPB.DRIVE]  ; mov ah,[es:bp+0]
 23543                                  	; 15/12/2022
 23544 00003E46 268A6600                	MOV	AH,[ES:BP]
 23545                                  SETESRET:
 23546 00003E4A 16                      	PUSH	SS
 23547 00003E4B 07                      	POP	ES
 23548 00003E4C C3                      	retn
 23549                                  
 23550                                  ;----------------------------------------------------------------------------
 23551                                  ;
 23552                                  ; Procedure Name : MetaCompare
 23553                                  ;
 23554                                  ; Inputs:
 23555                                  ;	DS:SI -> 11 character FCB style name NO '?'
 23556                                  ;	    Typically this is a directory entry. It MUST be in upper case
 23557                                  ;	ES:DI -> 11 character FCB style name with possible '?'
 23558                                  ;	    Typically this is a FCB or SFT. It MUST be in upper case
 23559                                  ; Function:
 23560                                  ;	Compare FCB style names allowing for ? match to any char
 23561                                  ; Outputs:
 23562                                  ;	Zero if match else NZ
 23563                                  ; Destroys CX,SI,DI all others preserved
 23564                                  ;----------------------------------------------------------------------------
 23565                                  
 23566                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23567                                  	; DOSCODE:7D3Fh (MSDOS 5.0, MSDOS.SYS) 
 23568                                  
 23569                                  MetaCompare:
 23570 00003E4D B90B00                  	MOV	CX,11
 23571                                  WILDCRD:
 23572 00003E50 F3A6                    	REPE	CMPSB
 23573 00003E52 7407                    	JZ	short MetaRet 		; most of the time we will fail.
 23574                                  CHECK_META:
 23575 00003E54 26807DFF3F              	CMP	BYTE [ES:DI-1],"?"
 23576 00003E59 74F5                    	JZ	short WILDCRD
 23577                                  MetaRet:
 23578 00003E5B C3                       	retn				; Zero set, Match
 23579                                  
 23580                                  ;Break	<NEXTENTRY -- STEP THROUGH DIRECTORY>
 23581                                  ;----------------------------------------------------------------------------
 23582                                  ;
 23583                                  ; Procedure Name : NEXTENTRY
 23584                                  ;
 23585                                  ; Inputs:
 23586                                  ;	Same as outputs of GETENTRY, above
 23587                                  ; Function:
 23588                                  ;	Update BX, and [LASTENT] for next directory entry.
 23589                                  ;	Carry set if no more.
 23590                                  ;----------------------------------------------------------------------------
 23591                                  
 23592                                  NEXTENTRY:
 23593                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23594                                  	; DOSCODE:7D4Eh (MSDOS 5.0, MSDOS.SYS) 
 23595                                  
 23596                                  	; 19/05/2019 - Retro DOS v4.0
 23597                                  	; DOSCODE:7D88h (MSDOS 6.21, MSDOS.SYS)
 23598                                  
 23599                                  	; 27/07/2018 - Retro DOS v3.0
 23600                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 4671h 
 23601                                  	; 15/03/2018 - Retro DOS v2.0
 23602                                  
 23603 00003E5C A1[4803]                	MOV	AX,[LASTENT]
 23604 00003E5F 3B06[DA05]              	CMP	AX,[ENTLAST]
 23605 00003E63 7422                    	JZ	short NONE
 23606 00003E65 40                      	INC	AX
 23607                                  	;ADD	BX,32
 23608 00003E66 8D5F20                  	LEA	BX,[BX+32]
 23609 00003E69 39D3                    	CMP	BX,DX
 23610                                  	; 21/11/2022 - MSDOS 5.0 MSDOS.SYS (DOSCODE:7D5Dh)
 23611                                  	;JB	short HAVIT ; MSDOS 6.0 src (dir.asm)
 23612                                  	; 16/12/2022
 23613 00003E6B 751C                    	jne	short HAVIT ; MSDOS 6.21 (DOSCODE:7D97h)
 23614 00003E6D 8A1E[7305]              	MOV	BL,[SECCLUSPOS]
 23615 00003E71 FEC3                    	INC	BL
 23616 00003E73 3A1E[7705]              	CMP	BL,[CLUSFAC]
 23617 00003E77 7215                    	JB	short SAMECLUS
 23618 00003E79 8B1E[DC05]              	MOV	BX,[NXTCLUSNUM]
 23619 00003E7D E8C716                  	call	IsEOF
 23620 00003E80 7305                    	JAE	short NONE
 23621                                  	; 23/07/2019
 23622 00003E82 83FB02                  	CMP	BX,2
 23623                                  	;JB	short NONE
 23624                                  	;JMP	short GETENT
 23625                                  	; 16/12/2022
 23626 00003E85 732D                    	jnb	short GETENT
 23627                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23628                                  	;JB	short NONE
 23629                                  	;JMP	short GETENT
 23630                                  NONE:
 23631 00003E87 F9                      	STC
 23632 00003E88 C3                      	retn
 23633                                  HAVIT:
 23634 00003E89 A3[4803]                	MOV	[LASTENT],AX
 23635 00003E8C F8                      	CLC
 23636                                  nextentry_retn:
 23637 00003E8D C3                      	retn
 23638                                  SAMECLUS:
 23639 00003E8E 881E[7305]              	MOV	[SECCLUSPOS],BL
 23640 00003E92 A3[4803]                	MOV	[LASTENT],AX
 23641 00003E95 1E                      	PUSH	DS
 23642 00003E96 C53E[E205]              	LDS	DI,[CURBUF]
 23643                                  	; 19/05/2019
 23644                                  	; MSDOS 6.0
 23645                                  	;;mov	dx,[di+8]
 23646                                  	; 23/09/2023
 23647                                  	;MOV	DX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 23648                                  ;hkn; SS override
 23649                                  	;MOV	[SS:HIGH_SECTOR],DX 		;AN000; >32mb
 23650                                  	; 23/09/2023
 23651 00003E9A 8B7508                  	mov	si,[di+BUFFINFO.buf_sector+2]	
 23652                                  	
 23653                                  	;mov	dx,[di+6]
 23654 00003E9D 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector]	;AN000; >32mb
 23655                                  	;inc	dx ; MSDOS 3.3
 23656                                  	; MSDOS 6.0
 23657                                  	;ADD	DX,1				;AN000; >32mb
 23658                                  	;ADC	word [SS:HIGH_SECTOR],0 	;AN000; >32mb
 23659                                  	; 23/09/2023
 23660 00003EA0 42                      	inc	dx
 23661 00003EA1 7501                    	jnz	short nextexntry_fc
 23662 00003EA3 46                      	inc	si
 23663                                  	;inc	word [SS:HIGH_SECTOR]
 23664                                  nextexntry_fc:
 23665                                  	; 23/09/2023
 23666 00003EA4 368936[0706]            	mov	[SS:HIGH_SECTOR],si
 23667                                  	; MSDOS 3.3 & MSDOS 6.0
 23668 00003EA9 1F                      	POP	DS
 23669 00003EAA E844F8                  	call	FIRSTCLUSTER
 23670 00003EAD 31DB                    	XOR	BX,BX
 23671 00003EAF EB23                    	JMP	short SETENTRY
 23672                                  
 23673                                  ;----------------------------------------------------------------------------
 23674                                  ;
 23675                                  ; Procedure Name : GETENTRY
 23676                                  ;
 23677                                  ; Inputs:
 23678                                  ;	[LASTENT] has directory entry
 23679                                  ;	ES:BP points to drive parameters
 23680                                  ;	[DIRSEC],[CLUSNUM],[CLUSFAC],[ENTLAST] set for DIR involved
 23681                                  ; Function:
 23682                                  ;	Locates directory entry in preparation for search
 23683                                  ;	GETENT provides entry for passing desired entry in AX
 23684                                  ; Outputs:
 23685                                  ;	[CURBUF+2]:BX = Pointer to next directory entry in CURBUF
 23686                                  ;	[CURBUF+2]:DX = Pointer to first byte after end of CURBUF
 23687                                  ;	[LASTENT] = New directory entry number
 23688                                  ;	[NXTCLUSNUM],[SECCLUSPOS] set via DIRREAD
 23689                                  ;	Carry set if error (currently user FAILed to I 24)
 23690                                  ;----------------------------------------------------------------------------
 23691                                  
 23692                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23693                                  GETENTRY:
 23694                                  	; 27/07/2018 - Retro DOS v3.0
 23695 00003EB1 A1[4803]                	MOV	AX,[LASTENT]
 23696                                  
 23697                                  	;entry	GETENT
 23698                                  GETENT:
 23699 00003EB4 A3[4803]                	MOV	[LASTENT],AX
 23700                                  ;
 23701                                  ; Convert the entry number in AX into a byte offset from the beginning of the
 23702                                  ; directory.
 23703                                  ;
 23704 00003EB7 B105                    	mov	cl,5			; shift left by 5 = mult by 32
 23705 00003EB9 D3C0                    	rol	ax,cl			; keep hight order bits
 23706 00003EBB 89C2                    	mov	dx,ax
 23707                                  	; 19/05/2019 - Retro DOS v4.0
 23708                                  	;and	ax,0FFE0h
 23709                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23710                                  	;and	ax,~(32-1)		; mask off high order bits
 23711                                  	; 16/12/2022
 23712 00003EBD 24E0                    	and	al,0E0h ; ~31
 23713 00003EBF 83E21F                  	and	dx,1Fh
 23714                                  	;and	dx,32-1			; mask off low order bits
 23715                                  ;
 23716                                  ; DX:AX contain the byte offset of the required directory entry from the
 23717                                  ; beginning of the directory. Convert this to a sector number. Round the
 23718                                  ; sector size down to a multiple of 32.
 23719                                  ;
 23720                                  	;mov	bx,[es:bp+2]
 23721 00003EC2 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 23722 00003EC6 80E3E0                  	and	bl,0E0h
 23723                                  	;AND	BL,255-31		; Must be multiple of 32
 23724 00003EC9 F7F3                    	DIV	BX
 23725 00003ECB 89D3                    	MOV	BX,DX			; Position within sector
 23726 00003ECD 53                      	PUSH	BX
 23727 00003ECE E8CCF7                  	call	DIRREAD
 23728 00003ED1 5B                      	POP	BX
 23729                                  	;retc
 23730 00003ED2 72B9                    	jc	short nextentry_retn	
 23731                                  SETENTRY:
 23732 00003ED4 8B16[E205]              	MOV	DX,[CURBUF]
 23733                                  	;add	dx,16 ; MSDOS 3.3
 23734                                  	;add	dx,20 ; MSDOS 6.0 
 23735 00003ED8 83C214                  	ADD	DX,BUFINSIZ
 23736 00003EDB 01D3                    	ADD	BX,DX
 23737                                  	;add	dx,[es:bp+2]
 23738 00003EDD 26035602                	ADD	DX,[ES:BP+DPB.SECTOR_SIZE]  ; Always clears carry
 23739                                  	; 29/12/2022
 23740                                  	; MSDOS 6.21 MSDOS.SYS contains a 'CLC' here, at DOSCODE:7E15h
 23741 00003EE1 F8                      	clc
 23742 00003EE2 C3                      	retn
 23743                                  
 23744                                  ;Break	<SETDIRSRCH SETROOTSRCH -- Set Search environments>
 23745                                  ;----------------------------------------------------------------------------
 23746                                  ;
 23747                                  ; Procedure Name : SETDIRSRCH,SETROOTSRCH
 23748                                  ;
 23749                                  ; Inputs:
 23750                                  ;	BX cluster number of start of directory
 23751                                  ;	ES:BP Points to DPB
 23752                                  ;	DI next cluster number from fastopen extended info. DOS 3.3 only
 23753                                  ; Function:
 23754                                  ;	Set up a directory search
 23755                                  ; Outputs:
 23756                                  ;	[DIRSTART] = BX
 23757                                  ;	[CLUSFAC],[CLUSNUM],[SECCLUSPOS],[DIRSEC] set
 23758                                  ;	Carry set if error (currently user FAILed to I 24)
 23759                                  ; destroys AX,DX,BX
 23760                                  ;----------------------------------------------------------------------------
 23761                                  
 23762                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23763                                  SETDIRSRCH:
 23764 00003EE3 09DB                    	OR	BX,BX
 23765 00003EE5 7437                    	JZ	short SETROOTSRCH
 23766 00003EE7 891E[C205]              	MOV	[DIRSTART],BX
 23767                                  	;mov	al,[es:bp+4]
 23768 00003EEB 268A4604                	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 23769 00003EEF FEC0                    	INC	AL
 23770 00003EF1 A2[7705]                	MOV	[CLUSFAC],AL
 23771                                  
 23772                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 23773                                  	;SAVE	<SI>
 23774 00003EF4 56                      	push	si
 23775                                  	;test	byte [FastOpenFlg],2
 23776 00003EF5 F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success
 23777 00003EFA 7507                    	JNZ	short UNP_OK
 23778                                  
 23779                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 23780                                  	;invoke	UNPACK
 23781 00003EFC E85F16                  	call	UNPACK
 23782 00003EFF 7302                    	JNC	short UNP_OK
 23783                                  	;RESTORE <SI>
 23784 00003F01 5E                      	pop	si
 23785                                  	;return
 23786 00003F02 C3                      	retn
 23787                                  
 23788                                  UNP_OK:
 23789 00003F03 893E[BC05]              	MOV	[CLUSNUM],DI
 23790 00003F07 89DA                    	MOV	DX,BX
 23791 00003F09 30DB                    	XOR	BL,BL
 23792 00003F0B 881E[7305]              	MOV	[SECCLUSPOS],BL
 23793                                  	;invoke	FIGREC
 23794 00003F0F E8F50E                  	call	FIGREC
 23795                                  	;RESTORE <SI>
 23796 00003F12 5E                      	pop	si
 23797                                  	
 23798                                  	; 19/05/2019 - Retro DOS v4.0
 23799                                  
 23800                                  	; MSDOS 6.0
 23801                                  	;PUSH	DX			   ;AN000; >32mb
 23802                                  	;MOV	DX,[HIGH_SECTOR]	   ;AN000; >32mb
 23803                                  	;MOV	[DIRSEC+2],DX		   ;AN000; >32mb
 23804                                  	;POP	DX			   ;AN000; >32mb
 23805                                  
 23806                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23807                                  	;push	dx
 23808                                  	;mov	dx,[HIGH_SECTOR]
 23809                                  	;mov	[DIRSEC+2],dx
 23810                                  	;pop	dx
 23811                                  	;MOV	[DIRSEC],dx
 23812                                  	; 16/12/2022
 23813 00003F13 A1[0706]                	mov	ax,[HIGH_SECTOR]
 23814 00003F16 A3[C005]                	mov	[DIRSEC+2],AX
 23815 00003F19 8916[BE05]              	MOV	[DIRSEC],DX
 23816                                  
 23817                                  	; 16/12/2022
 23818                                  	; cf=0 (at the return of FIGREC)
 23819                                  	;CLC
 23820 00003F1D C3                      	retn
 23821                                  
 23822                                  	;entry	SETROOTSRCH
 23823                                  SETROOTSRCH:
 23824 00003F1E 31C0                    	XOR	AX,AX
 23825 00003F20 A3[C205]                	MOV	[DIRSTART],AX
 23826                                  	; 22/09/2023
 23827 00003F23 A3[C005]                	mov	[DIRSEC+2],ax ; 0
 23828 00003F26 A2[7305]                	MOV	[SECCLUSPOS],AL
 23829 00003F29 48                      	DEC	AX
 23830 00003F2A A3[BC05]                	MOV	[CLUSNUM],AX
 23831                                  	;mov	ax,[es:bp+0Bh]
 23832 00003F2D 268B460B                	MOV	AX,[ES:BP+DPB.FIRST_SECTOR]
 23833                                  	; 19/05/2019
 23834                                  	;;mov	dx,[es:bp+10h] ; MSDOS 3.3
 23835                                  	;mov	dx,[es:bp+11h] ; MSDOS 6.0
 23836 00003F31 268B5611                	MOV	DX,[ES:BP+DPB.DIR_SECTOR]
 23837 00003F35 29D0                    	SUB	AX,DX
 23838 00003F37 A2[7705]                	MOV	[CLUSFAC],AL
 23839 00003F3A 8916[BE05]              	MOV	[DIRSEC],DX		      ;F.C. >32mb
 23840                                  	; 22/09/2023
 23841                                  	; MSDOS 6.0
 23842                                  	;MOV	WORD [DIRSEC+2],0	      ;F.C. >32mb
 23843 00003F3E F8                      	CLC
 23844 00003F3F C3                      	retn
 23845                                  
 23846                                  ;============================================================================
 23847                                  ; DIR2.ASM, MSDOS 6.0, 1991
 23848                                  ;============================================================================
 23849                                  ; 27/07/2018 - Retro DOS v3.0
 23850                                  ; 19/05/2019 - Retro DOS v4.0 
 23851                                  
 23852                                  ;	TITLE	DIR2 - Directory and path cracking
 23853                                  ;	NAME	Dir2
 23854                                  
 23855                                  ;Break	<GETPATH -- PARSE A WFP>
 23856                                  ;----------------------------------------------------------------------------
 23857                                  ;
 23858                                  ; Procedure Name : GETPATH
 23859                                  ;
 23860                                  ; Inputs:
 23861                                  ;	[WFP_START] Points to WFP string ("d:\" must be first 3 chars, NUL
 23862                                  ;		terminated; d:/ (note forward slash) indicates a real device).
 23863                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 23864                                  ;		( = -1 if current dir not involved, else
 23865                                  ;		 Points to first char after last "/" of current dir part)
 23866                                  ;	[THISCDS] Points to CDS being used
 23867                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 23868                                  ;	[NoSetDir] set
 23869                                  ;	[THISDPB] set to DPB if disk otherwise garbage.
 23870                                  ; Function:
 23871                                  ;	Crack the path
 23872                                  ; Outputs:
 23873                                  ;	Sets EXTERR_LOCUS = errLOC_Disk if disk file
 23874                                  ;	Sets EXTERR_LOCUS = errLOC_Unk if char device
 23875                                  ;	ID1 field of [THISCDS] updated appropriately
 23876                                  ;	[ATTRIB] = [SATTRIB]
 23877                                  ;	ES:BP Points to DPB
 23878                                  ;	Carry set if bad path
 23879                                  ;	   SI Points to path element causing failure
 23880                                  ;	   Zero set
 23881                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 23882                                  ;	      start a search on the last directory
 23883                                  ;	      CL is zero if there is a bad name in the path
 23884                                  ;	      CL is non-zero if the name was simply not found
 23885                                  ;		 [ENTFREE] may have free spot in directory
 23886                                  ;		 [NAME1] is the name.
 23887                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 23888                                  ;	   Zero reset
 23889                                  ;	      File in middle of path or bad name in path or attribute mismatch
 23890                                  ;		or path too long or malformed path
 23891                                  ;	ELSE
 23892                                  ;	   [CurBuf] = -1 if root directory
 23893                                  ;	   [CURBUF] contains directory record with match
 23894                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 23895                                  ;	   [CURBUF+2]:SI Points into [CURBUF] to dir_first field for entry
 23896                                  ;	   AH = device ID
 23897                                  ;	      bit 7 of AH set if device SI and BX
 23898                                  ;	      will point DOSGROUP relative The firclus
 23899                                  ;	      field of the device entry contains the device pointer
 23900                                  ;	   [NAME1] Has name looked for
 23901                                  ;	   If last element is a directory zero is set and:
 23902                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 23903                                  ;	      are set up to start a search on it.
 23904                                  ;	      unless [NoSetDir] is non zero in which case the return is
 23905                                  ;	      like that for a file (except for zero flag)
 23906                                  ;	   If last element is a file zero is reset
 23907                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 23908                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 23909                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 23910                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 23911                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 23912                                  ; DS preserved, Others destroyed
 23913                                  ;---------------------------------------------------------------------------
 23914                                  
 23915                                  ;hkn; called from delete.asm, finfo.asm, mknode.asm and rename.asm.
 23916                                  ;hkn; DS already set up at this point.
 23917                                  
 23918                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23919                                  GETPATH:
 23920                                  	;mov	word [CREATING],0E500h
 23921 00003F40 C706[7E05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Not Creating, not DEL *.*
 23922                                  
 23923                                  ; Same as GetPath only CREATING and DELALL already set
 23924                                  
 23925                                  	;entry	GetPathNoSet
 23926                                  GetPathNoSet:
 23927                                  	;mov	byte [EXTERR_LOCUS],2	
 23928 00003F46 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 23929 00003F4B C706[E205]FFFF          	MOV	word [CURBUF],-1	; initial setting
 23930                                  
 23931                                  ; See if the input indicates a device that has already been detected. If so,
 23932                                  ; go build the guy quickly. Otherwise, let findpath find the device.
 23933                                  
 23934 00003F51 8B3E[B205]              	MOV	DI,[WFP_START]		; point to the beginning of the name
 23935                                  	;cmp	word [DI+1],5C3Ah
 23936                                  	;CMP	WORD [DI+1],'\' << 8 + ':'
 23937 00003F55 817D013A5C              	cmp	word [DI+1],':\'
 23938 00003F5A 7438                    	JZ	short CrackIt
 23939                                  
 23940                                  ; Let ChkDev find it in the device list
 23941                                  
 23942 00003F5C 83C703                  	ADD	DI,3
 23943                                  	; 18/08/2018
 23944                                  	;MOV	SI,DI			; let CHKDEV see the original name
 23945                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23946                                  	; 16/12/2022
 23947                                  	;mov	si,di ; not required ! (it is written in CHKDEV proc already!)
 23948 00003F5F E8AB00                  	CALL	CHKDEV
 23949 00003F62 722E                    	JC	short InternalError
 23950                                  
 23951                                  Build_devJ:
 23952 00003F64 A0[6D05]                	MOV	AL,[SATTRIB]
 23953 00003F67 A2[6B05]                	MOV	[ATTRIB],AL
 23954                                  	;mov	byte [EXTERR_LOCUS],1
 23955 00003F6A C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; In the particular case of
 23956                                  					; "finding" a char device
 23957                                  					; set LOCUS to Unknown. This makes
 23958                                  					; certain idiotic problems reported
 23959                                  					; by a certain 3 letter OEM go away.
 23960                                  
 23961                                  ; Take name in name1 and pack it back into where wfp_start points. This
 23962                                  ; guarantees wfp_start pointing to a canonical representation of a device.
 23963                                  ; We are allowed to do this as GetPath is *ALWAYS* called before entering a
 23964                                  ; wfp into the share set.
 23965                                  ;
 23966                                  ; We copy chars from name1 to wfp_start remembering the position of the last
 23967                                  ; non-space seen +1.  This position is kept in DX.
 23968                                  
 23969                                  ;hkn; SS is DOSDATA
 23970 00003F6F 16                      	push	ss
 23971 00003F70 07                      	pop	es
 23972                                  
 23973                                  ;hkn; NAME1 is in DOSDATA
 23974 00003F71 BE[4B05]                	mov	si,NAME1
 23975 00003F74 8B3E[B205]              	mov	di,[WFP_START]
 23976 00003F78 89FA                    	mov	dx,di
 23977 00003F7A B90800                  	mov	cx,8			; 8 chars in device name
 23978                                  MoveLoop:
 23979 00003F7D AC                      	lodsb
 23980 00003F7E AA                      	stosb
 23981 00003F7F 3C20                    	cmp	al," "
 23982 00003F81 7402                    	jz	short NoSave
 23983                                  
 23984 00003F83 89FA                    	mov	dx,di
 23985                                  NoSave:
 23986 00003F85 E2F6                    	loop	MoveLoop
 23987                                  
 23988                                  ; DX is the position of the last seen non-space + 1. We terminate the name
 23989                                  ; at this point.
 23990                                  
 23991 00003F87 89D7                    	mov	di,dx
 23992 00003F89 C60500                  	mov	byte [di],0		; end of string
 23993 00003F8C E8C402                  	call	Build_device_ent	; Clears carry sets zero
 23994 00003F8F FEC0                    	INC	AL			; reset zero
 23995 00003F91 C3                      	retn
 23996                                  
 23997                                  InternalError:
 23998                                  InternalError_loop:
 23999 00003F92 EBFE                    	JMP	short InternalError_loop	; freeze
 24000                                  
 24001                                  ; Start off at the correct spot. Optimize if the current dir part is valid.
 24002                                  
 24003                                  CrackIt:
 24004 00003F94 8B36[B605]              	MOV	SI,[CURR_DIR_END]	; get current directory pointer
 24005 00003F98 83FEFF                  	CMP	SI,-1			; valid?
 24006 00003F9B 7503                    	JNZ	short LOOK_SING		; Yes, use it.
 24007 00003F9D 8D7503                  	LEA	SI,[DI+3]		; skip D:\.
 24008                                  LOOK_SING:
 24009                                  	;mov	byte [ATTRIB],16h
 24010 00003FA0 C606[6B05]16            	MOV	byte [ATTRIB],attr_directory+attr_system+attr_hidden
 24011                                  					; Attributes to search through Dirs
 24012 00003FA5 C43E[A205]              	LES	DI,[THISCDS]
 24013 00003FA9 B8FFFF                  	MOV	AX,-1
 24014                                  	;mov	bx,[es:di+73]
 24015 00003FAC 268B5D49                	MOV	BX,[ES:DI+curdir.ID]
 24016 00003FB0 8B36[B605]              	MOV	SI,[CURR_DIR_END]
 24017                                  
 24018                                  ; AX = -1
 24019                                  ; BX = cluster number of current directory. THis number is -1 if the media
 24020                                  ;      has been uncertainly changed.
 24021                                  ; SI = offset in DOSGroup into path to end of current directory text. This
 24022                                  ;      may be -1 if no current directory part has been used.
 24023                                  
 24024 00003FB4 39C6                    	CMP	SI,AX			; if Current directory is not part
 24025 00003FB6 743B                    	JZ	short NO_CURR_D		; then we must crack from root
 24026 00003FB8 39C3                    	CMP	BX,AX			; is the current directory cluster valid
 24027                                  
 24028                                  ; DOS 3.3  6/25/86
 24029 00003FBA 7437                    	JZ	short NO_CURR_D		; no, crack form the root
 24030                                  	;test	byte [FastOpenFlg],1
 24031 00003FBC F606[3A0D]01            	TEST	byte [FastOpenFlg],FastOpen_Set ; for fastopen ?
 24032 00003FC1 743D                    	JZ	short GOT_SEARCH_CLUSTER	; no
 24033 00003FC3 06                      	PUSH	ES			; save registers
 24034 00003FC4 57                      	PUSH	DI
 24035 00003FC5 51                      	PUSH	CX
 24036 00003FC6 FF74FF                  	PUSH	word [SI-1]		; save \ and 1st char of next element
 24037 00003FC9 56                      	PUSH	SI
 24038 00003FCA 53                      	PUSH	BX
 24039                                  
 24040 00003FCB C644FF00                	MOV	BYTE [SI-1],0		; call fastopen to look up cur dir info
 24041 00003FCF 8B36[B205]              	MOV	SI,[WFP_START]
 24042                                  
 24043                                  ;hkn; FastOpenTable, Dir_Info_Buff & FastOpen_Ext_Info are in DOSDATA
 24044 00003FD3 BB[300D]                	MOV	BX,FastOpenTable
 24045 00003FD6 BF[460D]                	MOV	DI,Dir_Info_Buff
 24046 00003FD9 B9[3B0D]                	MOV	CX,FastOpen_Ext_Info
 24047                                  	;mov	al,1
 24048 00003FDC B001                    	MOV	AL,FONC_Look_up
 24049 00003FDE 1E                      	PUSH	DS
 24050 00003FDF 07                      	POP	ES
 24051                                  	;call	far [BX+2]
 24052 00003FE0 FF5F02                  	CALL	far [BX+fastopen_entry.name_caching]
 24053 00003FE3 7203                    	JC	short GO_Chk_end1 	;fastopen not installed, or wrong drive.
 24054                                  					; Go to Got_Srch_cluster
 24055                                  	; 29/12/2022
 24056                                  	;CMP	BYTE [SI],0		;fastopen has current dir info?
 24057                                  	;JE	short GO_Chk_end	;yes. Go to got_search_cluster
 24058                                  	;stc
 24059                                  	;jmp	short GO_Chk_end	;Go to No_Curr_D
 24060                                  
 24061 00003FE5 803C01                  	cmp	byte [si],1
 24062                                  GO_Chk_end1:	; 29/12/2022
 24063 00003FE8 F5                      	cmc 
 24064                                  	; [si] = 0 -> cf = 0
 24065                                  	; [si] > 0 -> cf = 1
 24066                                  
 24067                                  ;GO_Chk_end1:
 24068                                  	; 29/12/2022
 24069                                  	;clc
 24070                                  
 24071                                  GO_Chk_end:				; restore registers
 24072 00003FE9 5B                      	POP	BX
 24073 00003FEA 5E                      	POP	SI
 24074 00003FEB 8F44FF                  	POP	word [SI-1]
 24075 00003FEE 59                      	POP	CX
 24076 00003FEF 5F                      	POP	DI
 24077 00003FF0 07                      	POP	ES
 24078 00003FF1 730D                    	JNC	short GOT_SEARCH_CLUSTER ; crack based on cur dir
 24079                                  
 24080                                  ; DOS 3.3  6/25/86
 24081                                  ;
 24082                                  ; We must cract the path beginning at the root. Advance pointer to beginning
 24083                                  ; of path and go crack from root.
 24084                                  
 24085                                  NO_CURR_D:
 24086 00003FF3 8B36[B205]              	MOV	SI,[WFP_START]
 24087 00003FF7 8D7403                  	LEA	SI,[SI+3]		; Skip "d:/"
 24088 00003FFA C42E[8A05]              	LES	BP,[THISDPB]		; Get ES:BP
 24089 00003FFE EB3B                    	JMP	short ROOTPATH
 24090                                  
 24091                                  ; We are able to crack from the current directory part. Go set up for search
 24092                                  ; of specified cluster.
 24093                                  
 24094                                  GOT_SEARCH_CLUSTER:
 24095 00004000 C42E[8A05]              	LES	BP,[THISDPB]		; Get ES:BP
 24096 00004004 E8DCFE                  	call	SETDIRSRCH
 24097                                  	;JC	short SETFERR
 24098                                  	;JMP	short FINDPATH
 24099                                  	; 16/12/2022
 24100 00004007 7342                    	jnc	short FINDPATH ; 17/08/2018
 24101                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24102                                  	;JC	short SETFERR
 24103                                  	;JMP	short FINDPATH
 24104                                  SETFERR:
 24105 00004009 30C9                    	XOR	CL,CL			; set zero
 24106 0000400B F9                      	STC
 24107 0000400C C3                      	retn
 24108                                  
 24109                                  ;---------------------------------------------------------------------------
 24110                                  ;
 24111                                  ; Procedure Name : ChkDev
 24112                                  ;
 24113                                  ; Check to see if the name at DS:DI is a device. Returns carry set if not a
 24114                                  ;   device.
 24115                                  ; Blasts CX,SI,DI,AX,BX
 24116                                  ;---------------------------------------------------------------------------
 24117                                  
 24118                                  CHKDEV:
 24119 0000400D 89FE                    	MOV	SI,DI
 24120 0000400F 8CD7                    	MOV	DI,SS
 24121 00004011 8EC7                    	MOV	ES,DI
 24122                                  
 24123 00004013 BF[4B05]                	MOV	DI,NAME1
 24124 00004016 B90900                  	MOV	CX,9
 24125                                  TESTLOOP:
 24126 00004019 E84910                  	call	GETLET
 24127                                  
 24128 0000401C 3C2E                    	CMP	AL,'.'
 24129 0000401E 740E                    	JZ	short TESTDEVICE
 24130 00004020 E89810                  	call	PATHCHRCMP
 24131 00004023 7407                    	JZ	short NOTDEV
 24132 00004025 08C0                    	OR	AL,AL
 24133 00004027 7405                    	JZ	short TESTDEVICE
 24134                                  
 24135 00004029 AA                      	STOSB
 24136 0000402A E2ED                    	LOOP	TESTLOOP
 24137                                  NOTDEV:
 24138 0000402C F9                      	STC
 24139 0000402D C3                      	retn
 24140                                  
 24141                                  TESTDEVICE:
 24142                                  	;ADD	CX,2
 24143                                  	; 24/09/2023
 24144 0000402E 41                      	inc	cx
 24145 0000402F 41                      	inc	cx
 24146 00004030 B020                    	MOV	AL,' '
 24147 00004032 F3AA                    	REP	STOSB
 24148 00004034 8CD0                    	MOV	AX,SS
 24149 00004036 8ED8                    	MOV	DS,AX
 24150                                  	;call	DEVNAME
 24151                                  	;retn
 24152                                  	; 18/12/2022
 24153 00004038 E9B901                  	jmp	DEVNAME
 24154                                  
 24155                                  ;Break	<ROOTPATH, FINDPATH -- PARSE A PATH>
 24156                                  ;----------------------------------------------------------------------------
 24157                                  ;
 24158                                  ; Procedure Name : ROOTPATH,FINDPATH
 24159                                  ;
 24160                                  ; Inputs:
 24161                                  ;	Same as FINDPATH but,
 24162                                  ;	SI Points to asciz string of path which is assumed to start at
 24163                                  ;		the root (no leading '/').
 24164                                  ; Function:
 24165                                  ;	Search from root for path
 24166                                  ; Outputs:
 24167                                  ;	Same as FINDPATH but:
 24168                                  ;	If root directory specified, [CURBUF] and [NAME1] are NOT set, and
 24169                                  ;	[NoSetDir] is ignored.
 24170                                  ;----------------------------------------------------------------------------
 24171                                  
 24172                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24173                                  	; DOSCODE:7F47h (MSDOS 5.0, MSDOS.SYS)
 24174                                  
 24175                                  ROOTPATH:
 24176 0000403B E8E0FE                  	call	SETROOTSRCH
 24177                                  	; 24/09/2023
 24178 0000403E 30E4                    	xor	ah,ah
 24179                                  	;CMP	BYTE [SI],0
 24180 00004040 3824                    	cmp	[si],ah ; 0
 24181 00004042 7507                    	JNZ	short FINDPATH
 24182                                  
 24183                                  ; Root dir specified
 24184 00004044 A0[6D05]                	MOV	AL,[SATTRIB]
 24185 00004047 A2[6B05]                	MOV	[ATTRIB],AL
 24186                                  	; 24/09/2023
 24187                                  	;XOR	AH,AH			; Sets "device ID" byte, sets zero
 24188                                  					; (dir), clears carry.
 24189 0000404A C3                      	retn
 24190                                  
 24191                                  ; Inputs:
 24192                                  ;	[ATTRIB] Set to get through directories
 24193                                  ;	[SATTRIB] Set to find last element
 24194                                  ;	ES:BP Points to DPB
 24195                                  ;	SI Points to asciz string of path (no leading '/').
 24196                                  ;	[SECCLUSPOS] = 0
 24197                                  ;	[DIRSEC] = Phys sec # of first sector of directory
 24198                                  ;	[CLUSNUM] = Cluster # of next cluster
 24199                                  ;	[CLUSFAC] = Sectors per cluster
 24200                                  ;	[NoSetDir] set
 24201                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 24202                                  ;		( = -1 if current dir not involved, else
 24203                                  ;		 Points to first char after last "/" of current dir part)
 24204                                  ;	[THISCDS] Points to CDS being used
 24205                                  ;	[CREATING] and [DELALL] set
 24206                                  ; Function:
 24207                                  ;	Parse path name
 24208                                  ; Outputs:
 24209                                  ;	ID1 field of [THISCDS] updated appropriately
 24210                                  ;	[ATTRIB] = [SATTRIB]
 24211                                  ;	ES:BP Points to DPB
 24212                                  ;	[THISDPB] = ES:BP
 24213                                  ;	Carry set if bad path
 24214                                  ;	   SI Points to path element causing failure
 24215                                  ;	   Zero set
 24216                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 24217                                  ;	      start a search on the last directory
 24218                                  ;	      CL is zero if there is a bad name in the path
 24219                                  ;	      CL is non-zero if the name was simply not found
 24220                                  ;		 [ENTFREE] may have free spot in directory
 24221                                  ;		 [NAME1] is the name.
 24222                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 24223                                  ;	   Zero reset
 24224                                  ;	      File in middle of path or bad name in path
 24225                                  ;		or path too long or malformed path
 24226                                  ;	ELSE
 24227                                  ;	   [CURBUF] contains directory record with match
 24228                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 24229                                  ;	   [CURBUF+2]:SI Points to fcb_FIRCLUS field for entry
 24230                                  ;	   [NAME1] Has name looked for
 24231                                  ;	   AH = device ID
 24232                                  ;	      bit 7 of AH set if device SI and BX
 24233                                  ;	      will point DOSGROUP relative The firclus
 24234                                  ;	      field of the device entry contains the device pointer
 24235                                  ;	   If last element is a directory zero is set and:
 24236                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 24237                                  ;	      are set up to start a search on it,
 24238                                  ;	      unless [NoSetDir] is non zero in which case the return is
 24239                                  ;	      like that for a file (except for zero flag)
 24240                                  ;	   If last element is a file zero is reset
 24241                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 24242                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 24243                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 24244                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 24245                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 24246                                  ; Destroys all other registers
 24247                                  
 24248                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24249                                  	; DOSCODE:7F58h (MSDOS 5.0, MSDOS.SYS)
 24250                                  
 24251                                      	;entry	FINDPATH
 24252                                  FINDPATH:
 24253 0000404B 06                      	PUSH	ES			; Save ES:BP
 24254 0000404C 56                      	PUSH	SI
 24255 0000404D 89F7                    	MOV	DI,SI
 24256 0000404F 8B0E[C205]              	MOV	CX,[DIRSTART]		; Get start clus of dir being searched
 24257 00004053 833E[B605]FF            	CMP	word [CURR_DIR_END],-1
 24258 00004058 740E                    	JZ	short NOIDS		; No current dir part
 24259 0000405A 3B3E[B605]              	CMP	DI,[CURR_DIR_END]
 24260 0000405E 7508                    	JNZ	short NOIDS		; Not to current dir end yet
 24261 00004060 C43E[A205]              	LES	DI,[THISCDS]
 24262                                  	;mov	[es:di+73],cx
 24263 00004064 26894D49                	MOV	[ES:DI+curdir.ID],CX	; Set current directory currency
 24264                                  NOIDS:
 24265                                  
 24266                                  ; Parse the name off of DS:SI into NAME1. AL = 1 if there was a meta
 24267                                  ; character in the string. CX,DI may be destroyed.
 24268                                  ;
 24269                                  ;	invoke	NAMETRANS
 24270                                  ;	MOV	CL,AL
 24271                                  ;
 24272                                  ; The above is the slow method. The name has *already* been munged by
 24273                                  ; TransPath so no special casing needs to be done. All we do is try to copy
 24274                                  ; the name until ., \ or 0 is hit.
 24275                                  
 24276 00004068 8CD0                    	MOV	AX,SS
 24277 0000406A 8EC0                    	MOV	ES,AX
 24278                                  
 24279                                  ;hkn; Name1 is in DOSDATA
 24280 0000406C BF[4B05]                	MOV	DI,NAME1
 24281 0000406F B82020                  	MOV	AX,'  ' ; 2020h
 24282 00004072 AA                      	STOSB
 24283 00004073 AB                      	STOSW
 24284 00004074 AB                      	STOSW
 24285 00004075 AB                      	STOSW
 24286 00004076 AB                      	STOSW
 24287 00004077 AB                      	STOSW
 24288                                  
 24289                                  ;hkn; Name1 is in DOSDATA
 24290 00004078 BF[4B05]                	MOV	DI,NAME1
 24291 0000407B 30E4                    	XOR	AH,AH			; bits for CL
 24292                                  GetNam:
 24293                                  	; 19/05/2019 - Retro DOS v4.0
 24294                                  	;INC	CL ; ?*! ; MSDOS 6.0	;AN000; KK increment volid count
 24295                                  
 24296                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24297                                  	; 16/12/2022
 24298                                  	;inc	cl ; not required !	
 24299                                  	
 24300 0000407D AC                      	LODSB
 24301 0000407E 3C2E                    	CMP	AL,'.'	; 2Eh
 24302 00004080 7412                    	JZ	short _SetExt
 24303 00004082 08C0                    	OR	AL,AL
 24304 00004084 7424                    	JZ	short _GetDone
 24305 00004086 3C5C                    	CMP	AL,'\'	; 5Ch
 24306 00004088 7420                    	JZ	short _GetDone
 24307 0000408A 3C3F                    	CMP	AL,'?'	; 3Fh
 24308 0000408C 7503                    	JNZ	short StoNam
 24309 0000408E 80CC01                  	OR	AH,1
 24310                                  StoNam: 
 24311 00004091 AA                      	STOSB
 24312 00004092 EBE9                    	JMP	short GetNam
 24313                                  _SetExt:
 24314 00004094 BF[5305]                	MOV	DI,NAME1+8
 24315                                  GetExt:
 24316 00004097 AC                      	LODSB
 24317 00004098 08C0                    	OR	AL,AL
 24318 0000409A 740E                    	JZ	short _GetDone
 24319 0000409C 3C5C                    	CMP	AL,'\'
 24320 0000409E 740A                    	JZ	short _GetDone
 24321 000040A0 3C3F                    	CMP	AL,'?'
 24322 000040A2 7503                    	JNZ	short StoExt
 24323 000040A4 80CC01                  	OR	AH,1
 24324                                  StoExt: 
 24325 000040A7 AA                      	STOSB
 24326 000040A8 EBED                    	JMP	short GetExt
 24327                                  _GetDone:
 24328 000040AA 4E                      	DEC	SI
 24329 000040AB 88E1                    	MOV	CL,AH  ; 0 or 1 ; 29/12/2022
 24330 000040AD 80C980                  	OR	CL,80H
 24331 000040B0 5F                      	POP	DI			; Start of this element
 24332 000040B1 07                      	POP	ES			; Restore ES:BP
 24333 000040B2 39FE                    	CMP	SI,DI
 24334 000040B4 7503                    	JNZ	short check_device
 24335 000040B6 E9E200                  	JMP	_BADPATH		; NUL parse (two delims most likely)
 24336                                  check_device:
 24337 000040B9 56                      	PUSH	SI			; Start of next element
 24338                                  	;MOV	AL,[SI]
 24339                                  	;OR	AL,AL
 24340                                  	; 23/09/2023
 24341 000040BA 803C00                  	cmp	byte [si],0
 24342 000040BD 7508                    	JNZ	short NOT_LAST
 24343                                  
 24344                                  ; for last element of the path switch to the correct search attributes
 24345                                  
 24346 000040BF 8A3E[6D05]              	MOV	BH,[SATTRIB]
 24347 000040C3 883E[6B05]              	MOV	[ATTRIB],BH
 24348                                  
 24349                                  NOT_LAST:
 24350                                  
 24351                                  ; check name1 to see if we have a device...
 24352                                  
 24353 000040C7 06                      	PUSH	ES			; Save ES:BP
 24354                                  
 24355                                  ;hkn; SS is DOSDATA
 24356                                  	;context ES
 24357 000040C8 16                      	push	ss
 24358 000040C9 07                      	pop	es
 24359 000040CA E82701                  	call	DEVNAME 		; blast BX
 24360 000040CD 07                      	POP	ES			; Restore ES:BP
 24361 000040CE 720B                    	JC	short FindFile		; Not a device
 24362 000040D0 08C0                    	OR	AL,AL			; Test next char again
 24363 000040D2 7403                    	JZ	short GO_BDEV
 24364 000040D4 E9C800                  	JMP	FILEINPATH		; Device name in middle of path
 24365                                  
 24366                                  GO_BDEV:
 24367 000040D7 5E                      	POP	SI			; Points to NUL at end of path
 24368 000040D8 E989FE                  	JMP	Build_devJ
 24369                                  
 24370                                  FindFile:
 24371                                  ;;;; 7/28/86
 24372 000040DB 803E[4B05]E5            	CMP	BYTE [NAME1],0E5H	; if 1st char = E5
 24373 000040E0 7505                    	JNZ	short NOE5		; no
 24374 000040E2 C606[4B05]05            	MOV	BYTE [NAME1],05H	; change it to 05
 24375                                  NOE5:
 24376                                  ;;;; 7/28/86
 24377 000040E7 57                      	PUSH	DI			; Start of this element
 24378 000040E8 06                      	PUSH	ES			; Save ES:BP
 24379 000040E9 51                      	PUSH	CX			; CL return from NameTrans
 24380                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 24381                                  
 24382 000040EA E89502                  	CALL	LookupPath		; call fastopen to get dir entry
 24383 000040ED 7303                    	JNC	short DIR_FOUND		; found dir entry
 24384                                  
 24385                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 24386 000040EF E8B0FC                  	call	FINDENTRY
 24387                                  DIR_FOUND:
 24388 000040F2 59                      	POP	CX
 24389 000040F3 07                      	POP	ES
 24390 000040F4 5F                      	POP	DI
 24391 000040F5 7303                    	JNC	short LOAD_BUF
 24392 000040F7 E9CA00                  	JMP	BADPATHPOP
 24393                                  
 24394                                  LOAD_BUF:
 24395 000040FA C53E[E205]              	LDS	DI,[CURBUF]
 24396                                  	;test	byte [bx+0Bh],10h
 24397 000040FE F6470B10                	TEST	BYTE [BX+dir_entry.dir_attr],attr_directory
 24398 00004102 7503                    	JNZ	short GO_NEXT 		; DOS 3.3
 24399 00004104 E99800                  	JMP	FILEINPATH		; Error or end of path
 24400                                  
 24401                                  ; if we are not setting the directory, then check for end of string
 24402                                  
 24403                                  GO_NEXT:
 24404                                  ;hkn; SS override
 24405 00004107 36803E[4C03]00          	CMP	BYTE [SS:NoSetDir],0
 24406 0000410D 7423                    	JZ	short SetDir
 24407 0000410F 89FA                    	MOV	DX,DI			; Save pointer to entry
 24408 00004111 8CD9                    	MOV	CX,DS
 24409                                  
 24410                                  ;hkn; SS is DOSDATA
 24411                                  	;context DS
 24412 00004113 16                      	push	ss
 24413 00004114 1F                      	pop	ds
 24414 00004115 5F                      	POP	DI			; Start of next element
 24415                                  	; 19/05/2019 - Retro DOS v4.0
 24416                                  	; MSDOS 6.0
 24417 00004116 F606[3A0D]01            	TEST	byte [FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 24418 0000411B 740B                    	JZ	short _nofast			; the FastOpen
 24419 0000411D F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success ; Lookup just happened
 24420 00004122 7404                    	JZ	short _nofast			; no
 24421 00004124 8B3E[660D]              	MOV	DI,[Next_Element_Start]	; no need to insert it again
 24422                                  _nofast:
 24423 00004128 803D00                  	CMP	BYTE [DI],0
 24424                                  	;;JNZ	short NEXT_ONE		; DOS 3.3
 24425                                  	;;JMP	_SETRET  ; retn		; Got it
 24426                                  	;retn	; 05/09/2018
 24427                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24428                                  	;jmp	_SETRET
 24429                                  	; 16/12/2022
 24430 0000412B 7421                    	jz	short _SETRET
 24431                                  
 24432                                  NEXT_ONE:
 24433 0000412D 57                      	PUSH	DI			; Put start of next element back on stack
 24434 0000412E 89D7                    	MOV	DI,DX
 24435 00004130 8ED9                    	MOV	DS,CX			; Get back pointer to entry
 24436                                  SetDir:
 24437 00004132 8B14                    	MOV	DX,[SI] 		; Dir_first
 24438                                  
 24439                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 24440 00004134 1E                      	PUSH	DS		      ; save [curbuf+2]
 24441                                  ;hkn; SS is DOSDATA
 24442 00004135 16                      	push	ss
 24443 00004136 1F                      	pop	ds		      ; set DS Dosgroup
 24444                                  	;test	byte [FastOpenFlg],2
 24445 00004137 F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success
 24446 0000413C 7411                    	JZ	short DO_NORMAL	      ; fastopen not in memory or path not
 24447 0000413E 89D3                    	MOV	BX,DX		      ; not found
 24448 00004140 8B3E[BC05]              	MOV	DI,[CLUSNUM]	      ; clusnum was set in LookupPath
 24449 00004144 50                      	PUSH	AX		      ; save device id (AH)
 24450 00004145 E89BFD                  	call	SETDIRSRCH
 24451 00004148 58                      	POP	AX		      ; restore device id (AH)
 24452 00004149 83C402                  	ADD	SP,2		      ; pop ds in stack
 24453 0000414C EB37                    	JMP	short FAST_OPEN_SKIP
 24454                                  
 24455                                  	; 16/12/2022
 24456                                  _SETRET:
 24457 0000414E C3                      	retn
 24458                                  
 24459                                  DO_NORMAL:
 24460 0000414F 1F                      	POP	DS			; DS = [curbuf + 2]
 24461                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 24462                                  
 24463 00004150 29FB                    	SUB	BX,DI			; Offset into sector of start of entry
 24464 00004152 29FE                    	SUB	SI,DI			; Offset into sector of dir_first
 24465 00004154 53                      	PUSH	BX
 24466 00004155 50                      	PUSH	AX
 24467 00004156 56                      	PUSH	SI
 24468 00004157 51                      	PUSH	CX
 24469                                  	;push	word [di+6]
 24470 00004158 FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector]	;AN000;>32mb
 24471                                  	; 19/05/2019
 24472                                  	; MSDOS 6.0
 24473                                  	;push	word [di+8]
 24474 0000415B FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;AN000;>32mb
 24475 0000415E 89D3                    	MOV	BX,DX
 24476                                  
 24477                                  ;hkn; SS is DOSDATA
 24478                                  	;context DS
 24479 00004160 16                      	push	ss
 24480 00004161 1F                      	pop	ds
 24481                                  	;invoke	SETDIRSRCH		; This uses UNPACK which might blow
 24482 00004162 E87EFD                  	call	SETDIRSRCH		; the entry sector buffer
 24483                                  	; 19/05/2019
 24484                                  	; MSDOS 6.0
 24485 00004165 8F06[0706]              	POP	word [HIGH_SECTOR]
 24486 00004169 5A                      	POP	DX
 24487 0000416A 7203                    	JC	short SKIP_GETB
 24488                                  	; 22/09/2023
 24489                                  	;;mov	byte [ALLOWED],18h
 24490                                  	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 24491                                  	;XOR	AL,AL ; *
 24492                                  	;;invoke GETBUFFR		; Get the entry buffer back
 24493                                  	;call	GETBUFFR
 24494 0000416C E8FA17                  	call	GETBUFFER ; * ; pre-read
 24495                                  SKIP_GETB:
 24496 0000416F 59                      	POP	CX
 24497 00004170 5E                      	POP	SI
 24498 00004171 58                      	POP	AX
 24499 00004172 5B                      	POP	BX
 24500 00004173 7305                    	JNC	short SET_THE_BUF
 24501 00004175 5F                      	POP	DI			; Start of next element
 24502 00004176 89FE                    	MOV	SI,DI			; Point with SI
 24503 00004178 EB21                    	JMP	SHORT _BADPATH
 24504                                  
 24505                                  SET_THE_BUF:
 24506 0000417A E879F5                  	call	SET_BUF_AS_DIR
 24507 0000417D 8B3E[E205]              	MOV	DI,[CURBUF]
 24508 00004181 01FE                    	ADD	SI,DI			; Get the offsets back
 24509 00004183 01FB                    	ADD	BX,DI
 24510                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 24511                                  FAST_OPEN_SKIP:
 24512 00004185 5F                      	POP	DI			; Start of next element
 24513 00004186 E89D02                  	CALL	InsertPath		; insert dir entry info
 24514                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 24515 00004189 8A05                    	MOV	AL,[DI]
 24516 0000418B 08C0                    	OR	AL,AL
 24517 0000418D 74BF                    	JZ	short _SETRET		; At end
 24518 0000418F 47                      	INC	DI			; Skip over "/"
 24519 00004190 89FE                    	MOV	SI,DI			; Point with SI
 24520 00004192 E8260F                  	call	PATHCHRCMP
 24521 00004195 7503                    	JNZ	short find_bad_name	; oops
 24522 00004197 E9B1FE                  	JMP	FINDPATH		; Next element
 24523                                  
 24524                                  find_bad_name:
 24525 0000419A 4E                      	DEC	SI			; Undo above INC to get failure point
 24526                                  _BADPATH:
 24527 0000419B 30C9                    	XOR	CL,CL			; Set zero
 24528 0000419D EB2C                    	JMP	SHORT BADPRET
 24529                                  
 24530                                  FILEINPATH:
 24531 0000419F 5F                      	POP	DI			; Start of next element
 24532                                  
 24533                                  ;hkn; SS is DOSDATA
 24534                                  	;context DS			; Got to from one place with DS gone
 24535 000041A0 16                      	push	ss
 24536 000041A1 1F                      	pop	ds
 24537                                  
 24538                                  ; DOS 3.3 FastOpen
 24539                                  	;test	byte [FastOpenFlg],1
 24540 000041A2 F606[3A0D]01            	TEST	byte [FastOpenFlg],FastOpen_Set  ; do this here is we don't want to
 24541 000041A7 740B                    	JZ	short NO_FAST		; device info to fastopen
 24542                                  	;test	byte [FastOpenFlg],2
 24543 000041A9 F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success
 24544 000041AE 7404                    	JZ	short NO_FAST
 24545 000041B0 8B3E[660D]              	MOV	DI,[Next_Element_Start]  ; This takes care of one time lookup
 24546                                  					 ; success
 24547                                  NO_FAST:
 24548                                  ; DOS 3.3 FastOpen
 24549 000041B4 8A05                    	MOV	AL,[DI]
 24550 000041B6 08C0                    	OR	AL,AL
 24551 000041B8 7404                    	JZ	short INCRET
 24552 000041BA 89FE                    	MOV	SI,DI			; Path too long
 24553 000041BC EB0D                    	JMP	SHORT BADPRET
 24554                                  
 24555                                  INCRET:
 24556                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 24557                                  
 24558 000041BE E86502                  	CALL   InsertPath		; insert dir entry info
 24559                                  
 24560                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 24561 000041C1 FEC0                    	INC	AL			; Reset zero
 24562                                  	; 16/12/2022	
 24563                                  ;_SETRET:
 24564 000041C3 C3                      	retn
 24565                                  
 24566                                  BADPATHPOP:
 24567 000041C4 5E                      	POP	SI			; Start of next element
 24568 000041C5 8A04                    	MOV	AL,[SI]
 24569 000041C7 89FE                    	MOV	SI,DI			; Start of bad element
 24570 000041C9 08C0                    	OR	AL,AL			; zero if bad element is last, non-zero if path too long
 24571                                  BADPRET:
 24572 000041CB A0[6D05]                	MOV	AL,[SATTRIB]
 24573 000041CE A2[6B05]                	MOV	[ATTRIB],AL		; Make sure return correct
 24574 000041D1 F9                      	STC
 24575 000041D2 C3                      	retn
 24576                                  
 24577                                  ;Break	<STARTSRCH -- INITIATE DIRECTORY SEARCH>
 24578                                  ;---------------------------------------------------------------------------
 24579                                  ;
 24580                                  ; Procedure Name : STARTSRCH
 24581                                  ;
 24582                                  ; Inputs:
 24583                                  ;	[THISDPB] Set
 24584                                  ; Function:
 24585                                  ;	Set up a search for GETENTRY and NEXTENTRY
 24586                                  ; Outputs:
 24587                                  ;	ES:BP = Drive parameters
 24588                                  ;	Sets up LASTENT, ENTFREE=ENTLAST=-1, VOLID=0
 24589                                  ; Destroys ES,BP,AX
 24590                                  ;--------------------------------------------------------------------------
 24591                                  
 24592                                  STARTSRCH:
 24593 000041D3 C42E[8A05]              	LES	BP,[THISDPB]
 24594 000041D7 31C0                    	XOR	AX,AX
 24595 000041D9 A3[4803]                	MOV	[LASTENT],AX
 24596 000041DC A2[7B05]                	MOV	[VOLID],AL		; No volume ID found
 24597 000041DF 48                      	DEC	AX
 24598 000041E0 A3[D805]                	MOV	[ENTFREE],AX
 24599 000041E3 A3[DA05]                	MOV	[ENTLAST],AX
 24600 000041E6 C3                      	retn
 24601                                  
 24602                                  ;BREAK <MatchAttributes - the final check for attribute matching>
 24603                                  ;----------------------------------------------------------------------------
 24604                                  ; Procedure Name : MatchAttributes
 24605                                  ;
 24606                                  ; Input:    [Attrib] = attribute to search for
 24607                                  ;	    CH = found attribute
 24608                                  ; Output:   JZ <match>
 24609                                  ;	    JNZ <nomatch>
 24610                                  ; Registers modified: noneski
 24611                                  ;----------------------------------------------------------------------------
 24612                                  
 24613                                  MatchAttributes:
 24614 000041E7 50                      	PUSH	AX
 24615                                  
 24616                                  ;hkn; SS override
 24617 000041E8 36A0[6B05]              	MOV	AL,[ss:ATTRIB]		; AL <- SearchSet
 24618 000041EC F6D0                    	NOT	AL			; AL <- SearchSet'
 24619 000041EE 20E8                    	AND	AL,CH			; AL <- SearchSet' and FoundSet
 24620                                  	;and	al,16h
 24621 000041F0 2416                    	AND	AL,attr_all	; AL <- SearchSet' and FoundSet and Important
 24622                                  ;
 24623                                  ; the result is non-zero if an attribute is not in the search set
 24624                                  ; and in the found set and in the important set. This means that we do not
 24625                                  ; have a match. Do a JNZ <nomatch> or JZ <match>
 24626                                  ;
 24627 000041F2 58                      	POP	AX
 24628 000041F3 C3                      	retn
 24629                                  
 24630                                  ; 19/05/2019 - Retro DOS v4.0
 24631                                  ; DOSCODE:8148h (MSDOS 6.21, MSDOS.SYS)
 24632                                  
 24633                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24634                                  ; DOSCODE:810Dh (MSDOS 5.0, MSDOS.SYS)
 24635                                  
 24636                                  ;Break <DevName - Look for name of device>
 24637                                  ;---------------------------------------------------------------------------
 24638                                  ;
 24639                                  ; Procedure Name : DevName
 24640                                  ;
 24641                                  ; Inputs:
 24642                                  ;	DS,ES:DOSDATA
 24643                                  ;	Filename in NAME1
 24644                                  ;	ATTRIB set so that we can error out if looking for Volume IDs
 24645                                  ; Function:
 24646                                  ;	Determine if file is in list of I/O drivers
 24647                                  ; Outputs:
 24648                                  ;	Carry set if not a device
 24649                                  ;	ELSE
 24650                                  ;	Zero flag set
 24651                                  ;	BH = Bit 7,6 = 1, bit 5 = 0 (cooked mode)
 24652                                  ;	     bits 0-4 set from low byte of attribute word
 24653                                  ;	DEVPT = DWORD pointer to Device header of device
 24654                                  ; BX destroyed, others preserved
 24655                                  ;---------------------------------------------------------------------------
 24656                                  
 24657                                  DEVNAME:
 24658                                  	; 28/07/2018 - Retro DOS v3.0
 24659                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 49FBh
 24660                                  
 24661 000041F4 56                      	PUSH	SI
 24662 000041F5 57                      	PUSH	DI
 24663 000041F6 51                      	PUSH	CX
 24664 000041F7 50                      	PUSH	AX
 24665                                  
 24666                                  ; E5 special code
 24667 000041F8 FF36[4B05]              	PUSH	WORD [NAME1]
 24668 000041FC 803E[4B05]05            	CMP	byte [NAME1],5
 24669 00004201 7505                    	JNZ	short NOKTR
 24670 00004203 C606[4B05]E5            	MOV	byte [NAME1],0E5h
 24671                                  NOKTR:
 24672                                  	;test	byte [ATTRIB],8
 24673 00004208 F606[6B05]08            	TEST	byte [ATTRIB],attr_volume_id
 24674                                  					; If looking for VOL id don't find devs
 24675 0000420D 7521                    	JNZ	short RET31
 24676                                  
 24677                                  ;hkn; NULDEV is in DOSDATA
 24678 0000420F BE[4800]                	MOV	SI,NULDEV
 24679                                  LOOKIO:
 24680                                  	; 21/11/2022
 24681                                  	;test	byte [SI+SYSDEV.ATT+1],80h
 24682                                  	; 17/12/2022
 24683                                  	;test	byte [si+5],80h
 24684 00004212 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
 24685                                  	;;test	word [si+4],8000h
 24686                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP
 24687 00004216 7411                    	JZ	short SKIPDEV 		; Skip block devices (NET and LOCAL)
 24688 00004218 89F0                    	MOV	AX,SI
 24689                                  	;add	si,10
 24690 0000421A 83C60A                  	ADD	SI,SYSDEV.NAME
 24691                                  
 24692                                  ;hkn; NAME1 is in DOSDATA
 24693 0000421D BF[4B05]                	MOV	DI,NAME1
 24694 00004220 B90400                  	MOV	CX,4			; All devices are 8 letters
 24695 00004223 F3A7                    	REPE	CMPSW			; Check for name in list
 24696 00004225 89C6                    	MOV	SI,AX
 24697 00004227 7415                    	JZ	short IOCHK		; Found it?
 24698                                  SKIPDEV:
 24699 00004229 C534                    	LDS	SI,[SI]			; Get address of next device
 24700 0000422B 83FEFF                  	CMP	SI,-1			; At end of list?
 24701 0000422E 75E2                    	JNZ	short LOOKIO
 24702                                  RET31:	
 24703 00004230 F9                      	STC				; Not found
 24704                                  RETNV:	
 24705 00004231 8CD1                    	MOV	CX,SS
 24706 00004233 8ED9                    	MOV	DS,CX
 24707                                  
 24708 00004235 8F06[4B05]              	POP	WORD [NAME1]
 24709 00004239 58                      	POP	AX
 24710 0000423A 59                      	POP	CX
 24711 0000423B 5F                      	POP	DI
 24712 0000423C 5E                      	POP	SI
 24713 0000423D C3                      	RETN
 24714                                  
 24715                                  IOCHK:
 24716                                  ;hkn; SS override for DEVPT
 24717 0000423E 368C1E[9C05]            	MOV	[SS:DEVPT+2],DS		; Save pointer to device
 24718                                  	;mov	bh,[si+4]
 24719 00004243 8A7C04                  	MOV	BH,[SI+SYSDEV.ATT]
 24720 00004246 80CFC0                  	OR	BH,0C0h
 24721 00004249 80E7DF                  	and	bh,0DFh
 24722                                  	;AND	BH,~(020h)		; Clears Carry
 24723 0000424C 368936[9A05]            	MOV	[SS:DEVPT],SI
 24724 00004251 EBDE                    	JMP	short RETNV
 24725                                  
 24726                                  ;BREAK <Build_device_ent - Make a Directory entry>
 24727                                  ;---------------------------------------------------------------------------
 24728                                  ; Procedure Name : Build_device_ent
 24729                                  ;
 24730                                  ; Inputs:
 24731                                  ;	[NAME1] has name
 24732                                  ;	BH is attribute field (supplied by DEVNAME)
 24733                                  ;	[DEVPT] points to device header (supplied by DEVNAME)
 24734                                  ; Function:
 24735                                  ;	Build a directory entry for a device at DEVFCB
 24736                                  ; Outputs:
 24737                                  ;	BX points to DEVFCB
 24738                                  ;	SI points to dir_first field
 24739                                  ;	AH = input BH
 24740                                  ;	AL = 0
 24741                                  ;	dir_first = DEVPT
 24742                                  ;	Zero Set, Carry Clear
 24743                                  ; DS,ES,BP preserved, others destroyed
 24744                                  ;--------------------------------------------------------------------------
 24745                                  
 24746                                  Build_device_ent:
 24747 00004253 B82020                  	MOV	AX,"  " ; 2020h
 24748                                  
 24749                                  ;hkn; DEVFCB is in DOSDATA
 24750 00004256 BF[5305]                	MOV	DI,DEVFCB+8		; Point to extent field
 24751                                  
 24752                                  ;	Fill dir_ext  BUGBUG - use ERRNZs for this stuff!
 24753                                  
 24754 00004259 AB                      	STOSW
 24755 0000425A AA                      	STOSB				; Blank out extent field
 24756                                  	;mov	al,40h
 24757 0000425B B040                    	MOV	AL,attr_device
 24758                                  
 24759                                  ;	Fill Dir_attr
 24760                                  
 24761 0000425D AA                      	STOSB				; Set attribute field
 24762 0000425E 31C0                    	XOR	AX,AX
 24763 00004260 B90A00                  	MOV	CX,10
 24764                                  
 24765                                  ; Fill dir_pad
 24766                                  
 24767 00004263 F3AB                    	REP	STOSW			; Fill rest with zeros
 24768 00004265 E888C8                  	call	DATE16
 24769                                  
 24770                                  ;hkn; DEVFCB is in DOSDATA
 24771 00004268 BF[6105]                	MOV	DI,DEVFCB+dir_entry.dir_time ; 09/08/2018
 24772 0000426B 92                      	XCHG	AX,DX
 24773                                  
 24774                                  ; Fill dir_time
 24775                                  
 24776 0000426C AB                      	STOSW
 24777 0000426D 92                      	XCHG	AX,DX
 24778                                  
 24779                                  ; Fill dir_date
 24780                                  
 24781 0000426E AB                      	STOSW
 24782 0000426F 89FE                    	MOV	SI,DI			; SI points to dir_first field
 24783 00004271 A1[9A05]                	MOV	AX,[DEVPT]
 24784                                  
 24785                                  ; Fill dir_first
 24786                                  
 24787 00004274 AB                      	STOSW				; Dir_first points to device
 24788 00004275 A1[9C05]                	MOV	AX,[DEVPT+2]
 24789                                  ;
 24790                                  ; Fill dir_size_l
 24791                                  ;
 24792 00004278 AB                      	STOSW
 24793 00004279 88FC                    	MOV	AH,BH			; Put device atts in AH
 24794                                  
 24795                                  ;hkn; DEVFCB is in DOSDATA
 24796 0000427B BB[4B05]                	MOV	BX,DEVFCB
 24797 0000427E 30C0                    	XOR	AL,AL			; Set zero, clear carry
 24798 00004280 C3                      	retn
 24799                                  
 24800                                  ;Break	<ValidateCDS - given a CDS, validate the media and the current directory>
 24801                                  ;----------------------------------------------------------------------------
 24802                                  ;
 24803                                  ;   ValidateCDS - Get current CDS. Splice it. Call FatReadCDS to check
 24804                                  ;   media. If media has been changed, do DOS_Chdir to validate path.
 24805                                  ;   If invalid, reset original CDS to root.
 24806                                  ;
 24807                                  ;   Inputs:	ThisCDS points to CDS of interest
 24808                                  ;		SS:DI points to temp buffer
 24809                                  ;   Outputs:	The current directory string is validated on the appropriate
 24810                                  ;		    drive
 24811                                  ;		ThisDPB changed
 24812                                  ;		ES:DI point to CDS
 24813                                  ;		Carry set if error (currently user FAILed to I 24)
 24814                                  ;   Registers modified: all
 24815                                  ;----------------------------------------------------------------------------
 24816                                  
 24817                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24818                                  	; DOSCODE:819Bh (MSDOS 5.0, MSDOS.SYS)
 24819                                  
 24820                                  ValidateCDS:
 24821                                  	; 19/05/2019 - Retro DOS v4.0
 24822                                  	; 28/07/2018 - Retro DOS v3.0
 24823                                  
 24824                                     %define  Temp	[bp-2]	; word
 24825                                     %define  SaveCDS	[bp-6]	; dword
 24826                                     %define  SaveCDSL	[bp-6]	; word
 24827                                     %define  SaveCDSH	[bp-4]	; word
 24828                                  
 24829                                  	;Enter
 24830 00004281 55                      	push	bp
 24831 00004282 89E5                    	mov	bp,sp
 24832 00004284 83EC06                  	sub	sp,6
 24833                                  
 24834 00004287 897EFE                  	MOV	Temp,DI
 24835                                  
 24836                                  ;hkn; SS override
 24837 0000428A 36C536[A205]            	LDS	SI,[SS:THISCDS]
 24838 0000428F 8976FA                  	MOV	SaveCDSL,SI
 24839 00004292 8C5EFC                  	MOV	SaveCDSH,DS
 24840                                  	;EnterCrit critDisk
 24841 00004295 E879D0                  	call	ECritDisk
 24842                                  	; 21/11/2022
 24843                                  	;test	byte [SI+curdir.flags+1],80h
 24844                                  	;test	word [si+67],8000h
 24845                                  	; 17/12/2022
 24846                                  	;test	byte [SI+68],80h
 24847 00004298 F6444480                	test	byte [SI+curdir.flags+1],(curdir_isnet>>8)
 24848                                  	;TEST	word [SI+curdir.flags],curdir_isnet	; Clears carry
 24849 0000429C 7403                    	JZ	short _DoSplice
 24850 0000429E E99200                  	JMP	FatFail
 24851                                  _DoSplice:
 24852 000042A1 30D2                    	XOR	DL,DL
 24853 000042A3 368616[4C03]            	XCHG	DL,[SS:NoSetDir]
 24854                                  
 24855                                  ;hkn; SS is DOSDATA
 24856                                  	;Context ES
 24857 000042A8 16                      	push	ss
 24858 000042A9 07                      	pop	es
 24859                                  	;Invoke	FStrcpy
 24860 000042AA E837CF                  	call	FStrCpy
 24861 000042AD 8B76FE                  	MOV	SI,Temp
 24862                                  
 24863                                  ;hkn; SS is DOSDATA
 24864                                  	;Context DS
 24865 000042B0 16                      	push	ss
 24866 000042B1 1F                      	pop	ds	
 24867                                  	;Invoke	Splice
 24868 000042B2 E85D2B                  	call	Splice
 24869                                  
 24870                                   ;hkn; SS is DOSDATA
 24871                                  	;Context DS			;   FatReadCDS (ThisCDS);
 24872 000042B5 16                      	push	ss
 24873 000042B6 1F                      	pop	ds
 24874 000042B7 8816[4C03]              	MOV	[NoSetDir],DL
 24875 000042BB C43E[A205]              	LES	DI,[THISCDS]
 24876                                  	;SAVE	<BP>
 24877 000042BF 55                      	push	bp
 24878                                  	;Invoke	FATREAD_CDS
 24879 000042C0 E83114                  	call	FATREAD_CDS	
 24880                                  	;RESTORE <BP>
 24881 000042C3 5D                      	pop	bp
 24882 000042C4 726D                    	JC	short FatFail
 24883                                  
 24884 000042C6 C536[A205]              	LDS	SI,[THISCDS]		;   if (ThisCDS->ID == -1) {
 24885                                  	;cmp	word [si+73],-1
 24886 000042CA 837C49FF                	CMP	word [SI+curdir.ID],-1
 24887 000042CE 7555                    	JNZ	short RestoreCDS
 24888                                  
 24889                                  ;hkn; SS is DOSDATA
 24890                                  	;Context ES
 24891 000042D0 16                      	push	ss
 24892 000042D1 07                      	pop	es
 24893                                  
 24894                                  ;hkn; SS override
 24895                                  	;SAVE	<wfp_Start>		;	t = wfp_Start;
 24896 000042D2 36FF36[B205]            	push	word [SS:WFP_START]
 24897                                  	;cmp	si,[bp-6]
 24898 000042D7 3B76FA                  	CMP	SI,SaveCDSL		; if not spliced
 24899 000042DA 750B                    	JNZ	short DoChdir
 24900                                  	;mov	di,[bp-2]
 24901 000042DC 8B7EFE                  	MOV	DI,Temp
 24902                                  
 24903                                  ;hkn; SS override
 24904 000042DF 36893E[B205]            	MOV	[SS:WFP_START],DI	;	wfp_start = d;
 24905                                  	;Invoke	FStrCpy 		;	strcpy (d, ThisCDS->Text);
 24906 000042E4 E8FDCE                  	call	FStrCpy
 24907                                  DoChdir:
 24908                                  ;hkn; SS is DOSDATA
 24909                                  	;Context DS
 24910 000042E7 16                      	push	ss
 24911 000042E8 1F                      	pop	ds
 24912                                  	;SAVE	<<WORD PTR SAttrib>,BP> ;	c = DOSChDir ();
 24913 000042E9 FF36[6D05]              	push	word [SATTRIB]
 24914 000042ED 55                      	push	bp
 24915                                  	;Invoke	DOS_ChDir
 24916 000042EE E8F0EE                  	call	DOS_CHDIR
 24917                                  	;RESTORE <BP,BX,wfp_start>	;	wfp_Start = t;
 24918 000042F1 5D                      	pop	bp
 24919 000042F2 5B                      	pop	bx
 24920 000042F3 8F06[B205]              	pop	word [WFP_START]
 24921 000042F7 881E[6D05]              	MOV	[SATTRIB],BL
 24922 000042FB C576FA                  	LDS	SI,SaveCDS
 24923 000042FE 730F                    	JNC	short SetCluster	;	if (c == -1) {
 24924                                  
 24925                                  ;hkn; SS override for THISCDS
 24926 00004300 368936[A205]            	MOV	[SS:THISCDS],SI		;	    ThisCDS = TmpCDS;
 24927 00004305 368C1E[A405]            	MOV	[SS:THISCDS+2],DS
 24928 0000430A 31C9                    	XOR	CX,CX			;	    TmpCDS->text[3] = c = 0;
 24929 0000430C 884C03                  	MOV	[SI+3],CL		;	    }
 24930                                  SetCluster:
 24931                                  	;mov	word [si+73],0FFFFh
 24932 0000430F C74449FFFF              	MOV	word [SI+curdir.ID],-1	;	TmpCDS->ID = -1;
 24933 00004314 36C536[A205]            	LDS	SI,[SS:THISCDS]		;	ThisCDS->ID = c;
 24934                                  	; 21/11/2022
 24935                                  	;test	byte [si+curdir.flags+1],20h
 24936                                  	; 19/05/2019
 24937                                  	; MSDOS 6.0
 24938                                  	; 17/12/2022
 24939                                  	;test	byte [si+68],20h
 24940 00004319 F6444420                	test	byte [SI+curdir.flags+1],(curdir_splice>>8)	
 24941                                  	;;test	word [si+67],2000h
 24942                                  	;TEST	word [SI+curdir.flags],curdir_splice ;AN000;;MS. for Join and Subst
 24943 0000431D 7403                    	JZ	short _setdirclus		     ;AN000;;MS.
 24944 0000431F B9FFFF                  	MOV	CX,-1				     ;AN000;;MS.
 24945                                  _setdirclus:
 24946                                  	;mov	[si+73],cx
 24947 00004322 894C49                  	MOV	[SI+curdir.ID],CX	;	}
 24948                                  RestoreCDS:
 24949 00004325 C47EFA                  	LES	DI,SaveCDS
 24950 00004328 36893E[A205]            	MOV	[SS:THISCDS],DI
 24951 0000432D 368C06[A405]            	MOV	[SS:THISCDS+2],ES
 24952 00004332 F8                      	CLC
 24953                                  FatFail:
 24954                                  	;LeaveCrit critDisk
 24955 00004333 E8F6CF                  	call	LCritDisk
 24956                                  
 24957                                  	;les	di,[bp-6]
 24958 00004336 C47EFA                  	LES	DI,SaveCDS
 24959                                  	;Leave
 24960 00004339 89EC                    	mov	sp,bp
 24961 0000433B 5D                      	pop	bp
 24962 0000433C C3                      	retn
 24963                                  
 24964                                  ; 28/07/2018 - Retro DOS v3.0
 24965                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - offset 43BDh
 24966                                  
 24967                                  ;Break	<CheckThisDevice - Check for being a device>
 24968                                  ;---------------------------------------------------------------------------
 24969                                  ;
 24970                                  ;   CheckThisDevice - Examine the area at DS:SI to see if there is a valid
 24971                                  ;   device specified. We will return carry if there is a device present. 
 24972                                  ;   The forms of devices we will recognize are:
 24973                                  ;
 24974                                  ;	[path]device
 24975                                  ;
 24976                                  ;   Note that the drive letter has *already* been removed. All other forms
 24977                                  ;   are not considered to be devices. If such a device is found we change
 24978                                  ;   the source pointer to point to the device component.
 24979                                  ;
 24980                                  ;   Inputs:	ES is DOSDATA
 24981                                  ;		DS:SI contains name
 24982                                  ;   Outputs:	ES is DOSDATA
 24983                                  ;		DS:SI point to name or device
 24984                                  ;		Carry flag set if device was found
 24985                                  ;		Carry flag reset otherwise
 24986                                  ;   Registers Modified: all except ES:DI, DS
 24987                                  ;----------------------------------------------------------------------------
 24988                                  
 24989                                  CheckThisDevice:
 24990 0000433D 57                      	push	di
 24991 0000433E 56                      	push	si
 24992 0000433F 89F7                    	MOV	DI,SI
 24993                                  
 24994                                  ; Check for presence of \dev\ (Dam multiplan!)
 24995                                  
 24996 00004341 8A04                    	MOV	AL,[SI]
 24997 00004343 E8750D                  	call	PATHCHRCMP		; is it a path char?
 24998 00004346 7517                    	JNZ	short ParseDev		; no, go attempt to parse device
 24999 00004348 46                      	INC	SI			; simulate LODSB
 25000                                  
 25001                                  ; We have the leading path separator. Look for DEV part.
 25002                                  
 25003 00004349 AD                      	LODSW
 25004 0000434A 0D2020                  	OR	AX,2020h
 25005 0000434D 3D6465                  	cmp	ax,"de"
 25006                                  	;CMP	AX,"e"<< 8 + "d"
 25007 00004350 752D                    	JNZ	short NotDevice		; not "de", assume not device
 25008 00004352 AC                      	LODSB
 25009 00004353 0C20                    	OR	AL,20h
 25010 00004355 3C76                    	CMP	AL,"v"                  ; Not "v", assume not device
 25011 00004357 7526                    	JNZ	short NotDevice
 25012 00004359 AC                      	LODSB
 25013 0000435A E85E0D                  	call	PATHCHRCMP		; do we have the last path separator?
 25014 0000435D 7520                    	JNZ	short NotDevice		; no. go for it.
 25015                                  
 25016                                  ; DS:SI now points to a potential drive. Preserve them as NameTrans advances
 25017                                  ; SI and DevName may destroy DS.
 25018                                  
 25019                                  ParseDev:
 25020 0000435F 1E                      	push	ds
 25021 00004360 56                      	push	si			; preserve the source pointer
 25022 00004361 E8950C                  	call	NameTrans		; advance DS:SI
 25023 00004364 803C00                  	CMP	BYTE [SI],0		; parse entire string?
 25024 00004367 F9                      	STC				; simulate a Carry return from DevName
 25025 00004368 750B                    	JNZ	short SkipSearch	; no parse. simulate a file return.
 25026                                  
 25027                                  ;hkn; SS is DOSDATA
 25028 0000436A 16                      	push	ss
 25029 0000436B 1F                      	pop	ds
 25030                                  
 25031                                  ; M026 - start - fix ported from ROMDOS2 for bug # 2849
 25032                                  ;
 25033                                  ; SR;
 25034                                  ; We have to set Attrib before invoking DevName. Otherwise, the value from
 25035                                  ; a previous DOS call is used and DevName thinks it is not a device if the
 25036                                  ; old call set the volume attribute bit.
 25037                                  
 25038 0000436C A0[6D05]                	mov	al,[SATTRIB]
 25039 0000436F A2[6B05]                	mov	[ATTRIB],al		;set Attrib for DevName
 25040                                  
 25041                                  ; M026 - end
 25042                                  
 25043 00004372 E87FFE                  	call	DEVNAME
 25044                                  
 25045                                  SkipSearch:
 25046 00004375 5E                      	pop	si
 25047 00004376 1F                      	pop	ds
 25048                                  
 25049                                  ; SI points to the beginning of the potential device. If we have a device
 25050                                  ; then we do not change SI. If we have a file, then we reset SI back to the
 25051                                  ; original value. At this point Carry set indicates FILE.
 25052                                  
 25053                                  CheckReturn:
 25054 00004377 5F                      	pop	di			; get original SI
 25055 00004378 7302                    	JNC	short Check_Done	; if device then do not reset pointer
 25056 0000437A 89FE                    	MOV	SI,DI
 25057                                  Check_Done:
 25058 0000437C 5F                      	pop	di
 25059 0000437D F5                      	CMC				; invert carry. Carry => device
 25060 0000437E C3                      	retn
 25061                                  NotDevice:
 25062 0000437F F9                      	STC
 25063 00004380 EBF5                    	JMP	short CheckReturn
 25064                                  
 25065                                  ;BREAK <LookupPath - call fastopen to get dir entry info>
 25066                                  ;-----------------------------------------------------------------------------
 25067                                  ;
 25068                                  ; Procedure Name : LookupPath
 25069                                  ;
 25070                                  ; Output  DS:SI -> path name,
 25071                                  ;	  ES:DI -> dir entry info buffer
 25072                                  ;	  ES:CX -> extended dir info buffer
 25073                                  ;
 25074                                  ;	  carry flag clear : tables pointed by ES:DI and ES:CX are filled by
 25075                                  ;			     FastOpen, DS:SI points to char just one after
 25076                                  ;			     the last char of path name which is fully or
 25077                                  ;			     partially found in FastOPen
 25078                                  ;	  carry flag set : FastOpen not in memory or path name not found
 25079                                  ;
 25080                                  ;----------------------------------------------------------------------------
 25081                                  
 25082                                  LookupPath:
 25083                                  ;	PUSH	AX
 25084                                  
 25085                                  ;hkn; SS override
 25086                                  	;test	byte [ss:FastOpenFlg],1
 25087 00004382 36F606[3A0D]01          	TEST	byte [ss:FastOpenFlg],FastOpen_Set  ; flg is set in DOSOPEN
 25088 00004388 7503                    	JNZ	short FASTINST			    ; and this routine is
 25089                                  NOLOOK:
 25090 0000438A E99700                  	JMP	NOLOOKUP			    ; executed once
 25091                                  
 25092                                  FASTINST:
 25093                                  ;hkn; SS override
 25094                                  	;test	byte [ss:FastOpenFlg],8
 25095 0000438D 36F606[3A0D]08          	TEST	byte [ss:FastOpenFlg],No_Lookup	    ; no more lookup?
 25096 00004393 75F5                    	JNZ	short NOLOOK			    ; yes
 25097                                  
 25098 00004395 BB[300D]                	MOV	BX,FastOpenTable		    ; get fastopen related tab
 25099                                  
 25100                                  ;hkn; SS override
 25101 00004398 368B36[B205]            	MOV	SI,[SS:WFP_START]		    ; si points to path name
 25102 0000439D BF[460D]                	MOV	DI,Dir_Info_Buff
 25103 000043A0 B9[3B0D]                	MOV	CX,FastOpen_Ext_Info
 25104 000043A3 B001                    	MOV	AL,FONC_Look_up 		    ; al = 1
 25105 000043A5 1E                      	PUSH	DS
 25106 000043A6 07                      	POP	ES
 25107                                  
 25108                                  ;hkn; SS override
 25109                                  	;call	far [bx+2]
 25110 000043A7 FF5F02                  	CALL	far [BX+fastopen_entry.name_caching] ;call fastopen
 25111 000043AA 7267                    	JC	short NOTFOUND			    ; fastopen not in memory
 25112                                  
 25113 000043AC 8D5CFE                  	LEA	BX,[SI-2]
 25114                                  
 25115                                  ;hkn; SS override
 25116 000043AF 363B1E[B205]            	CMP	BX,[SS:WFP_START]		    ; path found ?
 25117 000043B4 745D                    	JZ	short NOTFOUND			    ; no
 25118                                  
 25119                                  	; 19/05/2019 - Retro DOS v4.0
 25120                                  
 25121                                  	; MSDOS 6.0				    ; fully or partially found
 25122 000043B6 803C00                  	CMP	BYTE [SI],0			    ;AN000;FO.
 25123 000043B9 751A                    	JNZ	short parfnd			    ;AN000;FO.; partiallyfound
 25124 000043BB 51                      	PUSH	CX				    ;AN000;FO.; is attribute matched ?
 25125                                  
 25126                                  ;hkn; SS override for attrib/sattrib
 25127 000043BC 368A0E[6B05]            	MOV	CL,[ss:ATTRIB]			    ;AN000;FO.;
 25128 000043C1 368A2E[6D05]            	MOV	CH,[ss:SATTRIB]			    ;AN000;FO.; attrib=sattrib
 25129 000043C6 36882E[6B05]            	MOV	[ss:ATTRIB],CH			    ;AN000;FO.;
 25130                                  	;mov	ch,[es:di+0Bh]
 25131 000043CB 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]	    ;AN000;FO.;
 25132 000043CF E815FE                  	call	MatchAttributes 		    ;AN000;FO.;
 25133                                  ;;;	MOV	[ss:ATTRIB],CL			    ;AN001;FO.; restore attrib
 25134 000043D2 59                      	POP	CX				    ;AN000;FO.;
 25135 000043D3 754F                    	JNZ	short NOLOOKUP			    ;AN000;FO.; not matched
 25136                                  parfnd:
 25137                                  
 25138                                  ;hkn; SS override
 25139 000043D5 368936[660D]            	MOV	[SS:Next_Element_Start],SI	    ; save si
 25140 000043DA 89CB                    	MOV	BX,CX
 25141                                  	; MSDOS 6.0
 25142                                  	;mov	ax,[bx+7]
 25143 000043DC 8B4707                  	MOV	AX,[BX+FEI.lastent]		    ;AN000;;FO. restore lastentry
 25144                                  ;hkn; SS override for LASTENT, DIRSTART, CLUSNUM
 25145 000043DF 36A3[4803]              	MOV	[SS:LASTENT],AX			    ;AN000;;FO.
 25146 000043E3 8B4709                  	MOV	AX,[BX+FEI.dirstart]		    ;AN001;;FO. restore dirstart
 25147 000043E6 36A3[C205]              	MOV	[SS:DIRSTART],AX		    ;AN001;;FO.
 25148                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25149                                  	;;mov	ax,[bx+3] ; MSDOS 3.3
 25150                                  	;mov	ax,[bx+5] ; MSDOS 6.0
 25151 000043EA 8B4705                  	MOV	AX,[BX+FEI.clusnum]		    ; restore next cluster num
 25152 000043ED 36A3[BC05]              	MOV	[SS:CLUSNUM],AX			    ;
 25153                                  
 25154 000043F1 06                      	PUSH	ES				    ; save ES
 25155                                  ;hkn; SS override
 25156 000043F2 36C41E[8A05]            	LES	BX,[SS:THISDPB]			    ; put drive id
 25157 000043F7 268A27                  	mov	ah,[ES:BX] ; 15/08/2018
 25158                                  	;MOV	AH,[ES:BX+DPB.DRIVE]		    ; in AH for DOOPEN
 25159 000043FA 07                      	POP	ES				    ; pop ES
 25160                                  ;SR;
 25161                                  ; We cannot have a root dir if we have come here. So, we zero out CurBuf to
 25162                                  ;indicate it is not a root dir
 25163                                  
 25164 000043FB 36C706[E205]0000        	mov	word [SS:CURBUF],0		    ; indicate not root dir
 25165 00004402 368C06[E405]            	MOV	WORD [SS:CURBUF+2],ES		    ; [curbuf+2].bx points to
 25166 00004407 89FB                    	MOV	BX,DI				    ; start of entry
 25167                                  	;lea	si,[di+1Ah]
 25168 00004409 8D751A                  	LEA	SI,[DI+dir_entry.dir_first]	    ; [curbuf+2]:si points to
 25169                                  						    ; dir_first field in the
 25170                                  						    ; dir entry
 25171                                  ;hkn; SS override for FastOpenFlg
 25172                                  	;or	byte [ss:FastOpenFlg],12h ; 29/12/2022
 25173 0000440C 36800E[3A0D]12          	OR	byte [SS:FastOpenFlg],Lookup_Success+Set_For_Search
 25174                                  ;	POP	AX
 25175 00004412 C3                      	RETN
 25176                                  NOTFOUND:
 25177 00004413 83F8FF                  	CMP	AX,-1				    ; not in memory ?
 25178 00004416 7506                    	JNZ	short Partial_Success 		    ; yes, in memory
 25179 00004418 36C606[3A0D]00          	MOV	byte [SS:FastOpenFlg],0		    ; no more fastopen
 25180                                  Partial_Success:
 25181                                  	;and	byte [SS:FastOpenFlg],0FBh
 25182 0000441E 368026[3A0D]FB          	AND	byte [SS:FastOpenFlg],Special_Fill_Reset
 25183                                  NOLOOKUP:
 25184                                  ;	POP	AX
 25185 00004424 F9                      	STC
 25186 00004425 C3                      	RETN
 25187                                  
 25188                                  ;BREAK <InsertPath - call fastopen to insert dir entry info>
 25189                                  ;-----------------------------------------------------------------------------
 25190                                  ;
 25191                                  ; Procedure Name : InsertPath
 25192                                  ; Input:  FastOpen_Set flag set when from DOSOPEN otherwise 0
 25193                                  ;	  Lookup_Success flag set when got dir entry info from FASTOPEN
 25194                                  ;	  DS = DOSDATA
 25195                                  ; Output: FastOPen_Ext_Info is set and path dir info is inserted
 25196                                  ;
 25197                                  ;-----------------------------------------------------------------------------
 25198                                  
 25199                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25200                                  
 25201                                  InsertPath:
 25202 00004426 9C                      	PUSHF
 25203                                  ;hkn; SS override for FastOpenFlag
 25204                                  	;test	byte [SS:FastOpenFlg], 1
 25205 00004427 36F606[3A0D]01          	TEST	byte [SS:FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 25206 0000442D 7479                    	JZ	short GET_NEXT_ELEMENT		; the FastOpen
 25207                                  	;test	byte [ss:FastOpenFlg],2
 25208 0000442F 36F606[3A0D]02          	TEST	byte [SS:FastOpenFlg],Lookup_Success ; Lookup just happened
 25209 00004435 740D                    	JZ	short INSERT_DIR_INFO		; no
 25210                                  	;and	byte [ss:FastOpenFlg],0FDh
 25211 00004437 368026[3A0D]FD          	AND	byte [SS:FastOpenFlg],Lookup_Reset  ; we got dir info from fastopen so
 25212 0000443D 368B3E[660D]            	MOV	DI,[SS:Next_Element_Start]	; no need to insert it again
 25213 00004442 EB5E                    	JMP	short GET_NEXT2
 25214                                  INSERT_DIR_INFO:				; save registers
 25215 00004444 1E                      	PUSH	DS
 25216 00004445 06                      	PUSH	ES
 25217 00004446 53                      	PUSH	BX
 25218 00004447 56                      	PUSH	SI
 25219 00004448 57                      	PUSH	DI
 25220 00004449 51                      	PUSH	CX
 25221 0000444A 50                      	PUSH	AX
 25222                                  
 25223                                  ;hkn; SS override
 25224 0000444B 36C53E[E205]            	LDS	DI,[SS:CURBUF]			; DS:DI -> buffer header
 25225 00004450 BE[3B0D]                	MOV	SI,FastOpen_Ext_Info
 25226                                  	;mov	ax,[di+6]
 25227 00004453 8B4506                  	MOV	AX,[DI+BUFFINFO.buf_sector]	; get directory sector
 25228                                  	; MSDOS 6.0
 25229                                  	;mov	[ss:si+1],ax
 25230 00004456 36894401                	MOV	[SS:SI+FEI.dirsec],AX 		;AN000; >32mb save dir sector
 25231                                  	; 19/05/2019 - Retro DOS v4.0
 25232 0000445A 8B4508                  	MOV	AX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 25233                                  
 25234                                  ;hkn; SS is DOSDATA
 25235 0000445D 16                      	push	ss
 25236 0000445E 1F                      	pop	ds
 25237                                  	; MSDOS 3.3	
 25238                                  	;;mov	[si+1],ax	
 25239                                  	;MOV	[SI+FEI.dirsec],AX
 25240                                  	; MSDOS 6.0
 25241                                  	;mov	[si+3],ax
 25242 0000445F 894403                  	MOV	[SI+FEI.dirsec+2],AX		;AN000;>32mb save high dir sector
 25243                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25244 00004462 A1[BC05]                	MOV	AX,[CLUSNUM]		; save next cluster number
 25245                                  	;;mov	[si+5],ax ; MSDOS 6.0
 25246                                  	;mov	[si+3],ax ; MSDOS 3.3
 25247 00004465 894405                  	MOV	[SI+FEI.clusnum],AX
 25248                                  	; MSDOS 6.0
 25249 00004468 A1[4803]                	MOV	AX,[LASTENT]		;AN000;FO. save lastentry for search first
 25250                                  	;mov	[si+7],ax
 25251 0000446B 894407                  	MOV	[SI+FEI.lastent],AX	;AN000;FO.
 25252 0000446E A1[C205]                	MOV	AX,[DIRSTART]		;AN001;FO. save  for search first
 25253                                  	;mov	[si+9],ax
 25254 00004471 894409                  	MOV	[SI+FEI.dirstart],AX	;AN001;FO.
 25255                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25256 00004474 89D8                    	MOV	AX,BX
 25257                                  	;;add	di,16  ; MSDOS 3.3
 25258                                  	;add	di,20  ; MSDOS 6.0
 25259 00004476 83C714                  	ADD	DI,BUFINSIZ		; DS:DI -> start of data in buffer
 25260 00004479 29F8                    	SUB	AX,DI			; AX=BX relative to start of sector
 25261                                  	;mov	cl,32
 25262 0000447B B120                    	MOV	CL,dir_entry.size
 25263 0000447D F6F1                    	DIV	CL
 25264                                  	;MOV	[SI+FEI.dirpos],AL	; save directory entry # in buffer
 25265 0000447F 8804                    	mov	[si],al
 25266                                  
 25267 00004481 1E                      	PUSH	DS
 25268 00004482 07                      	POP	ES
 25269                                  
 25270 00004483 8E1E[E405]              	MOV	DS,[CURBUF+2]
 25271 00004487 89DF                    	MOV	DI,BX			; DS:DI -> dir entry info
 25272                                  	;cmp	word [di+1Ah],0
 25273 00004489 837D1A00                	CMP	word [DI+dir_entry.dir_first],0 
 25274                                  					; never insert info when file is empty
 25275 0000448D 740C                    	JZ	short SKIP_INSERT	; e.g. newly created file
 25276                                  
 25277 0000448F 56                      	PUSH	SI			; ES:BX -> extended info
 25278 00004490 5B                      	POP	BX
 25279                                  
 25280                                  	;mov	al,2
 25281 00004491 B002                    	MOV	AL,FONC_insert		; call fastopen insert operation
 25282 00004493 BE[300D]                	MOV	SI,FastOpenTable
 25283                                  	;call	far [es:si+2]	 ; call dword ptr es:[si+2] ; 29/12/2022
 25284                                  	; 07/12/2022
 25285 00004496 26FF5C02                	CALL	far [ES:SI+fastopen_entry.name_caching]
 25286                                  
 25287 0000449A F8                      	CLC
 25288                                  SKIP_INSERT:
 25289 0000449B 58                      	POP	AX
 25290 0000449C 59                      	POP	CX			; restore registers
 25291 0000449D 5F                      	POP	DI
 25292 0000449E 5E                      	POP	SI
 25293 0000449F 5B                      	POP	BX
 25294 000044A0 07                      	POP	ES
 25295 000044A1 1F                      	POP	DS
 25296                                  GET_NEXT2:
 25297                                  	;or	[ss:FastOpenFlg],8
 25298 000044A2 36800E[3A0D]08          	OR	byte [SS:FastOpenFlg],No_Lookup
 25299                                  					; we got dir info from fastopen so
 25300                                  GET_NEXT_ELEMENT:
 25301 000044A8 9D                      	POPF
 25302 000044A9 C3                      	RETN
 25303                                  
 25304                                  ;============================================================================
 25305                                  ; DEV.ASM (MSDOS 6.0, 1991)
 25306                                  ;============================================================================
 25307                                  ; 17/07/2018 - Retro DOS v3.0
 25308                                  ; 30/04/2019 - Retro DOS v4.0
 25309                                  
 25310                                  ;**	Misc Routines to do 1-12 low level I/O and call devices
 25311                                  
 25312                                  ; Offset 12B8h of IBMDOS.COM (MSDOS 3.3), 1987
 25313                                  
 25314                                  ;DOSCODE:8401h (MSDOS 6.21, MSDOS.SYS)
 25315                                  
 25316                                  ;Public DEV001S, DEV001E 		; Pathgen labels
 25317                                  ;DEV001s:
 25318                                  ;		length of packets
 25319 000044AA 160E160D0F0E            LenTab:	 DB	DRDWRHL, DRDNDHL, DRDWRHL, DSTATHL, DFLSHL, DRDNDHL
 25320                                  ;LenTab: db	22,14,22,13,15,14
 25321                                  
 25322                                  ;	Error Function
 25323                                  
 25324                                  CmdTab:
 25325 000044B0 8604                    	DB	86h, DEVRD	; 0 input
 25326 000044B2 8605                    	DB	86h, DEVRDND	; 1 input status
 25327 000044B4 8708                    	DB	87h, DEVWRT	; 2 output
 25328 000044B6 870A                    	DB	87h, DEVOST	; 3 output status
 25329 000044B8 8607                    	DB	86h, DEVIFL	; 4 input flush
 25330 000044BA 8605                    	DB	86h, DEVRDND	; 5 input status with system WAIT
 25331                                  
 25332                                  ; Offset 12BEh of IBMDOS.COM (MSDOS 3.3), 1987
 25333                                  
 25334                                  ;CmdTab:
 25335                                  ;	db	86h, 4
 25336                                  ;	db	86h, 5
 25337                                  ;	db	87h, 8
 25338                                  ;	db	87h, 10
 25339                                  ;	db	86h, 7
 25340                                  ;	db	86h, 5
 25341                                  
 25342                                  ;DEV001E:
 25343                                  
 25344                                  ; 30/04/2019 - Retro DOS v4.0
 25345                                  ; DOSCODE:8413h (MSDOS 6.21, MSDOS.SYS)
 25346                                  
 25347                                  ;Break	<IOFUNC -- DO FUNCTION 1-12 I/O>
 25348                                  ;----------------------------------------------------------------------------
 25349                                  ;
 25350                                  ; Procedure Name : IOFUNC
 25351                                  ;
 25352                                  ; Inputs:
 25353                                  ;	DS:SI Points to SFT
 25354                                  ;	AH is function code
 25355                                  ;		= 0 Input
 25356                                  ;		= 1 Input Status
 25357                                  ;		= 2 Output
 25358                                  ;		= 3 Output Status
 25359                                  ;		= 4 Flush
 25360                                  ;		= 5 Input Status - System WAIT invoked for K09 if no char
 25361                                  ;				   present.
 25362                                  ;	AL = character if output
 25363                                  ; Function:
 25364                                  ;	Perform indicated I/O to device or file
 25365                                  ; Outputs:
 25366                                  ;	AL is character if input
 25367                                  ;	If a status call
 25368                                  ;		zero set if not ready
 25369                                  ;		zero reset if ready (character in AL for input status)
 25370                                  ; For regular files:
 25371                                  ;	Input Status
 25372                                  ;		Gets character but restores position
 25373                                  ;		Zero set on EOF
 25374                                  ;	Input
 25375                                  ;		Gets character advances position
 25376                                  ;		Returns ^Z on EOF
 25377                                  ;	Output Status
 25378                                  ;		Always ready
 25379                                  ; AX altered, all other registers preserved
 25380                                  ;----------------------------------------------------------------------------
 25381                                  
 25382                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25383                                  ; DOSCODE:83D8h (MSDOS 5.0, MSDOS.SYS)
 25384                                  
 25385                                  IOFUNC:
 25386 000044BC 368C16[8C03]            	MOV	[SS:IOXAD+2],SS		; SS override for IOXAD, IOSCNT, 
 25387                                  					; DEVIOBUF
 25388 000044C1 36C706[8A03][BC03]      	MOV	WORD [SS:IOXAD],DEVIOBUF
 25389 000044C8 36C706[8E03]0100        	MOV	WORD [SS:IOSCNT],1
 25390 000044CF 36A3[BC03]              	MOV	WORD [SS:DEVIOBUF],AX
 25391                                  	;test	byte [si+6],80h
 25392                                  	;TEST	word [SI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
 25393 000044D3 F6440680                	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 25394 000044D7 7403                    	JZ	short IOTO22		;AN000;
 25395 000044D9 E9A500                  	JMP	IOTOFILE		;AN000;
 25396                                  IOTO22:
 25397                                  	;test	word [si+5],80h
 25398                                  	;TEST	word [SI+SF_ENTRY.sf_flags],devid_device 
 25399 000044DC F6440580                	test	byte [SI+SF_ENTRY.sf_flags],devid_device	
 25400 000044E0 7503                    	JNZ	short IOTO33		;AN000;
 25401 000044E2 E99C00                  	JMP	IOTOFILE		;AN000;
 25402                                  IOTO33:
 25403 000044E5 06                      	push	es ; * (MSDOS 6.21)
 25404 000044E6 E879BF                  	call	save_world
 25405 000044E9 8CDA                    	MOV	DX,DS
 25406 000044EB 8CD3                    	MOV	BX,SS
 25407 000044ED 8EDB                    	MOV	DS,BX
 25408 000044EF 8EC3                    	MOV	ES,BX
 25409 000044F1 31DB                    	XOR	BX,BX
 25410 000044F3 80FC05                  	cmp	ah,5		    ; system wait enabled?
 25411 000044F6 7503                    	jnz	short _no_sys_wait
 25412                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25413                                  	; 16/12/2022
 25414 000044F8 80CF04                  	or	bh,04h
 25415                                  	;or	bx,0400H	    ; Set bit 10 in status word for driver
 25416                                  				    ; It is up to device driver to carry out
 25417                                  				    ; appropriate action.
 25418                                  _no_sys_wait:
 25419 000044FB 891E[7F03]              	MOV	[IOCALL_REQSTAT],BX
 25420 000044FF 31DB                    	XOR	BX,BX
 25421 00004501 881E[8903]              	MOV	[IOMED],BL
 25422                                  
 25423 00004505 88E3                    	MOV	BL,AH		 	; get function
 25424 00004507 2E8AA7[AA44]            	MOV	AH,[cs:BX+LenTab]
 25425 0000450C D1E3                    	SHL	BX,1
 25426 0000450E 2E8B8F[B044]            	MOV	CX,[cs:BX+CmdTab]
 25427 00004513 BB[7C03]                	MOV	BX,IOCALL ; DOSDATA:037Ch
 25428 00004516 8826[7C03]              	MOV	[IOCALL_REQLEN],AH
 25429 0000451A 882E[7E03]              	MOV	[IOCALL_REQFUNC],CH
 25430                                  
 25431 0000451E 8EDA                    	MOV	DS,DX
 25432 00004520 E86B01                  	CALL	DEVIOCALL
 25433 00004523 368B3E[7F03]            	MOV	DI,[SS:IOCALL_REQSTAT]	; SS override
 25434 00004528 21FF                    	and	di,di
 25435 0000452A 7834                    	js	short DevErr
 25436                                  OKDevIO:
 25437 0000452C 8CD0                    	MOV	AX,SS
 25438 0000452E 8ED8                    	MOV	DS,AX
 25439                                  
 25440                                  	;cmp	ch,5
 25441 00004530 80FD05                  	CMP	CH,DEVRDND
 25442 00004533 7506                    	JNZ	short DNODRD
 25443 00004535 A0[8903]                	MOV	AL,[IORCHR]
 25444 00004538 A2[BC03]                	MOV	[DEVIOBUF],AL
 25445                                  
 25446                                  DNODRD: 
 25447 0000453B 8A26[8003]              	MOV	AH,[IOCALL_REQSTAT+1]
 25448 0000453F F6D4                    	NOT	AH			; Zero = busy, not zero = ready
 25449                                  	;and	ah,2
 25450 00004541 80E402                  	AND	AH,STBUI>>8
 25451                                  
 25452                                  QuickReturn:				;AN000; 2/13/KK
 25453 00004544 E804BF                  	call	restore_world
 25454 00004547 07                      	pop	es ; * (MSDOS 6.21)
 25455                                  
 25456                                  	; SR;
 25457                                  	; We return ax = -1 if the user failed on I24. This is the case if 
 25458                                  	; IoStatFail = -1 (set after return from the I24)
 25459                                  
 25460                                  	; MSDOS 6.0
 25461 00004548 9C                      	pushf
 25462 00004549 36A0[8300]              	mov	al,[ss:IoStatFail]	;assume fail error
 25463 0000454D 98                      	cbw				;sign extend to word
 25464 0000454E 83F8FF                  	cmp	ax,-1
 25465 00004551 7507                    	jne	short not_fail_ret
 25466 00004553 36FE06[8300]            	inc	byte [ss:IoStatFail]
 25467 00004558 9D                      	popf
 25468 00004559 C3                      	retn
 25469                                  
 25470                                  not_fail_ret:
 25471 0000455A 36A1[BC03]              	mov	ax,[ss:DEVIOBUF]	;ss override
 25472 0000455E 9D                      	popf
 25473 0000455F C3                      	retn
 25474                                  
 25475                                  DevErr:
 25476 00004560 88CC                    	MOV	AH,CL
 25477 00004562 E88E0D                  	call	CHARHARD
 25478 00004565 3C01                    	CMP	AL,1
 25479 00004567 7507                    	JNZ	short NO_RETRY
 25480 00004569 E8DFBE                  	call	restore_world
 25481                                  	; 12/05/2019
 25482 0000456C 07                      	pop	es ; * (MSDOS 6.21)		
 25483 0000456D E94CFF                  	JMP	IOFUNC	; 10/08/2018
 25484                                  
 25485                                  NO_RETRY:
 25486                                  	; Know user must have wanted Ignore OR Fail. Make sure device shows ready
 25487                                  	; ready so that DOS doesn't get caught in a status loop when user 
 25488                                  	; simply wants to ignore the error.
 25489                                  	;
 25490                                  	; SR; If fail wanted by user set ax to special value (ax = -1). This 
 25491                                  	; should be checked by the caller on return
 25492                                  
 25493                                  					; SS override
 25494 00004570 368026[8003]FD          	and	byte [SS:IOCALL_REQSTAT+1],0FDh
 25495                                  	;AND	BYTE [SS:IOCALL_REQSTAT+1],~(STBUI>>8)
 25496                                  
 25497                                  	; SR;
 25498                                  	; Check if user failed
 25499                                  
 25500                                  	; MSDOS 6.0
 25501 00004576 3C03                    	cmp	al,3
 25502 00004578 7505                    	jnz	short not_fail
 25503 0000457A 36FE0E[8300]            	dec	byte [ss:IoStatFail]	;set flag indicating fail on I24
 25504                                  not_fail:
 25505 0000457F EBAB                    	JMP	short OKDevIO
 25506                                  
 25507                                  IOTOFILE:
 25508 00004581 08E4                    	OR	AH,AH
 25509 00004583 7421                    	JZ	short IOIN
 25510 00004585 FECC                    	DEC	AH
 25511 00004587 7405                    	JZ	short IOIST
 25512 00004589 FECC                    	DEC	AH
 25513 0000458B 7411                    	JZ	short IOUT
 25514                                  IOUT_retn:	; 18/12/2022
 25515 0000458D C3                      	retn				; NON ZERO FLAG FOR OUTPUT STATUS
 25516                                  IOIST:
 25517                                  	;push	word [si+15h]
 25518 0000458E FF7415                  	PUSH	WORD [SI+SF_ENTRY.sf_position]   ; Save position
 25519                                  	;push	word [si+17h]
 25520 00004591 FF7417                  	PUSH	WORD [SI+SF_ENTRY.sf_position+2]
 25521 00004594 E80F00                  	CALL	IOIN
 25522                                  	;pop	word [si+17h]
 25523 00004597 8F4417                  	POP	WORD [SI+SF_ENTRY.sf_position+2] ; Restore position
 25524                                  	;pop	word [si+15h]
 25525 0000459A 8F4415                  	POP	WORD [SI+SF_ENTRY.sf_position]
 25526 0000459D C3                      	retn
 25527                                  IOUT:
 25528 0000459E E82500                  	CALL	SETXADDR
 25529 000045A1 E880EF                  	call	DOS_WRITE
 25530                                  	;CALL	RESTXADDR	; If you change this into a jmp don't
 25531                                  	; 18/12/2022
 25532 000045A4 EB52                    	jmp	RESTXADDR
 25533                                  ;IOUT_retn:
 25534                                  	;retn			; come crying to me when things don't
 25535                                  				; work ARR
 25536                                  IOIN:
 25537 000045A6 E81D00                  	CALL	SETXADDR
 25538                                  					; SS override for DOS34_FLAG
 25539                                  	;OR	word [SS:DOS34_FLAG],Disable_EOF_I24	;AN000;
 25540                                  	;or	word [ss:DOS34_FLAG],40h
 25541                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25542                                  	; 16/12/2022
 25543 000045A9 36800E[1106]40          	or	byte [ss:DOS34_FLAG],40h 
 25544 000045AF E849ED                  	CALL	DOS_READ
 25545                                  	;AND	word [SS:DOS34_FLAG],NO_Disable_EOF_I24 ;AN000;
 25546                                  	;and	word [SS:DOS34_FLAG],0FFBFh
 25547                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25548                                  	; 16/12/2022
 25549 000045B2 368026[1106]BF          	and	byte [SS:DOS34_FLAG],0BFh ; 07/12/2022
 25550 000045B8 09C9                    	OR	CX,CX			; Check EOF
 25551 000045BA E83B00                  	CALL	RESTXADDR
 25552                                  					; SS override
 25553 000045BD 36A0[BC03]              	MOV	AL,[SS:DEVIOBUF]	; Get byte from trans addr
 25554 000045C1 75CA                    	jnz	short IOUT_retn	
 25555 000045C3 B01A                    	MOV	AL,1AH			; ^Z if no bytes
 25556 000045C5 C3                      	retn
 25557                                  
 25558                                  SETXADDR:
 25559                                  					; SS override
 25560 000045C6 368F06[6C03]            	POP	WORD [SS:CALLSCNT]	; Return address
 25561                                  
 25562 000045CB 06                      	push	es ; * (MSDOS 6.21)
 25563                                  
 25564 000045CC E893BE                  	call	save_world
 25565                                  					; SS override for DMAADD and THISSFT
 25566                                  	; 24/09/2023
 25567                                  	;PUSH	WORD [SS:DMAADD]	; Save Disk trans addr
 25568                                  	;PUSH	WORD [SS:DMAADD+2]
 25569 000045CF 368C1E[A005]            	MOV	[SS:THISSFT+2],DS
 25570                                  
 25571 000045D4 16                      	push	ss
 25572 000045D5 1F                      	pop	ds
 25573                                  
 25574                                  	; 24/09/2023
 25575 000045D6 FF36[2C03]              	push	word [DMAADD]
 25576 000045DA FF36[2E03]              	push	word [DMAADD+2]
 25577                                  
 25578 000045DE 8936[9E05]              	MOV	[THISSFT],SI		; Finish setting SFT pointer
 25579 000045E2 8B0E[8C03]              	MOV	CX,[IOXAD+2]
 25580 000045E6 890E[2E03]              	MOV	[DMAADD+2],CX
 25581 000045EA 8B0E[8A03]              	MOV	CX,[IOXAD]
 25582 000045EE 890E[2C03]              	MOV	[DMAADD],CX		; Set byte trans addr
 25583 000045F2 8B0E[8E03]              	MOV	CX,[IOSCNT]		; ioscnt specifies length of buffer
 25584 000045F6 EB10                    	JMP	SHORT RESTRET		; RETURN ADDRESS
 25585                                  
 25586                                  RESTXADDR:
 25587 000045F8 8F06[6C03]              	POP	WORD [CALLSCNT]		; Return address
 25588 000045FC 8F06[2E03]              	POP	WORD [DMAADD+2]		; Restore Disk trans addr
 25589 00004600 8F06[2C03]              	POP	WORD [DMAADD]
 25590                                  
 25591 00004604 E844BE                  	call	restore_world
 25592                                  
 25593 00004607 07                      	pop	es ; * (MSDOS 6.21)
 25594                                  					; SS override
 25595                                  RESTRET:
 25596 00004608 36FF26[6C03]            	JMP	WORD [SS:CALLSCNT]	; Return address
 25597                                  
 25598                                  ; DOSCODE:8569h (MSDOS 6.21, MSDOS.SYS)
 25599                                  ; 21/11/2022
 25600                                  ; DOSCODE:852Eh (MSDOS 5.0, MSDOS.SYS)
 25601                                  
 25602                                  ;Break <DEV_OPEN_SFT, DEV_CLOSE_SFT - OPEN or CLOSE A DEVICE>
 25603                                  
 25604                                  ;----------------------------------------------------------------------------
 25605                                  ;**	Dev_Open_SFT - Open the Device for an SFT
 25606                                  ;
 25607                                  ;	Dev_Open_SFT issues an open call to the device associated with
 25608                                  ;	the SFT.
 25609                                  ;
 25610                                  ;	ENTRY	(ES:DI) = SFT
 25611                                  ;	EXIT	none
 25612                                  ;	USES	all
 25613                                  ;----------------------------------------------------------------------------
 25614                                  
 25615                                  DEV_OPEN_SFT:
 25616 0000460D 06                      	push	es ; * (MSDOS 6.21)
 25617 0000460E E851BE                  	call	save_world
 25618                                  	;mov	al,0Dh	
 25619 00004611 B00D                    	MOV	AL,DEVOPN
 25620 00004613 EB06                    	JMP	SHORT DO_OPCLS
 25621                                  
 25622                                  ;----------------------------------------------------------------------------
 25623                                  ; Procedure Name : DEV_CLOSE_SFT
 25624                                  ;
 25625                                  ; Inputs:
 25626                                  ;	ES:DI Points to SFT
 25627                                  ; Function:
 25628                                  ;	Issue a CLOSE call to the correct device
 25629                                  ; Outputs:
 25630                                  ;	None
 25631                                  ; ALL preserved
 25632                                  ;----------------------------------------------------------------------------
 25633                                  
 25634                                  DEV_CLOSE_SFT:
 25635 00004615 06                      	push	es ; * (MSDOS 6.21)
 25636 00004616 E849BE                  	call	save_world
 25637                                  	;mov	al,0Eh	
 25638 00004619 B00E                    	MOV	AL,DEVCLS
 25639                                  
 25640                                  	; Main entry for device open and close. AL contains the function 
 25641                                  	; requested. Subtlety: if Sharing is NOT loaded then we do NOT issue 
 25642                                  	; open/close to block devices. This allows networks to function but 
 25643                                  	; does NOT hang up with bogus change-line code.
 25644                                  
 25645                                  	;entry	DO_OPCLS
 25646                                  DO_OPCLS:
 25647                                  	; Is the SFT for the net? If so, no action necessary.
 25648                                  
 25649                                  	; MSDOS 6.0
 25650                                  	;test	word [es:di+5],8000h
 25651                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 25652 0000461B 26F6450680              	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 25653 00004620 7567                    	jnz	short OPCLS_DONE	; NOP on net SFTs
 25654 00004622 30E4                    	XOR	AH,AH			; Unit
 25655                                  	;test	byte [es:di+5],80h
 25656 00004624 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 25657                                  	;les	di,[es:di+7]
 25658 00004629 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get DPB or device
 25659 0000462D 7513                    	JNZ	short GOT_DEV_ADDR
 25660                                  
 25661                                  	; We are about to call device open/close on a block driver. If no 
 25662                                  	; sharing then just short circuit to done.
 25663                                  	
 25664                                  	; MSDOS 6.0
 25665                                  					; SS override
 25666 0000462F 36803E[0303]01          	CMP	byte [ss:fShare],1	;AN010; /NC or no SHARE
 25667 00004635 7652                    	JBE	short OPCLS_DONE	;AN010; yes
 25668                                  
 25669                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25670                                  	;mov	ah,[es:di+1]
 25671 00004637 268A6501                	MOV	AH,[ES:DI+DPB.UNIT]	; (ah) = unit
 25672 0000463B 268A0D                  	mov	cl,[es:di]
 25673                                  	;MOV	CL,[ES:DI+DPB.DRIVE]	; (cl) = drive
 25674                                  	;;les	di,[es:di+12h] ; MSDOS 3.3
 25675                                  	;les	di,[es:di+13h] ; MSDOS 6.0
 25676 0000463E 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Get device
 25677                                  GOT_DEV_ADDR:				; ES:DI -> device
 25678                                  	;test	word [es:di+4],800h
 25679                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL
 25680 00004642 26F6450508              	test	byte [ES:DI+SYSDEV.ATT+1],(DEVOPCL>>8)
 25681 00004647 7440                    	JZ	short OPCLS_DONE	; Device can't
 25682 00004649 06                      	PUSH	ES
 25683 0000464A 1F                      	POP	DS
 25684 0000464B 89FE                    	MOV	SI,DI			; DS:SI -> device
 25685                                  
 25686                                  OPCLS_RETRY:
 25687                                  	;Context ES
 25688 0000464D 16                      	push	ss
 25689 0000464E 07                      	pop	es
 25690                                  					; DEVCALL is in DOSDATA
 25691 0000464F BF[5A03]                	MOV	DI,DEVCALL
 25692                                  
 25693 00004652 89FB                    	MOV	BX,DI
 25694 00004654 50                      	PUSH	AX
 25695                                  	;mov	al,13
 25696 00004655 B00D                    	MOV	AL,DOPCLHL
 25697 00004657 AA                      	STOSB				; Length
 25698 00004658 58                      	POP	AX
 25699 00004659 86E0                    	XCHG	AH,AL
 25700 0000465B AA                      	STOSB				; Unit
 25701 0000465C 86E0                    	XCHG	AH,AL
 25702 0000465E AA                      	STOSB				; Command
 25703 0000465F 26C7050000              	MOV	WORD [ES:DI],0		; Status
 25704 00004664 50                      	PUSH	AX			; Save Unit,Command
 25705                                  	;invoke	DEVIOCALL2
 25706 00004665 E82900                  	call	DEVIOCALL2
 25707                                  
 25708                                  	;mov	di,[es:bx+3]
 25709 00004668 268B7F03                	MOV	DI,[ES:BX+SRHEAD.REQSTAT]
 25710                                  	;test	di,8000h
 25711                                  	;jz	short OPCLS_DONEP	
 25712 0000466C 21FF                    	and	di,di
 25713 0000466E 7918                    	jns	short OPCLS_DONEP	; No error
 25714                                  	; 21/11/2022
 25715                                  	;test	word [si+4],8000h
 25716                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP
 25717                                  	;test	word [si+5],80h
 25718 00004670 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
 25719 00004674 7404                    	JZ	short BLKDEV
 25720 00004676 B486                    	MOV	AH,86H			; Read error in data, Char dev
 25721 00004678 EB04                    	JMP	SHORT HRDERR
 25722                                  BLKDEV:
 25723 0000467A 88C8                    	MOV	AL,CL			; Drive # in AL
 25724 0000467C B406                    	MOV	AH,6			; Read error in data, Blk dev
 25725                                  HRDERR:
 25726                                  	;invoke	CHARHARD
 25727 0000467E E8720C                  	call	CHARHARD
 25728 00004681 3C01                    	cmp	al,1
 25729 00004683 7503                    	jne	short OPCLS_DONEP	; IGNORE or FAIL
 25730                                  					;  Note that FAIL is essentually IGNORED
 25731 00004685 58                      	POP	AX			; Get back Unit, Command
 25732 00004686 EBC5                    	JMP	short OPCLS_RETRY
 25733                                  OPCLS_DONEP:
 25734 00004688 58                      	POP	AX			; Clean stack
 25735                                  OPCLS_DONE:
 25736 00004689 E8BFBD                  	call	restore_world
 25737 0000468C 07                      	pop	es ; * (MSDOS 6.21)
 25738 0000468D C3                      	retn
 25739                                  
 25740                                  ; 30/04/2019 - Retro DOS v4.0
 25741                                  ; DOSCODE:85EAh (MSDOS 6.21, MSDOS.SYS)
 25742                                  
 25743                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25744                                  ; DOSCODE:85AFh (MSDOS 5.0, MSDOS.SYS)
 25745                                  
 25746                                  ;Break	<DEVIOCALL, DEVIOCALL2 - CALL A DEVICE>
 25747                                  ;----------------------------------------------------------------------------
 25748                                  ;**	DevIoCall  - Call Device
 25749                                  ;
 25750                                  ;	ENTRY	DS:SI Points to device SFT
 25751                                  ;		ES:BX Points to request data
 25752                                  ;	EXIT	DS:SI -> Device driver
 25753                                  ;	USES	DS:SI,AX
 25754                                  ;----------------------------------------------------------------------------
 25755                                  ;**	DevIoCall2 - Call Device
 25756                                  ;
 25757                                  ;	ENTRY	DS:SI Points to DPB
 25758                                  ;		ES:BX Points to request data
 25759                                  ;	EXIT	DS:SI -> Device driver
 25760                                  ;	USES	DS:SI,AX
 25761                                  ;----------------------------------------------------------------------------
 25762                                  
 25763                                  DEVIOCALL:
 25764                                  					; SS override for CALLSSEC, 
 25765                                  	;lds	si,[si+7]		; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
 25766 0000468E C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 25767                                  
 25768                                  	;entry	DEVIOCALL2
 25769                                  DEVIOCALL2:
 25770                                  	;EnterCrit critDevice
 25771 00004691 E8B2CC                  	call	ECritDevice
 25772                                  
 25773                                  	; MSDOS 6.0
 25774                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP ;AN000; >32mb block device ?
 25775                                  	;test	byte [si+5],80h
 25776 00004694 F6440580                	test	byte [si+SYSDEV.ATT+1],(DEVTYP>>8)
 25777 00004698 7548                    	jnz	short chardev2		;AN000; >32mb no
 25778                                  
 25779                                  	; 16/12/2022
 25780                                  	; 22/11/2022
 25781 0000469A 268A4702                	mov	al,[ES:BX+SRHEAD.REQFUNC] ; [es:bx+2]
 25782 0000469E 3C04                    	cmp	al,DEVRD	; 4
 25783 000046A0 7408                    	je	short chkext	
 25784 000046A2 3C08                    	cmp	al,DEVWRT	; 8
 25785 000046A4 7404                    	je	short chkext
 25786 000046A6 3C09                    	cmp	al,DEVWRTV	; 9
 25787 000046A8 7538                    	jne	short chardev2
 25788                                  
 25789                                  	; 16/12/2022
 25790                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25791                                  	;;cmp	byte [es:bx+2],4
 25792                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVRD  ;AN000; >32mb read ?
 25793                                  	;JZ	short chkext		;AN000; >32mb   yes
 25794                                  	;;cmp	byte [es:bx+2],8
 25795                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRT ;AN000; >32mb write ?
 25796                                  	;JZ	short chkext		;AN000; >32mb   yes
 25797                                  	;;cmp	byte [es:bx+2],9
 25798                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRTV
 25799                                  	;				;AN000; >32mb write/verify ?
 25800                                  	;JNZ	short chardev2		;AN000; >32mb no
 25801                                  chkext:
 25802 000046AA E89900                  	CALL	RW_SC			;AN000;LB. use secondary cache if there
 25803 000046AD 7255                    	JC	short dev_exit		;AN000;LB. done
 25804                                  
 25805                                  	;test	byte [si+4],2
 25806 000046AF F6440402                	TEST	byte [SI+SYSDEV.ATT],EXTDRVR ;AN000;>32mb extended driver?
 25807 000046B3 741D                    	JZ	short chksector		;AN000;>32mb   no
 25808 000046B5 26800708                	ADD	BYTE [ES:BX],8		;AN000;>32mb   make length to 30
 25809 000046B9 36A1[6E03]              	MOV	AX,[SS:CALLSSEC]	;AN000;>32mb
 25810 000046BD 36C706[6E03]FFFF        	MOV	word [SS:CALLSSEC],-1	;AN000;>32mb   old sector  =-1
 25811 000046C4 36A3[7403]              	MOV	[SS:CALLNEWSC],AX	;AN000;>32mb   new sector  =
 25812 000046C8 36A1[0706]              	MOV	AX,[SS:HIGH_SECTOR]	;AN000; >32mb  low sector,high sector
 25813 000046CC 36A3[7603]              	MOV	[SS:CALLNEWSC+2],AX	;AN000; >32mb
 25814 000046D0 EB10                    	JMP	short chardev2		;AN000; >32mb
 25815                                  chksector:				;AN000; >32mb
 25816 000046D2 36833E[0706]00          	CMP	word [SS:HIGH_SECTOR],0	;AN000; >32mb   if >32mb
 25817 000046D8 7408                    	JZ	short chardev2		;AN000; >32mb   then fake error
 25818                                  	;mov	word [es:bx+3],8107h
 25819 000046DA 26C747030781            	MOV	word [ES:BX+SRHEAD.REQSTAT],STERR+STDON+error_I24_not_DOS_disk 
 25820                                  					;AN000; >32mb
 25821 000046E0 EB22                    	JMP	SHORT dev_exit		;AN000; >32mb
 25822                                  
 25823                                  chardev2:				;AN000;
 25824                                  	; As above only DS:SI points to device header on entry, and DS:SI is 
 25825                                  	; preserved
 25826                                  
 25827                                  	;mov	ax,[si+6]
 25828 000046E2 8B4406                  	MOV	AX,[SI+SYSDEV.STRAT]
 25829 000046E5 36A3[7803]              	MOV	[SS:CALLDEVAD],AX
 25830 000046E9 368C1E[7A03]            	MOV	[SS:CALLDEVAD+2],DS
 25831 000046EE 36FF1E[7803]            	CALL	far [SS:CALLDEVAD]
 25832                                  
 25833                                  	;mov	ax,[si+8]
 25834 000046F3 8B4408                  	MOV	AX,[SI+SYSDEV.INT]
 25835 000046F6 36A3[7803]              	MOV	[SS:CALLDEVAD],AX
 25836 000046FA 36FF1E[7803]            	CALL	far [SS:CALLDEVAD]
 25837                                  
 25838                                  	; MSDOS 6.0
 25839 000046FF E83A01                  	CALL	VIRREAD 		;AN000;LB. move data from SC to buffer
 25840 00004702 72DE                    	JC	short chardev2		;AN000;LB. bad sector or exceeds max sec
 25841                                  
 25842                                  dev_exit:
 25843                                  	;LeaveCrit critDevice
 25844                                  	;call	LCritDevice
 25845                                  	;retn
 25846                                  	; 18/12/2022
 25847 00004704 E95ACC                  	jmp	LCritDevice
 25848                                  
 25849                                  ; DOSCODE:8669h (MSDOS 6.21, MSDOS.SYS)
 25850                                  ; 22/11/2022
 25851                                  ; DOSCODE:862Eh (MSDOS 5.0, MSDOS.SYS)
 25852                                  
 25853                                  ;Break	<SETREAD, SETWRITE -- SET UP HEADER BLOCK>
 25854                                  ;---------------------------------------------------------------------------
 25855                                  ;
 25856                                  ; Procedure Name : SETREAD, SETWRITE
 25857                                  ;
 25858                                  ; Inputs:
 25859                                  ;	DS:BX = Transfer Address
 25860                                  ;	CX = Record Count
 25861                                  ;	DX = Starting Record
 25862                                  ;	AH = Media Byte
 25863                                  ;	AL = Unit Code
 25864                                  ; Function:
 25865                                  ;	Set up the device call header at DEVCALL
 25866                                  ; Output:
 25867                                  ;	ES:BX Points to DEVCALL
 25868                                  ; No other registers effected
 25869                                  ;
 25870                                  ;---------------------------------------------------------------------------
 25871                                  
 25872                                  SETREAD:
 25873 00004707 57                      	PUSH	DI
 25874 00004708 51                      	PUSH	CX
 25875 00004709 50                      	PUSH	AX
 25876 0000470A B104                    	MOV	CL,DEVRD ; mov cl,4
 25877                                  SETCALLHEAD:
 25878 0000470C B016                    	MOV	AL,DRDWRHL ; mov al,16h
 25879 0000470E 16                      	PUSH	SS
 25880 0000470F 07                      	POP	ES
 25881                                  					; DEVCALL is in DOSDATA
 25882 00004710 BF[5A03]                	MOV	DI,DEVCALL
 25883                                  
 25884 00004713 AA                      	STOSB				; length
 25885 00004714 58                      	POP	AX			; 
 25886 00004715 AA                      	STOSB				; Unit
 25887 00004716 50                      	PUSH	AX
 25888 00004717 88C8                    	MOV	AL,CL
 25889 00004719 AA                      	STOSB				; Command code
 25890 0000471A 31C0                    	XOR	AX,AX
 25891 0000471C AB                      	STOSW				; Status
 25892 0000471D 83C708                  	ADD	DI,8			; Skip link fields
 25893 00004720 58                      	POP	AX
 25894 00004721 86E0                    	XCHG	AH,AL
 25895 00004723 AA                      	STOSB				; Media byte
 25896 00004724 86C4                    	XCHG	AL,AH
 25897 00004726 50                      	PUSH	AX
 25898 00004727 89D8                    	MOV	AX,BX
 25899 00004729 AB                      	STOSW
 25900                                  
 25901 0000472A 8CD8                    	MOV	AX,DS
 25902 0000472C AB                      	STOSW				; Transfer addr
 25903                                  
 25904 0000472D 59                      	POP	CX			; Real AX
 25905 0000472E 58                      	POP	AX			; Real CX
 25906 0000472F AB                      	STOSW				; Count
 25907                                  
 25908 00004730 92                      	XCHG	AX,DX			; AX=Real DX, DX=real CX, CX=real AX
 25909 00004731 AB                      	STOSW				; Start
 25910 00004732 91                      	XCHG	AX,CX
 25911 00004733 87D1                    	XCHG	DX,CX
 25912 00004735 5F                      	POP	DI
 25913                                  					; DEVCALL is in DOSDATA
 25914 00004736 BB[5A03]                	MOV	BX,DEVCALL
 25915 00004739 C3                      	retn
 25916                                  
 25917                                  	;entry	SETWRITE
 25918                                  SETWRITE:
 25919                                  
 25920                                  ; Inputs:
 25921                                  ;	DS:BX = Transfer Address
 25922                                  ;	CX = Record Count
 25923                                  ;	DX = Starting Record
 25924                                  ;	AH = Media Byte
 25925                                  ;	AL = Unit Code
 25926                                  ; Function:
 25927                                  ;	Set up the device call header at DEVCALL
 25928                                  ; Output:
 25929                                  ;	ES:BX Points to DEVCALL
 25930                                  ; No other registers effected
 25931                                  
 25932 0000473A 57                      	PUSH	DI
 25933 0000473B 51                      	PUSH	CX
 25934 0000473C 50                      	PUSH	AX
 25935 0000473D B108                    	MOV	CL,DEVWRT ; mov cl,8
 25936 0000473F 36020E[FF02]            	ADD	CL,[SS:VERFLG]		; SS override
 25937 00004744 EBC6                    	JMP	SHORT SETCALLHEAD
 25938                                  
 25939                                  ; 30/04/2019 - Retro DOS v4.0
 25940                                  ; DOSCODE:86A8h (MSDOS 6.21, MSDOS.SYS)
 25941                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25942                                  ; DOSCODE:866Dh (MSDOS 5.0, MSDOS.SYS)
 25943                                  
 25944                                  ;Break	<RW_SC -- Read Write Secondary Cache>
 25945                                  ;---------------------------------------------------------------------------
 25946                                  ;
 25947                                  ; Procedure Name : RW_SC
 25948                                  ;
 25949                                  ; Inputs:
 25950                                  ;	 [SC_CACHE_COUNT]= secondary cache count
 25951                                  ;	 [SC_STATUS]= SC validity status
 25952                                  ;	 [SEQ_SECTOR]= last sector read
 25953                                  ; Function:
 25954                                  ;	Read from or write through secondary cache
 25955                                  ; Output:
 25956                                  ;	ES:BX Points to DEVCALL
 25957                                  ;	carry clear, I/O is not done
 25958                                  ;		     [SC_FLAG]=1 if continuos sectors will be read
 25959                                  ;	carry set, I/O is done
 25960                                  ;
 25961                                  ;----------------------------------------------------------------------------
 25962                                  
 25963                                  RW_SC:
 25964                                  	; SS override for all variables used.
 25965                                  	
 25966 00004746 36833E[7700]00          	CMP	word [ss:SC_CACHE_COUNT],0  ;AN000;LB. secondary cache exists?
 25967 0000474C 7421                    	JZ	short scexit4		    ;AN000;LB. no, do nothing
 25968 0000474E 36833E[6C03]01          	CMP	word [ss:CALLSCNT],1	    ;AN000;LB. sector count = 1 (buffer I/O)
 25969 00004754 7519                    	JNZ	short scexit4 		    ;AN000;LB. no, do nothing
 25970 00004756 51                      	PUSH	CX			    ;AN000;LB.
 25971 00004757 52                      	PUSH	DX			    ;AN000;LB. yes
 25972 00004758 1E                      	PUSH	DS			    ;AN000;LB. save registers
 25973 00004759 56                      	PUSH	SI			    ;AN000;LB.
 25974 0000475A 06                      	PUSH	ES			    ;AN000;LB.
 25975 0000475B 57                      	PUSH	DI			    ;AN000;LB.
 25976                                  
 25977 0000475C 368B16[6E03]            	MOV	DX,[ss:CALLSSEC]	    ;AN000;LB. starting sector
 25978 00004761 36803E[5C03]04          	CMP	BYTE [ss:DEVCALL_REQFUNC],DEVRD ;AN000;LB. read ?
 25979 00004767 7408                    	JZ	short doread		    ;AN000;LB. yes
 25980 00004769 E8BE00                  	CALL	INVALIDATE_SC		    ;AN000;LB. invalidate SC
 25981 0000476C E98B00                  	JMP	scexit2 		    ;AN000;LB. back to normal
 25982                                  scexit4:				    ;AN000;
 25983 0000476F F8                      	CLC				    ;AN000;LB. I/O not done yet
 25984 00004770 C3                      	retn				    ;AN000;LB.
 25985                                  doread: 				    ;AN000;
 25986 00004771 E82001                  	CALL	SC2BUF			    ;AN000;LB. check if in SC
 25987 00004774 720A                    	JC	short readSC		    ;AN000;LB.
 25988 00004776 36C706[5D03]0001        	MOV	word [ss:DEVCALL_REQSTAT],STDON ;AN000;LB. fake done and ok
 25989 0000477D F9                      	STC				    ;AN000;LB. set carry
 25990 0000477E EB68                    	JMP	short saveseq 		    ;AN000;LB. save seq. sector #
 25991                                  readSC: 				    ;AN000;
 25992 00004780 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]   	    ;AN000;LB. subtract sector num from
 25993 00004784 368B0E[6E03]            	MOV	CX,[ss:CALLSSEC]	    ;AN000;LB. saved sequential sector
 25994 00004789 362B0E[A90D]            	SUB	CX,[ss:SEQ_SECTOR]    	    ;AN000;LB. number
 25995 0000478E 361B06[AB0D]            	SBB	AX,[ss:SEQ_SECTOR+2]  	    ;AN000;LB.
 25996                                  	; 24/09/2023
 25997                                  	;CMP	AX,0			    ;AN000;LB. greater than 64K
 25998 00004793 7552                    	JNZ	short saveseq2		    ;AN000;LB. yes,save seq. sector #
 25999                                  chklow: 						
 26000 00004795 83F901                  	CMP	CX,1			    ;AN000;LB. <= 1
 26001 00004798 774D                    	JA	short saveseq2		    ;AN000;LB. no, not sequential
 26002 0000479A 36C706[B50D]FFFF        	MOV	word [ss:SC_STATUS],-1	    ;AN000;LB. presume all SC valid
 26003 000047A1 36A1[7700]              	MOV	AX,[ss:SC_CACHE_COUNT]	    ;AN000;LB. yes, sequential
 26004 000047A5 36A3[6C03]              	MOV	[ss:CALLSCNT],AX	    ;AN000;LB. read continuous sectors
 26005                                  readsr:
 26006 000047A9 36A1[6A03]              	MOV	AX,[ss:CALLXAD+2]	    ;AN000;LB. save buffer addr
 26007 000047AD 36A3[0E06]              	MOV	[ss:TEMP_VAR2],AX	    ;AN000;LB. in temp vars
 26008 000047B1 36A1[6803]              	MOV	AX,[ss:CALLXAD]	    	    ;AN000;LB.
 26009 000047B5 36A3[0C06]              	MOV	[ss:TEMP_VAR],AX	    ;AN000;LB.
 26010                                  
 26011 000047B9 36A1[7300]              	MOV	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. use SC cache addr as
 26012 000047BD 36A3[6803]              	MOV	[ss:CALLXAD],AX		    ;AN000;LB. transfer addr
 26013 000047C1 36A1[7500]              	MOV	AX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
 26014 000047C5 36A3[6A03]              	MOV	[ss:CALLXAD+2],AX	    ;AN000;LB.
 26015 000047C9 36C606[B70D]01          	MOV	byte [ss:SC_FLAG],1	    ;AN000;LB. flag it for later;
 26016 000047CF 36A0[AF0D]              	MOV	AL,[ss:SC_DRIVE]	    ;AN000;LB. current drive
 26017 000047D3 36A2[B00D]              	MOV	[ss:CurSC_DRIVE],AL	    ;AN000;LB. set current drive
 26018 000047D7 36A1[6E03]              	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB. current sector
 26019 000047DB 36A3[B10D]              	MOV	[ss:CurSC_SECTOR],AX	    ;AN000;LB. set current sector
 26020 000047DF 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB.
 26021 000047E3 36A3[B30D]              	MOV	[ss:CurSC_SECTOR+2],AX	    ;AN000;LB.
 26022                                  saveseq2:				    ;AN000;
 26023 000047E7 F8                      	CLC				    ;AN000;LB. clear carry
 26024                                  saveseq:				    ;AN000;	
 26025 000047E8 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB. save current sector #
 26026 000047EC 36A3[AB0D]              	MOV	[ss:SEQ_SECTOR+2],AX	    ;AN000;LB. for access mode ref.
 26027 000047F0 36A1[6E03]              	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB.	
 26028 000047F4 36A3[A90D]              	MOV	[ss:SEQ_SECTOR],AX 	    ;AN000;LB.	
 26029 000047F8 EB01                    	JMP	short scexit 		    ;AN000;LB.	
 26030                                  scexit2:				    ;AN000;LB.
 26031 000047FA F8                      	CLC				    ;AN000;LB.	clear carry
 26032                                  scexit: 				    ;AN000;		
 26033 000047FB 5F                      	POP	DI			    ;AN000;LB.
 26034 000047FC 07                      	POP	ES			    ;AN000;LB. restore registers
 26035 000047FD 5E                      	POP	SI			    ;AN000;LB.
 26036 000047FE 1F                      	POP	DS			    ;AN000;LB.
 26037 000047FF 5A                      	POP	DX			    ;AN000;LB.
 26038 00004800 59                      	POP	CX			    ;AN000;LB.
 26039 00004801 C3                      	retn				    ;AN000;LB.
 26040                                  
 26041                                  ;Break	<IN_SC -- check if in secondary cache>
 26042                                  ;--------------------------------------------------------------------------
 26043                                  ;
 26044                                  ; Procedure Name : IN_SC
 26045                                  ;
 26046                                  ; Inputs:  [SC_DRIVE]= requesting drive
 26047                                  ;	   [CURSC_DRIVE]= current SC drive
 26048                                  ;	   [CURSC_SECTOR]= starting scetor # of SC
 26049                                  ;	   [SC_CACHE_COUNT]= SC count
 26050                                  ;	   [HIGH_SECTOR]:DX= sector number
 26051                                  ; Function:
 26052                                  ;	Check if the sector is in secondary cache
 26053                                  ; Output:
 26054                                  ;	carry clear, in SC
 26055                                  ;	   CX= the index in the secondary cache
 26056                                  ;	carry set, not in SC
 26057                                  ;
 26058                                  ;---------------------------------------------------------------------------
 26059                                  
 26060                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26061                                  IN_SC:
 26062                                  	; SS override for all variables used
 26063 00004802 36A0[AF0D]              	MOV	AL,[ss:SC_DRIVE]	    ;AN000;;LB. current drive
 26064 00004806 363A06[B00D]            	CMP	AL,[ss:CurSC_DRIVE]	    ;AN000;;LB. same as SC drive
 26065 0000480B 751B                    	JNZ	short outrange2		    ;AN000;;LB. no
 26066 0000480D 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;;LB. subtract sector num from
 26067 00004811 89D1                    	MOV	CX,DX			    ;AN000;;LB. secondary starting sector
 26068 00004813 362B0E[B10D]            	SUB	CX,[ss:CurSC_SECTOR]        ;AN000;;LB. number
 26069 00004818 361B06[B30D]            	SBB	AX,[ss:CurSC_SECTOR+2]      ;AN000;;LB.
 26070                                  	; 24/09/2023
 26071                                  	;CMP	AX,0			    ;AN000;;LB. greater than 64K
 26072 0000481D 7509                    	JNZ	short outrange2		    ;AN000;;LB. yes
 26073 0000481F 363B0E[7700]            	CMP	CX,[ss:SC_CACHE_COUNT]	    ;AN000;;LB. greater than SC count
 26074 00004824 7302                    	JAE	short outrange2		    ;AN000;;LB. yes
 26075 00004826 F8                      	CLC				    ;AN000;;LB. clear carry
 26076                                  	;JMP	short inexit		    ;AN000;;LB. in SC
 26077                                  	; 16/12/2022
 26078 00004827 C3                      	retn	; 30/04/2019
 26079                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26080                                  	;jmp	short inexit
 26081                                  
 26082                                  outrange2:				    ;AN000;;LB. set carry
 26083 00004828 F9                      	STC				    ;AN000;;LB.
 26084                                  inexit: 				    ;AN000;;LB.
 26085 00004829 C3                      	retn				    ;AN000;;LB.
 26086                                  
 26087                                  ;Break	<INVALIDATE_SC - invalide secondary cache>
 26088                                  ;---------------------------------------------------------------------------
 26089                                  ;
 26090                                  ; Procedure Name : Invalidate_Sc
 26091                                  ;
 26092                                  ; Inputs:  [SC_DRIVE]= requesting drive
 26093                                  ;	   [CURSC_DRIVE]= current SC drive
 26094                                  ;	   [CURSC_SECTOR]= starting scetor # of SC
 26095                                  ;	   [SC_CACHE_COUNT]= SC count
 26096                                  ;	   [SC_STATUS]= SC status word
 26097                                  ;	   [HIGH_SECTOR]:DX= sector number
 26098                                  ;
 26099                                  ; Function:
 26100                                  ;	invalidate secondary cache if in there
 26101                                  ; Output:
 26102                                  ;	[SC_STATUS] is updated
 26103                                  ;---------------------------------------------------------------------------
 26104                                  
 26105                                  INVALIDATE_SC:
 26106                                  	; SS override for all variables used
 26107                                  
 26108 0000482A E8D5FF                  	CALL	IN_SC			    ;AN000;;LB. in secondary cache
 26109 0000482D 720C                    	JC	short outrange		    ;AN000;;LB. no
 26110 0000482F B80100                  	MOV	AX,1			    ;AN000;;LB. invalidate the sector
 26111 00004832 D3E0                    	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
 26112 00004834 F7D0                    	NOT	AX			    ;AN000;;LB.
 26113 00004836 362106[B50D]            	AND	[ss:SC_STATUS],AX	    ;AN000;;LB. save the status
 26114                                  outrange:				    ;AN000;;LB.
 26115 0000483B C3                      	retn				    ;AN000;;LB.
 26116                                  
 26117                                  ; DOSCODE:87A5h (MSDOS 6.21, MSDOS.SYS)
 26118                                  ; 22/11/2022
 26119                                  ; DOSCODE:876Ah (MSDOS 5.0, MSDOS.SYS)
 26120                                  
 26121                                  ;Break	<VIRREAD- virtually read data into buffer>
 26122                                  ;--------------------------------------------------------------------------
 26123                                  ;
 26124                                  ; Procedure Name : SC_FLAG
 26125                                  ;
 26126                                  ; Inputs:  SC_FLAG = 0, no sectors were read into SC
 26127                                  ;		     1, continuous sectors were read into SC
 26128                                  ; Function:
 26129                                  ;	   Move data from SC to buffer
 26130                                  ; Output:
 26131                                  ;	 carry clear, data is moved to buffer
 26132                                  ;	 carry set, bad sector or exceeds maximum sector
 26133                                  ;	   SC_FLAG =0
 26134                                  ;	   CALLSCNT=1
 26135                                  ;	   SC_STATUS= -1 if succeeded
 26136                                  ;     
 26137                                  ;		       0 if failed
 26138                                  ;--------------------------------------------------------------------------
 26139                                  
 26140                                  VIRREAD:
 26141                                  	; SS override for all variables used
 26142                                  
 26143 0000483C 36803E[B70D]00          	CMP	byte [ss:SC_FLAG],0	    ;AN000;;LB. from SC fill
 26144 00004842 744E                    	JZ	short sc2end		    ;AN000;;LB. no
 26145 00004844 36A1[0E06]              	MOV	AX,[ss:TEMP_VAR2]	    ;AN000;;LB. restore buffer addr
 26146 00004848 36A3[6A03]              	MOV	[ss:CALLXAD+2],AX	    ;AN000;;LB.
 26147 0000484C 36A1[0C06]              	MOV	AX,[ss:TEMP_VAR]	    ;AN000;;LB.
 26148 00004850 36A3[6803]              	MOV	[ss:CALLXAD],AX		    ;AN000;;LB.
 26149 00004854 36C606[B70D]00          	MOV	byte [ss:SC_FLAG],0	    ;AN000;;LB. reset sc_flag
 26150 0000485A 36C706[6C03]0100        	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. one sector transferred
 26151                                  
 26152                                  	;TEST	word [SS:DEVCALL_REQSTAT],STERR ;AN000;;LB. error?
 26153 00004861 36F606[5E03]80          	test	byte [ss:DEVCALL_REQSTAT+1],(STERR>>8) ; 80h
 26154 00004867 7513                    	JNZ	short scerror 		    ;AN000;;LB. yes
 26155 00004869 1E                      	PUSH	DS			    ;AN000;;LB.
 26156 0000486A 56                      	PUSH	SI			    ;AN000;;LB.
 26157 0000486B 06                      	PUSH	ES			    ;AN000;;LB.
 26158 0000486C 57                      	PUSH	DI			    ;AN000;;LB.
 26159 0000486D 52                      	PUSH	DX			    ;AN000;;LB.
 26160 0000486E 51                      	PUSH	CX			    ;AN000;;LB.
 26161 0000486F 31C9                    	XOR	CX,CX			    ;AN000;;LB. we want first sector in SC
 26162 00004871 E83100                  	CALL	SC2BUF2 		    ;AN000;;LB. move data from SC to buf
 26163 00004874 59                      	POP	CX
 26164 00004875 5A                      	POP	DX			    ;AN000;;LB.
 26165 00004876 5F                      	POP	DI			    ;AN000;;LB.
 26166 00004877 07                      	POP	ES			    ;AN000;;LB.
 26167 00004878 5E                      	POP	SI			    ;AN000;;LB.
 26168 00004879 1F                      	POP	DS			    ;AN000;;LB.
 26169 0000487A EB16                    	JMP	SHORT sc2end		    ;AN000;;LB. return
 26170                                  scerror:				    ;AN000;
 26171 0000487C 36C706[6C03]0100        	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. reset sector count to 1
 26172 00004883 36C706[B50D]0000        	MOV	word [ss:SC_STATUS],0	    ;AN000;;LB. invalidate all SC sectors
 26173 0000488A 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1    ;AN000;;LB. invalidate drive
 26174 00004890 F9                      	STC				    ;AN000;;LB. carry set
 26175 00004891 C3                      	retn				    ;AN000;;LB.
 26176                                  sc2end: 				    ;AN000;
 26177 00004892 F8                      	CLC				    ;AN000;;LB. carry clear
 26178 00004893 C3                      	retn				    ;AN000;;LB.
 26179                                  
 26180                                  ; 30/04/2019 - Retro  DOS v4.0
 26181                                  ; DOSCODE:87FDh (MSDOS 6.21, MSDOS.SYS)
 26182                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26183                                  ; DOSCODE:87C2h (MSDOS 5.0, MSDOS.SYS)
 26184                                  
 26185                                  ;Break	<SC2BUF- move data from SC to buffer>
 26186                                  ;----------------------------------------------------------------------------
 26187                                  ;
 26188                                  ; Procedure Name : SC2BUF
 26189                                  ;
 26190                                  ; Inputs:  [SC_STATUS] = SC validity status
 26191                                  ;	   [SC_SECTOR_SIZE] = request sector size
 26192                                  ;	   [SC_CACHE_PTR] = pointer to SC
 26193                                  ; Function:
 26194                                  ;	   Move data from SC to buffer
 26195                                  ; Output:
 26196                                  ;	   carry clear, in SC  and data is moved
 26197                                  ;	   carry set, not in SC and data is not moved
 26198                                  ;---------------------------------------------------------------------------
 26199                                  
 26200                                  SC2BUF:
 26201                                  	; SS override for all variables used
 26202 00004894 E86BFF                  	CALL	IN_SC			    ;AN000;LB. in secondary cache
 26203                                  	;JC	short noSC		    ;AN000;LB. no
 26204                                  	; 24/09/2023
 26205 00004897 723D                    	jc	short sexit
 26206 00004899 B80100                  	MOV	AX,1			    ;AN000;LB. check if valid sector
 26207 0000489C D3E0                    	SHL	AX,CL			    ;AN000;LB. in the secondary cache
 26208 0000489E 368506[B50D]            	TEST	[ss:SC_STATUS],AX	    ;AN000;LB.
 26209 000048A3 7430                    	JZ	short noSC		    ;AN000;LB. invalid
 26210                                  ;entry SC2BUF2
 26211                                  SC2BUF2:				    ;AN000;
 26212                                  	;MOV	AX,CX			    ;AN000;LB. times index with
 26213                                  	;MUL	word [ss:SC_SECTOR_SIZE]    ;AN000;LB. sector size
 26214                                  	; 24/09/2023
 26215 000048A5 36A1[AD0D]              	mov	ax,[ss:SC_SECTOR_SIZE]
 26216 000048A9 91                      	xchg	ax,cx ; cx = [ss:SC_SECTOR_SIZE]
 26217 000048AA F7E1                    	mul	cx
 26218 000048AC 360306[7300]            	ADD	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. add SC starting addr
 26219 000048B1 361316[7500]            	ADC	DX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
 26220 000048B6 8EDA                    	MOV	DS,DX			    ;AN000;LB. DS:SI-> SC sector addr
 26221 000048B8 89C6                    	MOV	SI,AX			    ;AN000;LB.
 26222 000048BA 368E06[6A03]            	MOV	ES,[ss:CALLXAD+2]		    ;AN000;LB. ES:DI-> buffer addr
 26223 000048BF 368B3E[6803]            	MOV	DI,[ss:CALLXAD]		    ;AN000;LB.
 26224                                  	; 24/09/2023
 26225                                  	;MOV	CX,[ss:SC_SECTOR_SIZE]	    ;AN000;LB. count= sector size
 26226 000048C4 D1E9                    	SHR	CX,1			    ;AN000;LB. may use DWORD move for 386
 26227                                  ;entry MOVWORDS
 26228                                  MOVWORDS:				    ;AN000;
 26229 000048C6 36803E[6A00]00          	CMP	byte [ss:DDMOVE],0	    ;AN000;LB. 386 ?
 26230 000048CC 7403                    	JZ	short nodd		    ;AN000;LB. no
 26231 000048CE D1E9                    	SHR	CX,1			    ;AN000;LB. words/2
 26232 000048D0 66                      	DB	66H			    ;AN000;LB. use double word move
 26233                                  nodd:
 26234 000048D1 F3A5                    	REP	MOVSW			    ;AN000;LB. move to buffer
 26235 000048D3 F8                      	CLC				    ;AN000;LB. clear carry
 26236 000048D4 C3                      	retn				    ;AN000;LB. exit
 26237                                  noSC:					    ;AN000;
 26238 000048D5 F9                      	STC				    ;AN000;LB. set carry
 26239                                  sexit:					    ;AN000;
 26240 000048D6 C3                      	retn				    ;AN000;LB.
 26241                                  
 26242                                  ;============================================================================
 26243                                  ; MKNODE.ASM, MSDOS 6.0, 1991
 26244                                  ;============================================================================
 26245                                  ; 29/07/2018 - Retro DOS v3.0
 26246                                  ; 19/05/2019 - Retro DOS v4.0
 26247                                  
 26248                                  ;	TITLE	MKNODE - Node maker
 26249                                  ;	NAME	MKNODE
 26250                                  
 26251                                  ;**	MKNODE.ASM
 26252                                  ;----------------------------------------------------------------------------
 26253                                  ;	Low level routines for making a new local file system node
 26254                                  ;	and filling in an SFT from a directory entry
 26255                                  ;
 26256                                  ;	BUILDDIR
 26257                                  ;	SETDOTENT
 26258                                  ;	MakeNode
 26259                                  ;	NEWENTRY
 26260                                  ;	FREEENT
 26261                                  ;	NEWDIR
 26262                                  ;	DOOPEN
 26263                                  ;	RENAME_MAKE
 26264                                  ;	CHECK_VIRT_OPEN
 26265                                  ;
 26266                                  ;	Revision history:
 26267                                  ;
 26268                                  ;	 AN000	version 4.0  Jan. 1988
 26269                                  ;	 A004	PTM 3680  --- Make SFT NAME field offset same as 3.30
 26270                                  
 26271                                  ;Break   <BUILDDIR,NEWDIR -- ALLOCATE DIRECTORIES>
 26272                                  ;----------------------------------------------------------------------------
 26273                                  ;
 26274                                  ; Procedure Name : BUILDDIR,NEWDIR
 26275                                  ;
 26276                                  ; Inputs:
 26277                                  ;       ES:BP Points to DPB
 26278                                  ;       [THISSFT] Set if using NEWDIR entry point
 26279                                  ;               (used by ALLOCATE)
 26280                                  ;       [LASTENT] current last valid entry number in directory if no free
 26281                                  ;               entries
 26282                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 26283                                  ; Function:
 26284                                  ;       Grow directory if no free entries and not root
 26285                                  ; Outputs:
 26286                                  ;       CARRY SET IF FAILURE
 26287                                  ;       ELSE
 26288                                  ;          AX entry number of new entry
 26289                                  ;          If a new dir [DIRSTART],[CLUSFAC],[CLUSNUM],[DIRSEC] set
 26290                                  ;               AX = first entry of new dir
 26291                                  ;       GETENT should be called to set [LASTENT]
 26292                                  ;
 26293                                  ;----------------------------------------------------------------------------
 26294                                  
 26295                                  ; 19/05/2019 - Retro DOS v4.0
 26296                                  ; DOSCODE:8845h (MSDOS 6.21, MSDOS.SYS)
 26297                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26298                                  ; DOSCODE:880Ah (MSDOS 6.21, MSDOS.SYS)
 26299                                  
 26300                                  ; 24/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 MSDOS.SYS)
 26301                                  ; DOSCODE:8845h (MSDOS 6.22, MSDOS.SYS)
 26302                                  
 26303                                  BUILDDIR:
 26304                                  	; 29/07/2018 - Retro DOS v3.0
 26305                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 4E66h
 26306                                  
 26307 000048D7 A1[D805]                        MOV     AX,[ENTFREE]
 26308 000048DA 83F8FF                          CMP     AX,-1 ; 0FFFFh
 26309                                  	;JZ	short CHECK_IF_ROOT
 26310                                          ;CLC
 26311                                          ;retn
 26312                                  	; 24/09/2023
 26313 000048DD 7507                    	jne	short builddir_cmc_retn  ; cf=1 (will be 0)
 26314                                  
 26315                                  CHECK_IF_ROOT:
 26316 000048DF 833E[C205]00                    CMP     word [DIRSTART],0
 26317 000048E4 7502                            JNZ	short NEWDIR
 26318                                          ;STC
 26319                                  	; 24/09/2023
 26320                                  	; [DIRSTART]=0, cf=0, zf=1 (cf will be 1 after cmc instruction)
 26321                                  builddir_cmc_retn:
 26322                                  	; 24/09/2023
 26323 000048E6 F5                      	cmc	; cf=1 <-> cf=0
 26324                                  builddir_retn:
 26325 000048E7 C3                              retn				; Can't grow root
 26326                                  
 26327                                  	;entry   NEWDIR
 26328                                  NEWDIR: 
 26329 000048E8 8B1E[C205]              	MOV     BX,[DIRSTART]
 26330 000048EC 09DB                            OR      BX,BX
 26331 000048EE 7405                            JZ	short NULLDIR
 26332 000048F0 E82806                  	call	GETEOF
 26333 000048F3 72F2                            jc	short builddir_retn	; Screw up
 26334                                  NULLDIR:
 26335 000048F5 B90100                          MOV     CX,1
 26336 000048F8 E83905                  	call	ALLOCATE
 26337 000048FB 72EA                            jc	short  builddir_retn
 26338 000048FD 8B16[C205]                      MOV     DX,[DIRSTART]
 26339 00004901 09D2                            OR      DX,DX
 26340 00004903 750D                            JNZ	short ADDINGDIR
 26341 00004905 E8DBF5                  	call	SETDIRSRCH
 26342 00004908 72DD                            jc	short  builddir_retn
 26343 0000490A C706[4803]FFFF                  MOV     word [LASTENT],-1
 26344 00004910 EB29                            JMP     SHORT GOTDIRREC
 26345                                  ADDINGDIR:
 26346 00004912 53                              PUSH    BX
 26347 00004913 8B1E[BC05]                      MOV     BX,[CLUSNUM]
 26348 00004917 E82D0C                          call	IsEOF
 26349 0000491A 5B                              POP     BX
 26350 0000491B 7217                            JB	short NOTFIRSTGROW
 26351                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 26352 0000491D 891E[BC05]                      MOV     [CLUSNUM],BX
 26353                                  	; 24/09/2023
 26354                                  	;PUSH	CX ; (not necessary)
 26355 00004921 50                      	PUSH	AX
 26356 00004922 55                      	PUSH	BP
 26357 00004923 B401                            MOV     AH,1			; CLUSNUM update
 26358                                  	; 15/12/2022
 26359 00004925 268A5600                	mov	dl,[ES:BP] ; 09/09/2018
 26360                                          ; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26361                                  	;;mov	dl,[es:bp+0]
 26362                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; drive #
 26363 00004929 8B0E[C205]                      MOV     CX,[DIRSTART]		; first cluster #
 26364 0000492D 89DD                            MOV     BP,BX 			; CLUSNUM
 26365 0000492F E8E8DD                  	call	FastOpen_Update
 26366 00004932 5D                              POP     BP
 26367 00004933 58                              POP     AX
 26368                                  	; 24/09/2023
 26369                                          ;POP	CX
 26370                                  
 26371                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 26372                                  NOTFIRSTGROW:
 26373 00004934 89DA                            MOV     DX,BX
 26374 00004936 30DB                            XOR     BL,BL
 26375 00004938 E8CC04                  	call	FIGREC
 26376                                  GOTDIRREC:
 26377                                  	;mov	cl,[es:bp+4]
 26378 0000493B 268A4E04                        MOV     CL,[ES:BP+DPB.CLUSTER_MASK]
 26379 0000493F FEC1                            INC     CL
 26380 00004941 30ED                            XOR     CH,CH
 26381                                  ZERODIR:
 26382 00004943 51                              PUSH    CX
 26383                                  	; 22/09/2023
 26384                                  	;;mov	byte [ALLOWED],18h
 26385                                          ;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 26386 00004944 B0FF                            MOV     AL,0FFH
 26387                                          ;call	GETBUFFR
 26388 00004946 E82210                          call	GETBUFFRD ; *
 26389 00004949 7302                    	JNC	short GET_SSIZE
 26390 0000494B 59                              POP     CX
 26391 0000494C C3                              retn
 26392                                  
 26393                                  GET_SSIZE:
 26394                                  	;mov	cx,[es:bp+2]
 26395 0000494D 268B4E02                        MOV     CX,[ES:BP+DPB.SECTOR_SIZE]
 26396 00004951 06                              PUSH    ES
 26397 00004952 C43E[E205]                      LES     DI,[CURBUF]
 26398                                  	;or	byte [es:di+5],4
 26399 00004956 26804D0504                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 26400 0000495B 57                              PUSH    DI
 26401                                  	;;add	di,16	; MSDOS 3.3
 26402                                  	;add	di,20	; MSDOS 6.0	
 26403 0000495C 83C714                          ADD     DI,BUFINSIZ
 26404 0000495F 31C0                            XOR     AX,AX
 26405 00004961 D1E9                            SHR     CX,1
 26406 00004963 F3AB                            REP     STOSW
 26407 00004965 7301                            JNC	short EVENZ
 26408 00004967 AA                              STOSB
 26409                                  EVENZ:
 26410 00004968 5F                              POP     DI
 26411                                  
 26412                                  	; MSDOS 6.0
 26413 00004969 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 26414                                  					;LB. if already dirty		  ;AN000;
 26415 0000496E 7508                            JNZ	short yesdirty7		;LB.  don't increment dirty count ;AN000;
 26416 00004970 E8FF11                          call	INC_DIRTY_COUNT		;LB. 				  ;AN000;
 26417                                          
 26418                                  	;or	byte [es:di+5],40h
 26419 00004973 26804D0540              	OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 26420                                  yesdirty7:
 26421 00004978 07                              POP	ES
 26422 00004979 59                              POP	CX
 26423                                  
 26424                                  	; 19/05/2019 - Retro DOS v4.0
 26425                                  
 26426                                  	; MSDOS 3.3
 26427                                  	;INC	DX
 26428                                  
 26429                                  	; MSDOS 6.0
 26430                                  	; 24/09/2023
 26431                                  	;add	dx,1
 26432                                  	;;adc	word [HIGH_SECTOR],0
 26433                                  	;; 24/09/2023
 26434                                  	;; ax=0
 26435                                  	;adc	[HIGH_SECTOR],ax ; 0
 26436                                  	; 24/09/2023
 26437 0000497A 42                      	inc	dx
 26438 0000497B 7504                    	jnz	short loop_zerodir
 26439 0000497D FF06[0706]              	inc	word [HIGH_SECTOR]
 26440                                  loop_zerodir:
 26441 00004981 E2C0                            LOOP    ZERODIR
 26442                                  
 26443 00004983 A1[4803]                        MOV     AX,[LASTENT]
 26444 00004986 40                              INC     AX
 26445                                  	; 24/09/2023
 26446                                  	; cf=0
 26447                                  	;CLC
 26448 00004987 C3                              retn
 26449                                  
 26450                                  ;--------------------------------------------------------------------------
 26451                                  ;
 26452                                  ; Procedure Name : SETDOTENT
 26453                                  ;
 26454                                  ; set up a . or .. directory entry for a directory.
 26455                                  ;
 26456                                  ;   Inputs:     ES:DI point to the beginning of a directory entry.
 26457                                  ;               AX contains ". " or ".."
 26458                                  ;               DX contains first cluster of entry
 26459                                  ;
 26460                                  ;----------------------------------------------------------------------------
 26461                                  
 26462                                  SETDOTENT:
 26463                                  ;	Fill in name field
 26464 00004988 AB                              STOSW
 26465 00004989 B90400                          MOV     CX,4
 26466 0000498C B82020                          MOV     AX,"  " ; 2020h
 26467 0000498F F3AB                            REP     STOSW
 26468 00004991 AA                              STOSB
 26469                                  
 26470                                  ;	Set up attribute
 26471                                  	;mov	al, 10h
 26472 00004992 B010                            MOV     AL,attr_directory
 26473 00004994 AA                              STOSB
 26474                                  
 26475                                  ;	Initialize time and date of creation
 26476 00004995 83C70A                          ADD     DI,10
 26477 00004998 8B36[9E05]                      MOV     SI,[THISSFT]
 26478                                  	;mov	ax,[si+0Dh]
 26479 0000499C 8B440D                          MOV     AX,[SI+SF_ENTRY.sf_time]
 26480 0000499F AB                              STOSW
 26481                                  	;mov	ax,[si+0Fh]
 26482 000049A0 8B440F                          MOV     AX,[SI+SF_ENTRY.sf_date]
 26483 000049A3 AB                      	STOSW
 26484                                  
 26485                                  ;	Set up first cluster field
 26486 000049A4 89D0                            MOV     AX,DX
 26487 000049A6 AB                              STOSW
 26488                                  
 26489                                  ;	0 file size
 26490 000049A7 31C0                            XOR     AX,AX
 26491 000049A9 AB                              STOSW
 26492 000049AA AB                              STOSW
 26493 000049AB C3                              retn
 26494                                  
 26495                                  ;Break   <MAKENODE -- CREATE A NEW NODE>
 26496                                  ;---------------------------------------------------------------------------
 26497                                  ;
 26498                                  ; Procedure Name : MakeNode
 26499                                  ;
 26500                                  ; Inputs:
 26501                                  ;       AL - attribute to create
 26502                                  ;       AH = 0 if it is ok to truncate a file already by this name
 26503                                  ;	AH != 0 if truncation not allowed (prexisting file is an error)
 26504                                  ;               (AH ignored on dirs and devices)
 26505                                  ;
 26506                                  ;        NOTE: When making a DIR or volume ID, AH need not be set since
 26507                                  ;               a name already existant is ALWAYS an error in these cases.
 26508                                  ;
 26509                                  ;       [WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 26510                                  ;               terminated)
 26511                                  ;       [CURR_DIR_END] Points to end of Current dir part of string
 26512                                  ;               ( = -1 if current dir not involved, else
 26513                                  ;                Points to first char after last "/" of current dir part)
 26514                                  ;       [THISCDS] Points to CDS being used
 26515                                  ;       [THISSFT] Points to an empty SFT. EXCEPT sf_mode filled in.
 26516                                  ; Function:
 26517                                  ;       Make a new node
 26518                                  ; Outputs:
 26519                                  ;       Sets EXTERR_LOCUS = errLOC_Disk or errLOC_Unk via GetPathNoset
 26520                                  ;       CARRY SET IF ERROR
 26521                                  ;          AX = 1 A node by this name exists and is a directory
 26522                                  ;          AX = 2 A new node could not be created
 26523                                  ;          AX = 3 A node by this name exists and is a disk file
 26524                                  ;               (AH was NZ on input)
 26525                                  ;          AX = 4 Bad Path
 26526                                  ;               SI return from GetPath maintained
 26527                                  ;          AX = 5 Attribute mismatch
 26528                                  ;          AX = 6 Sharing Violation
 26529                                  ;               (INT 24 generated ALWAYS since create is always compat mode
 26530                                  ;          AX = 7 file not found for Extended Open (not exists and fails)
 26531                                  ;       ELSE
 26532                                  ;          AX = 0 Disk Node
 26533                                  ;          AX = 3 Device Node (error in some cases)
 26534                                  ;          [DIRSTART],[DIRSEC],[CLUSFAC],[CLUSNUM] set to directory
 26535                                  ;               containing new node.
 26536                                  ;          [CURBUF+2]:BX Points to entry
 26537                                  ;          [CURBUF+2]:SI Points to entry.dir_first
 26538                                  ;          [THISSFT] is filled in
 26539                                  ;               sf_mode = unchanged.
 26540                                  ;          Attribute byte in entry is input AL
 26541                                  ; DS preserved, others destroyed
 26542                                  ;
 26543                                  ;-------------------------------------------------------------------------
 26544                                  
 26545                                  ; 19/05/2019 - Retro DOS v4.0
 26546                                  ; DOSCODE:8925h (MSDOS 6.21, MSDOS.SYS)
 26547                                  
 26548                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26549                                  ; DOSCODE:88EAh (MSDOS 5.0, MSDOS.SYS)
 26550                                  
 26551                                  MakeNode:
 26552                                  	;mov	word [CREATING],0E5FFh
 26553 000049AC C706[7E05]FFE5          	MOV	WORD [CREATING],DIRFREE*256 + 0FFh ; Creating, not DEL *.*
 26554 000049B2 50                              PUSH    AX              ; Save AH value
 26555 000049B3 C606[4C03]00            	MOV	byte [NoSetDir],0
 26556 000049B8 A2[6D05]                	MOV	[SATTRIB],AL
 26557 000049BB E888F5                  	call	GetPathNoSet
 26558 000049BE 88CA                            MOV     DL,CL           ; Save CL info
 26559 000049C0 89C1                            MOV     CX,AX           ; Device ID to CH
 26560 000049C2 58                              POP     AX              ; Get back AH
 26561 000049C3 732E                            JNC	short make_exists ; File existed
 26562 000049C5 7505                            JNZ	short make_err_4 ; Path bad
 26563 000049C7 80FA80                          CMP     DL,80h          ; Check "CL" return from GETPATH
 26564 000049CA 7406                            JZ	short make_type	; Name simply not found, and no metas
 26565                                  make_err_4:
 26566 000049CC B004                            MOV     AL,4            ; case 1 bad path
 26567                                  make_err_ret:
 26568 000049CE 30E4                            XOR     AH,AH
 26569 000049D0 F9                              STC
 26570                                  ;make_retn:	; 22/11/2022
 26571 000049D1 C3                              retn
 26572                                  
 26573                                          ;entry	RENAME_MAKE     ; Used by DOS_RENAME to "copy" a node
 26574                                  RENAME_MAKE:
 26575                                  make_type:
 26576                                  ;Extended Open hooks
 26577                                  	; MSDOS 6.0
 26578                                  	;TESTB	EXTOPEN_ON,EXT_OPEN_ON	;FT. from extended open		;AN000;
 26579 000049D2 F606[F605]01            	test	byte [EXTOPEN_ON],EXT_OPEN_ON ; 1
 26580 000049D7 7411                    	JZ	short make_type2	;FT. no				;AN000;
 26581 000049D9 800E[F605]04            	OR	byte [EXTOPEN_ON],EXT_FILE_NOT_EXISTS ; 4
 26582                                  					;FT. set for extended open ;AN000;
 26583                                  	;TESTB	EXTOPEN_FLAG,0F0H	;FT. not exists and fails	;AN000;
 26584 000049DE F606[F405]F0            	test	byte [EXTOPEN_FLAG],0F0h
 26585 000049E3 7505                    	JNZ	short make_type2	;FT. no				;AN000;
 26586 000049E5 F9                      	STC				;FT. set carry			;AN000;
 26587 000049E6 B80700                  	MOV    AX,7			;FT. file not found		;AN000;
 26588                                  	; 22/11/2022
 26589                                  make_retn:
 26590                                  	;return
 26591 000049E9 C3                      	retn				;FT.				;AN000;
 26592                                  
 26593                                  ;	Extended Open hooks
 26594                                  
 26595                                  make_type2:
 26596 000049EA C43E[9E05]                      LES     DI,[THISSFT]
 26597 000049EE 31C0                            XOR     AX,AX           ; nothing exists Disk Node
 26598 000049F0 F9                              STC                     ; Not found
 26599 000049F1 EB5A                            JMP     short make_new
 26600                                  
 26601                                  ; The node exists. It may be either a device, directory or file:
 26602                                  ;   Zero set => directory
 26603                                  ;   High bit of CH on => device
 26604                                  ;   else => file
 26605                                  
 26606                                  make_exists:
 26607 000049F3 7448                            JZ	short make_exists_dir
 26608 000049F5 B003                            MOV     AL,3            ; file exists type 3  (error or device node)
 26609                                  	;test	byte [ATTRIB],18h
 26610 000049F7 F606[6B05]18            	TEST	byte [ATTRIB],attr_volume_id+attr_directory
 26611 000049FC 753B                            JNZ	short make_err_ret_5
 26612                                  				; Cannot already exist as Disk or Device Node
 26613                                                                  ;       if making DIR or Volume ID
 26614 000049FE 08ED                            OR      CH,CH
 26615 00004A00 781A                            JS	short make_share ; No further checks on attributes if device
 26616 00004A02 08E4                            OR      AH,AH
 26617 00004A04 75C8                            JNZ	short make_err_ret ; truncating NOT OK (AL = 3)
 26618 00004A06 51                              PUSH    CX              ; Save device ID
 26619 00004A07 8E06[E405]                      MOV     ES,[CURBUF+2]
 26620                                  	;mov	ch,[es:bx+0Bh]
 26621 00004A0B 268A6F0B                        MOV     CH,[ES:BX+dir_entry.dir_attr] ; Get file attributes
 26622                                  	;test	ch,1
 26623 00004A0F F6C501                  	test	CH,attr_read_only
 26624 00004A12 7524                            JNZ	short make_err_ret_5P ; Cannot create on read only files
 26625 00004A14 E8D0F7                  	call	MatchAttributes
 26626 00004A17 59                              POP     CX              ; Devid back in CH
 26627 00004A18 751F                            JNZ	short make_err_ret_5 ; Attributes not ok
 26628 00004A1A 30C0                            XOR     AL,AL           ; AL = 0, Disk Node
 26629                                  make_share:
 26630 00004A1C 30E4                            XOR     AH,AH
 26631 00004A1E 50                              PUSH    AX              ; Save Disk or Device node
 26632 00004A1F 51                              PUSH    CX              ; Save Device ID
 26633 00004A20 88EC                            MOV     AH,CH           ; Device ID to AH
 26634 00004A22 E84501                          CALL    DOOPEN          ; Fill in SFT for share check
 26635 00004A25 C43E[9E05]                      LES     DI,[THISSFT]
 26636 00004A29 56                      	push	si
 26637 00004A2A 53                      	push	bx		; Save CURBUF pointers
 26638 00004A2B E86729                  	call	ShareEnter
 26639 00004A2E 735A                            jnc	short MakeEndShare
 26640                                  
 26641                                  ; User failed request.
 26642 00004A30 5B                      	pop	bx
 26643 00004A31 5E                      	pop	si
 26644 00004A32 59                      	pop	cx
 26645 00004A33 58                      	pop	ax
 26646                                  
 26647                                  Make_Share_ret:
 26648 00004A34 B006                            MOV     AL,6
 26649 00004A36 EB96                            JMP	short make_err_ret
 26650                                  
 26651                                  make_err_ret_5P:
 26652 00004A38 59                              POP     CX              ; Get back device ID
 26653                                  make_err_ret_5:
 26654 00004A39 B005                            MOV     AL,5            ; Attribute mismatch
 26655                                          ; 22/11/2022
 26656 00004A3B EB91                    	JMP     short make_err_ret
 26657                                  
 26658                                  make_exists_dir:
 26659 00004A3D B001                            MOV     AL,1            ; exists as directory, always an error
 26660                                  	; 22/11/2022
 26661 00004A3F EB8D                    	JMP     short make_err_ret
 26662                                  
 26663                                  make_save:
 26664 00004A41 50                              PUSH    AX              ; Save whether Disk or File
 26665 00004A42 89C8                            MOV     AX,CX           ; Device ID to AH
 26666 00004A44 E87400                          CALL    NEWENTRY
 26667 00004A47 58                              POP     AX              ; 0 if Disk, 3 if File
 26668 00004A48 739F                            jnc	short make_retn
 26669 00004A4A B002                            MOV     AL,2            ; create failed case 2
 26670                                  make_save_retn:
 26671 00004A4C C3                              retn
 26672                                  
 26673                                  make_new:
 26674 00004A4D E8F1FF                          call    make_save
 26675 00004A50 72FA                            jc	short make_save_retn	; case 2 fail
 26676                                  	;test	byte [ATTRIB],10h
 26677 00004A52 F606[6B05]10            	test	BYTE [ATTRIB],attr_directory
 26678 00004A57 75F3                            jnz	short make_save_retn	; Don't "open" directories,
 26679                                  					; so don't tell the sharer about them
 26680 00004A59 50                      	push	ax
 26681 00004A5A 53                      	push	bx
 26682 00004A5B 56                      	push	si		
 26683 00004A5C E83629                          call	ShareEnter
 26684 00004A5F 5E                      	pop	si
 26685 00004A60 5B                      	pop	bx
 26686 00004A61 58                      	pop	ax
 26687 00004A62 73E8                    	jnc	short make_save_retn
 26688                                  
 26689                                  ; We get here by having the user FAIL a share problem. Typically a failure of
 26690                                  ; this nature is an out-of-space or an internal error. We clean up as best as
 26691                                  ; possible: delete the newly created directory entry and return share_error.
 26692                                  
 26693 00004A64 50                              PUSH    AX
 26694 00004A65 C43E[E205]                      LES     DI,[CURBUF]
 26695                                  	;mov	byte [es:bx],0E5h
 26696 00004A69 26C607E5                	MOV	BYTE [ES:BX],DIRFREE	; nuke newly created entry.
 26697                                  	
 26698                                  	; MSDOS 6.0
 26699                                  	;test	byte [es:di+5],40h
 26700 00004A6D 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 26701                                  					;LB. if already dirty		  ;AN000;
 26702 00004A72 7508                            JNZ	short yesdirty8		;LB.  don't increment dirty count ;AN000;
 26703                                  	; 22/11/2022
 26704 00004A74 E8FB10                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 26705                                  	;or	byte [es:di+5],40h
 26706 00004A77 26804D0540                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty ; flag buffer as dirty
 26707                                  yesdirty8:
 26708 00004A7C C42E[8A05]                      LES     BP,[THISDPB]
 26709                                  	; 15/12/2022
 26710 00004A80 268A4600                        mov	al,[ES:BP]
 26711                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26712                                  	;;mov	al,[es:bp+0]
 26713                                  	;MOV	AL,[ES:BP+DPB.DRIVE]	; get drive for flush
 26714 00004A84 E8E60F                          call	FLUSHBUF		; write out buffer.
 26715 00004A87 58                              POP     AX
 26716 00004A88 EBAA                            jmp	short Make_Share_ret
 26717                                  
 26718                                  ; We have found an existing file. We have also entered it into the share set.
 26719                                  ; At this point we need to call newentry to correctly address the problem of
 26720                                  ; getting rid of old data (create an existing file) or creating a new
 26721                                  ; directory entry (create a new file). Unfortunately, this operation may
 26722                                  ; result in an INT 24 that the user doesn't return from, thus locking the file
 26723                                  ; irretrievably into the share set. The correct solution is for us to LEAVE
 26724                                  ; the share set now, do the operation and then reassert the share access.
 26725                                  ;
 26726                                  ; We are allowed to do this! There is no window! After all, we are in
 26727                                  ; critDisk here and for someone else to get in, they must enter critDisk also.
 26728                                  
 26729                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26730                                  	; DOSCODE:89C8h (MSDOS 5.0, MSDOS.SYS)
 26731                                  
 26732                                  MakeEndShare:
 26733 00004A8A C43E[9E05]                      LES     DI,[THISSFT]		; grab SFT
 26734 00004A8E 31C0                            XOR     AX,AX
 26735 00004A90 E87EC8                  	call	ECritSFT
 26736 00004A93 268705                  	xchg	AX,[ES:DI]
 26737                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 26738 00004A96 50                      	push	ax
 26739 00004A97 57                      	push	di
 26740 00004A98 06                      	push	es
 26741 00004A99 9C                              PUSHF
 26742 00004A9A E8F328                          call	ShareEnd                ; remove sharing
 26743 00004A9D 9D                              POPF
 26744 00004A9E 07                      	pop	es
 26745 00004A9F 5F                      	pop	di
 26746 00004AA0 268F05                          pop	word [ES:DI]	
 26747                                  	;pop	word [ES:DI+SF_ENTRY.sf_ref_count]
 26748 00004AA3 E886C8                  	call	LCritSFT
 26749                                  	; 22/11/2022
 26750                                  	; DOSCODE:89E4h (MSDOS 5.0, MSDOS.SYS)
 26751 00004AA6 5B                      	pop	bx
 26752 00004AA7 5E                      	pop	si
 26753 00004AA8 59                      	pop	cx
 26754 00004AA9 58                      	pop	ax
 26755 00004AAA E894FF                          CALL    make_save
 26756                                  
 26757                                  ; If the user failed, we do not reenter into the sharing set.
 26758                                  
 26759 00004AAD 729D                            jc	short make_save_retn	; bye if error
 26760 00004AAF 50                      	push	ax
 26761 00004AB0 53                      	push	bx
 26762 00004AB1 56                      	push	si
 26763 00004AB2 9C                              PUSHF
 26764 00004AB3 E8DF28                          call	ShareEnter
 26765 00004AB6 9D                              POPF
 26766 00004AB7 5E                      	pop	si
 26767 00004AB8 5B                      	pop	bx
 26768 00004AB9 58                      	pop	ax
 26769                                  
 26770                                  ; If Share_check fails, then we have an internal ERROR!!!!!
 26771                                  
 26772                                  makeendshare_retn:
 26773 00004ABA C3                              retn
 26774                                  
 26775                                  ;---------------------------------------------------------------------------
 26776                                  ;
 26777                                  ; Procedure Name : NEWENTRY
 26778                                  ;
 26779                                  ; Inputs:
 26780                                  ;       [THISSFT] set
 26781                                  ;       [THISDPB] set
 26782                                  ;       [LASTENT] current last valid entry number in directory if no free
 26783                                  ;               entries
 26784                                  ;       [VOLID] set if a volume ID was found during search
 26785                                  ;	Attrib Contains attributes for new file
 26786                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 26787                                  ;       CARRY FLAG INDICATES STATUS OF SEARCH FOR FILE
 26788                                  ;               NC means file existed (device)
 26789                                  ;               C  means file did not exist
 26790                                  ;       AH = Device ID byte
 26791                                  ;       If FILE
 26792                                  ;           [CURBUF+2]:BX points to start of directory entry
 26793                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 26794                                  ;       If device
 26795                                  ;           DS:BX points to start of "fake" directory entry
 26796                                  ;           DS:SI points to dir_first of "fake" directory entry
 26797                                  ;               (has DWORD pointer to device header)
 26798                                  ; Function:
 26799                                  ;       Make a new directory entry
 26800                                  ;       If an old one existed it is truncated first
 26801                                  ; Outputs:
 26802                                  ;       Carry set if error
 26803                                  ;               Can't grow dir, atts didn't match, attempt to make 2nd
 26804                                  ;               vol ID, user FAILed to I 24
 26805                                  ;       else
 26806                                  ;               outputs of DOOPEN
 26807                                  ; DS, BX, SI preserved (meaning on SI BX, not value), others destroyed
 26808                                  ;
 26809                                  ;----------------------------------------------------------------------------
 26810                                  
 26811                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26812                                  	; DOSCODE:89F9h (MSDOS 5.0, MSDOS.SYS)
 26813                                  
 26814                                  NEWENTRY:
 26815 00004ABB C42E[8A05]                      LES     BP,[THISDPB]
 26816 00004ABF 7315                            JNC	short EXISTENT	
 26817 00004AC1 803E[4A03]00                    CMP     byte [FAILERR],0
 26818                                  	;STC
 26819                                          ;jnz	short makeendshare_retn	; User FAILed, node might exist
 26820                                          ; 24/09/2023
 26821 00004AC6 750C                    	jnz	short ERRRET3
 26822 00004AC8 E80CFE                  	CALL    BUILDDIR        ; Try to build dir
 26823 00004ACB 72ED                            jc	short makeendshare_retn	; Failed
 26824 00004ACD E8E4F3                          call	GETENT          ; Point at that free entry
 26825 00004AD0 72E8                            jc	short makeendshare_retn	; Failed
 26826 00004AD2 EB0E                            JMP     SHORT FREESPOT
 26827                                  
 26828                                  ERRRET3:
 26829 00004AD4 F9                              STC
 26830                                  newentry_retn:
 26831 00004AD5 C3                              retn
 26832                                  
 26833                                  EXISTENT:
 26834 00004AD6 08E4                            OR      AH,AH           ; Check if file is I/O device
 26835 00004AD8 7903                            JNS	short NOT_DEV1
 26836 00004ADA E98D00                          JMP     DOOPEN          ; If so, proceed with open
 26837                                  
 26838                                  NOT_DEV1:
 26839 00004ADD E82901                          call	FREEENT		; Free cluster chain
 26840 00004AE0 72F3                            jc	short newentry_retn ; Failed
 26841                                  FREESPOT:
 26842                                  	;test	byte [ATTRIB],8
 26843 00004AE2 F606[6B05]08            	test	BYTE [ATTRIB],attr_volume_id
 26844 00004AE7 7407                            JZ	short NOTVOLID
 26845 00004AE9 803E[7B05]00                    CMP     BYTE [VOLID],0
 26846 00004AEE 75E4                            JNZ	short ERRRET3	; Can't create a second volume ID
 26847                                  NOTVOLID:
 26848 00004AF0 8E06[E405]                      MOV     ES,[CURBUF+2]
 26849 00004AF4 89DF                            MOV     DI,BX
 26850                                  
 26851 00004AF6 BE[4B05]                        MOV     SI,NAME1
 26852                                  
 26853 00004AF9 B90500                          MOV     CX,5
 26854 00004AFC F3A5                            REP     MOVSW
 26855 00004AFE A4                              MOVSB                   ; Move name into dir entry
 26856 00004AFF A0[6B05]                	MOV	AL,[ATTRIB]
 26857 00004B02 AA                      	STOSB                   ; Attributes
 26858                                  
 26859                                  ;; File Tagging for Create DOS 4.00
 26860 00004B03 B105                            MOV     CL,5            ;FT. assume normal FBUGBUG	;AN000;
 26861                                  ;; File Tagging for Create DOS 4.00
 26862                                  
 26863 00004B05 31C0                            XOR     AX,AX
 26864 00004B07 F3AB                            REP     STOSW           ; Zero pad
 26865 00004B09 E8E4BF                          call	DATE16
 26866 00004B0C 92                              XCHG    AX,DX
 26867 00004B0D AB                              STOSW                   ; dir_time
 26868 00004B0E 92                              XCHG    AX,DX
 26869 00004B0F AB                              STOSW                   ; dir_date
 26870 00004B10 31C0                            XOR     AX,AX
 26871 00004B12 57                              PUSH    DI              ; Correct SI input value
 26872                                  				; 	(recomputed for new buffer)
 26873 00004B13 AB                              STOSW                   ; Zero dir_first and size
 26874 00004B14 AB                              STOSW
 26875 00004B15 AB                              STOSW
 26876                                  updnxt:
 26877 00004B16 8B36[E205]              	MOV	SI,[CURBUF]
 26878                                  
 26879                                  	; 19/05/2019 - Retro DOS v4.0
 26880                                  
 26881                                  	; MSDOS 6.0
 26882 00004B1A 26F6440540              	TEST	byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 26883                                  				;LB. if already dirty		  ;AN000;
 26884 00004B1F 7508                            JNZ	short yesdirty9	;LB.  don't increment dirty count ;AN000;
 26885 00004B21 E84E10                          call	INC_DIRTY_COUNT	;LB.				  ;AN000;
 26886                                          
 26887                                  	;or	byte [es:si+5],40h
 26888 00004B24 26804C0540              	OR      byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 26889                                  yesdirty9:
 26890 00004B29 C42E[8A05]                      LES     BP,[THISDPB]
 26891                                  	; 15/12/2022
 26892 00004B2D 268A4600                	MOV	AL,[ES:BP]
 26893                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26894                                  	;;mov	al,[es:bp+0]
 26895                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; Sets AH value again (in AL)
 26896 00004B31 50                              PUSH    AX
 26897 00004B32 53                              PUSH    BX
 26898                                  
 26899                                  ; If we have a file, we need to increment the open ref. count so that
 26900                                  ; we have some protection against invalid media changes if an Int 24
 26901                                  ; error occurs.
 26902                                  ; Do nothing for a device.
 26903                                  
 26904 00004B33 06                      	push	es
 26905 00004B34 57                      	push	di
 26906 00004B35 C43E[9E05]                      LES     DI,[THISSFT]
 26907                                  	;test	word [es:di+5],80h
 26908                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 26909 00004B39 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 26910 00004B3E 751A                            jnz	short GotADevice
 26911 00004B40 1E                      	push	ds
 26912 00004B41 53                      	push	bx
 26913 00004B42 C51E[8A05]                      LDS     BX,[THISDPB]
 26914                                  	;mov	[es:di+7],bx
 26915 00004B46 26895D07                        MOV     [ES:DI+SF_ENTRY.sf_devptr],BX
 26916 00004B4A 8CDB                            MOV     BX,DS
 26917                                  	;mov	[es:di+9],bx
 26918 00004B4C 26895D09                        MOV     [ES:DI+SF_ENTRY.sf_devptr+2],BX
 26919 00004B50 5B                      	pop	bx
 26920 00004B51 1F                      	pop	ds ; need to use DS for segment later on
 26921 00004B52 E8B8FA                  	call	DEV_OPEN_SFT    ; increment ref. count
 26922 00004B55 C606[A20A]01                    mov	byte [VIRTUAL_OPEN],1; set flag
 26923                                  GotADevice:
 26924 00004B5A 5F                      	pop	di
 26925 00004B5B 07                      	pop	es
 26926                                  
 26927 00004B5C E80E0F                          call	FLUSHBUF
 26928 00004B5F E8EF00                          Call    CHECK_VIRT_OPEN ; decrement ref. count            ;AN000;
 26929 00004B62 5B                              POP     BX
 26930 00004B63 58                              POP     AX
 26931 00004B64 5E                              POP     SI              ; Get SI input back
 26932 00004B65 88C4                            MOV     AH,AL           ; Get I/O driver number back
 26933 00004B67 7301                    	jnc	short DOOPEN    ; Failed
 26934 00004B69 C3                      	retn
 26935                                  	
 26936                                  ;NOTE FALL THROUGH
 26937                                  
 26938                                  ; DOSCODE:8AE4h (MSDOS 6.21, MSDOS.SYS)
 26939                                  
 26940                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26941                                  ; DOSCODE:8AA9h (MSDOS 5.0, MSDOS.SYS)
 26942                                  
 26943                                  ; DOOPEN
 26944                                  ;----------------------------------------------------------------------------
 26945                                  ;
 26946                                  ; Inputs:
 26947                                  ;       [THISDPB] points to DPB if file
 26948                                  ;       [THISSFT] points to SFT being used
 26949                                  ;       AH = Device ID byte
 26950                                  ;       If FILE
 26951                                  ;           [CURBUF+2]:BX points to start of directory entry
 26952                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 26953                                  ;       If device
 26954                                  ;           DS:BX points to start of "fake" directory entry
 26955                                  ;           DS:SI points to dir_first of "fake" directory entry
 26956                                  ;               (has DWORD pointer to device header)
 26957                                  ; Function:
 26958                                  ;       Fill in SFT from dir entry
 26959                                  ; Outputs:
 26960                                  ;       CARRY CLEAR
 26961                                  ;       sf_ref_count and sf_mode fields not altered
 26962                                  ;       sf_flags high byte = 0
 26963                                  ;       sf_flags low byte = AH except
 26964                                  ;       sf_flags Bit 6 set (not dirty or not EOF)
 26965                                  ;       sf_attr sf_date sf_time sf_name set from entry
 26966                                  ;       sf_position = 0
 26967                                  ;       If device
 26968                                  ;           sf_devptr = dword at dir_first (pointer to device header)
 26969                                  ;           sf_size = 0
 26970                                  ;       If file
 26971                                  ;           sf_firclus sf_size set from entry
 26972                                  ;           sf_devptr = [THISDPB]
 26973                                  ;           sf_cluspos = 0
 26974                                  ;           sf_lstclus = sf_firclus
 26975                                  ;           sf_dirsec sf_dirpos set
 26976                                  ; DS,SI,BX preserved, others destroyed
 26977                                  ;
 26978                                  ;----------------------------------------------------------------------------
 26979                                  
 26980                                  	;entry	DOOPEN
 26981                                  DOOPEN:
 26982                                  ;	Generate and store attribute
 26983                                  
 26984 00004B6A 88E6                            MOV     DH,AH           ; AH to different place
 26985 00004B6C C43E[9E05]                      LES     DI,[THISSFT]
 26986                                  	;add	di,4
 26987 00004B70 83C704                          ADD     DI,SF_ENTRY.sf_attr ; Skip ref_count and mode fields
 26988                                  	; 24/09/2023
 26989 00004B73 31C0                    	xor	ax,ax
 26990                                  	;XOR	AL,AL		; Assume it's a device, devices have an
 26991                                  				;   attribute of 0 (for R/O testing etc).
 26992 00004B75 08F6                            OR      DH,DH           ; See if our assumption good.
 26993 00004B77 7807                            JS	short DEV_SFT1	; If device DS=DOSGROUP
 26994 00004B79 8E1E[E405]                      MOV     DS,[CURBUF+2]
 26995                                  	;mov	al,[BX+0Bh]
 26996 00004B7D 8A470B                          MOV     AL,[BX+dir_entry.dir_attr]
 26997                                  				; If file, get attrib from dir entry
 26998                                  DEV_SFT1:
 26999 00004B80 AA                              STOSB                   ; sf_attr, ES:DI -> sf_flags
 27000                                  
 27001                                  ;	Generate and store flags word
 27002                                  
 27003                                  	; 24/09/2023
 27004                                  	;XOR	AX,AX
 27005                                          ; ah=0
 27006 00004B81 88F0                    	MOV     AL,DH
 27007                                  	;or	al,40h
 27008 00004B83 0C40                            OR      AL,devid_file_clean
 27009 00004B85 AB                              STOSW                   ; sf_flags, ES:DI -> sf_devptr
 27010                                  
 27011                                  ;	Generate and store device pointer
 27012                                  
 27013 00004B86 1E                              PUSH    DS
 27014                                  	;lds	ax,[bx+1Ah]
 27015 00004B87 C5471A                          LDS     AX,[BX+dir_entry.dir_first] ; Assume device
 27016 00004B8A 08F6                            OR      DH,DH
 27017 00004B8C 7805                            JS	short DEV_SFT2
 27018                                  
 27019                                  ;hkn; SS override
 27020 00004B8E 36C506[8A05]                    LDS     AX,[SS:THISDPB]	; Was file
 27021                                  DEV_SFT2:
 27022 00004B93 AB                              STOSW 			; store offset
 27023 00004B94 8CD8                            MOV     AX,DS
 27024 00004B96 1F                              POP     DS
 27025 00004B97 AB                      	STOSW			; store segment
 27026                                  				; ES:DI -> sf_firclus
 27027                                  
 27028                                  ;	Generate pointer to, generate and store first cluster 
 27029                                  ;	(irrelevant for devices)
 27030                                  
 27031 00004B98 56                              PUSH    SI              ; Save pointer to dir_first
 27032 00004B99 A5                              MOVSW                   ; dir_first -> sf_firclus
 27033                                                                  ; DS:SI -> dir_size_l, ES:DI -> sf_time
 27034                                  
 27035                                  ;	Copy time/date of last modification
 27036                                  
 27037                                  	;sub	si,6
 27038 00004B9A 83EE06                          SUB     SI,dir_entry.dir_size_l - dir_entry.dir_time 
 27039                                  				; DS:SI->dir_time
 27040 00004B9D A5                              MOVSW                   ; dir_time -> sf_time
 27041                                                                  ; DS:SI -> dir_date, ES:DI -> sf_date
 27042 00004B9E A5                              MOVSW                   ; dir_date -> sf_date
 27043                                                                  ; DS:SI -> dir_first, ES:DI -> sf_size
 27044                                  
 27045                                  ;	Generate and store file size (0 for devices)
 27046                                  
 27047 00004B9F AD                              LODSW                   ; skip dir_first, DS:SI -> dir_size_l
 27048 00004BA0 AD                              LODSW                   ; dir_size_l in AX , DS:SI -> dir_size_h
 27049 00004BA1 89C1                            MOV     CX,AX           ; dir_size_l in CX
 27050 00004BA3 AD                              LODSW                   ; dir_size_h (size AX:CX), DS:SI -> ????
 27051 00004BA4 08F6                            OR      DH,DH
 27052 00004BA6 7904                            JNS	short FILE_SFT1
 27053 00004BA8 31C0                            XOR     AX,AX
 27054 00004BAA 89C1                            MOV     CX,AX           ; Devices are open ended
 27055                                  FILE_SFT1:
 27056 00004BAC 91                              XCHG    AX,CX
 27057 00004BAD AB                              STOSW                   ; Low word of sf_size
 27058 00004BAE 91                              XCHG    AX,CX
 27059 00004BAF AB                              STOSW                   ; High word of sf_size
 27060                                                                  ; ES:DI -> sf_position
 27061                                  ; Initialize position to 0
 27062                                  
 27063 00004BB0 31C0                            XOR     AX,AX
 27064 00004BB2 AB                              STOSW
 27065 00004BB3 AB                              STOSW                   ; sf_position
 27066                                                                  ; ES:DI -> sf_cluspos
 27067                                  
 27068                                  ; Generate cluster optimizations for files
 27069                                  
 27070 00004BB4 08F6                            OR      DH,DH
 27071 00004BB6 7843                            JS	short DEV_SFT3
 27072 00004BB8 AB                              STOSW                   ; sf_cluspos ; 19h
 27073                                  	;mov	ax,[bx+1Ah]
 27074 00004BB9 8B471A                          MOV     AX,[BX+dir_entry.dir_first]
 27075                                  	; 19/05/2019
 27076                                  	; MSDOS 3.3
 27077                                  	;STOSW 			; sf_lstclus ; 1Bh
 27078                                  	; MSDOS 6.0
 27079 00004BBC 57                              PUSH	DI              ;AN004; save dirsec offset
 27080                                  	;sub	di,1Bh
 27081 00004BBD 83EF1B                          SUB	DI,SF_ENTRY.sf_dirsec	;AN004; es:di -> SFT
 27082                                  	;mov	[es:di+35h],ax
 27083 00004BC0 26894535                        MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX	;AN004; save it
 27084 00004BC4 5F                              POP	DI              ;AN004; restore dirsec offset
 27085                                  
 27086                                  ; DOS 3.3  FastOpen  6/13/86
 27087                                  
 27088 00004BC5 1E                      	PUSH	DS
 27089                                  
 27090                                  ;hkn; SS is DOSDATA
 27091 00004BC6 16                      	push	ss
 27092 00004BC7 1F                      	pop	ds
 27093                                  	;test	byte [FastOpenFlg],4
 27094 00004BC8 F606[3A0D]04            	TEST	byte [FastOpenFlg],Special_Fill_Set
 27095 00004BCD 7411                    	JZ	short Not_FastOpen
 27096                                  
 27097                                  ;hkn; FastOpen_Ext_Info is in DOSDATA
 27098 00004BCF BE[3B0D]                        MOV     SI,FastOpen_Ext_Info
 27099                                  
 27100                                  	;mov	ax,[si+1]
 27101 00004BD2 8B4401                          MOV     AX,[SI+FEI.dirsec]
 27102 00004BD5 AB                              STOSW                   ; sf_dirsec
 27103                                  	; MSDOS 6.0
 27104                                  	;mov	ax,[si+3]
 27105 00004BD6 8B4403                          MOV	AX,[SI+FEI.dirsec+2]
 27106                                  				;;; changed for >32mb
 27107 00004BD9 AB                              STOSW                   ; sf_dirsec
 27108                                  	; 19/08//2018
 27109 00004BDA 8A04                    	mov	al,[SI]
 27110                                          ;MOV	AL,[SI+FEI.dirpos] ; mov al,[SI+0]
 27111 00004BDC AA                              STOSB                   ; sf_dirpos
 27112 00004BDD 1F                              POP	DS
 27113                                          ;JMP	short Next_Name
 27114                                  	; 24/09/2023
 27115 00004BDE EB1E                    	jmp	short FILE_SFT2  ; cf=0 (after 'test' instruction)
 27116                                  
 27117                                  ; DOS 3.3  FastOpen  6/13/86
 27118                                  
 27119                                  Not_FastOpen:
 27120                                          ;POP     DS		; normal path
 27121                                  
 27122                                  ;hkn; SS override
 27123                                  	;MOV	SI,[SS:CURBUF]	; DS:SI->buffer header
 27124                                  	; 16/12/2022
 27125                                  	; 28/07/2019
 27126 00004BE0 8B36[E205]              	mov	si,[CURBUF]
 27127 00004BE4 1F                      	pop	ds
 27128                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27129                                  	;pop	ds
 27130                                  	;mov	si,[ss:CURBUF]
 27131                                  	
 27132                                  	;mov	ax,[si+6]
 27133 00004BE5 8B4406                          MOV     AX,[SI+BUFFINFO.buf_sector]     ;F.C. >32mb ;AN000;
 27134 00004BE8 AB                              STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 27135                                  	; 19/05/2019        
 27136                                  	; MSDOS 6.0
 27137                                  	;mov	ax,[si+8]
 27138 00004BE9 8B4408                  	MOV	AX,[SI+BUFFINFO.buf_sector+2]	;F.C. >32mb ;AN000;
 27139 00004BEC AB                              STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 27140                                          
 27141 00004BED 89D8                    	MOV     AX,BX
 27142                                  	;;add	si,16	; MSDOS 3.3	
 27143                                  	;add	si,20	; MSDOS 6.0
 27144 00004BEF 83C614                          ADD     SI,BUFINSIZ     ; DS:SI-> start of data in buffer
 27145 00004BF2 29F0                            SUB     AX,SI           ; AX = BX relative to start of sector
 27146                                          ;mov	cl,32
 27147 00004BF4 B120                    	MOV     CL,dir_entry.size
 27148 00004BF6 F6F1                            DIV     CL
 27149 00004BF8 AA                              STOSB                   ; sf_dirpos
 27150                                  Next_Name:
 27151 00004BF9 EB03                            JMP     SHORT FILE_SFT2
 27152                                  
 27153                                  	; 24/09/2023
 27154                                  	; cf=0 (after 'or' instruction)
 27155                                  DEV_SFT3:
 27156                                  	;add	di,7
 27157 00004BFB 83C707                          ADD     DI,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 27158                                  FILE_SFT2:
 27159                                  
 27160                                  ; Copy in the object's name
 27161                                  
 27162 00004BFE 89DE                            MOV     SI,BX           ; DS:SI points to dir_name
 27163 00004C00 B90B00                          MOV     CX,11
 27164 00004C03 F3A4                            REP     MOVSB           ; sf_name
 27165 00004C05 5E                              POP     SI              ; recover DS:SI -> dir_first
 27166                                  
 27167                                  ;hkn; SS is DOSDATA
 27168 00004C06 16                              push	ss
 27169 00004C07 1F                      	pop	ds
 27170                                  	; 24/09/2023
 27171                                  	; cf=0
 27172                                          ;CLC
 27173 00004C08 C3                              retn
 27174                                  
 27175                                  ;---------------------------------------------------------------------------
 27176                                  ;
 27177                                  ; Procedure Name : FREEENT
 27178                                  ;
 27179                                  ; Inputs:
 27180                                  ;       ES:BP -> DPB
 27181                                  ;       [CURBUF] Set
 27182                                  ;       [CURBUF+2]:BX points to directory entry
 27183                                  ;       [CURBUF+2]:SI points to above dir_first
 27184                                  ; Function:
 27185                                  ;       Free the cluster chain for the entry if present
 27186                                  ; Outputs:
 27187                                  ;       Carry set if error (currently user FAILed to I 24)
 27188                                  ;       (NOTE dir_firclus and dir_size_l/h are wrong)
 27189                                  ; DS BX SI ES BP preserved (BX,SI in meaning, not value) others destroyed
 27190                                  ;---------------------------------------------------------------------------
 27191                                  
 27192                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27193                                  FREEENT:
 27194 00004C09 1E                              PUSH    DS
 27195 00004C0A C53E[E205]                      LDS     DI,[CURBUF]
 27196 00004C0E 8B0C                            MOV     CX,[SI]         ; Get pointer to clusters
 27197                                  	; 19/05/2019 - Retro DOS v4.0
 27198                                  	; MSDOS 6.0
 27199 00004C10 8B5508                  	MOV	DX,[DI+BUFFINFO.buf_sector+2]  ;F.C. >32mb	;AN000;
 27200                                  ;hkn; SS override
 27201 00004C13 368916[0706]                    MOV	[SS:HIGH_SECTOR],DX		;F.C. >32mb	;AN000;
 27202 00004C18 8B5506                          MOV     DX,[DI+BUFFINFO.buf_sector]
 27203 00004C1B 1F                              POP     DS
 27204 00004C1C 83F902                  	CMP	CX,2
 27205 00004C1F 722E                            JB	short RET1	; Was 0 length file (or mucked Firclus if CX=1)
 27206                                  	;cmp	cx,[es:bp+0Dh]
 27207 00004C21 263B4E0D                        CMP     CX,[ES:BP+DPB.MAX_CLUSTER]
 27208 00004C25 7728                            JA	short RET1	; Treat like zero length file (firclus mucked)
 27209 00004C27 29FB                            SUB     BX,DI
 27210 00004C29 53                              PUSH    BX              ; Save offset
 27211 00004C2A FF36[0706]              	PUSH	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 27212 00004C2E 52                              PUSH    DX              ; Save sector number
 27213 00004C2F 89CB                            MOV     BX,CX
 27214 00004C31 E8AC02                          call	RELEASE         ; Free any data allocated
 27215 00004C34 5A                              POP     DX
 27216 00004C35 8F06[0706]                      POP	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 27217 00004C39 7302                            JNC	short GET_BUF_BACK
 27218 00004C3B 5B                              POP     BX
 27219                                  freeent_retn:
 27220 00004C3C C3                              retn			; Screw up
 27221                                  
 27222                                  GET_BUF_BACK:
 27223                                  	; 22/09/2023
 27224                                  	;;mov	byte [ALLOWED],18h
 27225                                          ;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 27226                                          ;XOR	AL,AL ; *
 27227                                  	;call	GETBUFFR        ; Get sector back
 27228 00004C3D E8290D                  	call	GETBUFFER ; * ; pre read      
 27229                                  
 27230 00004C40 5B                      	POP     BX              ; Get offset back
 27231 00004C41 72F9                            jc	short freeent_retn
 27232 00004C43 E8B0EA                  	call	SET_BUF_AS_DIR
 27233 00004C46 031E[E205]                      ADD     BX,[CURBUF]	; Correct it for new buffer
 27234 00004C4A 89DE                            MOV     SI,BX
 27235                                  	;add	si,1Ah
 27236 00004C4C 83C61A                          ADD     SI,dir_entry.dir_first	; Get corrected SI
 27237                                  RET1:
 27238 00004C4F F8                              CLC
 27239 00004C50 C3                              retn
 27240                                  
 27241                                  ;---------------------------------------------------------------------------
 27242                                  ;
 27243                                  ; Procedure Name : CHECK_VIRT_OPEN
 27244                                  ;
 27245                                  ; CHECK_VIRT_OPEN checks to see if we had performed a "virtual open" (by
 27246                                  ; examining the flag [VIRTUAL_OPEN] to see if it is 1). If we did, then
 27247                                  ; it calls Dev_Close_SFT to decrement the ref. count. It also resets the
 27248                                  ; flag [VIRTUAL_OPEN].
 27249                                  ; No registers affected (including flags).
 27250                                  ; On input, [THISSFT] points to current SFT.
 27251                                  ;
 27252                                  ;---------------------------------------------------------------------------
 27253                                  
 27254                                  CHECK_VIRT_OPEN:
 27255 00004C51 50                      	PUSH    AX
 27256 00004C52 9F                              lahf                    ; preserve flags
 27257 00004C53 803E[A20A]00                    CMP     byte [VIRTUAL_OPEN],0
 27258 00004C58 7410                            JZ	short ALL_CLOSED
 27259 00004C5A C606[A20A]00                    mov     byte [VIRTUAL_OPEN],0	; reset flag
 27260 00004C5F 06                      	push	es
 27261 00004C60 57                      	push	di
 27262 00004C61 C43E[9E05]                      LES     DI,[THISSFT]
 27263 00004C65 E8ADF9                          call	DEV_CLOSE_SFT
 27264 00004C68 5F                      	pop	di
 27265 00004C69 07                      	pop	es
 27266                                  
 27267                                  ALL_CLOSED:
 27268 00004C6A 9E                              sahf                    ; restore flags
 27269 00004C6B 58                              POP     AX
 27270 00004C6C C3                              retn
 27271                                  
 27272                                  ;============================================================================
 27273                                  ; ROM.ASM, MSDOS 6.0, 1991
 27274                                  ;============================================================================
 27275                                  ; 29/07/2018 - Retro DOS v3.0
 27276                                  ; 20/05/2019 - Retro DOS v4.0
 27277                                  
 27278                                  ;	TITLE	ROM - Miscellaneous routines
 27279                                  ;	NAME	ROM
 27280                                  
 27281                                  ;**	Misc Low level routines for doing simple FCB computations, Cache
 27282                                  ;       reads and writes, I/O optimization, and FAT allocation/deallocation
 27283                                  ;
 27284                                  ;	SKPCLP
 27285                                  ;	FNDCLUS
 27286                                  ;	BUFSEC
 27287                                  ;	BUFRD
 27288                                  ;	BUFWRT
 27289                                  ;	NEXTSEC
 27290                                  ;	OPTIMIZE
 27291                                  ;	FIGREC
 27292                                  ;	ALLOCATE
 27293                                  ;	RESTFATBYT
 27294                                  ;	RELEASE
 27295                                  ;	RELBLKS
 27296                                  ;	GETEOF
 27297                                  ;
 27298                                  ;	Modification history:
 27299                                  ;
 27300                                  ;		Created: ARR 30 March 1983
 27301                                  ;               M039: DB 10/25/90 - Disk read/write optimization.
 27302                                  
 27303                                  ;Break   <FNDCLUS -- Skip over allocation units>
 27304                                  ;--------------------------------------------------------------------------
 27305                                  ;
 27306                                  ; Procedure Name : FNDCLUS
 27307                                  ;
 27308                                  ; Inputs:
 27309                                  ;       CX = No. of clusters to skip
 27310                                  ;       ES:BP = Base of drive parameters
 27311                                  ;       [THISSFT] point to SFT
 27312                                  ; Outputs:
 27313                                  ;       BX = Last cluster skipped to
 27314                                  ;       CX = No. of clusters remaining (0 unless EOF)
 27315                                  ;       DX = Position of last cluster
 27316                                  ;       Carry set if error (currently user FAILed to I 24)
 27317                                  ; DI destroyed. No other registers affected.
 27318                                  ;--------------------------------------------------------------------------
 27319                                  
 27320                                  ; 20/05/2019 - Retro DOS v4.0
 27321                                  ; DOSCODE:8BF2h (MSDOS 6.21, MSDOS.SYS)
 27322                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27323                                  ; DOSCODE:8BB7h (MSDOS 5.0, MSDOS.SYS)
 27324                                  
 27325                                  FNDCLUS:
 27326 00004C6D 06                      	PUSH	ES
 27327 00004C6E C43E[9E05]                      LES     DI,[THISSFT]		; setup addressability to SFT
 27328                                  	;;mov	bx,[es:di+1Bh] ; MSDOS 3.3
 27329                                  	;mov	bx,[es:di+35h] ; MSDOS 6.0
 27330 00004C72 268B5D35                	MOV	BX,[ES:DI+SF_ENTRY.sf_lstclus]
 27331                                  	;mov	dx,[es:di+19h]
 27332 00004C76 268B5519                        MOV     DX,[ES:DI+SF_ENTRY.sf_cluspos]
 27333 00004C7A 09DB                    	OR	BX,BX
 27334 00004C7C 7424                    	JZ	short NOCLUS
 27335                                  
 27336 00004C7E 29D1                            SUB     CX,DX
 27337 00004C80 7308                            JNB	short FINDIT
 27338                                  
 27339 00004C82 01D1                            ADD     CX,DX
 27340 00004C84 31D2                            XOR     DX,DX
 27341                                  	;mov	bx,[es:di+0Bh]
 27342 00004C86 268B5D0B                        MOV     BX,[ES:DI+SF_ENTRY.sf_firclus]
 27343                                  FINDIT:
 27344 00004C8A 07                              POP	ES
 27345 00004C8B E313                    	JCXZ	RET9
 27346                                  
 27347                                  	;entry	SKPCLP
 27348                                  SKPCLP:
 27349 00004C8D E8CE08                  	call	UNPACK
 27350 00004C90 7214                            jc	short fndclus_retn	; retc
 27351                                  
 27352                                  	; 09/09/2018
 27353                                  
 27354                                  	; MSDOS 3.3
 27355                                  	;push	bx
 27356                                  	;mov	bx,di
 27357                                  	;call	IsEOF
 27358                                  	;pop	bx	
 27359                                  	;jae	short RET9
 27360                                  
 27361                                  	; 20/05/2019 - Retro DOS v4.0
 27362                                  
 27363                                  	; MSDOS 6.0
 27364 00004C92 87DF                    	xchg	bx,di
 27365 00004C94 E8B008                  	call	IsEOF
 27366 00004C97 87DF                    	xchg	bx,di
 27367 00004C99 7305                    	jae	short RET9
 27368                                  
 27369 00004C9B 87DF                            XCHG    BX,DI
 27370 00004C9D 42                              INC     DX
 27371                                  
 27372 00004C9E E2ED                    	LOOP	SKPCLP			; RMFS
 27373                                  RET9:	
 27374 00004CA0 F8                      	CLC
 27375 00004CA1 C3                              retn
 27376                                  NOCLUS:
 27377 00004CA2 07                              POP	ES
 27378 00004CA3 41                              INC	CX
 27379 00004CA4 4A                              DEC	DX
 27380 00004CA5 F8                              CLC
 27381                                  
 27382                                  fndclus_retn:
 27383 00004CA6 C3                              retn
 27384                                  
 27385                                  ;Break  <BUFSEC -- BUFFER A SECTOR AND SET UP A TRANSFER>
 27386                                  ;--------------------------------------------------------------------------
 27387                                  ;
 27388                                  ; Procedure Name : BUFSEC
 27389                                  ;
 27390                                  ; Inputs:
 27391                                  ;       AH = priority of buffer
 27392                                  ;       AL = 0 if buffer must be read, 1 if no pre-read needed
 27393                                  ;       ES:BP = Base of drive parameters
 27394                                  ;       [CLUSNUM] = Physical cluster number
 27395                                  ;       [SECCLUSPOS] = Sector position of transfer within cluster
 27396                                  ;       [BYTCNT1] = Size of transfer
 27397                                  ; Function:
 27398                                  ;       Insure specified sector is in buffer, flushing buffer before
 27399                                  ;       read if necessary.
 27400                                  ; Outputs:
 27401                                  ;       ES:DI = Pointer to buffer
 27402                                  ;       SI = Pointer to transfer address
 27403                                  ;       CX = Number of bytes
 27404                                  ;       [NEXTADD] updated
 27405                                  ;       [TRANS] set to indicate a transfer will occur
 27406                                  ;       Carry set if error (user FAILed to I 24)
 27407                                  ;--------------------------------------------------------------------------
 27408                                  
 27409                                  BUFSEC:
 27410 00004CA7 8B16[BC05]                      MOV     DX,[CLUSNUM]
 27411 00004CAB 8A1E[7305]                      MOV     BL,[SECCLUSPOS]
 27412                                  	;mov	byte [ALLOWED],38h
 27413 00004CAF C606[4B03]38                    MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
 27414 00004CB4 E85001                          CALL    FIGREC
 27415 00004CB7 E8B60C                  	call	GETBUFFR
 27416 00004CBA 72EA                            jc	short fndclus_retn
 27417                                  
 27418 00004CBC C606[7405]01                    MOV     BYTE [TRANS],1	; A transfer is taking place
 27419 00004CC1 8B36[B805]                      MOV     SI,[NEXTADD]
 27420 00004CC5 89F7                            MOV     DI,SI
 27421 00004CC7 8B0E[D205]                      MOV     CX,[BYTCNT1]
 27422 00004CCB 01CF                            ADD     DI,CX
 27423 00004CCD 893E[B805]                      MOV     [NEXTADD],DI
 27424 00004CD1 C43E[E205]                      LES     DI,[CURBUF]
 27425                                  	;or	byte [es:di+5],8
 27426 00004CD5 26804D0508                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDATA
 27427                                  	;;lea	di,[di+16] ; MSDOS 3.3 
 27428                                  	;lea	di,[di+20] ; MSDOS 6.0
 27429 00004CDA 8D7D14                          LEA     DI,[DI+BUFINSIZ]        ; Point to buffer
 27430 00004CDD 033E[CC05]                      ADD     DI,[BYTSECPOS]
 27431 00004CE1 F8                              CLC
 27432 00004CE2 C3                              retn
 27433                                  
 27434                                  ;Break   <BUFRD, BUFWRT -- PERFORM BUFFERED READ AND WRITE>
 27435                                  
 27436                                  ;---------------------------------------------------------------------------
 27437                                  ;
 27438                                  ; Procedure Name : BUFRD
 27439                                  ;
 27440                                  ; Do a partial sector read via one of the system buffers
 27441                                  ; ES:BP Points to DPB
 27442                                  ; Carry set if error (currently user FAILed to I 24)
 27443                                  ;
 27444                                  ; DS - set to DOSDATA
 27445                                  ;
 27446                                  ;----------------------------------------------------------------------------
 27447                                  
 27448                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27449                                  	; 20/05/2019 - Retro DOS v4.0
 27450                                  BUFRD:
 27451 00004CE3 06                              PUSH	ES
 27452 00004CE4 31C0                            xor	ax, ax			; pre-read sector
 27453 00004CE6 E8BEFF                          CALL    BUFSEC
 27454 00004CE9 7303                            JNC	short BUF_OK
 27455                                  
 27456                                  BUF_IO_FAIL:				; this label used by BUFWRT also
 27457 00004CEB 07                              POP	ES
 27458 00004CEC EB2B                            JMP     SHORT RBUFPLACED
 27459                                  
 27460                                  BUF_OK:
 27461 00004CEE 8CC3                            MOV     BX,ES
 27462 00004CF0 8E06[2E03]                      MOV     ES,[DMAADD+2]
 27463 00004CF4 8EDB                            MOV     DS,BX
 27464 00004CF6 87FE                    	XCHG    DI,SI
 27465 00004CF8 D1E9                            SHR     CX,1
 27466                                  ;M039
 27467                                  	; MSDOS 3.3
 27468                                  	;JNC	short EVENRD
 27469                                  	;MOVSB
 27470                                  ;EVENRD:
 27471                                  	;REP     MOVSW
 27472                                  
 27473                                  ;	CX = # of whole WORDs ; CF=1 if odd # of bytes.
 27474                                  ;       DS:SI-> Source within Buffer.
 27475                                  ;       ES:DI-> Destination within Transfer memory block.
 27476                                  
 27477                                  	; MSDOS 6.0
 27478 00004CFA F3A5                    	rep	movsw			;Copy Buffer to Transfer memory.
 27479                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 27480                                  	;rep	movsb                   ;Copy last byte.
 27481                                  	; 16/12/2022
 27482 00004CFC 7301                    	jnc	short EVENRD ; **** 20/05/2019
 27483 00004CFE A4                      	movsb ; ****
 27484                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27485                                  	;adc	cx,0
 27486                                  	;rep	movsb
 27487                                  ;M039
 27488                                  EVENRD: ; ****
 27489 00004CFF 07                              POP	ES
 27490                                  ;hkn; SS override
 27491 00004D00 36C53E[E205]                    LDS     DI,[SS:CURBUF]
 27492                                  	;;lea	bx,[di+16]
 27493                                  	;lea	bx,[di+20] ; MSDOS 6.0
 27494 00004D05 8D5D14                  	LEA     BX,[DI+BUFINSIZ]
 27495 00004D08 29DE                            SUB     SI,BX                   ; Position in buffer
 27496 00004D0A E8030C                          call	PLACEBUF
 27497                                  	;cmp	si,[es:bp+2]
 27498 00004D0D 263B7602                	CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Read Last byte?
 27499 00004D11 7205                            JB	short RBUFPLACEDC	; No, leave buf where it is
 27500                                  ;M039
 27501                                  	; MSDOS 3.3
 27502                                  	;call	PLACEHEAD               ; Make it prime candidate for chucking
 27503                                                                          ;  even though it is MRU.
 27504                                          ; MSDOS 6.0
 27505 00004D13 36893E[6D00]            	MOV	[ss:BufferQueue],DI	; Make it prime candidate for
 27506                                  ;M039					; chucking even though it is MRU.
 27507                                  
 27508                                  RBUFPLACEDC:
 27509 00004D18 F8                              CLC
 27510                                  RBUFPLACED:
 27511 00004D19 16                      	push	ss
 27512 00004D1A 1F                      	pop	ds
 27513 00004D1B C3                              retn
 27514                                  
 27515                                  ;----------------------------------------------------------------------------
 27516                                  ;
 27517                                  ; Procedure : BUFWRT
 27518                                  ;
 27519                                  ; Do a partial sector write via one of the system buffers
 27520                                  ; ES:BP Points to DPB
 27521                                  ; Carry set if error (currently user FAILed to I 24)
 27522                                  ;
 27523                                  ; DS - set to DOSDATA
 27524                                  ;
 27525                                  ;----------------------------------------------------------------------------
 27526                                  
 27527                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27528                                  	; 20/05/2019 - Retro DOS v4.0
 27529                                  BUFWRT:
 27530                                          ;MOV     AX,[SECPOS]
 27531                                          ; MSDOS 6.0
 27532                                  	;ADD	AX,1            	; Set for next sector
 27533                                          ;MOV	[SECPOS],AX 		;F.C. >32mb	;AN000;
 27534                                          ;ADC	word [SECPOS+2],0	;F.C. >32mb	;AN000;
 27535                                          ; 24/09/2023
 27536 00004D1C FF06[C405]              	inc	word [SECPOS]
 27537 00004D20 7504                    	jnz	short bufw_secpos
 27538 00004D22 FF06[C605]              	inc	word [SECPOS+2]
 27539                                  bufw_secpos:
 27540 00004D26 A1[C605]                	MOV	AX,[SECPOS+2]		;F.C. >32mb	;AN000;
 27541 00004D29 3B06[CA05]                      CMP	AX,[VALSEC+2]		;F.C. >32mb	;AN000;
 27542 00004D2D B001                            MOV	AL,1			;F.C. >32mb	;AN000;
 27543 00004D2F 770F                            JA	short NOREAD		;F.C. >32mb	;AN000;
 27544 00004D31 720B                            JB	short _doread		;F.C. >32mb	;AN000;
 27545 00004D33 A1[C405]                        MOV	AX,[SECPOS]		;F.C. >32mb	;AN000;
 27546                                  
 27547                                  	; MSDOS 3.3
 27548                                  	;INC	AX
 27549                                  	;MOV	[SECPOS],AX ; 09/09/2018
 27550                                  
 27551                                  	; 20/05/2019
 27552                                  	; MSDOS 3.3 & MSDOS 6.0
 27553 00004D36 3B06[C805]                      CMP     AX,[VALSEC]		; Has sector been written before?
 27554 00004D3A B001                            MOV     AL,1
 27555 00004D3C 7702                            JA	short NOREAD		; Skip preread if SECPOS>VALSEC
 27556                                  _doread:
 27557 00004D3E 30C0                            XOR     AL,AL
 27558                                  NOREAD:
 27559 00004D40 06                              PUSH	ES
 27560 00004D41 E863FF                          CALL    BUFSEC
 27561 00004D44 72A5                    	JC	short BUF_IO_FAIL
 27562 00004D46 8E1E[2E03]                      MOV     DS,[DMAADD+2]
 27563 00004D4A D1E9                            SHR     CX,1
 27564                                  ;M039
 27565                                  	; MSDOS 3.3
 27566                                  	;JNC	short EVENWRT ; 09/09/2018
 27567                                  	;MOVSB
 27568                                  ;EVENWRT:
 27569                                  	;REP	MOVSW
 27570                                  
 27571                                  ;	CX = # of whole WORDs; CF=1 if odd # of bytes.
 27572                                  ;       DS:SI-> Source within Transfer memory block.
 27573                                  ;       ES:DI-> Destination within Buffer.
 27574                                  
 27575                                  	; MSDOS 6.0
 27576 00004D4C F3A5                    	rep	movsw			;Copy Transfer memory to Buffer.
 27577                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 27578                                  	;rep	movsb                   ;Copy last byte.
 27579                                  	; 16/12/2022
 27580 00004D4E 7301                    	jnc	short EVENWRT ; **** 20/05/2019
 27581 00004D50 A4                      	movsb ; ****
 27582                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27583                                  	;adc	cx,0
 27584                                  	;rep	movsb
 27585                                  ;M039
 27586                                  EVENWRT: ; ****
 27587 00004D51 07                              POP	ES
 27588                                  
 27589                                  ;hkn; SS override
 27590 00004D52 36C51E[E205]                    LDS     BX,[SS:CURBUF]
 27591                                  
 27592                                  	; MSDOS 6.0
 27593 00004D57 F6470540                        TEST	byte [BX+BUFFINFO.buf_flags],buf_dirty
 27594                                  					;LB. if already dirty		  ;AN000;
 27595 00004D5B 7507                            JNZ	short yesdirty10	;LB.  don't increment dirty count ;AN000;
 27596 00004D5D E8120E                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 27597                                  	
 27598                                  	;or	byte [bx+5],40h
 27599 00004D60 804F0540                        OR	byte [BX+BUFFINFO.buf_flags],buf_dirty
 27600                                  yesdirty10:
 27601                                  	;;lea	si,[bx+16]
 27602                                  	;lea	si,[bx+20] ; MSDOS 6.0
 27603 00004D64 8D7714                          LEA     SI,[BX+BUFINSIZ]
 27604 00004D67 29F7                            SUB     DI,SI                   ; Position in buffer
 27605                                  ;M039
 27606                                  	; MSDOS 3.3
 27607                                  	;MOV	SI,DI
 27608                                  	;MOV	DI,BX
 27609                                  	;call	PLACEBUF
 27610                                  	;;cmp	si,[es:bp+2]
 27611                                  	;CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 27612                                  	;JB	short WBUFPLACED	; No, leave buf where it is
 27613                                  	;call	PLACEHEAD               ; Make it prime candidate for chucking
 27614                                                                          ;  even though it is MRU.
 27615                                  	; MSDOS 6.0
 27616                                  	;cmp	di,[es:bp+2]
 27617 00004D69 263B7E02                	CMP	di,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 27618 00004D6D 7205                            JB	short WBUFPLACED	; No, leave buf where it is
 27619 00004D6F 36891E[6D00]                    MOV	[ss:BufferQueue],BX	; Make it prime candidate for
 27620                                  					; chucking even though it is MRU.
 27621                                  ;M039
 27622                                  
 27623                                  WBUFPLACED:
 27624 00004D74 F8                              CLC
 27625 00004D75 16                      	push	ss
 27626 00004D76 1F                      	pop	ds
 27627 00004D77 C3                              retn
 27628                                  
 27629                                  ;Break   <NEXTSEC -- Compute next sector to read or write>
 27630                                  ;---------------------------------------------------------------------------
 27631                                  ;
 27632                                  ; Procedure Name : NEXTSEC
 27633                                  ;
 27634                                  ; Compute the next sector to read or write
 27635                                  ; ES:BP Points to DPB
 27636                                  ;
 27637                                  ;---------------------------------------------------------------------------
 27638                                  
 27639                                  NEXTSEC:
 27640 00004D78 F606[7405]FF            	test	byte [TRANS],0FFh ; -1 
 27641 00004D7D 7426                            JZ	short CLRET
 27642                                  
 27643 00004D7F A0[7305]                        MOV     AL,[SECCLUSPOS]
 27644 00004D82 FEC0                            INC     AL
 27645                                  	;cmp	al,[es:bp+4]
 27646 00004D84 263A4604                        CMP     AL,[ES:BP+DPB.CLUSTER_MASK]
 27647 00004D88 7618                            JBE	short SAVPOS
 27648                                  
 27649 00004D8A 8B1E[BC05]                      MOV     BX,[CLUSNUM]
 27650 00004D8E E8B607                          call	IsEOF
 27651 00004D91 7314                            JAE	short NONEXT
 27652                                  
 27653 00004D93 E8C807                          call	UNPACK
 27654 00004D96 720F                            JC	short NONEXT
 27655                                  clusgot:
 27656 00004D98 893E[BC05]                      MOV     [CLUSNUM],DI
 27657 00004D9C FF06[BA05]                      INC     word [LASTPOS]
 27658 00004DA0 B000                            MOV     AL,0
 27659                                  SAVPOS:
 27660 00004DA2 A2[7305]                        MOV     [SECCLUSPOS],AL
 27661                                  CLRET:
 27662 00004DA5 F8                              CLC
 27663 00004DA6 C3                              retn
 27664                                  NONEXT:
 27665 00004DA7 F9                              STC
 27666 00004DA8 C3                              retn
 27667                                  
 27668                                  ;Break	<OPTIMIZE -- DO A USER DISK REQUEST WELL>
 27669                                  ;----------------------------------------------------------------------------
 27670                                  ;
 27671                                  ; Procedure Name : OPTIMIZE
 27672                                  ;
 27673                                  ; Inputs:
 27674                                  ;       BX = Physical cluster
 27675                                  ;       CX = No. of records
 27676                                  ;       DL = sector within cluster
 27677                                  ;       ES:BP = Base of drive parameters
 27678                                  ;       [NEXTADD] = transfer address
 27679                                  ; Outputs:
 27680                                  ;       AX = No. of records remaining
 27681                                  ;       BX = Transfer address
 27682                                  ;       CX = No. or records to be transferred
 27683                                  ;       DX = Physical sector address            (LOW)
 27684                                  ;       [HIGH_SECTOR] = Physical sector address (HIGH)
 27685                                  ;       DI = Next cluster
 27686                                  ;       [CLUSNUM] = Last cluster accessed
 27687                                  ;       [NEXTADD] updated
 27688                                  ;       Carry set if error (currently user FAILed to I 24)
 27689                                  ; ES:BP unchanged. Note that segment of transfer not set.
 27690                                  ;
 27691                                  ;---------------------------------------------------------------------------
 27692                                  
 27693                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27694                                  OPTIMIZE:
 27695 00004DA9 52                      	PUSH    DX
 27696 00004DAA 53                              PUSH    BX
 27697                                  	;mov	al,[es:bp+4]
 27698 00004DAB 268A4604                        MOV     AL,[ES:BP+DPB.CLUSTER_MASK]
 27699 00004DAF FEC0                            INC     AL              ; Number of sectors per cluster
 27700 00004DB1 88C4                            MOV     AH,AL
 27701 00004DB3 28D0                            SUB     AL,DL           ; AL = Number of sectors left in first cluster
 27702 00004DB5 89CA                            MOV     DX,CX
 27703                                  	;MOV	CX,0
 27704                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27705                                  	; 16/12/2022
 27706 00004DB7 31C9                    	xor	cx,cx	; sub cx,cx
 27707                                  OPTCLUS:
 27708                                  ; AL has number of sectors available in current cluster
 27709                                  ; AH has number of sectors available in next cluster
 27710                                  ; BX has current physical cluster
 27711                                  ; CX has number of sequential sectors found so far
 27712                                  ; DX has number of sectors left to transfer
 27713                                  ; ES:BP Points to DPB
 27714                                  ; ES:SI has FAT pointer
 27715                                  
 27716                                  do_norm3:
 27717 00004DB9 E8A207                          call	UNPACK
 27718 00004DBC 7236                            JC	short OP_ERR
 27719                                  clusgot2:
 27720 00004DBE 00C1                    	ADD	CL,AL
 27721 00004DC0 80D500                          ADC     CH,0
 27722 00004DC3 39D1                            CMP     CX,DX
 27723 00004DC5 7332                            JAE	short BLKDON
 27724 00004DC7 88E0                            MOV     AL,AH
 27725 00004DC9 43                              INC     BX
 27726 00004DCA 39DF                            CMP     DI,BX
 27727 00004DCC 74EB                            JZ	short OPTCLUS
 27728 00004DCE 4B                              DEC     BX
 27729                                  FINCLUS:
 27730 00004DCF 891E[BC05]                      MOV     [CLUSNUM],BX    ; Last cluster accessed
 27731 00004DD3 29CA                            SUB     DX,CX           ; Number of sectors still needed
 27732 00004DD5 52                              PUSH    DX
 27733 00004DD6 89C8                            MOV     AX,CX
 27734                                  	;mul	word[ES:BP+2]
 27735 00004DD8 26F76602                        MUL	word [ES:BP+DPB.SECTOR_SIZE] 
 27736                                  				; Number of sectors times sector size
 27737 00004DDC 8B36[B805]                      MOV     SI,[NEXTADD]
 27738 00004DE0 01F0                            ADD     AX,SI           ; Adjust by size of transfer
 27739 00004DE2 A3[B805]                        MOV     [NEXTADD],AX
 27740 00004DE5 58                              POP     AX              ; Number of sectors still needed
 27741 00004DE6 5A                              POP     DX              ; Starting cluster
 27742 00004DE7 29D3                            SUB     BX,DX           ; Number of new clusters accessed
 27743 00004DE9 011E[BA05]                      ADD     [LASTPOS],BX
 27744 00004DED 5B                              POP     BX              ; BL = sector position within cluster
 27745 00004DEE E81600                  	call	FIGREC
 27746 00004DF1 89F3                            MOV     BX,SI
 27747                                  	; 24/09/2023
 27748                                  	; cf=0 (at the return of FIGREC)
 27749                                  	;CLC
 27750 00004DF3 C3                              retn
 27751                                  OP_ERR:
 27752 00004DF4 83C404                          ADD     SP,4
 27753 00004DF7 F9                      	STC
 27754 00004DF8 C3                              retn
 27755                                  BLKDON:
 27756 00004DF9 29D1                            SUB     CX,DX           ; Number of sectors in cluster we don't want
 27757 00004DFB 28CC                            SUB     AH,CL           ; Number of sectors in cluster we accepted
 27758 00004DFD FECC                            DEC     AH              ; Adjust to mean position within cluster
 27759 00004DFF 8826[7305]                      MOV     [SECCLUSPOS],AH
 27760 00004E03 89D1                            MOV     CX,DX           ; Anyway, make the total equal to the request
 27761 00004E05 EBC8                            JMP     SHORT FINCLUS
 27762                                  
 27763                                  ;Break	<FIGREC -- Figure sector in allocation unit>
 27764                                  ;---------------------------------------------------------------------------
 27765                                  ;
 27766                                  ; Procedure Name : FIGREC
 27767                                  ;
 27768                                  ; Inputs:
 27769                                  ;       DX = Physical cluster number
 27770                                  ;       BL = Sector position within cluster
 27771                                  ;       ES:BP = Base of drive parameters
 27772                                  ; Outputs:
 27773                                  ;       DX = physical sector number           (LOW)
 27774                                  ;       [HIGH_SECTOR] Physical sector address (HIGH)
 27775                                  ; No other registers affected.
 27776                                  ;
 27777                                  ;---------------------------------------------------------------------------
 27778                                  
 27779                                  	; 10/06/2019
 27780                                  	; 20/05/2019 - Retro DOS v4.0
 27781                                  	; DOSCODE:8D96h (MSDOS 6.21, MSDOS.SYS)
 27782                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27783                                  	; DOSCODE:8D5Bh (MSDOS 5.0, MSDOS.SYS)	
 27784                                  FIGREC:
 27785 00004E07 51                              PUSH    CX
 27786                                  	;mov	cl,[es:bp+5]
 27787 00004E08 268A4E05                        MOV     CL,[ES:BP+DPB.CLUSTER_SHIFT]
 27788 00004E0C 4A                              DEC     DX
 27789 00004E0D 4A                              DEC     DX
 27790                                  
 27791                                  	; MSDOS 3.3
 27792                                  	;SHL	DX,CL
 27793                                  
 27794                                  ;hkn; SS override HIGH_SECTOR
 27795                                  	; MSDOS 6.0
 27796 00004E0E 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0		;F.C. >32mb
 27797                                  	; 24/09/2023
 27798 00004E15 30ED                    	xor	ch,ch				;F.C. >32mb
 27799 00004E17 08C9                    	OR	CL,CL				;F.C. >32mb
 27800 00004E19 740C                    	JZ	short noshift			;F.C. >32mb
 27801 00004E1B 30ED                    	XOR	CH,CH				;F.C. >32mb
 27802                                  rotleft:					;F.C. >32mb
 27803 00004E1D F8                      	CLC					;F.C. >32mb
 27804 00004E1E D1D2                    	RCL	DX,1				;F.C. >32mb
 27805                                  	; 10/06/2019
 27806 00004E20 36D116[0706]            	RCL	word [ss:HIGH_SECTOR],1		;F.C. >32mb
 27807 00004E25 E2F6                    	LOOP	rotleft				;F.C. >32mb
 27808                                  noshift:
 27809                                  	; MSDOS 3.3 & MSDOS 6.0
 27810 00004E27 08DA                            OR      DL,BL
 27811                                  	;add	dx,[es:bp+0Bh]
 27812 00004E29 2603560B                        ADD     DX,[ES:BP+DPB.FIRST_SECTOR]
 27813                                  	; MSDOS 6.0
 27814                                  	; 10/06/2019
 27815                                  	;ADC	word [ss:HIGH_SECTOR],0		;F.C. >32mb
 27816                                  	; 24/09/2023
 27817                                  	; cx=0
 27818 00004E2D 36110E[0706]            	ADC	word [ss:HIGH_SECTOR],cx ; 0
 27819                                  
 27820                                  	; MSDOS 3.3 & MSDOS 6.0
 27821 00004E32 59                      	POP     CX
 27822                                  figrec_retn:
 27823 00004E33 C3                              retn
 27824                                  
 27825                                  ; 20/05/2019 - Retro DOS v4.0
 27826                                  ; DOSCODE:8DC2h (MSDOS 6.21, MSDOS.SYS)
 27827                                  
 27828                                  ; 30/07/2018 - Retro DOS v3.0
 27829                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 
 27830                                  
 27831                                  ;Break   <ALLOCATE -- Assign disk space>
 27832                                  ;---------------------------------------------------------------------------
 27833                                  ;
 27834                                  ; Procedure Name : ALLOCATE - Allocate Disk Space
 27835                                  ;
 27836                                  ;   ALLOCATE is called to allocate disk clusters. The new clusters are
 27837                                  ;   FAT-chained onto the end of the existing file.
 27838                                  ;
 27839                                  ;   The DPB contains the cluster # of the last free cluster allocated
 27840                                  ;   (dpb_next_free). We start at this cluster and scan towards higher
 27841                                  ;   numbered clusters, looking for the necessary free blocks.
 27842                                  ;
 27843                                  ;   Once again, fancy terminology gets in the way of correct coding. When
 27844                                  ;   using next_free, start scanning AT THAT POINT and not the one following it.
 27845                                  ;   This fixes the boundary condition bug when only free = next_free = 2.
 27846                                  ;
 27847                                  ;       If we get to the end of the disk without satisfaction:
 27848                                  ;
 27849                                  ;           if (dpb_next_free == 2) then we've scanned the whole disk.
 27850                                  ;               return (insufficient_disk_space)
 27851                                  ;           ELSE
 27852                                  ;               dpb_next_free = 2; start scan over from the beginning.
 27853                                  ;
 27854                                  ;   Note that there is no multitasking interlock. There is no race when
 27855                                  ;   examining the entrys in an in-core FAT block since there will be no
 27856                                  ;   context switch. When UNPACK context switches while waiting for a FAT read
 27857                                  ;   we are done with any in-core FAT blocks, so again there is no race. The
 27858                                  ;   only special concern is that V2 and V3 MSDOS left the last allocated
 27859                                  ;   cluster as "00"; marking it EOF only when the entire alloc request was
 27860                                  ;   satisfied. We can't allow another activation to think this cluster is
 27861                                  ;   free, so we give it a special temporary mark to show that it is, indeed,
 27862                                  ;   allocated.
 27863                                  ;
 27864                                  ;   Note that when we run out of space this algorithem will scan from
 27865                                  ;   dpb_next_free to the end, then scan from cluster 2 through the end,
 27866                                  ;   redundantly scanning the later part of the disk. This only happens when
 27867                                  ;   we run out of space, so sue me.
 27868                                  ;
 27869                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 27870                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 27871                                  ;                                                                          ;
 27872                                  ;   The use of FATBYT and RESTFATBYT is somewhat mysterious. Here is the
 27873                                  ;   explanation:
 27874                                  ;
 27875                                  ;   In the NUL file case (sf_firclus currently 0) ALLOCATE is called with
 27876                                  ;   entry BX = 0. What needs to be done in this case is to stuff the cluster
 27877                                  ;   number of the first cluster allocated in sf_firclus when the ALLOCATE is
 27878                                  ;   complete. THIS VALUE IS SAVED TEMPORARILY IN CLUSTER 0, HENCE THE CURRENT
 27879                                  ;   VALUE IN CLUSTER 0 MUST BE SAVED AND RESTORED. This is a side effect of
 27880                                  ;   the fact that PACK and UNPACK don't treat requests for clusters 0 and 1 as
 27881                                  ;   errors. This "stuff" is done by the call to PACK which is right before
 27882                                  ;   the
 27883                                  ;           LOOP   findfre         ; alloc more if needed
 27884                                  ;   instruction when the first cluster is allocated to the nul file. The
 27885                                  ;   value is recalled from cluster 0 and stored at sf_firclus at ads4:
 27886                                  ;
 27887                                  ;   This method is obviously useless (because it is non-reentrant) for
 27888                                  ;   multitasking, and will have to be changed. Storing the required value on
 27889                                  ;   the stack is recommended. Setting sf_firclus at the PACK of cluster 0
 27890                                  ;   (instead of actually doing the PACK) is BAD because it doesn't handle
 27891                                  ;   problems with INT 24 well.
 27892                                  ;
 27893                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 27894                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 27895                                  ;                                                                          ;
 27896                                  ;       ENTRY   BX = Last cluster of file (0 if null file)
 27897                                  ;               CX = No. of clusters to allocate
 27898                                  ;               ES:BP = Base of drive parameters
 27899                                  ;               [THISSFT] = Points to SFT
 27900                                  ;
 27901                                  ;       EXIT    'C' set if insufficient space
 27902                                  ;                 [FAILERR] can be tested to see the reason for failure
 27903                                  ;                 CX = max. no. of clusters that could be added to file
 27904                                  ;               'C' clear if space allocated
 27905                                  ;                 BX = First cluster allocated
 27906                                  ;                 FAT is fully updated
 27907                                  ;                 sf_FIRCLUS field of SFT set if file was null
 27908                                  ;
 27909                                  ;       USES    ALL but SI, BP
 27910                                  
 27911                                  ;callmagic  proc near
 27912                                  ;       push    ds                             ;push segment of routine 
 27913                                  ;       push    Offset MagicPatch              ;push offset for routine
 27914                                  ;       retf                                   ;simulate jmp far
 27915                                  ;                                              ;far return address is on
 27916                                  ;                                              ;stack, so far return from
 27917                                  ;                                              ;call will return this routine
 27918                                  ;callmagic  endp
 27919                                  
 27920                                  
 27921                                  ; 25/09/2023
 27922                                  %if 0
 27923                                  callmagic:
 27924                                  	push	ds
 27925                                  	push	MagicPatch
 27926                                  	retf	
 27927                                  %endif
 27928                                  
 27929                                  ALLOCATE:
 27930                                  	; 10/09/2018
 27931                                  ;BEGIN MAGICDRV MODIFICATIONS
 27932                                  ;
 27933                                  ;7/5/92 scottq
 27934                                  ;
 27935                                  ;This is the disk compression patch location which allows
 27936                                  ;the disk compression software to fail allocations if the
 27937                                  ;FAT would allows allocation, but the free space for compressed
 27938                                  ;data would not.
 27939                                  ;        
 27940                                  ;;;	call    far ptr MAGICPATCH
 27941                                  ;;; We cannot do a far call since we cannot have fix-ups[romdos,hidos],
 27942                                  ;;; but we do know the segment and offset of the routine
 27943                                  ;;; so simulate a far call to dosdata:magicpatch
 27944                                  ;;; note dosassume above, so DS -> dosdata
 27945                                  
 27946                                  	; MSDOS 6.0
 27947                                          ;clc				;clear carry so we fall through
 27948                                  	;				;if no patch is present
 27949                                  	;push	cs			;push segment for far return
 27950                                          ;call	callmagic		;this is a near call
 27951                                          ;jnc	short Regular_Allocate_Path
 27952                                  	;jmp	Disk_Full_Return
 27953                                  
 27954                                  ; 25/09/2023
 27955                                  %if 0
 27956                                  	clc
 27957                                  	push	cs
 27958                                  	call	callmagic
 27959                                  	jnc	short Regular_Allocate_Path
 27960                                  	jmp	Disk_Full_Return
 27961                                  Regular_Allocate_Path:
 27962                                  %endif
 27963                                  
 27964                                  	; 20/05/2019 - Retro DOS v4.0
 27965                                  ;END MAGICDRV MODIFICATIONS
 27966                                  
 27967                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27968                                  	; DOSCODE:8D87h (MSDOS 5.0, MSDOS.SYS)
 27969                                  
 27970 00004E34 53                              PUSH    BX                      ; save (bx)
 27971 00004E35 31DB                            XOR     BX,BX
 27972 00004E37 E82407                  	call	UNPACK
 27973 00004E3A 893E[9605]                      MOV     [FATBYT],DI             ; save correct cluster 0 value
 27974 00004E3E 5B                              POP     BX
 27975 00004E3F 72F2                            jc	short figrec_retn	; abort if error   [INTERR?]
 27976                                  
 27977 00004E41 51                              PUSH    CX
 27978 00004E42 53                              PUSH    BX
 27979                                  
 27980 00004E43 89DA                            MOV     DX,BX
 27981                                  	;;mov	bx,[es:bp+1Ch]  ; MSDOS 3.3
 27982                                  	;mov	bx,[es:bp+1Dh]	; MSDOS 6.0
 27983 00004E45 268B5E1D                        mov     bx,[ES:BP+DPB.NEXT_FREE]
 27984 00004E49 83FB02                          cmp     bx,2
 27985 00004E4C 7709                            ja	short FINDFRE
 27986                                  
 27987                                  ;   couldn't find enough free space beyond dpb_next_free, or dpb_next_free is
 27988                                  ;   <2 or >dpb_max_clus. Reset it and restart the scan
 27989                                  
 27990                                  ads1:
 27991                                  	;;mov	word [es:bp+1Ch],2 ; MSDOS 3.3
 27992                                  	;mov	word [es:bp+1Dh],2 ; MSDOS 6.0
 27993 00004E4E 26C7461D0200                    mov     word [ES:BP+DPB.NEXT_FREE],2
 27994 00004E54 BB0100                          mov     bx,1                    ; Counter next instruction so first
 27995                                                                          ;       cluster examined is 2
 27996                                  
 27997                                  ;   Scanning both forwards and backwards for a free cluster
 27998                                  ;
 27999                                  ;       (BX) = forwards scan pointer
 28000                                  ;       (CX) = clusters remaining to be allocated
 28001                                  ;       (DX) = current last cluster in file
 28002                                  ;       (TOS) = last cluster of file
 28003                                  
 28004                                  FINDFRE:
 28005 00004E57 43                              INC     BX
 28006                                  	;cmp	bx,[es:bp+0Dh]
 28007 00004E58 263B5E0D                        CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 28008 00004E5C 7757                    	ja	short ads7	; at end of disk
 28009 00004E5E E8FD06                          call	UNPACK          ; check out this cluster
 28010 00004E61 722F                            jc	short ads4	; FAT error             [INTERR?]
 28011 00004E63 75F2                            jnz	short FINDFRE	; not free, keep on truckin
 28012                                  
 28013                                  ;   Have found a free cluster. Chain it to the file
 28014                                  ;
 28015                                  ;       (BX) = found free cluster #
 28016                                  ;       (DX) = current last cluster in file
 28017                                  
 28018                                  	;;mov	[es:bp+1Ch],bx
 28019                                  	;mov	[es:bp+1Dh],bx ; MSDOS 6.0
 28020 00004E65 26895E1D                        mov	[ES:BP+DPB.NEXT_FREE],bx ; next time start search here
 28021 00004E69 92                              xchg    ax,dx           ; save (dx) in ax
 28022 00004E6A BA0100                          mov     dx,1            ; mark this free guy as "1"
 28023 00004E6D E84207                  	call	PACK            ; set special "temporary" mark
 28024 00004E70 7220                            jc	short ads4	; FAT error             [INTERR?]
 28025                                  	;;cmp	word [es:bp+1Eh],-1
 28026                                          ;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
 28027 00004E72 26837E1FFF              	CMP	word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 28028 00004E77 7404                            JZ	short NO_ALLOC	; No
 28029                                  	;;dec	word [es:bp+1Eh]
 28030                                          ;dec	word [es:bp+1Fh] ; MSDOS 6.0
 28031 00004E79 26FF4E1F                        DEC     word [ES:BP+DPB.FREE_CNT] ; Reduce free count by 1
 28032                                  NO_ALLOC:
 28033 00004E7D 92                              xchg    ax,dx           ; (dx) = current last cluster in file
 28034 00004E7E 87DA                            XCHG    BX,DX
 28035 00004E80 89D0                            MOV     AX,DX
 28036 00004E82 E82D07                  	call	PACK            ; link free cluster onto file
 28037                                                                  ;  CAVEAT.. On Nul file, first pass stuffs
 28038                                                                  ;    cluster 0 with FIRCLUS value.
 28039 00004E85 720B                            jc	short ads4	; FAT error [INTERR?]
 28040 00004E87 93                              xchg    BX,AX           ; (BX) = last one we looked at
 28041 00004E88 89DA                            mov     dx,bx           ; (dx) = current end of file
 28042 00004E8A E2CB                            LOOP    FINDFRE         ; alloc more if needed
 28043                                  
 28044                                  ;   We've successfully extended the file. Clean up and exit
 28045                                  ;
 28046                                  ;       (BX) = last cluster in file
 28047                                  
 28048 00004E8C BAFFFF                          MOV     DX,0FFFFH
 28049 00004E8F E82007                  	call	PACK            ; mark last cluster EOF
 28050                                  
 28051                                  ;   Note that FAT errors jump here to clean the stack and exit. This saves us
 28052                                  ;   2 whole bytes. Hope its worth it...
 28053                                  ;
 28054                                  ;       'C' set if error
 28055                                  ;       calling (BX) and (CX) pushed on stack
 28056                                  
 28057                                  ads4:   
 28058 00004E92 5B                      	POP     BX
 28059 00004E93 59                              POP     CX              ; Don't need this stuff since we're successful
 28060 00004E94 729D                            jc	short figrec_retn
 28061 00004E96 E8C506                          call	UNPACK          ; Get first cluster allocated for return
 28062                                                                  ; CAVEAT... In nul file case, UNPACKs cluster 0.
 28063 00004E99 7298                            jc	short figrec_retn
 28064 00004E9B E83200                  	call	RESTFATBYT      ; Restore correct cluster 0 value
 28065 00004E9E 7293                            jc	short figrec_retn
 28066 00004EA0 87DF                            XCHG    BX,DI           ; (DI) = last cluster in file upon our entry
 28067 00004EA2 09FF                            OR      DI,DI           ; clear 'C'
 28068 00004EA4 758D                    	jnz	short figrec_retn ; we were extending an existing file
 28069                                  
 28070                                  ;   We were doing the first allocation for a new file. Update the SFT cluster
 28071                                  ;   info
 28072                                  dofastk:
 28073                                  	; 20/05/2019
 28074                                  	; MSDOS 6.0
 28075                                  	;push	dx ; * MSDOS 6.0
 28076                                  	;;mov	dl,[es:bp+0]
 28077                                  	;;MOV	DL,[ES:BP+DPB.DRIVE]	; get drive #
 28078                                  	;mov	dl,[es:bp]
 28079                                  
 28080                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28081                                  	; DOSCODE:8DF9h (MSDOS 5.0, MSDOS.SYS)
 28082                                  	
 28083                                  	; 16/12/2022
 28084                                  	;push	dx ; *
 28085                                  	;mov	dl,[ES:BP+DPB.DRIVE] 
 28086                                  	; 15/12/2022
 28087                                  	;mov	dl,[es:bp]
 28088                                  	
 28089                                  	; MSDOS 3.3 & MSDOS 6.0
 28090 00004EA6 06                      	PUSH	ES
 28091 00004EA7 C43E[9E05]              	LES     DI,[THISSFT]
 28092                                  	;mov	[es:di+0Bh],bx
 28093 00004EAB 26895D0B                	MOV     [ES:DI+SF_ENTRY.sf_firclus],BX
 28094                                  	;;mov	[es:di+1Bh],bx ; MSDOS 3.3
 28095                                  	;mov	[es:di+35h],bx ; MSDOS 6.0
 28096 00004EAF 26895D35                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],BX
 28097 00004EB3 07                      	POP	ES
 28098                                  	;retn
 28099                                  
 28100                                  	;pop	dx ; * MSDOS 6.0
 28101                                  
 28102                                  	; 16/12/2022
 28103                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28104                                  	;pop	dx ; *
 28105                                  
 28106 00004EB4 C3                      	retn	
 28107                                  
 28108                                  ;** we're at the end of the disk, and not satisfied. See if we've scanned ALL
 28109                                  ;   of the disk...
 28110                                  
 28111                                  ads7:   
 28112 00004EB5 26837E1D02              	cmp	word [ES:BP+DPB.NEXT_FREE],2
 28113 00004EBA 7592                    	jnz	short ads1	; start scan from front of disk
 28114                                  
 28115                                  ;   Sorry, we've gone over the whole disk, with insufficient luck. Lets give
 28116                                  ;   the space back to the free list and tell the caller how much he could have
 28117                                  ;   had.  We have to make sure we remove the "special mark" we put on the last
 28118                                  ;   cluster we were able to allocate, so it doesn't become orphaned.
 28119                                  ;
 28120                                  ;       (CX) = clusters remaining to be allocated
 28121                                  ;       (TOS) = last cluster of file (before call to ALLOCATE)
 28122                                  ;       (TOS+1) = # of clusters wanted to allocate
 28123                                  
 28124 00004EBC 5B                              POP     BX              ; (BX) = last cluster of file
 28125 00004EBD BAFFFF                          MOV     DX,0FFFFH
 28126 00004EC0 E81F00                  	call	RELBLKS         ; give back any clusters just alloced
 28127 00004EC3 58                              POP     AX              ; No. of clusters requested
 28128                                                                  ; Don't "retc". We are setting Carry anyway,
 28129                                                                  ;   Alloc failed, so proceed with return CX
 28130                                                                  ;   setup.
 28131 00004EC4 29C8                            SUB     AX,CX           ; AX=No. of clusters allocated
 28132 00004EC6 E80700                  	call	RESTFATBYT      ; Don't "retc". We are setting Carry anyway,
 28133                                                                  ;   Alloc failed.
 28134                                  Disk_Full_Return:               ;label added for magic patch 8-6-92 scottq
 28135                                          ; MSDOS 6.0
 28136 00004EC9 C606[0B06]01            	MOV	byte [DISK_FULL],1 ;MS. indicating disk full
 28137 00004ECE F9                              STC
 28138 00004ECF C3                              retn
 28139                                  
 28140                                  ;-----------------------------------------------------------------------
 28141                                  ;
 28142                                  ; Procedure Name : RESTFATBYT
 28143                                  ;
 28144                                  ; SEE ALLOCATE CAVEAT
 28145                                  ;       Carry set if error (currently user FAILed to I 24)
 28146                                  ;-----------------------------------------------------------------------
 28147                                  
 28148                                  RESTFATBYT:
 28149 00004ED0 53                              PUSH    BX
 28150 00004ED1 52                              PUSH    DX
 28151 00004ED2 57                              PUSH    DI
 28152 00004ED3 31DB                            XOR     BX,BX
 28153 00004ED5 8B16[9605]                      MOV     DX,[FATBYT]
 28154 00004ED9 E8D606                  	call	PACK
 28155 00004EDC 5F                              POP     DI
 28156 00004EDD 5A                              POP     DX
 28157 00004EDE 5B                              POP     BX
 28158                                  ; 16/12/2022
 28159                                  ; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28160                                  ;RELEASE_flush:
 28161 00004EDF C3                      	retn
 28162                                  
 28163                                  ;Break	<RELEASE -- DEASSIGN DISK SPACE>
 28164                                  ;---------------------------------------------------------------------------
 28165                                  ;
 28166                                  ; Procedure Name : RELEASE
 28167                                  ;
 28168                                  ; Inputs:
 28169                                  ;       BX = Cluster in file
 28170                                  ;       ES:BP = Base of drive parameters
 28171                                  ; Function:
 28172                                  ;       Frees cluster chain starting with [BX]
 28173                                  ;       Carry set if error (currently user FAILed to I 24)
 28174                                  ; AX,BX,DX,DI all destroyed. Other registers unchanged.
 28175                                  ;
 28176                                  ;-----------------------------------------------------------------------------
 28177                                  
 28178                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28179                                  	; 20/05/2019 - Retro DOS v4.0
 28180                                  RELEASE:
 28181 00004EE0 31D2                            XOR     DX,DX
 28182                                  
 28183                                  	;entry	RELBLKS
 28184                                  RELBLKS:
 28185                                  
 28186                                  ;   Enter here with DX=0FFFFH to put an end-of-file mark in the first cluster
 28187                                  ;   and free the rest in the chain.
 28188                                  
 28189 00004EE2 E87906                  	call	UNPACK
 28190 00004EE5 7224                    	jc	short RELEASE_flush
 28191 00004EE7 7422                    	jz	short RELEASE_flush
 28192 00004EE9 89F8                            MOV     AX,DI
 28193 00004EEB 52                              PUSH    DX
 28194 00004EEC E8C306                  	call	PACK
 28195 00004EEF 5A                              POP     DX
 28196 00004EF0 7219                    	jc	short RELEASE_flush
 28197 00004EF2 09D2                            OR      DX,DX
 28198 00004EF4 750B                            JNZ	short NO_DEALLOC	; Was putting EOF mark
 28199                                  	;;cmp	word [es:bp+1Eh],-1 ; MSDOS 3.3
 28200                                  	;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
 28201 00004EF6 26837E1FFF              	CMP     word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 28202 00004EFB 7404                            JZ	short NO_DEALLOC	; No
 28203 00004EFD 26FF461F                        INC	word [ES:BP+DPB.FREE_CNT] ; Increase free count by 1
 28204                                  NO_DEALLOC:
 28205 00004F01 89C3                            MOV     BX,AX
 28206 00004F03 48                              dec     ax              ; check for "1"
 28207 00004F04 7405                    	jz	short RELEASE_flush	; is last cluster of incomplete chain
 28208 00004F06 E83E06                  	call	IsEOF
 28209 00004F09 72D5                            JB	short RELEASE	; Carry clear if JMP not taken
 28210                                  
 28211                                  	; 16/12/2022
 28212                                  ; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28213                                  ;%if 0
 28214                                  RELEASE_flush:
 28215                                  	; MSDOS 6.0
 28216 00004F0B 268A4600                	mov	al,[es:bp]
 28217                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 28218 00004F0F 56                      	push	si		; FLUSHBUF may trash these and we guarantee
 28219 00004F10 51                      	push	cx		;  them to be preserved.
 28220 00004F11 06                      	push	es
 28221 00004F12 55                      	push	bp
 28222 00004F13 E8570B                  	call	FLUSHBUF	; commit buffers for this drive
 28223 00004F16 5D                      	pop	bp
 28224 00004F17 07                      	pop	es
 28225 00004F18 59                      	pop	cx
 28226 00004F19 5E                      	pop	si
 28227                                  ;%endif
 28228                                  RET12:
 28229 00004F1A C3                      	retn
 28230                                  
 28231                                  ;Break	<GETEOF -- Find the end of a file>
 28232                                  ;------------------------------------------------------------------------
 28233                                  ;
 28234                                  ; Procedure Name : GETEOF
 28235                                  ;
 28236                                  ; Inputs:
 28237                                  ;       ES:BP Points to DPB
 28238                                  ;       BX = Cluster in a file
 28239                                  ;       DS = CS
 28240                                  ; Outputs:
 28241                                  ;       BX = Last cluster in the file
 28242                                  ;       Carry set if error (currently user FAILed to I 24)
 28243                                  ; DI destroyed. No other registers affected.
 28244                                  ;
 28245                                  ;--------------------------------------------------------------------------
 28246                                  
 28247                                  GETEOF:
 28248 00004F1B E84006                  	call	UNPACK
 28249 00004F1E 72FA                            jc	short RET12
 28250 00004F20 53                              PUSH    BX
 28251 00004F21 89FB                            MOV     BX,DI
 28252 00004F23 E82106                  	call	IsEOF
 28253 00004F26 5B                              POP     BX
 28254 00004F27 73F1                            JAE     short RET12
 28255 00004F29 89FB                            MOV     BX,DI
 28256 00004F2B EBEE                            JMP     short GETEOF
 28257                                  
 28258                                  ;============================================================================
 28259                                  ; FCB.ASM, MSDOS 6.0, 1991
 28260                                  ;============================================================================
 28261                                  ; 30/07/2018 - Retro DOS v3.0
 28262                                  ; 20/05/2019 - Retro DOS v4.0
 28263                                  
 28264                                  ;	TITLE	FCB - FCB parse calls for MSDOS
 28265                                  ;	NAME	FCB
 28266                                  
 28267                                  ;**	FCB.ASM - Low level routines for parsing names into FCBs and analyzing
 28268                                  ;		  filename characters
 28269                                  ;
 28270                                  ;	MakeFcb
 28271                                  ;	NameTrans
 28272                                  ;	PATHCHRCMP
 28273                                  ;	GetLet
 28274                                  ;	UCase
 28275                                  ;	GetLet3
 28276                                  ;	GetCharType
 28277                                  ;	TESTKANJ
 28278                                  ;	NORMSCAN
 28279                                  ;	DELIM
 28280                                  ;
 28281                                  ;	Revision history:
 28282                                  ;
 28283                                  ;		A000  version 4.00  Jan. 1988
 28284                                  ;	
 28285                                  ;	M048 - access FILE_UCASE_TAB using DS rather than SS.
 28286                                  
 28287                                  TableLook	EQU	-1
 28288                                  
 28289                                  SCANSEPARATOR	EQU	1
 28290                                  DRVBIT		EQU	2
 28291                                  NAMBIT		EQU	4
 28292                                  EXTBIT		EQU	8
 28293                                  
 28294                                  ;----------------------------------------------------------------------------
 28295                                  ;
 28296                                  ; Procedure : MakeFcb
 28297                                  ;
 28298                                  ;----------------------------------------------------------------------------
 28299                                  
 28300                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28301                                  	; DOSCODE:8E77h (MSDOS 5.0, MSDOS.SYS)
 28302                                  MAKEFCB:
 28303                                  ;hkn; SS override
 28304 00004F2D 36C606[4E03]00          	MOV	BYTE [SS:SpaceFlag],0
 28305 00004F33 30D2                    	XOR	DL,DL		; Flag--not ambiguous file name
 28306                                  	;test	al,2
 28307 00004F35 A802                    	test	AL,DRVBIT	; Use current drive field if default?
 28308 00004F37 7504                    	JNZ	short DEFDRV
 28309 00004F39 26C60500                	MOV	BYTE [ES:DI],0	; No - use default drive
 28310                                  DEFDRV:
 28311 00004F3D 47                      	INC	DI
 28312 00004F3E B90800                  	MOV	CX,8
 28313                                  	;test	al,4
 28314 00004F41 A804                    	test	AL,NAMBIT	; Use current name fields as default?
 28315 00004F43 93                      	XCHG	AX,BX		; Save bits in BX
 28316 00004F44 B020                    	MOV	AL," "
 28317 00004F46 7404                    	JZ	short FILLB	; If not, go fill with blanks
 28318 00004F48 01CF                    	ADD	DI,CX
 28319 00004F4A 31C9                    	XOR	CX,CX		; Don't fill any
 28320                                  FILLB:
 28321 00004F4C F3AA                    	REP	STOSB
 28322 00004F4E B103                    	MOV	CL,3
 28323 00004F50 F6C308                  	test	BL,EXTBIT	; Use current extension as default
 28324 00004F53 7404                    	JZ	short FILLB2
 28325 00004F55 01CF                    	ADD	DI,CX
 28326 00004F57 31C9                    	XOR	CX,CX
 28327                                  FILLB2:
 28328 00004F59 F3AA                    	REP	STOSB
 28329 00004F5B 91                      	XCHG	AX,CX		; Put zero in AX
 28330 00004F5C AB                      	STOSW
 28331 00004F5D AB                      	STOSW			; Initialize two words after to zero
 28332 00004F5E 83EF10                  	SUB	DI,16		; Point back at start
 28333                                  	;test	bl,1
 28334 00004F61 F6C301                  	test	BL,SCANSEPARATOR; Scan off separators if not zero
 28335 00004F64 7409                    	JZ	short SKPSPC
 28336 00004F66 E88800                  	CALL	SCANB		; Peel off blanks and tabs
 28337 00004F69 E82201                  	CALL	DELIM		; Is it a one-time-only delimiter?
 28338 00004F6C 7504                    	JNZ	short NOSCAN
 28339 00004F6E 46                      	INC	SI		; Skip over the delimiter
 28340                                  SKPSPC:
 28341 00004F6F E87F00                  	CALL	SCANB		; Always kill preceding blanks and tabs
 28342                                  NOSCAN:
 28343 00004F72 E8F000                  	CALL	GETLET
 28344 00004F75 761E                    	JBE	short NODRV	; Quit if termination character
 28345 00004F77 803C3A                  	CMP	BYTE [SI],":"	; Check for potential drive specifier
 28346 00004F7A 7519                    	JNZ	short NODRV
 28347 00004F7C 46                      	INC	SI		; Skip over colon
 28348 00004F7D 2C40                    	SUB	AL,"@"          ; Convert drive letter to drive number (A=1)
 28349 00004F7F 760F                    	JBE	short BADDRV	; Drive letter out of range
 28350                                  
 28351 00004F81 50                      	PUSH	AX
 28352 00004F82 E8161B                  	call	GetVisDrv
 28353 00004F85 58                      	POP	AX
 28354 00004F86 730A                    	JNC	short HAVDRV
 28355                                  
 28356                                  	; 20/05/2019 - Retro DOS v4.0
 28357                                  	; MSDOS 6.0
 28358                                  ;hkn; SS override
 28359 00004F88 36803E[1006]1A          	CMP	byte [SS:DrvErr],error_not_DOS_disk ; 1Ah
 28360                                  					; if not FAT drive ;AN000;
 28361 00004F8E 7402                    	JZ	short HAVDRV		; assume ok	   ;AN000;
 28362                                  BADDRV:
 28363 00004F90 B2FF                    	MOV	DL,-1
 28364                                  HAVDRV:
 28365 00004F92 AA                      	STOSB			; Put drive specifier in first byte
 28366 00004F93 46                      	INC	SI
 28367 00004F94 4F                      	DEC	DI		; Counteract next two instructions
 28368                                  NODRV:
 28369 00004F95 4E                      	DEC	SI		; Back up
 28370 00004F96 47                      	INC	DI		; Skip drive byte
 28371                                  
 28372                                  	;entry	NORMSCAN
 28373                                  NORMSCAN:
 28374 00004F97 B90800                  	MOV	CX,8
 28375 00004F9A E82200                  	CALL	GETWORD 	; Get 8-letter file name
 28376 00004F9D 803C2E                  	CMP	BYTE [SI],"."
 28377 00004FA0 7510                    	JNZ	short NODOT
 28378 00004FA2 46                      	INC	SI		; Skip over dot if present
 28379                                  
 28380                                  	; 24/09/2023
 28381                                  	;mov	cx,3
 28382 00004FA3 B103                    	mov	cl,3	; ch=0
 28383                                  
 28384                                  	; MSDOS 6.0
 28385                                  ;hkn; SS override
 28386                                  	;TEST	word [SS:DOS34_FLAG],DBCS_VOLID2 ; 100h ;AN000;
 28387                                  	; 10/06/2019
 28388 00004FA5 36F606[1206]01          	test	byte [SS:DOS34_FLAG+1],(DBCS_VOLID2>>8) ; 1
 28389 00004FAB 7402                    	JZ	short VOLOK				;AN000;
 28390 00004FAD A4                      	MOVSB			; 2nd byte of DBCS	;AN000;
 28391                                  	; 24/09/2023
 28392                                  	;MOV	CX,2					;AN000;
 28393 00004FAE 49                      	dec	cx  ; cx=2
 28394                                  	;JMP	SHORT contvol				;AN000;
 28395                                  VOLOK:
 28396                                  	;MOV	CX,3		; Get 3-letter extension
 28397                                  contvol:
 28398 00004FAF E81300                  	CALL	MUSTGETWORD
 28399                                  NODOT:
 28400 00004FB2 88D0                    	MOV	AL,DL
 28401                                  
 28402                                  	; MSDOS 6.0
 28403                                  	;and	word [ss:DOS34_FLAG],0FEFFh
 28404                                  	; 18/12/2022
 28405 00004FB4 368026[1206]FE          	and	byte [ss:DOS34_FLAG+1],0FEh ; (~DBCS_VOLID2)>>8
 28406                                  	;and	word [ss:DOS34_FLAG],~DBCS_VOLID2 ; ### BUG FIX ###
 28407                                  
 28408 00004FBA C3                      	retn
 28409                                  
 28410                                  NONAM:
 28411 00004FBB 01CF                    	ADD	DI,CX
 28412 00004FBD 4E                      	DEC	SI
 28413 00004FBE C3                      	retn
 28414                                  
 28415                                  GETWORD:
 28416 00004FBF E8A300                  	CALL	GETLET		
 28417 00004FC2 76F7                    	JBE	short NONAM	; Exit if invalid character
 28418 00004FC4 4E                      	DEC	SI
 28419                                  
 28420                                  ;	UGH!!! Horrible bug here that should be fixed at some point:
 28421                                  ;	If the name we are scanning is longer than CX, we keep on reading!
 28422                                  
 28423                                  MUSTGETWORD:
 28424 00004FC5 E89D00                  	CALL	GETLET
 28425                                  
 28426                                  ;	If spaceFlag is set then we allow spaces in a pathname
 28427                                  
 28428                                  ;IF NOT TABLELOOK
 28429                                  ;	JB	short FILLNAM  ; MSDOS 3.3
 28430                                  ;ENDIF
 28431 00004FC8 750C                    	JNZ	short MustCheckCX
 28432                                  
 28433                                  ;hkn; SS override
 28434 00004FCA 36F606[4E03]FF          	test	BYTE [SS:SpaceFlag],0FFh
 28435 00004FD0 7419                    	JZ	short FILLNAM
 28436 00004FD2 3C20                    	CMP	AL," "
 28437 00004FD4 7515                    	JNZ	short FILLNAM
 28438                                  
 28439                                  MustCheckCX:
 28440 00004FD6 E3ED                    	JCXZ	MUSTGETWORD
 28441 00004FD8 49                      	DEC	CX
 28442 00004FD9 3C2A                    	CMP	AL,"*"          ; Check for ambiguous file specifier
 28443 00004FDB 7504                    	JNZ	short NOSTAR
 28444 00004FDD B03F                    	MOV	AL,"?"
 28445 00004FDF F3AA                    	REP	STOSB
 28446                                  NOSTAR:
 28447 00004FE1 AA                      	STOSB
 28448 00004FE2 3C3F                    	CMP	AL,"?"
 28449 00004FE4 75DF                    	JNZ	short MUSTGETWORD
 28450 00004FE6 80CA01                  	OR	DL,1		; Flag ambiguous file name
 28451 00004FE9 EBDA                    	JMP	short MUSTGETWORD
 28452                                  FILLNAM:
 28453 00004FEB B020                    	MOV	AL," "
 28454 00004FED F3AA                    	REP	STOSB
 28455 00004FEF 4E                      	DEC	SI
 28456 00004FF0 C3                      	retn
 28457                                  
 28458                                  SCANB:
 28459 00004FF1 AC                      	LODSB
 28460 00004FF2 E8A100                  	CALL	SPCHK
 28461 00004FF5 74FA                    	JZ	short SCANB
 28462 00004FF7 4E                      	DEC	SI
 28463                                  scanb_retn:
 28464 00004FF8 C3                      	retn
 28465                                  
 28466                                  ;----------------------------------------------------------------------------
 28467                                  ;
 28468                                  ; Procedure Name : NameTrans
 28469                                  ;
 28470                                  ; NameTrans is used by FindPath to scan off an element of a path. We must
 28471                                  ; allow spaces in pathnames
 28472                                  ;
 28473                                  ;   Inputs:	DS:SI points to start of path element
 28474                                  ;   Outputs:	Name1 has unpacked name, uppercased
 28475                                  ;		ES = DOSGroup
 28476                                  ;		DS:SI advanced after name
 28477                                  ;   Registers modified: DI,AX,DX,CX
 28478                                  ;
 28479                                  ;----------------------------------------------------------------------------
 28480                                  
 28481                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28482                                  	; 20/05/2019 - Retro DOS v4.0
 28483                                  NameTrans:
 28484                                  ;hkn; SS override
 28485 00004FF9 36C606[4E03]01          	MOV	BYTE [SS:SpaceFlag],1
 28486 00004FFF 16                      	push	ss
 28487 00005000 07                      	pop	es
 28488                                  
 28489                                  ;hkn; NAME1 is in DOSDATA
 28490 00005001 BF[4B05]                	MOV	DI,NAME1
 28491 00005004 57                      	PUSH	DI
 28492 00005005 B82020                  	MOV	AX,'  '
 28493 00005008 B90500                  	MOV	CX,5
 28494 0000500B AA                      	STOSB
 28495 0000500C F3AB                    	REP	STOSW		; Fill "FCB" at NAME1 with spaces
 28496 0000500E 30C0                    	XOR	AL,AL		; Set stuff for NORMSCAN
 28497 00005010 88C2                    	MOV	DL,AL
 28498 00005012 AA                      	STOSB
 28499 00005013 5F                      	POP	DI
 28500                                  
 28501 00005014 E880FF                  	CALL	NORMSCAN
 28502                                  
 28503                                  ;hkn; SS override for NAME1
 28504 00005017 36803E[4B05]E5          	CMP	byte [SS:NAME1],0E5H
 28505 0000501D 75D9                    	jnz	short scanb_retn
 28506 0000501F 36C606[4B05]05          	MOV	byte [SS:NAME1],5 ; Magic name translation
 28507 00005025 C3                      	retn
 28508                                  
 28509                                  ;Break	<GETLET, DELIM -- CHECK CHARACTERS AND CONVERT>
 28510                                  ;============================================================================
 28511                                  
 28512                                  ; 20/05/2019 - Retro DOS v4.0
 28513                                  ; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)
 28514                                  
 28515                                  ;If TableLook
 28516                                  
 28517                                  ;hkn; Table	SEGMENT
 28518                                  ;	PUBLIC	CharType
 28519                                  ;----------------------------------------------------------------------------
 28520                                  
 28521                                  ; Character type table for file name scanning
 28522                                  ; Table provides a mapping of characters to validity bits.
 28523                                  ; Four bits are provided for each character. Values 7Dh and above
 28524                                  ; have all bits set, so that part of the table is chopped off, and
 28525                                  ; the translation routine is responsible for screening these values.
 28526                                  ; The bit values are defined in DOSSYM.INC
 28527                                  
 28528                                  ;	      ; ^A and NUL
 28529                                  ;CharType:
 28530                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28531                                  ;	      ; ^C and ^B
 28532                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28533                                  ;	      ; ^E and ^D
 28534                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28535                                  ;	      ; ^G and ^F
 28536                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28537                                  ;	      ; TAB and BS
 28538                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM+FSPCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28539                                  ;	      ; ^K and ^J
 28540                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28541                                  ;	      ; ^M and ^L
 28542                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28543                                  ;	      ; ^O and ^N
 28544                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28545                                  ;	      ; ^Q and ^P
 28546                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28547                                  ;	      ; ^S and ^R
 28548                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28549                                  ;	      ; ^U and ^T
 28550                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28551                                  ;	      ; ^W and ^V
 28552                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28553                                  ;	      ; ^Y and ^X
 28554                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28555                                  ;	      ; ESC and ^Z
 28556                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28557                                  ;	      ; ^] and ^;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28559                                  ;	      ; ^_ and ^^
 28560                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28561                                  ;	      ; ! and SPACE
 28562                                  ;	 db   LOW (NOT FCHK+FDELIM+FSPCHK)
 28563                                  ;	      ; # and "
 28564                                  ;	 db   LOW (NOT FFCB+FCHK)
 28565                                  ;	      ; $ - )
 28566                                  ;	 db   3 dup (0FFh)
 28567                                  ;	      ; + and *
 28568                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR 0Fh
 28569                                  ;	      ; - and '
 28570                                  ;	 db   NOT (FFCB+FCHK+FDELIM)
 28571                                  ;	      ; / and .
 28572                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FCHK) AND 0Fh
 28573                                  ;	      ; 0 - 9
 28574                                  ;	 db   5 dup (0FFh)
 28575                                  ;	      ; ; and :
 28576                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
 28577                                  ;	      ; = and <
 28578                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
 28579                                  ;	      ; ? and >
 28580                                  ;	 db   NOT FFCB+FCHK+FDELIM
 28581                                  ;	      ; A - Z
 28582                                  ;	 db   13 dup (0FFh)
 28583                                  ;	      ; \ and [
 28584                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR 0Fh
 28585                                  ;	      ; ^ and ]
 28586                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28587                                  ;	      ; _ - {
 28588                                  ;	 db   15 dup (0FFh)
 28589                                  ;	      ; } and |
 28590                                  ;	 db   NOT FFCB+FCHK+FDELIM
 28591                                  
 28592                                  ;CharType_last equ ($ - CharType) * 2	; This is the value of the last
 28593                                  ;					; character in the table
 28594                                  
 28595                                  ;FCHK	equ 1		; normal name char, no chks needed
 28596                                  ;FDELIM	equ 2		; is a delimiter
 28597                                  ;FSPCHK	equ 4		; set if character is not a space or equivalent
 28598                                  ;FFCB	equ 8		; is valid in an FCB
 28599                                  
 28600                                  ; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)
 28601                                  ;----------------------------------------------------------------------------
 28602                                  ; DOSCODE:8F76h (MSDOS 5.0, MSDOS.SYS)
 28603                                  
 28604                                  CharType: ; 63 bytes
 28605 00005026 6666666606666666                db  66h, 66h, 66h, 66h, 06h, 66h, 66h, 66h ; 0-7
 28606 0000502E 6666666666666666        	db  66h, 66h, 66h, 66h, 66h, 66h, 66h, 66h ; 8-15
 28607 00005036 F8F6FFFFFF4FF46E        	db 0F8h,0F6h,0FFh,0FFh,0FFh, 4Fh,0F4h, 6Eh ; 16-23
 28608 0000503E FFFFFFFFFF4444F4        	db 0FFh,0FFh,0FFh,0FFh,0FFh, 44h, 44h,0F4h ; 24-31
 28609 00005046 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 32-39
 28610 0000504E FFFFFFFFFF6F66FF        	db 0FFh,0FFh,0FFh,0FFh,0FFh, 6Fh, 66h,0FFh ; 40-47
 28611 00005056 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 48-55
 28612 0000505E FFFFFFFFFFFFF4          	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0F4h	   ; 56-62
 28613                                  
 28614                                  CharType_last equ ($ - CharType) * 2
 28615                                  
 28616                                  ; Offset 12CAh of IBMDOS.COM (MSDOS 3.3), 1987
 28617                                  ;----------------------------------------------------------------------------
 28618                                  ;CharType:
 28619                                  ;       db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 28620                                  ;	db 0F6h,0F0h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 28621                                  ;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 28622                                  ;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 28623                                  ;	db 0F8h,0FFh,0F6h,0FFh,0FFh,0FFh,0FFh,0FFh
 28624                                  ;	db 0FFh,0FFh,0FFh,0F4h,0F4h,0FFh,0FEh,0F6h
 28625                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28626                                  ;	db 0FFh,0FFh,0F4h,0F4h,0F4h,0F4h,0F4h,0FFh
 28627                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28628                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28629                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28630                                  ;	db 0FFh,0FFh,0FFh,0F6h,0F6h,0F6h,0FFh,0FFh
 28631                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28632                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28633                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28634                                  ;	db 0FFh,0FFh,0FFh,0FFh,0F4h,0FFh,0FFh,0FFh
 28635                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28636                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28637                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28638                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28639                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28640                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28641                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28642                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28643                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28644                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28645                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28646                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28647                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28648                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28649                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28650                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28651                                  
 28652                                  ;hkn; Table	ENDS
 28653                                  
 28654                                  ;ENDIF
 28655                                  
 28656                                  ; 20/05/2019 - Retro DOS v4.0
 28657                                  ; DOSCODE:9011h (MSDOS 6.21, MSDOS.SYS)
 28658                                  
 28659                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28660                                  ; DOSCODE:8FB5h (MSDOS 5.0, MSDOS.SYS)
 28661                                  
 28662                                  ;----------------------------------------------------------------------------
 28663                                  ;
 28664                                  ; Procedure Names : GetLet, UCase, GetLet3
 28665                                  ;
 28666                                  ; These routines take a character, convert it to upper case, and check
 28667                                  ; for delimiters.  Three different entry points:
 28668                                  ;	GetLet -  DS:[SI] = character to convert
 28669                                  ;	UCase  -  AL = character to convert
 28670                                  ;	GetLet3 - AL = character
 28671                                  ;		  [BX] = translation table to use
 28672                                  ;
 28673                                  ;	Exit (in all cases) : AL = upper case character
 28674                                  ;			      CY set if char is control char other than TAB
 28675                                  ;			      ZF set if char is a delimiter
 28676                                  ;	Uses : AX, flags
 28677                                  ;
 28678                                  ; NOTE: This routine exists in a fast table lookup version, and a slow
 28679                                  ; inline version.  Return with carry set is only possible in the inline
 28680                                  ; version. The table lookup version is the one in use.
 28681                                  ;
 28682                                  ;----------------------------------------------------------------------------
 28683                                  
 28684                                  ; This entry point has character at [SI]
 28685                                  
 28686                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5517h
 28687                                  GETLET:	
 28688 00005065 AC                      	LODSB
 28689                                  
 28690                                  ; This entry point has character in AL
 28691                                  
 28692                                  	;entry	UCase
 28693                                  UCase:	
 28694                                  	; 09/08/2018
 28695                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5518h
 28696                                  _UCase:
 28697 00005066 53                      	PUSH	BX
 28698 00005067 BB[310B]                	MOV	BX,FILE_UCASE_TAB+2
 28699                                  
 28700                                  ; Convert the character in AL to upper case
 28701                                  
 28702                                  gl_0:
 28703 0000506A 3C61                    	CMP	AL,"a"
 28704 0000506C 7214                    	JB	short gl_2	; Already upper case, go check type
 28705 0000506E 3C7A                    	CMP	AL,"z"
 28706 00005070 7702                    	JA	short gl_1
 28707 00005072 2C20                    	SUB	AL,20H		; Convert to upper case
 28708                                  
 28709                                  ; Map European character to upper case
 28710                                  
 28711                                  gl_1:
 28712 00005074 3C80                    	CMP	AL,80H
 28713 00005076 720A                    	JB	short gl_2	; Not EuroChar, go check type
 28714 00005078 2C80                    	SUB	AL,80H		; translate to upper case with this index
 28715                                  
 28716                                  	; M048 - Start 
 28717                                  	; Lantastic call Ucase thru int 2f without setting SS to DOSDATA.
 28718                                  	; So we shall set up DS and to access FILE_UCASE_TAB in BX and also 
 28719                                  	; preserve it.
 28720                                  
 28721                                  	; 09/08/2018 - Retro DOS v3.0
 28722                                  	; MSDOS 3.3
 28723                                  	;;XLAT	BYTE [CS:BX]	; ds as file_ucase_tab is in DOSDATA
 28724                                  	;CS	XLAT
 28725                                  
 28726                                  	; 20/05/2019 - Retro DOS v4.0
 28727                                  
 28728                                  	; MSDOS 6.0
 28729 0000507A 1E                      	push	ds
 28730                                  	;getdseg <ds>
 28731 0000507B 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 28732 00005080 D7                      	XLAT			; ds as file_ucase_tab is in DOSDATA
 28733 00005081 1F                      	pop	ds
 28734                                  
 28735                                  	; M048 - End
 28736                                  
 28737                                  ; Now check the type
 28738                                  
 28739                                  ;If TableLook
 28740                                  gl_2:
 28741                                  	; 20/05/2019 - Retro DOS v4.0
 28742 00005082 50                      	PUSH	AX
 28743                                  
 28744                                  	; MSDOS 3.3
 28745                                  	;mov	bx,CharType
 28746                                  	;; 09/08/2018
 28747                                  	;;xlat	byte [cs:bx]
 28748                                  	;cs	xlat	
 28749                                  	
 28750                                  	; MSDOS 6.0
 28751 00005083 E81800                  	CALL	GetCharType	; returns type flags in AL
 28752                                  	
 28753                                  	;test	al,1	
 28754 00005086 A801                    	TEST	AL,FCHK 	; test for normal character
 28755 00005088 58                      	POP	AX
 28756                                  
 28757 00005089 5B                      	POP	BX
 28758 0000508A C3                      	RETN
 28759                                  
 28760                                  ; This entry has character in AL and lookup table in BX
 28761                                  
 28762                                  	; MSDOS 6.0
 28763                                  ;	;entry GetLet3
 28764                                  GETLET3: ; 10/08/2018
 28765 0000508B 53                      	PUSH	BX
 28766 0000508C EBDC                    	JMP	short gl_0
 28767                                  ;ELSE
 28768                                  ;
 28769                                  ;gl_2:
 28770                                  ;	POP	BX
 28771                                  ;	CMP	AL,"."
 28772                                  ;	retz
 28773                                  ;	CMP	AL,'"'
 28774                                  ;	retz
 28775                                  ;	CALL	PATHCHRCMP
 28776                                  ;	retz
 28777                                  ;	CMP	AL,"["
 28778                                  ;	retz
 28779                                  ;	CMP	AL,"]"
 28780                                  ;	retz
 28781                                  ;ENDIF
 28782                                  
 28783                                  ;---------------------------------------------------------------------
 28784                                  ;
 28785                                  ; DELIM - check if character is a delimiter
 28786                                  ;	Entry : AX = character to check
 28787                                  ;	Exit  : ZF set if character is not a delimiter
 28788                                  ;	Uses  : Flags
 28789                                  ;
 28790                                  ;--------------------------------------------------------------------
 28791                                  
 28792                                  	;entry	DELIM
 28793                                  DELIM:
 28794                                  ;IF TableLook
 28795                                  	; 20/05/2019 - Retro DOS v4.0
 28796 0000508E 50                      	PUSH	AX
 28797                                  
 28798                                  	; MSDOS 3.3
 28799                                  	;push	bx
 28800                                  	;mov	bx,CharType
 28801                                  	;;09/08/2018
 28802                                  	;;xlat	byte [cs:bx]
 28803                                  	;cs	xlat
 28804                                  	;pop	bx
 28805                                  
 28806                                  	; MSDOS 6.0
 28807 0000508F E80C00                  	CALL	GetCharType
 28808                                  	
 28809                                  	;test	al,2
 28810 00005092 A802                    	TEST	AL,FDELIM
 28811 00005094 58                      	POP	AX
 28812 00005095 C3                      	RETN
 28813                                  ;ELSE
 28814                                  ;	CMP	AL,":"
 28815                                  ;	retz
 28816                                  ;
 28817                                  ;	CMP	AL,"<"
 28818                                  ;	retz
 28819                                  ;	CMP	AL,"|"
 28820                                  ;	retz
 28821                                  ;	CMP	AL,">"
 28822                                  ;	retz
 28823                                  ;
 28824                                  ;	CMP	AL,"+"
 28825                                  ;	retz
 28826                                  ;	CMP	AL,"="
 28827                                  ;	retz
 28828                                  ;	CMP	AL,";"
 28829                                  ;	retz
 28830                                  ;	CMP	AL,","
 28831                                  ;	retz
 28832                                  ;ENDIF
 28833                                  
 28834                                  ;-------------------------------------------------------------------------
 28835                                  ;
 28836                                  ;  SPCHK - checks to see if a character is a space or equivalent
 28837                                  ;	Entry : AL = character to check
 28838                                  ;	Exit  : ZF set if character is a space
 28839                                  ;	Uses  : flags
 28840                                  ;
 28841                                  ;-------------------------------------------------------------------------
 28842                                  
 28843                                  	;entry SPCHK
 28844                                  SPCHK:
 28845                                  ;IF TableLook
 28846                                  	; 20/05/2019 - Retro DOS v4.0
 28847 00005096 50                      	PUSH	AX
 28848                                  
 28849                                  	; MSDOS 3.3
 28850                                  	;push	bx
 28851                                  	;mov	bx,CharType
 28852                                  	;; 09/08/2018
 28853                                  	;;xlat	byte [cs:bx]
 28854                                  	;cs	xlat
 28855                                  	;pop	bx
 28856                                  
 28857                                  	; MSDOS 6.0
 28858 00005097 E80400                  	CALL	GetCharType
 28859                                  	
 28860                                  	;test	al,4
 28861 0000509A A804                    	TEST	AL,FSPCHK
 28862 0000509C 58                      	POP	AX
 28863 0000509D C3                      	RETN
 28864                                  ;ELSE
 28865                                  ;	CMP	AL,9		; Filter out tabs too
 28866                                  ;	retz
 28867                                  ;; WARNING! " " MUST be the last compare
 28868                                  ;	CMP	AL," "
 28869                                  ;	return
 28870                                  ;ENDIF
 28871                                  
 28872                                  ;-------------------------------------------------------------------------
 28873                                  ;
 28874                                  ;  GetCharType - return flag bits indicating character type
 28875                                  ;	Bits are defined in DOSSYM.INC. Uses lookup table
 28876                                  ;	defined above at label CharType.
 28877                                  ;
 28878                                  ;	Entry : AL = character to return type flags for
 28879                                  ;	Exit  : AL = type flags
 28880                                  ;	Uses  : AL, flags
 28881                                  ;
 28882                                  ;-------------------------------------------------------------------------
 28883                                  
 28884                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28885                                  
 28886                                  	; 20/05/2019 - Retro DOS v4.0
 28887                                  	; MSDOS 6.0
 28888                                  GetCharType:
 28889                                  	;cmp	al,7Eh
 28890 0000509E 3C7E                    	cmp	al,CharType_last 	; beyond end of table?
 28891 000050A0 7316                    	jae	short gct_90		; return standard value
 28892                                  
 28893 000050A2 53                      	push	bx
 28894 000050A3 BB[2650]                	mov	bx,CharType		; load lookup table
 28895 000050A6 D0E8                    	shr	al,1			; adjust for half-byte table entry size
 28896                                  	;xlat	cs:[bx] 		; get flags
 28897 000050A8 2ED7                    	cs	xlat	
 28898 000050AA 5B                      	pop	bx
 28899                                  
 28900                                  ; carry clear from previous shift means we want the low nibble.  Otherwise
 28901                                  ; we have to shift the flags down to the low nibble
 28902                                  
 28903 000050AB 7308                    	jnc	short gct_80		; carry clear, no shift needed
 28904                                  
 28905 000050AD D0E8                    	shr	al,1			; we want high nibble, shift it down
 28906 000050AF D0E8                    	shr	al,1
 28907 000050B1 D0E8                    	shr	al,1
 28908 000050B3 D0E8                    	shr	al,1
 28909                                  gct_80:
 28910 000050B5 240F                    	and	al,0Fh			; clear the unused nibble
 28911 000050B7 C3                      	retn
 28912                                  gct_90:
 28913 000050B8 B00F                    	mov	al,0Fh			; set all flags
 28914 000050BA C3                      	retn
 28915                                  
 28916                                  ;----------------------------------------------------------------------------
 28917                                  ;
 28918                                  ; Procedure : PATHCHRCMP
 28919                                  ;
 28920                                  ;----------------------------------------------------------------------------
 28921                                  
 28922                                  PATHCHRCMP:
 28923 000050BB 3C2F                    	CMP	AL,'/'
 28924 000050BD 7606                    	JBE	short PathRet
 28925 000050BF 3C5C                    	CMP	AL,'\'
 28926 000050C1 C3                      	retn
 28927                                  GotFor:
 28928 000050C2 B05C                    	MOV	AL,'\'
 28929 000050C4 C3                      	retn
 28930                                  PathRet:
 28931 000050C5 74FB                    	JZ	short GotFor
 28932 000050C7 C3                      	retn
 28933                                  
 28934                                  ;============================================================================
 28935                                  ; MSCRTLC.ASM, MSDOS 6.0, 1991
 28936                                  ;============================================================================
 28937                                  ; 30/07/2018 - Retro DOS v3.0
 28938                                  ; 29/04/2019 - Retro DOS v4.0
 28939                                  
 28940                                  ; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11, CTRLC.ASM, 1983)
 28941                                  
 28942                                  ;**	MSCTRLC.ASM - ^C and error handler for MSDOS
 28943                                  
 28944                                  ;	TITLE	Control C detection, Hard error and EXIT routines
 28945                                  ;	NAME	IBMCTRLC
 28946                                  
 28947                                  ;**	Low level routines for detecting special characters on CON input,
 28948                                  ;	the ^C exit/int code, the Hard error INT 24 code, the
 28949                                  ;	process termination code, and the INT 0 divide overflow handler.
 28950                                  ;
 28951                                  ;	FATAL
 28952                                  ;	FATAL1
 28953                                  ;	reset_environment
 28954                                  ;	DSKSTATCHK
 28955                                  ;	SPOOLINT
 28956                                  ;	STATCHK
 28957                                  ;	CNTCHAND
 28958                                  ;	DIVOV
 28959                                  ;	CHARHARD
 28960                                  ;	HardErr
 28961                                  ;
 28962                                  ;	Revision history:
 28963                                  ;
 28964                                  ;	    AN000	version 4.0   Jan 1988
 28965                                  ;	    A002	PTM    -- dir >lpt3 hangs
 28966                                  ;	    A003	PTM 3957- fake version for IBMCAHE.COM
 28967                                  ;
 28968                                  ; 	M011: NEC's 8086 clone chip uses Intel's undocumented bit number in
 28969                                  ;	      flags register. In order to return to user normally DOS used to
 28970                                  ;	      move F202 into flags, which sets bit number 1 in flags uncondit-
 28971                                  ;	      ionally. Now it is modified to maintain the state of bit 1.
 28972                                  ;
 28973                                  ; 	M024: suppressed fail and ignore options if not in the middle of int 
 28974                                  ;	      24 and if Ctrl P or ctrl printscrn is pressed in routine 
 28975                                  ;	      charhard.
 28976                                  
 28977                                  ; 29/04/2019 - Retro DOS v4.0
 28978                                  	; MSDOS 6.0
 28979                                  ;		public	LowInt23Addr		
 28980                                  LowInt23Addr: ;	LABEL	DWORD
 28981 000050C8 [CD10]0000              	DW	LowInt23, 0
 28982                                  
 28983                                  ;		public	LowInt24Addr
 28984                                  LowInt24Addr: ;	LABEL	DWORD
 28985 000050CC [E110]0000              	DW	LowInt24, 0
 28986                                  
 28987                                  ;		public	LowInt28Addr
 28988                                  LowInt28Addr: ;	LABEL	DWORD
 28989 000050D0 [F510]0000              	DW	LowInt28, 0
 28990                                  
 28991                                  ;Break	<Checks for ^C in CON I/O>
 28992                                  
 28993                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28994                                  ; 05/05/2019 - Retro DOS v4.0
 28995                                  
 28996                                  ;---------------------------------------------------------------------------
 28997                                  ;
 28998                                  ; Procedure Name : DSKSTATCHK
 28999                                  ;
 29000                                  ; Check for ^C if only one level in
 29001                                  ;
 29002                                  ;---------------------------------------------------------------------------
 29003                                  
 29004                                          ;procedure DSKSTATCHK,NEAR ; Check for ^C if only one level in
 29005                                  
 29006                                  DSKSTATCHK:        
 29007                                  	;CMP	BYTE [INDOS],1
 29008 000050D4 36803E[2103]01                  CMP     BYTE [SS:INDOS],1 ; 15/03/2018
 29009                                  	;retnz			; Do NOTHING
 29010                                  	; 16/12/2022
 29011 000050DA 7534                    	JNZ	SHORT _RET37 ; Retro DOS v2.0 - 04/03/2018         
 29012                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29013                                  	;jz	short _RET37 ; dskstatchk1
 29014                                  	;retn
 29015                                  ;_RET37:
 29016                                  ;dskstatchk1:
 29017 000050DC 51                      	PUSH    CX
 29018 000050DD 06                              PUSH    ES
 29019 000050DE 53                              PUSH    BX
 29020 000050DF 1E                              PUSH    DS
 29021 000050E0 56                              PUSH    SI
 29022                                          
 29023                                  	;PUSH	CS
 29024                                          ;POP	ES
 29025                                          ;PUSH	CS
 29026                                          ;POP	DS
 29027                                  
 29028 000050E1 8CD3                    	MOV	BX,SS		; SS is DOSDATA. ES:BX must be set up
 29029 000050E3 8EC3                    	MOV	ES,BX		; for deviocall2
 29030 000050E5 8EDB                    	MOV	DS,BX
 29031                                  
 29032                                  	; 16/12/2022
 29033                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29034                                  
 29035                                  	; 05/05/2019
 29036                                  	;MOV	BYTE [ss:DSKSTCOM],DEVRDND
 29037                                          ;MOV	BYTE [ss:DSKSTCALL],DRDNDHL
 29038                                  	;mov	word [ss:DSKSTST],0
 29039                                  
 29040                                  	; 16/12/2022
 29041                                  	; 25/06/2019
 29042 000050E7 C606[9403]05            	MOV	BYTE [DSKSTCOM],DEVRDND	 ; 5
 29043 000050EC C606[9203]0E                    MOV	BYTE [DSKSTCALL],DRDNDHL ; 14
 29044 000050F1 C706[9503]0000          	mov	word [DSKSTST],0
 29045                                  
 29046 000050F7 BB[9203]                        MOV     BX,DSKSTCALL
 29047                                  
 29048                                  	;LDS	SI,[ss:BCON]
 29049                                          ; 25/062019
 29050 000050FA C536[3200]              	lds	si,[BCON]
 29051                                  
 29052                                  ; 16/12/2022
 29053                                  ;	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29054                                  ;	mov	byte [ss:DSKSTCOM],DEVRDND  ; 5
 29055                                  ;       mov	byte [ss:DSKSTCALL],DRDNDHL ; 14
 29056                                  ;	mov	word [ss:DSKSTST],0
 29057                                  ;	mov	bx,DSKSTCALL
 29058                                  ;	lds	si,[ss:BCON]
 29059                                  
 29060 000050FE E890F5                  	CALL	DEVIOCALL2
 29061                                   	; 15/03/2018
 29062                                  	;;test	word [ss:DSKSTST],200h
 29063                                          ;TEST	WORD [SS:DSKSTST],STBUI
 29064                                  	; 05/05/2019
 29065 00005101 36F606[9603]02          	test	byte [ss:DSKSTST+1],(STBUI>>8) ; 2
 29066 00005107 7408                    	jz	short _GotCh		; No characters available
 29067                                  
 29068 00005109 30C0                            XOR     AL,AL                   ; Set zero
 29069                                  RET36:
 29070 0000510B 5E                              POP     SI
 29071 0000510C 1F                              POP     DS
 29072 0000510D 5B                              POP     BX
 29073 0000510E 07                              POP     ES
 29074 0000510F 59                              POP     CX
 29075                                  	; 16/12/2022
 29076                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29077                                  _RET37:
 29078 00005110 C3                              RETN
 29079                                  
 29080                                  _GotCh:
 29081 00005111 36A0[9F03]                      MOV     AL,[SS:DSKCHRET]	; SS override
 29082                                  
 29083 00005115 3C03                            CMP     AL,"C"-"@" ; cmp al,3
 29084 00005117 75F2                            JNZ     SHORT RET36
 29085 00005119 36C606[9403]04                  MOV     BYTE [SS:DSKSTCOM],DEVRD
 29086 0000511F 36C606[9203]16                  MOV     BYTE [SS:DSKSTCALL],DRDWRHL
 29087 00005125 36880E[9F03]                    MOV     [SS:DSKCHRET],CL
 29088                                  	; 09/09/2018
 29089 0000512A 36C706[9503]0000        	MOV	word [SS:DSKSTST],0
 29090 00005131 36C706[A403]0100        	MOV	word [SS:DSKSTCNT],1
 29091 00005138 E856F5                  	CALL	DEVIOCALL2              ; Eat the ^C
 29092 0000513B 5E                              POP     SI
 29093 0000513C 1F                              POP     DS
 29094 0000513D 5B                              POP     BX                      ; Clean stack
 29095 0000513E 07                              POP     ES
 29096 0000513F 59                              POP     CX
 29097 00005140 E9CF00                          JMP	CNTCHAND ; 10/08/2018
 29098                                  
 29099                                  	; 05/05/2019
 29100                                  NOSTOP:
 29101                                  	; MSDOS 6.0
 29102 00005143 3C10                    	CMP	AL,"P"-"@"
 29103 00005145 7509                    	JNZ	short check_next
 29104                                  				    	; SS override
 29105 00005147 36803E[900D]00          	CMP	BYTE [SS:SCAN_FLAG],0	; ALT_Q ?
 29106 0000514D 7405                    	JZ	short INCHKJ		; no
 29107                                  check_end:	; 24/09/2023
 29108 0000514F C3                      	retn
 29109                                  check_next:
 29110                                  	;IF	NOT TOGLPRN
 29111                                  	;CMP	AL,"N"-"@"
 29112                                  	;JZ	short INCHKJ
 29113                                  	;ENDIF
 29114                                  
 29115 00005150 3C03                    	CMP	AL,"C"-"@"
 29116                                  	; 24/09/2023
 29117                                  	;JZ	short INCHKJ
 29118                                  ;check_end:
 29119                                  	;retn
 29120 00005152 75FB                    	jnz	short check_end
 29121                                  
 29122                                  	; 24/09/2023
 29123                                  	; 08/09/2018
 29124                                  INCHKJ:	; 10/08/2018
 29125 00005154 E9A500                  	jmp	INCHK
 29126                                  
 29127                                  	; MSDOS 3.3
 29128                                          ;CMP     AL,"P"-"@"  ; cmp al,16
 29129                                          ;JZ	short INCHKJ
 29130                                  
 29131                                  	; 15/04/2018
 29132                                          ;;IF	NOT TOGLPRN
 29133                                          ;CMP	AL,"N"-"@"
 29134                                          ;JZ	SHORT INCHKJ
 29135                                          ;;ENDIF
 29136                                  	
 29137                                  	;CMP     AL,"C"-"@"  ; cmp al,3
 29138                                          ;JZ	short INCHKJ
 29139                                  	;RETN
 29140                                  
 29141                                  ;	; 08/09/2018
 29142                                  ;INCHKJ:; 10/08/2018
 29143                                  ;	JMP	INCHK
 29144                                  
 29145                                  ;----------------------------------------------------------------------------
 29146                                  ;
 29147                                  ; Procedure Name : SpoolInt
 29148                                  ;
 29149                                  ; SpoolInt - signal processes that the DOS is truly idle. We are allowed to
 29150                                  ; do this ONLY if we are working on a 1-12 system call AND if we are not in
 29151                                  ; the middle of an INT 24.
 29152                                  ;
 29153                                  ;----------------------------------------------------------------------------
 29154                                  
 29155                                  SPOOLINT:
 29156 00005157 9C                              PUSHF
 29157                                  	; 15/03/2018
 29158 00005158 36803E[5803]00                  CMP     BYTE [SS:IDLEINT],0	; SS override
 29159 0000515E 7423                            JZ      SHORT POPFRET
 29160 00005160 36803E[2003]00                  CMP     BYTE [SS:ERRORMODE],0
 29161 00005166 751B                            JNZ     SHORT POPFRET		;No spool ints in error mode
 29162                                  
 29163                                  	; 30/07/2018
 29164                                  
 29165                                  	; Note that we are going to allow an external program to issue system 
 29166                                  	; calls at this time. We MUST preserve IdleInt across this.
 29167                                  
 29168 00005168 36FF36[5803]            	PUSH	WORD [SS:IDLEINT]
 29169                                  
 29170                                  	; 05/05/2019 - Retro DOS v4.0
 29171                                   
 29172                                  	; MSDOS 6.0
 29173 0000516D 36803E[F211]00          	cmp	byte [SS:DosHasHMA],0	; Q: is dos running in HMA (M021)
 29174 00005173 7504                    	jne	short do_low_int28	; Y: the int must be done from low mem
 29175 00005175 CD28                    	INT	int_spooler  ; int 28h 	; N: Execute user int 28 handler
 29176 00005177 EB05                    	jmp	short spool_ret_addr
 29177                                  
 29178                                  do_low_int28:
 29179                                  	;call	far [ss:LowInt28Addr]
 29180 00005179 2EFF1E[D050]            	call	far [cs:LowInt28Addr]	; 05/05/2019
 29181                                  
 29182                                  spool_ret_addr:
 29183                                  	;INT	int_spooler		; INT 28h
 29184                                  
 29185 0000517E 368F06[5803]            	POP	WORD [SS:IDLEINT]
 29186                                  POPFRET:
 29187 00005183 9D                              POPF
 29188                                  _RET18:  
 29189 00005184 C3                      	RETN
 29190                                  
 29191                                  ; 05/05/2019 - Retro DOS v4.0
 29192                                  ; DOSCODE:9137h (MSDOS 6.21, MSDOS.SYS)
 29193                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29194                                  ; DOSCODE:90DBh (MSDOS 5.0, MSDOS.SYS)
 29195                                  
 29196                                  ;----------------------------------------------------------------------------
 29197                                  ;
 29198                                  ; Procedure Name : STATCHK
 29199                                  ;
 29200                                  ;----------------------------------------------------------------------------
 29201                                  
 29202                                  STATCHK:
 29203 00005185 E84CFF                          CALL	DSKSTATCHK              ; Allows ^C to be detected under
 29204                                                                          ; input redirection
 29205 00005188 53                              PUSH    BX
 29206 00005189 31DB                            XOR     BX,BX
 29207 0000518B E8E9E4                          CALL	GET_IO_SFT
 29208 0000518E 5B                              POP     BX
 29209 0000518F 72F3                            JC      SHORT _RET18
 29210                                  
 29211 00005191 B401                            MOV     AH,1
 29212 00005193 E826F3                          CALL	IOFUNC
 29213 00005196 74BF                            JZ      SHORT SPOOLINT
 29214 00005198 3C13                            CMP     AL,'S'-'@'
 29215 0000519A 75A7                            JNZ     SHORT NOSTOP
 29216                                  
 29217                                  	; 05/05/2019
 29218                                  	; MSDOS 6.0			; SS override
 29219 0000519C 36803E[900D]00          	CMP	BYTE [SS:SCAN_FLAG],0	; AN000; ALT_R ?
 29220 000051A2 75AB                    	JNZ	short check_end		; AN000; yes
 29221                                  
 29222 000051A4 30E4                            XOR     AH,AH
 29223 000051A6 E813F3                          CALL	IOFUNC                  ; Eat Cntrl-S
 29224 000051A9 EB4A                            JMP     SHORT PAUSOSTRT
 29225                                  PRINTOFF:
 29226                                  PRINTON:
 29227 000051AB 36F616[FE02]            	NOT	BYTE [SS:PFLAG] ; 14/03/2018
 29228                                  
 29229                                  	; 30/07/2018 - Retro DOS v3.0
 29230 000051B0 53                      	PUSH	BX
 29231 000051B1 BB0400                  	MOV	BX,4
 29232 000051B4 E8C0E4                  	call	GET_IO_SFT
 29233 000051B7 5B                      	POP	BX
 29234 000051B8 72CA                    	jc	short _RET18
 29235 000051BA 06                      	PUSH	ES
 29236 000051BB 57                      	PUSH	DI
 29237 000051BC 1E                      	PUSH	DS
 29238 000051BD 07                      	POP	ES
 29239 000051BE 89F7                    	MOV	DI,SI			; ES:DI -> SFT
 29240                                  	;test	word [es:di+5],800h
 29241                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_net_spool
 29242                                  	; 05/05/2019
 29243 000051C0 26F6450608              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8)
 29244 000051C5 7418                    	JZ	short NORM_PR 		; Not redirected, echo is OK
 29245                                  
 29246                                  	;Callinstall NetSpoolEchoCheck,MultNet,38,<AX>,<AX> 
 29247                                  					; See if allowed
 29248 000051C7 50                      	push	ax
 29249 000051C8 B82611                  	mov	ax,1126h
 29250 000051CB CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 29251                                  			; Return: CF set on error, AX = error code
 29252                                  			; STACK unchanged
 29253 000051CD 58                      	pop	ax
 29254                                  
 29255 000051CE 730F                    	JNC	short NORM_PR 		; Echo is OK
 29256                                  
 29257                                  					; SS override
 29258 000051D0 36C606[FE02]00          	MOV	BYTE [SS:PFLAG],0	; If not allowed, disable echo
 29259                                  
 29260                                  	;Callinstall NetSpoolClose,MultNet,36,<AX>,<AX> ; and close
 29261                                  
 29262 000051D6 50                      	push    ax
 29263 000051D7 B82411                  	mov     ax,1124h
 29264 000051DA CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 29265                                  			; ES:DI -> SFT, SS = DOS CS
 29266 000051DC 58                      	pop     ax
 29267                                  
 29268 000051DD EB10                    	JMP	SHORT RETP6
 29269                                  NORM_PR:
 29270 000051DF 36803E[FE02]00          	CMP	BYTE [SS:PFLAG],0	; SS override
 29271 000051E5 7505                    	JNZ	short PRNOPN
 29272 000051E7 E82BF4                  	call	DEV_CLOSE_SFT
 29273 000051EA EB03                    	JMP	SHORT RETP6
 29274                                  PRNOPN:
 29275 000051EC E81EF4                  	call	DEV_OPEN_SFT
 29276                                  RETP6:
 29277 000051EF 5F                      	POP	DI
 29278 000051F0 07                      	POP	ES
 29279                                  STATCHK_RETN:
 29280 000051F1 C3                              RETN
 29281                                  PAUSOLP:
 29282 000051F2 E862FF                          CALL    SPOOLINT
 29283                                  PAUSOSTRT:
 29284 000051F5 B401                            MOV     AH,1
 29285 000051F7 E8C2F2                          CALL	IOFUNC
 29286 000051FA 74F6                            JZ      SHORT PAUSOLP
 29287                                  INCHK:
 29288 000051FC 53                              PUSH    BX
 29289 000051FD 31DB                            XOR     BX,BX
 29290 000051FF E875E4                          CALL	GET_IO_SFT
 29291 00005202 5B                              POP     BX
 29292 00005203 72EC                            JC      SHORT STATCHK_RETN ; 30/07/2018
 29293 00005205 30E4                            XOR     AH,AH
 29294 00005207 E8B2F2                          CALL	IOFUNC
 29295                                  	; 30/07/2018
 29296                                  	; MSDOS 3.3
 29297                                          ;CMP	AL,'P'-'@' ;cmp al,16
 29298                                          ;JNZ	SHORT NOPRINT
 29299                                  
 29300                                  	;cmp	byte [SS:SCAN_FLAG],0
 29301                                  	;JZ	SHORT PRINTON	
 29302                                  	;mov	byte [ss:SCAN_FLAG],0
 29303                                  
 29304                                  	; 05/05/2019
 29305                                  	; MSDOS 6.0
 29306 0000520A 3C10                    	CMP	AL,"P"-"@"
 29307                                  	;;;;  7/14/86	ALT_Q key fix
 29308 0000520C 749D                    	JZ	short PRINTON		; no! must be CTRL_P
 29309                                  ;NOPRINT:	
 29310                                  	;IF	NOT TOGLPRN
 29311                                  	;CMP	AL,"N"-"@"
 29312                                  	;JZ	short PRINTOFF
 29313                                  	;ENDIF
 29314 0000520E 3C03                    	CMP	AL,"C"-"@" ; cmp al,3 
 29315                                  	;retnz
 29316 00005210 75DF                    	jnz	short STATCHK_RETN
 29317                                  
 29318                                  	; !! NOTE: FALL THROUGH !!
 29319                                  
 29320                                  ;---------------------------------------------------------------------------
 29321                                  ;
 29322                                  ; Procedure Name : CNTHAND ( CTRLC_C HANDLER )
 29323                                  ;
 29324                                  ; "^C" and CR/LF is printed. Then the user registers are restored and the
 29325                                  ; user CTRL-C handler is executed. At this point the top of the stack has 1)
 29326                                  ; the interrupt return address should the user CTRL-C handler wish to allow
 29327                                  ; processing to continue; 2) the original interrupt return address to the code
 29328                                  ; that performed the function call in the first place. If the user CTRL-C
 29329                                  ; handler wishes to continue, it must leave all registers unchanged and RET
 29330                                  ; (not IRET) with carry CLEAR. If carry is SET then an terminate system call
 29331                                  ; is simulated.
 29332                                  ;
 29333                                  ;---------------------------------------------------------------------------
 29334                                  
 29335                                  CNTCHAND:
 29336                                  	; MSDOS 6.0			; SS override
 29337                                  					; AN002; from RAWOUT
 29338                                  	;TEST	word [SS:DOS34_FLAG],CTRL_BREAK_FLAG  
 29339                                  	;JNZ	short around_deadlock 	; AN002;
 29340                                  
 29341                                  	; 05/05/2019 - Retro DOS v4.0
 29342                                  	; (MSDOS 6.21 MSDOS.SYS DOSCODE:91C4h, 29/12/2022)
 29343 00005212 36F606[1206]02          	TEST	byte [SS:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8)  ; 2 
 29344 00005218 7508                    	JNZ	short around_deadlock 	; AN002;
 29345                                  
 29346 0000521A B003                            MOV     AL,3			; Display "^C"
 29347 0000521C E8E2C4                          CALL	BUFOUT
 29348 0000521F E87EC3                          CALL	CRLF
 29349                                  around_deadlock:
 29350 00005222 16                              PUSH    SS
 29351 00005223 1F                              POP     DS
 29352 00005224 803E[5703]00                    CMP     BYTE [CONSWAP],0
 29353 00005229 7403                            JZ      SHORT NOSWAP
 29354 0000522B E8B3E0                          CALL	SWAPBACK
 29355                                  NOSWAP:
 29356 0000522E FA                      	CLI				; Prepare to play with stack
 29357 0000522F 8E16[8605]              	MOV	SS,[USER_SS]		; User stack now restored
 29358 00005233 8B26[8405]              	MOV	SP,[USER_SP]
 29359 00005237 E811B2                          CALL	restore_world       ; User registers now restored
 29360                                  
 29361                                  	; 30/07/2018 - Retro DOS v3.0 
 29362                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56ACh)
 29363                                          ; 14/03/2018 - Retro DOS v2.0
 29364                                  	;MOV	BYTE [CS:INDOS],0	
 29365                                          ;MOV	BYTE [CS:ERRORMODE],0
 29366                                          ;MOV	[CS:ConC_Spsave],SP
 29367                                  	;clc	;30/07/2018
 29368                                          ;INT	int_ctrl_c ; 23h    ; Execute user Ctrl-C handler
 29369                                  	;;int	23h	; DOS - CONTROL "C" EXIT ADDRESS
 29370                                  			; Return: return via RETF 2 with CF set
 29371                                  			; DOS will abort program with errorlevel 0
 29372                                  			; else
 29373                                  			; interrupted DOS call continues
 29374                                  
 29375                                  	; 05/05/2019 - Retro DOS v4.0
 29376                                  	; MSDOS 6.0 (MSDOS 6.21, MSDOS.SYS,91ECh) 
 29377                                  
 29378                                  	; CS was used to address these variables. We have to use DOSDATA
 29379                                  	
 29380 0000523A 07                      	pop	es ; *	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:91ECh)
 29381                                  			; (pop es, after 'call restore_world')	
 29382 0000523B 1E                      	push	ds
 29383                                  	;getdseg <ds>			; ds -> dosdata
 29384 0000523C 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 29385 00005241 C606[2103]00            	mov	byte [INDOS],0		; Go to known state
 29386 00005246 C606[2003]00            	mov	byte [ERRORMODE],0
 29387 0000524B 8926[3203]              	mov	[ConC_Spsave],SP	; save his SP
 29388                                  	; User SP has changed because of push. Adjust for it
 29389 0000524F 8306[3203]02            	add	word [ConC_Spsave],2
 29390                                  
 29391 00005254 803E[F211]00            	cmp	byte [DosHasHMA],0	; Q: is dos running in HMA (M021)
 29392 00005259 1F                       	pop	ds	; restore ds
 29393 0000525A 7505                    	jne	short do_low_int23	; Y: the int must be done from low mem
 29394 0000525C F8                      	CLC				
 29395 0000525D CD23                    	INT	int_ctrl_c  ; int 23h	; N: Execute user Ctrl-C handler
 29396 0000525F EB06                    	jmp	short ctrlc_ret_addr
 29397                                  
 29398                                  	; 05/05/2019
 29399                                  do_low_int23:
 29400 00005261 F8                      	clc
 29401 00005262 2EFF1E[C850]            	call	far [cs:LowInt23Addr]	
 29402                                  
 29403                                  	; 30/07/2018 
 29404                                  
 29405                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56C0h)
 29406                                  
 29407                                  ; The user has returned to us. The circumstances we allow are:
 29408                                  ;
 29409                                  ;   IRET	We retry the operation by redispatching the system call
 29410                                  ;   CLC/RETF	POP the stack and retry
 29411                                  ;   ... 	Exit the current process with ^C exit
 29412                                  ;
 29413                                  ; User's may RETURN to us and leave interrupts on. 
 29414                                  ; Turn 'em off just to be sure
 29415                                  
 29416                                  ctrlc_ret_addr: ; 05/05/2019
 29417                                  
 29418 00005267 FA                      	CLI
 29419                                  
 29420                                  	; MSDOS 3.3 
 29421                                  	;MOV	[CS:USER_IN_AX],ax	; save the AX
 29422                                  	;PUSHF				; and the flags (maybe new call)
 29423                                  	;POP	AX
 29424                                  
 29425                                  	; 05/05/2019
 29426                                  	; MSDOS 6.0
 29427                                  
 29428                                  	; We have to use DOSDATA for these variables. Previously CS was used 
 29429                                  
 29430 00005268 50                      	push	ax
 29431 00005269 8CD8                    	mov	ax,ds
 29432                                  	;getdseg <ds>			; ds -> dosdata
 29433 0000526B 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 29434 00005270 A3[0A0D]                	mov	[TEMPSEG],ax
 29435 00005273 58                      	pop	ax
 29436 00005274 A3[3A03]                	MOV	[USER_IN_AX],ax		; save the AX
 29437 00005277 9C                      	pushf				; and the flags (maybe new call)
 29438 00005278 58                      	pop	ax
 29439                                  
 29440                                  ; See if the input stack is identical to the output stack
 29441                                  
 29442                                  	; MSDOS 3.3
 29443                                  	;CMP	SP,[CS:ConC_Spsave]
 29444                                  	;JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP
 29445                                  
 29446                                  	; MSDOS 6.0
 29447 00005279 3B26[3203]              	CMP	SP,[ConC_Spsave]
 29448 0000527D 750A                    	JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP
 29449                                  
 29450                                  ; Repeat the operation by redispatching the system call.
 29451                                  
 29452                                  ctrlc_repeat:
 29453                                  	; MSDOS 3.3
 29454                                  	;MOV	AX,[CS:USER_IN_AX]
 29455                                  	; 05/05/2019
 29456                                  	; MSDOS 6.0
 29457 0000527F A1[3A03]                	mov	ax,[USER_IN_AX]
 29458 00005282 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore ds and original sp
 29459                                  	; MSDOS 3.3 & MSDOS 6.0 
 29460                                  	;transfer COMMAND
 29461                                  COMMANDJ:
 29462 00005286 E97FB0                  	JMP	COMMAND
 29463                                  
 29464                                  ; The current SP is NOT the same as the input SP. Presume that he 
 29465                                  ; RETF'd leaving some flags on the stack and examine the input
 29466                                  
 29467                                  ctrlc_try_new:
 29468 00005289 83C402                  	ADD	SP,2			; pop those flags
 29469                                  	;;test	ax,1
 29470                                  	;TEST	AX,f_Carry		; did he return with carry?
 29471 0000528C A801                    	test	al,f_Carry ; test al,1
 29472 0000528E 74EF                    	JZ	short ctrlc_repeat	; no carry set, just retry
 29473                                  
 29474                                  	; MSDOS 6.0
 29475 00005290 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore ds
 29476                                  
 29477                                  	; Well...  time to abort the user.  
 29478                                  	; Signal a ^C exit and use the EXIT system call..
 29479                                  
 29480                                  ctrlc_abort:
 29481                                  	; MSDOS 3.3
 29482                                          ;;MOV	AX,(EXIT SHL 8) + 0
 29483                                          ;MOV	AX, (EXIT*256) + 0  ; 4C00h
 29484                                  	;mov	byte [CS:DidCTRLC],0FFh ; 14/03/2018
 29485                                          ;transfer COMMAND	    ; give up by faking $EXIT
 29486                                  	;;JMP	SHORT COMMANDJ
 29487                                  	;JMP	COMMAND
 29488                                  
 29489                                  	; 05/05/2019 - Retro DOS v4.0
 29490                                  	; MSDOS 6.0
 29491 00005294 B8004C                  	MOV	AX,(EXIT<<8)+0  ; 4C00h
 29492 00005297 1E                      	push	ds
 29493                                  	;getdseg <ds>			; ds -> dosdata
 29494 00005298 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]	
 29495 0000529D C606[4D03]FF            	MOV	byte [DidCTRLC],-1 ; 0FFh
 29496 000052A2 1F                      	pop	ds
 29497                                  	;transfer COMMAND		; give up by faking $EXIT
 29498 000052A3 EBE1                    	JMP	SHORT COMMANDJ
 29499                                  	;JMP	COMMAND
 29500                                  
 29501                                  ;Break	<DIVISION OVERFLOW INTERRUPT>
 29502                                  ;----------------------------------------------------------------------------
 29503                                  ;
 29504                                  ; Procedure Name : DIVOV
 29505                                  ;
 29506                                  ; Default handler for division overflow trap
 29507                                  ;
 29508                                  ;----------------------------------------------------------------------------
 29509                                  
 29510                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29511                                  DIVOV: 
 29512                                  	; 05/05/2019 - Retro DOS v4.0
 29513                                  	; 30/07/2018
 29514                                  	; 07/07/2018 - Retro DOS v3.0
 29515 000052A5 BE[9D09]                	mov	si,DIVMES
 29516 000052A8 2E8B1E[B009]            	mov	bx,[cs:DivMesLen]
 29517                                  	;mov	ax,cs
 29518                                  	;mov	ss,ax
 29519                                  	; 05/05/2019
 29520                                  	;getdseg <ss>		; we are in an ISR, flag is CLI
 29521 000052AD 2E8E16[0700]            	mov	ss,[cs:DosDSeg]
 29522 000052B2 BC[A007]                	mov     sp,AUXSTACK
 29523                                  	;call	RealDivOv ; MSDOS 3.3
 29524 000052B5 E80200                  	call	_OUTMES ; MSDOS 6.0
 29525 000052B8 EBDA                    	jmp	short ctrlc_abort  ; Use Ctrl-C abort on divide overflow
 29526                                  
 29527                                  ; 30/07/2018
 29528                                  
 29529                                  ; MSDOS 6.0
 29530                                  ;---------------------------------------------------------------------------
 29531                                  ;
 29532                                  ; Procedure Name : OutMes
 29533                                  ;
 29534                                  ;
 29535                                  ; OutMes: perform message output
 29536                                  ; Inputs:   SS:SI points to message
 29537                                  ;	    BX has message length
 29538                                  ; Outputs:  message to BCON
 29539                                  ;
 29540                                  ;Actually, cs:si points to the message now. The segment address is filled in
 29541                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 29542                                  ;NB. This procedure is called only from DIVOV. -SR
 29543                                  ;
 29544                                  ;---------------------------------------------------------------------------
 29545                                  
 29546                                  ;MSDOS 3.3
 29547                                  ;---------------------------------------------------------------------------
 29548                                  ; RealDivOv: perform actual divide overflow stuff.
 29549                                  ; Inputs:   none
 29550                                  ; Outputs:  message to BCON
 29551                                  ;---------------------------------------------------------------------------
 29552                                  
 29553                                  	; 05/05/2019 - Retro DOS v4.0
 29554                                  	; DOSCODE:926Ch (MSDOS 6.21, MSDOS.SYS)
 29555                                  
 29556                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29557                                  	; DOSCODE:9210h (MSDOS 5.0, MSDOS.SYS)
 29558                                  
 29559                                  ;---------------------------------------------------------------------------
 29560                                  ;
 29561                                  ; Procedure Name : OutMes
 29562                                  ;
 29563                                  ; OutMes: perform message output
 29564                                  ; Inputs:   SS:SI points to message
 29565                                  ;	    BX has message length
 29566                                  ; Outputs:  message to BCON
 29567                                  ;
 29568                                  ;Actually, cs:si points to the message now. The segment address is filled in
 29569                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 29570                                  ;NB. This procedure is called only from DIVOV. -SR
 29571                                  ;
 29572                                  ;---------------------------------------------------------------------------
 29573                                  
 29574                                  	; 30/07/2018
 29575                                  	; MSDOS 6.0
 29576                                  _OUTMES:
 29577                                  	; MSDOS 3.3
 29578                                  ;RealDivOv:
 29579                                  	; 07/07/2018 - Retro DOS v3.0
 29580                                          ;Context ES
 29581 000052BA 16                      	push	ss ; 05/05/2019
 29582                                  	;PUSH	CS ; 30/07/2018		; get ES addressability
 29583 000052BB 07                      	POP	ES
 29584                                          ;Context DS
 29585 000052BC 16                      	push	ss ; 05/05/2019	
 29586                                  	;PUSH	CS ; 30/07/2018		; get DS addressability
 29587 000052BD 1F                      	POP	DS
 29588 000052BE C606[9403]08                    MOV     BYTE [DSKSTCOM],DEVWRT
 29589 000052C3 C606[9203]16                    MOV     BYTE [DSKSTCALL],DRDWRHL
 29590 000052C8 C706[9503]0000                  MOV     WORD [DSKSTST],0
 29591                                  	; BX = [DivMesLen] = 19
 29592 000052CE 891E[A403]                      MOV     [DSKSTCNT],BX
 29593 000052D2 BB[9203]                        MOV     BX,DSKSTCALL
 29594 000052D5 8936[A003]                      MOV     [DSKCHRET+1],SI		; transfer address (need an EQU)
 29595                                  	; 08/09/2018
 29596                                  	;mov	[DEVIOBUF_PTR],si
 29597                                  	; MSDOS 6.0
 29598                                  					; CS is used for string, fill in 
 29599                                  					; segment address 
 29600 000052D9 8C0E[A203]              	MOV	[DSKCHRET+3],CS
 29601                                  
 29602 000052DD C536[3200]                      LDS     SI,[BCON]
 29603 000052E1 E8ADF3                          CALL	DEVIOCALL2
 29604                                  
 29605                                  	;; 14/03/2018
 29606                                          ;;MOV	WORD [CS:DSKCHRET+1],DEVIOBUF
 29607                                  	;; 08/09/2018
 29608                                  	;mov	word [CS:DEVIOBUF_PTR],DEVIOBUF
 29609                                          ;MOV	WORD [CS:DSKSTCNT],1
 29610                                          
 29611                                  	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 29612                                  
 29613                                  	; ES still points to DOSDATA. ES is
 29614                                  					; not destroyed by deviocall2. So use
 29615                                  					; ES override.
 29616                                  
 29617 000052E4 26C706[A003][BC03]      	MOV	WORD [ES:DSKCHRET+1],DEVIOBUF
 29618 000052EB 26C706[A403]0100        	MOV	WORD [ES:DSKSTCNT],1
 29619                                  
 29620 000052F2 C3                      	RETN
 29621                                  
 29622                                  ;Break	<CHARHRD,HARDERR,ERROR -- HANDLE DISK ERRORS AND RETURN TO USER>
 29623                                  ;---------------------------------------------------------------------------
 29624                                  ;
 29625                                  ; Procedure Name : CHARHARD
 29626                                  ;
 29627                                  ;
 29628                                  ; Character device error handler
 29629                                  ; Same function as HARDERR
 29630                                  ;
 29631                                  ;---------------------------------------------------------------------------
 29632                                  
 29633                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29634                                  CHARHARD:
 29635                                  	; 05/05/2019 - Retro DOS v4.0
 29636                                  	; 30/07/2018
 29637                                  	; 08/07/2018 - Retro DOS v3.0
 29638                                  
 29639                                  	; MSDOS 6.0
 29640                                  		   			; M024 - start
 29641 000052F3 36803E[2003]00          	cmp	byte [SS:ERRORMODE], 0	; Q: are we in the middle of int 24
 29642                                  	;jne	short @f		; Y: allow fail
 29643 000052F9 750B                    	jne	short chard1
 29644                                  
 29645 000052FB 80CC10                  	OR	AH,Allowed_RETRY ; 10h	; assume ctrl p
 29646                                  
 29647 000052FE 36F606[FE02]FF          	test	byte [ss:PFLAG],-1	; Q: has ctrl p been pressed
 29648 00005304 7503                    	jnz	short ctrlp		; Y: 
 29649                                  ;@@:
 29650                                  chard1:					; M024 - end
 29651                                  	; MSDOS 6.0 & MSDOS 3.3
 29652                                  
 29653                                  ; Character device error handler
 29654                                  ; Same function as HARDERR
 29655                                  
 29656                                  	;or	ah,38h
 29657 00005306 80CC38                  	or	ah,Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL
 29658                                  ctrlp:			; SS override for Allowed and EXITHOLD
 29659 00005309 368826[4B03]            	mov	[SS:ALLOWED],ah
 29660                                  
 29661                                  	; 15/03/2018
 29662 0000530E 368C06[8205]                    MOV     [SS:EXITHOLD+2],ES
 29663 00005313 36892E[8005]                    MOV     [SS:EXITHOLD],BP
 29664 00005318 56                              PUSH    SI
 29665                                  	;and	di,0FFh
 29666 00005319 81E7FF00                        AND     DI,STECODE
 29667 0000531D 8CDD                            MOV     BP,DS                   ;Device pointer is BP:SI
 29668 0000531F E86400                          CALL    FATALC
 29669 00005322 5E                              POP     SI
 29670                                  	;return
 29671 00005323 C3                              RETN
 29672                                  
 29673                                  ;---------------------------------------------------------------------------
 29674                                  ;
 29675                                  ; Procedure Name : HardErr
 29676                                  ;
 29677                                  ; Hard disk error handler. Entry conditions:
 29678                                  ;	DS:BX = Original disk transfer address
 29679                                  ;	DX = Original logical sector number
 29680                                  ;	CX = Number of sectors to go (first one gave the error)
 29681                                  ;	AX = Hardware error code
 29682                                  ;	DI = Original sector transfer count	
 29683                                  ;	ES:BP = Base of drive parameters
 29684                                  ;	[READOP] = 0 for read, 1 for write
 29685                                  ;	Allowed Set with allowed responses to this error (other bits MUST BE 0)
 29686                                  ; Output:
 29687                                  ;	[FAILERR] will be set if user responded FAIL
 29688                                  ;
 29689                                  ;--------------------------------------------------------------------------
 29690                                  
 29691                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29692                                  HARDERR:
 29693                                  	; 05/05/2019 - Retro DOS v4.0
 29694                                  	; 30/07/2018
 29695                                  	; 08/07/2018 - Retro DOS v3.0
 29696 00005324 97                      	XCHG    AX,DI                   ; Error code in DI, count in AX
 29697                                          ;and	di,0FFh
 29698 00005325 81E7FF00                	AND     DI,STECODE              ; And off status bits
 29699                                          ;CMP	DI,WRECODE		; Write Protect Error?
 29700                                  	;cmp	di,0
 29701 00005329 83FF00                  	cmp	DI,error_I24_write_protect ; Write Protect Error?
 29702 0000532C 750A                            JNZ     short NOSETWRPERR
 29703 0000532E 50                              PUSH    AX
 29704                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29705                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 29706                                          ;;MOV	AL,[ES:BP+0]
 29707                                  	; 15/12/2022
 29708 0000532F 268A4600                	mov	al,[ES:BP]
 29709                                          	; 15/03/2018
 29710 00005333 36A2[2203]                      MOV     [SS:WPERR],AL		; Flag drive with WP error
 29711 00005337 58                              POP     AX
 29712                                  NOSETWRPERR:
 29713 00005338 29C8                            SUB     AX,CX                   ; Number of sectors successfully transferred
 29714 0000533A 01C2                            ADD     DX,AX                   ; First sector number to retry
 29715 0000533C 52                              PUSH    DX
 29716                                  	; 08/07/2018
 29717                                          ;MUL	word [ES:BP+2] 		; Number of bytes transferred
 29718 0000533D 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]
 29719 00005341 5A                              POP     DX
 29720 00005342 01C3                            ADD     BX,AX                   ; First address for retry
 29721 00005344 30E4                            XOR     AH,AH                   ; Flag disk section in error
 29722                                          ;CMP	DX,[ES:BP+6] 		; In reserved area?
 29723 00005346 263B5606                	CMP	DX,[ES:BP+DPB.FIRST_FAT]
 29724 0000534A 721A                            JB      SHORT ERRINT
 29725 0000534C FEC4                            INC     AH                      ; Flag for FAT
 29726                                          ;CMP	DX,[ES:BP+10H] ; MSDOS 3.3
 29727                                  	;cmp	dx,[ES:BP+11h] ; MSDOS 6.0 - 05/05/2019 	
 29728 0000534E 263B5611                	CMP	DX,[ES:BP+DPB.DIR_SECTOR]  ; In FAT?  
 29729 00005352 7308                    	JAE	short TESTDIR 		; No
 29730                                  		 ; Err in FAT must force recomp of freespace
 29731                                  	;mov	word [ES:BP+1Eh],-1 ; MSDOS 3.3
 29732                                  	;mov	word [ES:BP+1Fh],-1 ; MSDOS 6.0 - 05/05/2019 
 29733 00005354 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1
 29734 0000535A EB0A                    	JMP	SHORT ERRINT
 29735                                  TESTDIR:
 29736 0000535C FEC4                            INC     AH
 29737                                          ;CMP	DX,[ES:BP+0BH]		; In directory?
 29738 0000535E 263B560B                	CMP	DX,[ES:BP+DPB.FIRST_SECTOR] 
 29739 00005362 7202                            JB      SHORT ERRINT
 29740 00005364 FEC4                            INC     AH                      ; Must be in data area
 29741                                  ERRINT:
 29742 00005366 D0E4                            SHL     AH,1                    ; Make room for read/write bit
 29743 00005368 360A26[7505]                    OR      AH,[SS:READOP] ; 15/03/2018
 29744                                  
 29745                                  	; 15/08/2018
 29746                                  					; SS override for allowed and EXITHOLD
 29747 0000536D 360A26[4B03]            	OR	AH,[SS:ALLOWED]		; Set the allowed_ bits
 29748                                  
 29749                                          ;entry   FATAL
 29750                                  FATAL:
 29751                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29752                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 29753                                          ;;MOV	AL,[ES:BP+0]		; Get drive number
 29754                                  	; 15/12/2022
 29755 00005372 268A4600                	MOV	AL,[ES:BP]        
 29756                                  
 29757                                  	;entry   FATAL1
 29758                                  FATAL1:  
 29759                                  	; 15/03/2018      
 29760 00005376 368C06[8205]            	MOV     [SS:EXITHOLD+2],ES
 29761 0000537B 36892E[8005]                    MOV     [SS:EXITHOLD],BP	; The only things we preserve	
 29762                                  	;LES	SI,[ES:BP+12H] ; MSDOS 3.3
 29763                                  	;LES	SI,[ES:BP+13H] ; MSDOS 6.0 - 05/05/2019
 29764 00005380 26C47613                	LES	SI,[ES:BP+DPB.DRIVER_ADDR]
 29765 00005384 8CC5                            MOV     BP,ES                   ; BP:SI points to the device involved
 29766                                  
 29767                                  	; DI has the INT-24-style extended error. We now map the error code 
 29768                                  	; for this into the normalized get extended error set by using the 
 29769                                  	; ErrMap24 table as a translate table. Note that we translate ONLY 
 29770                                  	; the device returned codes and leave all others beyond the look up 
 29771                                  	; table alone.
 29772                                  
 29773                                  	; 08/07/2018 - Retro DOS v3.0
 29774                                  FATALC:
 29775 00005386 E89701                  	call	SET_I24_EXTENDED_ERROR
 29776                                  	;cmp	di,0Ch
 29777 00005389 83FF0C                  	CMP	DI,error_I24_gen_failure
 29778 0000538C 7603                    	JBE	short GOT_RIGHT_CODE	; Error codes above gen_failure get
 29779 0000538E BF0C00                  	MOV	DI,error_I24_gen_failure; mapped to gen_failure. Real codes
 29780                                  					;  Only come via GetExtendedError
 29781                                  ;** ----------------------------------------------------------------
 29782                                  ;
 29783                                  ; Entry point used by REDIRector on Network I 24 errors.
 29784                                  ;
 29785                                  ;	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
 29786                                  ;
 29787                                  ; ALL I 24 regs set up. ALL Extended error info SET. ALLOWED Set.
 29788                                  ;     EXITHOLD set for restore of ES:BP.
 29789                                  ; ------------------------------------------------------------------
 29790                                  	;entry	NET_I24_ENTRY
 29791                                  NET_I24_ENTRY:
 29792                                  GOT_RIGHT_CODE:
 29793 00005391 36803E[2003]00          	CMP     BYTE [SS:ERRORMODE],0	; No INT 24s if already INT 24
 29794 00005397 7404                            JZ	SHORT NoSetFail
 29795 00005399 B003                    	MOV	AL,3
 29796 0000539B EB6C                    	JMP	short FailRet
 29797                                  NoSetFail:
 29798 0000539D 368926[8805]                    MOV     [SS:CONTSTK],SP		; SS override
 29799 000053A2 16                              PUSH	SS
 29800 000053A3 07                              POP	ES
 29801                                      
 29802                                  	; Wango!!! We may need to free some user state info... In 
 29803                                  	; particular, we may have locked down a JFN for a user and he may 
 29804                                  	; NEVER return to us. Thus,we need to free it here and then 
 29805                                  	; reallocate it when we come back.
 29806                                  
 29807 000053A4 36833E[AA05]FF          	CMP	word [SS:SFN],-1 ; 0FFFFh
 29808 000053AA 740C                    	JZ	short _NoFree
 29809 000053AC 1E                      	push	ds
 29810 000053AD 56                      	push	si
 29811 000053AE 36C536[AE05]            	LDS	SI,[SS:PJFN]
 29812 000053B3 C604FF                  	MOV	BYTE [SI],0FFH
 29813 000053B6 5E                      	pop	si
 29814 000053B7 1F                      	pop	ds
 29815                                  
 29816                                  _NoFree:
 29817 000053B8 FA                      	CLI
 29818                                  					; Prepare to play with stack
 29819 000053B9 36FE06[2003]                    INC     BYTE [SS:ERRORMODE]	; Flag INT 24 in progress
 29820 000053BE 36FE0E[2103]                    DEC     BYTE [SS:INDOS]		; INT 24 handler might not return
 29821                                  
 29822                                  	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 29823                                  
 29824                                  	;; Extended Open hooks
 29825                                  					; AN000;IFS.I24 error disabled
 29826                                  	;test	byte [ss:EXTOPEN_ON],2
 29827 000053C3 36F606[F605]02          	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF 
 29828 000053C9 7404                    	JZ	short i24yes		; AN000;IFS.no
 29829                                  faili24:				; AN000;
 29830 000053CB B003                    	MOV	AL,3			; AN000;IFS.fake fail
 29831 000053CD EB29                    	JMP	short passi24 		; AN000;IFS.exit
 29832                                  i24yes: 				; AN000;
 29833                                  	;; Extended Open hooks
 29834                                  
 29835 000053CF 368E16[8605]                    MOV     SS,[SS:USER_SS]
 29836 000053D4 268B26[8405]                    MOV     SP,[ES:USER_SP]         ; User stack pointer restored
 29837                                  
 29838                                  	;;int	24h	
 29839                                          ;IN	int_fatal_abort		; Fatal error interrupt vector,
 29840                                  					; must preserve ES
 29841                                  	; 05/05/2019
 29842 000053D9 26803E[F211]00          	cmp	byte [es:DosHasHMA], 0	; Q: is dos running in HMA (M021)
 29843 000053DF 7504                    	jne	short do_low_int24	; Y: the int must be done from low mem
 29844 000053E1 CD24                    	INT	int_fatal_abort 	; Fatal error interrupt vector, 
 29845                                  					; must preserve ES
 29846 000053E3 EB05                    	jmp	short criterr_ret_addr
 29847                                  
 29848                                  do_low_int24:
 29849                                  	; 05/05/2019
 29850                                  	; MSDOS 6.0
 29851 000053E5 2EFF1E[CC50]            	call    far [cs:LowInt24Addr]
 29852                                  criterr_ret_addr:
 29853 000053EA 268926[8405]                    MOV     [ES:USER_SP],SP         ; restore our stack
 29854 000053EF 268C16[8605]                    MOV     [ES:USER_SS],SS
 29855 000053F4 8CC5                            MOV     BP,ES
 29856 000053F6 8ED5                            MOV     SS,BP
 29857                                  passi24:
 29858 000053F8 368B26[8805]                    MOV     SP,[SS:CONTSTK]
 29859 000053FD 36FE06[2103]                    INC     BYTE [SS:INDOS]		; Back in the DOS
 29860 00005402 36C606[2003]00                  MOV     BYTE [SS:ERRORMODE],0	; Back from INT 24
 29861 00005408 FB                              STI
 29862                                  FailRet:
 29863 00005409 36C42E[8005]                    LES     BP,[SS:EXITHOLD]
 29864                                  	
 29865                                  	; 08/07/2018
 29866                                  
 29867                                  	; Triage the user's reply.
 29868                                  
 29869 0000540E 3C01                    	CMP	AL,1
 29870 00005410 723D                    	JB	short CheckIgnore	; 0 => ignore
 29871 00005412 7445                    	JZ	short CheckRetry	; 1 => retry
 29872 00005414 3C03                    	CMP	AL,3			; 3 => fail
 29873 00005416 754B                    	JNZ	short DoAbort 		; 2, invalid => abort
 29874                                  
 29875                                  	; The reply was fail. See if we are allowed to fail.
 29876                                  
 29877                                  				; SS override for ALLOWED, EXTOPEN_ON, 
 29878                                  				; ALLOWED, FAILERR, WPERR, SFN, pJFN
 29879                                  	;test	byte [ss:ALLOWED],8
 29880 00005418 36F606[4B03]08          	test	byte [ss:ALLOWED],Allowed_FAIL ; Can we?
 29881 0000541E 7443                    	jz	short DoAbort	; No, do abort
 29882                                  DoFail:
 29883 00005420 B003                    	MOV	AL,3		; just in case...
 29884                                  				; AN000;EO. I24 error disabled
 29885                                  	; 05/05/2019
 29886                                  	;(MSDOS 6.0, MSCTRLC.ASM, 1991)
 29887 00005422 36F606[F605]02          	test	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
 29888 00005428 7505                    	jnz	short CleanUp 		; AN000;EO. no
 29889                                  	
 29890 0000542A 36FE06[4A03]            	inc	byte [SS:FAILERR]	; Tell everybody
 29891                                  CleanUp:
 29892 0000542F 36C606[2203]FF          	MOV	byte [SS:WPERR],-1
 29893 00005435 36833E[AA05]FF          	CMP	word [SS:SFN],-1
 29894                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29895                                  	;jnz	short CleanUp2
 29896                                  	;retn
 29897                                  	; 17/12/2022
 29898 0000543B 7411                    	jz	short Cleanup_retn ; 08/07/2018 - Retro DOS v3.0
 29899                                  CleanUp2:
 29900 0000543D 1E                      	push	ds
 29901 0000543E 56                      	push	si
 29902 0000543F 50                      	push	ax
 29903 00005440 36A1[AA05]              	MOV	AX,[ss:SFN]
 29904 00005444 36C536[AE05]            	LDS	SI,[ss:PJFN]
 29905 00005449 8804                    	MOV	[SI],AL
 29906 0000544B 58                      	pop	ax
 29907 0000544C 5E                      	pop	si
 29908 0000544D 1F                      	pop	ds
 29909                                  Cleanup_retn:
 29910 0000544E C3                      	retn
 29911                                  
 29912                                  	; The reply was IGNORE. See if we are allowed to ignore.
 29913                                  
 29914                                  CheckIgnore:
 29915                                  	;test	byte [ss:ALLOWED],20h
 29916 0000544F 36F606[4B03]20          	test	byte [ss:ALLOWED],Allowed_IGNORE ; Can we?
 29917 00005455 74C9                    	jz	short DoFail			 ; No, do fail
 29918 00005457 EBD6                    	jmp	short CleanUp
 29919                                  
 29920                                  	; The reply was RETRY. See if we are allowed to retry.
 29921                                  
 29922                                  CheckRetry:
 29923                                  	;test	byte [ss:ALLOWED],10h
 29924 00005459 36F606[4B03]10          	test	byte [ss:ALLOWED],Allowed_RETRY	; Can we?
 29925 0000545F 74BF                    	jz	short DoFail			; No, do fail
 29926 00005461 EBCC                    	JMP	short CleanUp
 29927                                  
 29928                                  	; The reply was ABORT.
 29929                                  DoAbort:
 29930 00005463 16                      	push	ss
 29931 00005464 1F                      	pop	ds
 29932                                  
 29933 00005465 803E[5703]00            	CMP	byte [CONSWAP],0
 29934 0000546A 7403                    	JZ	short NOSWAP2
 29935 0000546C E872DE                  	call	SWAPBACK
 29936                                  NOSWAP2:
 29937                                  	; See if we are to truly abort. If we are in the process of aborting, 
 29938                                  	; turn this abort into a fail.
 29939                                  
 29940                                  	;test	[fAborting],0FFh
 29941                                  	;jnz	short DoFail
 29942                                  
 29943 0000546F 803E[5903]00            	cmp	byte [fAborting],0
 29944 00005474 75AA                    	JNZ	short DoFail
 29945                                  
 29946                                  	; Set return code
 29947                                  
 29948 00005476 C606[7C05]02            	MOV	BYTE [EXIT_TYPE],EXIT_HARD_ERROR ; 2
 29949 0000547B 30C0                    	XOR	AL,AL
 29950                                  
 29951                                  	; we are truly aborting the process. Go restore information from 
 29952                                  	; the PDB as necessary.
 29953                                  
 29954 0000547D E9850D                  	jmp	exit_inner
 29955                                  
 29956                                  ;** --------------------------------------------------------------------------
 29957                                  ;
 29958                                  ; reset_environment checks the DS value against the CurrentPDB. If they are
 29959                                  ; different, then an old-style return is performed. If they are the same,
 29960                                  ; then we release jfns and restore to parent. We still use the PDB at DS:0 as
 29961                                  ; the source of the terminate addresses.
 29962                                  ;
 29963                                  ; Some subtlety: We are about to issue a bunch of calls that *may* generate
 29964                                  ; INT 24s. We *cannot* allow the user to restart the abort process; we may
 29965                                  ; end up aborting the wrong process or turn a terminate/stay/resident into a
 29966                                  ; normal abort and leave interrupt handlers around. What we do is to set a
 29967                                  ; flag that will indicate that if any abort code is seen, we just continue the
 29968                                  ; operation. In essence, we dis-allow the abort response.
 29969                                  ;
 29970                                  ; output:   none.
 29971                                  ; ----------------------------------------------------------------------------
 29972                                  
 29973                                  	;entry	reset_environment
 29974                                  	
 29975                                  reset_environment:
 29976                                  	; 30/07/2018 - Retro DOS v3.0
 29977                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 588Ah 
 29978                                  
 29979                                  ;***	invoke	Reset_Version		; AN007 ;MS. reset version number
 29980                                  
 29981 00005480 1E                      	PUSH	DS			; save PDB of process
 29982                                  
 29983                                  	; There are no critical sections in force. Although we may enter 
 29984                                  	; here with critical sections locked down, they are no longer 
 29985                                  	; relevant. We may safely free all allocated resources.
 29986                                  
 29987 00005481 B482                    	MOV	AH,82h
 29988                                  		; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
 29989                                  	;int	2Ah 	
 29990 00005483 CD2A                    	INT	int_IBM
 29991                                  
 29992                                  					; SS override
 29993 00005485 36C606[5903]FF          	MOV	byte [SS:fAborting],-1	; signal abort in progress
 29994                                  
 29995                                  					; DOS 4.00 doesn't need it
 29996                                  	;CallInstall NetResetEnvironment, MultNET, 34  
 29997                                  					; Allow REDIR to clear some stuff
 29998                                  					; On process exit.
 29999 0000548B B82211                  	mov     ax, 1122h
 30000 0000548E CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
 30001                                  			; SS = DOS CS
 30002                                  	;mov	al,22h	
 30003 00005490 B022                    	MOV	AL,int_terminate
 30004 00005492 E8FFB9                  	call	_$GET_INTERRUPT_VECTOR	; and who to go to
 30005                                  
 30006 00005495 59                      	POP	CX			; get ThisPDB
 30007 00005496 06                      	push	es
 30008 00005497 53                      	push	bx			; save return address
 30009                                  
 30010 00005498 368B1E[3003]            	MOV	BX,[SS:CurrentPDB] 	; get currentPDB
 30011 0000549D 8EDB                    	MOV	DS,BX
 30012 0000549F A11600                  	MOV	AX,[PDB.PARENT_PID]	; get parentPDB
 30013                                  
 30014                                  	; AX = parentPDB, BX = CurrentPDB, CX = ThisPDB
 30015                                  	; Only free handles if AX <> BX and BX = CX and [exit_code].upper 
 30016                                  	; is not Exit_keep_process
 30017                                  	
 30018 000054A2 39D8                    	CMP	AX,BX
 30019 000054A4 7418                    	JZ	short reset_return	; parentPDB = CurrentPDB
 30020 000054A6 39CB                    	CMP	BX,CX
 30021 000054A8 7514                    	JNZ	short reset_return	; CurrentPDB <> ThisPDB
 30022 000054AA 50                      	PUSH	AX			; save parent
 30023                                  
 30024                                  					; SS override
 30025                                  	;cmp	byte [SS:EXIT_TYPE],3
 30026 000054AB 36803E[7C05]03          	CMP	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS ; 15/08/2018
 30027 000054B1 7406                    	JZ	short reset_to_parent 	; keeping this process
 30028                                  
 30029                                  	; We are truly removing a process. Free all allocation blocks 
 30030                                  	; belonging to this PDB
 30031                                  
 30032                                  	;invoke	arena_free_process
 30033 000054B3 E8870D                  	call	arena_free_process
 30034                                  
 30035                                  	; Kill off remainder of this process. Close file handles and signal 
 30036                                  	; to relevant network folks that this process is dead. Remember that 
 30037                                  	; CurrentPDB is STILL the current process!
 30038                                  
 30039                                  	;invoke	DOS_ABORT
 30040 000054B6 E82FDA                  	call	DOS_ABORT
 30041                                  
 30042                                  reset_to_parent:
 30043                                  					; SS override
 30044 000054B9 368F06[3003]            	POP	word [SS:CurrentPDB]	; set up process as parent
 30045                                  
 30046                                  reset_return:				; come here for normal return
 30047                                  	;Context DS			; DS is used to refer to DOSDATA  
 30048 000054BE 16                      	push	ss
 30049 000054BF 1F                      	pop	ds	
 30050                                  
 30051 000054C0 B0FF                    	MOV	AL,-1
 30052                                  
 30053                                  	; make sure that everything is clean In this case ignore any errors, 
 30054                                  	; we cannot "FAIL" the abort, the program being aborted is dead.
 30055                                  
 30056                                  	;EnterCrit critDisk
 30057 000054C2 E84CBE                  	call	ECritDisk
 30058                                  	;invoke	FLUSHBUF
 30059 000054C5 E8A505                  	call	FLUSHBUF
 30060                                  	;LeaveCrit critDisk
 30061 000054C8 E861BE                  	call	LCritDisk
 30062                                  
 30063                                  	; Decrement open ref. count if we had done a virtual open earlier.
 30064                                  
 30065 000054CB E883F7                  	call	CHECK_VIRT_OPEN
 30066 000054CE FA                      	CLI
 30067 000054CF C606[2103]00            	MOV	BYTE [INDOS],0		; Go to known state
 30068 000054D4 C606[2203]FF            	MOV	BYTE [WPERR],-1		; Forget about WP error
 30069 000054D9 C606[5903]00            	MOV	byte [fAborting],0	; let aborts occur
 30070 000054DE 8F06[8005]              	POP	WORD [EXITHOLD]
 30071 000054E2 8F06[8205]              	POP	WORD [EXITHOLD+2]
 30072                                  
 30073                                  	; Snake into multitasking... Get stack from CurrentPDB person
 30074                                  
 30075 000054E6 8E1E[3003]              	MOV	DS,[CurrentPDB]
 30076 000054EA 8E163000                	MOV	SS,[PDB.USER_STACK+2]
 30077 000054EE 8B262E00                	MOV	SP,[PDB.USER_STACK]
 30078                                  
 30079 000054F2 E856AF                  	call	restore_world
 30080                                  
 30081                                  	; 05/05/2019
 30082 000054F5 07                      	pop	es ; * ; MSDOS 6.21 (DOSCODE:94A8h, MSDOS.SYS)
 30083                                  
 30084                                  	; MSDOS 6.0
 30085 000054F6 50                      	push	ax			; set up ds, but save ds in TEMPSEG 
 30086 000054F7 8CD8                    	mov	ax,ds			; and not on stack.
 30087                                  	;getdseg <ds>			; ds -> dosdata
 30088 000054F9 2E8E1E[0700]            	mov	ds,[cs:DosDSeg] 
 30089 000054FE A3[0A0D]                	mov	[TEMPSEG],ax
 30090 00005501 58                      	pop	ax
 30091                                  					; set up ds to DOSDATA
 30092                                  	;MOV	[CS:USER_SP],AX ; MSDOS 3.3
 30093 00005502 A3[8405]                	mov	[USER_SP],ax
 30094                                  
 30095 00005505 58                      	POP	AX			; suck off CS:IP of interrupt...
 30096 00005506 58                      	POP	AX
 30097 00005507 58                      	POP	AX
 30098                                  
 30099                                  ; M011 : BEGIN
 30100                                  
 30101                                  	; MSDOS 3.3
 30102                                  ;	MOV	AX,0F202h	; STI
 30103                                  
 30104                                  	; MSDOS 6.0
 30105 00005508 9F                      	LAHF
 30106 00005509 86E0                    	XCHG	AH,AL
 30107 0000550B 2402                    	AND	AL,2
 30108 0000550D B4F2                    	MOV	AH,0F2h
 30109                                  
 30110                                  ; M011 : END
 30111                                  
 30112                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30113 0000550F 50                      	PUSH	AX
 30114                                   
 30115                                  	;PUSH	word [CS:EXITHOLD+2]
 30116                                  	;PUSH	word [CS:EXITHOLD]
 30117                                  	
 30118                                  	; MSDOS 6.0
 30119 00005510 FF36[8205]              	PUSH	word [EXITHOLD+2]
 30120 00005514 FF36[8005]              	PUSH	word [EXITHOLD]
 30121                                  
 30122                                  	;MOV	AX,[CS:USER_SP]
 30123                                  
 30124                                  	; MSDOS 6.0
 30125 00005518 A1[8405]                	MOV	AX,[USER_SP]
 30126 0000551B 8E1E[0A0D]              	mov	ds,[TEMPSEG]	; restore ds
 30127                                  
 30128 0000551F CF                      	IRET			; Long return back to user terminate address
 30129                                  
 30130                                  ;---------------------------------------------------------------------------
 30131                                  ;
 30132                                  ; Procedure Name : SET_I24_EXTENDED_ERROR
 30133                                  ;
 30134                                  ; This routine handles extended error codes.
 30135                                  ; Input : DI = error code from device
 30136                                  ; Output: All EXTERR fields are set
 30137                                  ;
 30138                                  ;--------------------------------------------------------------------------
 30139                                  
 30140                                  SET_I24_EXTENDED_ERROR:
 30141 00005520 50                      	PUSH	AX
 30142                                  					; ErrMap24End is in DOSDATA
 30143 00005521 B8[BB0E]                	MOV	AX,ErrMap24End
 30144 00005524 2D[AB0E]                	SUB	AX,ErrMap24
 30145                                  					; Change to dosdata to access 
 30146                                  					; ErrMap24 and EXTERR -SR
 30147                                  	; 05/05/2019 - Retro DOS v4.0
 30148                                  	
 30149                                  	; MSDOS 6.0
 30150 00005527 1E                      	push	ds
 30151                                  	;getdseg <ds>			; ds ->dosdata
 30152 00005528 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 30153                                  
 30154                                  	; AX is the index of the first unavailable error. Do not translate 
 30155                                  	; if greater or equal to AX.
 30156                                  
 30157 0000552D 39C7                    	CMP	DI,AX
 30158 0000552F 89F8                    	MOV	AX,DI
 30159 00005531 7306                    	JAE	short NoTrans
 30160                                  
 30161                                  	;MOV	AL,[CS:DI+ErrMap24]  ; MSDOS 3.3
 30162 00005533 8A85[AB0E]              	mov	al,[ErrMap24+di] ; MSDOS 6.0
 30163 00005537 30E4                    	XOR	AH,AH
 30164                                  NoTrans:
 30165                                  	;MOV	[CS:EXTERR],AX
 30166 00005539 A3[2403]                	mov	[EXTERR],AX
 30167 0000553C 1F                      	pop	ds
 30168                                  	;assume	ds:nothing
 30169 0000553D 58                      	POP	AX
 30170                                  
 30171                                  	; Now Extended error is set correctly. Translate it to get correct 
 30172                                  	; error locus class and recommended action.
 30173                                  
 30174 0000553E 56                      	PUSH	SI
 30175                                  					; ERR_TABLE_24 is in DOSCODE 
 30176 0000553F BE[5B0E]                	MOV	SI,ERR_TABLE_24
 30177 00005542 E835B1                  	call	CAL_LK			; Set other extended error fields
 30178 00005545 5E                      	POP	SI
 30179 00005546 C3                      	retn
 30180                                  
 30181                                  ;============================================================================
 30182                                  ; FAT.ASM, MSDOS 6.0, 1991
 30183                                  ;============================================================================
 30184                                  ; 30/07/2018 - Retro DOS v3.0
 30185                                  ; 20/05/2019 - Retro DOS v4.0
 30186                                  
 30187                                  ;	TITLE	FAT - FAT maintenance routines
 30188                                  ;	NAME	FAT
 30189                                  
 30190                                  ;**	FAT.ASM
 30191                                  ;----------------------------------------------------------------------------
 30192                                  ;	Low level local device routines for performing disk change sequence,
 30193                                  ;	setting cluster validity, and manipulating the FAT
 30194                                  ;
 30195                                  ;	IsEof
 30196                                  ;	UNPACK
 30197                                  ;	PACK
 30198                                  ;	MAPCLUSTER
 30199                                  ;	FATREAD_SFT
 30200                                  ;	FATREAD_CDS
 30201                                  ;	FAT_operation
 30202                                  ;
 30203                                  ;	Revision history:
 30204                                  ;
 30205                                  ;	  AN000  version Jan. 1988
 30206                                  ;	   A001  PTM	      -- disk changed for look ahead buffers
 30207                                  ;
 30208                                  ;	M014 - if a request for pack\unpack cluster 0 is made we write\read
 30209                                  ;	       from CL0FATENTRY rather than disk.
 30210                                  
 30211                                  ; DOSCODE:94FAh (MSDOS 6.21, MSDOS.SYS)
 30212                                  
 30213                                  ;Break <IsEOF - check the quantity in BX for EOF>
 30214                                  ;----------------------------------------------------------------------------
 30215                                  ;
 30216                                  ; Procedure Name : IsEOF
 30217                                  ;
 30218                                  ; IsEOF - check the fat value in BX for eof.
 30219                                  ;
 30220                                  ;   Inputs:	ES:BP point to DPB
 30221                                  ;		BX has fat value
 30222                                  ;   Outputs:	JAE eof
 30223                                  ;   Registers modified: none
 30224                                  ;
 30225                                  ;---------------------------------------------------------------------------
 30226                                  
 30227                                  IsEOF:
 30228                                  	;cmp	word [es:bp+0Dh],0FF6h
 30229 00005547 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; is this 16 bit fat?
 30230 0000554D 730B                    	JAE	short EOF16			; yes, check for eof there
 30231                                  
 30232                                  ;J.K. 8/27/86
 30233                                  ;Modified to accept 0FF0h as an eof. This is to handle the diskfull case
 30234                                  ;of any media that has "F0"(Other) as a MediaByte.
 30235                                  ;Hopely, this does not create any side effect for those who may use any value
 30236                                  ;other than "FF8-FFF" as an EOF for their own file.
 30237                                  
 30238 0000554F 81FBF00F                	cmp	bx,0FF0h
 30239 00005553 7404                    	je	short IsEOF_other
 30240                                  
 30241 00005555 81FBF80F                	CMP	BX,0FF8h		; do the 12 bit compare
 30242                                  IsEOF_other:
 30243 00005559 C3                      	retn
 30244                                  EOF16:
 30245 0000555A 83FBF8                  	CMP	BX,0FFF8h		; 16 bit compare
 30246 0000555D C3                      	retn
 30247                                  
 30248                                  ; DOSCODE:9511h (MSDOS 6.21, MSDOS.SYS)
 30249                                  
 30250                                  ;Break	<UNPACK -- UNPACK FAT ENTRIES>
 30251                                  ;---------------------------------------------------------------------------
 30252                                  ;
 30253                                  ; Procedur Name : UNPACK
 30254                                  ;
 30255                                  ; Inputs:
 30256                                  ;	BX = Cluster number (may be full 16-bit quantity)
 30257                                  ;	ES:BP = Base of drive parameters
 30258                                  ; Outputs:
 30259                                  ;	DI = Contents of FAT for given cluster (may be full 16-bit quantity)
 30260                                  ;	Zero set means DI=0 (free cluster)
 30261                                  ;	Carry set means error (currently user FAILed to I 24)
 30262                                  ; SI Destroyed, No other registers affected. Fatal error if cluster too big.
 30263                                  ;
 30264                                  ; NOTE: if BX = 0 then DI = contents of CL0FATENTRY
 30265                                  ;
 30266                                  ;----------------------------------------------------------------------------
 30267                                  	
 30268                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30269                                  	; DOSCODE:94B5h (MSDOS 5.0, MSDOS.SYS)
 30270                                  
 30271                                  	; 20/05/2019 - Retro DOS v4.0
 30272                                  UNPACK:
 30273                                  	; MSDOS 6.0			; M014 - Start
 30274 0000555E 09DB                    	or	bx, bx			; Q: are we unpacking cluster 0
 30275 00005560 7507                    	jnz	short up_cont		; N: proceed with normal unpack
 30276 00005562 8B3E[8100]              	mov	di,[CL0FATENTRY]	; Y: return value in CL0FATENTRY
 30277 00005566 09FF                    	or	di,di 			; return z if di=0
 30278 00005568 C3                      	retn				; done
 30279                                  up_cont:				; M014 - End
 30280                                  	; MSDOS 3.3 & MSDOS 6.0
 30281                                  	;cmp	bx,[es:bp+0Dh]
 30282 00005569 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 30283 0000556D 7726                    	JA	short HURTFAT
 30284 0000556F E8D600                  	CALL	MAPCLUSTER
 30285 00005572 721E                    	jc	short _DoContext
 30286 00005574 8B3D                    	MOV	DI,[DI]
 30287 00005576 750E                    	JNZ	short High12		; MZ if high 12 bits, go get 'em
 30288 00005578 268B760D                	MOV	SI,[ES:BP+DPB.MAX_CLUSTER] ; MZ is this 16-bit fat?
 30289 0000557C 81FEF60F                	CMP	SI,4096-10
 30290 00005580 720C                    	JB	short Unpack12		; MZ No, go 'AND' off bits
 30291 00005582 09FF                    	OR	DI,DI			; MZ set zero condition code, clears carry
 30292 00005584 EB0C                    	JMP	SHORT _DoContext 	; MZ go do context
 30293                                  High12:
 30294 00005586 D1EF                    	SHR	DI,1
 30295 00005588 D1EF                    	SHR	DI,1
 30296 0000558A D1EF                    	SHR	DI,1
 30297 0000558C D1EF                    	SHR	DI,1
 30298                                  Unpack12:
 30299 0000558E 81E7FF0F                	AND	DI,0FFFh		; Clears carry
 30300                                  _DoContext:
 30301 00005592 16                      	PUSH	SS
 30302 00005593 1F                      	POP	DS
 30303 00005594 C3                      	retn
 30304                                  HURTFAT:
 30305                                  	;;mov	word [es:bp+1Eh],0FFFFh
 30306                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 30307 00005595 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; Err in FAT must force recomp of freespace
 30308 0000559B 50                      	PUSH	AX
 30309 0000559C B488                    	MOV	AH,Allowed_FAIL+80h ; 88h
 30310                                  
 30311                                  ;hkn; SS override
 30312 0000559E 36C606[4B03]08          	MOV	byte [SS:ALLOWED],Allowed_FAIL ; 8
 30313                                  ;
 30314                                  ; Signal Bad FAT to INT int_fatal_abort handler. We have an invalid cluster.
 30315                                  ;
 30316 000055A4 BFFF0F                  	MOV	DI,0FFFh		; In case INT int_fatal_abort returns (it shouldn't)
 30317 000055A7 E8C8FD                  	call	FATAL
 30318 000055AA 3C03                    	CMP	AL,3
 30319 000055AC F8                      	CLC
 30320 000055AD 7501                    	JNZ	short OKU_RET 		; Try to ignore bad FAT
 30321 000055AF F9                      	STC				; User said FAIL
 30322                                  OKU_RET:
 30323 000055B0 58                      	POP	AX
 30324                                  hurtfat_retn:
 30325 000055B1 C3                      	retn
 30326                                  
 30327                                  ; DOSCODE:9565h (MSDOS 6.21, MSDOS.SYS)
 30328                                  
 30329                                  ;Break	<PACK -- PACK FAT ENTRIES>
 30330                                  ;----------------------------------------------------------------------------
 30331                                  ;
 30332                                  ; Procedure Name : PACK
 30333                                  ;
 30334                                  ; Inputs:
 30335                                  ;	BX = Cluster number
 30336                                  ;	DX = Data
 30337                                  ;	ES:BP = Pointer to drive DPB
 30338                                  ; Outputs:
 30339                                  ;	The data is stored in the FAT at the given cluster.
 30340                                  ;	SI,DX,DI all destroyed
 30341                                  ;	Carry set means error (currently user FAILed to I 24)
 30342                                  ;	No other registers affected
 30343                                  ;
 30344                                  ; NOTE: if BX = 0 then data in DX is atored in CL0FATENTRY.
 30345                                  ;
 30346                                  ;---------------------------------------------------------------------------
 30347                                  
 30348                                  	; 02/01/2024
 30349                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30350                                  	; 20/05/2019 - Retro DOS v4.0
 30351                                  PACK:
 30352                                  	; MSDOS 6.0			; M014 - start
 30353 000055B2 09DB                    	or	bx,bx			; Q: are we packing cluster 0
 30354 000055B4 7505                    	jnz	short p_cont		; N: proceed with normal pack
 30355 000055B6 8916[8100]              	mov	[CL0FATENTRY],dx	; Y: place value in CL0FATENTRY
 30356 000055BA C3                      	retn				; done
 30357                                  p_cont:					; M014 - end
 30358                                  	; MSDOS 3.3 & MSDOS 6.0
 30359 000055BB E88A00                  	CALL	MAPCLUSTER
 30360 000055BE 72D2                    	JC	short _DoContext
 30361 000055C0 8B35                    	MOV	SI,[DI]
 30362 000055C2 740B                    	JZ	short ALIGNED 		; byte (not nibble) aligned
 30363 000055C4 51                      	PUSH	CX			; move data to upper 12 bits
 30364 000055C5 B104                    	MOV	CL,4
 30365 000055C7 D3E2                    	SHL	DX,CL
 30366 000055C9 59                      	POP	CX
 30367 000055CA 83E60F                  	AND	SI,0FH			; leave in original low 4 bits
 30368 000055CD EB14                    	JMP	SHORT PACKIN
 30369                                  ALIGNED:
 30370                                  	;cmp	word [es:bp+0Dh],0FF6h
 30371 000055CF 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ 16 bit fats?
 30372 000055D5 730A                    	JAE	short Pack16		; MZ yes, go clobber original data
 30373 000055D7 81E600F0                	AND	SI,0F000h		; MZ leave in upper 4 bits of original
 30374 000055DB 81E2FF0F                	AND	DX,0FFFh		; MZ store only 12 bits
 30375 000055DF EB02                    	JMP	SHORT PACKIN		; MZ go store
 30376                                  Pack16:
 30377 000055E1 31F6                    	XOR	SI,SI			; MZ no original data
 30378                                  PACKIN:
 30379 000055E3 09D6                    	OR	SI,DX
 30380 000055E5 8935                    	MOV	[DI],SI
 30381                                  
 30382                                  ;hkn; SS override
 30383 000055E7 36C536[E205]            	LDS	SI,[SS:CURBUF]
 30384                                  	; MSDOS 6.0
 30385 000055EC F6440540                	TEST	byte [SI+BUFFINFO.buf_flags],buf_dirty  
 30386                                  					;LB. if already dirty		  ;AN000;
 30387 000055F0 7507                    	JNZ	short yesdirty11	;LB.  don't increment dirty count ;AN000;
 30388                                  	; 10/06/2019
 30389 000055F2 E87D05                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 30390                                  	
 30391                                  	;or	byte [si+5],40h
 30392 000055F5 804C0540                	OR	byte [SI+BUFFINFO.buf_flags],buf_dirty  
 30393                                  yesdirty11:				;LB.				;AN000;
 30394                                  ;hkn; SS override
 30395 000055F9 36803E[7805]00          	CMP	BYTE [SS:CLUSSPLIT],0	; 15/08/2018
 30396                                  ;hkn; SS is DOSDATA
 30397 000055FF 16                      	push	ss
 30398 00005600 1F                      	pop	ds
 30399 00005601 74AE                    	jz	short hurtfat_retn	; Carry clear
 30400 00005603 50                      	PUSH	AX
 30401 00005604 53                      	PUSH	BX
 30402 00005605 51                      	PUSH	CX
 30403 00005606 A1[8E05]                	MOV	AX,[CLUSSAVE]
 30404 00005609 8E1E[E405]              	MOV	DS,[CURBUF+2]
 30405                                  	;;add	si,16 ; MSDOS 3.3
 30406                                  	;add	si,20 ; MSDOS 6.0
 30407 0000560D 83C614                  	ADD	SI,BUFINSIZ
 30408 00005610 8824                    	MOV	[SI],AH
 30409                                  ;hkn; SS is DOSDATA
 30410                                  	;Context DS
 30411 00005612 16                      	push	ss
 30412 00005613 1F                      	pop	ds
 30413                                  	
 30414 00005614 50                      	PUSH	AX
 30415                                  	
 30416                                  	; MSDOS 6.0
 30417 00005615 8B16[9205]              	MOV	DX,[CLUSSEC+2]		;F.C. >32mb			;AN000;
 30418 00005619 8916[0706]              	MOV	[HIGH_SECTOR],DX	;F.C. >32mb			;AN000;
 30419                                  
 30420                                  	; MSDOS 3.3 & MSDOS 6.0
 30421 0000561D 8B16[9005]              	MOV	DX,[CLUSSEC]
 30422                                  
 30423                                  	;MOV	SI,1	  ; *
 30424                                  	;XOR	AL,AL     ; *
 30425                                  	;call	GETBUFFRB ; *
 30426                                  	; 22/09/2023
 30427 00005621 E83E03                  	call	GETBUFFRA ; *
 30428                                  
 30429 00005624 58                      	POP	AX
 30430 00005625 721B                    	JC	short POPP_RET
 30431 00005627 C53E[E205]              	LDS	DI,[CURBUF]
 30432                                  	
 30433                                  	; MSDOS 6.0
 30434 0000562B F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 30435                                  					;LB. if already dirty		  ;AN000;
 30436 0000562F 7507                    	JNZ	short yesdirty12	;LB.  don't increment dirty count ;AN000;
 30437 00005631 E83E05                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 30438                                  	
 30439                                  	;or	byte [di+5],40h
 30440 00005634 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty 
 30441                                  yesdirty12:
 30442                                  	;;add	di,16
 30443                                  	;add	di,20 ; MSDOS 6.0
 30444                                  	; 02/01/2024
 30445                                  	;ADD	DI,BUFINSIZ
 30446                                  	;DEC	DI
 30447 00005638 83C713                  	add	di,BUFINSIZ-1 ; 19
 30448                                  
 30449                                  	;add	di,[es:bp+2]
 30450 0000563B 26037E02                	ADD	DI,[ES:BP+DPB.SECTOR_SIZE]
 30451 0000563F 8805                    	MOV	[DI],AL
 30452 00005641 F8                      	CLC
 30453                                  POPP_RET:
 30454 00005642 16                      	PUSH	SS
 30455 00005643 1F                      	POP	DS
 30456 00005644 59                      	POP	CX
 30457 00005645 5B                      	POP	BX
 30458 00005646 58                      	POP	AX
 30459 00005647 C3                      	retn
 30460                                  
 30461                                  ; 31/07/2018 - Retro DOS v3.0
 30462                                  
 30463                                  ;Break	<MAPCLUSTER - BUFFER A FAT SECTOR>
 30464                                  ;---------------------------------------------------------------------------
 30465                                  ;
 30466                                  ; Procedure Name : MAPCLUSTER
 30467                                  ;
 30468                                  ; Inputs:
 30469                                  ;	ES:BP Points to DPB
 30470                                  ;	BX Is cluster number
 30471                                  ; Function:
 30472                                  ;	Get a pointer to the cluster
 30473                                  ; Outputs:
 30474                                  ;	DS:DI Points to contents of FAT for given cluster
 30475                                  ;	DS:SI Points to start of buffer
 30476                                  ;	Zero Not set if cluster data is in high 12 bits of word
 30477                                  ;	Zero set if cluster data is in low 12 or 16 bits
 30478                                  ;	Carry set if failed.
 30479                                  ; SI is destroyed.
 30480                                  ;
 30481                                  ;---------------------------------------------------------------------------
 30482                                  
 30483                                  	; 20/05/2019 - Retro DOS v4.0
 30484                                  	; DOSCODE:9601h (MSDOS 6.21, MSDOS.SYS)
 30485                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30486                                  	; DOSCODE:95A5h (MSDOS 5.0, MSDOS.SYS)
 30487                                  
 30488                                  MAPCLUSTER:
 30489                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5A15h
 30490 00005648 C606[7805]00            	MOV	BYTE [CLUSSPLIT],0
 30491                                  	;SAVE	<AX,BX,CX,DX>
 30492 0000564D 50                      	push	ax
 30493 0000564E 53                      	push	bx
 30494 0000564F 51                      	push	cx
 30495 00005650 52                      	push	dx
 30496 00005651 89D8                    	MOV	AX,BX			; AX = BX
 30497 00005653 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10  ; MZ 16 bit fat?
 30498 00005659 7302                    	JAE	short Map16		; MZ yes, do 16 bit algorithm
 30499 0000565B D1E8                    	SHR	AX,1			; AX = BX/2
 30500                                  Map16:	
 30501                                  	; MSDOS 6.0			; MZ skip prev => AX=2*BX
 30502 0000565D 31FF                    	XOR	DI,DI ; *		; >32mb fat ;AN000;
 30503                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30504 0000565F 01D8                    	ADD	AX,BX			; AX = 1.5*fat = byte offset in fat
 30505 00005661 11FF                    	ADC	DI,DI ; * MSDOS 6.0	; >32mb fat ;DI is zero before op;AN000;
 30506 00005663 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE]
 30507                                  
 30508                                  ;IF FastDiv
 30509                                  ;
 30510                                  ; Gross hack: 99% of all disks have 512 bytes per sector. We test for this
 30511                                  ; case and apply a really fast algorithm to get the desired results
 30512                                  ;
 30513                                  ; Divide method takes 157+4*4=173 (MOV and DIV)
 30514                                  ; Fast method takes 39+20*4=119
 30515                                  ;
 30516                                  ; This saves a bunch.
 30517                                  
 30518 00005667 81F90002                	CMP	CX,512			; 4  Is this 512 byte sector?
 30519 0000566B 7510                    	jne	short _DoDiv		; 4  for no jump
 30520 0000566D 89C2                    	MOV	DX,AX			; 2  get set for remainder
 30521 0000566F 81E2FF01                	AND	DX,512-1		; 4  Form remainder
 30522 00005673 88E0                    	MOV	AL,AH			; 2  Quotient in formation in AL
 30523                                  	; MDOS 3.3
 30524                                  	;shr	al,1	
 30525                                  	; MDOS 6.0
 30526 00005675 D1EF                    	shr	di,1			; 2
 30527 00005677 D0D8                    	rcr	al,1			; 2
 30528                                  	; MDOS 3.3 (& MSDOS 6.0)
 30529 00005679 30E4                    	xor	ah,ah			; 3
 30530 0000567B EB04                    	jmp	short DivDone		; 16
 30531                                  _DoDiv:
 30532                                  ;ENDIF
 30533                                  	; MSDOS 3.3
 30534                                  	;xor	dx,dx
 30535                                  	; MSDOS 6.0
 30536 0000567D 89FA                    	mov	dx,di			; 2
 30537                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 30538 0000567F F7F1                    	DIV	CX			; 155 AX is FAT sector # DX is sector index
 30539                                  ;IF FastDiv
 30540                                  DivDone:
 30541                                  ;ENDIF
 30542                                  	;add	ax,[es:bp+6]
 30543 00005681 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
 30544 00005685 49                      	DEC	CX			; CX is sector size - 1
 30545                                  	;SAVE	<AX,DX,CX>
 30546 00005686 50                      	push	ax
 30547 00005687 52                      	push	dx
 30548 00005688 51                      	push	cx
 30549 00005689 89C2                    	MOV	DX,AX
 30550                                  
 30551                                  	; MSDOS 6.0
 30552                                  	; 22/09/2023
 30553                                  	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb  low sector #
 30554                                  	;
 30555                                  	; MDOS 3.3 (& MSDOS 6.0)
 30556                                  	;XOR	AL,AL	   ; *
 30557                                  	;MOV	SI,1	   ; *
 30558                                  	;;invoke GETBUFFRB ; *
 30559                                  	;call	GETBUFFRB  ; *
 30560                                  	; 22/09/2023
 30561 0000568B E8CE02                  	call	GETBUFFRC  ; *!
 30562                                  
 30563                                  	;RESTORE <CX,AX,DX>		; CX is sec siz-1, AX is offset in sec
 30564 0000568E 59                      	pop	cx
 30565 0000568F 58                      	pop	ax
 30566 00005690 5A                      	pop	dx
 30567 00005691 724C                    	JC	short MAP_POP
 30568                                  
 30569 00005693 C536[E205]              	LDS	SI,[CURBUF]
 30570                                  	;;lea	di,[si+16]
 30571                                  	;lea	di,[si+20] ; MSDOS 6.0
 30572 00005697 8D7C14                  	LEA	DI,[SI+BUFINSIZ]
 30573 0000569A 01C7                    	ADD	DI,AX
 30574 0000569C 39C8                    	CMP	AX,CX
 30575 0000569E 752C                    	JNZ	short MAPRET
 30576 000056A0 8A05                    	MOV	AL,[DI]
 30577                                  	;Context DS		 	;hkn; SS is DOSDATA
 30578 000056A2 16                      	push	ss
 30579 000056A3 1F                      	pop	ds	
 30580 000056A4 FE06[7805]              	INC	BYTE [CLUSSPLIT]
 30581 000056A8 A2[8E05]                	MOV	[CLUSSAVE],AL
 30582 000056AB 8916[9005]              	MOV	[CLUSSEC],DX
 30583                                  	; MSDOS 6.0
 30584 000056AF C706[9205]0000          	MOV	WORD [CLUSSEC+2],0      ;F.C. >32mb	;AN000;
 30585 000056B5 42                      	INC	DX
 30586                                  
 30587                                  	; 22/09/2023
 30588                                  	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb FAT sector <32mb ;AN000;
 30589                                  	;
 30590                                  	; MDOS 3.3 (& MSDOS 6.0)
 30591                                  	;XOR	AL,AL	   ; *
 30592                                  	;MOV	SI,1	   ; *
 30593                                  	;;invoke GETBUFFRB ; *
 30594                                  	;call	GETBUFFRB  ; *
 30595                                  	; 22/09/2023
 30596 000056B6 E8A302                  	call	GETBUFFRC  ; *!
 30597 000056B9 7224                    	JC	short MAP_POP
 30598                                  
 30599 000056BB C536[E205]              	LDS	SI,[CURBUF]
 30600 000056BF 8D7C14                  	LEA	DI,[SI+BUFINSIZ]
 30601 000056C2 8A05                    	MOV	AL,[DI]
 30602                                  	;Context DS			;hkn; SS is DOSDATA
 30603 000056C4 16                      	push	ss
 30604 000056C5 1F                      	pop	ds
 30605 000056C6 A2[8F05]                	MOV	[CLUSSAVE+1],AL
 30606                                  
 30607                                  ;hkn; CLUSSAVE is in DOSDATA
 30608 000056C9 BF[8E05]                	MOV	DI,CLUSSAVE
 30609                                  MAPRET:
 30610                                  	;RESTORE <DX,CX,BX>
 30611 000056CC 5A                      	pop	dx
 30612 000056CD 59                      	pop	cx
 30613 000056CE 5B                      	pop	bx
 30614 000056CF 31C0                    	XOR	AX,AX			; MZ allow shift to clear carry
 30615 000056D1 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ is this 16-bit fat?
 30616 000056D7 7302                    	JAE	short MapSet		; MZ no, set flags
 30617 000056D9 89D8                    	MOV	AX,BX
 30618                                  MapSet:
 30619 000056DB A801                    	TEST	AL,1			; set zero flag if not on boundary
 30620                                  	;RESTORE <AX>
 30621 000056DD 58                      	pop	ax
 30622 000056DE C3                      	retn
 30623                                  
 30624                                  MAP_POP:
 30625                                  	;RESTORE <DX,CX,BX,AX>
 30626 000056DF 5A                      	pop	dx
 30627 000056E0 59                      	pop	cx
 30628 000056E1 5B                      	pop	bx
 30629 000056E2 58                      	pop	ax
 30630                                  fatread_sft_retn: ; 17/12/2022
 30631 000056E3 C3                      	retn
 30632                                  
 30633                                  ; 20/05/2019 - Retro DOS v4.0
 30634                                  ; DOSCODE:96B3h (MSDOS 6.21, MSDOS.SYS)
 30635                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30636                                  ; DOSCODE:9657h (MSDOS 5.0, MSDOS.SYS)
 30637                                  
 30638                                  ;Break	<FATREAD_SFT/FATREAD_CDS -- CHECK DRIVE GET FAT>
 30639                                  ;----------------------------------------------------------------------------
 30640                                  ;
 30641                                  ; Procedure Name : FATREAD_SFT
 30642                                  ;
 30643                                  ; Inputs:
 30644                                  ;	ES:DI points to an SFT for the drive of intrest (local only,
 30645                                  ;		giving a NET SFT will produce system crashing results).
 30646                                  ;	DS DOSDATA
 30647                                  ; Function:
 30648                                  ;	Can be used by an SFT routine (like CLOSE) to invalidate buffers
 30649                                  ;	if disk changed.
 30650                                  ;	In other respects, same as FATREAD_CDS.
 30651                                  ;	(note ES:DI destroyed!)
 30652                                  ; Outputs:
 30653                                  ;	Carry set if error (currently user FAILed to I 24)
 30654                                  ; NOTE: This routine may cause FATREAD_CDS to "miss" a disk change
 30655                                  ;	as far as invalidating curdir_ID is concerned.
 30656                                  ;	Since getting a true disk changed on this call is a screw up
 30657                                  ;	anyway, that's the way it goes.
 30658                                  ;
 30659                                  ;---------------------------------------------------------------------------
 30660                                  
 30661                                  FATREAD_SFT:
 30662 000056E4 26C46D07                	LES	BP,[ES:DI+SF_ENTRY.sf_devptr]
 30663                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30664                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 30665                                  	; 15/12/2022
 30666 000056E8 268A4600                	mov	AL,[ES:BP]
 30667 000056EC A2[7605]                	MOV	[THISDRV],AL
 30668 000056EF E83CAF                  	call	GOTDPB			;Set THISDPB
 30669                                  	;CALL	FAT_GOT_DPB
 30670                                  	; 17/12/2022
 30671 000056F2 EB78                    	jmp	FAT_GOT_DPB
 30672                                  ;fatread_sft_retn:
 30673                                  	;retn
 30674                                  
 30675                                  ;----------------------------------------------------------------------------
 30676                                  ;
 30677                                  ; Procedure Name : FATREAD_CDS
 30678                                  ;
 30679                                  ; Inputs:
 30680                                  ;	DS:DOSDATA
 30681                                  ;	ES:DI points to an CDS for the drive of intrest (local only,
 30682                                  ;		giving a NET or NUL CDS will produce system crashing results).
 30683                                  ; Function:
 30684                                  ;	If disk may have been changed, media is determined and buffers are
 30685                                  ;	flagged invalid. If not, no action is taken.
 30686                                  ; Outputs:
 30687                                  ;	ES:BP = Drive parameter block
 30688                                  ;	THISDPB = ES:BP
 30689                                  ;	THISDRV set
 30690                                  ;	Carry set if error (currently user FAILed to I 24)
 30691                                  ; DS preserved , all other registers destroyed
 30692                                  ;
 30693                                  ;---------------------------------------------------------------------------
 30694                                  
 30695                                  	; 20/05/2019 - Retro DOS v4.0
 30696                                  	; DOSCODE:96C5h (MSDOS 6.21, MSDOS.SYS)
 30697                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30698                                  	; DOSCODE:9669h (MSDOS 5.0, MSDOS.SYS)
 30699                                  
 30700                                  FATREAD_CDS:
 30701 000056F4 06                      	PUSH	ES
 30702 000056F5 57                      	PUSH	DI
 30703                                  	;les	bp,[es:di+45h]
 30704 000056F6 26C46D45                	LES	BP,[ES:DI+curdir.devptr]
 30705                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30706                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 30707                                  	; 15/12/2022
 30708 000056FA 268A4600                	mov	AL,[ES:BP]
 30709 000056FE A2[7605]                	MOV	[THISDRV],AL
 30710 00005701 E82AAF                  	call	GOTDPB			;Set THISDPB
 30711 00005704 E86500                  	CALL	FAT_GOT_DPB
 30712 00005707 5F                      	POP	DI			;Get back CDS pointer
 30713 00005708 07                      	POP	ES
 30714 00005709 72D8                    	jc	short fatread_sft_retn
 30715 0000570B 7538                    	JNZ	short NO_CHANGE		;Media NOT changed
 30716                                  
 30717                                  ;	Media changed. We now need to find all CDS structures which use this
 30718                                  ;	DPB and invalidate their ID pointers.
 30719                                  
 30720                                  MED_CHANGE:
 30721 0000570D 31C0                    	XOR	AX,AX
 30722 0000570F 48                      	DEC	AX			; AX = -1
 30723 00005710 1E                      	PUSH	DS
 30724 00005711 8A0E[4700]              	MOV	CL,[CDSCOUNT]
 30725 00005715 30ED                    	XOR	CH,CH			; CX is number of structures
 30726                                  	;lds	si,[es:di+45h]
 30727 00005717 26C57545                	LDS	SI,[ES:DI+curdir.devptr] ; Find all CDS with this devptr
 30728                                  
 30729                                  ;hkn; SS override
 30730                                  
 30731                                  ;	Find all CDSs with this DevPtr
 30732                                  ;
 30733                                  ;	(ax) = -1
 30734                                  ;	(ds:si) = DevPtr
 30735                                  
 30736 0000571B 36C43E[3C00]            	LES	DI,[SS:CDSADDR]		; (es:di) = CDS pointer
 30737                                  frcd20: 
 30738                                  	;;test	word [es:di+43h],8000h
 30739                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 30740 00005720 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 30741 00005725 7518                    	JNZ	short frcd25		; Leave NET guys alone!!
 30742                                  
 30743                                  	; MSDOS 3.3
 30744                                  	;push	es
 30745                                  	;push	di
 30746                                  	;les	di,[es:di+45h]
 30747                                  	;;les	di,[ES:DI+curdir.devptr]
 30748                                  	;call	POINTCOMP
 30749                                  	;pop	di
 30750                                  	;pop	es
 30751                                  	;jnz	short frcd25
 30752                                  
 30753                                  	; MSDOS 6.0
 30754 00005727 263B7545                	cmp	si,[ES:DI+curdir.devptr]
 30755 0000572B 7512                    	jne	short frcd25		; no match
 30756 0000572D 8CDB                    	mov	bx,ds
 30757 0000572F 263B5D47                	cmp	bx,[ES:DI+curdir.devptr+2]
 30758 00005733 750A                    	jne	short frcd25		; CDS not for this drive
 30759                                  
 30760                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30761                                  	;test	[es:di+49h],ax
 30762 00005735 26854549                	test	[ES:DI+curdir.ID],AX
 30763 00005739 7404                    	JZ	short frcd25		; If root (0), leave root
 30764                                  	;mov	[es:di+49h],ax
 30765 0000573B 26894549                	MOV	[ES:DI+curdir.ID],AX	; else invalid
 30766                                  frcd25:	
 30767                                  	;;add	di,81  ; MSDOS 3.3
 30768                                  	;add	di,88  ; MSDOS 6.0	 
 30769 0000573F 83C758                  	ADD	DI,curdir.size		; Point to next CDS
 30770 00005742 E2DC                    	LOOP	frcd20
 30771 00005744 1F                      	POP	DS
 30772                                  NO_CHANGE:
 30773 00005745 C42E[8A05]              	LES	BP,[THISDPB]
 30774 00005749 F8                      	CLC
 30775 0000574A C3                      	retn
 30776                                  
 30777                                  ;Break	<Fat_Operation - miscellaneous fat stuff>
 30778                                  ;----------------------------------------------------------------------------
 30779                                  ;
 30780                                  ; Procedure Name : FAT_operation
 30781                                  ;
 30782                                  ;----------------------------------------------------------------------------
 30783                                  
 30784                                  	; 03/01/2024
 30785                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30786                                  
 30787                                  FAT_operation:
 30788                                  	; 31/07/2018 - Retro DOS v3.0
 30789                                  FATERR:
 30790                                  	;mov	word [es:bp+1Eh],-1
 30791                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
 30792 0000574B 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 
 30793                                  					; Err in FAT must force recomp of freespace
 30794                                  	;and	di,0FFh
 30795 00005751 81E7FF00                	AND	DI,STECODE		; Put error code in DI
 30796                                  	;mov	byte [ALLOWED],18h
 30797 00005755 C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 30798                                  	;mov	ah,1Ah
 30799 0000575A B41A                    	MOV	AH,2+Allowed_FAIL+Allowed_RETRY ; While trying to read FAT
 30800 0000575C A0[7605]                	MOV	AL,[THISDRV]		; Tell which drive
 30801 0000575F E814FC                  	call	FATAL1
 30802 00005762 C42E[8A05]              	LES	BP,[THISDPB]
 30803 00005766 3C03                    	CMP	AL,3
 30804 00005768 7502                    	JNZ	short FAT_GOT_DPB	; User said retry
 30805 0000576A F9                      	STC				; User said FAIL
 30806 0000576B C3                      	retn
 30807                                  
 30808                                  FAT_GOT_DPB:
 30809                                  	;Context DS			;hkn; SS is DOSDATA
 30810 0000576C 16                      	push	ss			
 30811 0000576D 1F                      	pop	ds
 30812                                  	;mov	al,0Fh
 30813 0000576E B00F                    	MOV	AL,DMEDHL
 30814                                  	;mov	ah,[es:bp+1]
 30815 00005770 268A6601                	MOV	AH,[ES:BP+DPB.UNIT] 
 30816 00005774 A3[5A03]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018 
 30817 00005777 C606[5C03]01            	MOV	BYTE [DEVCALL_REQFUNC],DEVMDCH
 30818 0000577C C706[5D03]0000          	MOV	word [DEVCALL_REQSTAT],0
 30819                                  	;;mov	al,[es:bp+16h]
 30820                                  	;mov	al,[es:bp+17h] ; MSDOS 6.0
 30821 00005782 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 30822 00005786 A2[6703]                	MOV	[CALLMED],AL
 30823 00005789 06                      	PUSH	ES
 30824 0000578A 1E                      	PUSH	DS
 30825                                  
 30826                                  ;hkn; DEVCALL is in DOSDATA
 30827 0000578B BB[5A03]                	MOV	BX,DEVCALL
 30828                                  	;;lds	si,[es:bp+12h]
 30829                                  	;lds	si,[es:bp+13h] ; MSDOS 6.0
 30830 0000578E 26C57613                	LDS	SI,[ES:BP+DPB.DRIVER_ADDR] ; DS:SI Points to device header
 30831 00005792 07                      	POP	ES			; ES:BX Points to call header
 30832 00005793 E8FBEE                  	call	DEVIOCALL2
 30833                                  	;Context DS		 	;hkn; SS is DOSDATA
 30834 00005796 16                      	push	ss
 30835 00005797 1F                      	pop	ds
 30836 00005798 07                      	POP	ES			; Restore ES:BP
 30837 00005799 8B3E[5D03]              	MOV	DI,[DEVCALL_REQSTAT]
 30838                                  	;test	di,8000h
 30839                                  	;jnz	short FATERR
 30840 0000579D 09FF                    	or	di,di
 30841 0000579F 78AA                    	js	short FATERR		; have error
 30842 000057A1 30E4                    	XOR	AH,AH
 30843                                  	;xchg	ah,[es:bp+17h] ; MSDOS 3.3
 30844                                  	;xchg	ah,[es:bp+18h] ; MSDOS 6.0
 30845 000057A3 26866618                	XCHG	AH,[ES:BP+DPB.FIRST_ACCESS] ; Reset dpb_first_access
 30846 000057A7 A0[7605]                	MOV	AL,[THISDRV]		; Use physical unit number
 30847                                  ; See if we had changed volume id by creating one on the diskette
 30848 000057AA 3806[A10A]              	cmp	[VOLCHNG_FLAG],AL
 30849 000057AE 7508                    	jnz	short CHECK_BYT
 30850 000057B0 C606[A10A]FF            	mov	byte [VOLCHNG_FLAG],-1
 30851 000057B5 E9A500                  	jmp	GOGETBPB		; Need to get device driver to read in
 30852                                  					; new volume label.
 30853                                  CHECK_BYT:
 30854 000057B8 0A26[6803]              	OR	AH,[CALLRBYT]
 30855                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 30856                                  	;JMP	short NEWDSK
 30857                                  	; 17/12/2022
 30858 000057BC 7863                    	js	short NEWDSK
 30859                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30860                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 30861                                  	;JMP	short NEWDSK
 30862                                  
 30863                                  CHECK_ZR:
 30864 000057BE 743B                    	JZ	short CHKBUFFDIRT	; jump if I don't know
 30865                                  	; 24/09/2023
 30866                                  	; cf=0 (after 'or' instruction)
 30867                                  	;CLC
 30868 000057C0 C3                      	retn				; If Media not changed (NZ)
 30869                                  
 30870                                  DISK_CHNG_ERR:
 30871 000057C1 06                      	PUSH	ES
 30872 000057C2 55                      	PUSH	BP
 30873                                  	;;les	bp,[es:bp+12h]
 30874                                  	;les	bp,[es:bp+13h] ; MSDOS 6.0
 30875 000057C3 26C46E13                	LES	BP,[ES:BP+DPB.DRIVER_ADDR] ; Get device pointer
 30876                                  	;;test	word [es:bp+4],800h
 30877                                  	;TEST	word [ES:BP+SYSDEV.ATT],DEVOPCL ; Did it set vol id?
 30878 000057C7 26F6460508              	test	byte [es:bp+SYSDEV.ATT+1],(DEVOPCL>>8)
 30879 000057CC 5D                      	POP	BP
 30880 000057CD 07                      	POP	ES
 30881 000057CE 7426                    	JZ	short FAIL_OPJ2		; Nope, FAIL
 30882 000057D0 1E                      	PUSH	DS			; Save buffer pointer for ignore
 30883 000057D1 57                      	PUSH	DI
 30884 000057D2 16                      	push	ss			;hkn; SS is DOSDATA
 30885 000057D3 1F                      	pop	ds
 30886                                  	;mov	byte [ALLOWED],18h
 30887 000057D4 C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 30888 000057D9 06                      	PUSH	ES
 30889 000057DA C43E[6903]              	LES	DI,[CALLVIDM]		; Get volume ID pointer
 30890 000057DE 8C06[2A03]              	MOV	[EXTERRPT+2],ES
 30891 000057E2 07                      	POP	ES
 30892 000057E3 893E[2803]              	MOV	[EXTERRPT],DI
 30893                                  	;mov	ax,0Fh
 30894 000057E7 B80F00                  	MOV	AX,error_I24_wrong_disk
 30895 000057EA C606[7505]01            	MOV	byte [READOP],1		; Write
 30896                                  	;invoke	HARDERR
 30897 000057EF E832FB                  	call	HARDERR
 30898 000057F2 5F                      	POP	DI			; Get back buffer for ignore
 30899 000057F3 1F                      	POP	DS
 30900 000057F4 3C03                    	CMP	AL,3
 30901                                  FAIL_OPJ2:
 30902 000057F6 741C                    	JZ	short FAIL_OP
 30903 000057F8 E971FF                  	JMP	FAT_GOT_DPB		; Retry
 30904                                  
 30905                                  CHKBUFFDIRT:
 30906                                  	; 20/05/2019 - Retro DOS v4.0
 30907                                  
 30908                                  	; MSDOS 3.3
 30909                                  	;lds	di,[BUFFHEAD]
 30910                                  
 30911                                  	; MSDOS 6.0
 30912 000057FB 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0	; any dirty buffers ? ;hkn;
 30913 00005801 741E                    	je	short NEWDSK			; no, skip the check
 30914 00005803 E8F100                  	call	GETCURHEAD			; get pointer to first buffer
 30915                                  nbuffer:
 30916                                  	;cmp	al,[di+4]
 30917 00005806 384504                  	cmp	[di+BUFFINFO.buf_ID],al	; Unit OK ?
 30918 00005809 750D                    	jne	short lfnxt			; no, go for next buffer
 30919                                  	;test   byte [di+5],40h
 30920 0000580B F6450540                	TEST	byte [di+BUFFINFO.buf_flags],buf_dirty	; is the buffer dirty ?
 30921 0000580F 7407                    	jz	short lfnxt			; no, go for next buffer
 30922                                  	;Context DS
 30923 00005811 16                      	push	ss
 30924 00005812 1F                      	pop	ds
 30925                                  	; 24/09/2023
 30926                                  	; cf=0 (after 'test' instruction)
 30927                                  	;clc
 30928 00005813 C3                      	retn
 30929                                  
 30930                                  FAIL_OP:					; This label & code is here
 30931                                  	;Context DS				;  for reachability
 30932 00005814 16                      	push	ss
 30933 00005815 1F                      	pop	ds
 30934 00005816 F9                      	STC
 30935 00005817 C3                      	retn
 30936                                  
 30937                                  lfnxt:
 30938                                  	; 15/08/2018 - Retro DOS v3.0
 30939                                  	; MSDOS 3.3
 30940                                  	;lds	di,[di]
 30941                                  
 30942                                  	; 20/05/2019 - Retro DOS v4.0
 30943 00005818 8B3D                    	mov	di,[di]
 30944                                  	;;mov	di,[di+BUFFINFO.buf_next]	; get next buffer
 30945                                  	
 30946                                  	; MSDOS 3.3
 30947                                  	;cmp	di,-1
 30948                                  	;jne	short nbuffer
 30949                                  	
 30950                                  	; MSDOS 6.0
 30951 0000581A 36393E[BB0E]            	cmp	[ss:FIRST_BUFF_ADDR],di		; is this where we started ?;hkn;
 30952 0000581F 75E5                    	jne	short nbuffer			; no, check this guy also
 30953                                  
 30954                                  ; If no dirty buffers, assume Media changed
 30955                                  NEWDSK:
 30956                                  	;;mov	word [es:bp+1Eh],0FFFFh  ; MSDOS 3.3
 30957                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 30958 00005821 26C7461FFFFF            	mov	word [ES:BP+DPB.FREE_CNT],-1	; Media changed, must
 30959                                  						;  recompute
 30960                                  	; MSDOS 3.3
 30961                                  	;call	SETVISIT
 30962                                  	; MSDOS 6.0
 30963 00005827 E8CD00                  	call	 GETCURHEAD
 30964                                  nxbuffer:
 30965                                  	; MSDOS 3.3
 30966                                  	;or 	byte [di+5],20h
 30967                                  	; MSDOS 3.3 & MSDOS 6.0
 30968                                  	;cmp	[di+4],al
 30969 0000582A 384504                  	cmp	[DI+BUFFINFO.buf_ID],al		; This drive ?
 30970 0000582D 7510                    	jne	short lfnxt2
 30971                                  	;test	byte [di+5],40h
 30972 0000582F F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 30973 00005833 758C                    	jnz	short DISK_CHNG_ERR
 30974                                  	;mov	word [di+4],20FFh
 30975 00005835 C74504FF20              	mov	word [DI+BUFFINFO.buf_ID],(buf_visit*256)+0FFh ; free up
 30976 0000583A E8CC00                  	call	SCANPLACE
 30977                                  	; MSDOS 6.0
 30978 0000583D EB02                    	jmp	short skpbuff
 30979                                  lfnxt2:
 30980 0000583F 8B3D                    	mov	di,[di]
 30981                                  	;mov	di,[di+BUFFINFO.buf_next]
 30982                                  skpbuff:
 30983                                  	; MSDOS 6.0
 30984 00005841 363B3E[BB0E]            	cmp	di,[ss:FIRST_BUFF_ADDR]					;hkn;
 30985 00005846 75E2                    	jne	short nxbuffer
 30986                                  
 30987 00005848 36833E[7700]00          	CMP	word [ss:SC_CACHE_COUNT],0 ;LB.  look ahead buffers ?	;AN001;
 30988 0000584E 740D                    	JZ	short GOGETBPB		;LB.  no			;AN001;
 30989 00005850 363A06[B00D]            	CMP	AL,[ss:CurSC_DRIVE]	;LB.  same as changed drive	;AN001;
 30990 00005855 7506                    	JNZ	short GOGETBPB		;LB.  no			;AN001;
 30991 00005857 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ;LB.  invalidate look ahead buffers ;AN000;
 30992                                  ;lfnxt2:
 30993                                  	; MSDOS 3.3
 30994                                  	;call	SKIPVISIT
 30995                                  	;jnz	short nxbuffer
 30996                                  GOGETBPB:
 30997                                  	; MSDOS 3.3 & MSDOS 6.0
 30998                                  	;;lds	di,[es:bp+12h]
 30999                                  	;lds	di,[es:bp+13h] ; MSDOS 6.0	
 31000 0000585D 26C57E13                	LDS	DI,[ES:BP+DPB.DRIVER_ADDR]
 31001                                  	; 20/05/2019
 31002                                  	;test	word [di+4],2000h
 31003                                  	;TEST	word [DI+SYSDEV.ATT],ISFATBYDEV
 31004 00005861 F6450520                	TEST	byte [DI+SYSDEV.ATT+1],(ISFATBYDEV>>8)
 31005 00005865 7510                    	JNZ	short GETFREEBUF
 31006                                  	;context DS	    		;hkn; SS is DOSDATA
 31007 00005867 16                      	push	ss
 31008 00005868 1F                      	pop	ds
 31009 00005869 BB0200                  	MOV	BX,2
 31010 0000586C E8EFFC                  	CALL	UNPACK			; Read the first FAT sector into CURBUF
 31011                                  FAIL_OPJ:
 31012 0000586F 72A3                    	JC	short FAIL_OP
 31013 00005871 C53E[E205]              	LDS	DI,[CURBUF]
 31014 00005875 EB13                    	JMP	SHORT GOTGETBUF
 31015                                  
 31016                                  GETFREEBUF:
 31017 00005877 06                      	PUSH	ES			; Get a free buffer for BIOS to use
 31018 00005878 55                      	PUSH	BP
 31019                                  	; MSDOS 3.3
 31020                                  	;LDS	DI,[SS:BUFFHEAD] ; 15/08/2018
 31021                                  	; MSDOS 6.0
 31022 00005879 31D2                    	XOR	DX,DX			;LB.  fake to get 1st	  ;AN000;
 31023                                  ;hkn; SS override
 31024 0000587B 368916[0706]            	MOV	[SS:HIGH_SECTOR],DX ; 0	;LB.  buffer addr	  ;AN000;
 31025 00005880 E87400                  	call	GETCURHEAD		;LB.			  ;AN000;
 31026                                  	; MSDOS 3.3 & MSDOS 6.0
 31027 00005883 E84F02                  	call	BUFWRITE
 31028 00005886 5D                      	POP	BP
 31029 00005887 07                      	POP	ES
 31030                                  	;JC	short FAIL_OPJ
 31031 00005888 728A                    	jc	short FAIL_OP
 31032                                  GOTGETBUF:
 31033                                  	;;add	di,16
 31034                                  	;add	di,20 ; MSDOS 6.0
 31035 0000588A 83C714                  	ADD	DI,BUFINSIZ
 31036                                  
 31037                                  ;hkn; SS override
 31038 0000588D 368C1E[6A03]            	MOV	[SS:CALLXAD+2],DS
 31039                                  	;Context DS			;hkn; SS is DOSDATA
 31040 00005892 16                      	push	ss
 31041 00005893 1F                      	pop	ds
 31042 00005894 893E[6803]              	MOV	[CALLXAD],DI
 31043                                  	;mov	al,16h
 31044 00005898 B016                    	MOV	AL,DBPBHL
 31045                                  	;mov	ah,[es:bp+1]
 31046 0000589A 268A6601                	MOV	AH,[ES:BP+DPB.UNIT]
 31047 0000589E A3[5A03]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018
 31048 000058A1 C606[5C03]02            	MOV	BYTE [DEVCALL_REQFUNC],DEVBPB
 31049 000058A6 C706[5D03]0000          	MOV	word [DEVCALL_REQSTAT],0
 31050                                  	;;mov	al,[es:bp+16h]
 31051                                  	;mov	al,[es:bp+17h]
 31052 000058AC 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 31053 000058B0 A2[6703]                	MOV	[CALLMED],AL
 31054 000058B3 06                      	PUSH	ES ; **
 31055 000058B4 1E                      	PUSH	DS ; *
 31056                                  	;;
 31057                                  ; 03/01/2023
 31058                                  %if 0
 31059                                  	;;push	word [es:bp+14h]
 31060                                  	;push	word [es:bp+15h] ; MSDOS 6.0
 31061                                  	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR+2]
 31062                                  	;;push	word [es:bp+12h]
 31063                                  	;push	word [es:bp+13h] ; MSDOS 6.0
 31064                                  	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR]
 31065                                  
 31066                                  ;hkn; DEVCALL is in DOSDATA
 31067                                  	MOV	BX,DEVCALL
 31068                                  	POP	SI
 31069                                  	POP	DS			; DS:SI Points to device header
 31070                                  %endif
 31071                                  	; 03/01/2024
 31072 000058B5 BB[5A03]                	mov	bx,DEVCALL
 31073                                  	;lds	si,[es:bp+13h]
 31074 000058B8 26C57613                	lds	si,[es:bp+DPB.DRIVER_ADDR]
 31075                                  					; DS:SI Points to device header
 31076                                  	;;
 31077 000058BC 07                      	POP	ES ; *			; ES:BX Points to call header
 31078                                  	;invoke	DEVIOCALL2
 31079 000058BD E8D1ED                  	call	DEVIOCALL2
 31080 000058C0 07                      	POP	ES ; **			; Restore ES:BP
 31081                                  	;Context DS
 31082 000058C1 16                      	push	ss		 	;hkn; SS is DOSDATA
 31083 000058C2 1F                      	pop	ds
 31084 000058C3 8B3E[5D03]              	MOV	DI,[DEVCALL_REQSTAT]
 31085                                  	; MSDOS 3.3
 31086                                  	;test	di,8000h
 31087                                  	;jnz	short FATERRJ
 31088                                  	; MSDOS 6.0
 31089 000058C7 09FF                    	or	di,di
 31090 000058C9 7829                    	js	short FATERRJ 		; have error
 31091                                  	;;mov	al,[es:bp+16h]
 31092                                  	;mov	al,[es:bp+17h]  ; MSDOS 6.0
 31093 000058CB 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 31094 000058CF C536[6C03]              	LDS	SI,[CALLBPB]
 31095                                  	;;mov	word [es:bp+1Ch],0
 31096                                  	;mov	word [es:bp+1Dh],0 ; MSDOS 6.0
 31097 000058D3 26C7461D0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 ; recycle scanning pointer
 31098                                  	;invoke	$SETDPB
 31099 000058D9 E8F7B6                  	call	_$SETDPB
 31100                                  
 31101                                  ;hkn; SS override
 31102 000058DC 36C53E[6803]            	LDS	DI,[SS:CALLXAD]		; Get back buffer pointer
 31103                                  	;mov	al,[es:bp+8]
 31104 000058E1 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]
 31105                                  
 31106                                  	; MSDOS 3.3
 31107                                  	;;mov	ah,[es:bp+0Fh]
 31108                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 31109                                  	;;mov	[DI-8],ax
 31110                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AX
 31111                                  
 31112                                  	; MSDOS 6.0
 31113                                  	;mov	[di-0Ah],al
 31114 000058E5 8845F6                  	MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AL 
 31115                                  						;>32mb		  ;AN000;
 31116                                  	;mov	ax,[es:bp+0Fh]
 31117 000058E8 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]		;>32mb
 31118                                  	;mov	[di-9h],ax			  ;AC000;
 31119 000058EC 8945F7                  	MOV	[DI+BUFFINFO.buf_wrtcntinc-BUFINSIZ],AX 
 31120                                  					;>32mb Correct buffer info ;AC000;
 31121                                  	;Context DS			;hkn; SS is DOSDATA
 31122 000058EF 16                      	push	ss
 31123 000058F0 1F                      	pop	ds
 31124 000058F1 30C0                    	XOR	AL,AL			;Media changed (Z), Carry clear
 31125 000058F3 C3                      	retn
 31126                                  
 31127                                  FATERRJ: 
 31128 000058F4 E954FE                  	JMP	FATERR
 31129                                  
 31130                                  ;============================================================================
 31131                                  ; STDBUF.ASM
 31132                                  ;============================================================================
 31133                                  ; Retro DOS v2.0 - 12/03/2018
 31134                                  
 31135                                  ;
 31136                                  ; Standard buffer management for MSDOS
 31137                                  ;
 31138                                  
 31139                                  ;.xlist
 31140                                  ;.xcref
 31141                                  ;INCLUDE STDSW.ASM
 31142                                  ;.cref
 31143                                  ;.list
 31144                                  
 31145                                  ;TITLE	STDBUF - MSDOS buffer management
 31146                                  ;NAME	STDBUF
 31147                                  
 31148                                  ;INCLUDE BUF.ASM
 31149                                  
 31150                                  ;============================================================================
 31151                                  ; BUF.ASM
 31152                                  ;============================================================================
 31153                                  ; 31/07/2018 - Retro DOS v3.0
 31154                                  ; Retro DOS v2.0 - 12/03/2018
 31155                                  ;
 31156                                  ; buffer management for MSDOS
 31157                                  ;
 31158                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 31159                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 31160                                  ;
 31161                                  ;SUBTTL SETVISIT,SKIPVISIT -- MANAGE BUFFER SCANS
 31162                                  ;
 31163                                  ;SETVISIT:
 31164                                  ;	; 31/07/2018 - Retro DOS v3.0
 31165                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CAFh
 31166                                  ;; Inputs:
 31167                                  ;;      None
 31168                                  ;; Function:
 31169                                  ;;      Set up a scan of I/O buffers
 31170                                  ;; Outputs:
 31171                                  ;;      All visit flags = 0
 31172                                  ;;              NOTE: This pre-scan is needed because a hard disk error
 31173                                  ;;                    may cause a scan to stop in the middle leaving some
 31174                                  ;;                    visit flags set, and some not set.
 31175                                  ;;      DS:DI Points to [BUFFHEAD]
 31176                                  ;; No other registers altered
 31177                                  ;
 31178                                  ;       LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 31179                                  ;	PUSH    AX
 31180                                  ;       ;;XOR	AX,AX	  ;; MSDOS 2.11
 31181                                  ;	;mov	al,0DFh
 31182                                  ;	mov	al,~buf_visit
 31183                                  ;SETLOOP:
 31184                                  ;       ;;MOV	[DI+7],AL ;; MSDOS 2.11
 31185                                  ;	;and	[DI+5],al
 31186                                  ;	AND	[DI+BUFFINFO.buf_flags],AL
 31187                                  ;       LDS     DI,[DI]
 31188                                  ;       CMP     DI,-1
 31189                                  ;       JNZ     SHORT SETLOOP
 31190                                  ;       POP     AX ; 09/09/2018
 31191                                  ;	LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 31192                                  ;SVISIT_RETN:
 31193                                  ;       RETN
 31194                                  ;
 31195                                  ;SKIPVISIT:
 31196                                  ;	; 31/07/2018 - Retro DOS v3.0
 31197                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CC8h
 31198                                  ;
 31199                                  ;; Inputs:
 31200                                  ;;      DS:DI Points to a buffer
 31201                                  ;; Function:
 31202                                  ;;      Skip visited buffers
 31203                                  ;; Outputs:
 31204                                  ;;      DS:DI Points to next unvisited buffer
 31205                                  ;;      Zero is set if skip to LAST buffer
 31206                                  ;; No other registers altered
 31207                                  ;
 31208                                  ;       CMP     DI,-1
 31209                                  ;       ;retz
 31210                                  ;       JZ	SHORT SVISIT_RETN
 31211                                  ;
 31212                                  ;	;;CMP	BYTE [DI+7],1 ;; MSDOS 2.11
 31213                                  ;       ;;;retnz
 31214                                  ;       ;;JNZ	SHORT SVISIT_RETN
 31215                                  ;
 31216                                  ;	;test	byte [di+5],20h
 31217                                  ;	TEST	byte [DI+BUFFINFO.buf_flags],buf_visit	
 31218                                  ;	JNZ	short SKIPLOOP
 31219                                  ;	
 31220                                  ;	push	ax
 31221                                  ;	or	al,1
 31222                                  ;	pop	ax
 31223                                  ;	retn	
 31224                                  ;
 31225                                  ;SKIPLOOP:
 31226                                  ;	LDS     DI,[DI]
 31227                                  ;       JMP     SHORT SKIPVISIT
 31228                                  
 31229                                  ;============================================================================
 31230                                  ; BUF.ASM, MSDOS 6.0, 1991
 31231                                  ;============================================================================
 31232                                  ; 31/07/2018 - Retro DOS v3.0
 31233                                  ; 04/05/2019 - Retro DOS v4.0
 31234                                  
 31235                                  ;	TITLE	BUF - MSDOS buffer management
 31236                                  ;	NAME	BUF
 31237                                  
 31238                                  ;**	BUF.ASM - Low level routines for buffer cache management
 31239                                  ;
 31240                                  ;	GETCURHEAD
 31241                                  ;	ScanPlace
 31242                                  ;	PLACEBUF
 31243                                  ;	PLACEHEAD
 31244                                  ;	PointComp
 31245                                  ;	GETBUFFR
 31246                                  ;	GETBUFFRB
 31247                                  ;	FlushBuf
 31248                                  ;	BufWrite
 31249                                  ;	SET_RQ_SC_PARMS
 31250                                  ;
 31251                                  ;	Revision history:
 31252                                  ;
 31253                                  ;		AN000  version 4.00  Jan. 1988
 31254                                  ;		A004   PTM 3765 -- Disk reset failed
 31255                                  ;		M039 DB 10/17/90 - Disk write optimization
 31256                                  ;		I001   5.0 PTR 722211 - Preserve CY when in buffer in HMA
 31257                                  
 31258                                  ;Break	<GETCURHEAD -- Get current buffer header>
 31259                                  ;----------------------------------------------------------------------------
 31260                                  ; Procedure Name : GetCurHead
 31261                                  ; Inputs:
 31262                                  ;	 No Inputs
 31263                                  ; Function:
 31264                                  ;	Returns the pointer to the first buffer in Queue
 31265                                  ;	and updates FIRST_BUFF_ADDR
 31266                                  ;       and invalidates LASTBUFFER (recency pointer)
 31267                                  ; Outputs:
 31268                                  ;	DS:DI = pointer to the first buffer in Queue
 31269                                  ;	FIRST_BUFF_ADDR = offset ( DI ) of First buffer in Queue
 31270                                  ;       LASTBUFFER = -1
 31271                                  ; No other registers altered
 31272                                  ;----------------------------------------------------------------------------
 31273                                  
 31274                                  ; 04/05/2019 - Retro DOS v4.0
 31275                                  ; DOSCODE:98D2h (MSDOS 6.21, MSDOS.SYS)
 31276                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31277                                  ; DOSCODE:9876h (MSDOS 5.0, MSDOS.SYS)
 31278                                  
 31279                                  GETCURHEAD:
 31280 000058F7 36C53E[6D00]            	lds	di,[ss:BufferQueue]	; Pointer to the first buffer
 31281 000058FC 36C706[1E00]FFFF        	mov	word [ss:LastBuffer],-1	; invalidate last buffer
 31282 00005903 36893E[BB0E]            	mov	[ss:FIRST_BUFF_ADDR],di	;save first buffer addr
 31283 00005908 C3                      	retn
 31284                                  
 31285                                  ;Break	<SCANPLACE, PLACEBUF -- PUT A BUFFER BACK IN THE POOL>
 31286                                  ;----------------------------------------------------------------------------
 31287                                  ; Procedure Name : ScanPlace
 31288                                  ; Inputs:
 31289                                  ;	Same as PLACEBUF
 31290                                  ; Function:
 31291                                  ;	Save scan location and call PLACEBUF
 31292                                  ; Outputs:
 31293                                  ;	DS:DI Points to saved scan location
 31294                                  ; All registers, except DS:DI, preserved.
 31295                                  ;----------------------------------------------------------------------------
 31296                                  ;M039: Rewritten to preserve registers.
 31297                                  
 31298                                  ;SCANPLACE:
 31299                                  ;	; 31/07/2018 - Retro DOS v3.0
 31300                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 31301                                  ;	push	es
 31302                                  ;	les	si,[di]
 31303                                  ;	;les	si,[DI+BUFFINFO.buf_link]
 31304                                  ;	call	PLACEBUF
 31305                                  ;	push	es
 31306                                  ;	pop	ds
 31307                                  ;	mov	di,si
 31308                                  ;	pop	es
 31309                                  ;scanplace_retn:
 31310                                  ;	retn	
 31311                                  	
 31312                                  	; MSDOS 6.0
 31313                                  SCANPLACE:
 31314 00005909 FF35                    	push	word [di]
 31315                                  	;push	word [di+BUFFINFO.buf_next] ;Save scan location
 31316 0000590B E80200                  	call	PLACEBUF
 31317 0000590E 5F                      	pop	di
 31318 0000590F C3                      	retn
 31319                                  
 31320                                  ;----------------------------------------------------------------------------
 31321                                  ; Procedure Name : PlaceBuf
 31322                                  ; Input:
 31323                                  ;	DS:DI points to buffer (DS->BUFFINFO array, DI=offset in array)
 31324                                  ; Function:
 31325                                  ;	Remove buffer from queue and re-insert it in proper place.
 31326                                  ; NO registers altered
 31327                                  ;----------------------------------------------------------------------------
 31328                                  
 31329                                  ;procedure PLACEBUF,NEAR
 31330                                  
 31331                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31332                                  	; 20/05/2019 - Retro DOS v4.0
 31333                                  PLACEBUF:
 31334                                  	; 31/07/2018 - Retro DOS v3.0
 31335                                  
 31336                                  	; MSDOS 6.0
 31337 00005910 50                      	push	AX			;Save only regs we modify	;AN000;
 31338 00005911 53                      	push	BX							;AN000;
 31339                                  	; 23/09/2023
 31340                                  	;push	SI							;AN000;
 31341                                  	
 31342 00005912 8B05                    	mov	ax,[di]
 31343                                  	;mov	ax,[di+BUFFINFO.buf_next]
 31344 00005914 368B1E[6D00]            	mov	bx,[ss:BufferQueue]	; bx = offset of head of list;smr;SS Override
 31345                                  	
 31346 00005919 39D8                    	cmp	ax,bx				;Buf = last?		;AN000;
 31347 0000591B 7422                    	je	short nret			;Yes, special case	;AN000;
 31348 0000591D 39DF                    	cmp	di,bx				;Buf = first?		;AN000;
 31349 0000591F 7506                    	jne	short not_first 		;Yes, special case	;AN000;
 31350 00005921 36A3[6D00]              	mov	[ss:BufferQueue],ax		;smr;SS Override
 31351 00005925 EB18                    	jmp	short nret 			;Continue with repositioning;AN000;
 31352                                  not_first:
 31353                                  	; 23/09/2023
 31354 00005927 56                      	push	si
 31355                                  	;mov	si,[di+2]
 31356 00005928 8B7502                  	mov	SI,[DI+BUFFINFO.buf_prev]	;No, SI = prior Buf	;AN000;
 31357 0000592B 8904                    	mov	[si],ax
 31358                                  	;mov	[SI+BUFFINFO.buf_next],AX	; ax has di->buf_next	;AN000;
 31359 0000592D 96                      	xchg	si,ax
 31360                                  	;mov	[si+2],ax
 31361 0000592E 894402                  	mov	[SI+BUFFINFO.buf_prev],AX	;			;AN000;
 31362                                  	
 31363 00005931 8B7702                  	mov	SI,[BX+BUFFINFO.buf_prev]	;SI-> last buffer	;AN000;
 31364 00005934 893C                    	mov	[si],di
 31365                                  	;mov	[SI+BUFFINFO.buf_next],DI	;Add Buf to end of list ;AN000;
 31366 00005936 897F02                  	mov	[BX+BUFFINFO.buf_prev],DI				;AN000;
 31367 00005939 897502                  	mov	[DI+BUFFINFO.buf_prev],SI	;Update link in Buf too	;AN000;
 31368 0000593C 891D                    	mov	[di],bx
 31369                                  	;mov	[DI+BUFFINFO.buf_next],BX				;AN000;
 31370                                  	; 23/09/2023
 31371 0000593E 5E                      	pop	si
 31372                                  nret:	
 31373                                  	; 23/09/2023							;AN000;
 31374                                  	;pop	SI							;AN000;
 31375 0000593F 5B                      	pop	BX							;AN000;
 31376 00005940 58                      	pop	AX							;AN000;
 31377                                  									;AN000;
 31378                                  	;cmp	byte [di+4],0FFh
 31379 00005941 807D04FF                	cmp	byte [di+BUFFINFO.buf_ID],-1	; Buffer FREE?		;AN000;
 31380 00005945 7505                            jne	short pbx			; M039: -no, jump.
 31381 00005947 36893E[6D00]            	mov	[ss:BufferQueue],di		; M039: -yes, make it LRU.
 31382                                  pbx:	
 31383 0000594C C3                      	retn								;AN000;
 31384                                  
 31385                                  	; 31/07/2018 - Retro DOS v3.0
 31386                                  
 31387                                  	; MSDOS 3.3
 31388                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 31389                                  
 31390                                  ;PLACEBUF:
 31391                                  ;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 31392                                  ;	
 31393                                  ;       CALL	save_world
 31394                                  ;       LES     CX,[DI]
 31395                                  ;       CMP     CX,-1           	; Buf is LAST?
 31396                                  ;       JZ      SHORT NRET		; Buffer already last
 31397                                  ;       MOV     BP,ES           	; Pointsave = Buf.nextbuf
 31398                                  ;       PUSH    DS
 31399                                  ;       POP     ES              	; Buf is ES:DI
 31400                                  ;	; 15/03/2018
 31401                                  ;       LDS     SI,[SS:BUFFHEAD] 	; Curbuf = HEAD
 31402                                  ;       CALL    POINTCOMP       	; Buf == HEAD?
 31403                                  ;       JNZ     SHORT BUFLOOP
 31404                                  ;       MOV     [SS:BUFFHEAD],CX
 31405                                  ;       MOV     [SS:BUFFHEAD+2],BP	; HEAD = Pointsave
 31406                                  ;       JMP     SHORT LOOKEND
 31407                                  ;BUFLOOP:
 31408                                  ;	; 31/07/2018
 31409                                  ;	mov	ax,ds
 31410                                  ;	mov	bx,si
 31411                                  ;	;lds	si,[SI+BUFFINFO.buf_link]
 31412                                  ;       LDS     SI,[SI]
 31413                                  ;       CALL    POINTCOMP
 31414                                  ;       jnz	short BUFLOOP
 31415                                  ;	;
 31416                                  ;	mov	ds,ax
 31417                                  ;	mov	si,bx
 31418                                  ;	mov	[SI],cx
 31419                                  ;	;mov	[SI+BUFFINFO.buf_link],cx   ; If Curbuf.nextbuf == buf
 31420                                  ;	mov	[SI+2],bp
 31421                                  ;	;mov	[BX+BUFFINFO.buf_link+2],bp ; Curbuf.nextbuf = Pointsave
 31422                                  ;LOOKEND:
 31423                                  ;	mov	ax,ds
 31424                                  ;	mov	bx,si
 31425                                  ;       LDS     SI,[SI]
 31426                                  ;       CMP     SI,-1
 31427                                  ;       jnz     short LOOKEND
 31428                                  ;GOTHEEND:
 31429                                  ;       mov	ds,ax
 31430                                  ;	mov	[BX],di
 31431                                  ;	MOV     [BX+2],ES 		; Curbuf.nextbuf = Buf
 31432                                  ;       MOV     WORD [ES:DI],-1
 31433                                  ;	;mov	word [ES:DI+BUFFINFO.buf_link],-1
 31434                                  ;       MOV     WORD [ES:DI+2],-1 	; Buf is LAST
 31435                                  ;	;mov	word [ES:DI+BUFFINFO.buf_link+2],-1
 31436                                  ;NRET:
 31437                                  ;       CALL	restore_world
 31438                                  ;	
 31439                                  ;	;cmp	byte [di+4],-1
 31440                                  ;	cmp	byte [DI+BUFFINFO.buf_ID],-1  ; Free buffer ?
 31441                                  ;	jnz     short scanplace_retn
 31442                                  ;	call    PLACEHEAD
 31443                                  ;	retn
 31444                                  
 31445                                  ;EndProc PLACEBUF
 31446                                  
 31447                                  ;M039 - Removed PLACEHEAD.
 31448                                  ;----------------------------------------------------------------------------
 31449                                  ; places buffer at head
 31450                                  ;  NOTE:::::: ASSUMES THAT BUFFER IS CURRENTLY THE LAST
 31451                                  ;	ONE IN THE LIST!!!!!!!
 31452                                  ; BUGBUG ---- this routine can be removed because it has only
 31453                                  ; BUGBUG ---- one instruction. This routine is called from
 31454                                  ; BUGBUG ---- 3 places. ( Size = 3*3+6 = 15 bytes )
 31455                                  ; BUGBUG ---- if coded in line = 3 * 5 = 15 bytes
 31456                                  ; BUGBUG ---- But kept as it is for modularity
 31457                                  ;----------------------------------------------------------------------------
 31458                                  ;procedure   PLACEHEAD,NEAR
 31459                                  ;	mov	word ptr [BufferQueue], di
 31460                                  ;	ret
 31461                                  ;EndProc PLACEHEAD
 31462                                  ;M039
 31463                                  
 31464                                  ;----------------------------------------------------------------------------
 31465                                  ; Procedure Name : PLACEHEAD
 31466                                  ;
 31467                                  ; SAME AS PLACEBUF except places buffer at head
 31468                                  ;----------------------------------------------------------------------------
 31469                                  
 31470                                  	; MSDOS 3.3 (Retro DOS v3.0)
 31471                                  	; 05/09/2018
 31472                                  	; MSDOS 2.11 (Retro DOS v2.0)
 31473                                  ;PLACEHEAD:
 31474                                  ;	; 31/07/2018 - Retro DOS v3.0
 31475                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D4Ah
 31476                                  ;
 31477                                  ;       CALL	save_world
 31478                                  ;       PUSH	DS
 31479                                  ;       POP	ES
 31480                                  ;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 31481                                  ;       LDS     SI,[SS:BUFFHEAD]
 31482                                  ;	; 31/07/2018 - Retro DOS v3.0 (MSDOS 3.3)
 31483                                  ;	CALL    POINTCOMP
 31484                                  ;       JZ      SHORT GOTHEEND2
 31485                                  ;	MOV	[ES:DI],SI
 31486                                  ;	;mov	[ES:DI+BUFFINFO.buf_link],si
 31487                                  ;       MOV	[ES:DI+2],DS
 31488                                  ;	;mov	[ES:DI+BUFFINFO.buf_link+2],ds
 31489                                  ;       MOV	[SS:BUFFHEAD],DI
 31490                                  ;       MOV	[SS:BUFFHEAD+2],ES
 31491                                  ;LOOKEND2:
 31492                                  ;       mov	ax,ds
 31493                                  ;	mov	bx,si
 31494                                  ;	;lds	si,[SI+BUFFINFO.buf_link]
 31495                                  ;       LDS     SI,[SI]
 31496                                  ;       CALL    POINTCOMP
 31497                                  ;       JNZ	SHORT LOOKEND2 ; 05/09/2018
 31498                                  ;       mov	ds,ax
 31499                                  ;	mov	word [bx],-1
 31500                                  ;	;mov	word [BX+BUFFINFO.buf_link],-1
 31501                                  ;	mov	word [bx+2],-1
 31502                                  ;	;mov	word [BX+BUFFINFO.buf_link+2],-1
 31503                                  ;GOTHEEND2:
 31504                                  ;      	call	restore_world
 31505                                  ;placehead_retn:
 31506                                  ;	retn
 31507                                  
 31508                                  ; 20/05/2019 - Retro DOS v4.0
 31509                                  ; DOSCODE:9928h (MSDOS 6.21, MSDOS.SYS)
 31510                                  
 31511                                  ;Break	<POINTCOMP -- 20 BIT POINTER COMPARE>
 31512                                  ;----------------------------------------------------------------------------
 31513                                  ;
 31514                                  ; Procedure Name : PointComp
 31515                                  ; Inputs:
 31516                                  ;         DS:SI & ES:DI
 31517                                  ; Function:
 31518                                  ;          Checks for ((SI==DI) && (ES==DS))
 31519                                  ;	   Assumes that pointers are normalized for the
 31520                                  ;	   same segment
 31521                                  ;
 31522                                  ; Compare DS:SI to ES:DI (or DS:DI to ES:SI) for equality
 31523                                  ; DO NOT USE FOR < or >
 31524                                  ; No Registers altered
 31525                                  ;
 31526                                  ;----------------------------------------------------------------------------
 31527                                  
 31528                                  POINTCOMP:
 31529                                  	; 31/07/2018 - Retro DOS v3.0
 31530                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D84h
 31531 0000594D 39FE                    	CMP	SI,DI
 31532 0000594F 750A                    	jnz	short _ret_label	; return if nz
 31533                                  	;jnz	short placehead_retn 
 31534 00005951 51                      	PUSH	CX
 31535 00005952 52                      	PUSH	DX
 31536 00005953 8CD9                    	MOV	CX,DS
 31537 00005955 8CC2                    	MOV	DX,ES
 31538 00005957 39D1                    	CMP	CX,DX
 31539 00005959 5A                      	POP	DX
 31540 0000595A 59                      	POP	CX
 31541                                  _ret_label:
 31542 0000595B C3                      	retn
 31543                                  
 31544                                  ; 01/08/2018 - Retro DOS v3.0
 31545                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D93h 
 31546                                  
 31547                                  ;Break	<GETBUFFR, GETBUFFRB -- GET A SECTOR INTO A BUFFER>
 31548                                  
 31549                                  ;**	GetBuffr - Get a non-FAT Sector into a Buffer
 31550                                  ;----------------------------------------------------------------------------
 31551                                  ;	GetBuffr does normal ( non-FAT ) sector buffering
 31552                                  ;	It gets the specified local sector into one of the I/O buffers
 31553                                  ;	and shuffles the queue
 31554                                  ; 
 31555                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 31556                                  ;		       ELSE no pre-read
 31557                                  ;		(DX) = Desired physical sector number	      (LOW)
 31558                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 31559                                  ;		(ES:BP) = Pointer to drive parameters
 31560                                  ;		ALLOWED set in case of INT 24
 31561                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 31562                                  ;		'C' clear if OK
 31563                                  ;		CURBUF Points to the Buffer for the sector
 31564                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 31565                                  ;	USES	AX, BX, CX, SI, DI, Flags
 31566                                  ;----------------------------------------------------------------------------
 31567                                  
 31568                                  ;**	GetBuffrb - Get a FAT Sector into a Buffer
 31569                                  ;----------------------------------------------------------------------------
 31570                                  ;	GetBuffrb reads a sector from the FAT file system's FAT table.
 31571                                  ;	It gets the specified sector into one of the I/O buffers
 31572                                  ;	and shuffles the queue. We need a special entry point so that
 31573                                  ;	we can read the alternate FAT sector if the first read fails, also
 31574                                  ;	so we can mark the buffer as a FAT sector.
 31575                                  ; 
 31576                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 31577                                  ;		       ELSE no pre-read
 31578                                  ;		(DX) = Desired physical sector number	     (LOW)
 31579                                  ;		(SI) != 0
 31580                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 31581                                  ;		(ES:BP) = Pointer to drive parameters
 31582                                  ;		ALLOWED set in case of INT 24
 31583                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 31584                                  ;		'C' clear if OK
 31585                                  ;		CUR ddBUF Points to the Buffer for the sector
 31586                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 31587                                  ;	USES	AX, BX, CX, SI, DI, Flags
 31588                                  ;----------------------------------------------------------------------------
 31589                                  
 31590                                  	; 22/09/2023 - RetroDOS v4.2 MSDOS.SYS (optimization)
 31591                                  GETBUFFRC:
 31592 0000595C C706[0706]0000          	mov	word [HIGH_SECTOR],0
 31593                                  GETBUFFRA:
 31594 00005962 30C0                    	xor	al,al
 31595 00005964 BE0100                  	mov	si,1
 31596 00005967 EB09                    	jmp	short GETBUFFRB
 31597                                  
 31598                                  	; 22/09/2023
 31599                                  GETBUFFER:
 31600 00005969 30C0                    	xor	al,al
 31601                                  GETBUFFRD:
 31602                                  	;mov	byte [ALLOWED],18h
 31603 0000596B C606[4B03]18            	mov	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 31604                                  
 31605                                  	; 20/05/2019 - Retro DOS v4.0
 31606                                  	; DOSCODE:9937h (MSDOS 6.21, MSDOS.SYS)
 31607                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31608                                  	; DOSCODE:98DBh (MSDOS 5.0, MSDOS.SYS)
 31609                                  GETBUFFR:
 31610 00005970 31F6                    	XOR	SI,SI
 31611                                  
 31612                                  ;	This entry point is called for FAT buffering with SI != 0
 31613                                  
 31614                                  GETBUFFRB:
 31615 00005972 A3[9405]                	MOV	[PREREAD],AX			; save pre-read flag
 31616                                  	; 15/12/2022
 31617 00005975 268A4600                	mov	al,[ES:BP]
 31618                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31619                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 31620 00005979 C53E[1E00]              	LDS	DI,[LastBuffer]			; Get the recency pointer
 31621                                  	; MSDOS 6.0
 31622                                  ;hkn; SS override
 31623 0000597D 368B0E[0706]            	MOV	CX,[SS:HIGH_SECTOR]		; F.C. >32mb	;AN000;
 31624                                  
 31625                                  ;	See if this is the buffer that was most recently returned.
 31626                                  ;	A big performance win if it is.
 31627                                  
 31628 00005982 83FFFF                  	CMP	DI,-1				; Recency pointer valid?
 31629 00005985 7412                    	je	short getb5			; No
 31630                                  	;cmp	dx,[di+6]
 31631 00005987 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 31632 0000598A 750D                    	JNZ	short getb5			; Wrong sector
 31633                                  	
 31634                                  	; MSDOS 6.0
 31635                                  	;cmp	cx,[di+8]
 31636 0000598C 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]	; F.C. >32mb	;AN000;
 31637 0000598F 7508                    	JNZ	short getb5			; F.C. >32mb	;AN000;
 31638                                  	
 31639                                  	;cmp	al,[di+4]
 31640 00005991 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 31641                                  	;JZ	getb35				; Just asked for same buffer
 31642 00005994 7503                    	jnz	short getb5
 31643                                  	;jmp	getb35
 31644                                  	; 17/12/2022
 31645                                  	; 28/07/2019
 31646 00005996 E9C700                  	jmp	getb35x
 31647                                  	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31648                                  	;jmp	getb35
 31649                                  
 31650                                  ;	It's not the buffer most recently returned. See if it's in the
 31651                                  ;	cache.
 31652                                  ;
 31653                                  ;	(cx:dx) = sector #
 31654                                  ;	(al) = drive #
 31655                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 31656                                  ;	??? list may be incomplete ???
 31657                                  
 31658                                  getb5:	
 31659                                  	; MSDOS 3.3
 31660                                  	;lds	di,[SS:BUFFHEAD]
 31661                                  	; MSDOS 6.0
 31662 00005999 E85BFF                  	CALL	GETCURHEAD			; get Q Head
 31663                                  getb10:	
 31664                                  	;cmp	dx,[di+6]
 31665 0000599C 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 31666 0000599F 750D                    	jne	short getb12			; wrong sector lo
 31667                                  	
 31668                                  	; MSDOS 6.0
 31669                                  	;cmp	cx,[di+8]
 31670 000059A1 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]
 31671 000059A4 7508                    	jne	short getb12			; wrong sector hi
 31672                                  	
 31673                                  	;cmp	al,[di+4]
 31674 000059A6 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 31675                                  	;je	short getb25 ; 05/09/2018	; Found the requested sector
 31676 000059A9 7503                    	jne	short getb12
 31677 000059AB E98C00                  	jmp	getb25
 31678                                  getb12:	
 31679                                  	; MSDOS 3.3
 31680                                  	;;mov	di,[DI]
 31681                                  	;;;mov	di,[DI+BUFFINFO.buf_link]
 31682                                  	;
 31683                                  	; 15/08/2018
 31684                                  	;lds	di,[di]
 31685                                  
 31686                                  	;cmp	di,-1 ; 0FFFFh
 31687                                  	;jne	short getb10
 31688                                  	;lds	di,[SS:BUFFHEAD]
 31689                                  
 31690                                  	; MSDOS 6.0
 31691 000059AE 8B3D                    	mov	di,[di]
 31692                                  	;mov	DI,[DI+BUFFINFO.BUF_NEXT]
 31693 000059B0 363B3E[BB0E]            	cmp	DI,[SS:FIRST_BUFF_ADDR]		; back at the front again?
 31694 000059B5 75E5                    	jne	short getb10			; no, continue looking
 31695                                  
 31696                                  ;	The requested sector is not available in the buffers. DS:DI now points
 31697                                  ;	to the first buffer in the Queue. Flush the first buffer & read in the
 31698                                  ;	new sector into it.
 31699                                  ;
 31700                                  ;	BUGBUG - what goes on here? Isn't the first guy the most recently
 31701                                  ;	used guy? Shuld be for fast lookup. If he is, we shouldn't take
 31702                                  ;	him, we should take LRU. And the above lookup shouldn't be
 31703                                  ;	down a chain, but should be hashed.
 31704                                  ;
 31705                                  ;	(DS:DI) = first buffer in the queue
 31706                                  ;	(CX:DX) = sector # we want
 31707                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 31708                                  
 31709                                  	; MSDOS 3.3 & MSDOS 6.0
 31710                                  ;hkn; SS override
 31711 000059B7 51                      	PUSH	CX  ; MSDOS 6.0
 31712 000059B8 56                      	push	si
 31713 000059B9 52                      	push	dx
 31714 000059BA 55                      	push	bp
 31715 000059BB 06                      	push	es
 31716 000059BC E81601                  	CALL	BUFWRITE			; Write out the dirty buffer
 31717 000059BF 07                      	pop	es
 31718 000059C0 5D                      	pop	bp
 31719 000059C1 5A                      	pop	dx
 31720 000059C2 5E                      	pop	si
 31721 000059C3 368F06[0706]            	POP	word [SS:HIGH_SECTOR]  ; MSDOS 6.0
 31722                                  	;jc	short getbx			; if got hard error
 31723 000059C8 7303                    	jnc	short getb13
 31724 000059CA E99D00                  	jmp	getbx
 31725                                  
 31726                                  getb13:
 31727                                  	; MSDOS 6.0
 31728 000059CD E88F01                  	CALL	SET_RQ_SC_PARMS 		; set parms for secondary cache
 31729                                  
 31730                                  ;	We're ready to read in the buffer, if need be. If the caller
 31731                                  ;	wanted to just *write* the buffer then we'll skip reading it in.
 31732                                  
 31733 000059D0 30E4                    	XOR	AH,AH				; initial flags
 31734                                  ;hkn; SS override
 31735                                  	;test	byte [ss:PREREAD],0FFh
 31736                                  	;jnz	short getb20
 31737 000059D2 363826[9405]            	CMP	[SS:PREREAD],ah ; 0		; am to Read in the new sector?
 31738 000059D7 7549                    	JNZ	short getb20			; no, we're done
 31739                                  	;;lea	bx,[di+16] ; MSDOS 3.3
 31740                                  	;lea	bx,[di+20] ; MSDOS 6.0
 31741 000059D9 8D5D14                  	LEA	BX,[DI+BUFINSIZ] 		; (ds:bx) = data address
 31742                                  	;MOV	CX,1
 31743                                  	; 22/09/2023
 31744 000059DC 29C9                    	sub	cx,cx ; 0
 31745 000059DE 56                      	push	si
 31746 000059DF 57                      	push	di
 31747 000059E0 52                      	push	dx
 31748                                  	; MSDOS 6.0
 31749 000059E1 06                      	push	es ; ***
 31750                                  
 31751                                  ; Note: As far as I can tell, all disk reads into buffers go through
 31752                                  ;	this point. -mrw 10/88
 31753                                  	
 31754                                  	;cmp	byte [ss:BuffInHMA],0	; is buffers in HMA?
 31755                                  	; 22/09/2023
 31756 000059E2 36380E[7900]            	cmp	[ss:BuffInHMA],cl ; 0
 31757 000059E7 7407                    	jz	short getb14
 31758 000059E9 1E                      	push	ds ; **
 31759 000059EA 53                      	push	bx ; *
 31760 000059EB 36C51E[7A00]            	lds	bx,[ss:LoMemBuff]	; Then let's read it into scratch buff
 31761                                  getb14:
 31762                                  ;M039: Eliminated redundant HMA code.
 31763                                  
 31764                                  	; 22/09/2023
 31765 000059F0 41                      	inc	cx ; cx = 1
 31766                                  
 31767                                  	; MSDOS 3.3 (& MSDOS 6.0)
 31768 000059F1 09F6                    	OR	SI,SI			; FAT sector ?
 31769 000059F3 7407                    	JZ	short getb15		
 31770                                  
 31771 000059F5 E80BDD                  	call	FATSECRD
 31772                                  	;mov	ah,2
 31773 000059F8 B402                    	MOV	AH,buf_isFAT		; Set buf_flags
 31774                                  
 31775 000059FA EB05                    	JMP	SHORT getb17		; Buffer is marked free if read barfs
 31776                                  
 31777                                  getb15:
 31778 000059FC E830DD                  	call	DREAD			; Buffer is marked free if read barfs
 31779 000059FF B400                    	MOV	AH,0			; Set buf_flags to no type, DO NOT XOR!
 31780                                  getb17:
 31781                                  	; 17/12/2022	
 31782                                  ; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31783                                  ;%if 0
 31784                                  	; MSDOS 6.0							  ;I001
 31785 00005A01 9C                      	pushf								  ;I001
 31786 00005A02 36803E[7900]00          	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ? ;I001
 31787 00005A08 7411                    	jz	short not_in_hma	; no				  ;I001
 31788                                  	;mov	cx,[es:bp+2]
 31789 00005A0A 268B4E02                	mov	cx,[ES:BP+DPB.SECTOR_SIZE]				  ;I001
 31790 00005A0E D1E9                    	shr	cx,1							  ;I001
 31791 00005A10 9D                      	popf				; Retrieve possible CY from DREAD ;I001
 31792 00005A11 89DE                    	mov	si,bx							  ;I001
 31793 00005A13 5F                      	pop	di ; *							  ;I001
 31794 00005A14 07                      	pop	es ; **							  ;I001
 31795 00005A15 FC                      	cld								  ;I001
 31796 00005A16 9C                      	pushf				; Preserve possible CY from DREAD ;I001
 31797 00005A17 F3A5                    	rep	movsw			; move the contents of scratch buf;I001
 31798 00005A19 06                      	push	es							  ;I001
 31799 00005A1A 1F                      	pop	ds							  ;I001
 31800                                  ;%endif
 31801                                  
 31802                                  ; 17/12/2022
 31803                                  %if 0
 31804                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31805                                  	; MSDOS 5.0
 31806                                  	pushf
 31807                                  	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ?
 31808                                  	jz	short not_in_hma	; no
 31809                                  	popf
 31810                                  	mov	cx,[ES:BP+DPB.SECTOR_SIZE]
 31811                                  	shr	cx,1
 31812                                  	mov	si,bx
 31813                                  	pop	di ; *
 31814                                  	pop	es ; **
 31815                                  	cld
 31816                                  	rep	movsw
 31817                                  	push	es
 31818                                  	pop	ds
 31819                                  	jmp	short getb19 ; 27/11/2022
 31820                                  %endif
 31821                                  
 31822                                  not_in_hma:								  ;I001
 31823 00005A1B 9D                      	popf							 	  ;I001
 31824                                  getb19:
 31825 00005A1C 07                      	pop	es ; ***
 31826 00005A1D 5A                      	pop	dx
 31827 00005A1E 5F                      	pop	di
 31828 00005A1F 5E                      	pop	si
 31829 00005A20 7248                    	JC	short getbx
 31830                                  
 31831                                  ;	The buffer has the data setup in it (if we were to read)
 31832                                  ;	Setup the various buffer fields
 31833                                  ;
 31834                                  ;	(ds:di) = buffer address
 31835                                  ;	(es:bp) = DPB address
 31836                                  ;	(HIGH_SECTOR:DX) = sector #
 31837                                  ;	(ah) = BUF_FLAGS value
 31838                                  ;	(si) = 0 if non fat sector, != 0 if FAT sector read
 31839                                  
 31840                                  ;hkn; SS override
 31841                                  getb20:	; MSDOS 6.0
 31842 00005A22 368B0E[0706]            	MOV	CX,[SS:HIGH_SECTOR]
 31843                                  	;mov	[di+8],cx
 31844 00005A27 894D08                  	MOV	[DI+BUFFINFO.buf_sector+2],CX
 31845                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 31846                                   	;mov	[di+6],dx
 31847 00005A2A 895506                  	MOV	[DI+BUFFINFO.buf_sector],DX
 31848                                  	;;mov	[di+0Ah],bp  ; MSDOS 3.3
 31849                                  	;mov	[di+0Dh],bp  ; MSDOS 6.0
 31850 00005A2D 896D0D                  	MOV	[DI+BUFFINFO.buf_DPB],BP
 31851                                  	;;mov	[di+0Ch],es
 31852                                  	;mov	[di+0Fh],es  ; MSDOS 6.0
 31853 00005A30 8C450F                  	MOV	[DI+BUFFINFO.buf_DPB+2],ES
 31854                                  	; 15/12/2022
 31855 00005A33 268A4600                	mov	al,[es:bp]
 31856                                  	;mov	al,[es:bp+0]
 31857                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31858                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 31859                                  	;mov	[di+4],ax
 31860 00005A37 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX		; Set ID and Flags
 31861                                  getb25:	
 31862                                  	; MSDOS 3.3
 31863                                  	;mov     ax,1
 31864                                  
 31865                                  	; MSDOS 6.0
 31866                                  	;mov	byte [di+0Ah],1
 31867 00005A3A C6450A01                	MOV	byte [DI+BUFFINFO.buf_wrtcnt],1	; Default to not a FAT sector ;AC000;
 31868 00005A3E 31C0                    	XOR	AX,AX
 31869                                  
 31870                                  	; MSDOS 3.3 (& MSDOS 6.0)
 31871 00005A40 09F6                    	OR	SI,SI				; FAT sector ?
 31872 00005A42 740B                    	JZ	short getb30
 31873                                  
 31874                                  	;mov	al,[es:bp+8]
 31875 00005A44 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]	; update number of copies of
 31876                                  	
 31877                                  	; MSDOS 6.0
 31878 00005A48 88450A                  	MOV	[DI+BUFFINFO.buf_wrtcnt],AL	;  this sector present on disk
 31879                                  	;mov	ax,[es:bp+0Fh]
 31880 00005A4B 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]		; offset of identical FAT
 31881                                  						;  sectors
 31882                                  	; MSDOS 3.3
 31883                                  	;;mov	ah,[es:bp+0Fh]
 31884                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 31885                                  
 31886                                  ;	BUGBUG - dos 6 can clean this up by not setting wrtcntinc unless wrtcnt
 31887                                  ;		is set
 31888                                  
 31889                                  getb30:	
 31890                                  	; MSDOS 6.0
 31891                                  	;mov	[di+0Bh],ax
 31892 00005A4F 89450B                  	MOV	[DI+BUFFINFO.buf_wrtcntinc],AX
 31893                                  
 31894                                  	; MSDOS 3.3
 31895                                  	;;mov	[di+8],ax ; 15/08/2018	
 31896                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt],AX
 31897                                  
 31898 00005A52 E8BBFE                  	CALL	PLACEBUF
 31899                                  
 31900                                  ;hkn; SS override for next 4
 31901                                  getb35: 
 31902                                  	; 17/12/2022
 31903                                  	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31904                                  	; MSDOS 3.3 & MSDOS 5.0 & MSDOS 6.0
 31905                                  	;MOV	[SS:CURBUF+2],DS
 31906                                  	;MOV	[SS:LastBuffer+2],DS
 31907                                  	;MOV	[SS:CURBUF],DI
 31908                                  	;MOV	[SS:LastBuffer],DI
 31909                                  	;CLC
 31910                                  
 31911                                  	; 17/12/2022
 31912                                  	; 07/12/2022
 31913                                  	; Retro DOS v4.0
 31914 00005A55 368C1E[2000]            	mov	[ss:LastBuffer+2],ds
 31915 00005A5A 36893E[1E00]            	mov	[ss:LastBuffer],di
 31916 00005A5F F8                      	clc
 31917                                  getb35x: ; 28/07/2019
 31918 00005A60 368C1E[E405]            	MOV	[ss:CURBUF+2],ds
 31919 00005A65 36893E[E205]            	MOV	[ss:CURBUF],di
 31920                                  
 31921                                  ;	Return with 'C' set appropriately
 31922                                  ;	(dx) = caller's original value
 31923                                  
 31924                                  getbx:	
 31925 00005A6A 16                      	push	ss
 31926 00005A6B 1F                      	pop	ds
 31927                                  	;retn
 31928                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31929                                  getbuffrb_retn:
 31930                                  ;flushbuf_retn:	; 17/12/2022
 31931 00005A6C C3                      	retn
 31932                                  
 31933                                  ;Break	<FLUSHBUF -- WRITE OUT DIRTY BUFFERS>
 31934                                  ;----------------------------------------------------------------------------
 31935                                  ; Input:
 31936                                  ;	DS = DOSGROUP
 31937                                  ;	AL = Physical unit number local buffers only
 31938                                  ;	   = -1 for all units and all remote buffers
 31939                                  ; Function:
 31940                                  ;	Write out all dirty buffers for unit, and flag them as clean
 31941                                  ;	Carry set if error (user FAILed to I 24)
 31942                                  ;	    Flush operation completed.
 31943                                  ; DS Preserved, all others destroyed (ES too)
 31944                                  ;----------------------------------------------------------------------------
 31945                                  
 31946                                  	; 20/05/2019 - Retro DOS v4.0
 31947                                  	; DOSCODE:9A35h (MSDOS 6.21, MSDOS.SYS)
 31948                                  
 31949                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31950                                  	; DOSCODE:99DAh (MSDOS 5.0, MSDOS.SYS)
 31951                                  FLUSHBUF:
 31952                                  	; MSDOS 3.3
 31953                                  	;;mov	ah,-1 ; 01/08/2018 - Retro DOS v3.0
 31954                                  	;lds	di,[BUFFHEAD]
 31955                                  
 31956                                  	; MSDOS 6.0
 31957 00005A6D E887FE                  	call	GETCURHEAD
 31958                                  	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 31959 00005A70 36F606[1106]04          	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
 31960 00005A76 7508                    	jnz	short scan_buf_queue
 31961 00005A78 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0			;hkn;
 31962 00005A7E 7423                    	je	short end_scan
 31963                                  	
 31964                                  scan_buf_queue:
 31965 00005A80 E82900                  	call	CHECKFLUSH
 31966                                  	;push	ax  ; MSDOS 3.3
 31967                                  	; MSDOS 6.0
 31968                                  	;mov	ah,[di+4]
 31969 00005A83 8A6504                  	mov	ah,[DI+BUFFINFO.buf_ID]
 31970 00005A86 363826[2203]            	cmp	[SS:WPERR],ah					;hkn;
 31971 00005A8B 7408                    	je	short free_the_buf
 31972                                  	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 31973 00005A8D 36F606[1106]04          	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
 31974 00005A93 7405                    	jz	short dont_free_the_buf
 31975                                  	; MSDOS 3.3
 31976                                  	;;mov	al,[di+4]
 31977                                  	;mov	al,[DI+BUFFINFO.buf_ID]
 31978                                  	;cmp	[SS:WPERR],al					;hkn;
 31979                                  	; 15/08/2018
 31980                                  	;jne	short dont_free_the_buf	
 31981                                  free_the_buf:
 31982                                  	; MSDOS 6.0 (& MSDOS 3.3)
 31983 00005A95 C74504FF00              	mov	word [DI+BUFFINFO.buf_ID],00FFh
 31984                                  dont_free_the_buf:
 31985                                  	;pop	ax  ; MSDOS 3.3 	   	
 31986                                  
 31987                                  	; MSDOS 3.3
 31988                                  	;mov	di,[DI]
 31989                                  	;;mov	di,[DI+BUFFINFO.buf_link] ; .buf_next
 31990                                  	;
 31991                                  	; 15/08/2018
 31992                                  	;lds	di,[di]
 31993                                  	;
 31994                                  	;cmp	di,-1 ; 0FFFFh
 31995                                  	;jnz	short scan_buf_queue 
 31996                                  	
 31997                                  	; MSDOS 6.0
 31998 00005A9A 8B3D                    	mov	di,[di]
 31999                                  	;mov	di,[DI+BUFFINFO.buf_next] ; .buf_link
 32000 00005A9C 363B3E[BB0E]            	cmp	di,[SS:FIRST_BUFF_ADDR]				;hkn;
 32001 00005AA1 75DD                    	jne	short scan_buf_queue
 32002                                  
 32003                                  end_scan:
 32004 00005AA3 16                      	push	ss
 32005 00005AA4 1F                      	pop	ds
 32006                                  	; 01/08/2018 - Retro DOS v3.0
 32007                                  	;cmp	byte [FAILERR],0
 32008                                  	;jne	short bad_flush
 32009                                  	;retn
 32010                                  ;bad_flush:
 32011                                  	;stc
 32012                                  	;retn
 32013                                  
 32014                                  	; 17/12/2022
 32015                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32016                                  	; 01/08/2018 - Retro DOS v3.0
 32017 00005AA5 803E[4A03]01            	cmp	byte [FAILERR],1
 32018 00005AAA F5                      	cmc
 32019                                  flushbuf_retn:
 32020 00005AAB C3                      	retn
 32021                                  	
 32022                                  	; 17/12/2022
 32023                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32024                                  	;cmp	byte [FAILERR],0
 32025                                  	;jne	short bad_flush
 32026                                  	;retn
 32027                                  ;bad_flush:
 32028                                  	;stc
 32029                                  	;retn
 32030                                  
 32031                                  ;----------------------------------------------------------------------------
 32032                                  ;
 32033                                  ; Procedure Name : CHECKFLUSH
 32034                                  ;
 32035                                  ; Inputs : AL - Drive number, -1 means do not check for drive
 32036                                  ;	   DS:DI - pointer to buffer
 32037                                  ;
 32038                                  ; Function : Write out a buffer if it is dirty
 32039                                  ;
 32040                                  ; Carry set if problem (currently user FAILed to I 24)
 32041                                  ;
 32042                                  ;----------------------------------------------------------------------------
 32043                                  
 32044                                  CHECKFLUSH:
 32045                                  	; MSDOS 6.0
 32046 00005AAC B4FF                    	mov	ah,-1	; 01/08/2018 Retro DOS v3.0
 32047                                  	;cmp	[di+4],ah
 32048 00005AAE 386504                  	CMP	[DI+BUFFINFO.buf_ID],AH
 32049 00005AB1 74F8                    	jz	short flushbuf_retn	; Skip free buffer, carry clear
 32050 00005AB3 38C4                    	CMP	AH,AL			; 
 32051 00005AB5 7406                    	JZ	short DOBUFFER		; do this buffer
 32052                                  	;cmp	al,[di+4]
 32053 00005AB7 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 32054 00005ABA F8                      	CLC
 32055 00005ABB 75EE                    	jnz	short flushbuf_retn	; Buffer not for this unit or SFT
 32056                                  DOBUFFER:
 32057                                  	;test	byte [di+5],40h
 32058 00005ABD F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 32059 00005AC1 74E8                    	jz	short flushbuf_retn	; Buffer not dirty, carry clear by TEST
 32060 00005AC3 50                      	PUSH	AX
 32061                                  	;push	word [di+4]
 32062 00005AC4 FF7504                  	PUSH	WORD [DI+BUFFINFO.buf_ID]
 32063 00005AC7 E80B00                  	CALL	BUFWRITE
 32064 00005ACA 58                      	POP	AX
 32065 00005ACB 7206                    	JC	short LEAVE_BUF		; Leave buffer marked free (lost).
 32066                                  	;and	ah,0BFh
 32067 00005ACD 80E4BF                  	AND	AH,~buf_dirty		; Buffer is clean, clears carry
 32068                                  	;mov	[di+4],ax
 32069 00005AD0 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX
 32070                                  LEAVE_BUF:
 32071 00005AD3 58                      	POP	AX			; Search info
 32072                                  checkflush_retn:
 32073 00005AD4 C3                      	retn
 32074                                  
 32075                                  ;Break	<BUFWRITE -- WRITE OUT A BUFFER IF DIRTY>
 32076                                  ;----------------------------------------------------------------------------
 32077                                  ;
 32078                                  ;	BufWrite writes a buffer to the disk, if it's dirty.
 32079                                  ;
 32080                                  ;	ENTRY	DS:DI Points to the buffer
 32081                                  ;
 32082                                  ;	EXIT	Buffer marked free
 32083                                  ;		Carry set if error (currently user FAILed to I 24)
 32084                                  ;
 32085                                  ;	USES	All buf DS:DI
 32086                                  ;		HIGH_SECTOR
 32087                                  ;----------------------------------------------------------------------------
 32088                                  
 32089                                  	; 20/05/2019 - Retro DOS v4.0
 32090                                  	; DOSCODE:9AA0h (MSDOS 6.21, MSDOS.SYS)
 32091                                  
 32092                                  
 32093                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32094                                  	; DOSCODE:9A45h (MSDOS 5.0, MSDOS.SYS)
 32095                                  
 32096                                  BUFWRITE:
 32097                                  	; 10/09/2018
 32098                                  	; 01/08/2018 - Retro DOS v3.0
 32099                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E94h
 32100 00005AD5 B8FF00                  	MOV	AX,00FFH
 32101                                  	;xchg	ax,[di+4]
 32102 00005AD8 874504                  	XCHG	AX,[DI+BUFFINFO.buf_ID]	; Free, in case write barfs
 32103 00005ADB 3CFF                    	CMP	AL,0FFH
 32104 00005ADD 74F5                    	jz      short checkflush_retn	; Buffer is free, carry clear.
 32105                                  	;test	ah,40h
 32106 00005ADF F6C440                  	test	AH,buf_dirty
 32107 00005AE2 74F0                    	jz      short checkflush_retn	; Buffer is clean, carry clear.
 32108                                  	; MSDOS 6.0
 32109 00005AE4 E89100                  	call	DEC_DIRTY_COUNT 	; LB. decrement dirty count
 32110                                  
 32111                                  ;hkn; SS override
 32112 00005AE7 363A06[2203]            	CMP	AL,[SS:WPERR]
 32113 00005AEC 74E6                    	jz      short checkflush_retn	; If in WP error zap buffer
 32114                                  
 32115                                  ;hkn; SS override
 32116                                  	; MSDOS 6.0
 32117 00005AEE 36A2[AF0D]              	MOV	[SS:SC_DRIVE],AL	;LB. set it for invalidation ;AN000;
 32118                                  	
 32119                                  	;;les	bp,[di+10] ; MSDOS 3.3
 32120                                  	;les	bp,[di+13] ; MSDOS 6.0
 32121 00005AF2 C46D0D                  	LES	BP,[DI+BUFFINFO.buf_DPB]
 32122                                  	;;lea	bx,[di+16]
 32123                                  	;lea	bx,[di+20] ; MSDOS 6.0
 32124 00005AF5 8D5D14                  	LEA	BX,[DI+BUFINSIZ]	; Point at buffer
 32125                                  	;mov	dx,[di+6]
 32126 00005AF8 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector] ;F.C. >32mb		;AN000;
 32127                                  	
 32128                                  	; MSDOS 6.0
 32129                                  	;mov	cx,[di+8]
 32130 00005AFB 8B4D08                  	MOV	CX,[DI+BUFFINFO.buf_sector+2] ;F.C. >32mb	;AN000;
 32131                                  
 32132                                  ;hkn; SS override
 32133 00005AFE 36890E[0706]            	MOV	[SS:HIGH_SECTOR],CX	;F.C. >32mb		;AN000;
 32134 00005B03 8A4D0A                  	MOV	CL,[DI+BUFFINFO.buf_wrtcnt] ;>32mb		;AC000;
 32135                                  	; MSDOS 3.3
 32136                                  	;; mov	cx,[DI+8]
 32137                                  	;mov	cx,[DI+BUFFINFO.buf_wrtcnt]
 32138                                  	;MOV	AL,CH			; [DI+BUFFINFO.buf_wrtcntinc]
 32139 00005B06 30ED                    	XOR	CH,CH
 32140                                  	;;mov	ah,ch ; MSDOS 3.3
 32141                                  
 32142                                  ;hkn; SS override for ALLOWED
 32143                                  	;mov	byte [SS:ALLOWED],18h
 32144 00005B08 36C606[4B03]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 32145                                  	;test	byte [di+5],8
 32146                                  	; MSDOS 6.0 (& Retro DOS 3.0)
 32147                                  	;test	ah,8
 32148 00005B0E F6C408                  	test	AH,buf_isDATA
 32149 00005B11 7406                    	JZ	short NO_IGNORE
 32150                                  	;or	byte [SS:ALLOWED],20h
 32151 00005B13 36800E[4B03]20          	OR	byte [SS:ALLOWED],Allowed_IGNORE
 32152                                  NO_IGNORE:
 32153                                  	;xor	ah,ah ; 10/09/2018 (MSDOS 3.3, Retro DOS v3.0)
 32154                                  	; MSDOS 6.0
 32155                                  	;mov	ax,[di+11]
 32156 00005B19 8B450B                  	MOV	AX,[DI+BUFFINFO.buf_wrtcntinc]	;>32mb		;AC000;
 32157                                  
 32158 00005B1C 57                      	PUSH	DI		; Save buffer pointer
 32159 00005B1D 31FF                    	XOR	DI,DI		; Indicate failure
 32160                                  
 32161 00005B1F 1E                      	push	ds ; *
 32162 00005B20 53                      	push	bx ; **
 32163                                  WRTAGAIN:
 32164 00005B21 57                      	push	di ; ***
 32165 00005B22 51                      	push	cx ; ****
 32166 00005B23 50                      	push	ax ; *****
 32167                                  	;MOV	CX,1
 32168                                  	; 17/12/2022
 32169                                  	; ch = 0
 32170 00005B24 B101                    	mov	cl,1 ; 24/07/2019
 32171                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32172                                  	;mov	cx,1
 32173 00005B26 53                      	push	bx ; ******
 32174 00005B27 52                      	push	dx ; *******
 32175 00005B28 1E                      	push	ds ; ********
 32176                                  
 32177                                  ; Note: As far as I can tell, all disk reads into buffers go through this point. -mrw 10/88
 32178                                  
 32179                                  	; MSDOS 6.0
 32180                                  	;cmp	byte [ss:BuffInHMA],0 ; 10/06/2019
 32181                                  	; 22/09/2023
 32182 00005B29 36382E[7900]            	cmp	[ss:BuffInHMA],ch ; 0
 32183 00005B2E 7418                    	jz	short NBUFFINHMA
 32184 00005B30 51                      	push	cx
 32185 00005B31 06                      	push	es
 32186 00005B32 89DE                    	mov	si,bx
 32187 00005B34 268B4E02                	mov	cx,[es:bp+DPB.SECTOR_SIZE]
 32188 00005B38 D1E9                    	shr	cx,1
 32189 00005B3A 36C43E[7A00]            	les	di,[ss:LoMemBuff] ; 10/06/2019
 32190 00005B3F 89FB                    	mov	bx,di
 32191 00005B41 FC                      	cld
 32192 00005B42 F3A5                    	rep	movsw
 32193 00005B44 06                      	push	es
 32194 00005B45 1F                      	pop	ds
 32195 00005B46 07                      	pop	es
 32196 00005B47 59                      	pop	cx
 32197                                  NBUFFINHMA:
 32198 00005B48 E844DC                  	call	DWRITE		; Write out the dirty buffer
 32199 00005B4B 1F                      	pop	ds ; ********
 32200 00005B4C 5A                      	pop	dx ; *******
 32201 00005B4D 5B                      	pop	bx ; ******
 32202 00005B4E 58                      	pop	ax ; *****
 32203 00005B4F 59                      	pop	cx ; ****
 32204 00005B50 5F                      	pop	di ; ***
 32205 00005B51 7201                    	JC	short NOSET
 32206 00005B53 47                      	INC	DI		; If at least ONE write succeedes, the operation
 32207                                  NOSET:				;	succeedes.
 32208 00005B54 01C2                    	ADD	DX,AX
 32209 00005B56 E2C9                    	LOOP	WRTAGAIN
 32210 00005B58 5B                      	pop	bx ; **
 32211 00005B59 1F                      	pop	ds ; *
 32212                                  	;OR	DI,DI		; Clears carry
 32213                                  	;JNZ	short BWROK	; At least one write worked
 32214                                  	;STC			; DI never got INCed, all writes failed.
 32215                                  	; 22/09/2023
 32216 00005B5A 83FF01                  	cmp	di,1
 32217                                  BWROK:	
 32218 00005B5D 5F                      	POP	DI
 32219 00005B5E C3                      	retn
 32220                                  
 32221                                  ;**	Set_RQ_SC_Parms - Set Secondary Cache Parameters
 32222                                  ;----------------------------------------------------------------------------
 32223                                  ;	Set_RQ_SC_Parms sets the sector size and drive number value
 32224                                  ;	for the secondary cache. This updates SC_SECTOR_SIZE &
 32225                                  ;	SC_DRIVE even if SC is disabled to save the testing
 32226                                  ;	code and time
 32227                                  ;
 32228                                  ;	ENTRY	ES:BP = drive parameter block
 32229                                  ;
 32230                                  ;	EXIT	[SC_SECTOR_SIZE]= drive sector size
 32231                                  ;		[SC_DRIVE]= drive #
 32232                                  ;
 32233                                  ;	USES	Flags
 32234                                  ;----------------------------------------------------------------------------
 32235                                  
 32236                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32237                                  ; 04/05/2019 - Retro DOS v4.0
 32238                                  
 32239                                  SET_RQ_SC_PARMS:
 32240                                  ;hkn; SS override for all variables used in this procedure.
 32241 00005B5F 50                      	push	ax
 32242                                  	;mov	ax,[es:bp+2]
 32243 00005B60 268B4602                	MOV	ax,[ES:BP+DPB.SECTOR_SIZE]	; save sector size
 32244 00005B64 36A3[AD0D]              	MOV	[ss:SC_SECTOR_SIZE],ax
 32245                                  	;;mov	al,[es:bp+0]
 32246                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32247                                  	;MOV	al,[ES:BP+DPB.DRIVE]		; save drive #
 32248                                  	; 15/12/2022
 32249 00005B68 268A4600                	mov	al,[ES:BP]
 32250 00005B6C 36A2[AF0D]              	MOV	[ss:SC_DRIVE],al
 32251 00005B70 58                      	pop	ax
 32252                                  srspx:	
 32253 00005B71 C3                      	retn					;LB. return
 32254                                  
 32255                                  ;Break	<INC_DIRTY_COUNT-increment dirty count>
 32256                                  ;----------------------------------------------------------------------------
 32257                                  ; Input:
 32258                                  ;	none
 32259                                  ; Function:
 32260                                  ;	increment dirty buffers count
 32261                                  ; Output:
 32262                                  ;	dirty buffers count is incremented
 32263                                  ;
 32264                                  ; All registers preserved
 32265                                  ;----------------------------------------------------------------------------
 32266                                  
 32267                                  INC_DIRTY_COUNT:
 32268                                  ;; BUGBUG  ---- remove this routine
 32269                                  ;; BUGBUG ---- only one instruction is needed (speed win, space loose)
 32270 00005B72 36FF06[7100]            	inc	word [ss:DirtyBufferCount]	;hkn;
 32271 00005B77 C3                      	retn
 32272                                  
 32273                                  ;Break	<DEC_DIRTY_COUNT-decrement dirty count>
 32274                                  ;----------------------------------------------------------------------------
 32275                                  ; Input:
 32276                                  ;	none
 32277                                  ; Function:
 32278                                  ;	decrement dirty buffers count
 32279                                  ; Output:
 32280                                  ;	dirty buffers count is decremented
 32281                                  ;
 32282                                  ; All registers preserved
 32283                                  ;----------------------------------------------------------------------------
 32284                                  
 32285                                  DEC_DIRTY_COUNT:
 32286 00005B78 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0 ;hkn;
 32287 00005B7E 7405                    	jz	short ddcx		; BUGBUG - shouldn't it be an
 32288 00005B80 36FF0E[7100]            	dec	word [ss:DirtyBufferCount] 
 32289                                  					; error condition to underflow here? ;hkn;
 32290                                  ddcx:	
 32291 00005B85 C3                      	retn
 32292                                  
 32293                                  ;============================================================================
 32294                                  ; MSPROC.ASM, MSDOS 6.0, 1992
 32295                                  ;============================================================================
 32296                                  ; 02/08/2018 - Retro DOS v3.0
 32297                                  ; 29/04/2019 - Retro DOS v4.0
 32298                                  
 32299                                  ; (15/04/2018 - RetrO DOS v2.0, MSDOS 2.11 - PROC.ASM - 1983)
 32300                                  
 32301                                  ; Pseudo EXEC system call for DOS
 32302                                  
 32303                                  ;	TITLE	MSPROC - process maintenance
 32304                                  ;	NAME	MSPROC
 32305                                  
 32306                                  ; =========================================================================
 32307                                  ;**	Process related system calls and low level routines for DOS 2.X.
 32308                                  ;	I/O specs are defined in DISPATCH.
 32309                                  ;
 32310                                  ;	$WAIT
 32311                                  ;	$EXEC
 32312                                  ;	$Keep_process
 32313                                  ;	Stay_resident
 32314                                  ;	$EXIT
 32315                                  ;	$ABORT
 32316                                  ;	abort_inner
 32317                                  ;
 32318                                  ;	Modification history:
 32319                                  ;
 32320                                  ;		Created: ARR 30 March 1983
 32321                                  ;		AN000	version 4.0 jan. 1988
 32322                                  ;		A007	PTM 3957 - fake vesrion for IBMCACHE.COM
 32323                                  ;		A008	PTM 4070 - fake version for MS WINDOWS
 32324                                  ;
 32325                                  ;		M000	added support for loading programs into UMBs 7/9/90
 32326                                  ;
 32327                                  ;		M004 - MS PASCAL 3.2 support. Please see under tag M003 in 
 32328                                  ;		       dossym.inc. 7/30/90
 32329                                  ;		M005 - Support for EXE programs with out STACK segment and 
 32330                                  ;		       with resident size < 64K - 256 bytes. A 256 byte 
 32331                                  ;		       stack is provided at the end of the program. Note that
 32332                                  ;		       only SP is changed.
 32333                                  ;		M020 - Fix for Rational bug for details see exepatch.asm
 32334                                  ;
 32335                                  ;		M028 - 4b04 implementation
 32336                                  ;
 32337                                  ;		M029 - Support for EXEs without stack rewritten. If EXE is
 32338                                  ;			in memory block >= 64K, sp = 0. If memory block
 32339                                  ;			obtained is <64K, point sp at the end of the memory
 32340                                  ;			block. For EXEs smaller than 64K, 256 bytes are still
 32341                                  ;			added for a stack segment which may be needed if it
 32342                                  ;			is loaded in low memory situations.
 32343                                  ;
 32344                                  ;		M030 - Fixing bug in EXEPACPATCH & changing 4b04 to 4b05
 32345                                  ;
 32346                                  ;		M040 - Bug #3052. The environment sizing code would flag a
 32347                                  ;			a bad environment if it reached 32767 bytes. Changed
 32348                                  ;			to allow 32768 bytes of environment.
 32349                                  ;
 32350                                  ;		M047 - Release the allocated UMB when we failed to load a 
 32351                                  ;		       COM file high. Also ensure that if the biggest block
 32352                                  ;		       into which we load the com file is less than 64K then
 32353                                  ;		       we provide atleast 256 bytes of stack to the user.
 32354                                  ;
 32355                                  ;		M050 - Made Lie table search CASE insensitive
 32356                                  ;
 32357                                  ;		M060 - Removed special version table from the kernal and
 32358                                  ;                      put it in a device drive which puts the address
 32359                                  ;                      in the DOS DATA area location UU_IFS_DOS_CALL
 32360                                  ;		       as a DWORD.
 32361                                  ;
 32362                                  ;		M063 - Modified UMB support. If the HIGH_ONLY bit is set on
 32363                                  ;		       entry do not try to load low if there is no space in
 32364                                  ;		       UMBs.
 32365                                  ;
 32366                                  ;		M068 - Support for copy protect apps. Call ChkCopyProt to 
 32367                                  ;		       set a20off_count. Set bit EXECA20BIT in DOS_FLAG. Also
 32368                                  ;		       change return address to LeaveDos if AL=5.
 32369                                  ;
 32370                                  ;               20-Jul-1992 bens  Added ifdef RESTRICTED_BUILD code that
 32371                                  ;                      controls building a version of MSDOS.SYS that only
 32372                                  ;                      runs programs from a fixed list (defined in the
 32373                                  ;                      file RESTRICT.INC).  Search for "RESTRICTED_BUILD"
 32374                                  ;                      for details.  This feature is used to build a
 32375                                  ;                      "special" version of DOS that can be handed out to
 32376                                  ;                      OEM/ISV customers as part of a "service" disk.
 32377                                  ;
 32378                                  ; =========================================================================
 32379                                  
 32380                                  ;SAVEXIT  EQU  10
 32381                                  
 32382                                  ;BREAK	<$WAIT - return previous process error code>
 32383                                  ; =========================================================================
 32384                                  ;	$WAIT - Return previous process error code.
 32385                                  ;
 32386                                  ;	Assembler usage:
 32387                                  ;
 32388                                  ;	    MOV     AH, WaitProcess
 32389                                  ;	    INT     int_command
 32390                                  ;
 32391                                  ;	ENTRY	none
 32392                                  ;	EXIT	(ax) = exit code
 32393                                  ;	USES	all
 32394                                  ; =========================================================================
 32395                                  
 32396                                  	; 20/05/2019 - Retro DOS v4.0
 32397                                  	; DOSCODE:9B55h (MSDOS 6.21, MSDOS.SYS)
 32398                                  
 32399                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32400                                  	; DOSCODE:9A5Ah (MSDOS 5.0, MSDOS.SYS)	
 32401                                  _$WAIT:
 32402                                  	; 02/08/2018 - Retro DOS v3.0
 32403                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E1h
 32404                                  
 32405 00005B86 31C0                    	xor	AX,AX
 32406 00005B88 368706[3403]            	xchg	AX,[ss:exit_code]
 32407 00005B8D E9A7AA                  	jmp	SYS_RET_OK
 32408                                  
 32409                                  ; =========================================================================
 32410                                  ;BREAK <$exec - load/go a program>
 32411                                  ;	EXEC.ASM - EXEC System Call
 32412                                  ;
 32413                                  ;
 32414                                  ; Assembler usage:
 32415                                  ;	    lds     DX, Name
 32416                                  ;	    les     BX, Blk
 32417                                  ;	    mov     AH, Exec
 32418                                  ;	    mov     AL, FUNC
 32419                                  ;	    int     INT_COMMAND
 32420                                  ;
 32421                                  ;	AL  Function
 32422                                  ;	--  --------
 32423                                  ;	 0  Load and execute the program.
 32424                                  ;	 1  Load, create the program header but do not
 32425                                  ;	    begin execution.
 32426                                  ;	 3  Load overlay. No header created.
 32427                                  ;
 32428                                  ;	    AL = 0 -> load/execute program
 32429                                  ;
 32430                                  ;	    +---------------------------+
 32431                                  ;	    | WORD segment address of	|
 32432                                  ;	    | environment.		|
 32433                                  ;	    +---------------------------+
 32434                                  ;	    | DWORD pointer to ASCIZ	|
 32435                                  ;	    | command line at 80h	|
 32436                                  ;	    +---------------------------+
 32437                                  ;	    | DWORD pointer to default	|
 32438                                  ;	    | FCB to be passed at 5Ch	|
 32439                                  ;	    +---------------------------+
 32440                                  ;	    | DWORD pointer to default	|
 32441                                  ;	    | FCB to be passed at 6Ch	|
 32442                                  ;	    +---------------------------+
 32443                                  ;
 32444                                  ;	    AL = 1 -> load program
 32445                                  ;
 32446                                  ;	    +---------------------------+
 32447                                  ;	    | WORD segment address of	|
 32448                                  ;	    | environment.		|
 32449                                  ;	    +---------------------------+
 32450                                  ;	    | DWORD pointer to ASCIZ	|
 32451                                  ;	    | command line at 80h	|
 32452                                  ;	    +---------------------------+
 32453                                  ;	    | DWORD pointer to default	|
 32454                                  ;	    | FCB to be passed at 5Ch	|
 32455                                  ;	    +---------------------------+
 32456                                  ;	    | DWORD pointer to default	|
 32457                                  ;	    | FCB to be passed at 6Ch	|
 32458                                  ;	    +---------------------------+
 32459                                  ;	    | DWORD returned value of	|
 32460                                  ;	    | CS:IP			|
 32461                                  ;	    +---------------------------+
 32462                                  ;	    | DWORD returned value of	|
 32463                                  ;	    | SS:IP			|
 32464                                  ;	    +---------------------------+
 32465                                  ;
 32466                                  ;	    AL = 3 -> load overlay
 32467                                  ;
 32468                                  ;	    +---------------------------+
 32469                                  ;	    | WORD segment address where|
 32470                                  ;	    | file will be loaded.	|
 32471                                  ;	    +---------------------------+
 32472                                  ;	    | WORD relocation factor to |
 32473                                  ;	    | be applied to the image.	|
 32474                                  ;	    +---------------------------+
 32475                                  ;
 32476                                  ; Returns:
 32477                                  ;	    AX = error_invalid_function
 32478                                  ;	       = error_bad_format
 32479                                  ;	       = error_bad_environment
 32480                                  ;	       = error_not_enough_memory
 32481                                  ;	       = error_file_not_found
 32482                                  ; =========================================================================
 32483                                  ;
 32484                                  ;   Revision history:
 32485                                  ;
 32486                                  ;	 A000	version 4.00  Jan. 1988
 32487                                  ;
 32488                                  ; =========================================================================
 32489                                  
 32490                                  Exec_Internal_Buffer		EQU	OPENBUF
 32491                                  Exec_Internal_Buffer_Size	EQU	(128+128+53+curdirLen)
 32492                                  
 32493                                  ; =========================================================================
 32494                                  
 32495                                  ;IF1		; warning message on buffers
 32496                                  ;%out	Please make sure that the following are contiguous and of the
 32497                                  ;%out	following sizes:
 32498                                  ;%out
 32499                                  ;%out	OpenBuf     128
 32500                                  ;%out	RenBuf	    128
 32501                                  ;%out	SearchBuf    53
 32502                                  ;%out	DummyCDS    curdirLen
 32503                                  ;ENDIF
 32504                                  
 32505                                  ; =========================================================================
 32506                                  
 32507                                  ; =========================================================================
 32508                                  ;
 32509                                  ; =========================================================================
 32510                                  
 32511                                  	; 20/05/2019 - Retro DOS v4.0
 32512                                  	; DOSCODE:9B5Fh (MSDOS 6.21, MSDOS.SYS)
 32513                                  
 32514                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32515                                  	; DOSCODE:9B04h (MSDOS 5.0, MSDOS.SYS)
 32516                                  	
 32517                                  _$EXEC:
 32518                                  	; 02/08/2018 - Retro DOS v3.0
 32519                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5EF1h
 32520                                  
 32521                                  EXEC001S:
 32522                                  	;LocalVar    Exec_Blk		,DWORD
 32523                                  	;LocalVar    Exec_Func		,BYTE
 32524                                  	;LocalVar    Exec_Load_High	,BYTE
 32525                                  	;LocalVar    Exec_FH		,WORD
 32526                                  	;LocalVar    Exec_Rel_Fac	,WORD
 32527                                  	;LocalVar    Exec_Res_Len_Para	,WORD
 32528                                  	;LocalVar    Exec_Environ	,WORD
 32529                                  	;LocalVar    Exec_Size		,WORD
 32530                                  	;LocalVar    Exec_Load_Block	,WORD
 32531                                  	;LocalVar    Exec_DMA		,WORD
 32532                                  	;LocalVar    ExecNameLen 	,WORD
 32533                                  	;LocalVar    ExecName		,DWORD
 32534                                  	;
 32535                                  	;LocalVar    Exec_DMA_Save	,WORD
 32536                                  	;LocalVar    Exec_NoStack	,BYTE
 32537                                  
 32538                                  	; MSDOS 3.3 (& MSDOS 6.0)
 32539                                  	;%define	Exec_Blk	dword [bp-4]
 32540                                  	%define		Exec_Blk	[bp-4] ; 09/08/2018
 32541                                  	%define		Exec_BlkL	word [bp-4]	
 32542                                  	%define		Exec_BlkH	word [bp-2]
 32543                                  	%define		Exec_Func	byte [bp-5]
 32544                                  	%define		Exec_Load_High	byte [bp-6]
 32545                                  	%define		Exec_FH		word [bp-8]
 32546                                  	%define		Exec_Rel_Fac	word [bp-10]
 32547                                  	%define		Exec_Res_Len_Para word [bp-12]
 32548                                  	%define		Exec_Environ	word [bp-14]
 32549                                  	%define		Exec_Size	word [bp-16]
 32550                                  	%define		Exec_Load_Block	word [bp-18]
 32551                                  	%define		Exec_DMA	word [bp-20]
 32552                                  	%define		ExecNameLen	word [bp-22]
 32553                                  	;%define	ExecName	dword [bp-26]
 32554                                  	%define		ExecName	[bp-26] ; 09/08/2018
 32555                                  	%define		ExecNameL	word [bp-26]	
 32556                                  	%define		ExecNameH	word [bp-24]
 32557                                  	; MSDOS 6.0
 32558                                  	%define		Exec_DMA_Save	word [bp-28]
 32559                                  	%define		Exec_NoStack	byte [bp-29]
 32560                                  	
 32561                                  	; ==================================================================
 32562                                  	; validate function
 32563                                  	; ==================================================================
 32564                                  		      	
 32565                                  	; M068 - Start
 32566                                  	;
 32567                                  	; Reset the A20OFF_COUNT to 0. This is done as there is a 
 32568                                  	; possibility that the count may not be decremented all the way to
 32569                                  	; 0. A typical case is if the program for which we intended to keep 
 32570                                  	; the A20  off for a sufficiently long time (A20OFF_COUNT int 21 
 32571                                  	; calls), exits pre-maturely due to error conditions.
 32572                                  
 32573                                  	; MSDOS 6.0
 32574 00005B90 36C606[8500]00          	mov	byte [SS:A20OFF_COUNT], 0
 32575                                  
 32576                                  	; If al=5 (ExecReady) we'll change the return address on the stack	
 32577                                  	; to be LeaveDos in msdisp.asm. This ensures that the EXECA20OFF
 32578                                  	; bit set in DOS_FLAG by ExceReady is not cleared in msdisp.asm
 32579                                  
 32580 00005B96 3C05                    	cmp	al,5			; Q: is this ExecReady call
 32581                                  	;jne	short @f
 32582 00005B98 7505                    	jne	short Exec_@f		; N: continue
 32583                                  					; Y: change ret addr. to LeaveDos.
 32584 00005B9A 59                      	pop	cx			; Note CX is not input to ExecReady
 32585 00005B9B B9[0404]                	mov	cx,LeaveDOS
 32586 00005B9E 51                      	push	cx
 32587                                  ;@@:
 32588                                  Exec_@f:
 32589                                  	; M068 - End
 32590                                  	
 32591                                  	;Enter
 32592                                  
 32593 00005B9F 55                      	push	bp
 32594 00005BA0 89E5                    	mov	bp,sp
 32595                                  	;;sub	sp,26	; MSDOS 3.3
 32596                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)	
 32597                                  	;sub	sp,29	; MSDOS 6.0 (& MSDOS 6.21)
 32598                                  	; 17/12/2022
 32599                                  	; 20/05/2019
 32600 00005BA2 83EC1E                  	sub	sp,30	; Retro DOS v4.0	
 32601                                  
 32602                                  	; MSDOS 6.0
 32603 00005BA5 3C05                    	cmp	AL,5			; only 0, 1, 3 or 5 are allowed ;M028
 32604                                  					; M030
 32605 00005BA7 7614                    	jna	short Exec_Check_2
 32606                                  
 32607                                  	; MSDOS 3.3
 32608                                  	;cmp	AL,3
 32609                                  	;jna	short Exec_Check_2
 32610                                  
 32611                                  Exec_Bad_Fun:
 32612 00005BA9 36C606[2303]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; 1
 32613                                  					; Extended Error Locus	;smr;SS Override
 32614                                  	;mov	al,1
 32615 00005BAF B001                    	mov	al,error_invalid_function
 32616                                  
 32617                                  Exec_Ret_Err:
 32618                                  	;Leave
 32619 00005BB1 89EC                    	mov	sp,bp
 32620 00005BB3 5D                      	pop	bp
 32621                                  	;transfer SYS_RET_ERR
 32622 00005BB4 E989AA                  	jmp	SYS_RET_ERR
 32623                                  
 32624                                  	; MSDOS 6.0
 32625                                  ExecReadyJ:
 32626 00005BB7 E8FD17                  	call	ExecReady		; M028
 32627 00005BBA E90504                  	jmp	norm_ovl		; do a Leave & xfer sysret_OK ; M028
 32628                                  
 32629                                  Exec_Check_2:
 32630 00005BBD 3C02                    	cmp	AL,2			
 32631 00005BBF 74E8                    	je	short Exec_Bad_Fun
 32632                                  
 32633                                  	; MSDOS 6.0
 32634 00005BC1 3C04                    	cmp	al,4			; 2 & 4 are not allowed
 32635 00005BC3 74E4                    	je	short Exec_Bad_Fun
 32636                                  	
 32637 00005BC5 3C05                    	cmp	al,5			; M028 ; M030
 32638 00005BC7 74EE                    	je	short ExecReadyJ	; M028
 32639                                  
 32640                                  	;mov	[bp-4],bx
 32641 00005BC9 895EFC                  	mov	Exec_BlkL,BX		; stash args
 32642                                  	;mov	[bp-2],es
 32643 00005BCC 8C46FE                  	mov	Exec_BlkH,ES
 32644                                  	;mov	[bp-5],al
 32645 00005BCF 8846FB                  	mov	Exec_Func,AL
 32646                                  	;mov	byte [bp-6],0
 32647 00005BD2 C646FA00                	mov	Exec_Load_High,0
 32648                                  
 32649                                  	;mov	[bp-26],dx
 32650 00005BD6 8956E6                  	mov	ExecNameL,DX		; set up length of exec name
 32651                                  	;mov	[bp-24],ds
 32652 00005BD9 8C5EE8                  	mov	ExecNameH,DS
 32653 00005BDC 89D6                    	mov	SI,DX			; move pointer to convenient place
 32654                                  	;invoke	DStrLen
 32655 00005BDE E81AB6                  	call	DStrLen
 32656                                  	;mov	[bp-22],cx
 32657 00005BE1 894EEA                  	mov	ExecNameLen,CX		; save length
 32658                                  
 32659                                  	; MSDOS 6.0
 32660 00005BE4 36A0[0203]              	mov	al,[ss:AllocMethod]	; M063: save alloc method in 
 32661 00005BE8 36A2[8400]              	mov	[ss:ALLOCMSAVE],al	; M063: AllocMsave
 32662                                  
 32663 00005BEC 30C0                    	xor	AL,AL			; open for reading
 32664 00005BEE 55                      	push	BP
 32665                                  
 32666                                  	; MSDOS 6.0
 32667                                  	;or	byte [ss:DOS_FLAG],1
 32668 00005BEF 36800E[8600]01          	or	byte [ss:DOS_FLAG],EXECOPEN ; this flag is set to indicate to 
 32669                                  					; the redir that this open call is
 32670                                  					; due to an exec.
 32671                                  
 32672                                  	;invoke	$OPEN			; is the file there?
 32673 00005BF5 E80513                  	call	_$OPEN
 32674                                  
 32675                                  	; MSDOS 6.0
 32676 00005BF8 9C                      	pushf
 32677                                  	; 02/06/2019
 32678                                  	;and	byte [ss:DOS_FLAG],0FEh
 32679 00005BF9 368026[8600]FE          	and	byte [ss:DOS_FLAG],~EXECOPEN ; reset flag
 32680 00005BFF 9D                      	popf
 32681                                  
 32682 00005C00 5D                      	pop	BP
 32683                                  
 32684                                  	; MSDOS 3.3 & MSDOS 6.0
 32685 00005C01 72AE                    	jc	short Exec_Ret_Err
 32686                                  
 32687                                  	;mov	[bp-8],ax
 32688 00005C03 8946F8                  	mov	Exec_FH,AX
 32689 00005C06 89C3                    	mov	BX,AX
 32690 00005C08 30C0                    	xor	AL,AL
 32691                                  	;invoke	$Ioctl
 32692 00005C0A E88AC6                  	call	_$IOCTL
 32693 00005C0D 7207                    	jc	short Exec_BombJ
 32694                                  
 32695                                  	;test	dl,80h
 32696 00005C0F F6C280                  	test	DL,devid_ISDEV
 32697 00005C12 740A                    	jz	short Exec_Check_Environ
 32698                                  
 32699                                  	;mov	al,2
 32700 00005C14 B002                    	mov	AL,error_file_not_found
 32701                                  Exec_BombJ:
 32702 00005C16 E9CA00                  	jmp	Exec_Bomb
 32703                                  
 32704                                  BadEnv:
 32705                                  	;mov	al,0Ah
 32706 00005C19 B00A                    	mov	AL,error_bad_environment
 32707 00005C1B E9C500                  	jmp	Exec_Bomb
 32708                                  
 32709                                  Exec_Check_Environ:
 32710                                  	;mov	word [bp-18],0
 32711 00005C1E C746EE0000              	mov	Exec_Load_Block,0
 32712                                  	;mov	word [bp-14],0
 32713 00005C23 C746F20000              	mov	Exec_Environ,0
 32714                                  					; overlays... no environment
 32715                                  	;test	byte [bp-5],2
 32716 00005C28 F646FB02                	test	Exec_Func,exec_func_overlay
 32717 00005C2C 7552                    	jnz	short Exec_Read_Header
 32718                                  
 32719                                  	;lds	si,[bp-4]
 32720 00005C2E C576FC                  	lds	SI,Exec_Blk		; get block
 32721 00005C31 8B04                    	mov	ax,[SI]
 32722                                  	;mov	AX,[SI+EXEC1.ENVIRON]	; address of environ
 32723 00005C33 09C0                    	or	AX,AX
 32724 00005C35 750C                    	jnz	short Exec_Scan_Env
 32725                                  
 32726 00005C37 368E1E[3003]            	mov	DS,[SS:CurrentPDB]	;smr;SS Override
 32727                                  	;mov	ax,[44]
 32728 00005C3C A12C00                  	mov	AX,[PDB.ENVIRON]
 32729                                  
 32730                                  ; MSDOS 6.0
 32731                                  ;---------------------------------------------BUG 92 4/30/90-----------------
 32732                                  ;
 32733                                  ; Exec_environ is being correctly initialized after the environment has been
 32734                                  ; allocated and copied form the parent's env. It must not be initialized here.
 32735                                  ; Because if the call to $alloc below fails Exec_dealloc will deallocate the
 32736                                  ; parent's environment.
 32737                                  ;	mov	Exec_Environ,AX
 32738                                  ;
 32739                                  ;----------------------------------------------------------------------------
 32740                                  
 32741                                  	;mov	[bp-14],ax
 32742                                  	;mov	Exec_Environ,ax
 32743                                  
 32744 00005C3F 09C0                    	or	AX,AX
 32745 00005C41 743D                    	jz	short Exec_Read_Header
 32746                                  
 32747                                  Exec_Scan_Env:
 32748 00005C43 8EC0                    	mov	ES,AX
 32749 00005C45 31FF                    	xor	DI,DI
 32750                                  	;mov	cx,7FFFh ; MSDOS 3.3
 32751 00005C47 B90080                  	mov	CX,8000h ; MSDOS 6.0	; at most 32k of environment ;M040
 32752 00005C4A 30C0                    	xor	AL,AL
 32753                                  
 32754                                  Exec_Get_Environ_Len:
 32755 00005C4C F2AE                    	repnz	scasb			; find that nul byte
 32756 00005C4E 75C9                    	jnz	short BadEnv
 32757                                  
 32758 00005C50 49                      	dec	CX			; Dec CX for the next nul byte test
 32759 00005C51 78C6                    	js	short BadEnv		; gone beyond the end of the environment
 32760                                  
 32761 00005C53 AE                      	scasb				; is there another nul byte?
 32762 00005C54 75F6                    	jnz	short Exec_Get_Environ_Len ; no, scan some more
 32763                                  
 32764 00005C56 57                      	push	DI
 32765                                  	;lea	bx,[DI+11h]
 32766 00005C57 8D5D11                  	lea	BX,[DI+0Fh+2]
 32767                                  	;add	bx,[bp-22]
 32768 00005C5A 035EEA                  	add	BX,ExecNameLen		; BX <- length of environment
 32769                                  					; remember argv[0] length
 32770                                  					; round up and remember argc
 32771 00005C5D B104                    	mov	CL,4
 32772 00005C5F D3EB                    	shr	BX,CL			; number of paragraphs needed
 32773 00005C61 06                      	push	ES
 32774                                  	;invoke	$Alloc			; can we get the space?
 32775 00005C62 E84406                  	call	_$ALLOC
 32776 00005C65 1F                      	pop	DS
 32777 00005C66 59                      	pop	CX
 32778                                  
 32779                                  	;jnc	short Exec_Save_Environ
 32780                                  	;jmp	SHORT Exec_No_Mem	; nope... cry and sob
 32781                                  	; 17/12/2022
 32782 00005C67 7274                    	jc	short Exec_No_Mem ; 02/06/2019
 32783                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 32784                                  	;jnc	short Exec_Save_Environ
 32785                                  	;jmp	SHORT Exec_No_Mem
 32786                                  
 32787                                  Exec_Save_Environ:
 32788 00005C69 8EC0                    	mov	ES,AX
 32789                                  	;mov	[bp-14],ax
 32790 00005C6B 8946F2                  	mov	Exec_Environ,AX 	; save him for a rainy day
 32791 00005C6E 31F6                    	xor	SI,SI
 32792 00005C70 89F7                    	mov	DI,SI
 32793 00005C72 F3A4                    	rep	movsb			; copy the environment
 32794 00005C74 B80100                  	mov	AX,1
 32795 00005C77 AB                      	stosw
 32796                                  	;lds	si,[bp-26]
 32797 00005C78 C576E6                  	lds	SI,ExecName
 32798                                  	;mov	cx,[bp-22]
 32799 00005C7B 8B4EEA                  	mov	CX,ExecNameLen
 32800 00005C7E F3A4                    	rep	movsb
 32801                                  
 32802                                  Exec_Read_Header:
 32803                                  	; We read in the program header into the above data area and
 32804                                  	; determine where in this memory the image will be located.
 32805                                  
 32806                                  	;Context DS
 32807 00005C80 16                      	push	ss
 32808 00005C81 1F                      	pop	ds
 32809                                  	;mov	cx,26
 32810 00005C82 B91A00                  	mov	CX,exec_header_len	; header size
 32811 00005C85 BA[C80F]                	mov	DX,exec_signature
 32812 00005C88 06                      	push	ES
 32813 00005C89 1E                      	push	DS
 32814 00005C8A E88304                  	call	ExecRead
 32815 00005C8D 1F                      	pop	DS
 32816 00005C8E 07                      	pop	ES
 32817 00005C8F 7250                    	jc	short Exec_Bad_File
 32818                                  
 32819 00005C91 09C0                    	or	AX,AX
 32820 00005C93 744C                    	jz	short Exec_Bad_File
 32821                                  	;cmp	ax,26
 32822 00005C95 83F81A                  	cmp	AX,exec_header_len	; did we read the right number?
 32823 00005C98 7519                    	jnz	short Exec_Com_Filej	; yep... continue
 32824                                  
 32825 00005C9A F706[D40F]FFFF          	test	word [exec_max_BSS],-1 	; indicate load high?
 32826 00005CA0 7504                    	jnz	short Exec_Check_Sig
 32827                                  
 32828                                  	;mov	byte [bp-6],0FFh
 32829 00005CA2 C646FAFF                	mov	Exec_Load_High,-1
 32830                                  
 32831                                  Exec_Check_Sig:
 32832 00005CA6 A1[C80F]                	mov	AX,[exec_signature]	; rms;NSS
 32833                                  	;cmp	ax,5A4Dh ; 'MZ'
 32834 00005CA9 3D4D5A                  	cmp	AX,exe_valid_signature	; zibo arises!
 32835 00005CAC 7408                    	jz	short Exec_Save_Start 	; assume com file if no signature
 32836                                  
 32837                                  	;cmp	ax,4D5Ah ; 'ZM'
 32838 00005CAE 3D5A4D                  	cmp	AX,exe_valid_old_signature  ; zibo arises!
 32839 00005CB1 7403                    	jz	short Exec_Save_Start 	; assume com file if no signature
 32840                                  
 32841                                  Exec_Com_Filej:
 32842 00005CB3 E9E901                  	jmp	Exec_Com_File
 32843                                  
 32844                                  	; We have the program header... determine memory requirements
 32845                                  
 32846                                  Exec_Save_Start:
 32847 00005CB6 A1[CC0F]                	mov	AX,[exec_pages]		; get 512-byte pages	;rms;NSS
 32848 00005CB9 B105                    	mov	CL,5			; convert to paragraphs
 32849 00005CBB D3E0                    	shl	AX,CL
 32850 00005CBD 2B06[D00F]              	sub	AX,[exec_par_dir] 	; AX = size in paragraphs ;rms;NSS
 32851                                  	;mov	[bp-12],ax
 32852 00005CC1 8946F4                  	mov	Exec_Res_Len_Para,AX
 32853                                  
 32854                                  		; Do we need to allocate memory?
 32855                                  		; Yes if function is not load-overlay
 32856                                  
 32857                                  	;test	byte [bp-5],2
 32858 00005CC4 F646FB02                	test	Exec_Func,exec_func_overlay
 32859 00005CC8 7445                    	jz	short Exec_Allocate	; allocation of space
 32860                                  
 32861                                  		; get load address from block
 32862                                  
 32863                                  	;les	di,[bp-4]
 32864 00005CCA C47EFC                  	les	DI,Exec_Blk
 32865 00005CCD 268B05                  	mov	ax,[es:di]
 32866                                  	;mov	AX,[ES:DI+EXEC3.load_addr]
 32867                                  	;mov	[bp-20],ax
 32868 00005CD0 8946EC                  	mov	Exec_DMA,AX
 32869                                  
 32870                                  	; 17/12/2022
 32871                                  	;;mov	ax,[es:di+2]
 32872                                  	;mov	AX,[ES:DI+EXEC3.reloc_fac]
 32873                                  	;;mov	[bp-10],ax
 32874                                  	;mov	Exec_Rel_Fac,AX
 32875                                  
 32876                                  	; 17/12/2022
 32877                                  	; 30/11/2022 (!most proper code!)
 32878                                  	;mov	dx,[es:di+2]
 32879 00005CD3 268B5502                	mov	dx,[ES:DI+EXEC3.reloc_fac]
 32880                                  	;mov	[bp-10],dx
 32881 00005CD7 8956F6                  	mov	Exec_Rel_Fac,dx
 32882                                  	; ax = Exec_DMA
 32883 00005CDA E9DE00                  	jmp	Exec_Find_Res
 32884                                  
 32885                                  ; 17/12/2022
 32886                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 32887                                  ; 27/09/2023
 32888                                  %if 0
 32889                                  	; 02/06/2019 - Retro DOS v4.0
 32890                                  	;mov	ax,[bp-20]  ; *+*
 32891                                  	mov	AX,Exec_DMA ; *+*
 32892                                  	; 10/08/2018
 32893                                  	jmp	Exec_Find_Res		; M000
 32894                                  %endif
 32895                                  
 32896                                  Exec_No_Mem:
 32897                                  	;mov	al,8
 32898 00005CDD B008                    	mov	AL,error_not_enough_memory
 32899 00005CDF EB02                    	jmp	short Exec_Bomb
 32900                                  
 32901                                  Exec_Bad_File:
 32902                                  	;mov	al,0Bh
 32903 00005CE1 B00B                    	mov	AL,error_bad_format
 32904                                  
 32905                                  Exec_Bomb:
 32906                                  	;mov	bx,[bp-8]
 32907 00005CE3 8B5EF8                  	mov	BX,Exec_FH
 32908 00005CE6 E84004                  	call	Exec_Dealloc
 32909                                  	;LeaveCrit CritMem
 32910 00005CE9 E840B6                  	call	LCritMEM
 32911                                  	;save	<AX,BP>
 32912 00005CEC 50                      	push	ax
 32913 00005CED 55                      	push	bp
 32914                                  	;invoke	$CLOSE
 32915 00005CEE E83D0A                  	call	_$CLOSE
 32916                                  	;restore <BP,AX>
 32917 00005CF1 5D                      	pop	bp
 32918 00005CF2 58                      	pop	ax
 32919 00005CF3 E9BBFE                  	jmp	Exec_Ret_Err
 32920                                  
 32921                                  Exec_Chk_Mem: 
 32922                                  
 32923                                  	; 24/09/2023
 32924                                  	; ds = DOSDATA
 32925                                  ; 17/12/2022
 32926                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 32927                                  ;%if 0
 32928                                  	; MSDOS 6.0    			; M063 - Start
 32929                                  	;mov	al,[ss:AllocMethod]	; save current alloc method in ax
 32930                                  	; 10/06/2019
 32931 00005CF6 A0[0203]                	mov	al,[AllocMethod]
 32932                                  	;mov	bl,[ss:ALLOCMSAVE]
 32933 00005CF9 8A1E[8400]              	mov	bl,[ALLOCMSAVE]
 32934                                  	;mov	[ss:AllocMethod],bl	; restore original allocmethod
 32935 00005CFD 881E[0203]              	mov	[AllocMethod],bl
 32936                                  	
 32937 00005D01 F6C340                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 32938 00005D04 75D7                    	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 32939                                  	;				; N: continue
 32940                                  	;
 32941 00005D06 A840                    	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 32942 00005D08 74D3                    	jz	short Exec_No_Mem	; N: no memory 
 32943                                  	; 02/06/2019
 32944                                  	;mov	ax,[ss:SAVE_AX]		; Y: restore ax and
 32945 00005D0A A1[8A00]                	mov	ax,[SAVE_AX]
 32946                                  	;jmp	short Exec_Norm_Alloc	;    Try again
 32947                                  					; M063 - End
 32948 00005D0D EB2B                    	jmp	short Exec_Norm_Alloc1
 32949                                  ;%endif
 32950                                  
 32951                                  ; 17/12/2022
 32952                                  %if 0
 32953                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 32954                                  	; MSDOS 6.0    			; M063 - Start
 32955                                  	mov	al,[ss:AllocMethod]	; save current alloc method in ax
 32956                                  	mov	bl,[ss:ALLOCMSAVE]
 32957                                  	mov	[ss:AllocMethod],bl	; restore original allocmethod
 32958                                  
 32959                                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 32960                                  	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 32961                                  	;				; N: continue
 32962                                  	;
 32963                                  	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 32964                                  	jz	short Exec_No_Mem	; N: no memory 
 32965                                  
 32966                                  	mov	ax,[ss:SAVE_AX]		; Y: restore ax and
 32967                                  	jmp	short Exec_Norm_Alloc	;    Try again
 32968                                  					; M063 - End
 32969                                  %endif
 32970                                  
 32971                                  Exec_Allocate:
 32972                                  	; 09/09/2018
 32973                                  
 32974                                  	; M005 - START
 32975                                  	; If there is no STACK segment for this exe file and if this
 32976                                  	; not an overlay and the resident size is less than 64K - 
 32977                                  	; 256 bytes we shall add 256 bytes to the programs 
 32978                                  	; resident memory requirement and set Exec_SP to this value.
 32979                                  	
 32980                                  	; 17/12/2022
 32981 00005D0F 29DB                    	sub	bx,bx ; 0	
 32982                                  
 32983                                  	; MSDOS 6.0
 32984                                  	;;mov	byte [bp-29],0
 32985                                  	;mov	Exec_NoStack,0
 32986                                  	; 17/12/2022
 32987 00005D11 885EE3                  	mov	Exec_NoStack,bl ; 0
 32988 00005D14 391E[D60F]              	cmp	[exec_SS],bx ; 0
 32989                                  	;cmp	word [exec_SS],0	; Q: is there a stack seg
 32990 00005D18 7511                    	jne	short ea1		; Y: continue normal processing
 32991 00005D1A 391E[D80F]              	cmp	[exec_SP],bx ; 0
 32992                                  	;cmp	word [exec_SP],0	; Q: is there a stack ptr
 32993 00005D1E 750B                    	jne	short ea1		; Y: continue normal processing
 32994                                  
 32995                                  	;inc	byte [bp-29]
 32996 00005D20 FE46E3                  	inc	Exec_NoStack
 32997 00005D23 3DF00F                  	cmp	ax,1000h-10h		; Q: is this >= 64K-256 bytes
 32998 00005D26 7303                    	jae	short ea1		; Y: don't set Exec_SP
 32999                                  
 33000 00005D28 83C010                  	add	ax,10h			; add 10h paras to mem requirement
 33001                                  ea1:
 33002                                  	; M005 - END
 33003                                  
 33004                                  	; MSDOS 6.0			; M000 - start
 33005                                  	; 20/05/2019
 33006                                  	; (ds = ss = DOSDATA)
 33007 00005D2B F606[0203]80            	test	byte [AllocMethod],HIGH_FIRST ; 80h
 33008                                  					; Q: is the alloc strat high_first
 33009 00005D30 7405                    	jz	short Exec_Norm_Alloc	; N: normal allocate
 33010                                  					; Y: set high_only bit
 33011 00005D32 800E[0203]40            	or	byte [AllocMethod],HIGH_ONLY ; 40h
 33012                                  					; M000 - end
 33013                                  Exec_Norm_Alloc:
 33014 00005D37 A3[8A00]                	mov	[SAVE_AX],ax		; M000: save ax for possible 2nd  
 33015                                  Exec_Norm_Alloc1:	; 02/06/2019
 33016                                  					; M000: attempt at allocating memory
 33017                                  	; MSDOS 3.3
 33018                                  	;push	ax			; M000
 33019                                  
 33020 00005D3A BBFFFF                  	mov	BX,0FFFFh		; see how much room in arena
 33021 00005D3D 1E                      	push	DS
 33022                                  	;invoke	$Alloc			; should have carry set and BX has max
 33023 00005D3E E86805                  	call	_$ALLOC
 33024 00005D41 1F                      	pop	DS
 33025                                  
 33026                                  	; MSDOS 6.0
 33027 00005D42 A1[8A00]                	mov	AX,[SAVE_AX]		; M000
 33028                                  	; MSDOS 3.3
 33029                                  	;pop	ax			; M000
 33030                                  
 33031 00005D45 83C010                  	add	AX,10h			; room for header
 33032 00005D48 83FB11                  	cmp	BX,11h			; enough room for a header
 33033                                  	; MSDOS 6.0
 33034 00005D4B 72A9                    	jb	short Exec_Chk_Mem	; M000
 33035                                  	; MSDOS 3.3	
 33036                                  	;jb	short Exec_No_Mem
 33037                                  
 33038 00005D4D 39D8                    	cmp	AX,BX			; is there enough for bare image?
 33039                                  	; MSDOS 6.0
 33040 00005D4F 77A5                    	ja	short Exec_Chk_Mem	; M000
 33041                                  	; MSDOS 3.3
 33042                                  	;ja	short Exec_No_Mem
 33043                                  
 33044                                  	;test	byte [bp-6],0FFh
 33045 00005D51 F646FAFF                	test	Exec_Load_High,-1	; if load high, use max
 33046 00005D55 7518                    	jnz	short Exec_BX_Max	; use max
 33047                                  
 33048                                  	; 09/09/2018
 33049                                  
 33050 00005D57 0306[D20F]              	add	AX,[exec_min_BSS] 	; go for min allocation;rms;NSS
 33051                                  	; MSDOS 6.0
 33052 00005D5B 7299                    	jc	short Exec_Chk_Mem		; M000
 33053                                  	; MSDOS 3.3
 33054                                  	;jc	short Exec_No_Mem
 33055                                  
 33056 00005D5D 39D8                    	cmp	AX,BX			; enough space?
 33057                                  	; MSDOS 6.0
 33058 00005D5F 7795                    	ja	short Exec_Chk_Mem	; M000: nope...	
 33059                                  	; MSDOS 3.3
 33060                                  	;ja	short Exec_No_Mem
 33061                                  
 33062 00005D61 2B06[D20F]              	sub	AX,[exec_min_BSS] 	; rms;NSS
 33063 00005D65 0306[D40F]              	add	AX,[exec_max_BSS] 	; go for the MAX
 33064 00005D69 7204                    	jc	short Exec_BX_Max
 33065                                  
 33066 00005D6B 39D8                    	cmp	AX,BX
 33067 00005D6D 7602                    	jbe	short Exec_Got_Block
 33068                                  
 33069                                  Exec_BX_Max:
 33070 00005D6F 89D8                    	mov	AX,BX
 33071                                  
 33072                                  Exec_Got_Block:
 33073                                  	; 03/08/2018 - Retro DOS v3.0
 33074                                  
 33075 00005D71 1E                      	push	DS
 33076 00005D72 89C3                    	mov	BX,AX
 33077                                  	;mov	[bp-16],bx
 33078 00005D74 895EF0                  	mov	Exec_Size,BX
 33079                                  	;invoke	$Alloc			; get the space
 33080 00005D77 E82F05                  	call	_$ALLOC
 33081 00005D7A 1F                      	pop	DS
 33082                                  	; MSDOS 6.0
 33083                                  	;jc	short Exec_Chk_Mem	; M000
 33084                                  	; MSDOS 3.3
 33085                                  	;;jc	short Exec_No_Mem
 33086                                  	; 20/05/2019
 33087 00005D7B 7303                    	jnc	short ea0
 33088 00005D7D E976FF                  	jmp	Exec_Chk_Mem
 33089                                  ea0:
 33090                                  	; MSDOS 6.0
 33091 00005D80 8A0E[8400]              	mov	cl,[ALLOCMSAVE]		; M063: 
 33092 00005D84 880E[0203]              	mov	[AllocMethod],cl	; M063: restore allocmethod
 33093                                  
 33094                                  ;M029; Begin changes
 33095                                  ; This code does special handling for programs with no stack segment. If so,
 33096                                  ;check if the current block is larger than 64K. If so, we do not modify
 33097                                  ;Exec_SP. If smaller than 64K, we make Exec_SP = top of block. In either
 33098                                  ;case Exec_SS is not changed.
 33099                                  
 33100                                  	; MSDOS 6.0
 33101                                  	;cmp	byte [bp-29],0
 33102 00005D88 807EE300                	cmp	Exec_NoStack,0
 33103                                  	;je	@f
 33104 00005D8C 7412                    	je	short ea2
 33105                                  
 33106 00005D8E 81FB0010                	cmp	bx,1000h		; Q: >= 64K memory block
 33107                                  	;jae	@f			; Y: Exec_SP = 0
 33108 00005D92 730C                    	jae	short ea2
 33109                                  
 33110                                  ;Make Exec_SP point at the top of the memory block
 33111                                  
 33112 00005D94 B104                    	mov	cl,4
 33113 00005D96 D3E3                    	shl	bx,cl			; get byte offset
 33114 00005D98 81EB0001                	sub	bx,100h			; take care of PSP
 33115 00005D9C 891E[D80F]              	mov	[exec_SP],bx		; Exec_SP = top of block
 33116                                  ea2:
 33117                                  ;@@:
 33118                                  ;M029; end changes
 33119                                  
 33120                                  	;mov	[bp-18],ax
 33121 00005DA0 8946EE                  	mov	Exec_Load_Block,AX
 33122 00005DA3 83C010                  	add	AX,10h
 33123                                  	;test	byte [bp-6],0FFh
 33124 00005DA6 F646FAFF                	test	Exec_Load_High,-1
 33125 00005DAA 7409                    	jz	short Exec_Use_AX	; use ax for load info
 33126                                  
 33127                                  	;add	ax,[bp-16]
 33128 00005DAC 0346F0                  	add	AX,Exec_Size		; go to end
 33129                                  	;sub	ax,[bp-12]
 33130 00005DAF 2B46F4                  	sub	AX,Exec_Res_Len_Para	; drop off header
 33131 00005DB2 83E810                  	sub	AX,10h			; drop off pdb
 33132                                  
 33133                                  Exec_Use_AX:
 33134                                  	;mov	[bp-10],ax
 33135 00005DB5 8946F6                  	mov	Exec_Rel_Fac,AX 	; new segment
 33136                                  	;mov	[bp-20],ax
 33137 00005DB8 8946EC                  	mov	Exec_DMA,AX ; *+*	; beginning of dma
 33138                                  
 33139                                  	; Determine the location in the file of the beginning of
 33140                                  	; the resident
 33141                                  
 33142                                  ; 17/12/2022
 33143                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 33144                                  ;%if 0
 33145                                  
 33146                                  Exec_Find_Res:
 33147                                  	; MSDOS 6.0
 33148                                  	;;mov	dx,[bp-20]
 33149                                  	;mov	DX,Exec_DMA ; *+*
 33150                                  	;;mov	[bp-28],dx
 33151                                  	;mov	Exec_DMA_Save,DX
 33152                                  
 33153                                  	; 17/12/2022
 33154                                  	; AX = Exec_DMA
 33155                                  
 33156                                  	; 02/06/2019 - Retro DOS v4.0
 33157                                  	;mov	[bp-28],ax ; *+*
 33158 00005DBB 8946E4                  	mov	Exec_DMA_Save,AX ; *+*
 33159                                  
 33160                                  ;%endif
 33161                                  
 33162                                  ; 17/12/2022
 33163                                  %if 0
 33164                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 33165                                  Exec_Find_Res:
 33166                                  	;mov	dx,[bp-20]
 33167                                  	mov	DX,Exec_DMA ; *+*
 33168                                  	;mov	[bp-28],dx
 33169                                  	mov	Exec_DMA_Save,DX
 33170                                  %endif
 33171                                  
 33172                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33173 00005DBE 8B16[D00F]              	mov	DX,[exec_par_dir]
 33174 00005DC2 52                      	push	DX
 33175 00005DC3 B104                    	mov	CL,4
 33176 00005DC5 D3E2                    	shl	DX,CL			; low word of location
 33177 00005DC7 58                      	pop	AX
 33178 00005DC8 B10C                    	mov	CL,12
 33179 00005DCA D3E8                    	shr	AX,CL			; high word of location
 33180 00005DCC 89C1                    	mov	CX,AX			; CX <- high
 33181                                  
 33182                                  		; Read in the resident image (first, seek to it)
 33183                                  	;mov	bx,[bp-8]
 33184 00005DCE 8B5EF8                  	mov	BX,Exec_FH
 33185 00005DD1 1E                      	push	DS
 33186 00005DD2 30C0                    	xor	AL,AL
 33187                                  	;invoke	$Lseek			; Seek to resident
 33188 00005DD4 E8D30A                  	call	_$LSEEK
 33189 00005DD7 1F                      	pop	DS
 33190 00005DD8 7303                    	jnc	short Exec_Big_Read
 33191                                  
 33192 00005DDA E906FF                  	jmp	Exec_Bomb
 33193                                  
 33194                                  Exec_Big_Read:				; Read resident into memory
 33195                                  	;mov	bx,[bp-12]
 33196 00005DDD 8B5EF4                  	mov	BX,Exec_Res_Len_Para
 33197 00005DE0 81FB0010                	cmp	BX,1000h		; Too many bytes to read?
 33198 00005DE4 7203                    	jb	short Exec_Read_OK
 33199                                  
 33200 00005DE6 BBE00F                  	mov	BX,0FE0h		; Max in one chunk FE00 bytes
 33201                                  
 33202                                  Exec_Read_OK:
 33203                                  	;sub	[bp-12],bx
 33204 00005DE9 295EF4                  	sub	Exec_Res_Len_Para,BX	; We read (soon) this many
 33205 00005DEC 53                      	push	BX
 33206 00005DED B104                    	mov	CL,4
 33207 00005DEF D3E3                    	shl	BX,CL			; Get count in bytes from paras
 33208 00005DF1 89D9                    	mov	CX,BX			; Count in correct register
 33209 00005DF3 1E                      	push	DS
 33210                                  	;mov	ds,[bp-20]
 33211 00005DF4 8E5EEC                  	mov	DS,Exec_DMA		; Set up read buffer
 33212                                  
 33213 00005DF7 31D2                    	xor	DX,DX
 33214 00005DF9 51                      	push	CX			; Save our count
 33215 00005DFA E81303                  	call	ExecRead
 33216 00005DFD 59                      	pop	CX			; Get old count to verify
 33217 00005DFE 1F                      	pop	DS
 33218 00005DFF 7248                    	jc	short Exec_Bad_FileJ
 33219                                  
 33220 00005E01 39C1                    	cmp	CX,AX			; Did we read enough?
 33221 00005E03 5B                      	pop	BX			; Get paragraph count back
 33222 00005E04 7408                    	jz	short ExecCheckEnd	; and do reloc if no more to read
 33223                                  
 33224                                  	; The read did not match the request. If we are off by 512
 33225                                  	; bytes or more then the header lied and we have an error.
 33226                                  
 33227 00005E06 29C1                    	sub	CX,AX
 33228 00005E08 81F90002                	cmp	CX,512
 33229 00005E0C 733B                    	jae	short Exec_Bad_FileJ
 33230                                  
 33231                                  	; We've read in CX bytes... bump DTA location
 33232                                  
 33233                                  ExecCheckEnd:
 33234                                  	;add	[bp-20],bx
 33235 00005E0E 015EEC                  	add	Exec_DMA,BX		; Bump dma address
 33236                                  	;test	word [bp-12],0FFFFh
 33237 00005E11 F746F4FFFF              	test	Exec_Res_Len_Para,-1
 33238 00005E16 75C5                    	jnz	short Exec_Big_Read
 33239                                  
 33240                                  	; The image has now been read in. We must perform relocation
 33241                                  	; to the current location.
 33242                                  
 33243                                  exec_do_reloc:
 33244                                  	;mov	cx,[bp-10]
 33245 00005E18 8B4EF6                  	mov	CX,Exec_Rel_Fac
 33246 00005E1B A1[D60F]                	mov	AX,[exec_SS]		; get initial SS ;rms;NSS
 33247 00005E1E 01C8                    	add	AX,CX			; and relocate him
 33248 00005E20 A3[C20F]                	mov	[exec_init_SS],AX 	; rms;NSS
 33249                                  
 33250 00005E23 A1[D80F]                	mov	AX,[exec_SP]		; initial SP ;rms;NSS
 33251 00005E26 A3[C00F]                	mov	[exec_init_SP],AX 	; rms;NSS
 33252                                  
 33253 00005E29 C406[DC0F]              	les	AX,[exec_IP]		; rms;NSS
 33254 00005E2D A3[C40F]                	mov	[exec_init_IP],AX 	; rms;NSS
 33255 00005E30 8CC0                    	mov	AX,ES			; rms;NSS
 33256 00005E32 01C8                    	add	AX,CX			; relocated...
 33257 00005E34 A3[C60F]                	mov	[exec_init_CS],AX 	; rms;NSS
 33258                                  
 33259 00005E37 31C9                    	xor	CX,CX
 33260 00005E39 8B16[E00F]              	mov	DX,[exec_rle_table]	; rms;NSS
 33261                                  	;mov	bx,[bp-8]
 33262 00005E3D 8B5EF8                  	mov	BX,Exec_FH
 33263 00005E40 1E                      	push	DS
 33264 00005E41 31C0                    	xor	AX,AX
 33265                                  	;invoke	$Lseek
 33266 00005E43 E8640A                  	call	_$LSEEK
 33267 00005E46 1F                      	pop	DS
 33268 00005E47 7303                    	jnc	short exec_get_entries
 33269                                  
 33270                                  Exec_Bad_FileJ:
 33271 00005E49 E995FE                  	jmp	Exec_Bad_File
 33272                                  
 33273                                  exec_get_entries:
 33274 00005E4C 8B16[CE0F]              	mov	DX,[exec_rle_count]	; Number of entries left ;rms;NSS
 33275                                  
 33276                                  exec_read_reloc:
 33277 00005E50 52                      	push	DX
 33278                                  	;mov	dx,OPENBUF
 33279 00005E51 BA[BE03]                	mov	DX,Exec_Internal_Buffer
 33280                                  	;;mov	cx,388 ; MSDOS 3.3 ; (390>>2)<<2
 33281                                  	;mov	cx,396 ; MSDOS 6.0
 33282 00005E54 B98C01                  	mov	CX,((Exec_Internal_Buffer_Size)/4)*4 ; (397>>2)<<2
 33283 00005E57 1E                      	push	DS
 33284 00005E58 E8B502                  	call	ExecRead
 33285 00005E5B 07                      	pop	ES
 33286 00005E5C 5A                      	pop	DX
 33287 00005E5D 72EA                    	jc	short Exec_Bad_FileJ
 33288                                  
 33289                                  	;;mov	cx,97 ;  MSDOS 3.3 ; (390>>2)
 33290                                  	;mov	cx,99 ;  MSDOS 6.0
 33291 00005E5F B96300                  	mov	CX,(Exec_Internal_Buffer_Size)/4 ; (397>>2)
 33292                                  					; Pointer to byte location in header
 33293                                  	;mov	di,OPENBUF
 33294 00005E62 BF[BE03]                	mov	DI,Exec_Internal_Buffer
 33295                                  	;mov	si,[bp-10]
 33296 00005E65 8B76F6                  	mov	SI,Exec_Rel_Fac 	; Relocate a single address
 33297                                  
 33298                                  exec_reloc_one:
 33299 00005E68 09D2                    	or	DX,DX			; Any more entries?
 33300 00005E6A 7416                    	jz	short Exec_Set_PDBJ
 33301                                  
 33302                                  exec_get_addr:
 33303 00005E6C 26C51D                  	lds	BX,[ES:DI]		; Get ra/sa of entry
 33304 00005E6F 8CD8                    	mov	AX,DS			; Relocate address of item
 33305                                  
 33306                                  	; MSDOS 6.0
 33307                                  ;;;;;;	add	AX,SI  ; MSDOS 3.3
 33308                                  	;add	ax,[bp-28]
 33309 00005E71 0346E4                  	add	AX,Exec_DMA_Save
 33310                                  
 33311 00005E74 8ED8                    	mov	DS,AX
 33312 00005E76 0137                    	add	[BX],SI
 33313 00005E78 83C704                  	add	DI,4
 33314 00005E7B 4A                      	dec	DX
 33315 00005E7C E2EA                    	loop	exec_reloc_one		; End of internal buffer?
 33316                                  
 33317                                  	; We've exhausted a single buffer's worth. Read in the next
 33318                                  	; piece of the relocation table.
 33319                                  
 33320 00005E7E 06                      	push	ES
 33321 00005E7F 1F                      	pop	DS
 33322 00005E80 EBCE                    	jmp	short exec_read_reloc
 33323                                  
 33324                                  Exec_Set_PDBJ:
 33325                                  	; MSDOS 6.0
 33326                                  	
 33327                                  	; We now determine if this is a buggy exe packed file and if 
 33328                                  	; so we patch in the right code. Note that fixexepatch will
 33329                                  	; point to a ret if dos loads low. The load segment as 
 33330                                  	; determined above will be in exec_dma_save
 33331                                  	
 33332 00005E82 06                      	push	es
 33333 00005E83 50                      	push	ax			; M030
 33334 00005E84 51                      	push	cx			; M030
 33335                                  	;mov	es,[bp-28]
 33336 00005E85 8E46E4                  	mov	es,Exec_DMA_Save
 33337 00005E88 36A1[C60F]              	mov	ax,[ss:exec_init_CS]	; M030
 33338 00005E8C 368B0E[C40F]            	mov	cx,[ss:exec_init_IP]	; M030
 33339 00005E91 36FF16[F311]            	call	word [ss:FixExePatch]
 33340                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33341                                  	; (MSDOS 5.0 MSDOS.SYS does not contain 'Rational386Patch')
 33342                                  	;call	word [ss:Rational386PatchPtr]
 33343 00005E96 59                      	pop	cx			; M030
 33344 00005E97 58                      	pop	ax			; M030
 33345 00005E98 07                      	pop	es
 33346                                  
 33347 00005E99 E9DE00                  	jmp	Exec_Set_PDB
 33348                                  
 33349                                  Exec_No_Memj:
 33350 00005E9C E93EFE                  	jmp	Exec_No_Mem
 33351                                  
 33352                                  	; we have a .COM file. First, determine if we are merely
 33353                                  	; loading an overlay.
 33354                                  
 33355                                  Exec_Com_File:
 33356                                  	;test	byte [bp-5],2
 33357 00005E9F F646FB02                	test	Exec_Func,exec_func_overlay
 33358 00005EA3 742D                    	jz	short Exec_Alloc_Com_File
 33359                                  	;lds	si,[bp-4]
 33360 00005EA5 C576FC                  	lds	SI,Exec_Blk		; get arg block
 33361 00005EA8 AD                      	lodsw				; get load address
 33362                                  	;mov	[bp-20],ax
 33363 00005EA9 8946EC                  	mov	Exec_DMA,AX
 33364 00005EAC B8FFFF                  	mov	AX,0FFFFh
 33365 00005EAF EB63                    	jmp	short Exec_Read_Block	; read it all!
 33366                                  
 33367                                  Exec_Chk_Com_Mem:			
 33368                                  	; MSDOS 6.0	     		; M063 - Start
 33369 00005EB1 36A0[0203]              	mov	al,[ss:AllocMethod]	; save current alloc method in ax
 33370 00005EB5 368A1E[8400]            	mov	bl,[ss:ALLOCMSAVE]
 33371 00005EBA 36881E[0203]            	mov	[ss:AllocMethod],bl	; restore original allocmethod
 33372 00005EBF F6C340                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 33373 00005EC2 75D8                    	jnz	short Exec_No_Memj	; Y: no space in UMBs. Quit
 33374                                  					; N: continue
 33375                                  	
 33376 00005EC4 A840                    	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 33377 00005EC6 74D4                    	jz	short Exec_No_Memj	; N: no memory 
 33378                                  	
 33379                                  	;mov	ax,[bp-18]
 33380 00005EC8 8B46EE                  	mov	ax,Exec_Load_Block	; M047: ax = block we just allocated	
 33381 00005ECB 31DB                    	xor	bx,bx			; M047: bx => free arena
 33382 00005ECD E87502                  	call	ChangeOwner		; M047: free this block
 33383                                  	
 33384 00005ED0 EB0E                    	jmp	short Exec_Norm_Com_Alloc
 33385                                  					; M063 - End
 33386                                  	
 33387                                  	; We must allocate the max possible size block (ick!)
 33388                                  	; and set up CS=DS=ES=SS=PDB pointer, IP=100, SP=max
 33389                                  	; size of block.
 33390                                  
 33391                                  Exec_Alloc_Com_File:
 33392                                  	; MSDOS 6.0			; M000 -start
 33393 00005ED2 36F606[0203]80          	test	byte [ss:AllocMethod],HIGH_FIRST ; 80h
 33394                                  					; Q: is the alloc strat high_first
 33395 00005ED8 7406                    	jz	short Exec_Norm_Com_Alloc ; N: normal allocate
 33396                                  					; Y: set high_only bit
 33397 00005EDA 36800E[0203]40          	or	byte [ss:AllocMethod],HIGH_ONLY ; 40h
 33398                                  					; M000 - end
 33399                                  Exec_Norm_Com_Alloc:			; M000
 33400                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33401 00005EE0 BBFFFF                  	mov	BX,0FFFFh
 33402                                  	;invoke	$Alloc			; largest piece available as error
 33403 00005EE3 E8C303                  	call	_$ALLOC
 33404 00005EE6 09DB                    	or	BX,BX
 33405                                  	; MSDOS 6.0
 33406 00005EE8 74C7                    	jz	short Exec_Chk_Com_Mem	; M000
 33407                                  	; MSDOS 3.3
 33408                                  	;jz	short Exec_No_Memj
 33409                                  
 33410                                  	;mov	[bp-16],bx
 33411 00005EEA 895EF0                  	mov	Exec_Size,BX		; save size of allocation block
 33412 00005EED 53                      	push	BX
 33413                                  	;invoke	$ALLOC			; largest piece available
 33414 00005EEE E8B803                  	call	_$ALLOC
 33415 00005EF1 5B                      	pop	BX			; get size of block...
 33416                                  	;mov	[bp-18],ax
 33417 00005EF2 8946EE                  	mov	Exec_Load_Block,AX
 33418                                  
 33419 00005EF5 83C010                  	add	AX,10h			; increment for header
 33420                                  	;mov	[bp-20],ax
 33421 00005EF8 8946EC                  	mov	Exec_DMA,AX
 33422                                  
 33423 00005EFB 31C0                    	xor	AX,AX			; presume 64K read...
 33424 00005EFD 81FB0010                	cmp	BX,1000h		; 64k or more in block?
 33425 00005F01 730E                    	jae	short Exec_Read_Com	; yes, read only 64k
 33426                                  
 33427 00005F03 89D8                    	mov	AX,BX			; convert size to bytes
 33428 00005F05 B104                    	mov	CL,4
 33429 00005F07 D3E0                    	shl	AX,CL
 33430                                  	; 17/12/2022
 33431                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33432                                  	;			(MSDOS 5.0, MSDOS.SYS compatibility)
 33433                                  	; MSDOS 5.0
 33434                                  	;cmp	AX,100h   
 33435                                  	; 02/06/2019 - Retro DOS v4.0
 33436                                  	; MSDOS 6.0
 33437                                          ; 17/12/2022
 33438 00005F09 3D0002                  	cmp	AX,200h                 ; enough memory for PSP and stack?
 33439 00005F0C 76A3                    	jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 33440                                  	;;jbe	short Exec_No_Memj	; M000: jump if not
 33441                                  	;; Retro DOS v3.0 modification (on MSDOS 6.0 code) -03/08/2018-
 33442                                  	;;jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 33443                                  	;jbe	short Exec_No_Memj	; M000: jump if not
 33444                                  
 33445                                  					; M047: size of the block is < 64K
 33446 00005F0E 2D0001                  	sub	ax,100h			; M047: reserve 256 bytes for stack
 33447                                  
 33448                                  Exec_Read_Com:
 33449                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33450 00005F11 2D0001                  	sub	AX,100h 		; remember size of psp
 33451                                  Exec_Read_Block:
 33452 00005F14 50                      	push	AX			; save number to read
 33453                                  	;mov	bx,[bp-8]
 33454 00005F15 8B5EF8                  	mov	BX,Exec_FH		; of com file
 33455 00005F18 31C9                    	xor	CX,CX			; but seek to 0:0
 33456 00005F1A 89CA                    	mov	DX,CX
 33457 00005F1C 31C0                    	xor	AX,AX			; seek relative to beginning
 33458                                  	;invoke	$Lseek			; back to beginning of file
 33459 00005F1E E88909                  	call	_$LSEEK
 33460 00005F21 59                      	pop	CX			; number to read
 33461                                  	;mov	ds,[bp-20]
 33462 00005F22 8E5EEC                  	mov	DS,Exec_DMA
 33463 00005F25 31D2                    	xor	DX,DX
 33464 00005F27 51                      	push	CX
 33465 00005F28 E8E501                  	call	ExecRead
 33466 00005F2B 5E                      	pop	SI			; get number of bytes to read
 33467 00005F2C 7303                    	jnc	short OkRead
 33468 00005F2E E9B0FD                  	jmp	Exec_Bad_File
 33469                                  
 33470                                  	; 10/09/2018
 33471                                  OkRead:
 33472 00005F31 39F0                    	cmp	AX,SI			; did we read them all?
 33473                                  	; MSDOS 6.0
 33474                                  	;jz	short Exec_Chk_Com_Mem	; M00: exactly the wrong number...no 
 33475                                  	; MSDOS 3.3
 33476                                  	;;jz	short Exec_No_Memj	; M00: exactly the wrong number...
 33477 00005F33 7503                    	jne	short OkRead2
 33478 00005F35 E979FF                  	jmp	Exec_Chk_Com_Mem
 33479                                  OkRead2:
 33480                                  	; MSDOS 6.0
 33481 00005F38 368A1E[8400]            	mov	bl,[ss:ALLOCMSAVE]	; M063
 33482 00005F3D 36881E[0203]            	mov	[ss:AllocMethod],bl	; M063: restore alloc method
 33483                                  
 33484                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33485                                  	;test	byte [bp-5],2
 33486 00005F42 F646FB02                	test	Exec_Func,exec_func_overlay
 33487 00005F46 7532                    	jnz	short Exec_Set_PDB	; no starto, chumo!
 33488                                  
 33489                                  	;mov	ax,[bp-20]
 33490 00005F48 8B46EC                  	mov	AX,Exec_DMA
 33491 00005F4B 83E810                  	sub	AX,10h
 33492 00005F4E 36A3[C60F]              	mov	[SS:exec_init_CS],AX
 33493 00005F52 36C706[C40F]0001        	mov	word [SS:exec_init_IP],100h ; initial IP is 100h
 33494                                  
 33495                                  	; SI is AT MOST FF00h. Add FE to account for PSP - word
 33496                                  	; of 0 on stack.
 33497                                  
 33498 00005F59 81C6FE00                	add	SI,0FEh 		; make room for stack
 33499                                  
 33500                                  	; MSDOS 6.0
 33501 00005F5D 83FEFE                  	cmp	si,0FFFEh		; M047: Q: was there >= 64K available
 33502 00005F60 7404                    	je	short Exec_St_Ok	; M047: Y: stack is fine
 33503 00005F62 81C60001                	add	si,100h			; M047: N: add the xtra 100h for stack
 33504                                  
 33505                                  Exec_St_Ok:
 33506                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33507 00005F66 368936[C00F]            	mov	[SS:exec_init_SP],SI 	; max value for read is also SP!;smr;SS Override
 33508 00005F6B 36A3[C20F]              	mov	[SS:exec_init_SS],AX 					;smr;SS Override
 33509 00005F6F 8ED8                    	mov	DS,AX
 33510 00005F71 C7040000                	mov	WORD [SI],0		; 0 for return
 33511                                  
 33512                                  	; MSDOS 6.0
 33513                                  
 33514                                  	; M068
 33515                                  	;
 33516                                  	; We now determine if this is a Copy Protected App. If so the 
 33517                                  	; A20OFF_COUNT is set to 6. Note that ChkCopyProt will point to a 
 33518                                  	; a ret if DOS is loaded low. Also DS contains the load segment.
 33519                                  
 33520 00005F75 36FF16[6100]            	call	word [ss:ChkCopyProt]	
 33521                                  
 33522                                  Exec_Set_PDB:
 33523                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33524                                  	;mov	bx,[bp-8]
 33525 00005F7A 8B5EF8                  	mov	BX,Exec_FH		; we are finished with the file.
 33526 00005F7D E8A901                  	call	Exec_Dealloc
 33527 00005F80 55                      	push	BP
 33528                                  	;invoke	$Close			; release the jfn
 33529 00005F81 E8AA07                  	call	_$CLOSE
 33530 00005F84 5D                      	pop	BP
 33531 00005F85 E89301                  	call	Exec_Alloc
 33532                                  	;test	byte [bp-5],2
 33533 00005F88 F646FB02                	test	Exec_Func,exec_func_overlay
 33534 00005F8C 743A                    	jz	short Exec_Build_Header
 33535                                  
 33536                                  	; MSDOS 6.0
 33537 00005F8E E8C201                  	call	Scan_Execname
 33538 00005F91 E8D601                  	call	Scan_Special_Entries
 33539                                  ;SR;
 33540                                  ;The current lie strategy uses the PSP to store the lie version. However,
 33541                                  ;device drivers are loaded as overlays and have no PSP. To handle them, we
 33542                                  ;use the Sysinit flag provided by the BIOS as part of a structure pointed at
 33543                                  ;by BiosDataPtr. If this flag is set, the overlay call has been issued from
 33544                                  ;Sysinit and therefore must be a device driver load. We then get the lie 
 33545                                  ;version for this driver and put it into the Sysinit PSP. When the driver
 33546                                  ;issues the version check, it gets the lie version until the next overlay
 33547                                  ;call is issued.
 33548                                  
 33549 00005F94 36803E[3F10]00          	cmp	byte [ss:DriverLoad],0	;was Sysinit processing done?
 33550 00005F9A 7426                    	je	short norm_ovl		;yes, no special handling
 33551 00005F9C 56                      	push	si
 33552 00005F9D 06                      	push	es
 33553 00005F9E 36C436[4010]            	les	si,[ss:BiosDataPtr]	;get ptr to BIOS data block
 33554                                  	 
 33555                                  	; (es:si points to 'SysinitPresent' address/flag in retrodos4.s) 
 33556 00005FA3 26803C00                	cmp	byte [es:si],0		;in Sysinit?
 33557 00005FA7 7411                    	je	short sysinit_done	;no, Sysinit is finished
 33558                                  	
 33559 00005FA9 368E06[3003]            	mov	es,[ss:CurrentPDB]	;es = current PSP (Sysinit PSP)
 33560 00005FAE 36FF36[BD0E]            	push	word [ss:SPECIAL_VERSION]
 33561 00005FB3 268F064000              	pop	word [es:PDB.Version]	;store lie version in Sysinit PSP
 33562                                  		;;; PDB.VERSION
 33563 00005FB8 EB06                    	jmp	short setver_done
 33564                                  sysinit_done:
 33565 00005FBA 36C606[3F10]00          	mov	byte [ss:DriverLoad],0	;Sysinit done,special handling off
 33566                                  setver_done:
 33567 00005FC0 07                      	pop	es
 33568 00005FC1 5E                      	pop	si
 33569                                  norm_ovl:
 33570                                  	;leave
 33571 00005FC2 89EC                    	mov	sp,bp		
 33572 00005FC4 5D                      	pop	bp
 33573                                  
 33574                                  	;transfer SYS_RET_OK		; overlay load -> done
 33575 00005FC5 E96FA6                  	jmp	SYS_RET_OK
 33576                                  
 33577                                  Exec_Build_Header:
 33578                                  	;mov	dx,[bp-18]
 33579 00005FC8 8B56EE                  	mov	DX,Exec_Load_Block
 33580                                  					; assign the space to the process
 33581                                  	;mov	si,1
 33582 00005FCB BE0100                  	mov	SI,ARENA.OWNER		; pointer to owner field
 33583                                  	;mov	ax,[bp-14]
 33584 00005FCE 8B46F2                  	mov	AX,Exec_Environ 	; get environ pointer
 33585 00005FD1 09C0                    	or	AX,AX
 33586 00005FD3 7405                    	jz	short No_Owner		; no environment
 33587                                  
 33588 00005FD5 48                      	dec	AX			; point to header
 33589 00005FD6 8ED8                    	mov	DS,AX
 33590 00005FD8 8914                    	mov	[SI],DX 		; assign ownership
 33591                                  No_Owner:
 33592                                  	;mov	ax,[bp-18]
 33593                                  	;mov	AX,Exec_Load_Block	; get load block pointer
 33594                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 33595                                  	; 17/12/2022
 33596 00005FDA 89D0                    	mov	ax,dx ; 06/06/2019
 33597                                  	;mov	ax,Exec_Load_Block	; get load block pointer
 33598                                  	
 33599 00005FDC 48                      	dec	AX
 33600 00005FDD 8ED8                    	mov	DS,AX			; point to header
 33601 00005FDF 8914                    	mov	[SI],DX 		; assign ownership
 33602                                  
 33603                                  	; MSDOS 6.0
 33604 00005FE1 1E                      	push	DS			;AN000;MS. make ES=DS
 33605 00005FE2 07                      	pop	ES			;AN000;MS.
 33606                                  	;mov	di,8
 33607 00005FE3 BF0800                  	mov	DI,ARENA.NAME		;AN000;MS. ES:DI points to destination
 33608 00005FE6 E86A01                  	call	Scan_Execname		;AN007;MS. parse execname
 33609                                  					;	   ds:si->name, cx=name length
 33610 00005FE9 51                      	push	CX			;AN007;;MS. save for fake version
 33611 00005FEA 56                      	push	SI			;AN007;;MS. save for fake version
 33612                                  
 33613                                  MoveName:				;AN000;
 33614 00005FEB AC                      	lodsb				;AN000;;MS. get char
 33615 00005FEC 3C2E                    	cmp	AL,'.'			;AN000;;MS. is '.' ,may be name.exe
 33616 00005FEE 7408                    	jz	short Mem_Done		;AN000;;MS. no, move to header
 33617                                  					;AN000;
 33618 00005FF0 AA                      	stosb				;AN000;;MS. move char
 33619                                  					; MSKK bug fix - limit length copied
 33620 00005FF1 83FF10                  	cmp	di,16 ; ARENAHEADERSIZE	; end of memory arena block?
 33621 00005FF4 7302                    	jae	short Mem_Done		; jump if so
 33622                                  	;
 33623 00005FF6 E2F3                    	loop	MoveName		;AN000;;MS. continue
 33624                                  Mem_Done:				;AN000;
 33625 00005FF8 30C0                    	xor	AL,AL			;AN000;;MS. make ASCIIZ
 33626                                  	;cmp	di,16
 33627 00005FFA 83FF10                  	cmp	DI,ARENAHEADERSIZE ; 16 ;AN000;MS. if not all filled
 33628 00005FFD 7301                    	jae	short Fill8		;AN000;MS.
 33629                                  	
 33630 00005FFF AA                      	stosb				;AN000;MS.
 33631                                  	
 33632                                  Fill8:					;AN000;
 33633 00006000 5E                      	pop	SI			;AN007;MS. ds:si -> file name
 33634 00006001 59                      	pop	CX			;AN007;MS.
 33635                                  	
 33636 00006002 E86501                  	call	Scan_Special_Entries	;AN007;MS.
 33637                                  
 33638                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33639 00006005 52                      	push	DX
 33640                                  	;mov	si,[bp-16]
 33641 00006006 8B76F0                  	mov	SI,Exec_Size
 33642 00006009 01D6                    	add	SI,DX
 33643                                  	;Invoke	$Dup_PDB		; ES is now PDB
 33644 0000600B E88BB0                  	call	_$DUP_PDB
 33645 0000600E 5A                      	pop	DX
 33646                                  
 33647                                  	;push	word [bp-14]
 33648 0000600F FF76F2                  	push	Exec_Environ
 33649                                  	;pop	WORD [ES:2Ch]
 33650 00006012 268F062C00              	pop	word [ES:PDB.ENVIRON]
 33651                                  
 33652                                  	; MSDOS 6.0			; *** Added for DOS 5.00
 33653                                  					; version number in PSP
 33654 00006017 36FF36[BD0E]             	push	word [ss:SPECIAL_VERSION] ; Set the DOS version number to
 33655 0000601C 268F064000              	pop	word [ES:PDB.Version]	; to be used for this application
 33656                                  		; PDB.VERSION
 33657                                  
 33658                                  	; MSDOS 3.3 (& MSDOS 6.0)	; set up proper command line stuff
 33659                                  	;lds	si,[bp-4]
 33660 00006021 C576FC                  	lds	SI,Exec_Blk		; get the block
 33661 00006024 1E                      	push	DS			; save its location
 33662 00006025 56                      	push	SI
 33663                                  	;lds	si,[si+6]
 33664 00006026 C57406                  	lds	SI,[SI+EXEC0.5C_FCB]	; get the 5c fcb
 33665                                  
 33666                                  	; DS points to user space 5C FCB
 33667                                  
 33668 00006029 B90C00                  	mov	CX,12			; copy drive, name and ext
 33669 0000602C 51                      	push	CX
 33670 0000602D BF5C00                  	mov	DI,5Ch
 33671 00006030 8A1C                    	mov	BL,[SI]
 33672 00006032 F3A4                    	rep	movsb
 33673                                  
 33674                                  	; DI = 5Ch + 12 = 5Ch + 0Ch = 68h
 33675                                  
 33676 00006034 31C0                    	xor	AX,AX			; zero extent, etc for CPM
 33677 00006036 AB                      	stosw
 33678 00006037 AB                      	stosw
 33679                                  
 33680                                  	; DI = 5Ch + 12 + 4 = 5Ch + 10h = 6Ch
 33681                                  
 33682 00006038 59                      	pop	CX
 33683 00006039 5E                      	pop	SI			; get block
 33684 0000603A 1F                      	pop	DS
 33685 0000603B 1E                      	push	DS			; save (again)
 33686 0000603C 56                      	push	SI
 33687                                  	;lds	si,[si+0Ah]
 33688 0000603D C5740A                  	lds	SI,[SI+EXEC0.6C_FCB]	; get 6C FCB
 33689                                  
 33690                                  	; DS points to user space 6C FCB
 33691                                  
 33692 00006040 8A3C                    	mov	BH,[SI] 		; do same as above
 33693 00006042 F3A4                    	rep	movsb
 33694 00006044 AB                      	stosw
 33695 00006045 AB                      	stosw
 33696 00006046 5E                      	pop	SI			; get block (last time)
 33697 00006047 1F                      	pop	DS
 33698                                  	;ld	si,[si+2]
 33699 00006048 C57402                  	lds	SI,[SI+EXEC0.COM_LINE]	; command line
 33700                                  
 33701                                  	; DS points to user space 80 command line
 33702                                  
 33703 0000604B 80C980                  	or	CL,80h
 33704 0000604E 89CF                    	mov	DI,CX
 33705 00006050 F3A4                    	rep	movsb			; Wham!
 33706                                  
 33707                                  	; Process BX into default AX (validity of drive specs on args).
 33708                                  	; We no longer care about DS:SI.
 33709                                  
 33710 00006052 FEC9                    	dec	CL			; get 0FFh in CL
 33711 00006054 88F8                    	mov	AL,BH
 33712 00006056 30FF                    	xor	BH,BH
 33713                                  	;invoke	GetVisDrv
 33714 00006058 E8400A                  	call	GetVisDrv
 33715 0000605B 7302                    	jnc	short Exec_BL
 33716                                  
 33717 0000605D 88CF                    	mov	BH,CL
 33718                                  
 33719                                  Exec_BL:
 33720 0000605F 88D8                    	mov	AL,BL
 33721 00006061 30DB                    	xor	BL,BL
 33722                                  	;invoke	GetVisDrv
 33723 00006063 E8350A                  	call	GetVisDrv
 33724 00006066 7302                    	jnc	short Exec_Set_Return
 33725                                  
 33726 00006068 88CB                    	mov	BL,CL
 33727                                  
 33728                                  Exec_Set_Return:
 33729                                  	;invoke	Get_User_Stack			; get his return address
 33730 0000606A E814A4                  	call	Get_User_Stack
 33731                                  
 33732                                  	;push	word [si+14h]
 33733 0000606D FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 33734                                  	;push	word [si+12h]
 33735 00006070 FF7412                  	push	word [SI+user_env.user_IP]
 33736                                  	;push	word [si+14h]
 33737 00006073 FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 33738                                  	;push	word [si+12h]
 33739 00006076 FF7412                  	push	word [SI+user_env.user_IP]
 33740                                  	;pop	word [ES:0Ah]
 33741 00006079 268F060A00              	pop	WORD [ES:PDB.EXIT]
 33742                                  	;pop	word [ES:0Ch]
 33743 0000607E 268F060C00              	pop	WORD [ES:PDB.EXIT+2]
 33744                                  
 33745 00006083 31C0                    	xor	AX,AX
 33746 00006085 8ED8                    	mov	DS,AX
 33747                                  					; save them where we can get them
 33748                                  					; later when the child exits.
 33749                                  	;pop	word [88h]
 33750 00006087 8F068800                	pop	word [addr_int_terminate] ; 22h*4
 33751                                  	;pop	word [90h]
 33752 0000608B 8F068A00                	pop	word [addr_int_terminate+2] ; (22h*4)+2
 33753                                  
 33754 0000608F 36C706[2C03]8000        	mov	WORD [SS:DMAADD],80h	; SS Override
 33755 00006096 368E1E[3003]            	mov	DS,[SS:CurrentPDB]	; SS Override
 33756 0000609B 368C1E[2E03]            	mov	[SS:DMAADD+2],DS	; SS Override
 33757                                  
 33758                                  	;test	byte [bp-5],1
 33759 000060A0 F646FB01                	test	Exec_Func,exec_func_no_execute
 33760 000060A4 7427                    	jz	short exec_go
 33761                                  
 33762 000060A6 36C536[C00F]            	lds	SI,[SS:exec_init_SP]	; get stack SS Override
 33763                                  	;les	di,[bp-4]
 33764 000060AB C47EFC                  	les	DI,Exec_Blk		; and block for return
 33765                                  	;mov	[es:di+10h],ds
 33766 000060AE 268C5D10                	mov	[ES:DI+EXEC1.SS],DS	; return SS
 33767                                  
 33768 000060B2 4E                      	dec	SI			; 'push' default AX
 33769 000060B3 4E                      	dec	SI
 33770 000060B4 891C                    	mov	[SI],BX 		; save default AX reg
 33771                                  	;mov	[es:di+0Eh], si
 33772 000060B6 2689750E                	mov	[ES:DI+EXEC1.SP],SI	; return 'SP'
 33773                                  
 33774 000060BA 36C506[C40F]            	lds	AX,[SS:exec_init_IP]	; SS Override
 33775                                  	;mov	[es:di+14h],ds
 33776 000060BF 268C5D14                	mov	[ES:DI+EXEC1.CS],DS	; initial entry stuff
 33777                                  	;mov	[es:di+12h],ax
 33778 000060C3 26894512                	mov	[ES:DI+EXEC1.IP],AX
 33779                                  	
 33780                                  	;leave
 33781 000060C7 89EC                    	mov	sp,bp
 33782 000060C9 5D                      	pop	bp	
 33783                                  
 33784                                  	;transfer SYS_RET_OK
 33785 000060CA E96AA5                  	jmp	SYS_RET_OK
 33786                                  
 33787                                  exec_go:
 33788 000060CD 36C536[C40F]            	lds	SI,[SS:exec_init_IP]	; get entry point SS Override
 33789 000060D2 36C43E[C00F]            	les	DI,[SS:exec_init_SP]	; new stack SS Override
 33790 000060D7 8CC0                    	mov	AX,ES
 33791                                  
 33792                                  	; MSDOS 6.0
 33793 000060D9 36803E[F211]00          	cmp	byte [SS:DosHasHMA],0	; Q: is dos in HMA (M021)
 33794 000060DF 741A                    	je	short Xfer_To_User	; N: transfer control to user
 33795                                  
 33796 000060E1 1E                      	push	ds			; Y: control must go to low mem stub
 33797                                  		
 33798 000060E2 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]		;    where we disable a20 and Xfer 
 33799                                  					;    control to user 
 33800 000060E7 800E[8600]04            	or	byte [DOS_FLAG],EXECA20OFF ; M068:
 33801                                  					; M004: Set bit to signal int 21
 33802                                  					; ah = 25 & ah= 49. See dossym.inc 
 33803                                  					; under TAG M003 & M009 for 
 33804                                  					; explanation
 33805 000060EC 8916[6300]              	mov	[A20OFF_PSP],dx		; M068: set the PSP for which A20 is
 33806                                  					; M068: going to be turned OFF.
 33807                                  	
 33808 000060F0 8CD8                    	mov	ax,ds			; ax = segment of low mem stub
 33809 000060F2 1F                      	pop	ds
 33810                                  	
 33811 000060F3 50                      	push	ax			; ret far into the low mem stub
 33812 000060F4 B8[FB10]                	mov	ax,disa20_xfer
 33813 000060F7 50                      	push	ax
 33814 000060F8 8CC0                    	mov	AX,ES			; restore ax
 33815 000060FA CB                      	retf
 33816                                  
 33817                                  Xfer_To_User:
 33818                                  	; DS:SI points to entry point
 33819                                  	; AX:DI points to initial stack
 33820                                  	; DX has PDB pointer
 33821                                  	; BX has initial AX value
 33822                                  
 33823 000060FB FA                      	cli
 33824                                  	; 15/08/2018
 33825 000060FC 36C606[2103]00          	mov	BYTE [SS:INDOS],0	; SS Override
 33826                                  
 33827 00006102 8ED0                    	mov	SS,AX			; set up user's stack
 33828 00006104 89FC                    	mov	SP,DI			; and SP
 33829 00006106 FB                      	sti
 33830                                  
 33831 00006107 1E                      	push	DS			; fake long call to entry
 33832 00006108 56                      	push	SI
 33833 00006109 8EC2                    	mov	ES,DX			; set up proper seg registers
 33834 0000610B 8EDA                    	mov	DS,DX
 33835 0000610D 89D8                    	mov	AX,BX			; set up proper AX
 33836                                  
 33837 0000610F CB                      	retf
 33838                                  
 33839                                  ; 04/08/2018 - Retro DOS v3.0
 33840                                  
 33841                                  ;----------------------------------------------------------------------------
 33842                                  ;
 33843                                  ;----------------------------------------------------------------------------
 33844                                  
 33845                                  ExecRead:
 33846 00006110 E81600                  	CALL	Exec_Dealloc
 33847                                  	;mov	bx,[bp-8]
 33848 00006113 8B5EF8                  	MOV	bx,Exec_FH
 33849                                  
 33850 00006116 55                      	PUSH	BP
 33851 00006117 E82507                  	call	_$READ
 33852 0000611A 5D                      	POP	BP
 33853                                  
 33854                                  	;CALL	Exec_Alloc
 33855                                  	;retn
 33856                                  	; 18/12/2022
 33857                                  	;jmp	short Exec_Alloc
 33858                                  
 33859                                  ; 18/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 
 33860                                  
 33861                                  ;----------------------------------------------------------------------------
 33862                                  ;
 33863                                  ;----------------------------------------------------------------------------
 33864                                  
 33865                                  Exec_Alloc:
 33866 0000611B 53                      	push	BX
 33867                                  	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 33868                                  	; 20/05/2019 - Retro DOS v4.0
 33869                                  	; MSDOS 6.0
 33870 0000611C 368B1E[3003]            	mov	bx,[SS:CurrentPDB]  ; SS Override
 33871 00006121 E81000                  	call	ChangeOwners
 33872 00006124 E805B2                  	call	LCritMEM
 33873 00006127 5B                      	pop	BX
 33874 00006128 C3                      	retn
 33875                                  
 33876                                  ;----------------------------------------------------------------------------
 33877                                  ;
 33878                                  ;----------------------------------------------------------------------------
 33879                                  
 33880                                  Exec_Dealloc:
 33881 00006129 53                      	push	BX
 33882                                  	;mov	bx,0
 33883 0000612A 29DB                    	sub	BX,BX		; (bx) = ARENA_OWNER_SYSTEM
 33884 0000612C E8E2B1                  	call	ECritMEM
 33885 0000612F E80200                  	call	ChangeOwners
 33886 00006132 5B                      	pop	BX
 33887 00006133 C3                      	retn
 33888                                  
 33889                                  ; 18/12/2022
 33890                                  %if 0
 33891                                  ;----------------------------------------------------------------------------
 33892                                  ;
 33893                                  ;----------------------------------------------------------------------------
 33894                                  
 33895                                  Exec_Alloc:
 33896                                  	push	BX
 33897                                  	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 33898                                  	; 20/05/2019 - Retro DOS v4.0
 33899                                  	; MSDOS 6.0
 33900                                  	mov	bx,[SS:CurrentPDB]  ; SS Override
 33901                                  	call	ChangeOwners
 33902                                  	call	LCritMEM
 33903                                  	pop	BX
 33904                                  	retn
 33905                                  
 33906                                  %endif
 33907                                  
 33908                                  ;----------------------------------------------------------------------------
 33909                                  ;
 33910                                  ;----------------------------------------------------------------------------
 33911                                  
 33912                                  ChangeOwners:
 33913 00006134 9C                      	pushf
 33914 00006135 50                      	push	AX
 33915                                  	;mov	ax,[bp-14]
 33916 00006136 8B46F2                  	mov	AX,Exec_Environ
 33917 00006139 E80900                  	call	ChangeOwner
 33918                                  	;mov	ax,[bp-18]
 33919 0000613C 8B46EE                  	mov	AX,Exec_Load_Block
 33920 0000613F E80300                  	call	ChangeOwner
 33921 00006142 58                      	pop	AX
 33922 00006143 9D                      	popf
 33923                                  chgown_retn:
 33924 00006144 C3                      	retn
 33925                                  
 33926                                  ;----------------------------------------------------------------------------
 33927                                  ;
 33928                                  ;----------------------------------------------------------------------------
 33929                                  
 33930                                  ChangeOwner:
 33931 00006145 09C0                    	or	AX,AX			; is area allocated?
 33932 00006147 74FB                    	jz	short chgown_retn	; no, do nothing
 33933 00006149 48                      	dec	AX
 33934 0000614A 1E                      	push	DS
 33935 0000614B 8ED8                    	mov	DS,AX
 33936 0000614D 891E0100                	mov	[ARENA.OWNER],BX
 33937 00006151 1F                      	pop	DS
 33938 00006152 C3                      	retn
 33939                                  
 33940                                  ;----------------------------------------------------------------------------
 33941                                  ;
 33942                                  ;----------------------------------------------------------------------------
 33943                                  
 33944                                  ; 20/05/2019 - Retro DOS v4.0
 33945                                  
 33946                                  	; MSDOS 6.0
 33947                                  Scan_Execname:
 33948 00006153 C576E6                  	lds	SI,ExecName		; DS:SI points to name
 33949                                  Scan_Execname1:				; M028
 33950                                  Save_Begin:				;
 33951 00006156 89F1                    	mov	CX,SI			; CX= starting addr
 33952                                  Scan0:					;
 33953 00006158 AC                      	lodsb				; get char
 33954                                  
 33955 00006159 3C3A                    	cmp	AL,':'			; is ':' , may be A:name
 33956 0000615B 74F9                    	jz	short Save_Begin	; yes, save si
 33957 0000615D 3C5C                    	cmp	AL,'\'                  ; is '\', may be A:\name
 33958 0000615F 74F5                    	jz	short Save_Begin	; yes, save si
 33959 00006161 3C00                    	cmp	AL,0			; is end of name
 33960 00006163 75F3                    	jnz	short Scan0		; no, continue scanning
 33961 00006165 29CE                    	sub	SI,CX			; get name's length
 33962 00006167 87F1                    	xchg	SI,CX			; cx= length, si= starting addr
 33963                                  
 33964 00006169 C3                      	retn
 33965                                  
 33966                                  ;----------------------------------------------------------------------------
 33967                                  ;
 33968                                  ;----------------------------------------------------------------------------
 33969                                  
 33970                                  ; 20/05/2019 - Retro DOS v4.0
 33971                                  
 33972                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33973                                  ; DOSCODE:A0EDh (MSDOS 5.0, MSDOS.SYS)
 33974                                  
 33975                                  	; MSDOS 6.0
 33976                                  
 33977                                  Scan_Special_Entries:
 33978                                  
 33979 0000616A 49                      	dec	CX			; cx= name length
 33980                                  ;M060	mov	DI,[Special_Entries]	; es:di -> addr of special entries
 33981                                  					;reset to current version
 33982                                  	;mov	word [ss:SPECIAL_VERSION],1406h 
 33983                                  				; (MSDOS 6.21, MSDOS.SYS, DOSCODE:A14Eh)
 33984                                  	;mov	word [ss:SPECIAL_VERSION],5
 33985                                  				; (MSDOS 5.0, MSDOS.SYS, DOSCODE:A0EEh)
 33986                                  
 33987                                  				; 5 for Retro DOS 4.0 (01/12/2022, MSDOS 5.0)
 33988 0000616B 36C706[BD0E]0616        	mov	word [ss:SPECIAL_VERSION],(MINOR_VERSION<<8)+MAJOR_VERSION
 33989                                  				; 0005h for Retro DOS v4.1 (MSDOS 5.0)
 33990                                  				; 24/09/2023
 33991                                  				; 1606h for Retro DOS v4.2 (MSDOS 6.22)
 33992                                  ;***	call	Reset_Version
 33993                                  
 33994                                  ;M060	push	SS
 33995                                  ;M060	pop	ES
 33996                                  
 33997 00006172 36C43E[5D00]            	les	DI,[SS:UU_IFS_DOS_CALL]	;M060; ES:DI --> Table in SETVER.SYS
 33998 00006177 8CC0                    	mov	AX,ES			;M060; First do a NULL ptr check to
 33999 00006179 09F8                    	or	AX,DI			;M060; be sure the table exists
 34000 0000617B 7427                    	jz	short End_List		;M060; If ZR then no table
 34001                                  
 34002                                  GetEntries:
 34003 0000617D 268A05                  	mov	AL,[ES:DI]		; end of list
 34004 00006180 08C0                    	or	AL,AL
 34005 00006182 7420                    	jz	short End_List		; yes
 34006                                  
 34007 00006184 36893E[0E06]            	mov	[ss:TEMP_VAR2],DI	; save di
 34008 00006189 38C8                    	cmp	AL,CL			; same length ?
 34009 0000618B 751B                    	jnz	short SkipOne 		; no
 34010                                  
 34011 0000618D 47                      	inc	DI			; es:di -> special name
 34012 0000618E 51                      	push	CX			; save length and name addr
 34013 0000618F 56                      	push	SI
 34014                                  
 34015                                  ; M050 - BEGIN
 34016                                  
 34017 00006190 50                      	push	ax			; save len
 34018                                  sse_next_char:
 34019 00006191 AC                      	lodsb
 34020 00006192 E8D1EE                  	call	UCase
 34021 00006195 AE                      	scasb
 34022 00006196 750D                    	jne	short Not_Matched
 34023 00006198 E2F7                    	loop	sse_next_char
 34024                                  	
 34025                                  ;	repz	cmpsb			; same name ?
 34026                                  ;	jnz	short Not_Matched	; no
 34027                                  
 34028 0000619A 58                      	pop	ax			; take len off the stack
 34029                                  
 34030                                  ; M050 - END
 34031                                  
 34032 0000619B 268B05                  	mov	AX,[ES:DI]		; get special version
 34033 0000619E 36A3[BD0E]              	mov	[ss:SPECIAL_VERSION],AX	; save it
 34034                                  
 34035                                  ;***	mov	AL,[ES:DI+2]		; get fake count
 34036                                  ;***	mov	[ss:FAKE_COUNT],AL 	; save it
 34037                                  
 34038 000061A2 5E                      	pop	SI
 34039 000061A3 59                      	pop	CX
 34040                                  	; 18/12/2022
 34041                                  	;jmp	SHORT End_List
 34042                                  
 34043                                  	; 18/12/2022
 34044                                  End_List:
 34045 000061A4 C3                      	retn
 34046                                  
 34047                                  Not_Matched:
 34048 000061A5 58                      	pop	ax			; get len from stack ; M050
 34049 000061A6 5E                      	pop	SI			; restore si,cx
 34050 000061A7 59                      	pop	CX
 34051                                  
 34052                                  SkipOne:
 34053 000061A8 368B3E[0E06]            	mov	DI,[ss:TEMP_VAR2]	; restore old di use SS Override
 34054 000061AD 30E4                    	xor	AH,AH			; position to next entry
 34055 000061AF 01C7                    	add	DI,AX
 34056                                  
 34057 000061B1 83C703                  	add	DI,3			; DI -> next entry length
 34058                                  ;***	add	DI,4			; DI -> next entry length
 34059                                  
 34060 000061B4 EBC7                    	jmp	short GetEntries
 34061                                  
 34062                                  	; 18/12/2022
 34063                                  ;End_List:
 34064                                  	;retn
 34065                                  
 34066                                  ; 04/08/2018 - Retro DOS v3.0
 34067                                  ; IBMDOS.COm (MSDOS 3.3, 1987) - Offset 633Dh
 34068                                  
 34069                                  ;----------------------------------------------------------------------------
 34070                                  ;SUBTTL Terminate and stay resident handler
 34071                                  ;
 34072                                  ; Input:    DX is  an  offset  from  CurrentPDB  at which to
 34073                                  ;	    truncate the current block.
 34074                                  ;
 34075                                  ; output:   The current block is truncated (expanded) to be [DX+15]/16
 34076                                  ;	    paragraphs long.  An exit is simulated via resetting CurrentPDB
 34077                                  ;	    and restoring the vectors.
 34078                                  ;
 34079                                  ;----------------------------------------------------------------------------
 34080                                  
 34081                                  	; 20/05/2019 - Retro DOS v4.0
 34082                                  	; DOSCODE:A19Bh (MSDOS 6.21, MSDOS.SYS)
 34083                                  
 34084                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 34085                                  	; DOSCODE:A13Bh (MSDOS 5.0, MSDOS.SYS)
 34086                                  
 34087                                  _$KEEP_PROCESS:
 34088 000061B6 50                      	push	AX			; keep exit code around
 34089                                  	;mov	byte [SS:EXIT_TYPE],3
 34090 000061B7 36C606[7C05]03          	mov	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS
 34091 000061BD 368E06[3003]            	mov	ES,[SS:CurrentPDB]
 34092 000061C2 83FA06                  	cmp	DX,6h			; keep enough space around for system
 34093 000061C5 7303                    	jae	short Keep_Shrink	; info
 34094                                  
 34095 000061C7 BA0600                  	mov	DX,6h
 34096                                  
 34097                                  Keep_Shrink:
 34098 000061CA 89D3                    	mov	BX,DX
 34099 000061CC 53                      	push	BX
 34100 000061CD 06                      	push	ES
 34101 000061CE E82E02                  	call	_$SETBLOCK		; ignore return codes.
 34102 000061D1 1F                      	pop	DS
 34103 000061D2 5B                      	pop	BX
 34104 000061D3 7207                    	jc	short Keep_Done		; failed on modification
 34105                                  
 34106 000061D5 8CD8                    	mov	AX,DS
 34107 000061D7 01D8                    	add	AX,BX
 34108                                  	;mov	[2],ax
 34109 000061D9 A30200                  	mov	[PDB.BLOCK_LEN],AX	;PBUGBUG
 34110                                  
 34111                                  Keep_Done:
 34112 000061DC 58                      	pop	AX
 34113 000061DD EB26                    	jmp	SHORT exit_inner	; and let abort take care of the rest
 34114                                  
 34115                                  ;----------------------------------------------------------------------------
 34116                                  ;
 34117                                  ;----------------------------------------------------------------------------
 34118                                  
 34119                                  STAY_RESIDENT:
 34120                                  	;mov	ax,3100h
 34121 000061DF B80031                  	mov	AX,(KEEP_PROCESS<<8)+0 ; Lower part is return code;PBUGBUG
 34122 000061E2 83C20F                  	add	DX,15
 34123 000061E5 D1DA                    	rcr	DX,1
 34124 000061E7 B103                    	mov	CL,3
 34125 000061E9 D3EA                    	shr	DX,CL
 34126                                  
 34127 000061EB E91AA1                  	jmp	COMMAND
 34128                                  
 34129                                  ;----------------------------------------------------------------------------
 34130                                  ;SUBTTL $EXIT - return to parent process
 34131                                  ;   Assembler usage:
 34132                                  ;	    MOV     AL, code
 34133                                  ;	    MOV     AH, Exit
 34134                                  ;	    INT     int_command
 34135                                  ;   Error return:
 34136                                  ;	    None.
 34137                                  ;
 34138                                  ;----------------------------------------------------------------------------
 34139                                  
 34140                                  	; 20/05/2019 - Retro DOS v4.0
 34141                                  	; DOSCODE:A1D3h (MSDOS 6.21, MSDOS.SYS)
 34142                                  
 34143                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 34144                                  	; DOSCODE:A173h (MSDOS 5.0, MSDOS.SYS)
 34145                                  _$EXIT:
 34146                                  	; 04/08/2018 - Retro DOS v3.0
 34147                                  	; IBMDOSDOS.COM (MSDOS 3.3, 1987) - Offset 6375h
 34148 000061EE 30E4                    	xor	AH,AH
 34149 000061F0 368626[4D03]            	xchg	AH,[SS:DidCTRLC]
 34150 000061F5 08E4                    	or	AH,AH
 34151                                  	;mov	BYTE [SS:EXIT_TYPE],0
 34152 000061F7 36C606[7C05]00          	mov	BYTE [SS:EXIT_TYPE],EXIT_TERMINATE
 34153 000061FD 7406                    	jz	short exit_inner
 34154                                  	;mov	BYTE [SS:EXIT_TYPE],1
 34155 000061FF 36C606[7C05]01          	mov	BYTE [SS:EXIT_TYPE],EXIT_CTRL_C
 34156                                  
 34157                                  	;entry	Exit_inner
 34158                                  exit_inner:
 34159 00006205 E879A2                  	call	Get_User_Stack		;PBUGBUG
 34160                                  
 34161 00006208 36FF36[3003]            	push	word [ss:CurrentPDB]
 34162                                  	;pop	word [si+14h]
 34163 0000620D 8F4414                  	pop	word [SI+user_env.user_CS] ;PBUGBUG
 34164 00006210 EB08                    	jmp	short abort_inner
 34165                                  
 34166                                  ;BREAK <$ABORT -- Terminate a process>
 34167                                  ;----------------------------------------------------------------------------
 34168                                  ; Inputs:
 34169                                  ;	user_CS:00 must point to valid program header block
 34170                                  ; Function:
 34171                                  ;	Restore terminate and Cntrl-C addresses, flush buffers and transfer
 34172                                  ;	to the terminate address
 34173                                  ; Returns:
 34174                                  ;	TO THE TERMINATE ADDRESS
 34175                                  ;----------------------------------------------------------------------------
 34176                                  
 34177                                  _$ABORT:
 34178 00006212 30C0                    	xor	AL,AL
 34179                                  	;mov	byte [SS:EXIT_TYPE],0
 34180                                  	;mov	byte [SS:EXIT_TYPE],AL ; = 0
 34181 00006214 36C606[7C05]00          	mov	byte [SS:EXIT_TYPE],EXIT_ABORT
 34182                                  
 34183                                  	; abort_inner must have AL set as the exit code! The exit type
 34184                                  	; is retrieved from exit_type. Also, the PDB at user_CS needs
 34185                                  	; to be correct as the one that is terminating.
 34186                                  
 34187                                  abort_inner:
 34188 0000621A 368A26[7C05]            	mov	AH,[SS:EXIT_TYPE]
 34189 0000621F 36A3[3403]              	mov	[SS:exit_code],AX
 34190 00006223 E85BA2                  	call	Get_User_Stack
 34191                                  
 34192                                  	;mov	ds,[si+14h]
 34193 00006226 8E5C14                  	mov	DS,[SI+user_env.user_CS] ; set up old interrupts ;PBUGBUG
 34194 00006229 31C0                    	xor	AX,AX
 34195 0000622B 8EC0                    	mov	ES,AX
 34196                                  	;mov	si,10
 34197 0000622D BE0A00                  	mov	SI,SAVEXIT
 34198                                  	;mov	di,88h
 34199 00006230 BF8800                  	mov	DI,addr_int_terminate
 34200 00006233 A5                      	movsw
 34201 00006234 A5                      	movsw
 34202 00006235 A5                      	movsw
 34203 00006236 A5                      	movsw
 34204 00006237 A5                      	movsw
 34205 00006238 A5                      	movsw
 34206 00006239 E944F2                  	jmp	reset_environment
 34207                                  
 34208                                  ;----------------------------------------------------------------------------
 34209                                  ;
 34210                                  ; fixexepatch will point to this is DOS loads low. 
 34211                                  ;
 34212                                  ;----------------------------------------------------------------------------
 34213                                  ; MSDOS 6.0
 34214                                  
 34215                                  ; 29/04/2019 - Retro DOS v4.0
 34216                                  ; DOSCODE:A221h (MSDOS 6.21, MSDOS.SYS)
 34217                                  
 34218                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 34219                                  ; DOSCODE:A1C1h (MSDOS 5.0, MSDOS.SYS)
 34220                                  
 34221                                  RetExePatch: ; proc near
 34222                                  	
 34223 0000623C C3                      	retn
 34224                                  
 34225                                  ;============================================================================
 34226                                  ; ALLOC.ASM, MSDOS 6.0, 1991
 34227                                  ;============================================================================
 34228                                  ; 04/08/2018 - Retro DOS v3.0
 34229                                  ; 14/05/2019 - Retro DOS v4.0
 34230                                  
 34231                                  ;	TITLE ALLOC.ASM - memory arena manager	NAME Alloc
 34232                                  
 34233                                  ;**
 34234                                  ;	Microsoft Confidential
 34235                                  ;	Copyright (C) Microsoft Corporation 1991
 34236                                  ;	All Rights Reserved.
 34237                                  ;
 34238                                  ;	Memory related system calls and low level routines for MSDOS 2.X.
 34239                                  ;	I/O specs are defined in DISPATCH.
 34240                                  ;
 34241                                  ;	$ALLOC
 34242                                  ;	$SETBLOCK
 34243                                  ;	$DEALLOC
 34244                                  ;	$AllocOper
 34245                                  ;	arena_free_process
 34246                                  ;	arena_next
 34247                                  ;	check_signature
 34248                                  ;	Coalesce
 34249                                  ;
 34250                                  ;	Modification history:
 34251                                  ;
 34252                                  ;	    Created: ARR 30 March 1983
 34253                                  ;
 34254                                  ;	    Revision: M000 - added support for allocing UMBs. 7/9/90
 34255                                  ;		      M003 - added support for link/unlink UMBs from
 34256                                  ;			     DOS arena chain. 7/18/90
 34257                                  ;		      M009 - Added error returns invalid function and 
 34258                                  ;			     arena trashed in set link state call.
 34259                                  ;		      M010 - Release UMB arenas allocated to current PDB
 34260                                  ;			     if UMB_HEAD is initialized.
 34261                                  ;
 34262                                  ;		      M016 - MACE utilities mkeyrate.com version 1.0 
 34263                                  ;			     support. Please see under M009 in 
 34264                                  ;			     ..\inc\dossym.inc. 8/31/90.
 34265                                  ;
 34266                                  ;		      M061 - In GetLastArena, if linking in UMBs check to make
 34267                                  ;			     sure that umb_head arena is valid and also make
 34268                                  ;			     sure that the previous arena is pointing to 
 34269                                  ;			     umb_head.
 34270                                  ;
 34271                                  ;		      M064 - allow HIGH_ONLY bit to be set by a call to 
 34272                                  ;			     set allloc strategy.
 34273                                  ;			     use STRAT_MASK to mask out bits 6 & 7 of 
 34274                                  ;			     bx in AllocSetStrat.
 34275                                  ;
 34276                                  ;		      M068 - use a count value (A20OFF_COUNT) rather than
 34277                                  ;			     a bit to indicate to dos dispatcher to turn
 34278                                  ;			     a20 off before iret. See M016.
 34279                                  ;
 34280                                  
 34281                                  ;	BREAK	<memory allocation utility routines>
 34282                                  
 34283                                  
 34284                                  ; 15/04/2018 - Retro DOS v2.0
 34285                                  ;----------------------------------------------------------------------------
 34286                                  ; xenix memory calls for MSDOS
 34287                                  ;
 34288                                  ; CAUTION: The following routines rely on the fact that arena_signature and
 34289                                  ; arena_owner_system are all equal to zero and are contained in DI.
 34290                                  ;
 34291                                  ;INCLUDE DOSSEG.ASM
 34292                                  
 34293                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 34294                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 34295                                  
 34296                                  ;.xlist
 34297                                  ;.xcref
 34298                                  ;INCLUDE DOSSYM.ASM
 34299                                  ;INCLUDE DEVSYM.ASM
 34300                                  ;.cref
 34301                                  ;.list
 34302                                  
 34303                                  ;TITLE ALLOC.ASM - memory arena manager
 34304                                  ;NAME Alloc
 34305                                  
 34306                                  ;SUBTTL memory allocation utility routines
 34307                                  ;PAGE
 34308                                  ;
 34309                                  ; arena data
 34310                                  ;
 34311                                  ;       i_need  arena_head,WORD         ; seg address of start of arena
 34312                                  ;       i_need  CurrentPDB,WORD         ; current process data block addr
 34313                                  ;       i_need  FirstArena,WORD         ; first free block found
 34314                                  ;       i_need  BestArena,WORD          ; best free block found
 34315                                  ;       i_need  LastArena,WORD          ; last free block found
 34316                                  ;       i_need  AllocMethod,BYTE        ; how to alloc first(best)last
 34317                                  
 34318                                  ;**	Arena_Free_Process
 34319                                  ;----------------------------------------------------------------------------
 34320                                  ;	Free all arena blocks allocated to a prOcess
 34321                                  ;
 34322                                  ;	ENTRY	(bx) = PID of process
 34323                                  ;	EXIT	none
 34324                                  ;	USES	????? BUGBUG
 34325                                  ;----------------------------------------------------------------------------
 34326                                  
 34327                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 34328                                  	; DOSCODE:A1C2h (MSDOS 5.0, MSDOS.SYS)
 34329                                  
 34330                                  arena_free_process:
 34331                                  	; 14/05/2019 - Retro DOS v4.0
 34332                                  	; 04/08/2018 - Retro DOS v3.0
 34333 0000623D 36A1[2400]                      MOV	AX,[SS:arena_head]
 34334                                  arena_free_process_start:
 34335 00006241 BF0000                  	MOV     DI,ARENA.SIGNATURE ; 0
 34336                                  	;MOV	AX,[SS:arena_head] ; 15/04/2018  
 34337 00006244 E83000                          CALL	check_signature         ; ES <- AX, check for valid block
 34338                                  
 34339                                  arena_free_process_loop:
 34340                                          ;retc
 34341 00006247 723D                            JC	SHORT AFP_RETN	; Retro DOS v2.0 - 05/03/2018
 34342 00006249 06                      	PUSH    ES
 34343 0000624A 1F                              POP     DS
 34344                                  	;cmp	[1],bx 
 34345 0000624B 391E0100                        CMP     [ARENA.OWNER],BX	; is block owned by pid?
 34346 0000624F 7504                            JNZ     SHORT arena_free_next	; no, skip to next
 34347                                  	;mov	[1],di
 34348 00006251 893E0100                        MOV     [ARENA.OWNER],DI	; yes... free him
 34349                                  
 34350                                  arena_free_next:
 34351                                  	;cmp	byte [di],5Ah ;'Z'
 34352 00006255 803D5A                          CMP     BYTE [DI],arena_signature_end
 34353                                                                          ; end of road, Jack?
 34354                                          ;retz				; never come back no more
 34355                                  	;JZ	SHORT AFP_RETN  ; MSDOS 3.3 (& MSDOS 2.11)
 34356                                  	; 14/05/2019
 34357                                  	; MSDOS 6.0
 34358 00006258 7405                    	jz	short arena_chk_umbs
 34359                                          
 34360 0000625A E81300                  	CALL    arena_next              ; next item in ES/AX carry set if trash
 34361 0000625D EBE8                            JMP     SHORT arena_free_process_loop
 34362                                  
 34363                                  	; MSDOS 6.0
 34364                                  arena_chk_umbs:				; M010 - Start
 34365                                  	; 20/05/2019
 34366 0000625F 36A1[8C00]              	mov	ax,[ss:UMB_HEAD]	; ax = umb_head
 34367 00006263 83F8FF                  	cmp	ax,0FFFFh		; Q: is umb_head initialized
 34368 00006266 741E                    	je	short ret_label		; N: we're done
 34369                                  	
 34370 00006268 8CDF                    	mov	di,ds			; di = last arena
 34371 0000626A 39C7                    	cmp	di,ax			; Q: is last arena above umb_head
 34372 0000626C 7318                    	jae	short ret_label		; Y: we've scanned umbs also. done.
 34373 0000626E EBD1                    	jmp	short arena_free_process_start
 34374                                  					; M010 - End
 34375                                  ;AFP_RETN:
 34376                                  ;	RETN
 34377                                  
 34378                                  ;	BREAK	<Arena Helper Routines>
 34379                                  
 34380                                  ;**	Arena_Next - Find Next item in Arena
 34381                                  ;----------------------------------------------------------------------------
 34382                                  ;	ENTRY	DS - pointer to block head
 34383                                  ;		(di) = 0
 34384                                  ;	EXIT	AX,ES - pointers to next head
 34385                                  ;		'C' set iff arena damaged
 34386                                  ;----------------------------------------------------------------------------
 34387                                  
 34388                                  arena_next:
 34389 00006270 8CD8                            MOV     AX,DS                   ; AX <- current block
 34390 00006272 03060300                        ADD     AX,[ARENA.SIZE]		; AX <- AX + current block length
 34391 00006276 40                              INC     AX                      ; remember that header!
 34392                                  
 34393                                  ;       fall into check_signature and return
 34394                                  ;
 34395                                  ;       CALL    check_signature         ; ES <- AX, carry set if error
 34396                                  ;       RETN
 34397                                  
 34398                                  ;**	Check_Signature - Check Memory Block Signature
 34399                                  ;----------------------------------------------------------------------------
 34400                                  ;	ENTRY	(AX) = address of block header
 34401                                  ;		(di) = 0
 34402                                  ;	EXIT	 ES = AX
 34403                                  ;		'C' clear if signature good
 34404                                  ;		'C' set if signature bad
 34405                                  ;	USES	ES, Flags
 34406                                  ;----------------------------------------------------------------------------
 34407                                  
 34408                                  check_signature:        
 34409                                  
 34410 00006277 8EC0                    	MOV     ES,AX                   ; ES <- AX
 34411                                  	;cmp	byte [es:di],4Dh ; 'M'
 34412 00006279 26803D4D                        CMP     BYTE [ES:DI],arena_signature_normal
 34413                                                                          ; IF next signature = not_end THEN
 34414 0000627D 7407                            JZ      SHORT check_signature_ok ;   GOTO ok
 34415                                  	;cmp 	byte [es:di],5Ah ; 'Z'
 34416 0000627F 26803D5A                        CMP     BYTE [ES:DI],arena_signature_end
 34417                                                                          ; IF next signature = end then
 34418 00006283 7401                            JZ      SHORT check_signature_ok ;   GOTO ok
 34419 00006285 F9                              STC                             ; set error
 34420                                  ret_label: ; MSDOS 6.0
 34421                                  AFP_RETN:
 34422                                   	; Retro DOS v2.0 - 05/03/2018
 34423                                  check_signature_ok:
 34424                                  COALESCE_RETN:
 34425 00006286 C3                      	RETN
 34426                                  
 34427                                  ;**	Coalesce - Combine free blocks ahead with current block
 34428                                  ;----------------------------------------------------------------------------
 34429                                  ;	Coalesce adds the block following the argument to the argument block,
 34430                                  ;	iff it's free.  Coalesce is usually used to join free blocks, but
 34431                                  ;	some callers (such as $setblock) use it to join a free block to it's
 34432                                  ;	preceeding allocated block.
 34433                                  ;
 34434                                  ;	ENTRY	(ds) = pointer to the head of a free block
 34435                                  ;		(di) = 0
 34436                                  ;	EXIT	'C' clear if OK
 34437                                  ;		  (ds) unchanged, this block updated
 34438                                  ;		  (ax) = address of next block, IFF not at end
 34439                                  ;		'C' set if arena trashed
 34440                                  ;	USES	(cx)
 34441                                  ;----------------------------------------------------------------------------
 34442                                          
 34443                                  Coalesce:
 34444                                  	;cmp	byte [di],5Ah ; 'Z'
 34445 00006287 803D5A                  	CMP     BYTE [DI],arena_signature_end
 34446                                                                          ; IF current signature = END THEN
 34447                                          ;retz				;   GOTO ok
 34448 0000628A 74FA                            jz	short COALESCE_RETN
 34449 0000628C E8E1FF                  	CALL    arena_next              ; ES, AX <- next block, Carry set if error
 34450                                          ;retc				; IF no error THEN GOTO check
 34451 0000628F 72F5                    	jc	short COALESCE_RETN
 34452                                  
 34453                                  coalesce_check:
 34454                                  	;cmp	[es:1],di
 34455 00006291 26393E0100                      CMP     [ES:ARENA.OWNER],DI
 34456                                          ;retnz				; IF next block isnt free THEN return
 34457 00006296 75EE                            JNZ	SHORT COALESCE_RETN
 34458                                  	;mov	cx,[ES:3]
 34459 00006298 268B0E0300              	MOV     CX,[ES:ARENA.SIZE]	; CX <- next block size
 34460 0000629D 41                              INC     CX                      ; CX <- CX + 1 (for header size)
 34461                                          ;ADD	[3],CX
 34462 0000629E 010E0300                	ADD     [ARENA.SIZE],CX		; current size <- current size + CX
 34463 000062A2 268A0D                          MOV     CL,[ES:DI]              ; move up signature
 34464 000062A5 880D                            MOV     [DI],CL
 34465 000062A7 EBDE                            JMP     SHORT Coalesce		; try again
 34466                                  
 34467                                  ; 04/08/2018 - Retro DOS v3.0
 34468                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 641Fh
 34469                                  
 34470                                  ;	BREAK  <$Alloc - allocate space in memory>
 34471                                  
 34472                                  ; MSDOS 6.0
 34473                                  ;----------------------------------------------------------------------------
 34474                                  ;**	$Alloc - Allocate Memory Space
 34475                                  ;
 34476                                  ;	$Alloc services the INT21 that allocates memory space to a program.
 34477                                  ;	Alloc returns a pointer to a free block of memory that
 34478                                  ;	has the requested size in paragraphs.
 34479                                  ;
 34480                                  ;	If the allocation strategy is HIGH_FIRST or HIGH_ONLY memory is 
 34481                                  ;	scanned from umb_head if not from arena_head. If the strategy is
 34482                                  ; 	HIGH_FIRST the scan is continued from arena_head if a block of 
 34483                                  ;	appropriate size is not found in the UMBs. If the strategy is 
 34484                                  ;	HIGH_FIRST+HIGH_ONLY only the UMBs are scanned for memory.
 34485                                  ;
 34486                                  ;	In either case if bit 0 of UmbFlag is not initialized then the scan
 34487                                  ;	starts from arena_head.
 34488                                  ;
 34489                                  ;	Assembler usage:
 34490                                  ;           MOV     BX,size
 34491                                  ;           MOV     AH,Alloc
 34492                                  ;           INT     21h
 34493                                  ;
 34494                                  ;	BUGBUG - a lot can be done to improve performance. We can set marks
 34495                                  ;	so that we start searching the arena at it's first non-trivial free
 34496                                  ;	block, we can peephole the code, etc. (We can move some subr calls
 34497                                  ;	inline, etc.) I assume that this is called rarely and that the arena
 34498                                  ;	doesn't have too many memory objects in it beyond the first free one.
 34499                                  ;	verify that this is true; if so, this can stay as is
 34500                                  ;
 34501                                  ;	ENTRY	(bx) = requested size, in bytes
 34502                                  ;		(DS) = (ES) = DOSGROUP
 34503                                  ;	EXIT	'C' clear if memory allocated
 34504                                  ;		  (ax:0) = address of requested memory
 34505                                  ;		'C' set if request failed
 34506                                  ;		  (AX) = error_not_enough_memory
 34507                                  ;		    (bx) = max size we could have allocated
 34508                                  ;		  (ax) = error_arena_trashed
 34509                                  ;	USES	All
 34510                                  ;----------------------------------------------------------------------------
 34511                                  
 34512                                  ; MSDOS 2.11 (& MSDOS 3.3)
 34513                                  ;----------------------------------------------------------------------------
 34514                                  ;SUBTTL $Alloc - allocate space in memory
 34515                                  ;
 34516                                  ;   Assembler usage:
 34517                                  ;           MOV     BX,size
 34518                                  ;           MOV     AH,Alloc
 34519                                  ;           INT     21h
 34520                                  ;         AX:0 is pointer to allocated memory
 34521                                  ;         BX is max size if not enough memory
 34522                                  ;
 34523                                  ;   Description:
 34524                                  ;           Alloc returns  a  pointer  to  a  free  block of
 34525                                  ;       memory that has the requested  size  in  paragraphs.
 34526                                  ;
 34527                                  ;   Error return:
 34528                                  ;           AX = error_not_enough_memory
 34529                                  ;              = error_arena_trashed
 34530                                  ;----------------------------------------------------------------------------
 34531                                  
 34532                                  ; DOSCODE:A28Eh (MSDOS 6.21, MSDOS.SYS)
 34533                                  
 34534                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 34535                                  ; DOSCODE:A22Eh (MSDOS 5.0, MSDOS.SYS)
 34536                                  
 34537                                  _$ALLOC:
 34538                                  	; 25/05/2019 (Procedure has been checked and confirmed)
 34539                                  	; 14/05/2019 - Retro DOS v4.0
 34540                                  	; 04/08/2018 - Retro DOS v3.0
 34541                                  	;EnterCrit critMem
 34542 000062A9 E865B0                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 34543                                  
 34544                                  ; 17/12/2022
 34545                                  ; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34546                                  ;%if 0
 34547                                  	; 14/05/2019
 34548 000062AC 16                      	push	ss
 34549 000062AD 1F                      	pop	ds
 34550                                  
 34551                                  	; MSDOS 6.0
 34552                                  	;mov	ax,[ss:arena_head]
 34553                                  	;mov	[ss:START_ARENA],ax	; assume LOW_FIRST
 34554                                  
 34555 000062AE A1[2400]                	mov	ax,[arena_head]
 34556 000062B1 A3[8E00]                	mov	[START_ARENA],ax			
 34557                                  	
 34558                                  	;test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
 34559 000062B4 F606[0203]C0            	test	byte [AllocMethod],HIGH_FIRST+HIGH_ONLY
 34560                                  					; Q: should we start scanning from 
 34561                                  					;    UMB's
 34562 000062B9 740D                    	jz	short norm_alloc	; N: scan from arena_head
 34563                                  		
 34564                                  	;;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
 34565                                  	;cmp	word [UMB_HEAD],-1
 34566                                  	;je	short norm_alloc	; N: scan from arena_head
 34567                                  
 34568                                  	;test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 34569 000062BB F606[8900]01            	test	byte [UMBFLAG],LINKSTATE ; 1
 34570 000062C0 7406                    	jz	short norm_alloc	; N: scan from arena_head
 34571                                  	
 34572                                  	;mov	ax,[ss:UMB_HEAD]
 34573                                  	;mov	[ss:START_ARENA],ax	; start_arena = umb_head
 34574 000062C2 A1[8C00]                	mov	ax,[UMB_HEAD]
 34575 000062C5 A3[8E00]                	mov	[START_ARENA],ax
 34576                                  					; M000 - end
 34577                                  norm_alloc:
 34578 000062C8 31C0                            XOR     AX,AX
 34579 000062CA 89C7                            MOV     DI,AX
 34580                                  	; 15/03/2018
 34581                                          ;MOV	[SS:FirstArena],AX	; init the options
 34582                                          ;MOV	[SS:BestArena],AX
 34583                                          ;MOV	[SS:LastArena],AX
 34584                                  	; 14/05/2019
 34585 000062CC A3[4003]                	MOV	[FirstArena],AX		; init the options
 34586 000062CF A3[4203]                        MOV	[BestArena],AX
 34587 000062D2 A3[4403]                        MOV	[LastArena],AX
 34588 000062D5 50                              PUSH    AX                      ; alloc_max <- 0
 34589                                  	; 04/08/2018
 34590                                  start_scan:
 34591                                  	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
 34592                                  	;MOV	AX,[arena_head]
 34593                                  
 34594                                  	; 14/05/2019	
 34595                                  	; MSDOS 6.0
 34596                                  	;mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
 34597 000062D6 A1[8E00]                	mov	ax,[START_ARENA]
 34598                                  
 34599                                  	; 27/09/2023 (BugFix) (*) 
 34600                                  	; ( jump from 'alloc_chk' (ds<>ss, ax = [SS:START_ARENA]))
 34601                                  start_scan_x:
 34602                                  
 34603 000062D9 E89BFF                  	CALL    check_signature         ; ES <- AX, carry set if error
 34604 000062DC 7236                            JC      SHORT alloc_err		; IF error THEN GOTO err
 34605                                  
 34606                                  ;%endif
 34607                                  
 34608                                  ; 17/12/2022
 34609                                  %if 0
 34610                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34611                                  
 34612                                  	; MSDOS 6.0
 34613                                  	mov	ax,[ss:arena_head]
 34614                                  	mov	[ss:START_ARENA],ax	; assume LOW_FIRST
 34615                                  
 34616                                  	test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
 34617                                  					; Q: should we start scanning from 
 34618                                  					;    UMB's
 34619                                  	jz	short norm_alloc	; N: scan from arena_head
 34620                                  		
 34621                                  	;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
 34622                                  	;je	short norm_alloc	; N: scan from arena_head
 34623                                  
 34624                                  	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 34625                                  	jz	short norm_alloc	; N: scan from arena_head
 34626                                  	
 34627                                  	mov	ax,[ss:UMB_HEAD]
 34628                                  	mov	[ss:START_ARENA],ax	; start_arena = umb_head
 34629                                  					; M000 - end
 34630                                  norm_alloc:
 34631                                          XOR     AX,AX
 34632                                          MOV     DI,AX
 34633                                  	; 15/03/2018
 34634                                  	MOV	[SS:FirstArena],AX	; init the options
 34635                                  	MOV	[SS:BestArena],AX
 34636                                  	MOV	[SS:LastArena],AX
 34637                                          PUSH    AX                      ; alloc_max <- 0
 34638                                  	; 04/08/2018
 34639                                  start_scan:
 34640                                  	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
 34641                                  	; 14/05/2019	
 34642                                  	; MSDOS 6.0
 34643                                  	mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
 34644                                  	CALL    check_signature         ; ES <- AX, carry set if error
 34645                                          JC      SHORT alloc_err		; IF error THEN GOTO err
 34646                                  %endif
 34647                                  
 34648                                  alloc_scan:
 34649 000062DE 06                              PUSH    ES
 34650 000062DF 1F                              POP     DS                      ; DS <- ES
 34651 000062E0 393E0100                        CMP     [ARENA.OWNER],DI ; 0
 34652 000062E4 7469                            JZ      SHORT alloc_free	; IF current block is free THEN examine
 34653                                  
 34654                                  alloc_next:
 34655                                  	; MSDOS 6.0			; M000 - start 
 34656 000062E6 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 34657 000062EC 741C                    	jz	short norm_strat	; N: see if we reached last arena
 34658                                  	
 34659 000062EE 36F606[0203]80          	test	byte [ss:AllocMethod],HIGH_FIRST
 34660                                  					; Q: is alloc strategy high_first
 34661 000062F4 7414                    	jz	short norm_strat	; N: see if we reached last arena
 34662 000062F6 36A1[8E00]              	mov	ax,[ss:START_ARENA]
 34663 000062FA 363B06[2400]            	cmp	ax,[ss:arena_head]	; Q: did we start scan from 
 34664                                  					;    arena_head
 34665 000062FF 7509                    	jne	short norm_strat	; N: see if we reached last arena
 34666 00006301 8CD8                    	mov	ax,ds			; ax = current block
 34667 00006303 363B06[8C00]            	cmp	ax,[ss:UMB_HEAD]	; Q: check against umb_head 
 34668 00006308 EB03                    	jmp	short alloc_chk_end
 34669                                  
 34670                                  norm_strat:
 34671                                  	;cmp	byte [di],5Ah ; 'Z'
 34672 0000630A 803D5A                          CMP     BYTE [DI],arena_signature_end
 34673                                                                          ; IF current block is last THEN
 34674                                  alloc_chk_end:
 34675 0000630D 740E                            JZ      SHORT alloc_end		;   GOTO end
 34676 0000630F E85EFF                          CALL    arena_next              ; AX, ES <- next block, Carry set if error
 34677 00006312 73CA                            JNC     SHORT alloc_scan	; IF no error THEN GOTO scan
 34678                                  
 34679                                  alloc_err:
 34680 00006314 58                              POP     AX
 34681                                  
 34682                                  alloc_trashed:
 34683                                  	;LeaveCrit critMem
 34684 00006315 E814B0                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0	
 34685                                          ;error	error_arena_trashed
 34686                                  	;mov	al,7
 34687 00006318 B007                    	MOV	AL,error_arena_trashed
 34688                                  alloc_errj:
 34689 0000631A E923A3                  	JMP	SYS_RET_ERR
 34690                                  
 34691                                  alloc_end:
 34692                                  	; 18/05/2019
 34693 0000631D 36833E[4003]00                  CMP	WORD [SS:FirstArena],0
 34694 00006323 7403                    	jz	short alloc_chk 
 34695 00006325 E98400                  	jmp	alloc_do_split
 34696                                  
 34697                                  alloc_chk:
 34698                                  	; MSDOS 6.0
 34699 00006328 36A1[2400]              	mov	ax,[ss:arena_head]
 34700 0000632C 363B06[8E00]            	cmp	ax,[ss:START_ARENA]	; Q: started scanning from arena_head
 34701 00006331 740E                    	je	short alloc_fail	; Y: not enough memory
 34702                                  					; N:
 34703                                  					; Q: is the alloc strat HIGH_ONLY
 34704 00006333 36F606[0203]40          	test 	byte [ss:AllocMethod],HIGH_ONLY
 34705 00006339 7506                    	jnz	short alloc_fail	; Y: return size of largest UMB
 34706                                  	
 34707 0000633B 36A3[8E00]              	mov	[ss:START_ARENA],ax	; N: start scanning from arena_head
 34708                                  	; 27/09/2023 (*)
 34709 0000633F EB98                    	jmp	short start_scan_x ; (*) ; (BugFix)
 34710                                  	;jmp	short start_scan
 34711                                  					; M000 - end
 34712                                  
 34713                                  alloc_fail:
 34714                                          ;invoke Get_User_Stack
 34715 00006341 E83DA1                          CALL	Get_User_Stack
 34716 00006344 5B                      	POP     BX
 34717                                          ;MOV	[SI].user_BX,BX
 34718                                  	;MOV	[SI+2],BX
 34719 00006345 895C02                  	mov	[SI+user_env.user_BX],bx
 34720                                  	;LeaveCrit critMem
 34721 00006348 E8E1AF                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 34722                                  	;error	error_not_enough_memory
 34723                                  	;mov	al,8
 34724 0000634B B008                    	MOV	AL,error_not_enough_memory
 34725                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34726 0000634D EBCB                    	jmp	short alloc_errj
 34727                                  	;JMP	SYS_RET_ERR
 34728                                  
 34729                                  alloc_free:
 34730 0000634F E835FF                          CALL    Coalesce		; add following free block to current
 34731 00006352 72C0                            JC	SHORT alloc_err		; IF error THEN GOTO err
 34732 00006354 8B0E0300                        MOV     CX,[ARENA.SIZE]
 34733 00006358 5A                              POP     DX                      ; check for max found size
 34734 00006359 39D1                            CMP     CX,DX
 34735 0000635B 7602                            JNA     SHORT alloc_test
 34736 0000635D 89CA                            MOV     DX,CX
 34737                                  
 34738                                  alloc_test:
 34739 0000635F 52                              PUSH    DX
 34740 00006360 39CB                            CMP     BX,CX                   ; IF BX > size of current block THEN
 34741 00006362 7782                    	JA      SHORT alloc_next	;   GOTO next
 34742                                  
 34743                                  	; 15/03/2018
 34744 00006364 36833E[4003]00                  CMP     WORD [SS:FirstArena],0
 34745 0000636A 7505                    	JNZ	SHORT alloc_best
 34746 0000636C 368C1E[4003]                    MOV     [SS:FirstArena],DS	; save first one found	
 34747                                  alloc_best:
 34748 00006371 36833E[4203]00                  CMP     WORD [SS:BestArena],0
 34749 00006377 740E                            JZ      SHORT alloc_make_best	; initial best
 34750 00006379 06                              PUSH	ES
 34751 0000637A 368E06[4203]                    MOV     ES,[SS:BestArena]
 34752 0000637F 26390E0300                      CMP     [ES:ARENA.SIZE],CX	; is size of best larger than found?
 34753 00006384 07                              POP	ES
 34754 00006385 7605                            JBE     SHORT alloc_last
 34755                                  alloc_make_best:
 34756 00006387 368C1E[4203]                    MOV     [SS:BestArena],DS	; assign best
 34757                                  alloc_last:
 34758 0000638C 368C1E[4403]                    MOV     [SS:LastArena],DS 	; assign last
 34759 00006391 E952FF                          JMP     alloc_next
 34760                                  ;
 34761                                  ; split the block high
 34762                                  ;
 34763                                  alloc_do_split_high:
 34764 00006394 368E1E[4403]                    MOV     DS,[SS:LastArena]
 34765 00006399 8B0E0300                        MOV     CX,[ARENA.SIZE]
 34766 0000639D 29D9                            SUB     CX,BX
 34767 0000639F 8CDA                            MOV     DX,DS
 34768 000063A1 7449                            JE      SHORT alloc_set_owner	; sizes are equal, no split
 34769 000063A3 01CA                            ADD     DX,CX                   ; point to next block
 34770 000063A5 8EC2                            MOV     ES,DX                   ; no decrement!
 34771 000063A7 49                              DEC     CX
 34772 000063A8 87D9                            XCHG    BX,CX                   ; bx has size of lower block
 34773 000063AA EB2B                            JMP     SHORT alloc_set_sizes	; cx has upper (requested) size
 34774                                  ;
 34775                                  ; we have scanned memory and have found all appropriate blocks
 34776                                  ; check for the type of allocation desired; first and best are identical
 34777                                  ; last must be split high
 34778                                  ;
 34779                                  alloc_do_split:
 34780                                  
 34781                                  ; 17/12/2022
 34782                                  ; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34783                                  ;%if 0
 34784                                  	; 14/05/2019
 34785                                  	; MSDOS 6.0			; M000 - start
 34786                                  	;xor	cx,cx
 34787 000063AC 368A0E[0203]            	mov	cl,[ss:AllocMethod]
 34788                                  	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
 34789 000063B1 80E13F                  	and	cl,3Fh
 34790                                  	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
 34791 000063B4 80F901                  	cmp	cl,BEST_FIT
 34792 000063B7 77DB                    	ja	short alloc_do_split_high
 34793                                  ;%endif
 34794                                  
 34795                                  	; 17/12/2022
 34796                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34797                                  	; MSDOS 6.0 & MSDOS 5.0
 34798                                  	;xor	cx,cx
 34799                                  	;mov	cl,[ss:AllocMethod]
 34800                                  	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
 34801                                  	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
 34802                                  	;ja	short alloc_do_split_high
 34803                                  
 34804                                  	; 15/03/2018
 34805                                          ;;CMP	BYTE [SS:AllocMethod], 1
 34806                                  	; 04/08/2018
 34807                                  	;CMP	BYTE [SS:AllocMethod],BEST_FIT
 34808                                          ;JA	SHORT alloc_do_split_high
 34809                                          
 34810 000063B9 368E1E[4003]            	MOV     DS,[SS:FirstArena]        
 34811 000063BE 7205                    	JB      SHORT alloc_get_size
 34812 000063C0 368E1E[4203]            	MOV     DS,[SS:BestArena]
 34813                                  
 34814                                  alloc_get_size:
 34815 000063C5 8B0E0300                        MOV     CX,[ARENA.SIZE]
 34816 000063C9 29D9                            SUB     CX,BX                   ; get room left over
 34817 000063CB 8CD8                            MOV     AX,DS
 34818 000063CD 89C2                            MOV     DX,AX                   ; save for owner setting
 34819 000063CF 741B                            JE      SHORT alloc_set_owner	; IF BX = size THEN (don't split)
 34820 000063D1 01D8                            ADD     AX,BX
 34821 000063D3 40                              INC     AX                      ; remember the header
 34822 000063D4 8EC0                            MOV     ES,AX                   ; ES <- DS + BX (new header location)
 34823 000063D6 49                              DEC     CX                      ; CX <- size of split block
 34824                                  alloc_set_sizes:
 34825 000063D7 891E0300                        MOV     [ARENA.SIZE],BX		; current size <- BX
 34826 000063DB 26890E0300                      MOV     [ES:ARENA.SIZE],CX      ; split size <- CX
 34827                                  	;mov	bl,4Dh ; 'M'
 34828 000063E0 B34D                            MOV     BL,arena_signature_normal
 34829 000063E2 861D                            XCHG    BL,[DI]			; current signature <- 4D
 34830 000063E4 26881D                          MOV     [ES:DI],BL		; new block sig <- old block sig
 34831 000063E7 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 34832                                  
 34833                                  alloc_set_owner:
 34834 000063EC 8EDA                            MOV     DS,DX
 34835 000063EE 36A1[3003]                      MOV     AX,[SS:CurrentPDB] ; 15/03/2018
 34836 000063F2 A30100                          MOV     [ARENA.OWNER],AX
 34837 000063F5 8CD8                            MOV     AX,DS
 34838 000063F7 40                              INC     AX
 34839 000063F8 5B                              POP     BX
 34840                                  	;LeaveCrit critMem
 34841 000063F9 E830AF                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 34842                                  	
 34843                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34844                                  alloc_ok:
 34845                                          ;transfer SYS_RET_OK
 34846 000063FC E938A2                  	JMP	SYS_RET_OK
 34847                                  
 34848                                  ;	BREAK $SETBLOCK - change size of an allocated block (if possible)
 34849                                  
 34850                                  ; MSDOS 6.0
 34851                                  ;----------------------------------------------------------------------------
 34852                                  ;**	$SETBLOCK - Change size of an Allocated Block
 34853                                  ;
 34854                                  ;	Setblock changes the size of an allocated block. First, we coalesce
 34855                                  ;	any following free space onto this block; then we try to trim the
 34856                                  ;	block down to the size requested.
 34857                                  ;
 34858                                  ;	Note that if the guy wants to grow the block but that growth fails,
 34859                                  ;	we still go ahead and coalesce any trailing free blocks onto it.
 34860                                  ;	Thus the maximum-size-possible value that we return has already
 34861                                  ;	been allocated! This is a bug, dare we fix it? BUGBUG
 34862                                  ;
 34863                                  ;	NOTE - $SETBLOCK is in bed with $ALLOC and jumps into $ALLOC to
 34864                                  ;		finish it's work. For this reason we build the allocsf
 34865                                  ;		structure on the frame, to make us compatible with $ALLOCs
 34866                                  ;		code.
 34867                                  ;
 34868                                  ;	ENTRY	(es) = segment of old block
 34869                                  ;		(bx) = newsize
 34870                                  ;		(ah) = SETBLOCK
 34871                                  ;
 34872                                  ;	EXIT	'C' clear if OK
 34873                                  ;		'C' set if error
 34874                                  ;		  (ax) = error_invalid_block
 34875                                  ;		       = error_arena_trashed
 34876                                  ;		       = error_not_enough_memory
 34877                                  ;		       = error_invalid_function
 34878                                  ;		  (bx) = maximum size possible, iff (ax) = error_not_enough_memory
 34879                                  ;	USES	???? BUGBUG
 34880                                  ;----------------------------------------------------------------------------
 34881                                  
 34882                                  ; MSDOS 2.11 (& MSDOS 3.3)
 34883                                  ;----------------------------------------------------------------------------
 34884                                  ;SUBTTL $SETBLOCK - change size of an allocated block (if possible)
 34885                                  ;
 34886                                  ;   Assembler usage:
 34887                                  ;           MOV     ES,block
 34888                                  ;           MOV     BX,newsize
 34889                                  ;           MOV     AH,setblock
 34890                                  ;           INT     21h
 34891                                  ;         if setblock fails for growing, BX will have the maximum
 34892                                  ;         size possible
 34893                                  ;   Error return:
 34894                                  ;           AX = error_invalid_block
 34895                                  ;              = error_arena_trashed
 34896                                  ;              = error_not_enough_memory
 34897                                  ;              = error_invalid_function
 34898                                  ;----------------------------------------------------------------------------
 34899                                  
 34900                                  _$SETBLOCK:        
 34901                                  	; 04/08/2018 - Retro DOS v3.0
 34902                                  	;EnterCrit   critMem
 34903 000063FF E80FAF                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 34904                                  
 34905 00006402 BF0000                  	MOV     DI,ARENA.SIGNATURE
 34906 00006405 8CC0                            MOV     AX,ES
 34907 00006407 48                              DEC     AX
 34908 00006408 E86CFE                          CALL    check_signature
 34909 0000640B 7303                            JNC     SHORT setblock_grab
 34910                                  
 34911                                  setblock_bad:
 34912 0000640D E905FF                          JMP     alloc_trashed
 34913                                  
 34914                                  setblock_grab:
 34915 00006410 8ED8                            MOV     DS,AX
 34916 00006412 E872FE                          CALL    Coalesce
 34917 00006415 72F6                            JC      SHORT setblock_bad
 34918 00006417 8B0E0300                        MOV     CX,[ARENA.SIZE]
 34919 0000641B 51                              PUSH    CX
 34920 0000641C 39CB                            CMP     BX,CX
 34921 0000641E 76A5                            JBE     SHORT alloc_get_size
 34922 00006420 E91EFF                          JMP     alloc_fail
 34923                                  
 34924                                  ;	BREAK $DEALLOC - free previously allocated piece of memory
 34925                                  
 34926                                  ; MSDOS 6.0
 34927                                  ;----------------------------------------------------------------------------
 34928                                  ;**	$DEALLOC - Free Heap Memory
 34929                                  ;
 34930                                  ;	ENTRY	(es) = address of item
 34931                                  ;
 34932                                  ;	EXIT	'C' clear of OK
 34933                                  ;		'C' set if error
 34934                                  ;		  (AX) = error_invalid_block
 34935                                  ;	USES	???? BUGBUG
 34936                                  
 34937                                  ; MSDOS 2.11 (& MSDOS 3.3)
 34938                                  ;----------------------------------------------------------------------------
 34939                                  ;SUBTTL $DEALLOC - free previously allocated piece of memory
 34940                                  ;
 34941                                  ;   Assembler usage:
 34942                                  ;           MOV     ES,block
 34943                                  ;           MOV     AH,dealloc
 34944                                  ;           INT     21h
 34945                                  ;
 34946                                  ;   Error return:
 34947                                  ;           AX = error_invalid_block
 34948                                  ;              = error_arena_trashed
 34949                                  ;---------------------------------------------------------------------------- 
 34950                                  
 34951                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34952                                  _$DEALLOC:
 34953                                  	; 14/05/2019 - Retro DOS v4.0    
 34954                                  	; 04/08/2018 - Retro DOS v3.0
 34955                                  	;EnterCrit   critMem
 34956 00006423 E8EBAE                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 34957                                  
 34958                                  	; MSDOS 6.0			; M016, M068 - Start
 34959 00006426 36F606[8600]04          	test	byte [ss:DOS_FLAG],EXECA20OFF
 34960                                  					; Q: was the previous call an int 21
 34961                                  					;    exec call
 34962 0000642C 740D                    	jz	short deallocate	; N: continue
 34963 0000642E 36803E[8500]00          	cmp	byte [ss:A20OFF_COUNT], 0 ; Q: is count 0
 34964 00006434 7505                    	jne	short deallocate	; N: continue
 34965                                  	;mov	byte [ss:A20OFF_COUNT], 1 ; Y: set count to 1
 34966                                  	; 25/09/2023
 34967 00006436 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]
 34968                                  deallocate:				; M016, M068 - End
 34969 0000643B BF0000                  	MOV     DI,ARENA.SIGNATURE ; = 0
 34970 0000643E 8CC0                            MOV     AX,ES
 34971 00006440 48                              DEC     AX
 34972 00006441 E833FE                          CALL    check_signature
 34973 00006444 720A                            JC      SHORT dealloc_err
 34974 00006446 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 34975                                  	;LeaveCrit critMem
 34976 0000644B E8DEAE                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 34977                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34978                                          ;transfer SYS_RET_OK
 34979                                  dealloc_ok:
 34980 0000644E EBAC                    	jmp	short alloc_ok
 34981                                  	;JMP	SYS_RET_OK
 34982                                  
 34983                                  dealloc_err:
 34984                                  	;LeaveCrit critMem
 34985 00006450 E8D9AE                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 34986                                          ;error	error_invalid_block
 34987                                  	;mov	al,9
 34988 00006453 B009                    	MOV	AL,error_invalid_block
 34989                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34990                                  dealloc_errj:
 34991                                  AllocOperErrj:	; 17/12/2022
 34992 00006455 E9E8A1                  	JMP	SYS_RET_ERR
 34993                                  
 34994                                  ;	BREAK $AllocOper - get/set allocation mechanism
 34995                                  
 34996                                  ; MSDOS 6.0
 34997                                  ;----------------------------------------------------------------------------
 34998                                  ;**	$AllocOper - Get/Set Allocation Mechanism
 34999                                  ;
 35000                                  ;	Assembler usage:
 35001                                  ;           MOV     AH,AllocOper
 35002                                  ;           MOV     BX,method
 35003                                  ;           MOV     AL,func
 35004                                  ;           INT     21h
 35005                                  ;
 35006                                  ;	ENTRY	
 35007                                  ;		(al) = 0
 35008                                  ;		  Get allocation Strategy in (ax)
 35009                                  ;
 35010                                  ;		(al) = 1, (bx) = method = zw0000xy
 35011                                  ;		  Set allocation strategy.
 35012                                  ;		   w  = 1  => HIGH_ONLY
 35013                                  ;		   z  = 1  => HIGH_FIRST
 35014                                  ;		   xy = 00 => FIRST_FIT
 35015                                  ;		      = 01 => BEST_FIT
 35016                                  ;		      = 10 => LAST_FIT
 35017                                  ;
 35018                                  ;		(al) = 2
 35019                                  ;		  Get UMB link state in (al)
 35020                                  ;
 35021                                  ;		(al) = 3
 35022                                  ;		  Set UMB link state
 35023                                  ;		   (bx) = 0 => Unlink UMBs
 35024                                  ;		   (bx) = 1 => Link UMBs
 35025                                  ;
 35026                                  ;
 35027                                  ;	EXIT	'C' clear if OK
 35028                                  ;
 35029                                  ;		 if (al) = 0
 35030                                  ;		  (ax) = existing method
 35031                                  ;		 if (al) = 1
 35032                                  ;		  Sets allocation strategy
 35033                                  ;		 if (al) = 2
 35034                                  ;		  (al) = 0 => UMBs not linked
 35035                                  ;		  (al) = 1 => UMBs linked in
 35036                                  ;		 if (al) = 3
 35037                                  ;		  Links/Unlinks the UMBs into DOS chain
 35038                                  ;
 35039                                  ;		'C' set if error
 35040                                  ;		  AX = error_invalid_function
 35041                                  ;
 35042                                  ;	Rev. M000 - added support for HIGH_FIRST in (al) = 1. 7/9/90
 35043                                  ; 	Rev. M003 - added functions (al) = 2 and (al) = 3. 7/18/90
 35044                                  ;	Rev. M009 - (al) = 3 will return 'invalid function' in ax if
 35045                                  ;		    umbhead has'nt been initialized by sysinit and 'trashed
 35046                                  ;		    arena' if an arena sig is damaged.
 35047                                  ;----------------------------------------------------------------------------
 35048                                  
 35049                                  ; MSDOS 2.11 (& MSDOS 3.3)
 35050                                  ;----------------------------------------------------------------------------
 35051                                  ;SUBTTL $AllocOper - get/set allocation mechanism
 35052                                  ;
 35053                                  ;   Assembler usage:
 35054                                  ;           MOV     AH,AllocOper
 35055                                  ;           MOV     BX,method
 35056                                  ;           MOV     AL,func
 35057                                  ;           INT     21h
 35058                                  ;
 35059                                  ;   Error return:
 35060                                  ;           AX = error_invalid_function
 35061                                  ;----------------------------------------------------------------------------
 35062                                  
 35063                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35064                                  _$ALLOCOPER:
 35065                                  	; 14/05/2019 - Retro DOS v4.0
 35066                                  	; MSDOS 6.0
 35067 00006458 08C0                    	or	al,al ; 0
 35068 0000645A 741E                    	jz	short AllocGetStrat
 35069                                  	; 17/12/2022
 35070                                  	;cmp	al,1
 35071                                  	;jz	short AllocSetStrat
 35072                                  
 35073                                  	; 01/12/2022
 35074                                  	;cmp	al, 2
 35075                                  	;jb	short AllocSetStrat
 35076                                  	;ja	short AllocSetLink
 35077                                  	;;jmp	short AllocGetLink
 35078                                  ;AllocGetLink:
 35079                                  	; MSDOS 6.0
 35080                                  	;mov	al,[ss:UMBFLAG]		; return link state in al
 35081                                  	;and 	al,LINKSTATE		
 35082                                  	;;transfer SYS_RET_OK
 35083                                  	;jmp	SYS_RET_OK
 35084                                  
 35085 0000645C 3C02                    	cmp	al,2
 35086                                  	; 17/12/2022
 35087 0000645E 7223                    	jb	short AllocSetStrat ; al = 1
 35088 00006460 7432                    	je	short AllocGetLink
 35089                                  
 35090                                  	;cmp	al,2
 35091                                  	;jz	short AllocGetLink
 35092 00006462 3C03                    	cmp	al,3
 35093 00006464 7436                    	jz	short AllocSetLink
 35094                                  
 35095                                  	; 15/04/2018
 35096                                  	;CMP	AL,1
 35097                                          ;JB	SHORT AllocOperGet
 35098                                          ;JZ	SHORT AllocOperSet
 35099                                  
 35100                                  AllocOperError:
 35101                                  	; 04/08/2018 - Retro DOS v3.0
 35102                                  	; MSDOS 3.3 (& MSDOS 6.0)	; Extended Error Locus	
 35103                                  	;mov	byte [ss:EXTERR_LOCUS],5
 35104 00006466 36C606[2303]05                  MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 35105                                  	;error	error_invalid_function
 35106                                  	;mov	al,1
 35107 0000646C B001                    	MOV	AL,error_invalid_function
 35108                                  	; 17/12/2022
 35109                                  ;AllocOperErrj:
 35110                                  	;JMP	SYS_RET_ERR
 35111                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35112                                  	;jmp	short dealloc_errj
 35113                                  	; 17/12/2022
 35114 0000646E EBE5                    	jmp	short AllocOperErrj
 35115                                  
 35116                                  AllocArenaError:
 35117                                  	; MSDOS 6.0
 35118 00006470 36C606[2303]05          	MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 35119                                  					; M009: Extended Error Locus
 35120                                  	;error	error_arena_trashed	; M009:
 35121                                  	;mov	al,7
 35122 00006476 B007                    	MOV	AL,error_arena_trashed
 35123                                  	;JMP	SYS_RET_ERR
 35124 00006478 EBDB                    	jmp	short AllocOperErrj ; 17/12/2022
 35125                                  
 35126                                  AllocGetStrat: 
 35127                                  	; MSDOS 6.0
 35128                                  AllocOperGet:
 35129 0000647A 36A0[0203]                      MOV     AL,[SS:AllocMethod]
 35130 0000647E 30E4                            XOR     AH,AH
 35131                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35132                                  	;transfer SYS_RET_OK
 35133                                  AllocOperOk:
 35134                                  	; 17/12/2022
 35135                                  	;jmp	short dealloc_ok
 35136 00006480 E9B4A1                  	JMP	SYS_RET_OK
 35137                                  
 35138                                  AllocSetStrat: 
 35139                                  	; 14/05/2019
 35140                                  	; MSDOS 6.0
 35141 00006483 53                      	push	bx			; M000 - start
 35142                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35143                                  	;and	bx,STRAT_MASK ; 0FF3Fh	; M064: mask off bit 6 & 7
 35144                                  	; 17/12/2022
 35145 00006484 80E33F                  	and	bl,3Fh
 35146 00006487 83FB02                  	cmp	bx,2			; BX must be 0-2
 35147                                  	;cmp	bl,2
 35148 0000648A 5B                      	pop	bx			; M000 - end
 35149 0000648B 77D9                    	ja	short AllocOperError
 35150                                  
 35151                                  AllocOperSet:
 35152 0000648D 36881E[0203]                    MOV     [SS:AllocMethod],BL
 35153                                    	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35154                                  	;transfer SYS_RET_OK
 35155                                  AllocOperOkj:
 35156 00006492 EBEC                    	jmp	short AllocOperOk
 35157                                  	;JMP	SYS_RET_OK
 35158                                  
 35159                                  AllocGetLink:
 35160                                  	; MSDOS 6.0
 35161 00006494 36A0[8900]              	mov	al,[ss:UMBFLAG]		; return link state in al
 35162                                  	;and	al,1
 35163 00006498 2401                    	and 	al,LINKSTATE		
 35164                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35165                                  	;transfer SYS_RET_OK
 35166                                  AllocOperOkj2:
 35167                                  	; 17/12/2022
 35168 0000649A EBE4                    	jmp	short AllocOperOk
 35169                                  	;jmp	short AllocOperOkj
 35170                                  	;;JMP	SYS_RET_OK
 35171                                  
 35172                                  AllocSetLink:
 35173                                  	; MSDOS 6.0			; M009 - start
 35174 0000649C 368B0E[8C00]            	mov	cx,[ss:UMB_HEAD]	; cx = umb_head
 35175 000064A1 83F9FF                  	cmp	cx,0FFFFh		; Q: has umb_head been initialized
 35176 000064A4 74C0                    	je	short AllocOperError	; N: error
 35177                                  					; Y: continue
 35178                                  					; M009 - end
 35179 000064A6 83FB01                  	cmp	bx,1			
 35180 000064A9 7204                    	jb	short UnlinkUmbs
 35181 000064AB 741C                    	jz	short LinkUmbs
 35182                                  	
 35183 000064AD EBB7                    	jmp	short AllocOperError
 35184                                  	
 35185                                  UnlinkUmbs:
 35186                                  	;test	byte [ss:UMBFLAG],1
 35187 000064AF 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs unlinked?
 35188 000064B5 7410                    	jz	short unlinked		; Y: return 
 35189                                  	
 35190 000064B7 E82900                  	call	GetLastArena		; get arena before umb_head in DS
 35191 000064BA 72B4                    	jc	short AllocArenaError	; M009: arena trashed
 35192                                  	
 35193                                  					; make it last
 35194 000064BC C60600005A              	mov	byte [0],arena_signature_end
 35195                                  	
 35196                                  	;and	byte [ss:UMBFLAG],0FEh
 35197 000064C1 368026[8900]FE          	and	byte [ss:UMBFLAG],~LINKSTATE ; indicate unlink'd state in umbflag
 35198                                  	
 35199                                  unlinked:
 35200                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35201                                  	;transfer SYS_RET_OK
 35202                                  	; 17/12/2022
 35203 000064C7 EBB7                    	jmp	short AllocOperOk
 35204                                  	;jmp	short AllocOperOkj2
 35205                                  	;;JMP	SYS_RET_OK
 35206                                  
 35207                                  LinkUmbs:
 35208 000064C9 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs linked?
 35209 000064CF 7510                    	jnz	short linked		; Y: return
 35210                                  	
 35211 000064D1 E80F00                  	call	GetLastArena		; get arena before umb_head
 35212 000064D4 729A                    	jc	short AllocArenaError	; M009: arena trashed
 35213                                  	
 35214                                  					; make it normal. M061: ds points to
 35215                                  					; arena before umb_head
 35216 000064D6 C60600004D              	mov	byte [0],arena_signature_normal
 35217                                  	
 35218 000064DB 36800E[8900]01          	or	byte [ss:UMBFLAG],LINKSTATE ; indicate link'd state in umbflag
 35219                                  linked:
 35220                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35221                                  	;transfer SYS_RET_OK
 35222                                  	; 17/12/2022
 35223 000064E1 EB9D                    	jmp	short AllocOperOk
 35224                                  	;jmp	short unlinked
 35225                                  	;;JMP	SYS_RET_OK
 35226                                  
 35227                                  ; MSDOS 6.0
 35228                                  ;--------------------------------------------------------------------------
 35229                                  ; Procedure Name : GetLastArena		-  M003
 35230                                  ;
 35231                                  ; Inputs	 : cx = umb_head
 35232                                  ;
 35233                                  ;
 35234                                  ; Outputs	 : If UMBs are linked
 35235                                  ;			ES = umb_head
 35236                                  ;			DS = arena before umb_head
 35237                                  ;		   else
 35238                                  ;			DS = last arena
 35239                                  ;			ES = next arena. will be umb_head if NC.
 35240                                  ;
 35241                                  ;		   CY if error
 35242                                  ;
 35243                                  ; Uses		 : DS, ES, DI, BX
 35244                                  ;--------------------------------------------------------------------------
 35245                                  
 35246                                  ; 14/05/2019 - Retro DOS v4.0
 35247                                  ; DOSCODE:A4D6h (MSDOS 6.21, MSDOS.SYS)
 35248                                  
 35249                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35250                                  ; DOSCODE:A476h (MSDOS 5.0, MSDOS.SYS)
 35251                                  	
 35252                                  GetLastArena:
 35253 000064E3 50                      	push	ax			; save ax
 35254                                  
 35255 000064E4 36A1[2400]              	mov	ax,[ss:arena_head]
 35256 000064E8 8EC0                    	mov	es,ax			; es = arena_head
 35257 000064EA 31FF                    	xor	di,di
 35258                                  
 35259 000064EC 26803D5A                	cmp     byte [es:di],arena_signature_end
 35260                                  					; Q: is this the last arena
 35261 000064F0 7419                    	je	short GLA_done		; Y: return last arena in ES		
 35262                                  					
 35263                                  GLA_next:
 35264 000064F2 8ED8                    	mov	ds,ax
 35265 000064F4 E879FD                  	call	arena_next		; ax, es -> next arena
 35266                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35267                                  	;jc	short GLA_err
 35268                                  	; 17/12/2022
 35269 000064F7 7228                    	jc	short GLA_err2
 35270                                  
 35271 000064F9 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
 35272 000064FF 7506                    	jnz	short GLA_chkumb	; Y: terminating condition is 
 35273                                  					;    umb_head
 35274                                  					; N: terminating condition is 05Ah
 35275                                  
 35276 00006501 26803D5A                	cmp     byte [es:di],arena_signature_end
 35277                                  					; Q: is this the last arena
 35278 00006505 EB02                    	jmp	short GLA_@f
 35279                                  GLA_chkumb:
 35280 00006507 39C8                    	cmp	ax,cx			; Q: is this umb_head
 35281                                  GLA_@f:
 35282 00006509 75E7                    	jne	short GLA_next		; N: get next arena
 35283                                  
 35284                                  GLA_done:
 35285                                  					; M061 - Start
 35286 0000650B 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
 35287 00006511 750B                    	jnz	short GLA_ret		; Y: we're done
 35288                                  					; N: let us confirm that the next 
 35289                                  					;    arena is umb_head
 35290 00006513 8ED8                    	mov	ds,ax
 35291 00006515 E858FD                  	call	arena_next		; ax, es -> next arena
 35292                                  	;jc	short GLA_err
 35293 00006518 7207                    	jc	short GLA_err2
 35294 0000651A 39C8                    	cmp	ax,cx			; Q: is this umb_head
 35295 0000651C 7502                    	jne	short GLA_err		; N: error
 35296                                  					; M061 - End
 35297                                  GLA_ret:
 35298                                  	; 17/12/2022				
 35299                                  	;clc
 35300                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35301                                  	;clc
 35302 0000651E 58                      	pop	ax			; M061
 35303 0000651F C3                      	retn				; M061
 35304                                  
 35305                                  GLA_err:
 35306 00006520 F9                      	stc				; M061
 35307                                  GLA_err2:
 35308 00006521 58                      	pop	ax
 35309 00006522 C3                      	retn
 35310                                  
 35311                                  ;============================================================================
 35312                                  ; SRVCALL.ASM, MSDOS 6.0, 1991
 35313                                  ;============================================================================
 35314                                  ; 04/08/2018 - Retro DOS v3.0
 35315                                  
 35316                                  ;	TITLE SRVCALL - Server DOS call
 35317                                  ;	NAME  SRVCALL
 35318                                  
 35319                                  ;**	SRVCALL.ASM - Server DOS call functions
 35320                                  ;
 35321                                  ;
 35322                                  ;	$ServerCall
 35323                                  ;
 35324                                  ;	Modification history:
 35325                                  ;
 35326                                  ;	    Created: ARR 08 August 1983
 35327                                  
 35328                                  ;AsmVars <Installed>
 35329                                  
 35330                                  ;include dpl.asm
 35331                                  
 35332                                  ;Installed = TRUE
 35333                                  
 35334                                  ; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 35335                                  ; ---------------------------------------------------------------------------
 35336                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35337                                  
 35338                                  ;BREAK <ServerCall -- Server DOS call>
 35339                                  
 35340                                  ; DOSCODE:A517h (MSDOS 6.21, MSDOS.SYS)
 35341                                  ; DOSCODE:A4B7h (MSDOS 5.0, MSDOS.SYS)
 35342                                  
 35343                                  ;hkn; TABLE	SEGMENT
 35344                                  ;Public SRVC001S,SRVC001E
 35345                                  ;SRVC001S label byte
 35346                                  
 35347                                  SRVC001S:
 35348                                  
 35349 00006523 [2765]                  SERVERTAB:	dw	SERVER_DISP
 35350 00006525 [7965]                  SERVERLEAVE:	dw	SERVERRETURN
 35351 00006527 0B                      SERVER_DISP:	db	(SERVER_DISP_END-SERVER_DISP-1)/2 ; = 11
 35352 00006528 [E165]                  		dw	SRV_CALL	; 0
 35353 0000652A [7A65]                  		dw	COMMIT_ALL	; 1
 35354 0000652C [B065]                  		dw	CLOSE_NAME	; 2
 35355 0000652E [BB65]                  		dw	CLOSE_UID	; 3
 35356 00006530 [C265]                  		dw	CLOSE_UID_PID	; 4
 35357 00006532 [C965]                  		dw	GET_LIST	; 5
 35358 00006534 [2266]                  		dw	GET_DOS_DATA	; 6
 35359 00006536 [4666]                  		dw	SPOOL_OPER	; 7
 35360 00006538 [4666]                  		dw	SPOOL_OPER	; 8
 35361 0000653A [4666]                  		dw	SPOOL_OPER	; 9
 35362 0000653C [5266]                  		dw	_$SetExtendedError  ; 10
 35363                                  
 35364                                  SERVER_DISP_END:  ;  LABEL BYTE
 35365                                  
 35366                                  ;SRVC001E label byte
 35367                                  
 35368                                  SRVC001E:
 35369                                  
 35370                                  ;hkn; TABLE	ENDS
 35371                                  
 35372                                  ;----------------------------------------------------------------------------
 35373                                  ;
 35374                                  ; Procedure Name : $ServerCall
 35375                                  ;
 35376                                  ; Inputs:
 35377                                  ;	DS:DX -> DPL  (except calls 7,8,9)
 35378                                  ; Function:
 35379                                  ;	AL=0	Server DOS call
 35380                                  ;	AL=1	Commit All files
 35381                                  ;	AL=2	Close file by name (SHARING LOADED ONLY) DS:DX in DPL -> name
 35382                                  ;	AL=3	Close all files for DPL_UID
 35383                                  ;	AL=4	Close all files for DPL_UID/PID_PID
 35384                                  ;	AL=5	Get open file list entry
 35385                                  ;		    IN: BX File Index
 35386                                  ;			CX User Index
 35387                                  ;		    OUT:ES:DI -> Name
 35388                                  ;			BX = UID
 35389                                  ;		    CX = # locked blocks held by this UID
 35390                                  ;	AL=6	Get DOS data area
 35391                                  ;		    OUT: DS:SI -> Start
 35392                                  ;			CX size in bytes of swap if indos
 35393                                  ;			DX size in bytes of swap always
 35394                                  ;	AL=7	Get truncate flag
 35395                                  ;	AL=8	Set truncate flag
 35396                                  ;	AL=9	Close all spool files
 35397                                  ;	AL=10	SetExtendedError
 35398                                  ;
 35399                                  ;----------------------------------------------------------------------------
 35400                                  
 35401                                  _$ServerCall:
 35402                                  	; 13/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35403                                  	; DOSCODE:A4D2h (MSDOS 5.0 MSDOS.SYS)		
 35404                                  	; 10/06/2019
 35405                                  	; 29/04/2019 - Retro DOS v4.0
 35406                                  	; DOSCODE:A532h (MSDOS 6.21 MSDOS.SYS)
 35407                                  
 35408                                  	; 05/08/2018 - Retro DOS v3.0
 35409                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 657Bh
 35410 0000653E 3C07                    	CMP	AL,7
 35411 00006540 7204                    	JB	short SET_STUFF
 35412 00006542 3C09                    	CMP	AL,9
 35413 00006544 761A                    	JBE	short NO_SET_ID		; No DPL on calls 7,8,9
 35414                                  SET_STUFF:
 35415 00006546 89D6                    	MOV	SI,DX			; Point to DPL with DS:SI
 35416                                  	;mov	bx,[si+12h]
 35417 00006548 8B5C12                  	MOV	BX,[SI+DPL.UID]
 35418                                  
 35419                                  	; MSDOS 6.0
 35420                                  ;SR;
 35421                                  ; WIN386 updates the USER_ID itself. If WIN386 is present we skip the updating
 35422                                  ; of USER_ID
 35423                                  
 35424 0000654B 36F606[3010]01          	test	byte [SS:IsWin386],1
 35425 00006551 7505                    	jnz	short skip_win386
 35426                                  
 35427                                  ;hkn; SS override for user_id and proc_id
 35428                                  	; 15/08/2018
 35429 00006553 36891E[3E03]            	MOV	[SS:USER_ID],BX		; Set UID
 35430                                  
 35431                                  skip_win386:
 35432 00006558 8B5C14                  	MOV	BX,[SI+DPL.PID]
 35433 0000655B 36891E[3C03]            	MOV	[SS:PROC_ID],BX		; Set process ID
 35434                                  NO_SET_ID:
 35435                                  	; 10/06/2019 - Retro DOS v4.0
 35436 00006560 2EFF36[2565]            	PUSH	word [cs:SERVERLEAVE]	; push return address
 35437 00006565 2EFF36[2365]            	PUSH	word [cS:SERVERTAB]	; push table address
 35438 0000656A 50                      	PUSH	AX
 35439 0000656B E8B4AC                  	call	TableDispatch
 35440                                  
 35441                                  ;hkn; SS override
 35442                                  	;mov 	byte [SS:EXETERR_LOCUS],1
 35443 0000656E 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 35444                                  	;error	error_invalid_function
 35445                                  	;mov	al,1
 35446 00006574 B001                    	MOV	AL,error_invalid_function
 35447                                  servercall_error:
 35448 00006576 E9C7A0                  	JMP	SYS_RET_ERR
 35449                                  
 35450                                  SERVERRETURN:
 35451 00006579 C3                      	retn
 35452                                  
 35453                                  ; Commit - iterate through the open file list and make sure that the
 35454                                  ; directory entries are correctly updated.
 35455                                  
 35456                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35457                                  COMMIT_ALL:
 35458 0000657A 31DB                    	XOR	BX,BX			;   for (i=0; ThisSFT=getSFT(i); i++)
 35459 0000657C 16                      	push	ss
 35460 0000657D 1F                      	pop	ds
 35461 0000657E E890AD                  	call	ECritSFT		; Gonna scan SFT cache, lock it down
 35462                                  CommitLoop:
 35463 00006581 53                      	push	bx
 35464 00006582 E82401                  	call	SFFromSFN
 35465 00006585 7222                    	JC	short CommitDone
 35466 00006587 26833D00                	cmp	word [es:di],0
 35467                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],0
 35468                                  					; if (ThisSFT->refcount != 0)
 35469 0000658B 7418                    	JZ	short CommitNext
 35470                                  	;cmp	word [es:di],0FFFFh ; -1
 35471 0000658D 26833DFF                	cmp	word [ES:DI],sf_busy
 35472                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],sf_busy  
 35473                                  					; BUSY SFTs have god knows what
 35474 00006591 7412                    	JZ	short CommitNext	;   in them.
 35475                                  	; 17/12/2022
 35476 00006593 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
 35477                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
 35478 00006598 750B                    	JNZ	short CommitNext	;  Skip Network SFTs so the SERVER
 35479                                  					;	doesn't deadlock
 35480 0000659A 893E[9E05]              	MOV	[THISSFT],DI
 35481 0000659E 8C06[A005]              	MOV	[THISSFT+2],ES
 35482 000065A2 E8FDCA                  	call	DOS_COMMIT		;	DOSCommit ();
 35483                                  CommitNext:
 35484 000065A5 5B                      	pop	bx
 35485 000065A6 43                      	INC	BX
 35486 000065A7 EBD8                    	JMP	short CommitLoop
 35487                                  CommitDone:
 35488 000065A9 E880AD                  	call	LCritSFT
 35489 000065AC 5B                      	pop	bx
 35490                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35491                                  Commit_Ok:
 35492 000065AD E987A0                  	jmp	SYS_RET_OK
 35493                                  	
 35494                                  
 35495                                  CLOSE_NAME:
 35496                                  
 35497                                  ;if installed
 35498                                  
 35499                                  ;hkn; SS override
 35500                                  	;call	far [ss:MFTcloN]
 35501 000065B0 36FF1E[A400]            	Call	far [SS:JShare+(5*4)] ; 5 = MFTcloN
 35502                                  ;else
 35503                                  ;	Call	MFTcloN
 35504                                  ;endif
 35505                                  
 35506                                  CheckReturns:
 35507 000065B5 7202                    	JC	short func_err
 35508                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35509                                  	;transfer SYS_RET_OK
 35510                                  Commit_Okj:
 35511 000065B7 EBF4                    	jmp	short Commit_Ok
 35512                                  	;jmp	SYS_RET_OK
 35513                                  
 35514                                  func_err:
 35515                                  	;transfer SYS_RET_ERR
 35516                                  	;jmp	SYS_RET_ERR
 35517 000065B9 EBBB                    	jmp	short servercall_error
 35518                                  
 35519                                  CLOSE_UID:
 35520                                  
 35521                                  ;if installed
 35522                                  ;hkn; SS override
 35523                                  	;call	far [ss:MFTclU]
 35524 000065BB 36FF1E[9C00]            	Call	far [SS:JShare+(3*4)] ; 3 = MTFTclu
 35525                                  ;else
 35526                                  ;	Call	MFTclU
 35527                                  ;endif
 35528 000065C0 EBF3                    	JMP	short CheckReturns
 35529                                  
 35530                                  CLOSE_UID_PID:
 35531                                  
 35532                                  ;if installed
 35533                                  ;hkn; SS override
 35534                                  	;call	far [ss:MFTCloseP]
 35535 000065C2 36FF1E[A000]            	Call	far [SS:JShare+(4*4)] ; 4 = MFTCloseP 
 35536                                  ;else
 35537                                  ;	Call	MFTCloseP
 35538                                  ;endif
 35539 000065C7 EBEC                    	JMP	short CheckReturns
 35540                                  
 35541                                  GET_LIST:
 35542                                  
 35543                                  ;if installed
 35544                                  ;hkn; SS override
 35545                                  	;call	far [ss:MFT_get]
 35546 000065C9 36FF1E[B400]            	Call	far [SS:JShare+(9*4)] ; 9 = MFT_get
 35547                                  ;else
 35548                                  ;	Call	MFT_get
 35549                                  ;endif
 35550 000065CE 72E9                    	JC	short func_err
 35551 000065D0 E8AE9E                  	call	Get_User_Stack
 35552                                  	;mov	[si+2],bx
 35553 000065D3 895C02                  	MOV	[SI+user_env.user_BX],BX
 35554                                  	;mov	[si+10],di
 35555 000065D6 897C0A                  	MOV	[SI+user_env.user_DI],DI
 35556                                  	;mov	[si+16],es
 35557 000065D9 8C4410                  	MOV	[SI+user_env.user_ES],ES
 35558                                  SetCXOK:
 35559                                  	;mov	[si+4],cx
 35560 000065DC 894C04                  	MOV	[SI+user_env.user_CX],CX
 35561                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35562                                  	;transfer SYS_RET_OK
 35563                                  Commit_Okj2:
 35564                                  	; 17/12/2022
 35565 000065DF EBCC                    	jmp	short Commit_Ok
 35566                                  	;jmp	short Commit_Okj
 35567                                  	;;jmp	SYS_RET_OK
 35568                                  
 35569                                  SRV_CALL:
 35570 000065E1 58                      	POP	AX			; get rid of call to $srvcall
 35571 000065E2 1E                      	push	ds
 35572 000065E3 56                      	push	si
 35573 000065E4 E89A9E                  	call	Get_User_Stack
 35574 000065E7 5F                      	pop	di
 35575 000065E8 07                      	pop	es
 35576                                  
 35577                                  ; DS:SI point to stack
 35578                                  ; ES:DI point to DPL
 35579                                  
 35580 000065E9 E815AC                  	call	XCHGP
 35581                                  
 35582                                  ; DS:SI point to DPL
 35583                                  ; ES:DI point to stack
 35584                                  ;
 35585                                  ; We now copy the registers from DPL to save stack
 35586                                  
 35587 000065EC 56                      	push	si
 35588 000065ED B90600                  	MOV	CX,6
 35589 000065F0 F3A5                    	REP	MOVSW			; Put in AX,BX,CX,DX,SI,DI
 35590 000065F2 47                      	INC	DI
 35591 000065F3 47                      	INC	DI			; Skip user_BP
 35592 000065F4 A5                      	MOVSW				; DS
 35593 000065F5 A5                      	MOVSW				; ES
 35594 000065F6 5E                      	pop	si			; DS:SI -> DPL
 35595 000065F7 8B04                    	mov	ax,[SI]
 35596                                  	;MOV	AX,[SI+DPL.AX]
 35597                                  	;mov	bx,[si+2]
 35598 000065F9 8B5C02                  	MOV	BX,[SI+DPL.BX]
 35599                                  	;mov	cx,[si+4]
 35600 000065FC 8B4C04                  	MOV	CX,[SI+DPL.CX]
 35601                                  	;mov	dx,[si+6]
 35602 000065FF 8B5406                  	MOV	DX,[SI+DPL.DX]
 35603                                  	;mov	di,[si+10]
 35604 00006602 8B7C0A                  	MOV	DI,[SI+DPL.DI]
 35605                                  	;mov	es,[si+14]
 35606 00006605 8E440E                  	MOV	ES,[SI+DPL.ES]
 35607                                  	;push	word [si+8]
 35608 00006608 FF7408                  	PUSH	word [SI+DPL.SI]
 35609                                  	;mov	ds,[si+12]
 35610 0000660B 8E5C0C                  	MOV	DS,[SI+DPL.DS]
 35611 0000660E 5E                      	POP	SI
 35612                                  
 35613                                  ;hkn; SS override for next 3
 35614 0000660F 368C1E[EC05]            	MOV	[SS:SAVEDS],DS
 35615 00006614 36891E[EA05]            	MOV	[SS:SAVEBX],BX
 35616 00006619 36C606[7205]FF          	MOV	byte [SS:FSHARING],-1	; set no redirect flag
 35617 0000661F E9669D                  	jmp	REDISP
 35618                                  
 35619                                  GET_DOS_DATA:
 35620 00006622 16                      	push	ss
 35621 00006623 07                      	pop	es
 35622 00006624 BF[2003]                	MOV     DI,SWAP_START
 35623 00006627 B9[AC0A]                	MOV     CX,SWAP_END
 35624 0000662A BA[3A03]                	MOV     DX,SWAP_ALWAYS
 35625 0000662D 29F9                    	SUB     CX,DI
 35626 0000662F 29FA                    	SUB     DX,DI
 35627 00006631 D1E9                    	SHR     CX,1                    ; div by 2, remainder in carry
 35628 00006633 83D100                  	ADC     CX,0                    ; div by 2 + round up
 35629 00006636 D1E1                    	SHL     CX,1                    ; round up to 2 boundary.
 35630 00006638 E8469E                  	call	Get_User_Stack
 35631                                  	;mov	[si+14],es
 35632 0000663B 8C440E                  	MOV     [SI+user_env.user_DS],ES
 35633                                  	;mov	[si+8],di
 35634 0000663E 897C08                  	MOV     [SI+user_env.user_SI],DI
 35635                                  	;mov	[si+6],dx
 35636 00006641 895406                  	MOV     [SI+user_env.user_DX],DX
 35637 00006644 EB96                    	JMP	short SetCXOK
 35638                                  
 35639                                  SPOOL_OPER:
 35640                                  	;CallInstall NETSpoolOper,MultNET,37,AX,BX
 35641                                  
 35642 00006646 50                      	push    ax
 35643 00006647 B82511                  	mov     ax,1125h
 35644 0000664A CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
 35645                                  			; STACK: WORD subfunction
 35646                                  			; Return: CF set on error, AX = error code
 35647                                  			; STACK unchanged
 35648 0000664C 5B                      	pop	bx
 35649                                  	; 17/12/2022
 35650                                  	;JC	short func_err2
 35651 0000664D 7390                    	jnc	short Commit_Okj2
 35652                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35653                                  	;;jmp	SYS_RET_OK
 35654                                  	;jmp	short Commit_Okj2
 35655                                  	
 35656                                  func_err2:
 35657 0000664F E9EE9F                  	jmp	SYS_RET_ERR
 35658                                  
 35659                                  ;Break	<$SetExtendedError - set extended error for later retrieval>
 35660                                  ;--------------------------------------------------------------------------
 35661                                  ;
 35662                                  ; Procedure Name : $SetExtendedError
 35663                                  ;
 35664                                  ; $SetExtendedError takes extended error information and loads it up for the
 35665                                  ; next extended error call. This is used by interrupt-level proccessors to
 35666                                  ; mask their actions.
 35667                                  ;
 35668                                  ;   Inputs: DS:SI points to DPL which contains all registers
 35669                                  ;   Outputs: none
 35670                                  ;
 35671                                  ;---------------------------------------------------------------------------
 35672                                  
 35673                                  _$SetExtendedError:
 35674                                  
 35675                                  ;hkn; SS override for all variables used
 35676                                  
 35677 00006652 8B04                    	mov	ax,[si]
 35678                                  	;MOV	AX,[SI+DPL.AX]
 35679 00006654 36A3[2403]              	MOV	[SS:EXTERR],AX
 35680                                  	;mov	ax,[si+10]
 35681 00006658 8B440A                  	MOV	AX,[SI+DPL.DI]
 35682 0000665B 36A3[2803]              	MOV	[SS:EXTERRPT],AX
 35683                                  	;mov	ax,[si+14]
 35684 0000665F 8B440E                  	MOV	AX,[SI+DPL.ES]
 35685 00006662 36A3[2A03]              	MOV	[SS:EXTERRPT+2],AX
 35686                                  	;mov	ax,[si+2]
 35687 00006666 8B4402                  	MOV	AX,[SI+DPL.BX]
 35688 00006669 36A3[2603]              	MOV	[SS:EXTERR_ACTION],AX
 35689                                  	;mov	ax,[si+4]
 35690 0000666D 8B4404                  	MOV	AX,[SI+DPL.CX]
 35691 00006670 368826[2303]            	MOV	[SS:EXTERR_LOCUS],AH
 35692 00006675 C3                      	retn
 35693                                  
 35694                                  ;============================================================================
 35695                                  ; UTIL.ASM, MSDOS 6.0, 1991
 35696                                  ;============================================================================
 35697                                  ; 05/08/2018 - Retro DOS v3.0
 35698                                  ; 05/05/2019 - Retro DOS v4.0
 35699                                  
 35700                                  ;**	Handle related utilities for MSDOS 2.X.
 35701                                  ;----------------------------------------------------------------------------
 35702                                  ;	pJFNFromHandle	written
 35703                                  ;	SFFromHandle	written
 35704                                  ;	SFFromSFN	written
 35705                                  ;	JFNFree 	written
 35706                                  ;	SFNFree 	written
 35707                                  ;
 35708                                  ;	Modification history:
 35709                                  ;
 35710                                  ;	    Created: MZ 1 April 1983
 35711                                  ;----------------------------------------------------------------------------
 35712                                  
 35713                                  ;	BREAK	<pJFNFromHandle - return pointer to JFN table entry>
 35714                                  
 35715                                  ;**	pJFNFromHandle - Translate Handle to Pointer to JFN
 35716                                  ;----------------------------------------------------------------------------
 35717                                  ;	pJFNFromHandle takes a file handle and turns that into a pointer to
 35718                                  ;	the JFN entry (i.e., to a byte holding the internal file handle #)
 35719                                  ;
 35720                                  ;	NOTE:
 35721                                  ;	  This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 35722                                  ;	  at DOSINIT time with SS NOT DOSGROUP
 35723                                  ;
 35724                                  ;	ENTRY	(bx) = handle
 35725                                  ;	EXIT	'C' clear if ok
 35726                                  ;		  (es:di) = address of JFN value
 35727                                  ;		'C' set if error
 35728                                  ;		  (ax) = error code
 35729                                  ;	USES	AX, DI, ES, Flags
 35730                                  ;----------------------------------------------------------------------------
 35731                                  
 35732                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35733                                  
 35734                                  pJFNFromHandle:
 35735                                  	; 05/05/2019 - Retro DOS v4.0
 35736                                  	;getdseg <es>			; es -> dosdata
 35737 00006676 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 35738                                  	
 35739                                  	;MOV	ES,[cs:CurrentPDB]	; get user process data block
 35740 0000667B 268E06[3003]            	mov	es,[es:CurrentPDB]
 35741                                  
 35742                                  	;cmp	bx,[ES:32h]
 35743 00006680 263B1E3200              	CMP	BX,[ES:PDB.JFN_Length]	; is handle greater than allocated
 35744 00006685 7204                    	JB	short pjfn10		; no, get offset
 35745                                  ReturnCarry_inv_hndl: ; 05/08/2018 - Retro DOS v3.0
 35746                                  	;mov	al,6
 35747 00006687 B006                    	MOV     AL,error_invalid_handle ; appropriate error
 35748                                  ReturnCarry:
 35749 00006689 F9                      	STC                             ; signal error
 35750 0000668A C3                      	retn				; go back
 35751                                  pjfn10: 
 35752                                  	;les	di,[es:34h]
 35753 0000668B 26C43E3400              	LES	DI,[ES:PDB.JFN_Pointer]	; get pointer to beginning of table
 35754 00006690 01DF                    	ADD	DI,BX			; add in offset, clear 'C'
 35755                                  	;clc
 35756                                  pJFNFromHandle_error:
 35757 00006692 C3                      	retn
 35758                                  
 35759                                  ;BREAK <SFFromHandle - return pointer (or error) to SF entry from handle>
 35760                                  ;----------------------------------------------------------------------------
 35761                                  ;
 35762                                  ; Procedure Name : SFFromHandle
 35763                                  ;
 35764                                  ; SFFromHandle - Given a handle, get JFN and then index into SF table
 35765                                  ;
 35766                                  ;   Input:      BX has handle
 35767                                  ;   Output:     Carry Set
 35768                                  ;                   AX has error code
 35769                                  ;               Carry Reset
 35770                                  ;                   ES:DI has pointer to SF entry
 35771                                  ;   Registers modified: If error, AX,ES, else ES:DI
 35772                                  ; NOTE:
 35773                                  ;   This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 35774                                  ;       at DOSINIT time with SS NOT DOSGROUP
 35775                                  ;
 35776                                  ;----------------------------------------------------------------------------
 35777                                  
 35778                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35779                                  
 35780                                  SFFromHandle:
 35781 00006693 E8E0FF                  	CALL	pJFNFromHandle		; get jfn pointer
 35782                                  	;retc				; return if error
 35783 00006696 72FA                    	jc	short pJFNFromHandle_error
 35784 00006698 26803DFF                	CMP     BYTE [ES:DI],-1		; unused handle
 35785                                  	;JNZ	short GetSF		; nope, suck out SF
 35786                                  	;;mov	al,6
 35787                                  	;MOV	AL,error_invalid_handle ; appropriate error
 35788                                  	;jmp	short ReturnCarry	; signal it
 35789                                  	; 17/12/2022
 35790                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35791 0000669C 74E9                    	jz	short ReturnCarry_inv_hndl ; Retro DOS v3.0 modification
 35792                                  	;JNZ	short GetSF		; nope, suck out SF
 35793                                  	;;mov	al,6
 35794                                  	;MOV	AL,error_invalid_handle ; appropriate error
 35795                                  	;jmp	short ReturnCarry	; signal it
 35796                                  GetSF:
 35797 0000669E 53                      	push	bx			; save handle
 35798 0000669F 268A1D                  	MOV     BL,[ES:DI]		; get SFN
 35799 000066A2 30FF                    	XOR     BH,BH                   ; ignore upper half
 35800 000066A4 E80200                  	CALL    SFFromSFN               ; get real sf spot
 35801 000066A7 5B                      	pop	bx			; restore
 35802 000066A8 C3                      	retn                        	; say goodbye
 35803                                  
 35804                                  ;BREAK <SFFromSFN - index into SF table for SFN>
 35805                                  
 35806                                  ;**	SFFromSFN - Get an SF Table entry from an SFN
 35807                                  ;----------------------------------------------------------------------------
 35808                                  ;	SFFromSfn uses an SFN to index an entry into the SF table. This
 35809                                  ;	is more than just a simple index instruction because the SF table
 35810                                  ;	can be made up of multiple pieces chained together. We follow the
 35811                                  ;	chain to the right piece and then do the index operation.
 35812                                  ;
 35813                                  ;   NOTE:
 35814                                  ;	This routine is called from SFFromHandle which is called
 35815                                  ;       at DOSINIT time with SS NOT DOSGROUP
 35816                                  ;
 35817                                  ;	ENTRY	BX has SF index
 35818                                  ;	EXIT	'C' clear if OK
 35819                                  ;		  ES:DI points to SF entry
 35820                                  ;		'C' set if index too large
 35821                                  ;	USES	BX, DI, ES
 35822                                  ;----------------------------------------------------------------------------
 35823                                  
 35824                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35825                                  
 35826                                  SFFromSFN:
 35827                                  	; 05/05/2019 - Retro DOS v4.0
 35828                                  	;getdseg <es>			; es -> dosdata
 35829 000066A9 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 35830                                  
 35831                                  	;LES	DI,[CS:SFT_ADDR]	; (es:di) = start of SFT table
 35832 000066AE 26C43E[2A00]            	les	di,[es:SFT_ADDR]
 35833                                  sfsfn5:	
 35834                                  	;cmp	bx,[es:di+4]
 35835 000066B3 263B5D04                	CMP	BX,[ES:DI+SFT.SFCount]	; is handle in this table?
 35836 000066B7 720E                    	JB	short sfsfn7		; yes, go grab it
 35837                                  	;sub	bx,[es:di+4]
 35838 000066B9 262B5D04                	SUB     BX,[ES:DI+SFT.SFCount]
 35839 000066BD 26C43D                  	les	di,[es:di] ; 14/08/2018
 35840                                  	;LES	DI,[ES:DI+SFT.SFLink]	; get next table segment
 35841 000066C0 83FFFF                  	CMP     DI,-1                   ; end of tables?
 35842 000066C3 75EE                    	JNZ	short sfsfn5		; no, try again
 35843 000066C5 F9                      	STC
 35844 000066C6 C3                      	retn				; return with error, not found
 35845                                  sfsfn7:
 35846 000066C7 50                      	push	ax
 35847                                  	;mov	ax,53 ; MSDOS 3.3
 35848                                  	;mov	ax,59 ; MSDOS 6.0
 35849                                  	;MOV	AX,SF_ENTRY.size	; put it in a nice place
 35850                                  	
 35851                                  	; 17/12/2022
 35852 000066C8 B03B                    	mov	al,SF_ENTRY.size ; 28/05/2019
 35853                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35854                                  	;mov	ax,SF_ENTRY.size ; 59
 35855                                  	
 35856 000066CA F6E3                    	MUL	BL			; (ax) = offset into this SF block
 35857 000066CC 01C7                    	ADD	DI,AX			; add base of SF block
 35858 000066CE 58                      	pop	ax
 35859                                  	;add	di,6
 35860 000066CF 83C706                  	ADD	DI,SFT.SFTable		; offset into structure, 'C' cleared
 35861 000066D2 C3                      	retn				; return with 'C' clear
 35862                                  
 35863                                  ;	BREAK <JFNFree - return a jfn pointer if one is free>
 35864                                  
 35865                                  ;**	JFNFree - Find a Free JFN Slot
 35866                                  ;----------------------------------------------------------------------------
 35867                                  ;	JFNFree scansthrough the JFN table and returnsa pointer to a free slot
 35868                                  ;
 35869                                  ;	ENTRY	(ss) = DOSDATA
 35870                                  ;	EXIT	'C' clear if OK
 35871                                  ;		  (bx) = new handle
 35872                                  ;		  (es:di) = pointer to JFN slot
 35873                                  ;		'C' set if error
 35874                                  ;		  (al) = error code
 35875                                  ;	USES	bx, di, es, flags
 35876                                  ;----------------------------------------------------------------------------
 35877                                  
 35878                                  JFNFree:
 35879 000066D3 31DB                    	XOR	BX,BX			; (bx) = initial JFN to try
 35880                                  jfnf1:	
 35881 000066D5 E89EFF                  	CALL	pJFNFromHandle		; get the appropriate handle
 35882 000066D8 7209                    	JC	short jfnf5		; no more handles
 35883 000066DA 26803DFF                	CMP     BYTE [ES:DI],-1		; free?
 35884 000066DE 7405                    	je	short jfnfx		; yes, carry is clear
 35885 000066E0 43                      	INC     BX                      ; no, next handle
 35886 000066E1 EBF2                    	JMP	short jfnf1		; and try again
 35887                                  
 35888                                  	; Error. 'C' set
 35889                                  jfnf5:	
 35890                                  	;mov	al,4
 35891 000066E3 B004                    	MOV	AL,error_too_many_open_files
 35892                                  jfnfx:	
 35893 000066E5 C3                      	retn				; bye
 35894                                  
 35895                                  ;	BREAK <SFNFree - Allocate a free SFN>
 35896                                  
 35897                                  ;**	SFNFree - Allocate a Free SFN/SFT
 35898                                  ;----------------------------------------------------------------------------
 35899                                  ;	SFNFree scans through the sf table looking for a free entry
 35900                                  ;	If it finds one it partially allocates it by setting SFT_REF_COUNT = -1
 35901                                  ;
 35902                                  ;	The problem is that we want to mark the SFT busy so that other threads
 35903                                  ;	can't allocate the SFT before we're finished marking it up.  However,
 35904                                  ;	we can't just mark it busy because we may get blown out of our open
 35905                                  ;	by INT24 and leave the thing orphaned.	To solve this we mark it
 35906                                  ;	"allocation in progress" by setting SFT_REF_COUNT = -1.  If we see
 35907                                  ;	an SFT with this value we look to see if it belongs to this user
 35908                                  ;	and process.  If it does belong to us then it must be an orphan
 35909                                  ;	and we reclaim it.
 35910                                  ;
 35911                                  ;	BUGBUG - improve the performance. I guess it's smaller to call SFFromSFN
 35912                                  ;		over and over, but we could at least set a high water mark...
 35913                                  ;		cause an N^2 loop calling slow SFFromSFN is real slow, too slow
 35914                                  ;		even though this is not a frequently called routine - jgl
 35915                                  ;
 35916                                  ;	ENTRY	(ss) = DOSDATA
 35917                                  ;	EXIT	'C' clear if no error
 35918                                  ;		  (bx) = SFN
 35919                                  ;		  (es:di) = pointer to SFT
 35920                                  ;		  es:[di].SFT_REF_COUNT = -1
 35921                                  ;		'C' set if error
 35922                                  ;		  (al) = error code
 35923                                  ;	USES	bx, di, es, Flags
 35924                                  ;----------------------------------------------------------------------------
 35925                                  
 35926                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35927                                  	; DOSCODE:A682h (MSDOS 5.0 MSDOS.SYS)
 35928                                  
 35929                                  SFNFree:
 35930                                  	; 12/08/2018
 35931                                  	; 05/08/2018 - Retro DOS v3.0
 35932                                  	;
 35933                                  	; MSDOS 6.0
 35934 000066E6 50                      	push	ax
 35935 000066E7 31DB                    	xor	bx,bx			; (bx) = SFN to consider
 35936                                  sfnf5:	
 35937 000066E9 53                      	push	bx
 35938 000066EA E8BCFF                  	call	SFFromSFN		; get the potential handle
 35939 000066ED 5B                      	pop	bx
 35940 000066EE 723A                    	jc	short sfnf95		; no more free SFNs
 35941 000066F0 26833D00                	cmp	word [ES:DI],0
 35942                                  	;cmp	word [ES:DI+SF_ENTRY.sf_Ref_Count],0 ; free?
 35943 000066F4 741D                    	je	short sfnf20			; yep, got one
 35944                                  	
 35945                                  	;cmp	word [es:di],0FFFFh ; -1
 35946 000066F6 26833DFF                	cmp	word [ES:DI],sf_busy
 35947                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 35948 000066FA 7403                    	je	short sfnf10		; special busy mark
 35949                                  sfnf7:	
 35950 000066FC 43                      	inc	bx			; try the next one
 35951 000066FD EBEA                    	jmp	short sfnf5
 35952                                  
 35953                                  ;	The SFT has the special "busy" mark; if it belongs to us then
 35954                                  ;	it was abandoned during a earlier call and we can use it.
 35955                                  ;
 35956                                  ;	(bx)	= SFN
 35957                                  ;	(es:di) = pointer to SFT
 35958                                  ;	(TOS)	= caller's (ax)
 35959                                  
 35960                                  sfnf10:	
 35961 000066FF 36A1[3E03]              	mov	ax,[SS:USER_ID]
 35962                                  	;cmp	[es:di+2Fh],ax
 35963 00006703 2639452F                	cmp	[ES:DI+SF_ENTRY.sf_UID],ax
 35964 00006707 75F3                    	jnz	short sfnf7		; not ours
 35965 00006709 36A1[3C03]              	mov	ax,[SS:PROC_ID]
 35966                                  	;cmp	[es:di+31h],ax
 35967 0000670D 26394531                	cmp	[ES:DI+SF_ENTRY.sf_PID],ax
 35968 00006711 75E9                    	jnz	short sfnf7		; can't use this one, try the next
 35969                                  
 35970                                  ;	We have an SFT to allocate
 35971                                  ;
 35972                                  ;	(bx)	= SFN
 35973                                  ;	(es:di) = pointer to SFT
 35974                                  ;	(TOS)	= caller's (ax)
 35975                                  
 35976                                  sfnf20:
 35977                                  	; cf = 0 ;; Retro DOS v3.0
 35978                                  
 35979                                  	;mov	word [es:di],0FFFFh
 35980 00006713 26C705FFFF              	mov	word [ES:DI],sf_busy
 35981                                  					; make sure that this is allocated
 35982                                  	;mov	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 35983                                  
 35984 00006718 36A1[3E03]              	mov	ax,[SS:USER_ID]
 35985                                  	;mov	[es:di+2Fh],ax
 35986 0000671C 2689452F                	mov	[ES:DI+SF_ENTRY.sf_UID],ax
 35987 00006720 36A1[3C03]              	mov	ax,[SS:PROC_ID]
 35988                                  	;mov	[es:di+31h],ax
 35989 00006724 26894531                	mov	[ES:DI+SF_ENTRY.sf_PID],ax
 35990                                  sfnf21: ;; Retro DOS v3.0
 35991                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35992                                  	;pop	ax
 35993                                  	;;clc
 35994                                  	;retn				; return with no error
 35995                                  	; 17/12/2022
 35996 00006728 58                      	pop	ax
 35997                                  	;clc
 35998 00006729 C3                      	retn
 35999                                  
 36000                                  ;**	Error - no more free SFNs
 36001                                  ;
 36002                                  ;	'C' set
 36003                                  ;	(TOS) = saved ax
 36004                                  
 36005                                  sfnf95: 
 36006 0000672A 58                      	pop	ax
 36007                                  	;mov	al,4
 36008 0000672B B004                    	mov	al,error_too_many_open_files
 36009 0000672D C3                      	retn				; return with 'C' and error
 36010                                  
 36011                                  ;============================================================================
 36012                                  ; HANDLE.ASM, MSDOS 6.0, 1991
 36013                                  ;============================================================================
 36014                                  ; 13/07/2018 - Retro DOS v3.0
 36015                                  ; 20/05/2019 - Retro DOS v4.0
 36016                                  
 36017                                  ; DOSCODE:A72Bh (MSDOS 6.21, MSDOS.SYS)
 36018                                  
 36019                                  ;	BREAK <$Close - return a handle to the system>
 36020                                  ;----------------------------------------------------------------------------
 36021                                  ;
 36022                                  ;**	$Close - Close a file Handle
 36023                                  ;
 36024                                  ;	BUGBUG - close gets called a LOT with invalid handles - sizzle that
 36025                                  ;		path
 36026                                  ;
 36027                                  ;	Assembler usage:
 36028                                  ;	    MOV     BX, handle
 36029                                  ;	    MOV     AH, Close
 36030                                  ;	    INT     int_command
 36031                                  ;
 36032                                  ;	ENTRY	(bx) = handle
 36033                                  ;	EXIT	<normal INT21 return convention>
 36034                                  ;	USES	all
 36035                                  ;
 36036                                  ;----------------------------------------------------------------------------
 36037                                  
 36038                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36039                                  ; DOSCODE:A6CBh (MSDOS 5.0 MSDOS.SYS)
 36040                                  
 36041                                  _$CLOSE:
 36042                                  ;	Grab the SFT pointer from the JFN.
 36043                                  
 36044 0000672E E85A02                  	call	CheckOwner		; get system file entry
 36045 00006731 722B                    	jc	short CloseError	; error return
 36046 00006733 16                      	push	ss
 36047 00006734 1F                      	pop	ds			; For DOS_CLOSE
 36048 00006735 893E[9E05]              	MOV	[THISSFT],DI		; save offset of pointer
 36049 00006739 8C06[A005]              	MOV	[THISSFT+2],ES		; save segment value
 36050                                  
 36051                                  ; DS:SI point to JFN table entry.
 36052                                  ; ES:DI point to SFT
 36053                                  ;
 36054                                  ; We now examine the user's JFN entry; If the file was a 70-mode file (network
 36055                                  ; FCB, we examine the ref count on the SFT;  if it was 1, we free the JFN.
 36056                                  ; If the file was not a net FCB, we free the JFN too.
 36057                                  
 36058                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],1
 36059 0000673D 26833D01                	cmp	word [ES:DI],1		; will the SFT become free?
 36060 00006741 740A                    	jz	short FreeJFN 		; yes, free JFN anyway.
 36061                                  	;mov	al,[ES:DI+2]
 36062 00006743 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 36063                                  	;and	al,0F0h
 36064 00006747 24F0                    	AND	AL,SHARING_MASK
 36065                                  	;cmp	al,70h
 36066 00006749 3C70                    	CMP	AL,SHARING_NET_FCB
 36067 0000674B 7407                    	JZ	short PostFree		; 70-mode and big ref count => free it
 36068                                  
 36069                                  ; The JFN must be freed.  Get the pointer to it and replace the contents with
 36070                                  ; -1.
 36071                                  
 36072                                  FreeJFN:
 36073 0000674D E826FF                  	call	pJFNFromHandle		;   d = pJFN (handle);
 36074 00006750 26C605FF                	MOV	BYTE [ES:DI],0FFh	; release the JFN
 36075                                  PostFree:
 36076                                  
 36077                                  ; ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_CLOSE!
 36078                                  
 36079 00006754 E8FDC7                  	call	DOS_CLOSE
 36080                                  
 36081                                  ; DOS_Close may return an error. If we see such an error, we report it but
 36082                                  ; the JFN stays closed because DOS_Close always frees the SFT!
 36083                                  
 36084 00006757 7205                    	JC	short CloseError
 36085                                  	;mov	ah,3Eh
 36086 00006759 B43E                    	MOV	AH,CLOSE		; MZ Bogus multiplan fix
 36087                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36088                                  CloseOk:
 36089 0000675B E9D99E                  	jmp	SYS_RET_OK
 36090                                  CloseError:
 36091 0000675E E9DF9E                  	jmp	SYS_RET_ERR
 36092                                  
 36093                                  ;	BREAK <$Commit - commit the file>
 36094                                  ;----------------------------------------------------------------------------
 36095                                  ;
 36096                                  ;**	$Commit - Commit a File
 36097                                  ;
 36098                                  ;	$Commit "commits" a file to disk - all of it's buffers are
 36099                                  ;	flushed out.  BUGBUG - I'm pretty sure that $Commit doesn't update
 36100                                  ;	the directory entry, etc., so this commit is pretty useless. check
 36101                                  ;	and fix this!! jgl
 36102                                  ;
 36103                                  ;	Assembler usage:
 36104                                  ;	    MOV     BX, handle
 36105                                  ;	    MOV     AH, Commit
 36106                                  ;	    INT     int_command
 36107                                  ;
 36108                                  ;	ENTRY	(bx) = handle
 36109                                  ;	EXIT	none
 36110                                  ;	USES	all
 36111                                  ;;----------------------------------------------------------------------------
 36112                                  
 36113                                  _$COMMIT:
 36114                                  ;	Grab the SFT pointer from the JFN.
 36115                                  
 36116 00006761 E82702                  	call	CheckOwner		; get system file entry
 36117 00006764 7213                    	JC	short CommitError	; error return
 36118 00006766 16                      	push	ss
 36119 00006767 1F                      	pop	ds			; For DOS_COMMIT
 36120 00006768 893E[9E05]              	MOV	[THISSFT],DI		; save offset of pointer
 36121 0000676C 8C06[A005]              	MOV	[THISSFT+2],ES		; save segment value
 36122                                  
 36123                                  ;	ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_COMMIT
 36124                                  ;
 36125                                  ;	ES:DI point to SFT
 36126                                  
 36127 00006770 E82FC9                  	call	DOS_COMMIT
 36128 00006773 7204                    	JC	short CommitError
 36129                                  	; 07/12/2022
 36130                                  	;jc	short CloseError
 36131                                  	;mov	ah,68h
 36132 00006775 B468                    	MOV	AH,COMMIT
 36133                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36134                                  	;jmp	SYS_RET_OK
 36135                                  CommitOk:
 36136 00006777 EBE2                    	jmp	short CloseOk	
 36137                                  
 36138                                  CommitError:
 36139                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36140                                  	;jmp	SYS_RET_ERR
 36141 00006779 EBE3                    	jmp	short CloseError
 36142                                  
 36143                                  ;	BREAK <$ExtHandle - extend handle count>
 36144                                  
 36145                                  ;**	$ExtHandle - Extend Handle Count
 36146                                  ;----------------------------------------------------------------------------
 36147                                  ;	Assembler usage:
 36148                                  ;	    MOV     BX, Number of Opens Allowed (MAX=65534;66535 is
 36149                                  ;	    MOV     AX, 6700H			 reserved to mark SFT
 36150                                  ;	    INT     int_command 		 busy )
 36151                                  ;
 36152                                  ;	ENTRY	(bx) = new number of handles
 36153                                  ;	EXIT	'C' clear if OK
 36154                                  ;		'C' set iff err
 36155                                  ;		  (ax) = error code
 36156                                  ;			 AX = error_not_enough_memory
 36157                                  ;			      error_too_many_open_files
 36158                                  ;	USES	all
 36159                                  ;----------------------------------------------------------------------------
 36160                                  
 36161                                  _$ExtHandle:
 36162 0000677B 31ED                    	XOR	BP,BP			; 0: enlarge   1: shrink  2:psp
 36163                                  	;cmp	bx,20
 36164 0000677D 83FB14                  	CMP	BX,FILPERPROC
 36165 00006780 7303                    	JAE	short exth2		; Don't set less than FilPerProc no
 36166 00006782 BB1400                  	MOV	BX,FILPERPROC
 36167                                  exth2:	
 36168 00006785 368E06[3003]            	MOV	ES,[ss:CurrentPDB]	; get user process data block;smr;SS Override
 36169                                  	;mov	cx,[ES:32h]
 36170 0000678A 268B0E3200              	MOV	CX,[ES:PDB.JFN_Length]	; get number of handle allowed
 36171 0000678F 39CB                    	CMP	BX,CX			; the requested == current
 36172 00006791 7455                    	JE	short ok_done 		; yes and exit
 36173 00006793 7722                    	JA	short larger		; go allocate new table
 36174                                  
 36175                                  ;	We're going to shrink the # of handles available
 36176                                  
 36177 00006795 BD0100                  	MOV	BP,1			; shrink
 36178                                  	;mov	ds,[ES:36h]
 36179 00006798 268E1E3600              	MOV	DS,[ES:PDB.JFN_Pointer+2] ;
 36180 0000679D 89DE                    	MOV	SI,BX			;
 36181 0000679F 29D9                    	SUB	CX,BX			; get difference
 36182                                  
 36183                                  ;	BUGBUG - code a SCASB here, should be a bit smaller
 36184                                  chck_handles:
 36185 000067A1 803CFF                  	CMP	BYTE [SI],-1		; scan through handles to ensure close
 36186 000067A4 753D                    	JNZ	short too_many_files	; status
 36187 000067A6 46                      	INC	SI
 36188 000067A7 E2F8                    	LOOP	chck_handles
 36189 000067A9 83FB14                  	CMP	BX,FILPERPROC		; = 20
 36190 000067AC 7709                    	JA	short larger		; no
 36191                                  
 36192 000067AE BD0200                  	MOV	BP,2			; psp
 36193                                  	;mov	di,24
 36194 000067B1 BF1800                  	MOV	DI,PDB.JFN_TABLE	; es:di -> jfn table in psp
 36195 000067B4 53                      	PUSH	BX
 36196 000067B5 EB1D                    	JMP	short movhandl
 36197                                  
 36198                                  larger:
 36199 000067B7 83FBFF                  	CMP	BX,-1			; 65535 is not allowed
 36200 000067BA 747F                    	JZ	short invalid_func	; 10/08/2018
 36201 000067BC F8                      	CLC
 36202 000067BD 53                      	PUSH	BX			; save requested number
 36203 000067BE 83C30F                  	ADD	BX,0FH			; adjust to paragraph boundary
 36204 000067C1 B104                    	MOV	CL,4
 36205                                  	;ror	bx,cl			; MSDOS 3.3
 36206 000067C3 D3DB                    	RCR	BX,CL			; DOS 4.00 fix		;AC000;
 36207 000067C5 81E3FF1F                	AND	BX,1FFFH		; clear most 3 bits
 36208                                  
 36209 000067C9 55                      	PUSH	BP
 36210 000067CA E8DCFA                  	call	_$ALLOC			; allocate memory
 36211 000067CD 5D                      	POP	BP
 36212 000067CE 7266                    	JC	short no_memory		; not enough meory
 36213                                  
 36214 000067D0 8EC0                    	MOV	ES,AX			; es:di points to new table memory
 36215 000067D2 31FF                    	XOR	DI,DI
 36216                                  movhandl:
 36217 000067D4 368E1E[3003]            	MOV	DS,[ss:CurrentPDB] 	; get user PDB address	;smr;SS Override
 36218                                  
 36219 000067D9 F7C50300                	test	BP,3			; enlarge ?
 36220 000067DD 740C                    	JZ	short enlarge 		; yes
 36221 000067DF 59                      	POP	CX			; cx = the amount you shrink
 36222 000067E0 51                      	PUSH	CX
 36223 000067E1 EB0C                    	JMP	short copy_hand
 36224                                  
 36225                                  ;	Done.  'C' clear
 36226                                  
 36227                                  ; 17/12/2022
 36228                                  ;ok_done:
 36229                                  ;	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36230                                  ;	;jmp	short CommitOk
 36231                                  ;	; 17/12/2022
 36232                                  ;	jmp	SYS_RET_OK
 36233                                  
 36234                                  too_many_files:
 36235                                  	;mov	al,4
 36236 000067E3 B004                    	MOV	AL,error_too_many_open_files
 36237                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36238                                  	;jmp	SYS_RET_ERR
 36239                                  CommitErrorj:
 36240                                  	;jmp	short CommitError
 36241                                  	; 17/12/2022
 36242 000067E5 E9589E                  	jmp	SYS_RET_ERR
 36243                                  
 36244                                  ; 17/12/2022 
 36245                                  ok_done:
 36246                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36247                                  	;jmp	short CommitOk
 36248                                  	; 17/12/2022
 36249 000067E8 E94C9E                  	jmp	SYS_RET_OK
 36250                                  
 36251                                  enlarge:
 36252                                  	;mov	cx,[32h]
 36253 000067EB 8B0E3200                	MOV	CX,[PDB.JFN_Length]	; get number of old handles
 36254                                  copy_hand:
 36255 000067EF 89CA                    	MOV	DX,CX
 36256                                  	;lds	si,[34h]
 36257 000067F1 C5363400                	LDS	SI,[PDB.JFN_Pointer]	; get old table pointer
 36258 000067F5 F3A4                    	REP	MOVSB			; copy infomation to new table
 36259 000067F7 59                      	POP	CX			; get new number of handles
 36260 000067F8 51                      	PUSH	CX			; save it again
 36261 000067F9 29D1                    	SUB	CX,DX			; get the difference
 36262 000067FB B0FF                    	MOV	AL,-1			; set availability to handles
 36263 000067FD F3AA                    	REP	STOSB
 36264 000067FF 368E1E[3003]            	MOV	DS,[ss:CurrentPDB] 	; get user process data block;smr;SS Override
 36265                                  	;cmp	word [34h],0
 36266 00006804 833E340000              	CMP	WORD [PDB.JFN_Pointer],0 ; check if original table pointer
 36267 00006809 750D                    	JNZ	short update_info	; yes, go update PDB entries
 36268 0000680B 55                      	PUSH	BP
 36269 0000680C 1E                      	PUSH	DS			; save old table segment
 36270 0000680D 06                      	PUSH	ES			; save new table segment
 36271 0000680E 8E063600                	MOV	ES,[PDB.JFN_Pointer+2]	; get old table segment
 36272 00006812 E80EFC                  	call	_$DEALLOC		; deallocate old table meomory
 36273 00006815 07                      	POP	ES			; restore new table segment
 36274 00006816 1F                      	POP	DS			; restore old table segment
 36275 00006817 5D                      	POP	BP
 36276                                  
 36277                                  update_info:
 36278 00006818 F7C50200                	test	BP,2			; psp?
 36279 0000681C 7408                    	JZ	short non_psp 		; no
 36280                                  	;mov	word [34h],18h ; 24
 36281 0000681E C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE ; restore
 36282 00006824 EB06                    	JMP	short final
 36283                                  non_psp:
 36284                                  	;mov	word [34h],0
 36285 00006826 C70634000000            	MOV	WORD [PDB.JFN_Pointer],0 ; new table pointer offset always 0
 36286                                  final:
 36287                                  	;mov	[36h],es	
 36288 0000682C 8C063600                	MOV	[PDB.JFN_Pointer+2],ES	; update table pointer segment
 36289                                  	;pop	word [32h]
 36290 00006830 8F063200                	POP	word [PDB.JFN_Length]	; restore new number of handles
 36291                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36292                                  	;jmp	SYS_RET_OK
 36293                                  ok_done_j:
 36294 00006834 EBB2                    	jmp	short ok_done
 36295                                  
 36296                                  no_memory:
 36297 00006836 5B                      	POP	BX			; clean stack
 36298                                  	;mov	al,8
 36299 00006837 B008                    	MOV	AL,error_not_enough_memory
 36300                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36301                                  	;jmp	SYS_RET_ERR
 36302                                  CommitErrorj2:
 36303 00006839 EBAA                    	jmp	short CommitErrorj
 36304                                  
 36305                                  invalid_func:
 36306                                  	;mov	al,1
 36307 0000683B B001                    	MOV	AL,error_invalid_function
 36308                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36309                                  	;jmp	SYS_RET_ERR
 36310                                  CommitErrorj3:
 36311                                  	;jmp	short CommitErrorj2
 36312                                  	; 17/12/2022
 36313 0000683D EBA6                    	jmp	short CommitErrorj
 36314                                  
 36315                                  ; 20/05/2019 - Retro DOS v4.0
 36316                                  ; DOSCODE:A83Ah (MSDOS 6.21, MSDOS.SYS)
 36317                                  
 36318                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36319                                  ; DOSCODE:A7DAh (MSDOS 5.0 MSDOS.SYS)
 36320                                  
 36321                                  ;	BREAK <$READ - Read from a file handle>
 36322                                  ;----------------------------------------------------------------------------
 36323                                  ;
 36324                                  ;**	$Read - Read from a File Handle
 36325                                  ;
 36326                                  ;   Assembler usage:
 36327                                  ;
 36328                                  ;	LDS	DX, buf
 36329                                  ;	MOV	CX, count
 36330                                  ;	MOV	BX, handle
 36331                                  ;	MOV	AH, Read
 36332                                  ;	INT	int_command
 36333                                  ;	  AX has number of bytes read
 36334                                  ;
 36335                                  ;	ENTRY	(bx) = file handle
 36336                                  ;		(cx) = byte count
 36337                                  ;		(ds:dx) = buffer address
 36338                                  ;	EXIT	Through system call return so that to user:
 36339                                  ;		  'C' clear if OK
 36340                                  ;		    (ax) = bytes read
 36341                                  ;		  'C' set if error
 36342                                  ;		    (ax) = error code
 36343                                  ;
 36344                                  ;----------------------------------------------------------------------------
 36345                                  
 36346                                  _$READ:
 36347 0000683F BE[FB32]                	MOV	SI,DOS_READ
 36348                                  ReadDo:
 36349 00006842 E831FE                  	call	pJFNFromHandle
 36350 00006845 7208                    	JC	short ReadError
 36351                                  
 36352 00006847 268A05                  	MOV	AL,[ES:DI]
 36353 0000684A E83E01                  	call	CheckOwner		; get the handle
 36354 0000684D 7303                    	JNC	short ReadSetup		; no errors do the operation
 36355                                  
 36356                                  ;	Have an error. 'C' set
 36357                                  
 36358                                  ReadError:
 36359                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36360                                  	;;jmp	SYS_RET_ERR		; go to error traps
 36361                                  	;jmp	short CommitErrorj3
 36362                                  	; 17/12/2022
 36363 0000684F E9EE9D                  	jmp	SYS_RET_ERR
 36364                                  
 36365                                  ReadSetup:
 36366 00006852 36893E[9E05]            	MOV	[ss:THISSFT],DI		; save offset of pointer;smr;SS Override
 36367 00006857 368C06[A005]            	MOV	[ss:THISSFT+2],ES	; save segment value	;smr;SS Override
 36368                                  	; 20/05/2019 - Retro DOS v4.0
 36369                                  	; MSDOS 6.0 
 36370                                  ;; Extended Open
 36371                                  	;test	byte [es:di+3],20h
 36372 0000685C 26F6450320              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(INT_24_ERROR>>8)
 36373                                  						 ;AN000;;EO. need i24
 36374 00006861 7406                    	JZ	short needi24 		     	 ;AN000;;EO. yes
 36375 00006863 36800E[F605]02          	OR	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
 36376                                  					;AN000;;EO. set it off;smr;SS Override
 36377                                  needi24:				;AN000;
 36378                                  ;; Extended Open
 36379 00006869 36FF36[2C03]            	push	word [SS:DMAADD]
 36380 0000686E 36FF36[2E03]            	push	word [SS:DMAADD+2]	;smr;SS Override
 36381                                  
 36382                                  ;;;;;	BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 36383                                  
 36384                                  	; 26/07/2019
 36385                                  
 36386                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36387                                  	;
 36388                                  	; (It is not necessary to call 'Align_Buffer' proc here/below because
 36389                                  	; there is not another caller; it is better to put the code in this proc
 36390                                   	; here instead of calling it as a subroutine; but I have modified code
 36391                                  	; here for MSDOS 5.0 MSDOS.SYS address compatibility)
 36392                                  
 36393                                  	; MSDOS 6.0
 36394 00006873 E81300                  	CALL	Align_Buffer		;AN000;MS. align user's buffer
 36395                                  	
 36396                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36397                                  	; MSDOS 3.3
 36398                                  	;MOV	BX,DX			; copy offset
 36399                                  	;push	cx			; don't stomp on count
 36400                                  	;MOV	CL,4			; bits to shift bytes->para
 36401                                  	;SHR	BX,CL			; get number of paragraphs
 36402                                  	;pop	cx			; get count back
 36403                                  	;MOV	AX,DS			; get original segment
 36404                                  	;ADD	AX,BX			; get new segment
 36405                                  	;MOV	DS,AX			; in seg register
 36406                                  	;AND	DX,0Fh			; normalize offset
 36407                                  	;MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 36408                                  	;MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 36409                                  						;smr;SS Override
 36410                                  ;;;;;	END BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 36411                                  	
 36412 00006876 16                      	push	ss			; go for DOS addressability
 36413 00006877 1F                      	pop	ds
 36414                                  
 36415 00006878 FFD6                    	CALL	SI ; DOS_READ		; indirect call to operation
 36416                                  
 36417 0000687A 8F06[2E03]              	pop	word [DMAADD+2]
 36418 0000687E 8F06[2C03]              	pop	word [DMAADD]
 36419                                  	;JNC	short READ_OK		;AN002;
 36420                                  	;JMP	short ReadError		;AN002; if error, say bye bye
 36421                                  	; 17/12/2022
 36422 00006882 72CB                    	jc	short ReadError
 36423                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36424                                  	;jnc	short READ_OK		;AN002;
 36425                                  	;jmp	short ReadError
 36426                                  
 36427                                  READ_OK:
 36428 00006884 89C8                    	MOV	AX,CX			; get correct return in correct reg
 36429                                  Read_Okj:
 36430                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36431                                  	;;jmp	SYS_RET_OK		; successful return
 36432                                  	;jmp	short ok_done_j
 36433                                  	; 17/12/2022
 36434 00006886 E9AE9D                  	jmp	SYS_RET_OK
 36435                                  
 36436                                  ; 13/07/2018 - Retro DOS v3.0
 36437                                  
 36438                                  ;----------------------------------------------------------------------------
 36439                                  
 36440                                  ;   Input: DS:DX points to user's buffer addr
 36441                                  ;   Function: rearrange segment and offset for READ/WRITE buffer
 36442                                  ;   Output: [DMAADD] set
 36443                                  
 36444                                  ; 20/05/2019 - Retro DOS v4.0
 36445                                  ; 26/07/2019
 36446                                  ;	; MSDOS 6.0
 36447                                  ;Align_Buffer:
 36448                                  ;	MOV	BX,DX			; copy offset
 36449                                  ;	push	cx			; don't stomp on count
 36450                                  ;	MOV	CL,4			; bits to shift bytes->para
 36451                                  ;	SHR	BX,CL			; get number of paragraphs
 36452                                  ;	pop	cx			; get count back
 36453                                  ;	MOV	AX,DS			; get original segment
 36454                                  ;	ADD	AX,BX			; get new segment
 36455                                  ;	MOV	DS,AX			; in seg register
 36456                                  ;	AND	DX,0Fh			; normalize offset
 36457                                  ;	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 36458                                  ;	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 36459                                  ;						;smr;SS Override
 36460                                  ;	retn
 36461                                  
 36462                                  ; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36463                                  Align_Buffer:
 36464 00006889 89D3                    	MOV	BX,DX			; copy offset
 36465 0000688B 51                      	push	cx			; don't stomp on count
 36466 0000688C B104                    	MOV	CL,4			; bits to shift bytes->para
 36467 0000688E D3EB                    	SHR	BX,CL			; get number of paragraphs
 36468 00006890 59                      	pop	cx			; get count back
 36469 00006891 8CD8                    	MOV	AX,DS			; get original segment
 36470 00006893 01D8                    	ADD	AX,BX			; get new segment
 36471 00006895 8ED8                    	MOV	DS,AX			; in seg register
 36472 00006897 83E20F                  	AND	DX,0Fh			; normalize offset
 36473 0000689A 368916[2C03]            	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 36474 0000689F 368C1E[2E03]            	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 36475                                  						;smr;SS Override
 36476 000068A4 C3                      	retn
 36477                                  
 36478                                  ; 20/05/2019 - Retro DOS v4.0
 36479                                  ; DOSCODE:A8A0h (MSDOS 6.21, MSDOS.SYS)
 36480                                  
 36481                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36482                                  ; DOSCODE:A840h (MSDOS 5.0 MSDOS.SYS)
 36483                                  
 36484                                  ;BREAK <$WRITE - write to a file handle>
 36485                                  ;----------------------------------------------------------------------------
 36486                                  ;
 36487                                  ;   Assembler usage:
 36488                                  ;	    LDS     DX, buf
 36489                                  ;	    MOV     CX, count
 36490                                  ;	    MOV     BX, handle
 36491                                  ;	    MOV     AH, Write
 36492                                  ;	    INT     int_command
 36493                                  ;	  AX has number of bytes written
 36494                                  ;   Errors:
 36495                                  ;	    AX = write_invalid_handle
 36496                                  ;	       = write_access_denied
 36497                                  ;
 36498                                  ;   Returns in register AX
 36499                                  ;
 36500                                  ;----------------------------------------------------------------------------
 36501                                  
 36502                                  _$WRITE:
 36503 000068A5 BE[2435]                	MOV	SI,DOS_WRITE
 36504 000068A8 EB98                    	JMP	short ReadDo
 36505                                  
 36506                                  ;BREAK <$LSEEK - move r/w pointer>
 36507                                  ;----------------------------------------------------------------------------
 36508                                  ;
 36509                                  ;   Assembler usage:
 36510                                  ;	    MOV     DX, offsetlow
 36511                                  ;	    MOV     CX, offsethigh
 36512                                  ;	    MOV     BX, handle
 36513                                  ;	    MOV     AL, method
 36514                                  ;	    MOV     AH, LSeek
 36515                                  ;	    INT     int_command
 36516                                  ;	  DX:AX has the new location of the pointer
 36517                                  ;   Error returns:
 36518                                  ;	    AX = error_invalid_handle
 36519                                  ;	       = error_invalid_function
 36520                                  ;   Returns in registers DX:AX
 36521                                  ;
 36522                                  ;----------------------------------------------------------------------------
 36523                                  
 36524                                  ; 21/05/2019 - Retro DOS v4.0
 36525                                  ; DOSCODE:A8A5h (MSDOS 6.21, MSDOS.SYS)
 36526                                  
 36527                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36528                                  ; DOSCODE:A845h (MSDOS 5.0 MSDOS.SYS)
 36529                                  
 36530                                  _$LSEEK:
 36531 000068AA E8DE00                  	call	CheckOwner		; get system file entry
 36532                                  
 36533                                  	; 17/12/2022
 36534                                  ;LSeekError:
 36535                                  	;JNC	short CHKOWN_OK		;AN002;
 36536                                  	;JMP	short ReadError		;AN002; error return
 36537                                  	; 17/12/2022
 36538                                  	; 02/06/2019
 36539 000068AD 72A0                    	jc	short ReadError
 36540                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36541                                  	;JNC	short CHKOWN_OK		;AN002;
 36542                                  	;JMP	short ReadError		;AN002; error return
 36543                                  
 36544                                  CHKOWN_OK:
 36545                                  					;AN002;
 36546 000068AF 3C02                    	CMP	AL,2			; is the seek value correct?
 36547 000068B1 760A                    	JBE	short LSeekDisp		; yes, go dispatch
 36548                                  	;mov	byte [ss:EXTERR_LOCUS],1 
 36549 000068B3 36C606[2303]01          	MOV	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 36550                                  					;smr;SS Override
 36551                                  	;mov	al,1
 36552 000068B9 B001                    	mov	al,error_invalid_function ; invalid method
 36553                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36554                                  LSeekError2:
 36555 000068BB EB92                    	jmp	short ReadError
 36556                                  
 36557                                  LSeekDisp:
 36558 000068BD 3C01                    	CMP	AL,1			; best way to dispatch; check middle
 36559 000068BF 720A                    	JB	short LSeekStore	; just store CX:DX
 36560 000068C1 771B                    	JA	short LSeekEOF		; seek from end of file
 36561                                  	;add	dx,[es:di+21]
 36562 000068C3 26035515                	ADD	DX,[ES:DI+SF_ENTRY.sf_position]
 36563                                  	;adc	cx,[es:di+23]
 36564 000068C7 26134D17                	ADC	CX,[ES:DI+SF_ENTRY.sf_position+2]
 36565                                  LSeekStore:
 36566 000068CB 89C8                    	MOV	AX,CX			; AX:DX
 36567 000068CD 92                      	XCHG	AX,DX			; DX:AX is the correct value
 36568                                  LSeekSetpos:
 36569                                  	;mov	[es:di+21],ax
 36570 000068CE 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 36571                                  	;mov	[es:di+23],dx
 36572 000068D2 26895517                	MOV	[ES:DI+SF_ENTRY.sf_position+2],DX
 36573 000068D6 E8A89B                  	call	Get_User_Stack
 36574                                  	;mov	[si+6],dx
 36575 000068D9 895406                  	MOV	[SI+user_env.user_DX],DX ; return DX:AX
 36576                                  	;jmp	SYS_RET_OK		; successful return
 36577                                  	; 25/06/2019
 36578                                  	;jmp	SYS_RET_OK_clc
 36579                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36580                                  	;jmp	SYS_RET_OK_clc
 36581                                  LSeekOk:
 36582 000068DC EBA8                    	jmp     short Read_Okj
 36583                                  
 36584                                  LSeekEOF:
 36585                                  	;;test	word [es:di+5],8000h
 36586                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 36587                                  	; 21/05/2019 - Retro DOS v4.0
 36588 000068DE 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 36589 000068E3 750A                    	JNZ	short Check_LSeek_Mode	; Is Net
 36590                                  LOCAL_LSeek:
 36591                                  	;add	dx,[es:di+17]
 36592 000068E5 26035511                	ADD	DX,[ES:DI+SF_ENTRY.sf_size]
 36593                                  	;adc	cx,[es:di+19]
 36594 000068E9 26134D13                	ADC	CX,[ES:DI+SF_ENTRY.sf_size+2]
 36595 000068ED EBDC                    	JMP	short LSeekStore	; go and set the position
 36596                                  
 36597                                  Check_LSeek_Mode:
 36598                                  	;;test	word [es:di+2],8000h
 36599                                  	;test	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 36600                                  	; 21/05/2019
 36601 000068EF 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 36602 000068F4 75EF                    	JNZ	short LOCAL_LSeek	; FCB treated like local file
 36603                                  	;mov	ax,[es:di+2]
 36604 000068F6 268B4502                	MOV	AX,[ES:DI+SF_ENTRY.sf_mode]
 36605                                  	;and	ax, 0F0h
 36606 000068FA 25F000                  	AND	AX,SHARING_MASK
 36607                                  	;cmp	ax,40h
 36608 000068FD 83F840                  	CMP	AX,SHARING_DENY_NONE
 36609 00006900 7405                    	JZ	short NET_LSEEK		; LSEEK exported in this mode
 36610                                  	;cmp	ax,30h
 36611 00006902 83F830                  	CMP	AX,SHARING_DENY_READ
 36612 00006905 75DE                    	JNZ	short LOCAL_LSeek	; Treated like local Lseek
 36613                                  NET_LSEEK:
 36614                                  ;	JMP	short LOCAL_LSeek
 36615                                  ; REMOVE ABOVE INSTRUCTION TO ENABLE DCR 142
 36616                                  	;CallInstall Net_Lseek,MultNET,33
 36617                                  	;JNC	short LSeekSetPos
 36618                                  
 36619 00006907 B82111                  	mov     ax,1121h
 36620 0000690A CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
 36621                                  			; CX:DX = offset (in bytes) from end
 36622                                  			; ES:DI -> SFT, SFT DPB field -> DPB of drive with file
 36623                                  			; SS = DOS CS
 36624                                  			; Return: CF set on error
 36625                                  			; CF clear if successful, DX:AX = new file position
 36626 0000690C 73C0                    	jnb     short LSeekSetpos
 36627                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36628                                  	;jmp	SYS_RET_ERR
 36629                                  ;LSeekError3:
 36630                                  	; 17/12/2022
 36631                                  LSeekError:
 36632                                  	;jmp	short LSeekError2
 36633                                  DupErr:	; 17/12/2022
 36634 0000690E E92F9D                  	jmp	SYS_RET_ERR
 36635                                  
 36636                                  ;BREAK <FileTimes - modify write times on a handle>
 36637                                  ;----------------------------------------------------------------------------
 36638                                  ;
 36639                                  ;   Assembler usage:
 36640                                  ;	    MOV AH, FileTimes (57H)
 36641                                  ;	    MOV AL, func
 36642                                  ;	    MOV BX, handle
 36643                                  ;	; if AL = 1 then then next two are mandatory
 36644                                  ;	    MOV CX, time
 36645                                  ;	    MOV DX, date
 36646                                  ;	    INT 21h
 36647                                  ;	; if AL = 0 then CX/DX has the last write time/date
 36648                                  ;	; for the handle.
 36649                                  ;
 36650                                  ;	AL=02		 get extended attributes
 36651                                  ;	   BX=handle
 36652                                  ;	   CX=size of buffer (0, return max size )
 36653                                  ;	   DS:SI query list (si=-1, selects all EA)
 36654                                  ;	   ES:DI buffer to hold EA list
 36655                                  ;
 36656                                  ;	AL=03		 get EA name list
 36657                                  ;	   BX=handle
 36658                                  ;	   CX=size of buffer (0, return max size )
 36659                                  ;	   ES:DI buffer to hold name list
 36660                                  ;
 36661                                  ;	AL=04		 set extended attributes
 36662                                  ;	   BX=handle
 36663                                  ;	   ES:DI buffer of EA list
 36664                                  ;
 36665                                  ;
 36666                                  ;   Error returns:
 36667                                  ;	    AX = error_invalid_function
 36668                                  ;	       = error_invalid_handle
 36669                                  ;
 36670                                  ;----------------------------------------------------------------------------
 36671                                  
 36672                                  ; 21/05/2019 - Retro DOS v4.0
 36673                                  ; DOSCODE:A90Dh (MSDOS 6.21, MSDOS.SYS)
 36674                                  
 36675                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36676                                  ; DOSCODE:A8ADh (MSDOS 5.0 MSDOS.SYS)
 36677                                  
 36678                                  _$FILE_TIMES:
 36679                                  	; 13/07/2018 - Retro DOS v3.0
 36680                                  
 36681                                  	; MSDOS 3.3
 36682                                  	;cmp	al,2			; correct subfunction ?
 36683                                  	;jb	short ft1
 36684                                  
 36685                                  	;;mov	byte [ss:EXTERR_LOCUS], 1
 36686                                  	;mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 36687                                  						;SS Overr
 36688                                  	;;mov	al,1
 36689                                  	;mov	al,error_invalid_function ; give bad return
 36690                                  	;jmp	SYS_RET_ERR
 36691                                  
 36692                                  	; MSDOS 6.0
 36693 00006911 3C02                    	cmp	al,2			; correct subfunction ?
 36694 00006913 7340                    	jae	short inval_func
 36695                                  ;ft1:
 36696 00006915 E87300                  	call	CheckOwner		; get sft
 36697                                  	; 17/12/2022
 36698 00006918 72F4                    	jc	short LSeekError	; bad handle
 36699                                  
 36700 0000691A 08C0                    	or	al,al			; get time/date ?
 36701 0000691C 7515                    	jnz	short ft_set_time
 36702                                  
 36703                                  ;------ here we get the time & date from the sft for the user
 36704                                  
 36705 0000691E FA                      	cli				; is this cli/sti reqd ? BUGBUG
 36706                                  	;mov	cx,[es:di+13]
 36707 0000691F 268B4D0D                	mov	cx,[es:di+SF_ENTRY.sf_time] ; get the time
 36708                                  	;mov	dx,[es:di+15]
 36709 00006923 268B550F                	mov	dx,[es:di+SF_ENTRY.sf_date] ;  & date
 36710 00006927 FB                      	sti
 36711 00006928 E8569B                  	call	Get_User_Stack
 36712                                  	;mov	[si+4],cx
 36713 0000692B 894C04                  	mov	[si+user_env.user_CX],cx
 36714                                  	;mov	[si+6],dx
 36715 0000692E 895406                  	mov	[si+user_env.user_DX],dx
 36716 00006931 EB1F                    	jmp	short ok_ret
 36717                                  
 36718                                  ;------ here we set the time in sft
 36719                                  
 36720                                  ft_set_time:
 36721 00006933 E8DBA9                  	call    ECritSFT
 36722                                  	;mov	[es:di+13],cx
 36723 00006936 26894D0D                	mov	[es:di+SF_ENTRY.sf_time],cx ; drop in new time
 36724                                  	;mov	[es:di+15],dx
 36725 0000693A 2689550F                	mov	[es:di+SF_ENTRY.sf_date],dx ;  and date	
 36726                                  
 36727 0000693E 31C0                    	xor	ax, ax
 36728 00006940 36FF1E[C800]            	call	far [ss:JShare+(14*4)] ; 14 = ShSU	; SS Override
 36729                                  
 36730                                  ;------ set the flags in SFT entry
 36731                                  	;and	word [es:di+5],0FFBFh
 36732                                  	; 18/12/2022
 36733                                  	;and	byte [es:di+5],0BFh
 36734 00006945 26806505BF              	and	byte [es:di+SF_ENTRY.sf_flags],~devid_file_clean
 36735                                  	;and	word [es:di+SF_ENTRY.sf_flags],~devid_file_clean 
 36736                                  							; mark file as dirty
 36737                                  	;or	word [es:di+5],4000h
 36738                                  	; 17/12/2022
 36739                                  	;or	byte [es:di+6],40h
 36740 0000694A 26804D0640              	or	byte [es:di+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8)
 36741                                  	;or	word [es:di+SF_ENTRY.sf_flags],sf_close_nodate
 36742                                  							; ask close not to
 36743                                  							;   bother about date
 36744                                  							;   and time
 36745 0000694F E8DAA9                  	call	LCritSFT
 36746                                  ok_ret:
 36747                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36748                                  	; 17/12/2022
 36749 00006952 E9E29C                  	jmp	SYS_RET_OK
 36750                                  	;jmp	short LSeekOk
 36751                                  
 36752                                  inval_func:
 36753                                  	;mov	byte [ss:EXTERR_LOCUS],1
 36754 00006955 36C606[2303]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 36755                                  						;SS Overr
 36756                                  	;mov	al,1
 36757 0000695B B001                    	mov	al,error_invalid_function ; give bad return
 36758                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36759                                  ft_error:
 36760                                  	;;jmp	SYS_RET_ERR
 36761                                  	;jmp	short LSeekError3
 36762                                  	; 17/12/2022
 36763 0000695D EBAF                    	jmp	short LSeekError
 36764                                  
 36765                                  ; 21/05/2019 - Retro DOS v4.0
 36766                                  ; DOSCODE:A95Bh (MSDOS 6.21, MSDOS.SYS)
 36767                                  
 36768                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36769                                  ; DOSCODE:A8FBh (MSDOS 5.0 MSDOS.SYS)
 36770                                  
 36771                                  ;BREAK <$DUP - duplicate a jfn>
 36772                                  ;----------------------------------------------------------------------------
 36773                                  ;
 36774                                  ;   Assembler usage:
 36775                                  ;	    MOV     BX, fh
 36776                                  ;	    MOV     AH, Dup
 36777                                  ;	    INT     int_command
 36778                                  ;	  AX has the returned handle
 36779                                  ;   Errors:
 36780                                  ;	    AX = dup_invalid_handle
 36781                                  ;	       = dup_too_many_open_files
 36782                                  ;
 36783                                  ;----------------------------------------------------------------------------
 36784                                  
 36785                                  _$DUP:
 36786 0000695F 89D8                    	MOV	AX,BX			; save away old handle in AX
 36787 00006961 E86FFD                  	call	JFNFree 		; free handle? into ES:DI, new in BX
 36788                                  DupErrorCheck:
 36789 00006964 72A8                    	JC	short DupErr		; nope, bye
 36790 00006966 06                      	push	es
 36791 00006967 57                      	push	di			; save away SFT
 36792 00006968 5E                      	pop	si			; into convenient place DS:SI
 36793 00006969 1F                      	pop	ds
 36794 0000696A 93                      	XCHG	AX,BX			; get back old handle
 36795 0000696B E81D00                  	call	CheckOwner		; get sft in ES:DI
 36796 0000696E 729E                    	JC	short DupErr		; errors go home
 36797 00006970 E8F2C0                  	call	DOS_Dup_Direct
 36798 00006973 E800FD                  	call	pJFNFromHandle		; get pointer
 36799 00006976 268A1D                  	MOV	BL,[ES:DI]		; get SFT number
 36800 00006979 881C                    	MOV	[SI],BL			; stuff in new SFT
 36801                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36802                                  	;jmp	SYS_RET_OK		; and go home
 36803 0000697B EBD5                    	jmp	short ok_ret
 36804                                  
 36805                                  	; 17/12/2022
 36806                                  ;DupErr:
 36807                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36808                                  	;;jmp	SYS_RET_ERR
 36809                                  	;jmp	short ft_error
 36810                                  
 36811                                  ;BREAK <$DUP2 - force a dup on a particular jfn>
 36812                                  ;----------------------------------------------------------------------------
 36813                                  ;
 36814                                  ;   Assembler usage:
 36815                                  ;	    MOV     BX, fh
 36816                                  ;	    MOV     CX, newfh
 36817                                  ;	    MOV     AH, Dup2
 36818                                  ;	    INT     int_command
 36819                                  ;   Error returns:
 36820                                  ;	    AX = error_invalid_handle
 36821                                  ;
 36822                                  ;----------------------------------------------------------------------------
 36823                                  
 36824                                  _$DUP2:
 36825 0000697D 53                      	push	bx
 36826 0000697E 51                      	push	cx			; save source
 36827 0000697F 89CB                    	MOV	BX,CX			; get one to close
 36828 00006981 E8AAFD                  	call	_$CLOSE			; close destination handle
 36829 00006984 5B                      	pop	bx
 36830 00006985 58                      	pop	ax			; old in AX, new in BX
 36831 00006986 E8EDFC                  	call	pJFNFromHandle		; get pointer
 36832 00006989 EBD9                    	JMP	short DupErrorCheck	; check error and do dup
 36833                                  
 36834                                  ;Break	<CheckOwner - verify ownership of handles from server>
 36835                                  ;----------------------------------------------------------------------------
 36836                                  ;   CheckOwner - Due to the ability of the server to close file handles for a
 36837                                  ;   process without the process knowing it (delete/rename of open files, for
 36838                                  ;   example), it is possible for the redirector to issue a call to a handle
 36839                                  ;   that it soes not rightfully own. We check here to make sure that the
 36840                                  ;   issuing process is the owner of the SFT. At the same time, we do a
 36841                                  ;   SFFromHandle to really make sure that the SFT is good.
 36842                                  ;
 36843                                  ;	ENTRY	BX has the handle
 36844                                  ;		User_ID is the current user
 36845                                  ;	EXIT	Carry Clear => ES:DI points to SFT
 36846                                  ;		Carry Set => AX has error code
 36847                                  ;	USES	none
 36848                                  ;----------------------------------------------------------------------------
 36849                                  
 36850                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36851                                  	; 21/05/2019 - Retro DOS v4.0
 36852                                  CheckOwner:
 36853                                  	; 13/07/2018 - Retro DOS v3.0
 36854                                  
 36855 0000698B E805FD                  	call	SFFromHandle
 36856 0000698E 721B                    	jc	short co_ret_label	; retc
 36857                                  
 36858 00006990 50                      	push	ax
 36859                                  
 36860                                  	; MSDOS 6.0
 36861                                  
 36862                                  ;SR; WIN386 patch - Do not check for USER_ID for using handles since these 
 36863                                  ;SR; are shared across multiple VMs in win386.
 36864                                  
 36865 00006991 36F606[3010]01          	test	byte [ss:IsWin386],1 ; 02/06/2019
 36866 00006997 7404                    	jz	short no_win386		;win386 is not present
 36867 00006999 31C0                    	xor	ax,ax			;set the zero flag
 36868 0000699B EB08                    	jmp	short _skip_win386	
 36869                                  
 36870                                  no_win386:
 36871 0000699D 36A1[3E03]              	mov	ax,[SS:USER_ID]		;smr;SS Override
 36872                                  	;cmp	ax,[es:di+47]
 36873 000069A1 263B452F                	cmp	ax,[es:di+SF_ENTRY.sf_UID]
 36874                                  
 36875                                  _skip_win386:
 36876 000069A5 58                      	pop	ax
 36877                                  	
 36878                                  	; 17/12/2022
 36879 000069A6 7403                    	jz	short co_ret_label
 36880                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36881                                  	;jnz	short CheckOwner_err
 36882                                  	;retn
 36883                                  	
 36884                                  CheckOwner_err:
 36885                                  	;mov	al,6
 36886 000069A8 B006                    	mov	al,error_invalid_handle
 36887 000069AA F9                      	stc
 36888                                  
 36889                                  co_ret_label:
 36890 000069AB C3                      	retn
 36891                                  
 36892                                  ;============================================================================
 36893                                  ; MACRO.ASM, MSDOS 6.0, 1991
 36894                                  ;============================================================================
 36895                                  ; Retro	DOS v3.0 - 11/07/2018
 36896                                  ; 21/05/2019 - Retro DOS v4.0
 36897                                  
 36898                                  ;	TITLE	MACRO - Pathname and macro related internal routines
 36899                                  ;	NAME	MACRO
 36900                                  
 36901                                  ;	Microsoft Confidential
 36902                                  ;	Copyright (C) Microsoft Corporation 1991
 36903                                  ;	All Rights Reserved.
 36904                                  
 36905                                  ;**	MACRO.ASM
 36906                                  ;
 36907                                  ;	$AssignOper
 36908                                  ;	FIND_DPB
 36909                                  ;	InitCDS
 36910                                  ;	$UserOper
 36911                                  ;	GetVisDrv
 36912                                  ;	GetThisDrv
 36913                                  ;	GetCDSFromDrv
 36914                                  ;
 36915                                  ;   Revision history:
 36916                                  ;
 36917                                  ;	Created: MZ 4 April 1983
 36918                                  ;		 MZ 18 April 1983   Make TransFCB handle extended FCBs
 36919                                  ;		 AR 2 June 1983     Define/Delete macro for NET redir.
 36920                                  ;		 MZ 3 Nov 83	    Fix InitCDS to reset length to 2
 36921                                  ;		 MZ 4 Nov 83	    Fix NetAssign to use STRLEN only
 36922                                  ;		 MZ 18 Nov 83	    Rewrite string processing for subtree
 36923                                  ;				    aliasing.
 36924                                  ;
 36925                                  ;   MSDOS performs several types of name translation. First, we maintain for
 36926                                  ;   each valid drive letter the text of the current directory on that drive.
 36927                                  ;   For invalid drive letters, there is no current directory so we pretend to
 36928                                  ;   be at the root. A current directory is either the raw local directory
 36929                                  ;   (consisting of drive:\path) or a local network directory (consisting of
 36930                                  ;   \\machine\path. There is a limit on the point to which a .. is allowed.
 36931                                  ;
 36932                                  ;   Given a path, MSDOS will transform this into a real from-the-root path
 36933                                  ;   without . or .. entries. Any component that is > 8.3 is truncated to
 36934                                  ;   this and all * are expanded into ?'s.
 36935                                  ;
 36936                                  ;   The second part of name translation involves subtree aliasing. A list of
 36937                                  ;   subtree pairs is maintained by the external utility SUBST. The results of
 36938                                  ;   the previous 'canonicalization' are then examined to see if any of the
 36939                                  ;   subtree pairs is a prefix of the user path. If so, then this prefix is
 36940                                  ;   replaced with the other subtree in the pair.
 36941                                  ;
 36942                                  ;   A third part involves mapping this "real" path into a "physical" path.  A
 36943                                  ;   list of drive/subtree pairs are maintained by the external utility JOIN.
 36944                                  ;   The output of the previous translation is examined to see if any of the
 36945                                  ;   subtrees in this list are a prefix of the string. If so, then the prefix
 36946                                  ;   is replaced by the appropriate drive letter. In this manner, we can
 36947                                  ;   'mount' one device under another.
 36948                                  ;
 36949                                  ;   The final form of name translation involves the mapping of a user's
 36950                                  ;   logical drive number into the internal physical drive. This is
 36951                                  ;   accomplished by converting the drive number into letter:CON, performing
 36952                                  ;   the above translation and then converting the character back into a drive
 36953                                  ;   number.
 36954                                  ;
 36955                                  ;   There are two main entry points: TransPath and TransFCB. TransPath will
 36956                                  ;   take a path and form the real text of the pathname with all . and ..
 36957                                  ;   removed. TransFCB will translate an FCB into a path and then invoke
 36958                                  ;   TransPath.
 36959                                  ;
 36960                                  ;	A000	version 4.00  Jan. 1988
 36961                                  
 36962                                  ;Installed = TRUE
 36963                                  
 36964                                  ;	I_need	ThisCDS,DWORD		; pointer to CDS used
 36965                                  ;	I_need	CDSAddr,DWORD		; pointer to CDS table
 36966                                  ;	I_need	CDSCount,BYTE		; number of CDS entries
 36967                                  ;	I_need	CurDrv,BYTE		; current macro assignment (old
 36968                                  ;					; current drive)
 36969                                  ;	I_need	NUMIO,BYTE		; Number of physical drives
 36970                                  ;	I_need	fSharing,BYTE		; TRUE => no redirection allowed
 36971                                  ;	I_need	DummyCDS,80h		; buffer for dummy cds
 36972                                  ;	I_need	DIFFNAM,BYTE		; flag for MyName being set
 36973                                  ;	I_need	MYNAME,16		; machine name
 36974                                  ;	I_need	MYNUM,WORD		; machine number
 36975                                  ;	I_need	DPBHEAD,DWORD		; beginning of DPB chain
 36976                                  ;	I_need	EXTERR_LOCUS,BYTE	; Extended Error Locus
 36977                                  ;	I_need	DrvErr,BYTE		; drive error
 36978                                  
 36979                                  ;BREAK <$AssignOper -- Set up a Macro>
 36980                                  ;----------------------------------------------------------------------------
 36981                                  ; Inputs:
 36982                                  ;	AL = 00 get assign mode 		    (ReturnMode)
 36983                                  ;	AL = 01 set assign mode 		    (SetMode)
 36984                                  ;	AL = 02 get attach list entry		    (GetAsgList)
 36985                                  ;	AL = 03 Define Macro (attch start)
 36986                                  ;	    BL = Macro type
 36987                                  ;	       = 0 alias
 36988                                  ;	       = 1 file/device
 36989                                  ;	       = 2 drive
 36990                                  ;	       = 3 Char device -> network
 36991                                  ;	       = 4 File device -> network
 36992                                  ;	    DS:SI -> ASCIZ source name
 36993                                  ;	    ES:DI -> ASCIZ destination name
 36994                                  ;	AL = 04 Cancel Macro
 36995                                  ;	    DS:SI -> ASCIZ source name
 36996                                  ;	AL = 05 Modified get attach list entry
 36997                                  ;	AL = 06 Get ifsfunc item
 36998                                  ;	AL = 07 set in_use of a drive's CDS
 36999                                  ;	     DL = drive number, 0=default  0=A,,
 37000                                  ;	AL = 08 reset in_use of a drive's CDS
 37001                                  ;	     DL = drive number, 0=A, 1=B,,,
 37002                                  ; Function:
 37003                                  ;	Do macro stuff
 37004                                  ; Returns:
 37005                                  ;	Std Xenix style error return
 37006                                  ;----------------------------------------------------------------------------
 37007                                  
 37008                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37009                                  	; 21/05/2019 - Retro DOS v4.0
 37010                                  _$AssignOper:
 37011                                  	; MSDOS 6.0
 37012 000069AC 3C07                    	CMP	AL,7			      ; set in_use ?		;AN000;
 37013 000069AE 7525                    	JNZ	short chk08		      ; no			;AN000;
 37014                                  srinuse:								;AN000;
 37015 000069B0 50                      	PUSH	AX			      ; save al 		;AN000;
 37016 000069B1 88D0                    	MOV	AL,DL			      ; AL= drive id		;AN000;
 37017 000069B3 E85601                  	CALL	GetCDSFromDrv		      ; ds:si -> cds		;AN000;
 37018 000069B6 58                      	POP	AX			      ; 			;AN000;
 37019 000069B7 7216                    	JC	short baddrv		      ; bad drive		;AN000;
 37020                                  	;cmp	word [si+45h],0
 37021 000069B9 837C4500                	CMP	WORD [SI+curdir.devptr],0     ; dpb ptr =0 ?		;AN000;
 37022 000069BD 7410                    	JZ	short baddrv		      ;     no			;AN000;
 37023 000069BF 3C07                    	CMP	AL,7			      ; set ?			;AN000;
 37024 000069C1 7506                    	JNZ	short resetdrv		      ; no			;AN000;
 37025                                  	;or	word [si+43h],4000h
 37026                                  	; 17/12/2022
 37027                                  	;or	byte [si+44h],40h
 37028 000069C3 804C4440                	or	byte [SI+curdir.flags+1],(curdir_inuse>>8)
 37029                                  	;OR	word [SI+curdir.flags],curdir_inuse ; set in_use	;AN000;
 37030 000069C7 EB19                    	JMP	SHORT okdone		      ; 			;AN000;
 37031                                  resetdrv:
 37032                                  	;and	word [si+43h],0BFFFh									;AN000;
 37033                                  	; 18/12/2022
 37034 000069C9 806444BF                	and	byte [SI+curdir.flags+1],0BFh ; (~curdir_inuse)>>8
 37035                                  	;AND	word [SI+curdir.flags],~curdir_inuse ; reset in_use	;AN000;
 37036 000069CD EB13                    	JMP	SHORT okdone		      ; 			;AN000;
 37037                                  
 37038                                  	; 17/12/2022
 37039                                  baddrv: 								;AN000;
 37040 000069CF B80F00                  	MOV	AX,error_invalid_drive	      ; error			;AN000;
 37041                                  
 37042                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37043                                  	;JMP	SHORT ASS_ERR		      ; 			;AN000;
 37044                                  	; 17/12/2022
 37045                                  	; 21/05/2019
 37046                                  ASS_ERR:
 37047 000069D2 E96B9C                  	jmp	SYS_RET_ERR
 37048                                  
 37049                                  chk08:									;AN000;
 37050 000069D5 3C08                    	CMP	AL,8			      ; reset inuse ?		;AN000;
 37051 000069D7 74D7                    	JZ	short srinuse 		      ; yes			;AN000;
 37052                                  
 37053                                    ;IF	NOT INSTALLED
 37054                                  	;transfer NET_ASSOPER
 37055                                    ;ELSE
 37056                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37057 000069D9 50                      	PUSH	AX
 37058                                  	;mov	ax,111Eh
 37059                                  	;MOV	AX,(MultNET SHL 8) OR 30
 37060 000069DA B81E11                  	mov	ax,(MultNET*256)+30
 37061 000069DD CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
 37062                                  			; SS = DOS CS
 37063                                  			; STACK: WORD function to execute
 37064                                  			; Return: CF set on error, AX = error code
 37065                                  			; STACK unchanged
 37066 000069DF 5B                      	POP	BX			; Don't zap error code in AX
 37067 000069E0 72F0                    	JC	short ASS_ERR
 37068                                  okdone:
 37069 000069E2 E9529C                  	jmp	SYS_RET_OK
 37070                                  
 37071                                  	; 17/12/2022
 37072                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37073                                  ;ASS_ERR:
 37074                                  	;jmp	SYS_RET_ERR
 37075                                  
 37076                                    ;ENDIF
 37077                                  
 37078                                  ;Break <FIND_DPB - Find a DPB from a drive number>
 37079                                  ;----------------------------------------------------------------------------
 37080                                  ;**	FIND_DPB - Find a DPB from a Drive #
 37081                                  ;
 37082                                  ;	ENTRY	AL has drive number A = 0
 37083                                  ;	EXIT	'C' set
 37084                                  ;		    No DPB for this drive number
 37085                                  ;		'C' clear
 37086                                  ;		    DS:SI points to DPB for drive
 37087                                  ;	USES	SI, DS, Flags
 37088                                  ;----------------------------------------------------------------------------
 37089                                  
 37090                                  	; 21/05/2019 - Retro DOS v4.0
 37091                                  FIND_DPB:
 37092 000069E5 36C536[2600]            	LDS	SI,[SS:DPBHEAD]		;smr;SS Override
 37093                                  fdpb5:	
 37094 000069EA 83FEFF                  	CMP	SI,-1
 37095 000069ED 7409                    	JZ	short fdpb10
 37096 000069EF 3A04                    	cmp	al,[si]
 37097                                  	;CMP	AL,[SI+DPB.DRIVE]
 37098 000069F1 7406                    	jz	short ret_label15	; Carry clear (retz)
 37099                                  	;;lds	si,[si+18h] ; MSDOS 3.3
 37100                                  	;lds	si,[si+19h] ; MSDOS 6.0
 37101 000069F3 C57419                  	LDS	SI,[SI+DPB.NEXT_DPB]
 37102 000069F6 EBF2                    	JMP	short fdpb5
 37103                                  fdpb10:	
 37104 000069F8 F9                      	STC
 37105                                  ret_label15:
 37106 000069F9 C3                      	retn
 37107                                  
 37108                                  ;	Break <InitCDS - set up an empty CDS>
 37109                                  ;----------------------------------------------------------------------------
 37110                                  ;**	InitCDS - Setup an Empty CDS
 37111                                  ;
 37112                                  ;	ENTRY	ThisCDS points to CDS
 37113                                  ;		AL has uppercase drive letter
 37114                                  ;	EXIT	ThisCDS is now empty
 37115                                  ;		(ES:DI) = CDS
 37116                                  ;		'C' set if no DPB associated with drive
 37117                                  ;	USES	AH,ES,DI, Flags
 37118                                  ;----------------------------------------------------------------------------
 37119                                  
 37120                                  ; 21/05/2019 - Retro DOS v4.0
 37121                                  ; DOSCODE:A9FDh (MSDOS 6.21, MSDOS.SYS)
 37122                                  
 37123                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37124                                  ; DOSCODE:A99Dh (MSDOS 5.0, MSDOS.SYS)
 37125                                  
 37126                                  InitCDS:
 37127                                  	; 19/08/2018
 37128                                  	; 05/08/2018 - Retro DOS v3.0
 37129                                  	; MSDOS 6.0
 37130 000069FA 50                      	push	ax			; save (AL) for caller
 37131 000069FB 36C43E[A205]            	LES	DI,[SS:THISCDS]		; (es:di) = CDS address
 37132                                  	;mov	word [es:di+67],0
 37133 00006A00 26C745430000            	MOV	word [ES:DI+curdir.flags],0 ; "free" CDS
 37134 00006A06 2C40                    	SUB	AL,"A"-1                ; A = 1
 37135 00006A08 363806[4600]            	CMP	[SS:NUMIO],AL		;smr;SS Override
 37136 00006A0D 7236                    	JC	short icdsx		; Drive does not map a physical drive
 37137 00006A0F 48                      	dec	ax			; (AL) = 0 if A, 1 if B, etc.
 37138 00006A10 50                      	PUSH	AX			; save drive number for later
 37139 00006A11 0441                    	add	al,"A"
 37140 00006A13 B43A                    	MOV	AH,':'
 37141 00006A15 268905                  	mov	[ES:DI],ax
 37142                                  	;MOV	[ES:DI+curdir.text],AX 	; set "x:"
 37143                                  	;mov	ax,"\"
 37144                                  	;mov	[es:di+2],ax
 37145                                  	;MOV	word [ES:DI+curdir.text+2],"\"	; NUL terminate
 37146 00006A18 26C745025C00            	mov	word [ES:DI+curdir.text+2],005Ch ; 19/08/2018
 37147                                  	;or	word [es:di+67],4000h
 37148                                  	;or	byte [es:di+68],40h
 37149 00006A1E 26804D4440              	OR	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
 37150 00006A23 29C0                    	sub	ax,ax
 37151                                  	;MOV	[es:di+73],ax ; 0
 37152 00006A25 26894549                	MOV	[ES:DI+curdir.ID],ax
 37153                                  	;mov	[es:di+75],ax ; 0
 37154 00006A29 2689454B                	MOV	[ES:DI+curdir.ID+2],ax
 37155 00006A2D B002                    	mov	al,2
 37156                                  	;mov	[es:di+79],aX ; 2
 37157 00006A2F 2689454F                	MOV	[ES:DI+curdir.end],ax
 37158 00006A33 58                      	POP	AX			; (al) = drive number
 37159 00006A34 1E                      	push	ds
 37160 00006A35 56                      	push	si
 37161 00006A36 E8ACFF                  	call	FIND_DPB
 37162 00006A39 7208                    	JC	short icds5		; OOOOPPPPPSSSS!!!!
 37163                                  	;mov	[es:di+69],si
 37164 00006A3B 26897545                	MOV	[ES:DI+curdir.devptr],SI
 37165                                  	;mov	[es:di+71],ds
 37166 00006A3F 268C5D47                	MOV	[ES:DI+curdir.devptr+2],DS
 37167                                  icds5:	
 37168 00006A43 5E                      	pop	si
 37169 00006A44 1F                      	pop	ds
 37170                                  icdsx:	
 37171 00006A45 58                      	pop	ax
 37172                                  RET45:
 37173 00006A46 C3                      	retn
 37174                                  
 37175                                  ;Break <$UserOper - get/set current user ID (for net)>
 37176                                  ;----------------------------------------------------------------------------
 37177                                  ;   $UserOper - retrieve or initiate a user id string.	MSDOS will only
 37178                                  ;	maintain this string and do no verifications.
 37179                                  ;
 37180                                  ;   Inputs:	AL has function type (0-get 1-set 2-printer-set 3-printer-get
 37181                                  ;				      4-printer-set-flags,5-printer-get-flags)
 37182                                  ;		DS:DX is user string pointer (calls 1,2)
 37183                                  ;		ES:DI is user buffer (call 3)
 37184                                  ;		BX is assign index (calls 2,3,4,5)
 37185                                  ;		CX is user number (call 1)
 37186                                  ;		DX is flag word (call 4)
 37187                                  ;   Outputs:	If AL = 0 then the current user string is written to DS:DX
 37188                                  ;			and user CX is set to the user number
 37189                                  ;		If AL = 3 then CX bytes have been put at input ES:DI
 37190                                  ;		If AL = 5 then DX is flag word
 37191                                  ;----------------------------------------------------------------------------
 37192                                  
 37193                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37194                                  	; 21/05/2019 - Retro DOS v4.0
 37195                                  _$UserOper:
 37196                                  	; 05/08/2018 - Retro DOS v3.0
 37197                                  	; MSDOS 6.0 (& MSDOS 3.3)
 37198 00006A47 50                      	PUSH	AX
 37199 00006A48 2C01                    	SUB	AL,1			; quick dispatch on 0,1
 37200 00006A4A 58                      	POP	AX
 37201 00006A4B 7211                    	JB	short UserGet 		; return to user the string
 37202 00006A4D 742E                    	JZ	short UserSet 		; set the current user
 37203 00006A4F 3C05                    	CMP	AL,5			; test for 2,3,4 or 5
 37204 00006A51 763D                    	JBE	short UserPrint		; yep
 37205                                  	;mov	byte [ss:EXTERR_LOCUS],1
 37206 00006A53 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ;smr;SS Override 
 37207                                  					; Extended Error Locus
 37208                                  	;error	error_invalid_function	; not 0,1,2,3
 37209                                  	;mov	al,1
 37210 00006A59 B001                    	MOV	AL,error_invalid_function
 37211                                  useroper_error:
 37212                                  	; 17/12/2022
 37213                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37214 00006A5B E9E29B                  	JMP	SYS_RET_ERR
 37215                                  	;jmp	short ASS_ERR
 37216                                  
 37217                                  UserGet:
 37218                                  ; Transfer MYNAME to DS:DX
 37219                                  ; Set Return CX to MYNUM
 37220 00006A5E 1E                      	PUSH	DS			; switch registers
 37221 00006A5F 07                      	POP	ES
 37222 00006A60 89D7                    	MOV	DI,DX			; destination
 37223 00006A62 368B0E[0E00]            	MOV	CX,[SS:MYNUM]		; Get number	;smr;SS Override
 37224 00006A67 E8179A                  	call	Get_User_Stack
 37225                                  	;mov	[si+4],cx
 37226 00006A6A 894C04                  	MOV	[SI+user_env.user_CX],CX ; Set number return
 37227 00006A6D 16                      	push	ss			; point to DOSDATA
 37228 00006A6E 1F                      	pop	ds
 37229 00006A6F BE[0503]                	MOV	SI,MYNAME		; point source to user string
 37230                                  UserMove:
 37231 00006A72 B90F00                  	MOV	CX,15
 37232 00006A75 F3A4                    	REP	MOVSB			; blam.
 37233 00006A77 31C0                    	XOR	AX,AX			; 16th byte is 0
 37234 00006A79 AA                      	STOSB
 37235                                  UserBye:
 37236 00006A7A E9BA9B                  	jmp	SYS_RET_OK		; no errors here
 37237                                  
 37238                                  UserSet:
 37239                                  ; Transfer DS:DX to MYNAME
 37240                                  ; CX to MYNUM
 37241 00006A7D 36890E[0E00]            	MOV	[SS:MYNUM],CX				;smr;SS Override
 37242 00006A82 89D6                    	MOV	SI,DX			; user space has source
 37243 00006A84 16                      	push	ss
 37244 00006A85 07                      	pop	es
 37245 00006A86 BF[0503]                	MOV	DI,MYNAME		; point dest to user string
 37246 00006A89 36FE06[0403]            	INC	byte [SS:DIFFNAM]	; signal change ;smr;SS Override
 37247 00006A8E EBE2                    	JMP	short UserMove
 37248                                  
 37249                                  UserPrint:
 37250                                  
 37251                                    ;IF NOT Installed
 37252                                    ;	transfer PRINTER_GETSET_STRING
 37253                                    ;ELSE
 37254 00006A90 50                      	PUSH	AX
 37255                                  	;mov	ax,111Fh
 37256                                  	;MOV	AX,(MultNET SHL 8) OR 31
 37257 00006A91 B81F11                  	mov	ax,(MultNET<<8)|31
 37258 00006A94 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
 37259                                  			; STACK: WORD function
 37260                                  			; Return: CF set on error, AX = error code
 37261                                  			; STACK unchanged
 37262 00006A96 5A                      	POP	DX			; Clean stack
 37263                                  	;JNC	short OKPA
 37264 00006A97 73E1                    	jnc	short UserBye ; 21/05/2019
 37265                                  	; 17/12/2022
 37266 00006A99 EBC0                    	jmp	short useroper_error
 37267                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37268                                  	;jnb     short OKPA
 37269                                  	;jmp     short useroper_error
 37270                                  
 37271                                  	; 17/12/2022
 37272                                  ;OKPA:
 37273                                  ;	jmp	short UserBye
 37274                                  
 37275                                    ;ENDIF
 37276                                  
 37277                                  
 37278                                  ;Break	<GetVisDrv - return visible drive>
 37279                                  ;----------------------------------------------------------------------------
 37280                                  ;   GetVisDrv - correctly map non-spliced inuse drives
 37281                                  ;
 37282                                  ;   Inputs:	AL has drive identifier (0=default)
 37283                                  ;   Outputs:	Carry Set - invalid drive/macro
 37284                                  ;		Carry Clear - AL has physical drive (0=A)
 37285                                  ;		    ThisCDS points to CDS
 37286                                  ;   Registers modified: AL
 37287                                  ;----------------------------------------------------------------------------
 37288                                  
 37289                                  	; 21/05/2019 - Retro DOS v4.0
 37290                                  	; DOSCODE:AA9Fh (MSDOS 6.21, MSDOS.SYS)
 37291                                  
 37292                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37293                                  	; DOSCODE:AA3Fh (MSDOS 5.0, MSDOS.SYS)	
 37294                                  GetVisDrv:
 37295                                  	; 05/08/2018 - Retro DOS v3.0
 37296                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6839h
 37297 00006A9B E81900                  	CALL	GETTHISDRV		; get inuse drive
 37298 00006A9E 72A6                    	jc	short RET45
 37299 00006AA0 1E                      	push	ds
 37300 00006AA1 56                      	push	si
 37301 00006AA2 36C536[A205]            	LDS	SI,[SS:THISCDS]		;smr;SS Override
 37302                                  	;test	word [si+67],2000h
 37303                                  	; 17/12/2022
 37304                                  	;test	byte [si+68],20h
 37305 00006AA7 F6444420                	test	byte [SI+curdir.flags+1],(curdir_splice>>8)
 37306                                  	;TEST	word [SI+curdir.flags],curdir_splice
 37307 00006AAB 5E                      	pop	si
 37308 00006AAC 1F                      	pop	ds
 37309 00006AAD 7497                    	jz	short RET45		; if not spliced, return OK
 37310                                  	; MSDOS 6.0
 37311                                  	;mov	byte [ss:DrvErr],0Fh
 37312 00006AAF 36C606[1006]0F          	MOV	byte [SS:DrvErr],error_invalid_drive ;IFS. ;AN000;smr;SS Override
 37313 00006AB5 F9                      	STC				; signal error
 37314 00006AB6 C3                      	retn
 37315                                  
 37316                                  ;Break <Getthisdrv - map a drive designator (0=def, 1=A...)>
 37317                                  ;----------------------------------------------------------------------------
 37318                                  ;   GetThisDrv - look through a set of macros and return the current drive and
 37319                                  ;	macro pointer
 37320                                  ;
 37321                                  ;   Inputs:	AL has drive identifier (1=A, 0=default)
 37322                                  ;   Outputs:
 37323                                  ;		Carry Set - invalid drive/macro
 37324                                  ;		Carry Clear - AL has physical drive (0=A)
 37325                                  ;		   ThisCDS points to macro
 37326                                  ;   Registers modified: AL
 37327                                  ;----------------------------------------------------------------------------
 37328                                  
 37329                                  	; 21/05/2019 - Retro DOS v4.0
 37330                                  	; DOSCODE:AABCh (MSDOS 6.21, MSDOS.SYS)
 37331                                  
 37332                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37333                                  	; DOSCODE:AA5Ch (MSDOS 5.0, MSDOS.SYS)	
 37334                                  GETTHISDRV:
 37335                                  	; 05/08/2018
 37336                                  	; 12/07/2018 - Retro DOS v3.0
 37337                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6850h
 37338                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37339 00006AB7 08C0                    	OR	AL,AL			; are we using default drive?
 37340 00006AB9 7505                    	JNZ	SHORT GTD10		; no, go get the CDS pointers
 37341 00006ABB 36A0[3603]              	MOV	AL,[SS:CURDRV]		; get the current drive
 37342                                  	;INC	ax			; Counteract next instruction
 37343                                  	; 04/09/2018
 37344                                  	;inc	al
 37345                                  	; 07/12/2022
 37346 00006ABF 40                      	inc	ax
 37347                                  GTD10:	
 37348                                  	;DEC	AX
 37349                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37350 00006AC0 48                      	dec	ax			; 0 = A
 37351                                  	;dec	al
 37352 00006AC1 1E                      	PUSH	DS			; save world
 37353 00006AC2 56                      	PUSH	SI
 37354                                  	;mov	byte [ss:EXTERR_LOCUS],2
 37355 00006AC3 36C606[2303]02          	MOV	BYTE [SS:EXTERR_LOCUS],errLOC_Disk		;smr;SS Override
 37356 00006AC9 36F606[7205]FF          	TEST	BYTE [SS:FSHARING],-1	; Logical or Physical?	;smr;SS Override
 37357 00006ACF 7420                    	JZ	SHORT GTD20		; Logical
 37358 00006AD1 50                      	PUSH	AX
 37359 00006AD2 06                      	PUSH	ES
 37360 00006AD3 57                      	PUSH	DI
 37361 00006AD4 36C706[A205][F304]      	MOV	WORD [SS:THISCDS],DUMMYCDS ;smr;SS Override
 37362                                  	;mov	[SS:THISCDS+2],CS ; MSDOS 3.3
 37363 00006ADB 368C16[A405]            	MOV	[SS:THISCDS+2],SS ; MSDOS 6.0 ;ThisCDS = &DummyCDS;smr;
 37364 00006AE0 0441                    	ADD	AL,'A'
 37365 00006AE2 E815FF                  	CALL	InitCDS			; InitCDS(c);
 37366                                  	;test	word [es:di+67],4000h
 37367                                  	; 17/12/2022
 37368                                  	;test	byte [es:di+68],40h
 37369 00006AE5 26F6454440              	test	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
 37370                                  	;TEST	WORD [ES:DI+curdir.flags],curdir_inuse	; Clears carry
 37371 00006AEA 5F                      	POP	DI
 37372 00006AEB 07                      	POP	ES
 37373 00006AEC 58                      	POP	AX
 37374 00006AED 740D                    	JZ	SHORT GTD30		; Not a physical drive.
 37375 00006AEF EB18                    	JMP	SHORT GTDX		; carry clear
 37376                                  GTD20:
 37377 00006AF1 E81800                  	CALL	GetCDSFromDrv
 37378 00006AF4 7206                    	JC	SHORT GTD30	; Unassigned CDS -> return error already set
 37379                                  	;test	word [si+43h],4000h
 37380                                  	; 17/12/2022
 37381                                  	;test	byte [si+44h],40h
 37382 00006AF6 F6444440                	test	byte [SI+curdir.flags+1],(curdir_inuse>>8)
 37383                                  	;TEST	WORD [SI+curdir.flags],curdir_inuse ; Clears Carry
 37384 00006AFA 750D                    	JNZ	SHORT GTDX		; carry clear
 37385                                  GTD30:	
 37386                                  	; 21/05/2019
 37387                                  	; MSDOS 6.0
 37388 00006AFC B00F                    	MOV	AL,error_invalid_drive	; invalid FAT drive
 37389 00006AFE 36A2[1006]              	MOV	BYTE [ss:DrvErr],AL	; save this for IOCTL
 37390                                  	; MSDOS 3.3 (.& MSDOS 6.0)
 37391 00006B02 36C606[2303]01          	MOV	BYTE [ss:EXTERR_LOCUS],errLOC_Unk
 37392 00006B08 F9                      	STC
 37393                                  GTDX:	
 37394 00006B09 5E                      	POP	SI			; restore world
 37395 00006B0A 1F                      	POP	DS
 37396 00006B0B C3                      	RETN
 37397                                   
 37398                                  
 37399                                  ;Break <GetCDSFromDrv - convert a drive number to a CDS pointer>
 37400                                  ;----------------------------------------------------------------------------
 37401                                  ;   GetCDSFromDrv - given a physical drive number, convert it to a CDS
 37402                                  ;	pointer, returning an error if the drive number is greater than the
 37403                                  ;	number of CDS's
 37404                                  ;
 37405                                  ;   Inputs:	AL is physical unit # A=0...
 37406                                  ;   Outputs:	Carry Set if Bad Drive
 37407                                  ;		Carry Clear
 37408                                  ;		    DS:SI -> CDS
 37409                                  ;		    [THISCDS] = DS:SI
 37410                                  ;   Registers modified: DS,SI
 37411                                  ;----------------------------------------------------------------------------
 37412                                  
 37413                                  	; 21/05/2019 - Retro DOS v4.0
 37414                                  GetCDSFromDrv:
 37415 00006B0C 363A06[4700]            	CMP	AL,[SS:CDSCOUNT]	; is this a valid designator;smr;SS Override
 37416                                  	;JB	SHORT GetCDS	; cf=1	; yes, go get the macro
 37417                                  	;STC				; signal error
 37418                                  	;RETN				; bye
 37419                                  	; 23/09/2023
 37420 00006B11 F5                      	cmc	; cf=1 <-> cf=0
 37421 00006B12 7217                    	jc	short GetCDS_retn
 37422                                  GetCDS:
 37423                                  	; 23/09/2023
 37424                                  	;PUSH	BX
 37425 00006B14 50                      	PUSH	AX
 37426 00006B15 36C536[3C00]            	LDS	SI,[SS:CDSADDR]		; get pointer to table	;smr;SS Override
 37427                                  	;mov	bl,81 ; MSDOS 3.3
 37428                                  	;mov	bl,88 ; MSDOS 6.0 
 37429                                  	; 23/09/2023
 37430                                  	;MOV	BL,curdir.size		; size in convenient spot
 37431                                  	;MUL	BL			; get net offset
 37432 00006B1A B458                    	mov	ah,curdir.size
 37433 00006B1C F6E4                    	mul	ah
 37434 00006B1E 01C6                    	ADD	SI,AX ; *		; convert to true pointer
 37435 00006B20 368936[A205]            	MOV	[SS:THISCDS],SI		; store convenient offset;smr;SS Override
 37436 00006B25 368C1E[A405]            	MOV	[SS:THISCDS+2],DS	; store convenient segment;smr;SS Override
 37437 00006B2A 58                      	POP	AX
 37438                                  	; 23/09/2023
 37439                                  	;POP	BX
 37440                                  	; (cf must be 0 here) ; *
 37441                                  	;CLC				; no error
 37442                                  GetCDS_retn:
 37443 00006B2B C3                      	RETN				; bye!
 37444                                  
 37445                                  ;============================================================================
 37446                                  ; MACRO2.ASM, MSDOS 6.0, 1991
 37447                                  ;============================================================================
 37448                                  ; Retro	DOS v3.0 - 12/07/2018
 37449                                  ; 22/05/2019 - Retro DOS v4.0
 37450                                  
 37451                                  ;BREAK <TransFCB - convert an FCB into a path, doing substitution>
 37452                                  ;----------------------------------------------------------------------------
 37453                                  ;   TransFCB - Copy an FCB from DS:DX into a reserved area doing all of the
 37454                                  ;       gritty substitution.
 37455                                  ;
 37456                                  ;   Inputs:     DS:DX - pointer to FCB
 37457                                  ;               ES:DI - point to destination
 37458                                  ;   Outputs:    Carry Set - invalid path in final map
 37459                                  ;               Carry Clear - FCB has been mapped into ES:DI
 37460                                  ;                   Sattrib is set from possibly extended FCB
 37461                                  ;                   ExtFCB set if extended FCB found
 37462                                  ;   Registers modified: most
 37463                                  ;----------------------------------------------------------------------------
 37464                                  
 37465                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37466                                  TransFCB:
 37467                                  	; 22/05/2019 - Retro DOS v4.0
 37468                                  	; 12/07/2018 - Retro DOS v3.0
 37469                                  	;LocalVar FCBTmp,16
 37470                                  	;ENTER
 37471 00006B2C 55                      	push	bp
 37472 00006B2D 89E5                    	mov	bp,sp
 37473                                  	;sub	sp,15	; MSDOS 3.3
 37474 00006B2F 83EC10                  	sub	sp,16	; MSDOS 6.0
 37475 00006B32 16                      	push	ss
 37476 00006B33 07                      	pop	es
 37477 00006B34 06                      	push	es
 37478 00006B35 57                      	push	di
 37479                                  	;lea	di,[bp-15] ; MSDOS 3.3
 37480                                  	;LEA	DI,FCBTmp 
 37481 00006B36 8D7EF0                  	lea	di,[bp-16]		; point to FCB temp area
 37482 00006B39 36C606[6C05]00          	mov	byte [SS:EXTFCB],0	; no extended FCB found ;smr;SS Override
 37483 00006B3F 36C606[6D05]00          	mov	byte [SS:SATTRIB],0	; default search attributes;smr;SS Override
 37484 00006B45 E836B1                  	call	GetExtended             ; get FCB, extended or not
 37485                                  	; 06/12/2022
 37486 00006B48 740D                    	jz	short GetDrive		; not an extended FCB, get drive
 37487 00006B4A 8A44FF                  	mov	AL,[SI-1]               ; get attributes
 37488 00006B4D 36A2[6D05]              	mov	[SS:SATTRIB],AL		; store search attributes;smr;SS Override
 37489 00006B51 36C606[6C05]FF          	mov	byte [SS:EXTFCB],-1	; signal extended FCB  ;smr;SS Override
 37490                                  GetDrive:
 37491 00006B57 AC                      	lodsb				; get drive byte
 37492 00006B58 E85CFF                  	call	GETTHISDRV
 37493 00006B5B 722A                    	jc	short BadPack
 37494 00006B5D E87303                  	call	TextFromDrive           ; convert 0-based drive to text
 37495                                  
 37496                                  ; Scan the source to see if there are any illegal chars
 37497                                  
 37498                                  	;mov	bx,CharType		; load lookup table
 37499 00006B60 B90B00                  	mov	cx,11
 37500 00006B63 56                      	push	si			; back over name, ext
 37501                                  FCBScan:
 37502 00006B64 AC                      	lodsb				; get a byte
 37503                                  	
 37504                                  	; 09/08/2018
 37505                                  	;;xlat	byte [es:bx]
 37506                                  	;es	xlat
 37507                                  
 37508                                  	; 22/05/2019 - Retro DOS v4.0	
 37509 00006B65 E836E5                  	call	GetCharType		; get flags
 37510                                  
 37511                                  	;test	al,8	
 37512 00006B68 A808                    	test	al,FFCB
 37513 00006B6A 741B                    	jz	short BadPack
 37514                                  NextCh: 
 37515 00006B6C E2F6                    	loop	FCBScan
 37516 00006B6E 5E                      	pop	si
 37517 00006B6F 89FB                    	mov	bx,di
 37518 00006B71 E863B5                  	call	PackName                ; crunch the path
 37519 00006B74 5F                      	pop	di			; get original destination
 37520 00006B75 07                      	pop	es
 37521 00006B76 16                      	push	ss			; get DS addressability
 37522 00006B77 1F                      	pop	ds
 37523                                  	;lea	si,[bp-15] ; MSDOS 3.3
 37524                                  	;LEA	SI,FCBTmp		; point at new pathname
 37525 00006B78 8D76F0                  	lea	si,[bp-16]
 37526 00006B7B 803F00                  	cmp	byte [bx],0
 37527 00006B7E 7407                    	jz	short BadPack
 37528 00006B80 55                      	push	bp
 37529 00006B81 E80E00                  	call	TransPathSet            ; convert the path
 37530 00006B84 5D                      	pop	bp
 37531 00006B85 7303                    	jnc	short FCBRet		; bye with transPath error code
 37532                                  BadPack:
 37533 00006B87 F9                      	STC
 37534                                  	;mov	al,3
 37535 00006B88 B003                    	MOV     AL,error_path_not_found
 37536                                  FCBRet: 
 37537                                  	;LEAVE
 37538 00006B8A 89EC                    	mov	sp,bp
 37539 00006B8C 5D                      	pop	bp
 37540                                  TransPath_retn:
 37541 00006B8D C3                      	retn
 37542                                  
 37543                                  ; 12/07/2018 - Retro DOS v3.0
 37544                                  
 37545                                  ;BREAK <TransPath - copy a path, do string sub and put in current dir>
 37546                                  ;----------------------------------------------------------------------------
 37547                                  ;
 37548                                  ;   TransPath - copy a path from DS:SI to ES:DI, performing component string
 37549                                  ;       substitution, insertion of current directory and fixing . and ..
 37550                                  ;       entries. Perform splicing. Allow input string to match splice
 37551                                  ;       exactly.
 37552                                  ;
 37553                                  ;   TransPathSet - Same as above except No splicing is performed if input path
 37554                                  ;       matches splice.
 37555                                  ;
 37556                                  ;   TransPathNoSet - No splicing/local using is performed at all.
 37557                                  ;
 37558                                  ;   The following anomalous behaviour is required:
 37559                                  ;
 37560                                  ;       Drive letters on devices are ignored. (set up DummyCDS)
 37561                                  ;       Paths on devices are ignored. (truncate to 0-length)
 37562                                  ;       Raw net I/O sets ThisCDS => NULL.
 37563                                  ;       fSharing => dummyCDS and no subst/splice. Only canonicalize.
 37564                                  ;
 37565                                  ;   Other behaviour:
 37566                                  ;
 37567                                  ;       ThisCDS set up.
 37568                                  ;       FatRead done on local CDS.
 37569                                  ;       ValidateCDS done on local CDS.
 37570                                  ;
 37571                                  ;   Brief flowchart:
 37572                                  ;
 37573                                  ;       if fSharing then
 37574                                  ;           set up DummyCDS (ThisCDS)
 37575                                  ;           canonicalize (sets cMeta)
 37576                                  ;           splice
 37577                                  ;           fatRead
 37578                                  ;           return
 37579                                  ;       if \\ or d:\\ lead then
 37580                                  ;           set up null CDS (ThisCDS)
 37581                                  ;           canonicalize (sets cMeta)
 37582                                  ;           return
 37583                                  ;       if device then
 37584                                  ;           set up dummyCDS (ThisCDS)
 37585                                  ;           canonicalize (sets cMeta)
 37586                                  ;           return
 37587                                  ;       if file then
 37588                                  ;           getCDS (sets (ThisCDS) from name)
 37589                                  ;           validateCDS (may reset current dir)
 37590                                  ;           Copy current dir
 37591                                  ;           canonicalize (set cMeta)
 37592                                  ;           splice
 37593                                  ;           generate correct CDS (ThisCDS)
 37594                                  ;           if local then
 37595                                  ;               fatread
 37596                                  ;           return
 37597                                  ;
 37598                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 37599                                  ;               DI - point to buffer in DOSDATA
 37600                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 37601                                  ;                   syntax, etc. or user FAILed to I 24.
 37602                                  ;               WFP_Start - points to beginning of buffer
 37603                                  ;               Curr_Dir_End - points to end of current dir in path
 37604                                  ;               DS - DOSDATA
 37605                                  ;   Registers modified: most
 37606                                  ;
 37607                                  ;----------------------------------------------------------------------------
 37608                                  
 37609                                  ; 22/05/2019
 37610                                  ; 13/05/2019 - Retro DOS v4.0
 37611                                  ; DOSCODE:AB99h (MSDOS 6.21, MSDOS.SYS)
 37612                                  
 37613                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37614                                  ; DOSCODE:AB39h (MSDOS 5.0, MSDOS.SYS)
 37615                                  
 37616                                  TransPath:
 37617 00006B8E 30C0                    	XOR     AL,AL
 37618 00006B90 EB02                    	JMP     SHORT SetSplice
 37619                                  TransPathSet:
 37620 00006B92 B0FF                    	MOV     AL,-1
 37621                                  SetSplice:
 37622 00006B94 36A2[4C03]              	MOV	[SS:NoSetDir],AL	;   NoSetDir = !fExact; ;smr;SS Override
 37623 00006B98 B0FF                    	MOV     AL,-1
 37624                                  TransPathNoSet:
 37625 00006B9A 36A2[7105]              	MOV	[SS:FSPLICE],AL		;   fSplice = TRUE;     ;smr;SS Override
 37626 00006B9E 36C606[7A05]FF          	MOV	byte [ss:CMETA],-1      			;smr;SS Override
 37627 00006BA4 36893E[B205]            	MOV     [SS:WFP_START],DI 				;smr;SS Override
 37628 00006BA9 36C706[B605]FFFF        	MOV	word [SS:CURR_DIR_END],-1 ; crack from start	;smr;SS Override
 37629 00006BB0 16                      	push	ss
 37630 00006BB1 07                      	pop	es
 37631                                  	;lea	bp,[di+134]
 37632 00006BB2 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; end of buffer
 37633                                  ;
 37634                                  ; if this is through the server dos call, fsharing is set. We set up a
 37635                                  ; dummy cds and let the operation go.
 37636                                  ;
 37637 00006BB6 36F606[7205]FF          	TEST	byte [SS:FSHARING],-1	; if no sharing		;smr;SS Override
 37638 00006BBC 7435                    	JZ	short CheckUNC		; skip to UNC check
 37639                                  ;
 37640                                  ; ES:DI point to buffer
 37641                                  ;
 37642 00006BBE E8FC02                  	CALL	DriveFromText           ; get drive and advance DS:SI
 37643 00006BC1 E8F3FE                  	call	GETTHISDRV              ; Set ThisCDS and convert to 0-based
 37644 00006BC4 722A                    	jc	short NoPath
 37645 00006BC6 E80A03                  	CALL	TextFromDrive		; drop in new
 37646 00006BC9 8D5D01                  	LEA	BX,[DI+1]               ; backup limit
 37647 00006BCC E83401                  	CALL	Canonicalize            ; copy and canonicalize
 37648 00006BCF 72BC                    	jc	short TransPath_retn	; errors
 37649                                  ;
 37650                                  ; Perform splices for net guys.
 37651                                  ;
 37652 00006BD1 16                      	push	ss
 37653 00006BD2 1F                      	pop	ds
 37654 00006BD3 8B36[B205]              	MOV     SI,[WFP_START] 		; point to name
 37655 00006BD7 F606[7105]FF            	TEST	byte [FSPLICE],-1
 37656 00006BDC 7403                    	JZ	short NoServerSplice
 37657 00006BDE E83102                  	CALL    Splice
 37658                                  NoServerSplice:
 37659 00006BE1 16                      	push	ss
 37660 00006BE2 1F                      	pop	ds                      ; for FATREAD
 37661 00006BE3 C43E[A205]              	LES     DI,[THISCDS]		; for fatread
 37662 00006BE7 E827A7                  	call	ECritDisk
 37663 00006BEA E807EB                  	call	FATREAD_CDS
 37664 00006BED E83CA7                  	call	LCritDisk
 37665                                  NoPath:
 37666                                  	;mov	al,3
 37667 00006BF0 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 37668 00006BF2 C3                      	retn				; any errors are in Carry flag
 37669                                  
 37670                                  ; Let the network decide if the name is for a spooled device. It will map
 37671                                  ; the name if so.
 37672                                  
 37673                                  CheckUNC:
 37674 00006BF3 36C706[A205]FFFF        	MOV     WORD [SS:THISCDS],-1	; NULL thisCDS		;smr;SS Override
 37675                                  	;CallInstall NetSpoolCheck,MultNET,35
 37676 00006BFA B82311                  	mov	ax,1123h
 37677 00006BFD CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
 37678                                  			; DS:SI -> ASCIZ filename to canonicalize
 37679                                  			; ES:DI -> 128-byte buffer for qualified name
 37680                                  			; Return: CF set if not resolved
 37681 00006BFF 7329                    	JNC	short UNCDone
 37682                                  
 37683                                  ; At this point the name is either a UNC-style name (prefixed with two leading
 37684                                  ; \\s) or is a local file/device. Remember that if a net-spooled device was
 37685                                  ; input, then the name has been changed to the remote spooler by the above net
 37686                                  ; call. Also, there may be a drive in front of the \\.
 37687                                  
 37688                                  NO_CHECK:
 37689 00006C01 E8B902                  	CALL    DriveFromText		; eat drive letter
 37690 00006C04 50                      	PUSH    AX                      ; save it
 37691 00006C05 8B04                    	MOV     AX,[SI]			; get first two bytes of path
 37692 00006C07 E8B1E4                  	call    PATHCHRCMP              ; convert to normal form
 37693 00006C0A 86E0                    	XCHG    AH,AL                   ; swap for second byte
 37694 00006C0C E8ACE4                  	call    PATHCHRCMP              ; convert to normal form
 37695 00006C0F 751F                    	JNZ	short CheckDevice	; not a path char
 37696 00006C11 38C4                    	CMP     AH,AL                   ; are they same?
 37697 00006C13 751B                    	JNZ	short CheckDevice	; nope
 37698                                  
 37699                                  ; We have a UNC request. We must copy the string up to the beginning of the
 37700                                  ; local machine root path
 37701                                  
 37702 00006C15 58                      	POP     AX
 37703 00006C16 A5                      	MOVSW                           ; get the lead \\.
 37704                                  UNCCpy:
 37705 00006C17 AC                      	LODSB                           ; get a byte
 37706 00006C18 E84BE4                   	call	UCase                   ;AN000;; convert the char
 37707 00006C1B 08C0                    	OR      AL,AL
 37708 00006C1D 740E                    	JZ	short UNCTerm		; end of string. All done.
 37709 00006C1F E899E4                  	call    PATHCHRCMP              ; is it a path char?
 37710 00006C22 89FB                    	MOV     BX,DI                   ; backup position
 37711 00006C24 AA                      	STOSB
 37712 00006C25 75F0                    	JNZ	short UNCCpy		; no, go copy
 37713 00006C27 E8D900                  	CALL    Canonicalize            ; wham (and set cMeta)
 37714                                  UNCDone:
 37715 00006C2A 16                      	push	ss
 37716 00006C2B 1F                      	pop	ds
 37717 00006C2C C3                       	retn				; return error code
 37718                                  UNCTerm:
 37719 00006C2D AA                      	STOSB                           ;AN000;
 37720 00006C2E EBFA                    	JMP	short UNCDone		;AN000;
 37721                                  
 37722                                  CheckDevice:
 37723                                  
 37724                                  ; Check DS:SI for device. First eat any path stuff
 37725                                  
 37726 00006C30 58                      	POP     AX                      ; retrieve drive info
 37727 00006C31 803C00                  	CMP     BYTE [SI],0		; check for null file
 37728 00006C34 7504                    	JNZ	short CheckPath
 37729                                  	;mov	al,2 
 37730 00006C36 B002                    	MOV     AL,error_file_not_found ; bad file error
 37731 00006C38 F9                      	STC                             ; signal error on null input
 37732 00006C39 C3                      	RETN				; bye!
 37733                                  CheckPath:
 37734 00006C3A 50                      	push	ax
 37735 00006C3B 55                      	push	bp			; save drive number
 37736                                  
 37737                                  
 37738                                  ; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37739                                  %if 0
 37740                                  	; MSDOS 6.0
 37741                                  ;;;BUGBUG BUG 10-26-1992 scottq
 37742                                  ;;;This is a hack for the CDROM extensions (2.1) who scan looking
 37743                                  ;;;for the following POP BP == 5Dh (restore <bp,ax>).
 37744                                  ;;;The problem is that a direct call to CheckThisDevice can (and did)
 37745                                  ;;;end up having a 5D in the opcode's displacement field. The
 37746                                  ;;;scanning code would choke on this thinking it was a POP BP instruction.
 37747                                  ;;;
 37748                                  ;;;What we do here is do a call to a function that is less than 5Dh
 37749                                  ;;;bytes away (and assert its not exactly 5D away) that jmps (transfers)
 37750                                  ;;;to the correct function. This cannot accidently insert a 5Dh.
 37751                                  ;;;
 37752                                  ;;;More info:
 37753                                  ;;;  This particular scan is begun at the UNCdone label for 32 bytes
 37754                                  ;;;looking for pop BP, so you cannot put a 5D between here and there.
 37755                                  ;;;
 37756                                  	call	no5Dshere
 37757                                  start5Dhack:
 37758                                  ;following is replaced with 5Dhack code--Invoke CheckThisDevice         
 37759                                  backfrom5Dhack:
 37760                                  
 37761                                  %endif
 37762                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37763                                  	; Note: 'call no5Dshere' is not required for MSDOS 5.0 MSDOS.SYS
 37764 00006C3C E8FED6                  	call    CheckThisDevice	; E8h,6Fh,0D6h
 37765                                  
 37766 00006C3F 5D                      	pop	bp
 37767 00006C40 58                      	pop	ax			; get drive letter back
 37768 00006C41 731C                    	JNC	short DoFile		; yes we have a file.
 37769                                  
 37770                                  ; We have a device. AX has drive letter. At this point we may fake a CDS ala
 37771                                  ; sharing DOS call. We know by getting here that we are NOT in a sharing DOS
 37772                                  ; call.
 37773                                  
 37774 00006C43 36C606[7205]FF          	MOV	byte [SS:FSHARING],-1	; simulate sharing dos call;smr;SS Override
 37775 00006C49 E86BFE                  	call	GETTHISDRV              ; set ThisCDS and init DUMMYCDS
 37776 00006C4C 36C606[7205]00          	MOV     byte [SS:FSHARING],0	;                       ;smr;SS Override
 37777                                  
 37778                                  ; Now that we have noted that we have a device, we put it into a form that
 37779                                  ; getpath can understand. Normally getpath requires d:\ to begin the input
 37780                                  ; string. We relax this to state that if the d:\ is present then the path
 37781                                  ; may be a file. If D:/ (note the forward slash) is present then we have
 37782                                  ; a device.
 37783                                  
 37784 00006C52 E87E02                  	CALL    TextFromDrive
 37785 00006C55 B02F                    	MOV     AL,'/'                  ; path sep.
 37786 00006C57 AA                      	STOSB
 37787 00006C58 E87AA5                  	call	StrCpy			; move remainder of string
 37788                                  
 37789 00006C5B F8                      	CLC                             ; everything OK.
 37790 00006C5C 16                      	push	ss
 37791 00006C5D 1F                      	pop	ds                      ; remainder of OK stuff
 37792                                  DoFile_retn:
 37793 00006C5E C3                      	retn
 37794                                  
 37795                                  ; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37796                                  %if 0
 37797                                  
 37798                                  no5Dshere:
 37799                                  	; 10/08/2018
 37800                                  	jmp	CheckThisDevice		; snoop for device
 37801                                  %endif
 37802                                  
 37803                                  ;.erre (no5Dshere - start5Dhack - 5D)
 37804                                  
 37805                                  ; We have a file. Get the raw CDS.
 37806                                  
 37807                                  DoFile:
 37808                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37809                                  
 37810 00006C5F E839FE                  	call	GetVisDrv               ; get proper CDS
 37811                                  	;mov	al,3 
 37812 00006C62 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad file error
 37813 00006C64 72F8                    	jc	short DoFile_retn  ; CARRY set -> bogus drive/spliced
 37814                                  
 37815                                  ; ThisCDS has correct CDS. DS:SI advanced to point to beginning of path/file.
 37816                                  ; Make sure that CDS has valid directory; ValidateCDS requires a temp buffer
 37817                                  ; Use the one that we are going to use (ES:DI).
 37818                                  
 37819                                  	;SAVE    <DS,SI,ES,DI>		; save all string pointers.
 37820 00006C66 1E                      	push	ds
 37821 00006C67 56                      	push	si
 37822 00006C68 06                      	push	es
 37823 00006C69 57                      	push	di
 37824 00006C6A E814D6                  	call	ValidateCDS             ; poke CDS and make everything OK
 37825                                  	;RESTORE <DI,ES,SI,DS>		; get back pointers
 37826 00006C6D 5F                      	pop	di
 37827 00006C6E 07                      	pop	es
 37828 00006C6F 5E                      	pop	si
 37829 00006C70 1F                      	pop	ds
 37830                                  	;mov	al,3
 37831 00006C71 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 37832                                  	;retc				; someone failed an operation
 37833 00006C73 72E9                    	jc	short DoFile_retn
 37834                                  
 37835                                  ; ThisCDS points to correct CDS. It contains the correct text of the
 37836                                  ; current directory. Copy it in.
 37837                                  
 37838 00006C75 1E                      	push	ds
 37839 00006C76 56                      	push	si
 37840 00006C77 36C536[A205]            	LDS     SI,[SS:THISCDS]		; point to CDS	;smr;SS Override
 37841 00006C7C 89FB                    	MOV     BX,DI                   ; point to destination
 37842                                  	;add	bx,[si+79] ; MSDOS 6.0
 37843 00006C7E 035C4F                  	ADD     BX,[SI+curdir.end]	; point to backup limit
 37844                                  	;lea	bp,[di+134]
 37845 00006C81 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; regenerate end of buffer
 37846                                  					;AN000;
 37847 00006C85 E85CA5                  	call	FStrCpy                 ; copy string. ES:DI point to end
 37848 00006C88 4F                      	DEC     DI                      ; point to NUL byte
 37849                                  
 37850                                  ; Make sure that there is a path char at end.
 37851                                  
 37852 00006C89 B05C                    	MOV     AL,'\'
 37853 00006C8B 263845FF                	CMP     [ES:DI-1],AL
 37854 00006C8F 7401                    	JZ	short GetOrig
 37855 00006C91 AA                      	STOSB
 37856                                  
 37857                                  ; Now get original string.
 37858                                  
 37859                                  GetOrig:
 37860 00006C92 4F                      	DEC     DI                      ; point to path char
 37861 00006C93 5E                      	pop	si
 37862 00006C94 1F                      	pop	ds
 37863                                  
 37864                                  ; BX points to the end of the root part of the CDS (at where a path char
 37865                                  ; should be). Now, we decide whether we use this root or extend it with the
 37866                                  ; current directory. See if the input string begins with a leading 
 37868 00006C95 E8D000                  	CALL    PathSep                 ; is DS:SI a path sep?
 37869 00006C98 7511                    	JNZ	short PathAssure	; no, DI is correct. Assure a path char
 37870 00006C9A 08C0                    	OR      AL,AL                   ; end of string?
 37871 00006C9C 7410                    	JZ	short DoCanon		; yes, skip.
 37872                                  ;
 37873                                  ; The string does begin with a \. Reset the beginning of the canonicalization
 37874                                  ; to this root. Make sure that there is a path char there and advance the
 37875                                  ; source string over all leading \'s.
 37876                                  ;
 37877 00006C9E 89DF                    	MOV     DI,BX                   ; back up to root point.
 37878                                  SkipPath:
 37879 00006CA0 AC                      	LODSB
 37880 00006CA1 E817E4                  	call    PATHCHRCMP
 37881 00006CA4 74FA                    	JZ	short SkipPath
 37882 00006CA6 4E                      	DEC     SI
 37883 00006CA7 08C0                    	OR      AL,AL
 37884 00006CA9 7403                    	JZ	short DoCanon
 37885                                  
 37886                                  ; DS:SI start at some file name. ES:DI points at some path char. Drop one in
 37887                                  ; for yucks.
 37888                                  
 37889                                  PathAssure:
 37890 00006CAB B05C                    	MOV     AL,'\'	; 5Ch
 37891 00006CAD AA                      	STOSB
 37892                                  
 37893                                  ; ES:DI point to the correct spot for canonicalization to begin.
 37894                                  ; BP is the max extent to advance DI
 37895                                  ; BX is the backup limit for ..
 37896                                  
 37897                                  DoCanon:
 37898 00006CAE E85200                  	CALL    Canonicalize            ; wham.
 37899                                  	;retc				; badly formatted path.
 37900 00006CB1 72AB                    	jc	short DoFile_retn
 37901                                  
 37902                                  ; The string has been moved to ES:DI. Reset world to DOS context, pointers
 37903                                  ; to wfp_start and do string substitution. BP is still the max position in
 37904                                  ; buffer.
 37905                                  
 37906 00006CB3 16                      	push	ss
 37907 00006CB4 1F                      	pop	ds
 37908 00006CB5 8B3E[B205]              	MOV     DI,[WFP_START]		; DS:SI point to string
 37909 00006CB9 C536[A205]              	LDS     SI,[THISCDS]		; point to CDS
 37910 00006CBD E81B02                  	CALL    PathPref                ; is there a prefix?
 37911 00006CC0 7514                    	JNZ	short DoSplice		; no, do splice
 37912                                  
 37913                                  ; We have a match. Check to see if we ended in a path char.
 37914                                  
 37915 00006CC2 8A44FF                  	MOV     AL,[SI-1]		; last char to match
 37916 00006CC5 E8F3E3                  	call    PATHCHRCMP              ; did we end on a path char? (root)
 37917 00006CC8 740C                    	JZ	short DoSplice		; yes, no current dir here.
 37918                                  Pathline:                               ; 2/13/KK
 37919 00006CCA 26803D00                	CMP     BYTE [ES:DI],0		; end at NUL?
 37920 00006CCE 7406                    	JZ	short DoSplice
 37921 00006CD0 47                      	INC     DI                      ; point to after current path char
 37922 00006CD1 36893E[B605]            	MOV     [SS:CURR_DIR_END],DI	; point to correct spot ;smr;SS Override
 37923                                  
 37924                                  ; Splice the result.
 37925                                  
 37926                                  DoSplice:
 37927 00006CD6 16                      	push	ss
 37928 00006CD7 1F                      	pop	ds			; back to DOSDATA
 37929 00006CD8 8B36[B205]              	MOV     SI,[WFP_START]		; point to beginning of string
 37930 00006CDC 31C9                    	XOR     CX,CX
 37931 00006CDE F606[7105]FF            	TEST	byte [FSPLICE],-1
 37932 00006CE3 7403                    	JZ	short SkipSplice
 37933 00006CE5 E82A01                  	CALL    Splice                  ; replaces in place.
 37934                                  SkipSplice:
 37935                                  
 37936                                  ; The final thing is to assure ourselves that a FATREAD is done on the local
 37937                                  ; device.
 37938                                  
 37939 00006CE8 16                      	push	ss
 37940 00006CE9 1F                      	pop	ds
 37941 00006CEA C43E[A205]              	LES     DI,[THISCDS]		; point to correct drive
 37942                                  	;test	word [es:di+67],8000h
 37943                                  	; 17/12/2022
 37944                                  	;test	byte [es:di+68],80h
 37945 00006CEE 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8 ; 04/12/2022
 37946                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
 37947 00006CF3 750D                    	JNZ	short Done		; net, no fatread necessary (retnz)
 37948 00006CF5 E30B                    	JCXZ    Done
 37949 00006CF7 E817A6                  	call	ECritDisk
 37950 00006CFA E8F7E9                  	call	FATREAD_CDS
 37951 00006CFD E82CA6                  	call	LCritDisk
 37952                                  	;mov	al, 3
 37953 00006D00 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 37954                                  Done:   
 37955 00006D02 C3                      	retn                         ; any errors in carry flag.
 37956                                  
 37957                                  ; 13/07/2018
 37958                                  
 37959                                  ;BREAK <Canonicalize - copy a path and remove . and .. entries>
 37960                                  ;----------------------------------------------------------------------------
 37961                                  ;   Canonicalize - copy path removing . and .. entries.
 37962                                  ;
 37963                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 37964                                  ;               ES:DI - point to buffer
 37965                                  ;               BX - backup limit (offset from ES) points to slash
 37966                                  ;               BP - end of buffer
 37967                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 37968                                  ;                   syntax, etc.
 37969                                  ;               Carry Clear -
 37970                                  ;                   DS:DI - advanced to end of string
 37971                                  ;                   ES:DI - advanced to end of canonicalized form after nul
 37972                                  ;   Registers modified: AX CX DX (in addition to those above)
 37973                                  ;----------------------------------------------------------------------------
 37974                                  
 37975                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37976                                  
 37977                                  Canonicalize:
 37978                                  
 37979                                  ; We copy all leading path separators.
 37980                                  
 37981 00006D03 AC                      	LODSB                           ;   while (PathChr (*s))
 37982 00006D04 E8B4E3                  	call    PATHCHRCMP
 37983 00006D07 7507                    	JNZ	short CanonDec
 37984 00006D09 39EF                    	CMP     DI,BP                   ;       if (d > dlim)
 37985 00006D0B 7319                    	JAE	short CanonBad		;           goto error;
 37986 00006D0D AA                      	STOSB
 37987 00006D0E EBF3                    	JMP	short Canonicalize	;           *d++ = *s++;
 37988                                  CanonDec:
 37989 00006D10 4E                      	DEC     SI
 37990                                  
 37991                                  ; Main canonicalization loop. We come here with DS:SI pointing to a textual
 37992                                  ; component (no leading path separators) and ES:DI being the destination
 37993                                  ; buffer.
 37994                                  
 37995                                  CanonLoop:
 37996                                  
 37997                                  ; If we are at the end of the source string, then we need to check to see that
 37998                                  ; a potential drive specifier is correctly terminated with a path sep char.
 37999                                  ; Otherwise, do nothing
 38000                                  
 38001 00006D11 31C0                    	XOR     AX,AX
 38002 00006D13 3804                    	CMP     [SI],AL                 ;       if (*s == 0) {
 38003 00006D15 751A                    	JNZ	short DoComponent
 38004 00006D17 26807DFF3A              	CMP     BYTE [ES:DI-1],':'	;           if (d[-1] == ':')
 38005 00006D1C 7505                    	JNZ	short DoTerminate
 38006 00006D1E B05C                    	MOV     AL,'\'                  ;               *d++ = '\';
 38007 00006D20 AA                      	STOSB
 38008 00006D21 88E0                    	MOV     AL,AH
 38009                                  DoTerminate:
 38010 00006D23 AA                      	STOSB                           ;           *d++ = 0;
 38011 00006D24 F8                      	CLC                             ;           return (0);
 38012 00006D25 C3                      	retn
 38013                                  
 38014                                  CanonBad:
 38015 00006D26 E8CB01                  	CALL	ScanPathChar            ; check for path chars in rest of string
 38016                                  	;mov	al,3
 38017 00006D29 B003                    	MOV     AL,error_path_not_found ; Set up for bad path error
 38018 00006D2B 7402                    	JZ	short PathEnc		; path character encountered in string
 38019                                  	;mov	al,2
 38020 00006D2D B002                    	MOV     AL,error_file_not_found ; Set bad file error
 38021                                  PathEnc:
 38022 00006D2F F9                      	STC
 38023                                  CanonBad_retn:
 38024 00006D30 C3                      	retn
 38025                                  
 38026                                  ; We have a textual component that we must copy. We uppercase it and truncate
 38027                                  ; it to 8.3
 38028                                  
 38029                                  DoComponent:                            ;           }
 38030 00006D31 E85000                  	CALL    CopyComponent		;       if (!CopyComponent (s, d))
 38031 00006D34 72FA                    	jc	short CanonBad_retn	;           return (-1);
 38032                                  
 38033                                  ; We special case the . and .. cases.  These will be backed up.
 38034                                  
 38035                                  	;CMP	WORD PTR ES:[DI],'.' + (0 SHL 8)
 38036 00006D36 26833D2E                	CMP	WORD [ES:DI],002Eh
 38037 00006D3A 7408                    	JZ	short Skip1
 38038                                  	;CMP	WORD PTR ES:[DI],'..'
 38039 00006D3C 26813D2E2E              	CMP     WORD [ES:DI],2E2Eh
 38040 00006D41 750A                    	JNZ	short CanonNormal
 38041 00006D43 4F                      	DEC     DI                      ;           d--;
 38042                                  Skip1:  
 38043 00006D44 E82A00                  	CALL    SkipBack                ;           SkipBack ();
 38044                                  	;mov	al,3
 38045 00006D47 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 38046 00006D49 72E5                    	jc	short CanonBad_retn
 38047 00006D4B EB02                    	JMP     short CanonPath         ;           }
 38048                                  
 38049                                  ; We have a normal path. Advance destination pointer over it.
 38050                                  
 38051                                  CanonNormal:                            ;       else
 38052 00006D4D 01CF                    	ADD     DI,CX                   ;           d += ct;
 38053                                  
 38054                                  ; We have successfully copied a component. We are now pointing at a path
 38055                                  ; sep char or are pointing at a nul or are pointing at something else.
 38056                                  ; If we point at something else, then we have an error.
 38057                                  
 38058                                  CanonPath:
 38059 00006D4F E81600                  	CALL    PathSep
 38060 00006D52 75D2                    	JNZ	short CanonBad		; something else...
 38061                                  
 38062                                  ; Copy the first path char we see.
 38063                                  
 38064 00006D54 AC                      	LODSB                           ; get the char
 38065 00006D55 E863E3                  	call    PATHCHRCMP              ; is it path char?
 38066 00006D58 75B6                    	JNZ	short CanonDec		; no, go test for nul
 38067 00006D5A 39EF                    	CMP     DI,BP                   ; beyond buffer end?
 38068 00006D5C 73C8                    	JAE	short CanonBad		; yep, error.
 38069 00006D5E AA                      	STOSB                           ; copy the one byte
 38070                                  
 38071                                  ; Skip all remaining path chars
 38072                                  
 38073                                  CanonPathLoop:
 38074 00006D5F AC                      	LODSB                           ; get next byte
 38075 00006D60 E858E3                  	call    PATHCHRCMP              ; path char again?
 38076 00006D63 74FA                    	JZ	short CanonPathLoop	; yep, grab another
 38077 00006D65 4E                      	DEC     SI                      ; back up
 38078 00006D66 EBA9                    	JMP	short  CanonLoop	; go copy component
 38079                                  
 38080                                  ;BREAK <PathSep - determine if char is a path separator>
 38081                                  ;----------------------------------------------------------------------------
 38082                                  ;   PathSep - look at DS:SI and see if char is / \ or NUL
 38083                                  ;   Inputs:     DS:SI - point to a char
 38084                                  ;   Outputs:    AL has char from DS:SI (/ => \)
 38085                                  ;               Zero set if AL is / \ or NUL
 38086                                  ;               Zero reset otherwise
 38087                                  ;   Registers modified: AL
 38088                                  ;----------------------------------------------------------------------------
 38089                                  
 38090                                  PathSep:
 38091 00006D68 8A04                    	MOV     AL,[SI]                 ; get the character
 38092                                  PathSepGotCh:				; already have character
 38093 00006D6A 08C0                    	OR      AL,AL                   ; test for zero
 38094 00006D6C 74C2                    	jz	short CanonBad_retn	; return if equal to zero (NUL)
 38095                                  	;call	PATHCHRCMP              ; check for path character
 38096                                  	;retn				; and return HIS determination
 38097                                  	; 18/12/2022
 38098 00006D6E E94AE3                  	jmp	PATHCHRCMP
 38099                                  
 38100                                  
 38101                                  ;BREAK <SkipBack - move backwards to a path separator>
 38102                                  ;----------------------------------------------------------------------------
 38103                                  ;   SkipBack - look at ES:DI and backup until it points to a / ;   Inputs:     ES:DI - point to a char
 38105                                  ;               BX has current directory back up limit (point to a / \)
 38106                                  ;   Outputs:    ES:DI backed up to point to a path char
 38107                                  ;               AL has char from output ES:DI (path sep if carry clear)
 38108                                  ;               Carry set if illegal backup
 38109                                  ;               Carry Clear if ok
 38110                                  ;   Registers modified: DI,AL
 38111                                  ;----------------------------------------------------------------------------
 38112                                  
 38113                                  SkipBack:
 38114 00006D71 39DF                    	CMP     DI,BX                   ;   while (TRUE) {
 38115 00006D73 720B                    	JB	short SkipBad		;       if (d < dlim)
 38116 00006D75 4F                      	DEC     DI                      ;           goto err;
 38117 00006D76 268A05                  	MOV     AL,[ES:DI]		;       if (pathchr (*--d))
 38118 00006D79 E83FE3                  	call    PATHCHRCMP              ;           break;
 38119 00006D7C 75F3                    	JNZ	short SkipBack		;       }
 38120 00006D7E F8                      	CLC                             ;   return (0);
 38121 00006D7F C3                      	retn				;
 38122                                  SkipBad:                                ;err:
 38123                                  	;mov	al,3
 38124 00006D80 B003                    	MOV     AL,error_path_not_found ; bad path error
 38125 00006D82 F9                      	STC                             ;   return (-1);
 38126 00006D83 C3                      	retn				;
 38127                                  
 38128                                  ;Break <CopyComponent - copy out a file path component>
 38129                                  ;----------------------------------------------------------------------------
 38130                                  ;   CopyComponent - copy a file component from a path string (DS:SI) into ES:DI
 38131                                  ;
 38132                                  ;   Inputs:     DS:SI - source path
 38133                                  ;               ES:DI - destination
 38134                                  ;               ES:BP - end of buffer
 38135                                  ;   Outputs:    Carry Set - too long
 38136                                  ;               Carry Clear - DS:SI moved past component
 38137                                  ;                   CX has length of destination
 38138                                  ;   Registers modified: AX,CX,DX
 38139                                  ;----------------------------------------------------------------------------
 38140                                  
 38141                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38142                                  
 38143                                  CopyComponent:
 38144                                  
 38145                                  %define CopyBP	 [BP]		; word
 38146                                  %define CopyD	 [BP+2]		; dword
 38147                                  %define CopyDoff [BP+2]		; word
 38148                                  %define CopyS	 [BP+6]		; dword
 38149                                  %define CopySoff [BP+6]		; word
 38150                                  %define CopyTemp [BP+10]	; byte
 38151                                  
 38152 00006D84 83EC0E                  	SUB     SP,14                   ; room for temp buffer
 38153 00006D87 1E                      	push	ds
 38154 00006D88 56                      	push	si
 38155 00006D89 06                      	push	es
 38156 00006D8A 57                      	push	di
 38157 00006D8B 55                      	push	bp
 38158 00006D8C 89E5                    	MOV     BP,SP
 38159 00006D8E B42E                    	MOV     AH,'.'
 38160 00006D90 AC                      	LODSB
 38161 00006D91 AA                      	STOSB
 38162 00006D92 38E0                    	CMP     AL,AH                   ;   if ((*d++=*s++) == '.') {
 38163 00006D94 7518                    	JNZ	short NormalComp
 38164 00006D96 E8CFFF                  	CALL    PathSep                 ;       if (!pathsep(*s))
 38165 00006D99 740B                    	JZ	short NulTerm
 38166                                  TryTwoDot:
 38167 00006D9B AC                      	LODSB                           ;           if ((*d++=*s++) != '.'
 38168 00006D9C AA                      	STOSB
 38169 00006D9D 38E0                    	CMP     AL,AH
 38170 00006D9F 7557                    	JNZ	short CopyBad
 38171 00006DA1 E8C4FF                  	CALL    PathSep
 38172 00006DA4 7552                    	JNZ	short CopyBad		;               || !pathsep (*s))
 38173                                  NulTerm:                                ;               return -1;
 38174 00006DA6 30C0                    	XOR     AL,AL                   ;       *d++ = 0;
 38175 00006DA8 AA                      	STOSB
 38176 00006DA9 897606                  	MOV     CopySoff,SI
 38177 00006DAC EB47                    	JMP     SHORT _GoodRet		;       }
 38178                                  NormalComp:                             ;   else {
 38179 00006DAE 8B7606                  	MOV     SI,CopySoff ; [bp+6]
 38180 00006DB1 E845E2                  	call	NameTrans               ;       s = NameTrans (s, Name1);
 38181 00006DB4 3B7606                  	CMP     SI,CopySoff             ;       if (s == CopySOff)
 38182 00006DB7 743F                    	JZ	short CopyBad		;           return (-1);
 38183 00006DB9 36F606[7205]FF          	TEST	byte [SS:FSHARING],-1	;       if (!fSharing) {;smr;SS Override
 38184 00006DBF 7510                    	JNZ	short DoPack
 38185 00006DC1 80E201                  	AND     DL,1                    ;           cMeta += fMeta;
 38186 00006DC4 360016[7A05]            	ADD	[ss:CMETA],DL		;           if (cMeta > 0);smr;SS Override
 38187 00006DC9 7F2D                    	JG	short CopyBad		;               return (-1);
 38188 00006DCB 7504                    	JNZ	short DoPack		;           else
 38189 00006DCD 08D2                    	OR      DL,DL                   ;           if (cMeta == 0 && fMeta == 0)
 38190 00006DCF 742F                    	JZ	short CopyBadPath	;               return (-1);
 38191                                  DoPack:                                 ;           }
 38192 00006DD1 897606                  	MOV     CopySoff,SI ; [bp+6]
 38193 00006DD4 16                      	push	ss
 38194 00006DD5 1F                      	pop	ds
 38195 00006DD6 BE[4B05]                	MOV     SI,NAME1
 38196 00006DD9 8D7E0A                  	LEA     DI,CopyTemp ; [bp+10]
 38197 00006DDC 57                      	push	di
 38198 00006DDD E8F7B2                  	call	PackName                ;       PackName (Name1, temp);
 38199 00006DE0 5F                      	pop	di
 38200 00006DE1 E809A4                  	call	StrLen                  ;       if (strlen(temp)+d > bp)
 38201 00006DE4 49                      	DEC     CX
 38202 00006DE5 034E02                  	ADD     CX,CopyDoff ; [bp+2]
 38203                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38204                                  	;cmp	cx,[bp+0]
 38205                                  	; 15/12/2022
 38206                                  	;cmp	cx,[bp]
 38207 00006DE8 3B4E00                  	CMP	CX,CopyBP   ; [bp+0]
 38208 00006DEB 730B                    	JAE	short CopyBad		;           return (-1);
 38209 00006DED 89FE                    	MOV     SI,DI                   ;       strcpy (d, temp);
 38210 00006DEF C47E02                  	LES     DI,CopyD    ; [bp+2]	
 38211 00006DF2 E8EFA3                  	call	FStrCpy
 38212                                  _GoodRet:				;       }
 38213 00006DF5 F8                      	CLC
 38214 00006DF6 EB0B                    	JMP     SHORT CopyEnd           ;   return 0;
 38215                                  CopyBad:
 38216 00006DF8 F9                      	STC
 38217 00006DF9 E8F800                  	CALL    ScanPathChar            ; check for path chars in rest of string
 38218                                  	;mov	al,2
 38219 00006DFC B002                    	MOV     AL,error_file_not_found ; Set up for bad file error
 38220 00006DFE 7503                    	JNZ	short CopyEnd
 38221                                  CopyBadPath:
 38222 00006E00 F9                      	STC
 38223                                  	;mov	al,3
 38224 00006E01 B003                    	MOV     AL,error_path_not_found ; Set bad path error
 38225                                  CopyEnd:
 38226 00006E03 5D                      	pop	bp
 38227 00006E04 5F                      	pop	di
 38228 00006E05 07                      	pop	es
 38229 00006E06 5E                      	pop	si
 38230 00006E07 1F                      	pop	ds
 38231 00006E08 9F                      	LAHF
 38232 00006E09 83C40E                  	ADD     SP,14                   ; reclaim temp buffer
 38233 00006E0C E8DEA3                  	call	StrLen
 38234 00006E0F 49                      	DEC     CX
 38235 00006E10 9E                      	SAHF
 38236 00006E11 C3                      	retn
 38237                                  
 38238                                  ; 14/05/2019 - Retro DOS v4.0
 38239                                  ; DOSCODE:AE22h (MSDOS 6.21, MSDOS.SYS)
 38240                                  
 38241                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38242                                  ; DOSCODE:ADBFh (MSDOS 5.0, MSDOS.SYS)
 38243                                  
 38244                                  ;Break <Splice - pseudo mount by string substitution>
 38245                                  ;----------------------------------------------------------------------------
 38246                                  ;   Splice - take a string and substitute a prefix if one exists. Change
 38247                                  ;       ThisCDS to point to physical drive CDS.
 38248                                  ;   Inputs:     DS:SI point to string
 38249                                  ;               NoSetDir = TRUE => exact matches with splice fail
 38250                                  ;   Outputs:    DS:SI points to thisCDS
 38251                                  ;               ES:DI points to DPB
 38252                                  ;               String at DS:SI may be reduced in length by removing prefix
 38253                                  ;               and substituting drive letter.
 38254                                  ;               CX = 0 If no splice done
 38255                                  ;               CX <> 0 otherwise
 38256                                  ;               ThisCDS points to proper CDS if spliced, otherwise it is
 38257                                  ;                   left alone
 38258                                  ;               ThisDPB points to proper DPB
 38259                                  ;   Registers modified: DS:SI, ES:DI, BX,AX,CX
 38260                                  ;----------------------------------------------------------------------------
 38261                                  
 38262                                  Splice:
 38263 00006E12 36F606[5A00]FF          	TEST	byte [SS:SPLICES],-1	;smr;SS Override
 38264 00006E18 7469                    	JZ	short AllDone
 38265 00006E1A 36FF36[A205]            	push	word [SS:THISCDS]
 38266 00006E1F 36FF36[A405]            	push	word [SS:THISCDS+2]	; TmpCDS = ThisCDS;smr;SS Override
 38267 00006E24 1E                      	push	ds
 38268 00006E25 56                      	push	si
 38269 00006E26 5F                      	pop	di
 38270 00006E27 07                      	pop	es
 38271 00006E28 31C0                    	XOR     AX,AX                   ;   for (i=1; s = GetCDSFromDrv (i); i++)
 38272                                  SpliceScan:
 38273 00006E2A E8DFFC                  	call	GetCDSFromDrv
 38274 00006E2D 724A                    	JC	short SpliceDone
 38275 00006E2F FEC0                    	INC     AL
 38276                                  	; 17/12/2022
 38277                                  	;test	byte [si+68],20h
 38278 00006E31 F6444420                	test	byte [si+curdir.flags+1],curdir_splice>>8 ; 04/12/2022
 38279                                  	;;test	word [si+67],2000h
 38280                                  	;TEST	word [SI+curdir.flags],curdir_splice
 38281 00006E35 74F3                    	JZ	short SpliceScan 	;       if ( Spliced (i) ) {
 38282 00006E37 57                      	push	di
 38283 00006E38 E8A000                  	CALL    PathPref                ;           if (!PathPref (s, d))
 38284 00006E3B 7403                    	JZ	short SpliceFound	;
 38285                                  SpliceSkip:
 38286 00006E3D 5F                      	pop	di
 38287 00006E3E EBEA                    	JMP	short SpliceScan	;               continue;
 38288                                  SpliceFound:
 38289 00006E40 26803D00                	CMP     BYTE [ES:DI],0		;           if (*s || NoSetDir) {
 38290 00006E44 7508                    	JNZ	short SpliceDo
 38291 00006E46 36F606[4C03]FF          	TEST	byte [ss:NoSetDir],-1			;smr;SS Override
 38292 00006E4C 75EF                    	JNZ	short SpliceSkip
 38293                                  SpliceDo:
 38294 00006E4E 89FE                    	MOV     SI,DI                   ;               p = src + strlen (p);
 38295 00006E50 06                      	push	es
 38296 00006E51 1F                      	pop	ds
 38297 00006E52 5F                      	pop	di
 38298 00006E53 E87F00                  	CALL	TextFromDrive1          ;               src = TextFromDrive1(src,i);
 38299 00006E56 36A1[B605]              	MOV     AX,[SS:CURR_DIR_END]			;smr;SS Override
 38300 00006E5A 09C0                    	OR      AX,AX
 38301 00006E5C 7808                    	JS	short NoPoke
 38302 00006E5E 01F8                    	ADD     AX,DI                   ;               curdirend += src-p;
 38303 00006E60 29F0                    	SUB     AX,SI
 38304 00006E62 36A3[B605]              	MOV     [SS:CURR_DIR_END],AX			;smr;SS Override
 38305                                  NoPoke:
 38306 00006E66 803C00                  	CMP     BYTE [SI],0		;               if (*p)
 38307 00006E69 7503                    	JNZ	short SpliceCopy	;                   *src++ = '\\';
 38308 00006E6B B05C                    	MOV     AL,"\"
 38309 00006E6D AA                      	STOSB
 38310                                  SpliceCopy:                             ;               strcpy (src, p);
 38311 00006E6E E873A3                  	call	FStrCpy
 38312 00006E71 83C404                  	ADD     SP,4                    ; throw away saved stuff
 38313 00006E74 80C901                  	OR      CL,1                    ; signal splice done.
 38314 00006E77 EB0C                    	JMP     SHORT DoSet             ;               return;
 38315                                  SpliceDone:                             ;               }
 38316 00006E79 368F06[A405]            	pop	word [SS:THISCDS+2]     ;   ThisCDS = TmpCDS;
 38317 00006E7E 368F06[A205]            	pop	word [SS:THISCDS]			;smr;SS Override
 38318                                  AllDone:
 38319 00006E83 31C9                    	XOR     CX,CX
 38320                                  DoSet:
 38321 00006E85 36C536[A205]            	LDS     SI,[SS:THISCDS]		;   ThisDPB = ThisCDS->devptr;;smr;SS Override
 38322                                  	;les	di,[si+69]
 38323 00006E8A C47C45                  	LES     DI,[SI+curdir.devptr]	
 38324 00006E8D 36893E[8A05]            	MOV	[SS:THISDPB],DI				;smr;SS Override
 38325 00006E92 368C06[8C05]            	MOV	[SS:THISDPB+2],ES			;smr;SS Override
 38326                                  Splice_retn:
 38327 00006E97 C3                      	retn
 38328                                  
 38329                                  ; 15/05/2019 - Retro DOS v4.0
 38330                                  ; DOSCODE:AEA9h (MSDOS 6.21, MSDOS.SYS)
 38331                                  
 38332                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38333                                  ; DOSCODE:AE46h (MSDOS 5.0, MSDOS.SYS)
 38334                                  
 38335                                  ;Break <$NameTrans - partially process a name>
 38336                                  ;----------------------------------------------------------------------------
 38337                                  ;   $NameTrans - allow users to see what names get mapped to. This call
 38338                                  ;   performs only string substitution and canonicalization, not splicing.  Due
 38339                                  ;   to Transpath playing games with devices, we need to insure that the output
 38340                                  ;   has drive letter and : in it.
 38341                                  ;
 38342                                  ;   Inputs:     DS:SI - source string for translation
 38343                                  ;               ES:DI - pointer to buffer
 38344                                  ;   Outputs:
 38345                                  ;       Carry Clear
 38346                                  ;               Buffer at ES:DI is filled in with data
 38347                                  ;               ES:DI point byte after nul byte at end of dest string in buffer
 38348                                  ;       Carry Set
 38349                                  ;               AX = error_path_not_found
 38350                                  ;   Registers modified: all
 38351                                  ;----------------------------------------------------------------------------
 38352                                  
 38353                                  _$NameTrans:
 38354 00006E98 1E                      	push	ds
 38355 00006E99 56                      	push	si
 38356 00006E9A 06                      	push	es
 38357 00006E9B 57                      	push	di
 38358 00006E9C 51                      	push	cx ; MSDOS 6.0
 38359                                  	
 38360                                  	; MSDOS 6.0	
 38361                                  ; M027 - Start
 38362                                  ;
 38363                                  ; Sattrib must be set up with default values here. Otherwise, the value from
 38364                                  ; a previous DOS call is used for attrib and DevName thinks it is not a 
 38365                                  ; device if the old call set the volume attribute bit. Note that devname in
 38366                                  ; dir2.asm gets ultimately called by Transpath. See also M026. Also save
 38367                                  ; and restore CX.
 38368                                  
 38369                                  	;mov	ch,16h
 38370 00006E9D B516                    	mov     ch,attr_hidden+attr_system+attr_directory
 38371 00006E9F E8B902                  	call	SetAttrib
 38372                                  
 38373                                  ; M027 - End
 38374                                  
 38375                                  	; MSDOS 3.3 (& MSDOS 6.0)
 38376 00006EA2 BF[BE03]                	MOV     DI,OPENBUF
 38377 00006EA5 E8E6FC                  	CALL    TransPath               ; to translation (everything)
 38378 00006EA8 59                      	pop	cx ; MSDOS 6.0
 38379 00006EA9 5F                      	pop     di
 38380 00006EAA 07                      	pop	es
 38381 00006EAB 5E                      	pop     si
 38382 00006EAC 1F                      	pop     ds
 38383 00006EAD 7303                    	JNC	short TransOK
 38384 00006EAF E98E97                  	jmp	SYS_RET_ERR
 38385                                  TransOK:
 38386 00006EB2 BE[BE03]                	MOV     SI,OPENBUF
 38387 00006EB5 16                      	push	ss
 38388 00006EB6 1F                      	pop	ds
 38389                                  ;GotText:
 38390 00006EB7 E82AA3                  	call	FStrCpy
 38391 00006EBA E97A97                  	jmp	SYS_RET_OK
 38392                                  
 38393                                  ;Break   <DriveFromText - return drive number from a text string>
 38394                                  ;----------------------------------------------------------------------------
 38395                                  ;   DriveFromText - examine DS:SI and remove a drive letter, advancing the
 38396                                  ;   pointer.
 38397                                  ;
 38398                                  ;   Inputs:     DS:SI point to a text string
 38399                                  ;   Outputs:    AL has drive number
 38400                                  ;               DS:SI advanced
 38401                                  ;   Registers modified: AX,SI.
 38402                                  ;----------------------------------------------------------------------------
 38403                                  
 38404                                  DriveFromText:
 38405 00006EBD 30C0                    	XOR     AL,AL                   ;       drive = 0;
 38406                                  	;CMP	BYTE [SI],0		;       if (*s &&
 38407                                  	; 23/09/2023
 38408 00006EBF 3804                    	cmp	[si],al ; 0
 38409 00006EC1 74D4                    	jz	short Splice_retn
 38410 00006EC3 807C013A                	CMP     BYTE [SI+1],':'		;           s[1] == ':') {
 38411 00006EC7 75CE                    	jnz	short Splice_retn
 38412 00006EC9 AD                      	LODSW                           ;           drive = (*s | 020) - 'a'+1;
 38413 00006ECA 0C20                    	OR      AL,20h
 38414                                  	;sub	al,60h
 38415 00006ECC 2C60                    	SUB     AL,'a'-1                ;           s += 2;
 38416 00006ECE 75C7                    	jnz	short Splice_retn
 38417 00006ED0 B0FF                    	MOV	AL,-1                   ; nuke AL...
 38418                                  	; 23/09/2023
 38419                                  	;dec	al ; -1
 38420 00006ED2 C3                      	retn				;           }
 38421                                  
 38422                                  ;Break   <TextFromDrive - convert a drive number to a text string>
 38423                                  ;----------------------------------------------------------------------------
 38424                                  ;   TextFromDrive - turn AL into a drive letter: and put it at es:di with
 38425                                  ;   trailing :. TextFromDrive1 takes a 1-based number.
 38426                                  ;
 38427                                  ;   Inputs:     AL has 0-based drive number
 38428                                  ;   Outputs:    ES:DI advanced
 38429                                  ;   Registers modified: AX
 38430                                  ;----------------------------------------------------------------------------
 38431                                  
 38432                                  TextFromDrive:
 38433 00006ED3 FEC0                    	INC     AL
 38434                                  TextFromDrive1:
 38435                                  	;add	al,40h
 38436 00006ED5 0440                    	ADD     AL,'A'-1                ;   *d++ = drive-1+'A';
 38437 00006ED7 B43A                    	MOV     AH,":"	; 3Ah           ;   strcat (d, ":");
 38438 00006ED9 AB                      	STOSW
 38439                                  PathPref_retn:
 38440 00006EDA C3                      	retn
 38441                                  
 38442                                  ;Break   <PathPref - see if one path is a prefix of another>
 38443                                  ;----------------------------------------------------------------------------
 38444                                  ;   PathPref - compare DS:SI with ES:DI to see if one is the prefix of the
 38445                                  ;   other.  Remember that only at a pathchar break are we allowed to have a
 38446                                  ;   prefix: A:\ and A:\FOO
 38447                                  ;
 38448                                  ;   Inputs:     DS:SI potential prefix
 38449                                  ;               ES:DI string
 38450                                  ;   Outputs:    Zero set => prefix found
 38451                                  ;                   DI/SI advanced past matching part
 38452                                  ;               Zero reset => no prefix, DS/SI garbage
 38453                                  ;   Registers modified: CX
 38454                                  ;----------------------------------------------------------------------------
 38455                                  
 38456                                  PathPref:
 38457 00006EDB E81DA3                  	call	DStrLen                 ; get length
 38458 00006EDE 49                      	DEC     CX                      ; do not include nul byte
 38459 00006EDF F3A6                    	REPZ    CMPSB                   ; compare
 38460 00006EE1 75F7                    	jnz	short PathPref_retn	; if NZ then return NZ
 38461 00006EE3 50                      	push	ax			; save char register
 38462 00006EE4 8A44FF                  	MOV     AL,[SI-1]               ; get last byte to match
 38463 00006EE7 E8D1E1                  	call    PATHCHRCMP              ; is it a path char (Root!)
 38464 00006EEA 7406                    	JZ	short Prefix		; yes, match root (I hope)
 38465                                  NotSep:                                 ; 2/13/KK
 38466 00006EEC 268A05                  	MOV     AL,[ES:DI]		; get next char to match
 38467 00006EEF E878FE                  	CALL    PathSepGotCh            ; was it a pathchar?
 38468                                  Prefix:
 38469 00006EF2 58                      	pop	ax			; get back original
 38470 00006EF3 C3                      	retn
 38471                                  
 38472                                  ;Break   <ScanPathChar - see if there is a path character in a string>
 38473                                  ;----------------------------------------------------------------------------
 38474                                  ;     ScanPathChar - search through the string (pointed to by DS:SI) for
 38475                                  ;     a path separator.
 38476                                  ;
 38477                                  ;     Input:    DS:SI target string (null terminated)
 38478                                  ;     Output:   Zero set => path separator encountered in string
 38479                                  ;               Zero clear => null encountered
 38480                                  ;     Registers modified: SI
 38481                                  ;----------------------------------------------------------------------------
 38482                                  
 38483                                  ScanPathChar:
 38484 00006EF4 AC                      	LODSB                           ; fetch a character
 38485 00006EF5 E872FE                  	call    PathSepGotCh
 38486 00006EF8 75FA                    	JNZ	short ScanPathChar	; not \, / or NUL => go back for more
 38487                                  	;call	PATHCHRCMP              ; path separator?
 38488                                  	;retn
 38489                                  	; 18/12/2022
 38490 00006EFA E9BEE1                  	jmp	PATHCHRCMP
 38491                                  
 38492                                  ;============================================================================
 38493                                  ; FILE.ASM, MSDOS 6.0, 1991
 38494                                  ;============================================================================
 38495                                  ; 14/07/2018 - Retro DOS v3.0
 38496                                  
 38497                                  ; 13/05/2019 - Retro DOS v4.0
 38498                                  ; DOSCODE:AF10h (MSDOS 6.21, MSDOS.SYS)
 38499                                  
 38500                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38501                                  ; DOSCODE:AEADh (MSDOS 5.0, MSDOS.SYS)
 38502                                  
 38503                                  ; MSDOS 2.11
 38504                                  ;BREAK <$Open - open a file handle>
 38505                                  ;----------------------------------------------------------------------------
 38506                                  ;   Assembler usage:
 38507                                  ;           LDS     DX, Name
 38508                                  ;           MOV     AH, Open
 38509                                  ;           MOV     AL, access
 38510                                  ;           INT     int_command
 38511                                  ;
 38512                                  ;       ACCESS          Function
 38513                                  ;       ------          --------
 38514                                  ;       open_for_read   file is opened for reading
 38515                                  ;       open_for_write  file is opened for writing
 38516                                  ;       open_for_both   file is opened for both reading and writing.
 38517                                  ;
 38518                                  ;   Error returns:
 38519                                  ;           AX = error_invalid_access
 38520                                  ;              = error_file_not_found
 38521                                  ;              = error_access_denied
 38522                                  ;              = error_too_many_open_files
 38523                                  ;----------------------------------------------------------------------------
 38524                                  
 38525                                  ; MSDOS 6.0
 38526                                  ;	BREAK <$Open - open a file from a path string>
 38527                                  ;----------------------------------------------------------------------------
 38528                                  ;
 38529                                  ;**	$OPen - Open a File
 38530                                  ;
 38531                                  ;	given a path name in DS:DX and an open mode in AL, $Open opens the
 38532                                  ;	file and and returns a handle
 38533                                  ;
 38534                                  ;	ENTRY	(DS:DX) = pointer to asciz name
 38535                                  ;		(AL) = open mode
 38536                                  ;	EXIT	'C' clear if OK
 38537                                  ;		  (ax) = file handle
 38538                                  ;		'C' set if error
 38539                                  ;		  (ax) = error code
 38540                                  ;	USES	all
 38541                                  ;
 38542                                  ;----------------------------------------------------------------------------
 38543                                  
 38544                                  ; 13/05/2019 - Retro DOS v4.0
 38545                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38546                                  
 38547                                  _$OPEN:       
 38548 00006EFD 30E4                    	xor	ah,ah  ; MSDOS 6.0	
 38549                                  _$Open2:
 38550                                  	;mov	ch,16h
 38551 00006EFF B516                    	mov	ch,attr_hidden+attr_system+attr_directory
 38552 00006F01 E85702                  	call	SetAttrib
 38553 00006F04 B9[9B2B]                	mov	cx,DOS_OPEN
 38554                                  
 38555                                  	;xor	ah,ah  ; MSDOS 3.3
 38556                                  
 38557 00006F07 50                      	push	ax
 38558                                  
 38559                                  ;*	General file open/create code. The $CREATE call and the various
 38560                                  ;	$OPEN calls all come here.
 38561                                  ;
 38562                                  ;	We'll share a lot of the standard stuff of allocating SFTs, cracking
 38563                                  ;	path names, etc., and then dispatch to our individual handlers.
 38564                                  ;	WARNING - this info and list is just a guess, not definitive - jgl
 38565                                  ;
 38566                                  ;	(TOS) = create mode
 38567                                  ;	(CX) = address of routine to call to do actual function
 38568                                  ;	(DS:DX) = ASCIZ name
 38569                                  ;	SAttrib = Attribute mask
 38570                                  
 38571                                  ;	Get a free SFT and mark it "being allocated"
 38572                                  
 38573                                  AccessFile:
 38574 00006F08 E806A4                  	call	ECritSFT
 38575 00006F0B E8D8F7                  	call	SFNFree			; get a free sfn
 38576 00006F0E E81BA4                  	call	LCritSFT
 38577 00006F11 7214                    	jc	short OpenFailJ		; oops, no free sft's
 38578 00006F13 36891E[AA05]            	MOV	[SS:SFN],BX		; save the SFN for later;smr;SS Override
 38579 00006F18 36893E[9E05]            	MOV	[SS:THISSFT],DI		; save the SF offset	;smr;SS Override
 38580 00006F1D 368C06[A005]            	MOV	[SS:THISSFT+2],ES	; save the SF segment	;smr;SS Override
 38581                                  
 38582                                  ;	Find a free area in the user's JFN table.
 38583                                  
 38584 00006F22 E8AEF7                  	call	JFNFree			; get a free jfn
 38585 00006F25 7303                    	jnc	short SaveJFN
 38586                                  OpenFailJ:
 38587 00006F27 E99300                  	JMP	OpenFail		; there were free JFNs... try SFN
 38588                                  
 38589                                  SaveJFN:
 38590 00006F2A 36893E[AE05]            	mov	[ss:PJFN],DI		; save the jfn offset	;smr;SS Override
 38591 00006F2F 368C06[B005]            	MOV	[ss:PJFN+2],ES		; save the jfn segment	;smr;SS Override
 38592 00006F34 36891E[AC05]            	MOV	[ss:JFN],BX		; save the jfn itself	;smr;SS Override
 38593                                  
 38594                                  ;	We have been given an JFN. We lock it down to prevent other tasks from
 38595                                  ;	reusing the same JFN.
 38596                                  
 38597 00006F39 368B1E[AA05]            	MOV	BX,[ss:SFN]					;smr;SS Override
 38598 00006F3E 26881D                  	MOV	[ES:DI],BL		; assign the JFN
 38599 00006F41 89D6                    	MOV	SI,DX			; get name in appropriate place
 38600 00006F43 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 38601 00006F46 51                      	push	cx			; save routine to call
 38602 00006F47 E844FC                  	call	TransPath		; convert the path
 38603 00006F4A 5B                      	pop	bx			; (bx) = routine to call
 38604                                  
 38605 00006F4B 36C536[9E05]            	LDS	SI,[SS:THISSFT]					;smr;SS Override
 38606 00006F50 720A                    	JC	short OpenCleanJ	; no error, go and open file
 38607 00006F52 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1				;smr;SS Override
 38608 00006F58 7404                    	JZ	short SetSearch
 38609                                  	;mov	al,2
 38610 00006F5A B002                    	MOV	AL,error_file_not_found ; no meta chars allowed
 38611                                  OpenCleanJ:
 38612 00006F5C EB50                    	JMP	short OpenClean
 38613                                  
 38614                                  SetSearch:
 38615 00006F5E 58                      	pop	ax			; Mode (Open), Attributes (Create)
 38616                                  
 38617                                  ;	We need to get the new inheritance bits.
 38618                                  
 38619 00006F5F 31C9                    	xor	cx,cx
 38620                                  	; MSDOS 6.0
 38621                                  	;mov	[si+2],cx ; 0
 38622 00006F61 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],cx ; initialize mode field to 0
 38623                                  	;mov    [si+51],cx ; 0
 38624 00006F64 894C33                  	MOV	[SI+SF_ENTRY.sf_MFT],cx	 ; clean out sharing info
 38625                                  	;
 38626 00006F67 81FB[9B2B]              	CMP	BX,DOS_OPEN
 38627 00006F6B 7509                    	JNZ	short _DoOper
 38628                                  	;test   al,80h
 38629 00006F6D A880                    	test	AL,SHARING_NO_INHERIT	; look for no inher
 38630 00006F6F 7405                    	JZ	short _DoOper ; 10/08/2018
 38631 00006F71 247F                    	AND	AL,7Fh			; mask off inherit bit
 38632                                  	;mov	cx,1000h
 38633 00006F73 B90010                  	MOV	CX,sf_no_inherit
 38634                                  _DoOper:
 38635                                  	;; MSDOS 3.3
 38636                                  	;;mov	word [si+2], 0
 38637                                  	;;mov	word [si+33h], 0
 38638                                  	;MOV	word [SI+SF_ENTRY.sf_mode],0
 38639                                  	;MOV	word [SI+SF_ENTRY.sf_MFT],0
 38640                                  
 38641                                  	; MSDOS 6.0
 38642                                  ;**	Check if this is an extended open. If so you must set the
 38643                                  ;	modes in sf_mode. Call Set_EXT_mode to do all this. See
 38644                                  ;	Set_EXT_mode in creat.asm
 38645                                  
 38646                                  	; MSDOS 6.0
 38647                                  	;SAVE	<di, es>                ;M022 conditional removed here
 38648 00006F76 57                      	push	di
 38649 00006F77 06                      	push	es
 38650 00006F78 1E                      	push	ds
 38651 00006F79 07                      	pop	es
 38652 00006F7A 56                      	push	si
 38653 00006F7B 5F                      	pop	di			; (es:di) = SFT address
 38654 00006F7C E808BC                  	call	Set_EXT_mode
 38655                                  	;RESTORE <es, di>
 38656 00006F7F 07                      	pop	es
 38657 00006F80 5F                      	pop	di
 38658                                  
 38659                                  	;Context DS
 38660 00006F81 16                      	push	ss
 38661 00006F82 1F                      	pop	ds	
 38662                                  
 38663 00006F83 51                      	push	cx
 38664 00006F84 FFD3                    	CALL	BX			; blam!
 38665 00006F86 59                      	pop	cx
 38666 00006F87 C536[9E05]              	LDS	SI,[THISSFT]
 38667 00006F8B 721A                    	JC	short OpenE2		;AN000;FT. chek extended open hooks first
 38668                                  	;jc	short OpenE ; MSDOS 3.3
 38669                                  
 38670                                  ;	The SFT was successfully opened. Remove busy mark.
 38671                                  
 38672                                  OpenOK:
 38673                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],1
 38674 00006F8D C7040100                	mov	word [SI],1
 38675                                  	;or	[SI+5],cx
 38676 00006F91 094C05                  	OR	[SI+SF_ENTRY.sf_flags],CX ; set no inherit bit if necessary
 38677                                  
 38678                                  ; If the open mode is 70, we scan the system for other SFT's with the same
 38679                                  ; contents. If we find one, then we can 'collapse' thissft onto the already
 38680                                  ; opened one. Otherwise we use this new one. We compare uid/pid/mode/mft
 38681                                  ;
 38682                                  ; Since this is only relevant on sharer systems, we stick this code into the
 38683                                  ; sharer.
 38684                                  
 38685 00006F94 36A1[AC05]              	MOV	AX,[ss:JFN]				;smr;SS Override
 38686 00006F98 36FF1E[C000]            	Call	far [ss:JShare+(12*4)]	; 12 = ShCol	;smr;SS Override
 38687                                  
 38688 00006F9D 36C706[AA05]FFFF        	MOV	word [ss:SFN],-1	; clear out sfn pointer	;smr;SS Override
 38689                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38690                                  OpenOkj:
 38691 00006FA4 E99096                  	jmp	SYS_RET_OK		; bye with no errors
 38692                                  
 38693                                  	; MSDOS 6.0
 38694                                  ;Extended Open hooks check
 38695                                  OpenE2:					;AN000;;EO.
 38696 00006FA7 83F857                  	CMP	AX,error_invalid_parameter ;AN000;;EO. IFS extended open ?
 38697 00006FAA 7503                    	JNZ	short OpenE		;AN000;;EO. no.
 38698 00006FAC EB11                    	JMP	short OpenCritLeave	;AN000;;EO. keep handle
 38699                                  
 38700                                  ;	Extended Open hooks check
 38701                                  ;
 38702                                  ;	AL has error code.  Stack has argument to dos_open/dos_create.
 38703                                  
 38704                                  OpenClean:
 38705 00006FAE 5B                      	pop	bx			; clean off stack
 38706                                  OpenE:
 38707                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],0 ; release SFT
 38708 00006FAF C7040000                	mov	word [SI],0
 38709 00006FB3 36C536[AE05]            	LDS	SI,[ss:PJFN]		;smr;SS Override
 38710 00006FB8 C604FF                  	MOV	BYTE [SI],0FFh		; free the SFN...
 38711 00006FBB EB02                    	JMP	SHORT OpenCritLeave
 38712                                  
 38713                                  OpenFail:
 38714 00006FBD FB                      	STI
 38715 00006FBE 59                      	pop	cx			; Clean stack
 38716                                  OpenCritLeave:
 38717 00006FBF 36C706[AA05]FFFF        	MOV	word [SS:SFN],-1	; remove mark.
 38718                                  
 38719                                  	; MSDOS 6.0
 38720                                  ; File Tagging DOS 4.00
 38721 00006FC6 36833E[2403]25          	CMP	word [SS:EXTERR],error_Code_Page_Mismatched
 38722                                  					;AN000;;FT. code page mismatch
 38723 00006FCC 7503                    	JNZ	short NORERR	  	;AN000;;FT. no
 38724 00006FCE E97796                  	jmp	From_GetSet		;AN000;;FT. yes
 38725                                  NORERR: 				;AN000;
 38726                                  ; File Tagging DOS 4.00
 38727                                  
 38728 00006FD1 E96C96                  	jmp	SYS_RET_ERR		; no free, return error
 38729                                  
 38730                                  ; MSDOS 2.11
 38731                                  ;BREAK <$CREAT - creat a new file and open him for input>
 38732                                  ;----------------------------------------------------------------------------
 38733                                  ;   Assembler usage:
 38734                                  ;           LDS     DX, name
 38735                                  ;           MOV     AH, Creat
 38736                                  ;           MOV     CX, access
 38737                                  ;           INT     21h
 38738                                  ;       ; AX now has the handle
 38739                                  ;
 38740                                  ;   Error returns:
 38741                                  ;           AX = error_access_denied
 38742                                  ;              = error_path_not_found
 38743                                  ;              = error_too_many_open_files
 38744                                  ;----------------------------------------------------------------------------
 38745                                  
 38746                                  ; MSDOS 6.0
 38747                                  ;	BREAK <$Creat - create a brand-new file>
 38748                                  ;----------------------------------------------------------------------------
 38749                                  ;
 38750                                  ;**	$Creat - Create a File
 38751                                  ;
 38752                                  ;	$Creat creates the directory entry specified in DS:DX and gives it the
 38753                                  ;	initial attributes contained in CX
 38754                                  ;
 38755                                  ;	ENTRY	(DS:DX) = ASCIZ path name
 38756                                  ;		(CX) = initial attributes
 38757                                  ;	EXIT	'C' set if error
 38758                                  ;		  (ax) = error code
 38759                                  ;		'C' clear if OK
 38760                                  ;		  (ax) = file handle
 38761                                  ;	USES	all
 38762                                  ;
 38763                                  ;----------------------------------------------------------------------------
 38764                                  
 38765                                  _$CREAT:
 38766 00006FD4 51                      	push	cx			; Save attributes on stack
 38767 00006FD5 B9[712A]                	mov	CX,DOS_CREATE		; routine to call
 38768                                  AccessSet:
 38769                                  	;mov	byte [ss:SATTRIB],6
 38770 00006FD8 36C606[6D05]06          	mov	byte [ss:SATTRIB],attr_hidden+attr_system ;smr;SS Override
 38771                                  	; 10/08/2018
 38772 00006FDE E927FF                  	JMP	AccessFile		; use good ol' open
 38773                                  
 38774                                  ; MSDOS 6.0 (MSDOS 3.3)
 38775                                  ;	BREAK <$CHMOD - change file attributes>
 38776                                  ;----------------------------------------------------------------------------
 38777                                  ;
 38778                                  ;**	$CHMOD - Change File Attributes
 38779                                  ;
 38780                                  ;   Assembler usage:
 38781                                  ;	    LDS     DX, name
 38782                                  ;	    MOV     CX, attributes
 38783                                  ;	    MOV     AL,func (0=get, 1=set)
 38784                                  ;	    INT     21h
 38785                                  ;   Error returns:
 38786                                  ;	    AX = error_path_not_found
 38787                                  ;	    AX = error_access_denied
 38788                                  ;
 38789                                  ;----------------------------------------------------------------------------
 38790                                  
 38791                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38792                                  _$CHMOD:
 38793                                  	; 05/08/2018 - Retro DOS v3.0
 38794                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6FCCh ,
 38795 00006FE1 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 38796 00006FE4 50                      	push	ax
 38797 00006FE5 51                      	push	cx			; save function and attributes
 38798 00006FE6 89D6                    	MOV	SI,DX			; get things in appropriate places
 38799 00006FE8 E8A7FB                  	call	TransPathSet		; get correct path
 38800 00006FEB 59                      	pop	cx
 38801 00006FEC 58                      	pop	ax			; and get function and attrs back
 38802 00006FED 7257                    	JC	short ChModErr		; errors get mapped to path not found
 38803 00006FEF 16                      	push	ss			; set up for later possible calls
 38804 00006FF0 1F                      	pop	ds
 38805 00006FF1 803E[7A05]FF            	CMP	byte [CMETA],-1
 38806 00006FF6 754E                    	JNZ	short ChModErr
 38807                                  	;mov	byte [SATTRIB],16h
 38808 00006FF8 C606[6D05]16            	MOV	byte [SATTRIB],attr_hidden+attr_system+attr_directory
 38809 00006FFD 2C01                    	SUB	AL,1			; fast way to discriminate
 38810 00006FFF 720B                    	JB	short ChModGet		; 0 -> go get value
 38811 00007001 7417                    	JZ	short ChModSet		; 1 -> go set value
 38812                                  	;mov	byte [EXTERR_LOCUS],1
 38813 00007003 C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 38814                                  	;mov	al,1
 38815 00007008 B001                    	mov	al,error_invalid_function ; bad value
 38816                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38817                                  chmod_errj:	
 38818                                  	;;jmp	SYS_RET_ERR
 38819                                  	;jmp	short ChModE	
 38820 0000700A EBC5                    	jmp	short NORERR	; 06/12/2022
 38821                                  ChModGet:
 38822 0000700C E84CB9                  	call	GET_FILE_INFO		; suck out the ol' info
 38823 0000700F 7237                    	JC	short ChModE		; error codes are already set for ret
 38824 00007011 E86D94                  	call	Get_User_Stack		; point to user saved vaiables
 38825                                  	;mov	[SI+4],ax
 38826 00007014 894404                  	MOV	[SI+user_env.user_CX],AX ; return the attributes
 38827                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
 38828                                  OpenOkj2:
 38829                                  	; 17/12/2022
 38830                                  	;;jmp	SYS_RET_OK		; say sayonara
 38831                                  	;jmp	short OpenOkj
 38832                                  	; 25/06/2019
 38833 00007017 E92096                  	jmp	SYS_RET_OK_clc
 38834                                  
 38835                                  ChModSet:
 38836 0000701A 89C8                    	MOV	AX,CX			; get attrs in position
 38837 0000701C E89AB9                  	call	SET_FILE_ATTRIBUTE	; go set
 38838 0000701F 7227                    	JC	short ChModE		; errors are set
 38839                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
 38840                                  	;jmp	SYS_RET_OK
 38841                                  OpenOkj3:
 38842                                  	;jmp	short OpenOkj2
 38843                                  	; 17/12/2022
 38844 00007021 E91396                  	jmp	SYS_RET_OK
 38845                                  
 38846                                  ; 17/12/2022
 38847                                  %if 0
 38848                                  ChModErr:
 38849                                  NotFound:	; 17/12/2022
 38850                                  	;mov	al,3
 38851                                  	mov	al,error_path_not_found
 38852                                  ChModE:
 38853                                  UnlinkE:	; 17/12/2022
 38854                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38855                                  	;;jmp	SYS_RET_ERR
 38856                                  	;jmp	short chmod_errj
 38857                                  	; 17/12/2022
 38858                                  	jmp	short NORERR
 38859                                  %endif
 38860                                  
 38861                                  ; 22/05/2019 - Retro DOS v4.0
 38862                                  ; DOSCODE:B039h (MSDOS 6.21, MSDOS.SYS)
 38863                                  
 38864                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38865                                  ; DOSCODE:AFD6h (MSDOS 5.0, MSDOS.SYS)
 38866                                  
 38867                                  ;	BREAK <$UNLINK - delete a file entry>
 38868                                  ;----------------------------------------------------------------------------
 38869                                  ;
 38870                                  ;**	$UNLINK - Delete a File
 38871                                  ;
 38872                                  ;
 38873                                  ;	Assembler usage:
 38874                                  ;	    LDS     DX, name
 38875                                  ;	    IF VIA SERVER DOS CALL
 38876                                  ;	     MOV     CX,SEARCH_ATTRIB
 38877                                  ;	    MOV     AH, Unlink
 38878                                  ;	    INT     21h
 38879                                  ;
 38880                                  ;	ENTRY	(ds:dx) = path name
 38881                                  ;		(cx) = search_attribute, if via server_dos
 38882                                  ;	EXIT	'C' clear if no error
 38883                                  ;		'C' set if error
 38884                                  ;		  (ax) = error code
 38885                                  ;			= error_file_not_found
 38886                                  ;			= error_access_denied
 38887                                  ;
 38888                                  ;----------------------------------------------------------------------------
 38889                                  
 38890                                  _$UNLINK:
 38891 00007024 51                      	push	cx			; Save possible CX input parm
 38892 00007025 89D6                    	MOV	SI,DX			; Point at input string
 38893 00007027 BF[BE03]                	MOV	DI,OPENBUF		; temp spot for path
 38894 0000702A E865FB                  	call	TransPathSet		; go get normalized path
 38895 0000702D 59                      	pop	cx
 38896 0000702E 7216                    	JC	short ChModErr		; badly formed path
 38897 00007030 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1	; meta chars?	;smr;SS Override
 38898 00007036 750E                    	JNZ	short NotFound
 38899 00007038 16                      	push	ss
 38900 00007039 1F                      	pop	ds
 38901                                  	;mov	ch,6
 38902 0000703A B506                    	mov	ch,attr_hidden+attr_system ; unlink appropriate files
 38903 0000703C E81C01                  	call	SetAttrib
 38904 0000703F E809B5                  	call	DOS_DELETE		; remove that file
 38905                                  	;JC	short UnlinkE 		; error is there
 38906                                  	; 17/12/2022
 38907 00007042 728D                    	jc	short NORERR
 38908                                  
 38909                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38910                                  UnlinkOk:
 38911                                  	;jmp	SYS_RET_OK		; okey doksy
 38912 00007044 EBDB                    	jmp	short OpenOkj3
 38913                                  
 38914                                  	; 17/12/2022
 38915                                  ChModErr:	; 17/12/2022
 38916                                  NotFound:
 38917                                  	;mov	al,3
 38918 00007046 B003                    	MOV	AL,error_path_not_found
 38919                                  ChModE:		; 17/12/2022
 38920                                  UnlinkE:
 38921                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38922                                  	;;jmp	SYS_RET_ERR		; bye
 38923                                  	;jmp	short ChModE
 38924                                  	; 17/12/2022
 38925 00007048 EB87                    	jmp	short NORERR
 38926                                  
 38927                                  ;BREAK <$RENAME - move directory entries around>
 38928                                  ;----------------------------------------------------------------------------
 38929                                  ;
 38930                                  ;   Assembler usage:
 38931                                  ;	    LDS     DX, source
 38932                                  ;	    LES     DI, dest
 38933                                  ;	    IF VIA SERVER DOS CALL
 38934                                  ;	      MOV   CX,SEARCH_ATTRIB
 38935                                  ;	    MOV     AH, Rename
 38936                                  ;	    INT     21h
 38937                                  ;
 38938                                  ;   Error returns:
 38939                                  ;	    AX = error_file_not_found
 38940                                  ;	       = error_not_same_device
 38941                                  ;	       = error_access_denied
 38942                                  ;
 38943                                  ;----------------------------------------------------------------------------
 38944                                  
 38945                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38946                                  _$RENAME:
 38947                                  	; MSDOS 3.3 (& MSDOS 6.0)
 38948 0000704A 51                      	push	cx
 38949 0000704B 1E                      	push	ds
 38950 0000704C 52                      	push	dx			; save source and possible CX arg
 38951 0000704D 06                      	PUSH	ES
 38952 0000704E 1F                      	POP	DS			; move dest to source
 38953 0000704F 89FE                    	MOV	SI,DI			; save for offsets
 38954 00007051 BF[3E04]                	MOV	DI,RENBUF
 38955 00007054 E83BFB                  	call	TransPathSet		; munge the paths
 38956 00007057 36FF36[B205]            	PUSH	word [ss:WFP_START]	; get pointer	;smr;SS Override
 38957 0000705C 368F06[B405]            	POP	word [ss:REN_WFP]	; stash it	;smr;SS Override
 38958 00007061 5E                      	pop	si
 38959 00007062 1F                      	pop	ds
 38960 00007063 59                      	pop	cx			; get back source and possible CX arg
 38961                                  epjc2:	
 38962 00007064 72E0                    	JC	short ChModErr		; get old error
 38963 00007066 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1			;smr;SS Override
 38964 0000706C 75D8                    	JNZ	short NotFound
 38965 0000706E 51                      	push	cx			; Save possible CX arg
 38966 0000706F BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 38967 00007072 E81DFB                  	call	TransPathSet		; wham
 38968 00007075 59                      	pop	cx
 38969 00007076 72EC                    	JC	short epjc2
 38970 00007078 16                      	push	ss
 38971 00007079 1F                      	pop	ds
 38972 0000707A 803E[7A05]FF            	CMP	byte [CMETA],-1
 38973 0000707F 72C5                    	JB	short NotFound
 38974                                  
 38975                                  	; MSDOS 6.0
 38976 00007081 FF36[A205]              	PUSH	WORD [THISCDS]		   ;AN000;;MS.save thiscds
 38977 00007085 FF36[A405]              	PUSH	WORD [THISCDS+2]	   ;AN000;;MS.
 38978 00007089 BF[BE03]                	MOV	DI,OPENBUF		   ;AN000;;MS.
 38979 0000708C 16                      	PUSH	SS			   ;AN000;;MS.
 38980 0000708D 07                      	POP	ES			   ;AN000;;MS.es:di-> source
 38981 0000708E 30C0                    	XOR	AL,AL			   ;AN000;;MS.scan all CDS
 38982                                  rnloop: 				   ;AN000;
 38983 00007090 E879FA                  	call	GetCDSFromDrv		   ;AN000;;MS.
 38984 00007093 7210                    	JC	short dorn		   ;AN000;;MS.	end of CDS
 38985 00007095 E81BA1                  	call	StrCmp			   ;AN000;;MS.	current dir ?
 38986 00007098 7404                    	JZ	short rnerr		   ;AN000;;MS.	yes
 38987 0000709A FEC0                    	INC	AL			   ;AN000;;MS.	next
 38988 0000709C EBF2                    	JMP	short rnloop		   ;AN000;;MS.
 38989                                  rnerr:					   ;AN000;
 38990 0000709E 83C404                  	ADD	SP,4			   ;AN000;;MS. pop thiscds
 38991                                  	;error	error_current_directory    ;AN000;;MS.
 38992 000070A1 B010                    	mov	al,error_current_directory 
 38993                                  	;jmp	SYS_RET_ERR
 38994                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38995 000070A3 EBA3                    	jmp	short UnlinkE
 38996                                  dorn:					   ;AN000;
 38997 000070A5 368F06[A405]            	POP	WORD [SS:THISCDS+2]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 38998 000070AA 368F06[A205]            	POP	WORD [SS:THISCDS]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 38999                                  
 39000 000070AF 16                      	push	ss
 39001 000070B0 1F                      	pop	ds
 39002                                  
 39003                                  	; MSDOS 3.3 (& MSDOS 6.0)
 39004                                  	;mov	ch,16h
 39005 000070B1 B516                    	mov	ch,attr_directory+attr_hidden+attr_system
 39006                                  					; rename appropriate files
 39007 000070B3 E8A500                  	call	SetAttrib
 39008 000070B6 E870B6                  	call	DOS_RENAME		; do the deed
 39009 000070B9 728D                    	JC	short UnlinkE 		; errors
 39010                                  
 39011                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39012                                  	;jmp	SYS_RET_OK
 39013 000070BB EB87                    	jmp	short UnlinkOk
 39014                                  
 39015                                  
 39016                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39017                                  
 39018                                  ; 14/07/2018 - Retro DOS v3.0
 39019                                  ; MSDOS 3.3 (& MSDOS 6.0)
 39020                                  
 39021                                  ;Break <$CreateNewFile - Create a new directory entry>
 39022                                  ;----------------------------------------------------------------------------
 39023                                  ;   CreateNew - Create a new directory entry.  Return a file handle if there
 39024                                  ;	was no previous directory entry, and fail if a directory entry with
 39025                                  ;	the same name existed previously.
 39026                                  ;
 39027                                  ;   Inputs:	DS:DX point to an ASCIZ file name
 39028                                  ;		CX contains default file attributes
 39029                                  ;   Outputs:	Carry Clear:
 39030                                  ;		    AX has file handle opened for read/write
 39031                                  ;		Carry Set:
 39032                                  ;		    AX has error code
 39033                                  ;   Registers modified: All
 39034                                  ;----------------------------------------------------------------------------
 39035                                  
 39036                                  _$CreateNewFile:
 39037 000070BD 51                      	push	cx			; Save attributes on stack
 39038 000070BE B9[3E2B]                	MOV	CX,DOS_Create_New	; routine to call
 39039 000070C1 E914FF                  	JMP	AccessSet		; use good ol' open
 39040                                  
 39041                                  ;**	BinToAscii - convert a number to a string.
 39042                                  ;----------------------------------------------------------------------------
 39043                                  ;	BinToAscii converts a 16 bit number into a 4 ascii characters.
 39044                                  ;	This routine is used to generate temp file names so we don't spend
 39045                                  ;	the time and code needed for a true hex number, we just use
 39046                                  ;	A thorugh O.
 39047                                  ;
 39048                                  ;	ENTRY	(ax) = value
 39049                                  ;		(es:di) = destination
 39050                                  ;	EXIT	(es:di) updated by 4
 39051                                  ;	USES	cx, di, flags
 39052                                  ;----------------------------------------------------------------------------
 39053                                  
 39054                                  ; MSDOS 3.3
 39055                                  ;BinToAscii:
 39056                                  ;	mov     cx,4
 39057                                  ;bta5:
 39058                                  ;	push    cx
 39059                                  ;	mov     cl,4
 39060                                  ;	rol     ax,cl
 39061                                  ;	push    ax
 39062                                  ;	and     al,0Fh
 39063                                  ;	add     al,'0'
 39064                                  ;	cmp     al,'9'
 39065                                  ;	jbe     short bta6
 39066                                  ;	add     al,7
 39067                                  ;bta6: 
 39068                                  ;	stosb
 39069                                  ;	pop     ax
 39070                                  ;	pop     cx
 39071                                  ;	loop    bta5
 39072                                  ;	retn
 39073                                  
 39074                                  ; MSDOS 6.0
 39075                                  BinToAscii:
 39076 000070C4 B90404                  	mov	cx,404h			; (ch) = digit counter, (cl) = shift cnt
 39077                                  bta5:	
 39078 000070C7 D3C0                    	ROL	AX,CL			; move leftmost nibble into rightmost
 39079 000070C9 50                      	push	ax			; preserve remainder of digits
 39080 000070CA 240F                    	AND	AL,0Fh			; grab low nibble
 39081 000070CC 0441                    	ADD	AL,'A'			; turn into ascii
 39082 000070CE AA                      	STOSB				; drop in the character
 39083 000070CF 58                      	pop	ax			; (ax) = shifted number
 39084 000070D0 FECD                    	dec	ch
 39085 000070D2 75F3                    	jnz	short bta5		; process 4 digits
 39086 000070D4 C3                      	retn
 39087                                  
 39088                                  ;Break	<$CreateTempFile - create a unique name>
 39089                                  ;----------------------------------------------------------------------------
 39090                                  ;   $CreateTemp - given a directory, create a unique name in that directory.
 39091                                  ;	Method used is to get the current time, convert to a name and attempt
 39092                                  ;	a create new. Repeat until create new succeeds.
 39093                                  ;
 39094                                  ;   Inputs:	DS:DX point to a null terminated directory name.
 39095                                  ;		CX  contains default attributes
 39096                                  ;   Outputs:	Unique name is appended to DS:DX directory.
 39097                                  ;		AX has handle
 39098                                  ;   Registers modified: all
 39099                                  ;----------------------------------------------------------------------------
 39100                                  
 39101                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39102                                  
 39103                                  _$CreateTempFile:
 39104                                  	;Enter
 39105 000070D5 55                      	push	bp
 39106 000070D6 89E5                    	mov	bp,sp
 39107                                  
 39108                                  	;LocalVar  EndPtr,DWORD
 39109                                  	;LocalVar  FilPtr,DWORD
 39110                                  	;LocalVar  Attr,WORD
 39111                                  
 39112 000070D8 83EC0A                  	sub	sp,10
 39113                                  
 39114                                  	;test	cx,0FFD8h
 39115 000070DB F7C1D8FF                	test	CX,~attr_changeable
 39116 000070DF 7405                    	JZ	short OKatts		; Ok if no non-changeable bits set
 39117                                  
 39118                                  ; We need this "hook" here to detect these cases (like user sets one both of
 39119                                  ; vol_id and dir bits) because of the structure of the or $CreateNewFile loop
 39120                                  ; below. The code loops on error_access_denied, but if one of the non
 39121                                  ; changeable attributes is specified, the loop COULD be infinite or WILL be
 39122                                  ; infinite because CreateNewFile will fail with access_denied always. Thus we
 39123                                  ; need to detect these cases before getting to the loop.
 39124                                  
 39125                                  	;mov	ax, 5
 39126 000070E1 B80500                  	MOV	AX,error_access_denied
 39127 000070E4 EB69                    	JMP	SHORT SETTMPERR
 39128                                  
 39129                                  OKatts:
 39130                                  	;MOV	attr,CX 		; save attribute
 39131 000070E6 894EF6                  	mov     [bp-10],cx
 39132                                  	;MOV	FilPtrL,DX		; pointer to file
 39133 000070E9 8956F8                  	mov	[bp-8],dx
 39134                                  	;MOV	FilPtrH,DS
 39135 000070EC 8C5EFA                  	mov	[bp-6],ds
 39136                                  	;MOV	EndPtrH,DS		; seg pointer to end of dir
 39137 000070EF 8C5EFE                  	mov	[bp-2],ds
 39138 000070F2 1E                      	PUSH	DS
 39139 000070F3 07                      	POP	ES			; destination for nul search
 39140 000070F4 89D7                    	MOV	DI,DX
 39141 000070F6 89F9                    	MOV	CX,DI
 39142 000070F8 F7D9                    	NEG	CX			; number of bytes remaining in segment
 39143                                  	; MSDOS 6.0
 39144 000070FA 09C9                    	OR	CX,CX			;AN000;MS. cx=0 ? ds:dx on segment boundary
 39145 000070FC 7501                    	JNZ	short okok		;AN000;MS. no
 39146                                  	;MOV	CX,-1			;AN000;MS.
 39147                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39148                                  	; 17/12/2022
 39149 000070FE 49                      	dec	cx  ; mov cx,-1
 39150                                  	;mov	cx,-1 ; 0FFFh
 39151                                  okok:					;AN000;
 39152 000070FF 31C0                    	XOR	AX,AX			;AN000;
 39153 00007101 F2AE                    	REPNZ	SCASB			;AN000;
 39154                                  					;AN000;
 39155 00007103 4F                      	DEC	DI			; point back to the null
 39156 00007104 268A45FF                	MOV	AL,[ES:DI-1]		; Get char before the NUL
 39157 00007108 E8B0DF                  	call	PATHCHRCMP		; Is it a path separator?
 39158 0000710B 7403                    	JZ	short SETENDPTR		; Yes
 39159                                  STOREPTH:
 39160 0000710D B05C                    	MOV	AL,'\'
 39161 0000710F AA                      	STOSB				; Add a path separator (and INC DI)
 39162                                  SETENDPTR:
 39163                                  	;MOV	EndPtrL,DI		; pointer to the tail
 39164 00007110 8856FC                  	mov	[bp-4],dl
 39165                                  CreateLoop:
 39166 00007113 16                      	push	ss			; let ReadTime see variables
 39167 00007114 1F                      	pop	ds
 39168 00007115 55                      	push	bp
 39169 00007116 E8019A                  	call	READTIME		; go get time
 39170 00007119 5D                      	pop	bp
 39171                                  ;
 39172                                  ; Time is in CX:DX. Go drop it into the string.
 39173                                  ;
 39174                                  	;les	di,EndPtr		; point to the string
 39175 0000711A C47EFC                  	les	di,[BP-4]
 39176 0000711D 89C8                    	mov	ax,cx
 39177 0000711F E8A2FF                  	call	BinToAscii		; store upper word
 39178 00007122 89D0                    	mov	ax,dx
 39179 00007124 E89DFF                  	call	BinToAscii		; store lower word
 39180 00007127 30C0                    	xor	al,al
 39181 00007129 AA                      	STOSB				; nul terminate
 39182                                  	;LDS	DX,FilPtr		; get name
 39183 0000712A C556F8                  	lds	dx,[bp-8]
 39184                                  	;MOV	CX,Attr 		; get attr
 39185 0000712D 8B4EF6                  	mov	cx,[bp-10]
 39186 00007130 55                      	push	bp
 39187 00007131 E889FF                  	CALL	_$CreateNewFile		; try to create a new file
 39188 00007134 5D                      	pop	bp
 39189 00007135 7319                    	JNC	short CreateDone	; failed, go try again
 39190                                  
 39191                                  ; The operation failed and the error has been mapped in AX. Grab the extended
 39192                                  ; error and figure out what to do.
 39193                                  
 39194                                  	;; MSDOS 3.3			; M049 - start
 39195                                  ;;	mov	ax,[ss:EXTERR]				;smr;SS Override
 39196                                  ;;	cmp	al,error_file_exists
 39197                                  ;;	jz	short CreateLoop	; file existed => try with new name
 39198                                  ;;	cmp	al,error_access_denied
 39199                                  ;;	jz	short CreateLoop	; access denied (attr mismatch)
 39200                                  
 39201                                  	; MSDOS 6.0
 39202                                  	;cmp	al,50h
 39203 00007137 3C50                    	CMP	AL,error_file_exists	; Q: did file already exist
 39204 00007139 74D8                    	JZ	short CreateLoop	; Y: try again
 39205                                  	;cmp	al,5
 39206 0000713B 3C05                    	CMP	AL,error_access_denied	; Q: was it access denied
 39207 0000713D 7510                    	JNZ	short SETTMPERR		; N: Error out
 39208                                  					; Y: Check to see if we got this due
 39209                                  					;    to the network drive. Note that
 39210                                  					;    the redir will set the exterr
 39211                                  					;    to error_cannot_make if this is 
 39212                                  					;    so. 
 39213 0000713F 36803E[2403]41          	CMP	byte [SS:EXTERR],error_net_access_denied ; M069
 39214                                  					; See if it's REALLY an att mismatch
 39215 00007145 7408                    	je	short SETTMPERR		; no, network error, stop
 39216                                  ;M070
 39217                                  ; If the user failed on an I24, we do not want to try again
 39218                                  ;
 39219 00007147 36803E[2403]53          	cmp	byte [SS:EXTERR],error_FAIL_I24 ;User failed on I24? ;M070
 39220                                  	;je	short SETTMPERR		;yes, do not try again ;M070
 39221                                  
 39222                                  	;jmp	short CreateLoop	;attr mismatch, try again ;M070
 39223                                  	; 17/12/2022
 39224 0000714D 75C4                    	jne	short CreateLoop ; 10/06/2019 
 39225                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39226                                  	;jz	short SETTMPERR
 39227                                  	;jmp	short CreateLoop
 39228                                  
 39229                                  ;;	MOV	AL,error_access_denied	; Return this "extended" error
 39230                                  					; M049 - end
 39231                                  SETTMPERR:
 39232 0000714F F9                      	STC
 39233                                  CreateDone:
 39234                                  	;Leave
 39235 00007150 89EC                    	mov	sp,bp
 39236 00007152 5D                      	pop	bp
 39237 00007153 7203                    	JC	short CreateFail
 39238 00007155 E9DF94                  	jmp	SYS_RET_OK		; success!
 39239                                  CreateFail:
 39240 00007158 E9E594                  	jmp	SYS_RET_ERR
 39241                                  
 39242                                  ;   SetAttrib will set the search attribute (SAttrib) either to the normal
 39243                                  ;   (CH) or to the value in CL if the current system call is through
 39244                                  ;   serverdoscall.
 39245                                  ;
 39246                                  ;   Inputs:	fSharing == FALSE => set sattrib to CH
 39247                                  ;		fSharing == TRUE => set sattrib to CL
 39248                                  ;   Outputs:	none
 39249                                  ;   Registers changed:	CX
 39250                                  
 39251                                  SetAttrib:
 39252 0000715B 36F606[7205]FF          	test	byte [SS:FSHARING],-1		;smr;SS Override
 39253 00007161 7502                    	jnz	short Set
 39254 00007163 88E9                    	mov	cl,ch
 39255                                  Set:
 39256 00007165 36880E[6D05]            	mov	byte [ss:SATTRIB],cl		;smr;SS Override
 39257 0000716A C3                      	retn
 39258                                  
 39259                                  ; 14/07/2018 - Retro DOS v3.0
 39260                                  ; MSDOS 6.0
 39261                                  
 39262                                  ; 29/04/2019 - Retro DOS v4.0
 39263                                  
 39264                                  ;Break	<Extended_Open- Extended open the file>
 39265                                  ;----------------------------------------------------------------------------
 39266                                  ; Input: AL= 0 reserved  AH=6CH
 39267                                  ;	 BX= mode
 39268                                  ;	 CL= create attribute  CH=search attribute (from server)
 39269                                  ;	 DX= flag
 39270                                  ;	 DS:SI = file name
 39271                                  ;	 ES:DI = parm list
 39272                                  ;			   DD  SET EA list (-1) null
 39273                                  ;			   DW  n  parameters
 39274                                  ;			   DB  type (TTTTTTLL)
 39275                                  ;			   DW  IOMODE
 39276                                  ; Function: Extended Open
 39277                                  ; Output: carry clear
 39278                                  ;		     AX= handle
 39279                                  ;		     CX=1 file opened
 39280                                  ;			2 file created/opened
 39281                                  ;			3 file replaced/opened
 39282                                  ;	  carry set: AX has error code
 39283                                  ;----------------------------------------------------------------------------
 39284                                  
 39285                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39286                                  _$Extended_Open:			  ;AN000;
 39287                                  	;ASSUME	CS:DOSCODE,SS:DOSDATA	  ;AN000;
 39288 0000716B 368916[F405]            	MOV	[SS:EXTOPEN_FLAG],DX	  ;AN000;EO. save ext. open flag;smr;SS Override
 39289 00007170 36C706[F705]0000        	MOV	word [SS:EXTOPEN_IO_MODE],0 ;AN000;EO. initialize IO mode;smr;SS Override
 39290                                  	; 17/12/2022
 39291 00007177 F6C6FE                  	test	dh,0FEh ; 04/12/2022 
 39292                                  	;;test	dx,0FE00h
 39293                                  	;TEST	DX,RESERVED_BITS_MASK	  ;AN000;EO. reserved bits 0  ?
 39294 0000717A 7545                    	JNZ	short ext_inval2	  ;AN000;EO. no
 39295 0000717C 88D4                    	MOV	AH,DL			  ;AN000;EO. make sure flag is right
 39296 0000717E 80FA00                  	CMP	DL,0			  ;AN000;EO. all fail ?
 39297 00007181 743E                    	JZ	short ext_inval2	  ;AN000;EO. yes, error
 39298                                  	;and	dl,0Fh
 39299 00007183 80E20F                  	AND	DL,EXISTS_MASK		  ;AN000;EO. get exists action byte
 39300 00007186 80FA02                  	CMP	DL,2			  ;AN000;EO, > 02
 39301 00007189 7736                    	JA	short ext_inval2	  ;AN000;EO. yes ,error
 39302                                  	;and	ah,0F0h
 39303 0000718B 80E4F0                  	AND	AH,NOT_EXISTS_MASK	  ;AN000;EO. get no exists action byte
 39304 0000718E 80FC10                  	CMP	AH,10H			  ;AN000;EO. > 10
 39305 00007191 772E                    	JA	short ext_inval2	  ;AN000;EO. yes error
 39306                                  
 39307 00007193 368C06[FB05]            	MOV	[SS:SAVE_ES],ES		  ;AN000;EO. save API parms;smr;SS Override
 39308 00007198 36893E[F905]            	MOV	[SS:SAVE_DI],DI		  ;AN000;EO.;smr;SS Override
 39309 0000719D 36FF36[F405]            	PUSH	word [SS:EXTOPEN_FLAG]	  ;AN000;EO.;smr;SS Override
 39310 000071A2 368F06[FD05]            	POP	word [SS:SAVE_DX]	  ;AN000;EO.;smr;SS Override
 39311 000071A7 36890E[FF05]            	MOV	[SS:SAVE_CX],CX		  ;AN000;EO.;smr;SS Override
 39312 000071AC 36891E[0106]            	MOV	[SS:SAVE_BX],BX		  ;AN000;EO.;smr;SS Override
 39313 000071B1 368C1E[0506]            	MOV	[SS:SAVE_DS],DS		  ;AN000;EO.;smr;SS Override
 39314 000071B6 368936[0306]            	MOV	[SS:SAVE_SI],SI		  ;AN000;EO.;smr;SS Override
 39315 000071BB 89F2                    	MOV	DX,SI			  ;AN000;EO. ds:dx points to file name
 39316 000071BD 89D8                    	MOV	AX,BX			  ;AN000;EO. ax= mode
 39317 000071BF EB0A                    	JMP	SHORT goopen2		  ;AN000;;EO. do normal
 39318                                  ext_inval2:				  ;AN000;;EO.
 39319                                  	;mov	al,1
 39320 000071C1 B001                    	mov	al,error_invalid_function ;AN000;EO.. invalid function
 39321                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39322                                  eo_err:
 39323                                  	;jmp	SYS_RET_ERR
 39324 000071C3 EB93                    	jmp	short CreateFail
 39325                                  
 39326                                  ext_inval_parm:				  ;AN000;EO..
 39327 000071C5 59                      	POP	CX			  ;AN000;EO..  pop up satck
 39328 000071C6 5E                      	POP	SI			  ;AN000;EO..
 39329                                  	;error	error_invalid_data	  ;AN000;EO..  invalid parms
 39330                                  	;mov	al,13
 39331 000071C7 B00D                    	mov	al,error_invalid_data
 39332                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39333                                  	;;jmp	SYS_RET_ERR
 39334                                  	;jmp	short eo_err
 39335                                  	; 17/12/2022
 39336 000071C9 EB8D                    	jmp	short CreateFail
 39337                                  
 39338                                  	; 17/12/2022	
 39339                                  ;error_return:				  ;AN000;EO.
 39340                                  ;	retn				  ;AN000;EO.. return with error
 39341                                  
 39342                                  goopen2:				  ;AN000;
 39343                                  	; 17/12/2022
 39344                                  	;test	bh,20h				 
 39345 000071CB F6C720                  	test	bh,INT_24_ERROR>>8 ; 04/12/2022
 39346                                  	;;test	bx,2000h
 39347                                  	;TEST	BX,INT_24_ERROR		  ;AN000;EO.. disable INT 24 error ?
 39348 000071CE 7406                    	JZ	short goopen		  ;AN000;EO.. no
 39349                                  	;or	byte [SS:EXTOPEN_ON],2
 39350 000071D0 36800E[F605]02          	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_I24_OFF ;AN000;EO.. set bit to disable;smr;SS Override
 39351                                  goopen:					  ;AN000;
 39352                                  	;or	byte [SS:EXTOPEN_ON],1 
 39353 000071D6 36800E[F605]01          	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_ON  ;AN000;EO.. set Extended Open active;smr;SS Override
 39354                                  	;AND	word [SS:EXTOPEN_FLAG],0FFh  ;AN000;EO.create new ?;smr;SS Override
 39355                                  	; 18/12/2022
 39356 000071DC 36C606[F505]00          	mov	byte [SS:EXTOPEN_FLAG+1],0 ; AND word [SS:EXTOPEN_FLAG],0FFh
 39357                                  	;cmp	word [SS:EXTOPEN_FLAG],10h
 39358 000071E2 36833E[F405]10          	CMP	word [SS:EXTOPEN_FLAG],EXT_EXISTS_FAIL+EXT_NEXISTS_CREATE ;AN000;FT.;smr;SS Override
 39359 000071E8 7516                    	JNZ	short chknext 		  ;AN000;;EO. no
 39360 000071EA E8D0FE                  	call	_$CreateNewFile		  ;AN000;;EO. yes
 39361 000071ED 723F                    	JC	short error_return	  ;AN000;;EO. error
 39362                                  
 39363 000071EF 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 39364 000071F5 7438                    	JZ	short ok_return2	  ;AN000;;EO. yes
 39365                                  	;mov	word [SS:EXTOPEN_FLAG],2
 39366 000071F7 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. creted/opened;smr;SS Override
 39367 000071FE EB7F                    	JMP	setXAttr		  ;AN000;;EO. set XAs
 39368                                  
 39369                                  	; 17/12/2022
 39370                                  ;ok_return2:
 39371                                  ;	jmp	SYS_RET_OK		  ;AN000;;EO.
 39372                                  
 39373                                  chknext:
 39374                                  	; 17/12/2022
 39375 00007200 36F606[F405]01          	test	byte [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ; 1
 39376                                  	;;test	word [SS:EXTOPEN_FLAG],1
 39377                                  	;TEST	word [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ;AN000;;EO. exists open;smr;SS Override
 39378 00007206 752A                    	JNZ	short exist_open	  ;AN000;;EO. yes
 39379 00007208 E8C9FD                  	call	_$CREAT			  ;AN000;;EO. must be replace open
 39380 0000720B 7221                    	JC	short error_return	  ;AN000;;EO. return with error
 39381 0000720D 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 39382 00007213 741A                    	JZ	short ok_return2	  ;AN000;;EO. yes
 39383 00007215 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. prsume create/open;smr;SS Override
 39384 0000721C 36F606[F605]04          	TEST	byte [SS:EXTOPEN_ON],EXT_FILE_NOT_EXISTS ;AN000;;EO. file not exists ?;smr;SS Override
 39385 00007222 755B                    	JNZ	short setXAttr		  ;AN000;;EO. no
 39386 00007224 36C706[F405]0300        	MOV	word [SS:EXTOPEN_FLAG],ACTION_REPLACED_OPENED ;AN000;;EO. replaced/opened;smr;SS Override
 39387 0000722B EB52                    	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 39388                                  error_return2:
 39389 0000722D F9                      	STC 				  ; Set Carry again to flag error ;AN001;
 39390                                  error_return:	 ;17/12/2022
 39391 0000722E C3                      	retn				  ;AN000;;EO. return with error
 39392                                  
 39393                                  	; 17/12/2022
 39394                                  ok_return:
 39395                                  ok_return2:
 39396 0000722F E90594                  	jmp	SYS_RET_OK
 39397                                  
 39398                                  exist_open:				  ;AN000;
 39399 00007232 36F606[7205]FF          	test	byte [SS:FSHARING],-1	  ;AN000;;EO. server doscall?;smr;SS Override
 39400 00007238 7402                    	jz	short noserver		  ;AN000;;EO. no
 39401 0000723A 88E9                    	MOV	CL,CH			  ;AN000;;EO. cl=search attribute
 39402                                  noserver:
 39403 0000723C E8C0FC                  	call	_$Open2			  ;AN000;;EO. do open
 39404 0000723F 732F                    	JNC	short ext_ok		  ;AN000;;EO.
 39405 00007241 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. error and IFS call;smr;SS Override
 39406 00007247 74E4                    	JZ	short error_return2	  ;AN000;;EO. return with error
 39407                                  local_extopen:
 39408                                  	;cmp	ax,2
 39409 00007249 83F802                  	CMP	AX,error_file_not_found   ;AN000;;EO. file not found error
 39410 0000724C 75DF                    	JNZ	short error_return2	  ;AN000;;EO. no,
 39411                                  	;;test	word [SS:EXTOPEN_FLAG],10h
 39412                                  	; 17/12/2022
 39413 0000724E 36F606[F405]10          	test	byte [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ; 10h
 39414                                  	;TEST	word [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ;AN000;;EO. want to fail;smr;SS Override
 39415                                  	;JNZ	short do_creat		  ;AN000;;EO. yes
 39416                                  	;JMP	short extexit 		  ;AN000;;EO. yes
 39417                                  	; 17/12/2022
 39418 00007254 745D                    	jz	short extexit ; 10/06/2019
 39419                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39420                                  	;jnz	short do_creat
 39421                                  	;jmp	short extexit
 39422                                  do_creat:
 39423 00007256 368B0E[FF05]            	MOV	CX,[SS:SAVE_CX]		  ;AN000;;EO. get ds:dx for file name;smr;SS Override
 39424 0000725B 36C536[0306]            	LDS	SI,[SS:SAVE_SI]		  ;AN000;;EO. cx = attribute;smr;SS Override
 39425 00007260 89F2                    	MOV	DX,SI			  ;AN000;;EO.
 39426 00007262 E86FFD                  	call	_$CREAT			  ;AN000;;EO. do create
 39427 00007265 724C                    	JC	short extexit 		  ;AN000;;EO. error
 39428                                  	;mov	word [SS:EXTOPEN_FLAG],2
 39429 00007267 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
 39430                                  					  ;AN000;;EO. is created/opened;smr;SS Override
 39431 0000726E EB0F                    	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 39432                                  
 39433                                  ext_ok:
 39434 00007270 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS call ?;smr;SS Override
 39435 00007276 74B7                    	JZ	short ok_return		  ;AN000;;EO. yes
 39436                                  	;mov	word [SS:EXTOPEN_FLAG],1
 39437 00007278 36C706[F405]0100        	MOV	word [SS:EXTOPEN_FLAG],ACTION_OPENED ;AN000;;EO. opened;smr;SS Override
 39438                                  setXAttr:
 39439                                  	; 29/04/2019
 39440 0000727F 50                      	push	ax
 39441 00007280 E8FE91                  	call	Get_User_Stack		  ;AN000;;EO.
 39442 00007283 36A1[F405]              	MOV	AX,[SS:EXTOPEN_FLAG]	  ;AN000;;EO.;smr;SS Override
 39443                                  	;mov	[si+4],ax
 39444 00007287 894404                  	MOV	[SI+user_env.user_CX],AX  ;AN000;;EO. set action code for cx
 39445 0000728A 58                      	pop	ax			  ;AN000;;EO.
 39446 0000728B 8904                    	mov	[si],ax
 39447                                  	;MOV	[SI+user_env.user_AX],AX  ;AN000;;EO. set handle for ax
 39448                                  	; 17/12/2022
 39449 0000728D EBA0                    	jmp	short ok_return
 39450                                  ;ok_return:				  ;AN000;
 39451                                  	;jmp	SYS_RET_OK		  ;AN000;;EO.
 39452                                  
 39453                                  extexit2:				  ;AN000; ERROR RECOVERY
 39454 0000728F 5B                      	POP	BX			  ;AN000;EO. close the handle
 39455 00007290 50                      	PUSH	AX			  ;AN000;EO. save error code from set XA
 39456                                  	;cmp	word [SS:EXTOPEN_FLAG],2
 39457 00007291 36833E[F405]02          	CMP	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
 39458                                  					  ;AN000;EO. from create;smr;SS Override
 39459 00007297 750C                    	JNZ	short justopen		  ;AN000;EO.
 39460 00007299 36C536[0306]            	LDS	SI,[SS:SAVE_SI]		  ;AN000;EO. cx = attribute;smr;SS Override
 39461 0000729E C514                    	LDS	DX,[SI]			  ;AN000;EO.
 39462 000072A0 E881FD                  	call	_$UNLINK 		  ;AN000;EO. delete the file
 39463 000072A3 EB03                    	JMP	SHORT reserror		  ;AN000;EO.
 39464                                  
 39465                                  justopen:				  ;AN000;
 39466 000072A5 E886F4                  	call	_$CLOSE			  ;AN000;EO. pretend never happend
 39467                                  reserror:				  ;AN000;
 39468 000072A8 58                      	POP	AX			  ;AN000;EO. restore error code from set XA
 39469 000072A9 EB08                    	JMP	SHORT extexit		  ;AN000;EO.
 39470                                  
 39471                                  ext_file_unfound:			  ;AN000;
 39472                                  	;mov	ax,2
 39473 000072AB B80200                  	MOV	AX,error_file_not_found   ;AN000;EO.
 39474 000072AE EB03                    	JMP	SHORT extexit		  ;AN000;EO.
 39475                                  ext_inval:				  ;AN000;
 39476                                  	;mov	ax,1
 39477 000072B0 B80100                  	MOV	AX,error_invalid_function ;AN000;EO.
 39478                                  lockoperr:	; 17/12/2022
 39479                                  extexit:
 39480 000072B3 E98A93                  	jmp	SYS_RET_ERR		  ;AN000;EO.
 39481                                  
 39482                                  ;============================================================================
 39483                                  ; LOCK.ASM, MSDOS 6.0, 1991
 39484                                  ;============================================================================
 39485                                  ; 14/07/2018 - Retro DOS v3.0
 39486                                  ; 22/05/2019 - Retro DOS v4.0
 39487                                  
 39488                                  ;BREAK <$LockOper - Lock Calls>
 39489                                  ;----------------------------------------------------------------------------
 39490                                  ;
 39491                                  ;   Assembler usage:
 39492                                  ;	    MOV     BX, Handle	       (DOS 3.3)
 39493                                  ;	    MOV     CX, OffsetHigh
 39494                                  ;	    MOV     DX, OffsetLow
 39495                                  ;	    MOV     SI, LengthHigh
 39496                                  ;	    MOV     DI, LengthLow
 39497                                  ;	    MOV     AH, LockOper
 39498                                  ;	    MOV     AL, Request
 39499                                  ;	    INT     21h
 39500                                  ;
 39501                                  ;   Error returns:
 39502                                  ;	    AX = error_invalid_handle
 39503                                  ;	       = error_invalid_function
 39504                                  ;	       = error_lock_violation
 39505                                  ;
 39506                                  ;   Assembler usage:
 39507                                  ;	    MOV     AX, 5C??	       (DOS 4.00)
 39508                                  ;
 39509                                  ;				    0? lock all
 39510                                  ;				    8? lock write
 39511                                  ;				    ?2 lock multiple
 39512                                  ;				    ?3 unlock multiple
 39513                                  ;				    ?4 lock/read
 39514                                  ;				    ?5 write/unlock
 39515                                  ;				    ?6 add (lseek EOF/lock/write/unlock)
 39516                                  ;	    MOV     BX, Handle
 39517                                  ;	    MOV     CX, count or size
 39518                                  ;	    LDS     DX, buffer
 39519                                  ;	    INT     21h
 39520                                  ;
 39521                                  ;   Error returns:
 39522                                  ;	    AX = error_invalid_handle
 39523                                  ;	       = error_invalid_function
 39524                                  ;	       = error_lock_violation
 39525                                  ;
 39526                                  ;----------------------------------------------------------------------------
 39527                                  
 39528                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39529                                  _$LockOper:
 39530 000072B6 3C01                    	CMP	AL,1
 39531 000072B8 770B                    	JA	short lock_bad_func
 39532                                  
 39533 000072BA 57                      	PUSH	DI			       ; Save LengthLow
 39534 000072BB E8D5F3                  	call	SFFromHandle		       ; ES:DI -> SFT
 39535 000072BE 731D                    	JNC	short lock_do 		       ; have valid handle
 39536 000072C0 5F                      	POP	DI			       ; Clean stack
 39537                                  	;mov	al,6
 39538 000072C1 B006                    	mov	al,error_invalid_handle
 39539                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39540                                  ;lockoperr:
 39541                                  	;jmp	SYS_RET_ERR
 39542                                  	; 17/12/2022
 39543 000072C3 EBEE                    	jmp	short lockoperr ; jmp SYS_RET_ERR
 39544                                  
 39545                                  lock_bad_func:
 39546                                  	;mov	byte [ss:EXTERR_LOCUS],1
 39547 000072C5 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus;smr;SS Override
 39548                                  	;mov	al,1
 39549 000072CB B001                    	mov	al,error_invalid_function
 39550                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39551                                  lockoperrj:
 39552                                  	;jmp	SYS_RET_ERR
 39553 000072CD EBE4                    	jmp	short lockoperr
 39554                                  
 39555                                  	; 22/05/2019 - Retro DOS v4.0
 39556                                  
 39557                                  	; MSDOS 6.0 
 39558                                  ; Align_buffer call has been deleted, since it corrupts the DTA (6/5/88) P5013
 39559                                  ; Dead code deleted, MD, 23 Mar 90
 39560                                  
 39561                                  ;lock_do:
 39562                                  ;	; MSDOS 3.3
 39563                                  ;	or	al,al
 39564                                  ;	pop	ax
 39565                                  ;	jz	short DOS_Lock
 39566                                  ;DOS_Unlock:
 39567                                  ;	;test	word [es:di+5],8000h
 39568                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 39569                                  ;	JZ	short LOCAL_UNLOCK
 39570                                  ;	push    ax
 39571                                  ;	mov     ax,110Bh
 39572                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 39573                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39574                                  ;			; STACK: WORD low word of size, ES:DI -> SFT for file
 39575                                  ;			; SFT DPB field -> DPB of drive containing file
 39576                                  ;			; Return: CF set error
 39577                                  ;	pop     bx
 39578                                  ;	jmp     short ValChk
 39579                                  ;
 39580                                  ;LOCAL_UNLOCK:
 39581                                  ;	Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39582                                  ;ValChk:
 39583                                  ;	JNC	short Lock_OK
 39584                                  ;lockerror:
 39585                                  ;	jmp	SYS_RET_ERR
 39586                                  ;Lock_OK:
 39587                                  ;	;MOV	AX,[SS:Temp_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 39588                                  ;	jmp	SYS_RET_OK
 39589                                  ;DOS_Lock:
 39590                                  ;	;test	word [es:di+5],8000h
 39591                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 39592                                  ;	JZ	short LOCAL_LOCK
 39593                                  ;	;CallInstall NET_XLock,MultNET,10
 39594                                  ;	mov     ax, 110Ah
 39595                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 39596                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39597                                  ;			; STACK: WORD low word of size, ES:DI -> SFT
 39598                                  ;			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 39599                                  ;			; Return: CF set error
 39600                                  ;	JMP	short ValChk
 39601                                  ;
 39602                                  ;LOCAL_LOCK:
 39603                                  ;	Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 39604                                  ;	JMP	short ValChk
 39605                                  
 39606                                  ; 17/12/2022
 39607                                  LOCAL_UNLOCK:
 39608                                  	; MSDOS 3.3
 39609                                  	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39610                                  	; MSDOS 6.0
 39611 000072CF FF1E[AC00]              	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39612                                  ValChk:
 39613 000072D3 7302                    	JNC	short Lock_OK
 39614                                  lockerror:
 39615                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39616                                  	;;jmp	SYS_RET_ERR
 39617                                  	;jmp	short lockoperrj
 39618                                  	; 17/12/2022
 39619 000072D5 EBDC                    	jmp	short lockoperr	; jmp SYS_RET_ERR
 39620                                  Lock_OK:
 39621                                  	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 39622                                  	; 10/06/2019
 39623 000072D7 A1[0C06]                	mov	ax,[TEMP_VAR]
 39624 000072DA E95A93                  	jmp	SYS_RET_OK
 39625                                  
 39626                                  	; 22/05/2019
 39627                                  lock_do:
 39628                                  	; MSDOS 6.0
 39629 000072DD 89C3                    	MOV	BX,AX				; save AX
 39630 000072DF BD[A903]                	MOV	BP,Lock_Buffer			; get DOS LOCK buffer
 39631                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39632                                  	;;mov	[bp+0],dx
 39633                                  	;MOV	[BP+LockBuf.Lock_position],DX	; set low offset
 39634                                  	; 15/12/2022
 39635 000072E2 895600                  	mov	[bp],dx
 39636                                  	;mov	[bp+2],cx
 39637 000072E5 894E02                  	MOV	[BP+LockBuf.Lock_position+2],CX; set high offset
 39638 000072E8 59                      	POP	CX				; get low length
 39639                                  	;mov	[bp+4],cx
 39640 000072E9 894E04                  	MOV	[BP+LockBuf.Lock_length],CX	; set low length
 39641                                  	;mov	[bp+6],si
 39642 000072EC 897606                  	MOV	[BP+LockBuf.Lock_length+2],SI	; set high length
 39643 000072EF B90100                  	MOV	CX,1				; one range
 39644                                  
 39645                                  ;	PUSH	CS				;
 39646                                  ;	POP	DS				; DS:DX points to
 39647                                  
 39648 000072F2 16                      	push	ss
 39649 000072F3 1F                      	pop	ds
 39650                                  
 39651 000072F4 89EA                    	MOV	DX,BP				; Lock_Buffer
 39652                                  	;test	al,1
 39653 000072F6 A801                    	TEST	AL,UNLOCK_ALL			; function 1
 39654                                  	;JNZ	short DOS_Unlock		; yes
 39655                                  	;JMP	short DOS_Lock			; function 0
 39656                                  	; 17/12/2022
 39657                                  	; 10/06/2019
 39658 000072F8 740E                    	jz	short DOS_Lock
 39659                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39660                                  	;JNZ	short DOS_Unlock
 39661                                  	;JMP	short DOS_Lock
 39662                                  
 39663                                  DOS_Unlock:
 39664                                  	;;test	word [es:di+5],8000h
 39665                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 39666 000072FA 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 39667 000072FF 74CE                    	JZ	short LOCAL_UNLOCK
 39668                                  
 39669                                  lock_unlock: ; 22/05/2019
 39670                                  	
 39671                                  	;CallInstall Net_Xlock,MultNET,10
 39672                                  	
 39673                                  	; MSDOS 3.3
 39674                                  	;mov     ax,110Bh
 39675                                  	;int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 39676                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39677                                  			; STACK: WORD low word of size, ES:DI -> SFT for file
 39678                                  			; SFT DPB field -> DPB of drive containing file
 39679                                  			; Return: CF set error
 39680                                  	; MSDOS 6.0
 39681 00007301 B80A11                  	mov     ax,110Ah
 39682 00007304 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 39683                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39684                                  			; STACK: WORD low word of size, ES:DI -> SFT
 39685                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 39686                                  			; Return: CF set error
 39687                                  
 39688 00007306 EBCB                    	JMP	SHORT ValChk
 39689                                  
 39690                                  ; 17/12/2022
 39691                                  %if 0
 39692                                  LOCAL_UNLOCK:
 39693                                  	; MSDOS 3.3
 39694                                  	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39695                                  	; MSDOS 6.0
 39696                                  	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39697                                  ValChk:
 39698                                  	JNC	short Lock_OK
 39699                                  lockerror:
 39700                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39701                                  	;jmp	SYS_RET_ERR
 39702                                  	jmp	short lockoperrj
 39703                                  Lock_OK:
 39704                                  	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 39705                                  	; 10/06/2019
 39706                                  	mov	ax,[TEMP_VAR]
 39707                                  	jmp	SYS_RET_OK
 39708                                  %endif
 39709                                  
 39710                                  DOS_Lock:
 39711                                  	;;test	word [es:di+5],8000h
 39712                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 39713 00007308 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 39714 0000730D 7407                    	JZ	short LOCAL_LOCK
 39715                                  
 39716                                  	;CallInstall NET_XLock,MultNET,10
 39717                                  
 39718 0000730F B80A11                  	mov     ax,110Ah
 39719 00007312 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 39720                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39721                                  			; STACK: WORD low word of size, ES:DI -> SFT
 39722                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 39723                                  			; Return: CF set error
 39724                                  
 39725 00007314 EBBD                    	JMP	short ValChk
 39726                                  
 39727                                  LOCAL_LOCK:
 39728                                  	; MSDOS 3.3
 39729                                  	;Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 39730                                  	; MSDOS 6.0
 39731 00007316 FF1E[A800]              	Call	far [JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 39732                                  
 39733 0000731A EBB7                    	JMP	short ValChk
 39734                                  
 39735                                  ; 14/07/2018 - Retro DOS v3.0
 39736                                  ; LOCK_CHECK
 39737                                  ;MSDOS 6.0 (& MSDOS 3.3)
 39738                                  
 39739                                  ;----------------------------------------------------------------------------
 39740                                  ; Inputs:
 39741                                  ;	Outputs of SETUP
 39742                                  ;	[USER_ID] Set
 39743                                  ;	[PROC_ID] Set
 39744                                  ; Function:
 39745                                  ;	Check for lock violations on local I/O
 39746                                  ;	Retries are attempted with sleeps in between
 39747                                  ; Outputs:
 39748                                  ;    Carry clear
 39749                                  ;	Operation is OK
 39750                                  ;    Carry set
 39751                                  ;	A lock violation detected
 39752                                  ; Outputs of SETUP preserved
 39753                                  ;----------------------------------------------------------------------------
 39754                                  
 39755                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39756                                  	; 22/05/2019 - Retro DOS v4.0
 39757                                  LOCK_CHECK:
 39758 0000731C 8B1E[1A00]              	MOV	BX,[RetryCount]	; Number retries
 39759                                  LockRetry:
 39760 00007320 53                      	push	bx		; save regs
 39761 00007321 50                      	push	ax ; MSDOS 6.0
 39762                                  
 39763                                  	;MSDOS 3.3
 39764                                  	;Call	far [ss:JShare+(8*4)]	; 8 = chk_block
 39765                                  	;MSDOS 6.0
 39766 00007322 FF1E[B000]              	Call	far [JShare+(8*4)]	; 8 = chk_block
 39767                                  
 39768 00007326 58                      	pop	ax ; MSDOS 6.0
 39769 00007327 5B                      	pop	bx		; restrore regs
 39770 00007328 7307                    	jnc	short lc_ret_label ; There are no locks (retnc)
 39771                                  LockN:
 39772 0000732A E8DB9E                  	call	Idle		; wait a while
 39773 0000732D 4B                      	DEC	BX		; remember a retry
 39774 0000732E 75F0                    	JNZ	short LockRetry	; more retries left...
 39775 00007330 F9                      	STC
 39776                                  lc_ret_label:
 39777 00007331 C3                      	retn
 39778                                  
 39779                                  ; 14/07/2018 - Retro DOS v3.0
 39780                                  ; LOCK_VIOLATION
 39781                                  ;MSDOS 6.0 (& MSDOS 3.3)
 39782                                  
 39783                                  ;----------------------------------------------------------------------------
 39784                                  ; Inputs:
 39785                                  ;	[THISDPB] set
 39786                                  ;	[READOP] indicates whether error on read or write
 39787                                  ; Function:
 39788                                  ;	Handle Lock violation on compatibility (FCB) mode SFTs
 39789                                  ; Outputs:
 39790                                  ;	Carry set if user says FAIL, causes error_lock_violation
 39791                                  ;	Carry clear if user wants a retry
 39792                                  ;
 39793                                  ; DS, ES, DI, CX preserved, others destroyed
 39794                                  ;----------------------------------------------------------------------------
 39795                                  
 39796                                  LOCK_VIOLATION:
 39797 00007332 1E                      	PUSH	DS
 39798 00007333 06                      	PUSH	ES
 39799 00007334 57                      	PUSH	DI
 39800 00007335 51                      	PUSH	CX
 39801                                  	;mov	ax,21h
 39802 00007336 B82100                  	MOV	AX,error_lock_violation
 39803                                  	;mov	byte [ALLOWED],18h
 39804 00007339 C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 39805 0000733E C42E[8A05]              	LES	BP,[THISDPB]
 39806 00007342 BF0100                  	MOV	DI,1		; Fake some registers
 39807 00007345 89F9                    	MOV	CX,DI
 39808                                  	;mov	dx,[es:bp+11]
 39809 00007347 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 39810 0000734B E8D6DF                  	call	HARDERR
 39811 0000734E 59                      	POP	CX
 39812 0000734F 5F                      	POP	DI
 39813 00007350 07                      	POP	ES
 39814 00007351 1F                      	POP	DS
 39815 00007352 3C01                    	CMP	AL,1
 39816 00007354 74DB                    	jz	short lc_ret_label ; 1 = retry, carry clear
 39817 00007356 F9                      	STC
 39818 00007357 C3                      	retn
 39819                                  
 39820                                  ; 14/07/2018 - Retro DOS v3.0
 39821                                  
 39822                                  ;----------------------------------------------------------------------------
 39823                                  
 39824                                  ;	do a retz to return error
 39825                                  
 39826                                  	; 22/05/2019 - Retro DOS v4.0
 39827                                  CheckShare:
 39828                                  	; MSDOS 3.3
 39829                                  	;cmp	byte [cs:fShare],0
 39830                                  	;retn
 39831                                  
 39832                                  	; MSDOS 6.0
 39833 00007358 1E                      	push	ds			;smr;
 39834                                  	;getdseg <ds>			; ds -> dosdata
 39835 00007359 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 39836 0000735E 803E[0303]00            	cmp	byte [fShare],0
 39837 00007363 1F                      	pop	ds			;smr;
 39838 00007364 C3                      	retn
 39839                                  	
 39840                                  ;============================================================================
 39841                                  ; SHARE.ASM, MSDOS 6.0, 1991
 39842                                  ;============================================================================
 39843                                  ; 14/07/2018 - Retro DOS v3.0
 39844                                  ; 22/05/2019 - Retro DOS v4.0
 39845                                  
 39846                                  ; SHARE_CHECK
 39847                                  ;----------------------------------------------------------------------------
 39848                                  ; Inputs:
 39849                                  ;       [THISSFT] Points to filled in local file/device SFT for new
 39850                                  ;               instance of file sf_mode ALWAYS has mode (even on FCB SFTs)
 39851                                  ;       [WFP_START] has full path of name
 39852                                  ;       [USER_ID] Set
 39853                                  ;       [PROC_ID] Set
 39854                                  ; Function:
 39855                                  ;       Check for sharing violations on local file/device access
 39856                                  ; Outputs:
 39857                                  ;    Carry clear
 39858                                  ;       Sharing approved
 39859                                  ;    Carry set
 39860                                  ;       A sharing violation detected
 39861                                  ;           AX is error code
 39862                                  ; USES    ALL but DS
 39863                                  ;----------------------------------------------------------------------------
 39864                                  
 39865                                  	; 22/05/2019 - Retro DOS v4.0
 39866                                  SHARE_CHECK:
 39867                                  	; 26/07/2019
 39868 00007365 FF1E[9400]              	call	far [JShare+(1*4)] 	; 1 = MFT_Enter
 39869                                  shchk_retn:
 39870 00007369 C3                      	retn
 39871                                  
 39872                                  ; SHARE_VIOLATION
 39873                                  ;----------------------------------------------------------------------------
 39874                                  ; Inputs:
 39875                                  ;       [THISDPB] Set
 39876                                  ;       AX has error code
 39877                                  ; Function:
 39878                                  ;       Handle Sharing errors
 39879                                  ; Outputs:
 39880                                  ;       Carry set if user says FAIL, causes error_sharing_violation
 39881                                  ;       Carry clear if user wants a retry
 39882                                  ;
 39883                                  ; DS, ES, DI preserved, others destroyed
 39884                                  ;----------------------------------------------------------------------------
 39885                                  
 39886                                  SHARE_VIOLATION:
 39887 0000736A 1E                      	PUSH    DS
 39888 0000736B 06                      	PUSH	ES
 39889 0000736C 57                      	PUSH    DI
 39890 0000736D C606[7505]00            	MOV     byte [READOP],0		; All share errors are reading
 39891                                  	;mov	byte [ALLOWED],18h
 39892 00007372 C606[4B03]18            	MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 39893 00007377 C42E[8A05]              	LES     BP,[THISDPB]
 39894 0000737B BF0100                  	MOV     DI,1			; Fake some registers
 39895 0000737E 89F9                    	MOV     CX,DI
 39896                                  	;mov	dx,[es:bp+17]
 39897 00007380 268B5611                	MOV     DX,[ES:BP+DPB.DIR_SECTOR]
 39898 00007384 E89DDF                  	call	HARDERR
 39899 00007387 5F                      	POP     DI
 39900 00007388 07                      	POP	ES
 39901 00007389 1F                      	POP     DS
 39902 0000738A 3C01                    	CMP     AL,1
 39903 0000738C 74DB                    	jz	short shchk_retn	; 1 = retry, carry clear
 39904 0000738E F9                      	STC
 39905 0000738F C3                      	retn
 39906                                  
 39907                                  ;----------------------------------------------------------------------------
 39908                                  ;   ShareEnd - terminate sharing info on a particular SFT/UID/PID. This does
 39909                                  ;       NOT perform a close, it merely asserts that the sharing information
 39910                                  ;       for the SFT/UID/PID may be safely released.
 39911                                  ;
 39912                                  ;   Inputs:     ES:DI points to an SFT
 39913                                  ;   Outputs:    None
 39914                                  ;   Registers modified: all except DS,ES,DI
 39915                                  ;----------------------------------------------------------------------------
 39916                                  
 39917                                  ShareEnd:
 39918                                  	; 26/07/2019
 39919 00007390 FF1E[9800]              	call	far [JShare+(2*4)]	; 2 = MFTClose
 39920 00007394 C3                      	retn
 39921                                  
 39922                                  ;Break <ShareEnter - attempt to enter a node into the sharing set>
 39923                                  ;----------------------------------------------------------------------------
 39924                                  ;   ShareEnter - perform a retried entry of a nodde into the sharing set. If
 39925                                  ;   the max number of retries is exceeded, we notify the user via int 24.
 39926                                  ;
 39927                                  ;   Inputs:     ThisSFT points to the SFT
 39928                                  ;               WFP_Start points to the WFP
 39929                                  ;   Outputs:    Carry clear => successful entry
 39930                                  ;               Carry set => failed system call
 39931                                  ;   Registers modified: all
 39932                                  ;----------------------------------------------------------------------------
 39933                                  
 39934                                  ShareEnter:
 39935 00007395 51                      	push	cx
 39936                                  retry:
 39937 00007396 8B0E[1A00]              	mov     cx,[RetryCount]
 39938                                  attempt:
 39939 0000739A C43E[9E05]              	les     di,[THISSFT]		; grab sft
 39940 0000739E 31C0                    	XOR     AX,AX
 39941                                   	;mov	[es:di+51],axfff
 39942 000073A0 26894533                	MOV     [ES:DI+SF_ENTRY.sf_MFT],AX ; indicate free SFT
 39943 000073A4 51                      	push	cx
 39944 000073A5 E8BDFF                  	call    SHARE_CHECK             ; attempt to enter into the sharing set
 39945 000073A8 59                      	pop	cx
 39946 000073A9 730A                    	jnc	short done		; success, let the user see this
 39947 000073AB E85A9E                  	call	Idle                    ; wait a while
 39948 000073AE E2EA                    	loop    attempt                 ; go back for another attempt
 39949 000073B0 E8B7FF                  	call    SHARE_VIOLATION         ; signal the problem to the user
 39950 000073B3 73E1                    	jnc	short retry		; user said to retry, go do it
 39951                                  done:
 39952 000073B5 59                      	pop	cx
 39953 000073B6 C3                      	retn
 39954                                  
 39955                                  ;============================================================================
 39956                                  ; EXEPATCH.ASM (MSDOS 6.0, 1991)
 39957                                  ;============================================================================
 39958                                  ; 29/04/2019 - Retro DOS 4.0
 39959                                  
 39960                                  ;** EXEPATCH.ASM 
 39961                                  ;----------------------------------------------------------------------------
 39962                                  ;	Contains the foll:
 39963                                  ;
 39964                                  ;		- code to find and overlay buggy unpack code
 39965                                  ;		- new code to be overlayed on buggy unpack code 
 39966                                  ;		- old code sequence to identify buggy unpack code
 39967                                  ;
 39968                                  ;	Revision history:
 39969                                  ;
 39970                                  ;		Created: 5/14/90
 39971                                  ;----------------------------------------------------------------------------
 39972                                  
 39973                                  ;----------------------------------------------------------------------------
 39974                                  ;
 39975                                  ; M020 : Fix for rational bug - for details see routine header
 39976                                  ; M028 : 4b04 implementation
 39977                                  ; M030 : Fixing bug in EXEPACKPATCH (EXEC_CS is an un-relocated value)
 39978                                  ; M032 : set turnoff bit only if DOS in HMA.
 39979                                  ; M033 : if IP < 2 then not exepacked.
 39980                                  ; M046 : support for a 4th version of exepacked files.
 39981                                  ; M068 : support for copy protected apps.
 39982                                  ; M071 : use A20OFF_COUNT of 10.
 39983                                  ;
 39984                                  ;----------------------------------------------------------------------------
 39985                                  
 39986                                  PATCH1_COM_OFFSET	EQU	06CH
 39987                                  PATCH1_OFFSET		EQU	028H
 39988                                  PATCH1_CHKSUM		EQU	0EF4EH
 39989                                  CHKSUM1_LEN		EQU	11CH/2 ; 142
 39990                                  
 39991                                  PATCH2_COM_OFFSET	EQU	076H
 39992                                  PATCH2_OFFSET		EQU	032H
 39993                                  
 39994                                  	; The strings that start at offset 076h have two possible 
 39995                                  	; check sums that are defined as PATCH2_CHKSUM PATCH2A_CHKSUM
 39996                                  
 39997                                  PATCH2_CHKSUM		EQU	78B2H
 39998                                  CHKSUM2_LEN		EQU	119H/2
 39999                                  PATCH2A_CHKSUM		EQU	1C47H		; M046
 40000                                  CHKSUM2A_LEN		EQU	103H/2		; M046
 40001                                  
 40002                                  PATCH3_COM_OFFSET	EQU	074H
 40003                                  PATCH3_OFFSET		EQU	032H
 40004                                  PATCH3_CHKSUM		EQU	4EDEH
 40005                                  CHKSUM3_LEN		EQU	117H/2
 40006                                  
 40007                                  ;**	Data structure passed for ExecReady call
 40008                                  ;
 40009                                  ;struc ERStruc
 40010                                  ; .ER_Reserved:	resw	1	; reserved, should be zero
 40011                                  ; .ER_Flags:	resw	1
 40012                                  ; .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
 40013                                  ; .ER_PSP:	resw	1	; PSP of the program
 40014                                  ; .ER_StartAddr: resd	1	; Start CS:IP of the program
 40015                                  ; .ER_ProgSize:	resd	1	; Program size including PSP
 40016                                  ; .size:
 40017                                  ;endstruc
 40018                                  
 40019                                  ;DOSCODE SEGMENT
 40020                                  
 40021                                  	; 22/05/2019 - Retro DOS v4.0
 40022                                  	; DOSCODE:B3DDh (MSDOS 6.21, MSDOS.SYS)
 40023                                  
 40024                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40025                                  	; DOSCODE:B37Ah (MSDOS 5.0, MSDOS.SYS)
 40026                                  
 40027                                  ; M028 - BEGIN
 40028                                  
 40029                                  ;--------------------------------------------------------------------------
 40030                                  ;
 40031                                  ;	Procedure Name		: ExecReady
 40032                                  ;
 40033                                  ;	Input			: DS:DX -> ERStruc (see exe.inc)
 40034                                  ;
 40035                                  ;--------------------------------------------------------------------------
 40036                                  
 40037                                  ExecReady:
 40038 000073B7 89D6                    	mov	si,dx			; move the pointer into a friendly one
 40039                                  	;;test	word [si+2],1
 40040                                  	; 17/12/2022
 40041 000073B9 F6440201                	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
 40042                                  	;test	word [si+ERStruc.ER_Flags],ER_EXE ; COM or EXE ?
 40043 000073BD 7413                    	jz	short er_setver		; only setver for .COM files
 40044                                  
 40045                                  	;mov	ax,[si+8]
 40046 000073BF 8B4408                  	mov	ax,[si+ERStruc.ER_PSP]
 40047 000073C2 83C010                  	add	ax,10h
 40048 000073C5 8EC0                    	mov	es,ax
 40049                                  
 40050                                  	;mov	cx,[si+10]
 40051 000073C7 8B4C0A                  	mov	cx,[si+ERStruc.ER_StartAddr]   ; M030
 40052                                  	;mov	cx,[si+12]
 40053 000073CA 8B440C                  	mov	ax,[si+ERStruc.ER_StartAddr+2] ; M030
 40054                                  
 40055                                  	;call	[ss:FixExePatch]
 40056 000073CD 36FF16[F311]            	call	word [ss:FixExePatch] ; 28/12/2022
 40057                                  	
 40058                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40059                                  	;call	[ss:Rational386PatchPtr]
 40060                                  
 40061                                  er_setver:
 40062                                  	;;test	word [si+2],2		; Q: is this an overlay
 40063                                  	; 17/12/2022
 40064 000073D2 F6440202                	test	byte [si+ERStruc.ER_Flags],ER_OVERLAY ; 2
 40065                                  	;test	word [si+ERStruc.ER_Flags],ER_OVERLAY
 40066 000073D6 7518                    	jnz	short er_chkdoshi	; Y: set A20OFF_COUNT if DOS high
 40067                                  					; N: set up lie version first
 40068 000073D8 1E                      	push	ds
 40069 000073D9 56                      	push	si
 40070                                  	;lds	si,[si+4]
 40071 000073DA C57404                  	lds	si,[si+ERStruc.ER_ProgName]
 40072 000073DD E876ED                  	call	Scan_Execname1
 40073 000073E0 E887ED                  	call	Scan_Special_Entries
 40074 000073E3 5E                      	pop	si
 40075 000073E4 1F                      	pop	ds
 40076                                  	;mov	es,[si+8]
 40077 000073E5 8E4408                  	mov	es,[si+ERStruc.ER_PSP]
 40078 000073E8 36A1[BD0E]              	mov	ax,[ss:SPECIAL_VERSION]
 40079 000073EC 26A34000                	mov	[es:PDB.Version],ax
 40080                                  
 40081                                  er_chkdoshi:
 40082 000073F0 36803E[F211]00          	cmp	byte [ss:DosHasHMA],0	; M032: Q: is dos in HMA (M021)
 40083 000073F6 741F                    	je	short er_done		; M032: N: done
 40084                                  
 40085                                  					; M068 - Start
 40086                                  	;mov	ax,[si+8]
 40087 000073F8 8B4408                  	mov	ax,[si+ERStruc.ER_PSP]	; ax = PSP
 40088                                  
 40089                                  	;or	byte [ss:DOS_FLAG],4
 40090 000073FB 36800E[8600]04          	or	byte [ss:DOS_FLAG],EXECA20OFF ; Set bit to signal int 21
 40091                                  					; ah = 25 & ah= 49. See dossym.inc 
 40092                                  					; under TAG M003 & M009 for 
 40093                                  					; explanation
 40094                                  	;;test	word [si+2],1
 40095                                  	; 17/12/2022
 40096 00007401 F6440201                	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
 40097                                  	;test	word [si+ERStruc.ER_Flags],ER_EXE ; Q: COM file
 40098 00007405 7507                    	jnz	short er_setA20		; N: inc a20off_count, set 
 40099                                  					;    a20off_psp and ret
 40100 00007407 1E                         	push	ds
 40101 00007408 8ED8                    	mov	ds,ax			; DS = load segment of com file.
 40102 0000740A E88E02                  	call	IsCopyProt		; check if copy protected
 40103 0000740D 1F                      	pop	ds
 40104                                  
 40105                                  er_setA20:
 40106                                  	; We need to inc the A20OFF_COUNT here. Note that if the count
 40107                                  	; is non-zero at this point it indicates that the A20 is to be 
 40108                                  	; turned off for that many int 21 calls made by the app. In 
 40109                                  	; addition the A20 has to be turned off when we exit from this 
 40110                                  	; call. Hence the inc.
 40111                                  
 40112 0000740E 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]		
 40113 00007413 36A3[6300]              	mov	[ss:A20OFF_PSP],ax	; set the PSP for which A20 is to be
 40114                                  					; turned OFF.
 40115                                  er_done:				; M068 - End
 40116 00007417 31C0                    	xor	ax,ax
 40117 00007419 C3                      	retn
 40118                                  
 40119                                  ; M028 - END
 40120                                  
 40121                                  
 40122                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40123                                  %if 0
 40124                                  
 40125                                  ;----------------------------------------------------------------------------
 40126                                  ;
 40127                                  ; procedure : Rational386Patch
 40128                                  ;
 40129                                  ; Older versions of the Rational DOS Extender have several bugs which trash
 40130                                  ; 386 registers (usually just the high word of 32 bit registers) during
 40131                                  ; interrupt processing. Lotus 123 3.1+ is a popular application that uses a
 40132                                  ; version of the Rational extender with the 32 bit register trashing bugs.
 40133                                  ;
 40134                                  ; This routine applies patches to the Rational DOS Extender to work around
 40135                                  ; most of the register trashing bugs.
 40136                                  ;
 40137                                  ; Note that there are additional register trashing bugs not fixed by these
 40138                                  ; patches. In particular, the high word of ESP and the FS and GS registers
 40139                                  ; may be modified on interrupts.
 40140                                  ;
 40141                                  ; There are two different Rational DOS Extender patchs in this module.
 40142                                  ; Rational386Patch is to correct 386 register trashing bugs on 386 or later
 40143                                  ; processors. This patch code is executed when MS-DOS is running on a 386
 40144                                  ; or later processor, regardless of whether MS-DOS is running in the HMA
 40145                                  ; or not.
 40146                                  ;
 40147                                  ; The other Rational patch routine (RationalPatch, below) fixes a register
 40148                                  ; trashing problem on 286 processors, and is only executed if MS-DOS is
 40149                                  ; running in the HMA.
 40150                                  ;
 40151                                  ; This patch detection and replacement is based on an example supplied by
 40152                                  ; Ben Williams at Rational.
 40153                                  ;
 40154                                  ;----------------------------------------------------------------------------
 40155                                  
 40156                                  ; 22/05/2019 - Retro DOS v4.0
 40157                                  ; DOSCODE:B448h (MSDOS 6.21, MSDOS.SYS)
 40158                                  
 40159                                  ;----------------------------------------------------------------------------
 40160                                  ;
 40161                                  ; INPUT : ES = segment where program got loaded
 40162                                  ;
 40163                                  ;----------------------------------------------------------------------------
 40164                                  
 40165                                  rpFind1:
 40166                                  	db	0FAh, 0E4h, 21h, 60h, 33h, 0C0h, 0E6h, 43h, 8Bh, 16h
 40167                                  
 40168                                  rpFind1Len equ	$ - rpFind1
 40169                                  
 40170                                  ;	cli
 40171                                  ;	in	al, 21h
 40172                                  ;	pusha
 40173                                  ;	xor	ax, ax
 40174                                  ;	out	43h, al
 40175                                  ;	mov	dx, ...
 40176                                  
 40177                                  rpFind1a:
 40178                                  	db	0B0h, 0Eh, 0E6h, 37h, 33h, 0C0h, 0E6h, 0F2h
 40179                                  
 40180                                  rpFind1aLen equ	$ - rpFind1a
 40181                                  
 40182                                  ;	mov	al, 0Eh
 40183                                  ;	out	37h, al
 40184                                  ;	xor	ax, ax
 40185                                  ;	out	0F2h, al
 40186                                  
 40187                                  ; bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI
 40188                                  
 40189                                  rpFind2:
 40190                                  	db	0Fh, 20h, 0C0h
 40191                                  
 40192                                  rpFind2Len equ	$ - rpFind2
 40193                                  
 40194                                  ;	mov	eax, cr0	;may be preceeded by PUSH CX (51h)
 40195                                  
 40196                                  rpFind3:
 40197                                  	db	0Fh, 22h, 0C0h, 0EAh
 40198                                  
 40199                                  rpFind3Len equ	$ - rpFind3
 40200                                  
 40201                                  ;	mov	cr0, eax	;may be preceeded by POP CX (59h)
 40202                                  ;	jmp	far ptr xxx	;change far ptr to go to replace3
 40203                                  ;	mov	ss, bx		;8E D3 ... and come back at or after this
 40204                                  
 40205                                  ; note, there is no rpRepl1 string
 40206                                  
 40207                                  rpRepl2:
 40208                                   	db	66h, 50h, 51h, 0Fh, 20h, 0C0h
 40209                                  
 40210                                  rpRepl2Len equ	$ - rpRepl2
 40211                                  
 40212                                  ;	push	eax
 40213                                  ;	push	cx
 40214                                  ;	mov	eax, cr0
 40215                                  
 40216                                  rpRepl3:
 40217                                  	db	8Eh, 0D3h, 59h, 66h, 58h
 40218                                  
 40219                                  rpRepl3Len equ	$ - rpRepl3
 40220                                  
 40221                                  ;	mov	ss, bx
 40222                                  ;	pop	cx
 40223                                  ;	pop	eax
 40224                                  
 40225                                  ; bug # 2 -- loss of high EAX and ESI on 386+ only if VCPI
 40226                                  
 40227                                  rpFind4:
 40228                                  	db	93h, 58h, 8Bh, 0CCh
 40229                                  
 40230                                  rpFind4Len equ	$ - rpFind4
 40231                                  
 40232                                  ;	xchg	bx, ax
 40233                                  ;	pop	ax
 40234                                  ;	mov	cx, sp
 40235                                  
 40236                                  rpFind5:
 40237                                  	db	0B8h, 0Ch, 0DEh, 0CDh, 67h, 8Bh, 0E1h, 0FFh, 0E3h
 40238                                  
 40239                                  rpFind5Len equ	$ - rpFind5
 40240                                  
 40241                                  ;	mov	ax, DE0Ch
 40242                                  ;	int	67h
 40243                                  ;	mov	sp, cx
 40244                                  ;	jmp	bx
 40245                                  
 40246                                  rpRepl4:
 40247                                  	db	93h, 58h, 8Bh, 0CCh
 40248                                  	db	02Eh, 066h, 0A3h
 40249                                  
 40250                                  rpRepl4o1Len equ $ - rpRepl4
 40251                                  
 40252                                  	db	00h, 00h
 40253                                  	db	02Eh, 066h, 89h, 36h
 40254                                  
 40255                                  rpRepl4o2Len equ $ - rpRepl4
 40256                                  
 40257                                  	db	00h, 00h
 40258                                  
 40259                                  rpRepl4Len equ	$ - rpRepl4
 40260                                  
 40261                                  ;	xchg	bx, ax
 40262                                  ;	pop	ax
 40263                                  ;	mov	cx, sp
 40264                                  ;	mov	dword ptr cs:[xxxx], eax
 40265                                  ;	mov	dword ptr cs:[xxxx], esi
 40266                                  
 40267                                  rpRepl5:
 40268                                  	db	8Bh, 0E1h
 40269                                  	db	2Eh, 66h, 0A1h
 40270                                  
 40271                                  rpRepl5o1Len equ $ - rpRepl5
 40272                                  
 40273                                  	db	00h, 00h
 40274                                  	db	2Eh, 66h, 8Bh, 36h
 40275                                  
 40276                                  rpRepl5o2Len equ $ - rpRepl5
 40277                                  
 40278                                  	db	00h, 00h
 40279                                  	db	0FFh, 0E3h
 40280                                  
 40281                                  rpRepl5Len equ	$ - rpRepl5
 40282                                  
 40283                                  ;	mov	sp, cx
 40284                                  ;	mov	eax, dword ptr cs:[xxxx]
 40285                                  ;	mov	esi, dword ptr cs:[xxxx]
 40286                                  ;	jmp	bx
 40287                                  
 40288                                  ; bug # 3 -- loss of high EAX, EBX, ECX, EDX on 386+ only if VCPI
 40289                                  
 40290                                  rpFind6:
 40291                                  	db	0FAh, 52h, 51h
 40292                                  
 40293                                  rpFind6Len equ	$ - rpFind6
 40294                                  
 40295                                  ;	cli
 40296                                  ;	push	dx
 40297                                  ;	push	cx
 40298                                  
 40299                                  rpFind7a:
 40300                                  	db	0B8h, 0Ch, 0DEh, 66h, 26h, 0FFh, 1Eh
 40301                                  
 40302                                  rpFind7aLen equ	$ - rpFind7a
 40303                                  
 40304                                  ;	mov	ax, 0DE0Ch
 40305                                  ;	call	fword ptr es:[xxxx]
 40306                                  
 40307                                  rpFind7b:
 40308                                  	db	59h, 5Ah, 5Bh
 40309                                  
 40310                                  rpFind7bLen equ	$ - rpFind7b
 40311                                  
 40312                                  ;	pop	cx
 40313                                  ;	pop	dx
 40314                                  ;	pop	bx
 40315                                  
 40316                                  rpRepl6 :
 40317                                  	db	0FAh, 66h, 50h, 66h, 53h, 66h, 51h, 66h, 52h
 40318                                  
 40319                                  rpRepl6Len equ	$ - rpRepl6
 40320                                  
 40321                                  ;	cli
 40322                                  ;	push	eax
 40323                                  ;	push	ebx
 40324                                  ;	push	ecx
 40325                                  ;	push	edx
 40326                                  
 40327                                  rpRepl7:
 40328                                  	db	66h, 5Ah, 66h, 59h, 66h, 5Bh, 66h, 58h, 5Bh
 40329                                  
 40330                                  rpRepl7Len equ	$ - rpRepl7
 40331                                  
 40332                                  ;	pop	edx
 40333                                  ;	pop	ecx
 40334                                  ;	pop	ebx
 40335                                  ;	pop	eax
 40336                                  ;	pop	bx
 40337                                  
 40338                                  ; bug # 4 -- loss of high EAX and EBX on 386+ only if VCPI
 40339                                  
 40340                                  rpFind8:
 40341                                   	db	60h, 06h, 1Eh, 0B8h, 00h, 00h, 8Eh, 0D8h
 40342                                  
 40343                                  rpFind8Len equ	$ - rpFind8
 40344                                  
 40345                                  ;	pusha
 40346                                  ;	push	es
 40347                                  ;	push	ds
 40348                                  ;	mov	ax, dgroup	;jump back to here from replace8
 40349                                  ;	mov	ds, ax
 40350                                  
 40351                                  rpFind9 :
 40352                                  	db	1Fh, 07h, 61h
 40353                                  
 40354                                  rpFind9Len equ	$ - rpFind9
 40355                                  
 40356                                  ;	pop	ds
 40357                                  ;	pop	es
 40358                                  ;	popa
 40359                                  
 40360                                  rpRepl8:
 40361                                   	db	66h, 60h, 06h, 1Eh
 40362                                  
 40363                                  rpRepl8Len equ	$ - rpRepl8
 40364                                  
 40365                                  ;	pushad
 40366                                  ;	push	es
 40367                                  ;	push	ds
 40368                                  
 40369                                  rpRepl9:
 40370                                  	db	1Fh, 07h, 66h, 61h, 0C3h
 40371                                  
 40372                                  rpRepl9Len equ	$ - rpRepl9
 40373                                  
 40374                                  ;	pop	ds
 40375                                  ;	pop	es
 40376                                  ;	popad
 40377                                  ;	retn			;no need to jmp back to main-line
 40378                                  
 40379                                  ;----------------------------------------------------------------------------
 40380                                  
 40381                                  struc SearchPair
 40382                                   .sp_off1: resw 1	; offset of 1st search string
 40383                                   .sp_len1: resw 1	; length of 1st search string
 40384                                   .sp_off2: resw 1	; 2nd string
 40385                                   .sp_len2: resw 1	; 2nd string
 40386                                   .sp_diff: resw 1	; max difference between offsets
 40387                                   .size:
 40388                                  endstruc
 40389                                  
 40390                                  ;rpBug1Strs SearchPair	<offset rpFind2, rpFind2Len, offset rpFind3, rpFind3Len, 20h>
 40391                                  
 40392                                  rpBug1Strs:
 40393                                  	dw	rpFind2
 40394                                  	dw	rpFind2Len ; 3
 40395                                  	dw	rpFind3
 40396                                  	dw	rpFind3Len ; 4
 40397                                  	dw	20h
 40398                                  
 40399                                  ;rpBug2Strs SearchPair	<offset rpFind4, rpFind4Len, offset rpFind5, rpFind5Len, 80h>
 40400                                  
 40401                                  rpBug2Strs:
 40402                                  	dw	rpFind4
 40403                                  	dw	rpFind4Len ; 4
 40404                                  	dw	rpFind5
 40405                                  	dw	rpFind5Len ; 9
 40406                                  	dw	80h
 40407                                  
 40408                                  ;rpBug3Strs SearchPair	<offset rpFind6, rpFind6Len, offset rpFind7a, rpFind7aLen, 80h>
 40409                                  
 40410                                  rpBug3Strs:
 40411                                  	dw	rpFind6
 40412                                  	dw	rpFind6Len ; 3
 40413                                  	dw	rpFind7a
 40414                                  	dw	rpFind7aLen ; 7
 40415                                  	dw	80h
 40416                                  
 40417                                  ;rpBug4Strs SearchPair	<offset rpFind8, 4, offset rpFind9, rpFind9Len, 80h>
 40418                                  
 40419                                  rpBug4Strs:
 40420                                  	dw	rpFind8
 40421                                  	dw	4
 40422                                  	dw	rpFind9
 40423                                  	dw	rpFind9Len ; 3
 40424                                  	dw	80h
 40425                                  
 40426                                  ;----------------------------------------------------------------------------
 40427                                  
 40428                                  struc StackVars
 40429                                   .sv_wVersion:	resw 1		; Rational extender version #
 40430                                   .sv_cbCodeSeg: resw 1		; code seg size to scan
 40431                                   .sv_pPatch:	resw 1		; offset of next avail patch byte
 40432                                   .size:
 40433                                  endstruc
 40434                                  
 40435                                  ;----------------------------------------------------------------------------
 40436                                  
 40437                                  ; 22/05/2019 - Retro DOS v4.0
 40438                                  
 40439                                  Rational386Patch:
 40440                                  	; Do a few quick checks to see if this looks like a Rational
 40441                                  	; Extended application. Hopefully this will quickly weed out
 40442                                  	; most non Rational apps.
 40443                                  
 40444                                  	cmp	word [es:0],395		; version number goes here - versions
 40445                                  	jae	short rp3QuickOut	;   3.95+ don't need patching
 40446                                  
 40447                                  	cmp	word [es:0Ch],20h	; always has this value here
 40448                                  	jne	short rp3QuickOut
 40449                                  
 40450                                  	push	ax
 40451                                  
 40452                                  	mov	ax,18h 			; extender has 18h at
 40453                                  	cmp	[es:24],ax		;   offsets 24, 28, & 36
 40454                                  	jne	short rp3QO_ax
 40455                                  	cmp	[es:28],ax
 40456                                  	jne	short rp3QO_ax
 40457                                  	cmp	[es:36],ax
 40458                                  	je	short rp3Maybe
 40459                                  rp3QO_ax:
 40460                                  	pop	ax
 40461                                  rp3QuickOut:
 40462                                  	retn
 40463                                  
 40464                                  ; It might be the rational extender, do more extensive checking
 40465                                  
 40466                                  rp3Maybe:
 40467                                  	cld
 40468                                  	push	bx			; note ax pushed above
 40469                                  	push	cx
 40470                                  	push	dx
 40471                                  	push	si
 40472                                  	push	di
 40473                                  	push	es
 40474                                  	push	ds			; we use all of them
 40475                                  	push	bp
 40476                                  	sub	sp,StackVars.size  ; 6	; make space for stack variables
 40477                                  	mov	bp,sp
 40478                                  
 40479                                  	push	cs
 40480                                  	pop	ds
 40481                                  
 40482                                  	mov	ax,[es:0]		; save version #
 40483                                  	;mov	[bp+StackVars.sv_wVersion],ax
 40484                                  	mov	[bp],ax	
 40485                                  					; check that binary version # matches
 40486                                  	call	VerifyVersion		;   ascii string
 40487                                  	jne	short rp3Exit_j
 40488                                  
 40489                                  ; Looks like this is it, find where to put the patch code.  The
 40490                                  ; patch will be located on top of Rational code specific to 80286
 40491                                  ; processors, so these patchs MUST NOT be applied if running on
 40492                                  ; an 80286 system.
 40493                                  
 40494                                  	; Rational says the code to patch will never be beyond offset 46xxh
 40495                                  
 40496                                  	mov	cx,4500h		; force search len to 4700h (searches
 40497                                  	;mov	[bp+2],cx
 40498                                  	mov	[bp+StackVars.sv_cbCodeSeg],cx	; start at offset 200h)
 40499                                  
 40500                                  	mov	es,[es:20h]		; es=code segment
 40501                                  
 40502                                  	mov	si,rpFind1		; string to find
 40503                                  	mov	dx,rpFind1Len ; 10	; length to match
 40504                                  	call	ScanCodeSeq		; look for code seq
 40505                                  	jz	short rpGotPatch
 40506                                  
 40507                                  ; According to Rational, some very old versions of the extender may not
 40508                                  ; have the find1 code sequence. If the find1 code wasn't found above,
 40509                                  ; try an alternative patch area which is on top of NEC 98xx switching code.
 40510                                  
 40511                                  	mov	si,rpFind1a
 40512                                  	mov	dx,rpFind1aLen  ;8
 40513                                  	call	ScanCodeSeq
 40514                                  	jz	short rpGotPatch
 40515                                  
 40516                                  rp3Exit_j:
 40517                                  	jmp	rp3Exit
 40518                                  
 40519                                  ; Found the location to write patch code! DI = offset in code seg.
 40520                                  
 40521                                  rpGotPatch:
 40522                                  	;mov	[bp+4],di
 40523                                  	mov	[bp-StackVars.sv_pPatch],di	; save patch pointer
 40524                                  
 40525                                  ;----------------------------------------------------------------------------
 40526                                  ; Bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI
 40527                                  
 40528                                  	;cmp	word [bp+0],381
 40529                                  	;cmp	word [bp+StackVars.sv_wVersion],381 ; only need bug 1 if version
 40530                                  	cmp	word [bp],381
 40531                                  	jae	short rpBug2			;   < 3.81
 40532                                  
 40533                                  	mov	bx,rpBug1Strs			; locate find2 & find3 code
 40534                                  	call	FindBadCode
 40535                                  	jc	short rpBug2
 40536                                  
 40537                                  ; si = rpFind2 offset, di = rpFind3 offset
 40538                                  
 40539                                  	push	di
 40540                                  	mov	di,si				; rpFind2 offset
 40541                                  	mov	dx,rpFind2Len ; 3
 40542                                  
 40543                                  	cmp	byte [es:di-1],51h	 	; find2 preceeded by push cx?
 40544                                  	jne	short rp_no_cx
 40545                                  
 40546                                  	dec	di				;   yes, gobble up push cx too
 40547                                  	inc	dx
 40548                                  rp_no_cx:
 40549                                  	mov	si,rpRepl2			; patch out find2 sequence
 40550                                  	mov	cx,rpRepl2Len  ; 6
 40551                                  	call	GenPatch
 40552                                  
 40553                                  	pop	di				; rpFind3 offset
 40554                                  	cmp	byte [es:di-1],59h 		; find3 preceeded by pop cx?
 40555                                  	jne	short rp_no_cx2
 40556                                  
 40557                                  	mov	byte [es:di-1],90h		;   yes, no-op it
 40558                                  rp_no_cx2:
 40559                                  	;mov	ax,[bp+4]
 40560                                  	mov	ax,[bp+StackVars.sv_pPatch]	; change offset of far jmp
 40561                                  	;mov	[es:di+4],ax
 40562                                  	mov	[es:di+rpFind3Len],ax		;   to go to patch code
 40563                                  
 40564                                  	push	di				; save find3 offset
 40565                                  	mov	si,rpRepl3			; copy repl3 to patch area
 40566                                  	mov	cx,rpRepl3Len ; 5
 40567                                  	call	CopyPatch
 40568                                  
 40569                                  	pop	bx				; find3 offset
 40570                                  	add	bx,rpFind3Len+4	 ; 8		; skip over find3 and far jmp
 40571                                  	call	GenJump 			; jmp back from patch area
 40572                                  	;mov	[bp+4],di
 40573                                  	mov	[bp+StackVars.sv_pPatch], di	;   to main-line, update patch
 40574                                  						;   area pointer
 40575                                  
 40576                                  ;----------------------------------------------------------------------------
 40577                                  ; Bug # 2 -- loss of high regs on 386+ under VCPI only
 40578                                  
 40579                                  rpBug2:
 40580                                  	mov	bx,rpBug2Strs			; locate find4 & find5 code
 40581                                  	call	FindBadCode
 40582                                  	jc	short rpBug3
 40583                                  
 40584                                  ; si = rpFind4 offset, di = rpFind5 offset
 40585                                  
 40586                                  	;push	word [bp+4]
 40587                                  	push	word [bp+StackVars.sv_pPatch]	; save current patch pointer
 40588                                  						;   (where repl4 goes)
 40589                                  	push	di				; save find5 offset
 40590                                  
 40591                                  	mov	di,si
 40592                                  	mov	dx,rpFind4Len ; 4
 40593                                  	mov	si,rpRepl4
 40594                                  	mov	cx,rpRepl4Len ; 15
 40595                                  	call	GenPatch			; patch out find4 code
 40596                                  
 40597                                  	pop	di				; find5 offset
 40598                                  	add	di,5				; keep 5 bytes of find5 code
 40599                                  	;mov	bx,[bp+4]
 40600                                  	mov	bx,[bp+StackVars.sv_pPatch]	; jump to patch area
 40601                                  	push	bx				; save repl5 location
 40602                                  	call	GenJump
 40603                                  
 40604                                  	mov	si,rpRepl5			; copy repl5 code to patch
 40605                                  	mov	cx,rpRepl5Len  ; 15		;   area -- it has a jmp bx
 40606                                  	call	CopyPatch			;   so no need to jmp back to
 40607                                  						;   main-line code
 40608                                  
 40609                                  ; patches have been made, now update the patch code to store/load dwords just
 40610                                  ; after the code in the patch area
 40611                                  
 40612                                  	pop	di				; repl5 location
 40613                                  	pop	si				; repl4 location
 40614                                  
 40615                                  	;mov	ax,[bp+4]
 40616                                  	mov	ax,[bp+StackVars.sv_pPatch]	; (where dwords go)
 40617                                  
 40618                                  	;mov	[es:si+7],ax
 40619                                  	mov	[es:si+rpRepl4o1Len],ax		; offset for EAX
 40620                                  	;mov	[es:di+5],ax
 40621                                  	mov	[es:di+rpRepl5o1Len],ax
 40622                                  	add	ax,4
 40623                                  	;mov	[es:si+0Dh],ax
 40624                                  	mov	[es:si+rpRepl4o2Len],ax		; offset for ESI
 40625                                  	;mov	[es:di+0Bh],ax
 40626                                  	mov	[es:di+rpRepl5o2Len],ax
 40627                                  
 40628                                  	;add	word [bp+4],8
 40629                                  	add	word [bp+StackVars.sv_pPatch],8	; reserve space for 2 dwords in
 40630                                  						; patch area
 40631                                  
 40632                                  ;----------------------------------------------------------------------------
 40633                                  ; Bug # 3 -- loss of high regs on 386+ under VCPI only
 40634                                  
 40635                                  rpBug3:
 40636                                  	mov	bx,rpBug3Strs			; locate find6 & find7a code
 40637                                  	call	FindBadCode
 40638                                  	jc	short rpBug4
 40639                                  
 40640                                  	;add	di,9
 40641                                  	add	di,rpFind7aLen + 2		; skip over offset in find7a
 40642                                  	push	si				;   code and locate find7b
 40643                                  	mov	si,rpFind7b			;   sequence
 40644                                  	mov	dx,rpFind7bLen ; 3
 40645                                  	call	ScanCodeSeq_di
 40646                                  	pop	si
 40647                                  	jnz	short rpBug4
 40648                                  
 40649                                  	push	di				; save find7b code offset
 40650                                  
 40651                                  	mov	di,si
 40652                                  	mov	dx,rpFind6Len ; 3
 40653                                  	mov	si,rpRepl6
 40654                                  	mov	cx,rpRepl6Len ; 9
 40655                                  	call	GenPatch			; patch out find6 code
 40656                                  
 40657                                  	pop	di
 40658                                  	mov	dx,rpFind7bLen ; 3
 40659                                  	mov	si,rpRepl7
 40660                                  	mov	cx,rpRepl7Len ; 9
 40661                                  	call	GenPatch			; patch out find7b code
 40662                                  
 40663                                  ;----------------------------------------------------------------------------
 40664                                  ; Bug # 4 -- loss of high regs on 386+ under VCPI only
 40665                                  
 40666                                  rpBug4:
 40667                                  	;cmp	word [bp+0],360
 40668                                  	;cmp	word [bp+StackVars.sv_wVersion],360 ; only applies if 
 40669                                  	cmp	word [bp],360
 40670                                  	jbe	short rp3Exit 			; version > 3.60 and < 3.95
 40671                                  
 40672                                  	mov	bx,rpBug4Strs			; locate find8 & find9 code
 40673                                  	call	FindBadCode
 40674                                  	jc	short rp3Exit
 40675                                  
 40676                                  	push	di				; save find9 code offset
 40677                                  
 40678                                  	mov	di,si
 40679                                  	mov	dx,3
 40680                                  	mov	si,rpRepl8
 40681                                  	mov	cx,rpRepl8Len ; 4
 40682                                  	call	GenPatch			; patch out find8 code
 40683                                  
 40684                                  	pop	di				; find9 offset
 40685                                  	;mov	bx,[bp+4]
 40686                                  	mov	bx,[bp+StackVars.sv_pPatch]	; patch find9 to jmp to
 40687                                  	call	GenJump 			;   patch area
 40688                                  
 40689                                  	mov	si,rpRepl9			; copy replacement code to
 40690                                  	mov	cx,rpRepl9Len ; 5		;   patch area--it does a RET
 40691                                  	call	CopyPatch			;   so no jmp back to main-line
 40692                                  
 40693                                  rp3Exit:
 40694                                  	add	sp,StackVars.size
 40695                                  	pop	bp
 40696                                  	pop	ds
 40697                                  	pop	es
 40698                                  	pop	di
 40699                                  	pop	si
 40700                                  	pop	dx
 40701                                  	pop	cx
 40702                                  	pop	bx
 40703                                  	pop	ax
 40704                                  	retn
 40705                                  
 40706                                  ;----------------------------------------------------------------------------
 40707                                  ;
 40708                                  ; FindBadCode
 40709                                  ;
 40710                                  ; Searches Rational code segment looking for a pair of find strings (all
 40711                                  ; patches have at least two find strings).
 40712                                  ;
 40713                                  ; Entry:
 40714                                  ;	ES    = code segment to search
 40715                                  ;	DS:BX = search pair structure for this search
 40716                                  ;	[bp].sv_cbCodeSeg = length of code seg to search
 40717                                  ;
 40718                                  ; Exit:
 40719                                  ;	CY flag clear if both strings found, and
 40720                                  ;	SI    = offset in ES of 1st string
 40721                                  ;	DI    = offset in ES of 2nd string
 40722                                  ;	CY set if either string not found, or strings too far apart
 40723                                  ;
 40724                                  ; Used:
 40725                                  ;	CX
 40726                                  ;
 40727                                  ;----------------------------------------------------------------------------
 40728                                  
 40729                                  ;struc SearchPair
 40730                                  ; .sp_off1: resw 1	; offset of 1st search string
 40731                                  ; .sp_len1: resw 1	; length of 1st search string
 40732                                  ; .sp_off2: resw 1	; 2nd string
 40733                                  ; .sp_len2: resw 1	; 2nd string
 40734                                  ; .sp_diff: resw 1	; max difference between offsets
 40735                                  ; .size:
 40736                                  ;endstruc
 40737                                  
 40738                                  FindBadCode:
 40739                                  	;mov	cx,[bp+2]
 40740                                  	mov	cx,[bp+StackVars.sv_cbCodeSeg]	; search length
 40741                                  
 40742                                  	mov	si,[bx]	; mov si,[bx+0]
 40743                                  	;mov	si,[bx+Searchpair.sp_off1] ; ds:si -> search string
 40744                                  	
 40745                                  	;mov	dx,[bx+2]
 40746                                  	mov	dx,[bx+SearchPair.sp_len1] ; dx = search len
 40747                                  	call	ScanCodeSeq
 40748                                  	jnz	short fbc_error		; done if 1st not found
 40749                                  
 40750                                  	push	di			; save 1st string offset
 40751                                  
 40752                                  	;mov	si,[bx+4]
 40753                                  	mov	si,[bx+SearchPair.sp_off2]
 40754                                  	;mov	dx,[bx+6]
 40755                                  	mov	dx,[bx+SearchPair.sp_len2]
 40756                                  	call	ScanCodeSeq_di		; don't change flags after this!
 40757                                  
 40758                                  	pop	si			; restore 1st string offset
 40759                                  	jnz	short fbc_error
 40760                                  
 40761                                  	mov	ax,di			; sanity check that
 40762                                  	sub	ax,si			;   si < di && di - si <= allowed diff
 40763                                  	jc	short fbc_error
 40764                                  	;cmp	ax,[bx+8]
 40765                                  	cmp	ax,[bx+SearchPair.sp_diff]
 40766                                  	ja	short fbc_error
 40767                                  
 40768                                  	clc
 40769                                  	retn
 40770                                  
 40771                                  fbc_error:
 40772                                  	stc
 40773                                  	retn
 40774                                  
 40775                                  ;----------------------------------------------------------------------------
 40776                                  ;
 40777                                  ; GenPatch
 40778                                  ;
 40779                                  ; Generate a patch sequence. 1) insert a jump at the buggy code location
 40780                                  ; (jumps to the patch code area), 2) copy the selected patch code to the
 40781                                  ; patch area, 3) insert a jump from the patch area back to the main-line
 40782                                  ; code.
 40783                                  ;
 40784                                  ; Entry:
 40785                                  ;	ES:DI = start of buggy code to be patched
 40786                                  ;	DX    = length of buggy code to be patched
 40787                                  ;	DS:SI = replacement patch code
 40788                                  ;	CX    = length of replacement patch code
 40789                                  ;	[bp].sv_pPatch = offset in ES of where to copy patch code
 40790                                  ;
 40791                                  ; Exit:
 40792                                  ;	DI, [bp].sv_pPatch = byte after generated patch code
 40793                                  ;
 40794                                  ; Used:
 40795                                  ;	AX, BX, SI, Flags
 40796                                  ;
 40797                                  ;----------------------------------------------------------------------------
 40798                                  
 40799                                  GenPatch:
 40800                                  	push	di			;save offset of buggy code
 40801                                  
 40802                                  	;mov	bx,[bp+4]
 40803                                  	mov	bx,[bp+StackVars.sv_pPatch]
 40804                                  					;jump from buggy code to patch area
 40805                                  	call	GenJump
 40806                                  
 40807                                  	call	CopyPatch		;copy replacement code to patch area
 40808                                  
 40809                                  	pop	bx			;offset of buggy code + buggy code
 40810                                  	add	bx,dx			;  length = return from patch offset
 40811                                  
 40812                                  	call	GenJump 		;jump from patch area back to main-
 40813                                  	;mov	[bp+4],di
 40814                                  	mov	[bp+StackVars.sv_pPatch],di
 40815                                  					;  line code, update patch pointer
 40816                                  	retn
 40817                                  
 40818                                  ;----------------------------------------------------------------------------
 40819                                  ;
 40820                                  ; CopyPatch
 40821                                  ;
 40822                                  ; Copies patch code to patch location.
 40823                                  ;
 40824                                  ; Entry:
 40825                                  ;	DS:SI = patch code to be copied
 40826                                  ;	ES    = segment of code to patch
 40827                                  ;	CX    = length of code to copy
 40828                                  ;	[bp].sv_pPatch = offset in ES of where to copy patch code
 40829                                  ;
 40830                                  ; Exit:
 40831                                  ;	DI, [bp].sv_pPatch = byte after copied patch code
 40832                                  ;
 40833                                  ; Used:
 40834                                  ;	SI, Flags
 40835                                  ;
 40836                                  ;----------------------------------------------------------------------------
 40837                                  
 40838                                  CopyPatch:
 40839                                  	push	cx
 40840                                  	;mov	di,[bp+4]
 40841                                  	mov	di,[bp+StackVars.sv_pPatch] ;patch pointer is the dest offset
 40842                                  	cld
 40843                                  	rep movsb
 40844                                  	pop	cx
 40845                                  	;mov	[bp+4],di
 40846                                  	mov	[bp+StackVars.sv_pPatch],di ;update net pointer location
 40847                                  	retn
 40848                                  
 40849                                  ;----------------------------------------------------------------------------
 40850                                  ;
 40851                                  ; GenJump
 40852                                  ;
 40853                                  ; Generates a rel16 JMP instruction at location 'from' to location 'to'.
 40854                                  ;
 40855                                  ; Entry:
 40856                                  ;	ES:DI = from location (where to put jmp instruction)
 40857                                  ;	BX    = to location (where to jump to)
 40858                                  ;
 40859                                  ; Exit:
 40860                                  ;	DI = byte after generated jump
 40861                                  ;
 40862                                  ; Used:
 40863                                  ;	AX
 40864                                  ;
 40865                                  ;----------------------------------------------------------------------------
 40866                                  
 40867                                  GenJump:
 40868                                  	mov	al,0E9h		; jmp rel16 opcode
 40869                                  	stosb
 40870                                  
 40871                                  	mov	ax,bx		; calc offset to 'to' location
 40872                                  	sub	ax,di
 40873                                  	sub	ax,2
 40874                                  
 40875                                  	stosw			; output offset
 40876                                  
 40877                                  	retn
 40878                                  
 40879                                  ;----------------------------------------------------------------------------
 40880                                  ;
 40881                                  ; ScanCodeSeq
 40882                                  ;
 40883                                  ; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
 40884                                  ;
 40885                                  ; returns in ES:DI the start of the pattern if Zero flag is set
 40886                                  ;
 40887                                  ;----------------------------------------------------------------------------
 40888                                  
 40889                                  ScanCodeSeq:
 40890                                  	mov	di,200h
 40891                                  ScanCodeSeq_di:
 40892                                  	push	cx
 40893                                  	sub	cx,dx
 40894                                  	inc	cx
 40895                                  scsagain:
 40896                                  	push	si
 40897                                  	push	di
 40898                                  	push	cx
 40899                                  	mov	cx,dx
 40900                                  	rep	cmpsb
 40901                                  	pop	cx
 40902                                  	pop	di
 40903                                  	pop	si
 40904                                  	je	short scsfound
 40905                                  	inc	di
 40906                                  	loop	scsagain
 40907                                  scsfound:
 40908                                  	pop	cx
 40909                                  vvexit:		; 18/12/2022
 40910                                  	retn
 40911                                  	
 40912                                  ;----------------------------------------------------------------------------
 40913                                  ;
 40914                                  ; VerifyVersion
 40915                                  ;
 40916                                  ; Checks whether the binary version from ES:0 matches the ASCII version
 40917                                  ; from ES:2A.
 40918                                  ;
 40919                                  ;       Entry: AX = binary version number 
 40920                                  ;       Exit : Z flag set if version numbers match
 40921                                  ;
 40922                                  ;----------------------------------------------------------------------------
 40923                                  
 40924                                  VerifyVersion:
 40925                                  	mov	si,[es:2Ah]		; offset of version number
 40926                                  					;  in ascii
 40927                                  	mov	bl,10
 40928                                  	add	si,3			; point to last digit
 40929                                  
 40930                                  	call	VVDigit
 40931                                  	jne	short vvexit
 40932                                  	call	VVDigit
 40933                                  	jne	short vvexit
 40934                                  	cmp	byte [es:si],'.'
 40935                                  	jne	short vvexit
 40936                                  	dec	si
 40937                                  	;call	VVDigit
 40938                                  	; 18/12/2022
 40939                                  	;jmp	short VVDigit
 40940                                  ;vvexit:
 40941                                  	;retn
 40942                                  VVDigit:
 40943                                  	div	bl
 40944                                  	add	ah,'0'
 40945                                  	dec	si
 40946                                  	cmp	[es:si+1],ah
 40947                                  	mov	ah,0			; do not xor or sub we need Z
 40948                                  	retn
 40949                                  
 40950                                  %endif
 40951                                  
 40952                                  ;-----------------------------------------------------------------------
 40953                                  
 40954                                  ; 23/05/2019 - Retro DOS v4.0
 40955                                  ; DOSCODE:B702h (MSDOS 6.21, MSDOS.SYS)
 40956                                  
 40957                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40958                                  ; DOSCODE:B3E0h (MSDOS 5.0, MSDOS.SYS)
 40959                                  
 40960                                  exepatch_start:	 ; label byte
 40961                                  
 40962                                  	; The following is the code that'll be layed over the buggy unpack
 40963                                  	; code.
 40964                                  str1:
 40965 0000741A 06                      	db  06h	  		;push	es		 
 40966 0000741B 8CD8                    	db  8Ch,0D8h		;mov	ax,ds 
 40967                                  
 40968                                  first_stop equ	$-str1
 40969                                  			
 40970 0000741D 2BC2                    	db  2Bh, 0C2h		;sub	ax, dx			
 40971                                  
 40972                                  first:  ; label	byte
 40973                                  
 40974 0000741F 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 40975 00007421 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 40976 00007423 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 40977 00007426 57                      	db  57h	    		;push	di
 40978 00007427 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 40979 0000742A B0FF                    	db  0B0h,0FFh 		;mov	al,0FFH 		
 40980 0000742C F3AE                    	db  0F3h,0AEh 		;repz	scasb			
 40981 0000742E 47                      	db  47h	    		;inc	di			
 40982 0000742F 8BF7                    	db  8Bh,0F7h  		;mov	si,di			
 40983 00007431 5F                      	db  5Fh	    		;pop	di
 40984 00007432 58                      	db  58h	    		;pop	ax
 40985                                  
 40986                                  second_stop equ	$-first
 40987                                  
 40988 00007433 2BC2                    	db  2Bh,0C2h  		;sub	ax, dx			
 40989                                  
 40990                                  second: ; label	byte
 40991                                  
 40992 00007435 8EC0                    	db  8Eh,0C0h  		;mov	es,ax			
 40993                                  		    		;NextRec:				
 40994 00007437 B90402                  	db  0B9h,04h,02h	;mov	cx, 0204h
 40995                                  		    		;norm_agn:				
 40996 0000743A 8BC6                    	db  8Bh,0C6h		;mov	ax,si			
 40997 0000743C F7D0                    	db  0F7h,0D0h		;not	ax		
 40998 0000743E D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 40999 00007440 7413                    	db  74h,13h		;jz	short SI_ok			
 41000 00007442 8CDA                    	db  8Ch,0DAh		;mov	dx,ds			
 41001 00007444 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H
 41002 00007447 2BD0                    	db  2Bh,0D0h		;sub	dx,ax			
 41003 00007449 7308                    	db  73h,08h		;jnc	short SItoDS			
 41004 0000744B F7DA                    	db  0F7h,0DAh		;neg	dx			
 41005 0000744D D3E2                    	db  0D3h,0E2h		;shl	dx,cl			
 41006 0000744F 2BF2                    	db  2Bh,0F2h		;sub	si,dx			
 41007 00007451 33D2                    	db  33h,0D2h		;xor	dx,dx			
 41008                                  				;SItoDS: 				
 41009 00007453 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 41010                                  				;SI_ok:					
 41011 00007455 87F7                    	db  87h,0F7h		;xchg	si,di			
 41012 00007457 1E                      	db  1Eh			;push	ds			
 41013 00007458 06                      	db  06h			;push	es			
 41014 00007459 1F                      	db  1Fh			;pop	ds			
 41015 0000745A 07                      	db  07h			;pop	es			
 41016 0000745B FECD                    	db  0FEh,0CDh		;dec	ch			
 41017 0000745D 75DB                    	db  75h,0DBh		;jnz	short norm_agn		
 41018 0000745F AC                      	db  0ACh		;lodsb			
 41019 00007460 92                      	db  92h			;xchg	dx,ax
 41020 00007461 4E                      	db  4Eh			;dec	si
 41021 00007462 AD                      	db  0ADh		;lodsw			
 41022 00007463 8BC8                    	db  8Bh,0C8h		;mov	cx,ax		
 41023 00007465 46                      	db  46h			;inc	si		
 41024 00007466 8AC2                    	db  8Ah,0C2h		;mov	al,dl		
 41025 00007468 24FE                    	db  24h,0FEh		;and	al,0FEH		
 41026 0000746A 3CB0                    	db  3Ch,0B0h		;cmp	al,RPTREC
 41027 0000746C 7505                    	db  75h,05h		;jne	short TryEnum
 41028 0000746E AC                      	db  0ACh		;lodsb				
 41029 0000746F F3AA                    	db  0F3h,0AAh		;rep stosb			
 41030                                  
 41031                                  ;	db  0EBh,07h,90h	;jmp	short TryNext
 41032 00007471 EB06                    	db  0EBh,06h		;jmp	short TryNext
 41033                                  
 41034                                  				;TryEnum:
 41035 00007473 3CB2                    	db  3Ch,0B2h		;cmp	al,ENMREC
 41036 00007475 756C                    	db  75h,6Ch		;jne	short CorruptExe		
 41037 00007477 F3A4                    	db  0F3h,0A4h		;rep movsb			
 41038                                  				;TryNext:
 41039                                  
 41040 00007479 92                      	db  92h			;xchg	dx,ax
 41041                                  ;	db  8Ah,0C2h		;mov	al,dl			
 41042                                  
 41043 0000747A A801                    	db  0A8h,01h		;test	al,1			
 41044 0000747C 74B9                    	db  74h,0B9h		;jz	short NextRec			
 41045 0000747E 9090                    	db  90h,90h		;nop,nop
 41046                                  	
 41047                                  last_stop equ $-second
 41048                                  size_str1 equ $-str1
 41049                                  
 41050                                  	; The following is the code that we need to look for in the exe
 41051                                  	; file.
 41052                                  
 41053                                  scan_patch1: ; label byte
 41054                                  
 41055 00007480 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 41056 00007482 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 41057 00007484 2BC2                    	db  2Bh,0C2h		;sub	ax,dx
 41058 00007486 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 41059 00007488 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 41060 0000748A BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 41061 0000748D B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 41062 00007490 B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 41063 00007492 F3AE                    	db  0F3h,0AEh		;repz	scasb			
 41064 00007494 47                      	db  47h			;inc	di			
 41065 00007495 8BF7                    	db  8Bh,0F7h		;mov	si,di
 41066 00007497 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 41067 00007499 2BC2                    	db  2Bh,0C2h		;sub	ax, dx
 41068 0000749B 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 41069 0000749D BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 41070                                  				;NextRec:
 41071 000074A0 B104                    	db  0B1h,04h		;mov	cl,4
 41072 000074A2 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 41073 000074A4 F7D0                    	db  0F7h,0D0h		;not	ax		
 41074 000074A6 D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 41075 000074A8 7409                    	db  74h,09h		;jz	short SI_ok
 41076 000074AA 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 41077 000074AC 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41078 000074AE 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 41079 000074B0 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H	       
 41080                                  	       			;SI_ok:
 41081 000074B3 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 41082 000074B5 F7D0                    	db  0F7h,0D0h		;not	ax
 41083 000074B7 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 41084 000074B9 7409                    	db  74h,09h		;jz	short DI_ok
 41085 000074BB 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 41086 000074BD 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41087 000074BF 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 41088 000074C1 83CFF0                  	db  83h,0CFh,0F0h	;or	di,0FFF0H
 41089                                  				;DI_ok:
 41090                                  
 41091                                  size_scan_patch1 equ $-scan_patch1
 41092                                  
 41093                                  scan_patch2: ; label byte
 41094                                  			
 41095 000074C4 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 41096 000074C6 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 41097 000074C8 48                      	db  48h			;dec	ax
 41098 000074C9 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 41099 000074CB 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 41100 000074CD BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 41101 000074D0 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 41102 000074D3 B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 41103 000074D5 F3AE                    	db  0F3h,0AEh		;repz	scasb			
 41104 000074D7 47                      	db  47h			;inc	di			
 41105 000074D8 8BF7                    	db  8Bh,0F7h		;mov	si,di
 41106 000074DA 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 41107 000074DC 48                      	db  48h			;dec	ax
 41108 000074DD 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 41109 000074DF BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH		
 41110                                  				;NextRec:
 41111 000074E2 B104                    	db  0B1h,04h		;mov	cl,4
 41112 000074E4 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 41113 000074E6 F7D0                    	db  0F7h,0D0h		;not	ax		
 41114 000074E8 D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 41115 000074EA 740A                    	db  74h,0Ah		;jz	short SI_ok
 41116 000074EC 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 41117 000074EE 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41118 000074F0 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 41119 000074F2 81CEF0FF                	db  81h,0CEh,0F0h,0FFh
 41120                                  				;or	si,0FFF0H
 41121                                  				;SI_ok:
 41122 000074F6 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 41123 000074F8 F7D0                    	db  0F7h,0D0h		;not	ax
 41124 000074FA D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 41125 000074FC 740A                    	db  74h,0Ah		;jz	short DI_ok
 41126 000074FE 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 41127 00007500 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41128 00007502 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 41129 00007504 81CFF0FF                	db  81h,0CFh,0F0h,0FFh
 41130                                  				;or	di,0FFF0H
 41131                                  				;DI_ok:
 41132                                  
 41133                                  size_scan_patch2 equ $-scan_patch2
 41134                                  
 41135                                  scan_patch3: ; label byte
 41136                                  
 41137 00007508 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 41138 0000750A 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 41139 0000750C 48                      	db  48h			;dec	ax
 41140 0000750D 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 41141 0000750F 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 41142 00007511 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 41143 00007514 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 41144 00007517 B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 41145 00007519 F3AE                    	db  0F3h,0AEh		;repz	scasb			
 41146 0000751B 47                      	db  47h			;inc	di			
 41147 0000751C 8BF7                    	db  8Bh,0F7h		;mov	si,di
 41148 0000751E 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 41149 00007520 48                      	db  48h			;dec	ax
 41150 00007521 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 41151 00007523 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH		
 41152                                  				;NextRec:
 41153 00007526 B104                    	db  0B1h,04h		;mov	cl,4
 41154 00007528 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 41155 0000752A F7D0                    	db  0F7h,0D0h		;not	ax		
 41156 0000752C D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 41157 0000752E 7409                    	db  74h,09h		;jz	short SI_ok
 41158 00007530 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 41159 00007532 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41160 00007534 8EDA                    	db  8Eh,0DAh		;mov	ds,dx	
 41161 00007536 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H	
 41162                                  				;SI_ok:
 41163 00007539 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 41164 0000753B F7D0                    	db  0F7h,0D0h		;not	ax
 41165 0000753D D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 41166 0000753F 7409                    	db  74h,09h		;jz	short DI_ok
 41167 00007541 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 41168 00007543 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41169 00007545 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 41170 00007547 83CFF0                  	db  83h,0CFh,0F0h	;or	di,0FFF0H
 41171                                  				;DI_ok:
 41172                                  
 41173                                  size_scan_patch3 equ $-scan_patch3
 41174                                  
 41175                                  scan_com: ; label byte
 41176                                  
 41177 0000754A AC                      	db  0ACh		;lodsb			
 41178 0000754B 8AD0                    	db  8Ah,0D0h		;mov	dl,al		
 41179 0000754D 4E                      	db  4Eh			;dec	si
 41180 0000754E AD                      	db  0ADh		;lodsw			
 41181 0000754F 8BC8                    	db  8Bh,0C8h		;mov	cx,ax		
 41182 00007551 46                      	db  46h			;inc	si		
 41183 00007552 8AC2                    	db  8Ah,0C2h		;mov	al,dl		
 41184 00007554 24FE                    	db  24h,0FEh		;and	al,0FEH		
 41185 00007556 3CB0                    	db  3Ch,0B0h		;cmp	al,RPTREC
 41186 00007558 7506                    	db  75h,06h		;jne	short TryEnum
 41187 0000755A AC                      	db  0ACh		;lodsb				
 41188 0000755B F3AA                    	db  0F3h,0AAh		;rep stosb			
 41189 0000755D EB0790                  	db  0EBh,07h,90h	;jmp	short TryNext
 41190                                  				;TryEnum:
 41191 00007560 3CB2                    	db  3Ch,0B2h		;cmp	al,ENMREC
 41192 00007562 756B                    	db  75h,6Bh		;jne	short CorruptExe		
 41193 00007564 F3A4                    	db  0F3h,0A4h		;rep movsb			
 41194                                  				;TryNext:
 41195 00007566 8AC2                    	db  8Ah,0C2h		;mov	al,dl			
 41196 00007568 A801                    	db  0A8h,01h		;test	al,1			
 41197                                  ;	db  74h,0BAh		;jz	short NextRec			
 41198                                  
 41199                                  size_scan_com	equ	$-scan_com
 41200                                  
 41201                                  ;-----------------------------------------------------------------------
 41202                                  
 41203                                  ; 23/05/2019 - Retro DOS v4.0
 41204                                  ; DOSCODE:B852h (MSDOS 6.21, MSDOS.SYS)
 41205                                  
 41206                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41207                                  ; DOSCODE:B530h (MSDOS 5.0, MSDOS.SYS)
 41208                                  
 41209                                  ExePatch:
 41210                                  	; 28/12/2022 - Retro DOS v4.1
 41211                                  	;call	ExePackPatch
 41212                                  	;;call	word [ss:RationalPatchPtr]
 41213                                  	;retn
 41214                                  	; 28/12/2022
 41215                                  	;jmp	short ExePackPatch
 41216                                  
 41217                                  ;-----------------------------------------------------------------------
 41218                                  ;
 41219                                  ; Procedure Name 	: ExePackPatch
 41220                                  ;
 41221                                  ; Inputs	 	: DS 			-> DOSDATA
 41222                                  ;			  ES:0 			-> read in image
 41223                                  ;			  ax:cx = start cs:ip of program
 41224                                  ; Output		:		
 41225                                  ;
 41226                                  ;	1. If ES <= 0fffh
 41227                                  ;	   2. if exepack signature ('RB') found
 41228                                  ;	      3. if common code to patch compares (for 3 diff. versions)
 41229                                  ;	       	 4. if rest of the code & checksum compares
 41230                                  ;	  	    5. overlay buggy code with code in 
 41231                                  ;		       doscode:str1.
 41232                                  ;		 6. endif
 41233                                  ;	      7. endif
 41234                                  ;	   8. endif
 41235                                  ;	9. endif
 41236                                  ;
 41237                                  ;
 41238                                  ; Uses			: NONE
 41239                                  ;
 41240                                  ;-----------------------------------------------------------------------
 41241                                  		
 41242                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41243                                  	; 23/05/2019 - Retro DOS v4.0	
 41244                                  ExePackPatch:
 41245 0000756A 53                      	push	bx
 41246 0000756B 8CC3                    	mov	bx,es			; bx has load segment
 41247 0000756D 81FBFF0F                	cmp	bx,0FFFh		; Q: is the load segment > 64K
 41248 00007571 7602                    	jbe	short ep_cont		; N: 
 41249 00007573 5B                      	pop	bx			; Y: no need to patch
 41250 00007574 C3                      	retn
 41251                                  ep_cont:
 41252 00007575 1E                      	push	ds
 41253 00007576 06                      	push	es
 41254 00007577 50                      	push	ax
 41255 00007578 51                      	push	cx
 41256 00007579 56                      	push	si
 41257 0000757A 57                      	push	di
 41258                                  	
 41259                                  		; M033 - start
 41260                                  		; exepacked programs have an IP of 12h (>=2)
 41261                                  
 41262 0000757B 83E902                  	sub	cx,2			; Q: is IP >=2 
 41263 0000757E 7303                    	jnb	short epp_1		; N: exit
 41264 00007580 E9C500                  	jmp	ep_notpacked
 41265                                  					; ax:cx now points to location of
 41266                                  					; 'RB' if this is an exepacked file.
 41267                                  		; M033 - end
 41268                                  epp_1:
 41269 00007583 89CF                    	mov	di,cx
 41270 00007585 8EC0                    	mov	es,ax
 41271 00007587 36893E[8700]            	mov	[ss:UNPACK_OFFSET],di	; save pointer to 'RB' in 
 41272                                  					; unpack_offset
 41273                                  
 41274 0000758C 26813D5242              	cmp	word [es:di],'RB' ; 4252h
 41275                                  	;ljne	ep_notpacked
 41276 00007591 7403                    	je	short epp_2
 41277 00007593 E9B200                  	jmp	ep_notpacked
 41278                                  epp_2:
 41279 00007596 0E                      	push	cs
 41280 00007597 1F                      	pop	ds			; set ds to cs
 41281                                  
 41282                                  	;add	di,6Ch
 41283 00007598 83C76C                  	add	di,PATCH1_COM_OFFSET	; es:di -> points to place in packed 
 41284                                  					;          file where we hope to find
 41285                                  					;	   scan string. 
 41286                                  
 41287 0000759B E8B200                  	call	chk_common_str		; check for match
 41288                                  
 41289 0000759E 7524                    	jnz	short ep_chkpatch2	; Q: does the patch match
 41290                                  					; N: check at patch2_offset
 41291                                  					; Y: check for rest of patch string
 41292 000075A0 BE[8074]                	mov	si,scan_patch1
 41293                                  					; ds:si -> scan string 
 41294 000075A3 368B3E[8700]            	mov	di,[ss:UNPACK_OFFSET]	; restore di to point to 'RB'
 41295                                  
 41296                                  	;add	di,28h
 41297                                  	; 07/12/2022
 41298 000075A8 83C728                  	add	di,PATCH1_OFFSET	; es:di -> points to place in packed 
 41299                                  					;          file where we hope to find
 41300                                  					;	   scan string. 
 41301                                  	;mov	cx,68
 41302 000075AB B94400                  	mov	cx,size_scan_patch1
 41303                                  	;mov	bx,142
 41304 000075AE BB8E00                  	mov	bx,CHKSUM1_LEN
 41305                                  	;mov	ax,0EF4Eh
 41306 000075B1 B84EEF                  	mov	ax,PATCH1_CHKSUM
 41307 000075B4 E8AD00                  	call	chk_patchsum		; check if patch and chk sum compare
 41308 000075B7 7208                    	jc	short ep_done1		; Q: did we pass the test
 41309                                  					; N: exit
 41310                                  					; Y: overlay code with new 
 41311 000075B9 BE[1A74]                	mov	si,str1
 41312                                  	;mov	cx,102
 41313 000075BC B96600                  	mov	cx,size_str1
 41314                                  	
 41315 000075BF F3A4                    	rep	movsb
 41316                                  ep_done1:
 41317 000075C1 E98400                  	jmp	ep_done
 41318                                  
 41319                                  ep_chkpatch2:
 41320                                  	;mov	di,76h
 41321 000075C4 BF7600                  	mov	di,PATCH2_COM_OFFSET	; es:di -> possible location of patch
 41322                                  					; in another version of unpack
 41323 000075C7 E88600                  	call	chk_common_str		; check for match
 41324                                  
 41325 000075CA 7544                    	jnz	short ep_chkpatch3	; Q: does the patch match
 41326                                  					; N: check for patch3_offset
 41327                                  					; Y: check for rest of patch string
 41328                                  
 41329 000075CC BE[C474]                	mov	si,scan_patch2
 41330                                  					; ds:si -> scan string 
 41331                                  	;mov	di,32h
 41332 000075CF BF3200                  	mov	di,PATCH2_OFFSET	; es:di -> points to place in packed 
 41333                                  					;          file where we hope to find
 41334                                  	;mov	cx,68			;	   scan string. 
 41335 000075D2 B94400                  	mov	cx,size_scan_patch2
 41336                                  	;mov	bx,140
 41337 000075D5 BB8C00                  	mov	bx,CHKSUM2_LEN
 41338                                  	;mov	ax,78B2h
 41339 000075D8 B8B278                  	mov	ax,PATCH2_CHKSUM
 41340 000075DB E88600                  	call	chk_patchsum		; check if patch and chk sum compare
 41341                                  
 41342                                  					; M046 - Start
 41343                                  					; Q: did we pass the test
 41344 000075DE 7311                    	jnc	short ep_patchcode2		; Y: overlay code with new 
 41345                                  					; N: try with a different chksum
 41346                                  
 41347 000075E0 BE[C474]                	mov	si,scan_patch2
 41348                                  					; ds:si -> scan string 
 41349                                  	;mov	cx,68
 41350 000075E3 B94400                  	mov	cx,size_scan_patch2
 41351                                  	;mov	bx,129
 41352 000075E6 BB8100                  	mov	bx,CHKSUM2A_LEN
 41353                                  	;mov	ax,1C47h
 41354 000075E9 B8471C                  	mov	ax,PATCH2A_CHKSUM
 41355 000075EC E87500                  	call	chk_patchsum		; check if patch and chk sum compare
 41356                                  					; Q: did we pass the test
 41357 000075EF 7257                    	jc	short ep_notpacked		; N: try with a different chksum
 41358                                  					; Y: overlay code with new 
 41359                                  						
 41360                                  ep_patchcode2:			       	; M046 - End
 41361 000075F1 BE[1A74]                	mov	si,str1
 41362                                  	;mov	cx,3
 41363 000075F4 B90300                  	mov	cx,first_stop
 41364 000075F7 F3A4                    	rep	movsb
 41365 000075F9 B89048                  	mov	ax,4890h		; ax = opcodes for dec ax, nop
 41366 000075FC AB                      	stosw
 41367 000075FD 83C602                  	add	si,2
 41368                                  	;mov	cx,20
 41369 00007600 B91400                  	mov	cx,second_stop
 41370 00007603 F3A4                    	rep	movsb
 41371 00007605 AB                      	stosw				; put in dec ax and nop
 41372 00007606 83C602                  	add	si,2
 41373                                  	;mov	cx,75
 41374 00007609 B94B00                  	mov	cx,last_stop
 41375 0000760C F3A4                    	rep	movsb
 41376 0000760E EB38                    	jmp	short ep_done
 41377                                  
 41378                                  ep_chkpatch3:
 41379                                  	;mov	di,74h
 41380 00007610 BF7400                  	mov	di,PATCH3_COM_OFFSET	; es:di -> possible location of patch
 41381                                  					; in another version of unpack
 41382 00007613 E83A00                  	call	chk_common_str		; check for match
 41383                                  
 41384 00007616 7530                    	jnz	short ep_notpacked	; Q: does the patch match
 41385                                  					; N: exit
 41386                                  					; Y: check for rest of patch string
 41387 00007618 BE[0875]                	mov	si,scan_patch3
 41388                                  					; ds:si -> scan string 
 41389                                  	;mov	di,32h
 41390 0000761B BF3200                  	mov	di,PATCH3_OFFSET	; es:di -> points to place in packed 
 41391                                  					;          file where we hope to find
 41392                                  					;	   scan string. 
 41393                                  	;mov	cx,66
 41394 0000761E B94200                  	mov	cx,size_scan_patch3
 41395                                  	;mov	bx,139
 41396 00007621 BB8B00                  	mov	bx,CHKSUM3_LEN
 41397                                  	;mov	ax,4EDEh
 41398 00007624 B8DE4E                  	mov	ax,PATCH3_CHKSUM
 41399 00007627 E83A00                  	call	chk_patchsum		; check if patch and chk sum compare
 41400 0000762A 721C                    	jc	short ep_notpacked	; Q: did we pass the test
 41401                                  					; N: exit
 41402                                  					; Y: overlay code with new 
 41403 0000762C BE[1A74]                	mov	si,str1
 41404                                  	;mv	cx,3
 41405 0000762F B90300                  	mov	cx,first_stop
 41406 00007632 F3A4                    	rep	movsb
 41407 00007634 B048                    	mov	al,48h			; al = opcode for dec ax
 41408 00007636 AA                      	stosb
 41409 00007637 83C602                  	add	si,2
 41410                                  	;mov	cx,20
 41411 0000763A B91400                  	mov	cx,second_stop
 41412 0000763D F3A4                    	rep	movsb
 41413 0000763F AA                      	stosb				; put in dec ax
 41414 00007640 83C602                  	add	si,2
 41415                                  	;mov	cx,75
 41416 00007643 B94B00                  	mov	cx,last_stop
 41417 00007646 F3A4                    	rep	movsb
 41418                                  
 41419                                  ep_notpacked:
 41420                                  	;stc
 41421                                  ep_done:
 41422 00007648 5F                      	pop	di
 41423 00007649 5E                      	pop	si
 41424 0000764A 59                      	pop	cx
 41425 0000764B 58                      	pop	ax
 41426 0000764C 07                      	pop	es
 41427 0000764D 1F                      	pop	ds
 41428 0000764E 5B                      	pop	bx
 41429 0000764F C3                      	retn
 41430                                  
 41431                                  ;-------------------------------------------------------------------------
 41432                                  ;
 41433                                  ; 	Procedure Name	: chk_common_str
 41434                                  ;
 41435                                  ;	Input		: DS = DOSCODE
 41436                                  ;			; ES:DI points to string in packed file
 41437                                  ;
 41438                                  ;	Output		; Z if match else NZ
 41439                                  ;
 41440                                  ;-------------------------------------------------------------------------
 41441                                  
 41442                                  	; 23/05/2019 - Retro DOS v4.0
 41443                                  chk_common_str:
 41444 00007650 BE[4A75]                	mov	si,scan_com
 41445                                  					; ds:si -> scan string 
 41446                                  	;mov	cx,32
 41447 00007653 B92000                  	mov	cx,size_scan_com
 41448                                  
 41449 00007656 F3A6                    	repe	cmpsb	       
 41450                                  
 41451                                  					; M046 - start
 41452                                  	; a fourth possible version of these exepacked programs have a 
 41453                                  	; 056h instead of 06Bh. See scan_com above
 41454                                  	;
 41455                                  	; 	db  75h, 6Bh		;jne CorruptExe		
 41456                                  	;
 41457                                  	; If the mismatch at this point is due to a 56h instead of 6Bh 
 41458                                  	; we shall try to match the rest of the string
 41459                                  	;
 41460                                  
 41461 00007658 7409                    	jz	short ccs_done
 41462 0000765A 26807DFF56              	cmp	byte [es:di-1],56h
 41463 0000765F 7502                    	jnz	short ccs_done
 41464                                  
 41465 00007661 F3A6                    	repe	cmpsb	    
 41466                                  ccs_done:				; M046 - end
 41467 00007663 C3                      	retn
 41468                                  
 41469                                  ;-------------------------------------------------------------------------
 41470                                  ;
 41471                                  ;	Procedure Name	: chk_patchsum
 41472                                  ;
 41473                                  ;	Input		: DS:SI -> string we're looking for
 41474                                  ;			: ES:DI -> offset in packed file
 41475                                  ;			: CX 	= scan length
 41476                                  ;			: BX	= length of check sum
 41477                                  ;			: AX 	= value of check sum
 41478                                  ;
 41479                                  ;	Output		: if patch & check sum compare
 41480                                  ;				NC
 41481                                  ;			  else
 41482                                  ;				CY
 41483                                  ;
 41484                                  ;	Uses		: AX, BX, CX, SI
 41485                                  ;
 41486                                  ;-------------------------------------------------------------------------
 41487                                  
 41488                                  	; 23/05/2019 - Retro DOS v4.0
 41489                                  chk_patchsum:
 41490 00007664 57                      	push	di
 41491                                  
 41492 00007665 F3A6                    	repe	cmpsb			   
 41493                                  
 41494 00007667 7518                    	jnz	short cp_fail		; Q: does the patch match
 41495                                  					; N: exit
 41496                                  					; Y:	
 41497                                  
 41498                                  		; we do a check sum starting from the location of the 
 41499                                  		; exepack signature 'RB' up to 11c/2 bytes, the end of the
 41500                                  		; unpacking code.
 41501                                  
 41502 00007669 368B3E[8700]            	mov	di,[ss:UNPACK_OFFSET]	; di -> start of unpack code
 41503 0000766E 89D9                    	mov	cx,bx			; cx = length of check sum
 41504                                  
 41505 00007670 89C3                    	mov	bx,ax			; save check sum passed to us in bx
 41506 00007672 31C0                    	xor	ax,ax
 41507                                  ep_chksum:
 41508 00007674 260305                  	add	ax,[es:di]
 41509 00007677 83C702                  	add	di,2
 41510 0000767A E2F8                    	loop	ep_chksum
 41511                                  
 41512 0000767C 5F                      	pop	di			; restore di
 41513                                  
 41514 0000767D 39D8                    	cmp	ax,bx		 	; Q: does the check sum match
 41515                                  	;jne	short cp_fail		; N: exit
 41516                                  					; Y: 
 41517                                  	; 25/09/2023
 41518                                  	;clc	
 41519                                  	;retn
 41520 0000767F 74E2                    	je	short ccs_done ; cf=0
 41521                                  	
 41522                                  cp_fail:
 41523 00007681 F9                      	stc
 41524 00007682 C3                      	retn
 41525                                  
 41526                                  ; 28/12/2022 - Retro DOS v4.1
 41527                                  %if 0
 41528                                  ;--------------------------------------------------------------------------- 
 41529                                  
 41530                                  
 41531                                  ; M020 : BEGIN
 41532                                  ;
 41533                                  ;---------------------------------------------------------------------------
 41534                                  ;
 41535                                  ; procedure : RationalPatch
 41536                                  ;
 41537                                  ; A routine (in Ration DOS extender) which is invoked at hardware interrupts
 41538                                  ; clobbers CX register on 286 machines. (123 release 3 uses Rational DOS
 41539                                  ; extender). This routine identifies Buggy Rational EXEs and fixes the bug.
 41540                                  ;
 41541                                  ; THE BUG is in the following code sequence:
 41542                                  ;
 41543                                  ;8b 0e 10 00	mov	cx, ds:[10h]		; delay count
 41544                                  ;90		even				; word align
 41545                                  ;e2 fe		loop	$			; wait		CLOBBERS CX
 41546                                  ;e8 xx xx	call	set_A20			; enable A20
 41547                                  ;
 41548                                  ; This patch routine replaces the mov & the loop with a far call into a
 41549                                  ; routine in DOS data segment which is in low memory (because A20 line
 41550                                  ; is off). The routine (RatBugCode) in DOS data saves & restores CX around
 41551                                  ; a mov & loop.
 41552                                  ;
 41553                                  ; Identification of Buggy Rational EXE
 41554                                  ; ====================================
 41555                                  ;
 41556                                  ; (ALL OFFSETS ARE IN THE PROGRAM SECTION - EXCLUDING THE EXE HEADER)
 41557                                  ;
 41558                                  ; OFFSET				Contains
 41559                                  ; ------				--------
 41560                                  ; 0000h			100 times Version number in binary
 41561                                  ;			bug exists in version 3.48 thru 3.83 (both inclusive)
 41562                                  ;
 41563                                  ; 000ah			the WORDS : 0000h, 0020h, 0000h, 0040h, 0001h
 41564                                  ;
 41565                                  ; 002ah			offset where version number is stored in ASCII
 41566                                  ;				e.g. '3.48A'
 41567                                  ;
 41568                                  ; 0030h			offset of copyright string. Copyright strings either
 41569                                  ;			start with "DOS/16M Copyright...." or
 41570                                  ;			"Copyright.....". The string contains
 41571                                  ;			"Rational Systems, Inc."
 41572                                  ;
 41573                                  ; 0020h			word : Paragraph offset of the buggy code segment
 41574                                  ;				from the program image
 41575                                  ; 0016h			word : size of buggy code segment
 41576                                  ;
 41577                                  ;	Buggy code is definite to start after offset 200h in its segment
 41578                                  ;
 41579                                  ;----------------------------------------------------------------------------
 41580                                  
 41581                                  ; 23/05/2019 - Retro DOS v4.0
 41582                                  ; DOSCODE:B976h (MSDOS 6.21, MSDOS.SYS)
 41583                                  
 41584                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41585                                  ; DOSCODE:B654h (MSDOS 5.0, MSDOS.SYS)
 41586                                  
 41587                                  RScanPattern1:
 41588                                  	db	0, 0, 20h, 0, 0, 0, 40h, 0, 1, 0
 41589                                  
 41590                                  RLen1 equ $ - RScanPattern1
 41591                                  
 41592                                  RScanPattern2:
 41593                                  	db	8Bh, 0Eh, 10h, 00h, 90h, 0E2h, 0FEh, 0E8h
 41594                                  
 41595                                  RLen2 equ $ - RScanPattern2
 41596                                  
 41597                                  RScanPattern3:
 41598                                  	db	8Bh, 0Eh, 10h, 00h, 0E2h, 0FEh, 0E8h
 41599                                  
 41600                                  RLen3 equ $ - RScanPattern2
 41601                                  
 41602                                  ; DOSCODE:B98Fh (MSDOS 6.21, MSDOS.SYS)
 41603                                  ; DOSCODE:B66Dh (MSDOS 5.0, MSDOS.SYS)
 41604                                  
 41605                                  ;----------------------------------------------------------------------------
 41606                                  ;
 41607                                  ; INPUT : ES = segment where program got loaded
 41608                                  ;
 41609                                  ;----------------------------------------------------------------------------
 41610                                  
 41611                                  RationalPatch:
 41612                                  	cld
 41613                                  	push	ax
 41614                                  	push	bx
 41615                                  	push	cx
 41616                                  	push	dx
 41617                                  	push	si
 41618                                  	push	di
 41619                                  	push	es
 41620                                  	push	ds			; we use all of them
 41621                                  	mov	di,0Ah			; look for pat1 at offset 0Ah
 41622                                  	push	cs
 41623                                  	pop	ds
 41624                                  	
 41625                                  	mov	si,RScanPattern1
 41626                                  	;mov	cx,10
 41627                                  	mov	cx,RLen1
 41628                                  	rep	cmpsb			; do we have the pattern ?
 41629                                  	jne	short rpexit
 41630                                  	mov	ax,[es:0]
 41631                                  	cmp	ax,348			; is it a buggy version ?
 41632                                  	jb	short rpexit
 41633                                  	cmp	ax,383			; is it a buggy version
 41634                                  	ja	short rpexit
 41635                                  
 41636                                  	call	VerifyVersion
 41637                                  	jne	short rpexit
 41638                                  
 41639                                  	mov	cx,[es:16h]		; Length of buggy code seg
 41640                                  	sub	cx,200h			; Length we search (we start
 41641                                  					;  at offset 200h)
 41642                                  	mov	es,[es:20h]		; es=buggy code segment
 41643                                  	mov	si,RScanPattern2
 41644                                  	;mov	dx,8	
 41645                                  	mov	dx,RLen2
 41646                                  	call	ScanCodeSeq		; look for code seq with nop
 41647                                  	jz	short rpfound
 41648                                  
 41649                                  	mov	si,RScanPattern3
 41650                                  	;mov	dx,15
 41651                                  	mov	dx,RLen3
 41652                                  	call	ScanCodeSeq		; look for code seq w/o nop
 41653                                  	jnz	short rpexit
 41654                                  
 41655                                  rpfound:
 41656                                  	
 41657                                  ;	we set up a far call into DOS data
 41658                                  ;	dx has the length of the code seq we were searching for
 41659                                  
 41660                                  	mov	al,9Ah			; far call opcode
 41661                                  	stosb
 41662                                  	mov	ax,RatBugCode
 41663                                  	stosw
 41664                                  	mov	ax,ss
 41665                                  	stosw
 41666                                  	mov	cx,dx
 41667                                  	sub	cx,6			; filler (with NOPs)
 41668                                  	mov	al,90h
 41669                                  	rep	stosb
 41670                                  rpexit:
 41671                                  	pop	ds
 41672                                  	pop	es
 41673                                  	pop	di
 41674                                  	pop	si
 41675                                  	pop	dx
 41676                                  	pop	cx
 41677                                  	pop	bx
 41678                                  	pop	ax
 41679                                  	retn
 41680                                  
 41681                                  ; M020 END
 41682                                  
 41683                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41684                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
 41685                                  
 41686                                  ; DOSCODE:B6D8h (MSDOS 5.0, MSDOS.SYS)
 41687                                  
 41688                                  ;----------------------------------------------------------------------------
 41689                                  ;
 41690                                  ; ScanCodeSeq
 41691                                  ;
 41692                                  ; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
 41693                                  ;
 41694                                  ; returns in ES:DI the start of the pattern if Zero flag is set
 41695                                  ;
 41696                                  ;----------------------------------------------------------------------------
 41697                                  
 41698                                  ScanCodeSeq:
 41699                                  	; 17/12/2022
 41700                                  	mov	di,200h
 41701                                  ;ScanCodeSeq_di:
 41702                                  	push	cx
 41703                                  	sub	cx,dx
 41704                                  	inc	cx
 41705                                  	; 17/12/2022
 41706                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41707                                  	;mov	di,200h
 41708                                  scsagain:
 41709                                  	push	si
 41710                                  	push	di
 41711                                  	push	cx
 41712                                  	mov	cx,dx
 41713                                  	rep	cmpsb
 41714                                  	pop	cx
 41715                                  	pop	di
 41716                                  	pop	si
 41717                                  	je	short scsfound
 41718                                  	inc	di
 41719                                  	loop	scsagain
 41720                                  scsfound:
 41721                                  	pop	cx
 41722                                  vvexit:		; 18/12/2022
 41723                                  	retn
 41724                                  
 41725                                  
 41726                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41727                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
 41728                                  
 41729                                  ; DOSCODE:B6F0h (MSDOS 5.0, MSDOS.SYS)
 41730                                  
 41731                                  ;----------------------------------------------------------------------------
 41732                                  ;
 41733                                  ; VerifyVersion
 41734                                  ;
 41735                                  ; Checks whether the binary version from ES:0 matches the ASCII version
 41736                                  ; from ES:2A.
 41737                                  ;
 41738                                  ;       Entry: AX = binary version number 
 41739                                  ;       Exit : Z flag set if version numbers match
 41740                                  ;
 41741                                  ;----------------------------------------------------------------------------
 41742                                  
 41743                                  VerifyVersion:
 41744                                  	mov	si,[es:2Ah]		; offset of version number
 41745                                  					;  in ascii
 41746                                  	mov	bl,10
 41747                                  	add	si,3			; point to last digit
 41748                                  
 41749                                  	call	VVDigit
 41750                                  	jne	short vvexit
 41751                                  	call	VVDigit
 41752                                  	jne	short vvexit
 41753                                  	cmp	byte [es:si],'.' ; 2Eh
 41754                                  	jne	short vvexit
 41755                                  	dec	si
 41756                                  	;call	VVDigit
 41757                                  	; 18/12/2022
 41758                                  	;jmp	short VVDigit
 41759                                  ;vvexit:
 41760                                  	;retn
 41761                                  VVDigit:
 41762                                  	div	bl
 41763                                  	add	ah,'0' ; 30h
 41764                                  	dec	si
 41765                                  	cmp	[es:si+1],ah
 41766                                  	mov	ah,0			; do not xor or sub we need Z
 41767                                  	retn
 41768                                  
 41769                                  ;--------------------------------------------------------------------------- 
 41770                                  %endif	; 28/12/2022
 41771                                  
 41772                                  ;---------------------------------------------------------------------------
 41773                                  ;
 41774                                  ;	M068
 41775                                  ;
 41776                                  ; 	Procedure Name	: IsCopyProt
 41777                                  ;
 41778                                  ;	Inputs		: DS:100 -> start of com file just read in
 41779                                  ;
 41780                                  ;	Outputs		: sets the A20OFF_COUNT variable to 10 if 
 41781                                  ;			  the program loaded in DS:100 uses a MICROSOFT
 41782                                  ;			  copy protect scheme that relies on the A20 line
 41783                                  ;			  being turned off for it's scheme to work.
 41784                                  ;
 41785                                  ;			  Note: The int 21 function dispatcher will turn 
 41786                                  ;				a20 off, if the A20OFF_COUNT is non-zero 
 41787                                  ;				and dec the A20OFF_COUNT before	iretting 
 41788                                  ;				to the user. 
 41789                                  ;
 41790                                  ;	Uses		: ES, DI, SI, CX
 41791                                  ;
 41792                                  ;---------------------------------------------------------------------------
 41793                                  
 41794                                  ; 23/05/2019 - Retro DOS v4.0
 41795                                  
 41796                                  CPStartOffset	EQU	0175h
 41797                                  CPID1Offset	EQU	011Bh
 41798                                  CPID2Offset	EQU	0173h
 41799                                  CPID3Offset	EQU	0146h
 41800                                  CPID4Offset	EQU	0124h
 41801                                  ID1		EQU	05343h
 41802                                  ID2		EQU	05044h
 41803                                  ID3		EQU	0F413h
 41804                                  ID4		EQU	08000h
 41805                                  
 41806                                  ; DOSCODE:B9FAh (MSDOS 6.21, MSDOS.SYS)
 41807                                  
 41808                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41809                                  ; DOSCODE:B71Ch (MSDOS 5.0, MSDOS.SYS)
 41810                                  
 41811                                  CPScanPattern:
 41812 00007683 89264801                	db	89h,26h,48h,01h		 ; mov [148],sp
 41813 00007687 8C0E4C01                	db	8Ch,0Eh,4Ch,01h		 ; mov [14C],cs
 41814 0000768B C7064A010001            	db	0C7h,06h,4Ah,01h,00h,01h ; mov [14A],100h 
 41815 00007691 8C0E1301                	db 	8Ch,0Eh,13h,01h		 ; mov [113],cs
 41816 00007695 B82001                  	db	0B8h,20h,01h		 ; mov ax,120h
 41817 00007698 BE0001                  	db	0BEh,00h,01h		 ; mov si,100h
 41818                                  
 41819                                  CPSPlen	EQU $ - CPScanPattern
 41820                                  
 41821                                  ; DOSCODE:BA12h (MSDOS 6.21, MSDOS.SYS)
 41822                                  ; DOSCODE:B734h (MSDOS 5.0, MSDOS.SYS)
 41823                                  
 41824                                  IsCopyProt:
 41825 0000769B 813E1B014353            	cmp	word [CPID1Offset],ID1
 41826 000076A1 752D                    	jne	short CP_done
 41827                                  
 41828 000076A3 813E73014450            	cmp	word [CPID2Offset],ID2
 41829 000076A9 7525                    	jne	short CP_done
 41830                                  
 41831 000076AB 813E460113F4            	cmp	word [CPID3Offset],ID3
 41832 000076B1 751D                    	jne	short CP_done
 41833                                  
 41834 000076B3 813E24010080            	cmp	word [CPID4Offset],ID4
 41835 000076B9 7515                    	jne	short CP_done
 41836                                  
 41837 000076BB 0E                      	push	cs
 41838 000076BC 07                      	pop	es
 41839 000076BD BF[8376]                	mov	di,CPScanPattern	; es:di -> Pattern to find
 41840                                  
 41841 000076C0 BE7501                  	mov	si,CPStartOffset	; ds:si -> possible location 
 41842                                  					; of pattern
 41843                                  
 41844 000076C3 B91800                  	mov	cx,CPSPlen ; 24		; cx = length of pattern
 41845 000076C6 F3A6                    	repe	cmpsb
 41846 000076C8 7506                    	jnz	short CP_done
 41847                                  
 41848 000076CA 36C606[8500]0A          	mov	byte [ss:A20OFF_COUNT],0Ah ; M071
 41849                                  CP_done:
 41850 000076D0 C3                      	retn
 41851                                  	
 41852                                  ;DOSCODE ENDS
 41853                                  
 41854                                  	;END
 41855                                  
 41856                                  ;----------------------------------------------------------------------------
 41857                                  
 41858                                  ;align 2 ; 05/09/2018 (Error!)
 41859                                  
 41860                                  ; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41861                                  ;align 16 ; 08/09/2018 (OK.)
 41862 000076D1 90                      align 2
 41863                                  
 41864                                  ; 06/08/2018 - Retro DOS v3.0
 41865                                  ;============================================================================
 41866                                  ; MSINIT.ASM
 41867                                  ;============================================================================
 41868                                  ; 22/04/2019 - Retro DOS v4.0 (MSINIT.ASM, MSDOS 6.0, 1991)
 41869                                  ;
 41870                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 41871                                  ;
 41872                                  	; 15/07/2018 - Retro DOS v3.0
 41873                                  	; (MSDOS 3.3, IBMDOS.COM, 1987)
 41874                                  
 41875                                  ; temp iret instruction
 41876                                  
 41877                                  
 41878                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41879                                  ; DOSCODE:B76Ah (MSDOS 5.0, MSDOS.SYS)
 41880                                  
 41881                                  initiret: ; MSDOS 6.0
 41882                                  SYSBUF:
 41883                                  ;IRETT: ; 06/05/2019
 41884 000076D2 CF                      	iret
 41885                                  
 41886                                  ; 22/04/2019 - Retro DOS v4.0
 41887                                  
 41888                                  ; pointer to the BIOS data segment that will be available just to the
 41889                                  ; initialization code
 41890                                  
 41891 000076D3 7000                    InitBioDataSeg:	dw 70h ; KERNEL_SEGMENT = 0070h
 41892                                  
 41893                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41894                                  ; DOSCODE:B76Dh (MSDOS 5.0, MSDOS.SYS)
 41895                                  
 41896                                  ; Convert AX from a number of bytes to a number of paragraphs (round up).
 41897                                  
 41898                                  ParaRound:
 41899 000076D5 83C00F                  	add	ax, 15
 41900 000076D8 D1D8                    	rcr	ax, 1
 41901 000076DA D1E8                    	shr	ax, 1
 41902 000076DC D1E8                    	shr	ax, 1
 41903 000076DE D1E8                    	shr	ax, 1
 41904 000076E0 C3                      	retn
 41905                                  
 41906                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 41907                                  
 41908                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41909                                  	; DOSCODE:B779h (MSDOS 5.0, MSDOS.SYS)
 41910                                  	
 41911                                  	; 30/05/2019
 41912                                  	; 22/04/2019 - Retro DOS v4.0
 41913                                  	; 07/07/2018 - Retro DOS v3.0
 41914                                  	; Retro DOS v2.0 - 03/03/2018
 41915                                  	; 03/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41916                                  	; MSDOS 5.0 - MSDOS.SYS, offset 79A9h
 41917                                  DOSINIT:
 41918                                  	; MSDOS 6.21 - MSDOS.SYS, offset 7C77h
 41919                                  	;
 41920                                  	; Far call from SYSINIT
 41921                                  	; DX = Memory size in paragraphs
 41922                                  	; DS:SI = [DEVICE_LIST] (SYSINIT.S) 
 41923                                  	;	  (Retro DOS v2.0, 16/03/2018)
 41924                                  	;
 41925                                  	; ES:DI = ptr to BIOS communication block (sysinit3.s)
 41926                                  	;	  (Retro DOS v4.0, 20/04/2019)
 41927                                  
 41928 000076E1 FA                              CLI
 41929 000076E2 FC                              CLD
 41930                                  
 41931                                  	; 03/11/2022
 41932                                  	;push	dx ; 30/05/2019		; save parameters from BIOS
 41933                                  	
 41934                                  	; 17/12/2022
 41935                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41936                                  	;push	dx ; =*=		; save parameters from BIOS
 41937                                  	
 41938 000076E3 56                      	push	si
 41939 000076E4 1E                      	push	ds
 41940 000076E5 57                      	push	di			;save di (ptr to BiosComBlock)
 41941                                  
 41942 000076E6 8CC3                    	mov	bx,es			;bx:di = ptr to BiosComBlock
 41943                                  
 41944                                  ; First, move the DOS data segment to its final location in low memory
 41945                                  
 41946                                  	;;mov	ax,0BF69h ; MSDOS 6.21 MSDOS.SYS, file offset 7C7Fh
 41947                                  	;mov	ax,0BC77h ; MSDOS 5.0 MSDOS.SYS, file offset 79B1h	
 41948 000076E8 B8[627B]                	mov	ax,MEMSTRT		; get offset of end of init code
 41949                                  
 41950                                  	;add	ax,15	; 0Fh		; round to nearest paragraph
 41951                                  	;and	ax,~15	; 0FFF0h	; boundary
 41952                                  
 41953                                  	;mov	si,ax			; si = offset of DOSDATA in current 
 41954                                  					; code segment
 41955                                  
 41956                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41957 000076EB 83C00F                  	add	ax,15			; round to nearest paragraph
 41958 000076EE 83E0F0                  	and	ax,~15			; boundary
 41959                                  
 41960 000076F1 89C6                    	mov	si,ax			; si = offset of DOSDATA in current 
 41961                                  					; code segment
 41962                                  	; 05/12/2022
 41963                                  	; 30/04/2019 - Retro DOS v4.0
 41964                                  	;xor	si,si
 41965                                  	
 41966 000076F3 8CC8                    	mov	ax,cs
 41967 000076F5 8ED8                    	mov	ds,ax			; ds = current code segment
 41968                                  					; DS:SI now points to dosdata
 41969                                  
 41970                                  	;mov	es,[cs:0BA49h] ; MSDOS 6.21 IO.SYS, offset 7C8Eh 
 41971                                  	;mov	es,[cs:InitBioDataSeg]	; First access to DosDataSg in
 41972                                  					;  BData segment. Cannot use
 41973                                  					;  getdseg macro here!!!
 41974                                  	; 17/12/2022
 41975 000076F7 8E06[D376]              	mov	es,[InitBioDataSeg]
 41976                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41977                                  	;mov	es,[cs:InitBioDataSeg]  ; ds = cs !
 41978                                  
 41979                                  	;mov	es,[es:3]
 41980 000076FB 268E060300              	mov	es,[es:DosDataSg]	; Get free location in low memory
 41981                                  
 41982 00007700 31FF                    	xor	di,di			; ES:DI now points to RAM data
 41983                                  
 41984                                  	;mov	cx,4970  ; Offset 0BA78h in MSDOS 6.21 MSDOS.SYS)
 41985                                  	;mov	cx,4976  ; 25/05/2019
 41986                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41987                                  	;mov	cx,4962
 41988                                  	;mov	cx,MSDAT001E		; get end of dosdata = size of dosdata
 41989 00007702 B9A512                  	mov	cx,DOSDATASIZE ; = 4962 for MSDOS 5.0 MSDOS.SYS
 41990 00007705 F3A4                    	rep	movsb			; move data to final location
 41991                                  	
 41992 00007707 5F                      	pop	di			; restore ptr to BiosComBlock
 41993 00007708 1F                      	pop	ds			; restore parms from BIOS
 41994 00007709 5E                      	pop	si
 41995                                  	; 17/12/2022
 41996                                  	;pop	dx ; 30/05/2019	
 41997                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41998                                  	;pop	dx ; =*=		
 41999                                  
 42000 0000770A 06                      	push	es
 42001 0000770B 1E                      	push	ds
 42002 0000770C 07                      	pop	es			; es:si -> device chain
 42003 0000770D 1F                      	pop	ds			; ds points to dosdata
 42004                                  
 42005                                  ;SR;
 42006                                  ;We get a ptr to the BIOS exchange data block. This has been setup right 
 42007                                  ;now so that the EXEC call knows when SysInit is present to do the special
 42008                                  ;lie table handling for device drivers. This can be expanded later on to
 42009                                  ;establish a communication block from the BIOS to the DOS.
 42010                                  
 42011                                  	;mov	[1040h],di	; Offset 0BA87h in MSDOS 6.21 MSDOS.SYS)
 42012                                  	;mov	[1042h],bx
 42013 0000770E 893E[4010]              	mov	[BiosDataPtr],di
 42014 00007712 891E[4210]              	mov	[BiosDataPtr+2],bx	; save ptr to BiosComBlock
 42015                                  
 42016 00007716 2E8C1E[0700]            	mov	[cs:DosDSeg],ds		; set pointer to dosdata in code seg
 42017                                  
 42018                                  	; Set the segment of Lowint23/24/28Addr in msctrlc.asm to dosdata
 42019                                  
 42020 0000771B 2E8C1E[CA50]            	mov	[cs:LowInt23Addr+2],ds	; set pointers in code seg
 42021 00007720 2E8C1E[CE50]            	mov	[cs:LowInt24Addr+2],ds
 42022 00007725 2E8C1E[D250]            	mov	[cs:LowInt28Addr+2],ds
 42023                                  
 42024                                  	;mov	[346h],dx	; MSDOS 6.21 DOSDATA addresses
 42025                                  	;mov	[584h],sp
 42026                                  	;mov	[586h],ss
 42027 0000772A 8916[4603]                  	mov	[ENDMEM],dx	; =*=
 42028 0000772E 8926[8405]              	mov	[USER_SP],sp
 42029 00007732 8C16[8605]              	mov	[USER_SS],ss
 42030                                  
 42031 00007736 8CD8                    	mov	ax,ds		; set up ss:sp to dosdata:dskstack
 42032 00007738 8ED0                    	mov	ss,ax
 42033                                  
 42034                                  	;mov	sp,920h		; MSDOS 6.21 DOSDATA address
 42035                                  	;mov	sp,offset dosdata:dskstack
 42036 0000773A BC[2009]                	mov	sp,DSKSTACK
 42037                                  
 42038                                  ;M023
 42039                                  ; Init patch ptrs to default values
 42040                                  
 42041                                  	;mov	word [1212h],RetExePatch
 42042                                  	;mov	word [1214h],RetExePatch
 42043                                  	;mov	word [61h],RetExePatch
 42044 0000773D C706[F311][3C62]        	mov	word [FixExePatch],RetExePatch	; M023
 42045                                  	; 28/12/2022 - Retro DOS v4.1
 42046                                  	;mov	word [RationalPatchPtr],RetExePatch ; M023
 42047 00007743 C706[6100][3C62]        	mov	word [ChkCopyProt],RetExePatch	; M068
 42048                                  
 42049                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42050                                  %if 0	; 19/09/2023
 42051                                  
 42052                                  ; Setup to call 386 Rational DOS Extender patch routine if running on
 42053                                  ; a 386 or later. Unlike other patches, this is not dependent on MS-DOS
 42054                                  ; running in the HMA.
 42055                                  
 42056                                  	call	WhatCPUType	; get cpu type (0 < 286,1==286,2 >= 386)
 42057                                  	cmp	al,2		;   386 or later?
 42058                                  	mov	ax,Rational386Patch
 42059                                  	jae	short di_set_patch
 42060                                  	mov	ax,RetExePatch	; < 386, don't need this patch
 42061                                  di_set_patch:
 42062                                  	mov	[Rational386PatchPtr],ax ; patch routine or RET instr.
 42063                                  
 42064                                  %endif
 42065                                  	; Set up the variable temp_dosloc to point to the dos code segment
 42066                                  
 42067 00007749 8CC8                    	mov	ax,cs		; ax = current segment of DOS code
 42068                                  
 42069                                  	; ax now holds segment of DOS code
 42070 0000774B A3[AA0A]                	mov	[TEMP_DOSLOC],ax   ; store temp location of DOS
 42071                                  
 42072 0000774E 8C06[4A00]              	mov	word [NULDEV+2],es ; nuldev -> points to device chain
 42073 00007752 8936[4800]              	mov	word [NULDEV],si
 42074                                  ;SR;
 42075                                  ; There are some locations in the Win386 instance data structures
 42076                                  ; which need to be set up with the DOS data segment. First, initialize
 42077                                  ; the segment part of the instance table pointer in the SIS.
 42078                                  
 42079                                  	;mov	[0FF2h],ds ; [Win386_Info+14+2]	
 42080 00007756 8C1E[F20F]              	mov	[Win386_Info+Win386_SIS.Instance_Data_Ptr+2],ds
 42081                                  
 42082                                  ; Now initialize the segment part of the pointer to the data in each
 42083                                  ; instance table entry.
 42084                                  
 42085 0000775A 56                      	push	si		; preserve pointer to device chain
 42086                                  	; 18/12/2022
 42087                                  	; cx = 0
 42088 0000775B B107                    	mov	cl,7
 42089                                  	;mov	cx,7		; There are 7 entries in the instance table
 42090                                  				; M019
 42091                                  	;mov	si,0FF6h ; offset (dosdata:Instance_Table+2)
 42092 0000775D BE[F60F]                	mov	si,Instance_Table+2 ; point si to segment field
 42093                                  Instance_init_loop:
 42094 00007760 8C1C                    	mov	[si],ds		; set offset in instance entry
 42095                                  	;add	si,6
 42096 00007762 83C606                  	add	si,size_of_Win386_IIS ; move on to next entry
 42097 00007765 E2F9                    	loop	Instance_init_loop
 42098                                  
 42099                                  ;Initialize the WIN386 2.xx instance table with the DOS data segment value
 42100                                  
 42101                                  	; 18/12/2022
 42102 00007767 B105                    	mov	cl,5
 42103                                  	;mov	cx,5		; There are five entries in the instance table
 42104                                  
 42105                                  	;mov	si,(offset dosdata:OldInstanceJunk) + 6
 42106                                  	;mov	si,11EDh	; point si to segment field
 42107 00007769 BE[CE11]                	mov	si,OldInstanceJunk+6
 42108                                  OldInstance_init_loop:
 42109 0000776C 8C1C                    	mov	[si],ds		; set offset in instance entry
 42110 0000776E 83C606                  	add	si,6		; move on to next entry
 42111 00007771 E2F9                    	loop	OldInstance_init_loop
 42112 00007773 5E                      	pop	si		; restore pointer to device chain
 42113                                  
 42114                                  ; End of WIN386 2.xx compatibility bullshit
 42115                                  
 42116                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42117                                  %if 0	
 42118                                     	; 30/04/2019
 42119                                  	;push	es
 42120                                  	;pop	ds
 42121                                  			; ds:si points to console device
 42122                                  
 42123                                  	; 24/04/2019 - Retro DOS v4.0
 42124                                  
 42125                                  	; 15/07/2018
 42126                                  	; MSDOS 3.3 (IBMDOS.COM, 1987)
 42127                                  	; (Set INT 2Ah handler address to an 'IRET')
 42128                                  
 42129                                  	; need crit vector inited to use deviocall
 42130                                  	;push	ds			; preserve segment of device chain
 42131                                  	push	es ; 30/04/2019
 42132                                  
 42133                                  %endif
 42134                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42135 00007774 06                      	push	es
 42136                                  	; 17/12/2022
 42137                                  	;pop	ds
 42138                                  	;push	ds
 42139                                  
 42140 00007775 31C0                    	xor	ax,ax
 42141 00007777 8ED8                    	mov	ds,ax			; point DS to int vector table
 42142 00007779 B8[D276]                	mov	ax,initiret
 42143                                  	;mov	[0A8h],ax  ; [2Ah*4]
 42144 0000777C A3A800                  	mov	[addr_int_ibm],ax
 42145 0000777F 8CC8                    	mov	ax,cs
 42146                                  	;mov	[0AAh],ax  ; [(2Ah*4)+2] 		
 42147 00007781 A3AA00                  	mov	[addr_int_ibm+2],ax
 42148 00007784 1F                      	pop	ds			; restore segment of device chain
 42149                                  
 42150 00007785 E81C02                  	call	CHARINIT  		; initialize console driver
 42151 00007788 56                      	push	si			; save pointer to header
 42152                                  
 42153 00007789 16                      	push	ss			; move pointer to dos data...
 42154 0000778A 07                      	pop	es			; ...into ES
 42155                                  
 42156                                  	;initialize sft for file 0 (CON)
 42157                                  
 42158                                          ; 07/07/2018 - Retro DOS v3.0
 42159                                  	; 24/04/2019 - Retro DOS v4.0
 42160                                  	;mov	di,SFTABL+6 
 42161 0000778B BF[D200]                	MOV     DI,SFTABL+SFT.SFTable	; Point to sft 0
 42162 0000778E B80300                          MOV     AX,3
 42163 00007791 AB                              STOSW           	; Refcount
 42164 00007792 FEC8                            DEC     AL
 42165 00007794 AB                              STOSW           	; Access rd/wr, compatibility
 42166 00007795 30C0                            XOR     AL,AL
 42167 00007797 AA                              STOSB           	; attribute
 42168                                  	;mov	al,0C3h
 42169 00007798 B0C3                    	mov	al,devid_device_EOF|devid_device|ISCIN|ISCOUT
 42170 0000779A AB                      	STOSW			; flags
 42171 0000779B 89F0                            mov	ax,si
 42172 0000779D AB                              stosw			; device pointer in devptr	
 42173 0000779E 8CD8                            mov	ax,ds
 42174 000077A0 AB                      	stosw
 42175 000077A1 31C0                    	xor	ax,ax	; 0
 42176 000077A3 AB                      	stosw			; firclus
 42177 000077A4 AB                      	stosw			; time
 42178 000077A5 AB                      	stosw			; date
 42179 000077A6 48                      	dec	ax	; -1
 42180 000077A7 AB                      	stosw			; size
 42181 000077A8 AB                      	stosw
 42182 000077A9 40                      	inc	ax	; 0
 42183 000077AA AB                      	stosw			; position
 42184 000077AB AB                      	stosw
 42185                                  	;add	di,7
 42186 000077AC 83C707                  	add	di,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 42187                                  				; point at name
 42188                                  	;add	si,10
 42189 000077AF 83C60A                  	add	si,SYSDEV.NAME	; sdevname
 42190                                  				; point to name
 42191 000077B2 B90400                  	mov	cx,4
 42192 000077B5 F3A5                    	rep	movsw		; name
 42193 000077B7 B103                    	mov	cl,3
 42194 000077B9 B020                    	mov	al," "
 42195 000077BB F3AA                    	rep	stosb		; extension
 42196                                  
 42197 000077BD 5E                      	pop	si		; get back pointer to header
 42198                                  
 42199                                  				; mark device as CON I/O
 42200                                  	; 15/07/2018
 42201                                          ;OR	BYTE [SI+4],ISCIN|ISCOUT ; or byte [si+4],3
 42202 000077BE 804C0403                	OR	BYTE [SI+SYSDEV.ATT],ISCIN|ISCOUT
 42203                                  	; 12/03/2018
 42204                                  	;mov	[ss:32h],si
 42205 000077C2 368936[3200]            	MOV     [SS:BCON],SI
 42206                                  	;mov	[ss:34h],ds
 42207 000077C7 368C1E[3400]                    MOV     [SS:BCON+2],DS
 42208                                  
 42209                                  	; initialize each device until the clock device is found
 42210                                  
 42211                                  CHAR_INIT_LOOP:
 42212 000077CC C534                            LDS     SI,[SI]			; AUX device
 42213 000077CE E8D301                  	call	CHARINIT 
 42214                                         	;15/07/2018
 42215                                  	;test	byte [SI+4],8
 42216 000077D1 F6440408                	TEST    BYTE [SI+SYSDEV.ATT],ISCLOCK
 42217 000077D5 74F5                            JZ      SHORT CHAR_INIT_LOOP
 42218                                  	; 12/03/2018
 42219                                  	;mov	[ss:2Eh],si
 42220 000077D7 368936[2E00]                    MOV     [SS:BCLOCK],SI
 42221                                  	;mov	[ss:30h],ds
 42222 000077DC 368C1E[3000]                    MOV     [SS:BCLOCK+2],DS
 42223                                          ;MOV	BP,MEMSTRT ; Retro DOS 3.0 ; ES:BP points to DPB
 42224                                  
 42225                                  	;mov	bp,4970			; bp = pointer to free mem
 42226                                  	;mov	bp,4976  ; 25/05/2019 - Retro DOS v4.0
 42227                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
 42228                                  	;mov	bp,4962 ; (MSDOS 5.0 MSDOS.SYS)
 42229 000077E1 BDA512                  	mov	bp,MSDAT001E		; es:bp points to dpb area
 42230                                  
 42231 000077E4 36892E[2600]            	mov	[ss:DPBHEAD],bp		; set offset of pointer to DPB's
 42232 000077E9 368C06[2800]            	mov	[ss:DPBHEAD+2],es	; set segment of pointer to DPB's
 42233                                  PERDRV:
 42234                                  	;lds	si,[SI+SYSDEV.NEXT] ; 15/07/2018
 42235 000077EE C534                            LDS	SI,[SI]			; Next device
 42236 000077F0 83FEFF                          CMP	SI,-1	; 0FFFFh
 42237 000077F3 7479                    	JZ	SHORT CONTINIT
 42238                                  
 42239 000077F5 E8AC01                          call	CHARINIT
 42240                                  
 42241                                  	; Retro DOS v2.0 - 16/03/2018 (NOTE for 'CHARINIT' return):
 42242                                  	; [CALLUNIT] = Number of drives for (Disk) Block Dev Driver ([DRVMAX])
 42243                                  	;           (..When the command is 'DSK$INIT', as in 'CHARINIT')
 42244                                  	; [CALLBPB] = [DEVCALL.COUNT] = Address of the BPB (DEVCALL offset 18) 
 42245                                  	; (REF: MSDOS 3.3 MSBIO2.ASM, MSDATA.INC, MSDISK.ASM, MSBIO1.ASM)
 42246                                  	; (.. !DSK$IN' in MSBIO1.ASM)
 42247                                  	; DEVCALL.MEDIA = CALLUNIT (DEVCALL offset 13)
 42248                                  
 42249                                          ; 15/07/2018
 42250                                  	;test	word [SI+4],8000h		; DEVTYP
 42251                                          ; 17/12/2022
 42252                                  	;test	byte [SI+5],80h
 42253 000077F8 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8) ; 80h
 42254                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP ; 8000h
 42255 000077FC 75F0                    	JNZ     SHORT PERDRV			; Skip any other character devs
 42256                                  
 42257 000077FE 368A0E[6703]                    MOV	CL,[SS:CALLUNIT] ; 12/03/2018
 42258 00007803 30ED                    	XOR     CH,CH
 42259                                          ; 07/07/2018
 42260                                  	;MOV	[SI+10],CL		; Number of units in name field
 42261 00007805 884C0A                  	mov	[si+SYSDEV.NAME],cl	; sdevname        
 42262 00007808 368A16[4600]            	MOV     DL,[SS:NUMIO]	; 15/03/2018
 42263 0000780D 30F6                    	XOR     DH,DH
 42264 0000780F 36000E[4600]            	ADD	[SS:NUMIO],CL	; 12/03/2018
 42265 00007814 1E                      	PUSH    DS
 42266 00007815 56                              PUSH    SI
 42267 00007816 36C51E[6C03]            	LDS	BX,[SS:CALLBPB]	; 12/03/2018
 42268                                  
 42269                                  PERUNIT:
 42270 0000781B 8B37                            MOV     SI,[BX]                 ; DS:SI Points to BPB
 42271 0000781D 43                              INC     BX
 42272 0000781E 43                              INC     BX                      ; On to next BPB
 42273                                  	; 15/12/2022
 42274                                  	; 07/07/2018
 42275                                          ;mov	[ES:BP+DPB.DRIVE],DL
 42276 0000781F 26885600                	MOV     [ES:BP],DL
 42277                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42278                                  	;;mov	[ES:BP+0],DL
 42279                                  	;mov	[ES:BP+DPB.DRIVE],DL
 42280                                  
 42281                                  	;MOV	[ES:BP+1],DH
 42282 00007823 26887601                	MOV	[ES:BP+DPB.UNIT],DH
 42283 00007827 53                              PUSH    BX
 42284 00007828 51                              PUSH    CX
 42285 00007829 52                              PUSH    DX
 42286                                  
 42287                                          ;invoke	$SETDPB
 42288 0000782A E8A697                          CALL	_$SETDPB		; build DPB!
 42289                                  
 42290                                  	; 07/07/2018
 42291                                  	;MOV	AX,[ES:BP+2]
 42292 0000782D 268B4602                	mov	ax,[ES:BP+DPB.SECTOR_SIZE]
 42293                                          ; 12/03/2018
 42294 00007831 363B06[3600]            	CMP	AX,[SS:MAXSEC]		; Q:is this the largest sector so far
 42295 00007836 7604                    	JBE     SHORT NOTMAX		; N:
 42296 00007838 36A3[3600]              	MOV	[SS:MAXSEC],AX		; Y: save it in maxsec
 42297                                  NOTMAX:					
 42298                                  	; set the next dpb field in the currently built bpb
 42299                                  	; and mark as never accessed
 42300                                          
 42301                                  	; 24/04/2019
 42302 0000783C 89E8                    	mov	ax,bp			; get pointer to DPB
 42303                                  	;add	ax,33
 42304 0000783E 83C021                  	add	ax,DPBSIZ		; advance pointer to next DPB
 42305                                  					; set seg & offset of next DPB
 42306                                  	;mov	[es:bp+25],ax
 42307 00007841 26894619                	mov	[es:bp+DPB.NEXT_DPB],ax
 42308                                  	;mov	[es:bp+27],es
 42309 00007845 268C461B                	mov	[es:bp+DPB.NEXT_DPB+2],es
 42310                                  					; mark as never accessed
 42311                                  	;mov	byte [es:bp+24],0FFh
 42312 00007849 26C64618FF              	mov	byte [es:bp+DPB.FIRST_ACCESS],-1
 42313                                  
 42314 0000784E 5A                      	POP     DX
 42315 0000784F 59                              POP     CX
 42316 00007850 5B                              POP     BX
 42317 00007851 8CD8                            MOV     AX,DS                   ; save segment of bpb array
 42318 00007853 5E                              POP     SI
 42319 00007854 1F                              POP     DS
 42320                                  					; ds:si -> device header
 42321                                  					; store it in the corresponding dpb
 42322                                  	; 07/07/2018
 42323                                          ;MOV	[ES:BP+19],SI ; 24/04/2019
 42324 00007855 26897613                	mov	[ES:BP+DPB.DRIVER_ADDR],si
 42325                                          ;MOV	[ES:BP+21],DS ; 24/04/2019
 42326 00007859 268C5E15                	mov	[ES:BP+DPB.DRIVER_ADDR+2],ds
 42327                                  
 42328 0000785D 1E                              PUSH    DS			; save pointer to device header
 42329 0000785E 56                              PUSH    SI
 42330 0000785F FEC6                            INC     DH			; inc unit #
 42331 00007861 FEC2                            INC     DL			; inc drive #
 42332 00007863 8ED8                            MOV     DS,AX			; restore segment of BPB array
 42333                                          ;add	bp,33 ; 24/04/2019
 42334 00007865 83C521                  	ADD     BP,DPBSIZ		; advance pointer to next dpb
 42335 00007868 E2B1                    	LOOP    PERUNIT			; process all units in each driver
 42336                                          
 42337 0000786A 5E                      	POP     SI			; restore pointer to device header
 42338 0000786B 1F                              POP     DS
 42339 0000786C EB80                    	JMP	PERDRV			; process all drivers in chain
 42340                                  
 42341                                  CONTINIT:
 42342                                  	; 24/04/2019
 42343                                  	;sub	bp,33			; set link in last DPB to -1
 42344 0000786E 83ED21                  	sub	bp,DPBSIZ		; back up to last dpb
 42345                                  					; set last link offset & segment
 42346                                  	;mov	word [bp+25],0FFFFh
 42347 00007871 C74619FFFF              	mov	word [bp+DPB.NEXT_DPB],-1
 42348                                  	;mov	word [bp+27],0FFFFh
 42349 00007876 C7461BFFFF              	mov	word [bp+DPB.NEXT_DPB+2],-1
 42350                                  	;add	bp,33
 42351 0000787B 83C521                  	add	BP,DPBSIZ		; advance to free memory again
 42352                                  					; the DPB chain is done.  
 42353 0000787E 16                      	push	ss
 42354 0000787F 1F                      	pop	ds
 42355                                  
 42356 00007880 89E8                    	mov	ax,bp
 42357 00007882 E850FE                  	call	ParaRound		; round up to segment
 42358                                  
 42359 00007885 8CDA                    	mov	dx,ds			; dx = dosdata segment
 42360 00007887 01C2                    	add	dx,ax			; dx = ds+ax first free segment
 42361                                  
 42362 00007889 BB0F00                  	mov	bx,0Fh
 42363                                  	
 42364                                  	; 24/05/2019
 42365                                  	;mov	cx,[ENDMEM]
 42366                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42367                                  	; 17/12/2022
 42368                                  	;mov	cx,[ENDMEM] 
 42369                                  					; set seg inpacketto dosdata					
 42370 0000788C 8C1E[A203]              	mov	[DSKCHRET+3],ds ; mov [DOSSEG_INIT],ds 
 42371                                  
 42372                                  ; Patch in the segments of the interrupt vectors with current code segment.
 42373                                  ; Also patch in the segment of the pointers in the dosdata area.
 42374                                  ;
 42375                                  ; Note: Formerly, temp_dosloc was initialized to -1 until after these
 42376                                  ; calls were done. The procedure patch_misc_segments is called multiple
 42377                                  ; times, and relies on temp_dosloc being initialized to -1 as a flag
 42378                                  ; for the first invocation. Thus, we must set it to -1 for this call.
 42379                                  
 42380 00007890 52                      	push	dx			; preserve first free segment
 42381                                  
 42382 00007891 A1[AA0A]                	mov	ax,[TEMP_DOSLOC]	; ax = segment to patch in 
 42383 00007894 8EC0                    	mov	es,ax			; es = segment of DOS
 42384 00007896 C706[AA0A]FFFF          	mov	word [TEMP_DOSLOC],-1	; -1 means first call to patch_misc_segments
 42385                                  
 42386 0000789C E8AF01                  	call	patch_vec_segments	; uses AX as doscode segment
 42387 0000789F E8E401                  	call	patch_misc_segments	; patch in segments for sharer and 
 42388                                  					; other tables with seg in ES.
 42389                                  	; 17/12/2022
 42390                                  	; cx = 0
 42391 000078A2 8C06[AA0A]              	mov	[TEMP_DOSLOC],es	; put back segment of dos code
 42392                                  
 42393 000078A6 5A                      	pop	dx			; restore first free segment
 42394                                  
 42395                                  ; We shall now proceed to set the offsets of the interrupt vectors handled
 42396                                  ; by DOS to their appropriate values in DOSCODE. In case the DOS loads in
 42397                                  ; HIMEM the offsets also will be patched to their appropriate values in the
 42398                                  ; low_mem_stub by seg_reinit.
 42399                                  
 42400                                  	;xor	ax,ax ; 0
 42401                                  	;mov	ds,ax
 42402                                  	;mov	es,ax
 42403                                  	; 17/12/2022
 42404                                  	; cx = 0
 42405                                  	;xor	cx,cx ; 0
 42406 000078A7 8ED9                    	mov	ds,cx
 42407 000078A9 8EC1                    	mov	es,cx
 42408                                  
 42409                                  	; set the segment of int 24 vector that was 
 42410                                  	; left out by patch_vec_segments above.
 42411                                  
 42412                                  	; 17/12/2022
 42413                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42414                                  ;%if 0
 42415                                  	; 24/05/2019
 42416                                  	;;mov	di,90h
 42417                                  	;;mov	di,4*int_fatal_abort
 42418                                  	;mov	di,addr_int_fatal_abort
 42419 000078AB BF9200                  	mov	di,addr_int_fatal_abort+2 ; 24/05/2019
 42420                                  
 42421 000078AE 36A1[AA0A]              	mov	ax,[ss:TEMP_DOSLOC]
 42422                                  	;mov	[di+2],ax  ; int 24h segment
 42423 000078B2 8905                    	mov	[di],ax ; 24/05/2019
 42424                                  
 42425                                  	;;mov	di,82h
 42426                                  	;mov	di,INTBASE+2
 42427                                  
 42428                                  ;%endif
 42429                                  	; 17/12/2022
 42430                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42431                                  	;;mov	di,90h
 42432                                  	;;mov	di,4*int_fatal_abort
 42433                                  	;mov	di,addr_int_fatal_abort
 42434                                  	;mov	ax,[ss:TEMP_DOSLOC]
 42435                                  	;mov	[di+2],ax  ; int 24h segment
 42436                                  	;;mov	di,82h
 42437                                  	;mov	di,INTBASE+2
 42438                                  
 42439                                  	; set default divide trap offset
 42440                                  
 42441                                  	;mov	word ptr ds:[0],offset doscode:divov
 42442 000078B4 C7060000[A552]          	mov	word [0],DIVOV	
 42443                                  
 42444                                  	; set vectors 20-28 and 2a-3f to point to iret.
 42445                                  
 42446                                  	;mov	di,80h
 42447 000078BA BF8000                  	mov	di,INTBASE
 42448                                  	;mov	ax,offset doscode:irett
 42449 000078BD B8[E202]                	mov	ax,IRETT
 42450                                  
 42451                                  	; 17/12/2022
 42452                                  	; cx = 0
 42453 000078C0 B109                    	mov	cl,9
 42454                                  	;mov	cx,9			; set 9 offsets (skip 2 between each)
 42455                                  					;   sets offsets for ints 20h-28h
 42456                                  iset1:
 42457 000078C2 AB                      	stosw
 42458                                  	;add	di,2
 42459                                  	; 20/09/2023
 42460 000078C3 47                      	inc	di
 42461 000078C4 47                      	inc	di
 42462 000078C5 E2FB                    	loop	iset1
 42463                                  
 42464 000078C7 83C704                  	add	di,4			; skip vector 29h
 42465                                  
 42466                                  ;	mov	cx,6			; set 6 offsets (skip 2 between each)
 42467                                  ;					;   sets offsets for ints 2ah-2fh
 42468                                  ;iset2:
 42469                                  ;	stosw
 42470                                  ;	add	di,2
 42471                                  ;	loop	iset2
 42472                                  
 42473                                  ; 30h & 31H is the CPM call entry point whose segment address is set up by
 42474                                  ; patch_vec_segments above. So skip it.
 42475                                  
 42476                                  ;	add	di,8			; skip vector 30h & 31h 
 42477                                  
 42478                                  	;;;
 42479                                  	; 06/05/2019 - Retro DOS v4.0
 42480                                  	;mov	cx,5			; set offsets for int 2Ah-2Eh
 42481                                  	; 17/12/2022
 42482 000078CA B105                    	mov	cl,5 ; 28/06/2019
 42483                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42484                                  	;mov	cx,6
 42485                                  iset2:
 42486 000078CC AB                      	stosw
 42487                                  	;add	di,2
 42488                                  	; 20/09/2023
 42489 000078CD 47                      	inc	di
 42490 000078CE 47                      	inc	di
 42491 000078CF E2FB                    	loop	iset2
 42492                                  
 42493                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42494                                  	; 17/12/2022
 42495 000078D1 83C70C                  	add	di,12			; skip vectors 2Fh, 30h & 31h
 42496                                  	;add	di,8
 42497                                  	;;;
 42498                                  
 42499                                  	; 17/12/2022
 42500 000078D4 B10E                    	mov	cl,14
 42501                                  	;mov	cx,14			; set 14 offsets (skip 2 between each)
 42502                                  					;   sets offsets for ints 32h-3fh
 42503                                  iset3:
 42504 000078D6 AB                      	stosw
 42505                                  	;add	di,2
 42506                                  	; 20/09/2023
 42507 000078D7 47                      	inc	di
 42508 000078D8 47                      	inc	di
 42509 000078D9 E2FB                    	loop	iset3
 42510                                  
 42511                                  ;if installed
 42512                                  	; set the offset of int2f handler
 42513                                  	;mov	word [0BCh],INT2F
 42514 000078DB C706BC00[0307]          	mov	word [02Fh*4],INT2F
 42515                                  	; set segment to doscode as we have to do int 2f to check for XMS
 42516 000078E1 36A1[AA0A]              	mov	ax,[ss:TEMP_DOSLOC]	; get segment of doscode
 42517                                  	;mov	[0BEh],ax
 42518 000078E5 A3BE00                  	mov	[(02Fh*4)+2],ax
 42519                                  ;endif
 42520                                  	; set up entry point call at vectors 30-31h. Note the segment of the 
 42521                                  	; long jump will be patched in by seg_reinit
 42522                                  
 42523                                  	;mov	byte [C0h],0EAh
 42524 000078E8 C606C000EA              	mov	byte [ENTRYPOINT],mi_long_jmp
 42525                                  	;mov	byte [C1h],CALL_ENTRY
 42526 000078ED C706C100[E302]          	mov	word [ENTRYPOINT+1],CALL_ENTRY
 42527                                  
 42528 000078F3 C7068000[DC02]          	mov	word [addr_int_abort],QUIT	; INT 20h
 42529 000078F9 C7068400[0803]          	mov	word [addr_int_command],COMMAND ; INT 21h
 42530 000078FF C70688000001            	mov	word [addr_int_terminate],100h	; INT 22h
 42531 00007905 89168A00                	mov	word [addr_int_terminate+2],dx	
 42532 00007909 C7069400[2D05]          	mov	word [addr_int_disk_read],ABSDRD   ; INT 25h
 42533 0000790F C7069800[B405]          	mov	word [addr_int_disk_write],ABSDWRT ; INT 26h 
 42534 00007915 C7069C00[DF61]          	mov	word [addr_int_keep_process],STAY_RESIDENT ; INT 27h
 42535                                  
 42536 0000791B 16                      	push	ss
 42537 0000791C 1F                      	pop	ds
 42538                                  	
 42539                                  	; 24/05/2019
 42540                                  	;push	ss
 42541                                  	;pop	es
 42542                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42543                                  	; 17/12/2022
 42544                                  	;push	ss
 42545                                  	;pop	es
 42546                                  
 42547 0000791D 52                      	push	dx			; remember address of arena
 42548                                  
 42549 0000791E 42                      	inc	dx			; leave room for arena header
 42550                                  	;mov	[330h],dx
 42551 0000791F 8916[3003]              	mov     [CurrentPDB],dx		; set current pdb
 42552                                  
 42553 00007923 31FF                    	xor	di,di			; point es:di at end of memory
 42554 00007925 8EC2                    	mov	es,dx			; ...where psp will be
 42555 00007927 31C0                    	xor	ax,ax
 42556                                  	;mov	cx,80h			; psp is 128 words
 42557                                  	; 17/12/2022
 42558 00007929 B180                    	mov	cl,128 ; 28/06/2019
 42559                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42560                                  	;mov	cx,128
 42561                                  
 42562 0000792B F3AB                    	rep	stosw			; zero out psp area
 42563 0000792D A1[4603]                        mov     ax,[ENDMEM]
 42564                                  	
 42565                                  	; 17/12/2022
 42566                                  	; cx = 0
 42567 00007930 E8ED97                  	call	SETMEM         	 	; build psp at dx; ax is memory size
 42568                                  
 42569                                  	; ds, es now point to PSP
 42570                                  
 42571 00007933 16                      	push	ss
 42572 00007934 1F                      	pop	ds
 42573                                  
 42574                                  	;mov	di,24
 42575 00007935 BF1800                  	mov	di,PDB.JFN_TABLE	; es:di -> pdb_jfn_table in psp
 42576 00007938 31C0                    	xor	ax,ax
 42577 0000793A AB                      	stosw
 42578 0000793B AA                      	stosb				; 0,1 and 2 are con device
 42579 0000793C B0FF                    	mov	al,0FFh
 42580                                  	;mov	cx,FILPERPROC-3 ; 17
 42581                                  	; 17/12/2022
 42582                                  	; cx = 4
 42583 0000793E B111                    	mov	cl,FILPERPROC-3 ; 17
 42584 00007940 F3AA                    	rep	stosb			; rest are unused
 42585                                  
 42586 00007942 16                      	push	ss
 42587 00007943 07                      	pop	es
 42588                                  					; must be set to print messages
 42589 00007944 8C1E[2C00]              	mov	[SFT_ADDR+2],ds     
 42590                                  
 42591                                  ; after this point the char device functions for con will work for
 42592                                  ; printing messages
 42593                                  
 42594                                  	; 24/04/2019 - Retro DOS v4.0
 42595                                  
 42596                                  ; 12/05/2019
 42597                                  ;
 42598                                  ;write_version_msg:
 42599                                  ;
 42600                                  ;	;if	(not ibm)
 42601                                  ;	;mov	si,offset doscode:header
 42602                                  ;	mov	si,HEADER
 42603                                  ;outmes:
 42604                                  ;	;lods	cs:byte ptr [si]
 42605                                  ;	cs
 42606                                  ;	lodsb
 42607                                  ;	cmp	al,"$"
 42608                                  ;	je	short outdone
 42609                                  ;	call	OUTT
 42610                                  ;	jmp	short outmes
 42611                                  ;outdone:
 42612                                  ;	push	ss			; out stomps on segments
 42613                                  ;	pop	ds
 42614                                  ;	push	ss
 42615                                  ;	pop	es
 42616                                  ;	;endif
 42617                                  
 42618                                  	; at this point es is dosdata
 42619                                  
 42620                                  	; Fill in the segment addresses of sysinitvar and country_cdpg 
 42621                                  	; in sysinittable (ms_data.asm)
 42622                                  
 42623                                  	;mov	si,0D28h
 42624 00007948 BE[280D]                	mov	si,SysInitTable
 42625                                  
 42626                                  	; 17/12/2022
 42627                                  	; ds = es = ss
 42628                                  
 42629                                  	; 17/12/2022
 42630                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42631                                  ;%if 0
 42632                                  	;;mov	[es:si+6],es
 42633                                  	;mov	[es:si+SYSI_EXT.Country_Tab+2],es
 42634                                  	;;mov	[es:si+2],es
 42635                                  	;mov	[es:si+SYSI_EXT.SysInitVars+2],es
 42636                                  	
 42637 0000794B 8C4406                  	mov	[si+SYSI_EXT.Country_Tab+2],es
 42638 0000794E 8C4402                  	mov	[si+SYSI_EXT.SysInitVars+2],es
 42639                                  
 42640                                  	; buffhead -> dosdata:hashinitvar 
 42641                                  
 42642                                  	;mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
 42643 00007951 8C06[3A00]              	mov	[BUFFHEAD+2],es
 42644                                  	;mov	si,offset dosdata:hashinitvar ; and all other references
 42645                                  	;mov	si,6Dh
 42646 00007955 BE[6D00]                	mov	si,HASHINITVAR
 42647                                  	;mov	[es:BUFFHEAD],si
 42648 00007958 8936[3800]              	mov	[BUFFHEAD],si
 42649                                  
 42650 0000795C 5A                              pop     dx                      ; restore address of arena
 42651                                  
 42652                                  	;mov	[032Ch+2],dx
 42653 0000795D 8916[2E03]                      mov     [DMAADD+2],dx
 42654                                  
 42655                                  	;mov	[es:arena_head],dx
 42656 00007961 8916[2400]              	mov	[arena_head],dx
 42657                                  
 42658                                  ;%endif
 42659                                  
 42660                                  ; 17/12/2022
 42661                                  %if 0
 42662                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42663                                  	;;;
 42664                                  	;mov	[es:si+6],es
 42665                                  	mov	[es:si+SYSI_EXT.Country_Tab+2],es
 42666                                  	;mov	[es:si+2],es
 42667                                  	mov	[es:si+SYSI_EXT.SysInitVars+2],es
 42668                                  
 42669                                  	; buffhead -> dosdata:hashinitvar 
 42670                                  
 42671                                  	mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
 42672                                  	;mov	si,offset dosdata:hashinitvar ; and all other references
 42673                                  	;mov	si,6Dh
 42674                                  	mov	si,HASHINITVAR
 42675                                  	mov	[es:BUFFHEAD],si
 42676                                  
 42677                                          pop     dx                      ; restore address of arena
 42678                                  
 42679                                  	;mov	[032Ch+2],dx
 42680                                          mov     [DMAADD+2],dx
 42681                                  
 42682                                  	mov	[es:arena_head],dx
 42683                                  	;;;
 42684                                  %endif
 42685                                  
 42686 00007965 8EDA                            mov     ds,dx
 42687                                  
 42688                                  	;mov	byte [0],'Z'
 42689 00007967 C60600005A              	mov     byte [ARENA.SIGNATURE],arena_signature_end
 42690                                          ;mov	word [1],0
 42691 0000796C C70601000000            	mov     word [ARENA.OWNER],arena_owner_system
 42692                                  
 42693 00007972 36A1[4603]                      mov     ax,[ss:ENDMEM]
 42694 00007976 29D0                    	sub	ax,dx
 42695 00007978 48                              dec     ax
 42696 00007979 A30300                          mov     [ARENA.SIZE],ax
 42697                                  
 42698                                  	; point to sft 0
 42699                                  
 42700                                  	;mov	di,offset dosdata:sftabl + sftable
 42701                                  	;mov	di,SFTABL+6
 42702 0000797C BF[D200]                	mov	di,SFTABL+SFT.SFTable
 42703 0000797F B80300                          mov     ax,3
 42704 00007982 AB                              stosw           		; adjust refcount
 42705                                  
 42706                                  	; es:di is shared data area i.e., es:di -> dosdata:sysinttable
 42707                                  
 42708                                          ;mov	di,offset dosdata:sysinittable
 42709                                  	;mov	di,0D28h
 42710 00007983 BF[280D]                	mov	di,SysInitTable	
 42711                                  
 42712 00007986 42                      	inc	dx			; advance dx from arena to psp
 42713 00007987 8EDA                    	mov	ds,dx			; point ds to psp
 42714                                  
 42715                                  					; pass the address os seg_reinit 
 42716                                  					; in dx
 42717 00007989 BA[F779]                	mov	dx,seg_reinit
 42718 0000798C B9[1A74]                	mov	cx,exepatch_start
 42719 0000798F 81E9[0000]              	sub	cx,_$STARTCODE		; cx = (doscode - exepatch) - dosinit
 42720                                  
 42721 00007993 B8[D276]                	mov	ax,SYSBUF
 42722 00007996 2D[0000]                	sub	ax,_$STARTCODE		; ax = size of doscode - dosinit
 42723                                  	
 42724 00007999 368B26[8405]                    mov     sp,[ss:USER_SP]		; use ss override for next 2
 42725 0000799E 368E16[8605]                    mov     ss,[ss:USER_SS]
 42726                                  
 42727 000079A3 CB                              retf
 42728                                  
 42729                                  ;
 42730                                  ; END OF DOSINIT
 42731                                  ;
 42732                                  ;--------------------------------------------------------------------------
 42733                                  
 42734                                  CHARINIT:
 42735                                  	; 24/04/2019 - Retro DOS v4.0
 42736                                  	; 07/07/2018 - Retro DOS v3.0
 42737                                  	;mov	byte [ss:035Ah],26 ; 1Ah
 42738 000079A4 36C606[5A03]1A                  MOV	BYTE [SS:DEVCALL_REQLEN],DINITHL
 42739                                  	;mov	byte [ss:035Bh],0
 42740 000079AA 36C606[5B03]00                  MOV	BYTE [SS:DEVCALL_REQUNIT],0
 42741                                  	;mov	byte [ss:035Ch],0
 42742 000079B0 36C606[5C03]00                  MOV	BYTE [SS:DEVCALL_REQFUNC],DEVINIT
 42743                                  	;mov	word [ss:035BD],0
 42744 000079B6 36C706[5D03]0000                MOV	WORD [SS:DEVCALL_REQSTAT],0
 42745 000079BD 06                              PUSH	ES
 42746 000079BE 53                              PUSH	BX
 42747 000079BF 50                              PUSH	AX
 42748 000079C0 BB[5A03]                        MOV	BX,DEVCALL
 42749                                          ;PUSH	CS
 42750 000079C3 16                      	PUSH	SS ; 30/04/2019
 42751 000079C4 07                              POP	ES
 42752 000079C5 E8C9CC                          CALL	DEVIOCALL2	
 42753 000079C8 58                      	POP	AX
 42754 000079C9 5B                              POP	BX
 42755 000079CA 07                              POP	ES
 42756 000079CB C3                              RETN
 42757                                  
 42758                                  ; 25/04/2019 - Retro DOS v4.0
 42759                                  
 42760                                  ;-----------------------------------------------------------------------------
 42761                                  ;
 42762                                  ;	check_XMM: routine to check presence of XMM driver
 42763                                  ;
 42764                                  ;	Exit:   Sets up the XMM entry point in XMMcontrol in DOSDATA
 42765                                  ;
 42766                                  ;	USED:	none
 42767                                  ;
 42768                                  ;-----------------------------------------------------------------------------
 42769                                  
 42770                                  check_XMM: ; proc near
 42771                                  ;
 42772                                  ; determine whether or not an XMM driver is installed
 42773                                  ;
 42774 000079CC 50                      	push	ax
 42775                                  	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_INSTALL_CHECK
 42776 000079CD B80043                  	mov	ax,4300h
 42777 000079D0 CD2F                    	int	2Fh
 42778                                  		; - Multiplex - XMS - INSTALLATION CHECK
 42779                                  		; Return: AL = 80h XMS driver installed
 42780                                  		; AL <> 80h no driver
 42781 000079D2 3C80                    	cmp	al,80h			; Q: installed
 42782 000079D4 751D                    	jne	short cXMM_no_driver	; N: set error, quit
 42783                                  ;
 42784                                  ; get the XMM control functions entry point, save it, we
 42785                                  ; need to call it later.
 42786                                  ;
 42787 000079D6 53                      	push	bx
 42788 000079D7 52                      	push	dx
 42789 000079D8 1E                      	push	ds
 42790 000079D9 06                      	push	es
 42791                                  	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_FUNCTION_ADDR
 42792 000079DA B81043                  	mov	ax,4310h
 42793 000079DD CD2F                    	int	2Fh
 42794                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
 42795                                  		; Return: ES:BX -> driver entry point
 42796                                  
 42797 000079DF 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 42798                                  
 42799 000079E4 891E[4911]              	mov	[XMMcontrol],bx
 42800 000079E8 8C06[4B11]              	mov	[XMMcontrol+2],es
 42801                                  cXMMexit:
 42802 000079EC F8                      	clc
 42803 000079ED 07                      	pop	es
 42804 000079EE 1F                      	pop	ds
 42805 000079EF 5A                      	pop	dx
 42806 000079F0 5B                      	pop	bx
 42807 000079F1 58                      	pop	ax
 42808 000079F2 C3                      	retn				; done
 42809                                  ;
 42810                                  ; set carry if XMM driver not present
 42811                                  ;
 42812                                  cXMM_no_driver:
 42813 000079F3 F9                      	stc
 42814 000079F4 58                      	pop	ax
 42815 000079F5 C3                      	retn
 42816                                  
 42817                                  ;-----------------------------------------------------------------------------
 42818                                  ;
 42819                                  ; Procedure Name : seg_reinit
 42820                                  ;
 42821                                  ; Inputs	 : ES has final dos code location
 42822                                  ;		   AX = 0 / 1
 42823                                  ;
 42824                                  ; Outputs	 : Patch in the sharer and other tables with seg in ES
 42825                                  ;		   if AX =0
 42826                                  ;		      if first entry
 42827                                  ;			 patch segment & offset of vectors with stub
 42828                                  ;			 and stub with segment in ES
 42829                                  ;		      else
 42830                                  ;			 patch stub with segment in ES
 42831                                  ;
 42832                                  ;		   else if AX = 1
 42833                                  ;			patch segment of vectors with segment in ES	
 42834                                  ;
 42835                                  ; NOTE		 : This routine can be called at most twice!
 42836                                  ;
 42837                                  ; Regs Mod.	 : es, ax, di, cx, bx
 42838                                  ;-----------------------------------------------------------------------------
 42839                                  
 42840 000079F6 00                      num_entry: db	0		; keeps track of the # of times this routine
 42841                                  				; has been called. (0 or 1)
 42842                                  
 42843                                  	; 04/11/2022 - Retro DOS v4.0 (ref: MSDOS 5.0)
 42844                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BAB7h
 42845                                  	; 25/05/2019 - Retro DOS v4.0 (ref: MSDOS 6.21)
 42846                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDA5h
 42847                                  
 42848                                  seg_reinit:	; proc	far
 42849 000079F7 1E                      	push	ds
 42850                                  
 42851 000079F8 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 42852                                  
 42853 000079FD E88600                  	call	patch_misc_segments	; patch in segments for sharer and 
 42854                                  					; other tables with seg in ES.
 42855                                  	; 17/12/2022
 42856                                  	; cx = 0
 42857 00007A00 39C8                    	cmp	ax,cx ; 0
 42858                                  	;cmp	ax,0
 42859 00007A02 753D                    	jne	short patch_vec_seg	; patch vectors with segment in es
 42860                                  
 42861                                  	; 17/12/2022
 42862 00007A04 2E380E[F679]            	cmp	[cs:num_entry],cl ; 0
 42863                                  	;cmp	byte [cs:num_entry],0	; Q: is it the first call to this 
 42864 00007A09 7508                    	jne	short second_entry	; N: just patch the stub with 
 42865                                  					;    segment in ES
 42866                                  					; Y: patch the vectors with stub 
 42867 00007A0B 8CD8                    	mov	ax,ds
 42868 00007A0D E83E00                  	call	patch_vec_segments	; patch the segment of vectors
 42869 00007A10 E8BD00                  	call	patch_offset		; patch the offsets of vectors 
 42870                                  					; with those in the stub.
 42871                                  	; 17/12/2022
 42872                                  	; cx = 0
 42873                                  second_entry:
 42874 00007A13 8CC0                    	mov	ax,es			; patch the stub with segment in es
 42875                                  
 42876                                  	;mov	di,OFFSET DOSDATA:DOSINTTABLE
 42877                                  	;mov	di,1062h	; (same table addr for MSDOS 5.0 and MSDOS 6.21)
 42878 00007A15 BF[4810]                	mov	di,DOSINTTABLE
 42879                                  	; 17/12/2022
 42880                                  	; cx = 0
 42881                                  	;mov	cx,9
 42882 00007A18 B109                    	mov	cl,9
 42883 00007A1A 1E                      	push	ds			
 42884 00007A1B 07                      	pop	es			; es:di -> DOSINTTABLE
 42885                                  
 42886                                  dosinttabloop:
 42887                                  	;add	di,2
 42888                                  	; 19/06/2023
 42889 00007A1C 47                      	inc	di
 42890 00007A1D 47                      	inc	di
 42891 00007A1E AB                      	stosw
 42892 00007A1F E2FB                    	loop	dosinttabloop	
 42893                                  
 42894                                  ; For ROMDOS, this routine will only be called when the DOS wants to
 42895                                  ; use the HMA, so we don't want to check CS
 42896                                  
 42897                                  ;ifndef ROMDOS
 42898 00007A21 3D00F0                  	cmp	ax,0F000h		; Q: is the DOS running in the HMA
 42899 00007A24 7220                    	jb	short sr_done		; N: done
 42900                                  ;endif
 42901 00007A26 E8A3FF                  	call	check_XMM		; Y: set up the XMS entry point
 42902 00007A29 721B                    	jc	short sr_done		; failed to set up XMS do not do
 42903                                  					; A20 toggling in the stub.
 42904                                  	; 17/12/2022
 42905                                  	; cx = 0
 42906 00007A2B E81D01                  	call	patch_in_nops		; enable the stub to check A20 state
 42907                                  ; M021-
 42908                                  	;mov	byte [1211h],1
 42909 00007A2E C606[F211]01            	mov	byte [DosHasHMA],1	; set flag telling DOS control of HMA 
 42910                                  				
 42911                                  					; set pointer to the routine that 
 42912                                  					; patches buggy exepacked code.
 42913                                  	;mov	[FixExePatch],offset DOSCODE:ExePatch
 42914 00007A33 C706[F311][6A75]        	mov	word [FixExePatch],ExePatch
 42915                                  					; M068: set pointer to the routine 
 42916                                  					; M068: that detects copy protected
 42917                                  					; M068: apps
 42918                                  	;mov	[ChkCopyProt],offset DOSCODE:IsCopyProt
 42919 00007A39 C706[6100][9B76]        	mov	word [ChkCopyProt],IsCopyProt
 42920                                  
 42921                                  	; 19/09/2023
 42922 00007A3F EB05                    	jmp	short sr_done
 42923                                  
 42924                                  ; 28/12/2022 - Retro DOS v4.1
 42925                                  %if 0
 42926                                  ;----------------------------------------------------------------------------
 42927                                  
 42928                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDF1h
 42929                                  
 42930                                  ;	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42931                                  ;
 42932                                  ;; M020 - begin
 42933                                  ;
 42934                                  ;	call	WhatCPUType
 42935                                  ;	cmp	al,1
 42936                                  ;	jne	short sr_done 		; we need Rational Patch only
 42937                                  ;					;  on 286 systems
 42938                                  ;	;mov	[RationalPatchPtr],offset DOSCODE:RationalPatch
 42939                                  ;	mov	word [RationalPatchPtr],RationalPatch
 42940                                  ;
 42941                                  ;; M020 - end
 42942                                  ;
 42943                                  ;	jmp	short sr_done
 42944                                  ;
 42945                                  ;patch_vec_seg:				; patch vectors with segment in es
 42946                                  ;	mov	ax,es
 42947                                  ;	call	patch_vec_segments	; patch in DOSCODE for the segments
 42948                                  ;					; NOTE we don't have to patch the 
 42949                                  ;					; offsets as they have been already
 42950                                  ;					; set to the doscode offsets at
 42951                                  ;					; DOSINIT.
 42952                                  ;sr_done:
 42953                                  ;	mov	byte [cs:num_entry],1
 42954                                  ;	pop	ds
 42955                                  ;	retf	; ! far return !
 42956                                  
 42957                                  ;----------------------------------------------------------------------------
 42958                                  ;
 42959                                  ; Procedure Name : WhatCPUType
 42960                                  ;
 42961                                  ; Inputs	 : none
 42962                                  ;
 42963                                  ; Outputs	 : AL = 0 if CPU <  286
 42964                                  ;		      = 1 if CPU == 286
 42965                                  ;		      = 2 if CPU >= 386
 42966                                  ;
 42967                                  ; Regs. Mod.	 : AX
 42968                                  ;
 42969                                  ;----------------------------------------------------------------------------
 42970                                  
 42971                                  WhatCPUType:
 42972                                  	; 25/04/2019 - Retro DOS v4.0
 42973                                  	;get_cpu_type	; done with a MACRO which can't be generated > once
 42974                                  
 42975                                  	;CPUTYPE.INC (MSDOS 6.0, 1991)
 42976                                  
 42977                                  ; Note: this must be a macro, and not a subroutine in the BIOS since
 42978                                  ; 	it is called from both CODE and SYSINITSEG.
 42979                                  ;
 42980                                  ;------GET_CPU_TYPE-----------------------------------May, 88 by M.Williamson
 42981                                  ;  Returns: AX = 0 if 8086 or 8088
 42982                                  ;              = 1 if 80286
 42983                                  ;              = 2 if 80386
 42984                                  
 42985                                  	; 04/11/2022
 42986                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB03h
 42987                                  
 42988                                  Get_CPU_Type:	;macro
 42989                                  	pushf
 42990                                  	push	bx			; preserve bx
 42991                                  	xor	bx,bx			; init bx to zero
 42992                                  
 42993                                  	xor	ax,ax			; 0000 into AX
 42994                                  	push	ax			; put it on the stack...
 42995                                  	popf				; ...then shove it into the flags
 42996                                  	pushf				; get it back out of the flags...
 42997                                  	pop	ax			; ...and into ax
 42998                                  	and	ax,0F000h		; mask off high four bits
 42999                                  	cmp	ax,0F000h		; was it all 1's?
 43000                                  	je	short cpu_8086		; aye; it's an 8086 or 8088
 43001                                  
 43002                                  	mov	ax,0F000h		; now try to set the high four bits..
 43003                                  	push	ax
 43004                                  	popf
 43005                                  	pushf
 43006                                  	pop	ax			; ...and see what happens
 43007                                  	and	ax,0F000h		; any high bits set ?
 43008                                  	jz	short cpu_286		; nay; it's an 80286
 43009                                  
 43010                                  cpu_386:				; bx starts as zero
 43011                                  	inc	bx			; inc twice if 386
 43012                                  cpu_286:				; just inc once if 286
 43013                                  	inc	bx
 43014                                  cpu_8086:				; don't inc at all if 086
 43015                                  	mov	ax,bx			; put CPU type value in ax
 43016                                  	pop	bx			; restore original bx
 43017                                  	popf
 43018                                  	
 43019                                  	;endm
 43020                                  
 43021                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS)
 43022                                  	retn	; 19/09/2023
 43023                                  
 43024                                  ; 19/09/2023
 43025                                  ;	; 04/11/2022
 43026                                  ;	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB27h
 43027                                  ;	cmp	al,1
 43028                                  ;	jne	short sr_done 		; we need Rational Patch only
 43029                                  ;					;  on 286 systems
 43030                                  ;	mov	word [RationalPatchPtr],RationalPatch
 43031                                  
 43032                                  ;----------------------------------------------------------------------------
 43033                                  %endif	; 28/12/2022
 43034                                  
 43035                                  	; 19/09/2023
 43036                                  	;jmp	short sr_done
 43037                                  
 43038                                  patch_vec_seg:				; patch vectors with segment in es
 43039 00007A41 8CC0                    	mov	ax,es
 43040 00007A43 E80800                  	call	patch_vec_segments	; patch in DOSCODE for the segments
 43041                                  					; NOTE we don't have to patch the 
 43042                                  					; offsets as they have been already
 43043                                  					; set to the doscode offsets at
 43044                                  					; DOSINIT.
 43045                                  sr_done:
 43046 00007A46 2EC606[F679]01          	mov	byte [cs:num_entry],1
 43047 00007A4C 1F                      	pop	ds
 43048 00007A4D CB                      	retf	; ! far return !
 43049                                  
 43050                                  ;----------------------------------------------------------------------------
 43051                                  ;
 43052                                  ; Procedure Name : patch_vec_segments
 43053                                  ;
 43054                                  ; Inputs	 : ax -> has segment address to patch in
 43055                                  ;		   ds -> DOSDATA
 43056                                  ;
 43057                                  ; Outputs	 : Patches in AX as the segment for the following vectors:
 43058                                  ;			
 43059                                  ;			0,20-28,3a-3f
 43060                                  ;
 43061                                  ; Regs. Mod.	 : DI,CX,DX,AX
 43062                                  ;
 43063                                  ;----------------------------------------------------------------------------
 43064                                  
 43065                                  patch_vec_segments:
 43066                                  
 43067 00007A4E 06                      	push	es
 43068                                  
 43069 00007A4F 31C9                    	xor	cx,cx ; 0
 43070 00007A51 8EC1                    	mov	es,cx
 43071                                  
 43072                                  	;mov	di,82h
 43073 00007A53 BF8200                  	mov	di,INTBASE+2		; di -> segment of int 20 vector
 43074                                  
 43075 00007A56 26A30200                	mov	[es:2],ax		; segment of default divide trap handler
 43076                                  
 43077                                  					; set vectors 20 & 21
 43078                                  	; 04/11/2022
 43079                                  	;mov	cx,2
 43080                                  	; 17/12/2022
 43081                                  	;mov	cl,2
 43082                                  ps_set1:
 43083 00007A5A AB                      	stosw	; int 20h segment
 43084                                  	;add	di,2
 43085                                  	; 17/12/2022
 43086 00007A5B 47                      	inc	di
 43087 00007A5C 47                      	inc	di
 43088                                  	;loop	ps_set1
 43089                                  
 43090                                  	; 17/12/2022
 43091 00007A5D AB                      	stosw	; int 21h segment
 43092                                  	;inc	di
 43093                                  	;inc	di
 43094                                  
 43095                                  	;add	di,4			; skip int 22h vector
 43096 00007A5E 83C706                  	add	di,6 ; *
 43097                                  
 43098 00007A61 AB                      	stosw				; set int 23h
 43099 00007A62 83C706                  	add	di,6			; skip int 24h
 43100                                  
 43101                                  					; set vectors 25-28 and 2a-3f 
 43102                                  	; 04/11/2022
 43103                                  	;mov	cx,4			; set 4 segments
 43104                                  	; 17/12/2022
 43105 00007A65 B104                    	mov	cl,4
 43106                                  ps_set2:
 43107 00007A67 AB                      	stosw				
 43108                                  	;add	di,2
 43109                                  	; 17/12/2022
 43110 00007A68 47                      	inc	di
 43111 00007A69 47                      	inc	di
 43112 00007A6A E2FB                    	loop	ps_set2
 43113                                  
 43114 00007A6C 83C704                  	add	di,4			; skip int 29h vector (fast con) as it may
 43115                                  					;   already be set.
 43116                                  	; 04/11/2022
 43117                                  	;mov	cx,6			; set 6 segs (skip 2 between each)
 43118                                  	; 17/12/2022
 43119 00007A6F B106                    	mov	cl,6			;  set segs for ints 2ah-2fh
 43120                                  ps_set3:
 43121 00007A71 AB                      	stosw
 43122                                  	;add	di,2
 43123                                  	; 17/12/2022
 43124 00007A72 47                      	inc	di
 43125 00007A73 47                      	inc	di
 43126 00007A74 E2FB                    	loop	ps_set3
 43127                                  
 43128                                  ; 30h & 31H is the CPM call entry point whose segment address is set up by
 43129                                  ; below. So skip it.
 43130                                  
 43131 00007A76 83C708                  	add	di,8			; skip vector 30h & 31h 
 43132                                  	
 43133                                  	; 04/11/2022
 43134                                  	;mov	cx,14			; set 14 segs (skip 2 between each)
 43135                                  	; 17/12/2022
 43136 00007A79 B10E                    	mov	cl,14			;   sets segs for ints 32h-3fh
 43137                                  ps_set4:
 43138 00007A7B AB                      	stosw
 43139                                  	;add	di,2
 43140                                  	; 17/12/2022
 43141 00007A7C 47                      	inc	di
 43142 00007A7D 47                      	inc	di
 43143 00007A7E E2FB                    	loop	ps_set4
 43144                                  
 43145                                  ; set offset of int2f
 43146                                  
 43147                                  ;if installed
 43148                                  ;	mov	word ptr es:[02fh * 4],offset doscode:int2f
 43149                                  ;endif
 43150                                  	;mov	[es:0C3h],ax
 43151 00007A80 26A3C300                	mov	[es:ENTRYPOINT+3],ax
 43152                                  	; 17/12/2022
 43153                                  	; cx = 0
 43154 00007A84 07                      	pop	es
 43155 00007A85 C3                      	retn
 43156                                  
 43157                                  ;---------------------------------------------------------------------------
 43158                                  ;
 43159                                  ; Procedure Name : patch_misc_segments
 43160                                  ;
 43161                                  ; Inputs	 : es = segment to patch in
 43162                                  ;		   ds = dosdata
 43163                                  ;
 43164                                  ; outputs	 : patches in the sharer and other tables in the dos
 43165                                  ;		   with right dos code segment in es
 43166                                  ;
 43167                                  ; Regs Mod	 : DI,SI,CX
 43168                                  ;
 43169                                  ;---------------------------------------------------------------------------
 43170                                  
 43171                                  patch_misc_segments:
 43172                                  
 43173 00007A86 53                      	push	bx
 43174 00007A87 06                      	push	es
 43175 00007A88 50                      	push	ax
 43176                                  
 43177 00007A89 8CC0                    	mov	ax,es			; ax - > DOS segment
 43178                                  	
 43179 00007A8B 1E                      	push	ds
 43180 00007A8C 07                      	pop	es			; es -> DOSDATA
 43181                                  	
 43182                                  ; initialize the jump table for the sharer...
 43183                                  
 43184                                  	;mov	di,offset dosdata:jshare
 43185                                  	;mov	di,90h
 43186 00007A8D BF[9000]                	mov	di,JShare
 43187                                  	;mov	bx,[0AAAh]
 43188 00007A90 8B1E[AA0A]              	mov	bx,[TEMP_DOSLOC]	; bx = location to which the share
 43189                                  					; table was patched during the first
 43190                                  					; call to this routine
 43191 00007A94 B90F00                  	mov	cx,15
 43192                                  jumptabloop:
 43193                                  	;add	di,2			; skip offset
 43194                                  	; 17/12/2022
 43195 00007A97 47                      	inc	di
 43196 00007A98 47                      	inc	di
 43197 00007A99 83FBFF                  	cmp	bx,-1 ; 0FFFFh		; Q: is this called for the 1st time
 43198 00007A9C 7405                    	je	short share_patch	; Y: patch in sharer table
 43199                                  					; N: 
 43200 00007A9E 263B1D                  	cmp	bx,[es:di]		; Q: has share been installed
 43201 00007AA1 7501                    	jne	short no_share_patch	; Y: don't patch in sharer table
 43202                                  share_patch:
 43203 00007AA3 AB                      	stosw				; drop in segment
 43204                                  no_share_patch:
 43205 00007AA4 E2F1                    	loop	jumptabloop
 43206                                  					; BUGBUG patching the country info 
 43207                                  					; with dosdata can be done inline
 43208                                  					; in dosinit.
 43209                                  					; for dos 3.3 country info
 43210                                  					; table address
 43211                                  
 43212                                  	;mov	si,offset dosdata:country_cdpg
 43213                                  	;mov	si,122Ah   
 43214 00007AA6 BE[0012]                	mov	si,COUNTRY_CDPG
 43215                                  					; initialize double word
 43216                                  					; pointers with dosdata in ds
 43217                                  	;mov	[si+4Fh],ds
 43218                                  	;mov	[si+54h],ds
 43219                                  	;mov	[si+59h],ds
 43220                                  	;mov	[si+5Eh],ds
 43221                                  	;mov	[si+80h],ds
 43222                                  	;mov	[si+63h],ds
 43223 00007AA9 8C5C4F                  	mov	[si+DOS_CCDPG.ccUcase_ptr+2],ds    
 43224 00007AAC 8C5C54                  	mov	[si+DOS_CCDPG.ccFileUcase_ptr+2],ds 
 43225 00007AAF 8C5C59                  	mov	[si+DOS_CCDPG.ccFileChar_ptr+2],ds
 43226 00007AB2 8C5C5E                  	mov	[si+DOS_CCDPG.ccCollate_ptr+2],ds
 43227 00007AB5 8C9C8000                	mov	[si+DOS_CCDPG.ccMono_ptr+2],ds
 43228 00007AB9 8C5C63                  	mov	[si+DOS_CCDPG.ccDBCS_ptr+2],ds	
 43229                                  
 43230                                  					; fastopen routines are in doscode
 43231                                  					; so patch with doscode seg in ax
 43232                                  
 43233                                  	;mov	si,offset dosdata:fastopentable
 43234                                  	;mov	si,0D30h
 43235 00007ABC BE[300D]                	mov	si,FastOpenTable
 43236                                  
 43237                                  	; 17/12/2022
 43238                                  	; bx = [TEMP_DOSLOC]
 43239 00007ABF 83FBFF                  	cmp	bx,-1
 43240                                  	;cmp	word [TEMP_DOSLOC],-1	; Q: first time 
 43241 00007AC2 7405                    	je	short fast_patch	; Y: patch segment
 43242                                  	;mov	cx,[TEMP_DOSLOC]
 43243                                  					; Q: has fastopen patched in it's
 43244                                  					;    segment
 43245                                  	; 17/12/2022
 43246 00007AC4 3B5C04                  	cmp	bx,[si+fastopen_entry.name_caching+2]
 43247                                  	;;cmp	cx,[si+4]
 43248                                  	;cmp	cx,[si+fastopen_entry.name_caching+2]
 43249 00007AC7 7503                    	jne	short no_fast_patch	; Y: don't patch in doscode seg
 43250                                  
 43251                                  fast_patch:
 43252                                  	;mov	[si+4],ax
 43253 00007AC9 894404                  	mov	[si+fastopen_entry.name_caching+2],ax
 43254                                  no_fast_patch:
 43255                                  	; 17/12/2022
 43256                                  	; cx = 0
 43257 00007ACC 58                      	pop	ax
 43258 00007ACD 07                      	pop	es
 43259 00007ACE 5B                      	pop	bx
 43260                                  
 43261 00007ACF C3                      	retn
 43262                                  
 43263                                  ;--------------------------------------------------------------------------
 43264                                  ;
 43265                                  ; Procedure Name : patch_offset
 43266                                  ; 
 43267                                  ; Inputs	 : NONE
 43268                                  ;
 43269                                  ; Outputs	 : Patches in the offsets in the low_mem_stub for vectors
 43270                                  ;		   0,20-28,3a-3f, and 30,31
 43271                                  ;
 43272                                  ;
 43273                                  ; Regs. Mod	 : AX,DI,CX
 43274                                  ;--------------------------------------------------------------------------
 43275                                  
 43276                                  patch_offset:
 43277 00007AD0 06                      	push	es		; preserve es
 43278                                  
 43279 00007AD1 31C0                    	xor	ax,ax
 43280 00007AD3 8EC0                    	mov	es,ax
 43281                                  				; set default divide trap address
 43282                                  	;mov	word ptr es:[0],offset dosdata:ldivov	
 43283                                  	;mov	word [es:0],108Ah
 43284 00007AD5 26C7060000[7010]        	mov	word [es:0],ldivov
 43285                                  
 43286                                  	;mov	di,80h
 43287 00007ADC BF8000                  	mov	di,INTBASE	; di-> offset of int 20 handler
 43288                                  	;mov	ax,offset dosdata:lirett
 43289                                  	;mov	ax,10DAh
 43290 00007ADF B8[C010]                	mov	ax,lirett
 43291                                  				; set vectors 20 & 21 to point to iret.
 43292                                  	; 17/12/2022
 43293                                  	; cx = 0
 43294                                  
 43295                                  	;mov	cx,2		; set 2 offsets (skip 2 between each)
 43296                                  po_iset1:
 43297 00007AE2 AB                      	stosw	; int 20h offset
 43298                                  	;add	di,2 ; *
 43299                                  	;loop	po_iset1
 43300                                  	; 17/12/2022
 43301 00007AE3 47                      	inc	di
 43302 00007AE4 47                      	inc	di
 43303 00007AE5 AB                      	stosw	; int 21h offset
 43304                                  
 43305                                  	;add	di,4		; skip vector 22h
 43306                                  	; 17/12/2022
 43307 00007AE6 83C706                  	add	di,6 ; *	
 43308                                  
 43309 00007AE9 AB                      	stosw			; set offset of 23h
 43310                                  	;add	di,6		; skip 24h
 43311                                  	; 19/09/2023
 43312 00007AEA 83C712                  	add	di,18		; skip 23h segment and int 24-25-26-27h
 43313                                  
 43314                                  				; set vectors 25-28 and 2a-3f to iret.
 43315                                  	; 04/11/2022
 43316                                  	;mov	cx,4		; set 4 offsets (skip 2 between each)
 43317                                  	; 19/09/2023
 43318                                  	; 17/12/2022
 43319                                  	;mov	cl,4		;   sets offsets for ints 25h-28h
 43320                                  po_iset2:
 43321 00007AED AB                      	stosw		; set offset for int 28h ; 19/09/2023
 43322                                  	;add	di,2
 43323                                  	; 19/09/2023
 43324                                  	; 17/12/2022
 43325                                  	;inc	di
 43326                                  	;inc	di
 43327                                  	; 19/09/2023
 43328                                  	;loop	po_iset2
 43329                                  
 43330                                  	;add	di,4		; skip vector 29h
 43331                                  	; 19/09/2023
 43332 00007AEE 83C706                  	add	di,6	; skip int 28h segment and int 29h ; 19/09/2023
 43333                                  
 43334                                  	; 04/11/2022
 43335                                  	;mov	cx,6		; set 6 offsets (skip 2 between each)
 43336                                  	; 17/12/2022
 43337                                  	;mov	cl,6		;   sets offsets for ints 2ah-2fh
 43338 00007AF1 B105                    	mov	cl,5		; sets offsets for ints 2Ah-2Eh
 43339                                  po_iset3:
 43340 00007AF3 AB                      	stosw
 43341                                  	;add	di,2
 43342                                  	; 17/12/2022
 43343 00007AF4 47                      	inc	di
 43344 00007AF5 47                      	inc	di
 43345 00007AF6 E2FB                    	loop	po_iset3
 43346                                  
 43347                                  ; 30h & 31H is the CPM call entry point whose offset address is set up by
 43348                                  ; below. So skip it.
 43349                                  
 43350                                  	;add	di,8		; skip vector 30h & 31h 
 43351                                  	; 17/12/2022
 43352 00007AF8 83C70C                  	add	di,12		; skip vector 2Fh, 30h & 31h
 43353                                  
 43354                                  	; 04/11/2022
 43355                                  	;mov	cx,14		; set 14 offsets (skip 2 between each)
 43356                                  				;   sets offsets for ints 32h-3fh
 43357                                  	; 17/12/2022
 43358 00007AFB B10E                    	mov	cl,14 ; 26/06/2019
 43359                                  po_iset4:
 43360 00007AFD AB                      	stosw
 43361                                  	;add	di,2
 43362                                  	; 17/12/2022
 43363 00007AFE 47                      	inc	di
 43364 00007AFF 47                      	inc	di
 43365 00007B00 E2FB                    	loop	po_iset4
 43366                                  
 43367                                  ;if installed
 43368                                  	;mov	word ptr es:[02fh * 4],offset dosdata:lint2f
 43369                                  	;mov	word [es:0BCh],10C6h ; (MSDOS 5.0 & 6.21)
 43370 00007B02 26C706BC00[AC10]        	mov	word [es:(2Fh*4)],lint2f
 43371                                  ;endif
 43372                                  
 43373                                  ; set up entry point call at vectors 30-31h
 43374                                  	;mov	byte [es:0C0h],0EAh
 43375 00007B09 26C606C000EA            	mov	byte [es:ENTRYPOINT],mi_long_jmp
 43376                                  	;mov	word [es:0C1h],10D0h
 43377                                  
 43378 00007B0F 26C706C100[B610]        	mov	word [es:ENTRYPOINT+1],lcall_entry
 43379                                  
 43380                                  							; 19/09/2023
 43381                                  	;mov	word [es:80h],1094h
 43382 00007B16 26C7068000[7A10]        	mov	word [es:addr_int_abort],lquit		; int 20h
 43383                                  	;mov	word [es:84h],109Eh
 43384 00007B1D 26C7068400[8410]        	mov	word [es:addr_int_command],lcommand	; int 21h
 43385                                  	;mov	word [es:94h],10A8h
 43386 00007B24 26C7069400[8E10]        	mov	word [es:addr_int_disk_read],labsdrd	; int 25h  
 43387                                  	;mov	word [es:98h],10B2h
 43388 00007B2B 26C7069800[9810]        	mov	word [es:addr_int_disk_write],labsdwrt	; int 26h
 43389                                  	;mov	word [es:9Ch],10BCh
 43390 00007B32 26C7069C00[A210]        	mov	word [es:addr_int_keep_process],lstay_resident	; int 27h
 43391                                  
 43392                                  	; 17/12/2022
 43393                                  	; CX = 0
 43394 00007B39 07                      	pop	es		; restore es
 43395 00007B3A C3                      	retn
 43396                                  
 43397                                  ;--------------------------------------------------------------------------
 43398                                  ;
 43399                                  ; 	Procedure Name	:	patch_in_nops
 43400                                  ;
 43401                                  ; 	Entry		: 	ES -> DOSDATA
 43402                                  ;
 43403                                  ;	Regs Mod	: 	cx, di
 43404                                  ;
 43405                                  ;	Description:
 43406                                  ;		This routine patches in 2 nops at the offsets specified in 
 43407                                  ;	patch_table. This basically enables the low mem stub to start 
 43408                                  ;	making XMS calls.
 43409                                  ;
 43410                                  ;--------------------------------------------------------------------------
 43411                                  
 43412                                  	; 04/11/2022
 43413                                  	; (MSDOS 5.0 MSDOS.SYS)
 43414                                  	; DOSCODE:0BC50h
 43415                                  
 43416                                  patch_table:	; label	byte
 43417                                  	;dw	offset dosdata:i0patch
 43418                                  	;dw	offset dosdata:i20patch
 43419                                  	;dw	offset dosdata:i21patch
 43420                                  	;dw	offset dosdata:i25patch
 43421                                  	;dw	offset dosdata:i26patch
 43422                                  	;dw	offset dosdata:i27patch
 43423                                  	;dw	offset dosdata:i2fpatch
 43424                                  	;dw	offset dosdata:cpmpatch
 43425 00007B3B [7010]                  	dw	i0patch
 43426 00007B3D [7A10]                  	dw	i20patch
 43427 00007B3F [8410]                  	dw	i21patch
 43428 00007B41 [8E10]                  	dw	i25patch
 43429 00007B43 [9810]                  	dw	i26patch
 43430 00007B45 [A210]                  	dw	i27patch
 43431 00007B47 [AC10]                  	dw	i2fpatch
 43432 00007B49 [B610]                  	dw	cpmpatch
 43433                                  
 43434                                  patch_table_size equ ($-patch_table)/2
 43435                                  
 43436                                  patch_in_nops:
 43437 00007B4B 50                      	push	ax
 43438 00007B4C 56                      	push	si
 43439 00007B4D BE[3B7B]                	mov	si,patch_table
 43440 00007B50 B89090                  	mov	ax,9090h ; nop, nop
 43441                                  	; 17/12/2022
 43442                                  	; cx = 0
 43443                                  	;mov	cx,8
 43444                                  	;mov	cx,patch_table_size ; 8
 43445 00007B53 B108                    	mov	cl,patch_table_size ; 8
 43446                                  pin_loop:
 43447 00007B55 2E8B3C                  	mov	di,[cs:si]
 43448 00007B58 AB                      	stosw
 43449                                  	;add	si,2
 43450                                  	; 17/12/2022
 43451 00007B59 46                      	inc	si
 43452 00007B5A 46                      	inc	si
 43453 00007B5B E2F8                    	loop	pin_loop
 43454 00007B5D 5E                      	pop	si
 43455 00007B5E 58                      	pop	ax
 43456 00007B5F C3                      	retn
 43457                                  
 43458                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43459                                  ; ---------------------------------------------------------------------------
 43460                                  ; MSDOS 5.0 - MSDOS.SYS offset BC77h, file offset 7EA7h
 43461                                  ; ---------------------------------------------------------------------------
 43462                                  
 43463                                  	; 05/12/2022 - temporary ; (paragraph alinment)
 43464                                  DOSCODE_END:
 43465                                  	;times	9 db 0	; db 9 dup(0)
 43466                                  	; 18/12/2022
 43467 00007B60 0000                    	dw	0  ;	times 2 db 0
 43468                                  
 43469                                  ;align 16
 43470                                  	; DOSCODE:BC80h	(MSDOS 5.0 MSDOS.SYS file offset 7EB0h)
 43471                                  	; MSDOS.SYS file offset: 32432 (start of DOSDATA)
 43472                                  
 43473                                  ; ---------------------------------------------------------------------------
 43474                                  
 43475                                  
 43476                                  ;memstrt label word
 43477                                  ; ---------------------------------------------------------------------------
 43478                                  ; MSDOS 6.21 - MSDOS.SYS offset BF69h, file offset 8189h
 43479                                  ; ---------------------------------------------------------------------------
 43480                                  
 43481                                  MEMSTRT: ; 25/04/2019 - Retro DOS v4.0
 43482                                  
 43483                                  ; if not ROMDOS, then we close the dos code segment, otherwise we close
 43484                                  ; the dos initialization segment
 43485                                  
 43486                                  ;ifndef ROMDOS
 43487                                  
 43488                                  ;doscode ends
 43489                                  
 43490                                  ;else
 43491                                  
 43492                                  ;;dosinitseg ends
 43493                                  
 43494                                  ;endif ; ROMDOS
 43495                                  
 43496                                  ;============================================================================
 43497                                  
 43498                                  ; DPUBLIC <ParaRound, cXMM_no_driver, cXMMexit, char_init_loop, charinit>
 43499                                  ; DPUBLIC <check_XMM, continit, dosinttabloop, endlist>
 43500                                  ; DPUBLIC <initiret, iset1, iset2, jumptabloop, nxtentry>
 43501                                  ; DPUBLIC <notmax,  patch_offset, perdrv>
 43502                                  ; DPUBLIC <perunit, po_iset1, po_iset2, po_iset3>
 43503                                  ; DPUBLIC <ps_set1, ps_set2, ps_set3, seg_reinit>
 43504                                  ; DPUBLIC <sr_done, version_fake_table, xxx>
 43505                                  
 43506                                  ;; burasý doscode sonu
 43507                                  
 43508                                  ;============================================================================
 43509                                  ; DOSDATA
 43510                                  ;============================================================================
 43511                                  ; 29/04/2019 - Retro DOS 4.0
 43512                                  
 43513                                  ;[BITS 16]
 43514                                  
 43515                                  ;[ORG 0]
 43516                                  
 43517                                  ; 25/04/2019 - Retro DOS v4.0
 43518                                  
 43519                                  ;============================================================================
 43520                                  ; DOSDATA - MSDOS 6.21 - MSDOS.SYS Offset 0BF70h, file offset 8190h
 43521                                  ;============================================================================
 43522                                  
 43523                                  ;align 16
 43524                                  	; DOSDATA (MSDOS.SYS kernel DATA) segment starts here...
 43525                                  	; (4970 bytes for MSDOS 6.21)
 43526                                  	; (4976 bytes for Retro DOS v4.0, 25/05/2019 modification.)
 43527                                  
 43528                                  ;============================================================================
 43529                                  ; MSCONST.ASM (MSDOS 6.0, 1991)
 43530                                  ;============================================================================
 43531                                  ; 03/11/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43532                                  ; 25/04/2019 - Retro DOS 4.0 (MSDOS 6.21)
 43533                                  ; 16/07/2018 - Retro DOS 3.0	
 43534                                  
 43535                                  ;Break <Initialized data and data used at DOS initialization>
 43536                                  ;----------------------------------------------------------------------------
 43537                                  
 43538                                  ; We need to identify the parts of the data area that are relevant to tasks
 43539                                  ; and those that are relevant to the system as a whole. Under 3.0, the system
 43540                                  ; data will be gathered with the system code. The process data under 2.x will
 43541                                  ; be available for swapping and under 3.0 it will be allocated per-process.
 43542                                  ;
 43543                                  ; The data that is system data will be identified by [SYSTEM] in the comments
 43544                                  ; describing that data item.
 43545                                  
 43546                                  ;DOSDATA SEGMENT
 43547                                  
 43548                                  ; 04/11/2022
 43549                                  ;[ORG 0]
 43550                                  
 43551                                  ; ----------------------------------------------------------------------------
 43552                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43553                                  ; ----------------------------------------------------------------------------
 43554                                  ; DOSDATA segment start offset from beginning of MSDOS.SYS file: 32432 (7EB0h)
 43555                                  ; (3DD0h+7EB0h = 0BC80h) - for MSDOS 5.0 kernel file -
 43556                                  ; ----------------------------------------------------------------------------
 43557                                  
 43558                                  ; 04/11/2022
 43559                                  
 43560                                  ;DOSDATA:0000h
 43561                                  
 43562 00007B62 90<rep Eh>              align 16
 43563                                  
 43564                                  ; ----------------------------------------------------------------------------
 43565                                  ; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43566                                  ; ----------------------------------------------------------------------------
 43567                                  
 43568                                  segment .data  vstart=0 ; 06/12/2022
 43569                                  								
 43570                                  ; ============================================================================
 43571                                  
 43572                                  ; 06/12/2022
 43573                                  ;DOSDATASTART equ $
 43574                                  DOSDATASTART:
 43575                                  
 43576                                  
 43577                                  ;hkn; add 4 bytes to get correct offsets since jmp has been removed in START
 43578                                  
 43579                                  	;; 03/11/2022
 43580                                  	;jmp	DOSINIT		; MSDOS 5.0 - MSDOS.SYS (DOSDATA:0000h)
 43581                                  
 43582                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43583                                  	;db	4 dup (?)	
 43584 00000000 00<rep 4h>              	times	4 db 0
 43585                                  
 43586                                  	; 29/04/2019 - Retro DOS v4.0 modification
 43587                                  	;dw 	_$STARTCODE ; DOSCODE offset and/or size of DOSDATA
 43588                                  	;dw	0
 43589                                  
 43590                                  	;EVEN
 43591                                  
 43592                                  ;align 2
 43593                                  
 43594                                  ; WANGO!!! The following word is used by SHARE and REDIR to determin data
 43595                                  ; area compatability. This location must be incremented EACH TIME the data
 43596                                  ; area here gets mucked with.
 43597                                  ;
 43598                                  ; Also, do NOT change this position relative to DOSDATA:0.
 43599                                  
 43600                                  MSCT001S:	; LABEL BYTE
 43601                                  	
 43602                                  DataVersion:	
 43603 00000004 0100                    	dw	1	;AC000; [SYSTEM] version number for DOS DATA
 43604                                  
 43605                                  ;hkn; add 8 bytes to get correct offsets since BugTyp, BugLev and "BUG " has 
 43606                                  ;hkn; been removed to DOSCODE above
 43607                                  
 43608                                  ;M044
 43609                                  ; First part of save area for saving last para of Window memory
 43610                                  
 43611                                  WinoldPatch1:	; db 8 dup (?)	;M044
 43612 00000006 00<rep 8h>              	times	8 db 0
 43613                                  
 43614                                  	; MSDOS 6.21 DOSDATA:000Eh
 43615                                  MYNUM:			; Offset 000Eh
 43616 0000000E 0000                    	dw	0	; [SYSTEM] A number that goes with MYNAME
 43617                                  FCBLRU: 		; [SYSTEM] LRU count for FCB cache
 43618 00000010 0000                    	dw	0
 43619                                  OpenLRU:
 43620 00000012 0000                    	dw	0	; [SYSTEM] LRU count for FCB cache opens
 43621                                  OEM_HANDLER: 		
 43622 00000014 FFFFFFFF                	dd	-1	; [SYSTEM] Pointer to OEM handler code	
 43623                                  
 43624                                  ;	BUGBUG - who uses LeaveAddr?  What if we want to rework the
 43625                                  ;;			way that we leave DOS???? - jgl
 43626                                  
 43627                                  LeaveAddr:
 43628 00000018 [0404]                  	dw	LeaveDOS  ; <<OFFSET DOSCODE:LeaveDOS>> ; [SYSTEM]
 43629                                  RetryCount:		
 43630 0000001A 0300                    	dw	3	; [SYSTEM] Share retries
 43631                                  RetryLoop:
 43632 0000001C 0100                    	dw	1	; [SYSTEM] Share retries
 43633                                  LastBuffer:
 43634 0000001E FFFFFFFF                	dd	-1	; [SYSTEM] Buffer queue recency pointer
 43635                                  CONTPOS:
 43636 00000022 0000                    	dw	0	; [SYSTEM] location in buffer of next read
 43637                                  arena_head:
 43638 00000024 0000                    	dw	0	; [SYSTEM] Segment # of first arena in memory
 43639                                  
 43640                                  ;; 16/07/2018
 43641                                  ;;***************************************************************************
 43642                                  ;; NOTE: INT 21H AH=52H !  (http://stanislavs.org/helppc/int_21-52.html)
 43643                                  ;;***************************************************************************
 43644                                  ;; INT 21,52 - Get Pointer to DOS "INVARS" (Undocumented)
 43645                                  ;;
 43646                                  ;;	AH = 52h
 43647                                  ;;
 43648                                  ;;	on return:
 43649                                  ;;	ES:BX = pointer to DOS "invars", a table of pointers used by DOS.
 43650                                  ;;		Known "invars" fields follow (varies with DOS version):
 43651                                  ;;
 43652                                  ;;	Offset Size		 Description
 43653                                  ;;
 43654                                  ;;	 -12   word   sharing retry count (DOS 3.1-3.3)
 43655                                  ;;	 -10   word   sharing retry delay  (DOS 3.1-3.3)
 43656                                  ;;	  -8   dword  pointer to current disk buffer (DOS 3.x)
 43657                                  ;;	  -4   word   pointer in DOS code segment of unread CON input;
 43658                                  ;;		      0 indicates no unread input (DOS 3.x)
 43659                                  ;;	  -2   word   segment of first Memory Control Block (MCB)
 43660                                  ;;	  00   dword  pointer to first DRIVE PARAMETER TABLE (A:) in chain
 43661                                  ;;	  04   dword  pointer to DOS System File Table (SFT)
 43662                                  ;;	  08   dword  pointer to $CLOCK device driver
 43663                                  ;;	  0C   dword  pointer to CON device driver
 43664                                  ;;	  10   byte   number of logical drives in system
 43665                                  ;;	  11   word   maximum bytes/block of any block device
 43666                                  ;;	  13   dword  pointer to DOS cache buffer header
 43667                                  ;;	  17 18bytes  NUL device header, first 4 bytes of device header
 43668                                  ;;		      point to the next device in device chain
 43669                                  ;;
 43670                                  ;;***************************************************************************
 43671                                  
 43672                                  ; The following block of data is used by SYSINIT. 
 43673                                  ; Do not change the order or size of this block
 43674                                  
 43675                                  ;SYSINITVAR:
 43676                                  ;----------------------------------------------------------------------------
 43677                                  SYSINITVARS:
 43678                                  DPBHEAD:
 43679 00000026 00000000                	dd	0	; [SYSTEM] Pointer to head of DPB-FAT list
 43680                                  SFT_ADDR:
 43681 0000002A [CC000000]              	dd	SFTABL	; [SYSTEM] Pointer to first SFT table
 43682                                  BCLOCK:
 43683 0000002E 00000000                	dd	0	; [SYSTEM] The CLOCK device
 43684                                  BCON:
 43685 00000032 00000000                	dd	0	; [SYSTEM] Console device entry points
 43686                                  MAXSEC:
 43687 00000036 8000                    	dw	128	; [SYSTEM] Maximum allowed sector size
 43688                                  BUFFHEAD:
 43689 00000038 00000000                	dd	0	; [SYSTEM] Pointer to head of buffer queue
 43690                                  CDSADDR:
 43691 0000003C 00000000                	dd	0	; [SYSTEM] Pointer to curdir structure table
 43692                                  SFTFCB:
 43693 00000040 00000000                	dd	0	; [SYSTEM] pointer to FCB cache table
 43694                                  KEEPCOUNT:
 43695 00000044 0000                    	dw	0	; [SYSTEM] count of FCB opens to keep
 43696                                  NUMIO:
 43697 00000046 00                      	db	0	; [SYSTEM] Number of disk tables
 43698                                  CDSCOUNT:
 43699 00000047 00                      	db	0	; [SYSTEM] Number of CDS structures in above
 43700                                  
 43701                                  ; A fake header for the NUL device
 43702                                  NULDEV:
 43703 00000048 00000000                	dd	0	; [SYSTEM] Link to rest of device list
 43704                                  	;dw	8004h
 43705 0000004C 0480                    	dw	DEVTYP|ISNULL ; [SYSTEM] Null device attributes
 43706 0000004E [C60D]                  	dw	SNULDEV	; [SYSTEM] Strategy entry point
 43707 00000050 [CC0D]                  	dw	INULDEV	; [SYSTEM] Interrupt entry point
 43708 00000052 4E554C2020202020        	db	"NUL     " ; [SYSTEM] Name of null device
 43709                                  SPLICES:
 43710 0000005A 00                      	db	0	; [SYSTEM] TRUE => splices being done
 43711                                  
 43712                                  Special_Entries:
 43713 0000005B 0000                    	dw	0	; [SYSTEM] address of special entries ;AN000;
 43714                                  UU_IFS_DOS_CALL:
 43715 0000005D 00000000                	dd	0	; [SYSTEM] entry for IFS DOS service ;AN000;
 43716                                  ; 
 43717                                  ; UU_IFS_HEADER:
 43718                                  ; 	dd	0	; [SYSTEM] IFS header chain ;AN000;
 43719                                  
 43720                                  ChkCopyProt:
 43721 00000061 0000                    	dw	0	; M068
 43722                                  A20OFF_PSP:
 43723 00000063 0000                    	dw	0	; M068
 43724                                  BUFFERS_PARM1:
 43725 00000065 0000                    	dw	0	; [SYSTEM] value of BUFFERS= ,m	;AN000;
 43726                                  BUFFERS_PARM2:
 43727 00000067 0000                    	dw	0	; [SYSTEM] value of BUFFERS= ,n ;AN000;
 43728                                  BOOTDRIVE:
 43729 00000069 00                      	db	0	; [SYSTEM] the boot drive ;AN000;
 43730                                  DDMOVE:
 43731 0000006A 00                      	db	0 	; [SYSTEM] 1 if we need DWORD move ;AN000;
 43732                                  EXT_MEM_SIZE:
 43733 0000006B 0000                    	dw	0	; [SYSTEM] extended memory size	;AN000;
 43734                                  
 43735                                  HASHINITVAR: ; LABEL   WORD	; AN000;
 43736                                  ;
 43737                                  ; Replaced by next two declarations
 43738                                  ;
 43739                                  ;UU_BUF_HASH_PTR:
 43740                                  ;	dd	0	; [SYSTEM] buffer Hash table addr
 43741                                  ;UU_BUF_HASH_COUNT:
 43742                                  ;	dw	1	; [SYSTEM] number of Hash entries
 43743                                  
 43744                                  BufferQueue:
 43745 0000006D 00000000                	dd	0	; [SYSTEM] Head of the buffer Queue
 43746                                  DirtyBufferCount:
 43747 00000071 0000                    	dw	0	; [SYSTEM] Count of Dirty buffers in the Que
 43748                                  			; BUGBUG ---- change to byte
 43749                                  SC_CACHE_PTR:
 43750 00000073 00000000                	dd	0	; [SYSTEM] secondary cache pointer
 43751                                  SC_CACHE_COUNT:
 43752 00000077 0000                    	dw	0 	; [SYSTEM] secondary cache count
 43753                                  BuffInHMA:
 43754 00000079 00                      	db	0	; Flag to indicate that buffs are in HMA
 43755                                  LoMemBuff:
 43756 0000007A 00000000                	dd	0	; Ptr to intermediate buffer
 43757                                  			;  in Low mem when buffs are in HMA
 43758                                  ;
 43759                                  ; All variables which have UU_ as prefix can be reused for other
 43760                                  ; purposes and can be renamed. All these variables were used for
 43761                                  ; EMS support of Buffer Manager. Now they are useless for Buffer
 43762                                  ; manager ---- MOHANS
 43763                                  ;
 43764                                  	;I_am	UU_BUF_EMS_FIRST_PAGE,3,<0,0,0>  
 43765                                  UU_BUF_EMS_FIRST_PAGE:	
 43766 0000007E 000000                  	db	0,0,0	; holds the first page above 640K
 43767                                  
 43768                                  	;;I_am	UU_BUF_EMS_NPA640,WORD,<0> ; holds the number of pages 
 43769                                  ;UU_BUF_EMS_NPA640:			   ; above 640K	
 43770                                  ;	dw	0			
 43771                                  
 43772                                  CL0FATENTRY:
 43773 00000081 FFFF                    	dw	-1	; M014:	Holds the data that
 43774                                  			; is used in pack/unpack rts.
 43775                                  			; in fat.asm if cluster 0 is specified.
 43776                                  			; SR;
 43777                                  IoStatFail:
 43778 00000083 00                      	db	0	; IoStatFail has been added to 
 43779                                  			; record a fail on an I24 
 43780                                  			; issued from IOFUNC on a status call. 
 43781                                  
 43782                                  ;***	I_am	UU_BUF_EMS_MODE,BYTE,<-1>	; EMS mode 	;AN000;
 43783                                  ;***	I_am	UU_BUF_EMS_HANDLE,BYTE		; buffer EMS handle ;AN000;
 43784                                  ;***	I_am	UU_BUF_EMS_PAGE_FRAME,WORD ,<-1>; EMS page frame # ;AN000;
 43785                                  ;***	I_am	UU_BUF_EMS_SEG_CNT,WORD,<1>	; EMS seg count	;AN000;
 43786                                  ;***	I_am	UU_BUF_EMS_PFRAME,WORD		; EMS page frame seg address ;AN000;
 43787                                  ;***	I_am	UU_BUF_EMS_RESERV,WORD,<0> 	; reserved	;AN000;
 43788                                  ;
 43789                                  ;***	I_am	UU_BUF_EMS_MAP_BUFF,1,<0>	; this is not used to save the 
 43790                                  						; state of the 	buffers page.
 43791                                  						; This one byte is retained to 
 43792                                  						; keep the size of this data 
 43793                                  						; block the same.;
 43794                                  ALLOCMSAVE:
 43795 00000084 00                      	db	0	; M063: temp var. used to 
 43796                                  			; M063: save alloc method in
 43797                                  			; M063: msproc.asm
 43798                                  A20OFF_COUNT:
 43799 00000085 00                      	db	0	; M068: indiactes the # of 
 43800                                  			; M068: int 21 calls for 
 43801                                  			; M068: which A20 is off
 43802                                  DOS_FLAG:
 43803 00000086 00                      	db	0	; see DOSSYM.INC for Bit 
 43804                                  			; definitions
 43805                                  UNPACK_OFFSET:
 43806 00000087 0000                    	dw	0	; saves pointer to the start
 43807                                  			; of unpack code in exepatch.
 43808                                  			; asm.
 43809                                  UMBFLAG:
 43810 00000089 00                      	db	0 	; M003: bit 0 indicates the 
 43811                                  			; M003: link state of the UMBs
 43812                                  			; M003: whether linked or not 
 43813                                  			; M003: to the DOS arena chain
 43814                                  SAVE_AX:
 43815 0000008A 0000                    	dw	0	; M000: temp varibale to store ax
 43816                                  			; M000: in msproc.asm
 43817                                  UMB_HEAD:
 43818 0000008C FFFF                    	dw	-1	; M000: this is initialized to  
 43819                                  			; M000: the first umb arena by 
 43820                                  			; M000: BIOS sysinit.
 43821                                  START_ARENA:
 43822 0000008E 0100                    	dw	1	; M000: this is the first arena 
 43823                                  			; M000: from which DOS will 
 43824                                  			; M000: start its scan for alloc.
 43825                                  
 43826                                  ; End of SYSINITVar block
 43827                                  ;----------------------------------------------------------------------------
 43828                                  
 43829                                  ; 25/04/2019 - Retro DOS v4.0
 43830                                  
 43831                                  ; 16/07/2018
 43832                                  ; MSDOS 3.3 (& MDOS 6.0)
 43833                                  
 43834                                  ;
 43835                                  ; Sharer jump table
 43836                                  ;
 43837                                  
 43838                                  ;PUBLIC	JShare
 43839                                  	;EVEN
 43840                                  
 43841                                  ;JShare	LABEL	DWORD
 43842                                  ;	DW	OFFSET DOSCODE:BadCall, 0
 43843                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	1   MFT_enter
 43844                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	2   MFTClose
 43845                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	3   MFTclU
 43846                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	4   MFTCloseP
 43847                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	5   MFTCloN
 43848                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	6   set_block
 43849                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	7   clr_block
 43850                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	8   chk_block
 43851                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	9   MFT_get
 43852                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	10  ShSave
 43853                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	11  ShChk
 43854                                  ;	DW	OFFSET DOSCODE:OKCall , 0  ;	12  ShCol
 43855                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	13  ShCloseFile
 43856                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	14  ShSU
 43857                                  
 43858                                  align 2
 43859                                  
 43860                                  JShare:
 43861 00000090 [FD06]0000              		DW	BadCall,0
 43862 00000094 [0107]0000              MFT_enter:	DW	OKCall, 0  ; 1   MFT_enter
 43863 00000098 [0107]0000              MFTClose:	DW	OKCall, 0  ; 2   MFTClose
 43864 0000009C [FD06]0000              MFTclU:		DW	BadCall,0  ; 3   MFTclU
 43865 000000A0 [FD06]0000              MFTCloseP:	DW	BadCall,0  ; 4   MFTCloseP
 43866 000000A4 [FD06]0000              MFTCloN:	DW	BadCall,0  ; 5   MFTCloN
 43867 000000A8 [FD06]0000              set_block:	DW	BadCall,0  ; 6   set_block
 43868 000000AC [FD06]0000              clr_block:	DW	BadCall,0  ; 7   clr_block
 43869 000000B0 [0107]0000              chk_block:	DW	OKCall, 0  ; 8   chk_block
 43870 000000B4 [FD06]0000              MFT_get:	DW	BadCall,0  ; 9   MFT_get
 43871 000000B8 [FD06]0000              ShSave:		DW	BadCall,0  ; 10  ShSave
 43872 000000BC [FD06]0000              ShChk:		DW	BadCall,0  ; 11  ShChk
 43873 000000C0 [0107]0000              ShCol:		DW	OKCall, 0  ; 12  ShCol
 43874 000000C4 [FD06]0000              ShCloseFile:	DW	BadCall,0  ; 13  ShCloseFile
 43875 000000C8 [FD06]0000              ShSU:		DW	BadCall,0  ; 14  ShSU
 43876                                  
 43877                                  
 43878                                  ;============================================================================
 43879                                  ; CONST2.ASM (MSDOS 6.0, 1991)
 43880                                  ;============================================================================
 43881                                  ; 25/04/2019 - Retro DOS 4.0 
 43882                                  ; 16/07/2018 - Retro DOS 3.0	
 43883                                  
 43884                                  ;Break <Initialized data and data used at DOS initialization>
 43885                                  ;----------------------------------------------------------------------------
 43886                                  
 43887                                  ; We need to identify the parts of the data area that are relevant to tasks
 43888                                  ; and those that are relevant to the system as a whole.  Under 3.0, the system
 43889                                  ; data will be gathered with the system code.  The process data under 2.x will
 43890                                  ; be available for swapping and under 3.0 it will be allocated per-process.
 43891                                  ;
 43892                                  ; The data that is system data will be identified by [SYSTEM] in the comments
 43893                                  ; describing that data item.
 43894                                  
 43895                                  ;DOSDATA SEGMENT WORD PUBLIC 'DATA'
 43896                                  
 43897                                  ;
 43898                                  ; Table of routines for assignable devices
 43899                                  ;
 43900                                  ; MSDOS allows assignment if the following standard devices:
 43901                                  ;   stdin  (usually CON input)
 43902                                  ;   stdout (usually CON output)
 43903                                  ;   auxin  (usually AUX input)
 43904                                  ;   auxout (usually AUX output)
 43905                                  ;   stdlpt (usually PRN output)
 43906                                  ;
 43907                                  ; SPECIAL NOTE:
 43908                                  ;   Status of a file is a strange idea. We choose to handle it in this manner:
 43909                                  ;   If we're not at end-of-file, then we always say that we have a character.
 43910                                  ;   Otherwise, we return ^Z as the character and set the ZERO flag. In this
 43911                                  ;   manner we can support program written under the old DOS (they use ^Z as EOF
 43912                                  ;   on devices) and programs written under the new DOS (they use the ZERO flag
 43913                                  ;   as EOF).
 43914                                  
 43915                                  ; Default SFTs for boot up
 43916                                  
 43917                                  		;PUBLIC	SFTABL
 43918                                  
 43919                                  SFTABL:	   ; LABEL   DWORD		; [SYSTEM] file table
 43920 000000CC FFFF                    		DW -1			; [SYSTEM] link to next table
 43921 000000CE FFFF                    		DW -1			; [SYSTEM] link seg to next table
 43922 000000D0 0500                    		DW sf_default_number	; [SYSTEM] Number of entries in table
 43923                                  		;times 295 db 0 ; MSDOS 6.0
 43924 000000D2 00<rep 127h>            		times (sf_default_number*sf_entry_size) db 0
 43925                                  
 43926                                  ; the next two variables relate to the position of the logical stdout/stdin
 43927                                  ; cursor. They are only meaningful when stdin/stdout are assigned to the
 43928                                  ; console.
 43929                                  		; DOSDATA:01F9h (MSDOS 6.21)
 43930 000001F9 00                      CARPOS:		db 0			; [SYSTEM] cursor position in stdin
 43931 000001FA 00                      STARTPOS:	db 0			; [SYSTEM] position of cursor at beginning
 43932                                  					;	   of buffered input call
 43933 000001FB 00<rep 80h>             INBUF:		times 128 db 0		; [SYSTEM] general device input buffer
 43934 0000027B 00<rep 83h>             CONBUF:		times 131 db 0		; [SYSTEM] The rest of INBUF and console buffer
 43935                                  		; DOSDATA:02FEh (MSDOS 6.21)
 43936 000002FE 00                      PFLAG:		db 0			; [SYSTEM] printer echoing flag
 43937 000002FF 00                      VERFLG:		db 0			; [SYSTEM] Initialize with verify off
 43938 00000300 03                      CHARCO:		db 00000011b		; [SYSTEM] Allows statchks every 4 chars...
 43939                                  switch_character:
 43940 00000301 2F                      chSwitch:	db '/'			; UNUSED - obsolete datum, can be reused
 43941 00000302 00                      AllocMethod:	db 0			; [SYSTEM] how to alloc first(best)last
 43942 00000303 00                      fShare:		db 0			; [SYSTEM] TRUE => sharing installed
 43943 00000304 01                      DIFFNAM:	db 1			; [SYSTEM] Indicates when MYNAME has changed
 43944 00000305 20<rep 10h>             MYNAME:		times 16 db 20h		; [SYSTEM] My network name
 43945                                  
 43946                                  ; The following table is a list of addresses that the sharer patches to be
 43947                                  ; PUSH AX to enable the critical sections
 43948                                  
 43949                                  		; DOSDATA:0315h (MSDOS 6.21)
 43950                                  
 43951                                  ;PUBLIC	CritPatch
 43952                                  
 43953                                  CritPatch:	; LABEL WORD
 43954                                  
 43955                                  ;IRP sect,<critDisk,critDevice>
 43956                                  
 43957                                  ;IF (NOT REDIRECTOR) AND (NOT SHAREF)
 43958                                  ;
 43959                                  ;SR; Change code patch address to a variable in data segment
 43960                                  ;
 43961                                  ;       dw OFFSET DOSDATA: redir_patch
 43962                                  ;       dw OFFSET DOSDATA: redir_patch
 43963                                  ;
 43964                                  ;;hkn	Short_Addr  E&sect
 43965                                  ;;hkn	Short_Addr  L&sect
 43966                                  ;
 43967                                  ;ELSE
 43968                                  ;	DW	0
 43969                                  ;	DW	0
 43970                                  ;ENDIF
 43971                                  ;ENDM
 43972                                  ;	DW	0
 43973                                  
 43974                                  	; 25/07/2019 - Retro DOS v4.0 (MSDOS 6.21)
 43975                                   
 43976 00000315 [0C0D]                  	dw 	redir_patch
 43977 00000317 [0C0D]                  	dw 	redir_patch			
 43978 00000319 [0C0D]                  	dw	redir_patch
 43979 0000031B [0C0D]                  	dw 	redir_patch
 43980                                  
 43981 0000031D 0000                    	dw	0
 43982                                  
 43983                                  ; WARNING!!! PRINT and PSPRINT *REQUIRE* ErrorMode to precede INDOS.
 43984                                  ; Also, IBM server 1.0 requires this also.
 43985                                  
 43986                                  	;EVEN			; Force swap area to start on word boundry
 43987 0000031F 90                      align 2
 43988                                  	;PUBLIC	SWAP_START
 43989                                  SWAP_START:	; LABEL BYTE
 43990 00000320 00                      ERRORMODE:	db 0		; Flag for INT 24 processing
 43991 00000321 00                      INDOS:		db 0		; DOS status for interrupt processing
 43992 00000322 FF                      WPERR:		db -1		; Write protect error flag
 43993 00000323 00                      EXTERR_LOCUS:	db 0		; Extended Error Locus
 43994 00000324 0000                    EXTERR:		dw 0		; Extended Error code
 43995                                  
 43996                                  ;WARNING Following two bytes Accessed as word in $GetExtendedError
 43997 00000326 00                      EXTERR_ACTION:	db 0		; Extended Error Action
 43998 00000327 00                      EXTERR_CLASS:	db 0		; Extended Error Class
 43999                                  ; end warning
 44000                                   
 44001 00000328 00000000                EXTERRPT:	dd 0		; Extended Error pointer
 44002                                  
 44003 0000032C 80000000                DMAADD:		dd 80h		; User's disk transfer address (disp/seg)
 44004 00000330 0000                    CurrentPDB:	dw 0		; Current process identifier
 44005 00000332 0000                    ConC_Spsave:	dw 0		; saved SP before ^C
 44006 00000334 0000                    exit_code:	dw 0		; exit code of last proc.
 44007 00000336 00                      CURDRV:		db 0		; Default drive (init A)
 44008 00000337 00                      CNTCFLAG:	db 0		; ^C check in dispatch disabled
 44009                                  ;				; F.C. 2/17/86
 44010 00000338 00                      CPSWFLAG:	db 0		; Code Page Switching Flag  DOS 4.00
 44011 00000339 00                      CPSWSAVE:	db 0		; copy of above in case of ABORT
 44012                                  ;align 2
 44013                                  SWAP_ALWAYS:	; 05/08/2018
 44014 0000033A 0000                    USER_IN_AX:	dw 0		; User INPUT AX value (used for
 44015                                  				;   extended error type stuff.
 44016                                  				;   NOTE: does not have Correct value on
 44017                                  				;   1-12, OEM, Get/Set CurrentPDB,
 44018                                  				;   GetExtendedError system calls)
 44019 0000033C 0000                    PROC_ID:	dw 0		; PID for sharing (0 = local)
 44020 0000033E 0000                    USER_ID:	dw 0		; Machine for sharing (0 = local)
 44021 00000340 0000                    FirstArena:	dw 0		; first free block found
 44022 00000342 0000                    BestArena:	dw 0		; best free block found
 44023 00000344 0000                    LastArena:	dw 0		; last free block found
 44024 00000346 0000                    ENDMEM:		dw 0		; End of memory used in DOSINIT
 44025 00000348 0000                    LASTENT:	dw 0		; Last entry for directory search
 44026 0000034A 00                      FAILERR:	db 0		; NZ if user did FAIL on I 24
 44027 0000034B 00                      ALLOWED:	db 0		; Allowed I 24 answers (see allowed_)
 44028 0000034C 00                      NoSetDir:	db 0		; true -> do not set directory
 44029 0000034D 00                      DidCTRLC:	db 0		; true -> we did a ^C exit
 44030 0000034E 00                      SpaceFlag:	db 0		; true -> embedded spaces are allowed in FC
 44031                                  
 44032                                  ; Warning!  The following items are accessed as a WORD in TIME.ASM
 44033                                  	;EVEN
 44034 0000034F 90                      align 2
 44035                                  		; DOSDATA:0350h (MSDOS 6.21)
 44036 00000350 00                      DAY:		db 0		; Day of month
 44037 00000351 00                      MONTH:		db 0		; Month of year
 44038 00000352 0000                    YEAR:		dw 0		; Year (with century)
 44039 00000354 FFFF                    DAYCNT:		dw -1		; Day count from beginning of year
 44040 00000356 00                      WEEKDAY:	db 0		; Day of week
 44041                                  ; end warning
 44042                                  
 44043 00000357 00                      CONSWAP:	db 0		; TRUE => console was swapped during device read
 44044 00000358 01                      IDLEINT:	db 1		; TRUE => idle int is allowed
 44045 00000359 00                      fAborting:	db 0		; TRUE => abort in progress
 44046                                  
 44047                                  ; Combination of all device call parameters
 44048                                  	;PUBLIC	DEVCALL 	;
 44049                                  ;DEVCALL SRHEAD	<>		; basic header for disk packet
 44050                                  DEVCALL: ; 08/08/2018
 44051 0000035A 00                      DEVCALL_REQLEN:  db 0 		;Length in bytes of request block
 44052 0000035B 00                      DEVCALL_REQUNIT: db 0		;Device unit number
 44053 0000035C 00                      DEVCALL_REQFUNC: db 0		;Type of request
 44054 0000035D 0000                    DEVCALL_REQSTAT: dw 0		;Status Word
 44055 0000035F 00<rep 8h>                       times 8 db 0		;Reserved for queue links
 44056                                  
 44057                                  	;PUBLIC	CALLUNIT
 44058                                  CALLUNIT: ; LABEL   BYTE	; unit number for disk
 44059                                  CALLFLSH: ; LABEL   WORD	;
 44060 00000367 00                      CALLMED:	db 0		; media byte
 44061                                  CALLBR:	  ; LABEL   DWORD	;
 44062                                  	;PUBLIC	CALLXAD 	;
 44063                                  CALLXAD:  ; LABEL   DWORD	;
 44064 00000368 00                      CALLRBYT:	db 0		;
 44065                                  	;PUBLIC	CALLVIDM	;
 44066                                  CALLVIDM: ; LABEL   DWORD	;
 44067 00000369 00<rep 3h>              	times 3 db 0	;
 44068                                  	;PUBLIC CallBPB		;
 44069                                  CALLBPB:  ; LABEL   DWORD	;
 44070                                  CALLSCNT:			;
 44071 0000036C 0000                    		dw 0		;
 44072                                  	;PUBLIC	CALLSSEC	;
 44073                                  CALLSSEC: ; LABEL   WORD	;
 44074 0000036E 0000                    		dw 0		;
 44075 00000370 00000000                CALLVIDRW:	dd 0		;
 44076                                  ;MSDOS 6.0
 44077 00000374 00000000                CALLNEWSC:	dd 0		; starting sector for >32mb
 44078 00000378 00000000                CALLDEVAD:	dd 0		; stash for device entry point
 44079                                  
 44080                                  ; Same as above for I/O calls	;
 44081                                  				;
 44082                                  	;PUBLIC	IOCall		;
 44083                                  ;IOCALL	SRHEAD	<>		;
 44084                                  IOCALL:	; 07/08/2018
 44085 0000037C 00                      IOCALL_REQLEN:	db 0		;Length in bytes of request block	
 44086 0000037D 00                      IOCALL_REQUNIT:	db 0		;Device unit number
 44087 0000037E 00                      IOCALL_REQFUNC: db 0		;Type of request
 44088 0000037F 0000                    IOCALL_REQSTAT: dw 0		;Status Word
 44089 00000381 00<rep 8h>              	times 8	db 0		;Reserved for queue links
 44090                                  IOFLSH:	  ; LABEL   WORD	;
 44091                                          ;PUBLIC  IORCHR		;
 44092                                  IORCHR:	  ; LABEL   BYTE	;
 44093 00000389 00                      IOMED:		db 0		;
 44094 0000038A 00000000                IOXAD:		dd 0		;
 44095 0000038E 0000                    IOSCNT:		dw 0		;	
 44096 00000390 0000                    IOSSEC:		dw 0		;
 44097                                  
 44098                                  ; Call struct for DSKSTATCHK	;
 44099 00000392 0E                      DSKSTCALL:	db DRDNDHL 	; = 14
 44100 00000393 00                      		db 0
 44101 00000394 05                      DSKSTCOM:	db DEVRDND	; = 5
 44102 00000395 0000                    DSKSTST:	dw 0		;
 44103 00000397 00<rep 8h>              	times 8	db 0		;
 44104 0000039F 00                      DSKCHRET:	db 0		;
 44105                                  
 44106                                  ;hkn; short_addr has been changed to provide offset in DOSCODE.
 44107                                  ;hkn; deviobuf is in DATA seg (DOSDATA)
 44108                                  ;hkn   short_addr  DEVIOBUF	;
 44109                                  	
 44110 000003A0 [BC03]                  DEVIOBUF_PTR	dw DEVIOBUF
 44111 000003A2 0000                    DOSSEG_INIT	dw 0		; DOS segment set at Init
 44112 000003A4 0100                    DSKSTCNT:	dw 1		;
 44113 000003A6 0000                    		dw 0		;
 44114                                  
 44115 000003A8 00                      CreatePDB:	db 0		; flag for creating a process
 44116                                  
 44117                                  ;MSDOS 6.0
 44118                                  Lock_Buffer:	; LABEL  DWORD	;MS. DOS Lock Buffer for Ext Lock
 44119 000003A9 00000000                		dd 0		;MS. position
 44120 000003AD 00000000                		dd 0		;MS. length
 44121                                  
 44122                                  ;hkn; the foll. was moved from dosmes.asm.
 44123                                  
 44124                                  	;EVEN
 44125 000003B1 90                      align 2				; needed to maintain offsets
 44126                                  
 44127                                  		; DOSDATA:03B2h (MSDOS 6.21)
 44128                                  USERNUM:
 44129 000003B2 0000                     		dw 0		; 24 bit user number
 44130 000003B4 00                      		db 0
 44131                                  ;IF IBM
 44132                                  ;IF IBMCOPYRIGHT
 44133                                  ;OEMNUM:	DB 0		; 8 bit OEM number
 44134                                  ;ELSE
 44135                                  ;OEMNUM:	DB 0FFh		; 8 bit OEM number
 44136                                  ;ENDIF
 44137                                  ;ELSE
 44138 000003B5 FF                      OEMNUM:		DB 0FFh
 44139                                  ;ENDIF
 44140                                  
 44141                                  ;============================================================================
 44142                                  ; MS_DATA.ASM (MSDOS 6.0, 1991)
 44143                                  ;============================================================================
 44144                                  ; 25/04/2019 - Retro DOS 4.0
 44145                                  
 44146                                  ; Retro DOS v4.0 NOTE: (by Erdogan Tan, 25/04/2019)
 44147                                  ; ----------------------------------------------------------
 44148                                  ; This data section which was named as uninitialized data
 44149                                  ; (as overlayed by initialization code) but follows 
 44150                                  ; initialized data section from DOSDATA:03B6h address
 44151                                  ; (in otherwords, the method is different than MSDOS 3.3,
 44152                                  ; and there is not overlaying..)
 44153                                  ; **********************************************************
 44154                                  ; Reference: MSDOS 6.21 kernel DOSDATA section (4970 bytes)
 44155                                  ; follows DOSCODE section in the kernel file (MSDOS.SYS) 
 44156                                  ; (it is located at offset 0BF70h, file offset 0BF70h-3DE0h) 
 44157                                  ; but starts from offset 0 (ORG 0) and ends at offset 1370h.
 44158                                  ; TIMEBUF is at offset 03B6h.
 44159                                  ; **********************************************************	
 44160                                  
 44161                                  ;Break <Uninitialized data overlayed by initialization code>
 44162                                  ;----------------------------------------------------------------------------
 44163                                  ;DOSDATA    SEGMENT WORD PUBLIC 'DATA'
 44164                                  ; Init code overlaps with data area below
 44165                                  
 44166                                  ; 	ORG     0
 44167                                  
 44168                                  MSDAT001S:	; label byte
 44169                                  
 44170                                  ; DOSDATA:03B6h	; MSDOS 6.21 (MSDOS.SYS, file offset 0BF70h-3DE0h+3B6h)
 44171                                  TIMEBUF: ;	times 6 db 0
 44172 000003B6 0000<rep 3h>            	times 3 dw	0		; Time read from clock device
 44173 000003BC 0000                    DEVIOBUF:	dw	0		; Buffer for I/O under file assignment
 44174                                  
 44175                                  ; The following areas are used as temp buffer in EXEC system call
 44176                                  
 44177                                  ; DOSDATA:03BEh
 44178                                  OPENBUF: ;times 64  dw	0
 44179 000003BE 00<rep 80h>             	times	128 db	0		; buffer for name operations
 44180                                  RENBUF:	
 44181 0000043E 00<rep 80h>             	times	128 db	0		; buffer for rename destination
 44182                                  
 44183                                  ; Buffer for search calls
 44184                                  SEARCHBUF:	
 44185 000004BE 00<rep 35h>             	times	53  db	0		; internal search buffer
 44186                                  DUMMYCDS:  ;times 88 db 0
 44187 000004F3 00<rep 58h>             	times	curdirLen db 0
 44188                                  
 44189                                  ; End of contiguous buffer
 44190                                   
 44191                                  ; Temporary directory entry for use by many routines. Device directory
 44192                                  ; entries (bogus) are built here.
 44193                                  
 44194                                  ; DOSDATA:054Bh
 44195                                  
 44196                                  DEVFCB:	; LABEL   BYTE			; Uses NAME1, NAME2, combined
 44197                                  
 44198                                  ; WARNING..  do not alter position of NAME1 relative to DEVFCB
 44199                                  ; without first examining BUILD_DEVICE_ENT. Look carefully at DOS_RENAME
 44200                                  ; as well as it is the only guy who uses NAME2 and DESTSTART.
 44201                                  
 44202                                  NAME1:	
 44203 0000054B 00<rep Ch>                      times 	12 db	0		; File name buffer
 44204                                  NAME2:
 44205 00000557 00<rep Dh>              	times	13 db	0 		;
 44206                                  DESTSTART:
 44207 00000564 0000                    	dw	0			;
 44208                                          ;DB      ((SIZE DIR_ENTRY) - ($ - DEVFCB)) DUP (?)
 44209                                  	;times	5  db	0
 44210 00000566 00<rep 5h>              	times	((dir_entry.size)-($-DEVFCB)) db 0
 44211                                  
 44212                                  ; End Temporary directory entry.
 44213                                  
 44214 0000056B 00                      ATTRIB:	db	0		; storage for file attributes
 44215                                  EXTFCB:	
 44216 0000056C 00                      	db	0		; TRUE => extended FCB in use
 44217                                  SATTRIB:
 44218 0000056D 00                      	db	0		; Storage for search attributes
 44219                                  OPEN_ACCESS:
 44220 0000056E 00                      	db	0		; access of open system call
 44221                                  FOUNDDEL:
 44222 0000056F 00                      	db	0		; true => file was deleted
 44223                                  FOUND_DEV:
 44224 00000570 00                      	db	0		; true => search found a device
 44225                                  FSPLICE:
 44226 00000571 00                      	db	0		; true => do a splice in transpath
 44227                                  FSHARING:
 44228 00000572 00                      	db	0		; TRUE => no redirection
 44229                                  SECCLUSPOS:
 44230 00000573 00                      	db	0		; Position of first sector within cluster
 44231 00000574 00                      TRANS:	db	0		;
 44232 00000575 00                      READOP:	db	0		;
 44233                                  THISDRV:
 44234 00000576 00                      	db	0		;
 44235                                  CLUSFAC:
 44236 00000577 00                      	db	0		;
 44237                                  CLUSSPLIT:
 44238 00000578 00                      	db	0		;
 44239                                  INSMODE:
 44240 00000579 00                      	db	0		; true => insert mode in buffered read
 44241 0000057A 00                      CMETA:	db	0		; count of meta'ed components found
 44242 0000057B 00                      VOLID:	db	0		;
 44243                                  EXIT_TYPE:
 44244 0000057C 00                      	db	0		; type of exit...
 44245                                   
 44246                                  	;EVEN
 44247                                  
 44248 0000057D 90                      align 2
 44249                                  
 44250                                  ; DOSDATA:057Eh
 44251                                  
 44252                                  ; WARNING - the following two items are accessed as a word
 44253                                  
 44254                                  CREATING:
 44255 0000057E 00                      	db	0		; true => creating a file
 44256 0000057F 00                      DELALL:	db	0		; = 0 iff BUGBUG
 44257                                  				; = DIRFREE iff BUGBUG
 44258                                  EXITHOLD:
 44259 00000580 00000000                	dd	0		; Temp location for proc terminate
 44260                                  USER_SP:
 44261 00000584 0000                    	dw	0		; User SP for system call
 44262                                  USER_SS:
 44263 00000586 0000                    	dw	0		; User SS for system call
 44264                                  CONTSTK:
 44265 00000588 0000                    	dw	0		;
 44266                                  THISDPB:
 44267 0000058A 00000000                	dd	0		;
 44268                                  CLUSSAVE:
 44269 0000058E 0000                    	dw	0		;
 44270                                  CLUSSEC:
 44271 00000590 00000000                	dd	0		;>32mb			AC0000
 44272                                  PREREAD:
 44273 00000594 0000                    	dw	0		; 0 means preread; 1 means optional
 44274 00000596 0000                    FATBYT:	dw	0		; Used by ALLOCATE
 44275                                  FATBYTE:
 44276 00000598 0000                    	dw	0		; Used by $SLEAZEFUNC
 44277                                  ; DOSDATA:059Ah
 44278 0000059A 00000000                DEVPT:	dd	0		;
 44279                                  THISSFT:
 44280 0000059E 00000000                	dd	0		; Address of user SFT
 44281                                  THISCDS:
 44282 000005A2 00000000                	dd	0		; Address of current CDS
 44283                                  THISFCB:
 44284 000005A6 00000000                	dd	0		; Address of user FCB
 44285 000005AA FFFF                    SFN:	dw	-1		; SystemFileNumber found for accessfile
 44286 000005AC 0000                    JFN:	dw	0		; JobFileNumber found for accessfile
 44287 000005AE 00000000                PJFN:	dd	0		; PointerJobFileNumber found for accessfile
 44288                                  WFP_START:
 44289 000005B2 0000                    	dw	0		;
 44290                                  REN_WFP:
 44291 000005B4 0000                    	dw	0		;
 44292                                  CURR_DIR_END:
 44293 000005B6 0000                    	dw	0		;
 44294                                  NEXTADD:
 44295 000005B8 0000                    	dw	0		;
 44296                                  LASTPOS:
 44297 000005BA 0000                    	dw	0		;
 44298                                  CLUSNUM:
 44299 000005BC 0000                    	dw	0		;
 44300 000005BE 00000000                DIRSEC:	dd	0		;>32mb			AC0000
 44301                                  DIRSTART:
 44302 000005C2 0000                    	dw	0		;
 44303 000005C4 00000000                SECPOS:	dd	0		;>32mb Position of first sector accessed
 44304 000005C8 00000000                VALSEC:	dd	0		;>32mb Number of valid (previously written)
 44305                                                                  ; sectors
 44306                                  BYTSECPOS:
 44307 000005CC 0000                    	dw	0		; Position of first byte within sector
 44308                                  BYTPOS: ;times	4 db 0		; Byte position in file of access
 44309 000005CE 0000<rep 2h>                    times	2 dw 0
 44310                                  BYTCNT1:
 44311 000005D2 0000                    	dw	0		; No. of bytes in first sector
 44312                                  BYTCNT2:
 44313 000005D4 0000                    	dw	0		; No. of bytes in last sector
 44314 000005D6 0000                    SECCNT:	dw	0		; No. of whole sectors
 44315                                  ; DOSDATA:05D8h
 44316                                  ENTFREE:
 44317 000005D8 0000                    	dw	0		;
 44318                                  ENTLAST:
 44319 000005DA 0000                    	dw	0		;
 44320                                  NXTCLUSNUM:
 44321 000005DC 0000                    	dw	0		;
 44322                                  GROWCNT:
 44323 000005DE 00000000                	dd	0		;
 44324 000005E2 00000000                CURBUF:	dd	0		;
 44325 000005E6 00000000                CONSFT:	dd	0		; SFT of console swapped guy.
 44326 000005EA 0000                    SAVEBX:	dw	0		;
 44327 000005EC 0000                    SAVEDS:	dw	0		;
 44328                                  RESTORE_TMP:
 44329 000005EE 0000                    	dw	0		; return address for restore world
 44330 000005F0 0000                    NSS:	dw	0
 44331 000005F2 0000                    NSP:	dw	0
 44332                                  ; DOSDATA:05F4h
 44333                                  EXTOPEN_FLAG:
 44334 000005F4 0000                    	dw	0		;FT. extended open input flag	;AN000;
 44335                                  EXTOPEN_ON:
 44336 000005F6 00                      	db	0		;FT. extended open conditional flag ;AN000;
 44337                                  EXTOPEN_IO_MODE:
 44338 000005F7 0000                    	dw	0		;FT. extended open io mode	;AN000;
 44339                                  SAVE_DI:
 44340 000005F9 0000                    	dw	0		;FT. extended open saved DI	;AN000;
 44341                                  SAVE_ES:
 44342 000005FB 0000                    	dw	0		;FT. extended open saved ES	;AN000;
 44343                                  SAVE_DX:
 44344 000005FD 0000                    	dw	0		;FT. extended open saved DX	;AN000;
 44345                                  SAVE_CX:
 44346 000005FF 0000                    	dw	0		;FT. extended open saved CX	;AN000;
 44347                                  SAVE_BX:
 44348 00000601 0000                    	dw	0		;FT. extended open saved BX	;AN000;
 44349                                  SAVE_SI:
 44350 00000603 0000                    	dw	0		;FT. extended open saved SI	;AN000;
 44351                                  SAVE_DS:
 44352 00000605 0000                    	dw	0		;FT. extended open saved DS	;AN000;
 44353                                  
 44354                                  ; DOSDATA:0607h
 44355                                  
 44356                                  ; HIGH_SECTOR is a hack to allow passing 32-bit sector numbers where
 44357                                  ; we used to just pass 16 bits in a register. Now High_SECTOR holds
 44358                                  ; the high 16, the low 16 are still in the register.
 44359                                  
 44360                                  HIGH_SECTOR:	
 44361 00000607 0000                    	dw	0		;>32mb higher sector #		;AN000;
 44362                                  	; 25/09/2023
 44363                                  OffsetMagicPatch:
 44364                                  	;dw	MagicPatch	;scottq 8/6/92
 44365                                  	; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 44366 00000609 0000                    	dw	0
 44367                                  				;see dos\mpatch.asm
 44368                                  DISK_FULL:
 44369 0000060B 00                      	db	0		;>32mb indicating disk full when 1 ;AN000;
 44370                                  TEMP_VAR:
 44371 0000060C 0000                    	dw	0		; temporary variable for everyone ;AN000;
 44372                                  TEMP_VAR2:
 44373 0000060E 0000                    	dw	0		; temporary variable 2 for everyone ;AN000;
 44374 00000610 00                      DrvErr:	db	0		; used to save drive error	;AN000;
 44375                                  DOS34_FLAG:
 44376 00000611 0000                    	dw	0		; common flag for DOS 3.4	;AN000;
 44377                                  NO_FILTER_PATH:
 44378 00000613 00000000                	dd	0		; pointer to original path	;AN000;
 44379                                  NO_FILTER_DPATH:
 44380 00000617 00000000                	dd	0		; pointer to original path of destination ;AN000;
 44381                                  ; M008
 44382                                  AbsRdWr_SS:
 44383 0000061B 0000                    	dw	0		; INT 25/26 user stack segment
 44384                                  AbsRdWr_SP:
 44385 0000061D 0000                    	dw	0		; INT 25/26 user stack offset
 44386                                  
 44387                                  	; I_am   UU_Callback_flag,BYTE,<0>  ; Unused
 44388                                  ; M008
 44389                                   
 44390                                   
 44391                                  ; make those pushes fast!!!
 44392                                  
 44393                                  ;EVEN
 44394                                  
 44395 0000061F 90                      align 2
 44396                                  
 44397                                  StackSize   equ 180h  ; 384	; gross but effective
 44398                                  
 44399                                  ;StackSize  equ 300h  ;	768	; This is a "trial" change IBM hasn't
 44400                                  ;				; made up their minds about
 44401                                   
 44402                                  ; WARNING!!!! DskStack may grow into AUXSTACK due to interrupt service.
 44403                                  ; This is NO problem as long as AUXSTACK comes immediately before DSKSTACK
 44404                                  
 44405                                  RENAMEDMA:	; LABEL   BYTE	; See DOS_RENAME
 44406                                   
 44407 00000620 00<rep 180h>                    times	StackSize db	0	;
 44408                                  AUXSTACK:			; LABEL   BYTE
 44409                                   
 44410 000007A0 00<rep 180h>                    times	StackSize db 	0	;
 44411                                  DSKSTACK:			; LABEL   BYTE
 44412                                   
 44413 00000920 00<rep 180h>                    times	StackSize db	0	;
 44414                                  IOSTACK:			; LABEL   BYTE
 44415                                  
 44416                                  ; DOSDATA:0AA0h 
 44417                                   
 44418                                  ; patch space for Boca folks.
 44419                                  ; Say What????!!! This does NOT go into the swappable area!
 44420                                  ; NOTE: We include the decl of ibmpatch in ms-dos even though it is not needed.
 44421                                  ;       This allows the REDIRector to work on either IBM or MS-DOS.
 44422                                   
 44423                                  IBMPATCH: ; label byte
 44424                                  PRINTER_FLAG:
 44425 00000AA0 00                      	db	0		; [SYSTEM] status of PRINT utility
 44426                                  VOLCHNG_FLAG:
 44427 00000AA1 00                      	db	0		; [SYSTEM] true if volume label created
 44428                                  VIRTUAL_OPEN:
 44429 00000AA2 00                      	db	0		; [SYSTEM] non-zero if we opened a virtual file
 44430                                   
 44431                                  ; Following 4 variables moved to MSDATA.asm from MSTABLE.asm (P4986)
 44432                                  
 44433                                  FSeek_drive:
 44434 00000AA3 00                      	db	0		;AN000; fastseek drive #
 44435                                  FSeek_firclus:
 44436 00000AA4 0000                    	dw	0		;AN000; fastseek first cluster #
 44437                                  FSeek_logclus:
 44438 00000AA6 0000                    	dw	0		;AN000; fastseek logical cluster #
 44439                                  FSeek_logsave:
 44440 00000AA8 0000                    	dw	0		;AN000; fastseek returned log clus #
 44441                                  
 44442                                  ; DOSDATA:0AAAh
 44443                                  
 44444                                  TEMP_DOSLOC:
 44445 00000AAA FFFF                    	dw	-1		;stores the temporary location of dos
 44446                                  				;at SYSINIT time.
 44447                                  SWAP_END:  ; LABEL   BYTE
 44448                                   
 44449                                  ; THE FOLLOWING BYTE MUST BE HERE, IMMEDIATELY FOLLOWING SWAP_END. IT CANNOT
 44450                                  ; BE USED. If the size of the swap data area is ODD, it will be rounded up
 44451                                  ; to include this byte.
 44452                                   
 44453 00000AAC 00                      	db	0
 44454                                  
 44455                                  ; DOSDATA:0AADh
 44456                                   
 44457                                  ;hkn;	DB	(512+80+32-(SWAP_END-ibmpatch)) DUP (?)
 44458                                  
 44459                                  ;DOSDATA    ENDS
 44460                                  
 44461                                  ;============================================================================
 44462                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
 44463                                  ;============================================================================
 44464                                  ; 27/04/2019 - Retro DOS 4.0
 44465                                  ; 16/07/2018 - Retro DOS 3.0
 44466                                  
 44467                                  ;DOSDATA Segment
 44468                                  
 44469                                  ; DOSDATA:0AADh (MSDOS 6.21, MSDOS.SYS)
 44470                                  
 44471                                  ;
 44472                                  ; upper case table
 44473                                  ; ---------------------------------------------------------------------------
 44474                                  UCASE_TAB:	; label   byte
 44475 00000AAD 8000                    	dw	128
 44476 00000AAF 809A45418E418F80        	db	128,154,069,065,142,065,143,128 
 44477 00000AB7 4545454949498E8F        	db	069,069,069,073,073,073,142,143
 44478 00000ABF 9092924F994F5555        	db	144,146,146,079,153,079,085,085
 44479 00000AC7 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
 44480 00000ACF 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
 44481 00000AD7 A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
 44482 00000ADF B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 44483 00000AE7 B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 44484 00000AEF C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 44485 00000AF7 C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 44486 00000AFF D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 44487 00000B07 D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 44488 00000B0F E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
 44489 00000B17 E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 44490 00000B1F F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 44491 00000B27 F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 44492                                  ;
 44493                                  ; file upper case table
 44494                                  ; ---------------------------------------------------------------------------
 44495                                  FILE_UCASE_TAB:	; label  byte
 44496 00000B2F 8000                    	dw	128
 44497 00000B31 809A45418E418F80        	db	128,154,069,065,142,065,143,128
 44498 00000B39 4545454949498E8F        	db	069,069,069,073,073,073,142,143
 44499 00000B41 9092924F994F5555        	db	144,146,146,079,153,079,085,085
 44500 00000B49 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
 44501 00000B51 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
 44502 00000B59 A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
 44503 00000B61 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 44504 00000B69 B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 44505 00000B71 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 44506 00000B79 C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 44507 00000B81 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 44508 00000B89 D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 44509 00000B91 E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
 44510 00000B99 E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 44511 00000BA1 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 44512 00000BA9 F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 44513                                  ;
 44514                                  ; file char list
 44515                                  ; ---------------------------------------------------------------------------
 44516                                  FILE_CHAR_TAB:	; label  byte
 44517 00000BB1 1600                    	dw	22				; length
 44518 00000BB3 0100FF                  	db	1,0,255 			; include all
 44519 00000BB6 000020                  	db	0,0,20h 			; exclude 0 - 20h
 44520 00000BB9 020E2E222F5C5B5D3A-     	db	2,14,'."/\[]:|<>+=;,'           ; exclude 14 special
 44520 00000BC2 7C3C3E2B3D3B2C     
 44521                                  	;db	24 dup (?)			; reserved
 44522 00000BC9 00<rep 18h>             	times	24 db 0
 44523                                  
 44524                                  ;
 44525                                  ; collate table
 44526                                  ; ---------------------------------------------------------------------------
 44527                                  COLLATE_TAB:	; label   byte
 44528 00000BE1 0001                    	dw	256
 44529 00000BE3 0001020304050607        	db	0,1,2,3,4,5,6,7
 44530 00000BEB 08090A0B0C0D0E0F        	db	8,9,10,11,12,13,14,15
 44531 00000BF3 1011121314151617        	db	16,17,18,19,20,21,22,23
 44532 00000BFB 18191A1B1C1D1E1F        	db	24,25,26,27,28,29,30,31
 44533 00000C03 2021222324252627        	db	" ","!",'"',"#","$","%","&","'"
 44534 00000C0B 28292A2B2C2D2E2F        	db	"(",")","*","+",",","-",".","/"
 44535 00000C13 3031323334353637        	db	"0","1","2","3","4","5","6","7"
 44536 00000C1B 38393A3B3C3D3E3F        	db	"8","9",":",";","<","=",">","?"
 44537 00000C23 4041424344454647        	db	"@","A","B","C","D","E","F","G"
 44538 00000C2B 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
 44539 00000C33 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
 44540 00000C3B 58595A5B5C5D5E5F        	db	"X","Y","Z","[","\","]","^","_"
 44541 00000C43 6041424344454647        	db	"`","A","B","C","D","E","F","G"
 44542 00000C4B 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
 44543 00000C53 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
 44544 00000C5B 58595A7B7C7D7E7F        	db	"X","Y","Z","{","|","}","~",127
 44545 00000C63 4355454141414143        	db	"C","U","E","A","A","A","A","C"
 44546 00000C6B 4545454949494141        	db	"E","E","E","I","I","I","A","A"
 44547 00000C73 4541414F4F4F5555        	db	"E","A","A","O","O","O","U","U"
 44548 00000C7B 594F552424242424        	db	"Y","O","U","$","$","$","$","$"
 44549 00000C83 41494F554E4EA6A7        	db	"A","I","O","U","N","N",166,167
 44550 00000C8B 3FA9AAABAC212222        	db	"?",169,170,171,172,"!",'"','"'
 44551 00000C93 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 44552 00000C9B B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 44553 00000CA3 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 44554 00000CAB C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 44555 00000CB3 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 44556 00000CBB D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 44557 00000CC3 E053                    	db	224,"S"
 44558 00000CC5 E2E3E4E5E6E7            	db	226,227,228,229,230,231
 44559 00000CCB E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 44560 00000CD3 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 44561 00000CDB F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 44562                                  
 44563                                  ; ------------------------------------------------<MSKK01>----------------------
 44564                                  
 44565                                  ; DOSDATA:0CE3h
 44566                                  
 44567                                  ; 29/04/2019
 44568                                  
 44569                                  ; dbcs is not supported in DOS 3.3
 44570                                  ;		   DBCS_TAB	    CC_DBCS <>
 44571                                  ;
 44572                                  ; DBCS for DOS 4.00			   2/12/KK
 44573                                  
 44574                                  DBCS_TAB:	; label byte		;AN000;  2/12/KK
 44575                                  ; ------------------------------------------------<MSKK01>----------------------
 44576                                  ;ifdef	DBCS
 44577                                  ; ifdef	  JAPAN
 44578                                  ;		dw	6		; <MSKK01>
 44579                                  ;		db	081h,09fh	; <MSKK01>
 44580                                  ;		db	0e0h,0fch	; <MSKK01>
 44581                                  ;		db	0,0		; <MSKK01>
 44582                                  ;
 44583                                  ;		db	0,0,0,0,0,0,0,0,0,0	; <MSKK01>
 44584                                  ; endif
 44585                                  ; ifdef	  TAIWAN
 44586                                  ;		dw	4		; <TAIWAN>
 44587                                  ;		db	081h,0FEh	; <TAIWAN>
 44588                                  ;		db	0,0		; <TAIWAN>
 44589                                  ;
 44590                                  ;		db	0,0,0,0,0,0,0,0,0,0,0,0
 44591                                  ; endif
 44592                                  ; ifdef   KOREA                         ; Keyl
 44593                                  ;               dw      4               ; <KOREA>
 44594                                  ;               db      0A1h,0FEh       ; <KOREA>
 44595                                  ;               db      0,0             ; <KOREA>
 44596                                  ;
 44597                                  ;		db	0,0,0,0,0,0,0,0,0,0,0,0
 44598                                  ;  endif
 44599                                  ;else
 44600 00000CE3 0000                    		dw	0		;AN000;  2/12/KK      max number
 44601                                  		;db	16 dup(0)	;AN000;  2/12/KK
 44602 00000CE5 00<rep 10h>             		times	16 db 0
 44603                                  
 44604                                  ;		dw	6		;  2/12/KK
 44605                                  ;		db	081h,09Fh	;  2/12/KK
 44606                                  ;		db	0E0h,0FCh	;  2/12/KK
 44607                                  ;		db	0,0		;  2/12/KK
 44608                                  ;
 44609                                  ;endif
 44610                                  ; ------------------------------------------------<MSKK01>----------------------
 44611                                  
 44612                                  ; DOSDATA:0CF5h
 44613                                  
 44614                                  ; ---------------------------------------------------------------------------
 44615                                  ;
 44616                                  ;CASE MAPPER ROUTINE FOR 80H-FFH character range, DOS 3.3
 44617                                  ;     ENTRY: AL = Character to map
 44618                                  ;     EXIT:  AL = The converted character
 44619                                  ; Alters no registers except AL and flags.
 44620                                  ; The routine should do nothing to chars below 80H.
 44621                                  ; ---------------------------------------------------------------------------
 44622                                  ; Example:
 44623                                  
 44624                                  MAP_CASE:
 44625                                  ;Procedure MAP_CASE,FAR
 44626                                  
 44627 00000CF5 3C80                    	CMP	AL,80h
 44628 00000CF7 7301                    	JAE	short Map1	;Map no chars below 80H ever
 44629 00000CF9 CB                      	RETF
 44630                                  Map1:
 44631 00000CFA 2C80                    	SUB	AL,80h		;Turn into index value
 44632 00000CFC 1E                      	PUSH	DS
 44633 00000CFD 53                      	PUSH	BX
 44634 00000CFE BB[AF0A]                	MOV	BX,UCASE_TAB+2
 44635                                  FINISH:
 44636 00000D01 0E                      	PUSH	CS		;Move to DS
 44637 00000D02 1F                      	POP	DS
 44638 00000D03 D7                      	XLAT			;Get upper case character
 44639 00000D04 5B                      	POP	BX
 44640 00000D05 1F                      	POP	DS
 44641                                  L_RET:	
 44642 00000D06 CB                      	RETF
 44643                                  
 44644                                  ;EndProc MAP_CASE
 44645                                  
 44646                                  ; ---------------------------------------------------------------------------
 44647                                  
 44648                                  ; The variables for ECS version are moved here for the same data alignments
 44649                                  ; as IBM-DOS and MS-DOS.
 44650                                  
 44651                                  InterChar:
 44652 00000D07 00                      	db	0	; Interim character flag ( 1= interim)  ;AN000;
 44653                                  ;------- NOTE: NEXT TWO BYTES SOMETIMES USED AS A WORD !! -------------------
 44654                                  DUMMY:	; LABEL   WORD
 44655                                  InterCon:  
 44656 00000D08 00                      	db	0	; Console in Interim mode ( 1= interim) ;AN000;
 44657                                  SaveCurFlg:
 44658 00000D09 00                      	db	0	; Print, do not advance cursor flag     ;AN000;
 44659                                  
 44660                                  ; ---------------------------------------------------------------------------
 44661                                  
 44662 00000D0A 0000                    TEMPSEG:  dw	0	;hkn; used to store ds.
 44663                                  redir_patch:
 44664 00000D0C 00                      	  db	0
 44665                                  
 44666                                  ; DOSDATA:0D0Dh
 44667                                  
 44668                                  Mark1:	; label byte
 44669                                  
 44670                                  ;IF2
 44671                                  ;	IF ((OFFSET MARK1) GT (OFFSET MSVERSION) )
 44672                                  ;		%OUT !DATA CORRUPTION!MARK1 OFFSET TOO BIG. RE-ORGANIZE DATA.
 44673                                  ;	ENDIF
 44674                                  ;ENDIF
 44675                                  
 44676 00000D0D 00<rep 5h>              	  times 5 db 0
 44677                                  
 44678                                  ;############################################################################
 44679                                  ;
 44680                                  ; ** HACK FOR DOS 4.0 REDIR **
 44681                                  ; 
 44682                                  ; The redir requires the following:
 44683                                  ;
 44684                                  ;	MSVERS	offset D12H
 44685                                  ;	YRTAB	offset D14H
 44686                                  ; 	MONTAB	offset D1CH
 44687                                  ;
 44688                                  ; WARNING! WARNING!
 44689                                  ; 
 44690                                  ; MARK1 SHOULD NOT BE >= 0D12H. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
 44691                                  ; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
 44692                                  ;
 44693                                  ; CURRENTLY MARK1 = 0D0DH
 44694                                  ;
 44695                                  ;############################################################################
 44696                                  
 44697                                  	;ORG	0D12h
 44698                                  
 44699                                  ; DOSDATA:0D12h (MSDOS 6.21, MSDOS.SYS)
 44700                                  
 44701                                  	;db	6
 44702                                  	;db	20
 44703                                  
 44704                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
 44705                                  MSVERSION:				; MS-DOS version in hex for $GET_VERSION
 44706 00000D12 06                      MSMAJORV: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
 44707 00000D13 16                      MSMINORV: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
 44708                                  
 44709                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
 44710                                  ;
 44711                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
 44712                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 
 44713                                  
 44714                                  ; Days in year
 44715                                  
 44716                                  YRTAB:   
 44717 00000D14 C8A6                    	DB	200,166			; Leap year
 44718 00000D16 C8A5                    	DB	200,165
 44719 00000D18 C8A5                    	DB	200,165
 44720 00000D1A C8A5                    	DB	200,165
 44721                                  
 44722                                  ; Days of each month
 44723                                  
 44724                                  MONTAB:        
 44725 00000D1C 1F                      	DB      31                      ; January
 44726                                  february:
 44727 00000D1D 1C                      	DB	28 			; February--reset each 
 44728                                  					; time year changes
 44729 00000D1E 1F                              DB      31                      ; March
 44730 00000D1F 1E                              DB      30                      ; April
 44731 00000D20 1F                              DB      31                      ; May
 44732 00000D21 1E                              DB      30                      ; June
 44733 00000D22 1F                              DB      31                      ; July
 44734 00000D23 1F                              DB      31                      ; August
 44735 00000D24 1E                              DB      30                      ; September
 44736 00000D25 1F                              DB      31                      ; October
 44737 00000D26 1E                              DB      30                      ; November
 44738 00000D27 1F                              DB      31                      ; December
 44739                                  
 44740                                  ;----------------THE FOLL. BLOCK MOVED FROM TABLE SEG IN MS_TABLE.ASM-------
 44741                                  
 44742                                  ; SYS init extended table,   DOS 3.3   F.C. 5/29/86
 44743                                  
 44744                                  SysInitTable:
 44745                                  	;dw	SYSINITVAR
 44746 00000D28 [2600]                  	dw	SYSINITVARS	; pointer to sysinit var
 44747 00000D2A 0000                            dw      0		; segment
 44748 00000D2C [0012]                          dw	COUNTRY_CDPG	; pointer to country tabl
 44749 00000D2E 0000                            dw      0		; segment of pointer
 44750                                  
 44751                                  ; DOS 3.3 F.C. 6/12/86
 44752                                  ; FASTOPEN communications area DOS 3.3   F.C. 5/29/86
 44753                                  
 44754                                  FastTable:				; a better name
 44755                                  FastOpenTable:
 44756 00000D30 0200                    	dw      2                       ; number of entries
 44757 00000D32 [A812]                  	dw      FastRet			; pointer to ret instr.
 44758 00000D34 0000                    	dw      0                       ; and will be modified by
 44759 00000D36 [A812]                  	dw      FastRet			; FASTxxx when loaded in
 44760 00000D38 0000                    	dw      0                       
 44761                                  
 44762                                  ; DOS 3.3 F.C. 6/12/86
 44763                                  
 44764                                  FastFlg:				; flags
 44765                                  FastOpenFlg:
 44766 00000D3A 00                      	db	0			; don't change the foll: order  
 44767                                  
 44768                                  ; FastOpen_Ext_Info is used as a temporary storage for saving dirpos,dirsec
 44769                                  ; and clusnum which are filled by DOS 3.nc when calling FastOpen Insert
 44770                                  ; or filled by FastOPen when calling FastOpen Lookup
 44771                                  
 44772                                  FastOpen_Ext_Info: ; label  byte	;dirpos
 44773                                  	;db	SIZE FASTOPEN_EXTENDED_INFO dup(0)
 44774                                  	;times	11 db 0
 44775 00000D3B 00<rep Bh>              	times	FEI.size db 0
 44776                                  
 44777                                  ; Dir_Info_Buff is a dir entry buffer which is filled by FastOPen
 44778                                  ; when calling FastOpen Lookup
 44779                                  
 44780                                  Dir_Info_Buff:	; label  byte
 44781                                  	;db   	SIZE dir_entry dup (0)
 44782                                  	;times	32 db 0
 44783 00000D46 00<rep 20h>             	times	dir_entry.size db 0
 44784                                  
 44785                                  Next_Element_Start:
 44786 00000D66 0000                    	dw	0			; save next element start offset
 44787                                  Del_ExtCluster:
 44788 00000D68 0000                    	dw	0			; for dos_delete                       
 44789                                  
 44790                                  ; The following is a stack and its pointer for interrupt 2F which is used
 44791                                  ; by NLSFUNC. There is no significant use of this stack, we are just trying
 44792                                  ; not to destroy the INT 21 stack saved for the user.
 44793                                  
 44794                                  USER_SP_2F:	; LABEL  WORD
 44795 00000D6A [6C0D]                  	dw    	FAKE_STACK_2F
 44796                                  
 44797                                  Packet_Temp:	; label  word		; temporary packet used by readtime
 44798                                  DOS_TEMP:	; label  word		; temporary word
 44799                                  FAKE_STACK_2F:  
 44800                                  	; dw  14 dup (0)		; 12 register temporary storage
 44801 00000D6C 0000<rep Eh>            	times 14 dw 0
 44802                                  
 44803                                  Hash_Temp: 	;label  word		; temporary word             
 44804                                  	;dw   4 dup (0)			; temporary hash table during config.sys
 44805 00000D88 0000<rep 4h>            	times 4 dw 0
 44806                                              	
 44807                                  SCAN_FLAG:	
 44808 00000D90 00                      	db     0			; flag to indicate key ALT_Q
 44809                                  DATE_FLAG:
 44810 00000D91 0000                    	dw     0                	; flag to update the date
 44811                                  
 44812                                  FETCHI_TAG:	; label  word		; OBSOLETE - no longer used
 44813 00000D93 0000                    	dw     0			; formerly part of IBM's piracy protection
 44814                                  
 44815                                  MSG_EXTERROR:	; label  DWORD   ; for system message addr                                                       
 44816 00000D95 00000000                	dd     0               		; for extended error                   
 44817 00000D99 00000000                	dd     0			; for parser                           
 44818 00000D9D 00000000                	dd     0			; for critical errror                  
 44819 00000DA1 00000000                	dd     0			; for IFS                              
 44820 00000DA5 00000000                	dd     0			; for code reduction                   
 44821                                  
 44822                                  SEQ_SECTOR:	; label  DWORD 		; last sector read                                                     
 44823 00000DA9 FFFFFFFF                	dd     -1                                                        
 44824                                  SC_SECTOR_SIZE:
 44825 00000DAD 0000                    	dw	0			; sector size for SC                 
 44826                                  SC_DRIVE:
 44827 00000DAF 00                      	db	0			; drive # for secondary cache        
 44828                                  CurSC_DRIVE:
 44829 00000DB0 FF                      	db	-1			; current SC drive                   
 44830                                  CurSC_SECTOR:
 44831 00000DB1 00000000                	dd	0			; current SC starting sector         
 44832                                  SC_STATUS:
 44833 00000DB5 0000                    	dw	0			; SC status word                     
 44834                                  SC_FLAG:
 44835 00000DB7 00                      	db	0			; SC flag                            
 44836                                  AbsDskErr:
 44837 00000DB8 0000                    	dw	0			; Storage for Abs dsk read/write err
 44838                                                                                            
 44839                                  NO_NAME_ID:	; label byte                                                           
 44840 00000DBA 4E4F204E414D452020-     	db	'NO NAME    '		; null media id                      
 44840 00000DC3 2020               
 44841                                  
 44842                                  ;hkn; moved from TABLE segment in kstrin.asm
 44843                                  
 44844                                  KISTR001S:	; label	byte		; 2/17/KK
 44845 00000DC5 00                      LOOKSIZ: DB	0			; 0 if byte, NZ if word	2/17/KK
 44846                                  KISTR001E:	; label	byte		; 2/17/KK
 44847                                  
 44848                                  ; the nul device driver used to be part of the code. However, since the 
 44849                                  ; header is in the data, and the entry points are only given as an offset,
 44850                                  ; the strategy and interrupt entry points must also be in the data now.
 44851                                  
 44852                                  ; DOSDATA:0DC6h
 44853                                  
 44854                                  SNULDEV:
 44855                                  ;procedure snuldev,far
 44856                                  	;or	word [es:bx+3],100h
 44857                                  	; 17/12/2022
 44858                                  	;or	byte [es:bx+4],01h
 44859                                  	; 05/01/2024 (Original MSDOS and RetroDOS DATA address compatibility)
 44860                                  	;or	byte [es:bx+SRHEAD.REQSTAT+1],(STDON>>8)
 44861 00000DC6 26814F030001            	or	word [es:bx+SRHEAD.REQSTAT],STDON ; set done bit
 44862                                  INULDEV:
 44863 00000DCC CB                      	retf				; must not be a return!
 44864                                  ;endproc snuldev
 44865                                  
 44866                                  ;M044
 44867                                  ; Second part of save area for saving last para of Windows memory
 44868                                  
 44869                                  WinoldPatch2:
 44870                                  	;db	8 dup (?)	; M044
 44871 00000DCD 00<rep 8h>              	times	8 db 0	
 44872                                  UmbSave2:
 44873                                  	;db	5 dup (?)	; M062
 44874 00000DD5 00<rep 5h>              	times	5 db 0
 44875                                  UmbSaveFlag:
 44876 00000DDA 00                      	db	0		; M062
 44877                                  
 44878                                  ; DOSDATA:0DDBh
 44879                                  
 44880                                  Mark2:	; label byte
 44881                                  
 44882                                  ;IF2
 44883                                  ;	IF ((OFFSET MARK2) GT (OFFSET ERR_TABLE_21) )
 44884                                  ;		%OUT !DATA CORRUPTION!MARK2 OFFSET TOO BIG. RE-ORGANIZE DATA.
 44885                                  ;	ENDIF
 44886                                  ;ENDIF
 44887                                  
 44888                                  ;############################################################################
 44889                                  ;
 44890                                  ; ** HACK FOR DOS 4.0 REDIR **
 44891                                  ; 
 44892                                  ; The redir requires the following:
 44893                                  ;
 44894                                  ;	ERR_TABLE_21	offset DDBH
 44895                                  ;	ERR_TABLE_24	offset E5BH
 44896                                  ; 	ErrMap24	offset EABH
 44897                                  ;
 44898                                  ; WARNING! WARNING!
 44899                                  ;
 44900                                  ; MARK2 SHOULD NOT BE >= 0DDBH. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
 44901                                  ; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
 44902                                  ;
 44903                                  ; CURRENTLY MARK2 = 0DD0H
 44904                                  ;
 44905                                  ;############################################################################
 44906                                  
 44907                                  	;ORG	0DDBh
 44908                                  
 44909                                  ; DOSDATA:0DDBh (MSDOS 6.21, MSDOS.SYS)
 44910                                  
 44911                                  ; ---------------------------------------------------------------------------
 44912                                  ;
 44913                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 21H
 44914                                  ; errors. Each entry is 4 bytes long:
 44915                                  ;
 44916                                  ;       Err#,Class,Action,Locus
 44917                                  ;
 44918                                  ; A value of 0FFh indicates a call specific value (ie. should already
 44919                                  ; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
 44920                                  ; THE END, IT IS ASSUMES THAT CLASS, ACTION, LOCUS IS ALREADY SET.
 44921                                  ;
 44922                                  ; ---------------------------------------------------------------------------
 44923                                  
 44924                                  ;ErrTab  Macro   err,class,action,locus
 44925                                  ;ifidn <locus>,<0FFh>
 44926                                  ;    DB  error_&err,errCLASS_&class,errACT_&action,0FFh
 44927                                  ;ELSE
 44928                                  ;    DB  error_&err,errCLASS_&class,errACT_&action,errLOC_&locus
 44929                                  ;ENDIF
 44930                                  ;ENDM
 44931                                  
 44932                                  ERR_TABLE_21: ; LABEL   BYTE
 44933 00000DDB 010704FF                    DB  error_invalid_function,       errCLASS_Apperr,    errACT_Abort,    0FFh
 44934 00000DDF 02080302                    DB  error_file_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 44935 00000DE3 03080302                    DB  error_path_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 44936 00000DE7 04010401                    DB  error_too_many_open_files,    errCLASS_OutRes,    errACT_Abort,    errLOC_Unk
 44937 00000DEB 050303FF                    DB  error_access_denied,          errCLASS_Auth,      errACT_User,     0FFh
 44938 00000DEF 06070401                    DB  error_invalid_handle,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 44939 00000DF3 07070505                    DB  error_arena_trashed,          errCLASS_Apperr,    errACT_Panic,    errLOC_Mem
 44940 00000DF7 08010405                    DB  error_not_enough_memory,      errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 44941 00000DFB 09070405                    DB  error_invalid_block,          errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
 44942 00000DFF 0A070405                    DB  error_bad_environment,        errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
 44943 00000E03 0B090301                    DB  error_bad_format,             errCLASS_BadFmt,    errACT_User,     errLOC_Unk
 44944 00000E07 0C070401                    DB  error_invalid_access,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 44945 00000E0B 0D090401                    DB  error_invalid_data,           errCLASS_BadFmt,    errACT_Abort,    errLOC_Unk
 44946 00000E0F 0F080302                    DB  error_invalid_drive,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 44947 00000E13 10030302                    DB  error_current_directory,      errCLASS_Auth,      errACT_User,     errLOC_Disk
 44948 00000E17 110D0302                    DB  error_not_same_device,        errCLASS_Unk,       errACT_User,     errLOC_Disk
 44949 00000E1B 12080302                    DB  error_no_more_files,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 44950 00000E1F 500C0302                    DB  error_file_exists,            errCLASS_Already,   errACT_User,     errLOC_Disk
 44951 00000E23 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 44952 00000E27 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 44953 00000E2B 540104FF                    DB  error_out_of_structures,      errCLASS_OutRes,    errACT_Abort,    0FFh
 44954 00000E2F 56030301                    DB  error_invalid_password,       errCLASS_Auth,      errACT_User,     errLOC_Unk
 44955 00000E33 52010402                    DB  error_cannot_make,            errCLASS_OutRes,    errACT_Abort,    errLOC_Disk
 44956 00000E37 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
 44957 00000E3B 550C0303                    DB  error_already_assigned,       errCLASS_Already,   errACT_User,     errLOC_Net
 44958 00000E3F 57090301                    DB  error_invalid_parameter,      errCLASS_BadFmt,    errACT_User,     errLOC_Unk
 44959 00000E43 530D0401                    DB  error_FAIL_I24,               errCLASS_Unk,       errACT_Abort,    errLOC_Unk
 44960 00000E47 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 44961                                      ; MSDOS 6.0
 44962 00000E4B 26010401                    DB  error_handle_EOF,             errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
 44963 00000E4F 27010401                    DB  error_handle_Disk_Full,       errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
 44964 00000E53 5A0D0402                    DB  error_sys_comp_not_loaded,    errCLASS_Unk,       errACT_Abort,    errLOC_Disk ;AN001;
 44965 00000E57 FFFFFFFF                    DB  0FFh,                         0FFH,       	  0FFH,       	   0FFh
 44966                                  
 44967                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D2Ah
 44968                                  ;ERR_TABLE_21:	db 1,7,4,0FFh
 44969                                  ;		db 2,8,3,2
 44970                                  ;		db 3,8,3,2
 44971                                  ;		db 4,1,4,1
 44972                                  ;		db 5,3,3,0FFh
 44973                                  ;		db 6,7,4,1
 44974                                  ;		db 7,7,5,5
 44975                                  ;		db 8,1,4,5
 44976                                  ;		db 9,7,4,5
 44977                                  ;		db 0Ah,7,4,5
 44978                                  ;		db 0Bh,9,3,1
 44979                                  ;		db 0Ch,7,4,1
 44980                                  ;		db 0Dh,9,4,1
 44981                                  ;		db 0Fh,8,3,2
 44982                                  ;		db 10h,3,3,2
 44983                                  ;		db 11h,0Dh,3,2
 44984                                  ;		db 12h,8,3,2
 44985                                  ;		db 50h,0Ch,3,2
 44986                                  ;		db 20h,0Ah,2,2
 44987                                  ;		db 21h,0Ah,2,2
 44988                                  ;		db 54h,1,4,0FFh
 44989                                  ;		db 56h,3,3,1
 44990                                  ;		db 52h,1,4,2
 44991                                  ;		db 32h,9,3,3
 44992                                  ;		db 55h,0Ch,3,3
 44993                                  ;		db 57h,9,3,1
 44994                                  ;		db 53h,0Dh,4,1
 44995                                  ;		db 24h,1,4,5
 44996                                  ; MSDOS 6.0 (MSDOS 6.21)
 44997                                  ;		db 26h,1,4,1
 44998                                  ;		db 27h,1,4,1
 44999                                  ;		db 5Ah,0Dh,4,2
 45000                                  ; MSDOS 6.0 & MSDOS 3.3
 45001                                  ;		db 0FFh,0FFh,0FFh,0FFh
 45002                                  
 45003                                  ; DOSDATA:0E5Bh (MSDOS 6.21, MSDOS.SYS)
 45004                                  
 45005                                  ; ---------------------------------------------------------------------------
 45006                                  ;
 45007                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 24H
 45008                                  ; errors. Each entry is 4 bytes long:
 45009                                  ;
 45010                                  ;       Err#,Class,Action,Locus
 45011                                  ;
 45012                                  ; A Locus value of 0FFh indicates a call specific value (ie. should already
 45013                                  ; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
 45014                                  ; THE END.
 45015                                  ;
 45016                                  ; ---------------------------------------------------------------------------
 45017                                  
 45018                                  ERR_TABLE_24: ; LABEL   BYTE
 45019 00000E5B 130B0702                    DB  error_write_protect,          errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 45020 00000E5F 14040501                    DB  error_bad_unit,               errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 45021 00000E63 150507FF                    DB  error_not_ready,              errCLASS_HrdFail,   errACT_IntRet,   0FFh
 45022 00000E67 16040501                    DB  error_bad_command,            errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 45023 00000E6B 170B0402                    DB  error_CRC,                    errCLASS_Media,     errACT_Abort,    errLOC_Disk
 45024 00000E6F 18040501                    DB  error_bad_length,             errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 45025 00000E73 19050102                    DB  error_seek,                   errCLASS_HrdFail,   errACT_Retry,    errLOC_Disk
 45026 00000E77 1A0B0702                    DB  error_not_DOS_disk,           errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 45027 00000E7B 1B0B0402                    DB  error_sector_not_found,       errCLASS_Media,     errACT_Abort,    errLOC_Disk
 45028 00000E7F 1C020704                    DB  error_out_of_paper,           errCLASS_TempSit,   errACT_IntRet,   errLOC_SerDev
 45029 00000E83 1D0504FF                    DB  error_write_fault,            errCLASS_HrdFail,   errACT_Abort,    0FFh
 45030 00000E87 1E0504FF                    DB  error_read_fault,             errCLASS_HrdFail,   errACT_Abort,    0FFh
 45031 00000E8B 1F0D04FF                    DB  error_gen_failure,            errCLASS_Unk,       errACT_Abort,    0FFh
 45032 00000E8F 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 45033 00000E93 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 45034 00000E97 220B0702                    DB  error_wrong_disk,             errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 45035 00000E9B 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
 45036 00000E9F 23070401                    DB  error_FCB_unavailable,        errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 45037 00000EA3 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 45038 00000EA7 FF0D05FF                    DB	0FFh,                         errCLASS_Unk,       errACT_Panic,    0FFh
 45039                                  
 45040                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D9Eh
 45041                                  ;ERR_TABLE_24:	db 13h,0Bh,7,2
 45042                                  ;		db 14h,4,5,1
 45043                                  ;		db 15h,5,7,0FFh
 45044                                  ;		db 16h,4,5,1
 45045                                  ;		db 17h,0Bh,4,2
 45046                                  ;		db 18h,4,5,1
 45047                                  ;		db 19h,5,1,2
 45048                                  ;		db 1Ah,0Bh,7,2
 45049                                  ;		db 1Bh,0Bh,4,2
 45050                                  ;		db 1Ch,2,7,4
 45051                                  ;		db 1Dh,5,4,0FFh
 45052                                  ;		db 1Eh,5,4,0FFh
 45053                                  ;		db 1Fh,0Dh,4,0FFh
 45054                                  ;		db 20h,0Ah,2,2
 45055                                  ;		db 21h,0Ah,2,2
 45056                                  ;		db 22h,0Bh,7,2
 45057                                  ;		db 32h,9,3,3
 45058                                  ;		db 23h,7,4,1
 45059                                  ;		db 24h,1,4,5
 45060                                  ;		db 0FFh,0Dh,5,0FFh
 45061                                  
 45062                                  ; DOSDATA:0EABh (MSDOS 6.21, MSDOS.SYS)
 45063                                  
 45064                                  ; ---------------------------------------------------------------------------
 45065                                  ;
 45066                                  ; We need to map old int 24 errors and device driver errors into the new set
 45067                                  ; of errors. The following table is indexed by the new errors
 45068                                  ;
 45069                                  ; ---------------------------------------------------------------------------
 45070                                  
 45071                                  ;Public  ErrMap24
 45072                                  ErrMap24: ; Label   BYTE
 45073 00000EAB 13                          DB  error_write_protect	; 0
 45074 00000EAC 14                          DB  error_bad_unit		; 1
 45075 00000EAD 15                          DB  error_not_ready		; 2
 45076 00000EAE 16                          DB  error_bad_command	; 3
 45077 00000EAF 17                          DB  error_CRC		; 4
 45078 00000EB0 18                          DB  error_bad_length	; 5
 45079 00000EB1 19                          DB  error_seek		; 6
 45080 00000EB2 1A                          DB  error_not_DOS_disk	; 7
 45081 00000EB3 1B                          DB  error_sector_not_found	; 8
 45082 00000EB4 1C                          DB  error_out_of_paper	; 9
 45083 00000EB5 1D                          DB  error_write_fault	; A
 45084 00000EB6 1E                          DB  error_read_fault	; B
 45085 00000EB7 1F                          DB  error_gen_failure	; C
 45086 00000EB8 1F                          DB  error_gen_failure	; D  RESERVED
 45087 00000EB9 1F                          DB  error_gen_failure	; E  RESERVED
 45088 00000EBA 22                          DB  error_wrong_disk	; F
 45089                                  
 45090                                  ;ErrMap24: db 13h, 14h, 15h, 16h, 17h, 18h, 19h, 1Ah
 45091                                  ;	   db 1Bh, 1Ch, 1Dh, 1Eh, 1Fh, 1Fh, 1Fh, 22h
 45092                                  	
 45093                                  ErrMap24End: ; LABEL   BYTE
 45094                                  
 45095                                  ; DOSDATA:0E5Bh (MSDOS 6.21, MSDOS.SYS)
 45096                                  
 45097                                  ; ---------------------------------------------------------------------------
 45098                                  
 45099                                  ; 27/04/2019 - Retro DOS v4.0
 45100                                  
 45101                                  FIRST_BUFF_ADDR:
 45102 00000EBB 0000                    	dw	0			; first buffer address               
 45103                                  SPECIAL_VERSION:
 45104 00000EBD 0000                    	dw	0			;AN006; used by INT 2F 47H
 45105                                  FAKE_COUNT:
 45106 00000EBF 00<rep FFh>             	times 255 db 0			;AN008; fake version count
 45107                                  OLD_FIRSTCLUS:
 45108 00000FBE 0000                    	dw	0			;AN011; save old first cluster for fastopen
 45109                                  
 45110                                  ; ---------------------------------------------------------------------------
 45111                                  
 45112                                  ;smr; moved from TABLE segment in exec.asm
 45113                                  
 45114 00000FC0 0000                    exec_init_SP: dw 0
 45115 00000FC2 0000                    exec_init_SS: dw 0
 45116 00000FC4 0000                    exec_init_IP: dw 0
 45117 00000FC6 0000                    exec_init_CS: dw 0
 45118                                  
 45119                                  exec_signature:
 45120 00000FC8 0000                    	dw	0	; must contain 4D5A (yay zibo!)
 45121                                  exec_len_mod_512:
 45122 00000FCA 0000                    	dw	0	; low 9 bits of length
 45123                                  exec_pages:
 45124 00000FCC 0000                    	dw	0	; number of 512b pages in file
 45125                                  exec_rle_count:
 45126 00000FCE 0000                    	dw	0	; count of reloc entries
 45127                                  exec_par_dir:
 45128 00000FD0 0000                    	dw	0	; number of paragraphs before image
 45129                                  exec_min_BSS:
 45130 00000FD2 0000                    	dw	0	; minimum number of para of BSS
 45131                                  exec_max_BSS:
 45132 00000FD4 0000                    	dw	0	; max number of para of BSS
 45133                                  exec_SS:
 45134 00000FD6 0000                    	dw	0	; stack of image
 45135                                  exec_SP:
 45136 00000FD8 0000                    	dw	0	; SP of image
 45137                                  exec_chksum:
 45138 00000FDA 0000                    	dw	0	; checksum of file (ignored)
 45139                                  exec_IP:
 45140 00000FDC 0000                    	dw	0	; IP of entry
 45141                                  exec_CS:
 45142 00000FDE 0000                    	dw	0	; CS of entry
 45143                                  exec_rle_table:
 45144 00000FE0 0000                    	dw	0	; byte offset of reloc table
 45145                                  
 45146                                  exec_header_len	equ $-exec_signature			;PBUGBUG
 45147                                  
 45148                                  ;smr; eom
 45149                                  
 45150                                  ; ---------------------------------------------------------------------------
 45151                                  
 45152                                  ;SR;
 45153                                  ; WIN386 instance table for DOS
 45154                                  
 45155                                  Win386_Info:
 45156 00000FE2 0300                    	db	3, 0
 45157 00000FE4 000000000000000000-     	dd	0, 0, 0
 45157 00000FED 000000             
 45158 00000FF0 [F40F]0000              	dw	Instance_Table, 0
 45159                                  
 45160                                  Instance_Table:
 45161 00000FF4 [2200]00000200          	dw	CONTPOS, 0, 2
 45162 00000FFA [3200]00000400          	dw	BCON, 0, 4
 45163 00001000 [F901]00000601          	dw	CARPOS, 0, 106h
 45164 00001006 [0003]00000100          	dw	CHARCO, 0, 1
 45165 0000100C [C00F]00002200          	dw	exec_init_SP, 0, 34	; M074
 45166 00001012 [8900]00000100          	dw	UMBFLAG,0,1		; M019
 45167 00001018 [8C00]00000200          	dw	UMB_HEAD,0,2		; M019
 45168 0000101E 00000000                	dw	0, 0
 45169                                  
 45170                                  ; M001; SR;
 45171                                  ; M001; On DOSMGR call ( cx == 0 ), we need to return a table of offsets of 
 45172                                  ; M001; some DOS variables. Note that the only really important variable in 
 45173                                  ; M001; this is User_Id. The other variables are needed only to patch stuff 
 45174                                  ; M001; which does not need to be done in DOS 5.0. 
 45175                                  
 45176                                  ; 29/12/2022
 45177                                  ; (MSDOS 6.21 MSDOS.SYS DOSDATA:1022h)
 45178                                  
 45179                                  Win386_DOSVars:
 45180 00001022 05                      	db	5	;Major version 5 ; M001
 45181 00001023 00                      	db	0	;Minor version 0 ; M001
 45182 00001024 [EC05]                  	dw	SAVEDS	; M001
 45183 00001026 [EA05]                  	dw	SAVEBX	; M001
 45184 00001028 [2103]                  	dw	INDOS	; M001
 45185 0000102A [3E03]                  	dw	USER_ID	; M001
 45186 0000102C [1503]                  	dw	CritPatch ; M001
 45187 0000102E [8C00]                  	dw	UMB_HEAD ; M012
 45188                                  
 45189                                  ;SR;
 45190                                  ; Flag to indicate whether WIN386 is running or not
 45191                                  
 45192 00001030 00                      IsWin386: db	0
 45193                                  
 45194                                  ;M018
 45195                                  ; This variable contains the path to the VxD device needed for Win386
 45196                                  
 45197 00001031 633A5C77696E613230-     VxDpath:  db	'c:\wina20.386',0	;M018
 45197 0000103A 2E33383600         
 45198                                  
 45199                                  ;End WIN386 support
 45200                                  
 45201                                  ; ---------------------------------------------------------------------------
 45202                                  
 45203                                  ;SR;
 45204                                  ; These variables have been added for the special lie support for device
 45205                                  ;drivers.
 45206                                  ;
 45207                                  
 45208                                  DriverLoad:	
 45209 0000103F 01                      	db	1	;initialized to do special handling
 45210                                  BiosDataPtr:
 45211 00001040 00000000                	dd	0
 45212                                  
 45213                                  ; 29/12/2022 - Retro DOS v4.1
 45214                                  %if 0
 45215                                  
 45216                                  ; 27/04/2019 - Retro DOS v4.0
 45217                                  ; 04/11/2022
 45218                                  ; DOSDATA:1044h (MSDOS 6.21 & MSDOS 5.0, MSDOS.SYS)
 45219                                  
 45220                                  ;------------------------------------------------------------------------
 45221                                  ; Patch for Sidekick
 45222                                  ;
 45223                                  ; A documented method for finding the offset of the Errormode flag in the 
 45224                                  ; dos swappable data area if for the app to scan in the dos segment (data) 
 45225                                  ; for the following sequence of instructions.
 45226                                  ;
 45227                                  ; Ref: Part C, Article 11, pg 356 of MSDOS Encyclopedia
 45228                                  ;
 45229                                  ; The Offset of Errormode flag is 0320h
 45230                                  ;
 45231                                  ;------------------------------------------------------------------------
 45232                                  
 45233                                  	db	036h, 0F6h, 06h, 020h, 03h, 0FFh ; test ss:[errormode], -1
 45234                                  	db	075h, 0Ch			 ; jnz  NearLabel
 45235                                  	db	036h, 0FFh, 036h, 058h, 03h	 ; push ss:[NearWord]
 45236                                  	db	0CDh, 028h			 ; int  28h
 45237                                  
 45238                                  ;--------------------------------------------------------------------------
 45239                                  ; Patch for PortOfEntry - M036
 45240                                  ;
 45241                                  ; PortOfEntry by Sector Technology uses an un documented way of determining
 45242                                  ; the offset of Errormode flag. The following patch is to support them in 
 45243                                  ; DOS 5.0. The corresponding code is actually in msdisp.asm
 45244                                  ;
 45245                                  ;---------------------------------------------------------------------------
 45246                                  
 45247                                  	db 	080h, 03Eh, 020h, 03h, 00h 	 ; cmp 	[errormode], 0
 45248                                  	db	075h, 037h			 ; jnz	NearLabel
 45249                                  	db 	0BCh, 0A0h, 0Ah		  	 ; mov	sp, dosdata:iostack
 45250                                  
 45251                                  %endif ; 29/12/2022
 45252                                  
 45253                                  ; DOSDATA:105Dh (MSDOS 6.21, MSDOS.SYS)
 45254                                  
 45255                                  ;--------------------------------------------------------------------------
 45256                                  
 45257                                  ;*** New FCB Implementation
 45258                                  ; This variable is used as a cache in the new FCB implementation to remember
 45259                                  ;the address of a local SFT that can be recycled for a regenerate operation
 45260                                  
 45261 00001044 00000000                LocalSFT: dd	0		; 0 to indicate invalid pointer
 45262                                  
 45263                                  ;DOSDATA ENDS
 45264                                  
 45265                                  ;============================================================================
 45266                                  ; LMSTUB.ASM (MSDOS 6.0, 1991)
 45267                                  ;============================================================================
 45268                                  ; 27/04/2019 - Retro DOS 4.0
 45269                                  
 45270                                  ;DOSDATA  SEGMENT WORD PUBLIC 'DATA'
 45271                                  
 45272                                  ;---------------------------------------------------------------------------
 45273                                  ;	Low Memory Stub for DOS when DOS runs in HMA
 45274                                  ;----------------------------------------------------------------------------
 45275                                  	
 45276                                  	;db	90h
 45277                                  
 45278                                  	;EVEN
 45279                                  align 2
 45280                                  
 45281                                  ; DOSDATA:1062h (MSDOS 6.21, MSDOS.SYS)
 45282                                  
 45283                                  DOSINTTABLE:	; LABEL	DWORD
 45284                                  
 45285                                  	;DW	OFFSET DOSCODE:DIVOV 		, 0
 45286                                  	;DW	OFFSET DOSCODE:QUIT 		, 0
 45287                                  	;DW	OFFSET DOSCODE:COMMAND		, 0
 45288                                  	;DW	OFFSET DOSCODE:ABSDRD		, 0
 45289                                  	;DW	OFFSET DOSCODE:ABSDWRT		, 0
 45290                                  	;DW	OFFSET DOSCODE:Stay_resident	, 0
 45291                                  	;DW	OFFSET DOSCODE:INT2F		, 0
 45292                                  	;DW	OFFSET DOSCODE:CALL_ENTRY	, 0
 45293                                  	;DW	OFFSET DOSCODE:IRETT		, 0
 45294                                  	
 45295 00001048 [A552]0000              	dw	DIVOV 		, 0  ; DOSINTTABLE+0
 45296 0000104C [DC02]0000              	dw	QUIT 		, 0  ; DOSINTTABLE+4	
 45297 00001050 [0803]0000              	dw	COMMAND		, 0  ; DOSINTTABLE+8
 45298 00001054 [2D05]0000              	dw	ABSDRD		, 0  ; DOSINTTABLE+12
 45299 00001058 [B405]0000              	dw	ABSDWRT		, 0  ; DOSINTTABLE+16
 45300 0000105C [DF61]0000              	dw	STAY_RESIDENT	, 0  ; DOSINTTABLE+20
 45301 00001060 [0307]0000              	dw	INT2F		, 0  ; DOSINTTABLE+24
 45302 00001064 [E302]0000              	dw	CALL_ENTRY	, 0  ; DOSINTTABLE+28
 45303 00001068 [E202]0000              	dw	IRETT		, 0  ; DOSINTTABLE+32
 45304                                  
 45305 0000106C 0000                    SS_Save: dw	0		; save user's stack segment
 45306 0000106E 0000                    SP_Save: dw	0		; save user's stack offset
 45307                                  
 45308                                  ;-------------------------------------------------------------------------
 45309                                  ;
 45310                                  ; LOW MEM STUB:
 45311                                  ;
 45312                                  ; The low mem stub contains the entry points into DOS for all interrupts 
 45313                                  ; handled by DOS. This stub is installed if the user specifies that the 
 45314                                  ; DOS load in HIMEM. Each entry point does this.
 45315                                  ;
 45316                                  ; 	1. if jmp to 8 has been patched out
 45317                                  ;	   2. if A20 OFF
 45318                                  ;	      3. Enable A20
 45319                                  ;	   4. else 
 45320                                  ;	      5. just go to dos entry
 45321                                  ;	   6. endif
 45322                                  ;	7. else
 45323                                  ;	   8. just go to dos entry
 45324                                  ;	9. endif
 45325                                  ;
 45326                                  ;--------------------------------------------------------------------------
 45327                                  
 45328                                  ; 27/04/2019 - Retro DOS v4.0
 45329                                  
 45330                                  ; DOSDATA:108Ah (MSDOS 6.21, MSDOS.SYS)
 45331                                  
 45332                                  ;--------------------------------------------------------------------------
 45333                                  ;
 45334                                  ; DIVIDE BY 0 handler
 45335                                  ;
 45336                                  ;--------------------------------------------------------------------------
 45337                                  
 45338                                  ldivov:
 45339                                  	; The following jump, skipping the XMS calls will be patched to 
 45340                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45341                                  	; needed because the stub is installed even before the XMS driver
 45342                                  	; is loaded if the user specifies dos=high in the config.sys
 45343                                  i0patch:
 45344 00001070 EB03                    	jmp	short divov_cont	
 45345                                  
 45346 00001072 E8D800                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45347                                  divov_cont:
 45348 00001075 2EFF2E[4810]            	jmp	far [cs:DOSINTTABLE]	; jmp to DOS
 45349                                  
 45350                                  ;------------------------------------------------------------------------
 45351                                  ;
 45352                                  ; INT 20 Handler
 45353                                  ;
 45354                                  ; Here we do not have to set up the stack to return here as the abort call
 45355                                  ; will return to the address after the int 21 ah=4b call. This would be the
 45356                                  ; common exit point if A20 had been OFF (for TOGGLE DOS) and the A20 line
 45357                                  ; will be restored then.
 45358                                  ;
 45359                                  ;-------------------------------------------------------------------------
 45360                                  
 45361                                  lquit:
 45362                                  	; The following jump, skipping the XMS calls will be patched to 
 45363                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45364                                  	; needed because the stub is installed even before the XMS driver
 45365                                  	; is loaded if the user specifies dos=high in the config.sys
 45366                                  i20patch:
 45367 0000107A EB03                    	jmp	short quit_cont	
 45368                                  
 45369 0000107C E8CE00                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45370                                  quit_cont:
 45371 0000107F 2EFF2E[4C10]            	jmp	far [cs:DOSINTTABLE+4]	; jump to DOS
 45372                                  
 45373                                  ;--------------------------------------------------------------------------
 45374                                  ;
 45375                                  ; INT 21 Handler
 45376                                  ;
 45377                                  ;--------------------------------------------------------------------------
 45378                                  
 45379                                  lcommand:
 45380                                  	; The following jump, skipping the XMS calls will be patched to 
 45381                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45382                                  	; needed because the stub is installed even before the XMS driver
 45383                                  	; is loaded if the user specifies dos=high in the config.sys
 45384                                  i21patch:
 45385 00001084 EB03                    	jmp	short command_cont	
 45386                                  
 45387 00001086 E8C400                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45388                                  command_cont:
 45389 00001089 2EFF2E[5010]            	jmp	far [cs:DOSINTTABLE+8]	; jmp to DOS
 45390                                  
 45391                                  ;------------------------------------------------------------------------
 45392                                  ;
 45393                                  ; INT 25 
 45394                                  ;
 45395                                  ;----------------------------------------------------------------------------
 45396                                  
 45397                                  labsdrd:
 45398                                  	; The following jump, skipping the XMS calls will be patched to 
 45399                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45400                                  	; needed because the stub is installed even before the XMS driver
 45401                                  	; is loaded if the user specifies dos=high in the config.sys
 45402                                  i25patch:
 45403 0000108E EB03                    	jmp	short absdrd_cont	
 45404                                  
 45405 00001090 E8BA00                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45406                                  absdrd_cont:
 45407 00001093 2EFF2E[5410]            	jmp	far [cs:DOSINTTABLE+12]	; jmp to DOS
 45408                                  
 45409                                  ;-------------------------------------------------------------------------
 45410                                  ;
 45411                                  ; INT 26
 45412                                  ;
 45413                                  ;-----------------------------------------------------------------------
 45414                                  
 45415                                  labsdwrt:
 45416                                  	; The following jump, skipping the XMS calls will be patched to 
 45417                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45418                                  	; needed because the stub is installed even before the XMS driver
 45419                                  	; is loaded if the user specifies dos=high in the config.sys
 45420                                  i26patch:
 45421 00001098 EB03                    	jmp	short absdwrt_cont	
 45422                                  
 45423 0000109A E8B000                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45424                                  absdwrt_cont:
 45425 0000109D 2EFF2E[5810]            	jmp	far [cs:DOSINTTABLE+16]	; jmp to DOS
 45426                                  
 45427                                  ;------------------------------------------------------------------------
 45428                                  ;
 45429                                  ; INT 27
 45430                                  ;
 45431                                  ;-----------------------------------------------------------------------
 45432                                  
 45433                                  lstay_resident:
 45434                                  	; The following jump, skipping the XMS calls will be patched to 
 45435                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45436                                  	; needed because the stub is installed even before the XMS driver
 45437                                  	; is loaded if the user specifies dos=high in the config.sys
 45438                                  i27patch:
 45439 000010A2 EB03                    	jmp	short sr_cont	
 45440                                  
 45441 000010A4 E8A600                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45442                                  sr_cont:
 45443 000010A7 2EFF2E[5C10]            	jmp	far [cs:DOSINTTABLE+20]	; jmp to DOS
 45444                                  
 45445                                  ;-----------------------------------------------------------------------------
 45446                                  ;
 45447                                  ; INT 2f
 45448                                  ;
 45449                                  ;-------------------------------------------------------------------------
 45450                                  
 45451                                  lint2f:
 45452                                  	; The following jump, skipping the XMS calls will be patched to 
 45453                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45454                                  	; needed because the stub is installed even before the XMS driver
 45455                                  	; is loaded if the user specifies dos=high in the config.sys
 45456                                  i2fpatch:
 45457 000010AC EB03                    	jmp	short int2f_cont	
 45458                                  
 45459 000010AE E89C00                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45460                                  int2f_cont:
 45461 000010B1 2EFF2E[6010]            	jmp	far [cs:DOSINTTABLE+24]	; jmp to DOS
 45462                                  
 45463                                  ;-----------------------------------------------------------------------------
 45464                                  ;
 45465                                  ; CPM entry
 45466                                  ;
 45467                                  ;------------------------------------------------------------------------
 45468                                  
 45469                                  lcall_entry:
 45470                                  	; The following jump, skipping the XMS calls will be patched to 
 45471                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45472                                  	; needed because the stub is installed even before the XMS driver
 45473                                  	; is loaded if the user specifies dos=high in the config.sys
 45474                                  cpmpatch:
 45475 000010B6 EB03                    	jmp	short callentry_cont	
 45476                                  
 45477 000010B8 E89200                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45478                                  callentry_cont:
 45479 000010BB 2EFF2E[6410]            	jmp	far [cs:DOSINTTABLE+28]	; jmp to DOS
 45480                                  
 45481                                  ;--------------------------------------------------------------------------
 45482                                  
 45483                                  lirett:
 45484 000010C0 CF                      	iret
 45485                                  
 45486                                  ;---------------------------------------------------------------------------
 45487                                  ;
 45488                                  ; LowIntXX:
 45489                                  ;
 45490                                  ; Interrupts from DOS that pass control to a user program must be done from
 45491                                  ; low memory, as the user program may change the state of the A20 line or
 45492                                  ; they may require that the A20 line be OFF. The following piece of code is
 45493                                  ; far call'd from the following places in DOS:
 45494                                  ;
 45495                                  ;	1. msctrlc.asm where dos issues an int 23h (ctrlc)
 45496                                  ;	2. msctrlc.asm where dos issues an int 24h (critical error)
 45497                                  ;	3. msctrlc.asm where dos issues an int 28h (idle int)
 45498                                  ;
 45499                                  ; The int 23 and int 24 handlers may decide to do a far return instead of an
 45500                                  ; IRET ane leave the flags on the stack. Therefore we save the return address
 45501                                  ; before doing the ints and then do a far junp back into DOS.
 45502                                  ;
 45503                                  ;---------------------------------------------------------------------------
 45504                                  
 45505 000010C1 00000000                DosRetAddr23:	dd	0
 45506 000010C5 00000000                DosRetAddr24:	dd	0
 45507 000010C9 00000000                DosRetAddr28:	dd	0
 45508                                  
 45509                                  	; Execute int 23h from low memory
 45510                                  LowInt23:
 45511                                  					; save the return address that is on
 45512                                  					; the stack
 45513 000010CD 2E8F06[C110]            	pop	word [cs:DosRetAddr23]
 45514 000010D2 2E8F06[C310]            	pop	word [cs:DosRetAddr23+2]
 45515                                  
 45516 000010D7 CD23                    	int	23h			; ctrl C
 45517                                  					; turn on A20 it has been turned OFF
 45518                                  					; by int 28/23/24 handler.
 45519                                  
 45520 000010D9 E87100                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF 
 45521                                  
 45522 000010DC 2EFF2E[C110]            	jmp	far [cs:DosRetAddr23]	; jump back to DOS
 45523                                  
 45524                                  
 45525                                  	; Execute int 24h from low memory
 45526                                  LowInt24:
 45527                                  					; save the return address that is on
 45528                                  					; the stack
 45529 000010E1 2E8F06[C510]            	pop	word [cs:DosRetAddr24]
 45530 000010E6 2E8F06[C710]            	pop	word [cs:DosRetAddr24+2]
 45531                                  
 45532 000010EB CD24                    	int	24h			; crit error
 45533                                  					; turn on A20 it has been turned OFF
 45534                                  					; by int 28/23/24 handler.
 45535                                  
 45536 000010ED E85D00                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF	
 45537                                  
 45538 000010F0 2EFF2E[C510]            	jmp	far [cs:DosRetAddr24]	; jump back to DOS
 45539                                  
 45540                                  
 45541                                   
 45542                                  	; Execute int 28h from low memory
 45543                                  LowInt28:
 45544 000010F5 CD28                    	int	28h			; idle int
 45545                                  					; turn on A20 it has been turned OFF
 45546                                  					; by int 28/23/24 handler.
 45547                                  
 45548 000010F7 E85300                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF	
 45549                                  
 45550 000010FA CB                      	retf
 45551                                  
 45552                                  ; DOSDATA:1115h (MSDOS 6.21, MSDOS.SYS)
 45553                                  
 45554                                  ;-------------------------------------------------------------------------
 45555                                  ;
 45556                                  ; int 21 ah=4b (exec) call will jump to the following label before xferring
 45557                                  ; control to the exec'd program. We turn off A20 inorder to allow programs
 45558                                  ; that have been packed by the faulty exepack utility to unpack correctly.
 45559                                  ; This is so because exepac'd programs rely on address wrap.
 45560                                  ;
 45561                                  ;------------------------------------------------------------------------- 
 45562                                  
 45563                                  disa20_xfer:
 45564 000010FB E83F00                  	call	XMMDisableA20		; disable A20
 45565                                  
 45566                                  	; Look at msproc.asm at label exec_go for understanding the following:
 45567                                  
 45568                                  	; DS:SI points to entry point
 45569                                  	; AX:DI points to initial stack
 45570                                  	; DX has PDB pointer
 45571                                  	; BX has initial AX value
 45572                                  
 45573 000010FE FA                      	cli
 45574 000010FF 2EC606[2103]00          	mov	byte [cs:INDOS],0	; SS Override
 45575                                  
 45576 00001105 8ED0                    	mov	SS,AX			; set up user's stack
 45577 00001107 89FC                    	mov	SP,DI			; and SP
 45578 00001109 FB                      	sti
 45579                                  
 45580 0000110A 1E                      	push	DS			; fake long call to entry
 45581 0000110B 56                      	push	SI
 45582 0000110C 8EC2                    	mov	ES,DX			; set up proper seg registers
 45583 0000110E 8EDA                    	mov	DS,DX
 45584 00001110 89D8                    	mov	AX,BX			; set up proper AX
 45585 00001112 CB                      	retf
 45586                                  
 45587                                  ;-------------------------------------------------------------------------
 45588                                  ;
 45589                                  ; M003:
 45590                                  ;
 45591                                  ; If an int 21 ah=25 call is made immediately after an exec call, DOS will
 45592                                  ; come here, turn A20 OFF restore user stack and registers before returning 
 45593                                  ; to user. This is done in dos\msdisp.asm. This has been done to support 
 45594                                  ; programs compiled with MS PASCAL 3.2. See under TAG M003 in DOSSYM.INC for 
 45595                                  ; more info.	
 45596                                  ;
 45597                                  ; Also at this point DS is DOSDATA. So we can assume DS DOSDATA. Note that 
 45598                                  ; SS is also DOS stack. It is important that we do the XMS call on DOS's 
 45599                                  ; stack to avoid additional stack overhead for the user.
 45600                                  ;
 45601                                  ; -------------------------------------------------------------------------
 45602                                  
 45603                                  disa20_iret:
 45604 00001113 E82700                  	call	XMMDisableA20
 45605 00001116 FE0E[2103]              	dec	byte [INDOS]
 45606 0000111A 8E16[8605]              	mov	SS,[USER_SS]		; restore user stack
 45607 0000111E 8B26[8405]              	mov	SP,[USER_SP]
 45608 00001122 89E5                    	mov	BP,SP
 45609                                  	;mov	[BP+user_env.user_AX],AL
 45610 00001124 884600                  	mov	[bp],al
 45611 00001127 A1[F205]                	mov	AX,[NSP]
 45612 0000112A A3[8405]                	mov	[USER_SP],AX
 45613 0000112D A1[F005]                	mov	AX,[NSS]
 45614 00001130 A3[8605]                	mov	[USER_SS],AX
 45615                                  
 45616 00001133 58                      	pop	AX			; restore user regs
 45617 00001134 5B                      	pop	BX
 45618 00001135 59                      	pop	CX
 45619 00001136 5A                      	pop	DX
 45620 00001137 5E                      	pop	SI
 45621 00001138 5F                      	pop	DI
 45622 00001139 5D                      	pop	BP
 45623 0000113A 1F                      	pop	DS
 45624 0000113B 07                      	pop	ES
 45625 0000113C CF                      	iret
 45626                                  
 45627                                  ;**************************************************************************
 45628                                  ;***	XMMDisableA20 - switch 20th address line			      
 45629                                  ;									      
 45630                                  ;	This routine is used to disable the 20th address line in 	      
 45631                                  ;	the system using XMM calls.					      
 45632                                  ;									      
 45633                                  ;	ENTRY	none		;ds = _DATA				      
 45634                                  ;	EXIT	A20 line disabled					      
 45635                                  ;	USES	NOTHING					      
 45636                                  ;									      
 45637                                  ;**************************************************************************
 45638                                  
 45639                                  XMMDisableA20:
 45640 0000113D 53                      	push	bx
 45641 0000113E 50                      	push	ax
 45642                                  	;mov	ah,XMM_LOCAL_DISABLE_A20
 45643 0000113F B406                    	mov	ah,6
 45644 00001141 2EFF1E[4911]            	call	far [cs:XMMcontrol]
 45645 00001146 58                      	pop	ax
 45646 00001147 5B                      	pop	bx
 45647 00001148 C3                      	retn
 45648                                  
 45649                                  ; The entry point in the BIOS XMS driver is defined here.
 45650                                  
 45651                                  XMMcontrol:
 45652 00001149 00000000                	dd	0
 45653                                  
 45654                                  ;--------------------------------------------------------------------------
 45655                                  ;
 45656                                  ;***	EnsureA20ON - Ensures that A20 is ON
 45657                                  ;									      
 45658                                  ;	This routine is used to query the A20 state in		 	      
 45659                                  ;	the system using XMM calls.					      
 45660                                  ;									      
 45661                                  ;	ENTRY: none		
 45662                                  ;
 45663                                  ;	EXIT : A20 will be ON
 45664                                  ;		
 45665                                  ; 	USES : NONE								      
 45666                                  ;									      
 45667                                  ;--------------------------------------------------------------------------
 45668                                  
 45669                                  ; 19/09/2023
 45670                                  ;LowMemory:	; label dword		; Set equal to 0000:0080
 45671                                  ;	dw	00080h
 45672                                  ;	dw	00000h
 45673                                  ;
 45674                                  ;HighMemory:	; label dword
 45675                                  ;	dw	00090h			; Set equal to FFFF:0090
 45676                                  ;	dw	0FFFFh
 45677                                  
 45678                                  EnsureA20ON:
 45679 0000114D 9C                      	pushf
 45680 0000114E 1E                      	push    ds
 45681 0000114F 06                      	push	es
 45682 00001150 51                      	push	cx
 45683 00001151 56                      	push	si
 45684 00001152 57                      	push	di
 45685                                  
 45686                                  	; 19/09/2023
 45687                                  	;lds	si,[cs:LowMemory]	; Compare the 4 words at 0000:0080
 45688                                  	;les	di,[cs:HighMemory]	; with the 4 at FFFF:0090
 45689                                  
 45690 00001153 31FF                    	xor	di,di
 45691 00001155 8EC7                    	mov	es,di
 45692 00001157 4F                      	dec	di
 45693 00001158 BE9000                  	mov	si,90h	; 0FFFFh:0090h	; HighMemory
 45694 0000115B 8EDF                    	mov	ds,di
 45695 0000115D BF8000                  	mov	di,80h ; 0000h:0080h	; LowMemory
 45696                                  	
 45697 00001160 B90400                  	mov	cx,4
 45698 00001163 FC                      	cld
 45699 00001164 F3A7                    	repe    cmpsw
 45700                                  
 45701 00001166 7407                    	jz	short EA20_OFF
 45702                                  EA20_RET:
 45703 00001168 5F                      	pop	di
 45704 00001169 5E                      	pop	si
 45705 0000116A 59                      	pop	cx
 45706 0000116B 07                      	pop	es
 45707 0000116C 1F                      	pop	ds
 45708 0000116D 9D                      	popf
 45709 0000116E C3                      	retn
 45710                                  
 45711                                  EA20_OFF:
 45712                                  	; We are going to do the XMS call on the DOS's AuxStack.
 45713                                  	; NOTE: ints are disabled at this point.
 45714                                  
 45715 0000116F 53                      	push	bx
 45716 00001170 50                      	push	ax
 45717                                  
 45718 00001171 8CD0                    	mov	ax,ss			; save user's stack pointer
 45719 00001173 2EA3[6C10]              	mov	[cs:SS_Save],ax
 45720 00001177 2E8926[6E10]            	mov	[cs:SP_Save],sp
 45721 0000117C 8CC8                    	mov	ax,cs
 45722 0000117E 8ED0                    	mov	ss,ax
 45723 00001180 BC[A007]                	mov	sp,AUXSTACK
 45724                                  					; ss:sp -> DOSDATA:AuxStack
 45725                                  	;mov	ah,XMM_LOCAL_ENABLE_A20
 45726 00001183 B405                    	mov	ah,5
 45727 00001185 2EFF1E[4911]            	call	far [cs:XMMcontrol]
 45728 0000118A 09C0                    	or	ax,ax
 45729 0000118C 740F                    	jz	short XMMerror		; AX = 0 fatal error
 45730                                  
 45731 0000118E 2EA1[6C10]              	mov	ax,[cs:SS_Save]		; restore user stack
 45732 00001192 8ED0                    	mov	ss,ax
 45733 00001194 2E8B26[6E10]            	mov	sp,[cs:SP_Save]
 45734                                  
 45735 00001199 58                      	pop	ax
 45736 0000119A 5B                      	pop	bx
 45737                                  
 45738 0000119B EBCB                    	jmp	short EA20_RET
 45739                                  
 45740                                  XMMerror:				; M006 - Start
 45741 0000119D B40F                    	mov	ah,0Fh			; get video mode
 45742 0000119F CD10                    	int	10h
 45743 000011A1 3C07                    	cmp	al,7			; Q: are we an MDA
 45744 000011A3 7406                    	je	short XMMcont			; Y: do not change mode
 45745 000011A5 30E4                    	xor	ah,ah ; 0			; set video mode
 45746 000011A7 B002                    	mov	al,02h			; 80 X 25 text
 45747 000011A9 CD10                    	int	10h
 45748                                  XMMcont:
 45749 000011AB B405                    	mov	ah,05h			; set display page
 45750 000011AD 30C0                    	xor	al,al			; page 0
 45751 000011AF CD10                    	int	10h
 45752                                  	
 45753 000011B1 BE[8E12]                	mov	si,XMMERRMSG
 45754 000011B4 0E                      	push	cs
 45755 000011B5 1F                      	pop	ds
 45756 000011B6 FC                      	cld				; clear direction flag
 45757                                  XMMprnt:
 45758 000011B7 AC                      	lodsb
 45759 000011B8 3C24                    	cmp	al,'$'			; indicates end of XMMERRMSG
 45760 000011BA 7409                    	jz	short XMMStall		; function 0Eh	
 45761 000011BC B40E                    	mov	ah,0Eh
 45762 000011BE BB0700                  	mov	bx,7
 45763 000011C1 CD10                    	int	10h
 45764 000011C3 EBF2                    	jmp	short XMMprnt
 45765                                  
 45766                                  XMMStall:
 45767 000011C5 FB                      	sti				; allow the user to warm boot
 45768 000011C6 EBFD                    	jmp	short XMMStall		; M006 - End
 45769                                  
 45770                                  ;---------------------------------------------------------------------------
 45771                                  
 45772                                  ; 27/04/2019 - Retro DOS v4.0
 45773                                  
 45774                                  ; retrodos4.s ; offset 0Ch in BIOS segment (0070h)
 45775                                  ALTAH	equ 0Ch
 45776                                  
 45777                                  ;This has been put in for WIN386 2.XX support. The format of the instance 
 45778                                  ;table was different for this. Segments will be patched in at init time.
 45779                                  
 45780                                  OldInstanceJunk:
 45781 000011C8 7000                    	dw	70h	;segment of BIOS
 45782 000011CA 0000                    	dw	0	;indicate stacks in SYSINIT area
 45783 000011CC 0600                    	dw	6	;5 instance items
 45784                                  
 45785                                  	;dw	0,offset dosdata:contpos, 2
 45786                                  	;dw	0,offset dosdata:bcon, 4
 45787                                  	;dw	0,offset dosdata:carpos,106h
 45788                                  	;dw	0,offset dosdata:charco, 1
 45789                                  	;dw	0,offset dosdata:exec_init_sp, 34               ;M032
 45790                                  	;dw	070h,offset BData:altah, 1	 ; altah byte in bios
 45791                                  
 45792 000011CE 0000[2200]0200          	dw	0,CONTPOS,2
 45793 000011D4 0000[3200]0400          	dw	0,BCON,4
 45794 000011DA 0000[F901]0601          	dw	0,CARPOS,106h
 45795 000011E0 0000[0003]0100          	dw	0,CHARCO,1
 45796 000011E6 0000[C00F]2200          	dw	0,exec_init_SP,34
 45797 000011EC 70000C000100            	dw	70h,ALTAH,1	; altah byte in bios
 45798                                  
 45799                                  ;---------------------------------------------------------------------------
 45800                                  
 45801                                  ; M021-
 45802                                  ;
 45803                                  ; DosHasHMA - This flag is set by seg_reinit when the DOS actually
 45804                                  ; 	takes control of the HMA. When running, this word is a reliable
 45805                                  ;	indicator that the DOS is actually using HMA. You can't just use
 45806                                  ;	CS, because ROMDOS uses HMA with CS < F000.
 45807                                  
 45808                                  DosHasHMA:
 45809 000011F2 00                      	db	0
 45810                                  FixExePatch:
 45811 000011F3 0000                    	dw	0		; M012
 45812                                  
 45813                                  ; 28/12/2022 - Retro DOS v4.1
 45814                                  ;RationalPatchPtr:
 45815                                  ;	dw	0		; M012
 45816                                  
 45817                                  ; End M021
 45818                                  
 45819                                  ;---------------------------------------------------------------------------
 45820                                  
 45821                                  ; 28/12/2022 - Retro DOS v4.1
 45822                                  %if 0
 45823                                  
 45824                                  ; M020 Begin
 45825                                  
 45826                                  RatBugCode:	; proc	far
 45827                                  	push	cx
 45828                                  	mov	cx,[10h]
 45829                                  rbc_loop:
 45830                                  	;loop	$
 45831                                  	loop	rbc_loop
 45832                                  	pop	cx
 45833                                  	retf
 45834                                  		
 45835                                  ; M020 End
 45836                                  
 45837                                  %endif
 45838                                  
 45839                                  ;---------------------------------------------------------------------------
 45840                                  	
 45841                                  UmbSave1:
 45842                                  	;db	11 dup (?)	; M023
 45843 000011F5 00<rep Bh>              	times	11 db 0	
 45844                                  
 45845                                  ; DOSDATA:122Ah
 45846                                  
 45847                                  Mark3:	; label byte
 45848                                  
 45849                                  ;IF2
 45850                                  ;	IF ((OFFSET MARK3) GT (OFFSET COUNTRY_CDPG) )
 45851                                  ;		%OUT !DATA CORRUPTION!MARK3 OFFSET TOO BIG. RE-ORGANIZE DATA.
 45852                                  ;	ENDIF
 45853                                  ;ENDIF
 45854                                  
 45855                                  ;############################################################################
 45856                                  ;
 45857                                  ; ** HACK FOR DOS 4.0 REDIR **
 45858                                  ;
 45859                                  ; The dos 4.X redir requires that country_cdpg is at offset 0122ah. Any new
 45860                                  ; data variable that is to be added to DOSDATA must go in between Mark3
 45861                                  ; COUNTRY_CDPG if it can. 
 45862                                  ;
 45863                                  ; MARK3 SHOULD NOT BE > 122AH 
 45864                                  ;
 45865                                  ; As of 9/6/90, this area is FULL!
 45866                                  ;
 45867                                  ;############################################################################
 45868                                   
 45869                                  	;ORG	0122Ah
 45870                                  
 45871                                  ; DOSDATA:122Ah (MSDOS 6.21, MSDOS.SYS)
 45872                                  
 45873                                  ; The following table is used for DOS 3.3
 45874                                  ;DOS country and code page information is defined here for DOS 3.3.
 45875                                  ;The initial value for ccDosCountry is 1 (USA).
 45876                                  ;The initial value for ccDosCodepage is 850.
 45877                                  
 45878                                  ; country and code page information
 45879                                  ; ---------------------------------------------------------------------------
 45880                                  COUNTRY_CDPG:	; label  byte
 45881 00001200 0000000000000000        	db   0,0,0,0,0,0,0,0		; reserved words
 45882 00001208 5C434F554E5452592E-     	db   '\COUNTRY.SYS',0		; path name of country.sys
 45882 00001211 53595300           
 45883                                  	;db   51 dup (?)
 45884 00001215 00<rep 33h>             	times 51 db 0
 45885                                  ; ------------------------------------------------<MSKK01>-------------------
 45886                                  ;ifdef	DBCS
 45887                                  ;  ifdef JAPAN
 45888                                  ;	dw   932			; system code page id (JAPAN)
 45889                                  ;  endif
 45890                                  ;  ifdef TAIWAN
 45891                                  ;	dw   938			; system code page id (TAIWAN)
 45892                                  ;  endif
 45893                                  ;  ifdef KOREA
 45894                                  ;	dw   934			; system code page id (KOREA IBM)
 45895                                  ;  endif
 45896                                  ;else
 45897 00001248 B501                    	dw   437			; system code page id
 45898                                  ;endif
 45899                                  ; ------------------------------------------------<MSKK01>-------------------
 45900 0000124A 0600                    	dw   6				; number of entries
 45901 0000124C 02                      	db   SetUcase  ; 2		; Ucase type
 45902 0000124D [AD0A]                  	dw   UCASE_TAB			;pointer to upper case table
 45903 0000124F 0000                    	dw   0				; segment of poiter
 45904 00001251 04                      	db   SetUcaseFile  ; 4		; Ucase file char type
 45905 00001252 [2F0B]                  	dw   FILE_UCASE_TAB 		;pointer to file upper case table
 45906 00001254 0000                    	dw   0				; segment of poiter
 45907 00001256 05                      	db   SetFileList ; 5		; valid file chars type
 45908 00001257 [B10B]                  	dw   FILE_CHAR_TAB 		;pointer to valid file char tab
 45909 00001259 0000                    	dw   0				; segment of poiter
 45910 0000125B 06                      	db   SetCollate	; 6		; collate type
 45911 0000125C [E10B]                  	dw   COLLATE_TAB		;pointer to collate table
 45912 0000125E 0000                    	dw   0				; segment of poiter
 45913 00001260 07                      	db   SetDBCS	; 7		;AN000; DBCS Ev			2/12/KK
 45914 00001261 [E30C]                  	dw   DBCS_TAB			;AN000;pointer to DBCS Ev table	2/12/KK
 45915 00001263 0000                    	dw   0				;AN000; segment of pointer	2/12/KK
 45916 00001265 01                      	db   SetCountryInfo  ; 1	; country info type
 45917 00001266 2600                    	dw   NEW_COUNTRY_SIZE		; extended country info size
 45918                                  ; ------------------------------------------------<MSKK01>-------------------
 45919                                  ;ifdef	DBCS
 45920                                  ;	...... 
 45921                                  ;else
 45922 00001268 0100                    	dw   1				; USA country id
 45923 0000126A B501                    	dw   437			; USA system code page id
 45924 0000126C 0000                    	dw   0 				; date format
 45925 0000126E 2400000000              	db   '$',0,0,0,0		; currency symbol
 45926 00001273 2C00                    	db   ',',0			; thousand separator
 45927 00001275 2E00                    	db   '.',0			; decimal separator
 45928 00001277 2D00                    	db   '-',0			; date separator
 45929 00001279 3A00                    	db   ':',0			; time separator
 45930 0000127B 00                      	db   0				; currency format flag
 45931 0000127C 02                      	db   2				; # of digits in currency
 45932 0000127D 00                      	db   0 				; time format
 45933 0000127E [F50C]                  	dw   MAP_CASE			; mono case routine entry point
 45934 00001280 0000                    	dw   0				; segment of entry point
 45935 00001282 2C00                    	db   ',',0			; data list separator
 45936 00001284 000000000000000000-     	dw   0,0,0,0,0			; reserved
 45936 0000128D 00                 
 45937                                  ;endif
 45938                                  ; ------------------------------------------------<MSKK01>-------------------
 45939                                  
 45940                                  ; 27/04/2019 - Retro DOS v4.0
 45941                                  
 45942                                  ;include msdos.cl2			; XMMERRMSG
 45943                                  
 45944                                  ; DOSDATA:122Ah (MSDOS 6.21, MSDOS.SYS)
 45945                                  
 45946                                  XMMERRMSG:
 45947 0000128E 0D0A                    	db	0Dh,0Ah
 45948 00001290 413230204861726477-     	db	'A20 Hardware Error',0Dh,0Ah,'$'
 45948 00001299 617265204572726F72-
 45948 000012A2 0D0A24             
 45949                                  
 45950                                  ; DOSDATA ends
 45951                                  
 45952                                  ; 05/11/2022
 45953                                  ;----------------------------------------------------------------------------
 45954                                  ; End of MSDOS 5.0 MSDOS.SYS /// Retro DOS v4.0 (2022) - 05/11/2022
 45955                                  ;----------------------------------------------------------------------------
 45956                                  
 45957                                  ; 28/12/2022 - Retro DOS v4.1
 45958                                  ; (windows 3.1 and Rational Extender patches are removed/disabled)
 45959                                  ; (Windows 3.1 does not use the patches below if DOS version is MSDOS 5.0)
 45960                                  ;----------------------------------------------------------------------------
 45961                                  %if 0
 45962                                  
 45963                                  ;----------------------------------------------------------------------------
 45964                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45965                                  
 45966                                  ;============================================================================
 45967                                  ; WPATCH.INC (MSDOS 6.0, 1991)  ;;; Windows 3.1 patches ;;;
 45968                                  ;============================================================================
 45969                                  ; 27/04/2019 - Retro DOS 4.0
 45970                                  
 45971                                  ;DOSDATA Segment
 45972                                  
 45973                                  ; DOSDATA:12CFh (MSDOS 6.21, MSDOS.SYS)
 45974                                  
 45975                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45976                                  ; DOSDATA:12CFh (MSDOS 5.0, MSDOS.SYS)
 45977                                  
 45978                                  ; first and second DOS patches
 45979                                  ;	Non-console device read/write (system calls 3Fh and 40h)
 45980                                  ;
 45981                                  ; Code in disk.asm, 2 locations, one for read, one for write
 45982                                  ;	DVRDLP:
 45983                                  ;	DVWRTLP:
 45984                                  ;
 45985                                  ;
 45986                                  ; 036h	lds	si,SS:[????]				  ; ThisSFT
 45987                                  ;	lds	si,si+7 				  ; sf_devptr
 45988                                  ; 0E8h	call	????		<- "simulate" int28 event ; DSKSTATCHK
 45989                                  
 45990                                  DOSP1_ID:	db	036h,0C5h,036h
 45991                                  DOSP1_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 45992                                  DOSP1_ID_LEN	equ	$-DOSP1_ID
 45993                                  
 45994                                  		db	90h, 90h
 45995                                  
 45996                                  DOSP12_ID:	db	036h,0C5h,036h
 45997                                  DOSP12_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 45998                                  DOSP12_ID_LEN	equ	$-DOSP1_ID
 45999                                  
 46000                                  ; DOSDATA:12E3h
 46001                                  
 46002                                  ; Third/Fourth DOS patch - System call 3Fh (Read) from console
 46003                                  ;
 46004                                  ; Code in disk.asm, 1 location
 46005                                  ;	GETBUF:
 46006                                  ;
 46007                                  ; 051h	push	cx	<- begin special int28 mode
 46008                                  ;	push	es
 46009                                  ;	push	di
 46010                                  ;	mov	dx,???? ; offset dosgroup:CONBUF
 46011                                  ;	call	????	; $STD_CON_STRING_INPUT
 46012                                  ;	pop	di
 46013                                  ;	pop	es
 46014                                  ; 059h	pop	cx	<- end special int28 mode
 46015                                  
 46016                                  DOSP3_ID:	db	051h,006h,057h,0BAh
 46017                                  DOSP3_CONBUF:	db	029h,002h,0E8h
 46018                                  DOSP3_ID_LEN	equ	$-DOSP3_ID
 46019                                  		db	09Ah,0E3h,05Fh,007h	; ???? , pop di, pop es
 46020                                  DOSP4_ID:	db	059h			; pop cx
 46021                                  DOSP4_ID_OFF	equ	(DOSP4_ID - DOSP3_ID)
 46022                                  	
 46023                                  ; DOSDATA:12EFh
 46024                                  
 46025                                  ; Fifth DOS patch - System call 40h (Write) to console
 46026                                  ;
 46027                                  ; Code in disk.asm, 1 location
 46028                                  ;
 46029                                  ;		push	cx
 46030                                  ;      WRCONLP: lodsb
 46031                                  ;		cmp	al,1Ah
 46032                                  ;		jz	????
 46033                                  ;		call	????	<- "simulate" int28 event
 46034                                  ;		loop	WRCONLP
 46035                                  ;      CONEOF:	pop	ax
 46036                                  
 46037                                  DOSP5_ID:	db	051h			; push cx
 46038                                  		db	0ACh,03Ch,01Ah,074h,005h
 46039                                  		db	0E8h			; call
 46040                                  DOSP5_ID_LEN	equ	$-DOSP5_ID
 46041                                  
 46042                                  ; DOSDATA:12F6h
 46043                                  
 46044                                  ; Seventh DOS patch - System call entry, patch USER_ID with VMid for share
 46045                                  ;
 46046                                  ; Code in disp.asm, 1 location
 46047                                  ;
 46048                                  ;
 46049                                  ;	mov [SaveDS],ds
 46050                                  ;	mov [SaveBX],bx
 46051                                  ;	mov bx,cs
 46052                                  ;	mov ds,bx
 46053                                  ;	inc [indos]
 46054                                  ;	xor ax,ax
 46055                                  ;	mov [USER_ID],AX	<- Patch to set USER_ID to VMID
 46056                                  
 46057                                  DOSP7_ID:	db	02Eh,08Ch,01Eh
 46058                                  DOSP7_SAVEDS:	db	07Eh,05h		; mov [SaveDS],ds
 46059                                  		db	02Eh,089h,01Eh
 46060                                  DOSP7_SAVEBX:	db	07Ch,05h		; mov [SaveBX],bx
 46061                                  		db	08Ch,0CBh		; mov bx,cs
 46062                                  		db	08Eh,0DBh		; mov ds,bx
 46063                                  		db	0FEh,006h
 46064                                  DOSP7_INDOS:	db	0CFh,002h		; inc [indos]
 46065                                  		db	033h,0C0h		; xor ax,ax
 46066                                  DOSP7_ID_LEN	equ	$-DOSP7_ID
 46067                                  
 46068                                  ; DOSDATA:130Ah
 46069                                  
 46070                                  ; Eighth DOS patch - OWNER check in handle calls. For share, need to NOP test
 46071                                  ;
 46072                                  ; Code in handle.asm, 1 location in routine CheckOwner
 46073                                  ;
 46074                                  ;
 46075                                  ;
 46076                                  ;	push	ax
 46077                                  ;	mov	ax,ss:[USER_ID]     <- patch to XOR AX,AX to set zero
 46078                                  ;	cmp	ax,es:[di.sf_UID]   <- NOP
 46079                                  ;	pop	ax
 46080                                  ;	jz	????
 46081                                  
 46082                                  DOSP8_ID:	db	050h			; push ax
 46083                                  		db	036h,0A1h
 46084                                  DOSP8_USER_ID:	db	0EAh,002h		; mov  ax,ss:[USER_ID]
 46085                                  		db	026h,03Bh,045h		; cmp  ax,es:[di+2F]
 46086                                  DOSP8_ID_LEN	equ	$-DOSP8_ID
 46087                                  		db	02Fh,058h		; pop  ax
 46088                                  
 46089                                  ; DOSDATA:1314h
 46090                                  
 46091                                  ; 10th, 11th, 12th DOS patch - System call 3Fh (Read) in raw mode
 46092                                  ;
 46093                                  ;   Take RAW read to STDIN SFT and turn it into a polling loop doing
 46094                                  ;   a yeild when a character is not ready to be read.
 46095                                  ;
 46096                                  ; Code in disk.asm, 3 locations
 46097                                  ;
 46098                                  ;   DVRDRAW:
 46099                                  ;	    PUSH    ES
 46100                                  ;	    POP     DS
 46101                                  ;   ReadRawRetry:				<- Patch 10
 46102                                  ;	    MOV     BX,DI
 46103                                  ;	    XOR     AX,AX			<- Reenter #2
 46104                                  ;	    MOV     DX,AX
 46105                                  ;	    call    SETREAD
 46106                                  ;	    PUSH    DS				<- Reenter #1
 46107                                  ;	    LDS     SI,[THISSFT]
 46108                                  ;	    call    DEVIOCALL
 46109                                  ;	    MOV     DX,DI
 46110                                  ;	    MOV     AH,86H
 46111                                  ;	    MOV     DI,[DEVCALL.REQSTAT]
 46112                                  ;	    TEST    DI,STERR
 46113                                  ;	    JZ	    CRDROK
 46114                                  ;	    call    CHARHARD
 46115                                  ;	    MOV     DI,DX
 46116                                  ;	    OR	    AL,AL
 46117                                  ;	    JZ	    CRDROK
 46118                                  ;	    CMP     AL,3
 46119                                  ;	    JZ	    CRDFERR
 46120                                  ;	    POP     DS
 46121                                  ;	    JMP     ReadRawRetry
 46122                                  ;
 46123                                  ;   CRDFERR:
 46124                                  ;	    POP     DI				<- Patch 11
 46125                                  ;   DEVIOFERR:
 46126                                  ;	    LES     DI,[THISSFT]
 46127                                  ;	    jmp     SET_ACC_ERR_DS
 46128                                  ;
 46129                                  ;   CRDROK:
 46130                                  ;	    POP     DI				<- Patch 12
 46131                                  ;	    MOV     DI,DX
 46132                                  ;	    ADD     DI,[CALLSCNT]
 46133                                  ;	    JMP     SHORT ENDRDDEVJ3
 46134                                  
 46135                                  DOSP10_ID:		db	006H,01FH
 46136                                  DOSP10_LOC_OFFSET	equ	$-DOSP10_ID
 46137                                  DOSP10_LOC:		db	08BH,0DFH
 46138                                  DOSP10_REENT2_OFFSET	equ	$-DOSP10_LOC
 46139                                  			db	033H,0C0H,08BH,0D0H,0E8H
 46140                                  DOSP10_ID_LEN		equ	$-DOSP10_ID
 46141                                  			db	0DFH,00EH
 46142                                  DOSP10_REENT1_OFFSET	equ	$-DOSP10_LOC
 46143                                  			db	01EH,036H,0C5H,036H,036H,005H,0E8H,0AFH,00EH
 46144                                  			db	08BH,0D7H,0B4H,086H,036H,08BH,03EH
 46145                                  DOSP10_PACKVAL_OFFSET	equ	$-DOSP10_ID
 46146                                  			db	009H,003H
 46147                                  			db	0F7H,0C7H,000H,080H,074H,019H,0E8H,047H,017H
 46148                                  			db	08BH,0FAH,00AH,0C0H,074H,010H,03CH,003H,074H,003H
 46149                                  			db	01FH,0EBH,0CFH
 46150                                  DOSP11_LOC_OFFSET	equ	$-DOSP10_ID
 46151                                  			db	05FH
 46152                                  DOSP11_REENT_OFFSET	equ	$-DOSP10_LOC
 46153                                  			db	036H,0C4H,03EH,036H,005H,0E9H,0A1H,004H
 46154                                  
 46155                                  DOSP12_LOC_OFFSET	equ	$-DOSP10_ID
 46156                                  			db	05FH,08BH,0FAH
 46157                                  ; DOSDATA:1353h
 46158                                  
 46159                                  ; 13th DOS patch - Actually a SYSINIT patch. Patches the stack fault code
 46160                                  ;		which prints the fatal stack fault error on DOS >= 3.20.
 46161                                  ;
 46162                                  ;	    Sets focus to current VM so user can see fatal message.
 46163                                  ;
 46164                                  ;
 46165                                  ;	l0: lodsb		<- Setfocus here
 46166                                  ;	    cmp al, '$'
 46167                                  ;	    je l1
 46168                                  ;	    mov bl, 7
 46169                                  ;	    mov ah, 0Eh
 46170                                  ;	    int 10h
 46171                                  ;	    jmp l0
 46172                                  ;	l1: jmp $
 46173                                  
 46174                                  DOSP13_ID:	db	0ACh			; l0: lodsb
 46175                                  		db	03Ch,024h		;     cmp al, '$'
 46176                                  		db	074h,008h		;     je l1
 46177                                  		db	0B3h,007h		;     mov bl, 7
 46178                                  		db	0B4h,00Eh		;     mov ah, 0Eh
 46179                                  		db	0CDh,010h		;     int 10h
 46180                                  		db	0EBh,0F3h		;     jmp l0
 46181                                  		db	0EBh,0FEh		; l1: jmp $
 46182                                  DOSP13_ID_LEN	equ	$-DOSP13_ID
 46183                                  
 46184                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 46185                                  ; DOSDATA:1362h (MSDOS 5.0 MSDOS.SYS)
 46186                                  
 46187                                  ; 06/12/2022
 46188                                  ;DOSDATASIZE	equ  $ - DOSDATASTART ; 4962 bytes (1362h)
 46189                                  
 46190                                  ; DOSDATA ends
 46191                                  
 46192                                  ;============================================================================
 46193                                  ; MPATCH.ASM (MSDOS 6.0, 1993)
 46194                                  ;============================================================================
 46195                                  ; 27/04/2019 - Retro DOS 4.0
 46196                                  
 46197                                  ;mpatch.asm -- holds data patch location for callouts 
 46198                                  ; -- allocate cluster in rom.asm
 46199                                  ;
 46200                                  ; This area is pointed to by OffsetMagicPatch[609h] in fixed DOS data.
 46201                                  ; Currently, this location is used only by magicdrv.sys's patch to
 46202                                  ; cluster allocation, however it can be expanded to be used by other
 46203                                  ; patches. This is important since we have an easy-access pointer to
 46204                                  ; this location in OffsetMagicPatch. Magicdrv.sys is guaranteed to
 46205                                  ; only patch out a far call/retf, so any space after that could be
 46206                                  ; used as a patch by using OffsetMagicPatch+6. See rom.asm on how
 46207                                  ; to call out here.
 46208                                  ;
 46209                                  ; Currently, we allocate only the minimum space required for the 6
 46210                                  ; byte magicdrv patch, so if you change the dos data, you may want
 46211                                  ; to reserve space here if your new data will be position dependent
 46212                                  ; and would prohibit growing of this table.
 46213                                  ;       
 46214                                  ;history	-	created 8-7-92 by scottq
 46215                                  ;		-	added Rational386PatchPtr 2-1-93 by jimmat
 46216                                  ;
 46217                                  ;Exported Functions
 46218                                  ;==================
 46219                                  ;MagicPatch     -       callout patched by magidrv.sys for cluster allocations
 46220                                  
 46221                                  ; DosData Segment
 46222                                  
 46223                                  ; DOSDATA:1362h (MSDOS 6.21, MSDOS.SYS)
 46224                                  
 46225                                  ; ---------------------------------------------------------------------------
 46226                                  
 46227                                  ; Rational386PatchPtr points to either a RET instruction (80286 or less) or
 46228                                  ; a routine to fix buggy versions of the Rational DOS Extender (80386 or
 46229                                  ; greater). Added to this file because it needed to be somewhere and is
 46230                                  ; 'patch' related.
 46231                                  
 46232                                  Rational386PatchPtr:
 46233                                  	dw	0	; points to patch routine or RET instr.
 46234                                  ; ---------------------------------------------------------------------------
 46235                                  
 46236                                  MagicPatch:
 46237                                  ;MagicPatch proc far
 46238                                          retf            ;default is to just return to allocate
 46239                                          nop             ;however, this code will be patched
 46240                                          nop             ;by magicdrv.sys to
 46241                                          nop             ; call far ?:?     
 46242                                          nop             ; retf or perhaps just jmp far
 46243                                          nop             ;retf/nop take one byte, so we need six instructions
 46244                                                          ;for 6 byte patch
 46245                                  ;MagicPatch endp
 46246                                  
 46247                                  ; ---------------------------------------------------------------------------
 46248                                  
 46249                                  ;DosData Ends
 46250                                  
 46251                                  ; DOSDATA:136Ah
 46252                                  
 46253                                  ;----------------------------------------------------------------------------
 46254                                  
 46255                                  ;DOSDATALAST SEGMENT
 46256                                  
 46257                                  ; 29/04/2019 - Retro DOS v4.0
 46258                                  
 46259                                  ;----------------------------------------------------------------------------
 46260                                  ; 25/05/2019 - Retro DOS v4.0 Modification (paragraph alignment)
 46261                                  
 46262                                  ;db 0,1,12,64,19,0 ; ! Magic numbers !
 46263                                  
 46264                                  ;align 16
 46265                                  
 46266                                  ; !!! DOSDATA:1370h ; Retro DOS v4.0 only!
 46267                                  
 46268                                  ;----------------------------------------------------------------------------
 46269                                  
 46270                                  %endif	; 05/11/2022
 46271                                  
 46272                                  ; 05/12/2022
 46273                                  ;MSDAT001E:	; label byte
 46274                                  
 46275                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 46276                                  DOSDATAEND equ $
 46277                                  DOSDATASIZE equ DOSDATAEND - DOSDATASTART ; = 4962 for MSDOS 5.0 MSDOS.SYS
 46278                                  MSDAT001E equ DOSDATAEND - DOSDATASTART
 46279                                  
 46280                                  ;DOSDATALAST ENDS
 46281                                  
 46282                                  ; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 5.0 KERNEL via NASM)
 46283                                  ; DECEMBER 2022, ISTANBUL - TURKIYE.
 46284                                  ;============================================================================
 46285                                  ;	END
 46286                                  ;============================================================================
 46287                                  ; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 6.21 KERNEL via NASM)
 46288                                  ; -----------------------------
 46289                                  ; MAY 2019, ISTANBUL - TURKIYE.
