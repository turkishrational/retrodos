BIOSDATA:0000 ;
BIOSDATA:0000 ;	+-------------------------------------------------------------------------+
BIOSDATA:0000 ;	|   This file has been generated by The	Interactive Disassembler (IDA)	  |
BIOSDATA:0000 ;	|	    Copyright (c) 2013 Hex-Rays, <support@hex-rays.com>		  |
BIOSDATA:0000 ;	|		       Licensed	to: Freeware version			  |
BIOSDATA:0000 ;	+-------------------------------------------------------------------------+
BIOSDATA:0000 ;
BIOSDATA:0000 ;	Input MD5   : 2CC640D7136F5626F0CD56F6A03C7A92
BIOSDATA:0000
BIOSDATA:0000 ;	---------------------------------------------------------------------------
BIOSDATA:0000 ;	File Name   : C:\Users\erdogan.tan\Desktop\IO621SYS.BIN
BIOSDATA:0000 ;	Format	    : Binary file
BIOSDATA:0000 ;	Base Address: 0000h Range: 0000h - 98D0h Loaded	length:	98D0h
BIOSDATA:0000
BIOSDATA:0000		      .386
BIOSDATA:0000		      .model flat
BIOSDATA:0000
BIOSDATA:0000 ;	===========================================================================
BIOSDATA:0000
BIOSDATA:0000 ;	Segment	type: Regular
BIOSDATA:0000 BIOSDATA	      segment byte public 'BIOSDATA' use16
BIOSDATA:0000		      assume cs:BIOSDATA
BIOSDATA:0000		      assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
BIOSDATA:0000
BIOSDATA:0000 BData_start:			      ;	...
BIOSDATA:0000		      jmp     init
BIOSDATA:0000 ;	---------------------------------------------------------------------------
BIOSDATA:0003 DosDataSg	      dw 0		      ;	...
BIOSDATA:0005 bios_i2f	      db 0EAh		      ;	far jump to int_2f (segment may	not be at 70h)
BIOSDATA:0006		      dw offset	int_2f
BIOSDATA:0008		      dw 70h
BIOSDATA:000A romstartaddr    dw 0		      ;	The start address for the romfind routines
BIOSDATA:000C altah	      db 0		      ;	...
BIOSDATA:000C					      ;	special	key handling
BIOSDATA:000D inHMA	      db 0		      ;	...
BIOSDATA:000D					      ;	flag indicates we're running from HMA
BIOSDATA:000E xms	      dd 0		      ;	...
BIOSDATA:000E					      ;	entry point to xms if above is true
BIOSDATA:0012 ptrsav	      dd 0		      ;	...
BIOSDATA:0012					      ;	pointer	save
BIOSDATA:0012					      ;	This variable holds the	pointer	to
BIOSDATA:0012					      ;	the Request Header passed by a program wishing
BIOSDATA:0012					      ;	to use a device	driver.	When the strategy routine
BIOSDATA:0012					      ;	is called it puts the address of the Request header
BIOSDATA:0012					      ;	in this	variable and returns.
BIOSDATA:0016 auxbuf	      db 4 dup(0)	      ;	...
BIOSDATA:0016					      ;	set of 1 byte buffers for com 1,2,3, and 4
BIOSDATA:001A zeroseg	      dw 0		      ;	...
BIOSDATA:001A					      ;	easy way to load segment registers with	zero
BIOSDATA:001C i13_ds	      dw 0		      ;	...
BIOSDATA:001C					      ;	ds register for	int 13h	call through
BIOSDATA:001E prevoper	      dw 0		      ;	...
BIOSDATA:001E					      ;	holds int 13h request (i.e. register ax).
BIOSDATA:0020 number_of_sec   db 0		      ;	...
BIOSDATA:0020					      ;	holds number of	secs. to read on an ecc	error
BIOSDATA:0021 auxnum	      dw 0		      ;	...
BIOSDATA:0021					      ;	which aux device was requested
BIOSDATA:0023 res_dev_list    dw offset	auxdev2	      ;	...
BIOSDATA:0023					      ;	CONHeader ;  Device Header for the CON Device Driver
BIOSDATA:0025		      dw 70h
BIOSDATA:0027		      dw 8013h
BIOSDATA:0029		      dw offset	strategy
BIOSDATA:002B		      dw offset	con_entry
BIOSDATA:002D		      db 'CON     '
BIOSDATA:0035 auxdev2	      dw offset	prndev2	      ;	...
BIOSDATA:0037		      dw 70h
BIOSDATA:0039		      dw 8000h
BIOSDATA:003B		      dw offset	strategy
BIOSDATA:003D		      dw offset	aux0_entry
BIOSDATA:003F asc_3F	      db 'AUX     '           ; ...
BIOSDATA:0047 prndev2	      dw offset	timdev	      ;	...
BIOSDATA:0049		      dw 70h
BIOSDATA:004B		      dw 0A0C0h		      ;	...
BIOSDATA:004D		      dw offset	strategy
BIOSDATA:004F		      dw offset	prn0_entry    ;	...
BIOSDATA:0051		      db 'PRN     '           ; ...
BIOSDATA:0059 timdev	      dw offset	dskdev	      ;	...
BIOSDATA:005B		      dw 70h		      ;	...
BIOSDATA:005D		      dw 8008h
BIOSDATA:005F		      dw offset	strategy
BIOSDATA:0061		      dw offset	tim_entry
BIOSDATA:0063		      db 'CLOCK$  '           ; ...
BIOSDATA:006B dskdev	      dw offset	com1dev	      ;	...
BIOSDATA:006D		      dw 70h
BIOSDATA:006F		      dw 8C2h
BIOSDATA:0071		      dw offset	strategy
BIOSDATA:0073		      dw offset	dsk_entry
BIOSDATA:0075 drvmax	      db 4		      ;	...
BIOSDATA:0075					      ;	maximum	number of drives
BIOSDATA:0076 step_drv	      db 0FEh		      ;	...
BIOSDATA:0076					      ;	-2 ; last drive	accessed
BIOSDATA:0077 fhave96	      db 0		      ;	...
BIOSDATA:0077					      ;	flag to	indicate presence of 96tpi support
BIOSDATA:0078 single	      db 0		      ;	...
BIOSDATA:0078					      ;	used to	detect single drive systems
BIOSDATA:0079 fhavek09	      db 0		      ;	...
BIOSDATA:0079					      ;	indicates if this is a k09 or not
BIOSDATA:0079					      ;	 used by console driver.
BIOSDATA:007A fsetowner	      db 0		      ;	...
BIOSDATA:007A					      ;	= 1 if we are setting the owner	of a drive.
BIOSDATA:007A					      ;	 (examined by checksingle).
BIOSDATA:007B com1dev	      dw offset	lpt1dev	      ;	...
BIOSDATA:007B					      ;	Device Header for device "COM1"
BIOSDATA:007D		      dw 70h
BIOSDATA:007F		      dw 8000h
BIOSDATA:0081		      dw offset	strategy
BIOSDATA:0083		      dw offset	aux0_entry    ;	...
BIOSDATA:0085		      db 'COM1    '
BIOSDATA:008D lpt1dev	      dw offset	lpt2dev	      ;	...
BIOSDATA:008F		      dw 70h
BIOSDATA:0091		      dw 0A0C0h
BIOSDATA:0093		      dw offset	strategy
BIOSDATA:0095		      dw offset	prn1_entry
BIOSDATA:0097		      db 'LPT1    '
BIOSDATA:009F lpt2dev	      dw offset	lpt3dev	      ;	...
BIOSDATA:00A1		      dw 70h
BIOSDATA:00A3		      dw 0A0C0h		      ;	...
BIOSDATA:00A5		      dw offset	strategy
BIOSDATA:00A7		      dw offset	prn2_entry
BIOSDATA:00A9		      db 'LPT2    '
BIOSDATA:00B1		      db 0, 0, 0
BIOSDATA:00B4 Orig13	      dd 0		      ;	...
BIOSDATA:00B4					      ;	Orig13 needs to	be at offset 0B4h
BIOSDATA:00B4					      ;	 for the CMS floppy driver to work.
BIOSDATA:00B8 lpt3dev	      dw offset	com2dev	      ;	...
BIOSDATA:00B8					      ;	Device Header for device LPT3
BIOSDATA:00BA		      dw 70h
BIOSDATA:00BC word_BC	      dw 0A0C0h		      ;	...
BIOSDATA:00BE		      dw offset	strategy
BIOSDATA:00C0		      dw offset	prn3_entry
BIOSDATA:00C2		      db 'LPT3    '
BIOSDATA:00CA com2dev	      dw offset	com3dev	      ;	...
BIOSDATA:00CC		      dw 70h
BIOSDATA:00CE		      dw 8000h
BIOSDATA:00D0		      dw offset	strategy
BIOSDATA:00D2		      dw offset	aux1_entry
BIOSDATA:00D4		      db 'COM2    '
BIOSDATA:00DC com3dev	      dw offset	com4dev	      ;	...
BIOSDATA:00DE		      dw 70h
BIOSDATA:00E0		      dw 8000h
BIOSDATA:00E2		      dw offset	strategy
BIOSDATA:00E4		      dw offset	aux2_entry
BIOSDATA:00E6		      db 'COM3    '
BIOSDATA:00EE com4dev	      dw 0FFFFh		      ;	...
BIOSDATA:00F0		      dw 70h
BIOSDATA:00F2		      dw 8000h
BIOSDATA:00F4		      dw offset	strategy
BIOSDATA:00F6		      dw offset	aux3_entry
BIOSDATA:00F8		      db 'COM4    '
BIOSDATA:0100 RomVectors      db 10h		      ;	...
BIOSDATA:0101 Old10	      dd 0
BIOSDATA:0105		      db 13h
BIOSDATA:0106 Old13	      dd 0		      ;	...
BIOSDATA:010A		      db 15h
BIOSDATA:010B Old15	      dd 0		      ;	...
BIOSDATA:010F		      db 19h
BIOSDATA:0110 Old19	      dd 0
BIOSDATA:0114		      db 1Bh
BIOSDATA:0115 Old1B	      dd 0
BIOSDATA:0119 start_bds	      dw offset	bds1	      ;	...
BIOSDATA:0119					      ;	Start of linked	list of	BDS's
BIOSDATA:011B		      dw 70h		      ;	KERNEL_SEGMENT (BIOSDATA segment)
BIOSDATA:011D accesscount     db 0		      ;	...
BIOSDATA:011E tim_drv	      db 0FFh		      ;	...
BIOSDATA:011F medbyt	      db 0		      ;	...
BIOSDATA:0120 rflag	      db 2		      ;	...
BIOSDATA:0120					      ;	2 for read, 3 for write
BIOSDATA:0121 verify	      db 0		      ;	1 if verify after write
BIOSDATA:0122 seccnt	      dw 0		      ;	...
BIOSDATA:0124		      db 0		      ;	-- pad where hardnum was
BIOSDATA:0125 dsktnum	      db 1		      ;	...
BIOSDATA:0125					      ;	number of diskette drives
BIOSDATA:0126 motorstartup    db 0		      ;	...
BIOSDATA:0126					      ;	value from table
BIOSDATA:0127 settlecurrent   db 0		      ;	...
BIOSDATA:0127					      ;	value from table
BIOSDATA:0128 settleslow      db 0		      ;	...
BIOSDATA:0128					      ;	slow settle value
BIOSDATA:0129 nextspeed	      db 0		      ;	value of speed to be used
BIOSDATA:012A save_head_sttl  db 0		      ;	...
BIOSDATA:012A					      ;	used by	read_sector routine
BIOSDATA:012B save_eot	      db 0		      ;	...
BIOSDATA:012B					      ;	saved eot from the default DPT
BIOSDATA:012C eot	      db 9		      ;	...
BIOSDATA:012D dpt	      dd 0		      ;	...
BIOSDATA:012D					      ;	pointer	to Disk	Parameter Table
BIOSDATA:0131 cursec	      db 0		      ;	...
BIOSDATA:0131					      ;	current	sector
BIOSDATA:0132 curhd	      db 0		      ;	...
BIOSDATA:0132					      ;	current	head
BIOSDATA:0133 curtrk	      dw 0		      ;	...
BIOSDATA:0133					      ;	current	track
BIOSDATA:0135 spsav	      dw 0		      ;	...
BIOSDATA:0135					      ;	save the stack pointer
BIOSDATA:0137 formt_eot	      db 8		      ;	...
BIOSDATA:0137					      ;	eot used for format
BIOSDATA:0138 hdnum	      db 0		      ;	...
BIOSDATA:0138					      ;	head number
BIOSDATA:0139 trknum	      dw 0		      ;	...
BIOSDATA:0139					      ;	track being manipulated
BIOSDATA:013B gap_patch	      db 50h		      ;	...
BIOSDATA:013B					      ;	format gap patched into	dpt
BIOSDATA:013C errin	      db 0CCh		      ;	...
BIOSDATA:013C					      ;	disk errors returned from the IBM rom
BIOSDATA:013C					      ;	write fault
BIOSDATA:013D		      db 80h		      ;	no response
BIOSDATA:013E		      db 40h		      ;	seek failure
BIOSDATA:013F		      db 10h		      ;	bad crc
BIOSDATA:0140		      db 8		      ;	dma overrun
BIOSDATA:0141		      db 6		      ;	media change
BIOSDATA:0142		      db 4		      ;	sector not found
BIOSDATA:0143		      db 3		      ;	write attempt to write-protect disk
BIOSDATA:0144 lsterr	      db 0		      ;	...
BIOSDATA:0144					      ;	all other errors
BIOSDATA:0145 errout	      db 10		      ;	returned error codes corresponding to above
BIOSDATA:0145					      ;	 write	fault error
BIOSDATA:0146		      db 2		      ;	no response
BIOSDATA:0147		      db 6		      ;	seek failure
BIOSDATA:0148		      db 4		      ;	bad crc
BIOSDATA:0149		      db 4		      ;	dma overrun
BIOSDATA:014A		      db 15		      ;	invalid	media change
BIOSDATA:014B		      db 8		      ;	sector not found
BIOSDATA:014C		      db 0		      ;	write attempt to write-protect disk
BIOSDATA:014D		      db 12		      ;	general	error
BIOSDATA:014E disksector      db 512 dup(0)	      ;	...
BIOSDATA:014E					      ;	read in	boot sector here
BIOSDATA:034E bds1	      dw offset	bds2	      ;	...
BIOSDATA:034E					      ;	dword link to next structure
BIOSDATA:0350		      dw 70h
BIOSDATA:0352		      db 0		      ;	int 13h	drive number
BIOSDATA:0353		      db 0		      ;	logical	drive letter
BIOSDATA:0354 fdrive1	      dw 512		      ;	...
BIOSDATA:0354					      ;	physical sector	size in	bytes
BIOSDATA:0356		      db 0FFh		      ;	sectors/allocation unit
BIOSDATA:0357		      dw 1		      ;	reserved sectors for dos
BIOSDATA:0359		      db 2		      ;	no of file allocation tables
BIOSDATA:035A		      dw 64		      ;	number of root directory entries
BIOSDATA:035C		      dw 360		      ;	number of sectors (at 512 bytes	each)
BIOSDATA:035E		      db 0		      ;	media descriptor, initially 0
BIOSDATA:035F		      dw 2		      ;	number of fat sectors
BIOSDATA:0361		      dw 9		      ;	sector limit (sectors per track)
BIOSDATA:0363		      dw 1		      ;	head limit (number of heads - 1)
BIOSDATA:0365		      dd 0		      ;	hidden sector count
BIOSDATA:0369		      dd 0		      ;	number of sectors (32 bit)
BIOSDATA:036D fatsiz	      db 0		      ;	true =>	large fats (BDS.fatsiz)
BIOSDATA:036E opcnt1	      dw 0		      ;	open ref. count
BIOSDATA:0370		      db 3		      ;	form factor
BIOSDATA:0371 flags1	      dw 20h		      ;	various	flags
BIOSDATA:0373		      dw 40		      ;	number of cylinders
BIOSDATA:0375 recbpb1	      dw 512		      ;	recommended bps	for this drive
BIOSDATA:0377		      db 1
BIOSDATA:0378		      dw 1
BIOSDATA:037A		      db 2
BIOSDATA:037B		      dw 224		      ;	number of root directory entries
BIOSDATA:037D		      dw 360
BIOSDATA:037F		      db 0F0h		      ;	media descriptor, initially 0F0h
BIOSDATA:0380		      dw 2
BIOSDATA:0382		      dw 9
BIOSDATA:0384		      dw 2
BIOSDATA:0386		      dd 0
BIOSDATA:038A		      dd 0
BIOSDATA:038E		      db 6 dup(0)
BIOSDATA:0394		      db 0FFh		      ;	last track accessed on this drive
BIOSDATA:0395		      dw 0FFFFh		      ;	keep these two contiguous (?)
BIOSDATA:0397		      dw 0FFFFh
BIOSDATA:0399		      db 'NO NAME    ',0      ; volume id for this disk
BIOSDATA:03A5		      dd 0		      ;	current	volume serial from boot	record
BIOSDATA:03A9		      db 'FAT12   ',0         ; current file system id from boot record
BIOSDATA:03B2 bds2	      dw offset	bds3	      ;	...
BIOSDATA:03B4		      dw 70h
BIOSDATA:03B6		      db 0
BIOSDATA:03B7		      db 1
BIOSDATA:03B8 fdrive2	      db 0, 2, 0FFh, 1,	0, 2, 40h, 0 ; ...
BIOSDATA:03B8		      db 68h, 1, 0, 2, 0, 9, 0,	1
BIOSDATA:03B8		      db 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:03B8		      db 0, 0, 0, 0, 3,	20h, 0,	28h
BIOSDATA:03B8		      db 0, 0, 2, 1, 1,	0, 2, 0E0h
BIOSDATA:03B8		      db 0, 68h, 1, 0F0h, 2, 0,	9, 0
BIOSDATA:03B8		      db 2, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:03B8		      db 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:03B8		      db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 4Eh, 4Fh, 20h
BIOSDATA:03B8		      db 4Eh, 41h, 4Dh,	45h, 20h, 20h, 20h, 20h
BIOSDATA:03B8		      db 0, 0, 0, 0, 0,	46h, 41h, 54h
BIOSDATA:03B8		      db 31h, 32h, 20h,	20h, 20h, 0
BIOSDATA:0416 bds3	      dw offset	bds4	      ;	...
BIOSDATA:0418		      dw 70h
BIOSDATA:041A		      db 0
BIOSDATA:041B		      db 0
BIOSDATA:041C fdrive3	      db 0, 2, 0FFh, 1,	0, 2, 40h, 0 ; ...
BIOSDATA:041C		      db 68h, 1, 0, 2, 0, 9, 0,	1
BIOSDATA:041C		      db 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:041C		      db 0, 0, 0, 0, 3,	20h, 0,	28h
BIOSDATA:041C		      db 0, 0, 2, 1, 1,	0, 2, 0E0h
BIOSDATA:041C		      db 0, 68h, 1, 0F0h, 2, 0,	9, 0
BIOSDATA:041C		      db 2, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:041C		      db 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:041C		      db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 4Eh, 4Fh, 20h
BIOSDATA:041C		      db 4Eh, 41h, 4Dh,	45h, 20h, 20h, 20h, 20h
BIOSDATA:041C		      db 0, 0, 0, 0, 0,	46h, 41h, 54h
BIOSDATA:041C		      db 31h, 32h, 20h,	20h, 20h, 0
BIOSDATA:047A bds4	      dw 0FFFFh		      ;	...
BIOSDATA:047C		      dw 70h
BIOSDATA:047E		      db 0
BIOSDATA:047F		      db 0
BIOSDATA:0480 fdrive4	      db 0, 2, 0FFh, 1,	0, 2, 40h, 0 ; ...
BIOSDATA:0480		      db 68h, 1, 0, 2, 0, 9, 0,	1
BIOSDATA:0480		      db 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0480		      db 0, 0, 0, 0, 3,	20h, 0,	28h
BIOSDATA:0480		      db 0, 0, 2, 1, 1,	0, 2, 0E0h
BIOSDATA:0480		      db 0, 68h, 1, 0F0h, 2, 0,	9, 0
BIOSDATA:0480		      db 2, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0480		      db 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0480		      db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 4Eh, 4Fh, 20h
BIOSDATA:0480		      db 4Eh, 41h, 4Dh,	45h, 20h, 20h, 20h, 20h
BIOSDATA:0480		      db 0, 0, 0, 0, 0,	46h, 41h, 54h
BIOSDATA:0480		      db 31h, 32h, 20h,	20h, 20h, 0
BIOSDATA:04DE sm92	      db 3, 9, 112, 160, 5, 2, 2 ; ...
BIOSDATA:04E5 keyrd_func      db 0		      ;	...
BIOSDATA:04E6 keysts_func     db 1		      ;	...
BIOSDATA:04E7 printdev	      db 0		      ;	...
BIOSDATA:04E7					      ;	printer	device index
BIOSDATA:04E8 wait_count      dw 50h		      ;	...
BIOSDATA:04E8					      ;	retry counts for printers
BIOSDATA:04EA		      dw 50h
BIOSDATA:04EC		      dw 50h
BIOSDATA:04EE		      dw 50h
BIOSDATA:04F0 daycnt	      dw 0		      ;	...
BIOSDATA:04F2 t_switch	      db 0		      ;	...
BIOSDATA:04F2					      ;	flag for updating daycnt
BIOSDATA:04F3 havecmoscloc    db 0		      ;	...
BIOSDATA:04F4 base_century    db 19		      ;	...
BIOSDATA:04F5 base_year	      db 80		      ;	...
BIOSDATA:04F6 month_tab	      db 31, 28, 31, 30, 31, 30, 2 dup(31), 30,	31, 30,	31 ; ...
BIOSDATA:0502 bintobcd	      dw offset	bin_to_bcd    ;	...
BIOSDATA:0504		      dw 70h
BIOSDATA:0506 daycnttoday     dw offset	daycnt_to_day ;	...
BIOSDATA:0508		      dw 70h
BIOSDATA:050A set_id_flag     db 0		      ;	...
BIOSDATA:050A					      ;	flag for getbp routine
BIOSDATA:050B fat_12_id	      db 'FAT12   ',0         ; ...
BIOSDATA:0514 fat_16_id	      db 'FAT16   ',0         ; ...
BIOSDATA:051D vol_no_name     db 'NO NAME    ',0      ; ...
BIOSDATA:0529 temp_h	      dw 0		      ;	...
BIOSDATA:0529					      ;	temporary for 32 bit calculation
BIOSDATA:052B start_sec_h     dw 0		      ;	...
BIOSDATA:052B					      ;	starting sector	number high word
BIOSDATA:052D saved_word      dw 0		      ;	...
BIOSDATA:052D					      ;	tempory	saving place for a word
BIOSDATA:052F multrk_flag     dw 0		      ;	...
BIOSDATA:0531 ec35_flag	      db 0		      ;	...
BIOSDATA:0531					      ;	flags for 3.5 inch disk	drives
BIOSDATA:0532 vretry_cnt      dw 0		      ;	...
BIOSDATA:0534 soft_ecc_cnt    dw 0		      ;	...
BIOSDATA:0536 multitrk_format_flag db 0		      ;	...
BIOSDATA:0536					      ;	multi track format request flag
BIOSDATA:0537 xfer_seg	      dw 0		      ;	...
BIOSDATA:0537					      ;	temp for transfer segment
BIOSDATA:0539 sectorspertrack dw 36		      ;	...
BIOSDATA:053B tracktable      db 0, 0, 1, 2	      ;	...
BIOSDATA:053B		      db 0, 0, 2, 2
BIOSDATA:053B		      db 0, 0, 3, 2
BIOSDATA:053B		      db 0, 0, 4, 2
BIOSDATA:053B		      db 0, 0, 5, 2
BIOSDATA:053B		      db 0, 0, 6, 2
BIOSDATA:053B		      db 0, 0, 7, 2
BIOSDATA:053B		      db 0, 0, 8, 2
BIOSDATA:053B		      db 0, 0, 9, 2
BIOSDATA:053B		      db 0, 0, 10, 2
BIOSDATA:053B		      db 0, 0, 11, 2
BIOSDATA:053B		      db 0, 0, 12, 2
BIOSDATA:053B		      db 0, 0, 13, 2
BIOSDATA:053B		      db 0, 0, 14, 2
BIOSDATA:053B		      db 0, 0, 15, 2
BIOSDATA:053B		      db 0, 0, 16, 2
BIOSDATA:053B		      db 0, 0, 17, 2
BIOSDATA:053B		      db 0, 0, 18, 2
BIOSDATA:053B		      db 0, 0, 19, 2
BIOSDATA:053B		      db 0, 0, 20, 2
BIOSDATA:053B		      db 0, 0, 21, 2
BIOSDATA:053B		      db 0, 0, 22, 2
BIOSDATA:053B		      db 0, 0, 23, 2
BIOSDATA:053B		      db 0, 0, 24, 2
BIOSDATA:053B		      db 0, 0, 25, 2
BIOSDATA:053B		      db 0, 0, 26, 2
BIOSDATA:053B		      db 0, 0, 27, 2
BIOSDATA:053B		      db 0, 0, 28, 2
BIOSDATA:053B		      db 0, 0, 29, 2
BIOSDATA:053B		      db 0, 0, 30, 2
BIOSDATA:053B		      db 0, 0, 31, 2
BIOSDATA:053B		      db 0, 0, 32, 2
BIOSDATA:053B		      db 0, 0, 33, 2
BIOSDATA:053B		      db 0, 0, 34, 2
BIOSDATA:053B		      db 0, 0, 35, 2
BIOSDATA:053B		      db 0, 0, 36, 2
BIOSDATA:05CB		      db 108 dup(0)
BIOSDATA:0637 mediatype	      db 0		      ;	...
BIOSDATA:0638 media_set_for_format db 0		      ;	...
BIOSDATA:0638					      ;	1 if we	have done an int 13h
BIOSDATA:0638					      ;	set media type for format call
BIOSDATA:0639 had_format_error db 0		      ;	...
BIOSDATA:0639					      ;	1 if the previous format operation failed.
BIOSDATA:063A tempdpt	      dd 0FFFFFFFFh	      ;	...
BIOSDATA:063A					      ;	-1 ; temp disk base table
BIOSDATA:063E model_byte      db 0FFh		      ;	...
BIOSDATA:063E					      ;	model byte set at init time
BIOSDATA:063F secondary_model_byte db 0		      ;	...
BIOSDATA:0640 int19sem	      db 0		      ;	...
BIOSDATA:0640					      ;	indicate that all int 19h
BIOSDATA:0640					      ;	initialization is complete
BIOSDATA:0641 i19_lst	      db 2		      ;	...
BIOSDATA:0641					      ;	original hardware int. vectors for int 19h
BIOSDATA:0642 int19old02      dd 0FFFFFFFFh	      ;	...
BIOSDATA:0646		      db 8
BIOSDATA:0647 int19old08      dd 0FFFFFFFFh	      ;	...
BIOSDATA:064B		      db 9
BIOSDATA:064C int19old09      dd 0FFFFFFFFh	      ;	...
BIOSDATA:0650		      db 0Ah
BIOSDATA:0651 int19old0A      dd 0FFFFFFFFh	      ;	...
BIOSDATA:0655		      db 0Bh
BIOSDATA:0656 int19old0B      dd 0FFFFFFFFh	      ;	...
BIOSDATA:065A		      db 0Ch
BIOSDATA:065B int19old0C      dd 0FFFFFFFFh	      ;	...
BIOSDATA:065F		      db 0Dh
BIOSDATA:0660 int19old0D      dd 0FFFFFFFFh	      ;	...
BIOSDATA:0664		      db 0Eh
BIOSDATA:0665 int19old0E      dd 0FFFFFFFFh	      ;	...
BIOSDATA:0669		      db 70h
BIOSDATA:066A int19old70      dd 0FFFFFFFFh	      ;	...
BIOSDATA:066E		      db 72h
BIOSDATA:066F int19old72      dd 0FFFFFFFFh	      ;	...
BIOSDATA:0673		      db 73h
BIOSDATA:0674 int19old73      dd 0FFFFFFFFh	      ;	...
BIOSDATA:0678		      db 74h
BIOSDATA:0679 int19old74      dd 0FFFFFFFFh	      ;	...
BIOSDATA:067D		      db 76h
BIOSDATA:067E int19old76      dd 0FFFFFFFFh	      ;	...
BIOSDATA:0682		      db 77h
BIOSDATA:0683 int19old77      dd 0FFFFFFFFh	      ;	...
BIOSDATA:0687 dskdrvs	      dw offset	fdrive1	      ;	...
BIOSDATA:0689		      dw offset	fdrive2
BIOSDATA:068B		      dw offset	fdrive3
BIOSDATA:068D		      dw offset	fdrive4
BIOSDATA:068F		      dw 22 dup(0)	      ;	up to 26 drives	for mini disks
BIOSDATA:06BB int6c_ret_addr  dd 0		      ;	...
BIOSDATA:06BF bin_date_time   db 4 dup(0)	      ;	...
BIOSDATA:06BF					      ;	century, year, month,	day
BIOSDATA:06C3 month_table     dw 0, 31,	59, 90,	120, 151, 181, 212, 243, 273, 304, 334 ; ...
BIOSDATA:06DB daycnt2	      dw 0		      ;	...
BIOSDATA:06DD feb29	      db 0		      ;	february 29 in a leap	year flag
BIOSDATA:06DE cdev	      dw offset	chardev_entry ;	...
BIOSDATA:06E0 cdev_2	      dw 2CCh		      ;	...
BIOSDATA:06E0					      ;	BIOSCODE segment
BIOSDATA:06E2 ttticks	      dw offset	time_to_ticks ;	...
BIOSDATA:06E4		      dw 2CCh
BIOSDATA:06E6 bcode_i2f	      dw offset	i2f_handler   ;	...
BIOSDATA:06E8		      dw 2CCh
BIOSDATA:06EA i13x	      dw offset	i13z	      ;	...
BIOSDATA:06EC		      dw 2CCh
BIOSDATA:06EE ;	---------------------------------------------------------------------------
BIOSDATA:06EE
BIOSDATA:06EE cbreak:				      ;	...
BIOSDATA:06EE		      mov     cs:altah,	3     ;	indicate break key set
BIOSDATA:06F4
BIOSDATA:06F4 intret:				      ;	...
BIOSDATA:06F4		      iret
BIOSDATA:06F5 ;	---------------------------------------------------------------------------
BIOSDATA:06F5
BIOSDATA:06F5 strategy:				      ;	...
BIOSDATA:06F5		      mov     word ptr cs:ptrsav, bx ; store es:bx (device driver request packet)
BIOSDATA:06F5					      ;	     away at [ptrsav] for next driver function call
BIOSDATA:06FA		      mov     word ptr cs:ptrsav+2, es
BIOSDATA:06FF		      retf
BIOSDATA:0700 ;	---------------------------------------------------------------------------
BIOSDATA:0700
BIOSDATA:0700 con_entry:			      ;	...
BIOSDATA:0700		      call    cdev_entry
BIOSDATA:0703		      in      al, 0	      ;	2C7h:0E4h = BIOSCODE:0E4h = 70h:2654h
BIOSDATA:0705
BIOSDATA:0705 prn0_entry:			      ;	...
BIOSDATA:0705		      call    cdev_entry
BIOSDATA:0708		      sti
BIOSDATA:0708 ;	---------------------------------------------------------------------------
BIOSDATA:0709		      db    0
BIOSDATA:070A		      db 2 dup(0)
BIOSDATA:070C ;	---------------------------------------------------------------------------
BIOSDATA:070C
BIOSDATA:070C prn1_entry:			      ;	...
BIOSDATA:070C		      call    cdev_entry
BIOSDATA:070F		      sti
BIOSDATA:070F ;	---------------------------------------------------------------------------
BIOSDATA:0710		      db    0
BIOSDATA:0711		      db 0, 1
BIOSDATA:0713 ;	---------------------------------------------------------------------------
BIOSDATA:0713
BIOSDATA:0713 prn2_entry:			      ;	...
BIOSDATA:0713		      call    cdev_entry
BIOSDATA:0716		      sti		      ;	 2C7h:0FBh = BIOSCODE:0FBh = 70h:266Bh
BIOSDATA:0717		      add     [bx+di], al
BIOSDATA:0717 ;	---------------------------------------------------------------------------
BIOSDATA:0719		      db    2
BIOSDATA:071A ;	---------------------------------------------------------------------------
BIOSDATA:071A
BIOSDATA:071A prn3_entry:			      ;	...
BIOSDATA:071A		      call    cdev_entry
BIOSDATA:071D		      sti
BIOSDATA:071E		      add     [bp+si], al
BIOSDATA:071E ;	---------------------------------------------------------------------------
BIOSDATA:0720		      db    3
BIOSDATA:0721 ;	---------------------------------------------------------------------------
BIOSDATA:0721
BIOSDATA:0721 aux0_entry:			      ;	...
BIOSDATA:0721		      call    cdev_entry
BIOSDATA:0724		      xor     [bx+di], al
BIOSDATA:0724 ;	---------------------------------------------------------------------------
BIOSDATA:0726		      db 0
BIOSDATA:0727 ;	---------------------------------------------------------------------------
BIOSDATA:0727
BIOSDATA:0727 aux1_entry:			      ;	...
BIOSDATA:0727		      call    cdev_entry
BIOSDATA:072A		      xor     [bx+di], al     ;	2C7h:130h = BIOSCODE:130h = 70h:26A0h
BIOSDATA:072A ;	---------------------------------------------------------------------------
BIOSDATA:072C		      db 1
BIOSDATA:072D ;	---------------------------------------------------------------------------
BIOSDATA:072D
BIOSDATA:072D aux2_entry:			      ;	...
BIOSDATA:072D		      call    cdev_entry
BIOSDATA:0730		      xor     [bx+di], al
BIOSDATA:0730 ;	---------------------------------------------------------------------------
BIOSDATA:0732		      db 2
BIOSDATA:0733 ;	---------------------------------------------------------------------------
BIOSDATA:0733
BIOSDATA:0733 aux3_entry:			      ;	...
BIOSDATA:0733		      call    cdev_entry
BIOSDATA:0736		      xor     [bx+di], al
BIOSDATA:0736 ;	---------------------------------------------------------------------------
BIOSDATA:0738		      db 3
BIOSDATA:0739 ;	---------------------------------------------------------------------------
BIOSDATA:0739
BIOSDATA:0739 tim_entry:			      ;	...
BIOSDATA:0739		      call    cdev_entry
BIOSDATA:073C		      inc     di	      ;	2C7h:147h = BIOSCODE:147h = 70h:26B7h
BIOSDATA:073C ;	---------------------------------------------------------------------------
BIOSDATA:073D		      db    1
BIOSDATA:073E ;	---------------------------------------------------------------------------
BIOSDATA:073E
BIOSDATA:073E dsk_entry:			      ;	...
BIOSDATA:073E		      call    cdev_entry
BIOSDATA:073E ;	---------------------------------------------------------------------------
BIOSDATA:0741		      dw offset	DSKTBL	      ;	2C7h:4A2h = BIOSCODE:4A2h = 70h:2A12h
BIOSDATA:0743
BIOSDATA:0743 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:0743
BIOSDATA:0743
BIOSDATA:0743 cdev_entry      proc near		      ;	...
BIOSDATA:0743		      cmp     cs:inHMA,	0
BIOSDATA:0749		      jz      short ce_enter_codeseg
BIOSDATA:074B		      push    ax	      ;	optimized for DOS in HMA
BIOSDATA:074C		      mov     ax, cs:DosDataSg
BIOSDATA:0750		      cmp     word ptr cs:ptrsav+2, ax
BIOSDATA:0755		      pop     ax
BIOSDATA:0756		      jnz     short not_from_dos ; jump	is coded this way to fall thru
BIOSDATA:0756					      ;	in 99.99% of the cases
BIOSDATA:0758
BIOSDATA:0758 ce_enter_codeseg:			      ;	...
BIOSDATA:0758		      jmp     dword ptr	cs:cdev
BIOSDATA:075D ;	---------------------------------------------------------------------------
BIOSDATA:075D
BIOSDATA:075D not_from_dos:			      ;	...
BIOSDATA:075D		      call    EnsureA20On
BIOSDATA:0760		      jmp     short ce_enter_codeseg
BIOSDATA:0760 cdev_entry      endp
BIOSDATA:0760
BIOSDATA:0762
BIOSDATA:0762 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:0762
BIOSDATA:0762
BIOSDATA:0762 outchr	      proc far		      ;	...
BIOSDATA:0762		      push    ax	      ;	int 29h	handler
BIOSDATA:0763		      push    si
BIOSDATA:0764		      push    di
BIOSDATA:0765		      push    bp
BIOSDATA:0766		      push    bx
BIOSDATA:0767		      mov     ah, 0Eh
BIOSDATA:0769		      mov     bx, 7
BIOSDATA:076C		      int     10h	      ;	- VIDEO	- WRITE	CHARACTER AND ADVANCE CURSOR (TTY WRITE)
BIOSDATA:076C					      ;	AL = character,	BH = display page (alpha modes)
BIOSDATA:076C					      ;	BL = foreground	color (graphics	modes)
BIOSDATA:076E		      pop     bx
BIOSDATA:076F		      pop     bp
BIOSDATA:0770		      pop     di
BIOSDATA:0771		      pop     si
BIOSDATA:0772		      pop     ax
BIOSDATA:0773		      iret
BIOSDATA:0773 outchr	      endp
BIOSDATA:0773
BIOSDATA:0774
BIOSDATA:0774 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:0774
BIOSDATA:0774
BIOSDATA:0774 block13	      proc far		      ;	...
BIOSDATA:0774		      cmp     cs:inHMA,	0
BIOSDATA:077A		      jz      short skipa20
BIOSDATA:077C		      call    IsA20off	      ;	A20 Off?
BIOSDATA:077F		      jnz     short skipa20
BIOSDATA:0781		      call    EnableA20	      ;	assure a20 enabled
BIOSDATA:0784
BIOSDATA:0784 skipa20:				      ;	...
BIOSDATA:0784		      mov     cs:i13_ds, ds   ;	save caller's ds for call-through
BIOSDATA:0789		      pushf		      ;	fake interrupt
BIOSDATA:078A		      call    dword ptr	cs:i13x	; call through Bios_Code entry table
BIOSDATA:078F		      mov     ds, cs:i13_ds
BIOSDATA:0794		      retf    2
BIOSDATA:0794 block13	      endp
BIOSDATA:0794
BIOSDATA:0797
BIOSDATA:0797 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:0797
BIOSDATA:0797
BIOSDATA:0797 call_orig13     proc far
BIOSDATA:0797		      mov     ds, ds:i13_ds   ;	get caller's ds register
BIOSDATA:079B		      pushf
BIOSDATA:079C		      call    cs:Orig13
BIOSDATA:07A1		      mov     cs:i13_ds, ds
BIOSDATA:07A6		      push    cs
BIOSDATA:07A7		      pop     ds	      ;	restore	ds -> Bios_Data	before return
BIOSDATA:07A8		      pushf
BIOSDATA:07A9		      cmp     cs:inHMA,	0
BIOSDATA:07AF		      jz      short c_o13_1
BIOSDATA:07B1		      call    IsA20off
BIOSDATA:07B1 ;	---------------------------------------------------------------------------
BIOSDATA:07B4		      dw 375h
BIOSDATA:07B6		      dw 10E8h
BIOSDATA:07B8		      db    0
BIOSDATA:07B9 ;	---------------------------------------------------------------------------
BIOSDATA:07B9
BIOSDATA:07B9 c_o13_1:				      ;	...
BIOSDATA:07B9		      popf
BIOSDATA:07BA		      retf
BIOSDATA:07BA call_orig13     endp
BIOSDATA:07BA
BIOSDATA:07BA ;	---------------------------------------------------------------------------
BIOSDATA:07BB HiMem	      dd 0FFFF0090h	      ;	...
BIOSDATA:07BF LoMem	      dd 80h		      ;	...
BIOSDATA:07C3
BIOSDATA:07C3 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:07C3
BIOSDATA:07C3
BIOSDATA:07C3 EnsureA20On     proc near		      ;	...
BIOSDATA:07C3		      call    IsA20off
BIOSDATA:07C6		      jz      short EnableA20
BIOSDATA:07C8		      retn
BIOSDATA:07C9 ;	---------------------------------------------------------------------------
BIOSDATA:07C9
BIOSDATA:07C9 EnableA20:			      ;	...
BIOSDATA:07C9		      push    ax
BIOSDATA:07CA		      push    bx
BIOSDATA:07CB		      mov     ah, 5	      ;	local enable A20
BIOSDATA:07CD		      call    cs:xms
BIOSDATA:07D2		      pop     bx
BIOSDATA:07D3		      pop     ax
BIOSDATA:07D4		      retn
BIOSDATA:07D4 EnsureA20On     endp
BIOSDATA:07D4
BIOSDATA:07D5
BIOSDATA:07D5 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:07D5
BIOSDATA:07D5
BIOSDATA:07D5 IsA20off	      proc near		      ;	...
BIOSDATA:07D5		      push    ds
BIOSDATA:07D6		      push    es
BIOSDATA:07D7		      push    cx
BIOSDATA:07D8		      push    si
BIOSDATA:07D9		      push    di
BIOSDATA:07DA		      lds     si, cs:HiMem
BIOSDATA:07DF		      les     di, cs:LoMem
BIOSDATA:07E4		      mov     cx, 8
BIOSDATA:07E7		      repe cmpsw
BIOSDATA:07E9		      pop     di
BIOSDATA:07EA		      pop     si
BIOSDATA:07EB		      pop     cx
BIOSDATA:07EC		      pop     es
BIOSDATA:07ED		      pop     ds
BIOSDATA:07EE		      retn
BIOSDATA:07EE IsA20off	      endp
BIOSDATA:07EE
BIOSDATA:07EF ;	---------------------------------------------------------------------------
BIOSDATA:07EF
BIOSDATA:07EF DisableA20:
BIOSDATA:07EF		      push    ax
BIOSDATA:07F0		      push    bx
BIOSDATA:07F1		      mov     ah, 6	      ;	local disable A20
BIOSDATA:07F3		      call    cs:xms	      ;	call far [cs:xms]
BIOSDATA:07F8		      pop     bx
BIOSDATA:07F9		      pop     ax
BIOSDATA:07FA		      retn
BIOSDATA:07FB ;	---------------------------------------------------------------------------
BIOSDATA:07FB
BIOSDATA:07FB int19:				      ;	...
BIOSDATA:07FB		      push    cs
BIOSDATA:07FC		      pop     ds
BIOSDATA:07FD		      mov     es, ds:zeroseg
BIOSDATA:0801		      assume es:nothing
BIOSDATA:0801		      mov     cx, 5
BIOSDATA:0804		      mov     si, offset RomVectors
BIOSDATA:0807
BIOSDATA:0807 _next_int:			      ;	...
BIOSDATA:0807		      lodsb		      ;	get int	number
BIOSDATA:0808		      cbw		      ;	assume < 128
BIOSDATA:0809		      shl     ax, 1
BIOSDATA:080B		      shl     ax, 1	      ;	int * 4
BIOSDATA:080D		      mov     di, ax
BIOSDATA:080F		      lodsw		      ;	install	the saved vector
BIOSDATA:0810		      stosw
BIOSDATA:0811		      lodsw
BIOSDATA:0812		      stosw
BIOSDATA:0813		      loop    _next_int
BIOSDATA:0815		      cmp     ds:int19sem, 0
BIOSDATA:081A		      jz      short doint19
BIOSDATA:081C		      mov     si, offset i19_lst ; stacks code has changed these hardware interrupt vectors
BIOSDATA:081C					      ;	stkinit	in sysinit1 will initialize int19oldxx values
BIOSDATA:081F		      mov     cx, 14
BIOSDATA:0822
BIOSDATA:0822 i19_restore_loop:			      ;	...
BIOSDATA:0822		      lodsb		      ;	get interrupt number
BIOSDATA:0823		      cbw		      ;	assume < 128
BIOSDATA:0824		      mov     di, ax
BIOSDATA:0826		      lodsw		      ;	get original vector offset
BIOSDATA:0827		      mov     bx, ax	      ;	save it
BIOSDATA:0829		      lodsw
BIOSDATA:082A		      cmp     bx, 0FFFFh      ;	check for 0ffffh (unlikely segment)
BIOSDATA:082D		      jz      short i19_restor_1 ; opt no need to check	selector too
BIOSDATA:082F		      cmp     ax, 0FFFFh
BIOSDATA:0832		      jz      short i19_restor_1
BIOSDATA:0834		      add     di, di
BIOSDATA:0836		      add     di, di
BIOSDATA:0838		      xchg    ax, bx
BIOSDATA:0838 ;	---------------------------------------------------------------------------
BIOSDATA:0839		      dw 93ABh
BIOSDATA:083B		      db 0ABh ;	«
BIOSDATA:083C ;	---------------------------------------------------------------------------
BIOSDATA:083C
BIOSDATA:083C i19_restor_1:			      ;	...
BIOSDATA:083C		      loop    i19_restore_loop
BIOSDATA:083E
BIOSDATA:083E doint19:				      ;	...
BIOSDATA:083E		      cmp     ds:inHMA,	0     ;	Is dos running from HMA	?
BIOSDATA:0843		      jz      short SkipVDisk ;	no
BIOSDATA:0845		      call    EraseVDiskHead  ;	Then erase our VDISK header at 1MB boundary
BIOSDATA:0845					      ;	Some m/c's (AST 386 & HP QS/16 do not clear
BIOSDATA:0845					      ;	the memory above 1MB during a warm boot.
BIOSDATA:0848
BIOSDATA:0848 SkipVDisk:			      ;	...
BIOSDATA:0848		      int     19h	      ;	DISK BOOT
BIOSDATA:0848					      ;	causes reboot of disk system
BIOSDATA:084A
BIOSDATA:084A Int15:				      ;	...
BIOSDATA:084A		      cmp     ax, 4F53h	      ;	del keystroke ?	(4F00h+DELKEY)
BIOSDATA:084D		      jz      short int15_1
BIOSDATA:084F		      jmp     cs:Old15
BIOSDATA:0854 ;	---------------------------------------------------------------------------
BIOSDATA:0854
BIOSDATA:0854 int15_1:				      ;	...
BIOSDATA:0854		      push    ds
BIOSDATA:0855		      push    ax
BIOSDATA:0856		      mov     ax, 40h	      ;	ROMBIOS	data segment
BIOSDATA:0859		      mov     ds, ax
BIOSDATA:085B		      assume ds:nothing
BIOSDATA:085B		      mov     al, ds:17h      ;	[KBFLAG]
BIOSDATA:085E		      and     al, 0Ch	      ;	(CTRLSTATE | ALTSTATE)
BIOSDATA:0860		      cmp     al, 0Ch	      ;	(CTRLSTATE | ALTSTATE)
BIOSDATA:0862		      jnz     short int15_2
BIOSDATA:0864		      push    cs
BIOSDATA:0865		      pop     ds
BIOSDATA:0866		      assume ds:nothing
BIOSDATA:0866		      cmp     ds:inHMA,	0     ;	is DOS running from HMA	?
BIOSDATA:086B		      jz      short int15_2   ;	no
BIOSDATA:086D		      call    EraseVDiskHead
BIOSDATA:0870
BIOSDATA:0870 int15_2:				      ;	...
BIOSDATA:0870		      pop     ax
BIOSDATA:0871		      pop     ds
BIOSDATA:0872		      stc
BIOSDATA:0873		      jmp     cs:Old15
BIOSDATA:0878
BIOSDATA:0878 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:0878
BIOSDATA:0878
BIOSDATA:0878 EraseVDiskHead  proc near		      ;	...
BIOSDATA:0878		      push    ax
BIOSDATA:0879		      push    cx
BIOSDATA:087A		      push    di
BIOSDATA:087B		      push    es
BIOSDATA:087C		      call    EnsureA20On
BIOSDATA:087F		      mov     ax, 0FFFFh      ;	HMA seg
BIOSDATA:0882		      mov     es, ax
BIOSDATA:0884		      assume es:nothing
BIOSDATA:0884		      mov     di, 10h	      ;	point to VDISK header
BIOSDATA:0887		      mov     cx, 16	      ;	size of	vdisk header
BIOSDATA:088A		      xor     ax, ax
BIOSDATA:088C		      rep stosw		      ;	clear it
BIOSDATA:088E		      pop     es
BIOSDATA:088F		      assume es:nothing
BIOSDATA:088F		      pop     di
BIOSDATA:0890		      pop     cx
BIOSDATA:0891		      pop     ax
BIOSDATA:0892		      retn
BIOSDATA:0892 EraseVDiskHead  endp
BIOSDATA:0892
BIOSDATA:0893 ;	---------------------------------------------------------------------------
BIOSDATA:0893
BIOSDATA:0893 int_2f:				      ;	...
BIOSDATA:0893		      jmp     dword ptr	cs:bcode_i2f
BIOSDATA:0898 ;	---------------------------------------------------------------------------
BIOSDATA:0898		      jmp     dsk_entry
BIOSDATA:089B ;	---------------------------------------------------------------------------
BIOSDATA:089B
BIOSDATA:089B re_init:
BIOSDATA:089B		      retf
BIOSDATA:089B ;	---------------------------------------------------------------------------
BIOSDATA:089C Win386_SI	      db 3, 0		      ;	...
BIOSDATA:089E SI_Next	      dd 0		      ;	...
BIOSDATA:08A2		      dd 0
BIOSDATA:08A6		      dd 0
BIOSDATA:08AA		      dw offset	Instance_Table
BIOSDATA:08AC		      dw 70h		      ;	BIOSDATA segment
BIOSDATA:08AE Instance_Table  dw 0		      ;	...
BIOSDATA:08B0		      dw 50h		      ;	print screen status...
BIOSDATA:08B2		      dw 2		      ;	2 bytes
BIOSDATA:08B4		      dw 0Eh		      ;	ROM Basic data
BIOSDATA:08B6		      dw 50h
BIOSDATA:08B8		      dw 14h
BIOSDATA:08BA		      dw offset	altah	      ;	a con device buffer
BIOSDATA:08BC		      dw 70h		      ;	BIOSDATA segment
BIOSDATA:08BE		      dw 1
BIOSDATA:08C0 NextStack	      dw 2 dup(0)	      ;	...
BIOSDATA:08C0					      ;	pointer	to next	stack to be used
BIOSDATA:08C4		      dw 2		      ;	2 bytes
BIOSDATA:08C6 IT_StackLoc     dd 0		      ;	...
BIOSDATA:08C6					      ;	location of hardware stacks
BIOSDATA:08CA IT_StackSize    dw 0		      ;	...
BIOSDATA:08CA					      ;	size of	hardware stacks
BIOSDATA:08CC		      dd 0		      ;	terminate the instance table
BIOSDATA:08D0 IsWin386	      db 0		      ;	...
BIOSDATA:08D0					      ;	Flag to	indicate whether
BIOSDATA:08D0					      ;	Win386 is running or not
BIOSDATA:08D1
BIOSDATA:08D1 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:08D1
BIOSDATA:08D1
BIOSDATA:08D1 V86_Crit_SetFocus	proc far
BIOSDATA:08D1		      push    di
BIOSDATA:08D2		      push    es
BIOSDATA:08D3		      push    bx
BIOSDATA:08D4		      push    ax
BIOSDATA:08D5		      xor     di, di
BIOSDATA:08D7		      mov     es, di
BIOSDATA:08D9		      assume es:nothing
BIOSDATA:08D9		      mov     bx, 15h
BIOSDATA:08DC		      mov     ax, 1684h
BIOSDATA:08DF		      int     2Fh	      ;	- Multiplex - MS WINDOWS - GET DEVICE API ENTRY	POINT
BIOSDATA:08DF					      ;	BX = virtual device (VxD) ID, ES:DI = 0000h:0000h
BIOSDATA:08DF					      ;	Return:	ES:DI -> VxD API entry point, or 0:0 if	the VxD	does not support an API
BIOSDATA:08E1		      mov     ax, es
BIOSDATA:08E3		      or      ax, di
BIOSDATA:08E5		      jz      short Skip
BIOSDATA:08E7		      push    cs
BIOSDATA:08E8		      mov     ax, offset Skip
BIOSDATA:08EB		      push    ax
BIOSDATA:08EC		      push    es
BIOSDATA:08ED		      push    di
BIOSDATA:08EE		      mov     ax, 1
BIOSDATA:08F1		      retf
BIOSDATA:08F2 ;	---------------------------------------------------------------------------
BIOSDATA:08F2
BIOSDATA:08F2 Skip:				      ;	...
BIOSDATA:08F2		      pop     ax
BIOSDATA:08F3		      pop     bx
BIOSDATA:08F4		      pop     es
BIOSDATA:08F5		      assume es:nothing
BIOSDATA:08F5		      pop     di
BIOSDATA:08F6		      retf
BIOSDATA:08F6 V86_Crit_SetFocus	endp
BIOSDATA:08F6
BIOSDATA:08F6 ;	---------------------------------------------------------------------------
BIOSDATA:08F7 FreeHMAPtr      dw 0FFFFh		      ;	...
BIOSDATA:08F9 MoveDOSIntoHMA  dw offset	FTryToMovDOSHi ; ...
BIOSDATA:08FB MoveDOSIntoHMA_2 dw 473h		      ;	...
BIOSDATA:08FB					      ;	SYSINIT	segment
BIOSDATA:08FD SysinitPresent  db 0		      ;	...
BIOSDATA:08FE endfloppy	      db 0		      ;	...
BIOSDATA:08FF		      db 0
BIOSDATA:0900 nul_vid	      db 'NO NAME    ',0      ; ...
BIOSDATA:090C tmp_vid	      db 'NO NAME    ',0      ; ...
BIOSDATA:0918 harddrv	      db 80h		      ;	...
BIOSDATA:0919 bdss	      dw 0FFFFh		      ;	...
BIOSDATA:0919					      ;	max_mini_dsk_num equ 23
BIOSDATA:0919					      ;	BDS_STRUC (2+max_mini_dsk_num) dup (<>)
BIOSDATA:0919					      ;	currently max. 25
BIOSDATA:0919					      ;	(MSDOS 6 BDS structure size = 100 bytes)
BIOSDATA:091B		      dw 0
BIOSDATA:091D		      db 80
BIOSDATA:091E		      db 3
BIOSDATA:091F		      dw 512
BIOSDATA:0921		      db 1
BIOSDATA:0922		      dw 1
BIOSDATA:0924		      db 2
BIOSDATA:0925		      dw 16
BIOSDATA:0927		      dw 0
BIOSDATA:0929		      db 0F8h
BIOSDATA:092A		      dw 1
BIOSDATA:092C		      dw 0
BIOSDATA:092E		      dw 0
BIOSDATA:0930		      dd 0
BIOSDATA:0934		      dd 0
BIOSDATA:0938		      db 0
BIOSDATA:0939		      dw 0
BIOSDATA:093B		      db 3
BIOSDATA:093C		      dw 20h
BIOSDATA:093E		      dw 40
BIOSDATA:0940		      db 31 dup(0)
BIOSDATA:095F		      db 255
BIOSDATA:0960		      dw 1
BIOSDATA:0962		      dw 0
BIOSDATA:0964		      db 'NO NAME    ',0
BIOSDATA:0970		      dd 0
BIOSDATA:0974		      db 'FAT12   ',0
BIOSDATA:097D bdss_1	      dw 0FFFFh
BIOSDATA:097F		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:097F		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:097F		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:097F		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:097F		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:097F		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:097F		      db 20h, 0
BIOSDATA:09E1 bdss_2	      dw 0FFFFh
BIOSDATA:09E3		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:09E3		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:09E3		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:09E3		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:09E3		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:09E3		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:09E3		      db 20h, 0
BIOSDATA:0A45 bdss_3	      dw 0FFFFh
BIOSDATA:0A47		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0A47		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0A47		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0A47		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0A47		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0A47		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0A47		      db 20h, 0
BIOSDATA:0AA9 bdss_4	      dw 0FFFFh
BIOSDATA:0AAB		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0AAB		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0AAB		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0AAB		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0AAB		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0AAB		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0AAB		      db 20h, 0
BIOSDATA:0B0D		      dw 0FFFFh
BIOSDATA:0B0F		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0B0F		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0B0F		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0B0F		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0B0F		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0B0F		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0B0F		      db 20h, 0
BIOSDATA:0B71		      dw 0FFFFh
BIOSDATA:0B73		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0B73		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0B73		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0B73		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0B73		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0B73		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0B73		      db 20h, 0
BIOSDATA:0BD5		      dw 0FFFFh
BIOSDATA:0BD7		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0BD7		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0BD7		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0BD7		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0BD7		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0BD7		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0BD7		      db 20h, 0
BIOSDATA:0C39		      dw 0FFFFh
BIOSDATA:0C3B		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0C3B		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0C3B		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0C3B		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0C3B		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0C3B		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0C3B		      db 20h, 0
BIOSDATA:0C9D		      dw 0FFFFh
BIOSDATA:0C9F		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0C9F		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0C9F		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0C9F		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0C9F		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0C9F		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0C9F		      db 20h, 0
BIOSDATA:0D01		      dw 0FFFFh
BIOSDATA:0D03		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0D03		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0D03		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0D03		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0D03		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0D03		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0D03		      db 20h, 0
BIOSDATA:0D65		      dw 0FFFFh
BIOSDATA:0D67		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0D67		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0D67		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0D67		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0D67		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0D67		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0D67		      db 20h, 0
BIOSDATA:0DC9		      dw 0FFFFh
BIOSDATA:0DCB		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0DCB		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0DCB		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0DCB		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0DCB		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0DCB		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0DCB		      db 20h, 0
BIOSDATA:0E2D		      dw 0FFFFh
BIOSDATA:0E2F		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0E2F		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0E2F		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0E2F		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0E2F		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0E2F		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0E2F		      db 20h, 0
BIOSDATA:0E91		      dw 0FFFFh
BIOSDATA:0E93		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1 ; ...
BIOSDATA:0E93		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0E93		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0E93		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0E93		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0E93		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0E93		      db 20h, 0
BIOSDATA:0EF5		      dw 0FFFFh
BIOSDATA:0EF7		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0EF7		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0EF7		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0EF7		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0EF7		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0EF7		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0EF7		      db 20h, 0
BIOSDATA:0F59		      dw 0FFFFh
BIOSDATA:0F5B		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0F5B		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0F5B		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0F5B		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0F5B		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0F5B		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0F5B		      db 20h, 0
BIOSDATA:0FBD		      dw 0FFFFh
BIOSDATA:0FBF		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:0FBF		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0FBF		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:0FBF		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:0FBF		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:0FBF		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:0FBF		      db 20h, 0
BIOSDATA:1021		      dw 0FFFFh
BIOSDATA:1023		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:1023		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:1023		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:1023		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:1023		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:1023		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:1023		      db 20h, 0
BIOSDATA:1085		      dw 0FFFFh
BIOSDATA:1087		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:1087		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:1087		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:1087		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:1087		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:1087		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:1087		      db 20h, 0
BIOSDATA:10E9		      dw 0FFFFh
BIOSDATA:10EB		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:10EB		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:10EB		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:10EB		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:10EB		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:10EB		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:10EB		      db 20h, 0
BIOSDATA:114D		      dw 0FFFFh
BIOSDATA:114F		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:114F		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:114F		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:114F		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:114F		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:114F		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:114F		      db 20h, 0
BIOSDATA:11B1		      dw 0FFFFh
BIOSDATA:11B3		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:11B3		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:11B3		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:11B3		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:11B3		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:11B3		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:11B3		      db 20h, 0
BIOSDATA:1215		      dw 0FFFFh
BIOSDATA:1217		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:1217		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:1217		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:1217		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:1217		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:1217		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:1217		      db 20h, 0
BIOSDATA:1279 bdss_24	      dw 0FFFFh
BIOSDATA:127B		      db 0, 0, 50h, 3, 0, 2, 1,	1, 0, 2, 10h, 0, 0, 0, 0F8h, 1
BIOSDATA:127B		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:127B		      db 3, 20h, 0, 28h, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0
BIOSDATA:127B		      db 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
BIOSDATA:127B		      db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h,	4Dh, 45h
BIOSDATA:127B		      db 20h, 20h, 20h,	20h, 0,	0, 0, 0, 0, 46h, 41h, 54h, 31h,	32h, 20h, 20h
BIOSDATA:127B		      db 20h, 0
BIOSDATA:12DD		      db 0
BIOSDATA:12DE ;	---------------------------------------------------------------------------
BIOSDATA:12DE
BIOSDATA:12DE ibm_disk_io:			      ;	...
BIOSDATA:12DE		      cmp     dl, 80h	      ;	main routine, fixes at rom bug
BIOSDATA:12DE					      ;	pass through floppy disk calls
BIOSDATA:12E1		      jb      short atd1
BIOSDATA:12E3		      cmp     ah, 2
BIOSDATA:12E6		      jz      short atd2      ;	intercept call 02h (read sectors)
BIOSDATA:12E8		      cmp     ah, 0Ah	      ;	and call 0Ah (read long)
BIOSDATA:12EB		      jz      short atd2
BIOSDATA:12ED
BIOSDATA:12ED atd1:				      ;	...
BIOSDATA:12ED		      jmp     cs:Old13	      ;	use rom	int 13h	handler
BIOSDATA:12F2 ;	---------------------------------------------------------------------------
BIOSDATA:12F2
BIOSDATA:12F2 atd2:				      ;	...
BIOSDATA:12F2		      push    bx
BIOSDATA:12F3		      push    cx
BIOSDATA:12F4		      push    dx
BIOSDATA:12F5		      push    di
BIOSDATA:12F6		      push    ds
BIOSDATA:12F7		      push    es
BIOSDATA:12F8		      push    ax
BIOSDATA:12F9		      mov     ax, 40h	      ;	rombios	data segment
BIOSDATA:12FC		      mov     ds, ax
BIOSDATA:12FE		      assume ds:nothing
BIOSDATA:12FE		      mov     byte ptr ds:74h, 0 ; [disk_status1]
BIOSDATA:12FE					      ;	initially no error code
BIOSDATA:1303		      and     dl, 7Fh	      ;	mask to	hard disk number
BIOSDATA:1306		      cmp     dl, ds:75h      ;	[hf_num] ; 40h:75h
BIOSDATA:130A		      jb      short atd3      ;	disk number in ranger
BIOSDATA:130C		      mov     byte ptr ds:74h, 1 ; [disk_status1]
BIOSDATA:1311		      jmp     short atd4      ;	disk number out	of range error,	return
BIOSDATA:1313 ;	---------------------------------------------------------------------------
BIOSDATA:1313
BIOSDATA:1313 atd3:				      ;	...
BIOSDATA:1313		      push    bx
BIOSDATA:1314		      mov     ax, es
BIOSDATA:1316		      shr     bx, 4	      ;	make es:bx to seg:000x form
BIOSDATA:1319		      add     ax, bx
BIOSDATA:131B		      mov     es, ax
BIOSDATA:131D		      pop     bx
BIOSDATA:131E		      and     bx, 0Fh
BIOSDATA:1321		      push    cs
BIOSDATA:1322		      call    check_dma
BIOSDATA:1325		      jb      short atd4      ;	abort if dma across segment boundary
BIOSDATA:1327		      pop     ax
BIOSDATA:1328		      push    ax
BIOSDATA:1329		      call    setcmd	      ;	set up command block for disk op
BIOSDATA:132C		      mov     dx, 3F6h	      ;	hf_reg_port
BIOSDATA:132F		      out     dx, al	      ;	AT only. Fixed disk register
BIOSDATA:1330		      call    docmd	      ;	carry out command
BIOSDATA:1333
BIOSDATA:1333 atd4:				      ;	...
BIOSDATA:1333		      pop     ax
BIOSDATA:1334		      mov     ah, ds:74h      ;	[disk_status1]
BIOSDATA:1338		      or      ah, ah
BIOSDATA:133A		      jz      short atd5
BIOSDATA:133C		      stc
BIOSDATA:133D
BIOSDATA:133D atd5:				      ;	...
BIOSDATA:133D		      pop     es
BIOSDATA:133E		      pop     ds
BIOSDATA:133F		      assume ds:nothing
BIOSDATA:133F		      pop     di
BIOSDATA:1340		      pop     dx
BIOSDATA:1341		      pop     cx
BIOSDATA:1342		      pop     bx
BIOSDATA:1343		      retf    2
BIOSDATA:1346
BIOSDATA:1346 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:1346
BIOSDATA:1346
BIOSDATA:1346 setcmd	      proc near		      ;	...
BIOSDATA:1346		      mov     byte ptr ds:asc_3F+4, al ; [cmd_block+sec_cnt]
BIOSDATA:1349		      mov     byte ptr ds:prndev2+1, 20h
BIOSDATA:134E		      cmp     ah, 2	      ;	cmd_reg	= 20h if function 02h (read)
BIOSDATA:1351		      jz      short setc1
BIOSDATA:1353		      mov     byte ptr ds:prndev2+1, 22h ; [cmd_block+cmd_reg]
BIOSDATA:1353					      ;	cmd_reg	= 22h if function 0Ah (read long)
BIOSDATA:1358
BIOSDATA:1358 setc1:				      ;	...
BIOSDATA:1358		      mov     al, cl
BIOSDATA:135A		      and     al, 3Fh	      ;	mask sector number
BIOSDATA:135C		      mov     byte ptr ds:asc_3F+5, al ; [cmd_block+sec_num]
BIOSDATA:135F		      mov     byte ptr ds:asc_3F+6, ch ; [cmd_block+cyl_low]
BIOSDATA:1363		      mov     al, cl
BIOSDATA:1365		      shr     al, 6	      ;	get two	high bits of cylinder number
BIOSDATA:1368		      mov     byte ptr ds:asc_3F+7, al ; [cmd_block+cyl_high]
BIOSDATA:136B		      mov     ax, dx
BIOSDATA:136D		      shl     al, 4	      ;	drive number
BIOSDATA:1370		      and     ah, 0Fh
BIOSDATA:1373		      or      al, ah	      ;	head number
BIOSDATA:1375		      or      al, 0A0h	      ;	set ecc	and 512	bytes per sector
BIOSDATA:1377		      mov     byte ptr ds:prndev2, al ;	[cmd_block+drv_head]
BIOSDATA:137A		      push    es
BIOSDATA:137B		      push    bx
BIOSDATA:137C		      push    cs
BIOSDATA:137D		      call    get_vec
BIOSDATA:1380		      mov     ax, es:[bx+5]   ;	[es:bx+fdp_precomp]
BIOSDATA:1380					      ;	write pre-comp from disk parameters
BIOSDATA:1384		      shr     ax, 2
BIOSDATA:1387		      mov     byte ptr ds:asc_3F+3, al ; [cmd_block+pre_comp]
BIOSDATA:138A		      mov     al, es:[bx+8]   ;	[es:bx+fdp_control]
BIOSDATA:138A					      ;	control	byte modifier
BIOSDATA:138E		      pop     bx
BIOSDATA:138F		      pop     es
BIOSDATA:1390		      mov     ah, ds:step_drv ;	[control_byte]
BIOSDATA:1394		      and     ah, 0C0h	      ;	keep disable retry bits
BIOSDATA:1397		      or      ah, al
BIOSDATA:1399		      mov     ds:step_drv, ah
BIOSDATA:139D		      retn
BIOSDATA:139D setcmd	      endp
BIOSDATA:139D
BIOSDATA:139E
BIOSDATA:139E ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:139E
BIOSDATA:139E
BIOSDATA:139E docmd	      proc near		      ;	...
BIOSDATA:139E		      mov     di, bx
BIOSDATA:13A0		      push    cs
BIOSDATA:13A1		      call    command
BIOSDATA:13A4		      jnz     short doc3
BIOSDATA:13A6
BIOSDATA:13A6 doc1:				      ;	...
BIOSDATA:13A6		      push    cs
BIOSDATA:13A7		      call    waitt	      ;	wait for controller to complete	read
BIOSDATA:13AA		      jnz     short doc3
BIOSDATA:13AC		      mov     cx, 256
BIOSDATA:13AF		      mov     dx, 1F0h	      ;	hf_port
BIOSDATA:13B2		      cld
BIOSDATA:13B3		      cli
BIOSDATA:13B4
BIOSDATA:13B4 rsct_loop:			      ;	...
BIOSDATA:13B4		      insw		      ;	read in	sector
BIOSDATA:13B5		      loop    rsct_loop
BIOSDATA:13B7		      sti
BIOSDATA:13B8		      test    byte ptr ds:prndev2+1, 2 ; [cmd_block+cmd_reg]
BIOSDATA:13BD		      jz      short doc2
BIOSDATA:13BF		      push    cs
BIOSDATA:13C0		      call    wait_drq
BIOSDATA:13C3		      jb      short doc3
BIOSDATA:13C5		      mov     cx, 4	      ;	4 bytes	of ecc
BIOSDATA:13C8		      mov     dx, 1F0h
BIOSDATA:13CB		      cli
BIOSDATA:13CC		      rep insb		      ;	read in	ecc
BIOSDATA:13CE		      sti
BIOSDATA:13CF
BIOSDATA:13CF doc2:				      ;	...
BIOSDATA:13CF		      push    cs
BIOSDATA:13D0		      call    check_status
BIOSDATA:13D3		      jnz     short doc3
BIOSDATA:13D5		      dec     byte ptr ds:asc_3F+4 ; [cmd_block+sec_cnt]
BIOSDATA:13D9		      jnz     short doc1
BIOSDATA:13DB
BIOSDATA:13DB doc3:				      ;	...
BIOSDATA:13DB		      retn
BIOSDATA:13DB docmd	      endp
BIOSDATA:13DB
BIOSDATA:13DC
BIOSDATA:13DC ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:13DC
BIOSDATA:13DC
BIOSDATA:13DC get_vec	      proc near		      ;	...
BIOSDATA:13DC		      push    0FF65h	      ;	get pointer to hard disk parameters
BIOSDATA:13DF		      jmp     far ptr 0F000h:2F8Eh
BIOSDATA:13DF get_vec	      endp
BIOSDATA:13DF
BIOSDATA:13E4
BIOSDATA:13E4 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:13E4
BIOSDATA:13E4
BIOSDATA:13E4 command	      proc near		      ;	...
BIOSDATA:13E4		      push    0FF65h	      ;	send contents of cmd_block to disk controller
BIOSDATA:13E7		      jmp     far ptr 0F000h:2E1Eh
BIOSDATA:13E7 command	      endp
BIOSDATA:13E7
BIOSDATA:13EC
BIOSDATA:13EC ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:13EC
BIOSDATA:13EC
BIOSDATA:13EC waitt	      proc near		      ;	...
BIOSDATA:13EC		      push    0FF65h	      ;	wait for disk interrupt
BIOSDATA:13EF		      jmp     far ptr 0F000h:2E7Fh
BIOSDATA:13EF waitt	      endp
BIOSDATA:13EF
BIOSDATA:13F4
BIOSDATA:13F4 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:13F4
BIOSDATA:13F4
BIOSDATA:13F4 wait_drq	      proc near		      ;	...
BIOSDATA:13F4		      push    0FF65h	      ;	wait for data request
BIOSDATA:13F7		      jmp     far ptr 0F000h:2EE2h
BIOSDATA:13F7 wait_drq	      endp
BIOSDATA:13F7
BIOSDATA:13FC
BIOSDATA:13FC ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:13FC
BIOSDATA:13FC
BIOSDATA:13FC check_status    proc near		      ;	...
BIOSDATA:13FC		      push    0FF65h	      ;	check hard disk	status
BIOSDATA:13FF		      jmp     far ptr 0F000h:2EF8h
BIOSDATA:13FF check_status    endp
BIOSDATA:13FF
BIOSDATA:1404
BIOSDATA:1404 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:1404
BIOSDATA:1404
BIOSDATA:1404 check_dma	      proc near		      ;	...
BIOSDATA:1404		      push    0FF65h	      ;	check for dma overrun 64k segment
BIOSDATA:1407		      jmp     far ptr 0F000h:2F69h
BIOSDATA:1407 check_dma	      endp
BIOSDATA:1407
BIOSDATA:140C ;	---------------------------------------------------------------------------
BIOSDATA:140C
BIOSDATA:140C endatrom:				      ;	...
BIOSDATA:140C		      cmp     ah, 15h
BIOSDATA:140F		      ja      short mebbe_hookit
BIOSDATA:1411
BIOSDATA:1411 no_hookit:			      ;	...
BIOSDATA:1411		      jmp     cs:Old13
BIOSDATA:1416 ;	---------------------------------------------------------------------------
BIOSDATA:1416
BIOSDATA:1416 mebbe_hookit:			      ;	...
BIOSDATA:1416		      cmp     dl, 80h
BIOSDATA:1419		      jb      short no_hookit
BIOSDATA:141B		      push    ds
BIOSDATA:141C		      push    ax
BIOSDATA:141D		      mov     ax, 40h
BIOSDATA:1420		      mov     ds, ax
BIOSDATA:1422		      assume ds:nothing
BIOSDATA:1422		      pop     ax
BIOSDATA:1423		      pushf
BIOSDATA:1424		      call    cs:Old13
BIOSDATA:1429		      pop     ds
BIOSDATA:142A		      assume ds:nothing
BIOSDATA:142A		      retf    2
BIOSDATA:142A ;	---------------------------------------------------------------------------
BIOSDATA:142D end_compaq_i13hook db 0		      ;	...
BIOSDATA:142E ;	---------------------------------------------------------------------------
BIOSDATA:142E
BIOSDATA:142E daycnt_to_day:			      ;	...
BIOSDATA:142E		      push    cs:daycnt	      ;	entry: [daycnt]	= number of days since 1-1-80
BIOSDATA:142E					      ;	return:	ch - century in	bcd
BIOSDATA:142E					      ;		cl - year in bcd
BIOSDATA:142E					      ;		dh - month in bcd
BIOSDATA:142E					      ;		dl - day in bcd
BIOSDATA:1433		      cmp     cs:daycnt, 7305 ;	(365*20+(20/4))
BIOSDATA:1433					      ;	# days from 1-1-1980 to	1-1-2000
BIOSDATA:143A		      jnb     short century20
BIOSDATA:143C		      mov     cs:base_century, 19
BIOSDATA:1442		      mov     cs:base_year, 80
BIOSDATA:1448		      jmp     short years
BIOSDATA:144A ;	---------------------------------------------------------------------------
BIOSDATA:144A
BIOSDATA:144A century20:			      ;	...
BIOSDATA:144A		      mov     cs:base_century, 20
BIOSDATA:1450		      mov     cs:base_year, 0
BIOSDATA:1456		      sub     cs:daycnt, 7305 ;	365*20+(20/4))
BIOSDATA:1456					      ;	adjust daycnt
BIOSDATA:145D
BIOSDATA:145D years:				      ;	...
BIOSDATA:145D		      xor     dx, dx
BIOSDATA:145F		      mov     ax, cs:daycnt
BIOSDATA:1463		      mov     bx, 1461	      ;	366+365*3)
BIOSDATA:1463					      ;	# of days in a Leap year block
BIOSDATA:1466		      div     bx	      ;	ax = # of leap block, dx = daycnt
BIOSDATA:1468		      mov     cs:daycnt, dx   ;	save daycnt left
BIOSDATA:146D		      mov     bl, 4
BIOSDATA:146F		      mul     bl
BIOSDATA:1471		      add     cs:base_year, al ; ax = #	of years. Less than 100
BIOSDATA:1476		      inc     cs:daycnt
BIOSDATA:147B		      cmp     cs:daycnt, 366  ;	daycnt = remainder of leap year	block
BIOSDATA:147B					      ;	within 366+355+355+355 days
BIOSDATA:1482		      jbe     short leapyear
BIOSDATA:1484		      inc     cs:base_year    ;	if daycnt <= 366, then leap year
BIOSDATA:1484					      ;	else daycnt -= 366, base_year++
BIOSDATA:1489		      sub     cs:daycnt, 366
BIOSDATA:1490		      mov     cx, 3	      ;	And next three years are normal
BIOSDATA:1493
BIOSDATA:1493 regularyear:			      ;	...
BIOSDATA:1493		      cmp     cs:daycnt, 365  ;	for(i=1; i>3 or	daycnt <=365; i++)
BIOSDATA:149A		      jbe     short yeardone  ;	{if (daycnt > 365)
BIOSDATA:149C		      inc     cs:base_year    ;	{ daycnt -= 365
BIOSDATA:14A1		      sub     cs:daycnt, 365  ;	}
BIOSDATA:14A8		      loop    regularyear     ;	}
BIOSDATA:14A8					      ;	should never fall through loop
BIOSDATA:14AA
BIOSDATA:14AA leapyear:				      ;	...
BIOSDATA:14AA		      mov     cs:month_tab+1, 29 ; leap	year.
BIOSDATA:14AA					      ;	change month table.
BIOSDATA:14B0
BIOSDATA:14B0 yeardone:				      ;	...
BIOSDATA:14B0		      xor     bx, bx
BIOSDATA:14B2		      xor     dx, dx
BIOSDATA:14B4		      mov     ax, cs:daycnt
BIOSDATA:14B8		      mov     si, offset month_tab
BIOSDATA:14BB		      mov     cx, 12
BIOSDATA:14BE
BIOSDATA:14BE months:				      ;	...
BIOSDATA:14BE		      inc     bl
BIOSDATA:14C0		      mov     dl, [si]
BIOSDATA:14C2		      cmp     ax, dx	      ;	cmp daycnt for each month till fit
BIOSDATA:14C2					      ;	dh=0
BIOSDATA:14C4		      jbe     short month_done
BIOSDATA:14C6		      inc     si	      ;	next month
BIOSDATA:14C7		      sub     ax, dx	      ;	adjust daycnt
BIOSDATA:14C9		      loop    months	      ;
BIOSDATA:14C9					      ;	should never fall through loop
BIOSDATA:14CB
BIOSDATA:14CB month_done:			      ;	...
BIOSDATA:14CB		      mov     cs:month_tab+1, 28 ; restore month table value
BIOSDATA:14D1		      mov     dl, bl
BIOSDATA:14D3		      mov     dh, cs:base_year
BIOSDATA:14D8		      mov     cl, cs:base_century ; al=day,dl=month,dh=year,cl=cntry
BIOSDATA:14DD		      call    dword ptr	cs:bintobcd ; call far [cs:bintobcd]
BIOSDATA:14DD					      ;	convert	"day" to bcd
BIOSDATA:14DD					      ;	dl = bcd day, al = month
BIOSDATA:14E2		      xchg    dl, al
BIOSDATA:14E4		      call    dword ptr	cs:bintobcd ; dh = bcd month, al = year
BIOSDATA:14E9		      xchg    dh, al
BIOSDATA:14EB		      call    dword ptr	cs:bintobcd ; cl = bcd year, al	= century
BIOSDATA:14F0		      xchg    cl, al
BIOSDATA:14F2		      call    dword ptr	cs:bintobcd ; ch = bcd century
BIOSDATA:14F7		      mov     ch, al
BIOSDATA:14F9		      pop     cs:daycnt	      ;	restore	original value
BIOSDATA:14FE		      retf
BIOSDATA:14FF ;	---------------------------------------------------------------------------
BIOSDATA:14FF
BIOSDATA:14FF bin_to_bcd:			      ;	...
BIOSDATA:14FF		      push    cx	      ;	convert	a binary input in al
BIOSDATA:14FF					      ;	(less than 63h or 99 decimal)
BIOSDATA:14FF					      ;	into a bcd value in al.	ah destroyed
BIOSDATA:1500		      aam		      ;	AH = AL/10, AL = AL MOD	10
BIOSDATA:1502		      mov     cl, 4
BIOSDATA:1504		      shl     ah, cl
BIOSDATA:1506		      or      al, ah	      ;	AL = (AH*10h)+AL
BIOSDATA:1508		      pop     cx
BIOSDATA:1509		      retf
BIOSDATA:150A ;	---------------------------------------------------------------------------
BIOSDATA:150A
BIOSDATA:150A int6c:				      ;	...
BIOSDATA:150A		      push    cs	      ;	The K09	requires the routines for reading the clock
BIOSDATA:150A					      ;	because	of the suspend/resume facility.
BIOSDATA:150B		      pop     ds
BIOSDATA:150C		      pop     word ptr ds:int6c_ret_addr
BIOSDATA:1510		      pop     word ptr ds:int6c_ret_addr+2
BIOSDATA:1514		      popf
BIOSDATA:1515		      call    read_real_date  ;	get the	date from the clock
BIOSDATA:1518		      cli
BIOSDATA:1519		      mov     ds:daycnt, si   ;	update dos copy	of date
BIOSDATA:151D		      sti
BIOSDATA:151E		      call    read_real_time  ;	get the	time from the	rtc
BIOSDATA:1521		      cli
BIOSDATA:1522		      mov     ah, 1
BIOSDATA:1524		      int     1Ah	      ;	CLOCK -	SET TIME OF DAY
BIOSDATA:1524					      ;	CX:DX =	clock count
BIOSDATA:1524					      ;	Return:	time of	day set
BIOSDATA:1526		      sti
BIOSDATA:1527		      jmp     ds:int6c_ret_addr	; jmp far [int6c_ret_addr] ; long jump
BIOSDATA:152B
BIOSDATA:152B ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:152B
BIOSDATA:152B
BIOSDATA:152B read_real_date  proc near		      ;	...
BIOSDATA:152B		      push    ax
BIOSDATA:152C		      push    cx
BIOSDATA:152D		      push    dx
BIOSDATA:152E		      xor     ah, ah	      ;	throw away clock roll over
BIOSDATA:1530		      int     1Ah	      ;	CLOCK -	GET TIME OF DAY
BIOSDATA:1530					      ;	Return:	CX:DX =	clock count
BIOSDATA:1530					      ;	AL = 00h if clock was read or written (via AH=0,1) since the previous
BIOSDATA:1530					      ;	midnight
BIOSDATA:1530					      ;	Otherwise, AL >	0
BIOSDATA:1532		      pop     dx
BIOSDATA:1533		      pop     cx
BIOSDATA:1534		      pop     ax
BIOSDATA:1535		      push    ax
BIOSDATA:1536		      push    bx
BIOSDATA:1537		      push    cx
BIOSDATA:1538		      push    dx
BIOSDATA:1539		      mov     cs:daycnt2, 1
BIOSDATA:1540		      mov     ah, 4
BIOSDATA:1542		      int     1Ah	      ;	CLOCK -	READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
BIOSDATA:1542					      ;	Return:	DL = day in BCD
BIOSDATA:1542					      ;	DH = month in BCD
BIOSDATA:1542					      ;	CL = year in BCD
BIOSDATA:1542					      ;	CH = century (19h or 20h)
BIOSDATA:1544		      jnb     short read_ok
BIOSDATA:1546		      jmp     r_d_ret
BIOSDATA:1549 ;	---------------------------------------------------------------------------
BIOSDATA:1549
BIOSDATA:1549 read_ok:				      ;	...
BIOSDATA:1549		      mov     ds:bin_date_time,	ch
BIOSDATA:154D		      mov     ds:bin_date_time+1, cl
BIOSDATA:1551		      mov     ds:bin_date_time+2, dh
BIOSDATA:1555		      mov     ds:bin_date_time+3, dl
BIOSDATA:1559		      mov     cs:daycnt2, 2   ;	READ OF	R-T CLOCK SUCCESSFUL
BIOSDATA:1560		      call    bcd_verify      ;	verify bcd values in range
BIOSDATA:1563		      jb      short r_d_ret   ;	some value out of range
BIOSDATA:1565		      mov     cs:daycnt2, 3
BIOSDATA:156C		      call    date_verify
BIOSDATA:156F		      jb      short r_d_ret
BIOSDATA:1571		      mov     cs:daycnt2, 0
BIOSDATA:1578		      call    in_bin
BIOSDATA:157B		      mov     al, ds:bin_date_time+1
BIOSDATA:157E		      cbw
BIOSDATA:157F		      cmp     ds:bin_date_time,	20 ; 20th century?
BIOSDATA:1584		      jnz     short century_19
BIOSDATA:1586		      add     ax, 100	      ;	add in a century
BIOSDATA:1589
BIOSDATA:1589 century_19:			      ;	...
BIOSDATA:1589		      sub     ax, 80	      ;	subtract off 1-1-80
BIOSDATA:158C		      mov     cl, 4	      ;	leap year every	4
BIOSDATA:158E		      div     cl	      ;	al= # leap year	blocks,	ah= remainder
BIOSDATA:1590		      mov     bl, ah	      ;	save odd years
BIOSDATA:1592		      cbw		      ;	zero ah
BIOSDATA:1593		      mov     cx, 1461	      ;	366+(3*365)
BIOSDATA:1593					      ;	# of days in leap year blocks
BIOSDATA:1596		      mul     cx
BIOSDATA:1598		      mov     cs:daycnt2, ax  ;	SAVE COUNT OF DAYS
BIOSDATA:159C		      mov     al, bl	      ;	get odd	years count
BIOSDATA:159E		      cbw
BIOSDATA:159F		      or      ax, ax
BIOSDATA:15A1		      jz      short leap_year
BIOSDATA:15A3		      mov     cx, 365	      ;	days in	year
BIOSDATA:15A6		      mul     cx
BIOSDATA:15A8		      add     cs:daycnt2, ax  ;	ADD ON DAYS IN ODD YEARS
BIOSDATA:15AD		      jmp     short leap_adjustment ; account for leap year
BIOSDATA:15AD					      ;	possibly account for a leap day
BIOSDATA:15AF ;	---------------------------------------------------------------------------
BIOSDATA:15AF
BIOSDATA:15AF leap_year:			      ;	...
BIOSDATA:15AF		      cmp     ds:bin_date_time+2, 2 ; is month february?
BIOSDATA:15B4		      jbe     short no_leap_adjustment ; jan or	feb. no	leap day yet
BIOSDATA:15B6
BIOSDATA:15B6 leap_adjustment:			      ;	...
BIOSDATA:15B6		      inc     cs:daycnt2      ;	account	for leap day
BIOSDATA:15BB
BIOSDATA:15BB no_leap_adjustment:		      ;	...
BIOSDATA:15BB		      mov     cl, ds:bin_date_time+3 ; get days	of month
BIOSDATA:15BF		      xor     ch, ch
BIOSDATA:15C1		      dec     cx	      ;	because	of offset from day 1, not day 0
BIOSDATA:15C2		      add     cs:daycnt2, cx  ;	GET DAYS IN MONTHS PRECEEDING
BIOSDATA:15C7		      mov     cl, ds:bin_date_time+2 ; get month
BIOSDATA:15CB		      xor     ch, ch
BIOSDATA:15CD		      dec     cx	      ;	january	starts at offset 0
BIOSDATA:15CE		      shl     cx, 1	      ;	word offset
BIOSDATA:15D0		      mov     si, offset month_table
BIOSDATA:15D3		      add     si, cx
BIOSDATA:15D5		      mov     ax, [si]
BIOSDATA:15D7		      add     cs:daycnt2, ax
BIOSDATA:15DC
BIOSDATA:15DC r_d_ret:				      ;	...
BIOSDATA:15DC		      mov     si, cs:daycnt2
BIOSDATA:15E1		      pop     dx
BIOSDATA:15E2		      pop     cx
BIOSDATA:15E3		      pop     bx
BIOSDATA:15E4		      pop     ax
BIOSDATA:15E5		      retn
BIOSDATA:15E5 read_real_date  endp
BIOSDATA:15E5
BIOSDATA:15E6 ;	---------------------------------------------------------------------------
BIOSDATA:15E6 ;	START OF FUNCTION CHUNK	FOR read_real_time
BIOSDATA:15E6
BIOSDATA:15E6 r_t_retj:				      ;	...
BIOSDATA:15E6		      xor     cx, cx
BIOSDATA:15E8		      xor     dx, dx
BIOSDATA:15EA		      jmp     short r_t_ret
BIOSDATA:15EA ;	END OF FUNCTION	CHUNK FOR read_real_time
BIOSDATA:15EC
BIOSDATA:15EC ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:15EC
BIOSDATA:15EC
BIOSDATA:15EC read_real_time  proc near		      ;	...
BIOSDATA:15EC
BIOSDATA:15EC ;	FUNCTION CHUNK AT BIOSDATA:15E6	SIZE 00000006 BYTES
BIOSDATA:15EC
BIOSDATA:15EC		      mov     ah, 2
BIOSDATA:15EE		      int     1Ah	      ;	CLOCK -	READ REAL TIME CLOCK (AT,XT286,CONV,PS)
BIOSDATA:15EE					      ;	Return:	CH = hours in BCD
BIOSDATA:15EE					      ;	CL = minutes in	BCD
BIOSDATA:15EE					      ;	DH = seconds in	BCD
BIOSDATA:15F0		      jb      short r_t_retj
BIOSDATA:15F2
BIOSDATA:15F2 oktime:
BIOSDATA:15F2		      mov     ds:bin_date_time,	ch
BIOSDATA:15F6		      mov     ds:bin_date_time+1, cl
BIOSDATA:15FA		      mov     ds:bin_date_time+2, dh
BIOSDATA:15FE		      mov     ds:bin_date_time+3, 0
BIOSDATA:1603		      call    bcd_verify
BIOSDATA:1606		      jb      short r_t_retj
BIOSDATA:1608		      call    time_verify
BIOSDATA:160B		      jb      short r_t_retj
BIOSDATA:160D		      call    in_bin
BIOSDATA:1610		      mov     ch, ds:bin_date_time
BIOSDATA:1614		      mov     cl, ds:bin_date_time+1
BIOSDATA:1618		      mov     dh, ds:bin_date_time+2
BIOSDATA:161C		      mov     dl, ds:bin_date_time+3
BIOSDATA:1620		      call    dword ptr	ds:ttticks ; call far [ttticks]
BIOSDATA:1620					      ;	note: indirect far call
BIOSDATA:1620					      ;	cx:dx =	number of ticks
BIOSDATA:1620					      ;	(at 18.2 ticks per sec.)
BIOSDATA:1624
BIOSDATA:1624 r_t_ret:				      ;	...
BIOSDATA:1624		      retn
BIOSDATA:1624 read_real_time  endp
BIOSDATA:1624
BIOSDATA:1625
BIOSDATA:1625 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:1625
BIOSDATA:1625
BIOSDATA:1625 in_bin	      proc near		      ;	...
BIOSDATA:1625		      mov     al, ds:bin_date_time ; century or	hours
BIOSDATA:1628		      call    bcd_to_bin
BIOSDATA:162B		      mov     ds:bin_date_time,	al
BIOSDATA:162E		      mov     al, ds:bin_date_time+1 ; years or	minutes
BIOSDATA:1631		      call    bcd_to_bin
BIOSDATA:1634		      mov     ds:bin_date_time+1, al
BIOSDATA:1637		      mov     al, ds:bin_date_time+2 ; months or seconds
BIOSDATA:163A		      call    bcd_to_bin
BIOSDATA:163D		      mov     ds:bin_date_time+2, al
BIOSDATA:1640		      mov     al, ds:bin_date_time+3 ; days (not used for time)
BIOSDATA:1643		      call    bcd_to_bin
BIOSDATA:1646		      mov     ds:bin_date_time+3, al
BIOSDATA:1649		      retn
BIOSDATA:1649 in_bin	      endp
BIOSDATA:1649
BIOSDATA:164A
BIOSDATA:164A ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:164A
BIOSDATA:164A
BIOSDATA:164A bcd_to_bin      proc near		      ;	...
BIOSDATA:164A		      mov     ah, al	      ;	bcd_to_bin converts two	bcd nibbles in al
BIOSDATA:164A					      ;	(value <= 99.) to a binary representation in al
BIOSDATA:164C		      and     al, 0Fh
BIOSDATA:164E		      mov     cl, 4
BIOSDATA:1650		      shr     ah, cl
BIOSDATA:1652		      aad
BIOSDATA:1654		      retn
BIOSDATA:1654 bcd_to_bin      endp
BIOSDATA:1654
BIOSDATA:1655
BIOSDATA:1655 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:1655
BIOSDATA:1655
BIOSDATA:1655 date_verify     proc near		      ;	...
BIOSDATA:1655		      cmp     ds:bin_date_time,	20h ; century check
BIOSDATA:165A		      ja      short date_error
BIOSDATA:165C		      jz      short century_20 ; jmp in	21th century
BIOSDATA:165E		      cmp     ds:bin_date_time,	19h ; century check
BIOSDATA:1663		      jb      short date_error
BIOSDATA:1665		      cmp     ds:bin_date_time+1, 80h ;	year check
BIOSDATA:166A		      jb      short date_error
BIOSDATA:166C
BIOSDATA:166C century_20:			      ;	...
BIOSDATA:166C		      cmp     ds:bin_date_time+1, 99h ;	year check
BIOSDATA:1671		      ja      short date_error
BIOSDATA:1673		      cmp     ds:bin_date_time+2, 12h ;	month check
BIOSDATA:1678		      ja      short date_error
BIOSDATA:167A		      cmp     ds:bin_date_time+2, 0
BIOSDATA:167F		      jbe     short date_error
BIOSDATA:1681		      cmp     ds:bin_date_time+3, 31h ;	day check
BIOSDATA:1686		      ja      short date_error
BIOSDATA:1688		      cmp     ds:bin_date_time+3, 0
BIOSDATA:168D		      jbe     short date_error
BIOSDATA:168F		      clc
BIOSDATA:1690		      retn
BIOSDATA:1691 ;	---------------------------------------------------------------------------
BIOSDATA:1691
BIOSDATA:1691 date_error:			      ;	...
BIOSDATA:1691		      stc
BIOSDATA:1692		      retn
BIOSDATA:1692 date_verify     endp
BIOSDATA:1692
BIOSDATA:1693
BIOSDATA:1693 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:1693
BIOSDATA:1693
BIOSDATA:1693 time_verify     proc near		      ;	...
BIOSDATA:1693		      cmp     ds:bin_date_time,	24h ; hour check
BIOSDATA:1698		      ja      short time_error
BIOSDATA:169A		      cmp     ds:bin_date_time+1, 59h ;	minute check
BIOSDATA:169F		      ja      short time_error
BIOSDATA:16A1		      cmp     ds:bin_date_time+2, 59h ;	second check
BIOSDATA:16A6		      ja      short time_error
BIOSDATA:16A8		      clc
BIOSDATA:16A9		      retn
BIOSDATA:16AA ;	---------------------------------------------------------------------------
BIOSDATA:16AA
BIOSDATA:16AA time_error:			      ;	...
BIOSDATA:16AA		      stc
BIOSDATA:16AB		      retn
BIOSDATA:16AB time_verify     endp
BIOSDATA:16AB
BIOSDATA:16AC
BIOSDATA:16AC ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:16AC
BIOSDATA:16AC
BIOSDATA:16AC bcd_verify      proc near		      ;	...
BIOSDATA:16AC		      mov     cx, 4	      ;	4 bytes	to check
BIOSDATA:16AF		      mov     bx, offset bin_date_time
BIOSDATA:16B2
BIOSDATA:16B2 bv_loop:				      ;	...
BIOSDATA:16B2		      mov     al, [bx]	      ;	get a bcd number (0..99)
BIOSDATA:16B4		      mov     ah, al
BIOSDATA:16B6		      and     ax, 0F00Fh      ;	10's place in high ah, 1's in al
BIOSDATA:16B6					      ;	is 1's place in range?
BIOSDATA:16B9		      cmp     al, 10
BIOSDATA:16BB		      ja      short bv_error  ;	jmp out	of range
BIOSDATA:16BD		      shr     ah, 1
BIOSDATA:16BF		      shr     ah, 1
BIOSDATA:16C1		      shr     ah, 1
BIOSDATA:16C3		      shr     ah, 1
BIOSDATA:16C5		      and     ah, 0Fh	      ;	get rid	of any erroneous bits
BIOSDATA:16C8		      cmp     ah, 10	      ;	is 10's place in range
BIOSDATA:16CB		      ja      short bv_error  ;	jmp out	of range
BIOSDATA:16CD		      inc     bx
BIOSDATA:16CE		      dec     cx
BIOSDATA:16CF		      jnz     short bv_loop
BIOSDATA:16D1		      clc		      ;	set success flag
BIOSDATA:16D2		      retn
BIOSDATA:16D3 ;	---------------------------------------------------------------------------
BIOSDATA:16D3
BIOSDATA:16D3 bv_error:				      ;	...
BIOSDATA:16D3		      stc		      ;	set error flag
BIOSDATA:16D4		      retn
BIOSDATA:16D4 bcd_verify      endp
BIOSDATA:16D4
BIOSDATA:16D4 ;	---------------------------------------------------------------------------
BIOSDATA:16D5		      db 90h
BIOSDATA:16D6 drvfat	      dw 0		      ;	...
BIOSDATA:16D8 bios_l	      dw 0		      ;	...
BIOSDATA:16DA bios_h	      dw 0		      ;	...
BIOSDATA:16DC doscnt	      dw 0		      ;	...
BIOSDATA:16DE fbigfat	      db 0		      ;	...
BIOSDATA:16DF fatloc	      dw 0		      ;	...
BIOSDATA:16E1 init_bootseg    dw 0		      ;	...
BIOSDATA:16E3 rom_drv_num     db 80h		      ;	...
BIOSDATA:16E4 md_sectorsize   dw 512		      ;	...
BIOSDATA:16E6 temp_cluster    dw 0		      ;	...
BIOSDATA:16E8 last_fat_secnum dw 65535		      ;	...
BIOSDATA:16EA num_heads	      db 2		      ;	...
BIOSDATA:16EB sec_trk	      db 9		      ;	...
BIOSDATA:16EC num_cyln	      db 40		      ;	...
BIOSDATA:16ED fakefloppydrv   db 0		      ;	...
BIOSDATA:16EE disktable	      dw 512, 256, 64, 0      ;
BIOSDATA:16EE		      dw 2048, 513, 112, 0    ;	warning	!!! old	values
BIOSDATA:16EE		      dw 8192, 1026, 256, 0   ;	default	disktable under
BIOSDATA:16EE		      dw 32680,	2051, 512, 0  ;	the assumption of total	fat size <= 128	kb,
BIOSDATA:16EE		      dw 65535,	4100, 1024, 0 ;	and the	maximum	size of	fat entry = 16 bit.
BIOSDATA:1716 disktable2      dw 0, 32680, 2051, 512, 0	; ...
BIOSDATA:1716		      dw 4, 0, 1026, 512, 64  ;	fbig = 64 ; covers upto	134 mb media.
BIOSDATA:1716		      dw 8, 0, 2051, 512, 64  ;	upto 268 mb
BIOSDATA:1716		      dw 16, 0,	4100, 512, 64 ;	upto 536 mb
BIOSDATA:1716		      dw 32, 0,	8197, 512, 64 ;	upto 1072 mb
BIOSDATA:1716		      dw 64, 0,	16390, 512, 64 ; upto 2144 mb
BIOSDATA:1716		      dw 128, 0, 32775,	512, 64	; upto 4288 mb...
BIOSDATA:175C rom_minidisk_num db 0		      ;	...
BIOSDATA:175C					      ;	temp variable for phys unit
BIOSDATA:175D hnum	      db 0		      ;	...
BIOSDATA:175D					      ;	real number of hardfiles
BIOSDATA:175E last_dskdrv_table	dw offset dskdrvs     ;	...
BIOSDATA:175E					      ;	index into dskdrv table
BIOSDATA:1760 end_of_bdss     dw offset	bdss	      ;	...
BIOSDATA:1760					      ;	offset value of	the ending address of bds table.
BIOSDATA:1760					      ;	needed to figure out the dosdatasg address.
BIOSDATA:1762 mini_hdlim      dw 0		      ;	...
BIOSDATA:1764 mini_seclim     dw 0		      ;	...
BIOSDATA:1766 bios_date	      db '01/10/84',0         ; ...
BIOSDATA:1766					      ;	used for checking at rom bios	date.
BIOSDATA:176F		      db 90h		      ;	align 2
BIOSDATA:1770 bpb48t	      dw 512		      ;	...
BIOSDATA:1770					      ;	48 tpi diskettes ; physical sector size	in bytes
BIOSDATA:1772		      db 2
BIOSDATA:1773		      dw 1
BIOSDATA:1775		      db 2
BIOSDATA:1776		      dw 112
BIOSDATA:1778		      dw 720
BIOSDATA:177A		      db 0FDh
BIOSDATA:177B		      dw 2
BIOSDATA:177D		      dw 9
BIOSDATA:177F		      dw 2
BIOSDATA:1781		      dw 0
BIOSDATA:1783		      dw 0
BIOSDATA:1785		      dd 0
BIOSDATA:1789		      db 90h
BIOSDATA:178A bpb96t	      dw 512		      ;	...
BIOSDATA:178A					      ;	96 tpi diskettes ; physical sector size	in bytes
BIOSDATA:178C		      db 1
BIOSDATA:178D		      dw 1
BIOSDATA:178F		      db 2
BIOSDATA:1790		      dw 224
BIOSDATA:1792		      dw 2400
BIOSDATA:1794		      db 0F9h
BIOSDATA:1795		      dw 7
BIOSDATA:1797		      dw 15
BIOSDATA:1799		      dw 2
BIOSDATA:179B		      dw 0
BIOSDATA:179D		      dw 0
BIOSDATA:179F		      db 0
BIOSDATA:17A0		      db 0
BIOSDATA:17A1		      db 0
BIOSDATA:17A2		      db 0
BIOSDATA:17A3		      db 90h
BIOSDATA:17A4 bpb35	      dw 512		      ;	...
BIOSDATA:17A4					      ;	3.5" diskettes ; physical sector size in bytes
BIOSDATA:17A6		      db 2		      ;	sectors/allocation unit
BIOSDATA:17A7		      dw 1		      ;	reserved sectors for dos
BIOSDATA:17A9		      db 2		      ;	number of allocation tables
BIOSDATA:17AA		      dw 112		      ;	number of directory entries
BIOSDATA:17AC		      dw 1440		      ;	number of sectors (at 512 bytes	each)
BIOSDATA:17AE		      db 0F9h		      ;	media descriptor
BIOSDATA:17AF		      dw 3		      ;	number of fat sectors
BIOSDATA:17B1		      dw 9		      ;	sectors	per track
BIOSDATA:17B3		      dw 2		      ;	heads
BIOSDATA:17B5		      dw 0		      ;	hidden sector count (low word)
BIOSDATA:17B7		      dw 0		      ;	hidden sector (high)
BIOSDATA:17B9		      dd 0		      ;	number of sectors
BIOSDATA:17BD		      db 90h
BIOSDATA:17BE bpb288	      dw 512		      ;	...
BIOSDATA:17BE					      ;	3.5" diskettes - 2.88 MB ; physical sector size	in bytes
BIOSDATA:17C0		      db 2
BIOSDATA:17C1		      dw 1
BIOSDATA:17C3		      db 2
BIOSDATA:17C4		      dw 240
BIOSDATA:17C6		      dw 5760
BIOSDATA:17C8		      db 0F0h ;	ð
BIOSDATA:17C9		      dw 9
BIOSDATA:17CB		      dw 36
BIOSDATA:17CD		      dw 2
BIOSDATA:17CF		      dw 0
BIOSDATA:17D1		      dw 0
BIOSDATA:17D3		      dd 0
BIOSDATA:17D7		      db 90h
BIOSDATA:17D8 bpbtable	      dw offset	bpb48t	      ;	...
BIOSDATA:17D8					      ;	48tpi drives
BIOSDATA:17DA		      dw offset	bpb96t	      ;	96tpi drives
BIOSDATA:17DC		      dw offset	bpb35	      ;	3.5" drives
BIOSDATA:17DE		      dw offset	bpb35	      ;	unused 8" diskette
BIOSDATA:17E0		      dw offset	bpb35	      ;	unused 8" diskette
BIOSDATA:17E2		      dw offset	bpb35	      ;	used for hard disk
BIOSDATA:17E4		      dw offset	bpb35	      ;	used for tape drive
BIOSDATA:17E6		      dw offset	bpb35	      ;	FFOTHER
BIOSDATA:17E8		      dw offset	bpb35	      ;	ERIMO
BIOSDATA:17EA		      dw offset	bpb288	      ;	2.88MB drive
BIOSDATA:17EC addr_of_bcretf  dw offset	bc_retf	      ;	...
BIOSDATA:17EE
BIOSDATA:17EE ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:17EE
BIOSDATA:17EE
BIOSDATA:17EE call_bios_code  proc far		      ;	...
BIOSDATA:17EE		      push    cs:addr_of_bcretf	; set up near return to	far return
BIOSDATA:17F3		      push    cs:cdev_2	      ;	push Bios_Code segment
BIOSDATA:17F8		      push    bp	      ;	save offset of utility function
BIOSDATA:17F9		      retf		      ;	far jump to (DOS)BIOS code
BIOSDATA:17F9 call_bios_code  endp
BIOSDATA:17F9
BIOSDATA:17F9 ;	---------------------------------------------------------------------------
BIOSDATA:17FA flp_drvs	      db 0		      ;	...
BIOSDATA:17FB ;	---------------------------------------------------------------------------
BIOSDATA:17FB
BIOSDATA:17FB init:				      ;	...
BIOSDATA:17FB		      cli		      ;	entry from boot	sector.	the register contents are:
BIOSDATA:17FB					      ;
BIOSDATA:17FB					      ;	dl = int 13 drive number we booted from
BIOSDATA:17FB					      ;	ch = media byte
BIOSDATA:17FB					      ;	bx = first data	sector on disk.
BIOSDATA:17FB					      ;	ax = first data	sector (high)
BIOSDATA:17FB					      ;	di = sectors/fat for the boot media.
BIOSDATA:17FC		      push    ax
BIOSDATA:17FD		      xor     ax, ax
BIOSDATA:17FF		      mov     ds, ax
BIOSDATA:1801		      pop     ax
BIOSDATA:1802		      mov     cs:bios_h, ax
BIOSDATA:1806		      mov     cs:bios_l, bx
BIOSDATA:180B		      push    cs
BIOSDATA:180C		      pop     es
BIOSDATA:180D		      assume es:nothing
BIOSDATA:180D		      push    cx
BIOSDATA:180E		      push    di
BIOSDATA:180F		      push    ds
BIOSDATA:1810		      mov     ax, 473h	      ;	SYSINIT	segment
BIOSDATA:1813		      mov     ds, ax
BIOSDATA:1815		      assume ds:nothing
BIOSDATA:1815		      mov     si, offset StartMsg ; "Starting MS-DOS...\r\n\n"
BIOSDATA:1818
BIOSDATA:1818 startmsg_nxt_chr:			      ;	...
BIOSDATA:1818		      lodsb
BIOSDATA:1819		      or      al, al
BIOSDATA:181B		      jz      short startmsg_ok
BIOSDATA:181D		      mov     ah, 0Eh
BIOSDATA:181F		      mov     bx, 7
BIOSDATA:1822		      int     10h	      ;	- VIDEO	- WRITE	CHARACTER AND ADVANCE CURSOR (TTY WRITE)
BIOSDATA:1822					      ;	AL = character,	BH = display page (alpha modes)
BIOSDATA:1822					      ;	BL = foreground	color (graphics	modes)
BIOSDATA:1824		      jmp     short startmsg_nxt_chr
BIOSDATA:1826 ;	---------------------------------------------------------------------------
BIOSDATA:1826
BIOSDATA:1826 startmsg_ok:			      ;	...
BIOSDATA:1826		      pop     ds
BIOSDATA:1827		      assume ds:nothing
BIOSDATA:1827		      mov     cx, 5
BIOSDATA:182A		      mov     si, offset RomVectors
BIOSDATA:182D
BIOSDATA:182D next_int:				      ;	...
BIOSDATA:182D		      lods    byte ptr cs:[si]
BIOSDATA:182F		      cbw
BIOSDATA:1830		      shl     ax, 1
BIOSDATA:1832		      shl     ax, 1
BIOSDATA:1834		      mov     di, ax
BIOSDATA:1836		      xchg    si, di
BIOSDATA:1838		      lodsw
BIOSDATA:1839		      stosw
BIOSDATA:183A		      lodsw
BIOSDATA:183B		      stosw
BIOSDATA:183C		      xchg    si, di
BIOSDATA:183E		      loop    next_int
BIOSDATA:1840		      pop     di
BIOSDATA:1841		      pop     cx
BIOSDATA:1842		      mov     ax, word ptr cs:Old13
BIOSDATA:1846		      mov     word ptr cs:Orig13, ax
BIOSDATA:184A		      mov     ax, word ptr cs:Old13+2
BIOSDATA:184E		      mov     word ptr cs:Orig13+2, ax
BIOSDATA:1852		      mov     ds:004Ch,	offset block13 ; Int 13h vector
BIOSDATA:1858		      mov     ds:004Eh,	cs
BIOSDATA:185C		      mov     word ptr ds:0054h, offset	Int15 ;	Int 15h	vector
BIOSDATA:1862		      mov     word ptr ds:0056h, cs
BIOSDATA:1866		      mov     word ptr ds:0064h, offset	int19 ;	Int 19h	vector
BIOSDATA:186C		      mov     word ptr ds:0066h, cs
BIOSDATA:1870		      sti
BIOSDATA:1871		      int     11h	      ;	EQUIPMENT DETERMINATION
BIOSDATA:1871					      ;	Return:	AX = equipment flag bits
BIOSDATA:1873		      test    ax, 1	      ;	floppy drives present ?
BIOSDATA:1876		      jnz     short normalfloppydrv ; yes
BIOSDATA:1878		      push    ax
BIOSDATA:1879		      push    bx
BIOSDATA:187A		      push    cx
BIOSDATA:187B		      push    dx
BIOSDATA:187C		      push    di
BIOSDATA:187D		      push    es
BIOSDATA:187E		      mov     ah, 8
BIOSDATA:1880		      mov     dl, 0
BIOSDATA:1882		      int     13h	      ;	DISK - DISK - GET CURRENT DRIVE	PARAMETERS (XT,AT,XT286,CONV,PS)
BIOSDATA:1882					      ;	DL = drive number
BIOSDATA:1882					      ;	Return:	CF set on error, AH = status code, BL =	drive type
BIOSDATA:1882					      ;	DL = number of consecutive drives
BIOSDATA:1882					      ;	DH = maximum value for head number, ES:DI -> drive parameter
BIOSDATA:1884		      jb      short _gdskp_error
BIOSDATA:1886		      mov     cs:flp_drvs, dl
BIOSDATA:188B
BIOSDATA:188B _gdskp_error:			      ;	...
BIOSDATA:188B		      pop     es
BIOSDATA:188C		      assume es:nothing
BIOSDATA:188C		      pop     di
BIOSDATA:188D		      pop     dx
BIOSDATA:188E		      pop     cx
BIOSDATA:188F		      pop     bx
BIOSDATA:1890		      pop     ax
BIOSDATA:1891		      jb      short normalfloppydrv ; if error it is an	old ROM	BIOS
BIOSDATA:1891					      ;	so, lets assume	that ROM BIOS lied
BIOSDATA:1893		      cmp     cs:flp_drvs, 0
BIOSDATA:1899		      jz      short _set_fake_flpdrv
BIOSDATA:189B		      mov     al, cs:flp_drvs
BIOSDATA:189F		      dec     al
BIOSDATA:18A1		      jmp     short got_num_flp_drvs
BIOSDATA:18A3 ;	---------------------------------------------------------------------------
BIOSDATA:18A3
BIOSDATA:18A3 _set_fake_flpdrv:			      ;	...
BIOSDATA:18A3		      mov     cs:fakefloppydrv,	1 ; we don't have any floppy drives.
BIOSDATA:18A9		      mov     ax, 1
BIOSDATA:18AC		      jmp     short settwodrive	; well then set	it for two drives!
BIOSDATA:18AE ;	---------------------------------------------------------------------------
BIOSDATA:18AE
BIOSDATA:18AE normalfloppydrv:			      ;	...
BIOSDATA:18AE		      rol     al, 1	      ;	there exist floppy drives.
BIOSDATA:18AE					      ;	put bits 6 & 7 into bits 0 & 1
BIOSDATA:18B0		      rol     al, 1
BIOSDATA:18B2
BIOSDATA:18B2 got_num_flp_drvs:			      ;	...
BIOSDATA:18B2		      and     ax, 3	      ;	only look at bits 0 & 1
BIOSDATA:18B5		      jnz     short notsingle ;	zero means single drive	system
BIOSDATA:18B7		      inc     ax	      ;	pretend	it's a two drive system
BIOSDATA:18B7					      ;	set this to two	fakedrives
BIOSDATA:18B8
BIOSDATA:18B8 settwodrive:			      ;	...
BIOSDATA:18B8		      inc     cs:single
BIOSDATA:18BD
BIOSDATA:18BD notsingle:			      ;	...
BIOSDATA:18BD		      inc     ax	      ;	ax has number of drives
BIOSDATA:18BE		      mov     cl, al
BIOSDATA:18C0		      test    dl, 80h	      ;	determine whether we booted from floppy	or hard	disk..
BIOSDATA:18C3		      jnz     short gothrd    ;	hard disk
BIOSDATA:18C5		      xor     ax, ax	      ;	indicate boot from drive A
BIOSDATA:18C7
BIOSDATA:18C7 gothrd:				      ;	...
BIOSDATA:18C7		      xor     dx, dx	      ;	ax = 0-based drive we booted from
BIOSDATA:18C7					      ;	bios_l,	bios_h set.
BIOSDATA:18C7					      ;	cl = number of floppies	including fake one
BIOSDATA:18C7					      ;	ch = media byte
BIOSDATA:18C9		      cli
BIOSDATA:18CA		      mov     ss, dx
BIOSDATA:18CC		      mov     sp, 700h
BIOSDATA:18CF		      sti
BIOSDATA:18D0		      push    cx
BIOSDATA:18D1		      mov     ah, ch
BIOSDATA:18D3		      push    ax	      ;	save boot drive	number and media byte
BIOSDATA:18D4		      mov     ah, 0C0h
BIOSDATA:18D6		      int     15h	      ;	SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT	mdl 3x9,CONV,XT286,PS)
BIOSDATA:18D8		      jb      short no_rom_system_conf
BIOSDATA:18DA		      cmp     ah, 0
BIOSDATA:18DD		      jnz     short no_rom_system_conf
BIOSDATA:18DF		      mov     al, es:[bx+2]   ;	[es:bx+ROMBIOS_DESC.bios_sd_modelbyte]
BIOSDATA:18E3		      mov     cs:model_byte, al
BIOSDATA:18E7		      mov     al, es:[bx+3]   ;	[es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]
BIOSDATA:18EB		      mov     cs:secondary_model_byte, al
BIOSDATA:18EF		      jmp     short turn_timer_on
BIOSDATA:18F1 ;	---------------------------------------------------------------------------
BIOSDATA:18F1
BIOSDATA:18F1 no_rom_system_conf:		      ;	...
BIOSDATA:18F1		      mov     si, 0FFFFh
BIOSDATA:18F4		      mov     es, si
BIOSDATA:18F6		      assume es:nothing
BIOSDATA:18F6		      mov     al, es:0Eh      ;	get model byte (from 0FFFFh:0Eh)
BIOSDATA:18FA		      mov     cs:model_byte, al
BIOSDATA:18FE
BIOSDATA:18FE turn_timer_on:			      ;	...
BIOSDATA:18FE		      mov     al, 20h	      ;	turn on	the timer
BIOSDATA:1900		      out     20h, al	      ;	Interrupt controller, 8259A.
BIOSDATA:1902		      cmp     cs:model_byte, 0 ; Olivetti m24 check
BIOSDATA:1908		      jnz     short not_olivetti_m24
BIOSDATA:190A		      in      al, 66h	      ;	inhibit	the normal aux port initialization
BIOSDATA:190C		      test    al, 20h
BIOSDATA:190E		      jz      short not_olivetti_m24
BIOSDATA:1910		      mov     al, 0Fh	      ;	double check
BIOSDATA:1912		      out     50h, al
BIOSDATA:1914		      in      al, 50h
BIOSDATA:1916		      test    al, 1	      ;	this test was copied from olivetti
BIOSDATA:1918		      jz      short skip_aux_port_init ; take this branch if 8530 installed
BIOSDATA:191A
BIOSDATA:191A not_olivetti_m24:			      ;	...
BIOSDATA:191A		      mov     al, 3	      ;	init com4
BIOSDATA:191C		      call    aux_init
BIOSDATA:191F		      mov     al, 2	      ;	init com3
BIOSDATA:1921		      call    aux_init
BIOSDATA:1924		      mov     al, 1	      ;	init com2
BIOSDATA:1926		      call    aux_init
BIOSDATA:1929		      xor     al, al	      ;	init com1
BIOSDATA:192B		      call    aux_init
BIOSDATA:192E
BIOSDATA:192E skip_aux_port_init:		      ;	...
BIOSDATA:192E		      mov     al, 2	      ;	init lpt3
BIOSDATA:1930		      call    print_init
BIOSDATA:1933		      mov     al, 1	      ;	init lpt2
BIOSDATA:1935		      call    print_init
BIOSDATA:1938		      xor     al, al	      ;	init lpt1
BIOSDATA:193A		      call    print_init
BIOSDATA:193D		      xor     dx, dx
BIOSDATA:193F		      mov     ds, dx	      ;	to initialize print screen vector
BIOSDATA:1941		      mov     es, dx
BIOSDATA:1943		      assume es:nothing
BIOSDATA:1943		      xor     ax, ax	      ;	0
BIOSDATA:1945		      mov     di, 534h	      ;	INITSPOT
BIOSDATA:1948		      stosw		      ;	IBM wants 4 zeros here
BIOSDATA:1949		      stosw
BIOSDATA:194A		      mov     ax, cs	      ;	fetch segment
BIOSDATA:194C		      mov     ds:006Ch,	offset cbreak
BIOSDATA:1952		      mov     ds:006Eh,	ax    ;	[BRKADR]
BIOSDATA:1955		      mov     ds:00A4h,	offset outchr ;	[CHROUT*4]
BIOSDATA:195B		      mov     ds:00A6h,	ax
BIOSDATA:195E		      mov     di, 4
BIOSDATA:1961		      mov     bx, offset intret
BIOSDATA:1964		      xchg    ax, bx
BIOSDATA:1965		      stosw		      ;	location 4
BIOSDATA:1966		      xchg    ax, bx
BIOSDATA:1967		      stosw		      ;	cs:
BIOSDATA:1968		      add     di, 4
BIOSDATA:196B		      xchg    ax, bx
BIOSDATA:196C		      stosw		      ;	location 12
BIOSDATA:196D		      xchg    ax, bx
BIOSDATA:196E		      stosw		      ;	cs:
BIOSDATA:196F		      xchg    ax, bx
BIOSDATA:1970		      stosw		      ;	location 16
BIOSDATA:1971		      xchg    ax, bx
BIOSDATA:1972		      stosw		      ;	cs:
BIOSDATA:1973		      mov     word ptr ds:0500h, dx ; 0	 ; Print screen	status byte (not active)
BIOSDATA:1977		      mov     ds:0504h,	dx    ;	0 ; DOS	single diskette	mode flag, 0=A:, 1=B:
BIOSDATA:197B		      mov     al, byte ptr ds:052Ch ; [SEC9+DISK_PARMS.DISK_MOTOR_STRT]
BIOSDATA:197E		      mov     cs:motorstartup, al
BIOSDATA:1982		      cmp     cs:model_byte, 0FDh ; is this an old rom?
BIOSDATA:1988		      jb      short no_diddle ;	no
BIOSDATA:198A		      mov     ds:052Bh,	20Fh  ;	[SEC9+DISK_PARMS.DISK_HEAD_STTL], 0200h+NORMSETTLE
BIOSDATA:1990		      mov     byte ptr ds:0522h, 0DFh ;	[SEC9+DISK_PARMS.DISK_SPECIFY_1]
BIOSDATA:1990					      ;	set 1st	specify	byte on	pc-1 pc-2 pc-xt	hal0
BIOSDATA:1995
BIOSDATA:1995 no_diddle:			      ;	...
BIOSDATA:1995		      int     12h	      ;	MEMORY SIZE -
BIOSDATA:1995					      ;	Return:	AX = number of contiguous 1K blocks of memory
BIOSDATA:1997		      mov     cl, 6
BIOSDATA:1999		      shl     ax, cl	      ;	convert	memory size to 16-byte blocks (segment no.)
BIOSDATA:199B		      pop     cx
BIOSDATA:199C		      mov     cs:drvfat, cx
BIOSDATA:19A1		      push    ax	      ;	save real top of memory
BIOSDATA:19A2		      push    ds
BIOSDATA:19A3		      push    bx
BIOSDATA:19A4		      xor     bx, bx
BIOSDATA:19A6		      mov     ds, bx
BIOSDATA:19A8		      mov     bx, ds:00BCh    ;	[2Fh*4]
BIOSDATA:19AC		      mov     ds, ds:00BEh
BIOSDATA:19B0		      cmp     word ptr [bx+3], 5052h ; 'RPL'
BIOSDATA:19B5		      jnz     short SkipRPL
BIOSDATA:19B7		      cmp     byte ptr [bx+5], 4Ch ; 'L'
BIOSDATA:19BB		      jnz     short SkipRPL
BIOSDATA:19BD		      mov     dx, ax	      ;	get TOM	into DX
BIOSDATA:19BF		      mov     ax, 4A06h	      ;	(multMULT shl 8) + multMULTRPLTOM
BIOSDATA:19C2		      int     2Fh	      ;	Get new	TOM from any RPL
BIOSDATA:19C4		      mov     ax, dx
BIOSDATA:19C6
BIOSDATA:19C6 SkipRPL:				      ;	...
BIOSDATA:19C6		      pop     bx
BIOSDATA:19C7		      pop     ds
BIOSDATA:19C8		      sub     ax, 40h	      ;	room for fatloc	segment. (1 kb buffer)
BIOSDATA:19CB		      mov     cs:fatloc, ax   ;	location to read fat
BIOSDATA:19CF		      sub     ax, 40h
BIOSDATA:19D2		      mov     cs:init_bootseg, ax
BIOSDATA:19D6		      pop     ax
BIOSDATA:19D7		      mov     dx, 473h	      ;	SYSINIT	segment
BIOSDATA:19DA		      mov     ds, dx
BIOSDATA:19DC		      assume ds:nothing
BIOSDATA:19DC		      mov     word ptr ds:DEVICE_LIST, offset res_dev_list
BIOSDATA:19E2		      mov     word ptr ds:DEVICE_LIST+2, cs
BIOSDATA:19E6		      mov     ds:MEMORY_SIZE, ax
BIOSDATA:19E9		      inc     cl
BIOSDATA:19EB		      mov     ds:DEFAULT_DRIVE,	cl
BIOSDATA:19EF		      mov     ds:CURRENT_DOS_LOCATION, 9FDh ; DOSLOADSEG
BIOSDATA:19F5		      mov     ax, 473h	      ;	SYSINIT	segment
BIOSDATA:19F8		      mov     es, ax
BIOSDATA:19FA		      assume es:nothing
BIOSDATA:19FA		      xor     ax, ax	      ;	some old ibm hardware generates	spurious int 0F's
BIOSDATA:19FA					      ;	due to bogus printer cards.
BIOSDATA:19FA					      ;	we initialize this value to point to an	iret
BIOSDATA:19FA					      ;	only if
BIOSDATA:19FA					      ;	   1) the original segment points to
BIOSDATA:19FA					      ;	      storage inside valid ram.
BIOSDATA:19FA					      ;	   2) the original segment is 0F000:xxxx
BIOSDATA:19FC		      mov     ds, ax	      ;	0
BIOSDATA:19FE		      assume ds:nothing
BIOSDATA:19FE		      mov     ax, ds:3Eh      ;	segment	for INT	0Fh
BIOSDATA:1A01		      cmp     ax, es:MEMORY_SIZE ; es:294h
BIOSDATA:1A01					      ;	(condition 1)
BIOSDATA:1A06		      jbe     short resetintf
BIOSDATA:1A08		      cmp     ax, 0F000h      ;	(condition 2)
BIOSDATA:1A0B		      jnz     short keepintf
BIOSDATA:1A0D
BIOSDATA:1A0D resetintf:			      ;	...
BIOSDATA:1A0D		      mov     ds:3Ch, offset intret ; [0Fh*4]
BIOSDATA:1A13		      mov     ds:3Eh, cs
BIOSDATA:1A17
BIOSDATA:1A17 keepintf:				      ;	...
BIOSDATA:1A17		      xor     cx, cx
BIOSDATA:1A19		      mov     ds, cx
BIOSDATA:1A1B		      mov     cl, ds:0496h    ;	get keyboard flag
BIOSDATA:1A1F		      test    cl, 10h	      ;	extended keyboard ?
BIOSDATA:1A22		      jz      short org_key   ;	no, original keyboard
BIOSDATA:1A22					      ;	change for extended keyboard functions
BIOSDATA:1A24		      mov     cs:keyrd_func, 10h
BIOSDATA:1A2A		      mov     cs:keysts_func, 11h
BIOSDATA:1A30
BIOSDATA:1A30 org_key:				      ;	...
BIOSDATA:1A30		      push    cs
BIOSDATA:1A31		      pop     ds
BIOSDATA:1A32		      push    cs
BIOSDATA:1A33		      pop     es
BIOSDATA:1A34		      assume es:nothing
BIOSDATA:1A34		      call    cmos_clock_read ;	If cmos	clock exists,
BIOSDATA:1A34					      ;	then set the system time according to that.
BIOSDATA:1A34					      ;	also, reset the	cmos clock rate.
BIOSDATA:1A37		      mov     word ptr ds:BData_start, offset harddrv ;	hdrv_pat
BIOSDATA:1A37					      ;	set up pointer to hdrive
BIOSDATA:1A3D		      pop     ax	      ;	number of floppies and FAT ID
BIOSDATA:1A3E		      xor     ah, ah	      ;	chuck fat id byte
BIOSDATA:1A40		      mov     ds:drvmax, al   ;	remember which drive is	hard disk
BIOSDATA:1A43		      mov     ds:dsktnum, al  ;	and set	initial	number of drives
BIOSDATA:1A46		      shl     ax, 1
BIOSDATA:1A48		      add     ds:last_dskdrv_table, ax
BIOSDATA:1A4C		      push    ds
BIOSDATA:1A4D		      mov     ax, 0F000h      ;	point to ROM BIOS
BIOSDATA:1A50		      mov     ds, ax
BIOSDATA:1A52		      assume ds:nothing
BIOSDATA:1A52		      cmp     word ptr ds:0FFEAh, 4F43h	; 'OC' ; look for COMPAQ
BIOSDATA:1A58		      jnz     short skip_mode2
BIOSDATA:1A5A		      cmp     word ptr ds:0FFECh, 504Dh	; 'PM'
BIOSDATA:1A60		      jnz     short skip_mode2
BIOSDATA:1A62		      cmp     word ptr ds:0FFEEh, 5141h	; 'QA'
BIOSDATA:1A68		      jnz     short skip_mode2
BIOSDATA:1A6A		      mov     ax, 0E400h
BIOSDATA:1A6D		      int     15h	      ;	OS HOOK	- DEVICE OPEN (AT,XT2,XT286,PS)
BIOSDATA:1A6D					      ;	BX = device ID,	CX = process type
BIOSDATA:1A6D					      ;	Return:	CF set on error, AH = status
BIOSDATA:1A6D					      ;	CF clear if successful,	AH = 00h
BIOSDATA:1A6F		      jb      short skip_mode2
BIOSDATA:1A71		      or      bx, 40h	      ;	enable mode 2
BIOSDATA:1A71					      ;	(dual hard disk	controllers on Compaq systems)
BIOSDATA:1A74		      mov     ax, 0E480h
BIOSDATA:1A77		      int     15h	      ;	OS HOOK	- DEVICE OPEN (AT,XT2,XT286,PS)
BIOSDATA:1A77					      ;	BX = device ID,	CX = process type
BIOSDATA:1A77					      ;	Return:	CF set on error, AH = status
BIOSDATA:1A77					      ;	CF clear if successful,	AH = 00h
BIOSDATA:1A79
BIOSDATA:1A79 skip_mode2:			      ;	...
BIOSDATA:1A79		      pop     ds
BIOSDATA:1A7A		      assume ds:nothing
BIOSDATA:1A7A		      mov     dl, 80h
BIOSDATA:1A7C		      mov     ah, 8
BIOSDATA:1A7E		      int     13h	      ;	DISK - DISK - GET CURRENT DRIVE	PARAMETERS (XT,AT,XT286,CONV,PS)
BIOSDATA:1A7E					      ;	DL = drive number
BIOSDATA:1A7E					      ;	Return:	CF set on error, AH = status code, BL =	drive type
BIOSDATA:1A7E					      ;	DL = number of consecutive drives
BIOSDATA:1A7E					      ;	DH = maximum value for head number, ES:DI -> drive parameter
BIOSDATA:1A80		      jb      short enddrv
BIOSDATA:1A82		      mov     ds:hnum, dl
BIOSDATA:1A86
BIOSDATA:1A86 enddrv:				      ;	...
BIOSDATA:1A86		      xor     dl, dl	      ;	scan the list of drives	to determine their type.
BIOSDATA:1A86					      ;	we have	three flavors of diskette drives:
BIOSDATA:1A86					      ;
BIOSDATA:1A86					      ;	48tpi drives  we do nothing special for	them
BIOSDATA:1A86					      ;	96tpi drives  mark the fact that they have changeline support.
BIOSDATA:1A86					      ;	3.5"  drives  mark changeline support and small.
BIOSDATA:1A86					      ;
BIOSDATA:1A86					      ;	the following code uses	registers for certain values:
BIOSDATA:1A86					      ;
BIOSDATA:1A86					      ;	   dl -	physical drive
BIOSDATA:1A86					      ;	   ds:di - points to current bds
BIOSDATA:1A86					      ;	   cx -	flag bits for bds
BIOSDATA:1A86					      ;	   dh -	form factor for	the drive
BIOSDATA:1A86					      ;	       (1 - 48tpi, 2 - 96tpi, 3	- 3.5" medium)
BIOSDATA:1A88		      push    cs
BIOSDATA:1A89		      pop     ds
BIOSDATA:1A8A		      mov     ds:eot, 9
BIOSDATA:1A8F		      mov     di, offset start_bds
BIOSDATA:1A92		      cmp     ds:fakefloppydrv,	1
BIOSDATA:1A97		      jnz     short loop_drive
BIOSDATA:1A99		      mov     di, [di]	      ;	[di+BDS.link] ;	di <- first bds	link
BIOSDATA:1A9B		      mov     di, [di]	      ;	[di+BDS.link] ;	di <- second bds link
BIOSDATA:1A9D		      mov     word ptr [di], 0FFFFh ; -1 ; set end of link
BIOSDATA:1AA1		      jmp     dohard	      ;	allocate/initialise bds	for harddrives
BIOSDATA:1AA4 ;	---------------------------------------------------------------------------
BIOSDATA:1AA4
BIOSDATA:1AA4 loop_drive:			      ;	...
BIOSDATA:1AA4		      cmp     dl, ds:drvmax
BIOSDATA:1AA8		      jb      short got_more
BIOSDATA:1AAA		      jmp     done_drives
BIOSDATA:1AAD ;	---------------------------------------------------------------------------
BIOSDATA:1AAD
BIOSDATA:1AAD got_more:				      ;	...
BIOSDATA:1AAD		      xor     cx, cx	      ;	zero all flags
BIOSDATA:1AAF		      mov     di, [di]	      ;	mov di,[di+BDS.link] ; get next	bds
BIOSDATA:1AB1		      mov     dh, 0	      ;	ff48tpi	; set form factor to 48	tpi
BIOSDATA:1AB3		      mov     ds:num_cyln, 40
BIOSDATA:1AB8		      push    ds
BIOSDATA:1AB9		      push    di
BIOSDATA:1ABA		      push    dx
BIOSDATA:1ABB		      push    cx
BIOSDATA:1ABC		      push    es
BIOSDATA:1ABD		      mov     ah, 8
BIOSDATA:1ABF		      int     13h	      ;	DISK - DISK - GET CURRENT DRIVE	PARAMETERS (XT,AT,XT286,CONV,PS)
BIOSDATA:1ABF					      ;	DL = drive number
BIOSDATA:1ABF					      ;	Return:	CF set on error, AH = status code, BL =	drive type
BIOSDATA:1ABF					      ;	DL = number of consecutive drives
BIOSDATA:1ABF					      ;	DH = maximum value for head number, ES:DI -> drive parameter
BIOSDATA:1AC1		      jb      short noparmsfromrom
BIOSDATA:1AC3		      cmp     ch, 0	      ;	if ch=0, then cl,dh=0 too.
BIOSDATA:1AC6		      jnz     short pfr_ok
BIOSDATA:1AC8		      mov     ch, 39	      ;	rom gave wrong info.
BIOSDATA:1ACA		      mov     cl, 9	      ;	let's default to 360k.
BIOSDATA:1ACC		      mov     dh, 1
BIOSDATA:1ACE
BIOSDATA:1ACE pfr_ok:				      ;	...
BIOSDATA:1ACE		      inc     dh	      ;	make number of heads 1-based
BIOSDATA:1AD0		      inc     ch	      ;	make number of cylinders 1-based
BIOSDATA:1AD2		      mov     ds:num_heads, dh ; save parms returned by	rom
BIOSDATA:1AD6		      and     cl, 3Fh	      ;	extract	sectors/track
BIOSDATA:1AD9		      mov     ds:sec_trk, cl
BIOSDATA:1ADD		      mov     ds:num_cyln, ch ;	assume less than 256 cylinders!!
BIOSDATA:1AE1		      cmp     cl, ds:eot      ;	make sure that eot contains the	max number of sec/trk
BIOSDATA:1AE1					      ;	 in system of floppies
BIOSDATA:1AE5		      jbe     short eot_ok
BIOSDATA:1AE7		      mov     ds:eot, cl
BIOSDATA:1AEB
BIOSDATA:1AEB eot_ok:				      ;	...
BIOSDATA:1AEB		      pop     es
BIOSDATA:1AEC		      assume es:nothing
BIOSDATA:1AEC		      pop     cx
BIOSDATA:1AED		      pop     dx
BIOSDATA:1AEE		      pop     di
BIOSDATA:1AEF		      pop     ds
BIOSDATA:1AF0		      mov     ah, 15h	      ;	set command to get dasd	type
BIOSDATA:1AF2		      int     13h	      ;	DISK - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
BIOSDATA:1AF2					      ;	DL = drive ID
BIOSDATA:1AF2					      ;	Return:	CF set on error, AH = disk type	(3 = hard drive)
BIOSDATA:1AF2					      ;	CX:DX =	number of sectors on the media
BIOSDATA:1AF4		      jb      short changeline_done
BIOSDATA:1AF6		      cmp     ah, 2	      ;	check for presence of changeline
BIOSDATA:1AF9		      jnz     short changeline_done
BIOSDATA:1AFB		      or      cl, 2	      ;	fchangeline ; signal type
BIOSDATA:1AFE		      mov     ds:fhave96, 1   ;	remember that we have 96tpi disks
BIOSDATA:1B03
BIOSDATA:1B03 changeline_done:			      ;	...
BIOSDATA:1B03		      cmp     ds:num_cyln, 40 ;	we have	a "strange" medium
BIOSDATA:1B08		      jnz     short try_80
BIOSDATA:1B0A		      cmp     ds:sec_trk, 9
BIOSDATA:1B0F		      jbe     short nextdrive
BIOSDATA:1B11
BIOSDATA:1B11 gotother:				      ;	...
BIOSDATA:1B11		      mov     dh, 7
BIOSDATA:1B13		      jmp     short nextdrive ;
BIOSDATA:1B13					      ;	80 cylinders and 9 sectors/track => 720	kb device
BIOSDATA:1B13					      ;	80 cylinders and 15 sec/trk => 96 tpi medium
BIOSDATA:1B15 ;	---------------------------------------------------------------------------
BIOSDATA:1B15
BIOSDATA:1B15 try_80:				      ;	...
BIOSDATA:1B15		      cmp     ds:num_cyln, 80
BIOSDATA:1B1A		      jnz     short gotother
BIOSDATA:1B1C		      mov     dh, 9	      ;	ff288 ;	assume 2.88 MB drive
BIOSDATA:1B1E		      cmp     ds:sec_trk, 36  ;	is it ?
BIOSDATA:1B23		      jz      short nextdrive ;	yes, go	update
BIOSDATA:1B25		      cmp     ds:sec_trk, 15
BIOSDATA:1B2A		      jz      short got96
BIOSDATA:1B2C		      cmp     ds:sec_trk, 9
BIOSDATA:1B31		      jnz     short gotother
BIOSDATA:1B33		      mov     dh, 2	      ;	ffsmall
BIOSDATA:1B35		      jmp     short nextdrive
BIOSDATA:1B37 ;	---------------------------------------------------------------------------
BIOSDATA:1B37
BIOSDATA:1B37 got96:				      ;	...
BIOSDATA:1B37		      mov     dh, 1	      ;	ff96tpi
BIOSDATA:1B39		      jmp     short nextdrive
BIOSDATA:1B3B ;	---------------------------------------------------------------------------
BIOSDATA:1B3B
BIOSDATA:1B3B noparmsfromrom:			      ;	...
BIOSDATA:1B3B		      pop     es
BIOSDATA:1B3C		      pop     cx
BIOSDATA:1B3D		      pop     dx
BIOSDATA:1B3E		      pop     di
BIOSDATA:1B3F		      pop     ds
BIOSDATA:1B40		      mov     ah, 15h	      ;	set command to get dasd	type
BIOSDATA:1B42		      int     13h	      ;	DISK - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
BIOSDATA:1B42					      ;	DL = drive ID
BIOSDATA:1B42					      ;	Return:	CF set on error, AH = disk type	(3 = hard drive)
BIOSDATA:1B42					      ;	CX:DX =	number of sectors on the media
BIOSDATA:1B44		      jb      short nextdrive
BIOSDATA:1B46		      cmp     ah, 2	      ;	is there changeline?
BIOSDATA:1B49		      jnz     short nextdrive
BIOSDATA:1B4B		      or      cl, 2
BIOSDATA:1B4E		      mov     ds:fhave96, 1   ;	remember that we have 96tpi drives
BIOSDATA:1B53		      mov     ds:num_cyln, 80
BIOSDATA:1B58		      mov     dh, 1
BIOSDATA:1B5A		      mov     al, 15	      ;	set eot	if necessary
BIOSDATA:1B5C		      cmp     al, ds:eot
BIOSDATA:1B60		      jbe     short nextdrive
BIOSDATA:1B62		      mov     ds:eot, al
BIOSDATA:1B65
BIOSDATA:1B65 nextdrive:			      ;	...
BIOSDATA:1B65		      or      cl, 20h	      ;	fi_own_physical	; set this true	for all	drives
BIOSDATA:1B68		      mov     bh, dl	      ;	save int 13h drive number
BIOSDATA:1B6A		      cmp     ds:single, 2
BIOSDATA:1B6F		      jnz     short not_special
BIOSDATA:1B71		      dec     bh	      ;	int 13h	drive number same for logical drive
BIOSDATA:1B73		      xor     cl, 20h	      ;	fi_own_physical	; reset	ownership flag for logical drive
BIOSDATA:1B76
BIOSDATA:1B76 not_special:			      ;	...
BIOSDATA:1B76		      xor     ax, ax	      ;	fill BDS for drive
BIOSDATA:1B78		      mov     al, ds:num_heads
BIOSDATA:1B7B		      mov     [di+54], ax     ;	[di+BDS.rheads]
BIOSDATA:1B7E		      mov     al, ds:sec_trk
BIOSDATA:1B81		      mov     [di+52], ax     ;	[di+BDS.rsecpertrack]
BIOSDATA:1B84		      mov     [di+35], cx     ;	[di+BDS.flags]
BIOSDATA:1B87		      mov     [di+34], dh     ;	[di+BDS.formfactor]
BIOSDATA:1B8A		      mov     [di+5], dl      ;	[di+BDS.drivelet]
BIOSDATA:1B8D		      mov     [di+4], bh      ;	[di+BDS.drivenum]
BIOSDATA:1B90		      mov     bl, ds:num_cyln
BIOSDATA:1B94		      mov     [di+37], bl     ;	[di+BDS.cylinders]
BIOSDATA:1B97		      cmp     ds:single, 1    ;	Special	case for single	drive system
BIOSDATA:1B9C		      jnz     short no_single
BIOSDATA:1B9E		      mov     ds:single, 2    ;	Don't forget we have single drive system
BIOSDATA:1BA3		      or      cx, 10h	      ;	fi_am_mult
BIOSDATA:1BA3					      ;	set that this is one of	several	drives
BIOSDATA:1BA6		      or      [di+35], cx     ;	[di+BDS.flags] ; save flags
BIOSDATA:1BA9		      mov     di, [di]	      ;	[di+BDS.link] ;	move to	next BDS in list
BIOSDATA:1BAB		      inc     dl	      ;	add a number
BIOSDATA:1BAD		      jmp     short nextdrive ;	Use same info for BDS as previous
BIOSDATA:1BAF ;	---------------------------------------------------------------------------
BIOSDATA:1BAF
BIOSDATA:1BAF no_single:			      ;	...
BIOSDATA:1BAF		      inc     dl
BIOSDATA:1BB1		      jmp     loop_drive
BIOSDATA:1BB4 ;	---------------------------------------------------------------------------
BIOSDATA:1BB4
BIOSDATA:1BB4 done_drives:			      ;	...
BIOSDATA:1BB4		      mov     word ptr [di], 0FFFFh ; [di+BDS.link],-1 ; set link to null
BIOSDATA:1BB8
BIOSDATA:1BB8 dohard:				      ;	...
BIOSDATA:1BB8		      mov     dh, ds:hnum
BIOSDATA:1BBC		      or      dh, dh	      ;	done if	no hardfiles
BIOSDATA:1BBE		      jz      short static_configure
BIOSDATA:1BC0		      mov     dl, 80h
BIOSDATA:1BC2
BIOSDATA:1BC2 dohard1:				      ;	...
BIOSDATA:1BC2		      push    dx
BIOSDATA:1BC3		      mov     di, ds:end_of_bdss
BIOSDATA:1BC7		      mov     bl, ds:drvmax
BIOSDATA:1BCB		      mov     bh, 0	      ;	first primary partition	(or active)
BIOSDATA:1BCD		      call    sethard
BIOSDATA:1BD0		      jb      short hardfile_err
BIOSDATA:1BD2		      call    dmax_check      ;	error if already 26 drives
BIOSDATA:1BD5		      jnb     short hardfile_err
BIOSDATA:1BD7		      call    xinstall_bds    ;	insert new bds into linked list
BIOSDATA:1BDA
BIOSDATA:1BDA hardfile_err:			      ;	...
BIOSDATA:1BDA		      pop     dx
BIOSDATA:1BDB		      inc     dl	      ;	next hard drive
BIOSDATA:1BDD		      dec     dh
BIOSDATA:1BDF		      jnz     short dohard1   ;
BIOSDATA:1BDF					      ;	end of physical	drive	initialization
BIOSDATA:1BDF					      ;
BIOSDATA:1BDF					      ;	*** do not change the position of the following	statement.
BIOSDATA:1BDF					      ;	*** domini routine will	use [drvmax] value for the start of the	logical
BIOSDATA:1BDF					      ;	*** drive number of mini disk(s).
BIOSDATA:1BE1		      call    domini	      ;	for setting up mini disks, if found
BIOSDATA:1BE4		      mov     dh, ds:hnum     ;	we already know	this is	>0
BIOSDATA:1BE8		      mov     dl, 80h
BIOSDATA:1BEA
BIOSDATA:1BEA dohardx1:				      ;	...
BIOSDATA:1BEA		      mov     bh, 1	      ;	do all subsequent primary partitions
BIOSDATA:1BEC
BIOSDATA:1BEC dohardx2:				      ;	...
BIOSDATA:1BEC		      push    dx
BIOSDATA:1BED		      push    bx
BIOSDATA:1BEE		      mov     di, ds:end_of_bdss
BIOSDATA:1BF2		      mov     bl, ds:drvmax
BIOSDATA:1BF6		      call    sethard
BIOSDATA:1BF9		      jb      short dohardx4  ;	move to	next hardfile if error
BIOSDATA:1BFB		      call    dmax_check      ;	make sure <=26 drives
BIOSDATA:1BFE		      jnb     short dohardx4  ;	skip if	error
BIOSDATA:1C00		      call    xinstall_bds    ;	insert new bds into linked list
BIOSDATA:1C03		      pop     bx	      ;	get partition number
BIOSDATA:1C04		      pop     dx	      ;	restore	physical drive counts
BIOSDATA:1C05		      inc     bh
BIOSDATA:1C07		      jmp     short dohardx2  ;	keep looping until we fail
BIOSDATA:1C09 ;	---------------------------------------------------------------------------
BIOSDATA:1C09
BIOSDATA:1C09 dohardx4:				      ;	...
BIOSDATA:1C09		      pop     bx	      ;	unjunk partition number	from stack
BIOSDATA:1C0A		      pop     dx	      ;	restore	physical drive counts
BIOSDATA:1C0B		      inc     dl	      ;	next hard drive
BIOSDATA:1C0D		      dec     dh
BIOSDATA:1C0F		      jnz     short dohardx1
BIOSDATA:1C11		      cmp     ds:dsktnum, 2   ;	>2 diskette drives
BIOSDATA:1C16		      jbe     short static_configure ; no - no need for	remapping
BIOSDATA:1C18		      call    remap	      ;	remap bds chain	to adjust driver letters
BIOSDATA:1C18					      ;	...
BIOSDATA:1C18					      ;	End of drive initialization.
BIOSDATA:1C1B
BIOSDATA:1C1B static_configure:			      ;	...
BIOSDATA:1C1B		      mov     di, ds:end_of_bdss
BIOSDATA:1C1F		      cmp     di, offset bdss ;	did we allocate	any hard drive bdss?
BIOSDATA:1C23		      jnz     short dynamic_configure ;	that's the end, then
BIOSDATA:1C25		      mov     di, offset harddrv ; end96tpi
BIOSDATA:1C25					      ;	keep everything	up to end96tpi
BIOSDATA:1C28		      cmp     ds:fhave96, 0
BIOSDATA:1C2D		      jnz     short dynamic_configure
BIOSDATA:1C2F		      mov     di, offset endfloppy
BIOSDATA:1C32
BIOSDATA:1C32 dynamic_configure:		      ;	...
BIOSDATA:1C32		      push    cs
BIOSDATA:1C33		      pop     es
BIOSDATA:1C34		      assume es:nothing
BIOSDATA:1C34		      cld		      ;	clear direction
BIOSDATA:1C35		      cmp     ds:model_byte, 0FCh ; AT ?
BIOSDATA:1C3A		      jnz     short checkcompaqbug
BIOSDATA:1C3C		      cmp     ds:hnum, 0      ;	No hard	file?
BIOSDATA:1C41		      jz      short checkcompaqbug
BIOSDATA:1C43		      xchg    ax, di	      ;	save allocation	pointer	in ax
BIOSDATA:1C44		      mov     si, 0F000h
BIOSDATA:1C47		      mov     es, si	      ;	ES -> ROM BIOS segment
BIOSDATA:1C49		      assume es:nothing
BIOSDATA:1C49		      mov     si, offset bios_date ; "01/10/84"
BIOSDATA:1C4C		      mov     di, 0FFF5h      ;	ROM BIOS string	is at	F000:FFF5
BIOSDATA:1C4F		      mov     cx, 9	      ;	bdate_l	; Only patch ROM for bios 01/10/84
BIOSDATA:1C52		      repe cmpsb	      ;	check for date + zero on end
BIOSDATA:1C54		      xchg    ax, di	      ;	restore	allocation pointer
BIOSDATA:1C55		      jnz     short checkcompaqbug
BIOSDATA:1C57		      mov     cx, offset endatrom
BIOSDATA:1C5A		      mov     si, offset ibm_disk_io
BIOSDATA:1C5D		      jmp     short install_int13_patch
BIOSDATA:1C5F ;	---------------------------------------------------------------------------
BIOSDATA:1C5F
BIOSDATA:1C5F checkcompaqbug:			      ;	...
BIOSDATA:1C5F		      mov     ax, 0F000h
BIOSDATA:1C62		      mov     es, ax
BIOSDATA:1C64		      cmp     word ptr es:0FFEAh, 'OC' ; look for COMPAQ
BIOSDATA:1C6B		      jnz     short not_compaq_patch
BIOSDATA:1C6D		      cmp     word ptr es:0FFECh, 'PM'
BIOSDATA:1C74		      jnz     short not_compaq_patch
BIOSDATA:1C76		      cmp     word ptr es:0FFEEh, 'QA'
BIOSDATA:1C7D		      jnz     short not_compaq_patch
BIOSDATA:1C7F		      mov     ax, es:0FFFBh   ;	get year
BIOSDATA:1C83		      xchg    ah, al
BIOSDATA:1C85		      cmp     ax, '86'        ; 3836h ; is it 86?
BIOSDATA:1C88		      ja      short not_compaq_patch
BIOSDATA:1C8A		      jb      short do_compaq_patch
BIOSDATA:1C8C		      mov     ax, es:0FFF5h   ;	get month
BIOSDATA:1C90		      xchg    ah, al
BIOSDATA:1C92		      cmp     ax, '08'        ; 3038h ; is it 08?
BIOSDATA:1C95		      ja      short not_compaq_patch
BIOSDATA:1C97		      jb      short do_compaq_patch
BIOSDATA:1C99		      mov     ax, es:0FFF8h   ;	get day
BIOSDATA:1C9D		      xchg    ah, al
BIOSDATA:1C9F		      cmp     ax, '04'        ; 3034h ; is it 04?
BIOSDATA:1CA2		      jnb     short not_compaq_patch
BIOSDATA:1CA4
BIOSDATA:1CA4 do_compaq_patch:			      ;	...
BIOSDATA:1CA4		      mov     cx, offset end_compaq_i13hook
BIOSDATA:1CA7		      mov     si, offset endatrom
BIOSDATA:1CAA
BIOSDATA:1CAA install_int13_patch:		      ;	...
BIOSDATA:1CAA		      push    cs
BIOSDATA:1CAB		      pop     es
BIOSDATA:1CAC		      assume es:nothing
BIOSDATA:1CAC		      mov     word ptr ds:Orig13, di ; set new rom bios	int 13 vector
BIOSDATA:1CB0		      mov     word ptr ds:Orig13+2, cs
BIOSDATA:1CB4		      sub     cx, si	      ;	size of	rom fix	module
BIOSDATA:1CB6		      rep movsb		      ;	relocate it
BIOSDATA:1CB8
BIOSDATA:1CB8 not_compaq_patch:			      ;	...
BIOSDATA:1CB8		      push    cs
BIOSDATA:1CB9		      pop     es
BIOSDATA:1CBA		      cmp     ds:havecmoscloc, 1 ; cmos	clock exists?
BIOSDATA:1CBF		      jnz     short checkk09  ;	no
BIOSDATA:1CC1		      mov     ds:daycnttoday, di ; set the address for mschar
BIOSDATA:1CC5		      mov     cx, 209	      ;	enddaycnttoday - daycnt_to_day
BIOSDATA:1CC8		      mov     si, offset daycnt_to_day
BIOSDATA:1CCB		      rep movsb
BIOSDATA:1CCD		      mov     ds:bintobcd, di ;	set the	address	for msclock
BIOSDATA:1CCD					      ;	let original segment stay
BIOSDATA:1CD1		      mov     cx, 11	      ;	endcmosclockset	- bin_to_bcd
BIOSDATA:1CD4		      mov     si, offset bin_to_bcd
BIOSDATA:1CD7		      rep movsb
BIOSDATA:1CD9
BIOSDATA:1CD9 checkk09:				      ;	...
BIOSDATA:1CD9		      push    di
BIOSDATA:1CDA		      mov     ax, 4101h	      ;	wait for bh=es:[di]
BIOSDATA:1CDD		      mov     bl, 1	      ;	wait for 1 clock tick
BIOSDATA:1CDF		      mov     bh, es:[di]
BIOSDATA:1CE2		      stc
BIOSDATA:1CE3		      int     15h	      ;	SYSTEM - WAIT ON EXTERNAL EVENT	(CONVERTIBLE)
BIOSDATA:1CE3					      ;	AL = condition type, BH	= condition compare or mask value
BIOSDATA:1CE3					      ;	BL = timeout value times 55 milliseconds, 00h means no timeout
BIOSDATA:1CE3					      ;	DX = I/O port address if AL bit	4 set
BIOSDATA:1CE5		      pop     di
BIOSDATA:1CE6		      jb      short configdone
BIOSDATA:1CE8		      mov     ds:fhavek09, 1  ;	remember we have a k09 type
BIOSDATA:1CED		      push    ds
BIOSDATA:1CEE		      xor     ax, ax
BIOSDATA:1CF0		      mov     ds, ax
BIOSDATA:1CF2		      mov     word ptr ds:disksector+62h, di ; [6Ch*4]
BIOSDATA:1CF2					      ;	new int	6ch handler
BIOSDATA:1CF6		      mov     word ptr ds:disksector+64h, cs
BIOSDATA:1CFA		      pop     ds
BIOSDATA:1CFB		      mov     si, offset int6c
BIOSDATA:1CFE		      mov     cx, 459	      ;	endk09-int6c (size of k09 routine)
BIOSDATA:1D01		      rep movsb
BIOSDATA:1D03
BIOSDATA:1D03 configdone:			      ;	...
BIOSDATA:1D03		      push    cs	      ;	di is final ending address of msbio.
BIOSDATA:1D04		      pop     ds
BIOSDATA:1D05		      add     di, 15	      ;	round (up) to paragraph
BIOSDATA:1D08		      shr     di, 1
BIOSDATA:1D0A		      shr     di, 1
BIOSDATA:1D0C		      shr     di, 1
BIOSDATA:1D0E		      shr     di, 1
BIOSDATA:1D10		      add     di, 70h
BIOSDATA:1D14		      mov     ds:DosDataSg, di ; where the dos data segment will be
BIOSDATA:1D18		      mov     ax, ds:drvfat   ;	get drive and fat id
BIOSDATA:1D1B		      mov     bp, offset SetDrive ; Note: SETDRIVES uses AL (drive number) only
BIOSDATA:1D1E		      push    cs	      ;	simulate far call
BIOSDATA:1D1F		      call    near ptr call_bios_code ;	get bds	for drive
BIOSDATA:1D22		      mov     bp, offset GetBp ; ensure	valid bpb is present
BIOSDATA:1D25		      push    cs
BIOSDATA:1D26		      call    near ptr call_bios_code
BIOSDATA:1D29		      push    es	      ;	copy bds to ds:di
BIOSDATA:1D2A		      pop     ds
BIOSDATA:1D2B		      xor     di, di
BIOSDATA:1D2D		      mov     al, es:[di]     ;	get fat	id byte
BIOSDATA:1D30		      mov     byte ptr es:drvfat+1, al ; save fat byte
BIOSDATA:1D34		      mov     ax, es:drvfat
BIOSDATA:1D38		      push    es
BIOSDATA:1D39		      push    ds	      ;	copy bds to es:di
BIOSDATA:1D3A		      pop     es
BIOSDATA:1D3B		      push    cs	      ;	copy Bios_Data to ds
BIOSDATA:1D3C		      pop     ds
BIOSDATA:1D3D		      mov     bp, offset SetDrive
BIOSDATA:1D40		      push    cs	      ;	simulate far call
BIOSDATA:1D41		      call    near ptr call_bios_code ;	get correct bds	for this drive
BIOSDATA:1D44		      push    es
BIOSDATA:1D45		      pop     ds
BIOSDATA:1D46		      pop     es
BIOSDATA:1D47		      assume es:nothing
BIOSDATA:1D47		      mov     bx, [di+6]      ;	[di+BDS.BDS_BPB.BPB_BYTESPERSECTOR]
BIOSDATA:1D4A		      mov     cs:md_sectorsize,	bx ; used by get_fat_sector proc.
BIOSDATA:1D4F		      mov     bl, [di+31]     ;	[di+BDS.fatsiz]
BIOSDATA:1D4F					      ;	get size of fat	on media
BIOSDATA:1D52		      mov     es:fbigfat, bl
BIOSDATA:1D57		      mov     cl, [di+8]
BIOSDATA:1D5A		      mov     ax, [di+23]     ;	[di+BDS.BDS_BPB.BPB_HIDDENSECTORS]
BIOSDATA:1D5D		      sub     es:bios_l, ax   ;	subtract hidden	sectors	since we
BIOSDATA:1D5D					      ;	need a logical sector number that will
BIOSDATA:1D5D					      ;	be used	by getclus(diskrd procedure)
BIOSDATA:1D62		      mov     ax, [di+25]     ;	[di+BDS.BDS_BPB.BPB_HIDDENSECTORS+2]
BIOSDATA:1D65		      sbb     es:bios_h, ax   ;	subtract upper 16 bits of sector num
BIOSDATA:1D6A		      xor     ch, ch	      ;	cx = sectors/cluster
BIOSDATA:1D6C		      push    ds
BIOSDATA:1D6D		      xor     di, di	      ;	0
BIOSDATA:1D6F		      mov     ds, di
BIOSDATA:1D71		      mov     bx, ds:053Ah    ;	clus=*53Ah
BIOSDATA:1D71					      ;	(First cluster field of	2nd dir	entry
BIOSDATA:1D71					      ;	of root	directory in the buffer	at 500h)
BIOSDATA:1D75		      pop     ds
BIOSDATA:1D76
BIOSDATA:1D76 loadit:				      ;	...
BIOSDATA:1D76		      mov     ax, 473h	      ;	SYSINIT	segment	(SYSINITSEG)
BIOSDATA:1D79		      mov     es, ax
BIOSDATA:1D7B		      assume es:nothing
BIOSDATA:1D7B		      mov     es, es:CURRENT_DOS_LOCATION
BIOSDATA:1D80		      assume es:nothing
BIOSDATA:1D80		      call    getclus	      ;	read cluster at	ES:DI (DI is updated)
BIOSDATA:1D83		      test    cs:fbigfat, 40h ;	fbig
BIOSDATA:1D89		      jnz     short eofbig
BIOSDATA:1D8B		      cmp     bx, 0FF7h
BIOSDATA:1D8F		      jmp     short iseofx
BIOSDATA:1D91 ;	---------------------------------------------------------------------------
BIOSDATA:1D91
BIOSDATA:1D91 eofbig:				      ;	...
BIOSDATA:1D91		      cmp     bx, 0FFF7h
BIOSDATA:1D94
BIOSDATA:1D94 iseofx:				      ;	...
BIOSDATA:1D94		      jb      short loadit    ;	keep loading until cluster = eof
BIOSDATA:1D96		      call    setdrvparms
BIOSDATA:1D99		      jmp     far ptr 473h:269h	; SYSINIT:_SYSINIT
BIOSDATA:1D9E
BIOSDATA:1D9E ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:1D9E
BIOSDATA:1D9E
BIOSDATA:1D9E remap	      proc near		      ;	...
BIOSDATA:1D9E		      mov     di, cs:start_bds ; get first bds
BIOSDATA:1DA3
BIOSDATA:1DA3 drive_loop:			      ;	...
BIOSDATA:1DA3		      cmp     byte ptr [di+4], 80h ; [di+BDS.drivenum] ; first hard disk??
BIOSDATA:1DA7		      jz      short fdrv_found ; yes, continue
BIOSDATA:1DA9		      mov     di, [di]	      ;	[di+BDS.link] ;	get next bds, assume segment
BIOSDATA:1DAB		      cmp     di, -1	      ;	last bds?
BIOSDATA:1DAE		      jnz     short drive_loop ; loop if not
BIOSDATA:1DB0		      jmp     short rmap_exit ;	yes, no	hard drive on	system
BIOSDATA:1DB2 ;	---------------------------------------------------------------------------
BIOSDATA:1DB2
BIOSDATA:1DB2 fdrv_found:			      ;	...
BIOSDATA:1DB2		      mov     al, 2	      ;	start with logical drv num=2
BIOSDATA:1DB4
BIOSDATA:1DB4 fdrv_loop:			      ;	...
BIOSDATA:1DB4		      mov     [di+5], al      ;	[di+BDS.drivelet] ; found ??
BIOSDATA:1DB7		      mov     di, [di]	      ;	[di+BDS.link] ;	ds:di--> next bds
BIOSDATA:1DB9		      inc     al	      ;	set num	for next drive
BIOSDATA:1DBB		      cmp     di, -1	      ;	last hard drive	??
BIOSDATA:1DBE		      jnz     short fdrv_loop ;	no - assign more disk	drives
BIOSDATA:1DC0		      mov     di, cs:start_bds ; get first bds
BIOSDATA:1DC5		      mov     di, [di]	      ;	[di+BDS.link] ;	ds:di-->bds2
BIOSDATA:1DC7		      mov     ah, cs:dsktnum  ;	get number of floppies to remap
BIOSDATA:1DCC		      sub     ah, 2	      ;	adjust for a: &	b:
BIOSDATA:1DCF
BIOSDATA:1DCF remap_loop1:			      ;	...
BIOSDATA:1DCF		      mov     di, [di]	      ;	[di+BDS.link] ;	set new	num to next floppy
BIOSDATA:1DD1		      mov     [di+5], al      ;	[di+BDS.drivelet]
BIOSDATA:1DD4		      inc     al	      ;	new number for next floppy
BIOSDATA:1DD6		      dec     ah	      ;	count down extra floppies
BIOSDATA:1DD8		      jnz     short remap_loop1	;
BIOSDATA:1DD8					      ;	now we've got to adjust the boot drive
BIOSDATA:1DD8					      ;	if we reassigned it
BIOSDATA:1DDA		      mov     al, byte ptr cs:drvfat
BIOSDATA:1DDE		      cmp     al, 2	      ;	is it a: or b: ?
BIOSDATA:1DE0		      jb      short rmap_exit
BIOSDATA:1DE2		      sub     al, cs:dsktnum  ;	is it one of the other floppies?
BIOSDATA:1DE7		      jb      short remap_boot_flop ; brif so
BIOSDATA:1DE9		      add     al, 2	      ;	bootdrv	-= (dsktnum-2)
BIOSDATA:1DEB		      jmp     short remap_change_boot_drv
BIOSDATA:1DED ;	---------------------------------------------------------------------------
BIOSDATA:1DED
BIOSDATA:1DED remap_boot_flop:			      ;	...
BIOSDATA:1DED		      add     al, cs:drvmax   ;	bootdrv	+= (drvmax-dsktnum)
BIOSDATA:1DF2
BIOSDATA:1DF2 remap_change_boot_drv:		      ;	...
BIOSDATA:1DF2		      mov     byte ptr cs:drvfat, al ; alter msdos.sys load drive
BIOSDATA:1DF6		      inc     al
BIOSDATA:1DF8		      push    ds
BIOSDATA:1DF9		      mov     di, 473h	      ;	SYSINIT	segment
BIOSDATA:1DFC		      mov     ds, di
BIOSDATA:1DFE		      assume ds:nothing
BIOSDATA:1DFE		      mov     ds:DEFAULT_DRIVE,	al ; [SYSINIT+DEFAULT_DRIVE]
BIOSDATA:1DFE					      ;	pass it	to sysinit as well
BIOSDATA:1E01		      pop     ds
BIOSDATA:1E02		      assume ds:nothing
BIOSDATA:1E02
BIOSDATA:1E02 rmap_exit:			      ;	...
BIOSDATA:1E02		      retn
BIOSDATA:1E02 remap	      endp
BIOSDATA:1E02
BIOSDATA:1E03
BIOSDATA:1E03 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:1E03
BIOSDATA:1E03
BIOSDATA:1E03 getboot	      proc near		      ;	...
BIOSDATA:1E03		      mov     ax, cs:init_bootseg
BIOSDATA:1E07		      mov     es, ax
BIOSDATA:1E09		      mov     bx, 200h	      ;	bootbias
BIOSDATA:1E09					      ;	load BX, ES:BX is where	sector goes
BIOSDATA:1E0C		      mov     ax, 201h
BIOSDATA:1E0F		      xor     dh, dh
BIOSDATA:1E11		      mov     cx, 1
BIOSDATA:1E14		      int     13h	      ;	DISK - READ SECTORS INTO MEMORY
BIOSDATA:1E14					      ;	AL = number of sectors to read,	CH = track, CL = sector
BIOSDATA:1E14					      ;	DH = head, DL =	drive, ES:BX ->	buffer to fill
BIOSDATA:1E14					      ;	Return:	CF set on error, AH = status, AL = number of sectors read
BIOSDATA:1E16		      jb      short erret
BIOSDATA:1E18		      cmp     word ptr es:3FEh,	0AA55h ; [es:bootbias+1FEh]
BIOSDATA:1E18					      ;	Dave Litton magic word?
BIOSDATA:1E1F		      jz      short norm_ret  ;	yes
BIOSDATA:1E21
BIOSDATA:1E21 erret:				      ;	...
BIOSDATA:1E21		      stc
BIOSDATA:1E22
BIOSDATA:1E22 norm_ret:				      ;	...
BIOSDATA:1E22		      retn
BIOSDATA:1E22 getboot	      endp
BIOSDATA:1E22
BIOSDATA:1E23
BIOSDATA:1E23 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:1E23
BIOSDATA:1E23
BIOSDATA:1E23 sethard	      proc near		      ;	...
BIOSDATA:1E23		      push    di	      ;	generate bpb for a variable sized hard file
BIOSDATA:1E24		      push    bx
BIOSDATA:1E25		      push    ds
BIOSDATA:1E26		      push    es
BIOSDATA:1E27		      mov     [di+5], bl      ;	[di+BDS.drivelet]
BIOSDATA:1E2A		      mov     [di+4], dl      ;	[di+BDS.drivenum]
BIOSDATA:1E2D		      or      byte ptr [di+35],	1 ; [di+BDS.flags] ; fnon_removable
BIOSDATA:1E31		      mov     byte ptr [di+34],	5 ; [di+BDS.formfactor]	; ffHardFile
BIOSDATA:1E35		      mov     ds:fbigfat, 0   ;	assume 12 bit FAT
BIOSDATA:1E3A		      mov     dh, bh	      ;	partition number
BIOSDATA:1E3C		      push    dx
BIOSDATA:1E3D		      mov     ah, 8
BIOSDATA:1E3F		      int     13h	      ;	DISK - DISK - GET CURRENT DRIVE	PARAMETERS (XT,AT,XT286,CONV,PS)
BIOSDATA:1E3F					      ;	DL = drive number
BIOSDATA:1E3F					      ;	Return:	CF set on error, AH = status code, BL =	drive type
BIOSDATA:1E3F					      ;	DL = number of consecutive drives
BIOSDATA:1E3F					      ;	DH = maximum value for head number, ES:DI -> drive parameter
BIOSDATA:1E41		      inc     dh
BIOSDATA:1E43		      mov     [di+15h],	dh    ;	[di+BDS.heads] ; get number of heads
BIOSDATA:1E46		      pop     dx
BIOSDATA:1E47		      jb      short setret    ;	error	if no hard disk
BIOSDATA:1E49		      and     cl, 3Fh
BIOSDATA:1E4C		      mov     [di+13h],	cl    ;	[di+BDS.secpertrack]
BIOSDATA:1E4F		      push    dx	      ;	save partition number
BIOSDATA:1E50		      call    getboot
BIOSDATA:1E53		      pop     dx	      ;	restore	partition number
BIOSDATA:1E54		      jb      short setret
BIOSDATA:1E56		      mov     bx, 3C2h	      ;	1C2h+bootbias
BIOSDATA:1E59
BIOSDATA:1E59 act_part:				      ;	...
BIOSDATA:1E59		      test    byte ptr es:[bx-4], 80h ;	is the partition active?
BIOSDATA:1E5E		      jz      short not_act   ;	no
BIOSDATA:1E60		      cmp     byte ptr es:[bx],	1 ; reject if partitiontype != 1, 4 or 6
BIOSDATA:1E64		      jz      short got_good_act
BIOSDATA:1E66		      cmp     byte ptr es:[bx],	4
BIOSDATA:1E6A		      jz      short got_good_act
BIOSDATA:1E6C		      cmp     byte ptr es:[bx],	6
BIOSDATA:1E70		      jnz     short not_act
BIOSDATA:1E72
BIOSDATA:1E72 got_good_act:			      ;	...
BIOSDATA:1E72		      or      dh, dh	      ;	is this	our target partition #?
BIOSDATA:1E74		      jz      short set2      ;	WE GOT THE ONE WANTED!
BIOSDATA:1E76		      dec     dh	      ;	count down
BIOSDATA:1E78
BIOSDATA:1E78 not_act:				      ;	...
BIOSDATA:1E78		      add     bx, 16
BIOSDATA:1E7B		      cmp     bx, 402h	      ;	202h+bootbias
BIOSDATA:1E7B					      ;	last entry done?
BIOSDATA:1E7F		      jnz     short act_part  ;	no, process next entry
BIOSDATA:1E81		      mov     bx, 3C2h	      ;	1C2h+bootbias
BIOSDATA:1E81					      ;	restore	original value of bx
BIOSDATA:1E84
BIOSDATA:1E84 get_primary:			      ;	...
BIOSDATA:1E84		      test    byte ptr es:[bx-4], 80h ;	Now scan the non-active	partitions
BIOSDATA:1E89		      jnz     short not_prim  ;	we've already scanned the ACTIVE ones
BIOSDATA:1E8B		      cmp     byte ptr es:[bx],	1 ; see	if partitiontype == 1, 4 or 6
BIOSDATA:1E8F		      jz      short got_prim
BIOSDATA:1E91		      cmp     byte ptr es:[bx],	4
BIOSDATA:1E95		      jz      short got_prim
BIOSDATA:1E97		      cmp     byte ptr es:[bx],	6
BIOSDATA:1E9B		      jnz     short not_prim
BIOSDATA:1E9D
BIOSDATA:1E9D got_prim:				      ;	...
BIOSDATA:1E9D		      or      dh, dh	      ;	is this	our target partition?
BIOSDATA:1E9F		      jz      short set2
BIOSDATA:1EA1		      dec     dh
BIOSDATA:1EA3
BIOSDATA:1EA3 not_prim:				      ;	...
BIOSDATA:1EA3		      add     bx, 16
BIOSDATA:1EA6		      cmp     bx, 402h	      ;	202h+bootbias
BIOSDATA:1EAA		      jnz     short get_primary	; loop till we've gone through table
BIOSDATA:1EAC
BIOSDATA:1EAC setret:				      ;	...
BIOSDATA:1EAC		      stc		      ;	error return
BIOSDATA:1EAD		      jmp     ret_hard
BIOSDATA:1EB0 ;	---------------------------------------------------------------------------
BIOSDATA:1EB0
BIOSDATA:1EB0 set2:				      ;	...
BIOSDATA:1EB0		      mov     cs:rom_drv_num, dl ; save	the rom	bios drive number
BIOSDATA:1EB5		      mov     ax, es:[bx+4]   ;	hidden sectors (start sector)
BIOSDATA:1EB9		      mov     dx, es:[bx+6]
BIOSDATA:1EBD		      sub     ax, 1	      ;	decrement the sector count by 1	to make	it zero	based.
BIOSDATA:1EBD					      ;	exactly	64k sectors should be allowed
BIOSDATA:1EC0		      sbb     dx, 0
BIOSDATA:1EC3		      add     ax, es:[bx+8]   ;	sectors	in partition
BIOSDATA:1EC7		      adc     dx, es:[bx+10]
BIOSDATA:1ECB		      jnb     short okdrive
BIOSDATA:1ECD		      or      ds:fbigfat, 80h ;	ftoobig
BIOSDATA:1ED2
BIOSDATA:1ED2 okdrive:				      ;	...
BIOSDATA:1ED2		      mov     ax, es:[bx+4]
BIOSDATA:1ED6		      mov     [di+23], ax     ;	[di+BDS.hiddensecs]
BIOSDATA:1ED6					      ;	BPB_HIDDENSECTORS = p->partitionbegin
BIOSDATA:1ED9		      mov     ax, es:[bx+6]
BIOSDATA:1EDD		      mov     [di+25], ax     ;	[di+BDS.hiddensecs+2]
BIOSDATA:1EE0		      mov     dx, es:[bx+10]  ;	# of sectors (high)
BIOSDATA:1EE4		      mov     ax, es:[bx+8]   ;	# of sectors (low)
BIOSDATA:1EE8		      mov     [di+29], dx     ;	[di+BDS.totalsecs32+2]
BIOSDATA:1EEB		      mov     [di+27], ax     ;	[di+BDS.totalsecs32]
BIOSDATA:1EEB					      ;	bpb->maxsec = p->partitionlength
BIOSDATA:1EEE		      cmp     dx, 0
BIOSDATA:1EF1		      ja      short okdrive_cont
BIOSDATA:1EF3		      cmp     ax, 64	      ;	if (p->partitionlength < 64)
BIOSDATA:1EF6		      jb      short setret    ;	return -1;
BIOSDATA:1EF8
BIOSDATA:1EF8 okdrive_cont:			      ;	...
BIOSDATA:1EF8		      mov     dx, [di+25]     ;	[di+BDS.hiddensecs+2]
BIOSDATA:1EFB		      mov     ax, [di+23]     ;	[di+BDS.hiddensecs]
BIOSDATA:1EFE		      xor     bx, bx	      ;	boot sector number - for mini disk
BIOSDATA:1EFE					      ;	usually	equal to the # of sec/trk.
BIOSDATA:1F00		      mov     bl, [di+19]     ;	[di+BDS.secpertrack]
BIOSDATA:1F03		      push    ax
BIOSDATA:1F04		      mov     ax, dx
BIOSDATA:1F06		      xor     dx, dx
BIOSDATA:1F08		      div     bx
BIOSDATA:1F0A		      mov     cs:temp_h, ax
BIOSDATA:1F0E		      pop     ax
BIOSDATA:1F0F		      div     bx	      ;	(sectors)dx:ax / (BDS.secpertrack)bx =
BIOSDATA:1F0F					      ;	(track)temp_h:ax + (sector)dx
BIOSDATA:1F11		      mov     cl, dl
BIOSDATA:1F13		      inc     cl
BIOSDATA:1F15		      xor     bx, bx
BIOSDATA:1F17		      mov     bl, [di+21]     ;	[di+BDS.heads]
BIOSDATA:1F1A		      push    ax
BIOSDATA:1F1B		      xor     dx, dx
BIOSDATA:1F1D		      mov     ax, cs:temp_h
BIOSDATA:1F21		      div     bx	      ;	dl is head, ax is cylinder
BIOSDATA:1F23		      mov     cs:temp_h, ax
BIOSDATA:1F27		      pop     ax
BIOSDATA:1F28		      div     bx
BIOSDATA:1F2A		      cmp     cs:temp_h, 0
BIOSDATA:1F30		      ja      short setret_brdg	; exceeds the limit of int 13h
BIOSDATA:1F32		      cmp     ax, 1024
BIOSDATA:1F35		      ja      short setret_brdg	; exceeds the limit of int 13h
BIOSDATA:1F35					      ;	Retro DOS v3.2 note by Erdogan Tan - 28/07/2019
BIOSDATA:1F35					      ;	**MSDOS	code accepts if	ax = 1024 but it is nonsense here
BIOSDATA:1F35					      ;	('ja' must be 'jnb')
BIOSDATA:1F37		      cmp     word ptr [di+71],	1 ; [di+BDS.bdsm_ismini]
BIOSDATA:1F37					      ;	check for mini disk
BIOSDATA:1F3B		      jnz     short oknotmini ;	not mini disk.
BIOSDATA:1F3D		      add     ax, [di+73]     ;	[di+BDS.bdsm_hidden_trks]
BIOSDATA:1F3D					      ;	set the	physical track number
BIOSDATA:1F40
BIOSDATA:1F40 oknotmini:			      ;	...
BIOSDATA:1F40		      ror     ah, 1	      ;	move high two bits of cyl to high
BIOSDATA:1F42		      ror     ah, 1	      ;	two bits of upper byte
BIOSDATA:1F44		      and     ah, 0C0h	      ;	turn off remainder of bits
BIOSDATA:1F47		      or      cl, ah	      ;	move two bits to correct spot
BIOSDATA:1F49		      mov     ch, al	      ;	ch is cylinder (low 8 bits)
BIOSDATA:1F49					      ;	cl is sector + 2 high bits of cylinder
BIOSDATA:1F4B		      mov     dh, dl	      ;	dh is head
BIOSDATA:1F4D		      mov     dl, cs:rom_drv_num ; dl is drive number
BIOSDATA:1F52		      push    cs
BIOSDATA:1F53		      pop     es
BIOSDATA:1F54		      assume es:nothing
BIOSDATA:1F54		      mov     bx, offset disksector
BIOSDATA:1F57		      mov     ax, 201h
BIOSDATA:1F5A		      int     13h	      ;	DISK - READ SECTORS INTO MEMORY
BIOSDATA:1F5A					      ;	AL = number of sectors to read,	CH = track, CL = sector
BIOSDATA:1F5A					      ;	DH = head, DL =	drive, ES:BX ->	buffer to fill
BIOSDATA:1F5A					      ;	Return:	CF set on error, AH = status, AL = number of sectors read
BIOSDATA:1F5C		      mov     bx, offset disksector
BIOSDATA:1F5F		      push    bx
BIOSDATA:1F60		      push    ax
BIOSDATA:1F61		      cmp     byte ptr cs:[bx],	0E9h ; is it a near jump?
BIOSDATA:1F65		      jz      short check_1_ok ; yes
BIOSDATA:1F67		      cmp     byte ptr cs:[bx],	0EBh ; is it a short jump?
BIOSDATA:1F6B		      jnz     short invalid_boot_record	; no
BIOSDATA:1F6D		      cmp     byte ptr cs:[bx+2], 90h ;	yes, is	the next one a nop?
BIOSDATA:1F72		      jnz     short invalid_boot_record
BIOSDATA:1F74
BIOSDATA:1F74 check_1_ok:			      ;	...
BIOSDATA:1F74		      mov     bx, 159h	      ;	disksector+EXT_BOOT.BPB
BIOSDATA:1F74					      ;	point to the bpb in the	boot record
BIOSDATA:1F77		      mov     al, cs:[bx+10]  ;	[bx+EBPB.MEDIADESCRIPTOR]
BIOSDATA:1F77					      ;	get the	mediadescriptor	byte
BIOSDATA:1F7B		      and     al, 0F0h	      ;	mask off low nibble
BIOSDATA:1F7D		      cmp     al, 0F0h ; 'ð'  ; is high nibble = 0Fh?
BIOSDATA:1F7F		      jnz     short invalid_boot_record	; no, invalid boot record
BIOSDATA:1F81		      cmp     word ptr cs:[bx],	512 ; [bx+EBPB.BYTESPERSECTOR]
BIOSDATA:1F86		      jnz     short invalid_boot_record	; invalidate non 512 byte sectors
BIOSDATA:1F88
BIOSDATA:1F88 check_2_ok:			      ;	yes, mediadescriptor ok.
BIOSDATA:1F88		      mov     al, cs:[bx+2]   ;	now make sure that the sectorspercluster is a power of 2
BIOSDATA:1F88					      ;	[bx+EBPB.SECTORSPERCLUSTER]
BIOSDATA:1F88					      ;	get the	sectorspercluster
BIOSDATA:1F8C		      or      al, al	      ;	is it zero?
BIOSDATA:1F8E		      jz      short invalid_boot_record	; yes, invalid boot record
BIOSDATA:1F90
BIOSDATA:1F90 ck_power_of_two:			      ;	...
BIOSDATA:1F90		      shr     al, 1	      ;	shift until first bit emerges
BIOSDATA:1F92		      jnb     short ck_power_of_two
BIOSDATA:1F94		      jz      short valid_boot_record
BIOSDATA:1F96
BIOSDATA:1F96 invalid_boot_record:		      ;	...
BIOSDATA:1F96		      pop     ax
BIOSDATA:1F97		      pop     bx
BIOSDATA:1F98		      jmp     unknown	      ;	jump to	invalid	boot record
BIOSDATA:1F98					      ;	unformatted or illegal media.
BIOSDATA:1F9B ;	---------------------------------------------------------------------------
BIOSDATA:1F9B
BIOSDATA:1F9B valid_boot_record:		      ;	...
BIOSDATA:1F9B		      pop     ax
BIOSDATA:1F9C		      pop     bx	      ;	Signature found. Now check version.
BIOSDATA:1F9D		      cmp     word ptr cs:[bx+8], '.2' ; '2.' (NASM syntax)
BIOSDATA:1FA3		      jnz     short try5
BIOSDATA:1FA5		      cmp     byte ptr cs:[bx+10], '0'
BIOSDATA:1FAA		      jnz     short try5
BIOSDATA:1FAC		      jmp     short copybpb
BIOSDATA:1FAE ;	---------------------------------------------------------------------------
BIOSDATA:1FAE
BIOSDATA:1FAE setret_brdg:			      ;	...
BIOSDATA:1FAE		      jmp     setret
BIOSDATA:1FB1 ;	---------------------------------------------------------------------------
BIOSDATA:1FB1
BIOSDATA:1FB1 unknown3_0_j:			      ;	...
BIOSDATA:1FB1		      jmp     unknown3_0      ;	legally	formatted media,
BIOSDATA:1FB1					      ;	although, content might	be bad.
BIOSDATA:1FB4 ;	---------------------------------------------------------------------------
BIOSDATA:1FB4
BIOSDATA:1FB4 try5:				      ;	...
BIOSDATA:1FB4		      call    cover_fdisk_bug
BIOSDATA:1FB7		      cmp     word ptr cs:[bx+8], '.0' ; '0.' (NASM syntax)
BIOSDATA:1FBD		      jnz     short no_os2
BIOSDATA:1FBF		      mov     al, cs:[bx+7]
BIOSDATA:1FC3		      sub     al, '1'
BIOSDATA:1FC5		      and     al, 0FEh
BIOSDATA:1FC7		      jz      short copybpb   ;	accept either '1' or '2'
BIOSDATA:1FC9		      jmp     unknown
BIOSDATA:1FCC ;	---------------------------------------------------------------------------
BIOSDATA:1FCC
BIOSDATA:1FCC no_os2:				      ;	...
BIOSDATA:1FCC		      cmp     word ptr cs:[bx+8], '.3' ; '3.' (NASM syntax)
BIOSDATA:1FD2		      jb      short unknown3_0_j ; must	be 2.1 boot record.
BIOSDATA:1FD2					      ;	do not trust it, but still legal.
BIOSDATA:1FD4		      jnz     short copybpb   ;	honor os2 boot record or dos 4.0 version
BIOSDATA:1FD6		      cmp     byte ptr cs:[bx+10], '1' ; if version >= 3.1, then o.k.
BIOSDATA:1FDB		      jb      short unknown3_0_j
BIOSDATA:1FDD
BIOSDATA:1FDD copybpb:				      ;	...
BIOSDATA:1FDD		      cmp     cs:disksector+26h, 29h ; [disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
BIOSDATA:1FE3		      jnz     short copybpb_fat	; conventional fat system
BIOSDATA:1FE5		      cmp     cs:disksector+10h, 0
BIOSDATA:1FEB		      jnz     short copybpb_fat	; a fat	system.
BIOSDATA:1FED		      push    di	      ;	non fat	based media.
BIOSDATA:1FEE		      push    ds
BIOSDATA:1FEF		      push    ds
BIOSDATA:1FF0		      pop     es
BIOSDATA:1FF1		      push    cs
BIOSDATA:1FF2		      pop     ds
BIOSDATA:1FF3		      mov     si, (offset disksector+0Bh) ; disksector+EXT_BOOT.BPB
BIOSDATA:1FF6		      add     di, 6	      ;	add di,BDS.BPB
BIOSDATA:1FF9		      cmp     word ptr cs:[si+8], 0 ; [cs:si+EBPB.TOTALSECTORS]
BIOSDATA:1FFE		      jnz     short already_nonz
BIOSDATA:2000		      cmp     word ptr cs:[si+21], 0 ; [cs:si+EBPB.BIGTOTALSECTORS]
BIOSDATA:2005		      jnz     short already_nonz
BIOSDATA:2007		      cmp     word ptr cs:[si+23], 0 ; [cs:si+EBPB.BIGTOTALSECTORS+2]
BIOSDATA:200C		      jnz     short already_nonz
BIOSDATA:200E		      mov     ax, [di+8]      ;	[di+BDS.totalsecs16]
BIOSDATA:2011		      mov     cs:[si+8], ax   ;	[cs:si+EBPB.TOTALSECTORS]
BIOSDATA:2015		      mov     ax, [di+21]     ;	[di+BDS.totalsecs32]
BIOSDATA:2018		      mov     cs:[si+21], ax  ;	[cs:si+EBPB.BIGTOTALSECTORS]
BIOSDATA:201C		      mov     ax, [di+23]     ;	[di+BDS.totalsecs32+2]
BIOSDATA:201F		      mov     cs:[si+23], ax  ;	[cs:si+EBPB.BIGTOTALSECTORS+2]
BIOSDATA:2023
BIOSDATA:2023 already_nonz:			      ;	...
BIOSDATA:2023		      mov     cx, 25	      ;	A_BPB.size - 6 ; Use SMALL version!
BIOSDATA:2026		      rep movsb
BIOSDATA:2028		      pop     ds
BIOSDATA:2029		      pop     di
BIOSDATA:202A		      push    es
BIOSDATA:202B		      push    ds
BIOSDATA:202C		      pop     es
BIOSDATA:202D		      push    cs
BIOSDATA:202E		      pop     ds
BIOSDATA:202F		      mov     bp, offset mov_media_ids
BIOSDATA:2032		      push    cs	      ;	simulate far call
BIOSDATA:2033		      call    near ptr call_bios_code
BIOSDATA:2036		      push    es
BIOSDATA:2037		      pop     ds
BIOSDATA:2038		      pop     es
BIOSDATA:2039		      assume es:nothing
BIOSDATA:2039		      jmp     goodret
BIOSDATA:203C ;	---------------------------------------------------------------------------
BIOSDATA:203C
BIOSDATA:203C copybpb_fat:			      ;	...
BIOSDATA:203C		      mov     si, (offset disksector+0Bh) ; disksector+EXT_BOOT.BPB
BIOSDATA:203C					      ;	cs:si -> bpb in	boot
BIOSDATA:203F		      xor     dx, dx
BIOSDATA:2041		      mov     ax, cs:[si+8]   ;	[cs:si+EBPB.TOTALSECTORS]
BIOSDATA:2041					      ;	get totsec from	boot sec
BIOSDATA:2045		      or      ax, ax
BIOSDATA:2047		      jnz     short copy_totsec	; if non zero, use that
BIOSDATA:2049		      mov     ax, cs:[si+21]  ;	[cs:si+EBPB.BIGTOTALSECTORS]
BIOSDATA:2049					      ;	get the	big version (32	bit total sectors)
BIOSDATA:204D		      mov     dx, cs:[si+23]  ;	[cs:si+EBPB.BIGTOTALSECTORS+2]
BIOSDATA:2051		      mov     cx, dx	      ;	see if it is a big zero
BIOSDATA:2051					      ;	10/12/2022
BIOSDATA:2051					      ;	mov bx,ax
BIOSDATA:2051					      ;	or bx,ax
BIOSDATA:2053		      or      cx, ax
BIOSDATA:2055		      jz      short totsec_already_set
BIOSDATA:2057
BIOSDATA:2057 copy_totsec:			      ;	...
BIOSDATA:2057		      mov     [di+27], ax     ;	[di+BDS.totalsecs32]
BIOSDATA:2057					      ;	make DPB match boot sec
BIOSDATA:205A		      mov     [di+29], dx     ;	[di+BDS.totalsecs32+2]
BIOSDATA:205D
BIOSDATA:205D totsec_already_set:		      ;	...
BIOSDATA:205D		      mov     ax, [di+27]     ;	[di+BDS.totalsecs32]
BIOSDATA:2060		      mov     dx, [di+29]     ;	[di+BDS.totalsecs32+2]
BIOSDATA:2063		      mov     bx, cs:[si+3]   ;	[cs:si+EBPB.RESERVEDSECTORS]
BIOSDATA:2063					      ;	get #reserved_sectors from BPB
BIOSDATA:2067		      mov     [di+9], bx      ;	[di+BDS.resectors] ; update BDS	field
BIOSDATA:206A		      sub     ax, bx
BIOSDATA:206C		      sbb     dx, 0	      ;	update the count
BIOSDATA:206F		      mov     bx, cs:[si+11]  ;	[cs:si+EBPB.SECTORSPERFAT] ; bx	= sectors/fat
BIOSDATA:2073		      mov     [di+17], bx     ;	[di+BDS.fatsecs] ; set in bds bpb
BIOSDATA:2076		      shl     bx, 1	      ;	always 2 fats (may be 1	fat!?)
BIOSDATA:2076					      ;	10/12/2022
BIOSDATA:2076					      ;	(number	of FATs	optimization)
BIOSDATA:2076					      ;	CL = number of FATs (2 or 1)
BIOSDATA:2076					      ;	dec cx
BIOSDATA:2076					      ;	shl bx,	cl
BIOSDATA:2078		      sub     ax, bx	      ;	sub # fat sectors
BIOSDATA:207A		      sbb     dx, 0
BIOSDATA:207D		      mov     bx, cs:[si+6]   ;	[cs:si+EBPB.ROOTENTRIES]
BIOSDATA:207D					      ;	# root entries
BIOSDATA:2081		      mov     [di+12], bx     ;	[di+BDS.direntries]
BIOSDATA:2081					      ;	set in bds bpb
BIOSDATA:2084		      mov     cl, 4
BIOSDATA:2086		      shr     bx, cl	      ;	div by 16 ents/sector
BIOSDATA:2088		      sub     ax, bx	      ;	sub # dir sectors
BIOSDATA:208A		      sbb     dx, 0	      ;	dx:ax now contains the # of data sectors
BIOSDATA:208D		      xor     cx, cx
BIOSDATA:208F		      mov     cl, cs:[si+2]   ;	[cs:si+EBPB.SECTORSPERCLUSTER]
BIOSDATA:208F					      ;	sectors	per cluster
BIOSDATA:2093		      mov     [di+8], cl      ;	[di+BDS.secperclus]
BIOSDATA:2093					      ;	set in bios bpb
BIOSDATA:2096		      push    ax
BIOSDATA:2097		      mov     ax, dx
BIOSDATA:2099		      xor     dx, dx
BIOSDATA:209B		      div     cx	      ;	cx = sectors per cluster
BIOSDATA:209D		      mov     cs:temp_h, ax   ;	[temp_h]:ax now	contains the # clusters.
BIOSDATA:20A1		      pop     ax
BIOSDATA:20A2		      div     cx
BIOSDATA:20A4		      cmp     cs:temp_h, 0
BIOSDATA:20AA		      ja      short toobig_ret ; too big cluster number
BIOSDATA:20AC		      cmp     ax, 0FF6h	      ;	4096-10
BIOSDATA:20AC					      ;	is this	16-bit fat?
BIOSDATA:20AF		      jb      short copymediaid	; no, small fat
BIOSDATA:20B1		      or      ds:fbigfat, 40h ;	fbig ; 16 bit fat
BIOSDATA:20B6
BIOSDATA:20B6 copymediaid:			      ;	...
BIOSDATA:20B6		      push    es
BIOSDATA:20B7		      push    ds
BIOSDATA:20B8		      pop     es
BIOSDATA:20B9		      assume es:nothing
BIOSDATA:20B9		      push    cs
BIOSDATA:20BA		      pop     ds
BIOSDATA:20BB		      mov     bp, offset mov_media_ids
BIOSDATA:20BE		      push    cs	      ;	simulate far call
BIOSDATA:20BF		      call    near ptr call_bios_code
BIOSDATA:20C2		      push    es
BIOSDATA:20C3		      pop     ds
BIOSDATA:20C4		      pop     es
BIOSDATA:20C5		      assume es:nothing
BIOSDATA:20C5		      jmp     massage_bpb     ;	now final check	for bpb	info and return.
BIOSDATA:20C8 ;	---------------------------------------------------------------------------
BIOSDATA:20C8
BIOSDATA:20C8 toobig_ret:			      ;	...
BIOSDATA:20C8		      or      cs:fbigfat, 80h
BIOSDATA:20CE		      jmp     goodret	      ;	still drive letter is	assigned but useless.
BIOSDATA:20CE					      ;	to big for current pc dos fat file system
BIOSDATA:20D1 ;	---------------------------------------------------------------------------
BIOSDATA:20D1
BIOSDATA:20D1 unknown:				      ;	...
BIOSDATA:20D1		      or      word ptr [di+35],	200h ; unformatted_media
BIOSDATA:20D1					      ;	Set unformatted	media flag.
BIOSDATA:20D6
BIOSDATA:20D6 unknown3_0:			      ;	...
BIOSDATA:20D6		      mov     dx, [di+29]     ;	skip setting unformatted_media bit
BIOSDATA:20D6					      ;	[di+BDS.totalsecs32+2]
BIOSDATA:20D9		      mov     ax, [di+27]     ;	[di+BDS.totalsecs32]
BIOSDATA:20DC		      mov     si, offset disktable2
BIOSDATA:20DF
BIOSDATA:20DF scan:				      ;	...
BIOSDATA:20DF		      cmp     dx, cs:[si]
BIOSDATA:20E2		      jb      short gotparm
BIOSDATA:20E4		      ja      short scan_next
BIOSDATA:20E6		      cmp     ax, cs:[si+2]
BIOSDATA:20EA		      jbe     short gotparm
BIOSDATA:20EC
BIOSDATA:20EC scan_next:			      ;	...
BIOSDATA:20EC		      add     si, 10	      ;	5*2
BIOSDATA:20EF		      jmp     short scan      ;	covers upto 512	mb media
BIOSDATA:20F1 ;	---------------------------------------------------------------------------
BIOSDATA:20F1
BIOSDATA:20F1 gotparm:				      ;	...
BIOSDATA:20F1		      mov     cl, [si+8]      ;	fat size for fbigfat flag
BIOSDATA:20F4		      or      ds:fbigfat, cl
BIOSDATA:20F8		      mov     cx, cs:[si+4]   ;	ch = number of sectors per cluster
BIOSDATA:20F8					      ;	cl = log base 2	of ch
BIOSDATA:20FC		      mov     dx, cs:[si+6]   ;	dx = number of root dir	entries
BIOSDATA:2100		      mov     [di+12], dx     ;	[di+BDS.direntries]
BIOSDATA:2100					      ;	save number of (root) dir entries
BIOSDATA:2103		      mov     dx, [di+29]     ;	[di+BDS.totalsecs32+2]
BIOSDATA:2106		      mov     ax, [di+27]     ;	[di+BDS.totalsecs32]
BIOSDATA:2109		      mov     [di+8], ch      ;	[di+BDS.secperclus]
BIOSDATA:2109					      ;	save sectors per cluster
BIOSDATA:210C		      test    ds:fbigfat, 40h ;	fbig
BIOSDATA:210C					      ;	if (fbigfat)
BIOSDATA:2111		      jnz     short dobig     ;	go to dobig (16	bit fat)
BIOSDATA:2113		      xor     bx, bx	      ;	(12 bit	fat)
BIOSDATA:2115		      mov     bl, ch
BIOSDATA:2117		      dec     bx
BIOSDATA:2118		      add     bx, ax	      ;	dx=0
BIOSDATA:211A		      shr     bx, cl	      ;	bx = 1+(bpb->maxsec+BDS.secperclus-1)/
BIOSDATA:211C		      inc     bx	      ;	BDS.secperclus
BIOSDATA:211D		      and     bl, 0FEh	      ;	bx &= ~1; (=number of clusters)
BIOSDATA:2120		      mov     si, bx
BIOSDATA:2122		      shr     bx, 1
BIOSDATA:2124		      add     bx, si
BIOSDATA:2126		      add     bx, 511	      ;	bx += 511 + bx/2
BIOSDATA:212A		      shr     bh, 1	      ;	bh >>= 1; (=bx/512)
BIOSDATA:212C		      mov     [di+17], bh     ;	[di+BDS.fatsecs]
BIOSDATA:212C					      ;	save number of fat sectors
BIOSDATA:212F		      jmp     short massage_bpb
BIOSDATA:2131 ;	---------------------------------------------------------------------------
BIOSDATA:2131
BIOSDATA:2131 dobig:				      ;	...
BIOSDATA:2131		      mov     cl, 4	      ;	16 (2^4) directory entries per sector
BIOSDATA:2133		      push    dx	      ;	save total sectors (high)
BIOSDATA:2134		      mov     dx, [di+12]     ;	[di+BDS.direntries]
BIOSDATA:2137		      shr     dx, cl	      ;	root dir sectors = BDS.direntries / 16;
BIOSDATA:2139		      sub     ax, dx
BIOSDATA:213B		      pop     dx
BIOSDATA:213C		      sbb     dx, 0	      ;	dx:ax =	total sectors -	root dir sectors
BIOSDATA:213F		      sub     ax, 1
BIOSDATA:2142		      sbb     dx, 0	      ;	dx:ax =	t - r -	d
BIOSDATA:2142					      ;	total secs - reserved secs - root dir secs
BIOSDATA:2145		      mov     bl, 2
BIOSDATA:2147		      mov     bh, [di+8]      ;	[di+BDS.secperclus]
BIOSDATA:2147					      ;	bx = 256 * BDS.secperclus + 2
BIOSDATA:214A		      add     ax, bx	      ;	ax = t-r-d+256*spc+2
BIOSDATA:214C		      adc     dx, 0
BIOSDATA:214F		      sub     ax, 1	      ;	ax = t-r-d+256*spc+1
BIOSDATA:2152		      sbb     dx, 0
BIOSDATA:2155		      div     bx	      ;	BDS.fatsecs =
BIOSDATA:2155					      ;	ceil((total-dir-res)/(256*BDS.secperclus+2))
BIOSDATA:2157		      mov     [di+17], ax     ;	[di+BDS.fatsecs]
BIOSDATA:2157					      ;	number of fat sectors
BIOSDATA:215A		      mov     bl, ds:fbigfat
BIOSDATA:215E		      mov     [di+31], bl     ;	[di+BDS.fatsiz]	; fat size flag
BIOSDATA:2161		      push    ds
BIOSDATA:2162		      push    ds
BIOSDATA:2163		      pop     es
BIOSDATA:2164		      assume es:nothing
BIOSDATA:2164		      push    cs
BIOSDATA:2165		      pop     ds
BIOSDATA:2166		      mov     bp, offset clear_ids
BIOSDATA:2169		      push    cs
BIOSDATA:216A		      call    near ptr call_bios_code
BIOSDATA:216D		      pop     ds
BIOSDATA:216E
BIOSDATA:216E massage_bpb:			      ;	...
BIOSDATA:216E		      mov     dx, [di+29]     ;	[di+BDS.totalsecs32+2]
BIOSDATA:2171		      mov     ax, [di+27]     ;	[di+BDS.totalsecs32]
BIOSDATA:2174		      cmp     dx, 0	      ;	double word total sectors?
BIOSDATA:2177		      ja      short goodret   ;	don't have to change it.
BIOSDATA:2179		      cmp     word ptr [di+25],	0 ; [di+BDS.hiddensecs+2]
BIOSDATA:217D		      ja      short goodret   ;	don't have to change it.
BIOSDATA:217F		      add     ax, [di+23]     ;	[di+BDS.hiddensecs]
BIOSDATA:2182		      jb      short goodret
BIOSDATA:2184		      mov     ax, [di+27]     ;	[di+BDS.totalsecs32]
BIOSDATA:2187		      mov     [di+14], ax     ;	[di+BDS.totalsecs16]
BIOSDATA:218A		      mov     word ptr [di+27],	0 ; [di+BDS.totalsecs32]
BIOSDATA:218F
BIOSDATA:218F goodret:				      ;	...
BIOSDATA:218F		      mov     bl, ds:fbigfat
BIOSDATA:2193		      mov     [di+31], bl     ;	[di+BDS.fatsiz]
BIOSDATA:2193					      ;	set size of fat	on media
BIOSDATA:2196		      clc
BIOSDATA:2197
BIOSDATA:2197 ret_hard:				      ;	...
BIOSDATA:2197		      pop     es
BIOSDATA:2198		      assume es:nothing
BIOSDATA:2198		      pop     ds
BIOSDATA:2199		      pop     bx
BIOSDATA:219A		      pop     di
BIOSDATA:219B		      retn
BIOSDATA:219B sethard	      endp
BIOSDATA:219B
BIOSDATA:219C
BIOSDATA:219C ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:219C
BIOSDATA:219C
BIOSDATA:219C cover_fdisk_bug proc near		      ;	...
BIOSDATA:219C		      push    ax
BIOSDATA:219D		      push    dx
BIOSDATA:219E		      push    si
BIOSDATA:219F		      cmp     cs:disksector+26h, 29h ; disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
BIOSDATA:21A5		      jz      short cfb_retit ;	if extended bpb, then >= pc dos	4.00
BIOSDATA:21A7		      cmp     word ptr cs:[bx+7], '01' ; '10' (NASM syntax) ; os2 1.0 = ibm 10.0
BIOSDATA:21AD		      jnz     short cfb_chk_BPB_TOTALSECTORS
BIOSDATA:21AF		      cmp     byte ptr cs:[bx+0Ah], '0'
BIOSDATA:21B4		      jnz     short cfb_retit
BIOSDATA:21B6
BIOSDATA:21B6 cfb_chk_BPB_TOTALSECTORS:		      ;	...
BIOSDATA:21B6		      mov     si, (offset disksector+0Bh) ; disksector+EXT_BOOT.BPB
BIOSDATA:21B9		      cmp     word ptr cs:[si+8], 0 ; [cs:si+EBPB.TOTALSECTORS]
BIOSDATA:21B9					      ;	just to	make sure.
BIOSDATA:21BE		      jz      short cfb_retit
BIOSDATA:21C0		      mov     ax, cs:[si+8]   ;	[cs:si+EBPB.TOTALSECTORS]
BIOSDATA:21C4		      add     ax, cs:[si+11h] ;	[cs:si+EBPB.HIDDENSECTORS]
BIOSDATA:21C8		      jnb     short cfb_retit
BIOSDATA:21CA		      jnz     short cfb_retit ;
BIOSDATA:21CA					      ;	if carry set and ax=0
BIOSDATA:21CC		      dec     word ptr cs:[si+8] ; 0 ->	0FFFFh
BIOSDATA:21CC					      ;	decrease BPB_TOTALSECTORS by 1
BIOSDATA:21D0		      sub     word ptr [di+1Bh], 1 ; [di+BDS.totalsecs32]
BIOSDATA:21D4		      sbb     word ptr [di+1Dh], 0 ; [di+BDS.totalsecs32+2]
BIOSDATA:21D8
BIOSDATA:21D8 cfb_retit:			      ;	...
BIOSDATA:21D8		      pop     si
BIOSDATA:21D9		      pop     dx
BIOSDATA:21DA		      pop     ax
BIOSDATA:21DB		      retn
BIOSDATA:21DB cover_fdisk_bug endp
BIOSDATA:21DB
BIOSDATA:21DB ;	---------------------------------------------------------------------------
BIOSDATA:21DC word2	      dw 2		      ;	...
BIOSDATA:21DE word3	      dw 3		      ;	...
BIOSDATA:21E0 word512	      dw 512		      ;	...
BIOSDATA:21E2
BIOSDATA:21E2 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:21E2
BIOSDATA:21E2
BIOSDATA:21E2 setdrvparms     proc near		      ;	...
BIOSDATA:21E2		      xor     bx, bx
BIOSDATA:21E4		      les     di, dword	ptr ds:start_bds ; get first bds in list
BIOSDATA:21E8
BIOSDATA:21E8 next_bds:				      ;	...
BIOSDATA:21E8		      push    es
BIOSDATA:21E9		      push    di
BIOSDATA:21EA		      mov     bl, es:[di+34]  ;	[es:di+BDS.formfactor]
BIOSDATA:21EE		      cmp     bl, 5	      ;	ffHardFile
BIOSDATA:21F1		      jnz     short nothardff
BIOSDATA:21F3		      xor     dx, dx
BIOSDATA:21F5		      mov     ax, es:[di+14]  ;	[es:di+BDS.totalsecs16]
BIOSDATA:21F9		      or      ax, ax
BIOSDATA:21FB		      jnz     short get_ccyl
BIOSDATA:21FD		      mov     dx, es:[di+29]  ;	[es:di+BDS.totalsecs32+2]
BIOSDATA:2201		      mov     ax, es:[di+27]  ;	[es:di+BDS.totalsecs32]
BIOSDATA:2205
BIOSDATA:2205 get_ccyl:				      ;	...
BIOSDATA:2205		      push    dx
BIOSDATA:2206		      push    ax
BIOSDATA:2207		      mov     ax, es:[di+21]  ;	[es:di+BDS.heads]
BIOSDATA:220B		      mul     word ptr es:[di+19] ; [es:di+BDS.secpertrack]
BIOSDATA:220B					      ;	assume sectors per cyl.	< 64k.
BIOSDATA:220F		      mov     cx, ax	      ;	cx has # sectors per cylinder
BIOSDATA:2211		      pop     ax
BIOSDATA:2212		      pop     dx	      ;	dx:ax =	total sectors
BIOSDATA:2213		      push    ax
BIOSDATA:2214		      mov     ax, dx
BIOSDATA:2216		      xor     dx, dx
BIOSDATA:2218		      div     cx
BIOSDATA:221A		      mov     cs:temp_h, ax
BIOSDATA:221E		      pop     ax
BIOSDATA:221F		      div     cx	      ;	div #sec by sec/cyl to get # cyl.
BIOSDATA:2221		      or      dx, dx
BIOSDATA:2223		      jz      short no_cyl_rnd ; came out even
BIOSDATA:2225		      inc     ax	      ;	round up
BIOSDATA:2226
BIOSDATA:2226 no_cyl_rnd:			      ;	...
BIOSDATA:2226		      mov     es:[di+37], ax  ;	[es:di+BDS.cylinders]
BIOSDATA:222A		      push    es
BIOSDATA:222B		      pop     ds
BIOSDATA:222C		      assume ds:nothing
BIOSDATA:222C		      lea     si, [di+6]      ;	[di+BDS.bytespersec]
BIOSDATA:222C					      ;	ds:si -> bpb for hard file
BIOSDATA:222F		      jmp     short set_recbpb
BIOSDATA:2231 ;	---------------------------------------------------------------------------
BIOSDATA:2231
BIOSDATA:2231 nothardff:			      ;	...
BIOSDATA:2231		      push    cs
BIOSDATA:2232		      pop     ds
BIOSDATA:2233		      assume ds:nothing
BIOSDATA:2233		      cmp     cs:fakefloppydrv,	1
BIOSDATA:2239		      jz      short go_to_next_bds
BIOSDATA:223B		      cmp     bl, 7	      ;	ffother
BIOSDATA:223B					      ;	special	case "other" type of medium
BIOSDATA:223E		      jnz     short not_process_other
BIOSDATA:2240
BIOSDATA:2240 process_other:
BIOSDATA:2240		      xor     dx, dx
BIOSDATA:2242		      mov     ax, [di+37]     ;	[di+BDS.cylinders]
BIOSDATA:2245		      mul     word ptr [di+54] ; [di+BDS.rheads]
BIOSDATA:2248		      mul     word ptr [di+52] ; [di+BDS.rsecpertrack]
BIOSDATA:224B		      mov     [di+47], ax     ;	[di+BDS.rtotalsecs16]
BIOSDATA:224B					      ;	have the total number of sectors
BIOSDATA:224E		      dec     ax
BIOSDATA:224F		      mov     dl, 1
BIOSDATA:2251
BIOSDATA:2251 again:				      ;	...
BIOSDATA:2251		      cmp     ax, 0FF6h	      ;	4096-10
BIOSDATA:2254		      jb      short _@@
BIOSDATA:2256		      shr     ax, 1
BIOSDATA:2258		      shl     dl, 1
BIOSDATA:225A		      jmp     short again
BIOSDATA:225C ;	---------------------------------------------------------------------------
BIOSDATA:225C
BIOSDATA:225C _@@:				      ;	...
BIOSDATA:225C		      cmp     dl, 1	      ;	is it a	small disk ?
BIOSDATA:225F		      jz      short __@@      ;	yes, 224 root entries is enuf
BIOSDATA:2261		      mov     word ptr [di+45],	240 ; [di+BDS.rdirentries]
BIOSDATA:2266
BIOSDATA:2266 __@@:				      ;	...
BIOSDATA:2266		      mov     [di+41], dl     ;	[di+BDS.rsecperclus]
BIOSDATA:2269		      mul     cs:word3	      ;	* 3
BIOSDATA:226E		      div     cs:word2	      ;	/ 2
BIOSDATA:2273		      xor     dx, dx
BIOSDATA:2275		      div     cs:word512      ;	/ 512
BIOSDATA:227A		      inc     ax	      ;	+ 1
BIOSDATA:227B
BIOSDATA:227B no_round_up:			      ;	[di+BDS.rfatsecs]
BIOSDATA:227B		      mov     [di+50], ax
BIOSDATA:227E		      jmp     short go_to_next_bds
BIOSDATA:2280 ;	---------------------------------------------------------------------------
BIOSDATA:2280
BIOSDATA:2280 not_process_other:		      ;	...
BIOSDATA:2280		      shl     bx, 1	      ;	bx is word index into table of bpbs
BIOSDATA:2282		      mov     si, offset bpbtable
BIOSDATA:2285		      mov     si, [bx+si]     ;	get address of bpb
BIOSDATA:2287
BIOSDATA:2287 set_recbpb:			      ;	...
BIOSDATA:2287		      lea     di, [di+39]     ;	[di+BDS.R_BPB]
BIOSDATA:2287					      ;	es:di -> recbpb
BIOSDATA:228A		      mov     cx, 25	      ;	bpbx.size
BIOSDATA:228D		      rep movsb		      ;	move (size bpbx) bytes
BIOSDATA:228F
BIOSDATA:228F go_to_next_bds:			      ;	...
BIOSDATA:228F		      pop     di
BIOSDATA:2290		      pop     es	      ;	restore	pointer	to bds
BIOSDATA:2291		      les     di, es:[di]     ;	[es:di+BDS.link]
BIOSDATA:2294		      cmp     di, -1	      ;	-1
BIOSDATA:2297		      jz      short got_end_of_bds_chain
BIOSDATA:2299		      jmp     next_bds
BIOSDATA:229C ;	---------------------------------------------------------------------------
BIOSDATA:229C
BIOSDATA:229C got_end_of_bds_chain:		      ;	...
BIOSDATA:229C		      retn
BIOSDATA:229C setdrvparms     endp
BIOSDATA:229C
BIOSDATA:229D
BIOSDATA:229D ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:229D
BIOSDATA:229D
BIOSDATA:229D print_init      proc near		      ;	...
BIOSDATA:229D		      cbw
BIOSDATA:229E		      mov     dx, ax	      ;	AL = device number
BIOSDATA:22A0		      mov     ah, 1
BIOSDATA:22A2		      int     17h	      ;	PRINTER	- INITIALIZE
BIOSDATA:22A2					      ;	DX = printer port (0-3)
BIOSDATA:22A2					      ;	Return:	AH = status
BIOSDATA:22A4		      retn
BIOSDATA:22A4 print_init      endp
BIOSDATA:22A4
BIOSDATA:22A5
BIOSDATA:22A5 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:22A5
BIOSDATA:22A5
BIOSDATA:22A5 aux_init	      proc near		      ;	...
BIOSDATA:22A5		      cbw
BIOSDATA:22A6		      mov     dx, ax
BIOSDATA:22A8		      mov     al, 0A3h	      ;	RSINIT ; 2400,n,1,8 (msequ.inc)
BIOSDATA:22AA		      mov     ah, 0
BIOSDATA:22AC		      int     14h	      ;	SERIAL I/O - INITIALIZE	USART
BIOSDATA:22AC					      ;	AL = initializing parameters, DX = port	number (0-3)
BIOSDATA:22AC					      ;	Return:	AH = RS-232 status code	bits, AL = modem status	bits
BIOSDATA:22AE		      retn
BIOSDATA:22AE aux_init	      endp
BIOSDATA:22AE
BIOSDATA:22AF
BIOSDATA:22AF ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:22AF
BIOSDATA:22AF
BIOSDATA:22AF domini	      proc near		      ;	...
BIOSDATA:22AF		      mov     dh, ds:hnum     ;	get number of hardfiles
BIOSDATA:22B3		      cmp     dh, 0
BIOSDATA:22B6		      jz      short dominiret ;	no hard	file? then exit.
BIOSDATA:22B8		      mov     dl, 80h	      ;	start with hardfile 80h
BIOSDATA:22BA
BIOSDATA:22BA domini_loop:			      ;	...
BIOSDATA:22BA		      push    dx
BIOSDATA:22BB		      mov     ds:rom_minidisk_num, dl
BIOSDATA:22BF		      mov     ah, 8
BIOSDATA:22C1		      int     13h	      ;	DISK - DISK - GET CURRENT DRIVE	PARAMETERS (XT,AT,XT286,CONV,PS)
BIOSDATA:22C1					      ;	DL = drive number
BIOSDATA:22C1					      ;	Return:	CF set on error, AH = status code, BL =	drive type
BIOSDATA:22C1					      ;	DL = number of consecutive drives
BIOSDATA:22C1					      ;	DH = maximum value for head number, ES:DI -> drive parameter
BIOSDATA:22C3		      inc     dh
BIOSDATA:22C5		      xor     ax, ax
BIOSDATA:22C7		      mov     al, dh
BIOSDATA:22C9		      mov     ds:mini_hdlim, ax	; # of heads
BIOSDATA:22CC		      and     cl, 3Fh
BIOSDATA:22CF		      mov     al, cl
BIOSDATA:22D1		      mov     ds:mini_seclim, ax ; # of	sectors/track
BIOSDATA:22D4		      push    es
BIOSDATA:22D5		      mov     dl, ds:rom_minidisk_num
BIOSDATA:22D9		      call    getboot	      ;	read master boot record	into
BIOSDATA:22D9					      ;	initbootsegment:bootbias
BIOSDATA:22DC		      jb      short domininext
BIOSDATA:22DE		      call    find_mini_partition
BIOSDATA:22E1
BIOSDATA:22E1 domininext:			      ;	...
BIOSDATA:22E1		      pop     es
BIOSDATA:22E2		      pop     dx
BIOSDATA:22E3		      inc     dl	      ;	next hard file
BIOSDATA:22E5		      dec     dh
BIOSDATA:22E7		      jnz     short domini_loop
BIOSDATA:22E9
BIOSDATA:22E9 dominiret:			      ;	...
BIOSDATA:22E9		      retn
BIOSDATA:22E9 domini	      endp
BIOSDATA:22E9
BIOSDATA:22EA
BIOSDATA:22EA ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:22EA
BIOSDATA:22EA
BIOSDATA:22EA find_mini_partition proc near	      ;	...
BIOSDATA:22EA		      add     bx, 1C2h	      ;	bx -> file system id
BIOSDATA:22EE
BIOSDATA:22EE fmpnext:				      ;	...
BIOSDATA:22EE		      cmp     byte ptr es:[bx],	5 ; extended partition id. = 5
BIOSDATA:22F2		      jz      short fmpgot
BIOSDATA:22F4		      add     bx, 16
BIOSDATA:22F7		      cmp     bx, 402h	      ;	202h+bootbias
BIOSDATA:22FB		      jnz     short fmpnext
BIOSDATA:22FD		      jmp     short fmpret    ;	extended partition not found
BIOSDATA:22FF ;	---------------------------------------------------------------------------
BIOSDATA:22FF
BIOSDATA:22FF fmpgot:				      ;	...
BIOSDATA:22FF		      call    dmax_check      ;	found my partition.
BIOSDATA:22FF					      ;	check for drvmax already 26
BIOSDATA:2302		      jnb     short fmpret    ;	done if	too many
BIOSDATA:2304		      mov     di, ds:end_of_bdss ; get next free bds
BIOSDATA:2308		      mov     word ptr [di+71],	1 ; [di+BDS.bdsm_ismini]
BIOSDATA:230D		      or      word ptr [di+35],	1 ; or byte [di+BDS.flags],fNon_Removable
BIOSDATA:2311		      mov     byte ptr [di+34],	5 ; mov	byte [di+BDS.formfactor],ffHardFile
BIOSDATA:2315		      mov     ds:fbigfat, 0   ;	assume 12 bit fat.
BIOSDATA:231A		      mov     ax, ds:mini_hdlim
BIOSDATA:231D		      mov     [di+15h],	ax    ;	[di+BDS.heads]
BIOSDATA:2320		      mov     ax, ds:mini_seclim
BIOSDATA:2323		      mov     [di+13h],	ax    ;	[di+BDS.secpertrack]
BIOSDATA:2326		      mov     al, ds:rom_minidisk_num
BIOSDATA:2329		      mov     [di+4], al      ;	[di+BDS.drivenum]
BIOSDATA:2329					      ;	set physical number
BIOSDATA:232C		      mov     al, ds:drvmax
BIOSDATA:232F		      mov     [di+5], al      ;	[di+BDS.drivelet]
BIOSDATA:232F					      ;	set logical number
BIOSDATA:2332		      cmp     word ptr es:[bx+10], 0
BIOSDATA:2337		      ja      short fmpgot_cont
BIOSDATA:2339		      cmp     word ptr es:[bx+8], 64 ; with current bpb,
BIOSDATA:2339					      ;	only lower word	is meaningful.
BIOSDATA:233E		      jb      short fmpret    ;	should be bigger than 64 sectors at least
BIOSDATA:2340
BIOSDATA:2340 fmpgot_cont:			      ;	...
BIOSDATA:2340		      sub     bx, 4	      ;	let bx point to	the start of the entry
BIOSDATA:2343		      mov     dh, es:[bx+2]   ;	cylinder
BIOSDATA:2347		      and     dh, 0C0h	      ;	get higher bits	of cyl
BIOSDATA:234A		      rol     dh, 1
BIOSDATA:234C		      rol     dh, 1
BIOSDATA:234E		      mov     dl, es:[bx+3]   ;	cyl byte
BIOSDATA:2352		      mov     [di+73], dx     ;	[di+BDS.bdsm_hidden_trks]
BIOSDATA:2352					      ;	set hidden trks
BIOSDATA:2355		      mov     cx, es:[bx+2]   ;	cylinder,cylinder/sector
BIOSDATA:2359		      mov     dh, es:[bx+1]   ;	head
BIOSDATA:235D		      mov     dl, ds:rom_minidisk_num
BIOSDATA:2361		      mov     bx, 200h	      ;	bootbias
BIOSDATA:2364		      mov     ax, 201h
BIOSDATA:2367		      int     13h	      ;	DISK - READ SECTORS INTO MEMORY
BIOSDATA:2367					      ;	AL = number of sectors to read,	CH = track, CL = sector
BIOSDATA:2367					      ;	DH = head, DL =	drive, ES:BX ->	buffer to fill
BIOSDATA:2367					      ;	Return:	CF set on error, AH = status, AL = number of sectors read
BIOSDATA:2369		      jb      short fmpret
BIOSDATA:236B		      mov     bx, 3C2h	      ;	1C2h+bootbias
BIOSDATA:236E		      push    es
BIOSDATA:236F		      call    setmini	      ;	install	a mini disk.
BIOSDATA:236F					      ;	bx value saved.
BIOSDATA:2372		      pop     es
BIOSDATA:2373		      jb      short fmpnextchain
BIOSDATA:2375		      call    xinstall_bds    ;	-- install the bdsm into table
BIOSDATA:2378
BIOSDATA:2378 fmpnextchain:			      ;	...
BIOSDATA:2378		      jmp     fmpnext	      ;	let's find out if we have any chained partition
BIOSDATA:237B ;	---------------------------------------------------------------------------
BIOSDATA:237B
BIOSDATA:237B fmpret:				      ;	...
BIOSDATA:237B		      retn
BIOSDATA:237B find_mini_partition endp
BIOSDATA:237B
BIOSDATA:237C
BIOSDATA:237C ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:237C
BIOSDATA:237C
BIOSDATA:237C setmini	      proc near		      ;	...
BIOSDATA:237C		      push    di
BIOSDATA:237D		      push    bx
BIOSDATA:237E		      push    ds
BIOSDATA:237F		      push    es
BIOSDATA:2380
BIOSDATA:2380 setmini_1:			      ;	...
BIOSDATA:2380		      cmp     byte ptr es:[bx],	1 ; FAT12 partition
BIOSDATA:2384		      jz      short setmini_2
BIOSDATA:2386		      cmp     byte ptr es:[bx],	4 ; FAT16 partition
BIOSDATA:238A		      jz      short setmini_2
BIOSDATA:238C		      cmp     byte ptr es:[bx],	6 ; FAT16 BIG partition
BIOSDATA:2390		      jz      short setmini_2
BIOSDATA:2392		      add     bx, 16
BIOSDATA:2395		      cmp     bx, 402h	      ;	202h+bootbias
BIOSDATA:2399		      jnz     short setmini_1
BIOSDATA:239B		      stc
BIOSDATA:239C		      pop     es
BIOSDATA:239D		      pop     ds
BIOSDATA:239E		      pop     bx
BIOSDATA:239F		      pop     di
BIOSDATA:23A0		      retn
BIOSDATA:23A1 ;	---------------------------------------------------------------------------
BIOSDATA:23A1
BIOSDATA:23A1 setmini_2:			      ;	...
BIOSDATA:23A1		      jmp     set2
BIOSDATA:23A1 setmini	      endp
BIOSDATA:23A1
BIOSDATA:23A4
BIOSDATA:23A4 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:23A4
BIOSDATA:23A4
BIOSDATA:23A4 dmax_check      proc near		      ;	...
BIOSDATA:23A4		      cmp     ds:drvmax, 26   ;	checks for drvmax < 26
BIOSDATA:23A9		      jb      short dmax_ok   ;	return with carry if okay
BIOSDATA:23AB		      push    es
BIOSDATA:23AC		      mov     ax, 473h	      ;	SYSINIT	segment	(SYSINITSEG)
BIOSDATA:23AF		      mov     es, ax
BIOSDATA:23B1		      assume es:nothing
BIOSDATA:23B1		      mov     es:toomanydrivesflag, 1 ;	SYSINITSEG:TOOMANYDRIVESFLAG
BIOSDATA:23B7		      pop     es
BIOSDATA:23B8		      assume es:nothing
BIOSDATA:23B8
BIOSDATA:23B8 dmax_ok:				      ;	...
BIOSDATA:23B8		      retn		      ;	cf = 0 -> error	(too many drives), cf =	1 -> ok
BIOSDATA:23B8 dmax_check      endp
BIOSDATA:23B8
BIOSDATA:23B9
BIOSDATA:23B9 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:23B9
BIOSDATA:23B9
BIOSDATA:23B9 xinstall_bds    proc near		      ;	...
BIOSDATA:23B9		      push    si
BIOSDATA:23BA		      push    bx
BIOSDATA:23BB		      mov     si, ds:start_bds ; get first bds
BIOSDATA:23BF
BIOSDATA:23BF xinstall_bds_1:			      ;	...
BIOSDATA:23BF		      cmp     word ptr [si], 0FFFFh ; -1 ; is this the last one?
BIOSDATA:23C2		      jz      short xinstall_bds_2 ; skip ahead	if so
BIOSDATA:23C4		      mov     si, [si]	      ;	[si+BDS.link] ;	chain through list
BIOSDATA:23C6		      jmp     short xinstall_bds_1
BIOSDATA:23C8 ;	---------------------------------------------------------------------------
BIOSDATA:23C8
BIOSDATA:23C8 xinstall_bds_2:			      ;	...
BIOSDATA:23C8		      mov     [si], di	      ;	[si+BDS.link]
BIOSDATA:23CA		      mov     word ptr [si+2], ds ; [si+BDS.link+2]
BIOSDATA:23CD		      mov     word ptr [di], 0FFFFh ; [di+BDS.link],-1
BIOSDATA:23CD					      ;	make sure it is	a null ptr.
BIOSDATA:23D1		      mov     word ptr [di+2], ds ; might as well plug segment
BIOSDATA:23D4		      lea     bx, [di+6]
BIOSDATA:23D7		      mov     si, ds:last_dskdrv_table
BIOSDATA:23DB		      mov     [si], bx
BIOSDATA:23DD		      add     ds:last_dskdrv_table, 2
BIOSDATA:23E2		      inc     ds:drvmax
BIOSDATA:23E6		      add     ds:end_of_bdss, 100 ; BDS.size = 100
BIOSDATA:23EB		      pop     bx
BIOSDATA:23EC		      pop     si
BIOSDATA:23ED		      retn
BIOSDATA:23ED xinstall_bds    endp
BIOSDATA:23ED
BIOSDATA:23EE
BIOSDATA:23EE ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:23EE
BIOSDATA:23EE
BIOSDATA:23EE cmos_clock_read proc near		      ;	...
BIOSDATA:23EE		      push    ax
BIOSDATA:23EF		      push    cx
BIOSDATA:23F0		      push    dx
BIOSDATA:23F1		      push    bp
BIOSDATA:23F2		      xor     bp, bp
BIOSDATA:23F4
BIOSDATA:23F4 loop_clock:			      ;	...
BIOSDATA:23F4		      xor     cx, cx
BIOSDATA:23F6		      xor     dx, dx
BIOSDATA:23F8		      mov     ah, 2
BIOSDATA:23FA		      int     1Ah	      ;	CLOCK -	READ REAL TIME CLOCK (AT,XT286,CONV,PS)
BIOSDATA:23FA					      ;	Return:	CH = hours in BCD
BIOSDATA:23FA					      ;	CL = minutes in	BCD
BIOSDATA:23FA					      ;	DH = seconds in	BCD
BIOSDATA:23FC		      cmp     cx, 0
BIOSDATA:23FF		      jnz     short clock_present
BIOSDATA:2401		      cmp     dx, 0
BIOSDATA:2404		      jnz     short clock_present
BIOSDATA:2406		      cmp     bp, 1	      ;	read again after a slight delay, in case clock
BIOSDATA:2409		      jz      short no_readdate	; was at zero setting.
BIOSDATA:240B		      inc     bp	      ;	only perform delay once.
BIOSDATA:240C		      mov     cx, 4000h	      ;	16384
BIOSDATA:240F
BIOSDATA:240F delay:				      ;	...
BIOSDATA:240F		      loop    delay
BIOSDATA:2411		      jmp     short loop_clock
BIOSDATA:2413 ;	---------------------------------------------------------------------------
BIOSDATA:2413
BIOSDATA:2413 clock_present:			      ;	...
BIOSDATA:2413		      mov     cs:havecmoscloc, 1 ; set the flag	for cmos clock
BIOSDATA:2419		      call    cmosck	      ;	reset cmos clock rate that may be
BIOSDATA:2419					      ;	possibly destroyed by cp dos and
BIOSDATA:2419					      ;	post routine did not restore that.
BIOSDATA:241C		      push    si
BIOSDATA:241D		      call    read_real_date  ;	read real-time clock for date
BIOSDATA:2420		      cli
BIOSDATA:2421		      mov     ds:daycnt, si   ;	set system date
BIOSDATA:2425		      sti
BIOSDATA:2426		      pop     si
BIOSDATA:2427
BIOSDATA:2427 no_readdate:			      ;	...
BIOSDATA:2427		      pop     bp
BIOSDATA:2428		      pop     dx
BIOSDATA:2429		      pop     cx
BIOSDATA:242A		      pop     ax
BIOSDATA:242B		      retn
BIOSDATA:242B cmos_clock_read endp
BIOSDATA:242B
BIOSDATA:242C
BIOSDATA:242C ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:242C
BIOSDATA:242C
BIOSDATA:242C cmosck	      proc near		      ;	...
BIOSDATA:242C		      push    ax
BIOSDATA:242D		      cmp     cs:model_byte, 0FCh ; Exit if not	an AT model
BIOSDATA:2433		      jnz     short cmosck9
BIOSDATA:2435		      cmp     cs:secondary_model_byte, 6 ; Is it 06 for	the industral AT ?
BIOSDATA:243B		      jz      short cmosck4   ;	Go reset CMOS periodic rate if 06
BIOSDATA:243D		      cmp     cs:secondary_model_byte, 4 ; Is it 00, 01, 02, or	03 ?
BIOSDATA:2443		      jnb     short cmosck9   ;	EXIT if	problem	fixed by POST
BIOSDATA:2443					      ;	Also,Secondary_model_byte = 0
BIOSDATA:2445
BIOSDATA:2445 cmosck4:				      ;	...
BIOSDATA:2445		      mov     al, 8Ah	      ;	cmos_reg_a|nmi
BIOSDATA:2445					      ;	NMI disabled on	return
BIOSDATA:2447		      mov     ah, 26h	      ;	00100110b ; Set	divider	& rate selection
BIOSDATA:2449		      call    cmos_write
BIOSDATA:244C		      mov     al, 8Bh	      ;	cmos_reg_b|nmi
BIOSDATA:244C					      ;	NMI disabled on	return
BIOSDATA:244E		      call    cmos_read
BIOSDATA:2451		      and     al, 7	      ;	00000111b ; clear SET,PIE,AIE,UIE,SQWE
BIOSDATA:2453		      mov     ah, al
BIOSDATA:2455		      mov     al, 0Bh	      ;	cmos_reg_b ; NMI enabled on return
BIOSDATA:2457		      call    cmos_write
BIOSDATA:245A
BIOSDATA:245A cmosck9:				      ;	...
BIOSDATA:245A		      pop     ax
BIOSDATA:245B		      retn
BIOSDATA:245B cmosck	      endp
BIOSDATA:245B
BIOSDATA:245C
BIOSDATA:245C ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:245C
BIOSDATA:245C
BIOSDATA:245C cmos_read	      proc near		      ;	...
BIOSDATA:245C		      pushf
BIOSDATA:245D		      cli
BIOSDATA:245E		      push    bx
BIOSDATA:245F		      push    ax	      ;	AL = cmos table	address	to be read
BIOSDATA:2460		      or      al, 80h
BIOSDATA:2462		      out     70h, al	      ;	CMOS Memory/RTC	Index Register:	RTC Seconds
BIOSDATA:2464		      nop		      ;	(undocumented delay needed)
BIOSDATA:2465		      in      al, 71h	      ;	CMOS Memory/RTC	Data Register
BIOSDATA:2467		      mov     bx, ax
BIOSDATA:2469		      pop     ax
BIOSDATA:246A		      and     al, 80h
BIOSDATA:246C		      or      al, 0Fh
BIOSDATA:246E		      out     70h, al	      ;	CMOS Memory/RTC	Index Register:	RTC Seconds
BIOSDATA:2470		      nop
BIOSDATA:2471		      in      al, 71h	      ;	CMOS Memory/RTC	Data Register
BIOSDATA:2473		      mov     ax, bx
BIOSDATA:2475		      pop     bx
BIOSDATA:2476		      push    cs	      ;	*place code segment in stack and
BIOSDATA:2476					      ;	*handle	popf for b- level 80286
BIOSDATA:2477		      call    near ptr cmod_popf
BIOSDATA:247A		      retn		      ;	return with flags restored
BIOSDATA:247A cmos_read	      endp
BIOSDATA:247A
BIOSDATA:247B
BIOSDATA:247B ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:247B
BIOSDATA:247B
BIOSDATA:247B cmod_popf	      proc far		      ;	...
BIOSDATA:247B		      iret		      ;	popf for level b- parts
BIOSDATA:247B cmod_popf	      endp		      ;	return far and restore flags
BIOSDATA:247B
BIOSDATA:247C
BIOSDATA:247C ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:247C
BIOSDATA:247C
BIOSDATA:247C cmos_write      proc near		      ;	...
BIOSDATA:247C		      pushf		      ;	write (ah) to location (al)
BIOSDATA:247D		      push    ax
BIOSDATA:247E		      cli
BIOSDATA:247F		      push    ax	      ;	save user nmi state
BIOSDATA:2480		      or      al, 80h	      ;	disable	nmi for	us
BIOSDATA:2482		      out     70h, al	      ;	CMOS Memory/RTC	Index Register:	RTC Seconds
BIOSDATA:2484		      nop
BIOSDATA:2485		      mov     al, ah
BIOSDATA:2487		      out     71h, al	      ;	CMOS Memory/RTC	Data Register
BIOSDATA:2489		      pop     ax	      ;	get user nmi
BIOSDATA:248A		      and     al, 80h
BIOSDATA:248C		      or      al, 0Fh
BIOSDATA:248E		      out     70h, al	      ;	CMOS Memory/RTC	Index Register:	RTC Seconds
BIOSDATA:2490		      nop
BIOSDATA:2491		      in      al, 71h	      ;	CMOS Memory/RTC	Data Register
BIOSDATA:2493		      pop     ax
BIOSDATA:2494		      push    cs	      ;	*place code segment in stack and
BIOSDATA:2495		      call    near ptr cmod_popf ; *handle popf	for b- level 80286
BIOSDATA:2498		      retn
BIOSDATA:2498 cmos_write      endp
BIOSDATA:2498
BIOSDATA:2499
BIOSDATA:2499 ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:2499
BIOSDATA:2499
BIOSDATA:2499 getclus	      proc near		      ;	...
BIOSDATA:2499		      push    cx	      ;	bx = cluster to	read
BIOSDATA:2499					      ;	cx = sectors per cluster
BIOSDATA:2499					      ;	es:di =	load location
BIOSDATA:249A		      push    di
BIOSDATA:249B		      mov     cs:doscnt, cx
BIOSDATA:24A0		      mov     ax, bx
BIOSDATA:24A2		      dec     ax
BIOSDATA:24A3		      dec     ax
BIOSDATA:24A4		      mul     cx	      ;	convert	to logical sector
BIOSDATA:24A4					      ;	dx:ax =	matching logical sector	number
BIOSDATA:24A4					      ;	starting from the data sector
BIOSDATA:24A6		      add     ax, cs:bios_l
BIOSDATA:24AB		      adc     dx, cs:bios_h   ;	dx:ax =	first logical sector to	read
BIOSDATA:24B0
BIOSDATA:24B0 unpack:				      ;	...
BIOSDATA:24B0		      push    ds
BIOSDATA:24B1		      push    ax
BIOSDATA:24B2		      push    bx
BIOSDATA:24B3		      mov     si, cs:fatloc
BIOSDATA:24B8		      mov     ds, si
BIOSDATA:24BA		      mov     si, bx	      ;	next cluster
BIOSDATA:24BC		      test    cs:fbigfat, 40h ;	fbig
BIOSDATA:24BC					      ;	16 bit fat?
BIOSDATA:24C2		      jnz     short unpack16  ;	yes
BIOSDATA:24C4
BIOSDATA:24C4 unpack12:
BIOSDATA:24C4		      shr     si, 1
BIOSDATA:24C6		      add     si, bx	      ;	12 bit fat. si=si/2
BIOSDATA:24C6					      ;	si = clus + clus/2
BIOSDATA:24C6					      ;	(si = byte offset of the cluster in the	FAT)
BIOSDATA:24C8		      push    dx
BIOSDATA:24C9		      xor     dx, dx
BIOSDATA:24CB		      call    get_fat_sector
BIOSDATA:24CE		      pop     dx
BIOSDATA:24CF		      mov     ax, [bx]	      ;	save cluster number into ax
BIOSDATA:24D1		      jnz     short even_odd  ;	if not a splitted fat, check even-odd
BIOSDATA:24D3		      mov     al, [bx]	      ;	(not needed!) Erdogan Tan - 2023
BIOSDATA:24D5		      mov     byte ptr cs:temp_cluster,	al ; splitted fat
BIOSDATA:24D9		      inc     si	      ;	(next byte)
BIOSDATA:24DA		      push    dx
BIOSDATA:24DB		      xor     dx, dx
BIOSDATA:24DD		      call    get_fat_sector
BIOSDATA:24E0		      pop     dx
BIOSDATA:24E1		      mov     al, byte ptr ds:0
BIOSDATA:24E4		      mov     byte ptr cs:temp_cluster+1, al
BIOSDATA:24E8		      mov     ax, cs:temp_cluster
BIOSDATA:24EC
BIOSDATA:24EC even_odd:				      ;	...
BIOSDATA:24EC		      pop     bx	      ;	restore	old fat	entry value
BIOSDATA:24ED		      push    bx
BIOSDATA:24EE		      shr     bx, 1	      ;	was it even or odd?
BIOSDATA:24F0		      jnb     short havclus   ;	it was even
BIOSDATA:24F2		      shr     ax, 1	      ;	odd. massage fat value and keep
BIOSDATA:24F2					      ;	the highest 12 bits.
BIOSDATA:24F4		      shr     ax, 1
BIOSDATA:24F6		      shr     ax, 1
BIOSDATA:24F8		      shr     ax, 1
BIOSDATA:24FA
BIOSDATA:24FA havclus:				      ;	...
BIOSDATA:24FA		      mov     bx, ax	      ;	now bx = new fat entry
BIOSDATA:24FC		      and     bx, 0FFFh	      ;	keep low 12 bits
BIOSDATA:2500		      jmp     short unpackx
BIOSDATA:2502 ;	---------------------------------------------------------------------------
BIOSDATA:2502
BIOSDATA:2502 unpack16:				      ;	...
BIOSDATA:2502		      push    dx
BIOSDATA:2503		      xor     dx, dx	      ;	extend to 32 bit offset
BIOSDATA:2505		      shl     si, 1	      ;	cluster	number * 2
BIOSDATA:2507		      adc     dx, 0
BIOSDATA:250A		      call    get_fat_sector
BIOSDATA:250D		      pop     dx
BIOSDATA:250E		      mov     bx, [bx]	      ;	bx = new fat entry
BIOSDATA:2510
BIOSDATA:2510 unpackx:				      ;	...
BIOSDATA:2510		      pop     si
BIOSDATA:2511		      pop     ax
BIOSDATA:2512		      pop     ds
BIOSDATA:2513		      sub     si, bx	      ;	previous - current (or current - new)
BIOSDATA:2515		      cmp     si, -1	      ;	one apart? (current = previous+1)
BIOSDATA:2518		      jnz     short getcl2
BIOSDATA:251A		      add     cs:doscnt, cx   ;	consequental cluster read, +1 cluster sectors
BIOSDATA:251A					      ;	(cx = sectors per cluster)
BIOSDATA:251F		      jmp     short unpack
BIOSDATA:2521 ;	---------------------------------------------------------------------------
BIOSDATA:2521
BIOSDATA:2521 getcl2:				      ;	...
BIOSDATA:2521		      push    bx
BIOSDATA:2522		      push    dx	      ;	sector to read (high)
BIOSDATA:2523		      push    ax	      ;	sector to read (low)
BIOSDATA:2524		      mov     ax, cs:drvfat   ;	get drive and fat spec
BIOSDATA:2528		      mov     cx, cs:doscnt
BIOSDATA:252D		      pop     dx	      ;	sector to read for diskrd (low)
BIOSDATA:252E		      pop     cs:start_sec_h  ;	sector to read for diskrd (high)
BIOSDATA:2533		      push    ds
BIOSDATA:2534		      push    cs
BIOSDATA:2535		      pop     ds
BIOSDATA:2536		      push    cs	      ;	simulate far call
BIOSDATA:2537		      mov     bp, offset DISKRD	; BIOSCODE:8E5h	; 2C7h:8E5h
BIOSDATA:253A		      call    near ptr call_bios_code
BIOSDATA:253D		      pop     ds
BIOSDATA:253E		      pop     bx
BIOSDATA:253F		      pop     di
BIOSDATA:2540		      mov     ax, cs:doscnt   ;	sector count
BIOSDATA:2544		      xchg    ah, al
BIOSDATA:2546		      shl     ax, 1	      ;	ax = ax	* 512 ;	byte count
BIOSDATA:2548		      add     di, ax	      ;	update load location
BIOSDATA:254A		      pop     cx
BIOSDATA:254B		      retn
BIOSDATA:254B getclus	      endp
BIOSDATA:254B
BIOSDATA:254C
BIOSDATA:254C ;	===============	S U B R	O U T I	N E =======================================
BIOSDATA:254C
BIOSDATA:254C
BIOSDATA:254C get_fat_sector  proc near		      ;	...
BIOSDATA:254C		      push    ax	      ;	dx:si =	offset value (starting from fat	entry 0)
BIOSDATA:254C					      ;		of fat entry to	find
BIOSDATA:254D		      push    cx
BIOSDATA:254E		      push    di
BIOSDATA:254F		      push    si
BIOSDATA:2550		      push    es
BIOSDATA:2551		      push    ds
BIOSDATA:2552		      mov     ax, si
BIOSDATA:2554		      mov     cx, cs:md_sectorsize ; 512
BIOSDATA:2559		      div     cx
BIOSDATA:255B		      nop		      ;	ax = sector number, dx = offset
BIOSDATA:255C		      push    es
BIOSDATA:255D		      push    ds
BIOSDATA:255E		      push    di
BIOSDATA:255F		      push    ax
BIOSDATA:2560		      push    cs
BIOSDATA:2561		      pop     ds
BIOSDATA:2562		      mov     ax, cs:drvfat   ;	get drive # and	FAT id
BIOSDATA:2566		      mov     bp, offset SetDrive ; BIOSCODE:04D7h
BIOSDATA:2569		      push    cs
BIOSDATA:256A		      call    near ptr call_bios_code ;	get bds	for drive
BIOSDATA:256D		      pop     ax	      ;	(sector	number -without	reserved and hidden sectors-)
BIOSDATA:256E		      add     ax, es:[di+9]   ;	[es:di+BDS.resectors]
BIOSDATA:256E					      ;	add #reserved_sectors
BIOSDATA:2572		      pop     di
BIOSDATA:2573		      pop     ds
BIOSDATA:2574		      pop     es
BIOSDATA:2575		      cmp     ax, cs:last_fat_secnum
BIOSDATA:257A		      jz      short gfs_split_chk ; don't need to read it again
BIOSDATA:257C		      mov     cs:last_fat_secnum, ax ; sector number
BIOSDATA:257C					      ;	(in the	partition, without hidden sectors)
BIOSDATA:2580		      push    dx
BIOSDATA:2581		      mov     cs:start_sec_h, 0	; prepare to read the fat sector
BIOSDATA:2581					      ;	start_sec_h is always 0	for fat	sector
BIOSDATA:2588		      mov     dx, ax
BIOSDATA:258A		      mov     cx, 1	      ;	1 sector read
BIOSDATA:258D		      mov     ax, cs:drvfat
BIOSDATA:2591		      push    ds
BIOSDATA:2592		      pop     es
BIOSDATA:2593		      assume es:nothing
BIOSDATA:2593		      xor     di, di	      ;	es:di -> fatloc	segment:0
BIOSDATA:2595		      push    ds
BIOSDATA:2596		      push    cs
BIOSDATA:2597		      pop     ds
BIOSDATA:2598		      push    cs	      ;	simulate far call
BIOSDATA:2599		      mov     bp, offset DISKRD	; BIOSCODE:08E5h ; 2C7h:8E5h
BIOSDATA:259C		      call    near ptr call_bios_code
BIOSDATA:259F		      pop     ds
BIOSDATA:25A0		      pop     dx
BIOSDATA:25A1		      mov     cx, cs:md_sectorsize ; 512
BIOSDATA:25A6
BIOSDATA:25A6 gfs_split_chk:			      ;	...
BIOSDATA:25A6		      dec     cx	      ;	511
BIOSDATA:25A7		      cmp     dx, cx	      ;	if offset points to the	last byte of this sector,
BIOSDATA:25A7					      ;	then splitted entry.
BIOSDATA:25A9		      mov     bx, dx	      ;	offset value from fatloc segment
BIOSDATA:25AB		      pop     ds
BIOSDATA:25AC		      pop     es
BIOSDATA:25AD		      assume es:nothing
BIOSDATA:25AD		      pop     si
BIOSDATA:25AE		      pop     di
BIOSDATA:25AF		      pop     cx
BIOSDATA:25B0		      pop     ax
BIOSDATA:25B1		      retn
BIOSDATA:25B1 get_fat_sector  endp
BIOSDATA:25B1
BIOSDATA:25B1 ;	---------------------------------------------------------------------------
BIOSDATA:25B2		      db 14 dup(0)
BIOSDATA:25B2 BIOSDATA	      ends
BIOSDATA:25B2
BIOSCODE:0000 ;	===========================================================================
BIOSCODE:0000
BIOSCODE:0000 ;	Segment	type: Regular
BIOSCODE:0000 BIOSCODE	      segment byte public 'BIOSCODE' use16
BIOSCODE:0000		      assume cs:BIOSCODE
BIOSCODE:0000		      assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
BIOSCODE:0000 BCode_start     db 30h dup(0)
BIOSCODE:0030 Bios_Data_Word  dw 70h		      ;	...
BIOSCODE:0030					      ;	BIOSDATA segment
BIOSCODE:0032 ;	---------------------------------------------------------------------------
BIOSCODE:0032
BIOSCODE:0032 _seg_reinit:			      ;	...
BIOSCODE:0032		      mov     es, cs:Bios_Data_Word
BIOSCODE:0037		      assume es:nothing
BIOSCODE:0037		      mov     di, offset cdev_2	; (offset cdev+2)
BIOSCODE:003A		      mov     cx, 4
BIOSCODE:003D
BIOSCODE:003D _seg_reinit_1:			      ;	...
BIOSCODE:003D		      stosw		      ;	ax = new code (BIOSCODE) segment value
BIOSCODE:003E		      inc     di
BIOSCODE:003F		      inc     di
BIOSCODE:0040		      loop    _seg_reinit_1
BIOSCODE:0042		      retf
BIOSCODE:0043 ;	---------------------------------------------------------------------------
BIOSCODE:0043
BIOSCODE:0043 chardev_entry:			      ;	...
BIOSCODE:0043		      push    si
BIOSCODE:0044		      push    ax
BIOSCODE:0045		      push    cx
BIOSCODE:0046		      push    dx
BIOSCODE:0047		      push    di
BIOSCODE:0048		      push    bp
BIOSCODE:0049		      push    ds
BIOSCODE:004A		      push    es
BIOSCODE:004B		      push    bx
BIOSCODE:004C		      mov     bp, sp
BIOSCODE:004E		      mov     si, [bp+18]     ;	get return address (dispatch table)
BIOSCODE:0051		      mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
BIOSCODE:0056		      assume ds:nothing
BIOSCODE:0056		      mov     ax, [si+2]      ;	get the	device number if present
BIOSCODE:0059		      mov     byte ptr ds:auxnum, al
BIOSCODE:005C		      mov     ds:printdev, ah
BIOSCODE:0060		      mov     si, [si]	      ;	point to the device dispatch table
BIOSCODE:0062		      les     bx, ds:ptrsav   ;	get pointer to i/o packet
BIOSCODE:0066		      assume es:nothing
BIOSCODE:0066		      mov     al, es:[bx+1]   ;	[es:bx+unit] ; al = unit code
BIOSCODE:006A		      mov     ah, es:[bx+13]  ;	[es:bx+media] ;	ah = media descrip
BIOSCODE:006E		      mov     cx, es:[bx+18]  ;	[es:bx+count] ;	cx = count
BIOSCODE:0072		      mov     dx, es:[bx+20]  ;	[es:bx+start] ;	dx = start sector
BIOSCODE:0076		      cmp     si, offset DSKTBL	; BIOSCODE:4A2h
BIOSCODE:007A		      jnz     short no_sector32_mapping
BIOSCODE:007C		      mov     ds:start_sec_h, 0
BIOSCODE:0082		      cmp     dx, 0FFFFh
BIOSCODE:0085		      jnz     short no_sector32_mapping
BIOSCODE:0087		      mov     dx, es:[bx+28]  ;	[es:bx+start_h]
BIOSCODE:0087					      ;	32 bit dsk req
BIOSCODE:008B		      mov     ds:start_sec_h, dx ; start_sec_h = packet.start_h
BIOSCODE:008F		      mov     dx, es:[bx+26]  ;	[es:bx+start_l]
BIOSCODE:008F					      ;	dx = packet.start_l
BIOSCODE:0093
BIOSCODE:0093 no_sector32_mapping:		      ;	...
BIOSCODE:0093		      xchg    ax, di
BIOSCODE:0094		      mov     al, es:[bx+2]   ;	[es:bx+cmd]
BIOSCODE:0098		      cmp     al, cs:[si]
BIOSCODE:009B		      jnb     short command_error
BIOSCODE:009D		      cbw		      ;	note that al <=	15 means ok
BIOSCODE:009E		      shl     ax, 1
BIOSCODE:00A0		      add     si, ax
BIOSCODE:00A2		      xchg    ax, di
BIOSCODE:00A3		      les     di, es:[bx+14]  ;	[es:bx+trans]
BIOSCODE:00A7		      cld
BIOSCODE:00A8		      call    word ptr cs:[si+1]
BIOSCODE:00AC		      jb      short already_got_ah_status
BIOSCODE:00AE		      mov     ah, 1
BIOSCODE:00B0
BIOSCODE:00B0 already_got_ah_status:		      ;	...
BIOSCODE:00B0		      mov     ds, cs:Bios_Data_Word
BIOSCODE:00B5		      lds     bx, ds:ptrsav
BIOSCODE:00B9		      assume ds:nothing
BIOSCODE:00B9		      mov     [bx+3], ax      ;	[bx+status]
BIOSCODE:00B9					      ;	mark operation complete
BIOSCODE:00BC		      pop     bx
BIOSCODE:00BD		      pop     es
BIOSCODE:00BE		      pop     ds
BIOSCODE:00BF		      pop     bp
BIOSCODE:00C0		      pop     di
BIOSCODE:00C1		      pop     dx
BIOSCODE:00C2		      pop     cx
BIOSCODE:00C3		      pop     ax
BIOSCODE:00C4		      pop     si
BIOSCODE:00C5		      add     sp, 2	      ;	get rid	of fake	return address
BIOSCODE:00C8
BIOSCODE:00C8 bc_retf:				      ;	...
BIOSCODE:00C8		      retf
BIOSCODE:00C9 ;	---------------------------------------------------------------------------
BIOSCODE:00C9
BIOSCODE:00C9 command_error:			      ;	...
BIOSCODE:00C9		      call    bc_cmderr
BIOSCODE:00CC		      jmp     short already_got_ah_status
BIOSCODE:00CC ;	---------------------------------------------------------------------------
BIOSCODE:00CE		      dw 0
BIOSCODE:00D0 _offset_D0h     db 5 dup(0)	      ;	5 bytes	from 0:C0h will	be copied onto here
BIOSCODE:00D0					      ;	which is the CP/M call 5 entry point
BIOSCODE:00D5
BIOSCODE:00D5 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:00D5
BIOSCODE:00D5
BIOSCODE:00D5 bc_cmderr	      proc near		      ;	...
BIOSCODE:00D5		      mov     al, 3	      ;	unknown	command	error
BIOSCODE:00D7
BIOSCODE:00D7 bc_err_cnt:			      ;	...
BIOSCODE:00D7		      les     bx, ds:ptrsav
BIOSCODE:00DB		      sub     es:[bx+18], cx
BIOSCODE:00DF		      mov     ah, 81h	      ;	mark error return
BIOSCODE:00E1		      stc		      ;	indicate abnormal end
BIOSCODE:00E2		      retn
BIOSCODE:00E2 bc_cmderr	      endp
BIOSCODE:00E2
BIOSCODE:00E2 ;	---------------------------------------------------------------------------
BIOSCODE:00E3		      db 0
BIOSCODE:00E4 con_table	      db 11		      ;	((con_table_end	- con_table)-1)/2 = 11
BIOSCODE:00E5		      dw offset	bc_exvec
BIOSCODE:00E7		      dw offset	bc_exvec
BIOSCODE:00E9		      dw offset	bc_exvec
BIOSCODE:00EB		      dw offset	bc_cmderr
BIOSCODE:00ED		      dw offset	con_read
BIOSCODE:00EF		      dw offset	con_rdnd
BIOSCODE:00F1		      dw offset	bc_exvec
BIOSCODE:00F3		      dw offset	con_flush
BIOSCODE:00F5		      dw offset	con_writ
BIOSCODE:00F7		      dw offset	con_writ
BIOSCODE:00F9		      dw offset	bc_exvec
BIOSCODE:00FB prn_table	      db 26		      ;	((prn_table_end	- prn_table)-1)/2 = 26
BIOSCODE:00FC		      dw offset	bc_exvec
BIOSCODE:00FE		      dw offset	bc_exvec
BIOSCODE:0100		      dw offset	bc_exvec
BIOSCODE:0102		      dw offset	bc_cmderr
BIOSCODE:0104		      dw offset	prn_input
BIOSCODE:0106		      dw offset	z_bus_exit
BIOSCODE:0108		      dw offset	bc_exvec
BIOSCODE:010A		      dw offset	bc_exvec
BIOSCODE:010C		      dw offset	prn_writ
BIOSCODE:010E		      dw offset	prn_writ
BIOSCODE:0110		      dw offset	prn_stat
BIOSCODE:0112		      dw offset	bc_exvec
BIOSCODE:0114		      dw offset	bc_exvec
BIOSCODE:0116		      dw offset	bc_exvec
BIOSCODE:0118		      dw offset	bc_exvec
BIOSCODE:011A		      dw offset	bc_exvec
BIOSCODE:011C		      dw offset	prn_tilbusy
BIOSCODE:011E		      dw offset	bc_exvec
BIOSCODE:0120		      dw offset	bc_exvec
BIOSCODE:0122		      dw offset	prn_genioctl
BIOSCODE:0124		      dw offset	bc_exvec
BIOSCODE:0126		      dw offset	bc_exvec
BIOSCODE:0128		      dw offset	bc_exvec
BIOSCODE:012A		      dw offset	bc_exvec
BIOSCODE:012C		      dw offset	bc_exvec
BIOSCODE:012E		      dw offset	prn_ioctl_query
BIOSCODE:0130 aux_table	      db 11		      ;	((aux_table_end	- aux_table)-1)/2 = 11
BIOSCODE:0131		      dw offset	bc_exvec
BIOSCODE:0133		      dw offset	bc_exvec
BIOSCODE:0135		      dw offset	bc_exvec
BIOSCODE:0137		      dw offset	bc_cmderr
BIOSCODE:0139		      dw offset	aux_read
BIOSCODE:013B		      dw offset	aux_rdnd
BIOSCODE:013D		      dw offset	bc_exvec
BIOSCODE:013F		      dw offset	aux_flsh
BIOSCODE:0141		      dw offset	aux_writ
BIOSCODE:0143		      dw offset	aux_writ
BIOSCODE:0145		      dw offset	aux_wrst
BIOSCODE:0147 tim_table	      db 10		      ;	((tim_table_end	- tim_table)-1)/2 = 10
BIOSCODE:0148		      dw offset	bc_exvec
BIOSCODE:014A		      dw offset	bc_exvec
BIOSCODE:014C		      dw offset	bc_exvec
BIOSCODE:014E		      dw offset	bc_cmderr
BIOSCODE:0150		      dw offset	tim_read
BIOSCODE:0152		      dw offset	z_bus_exit
BIOSCODE:0154		      dw offset	bc_exvec
BIOSCODE:0156		      dw offset	bc_exvec
BIOSCODE:0158		      dw offset	tim_writ
BIOSCODE:015A		      dw offset	tim_writ
BIOSCODE:015C
BIOSCODE:015C ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:015C
BIOSCODE:015C
BIOSCODE:015C con_read	      proc near		      ;	...
BIOSCODE:015C		      jcxz    short con_exit  ;	read cx	bytes from keyboard into buffer
BIOSCODE:015E
BIOSCODE:015E con_loop:				      ;	...
BIOSCODE:015E		      call    chrin	      ;	get char in al
BIOSCODE:0161		      stosb		      ;	store char at es:di
BIOSCODE:0162		      loop    con_loop
BIOSCODE:0164
BIOSCODE:0164 con_exit:				      ;	...
BIOSCODE:0164		      clc
BIOSCODE:0165		      retn
BIOSCODE:0165 con_read	      endp
BIOSCODE:0165
BIOSCODE:0166
BIOSCODE:0166 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0166
BIOSCODE:0166
BIOSCODE:0166 chrin	      proc near		      ;	...
BIOSCODE:0166		      mov     ah, ds:keyrd_func	; set by msinit. 0 or 10h
BIOSCODE:016A		      xor     al, al
BIOSCODE:016C		      xchg    al, ds:altah    ;	get character &	zero altah
BIOSCODE:0170		      or      al, al
BIOSCODE:0172		      jnz     short keyret
BIOSCODE:0174		      int     16h	      ;	KEYBOARD -
BIOSCODE:0176
BIOSCODE:0176 alt10:
BIOSCODE:0176		      or      ax, ax
BIOSCODE:0178		      jz      short chrin
BIOSCODE:017A		      cmp     ax, 7200h	      ;	check for ctrl-prtsc
BIOSCODE:017D		      jnz     short alt_ext_chk
BIOSCODE:017F		      mov     al, 10h
BIOSCODE:0181		      jmp     short keyret
BIOSCODE:0183 ;	---------------------------------------------------------------------------
BIOSCODE:0183
BIOSCODE:0183 alt_ext_chk:			      ;	...
BIOSCODE:0183		      cmp     ds:keyrd_func, 0
BIOSCODE:0188		      jz      short not_ext
BIOSCODE:018A		      cmp     al, 0E0h
BIOSCODE:018C		      jnz     short not_ext
BIOSCODE:018E		      or      ah, ah
BIOSCODE:0190		      jz      short keyret
BIOSCODE:0192		      xor     al, al
BIOSCODE:0194		      jmp     short alt_save
BIOSCODE:0196 ;	---------------------------------------------------------------------------
BIOSCODE:0196
BIOSCODE:0196 not_ext:				      ;	...
BIOSCODE:0196		      or      al, al	      ;	special	case?
BIOSCODE:0198		      jnz     short keyret
BIOSCODE:019A
BIOSCODE:019A alt_save:				      ;	...
BIOSCODE:019A		      mov     ds:altah,	ah    ;	store special key
BIOSCODE:019E
BIOSCODE:019E keyret:				      ;	...
BIOSCODE:019E		      retn
BIOSCODE:019E chrin	      endp
BIOSCODE:019E
BIOSCODE:019F
BIOSCODE:019F ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:019F
BIOSCODE:019F
BIOSCODE:019F con_rdnd	      proc near		      ;	...
BIOSCODE:019F		      mov     al, ds:altah    ;	keyboard non destructive read, no wait
BIOSCODE:01A2		      or      al, al
BIOSCODE:01A4		      jnz     short rdexit
BIOSCODE:01A6		      mov     ah, ds:keysts_func
BIOSCODE:01AA		      int     16h	      ;	KEYBOARD -
BIOSCODE:01AC		      jnz     short gotchr
BIOSCODE:01AE		      cmp     ds:fhavek09, 0
BIOSCODE:01B3		      jz      short z_bus_exit
BIOSCODE:01B5		      les     bx, ds:ptrsav
BIOSCODE:01B9		      test    word ptr es:[bx+3], 400h ; [es:bx+status]
BIOSCODE:01BF		      jz      short z_bus_exit
BIOSCODE:01C1		      mov     ax, 4100h
BIOSCODE:01C4		      xor     bl, bl
BIOSCODE:01C6		      int     15h	      ;	SYSTEM - WAIT ON EXTERNAL EVENT	(CONVERTIBLE)
BIOSCODE:01C6					      ;	AL = condition type, BH	= condition compare or mask value
BIOSCODE:01C6					      ;	BL = timeout value times 55 milliseconds, 00h means no timeout
BIOSCODE:01C6					      ;	DX = I/O port address if AL bit	4 set
BIOSCODE:01C8
BIOSCODE:01C8 z_bus_exit:			      ;	...
BIOSCODE:01C8		      stc
BIOSCODE:01C9		      mov     ah, 3	      ;	indicate busy status
BIOSCODE:01CB		      retn
BIOSCODE:01CC ;	---------------------------------------------------------------------------
BIOSCODE:01CC
BIOSCODE:01CC gotchr:				      ;	...
BIOSCODE:01CC		      or      ax, ax
BIOSCODE:01CE		      jnz     short notbrk    ;	check for null after break
BIOSCODE:01D0		      mov     ah, ds:keyrd_func	; issue	keyboard read function
BIOSCODE:01D4		      int     16h	      ;	KEYBOARD -
BIOSCODE:01D6		      jmp     short con_rdnd  ;	get a real status
BIOSCODE:01D8 ;	---------------------------------------------------------------------------
BIOSCODE:01D8
BIOSCODE:01D8 notbrk:				      ;	...
BIOSCODE:01D8		      cmp     ax, 7200h	      ;	check for ctrl-prtsc
BIOSCODE:01DB		      jnz     short rd_ext_chk
BIOSCODE:01DD		      mov     al, 10h	      ;	('P' & 1Fh) ; return control p
BIOSCODE:01DF		      jmp     short rdexit
BIOSCODE:01E1 ;	---------------------------------------------------------------------------
BIOSCODE:01E1
BIOSCODE:01E1 rd_ext_chk:			      ;	...
BIOSCODE:01E1		      cmp     ds:keyrd_func, 0 ; extended keyboard function?
BIOSCODE:01E6		      jz      short rdexit
BIOSCODE:01E8		      cmp     al, 0E0h	      ;	extended key value or greek alpha?
BIOSCODE:01EA		      jnz     short rdexit
BIOSCODE:01EC		      cmp     ah, 0	      ;	scan code exist?
BIOSCODE:01EF		      jz      short rdexit    ;	yes. greek alpha char.
BIOSCODE:01F1		      mov     al, 0	      ;	no. extended key stroke.
BIOSCODE:01F1					      ;	change it for compatibility
BIOSCODE:01F3
BIOSCODE:01F3 rdexit:				      ;	...
BIOSCODE:01F3		      les     bx, ds:ptrsav
BIOSCODE:01F7		      mov     es:[bx+13], al  ;	[es:bx+media]
BIOSCODE:01F7					      ;	 return	keyboard character here
BIOSCODE:01FB
BIOSCODE:01FB bc_exvec:				      ;	...
BIOSCODE:01FB		      clc		      ;	indicate normal	termination
BIOSCODE:01FC		      retn
BIOSCODE:01FC con_rdnd	      endp
BIOSCODE:01FC
BIOSCODE:01FD
BIOSCODE:01FD ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:01FD
BIOSCODE:01FD
BIOSCODE:01FD con_writ	      proc near		      ;	...
BIOSCODE:01FD		      jcxz    short bc_exvec  ;	console	write routine
BIOSCODE:01FF
BIOSCODE:01FF con_lp:				      ;	...
BIOSCODE:01FF		      mov     al, es:[di]
BIOSCODE:0202		      inc     di
BIOSCODE:0203		      int     29h	      ;	DOS 2+ internal	- FAST PUTCHAR
BIOSCODE:0203					      ;	AL = character to display
BIOSCODE:0205		      loop    con_lp
BIOSCODE:0205 con_writ	      endp
BIOSCODE:0205
BIOSCODE:0207 ;	START OF FUNCTION CHUNK	FOR con_flush
BIOSCODE:0207
BIOSCODE:0207 cc_ret:				      ;	...
BIOSCODE:0207		      clc
BIOSCODE:0208		      retn
BIOSCODE:0208 ;	END OF FUNCTION	CHUNK FOR con_flush
BIOSCODE:0209
BIOSCODE:0209 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0209
BIOSCODE:0209
BIOSCODE:0209 con_flush	      proc near		      ;	...
BIOSCODE:0209
BIOSCODE:0209 ;	FUNCTION CHUNK AT BIOSCODE:0207	SIZE 00000002 BYTES
BIOSCODE:0209
BIOSCODE:0209		      mov     ds:altah,	0     ;	flush out keyboard queue
BIOSCODE:0209					      ;	clear out holding buffer
BIOSCODE:020E
BIOSCODE:020E flloop:				      ;	...
BIOSCODE:020E		      mov     ah, 1	      ;	while (charavail()) charread();
BIOSCODE:0210		      int     16h	      ;	KEYBOARD - CHECK BUFFER, DO NOT	CLEAR
BIOSCODE:0210					      ;	Return:	ZF clear if character in buffer
BIOSCODE:0210					      ;	AH = scan code,	AL = character
BIOSCODE:0210					      ;	ZF set if no character in buffer
BIOSCODE:0212		      jz      short cc_ret
BIOSCODE:0214		      xor     ah, ah
BIOSCODE:0216		      int     16h	      ;	KEYBOARD - READ	CHAR FROM BUFFER, WAIT IF EMPTY
BIOSCODE:0216					      ;	Return:	AH = scan code,	AL = character
BIOSCODE:0218		      jmp     short flloop
BIOSCODE:0218 con_flush	      endp
BIOSCODE:0218
BIOSCODE:021A ;	---------------------------------------------------------------------------
BIOSCODE:021A
BIOSCODE:021A prn_input:			      ;	...
BIOSCODE:021A		      call    bc_err_cnt      ;	reset count to zero
BIOSCODE:021A					      ;	(sub reqpkt.count,cx)
BIOSCODE:021D		      clc		      ;	but return with	carry	reset for no error
BIOSCODE:021E		      retn
BIOSCODE:021F ;	---------------------------------------------------------------------------
BIOSCODE:021F
BIOSCODE:021F prn_writ:				      ;	...
BIOSCODE:021F		      jcxz    short prn_done  ;	write cx bytes from es:di to printer device
BIOSCODE:0221
BIOSCODE:0221 prn_loop:				      ;	...
BIOSCODE:0221		      mov     bx, 2	      ;	retry count
BIOSCODE:0224
BIOSCODE:0224 prn_out:				      ;	...
BIOSCODE:0224		      call    prnstat	      ;	get status
BIOSCODE:0227		      jnz     short TestPrnError
BIOSCODE:0229		      mov     al, es:[di]     ;	get character to print
BIOSCODE:022C		      xor     ah, ah
BIOSCODE:022E		      call    prnop	      ;	print to printer
BIOSCODE:0231		      jz      short prn_con   ;	no error - continue
BIOSCODE:0233		      cmp     ah, 0FFh	      ;	MODE_CTRLBRK
BIOSCODE:0236		      jnz     short _prnwf
BIOSCODE:0238		      mov     al, 0Ch	      ;	error_I24_gen_failure
BIOSCODE:023A		      mov     ds:altah,	0
BIOSCODE:023F		      jmp     short pmessg
BIOSCODE:0241 ;	---------------------------------------------------------------------------
BIOSCODE:0241
BIOSCODE:0241 _prnwf:				      ;	...
BIOSCODE:0241		      test    ah, 1	      ;	timeoutstatus
BIOSCODE:0244		      jz      short prn_con
BIOSCODE:0246
BIOSCODE:0246 TestPrnError:			      ;	...
BIOSCODE:0246		      dec     bx	      ;	retry until count is exhausted
BIOSCODE:0247		      jnz     short prn_out
BIOSCODE:0249
BIOSCODE:0249 pmessg:				      ;	...
BIOSCODE:0249		      jmp     bc_err_cnt
BIOSCODE:024C ;	---------------------------------------------------------------------------
BIOSCODE:024C
BIOSCODE:024C prn_con:				      ;	...
BIOSCODE:024C		      inc     di	      ;	point to next char and continue
BIOSCODE:024D		      loop    prn_loop
BIOSCODE:024F
BIOSCODE:024F prn_done:				      ;	...
BIOSCODE:024F		      clc
BIOSCODE:0250		      retn
BIOSCODE:0251 ;	---------------------------------------------------------------------------
BIOSCODE:0251
BIOSCODE:0251 prn_stat:				      ;	...
BIOSCODE:0251		      call    prnstat	      ;	device in dx
BIOSCODE:0254		      jnz     short pmessg
BIOSCODE:0256		      test    ah, 80h	      ;	notbusystatus
BIOSCODE:0259		      jnz     short prn_done
BIOSCODE:025B		      jmp     z_bus_exit
BIOSCODE:025E
BIOSCODE:025E ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:025E
BIOSCODE:025E
BIOSCODE:025E prnstat	      proc near		      ;	...
BIOSCODE:025E		      mov     ah, 2	      ;	PRINTER	- GET STATUS
BIOSCODE:025E prnstat	      endp		      ;	set command for	get status
BIOSCODE:025E					      ;	DX = printer port (0-3)
BIOSCODE:025E					      ;	Return:	AH = status
BIOSCODE:0260
BIOSCODE:0260 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0260
BIOSCODE:0260
BIOSCODE:0260 prnop	      proc near		      ;	...
BIOSCODE:0260		      mov     dx, ds:auxnum   ;	get printer number
BIOSCODE:0264		      int     17h	      ;	PRINTER	- GET STATUS
BIOSCODE:0264					      ;	DX = printer port (0-3)
BIOSCODE:0264					      ;	Return:	AH = status
BIOSCODE:0266		      push    ax
BIOSCODE:0267		      and     ah, 30h
BIOSCODE:026A		      cmp     ah, 30h	      ;	noprinter error
BIOSCODE:026D		      pop     ax
BIOSCODE:026E		      jnz     short NextTest
BIOSCODE:0270		      and     ah, 0DFh	      ;	~nopaperstatus
BIOSCODE:0273		      or      ah, 8	      ;	ioerrstatus
BIOSCODE:0276
BIOSCODE:0276 NextTest:				      ;	...
BIOSCODE:0276		      test    ah, 28h	      ;	(ioerrstatus+nopaperstatus)
BIOSCODE:0276					      ;	i/o error?
BIOSCODE:0279		      jz      short checknotready ; no,	try not	ready
BIOSCODE:027B		      mov     al, 9	      ;	error_I24_out_of_paper
BIOSCODE:027B					      ;	first, assume out of paper
BIOSCODE:027D		      test    ah, 20h	      ;	out of paper set?
BIOSCODE:0280		      jnz     short ret1      ;	yes, error is set
BIOSCODE:0282		      inc     al	      ;	return al=10 (i/o error)
BIOSCODE:0284
BIOSCODE:0284 ret1:				      ;	...
BIOSCODE:0284		      retn
BIOSCODE:0285 ;	---------------------------------------------------------------------------
BIOSCODE:0285
BIOSCODE:0285 checknotready:			      ;	...
BIOSCODE:0285		      mov     al, 2	      ;	assume not-ready
BIOSCODE:0287		      test    ah, 1
BIOSCODE:028A		      retn
BIOSCODE:028A prnop	      endp
BIOSCODE:028A
BIOSCODE:028B ;	---------------------------------------------------------------------------
BIOSCODE:028B
BIOSCODE:028B prn_tilbusy:			      ;	...
BIOSCODE:028B		      mov     si, di
BIOSCODE:028D
BIOSCODE:028D prn_tilbloop:			      ;	...
BIOSCODE:028D		      push    cx
BIOSCODE:028E		      push    bx
BIOSCODE:028F		      xor     bh, bh
BIOSCODE:0291		      mov     bl, ds:printdev
BIOSCODE:0295		      shl     bx, 1
BIOSCODE:0297		      mov     cx, ds:wait_count[bx] ; wait count times to come ready
BIOSCODE:029B		      pop     bx
BIOSCODE:029C
BIOSCODE:029C prn_getstat:			      ;	...
BIOSCODE:029C		      call    prnstat	      ;	get status
BIOSCODE:029F		      jnz     short prn_bperr ;	error
BIOSCODE:02A1		      test    ah, 80h	      ;	ready yet?
BIOSCODE:02A4		      loope   prn_getstat     ;	no, go for more
BIOSCODE:02A6		      pop     cx	      ;	get original count
BIOSCODE:02A7		      jz      short prn_berr  ;	still not ready	=> done
BIOSCODE:02A9		      lods    byte ptr es:[si]
BIOSCODE:02AB		      xor     ah, ah
BIOSCODE:02AD		      call    prnop
BIOSCODE:02B0		      jnz     short prn_berr
BIOSCODE:02B2		      loop    prn_tilbloop
BIOSCODE:02B4		      clc		      ;	normal no-error	return
BIOSCODE:02B5		      retn
BIOSCODE:02B6 ;	---------------------------------------------------------------------------
BIOSCODE:02B6
BIOSCODE:02B6 prn_bperr:			      ;	...
BIOSCODE:02B6		      pop     cx
BIOSCODE:02B7
BIOSCODE:02B7 prn_berr:				      ;	...
BIOSCODE:02B7		      jmp     bc_err_cnt
BIOSCODE:02BA ;	---------------------------------------------------------------------------
BIOSCODE:02BA
BIOSCODE:02BA prn_genioctl:			      ;	...
BIOSCODE:02BA		      les     di, ds:ptrsav
BIOSCODE:02BE		      cmp     byte ptr es:[di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
BIOSCODE:02BE					      ;	ioc_pc
BIOSCODE:02C3		      jz      short prnfunc_ok
BIOSCODE:02C5
BIOSCODE:02C5 prnfuncerr:			      ;	...
BIOSCODE:02C5		      jmp     bc_cmderr
BIOSCODE:02C8 ;	---------------------------------------------------------------------------
BIOSCODE:02C8
BIOSCODE:02C8 prnfunc_ok:			      ;	...
BIOSCODE:02C8		      mov     al, es:[di+14]  ;	[es:di+IOCTL_REQ.MINORFUNCTION]
BIOSCODE:02CC		      les     di, es:[di+19]  ;	[es:di+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:02D0		      xor     bh, bh
BIOSCODE:02D2		      mov     bl, ds:printdev
BIOSCODE:02D6		      shl     bx, 1
BIOSCODE:02D8		      mov     cx, ds:wait_count[bx] ; pull out retry count for device
BIOSCODE:02DC		      cmp     al, 65h	      ;	get_retry_count
BIOSCODE:02DE		      jz      short prngetcount
BIOSCODE:02E0		      cmp     al, 45h	      ;	set_retry_count
BIOSCODE:02E2		      jnz     short prnfuncerr
BIOSCODE:02E4		      mov     cx, es:[di]
BIOSCODE:02E7
BIOSCODE:02E7 prngetcount:			      ;	...
BIOSCODE:02E7		      mov     ds:wait_count[bx], cx
BIOSCODE:02EB		      mov     es:[di], cx     ;	[es:di+A_RETRYCOUNT.RC_COUNT]
BIOSCODE:02EB					      ;	return current retry count
BIOSCODE:02EE		      clc
BIOSCODE:02EF		      retn
BIOSCODE:02F0 ;	---------------------------------------------------------------------------
BIOSCODE:02F0
BIOSCODE:02F0 prn_ioctl_query:			      ;	...
BIOSCODE:02F0		      les     di, ds:ptrsav
BIOSCODE:02F4		      cmp     byte ptr es:[di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
BIOSCODE:02F4					      ;	ioc_pc
BIOSCODE:02F9		      jnz     short prn_query_err
BIOSCODE:02FB		      mov     al, es:[di+14]  ;	[es:di+IOCTL_REQ.MINORFUNCTION]
BIOSCODE:02FF		      cmp     al, 65h	      ;	GET_RETRY_COUNT
BIOSCODE:0301		      jz      short IOCtlSupported
BIOSCODE:0303		      cmp     al, 45h	      ;	SET_RETRY_COUNT
BIOSCODE:0305		      jnz     short prn_query_err
BIOSCODE:0307
BIOSCODE:0307 IOCtlSupported:			      ;	...
BIOSCODE:0307		      clc
BIOSCODE:0308		      retn
BIOSCODE:0309 ;	---------------------------------------------------------------------------
BIOSCODE:0309
BIOSCODE:0309 prn_query_err:			      ;	...
BIOSCODE:0309		      stc
BIOSCODE:030A		      jmp     bc_cmderr
BIOSCODE:030D ;	---------------------------------------------------------------------------
BIOSCODE:030D
BIOSCODE:030D aux_read:				      ;	...
BIOSCODE:030D		      jcxz    short exvec2
BIOSCODE:030F		      call    getbx	      ;	put address of auxbuf in bx
BIOSCODE:0312		      xor     al, al
BIOSCODE:0314		      xchg    al, [bx]
BIOSCODE:0316		      or      al, al
BIOSCODE:0318		      jnz     short aux2
BIOSCODE:031A
BIOSCODE:031A aux1:				      ;	...
BIOSCODE:031A		      call    auxin	      ;	get character from port
BIOSCODE:031A					      ;	won't return if error
BIOSCODE:031D
BIOSCODE:031D aux2:				      ;	...
BIOSCODE:031D		      stosb
BIOSCODE:031E		      loop    aux1	      ;	if more	characters, go around again
BIOSCODE:0320
BIOSCODE:0320 exvec2:				      ;	...
BIOSCODE:0320		      clc		      ;	all done, successful exit
BIOSCODE:0321		      retn
BIOSCODE:0322
BIOSCODE:0322 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0322
BIOSCODE:0322
BIOSCODE:0322 auxin	      proc near		      ;	...
BIOSCODE:0322		      mov     ah, 2
BIOSCODE:0324		      call    auxop
BIOSCODE:0327		      test    ah, 0Eh	      ;	flag_frame|flag_parity|flag_overrun
BIOSCODE:032A		      jnz     short arbad
BIOSCODE:032C		      retn
BIOSCODE:032D ;	---------------------------------------------------------------------------
BIOSCODE:032D
BIOSCODE:032D arbad:				      ;	...
BIOSCODE:032D		      pop     ax
BIOSCODE:032E		      xor     al, al
BIOSCODE:0330		      or      al, 0B0h	      ;	flag_rec_sig|flag_dsr|flag_cts
BIOSCODE:0332		      jmp     bc_err_cnt
BIOSCODE:0332 auxin	      endp
BIOSCODE:0332
BIOSCODE:0335 ;	---------------------------------------------------------------------------
BIOSCODE:0335
BIOSCODE:0335 aux_rdnd:				      ;	...
BIOSCODE:0335		      call    getbx	      ;	non-destructive	aux port read
BIOSCODE:0338		      mov     al, [bx]
BIOSCODE:033A		      or      al, al
BIOSCODE:033C		      jnz     short auxrdx    ;	if al is non-zero (char	in buffer)
BIOSCODE:033C					      ;	then return character
BIOSCODE:033E		      call    auxstat	      ;	if not,	get status of	aux device
BIOSCODE:0341		      test    ah, 1	      ;	flag_data_ready	- test data ready
BIOSCODE:0344		      jz      short auxbus    ;	then device is busy (not ready)
BIOSCODE:0346		      test    al, 20h	      ;	flag_dsr - test	data set ready
BIOSCODE:0348		      jz      short auxbus    ;	then device is busy (not ready)
BIOSCODE:034A		      call    auxin	      ;	else aux is ready, get character
BIOSCODE:034D		      mov     [bx], al
BIOSCODE:034F
BIOSCODE:034F auxrdx:				      ;	...
BIOSCODE:034F		      jmp     rdexit	      ;	return busy status
BIOSCODE:0352 ;	---------------------------------------------------------------------------
BIOSCODE:0352
BIOSCODE:0352 auxbus:				      ;	...
BIOSCODE:0352		      jmp     z_bus_exit
BIOSCODE:0355 ;	---------------------------------------------------------------------------
BIOSCODE:0355
BIOSCODE:0355 aux_wrst:				      ;	...
BIOSCODE:0355		      call    auxstat	      ;	return aux port	write status
BIOSCODE:0358		      test    al, 20h	      ;	test data set ready
BIOSCODE:035A		      jz      short auxbus    ;	then device is busy (not ready)
BIOSCODE:035C		      test    ah, 20h	      ;	flag_tranhol_emp - test	transmit hold reg
BIOSCODE:035F		      jz      short auxbus    ;	then device is busy (not ready)
BIOSCODE:0361		      clc
BIOSCODE:0362		      retn
BIOSCODE:0363
BIOSCODE:0363 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0363
BIOSCODE:0363
BIOSCODE:0363 auxstat	      proc near		      ;	...
BIOSCODE:0363		      mov     ah, 3	      ;	auxfunc_status
BIOSCODE:0363 auxstat	      endp
BIOSCODE:0363
BIOSCODE:0365
BIOSCODE:0365 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0365
BIOSCODE:0365
BIOSCODE:0365 auxop	      proc near		      ;	...
BIOSCODE:0365		      mov     dx, ds:auxnum   ;	ah=function code
BIOSCODE:0365					      ;	0=init,	1=send,	2=receive, 3=status
BIOSCODE:0365					      ;	get port number
BIOSCODE:0369		      int     14h	      ;	SERIAL I/O - GET USART STATUS
BIOSCODE:0369					      ;	DX = port number (0-3)
BIOSCODE:0369					      ;	Return:	AX = port status code
BIOSCODE:036B		      retn
BIOSCODE:036B auxop	      endp
BIOSCODE:036B
BIOSCODE:036C ;	---------------------------------------------------------------------------
BIOSCODE:036C
BIOSCODE:036C aux_flsh:				      ;	...
BIOSCODE:036C		      call    getbx	      ;	flush aux input	buffer
BIOSCODE:036C					      ;	get bx to point	to auxbuf
BIOSCODE:036C					      ;	zero out buffer
BIOSCODE:036C					      ;	all done, successful return
BIOSCODE:036F		      mov     byte ptr [bx], 0
BIOSCODE:0372		      clc
BIOSCODE:0373		      retn
BIOSCODE:0374 ;	---------------------------------------------------------------------------
BIOSCODE:0374
BIOSCODE:0374 aux_writ:				      ;	...
BIOSCODE:0374		      jcxz    short exvec2    ;	write to aux device (if	cx > 0)
BIOSCODE:0376
BIOSCODE:0376 aux_loop:				      ;	...
BIOSCODE:0376		      mov     al, es:[di]     ;	get character to be written
BIOSCODE:0379		      inc     di	      ;	move di	pointer	to next	character
BIOSCODE:037A		      mov     ah, 1	      ;	auxfunc_send - indicates a write
BIOSCODE:037C		      call    auxop	      ;	send character over aux	port
BIOSCODE:037F		      test    ah, 80h	      ;	check for error
BIOSCODE:0382		      jz      short awok      ;	then no	error
BIOSCODE:0384		      mov     al, 10	      ;	else indicate write fault
BIOSCODE:0386		      jmp     bc_err_cnt      ;	call error routines
BIOSCODE:0389 ;	---------------------------------------------------------------------------
BIOSCODE:0389
BIOSCODE:0389 awok:				      ;	...
BIOSCODE:0389		      loop    aux_loop	      ;	return bx -> single byte input buffer
BIOSCODE:0389					      ;	for selected aux port ([auxnum])
BIOSCODE:038B		      clc
BIOSCODE:038C		      retn
BIOSCODE:038D
BIOSCODE:038D ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:038D
BIOSCODE:038D
BIOSCODE:038D getbx	      proc near		      ;	...
BIOSCODE:038D		      mov     bx, ds:auxnum
BIOSCODE:0391		      add     bx, offset auxbuf
BIOSCODE:0395		      retn
BIOSCODE:0395 getbx	      endp
BIOSCODE:0395
BIOSCODE:0396 ;	---------------------------------------------------------------------------
BIOSCODE:0396
BIOSCODE:0396 time_to_ticks:			      ;	...
BIOSCODE:0396		      mov     al, 60	      ;	convert	time to	ticks
BIOSCODE:0396					      ;	input :	time in	cx and dx
BIOSCODE:0396					      ;	output:	ticks returned in cx:dx
BIOSCODE:0396					      ;
BIOSCODE:0396					      ;	the clock ticks	at the rate of:
BIOSCODE:0396					      ;	1193180/65536 ticks/second
BIOSCODE:0396					      ;	(about 18.2 ticks per second)
BIOSCODE:0398		      mul     ch	      ;	hours to minutes ///
BIOSCODE:0398					      ;	first convert from hour,min,sec,hund. to
BIOSCODE:0398					      ;	total number of	100th of seconds
BIOSCODE:039A		      mov     ch, 0
BIOSCODE:039C		      add     ax, cx	      ;	total minutes
BIOSCODE:039E		      mov     cx, 6000	      ;	60*100
BIOSCODE:03A1		      mov     bx, dx
BIOSCODE:03A3		      mul     cx	      ;	convert	to 1/100 sec
BIOSCODE:03A5		      mov     cx, ax
BIOSCODE:03A7		      mov     al, 100
BIOSCODE:03A9		      mul     bh	      ;	convert	seconds	to 1/100 sec
BIOSCODE:03AB		      add     cx, ax	      ;	combine	seconds	with hours and min
BIOSCODE:03AD		      adc     dx, 0
BIOSCODE:03B0		      mov     bh, 0
BIOSCODE:03B2		      add     cx, bx	      ;	combine	1/100 sec
BIOSCODE:03B4		      adc     dx, 0	      ;	dx:cx is time in 1/100 sec
BIOSCODE:03B7		      xchg    ax, dx
BIOSCODE:03B8		      xchg    ax, cx	      ;	now time is in cx:ax
BIOSCODE:03B9		      mov     bx, 59659
BIOSCODE:03BC		      mul     bx	      ;	multiply low half
BIOSCODE:03BE		      xchg    dx, cx
BIOSCODE:03C0		      xchg    ax, dx	      ;	cx->ax,	ax->dx,	dx->cx
BIOSCODE:03C1		      mul     bx	      ;	multiply high half
BIOSCODE:03C3		      add     ax, cx	      ;	combine	overlapping products
BIOSCODE:03C5		      adc     dx, 0
BIOSCODE:03C8		      xchg    ax, dx	      ;	ax:dx=time*59659
BIOSCODE:03C9		      mov     bx, 5
BIOSCODE:03CC		      div     bl	      ;	divide high half by 5
BIOSCODE:03CE		      mov     cl, al
BIOSCODE:03D0		      mov     ch, 0
BIOSCODE:03D2		      mov     al, ah	      ;	remainder of divide-by-5
BIOSCODE:03D4		      cbw
BIOSCODE:03D5		      xchg    ax, dx	      ;	use it to extend low half
BIOSCODE:03D6		      div     bx	      ;	divide low half	by 5
BIOSCODE:03D8		      mov     dx, ax	      ;	cx:dx is now number of ticks in	time
BIOSCODE:03DA		      retf
BIOSCODE:03DB ;	---------------------------------------------------------------------------
BIOSCODE:03DB
BIOSCODE:03DB tim_writ:				      ;	...
BIOSCODE:03DB		      mov     ax, es:[di]     ;	sets the current time
BIOSCODE:03DE		      push    ax	      ;	daycnt.	we need	to set this at the very
BIOSCODE:03DE					      ;	end to avoid tick windows
BIOSCODE:03DF		      cmp     ds:havecmoscloc, 0
BIOSCODE:03E4		      jz      short no_cmos_1
BIOSCODE:03E6		      mov     al, es:[di+3]   ;	get binary hours
BIOSCODE:03E6					      ;	convert	to bcd
BIOSCODE:03EA		      call    dword ptr	ds:bintobcd
BIOSCODE:03EE		      mov     ch, al	      ;	ch = bcd hours
BIOSCODE:03F0		      mov     al, es:[di+2]   ;	get binary minutes
BIOSCODE:03F4		      call    dword ptr	ds:bintobcd
BIOSCODE:03F8		      mov     cl, al	      ;	cl = bcd minutes
BIOSCODE:03FA		      mov     al, es:[di+5]   ;	get binary seconds
BIOSCODE:03FE		      call    dword ptr	ds:bintobcd
BIOSCODE:0402		      mov     dh, al	      ;	dh = bcd seconds
BIOSCODE:0404		      mov     dl, 0	      ;	dl = 0 (st) or 1 (dst)
BIOSCODE:0406		      cli
BIOSCODE:0407		      mov     ah, 3
BIOSCODE:0409		      int     1Ah	      ;	CLOCK -	SET REAL TIME CLOCK (AT,XT286,CONV,PS)
BIOSCODE:0409					      ;	CH = hours in BCD, CL =	minutes	in BCD
BIOSCODE:0409					      ;	 DH = seconds in BCD,DL	= 01h if daylight savings, 00h if standard time
BIOSCODE:0409					      ;	Return:	CMOS clock set
BIOSCODE:040B		      sti
BIOSCODE:040C
BIOSCODE:040C no_cmos_1:			      ;	...
BIOSCODE:040C		      mov     cx, es:[di+2]
BIOSCODE:0410		      mov     dx, es:[di+4]
BIOSCODE:0414		      call    dword ptr	ds:ttticks ; convert time to ticks
BIOSCODE:0414					      ;	cx:dx now has time in ticks
BIOSCODE:0418		      cli
BIOSCODE:0419		      mov     ah, 1
BIOSCODE:041B		      int     1Ah	      ;	CLOCK -	SET TIME OF DAY
BIOSCODE:041B					      ;	CX:DX =	clock count
BIOSCODE:041B					      ;	Return:	time of	day set
BIOSCODE:041D		      pop     ds:daycnt
BIOSCODE:0421		      sti
BIOSCODE:0422		      cmp     ds:havecmoscloc, 0
BIOSCODE:0427		      jz      short no_cmos_2
BIOSCODE:0429		      call    dword ptr	ds:daycnttoday
BIOSCODE:042D		      cli
BIOSCODE:042E		      mov     ah, 5
BIOSCODE:0430		      int     1Ah	      ;	CLOCK -	SET DATE IN REAL TIME CLOCK (AT,XT286,CONV,PS)
BIOSCODE:0430					      ;	DL = day in BCD, DH = month in BCD, CL = year in BCD
BIOSCODE:0430					      ;	CH = century (19h or 20h)
BIOSCODE:0430					      ;	Return:	CMOS clock set
BIOSCODE:0432		      sti
BIOSCODE:0433
BIOSCODE:0433 no_cmos_2:			      ;	...
BIOSCODE:0433		      clc
BIOSCODE:0434		      retn
BIOSCODE:0435 ;	---------------------------------------------------------------------------
BIOSCODE:0435
BIOSCODE:0435 tim_read:				      ;	...
BIOSCODE:0435		      call    GetTickCnt      ;	gettime	reads date and time
BIOSCODE:0435					      ;
BIOSCODE:0435					      ;	65,536 seconds = 1,193,180 ticks
BIOSCODE:0435					      ;
BIOSCODE:0435					      ;	time in	100th of seconds
BIOSCODE:0435					      ;	   = ticks from	clock  * 65,536	* 100 /	1,193,180
BIOSCODE:0435					      ;	   = ticks from	clock *	5 * 65,536 / 59,659
BIOSCODE:0438		      mov     si, ds:daycnt
BIOSCODE:043C		      mov     ax, cx
BIOSCODE:043E		      mov     bx, dx	      ;	start with ticks in cx:dx
BIOSCODE:043E					      ;	multiply by 5
BIOSCODE:0440		      shl     dx, 1
BIOSCODE:0442		      rcl     cx, 1
BIOSCODE:0444		      shl     dx, 1
BIOSCODE:0446		      rcl     cx, 1
BIOSCODE:0448		      add     dx, bx
BIOSCODE:044A		      adc     ax, cx
BIOSCODE:044C		      xchg    ax, dx
BIOSCODE:044D		      mov     cx, 59659	      ;	multiply by 65536 and divide by	59659
BIOSCODE:0450		      div     cx	      ;	dx has remainder
BIOSCODE:0450					      ;	ax has high word of final quotient
BIOSCODE:0452		      mov     bx, ax	      ;	put high word in safe place
BIOSCODE:0454		      xor     ax, ax	      ;	multiply by 65536
BIOSCODE:0456		      div     cx	      ;	bx:ax has time in 100th	of seconds
BIOSCODE:0458		      mov     dx, bx
BIOSCODE:045A		      mov     cx, 200	      ;	division by 200	is necessary
BIOSCODE:045A					      ;	to ensure no overflow--max result
BIOSCODE:045A					      ;	is number of seconds in	a day/2	= 43200.
BIOSCODE:045D		      div     cx
BIOSCODE:045F		      cmp     dl, 100	      ;	remainder over 100?
BIOSCODE:0462		      jb      short noadj
BIOSCODE:0464		      sub     dl, 100	      ;	keep 1/100's less than 100
BIOSCODE:0467
BIOSCODE:0467 noadj:				      ;	...
BIOSCODE:0467		      cmc		      ;	if we subtracted 100, carry is now set
BIOSCODE:0468		      mov     bl, dl	      ;	save 1/100's
BIOSCODE:046A		      rcl     ax, 1	      ;	multiply by two
BIOSCODE:046C		      mov     dl, 0
BIOSCODE:046E		      rcl     dx, 1
BIOSCODE:0470		      mov     cx, 60	      ;	divide out seconds
BIOSCODE:0473		      div     cx
BIOSCODE:0475		      mov     bh, dl	      ;	save the seconds
BIOSCODE:0477		      div     cl	      ;	break into hours and minutes
BIOSCODE:0479		      xchg    al, ah
BIOSCODE:047B		      push    ax
BIOSCODE:047C		      mov     ax, si
BIOSCODE:047E		      stosw
BIOSCODE:047F		      pop     ax	      ;	al = hours, ah = minutes
BIOSCODE:0480		      stosw
BIOSCODE:0481		      mov     ax, bx
BIOSCODE:0483		      stosw
BIOSCODE:0484		      clc		      ;	[es:di]	= count	of days	since 1-1-80
BIOSCODE:0484					      ;	   [es:di+2] = hours
BIOSCODE:0484					      ;	   [es:di+3] = minutes
BIOSCODE:0484					      ;	   [es:di+4] = seconds
BIOSCODE:0484					      ;	   [es:di+5] = hundredths of seconds
BIOSCODE:0485		      retn
BIOSCODE:0486
BIOSCODE:0486 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0486
BIOSCODE:0486
BIOSCODE:0486 GetTickCnt      proc near		      ;	...
BIOSCODE:0486		      xor     ah, ah	      ;	Returns	the tick count in cx:dx
BIOSCODE:0486					      ;	Takes care of DayCnt in	case of	rollover
BIOSCODE:0486					      ;	if ( rollover )	{
BIOSCODE:0486					      ;	    if ( t_switch )
BIOSCODE:0486					      ;		   daycnt++ ;
BIOSCODE:0486					      ;	    else
BIOSCODE:0486					      ;		   daycnt += rollover ;
BIOSCODE:0486					      ;	    }
BIOSCODE:0488		      int     1Ah	      ;	CLOCK -	GET TIME OF DAY
BIOSCODE:0488					      ;	Return:	CX:DX =	clock count
BIOSCODE:0488					      ;	AL = 00h if clock was read or written (via AH=0,1) since the previous
BIOSCODE:0488					      ;	midnight
BIOSCODE:0488					      ;	Otherwise, AL >	0
BIOSCODE:048A		      cmp     ds:t_switch, 0  ;	use old	method ? (>0 is	yes)
BIOSCODE:048F		      jnz     short inc_case  ;	old method assumes that	Int 1Ah	returns	rollover flag
BIOSCODE:0491		      xor     ah, ah	      ;	new method assumes that	Int 1Ah	returns	roll over count
BIOSCODE:0491					      ;	and not	flag
BIOSCODE:0493		      add     ds:daycnt, ax
BIOSCODE:0497		      retn
BIOSCODE:0498 ;	---------------------------------------------------------------------------
BIOSCODE:0498
BIOSCODE:0498 inc_case:				      ;	...
BIOSCODE:0498		      or      al, al
BIOSCODE:049A		      jz      short no_rollover
BIOSCODE:049C		      inc     ds:daycnt
BIOSCODE:04A0
BIOSCODE:04A0 no_rollover:			      ;	...
BIOSCODE:04A0		      retn
BIOSCODE:04A0 GetTickCnt      endp
BIOSCODE:04A0
BIOSCODE:04A0 ;	---------------------------------------------------------------------------
BIOSCODE:04A1		      db 0
BIOSCODE:04A2 DSKTBL	      db 26		      ;	...
BIOSCODE:04A3		      dw offset	dsk_init
BIOSCODE:04A5		      dw offset	media_chk
BIOSCODE:04A7		      dw offset	get_bpb
BIOSCODE:04A9		      dw offset	bc_cmderr
BIOSCODE:04AB		      dw offset	dsk_read
BIOSCODE:04AD		      dw offset	x_bus_exit
BIOSCODE:04AF		      dw offset	ret_carry_clear
BIOSCODE:04B1		      dw offset	ret_carry_clear
BIOSCODE:04B3		      dw offset	dsk_writ
BIOSCODE:04B5		      dw offset	dsk_writv
BIOSCODE:04B7		      dw offset	ret_carry_clear
BIOSCODE:04B9		      dw offset	ret_carry_clear
BIOSCODE:04BB		      dw offset	bc_cmderr
BIOSCODE:04BD		      dw offset	dsk_open
BIOSCODE:04BF		      dw offset	dsk_close
BIOSCODE:04C1		      dw offset	dsk_rem
BIOSCODE:04C3		      dw offset	ret_carry_clear
BIOSCODE:04C5		      dw offset	ret_carry_clear
BIOSCODE:04C7		      dw offset	ret_carry_clear
BIOSCODE:04C9		      dw offset	Do_Generic_IOCtl
BIOSCODE:04CB		      dw offset	ret_carry_clear
BIOSCODE:04CD		      dw offset	ret_carry_clear
BIOSCODE:04CF		      dw offset	ret_carry_clear
BIOSCODE:04D1		      dw offset	ioctl_getown
BIOSCODE:04D3		      dw offset	ioctl_setown
BIOSCODE:04D5		      dw offset	ioctl_support_query
BIOSCODE:04D7
BIOSCODE:04D7 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:04D7
BIOSCODE:04D7
BIOSCODE:04D7 SetDrive	      proc near		      ;	...
BIOSCODE:04D7		      les     di, dword	ptr ds:start_bds ; Point es:di to first	bds
BIOSCODE:04DB
BIOSCODE:04DB X_Scan_Loop:			      ;	...
BIOSCODE:04DB		      cmp     es:[di+5], al   ;	logical	drive number (BDS.drivelet)
BIOSCODE:04DF		      jz      short X_SetDrv
BIOSCODE:04E1		      les     di, es:[di]     ;	[es:di+BDS.link] ; Go to next bds
BIOSCODE:04E4		      cmp     di, 0FFFFh
BIOSCODE:04E7		      jnz     short X_Scan_Loop
BIOSCODE:04E9		      stc
BIOSCODE:04EA
BIOSCODE:04EA X_SetDrv:				      ;	...
BIOSCODE:04EA		      retn
BIOSCODE:04EA SetDrive	      endp
BIOSCODE:04EA
BIOSCODE:04EB ;	---------------------------------------------------------------------------
BIOSCODE:04EB
BIOSCODE:04EB media_chk:			      ;	...
BIOSCODE:04EB		      call    SetDrive
BIOSCODE:04EE		      mov     si, 1
BIOSCODE:04F1		      test    byte ptr es:[di+24h], 1 ;	[es:di+BDS.flags+1], fchanged_by_format
BIOSCODE:04F6		      jz      short WeAreNotFakingIt
BIOSCODE:04F8		      and     word ptr es:[di+23h], 0FEFFh ; [es:di+BDS.flags],
BIOSCODE:04F8					      ;	~fchanged_by_format ; reset flag
BIOSCODE:04FE		      mov     ds:tim_drv, 0FFh ; -1
BIOSCODE:04FE					      ;	Ensure that we ask the rom if media has	changed
BIOSCODE:0503		      test    byte ptr es:[di+23h], 1
BIOSCODE:0508		      jz      short WeHaveaFloppy
BIOSCODE:050A		      mov     si, 0FFFFh      ;	-1
BIOSCODE:050D		      jmp     short Media_Done
BIOSCODE:050F ;	---------------------------------------------------------------------------
BIOSCODE:050F
BIOSCODE:050F WeAreNotFakingIt:			      ;	...
BIOSCODE:050F		      test    byte ptr es:[di+23h], 1 ;	[es:di+BDS.flags], fnon_removable
BIOSCODE:0514		      jnz     short Media_Done
BIOSCODE:0516
BIOSCODE:0516 WeHaveaFloppy:			      ;	...
BIOSCODE:0516		      xor     si, si	      ;	0 ; Presume "I don't know"
BIOSCODE:0518		      cmp     ds:fhave96, 0   ;	Do we have changeline support?
BIOSCODE:051D		      jz      short mChk_NoChangeLine ;	Brif not
BIOSCODE:051F		      call    MediaCheck      ;	Call into removable routine
BIOSCODE:0522		      jb      short Err_Exitj
BIOSCODE:0524		      call    HasChange
BIOSCODE:0527		      jnz     short Media_Done
BIOSCODE:0529
BIOSCODE:0529 mChk_NoChangeLine:		      ;	...
BIOSCODE:0529		      mov     si, 1	      ;	Presume	no change
BIOSCODE:052C		      mov     al, ds:tim_drv  ;	Last drive accessed
BIOSCODE:052F
BIOSCODE:052F loc_2AEF:				      ;	[es:di+BDS.drivenum]
BIOSCODE:052F		      cmp     al, es:[di+4]   ;	Is drive of last access	the same?
BIOSCODE:0533		      jnz     short Media_Unk ;	No, then "i don't know"
BIOSCODE:0535		      call    Check_Time_Of_Access
BIOSCODE:0538		      jmp     short Media_Done
BIOSCODE:053A ;	---------------------------------------------------------------------------
BIOSCODE:053A
BIOSCODE:053A Media_Unk:			      ;	...
BIOSCODE:053A		      dec     si	      ;	0 ; Return "I don't know"
BIOSCODE:053B
BIOSCODE:053B Media_Done:			      ;	...
BIOSCODE:053B		      push    es
BIOSCODE:053C		      les     bx, ds:ptrsav
BIOSCODE:0540		      mov     es:[bx+14], si  ;	[es:bx+trans]
BIOSCODE:0544		      pop     es
BIOSCODE:0545		      or      si, si
BIOSCODE:0547		      jns     short ret_carry_clear ; volidok
BIOSCODE:0549		      cmp     ds:fhave96, 0
BIOSCODE:054E		      jz      short mChk1_NoChangeLine
BIOSCODE:0550		      call    Media_Set_vId
BIOSCODE:0553
BIOSCODE:0553 mChk1_NoChangeLine:		      ;	...
BIOSCODE:0553		      mov     ds:tim_drv, -1
BIOSCODE:0558
BIOSCODE:0558 ret_carry_clear:			      ;	...
BIOSCODE:0558		      clc		      ;	volidok
BIOSCODE:0559		      retn
BIOSCODE:055A ;	---------------------------------------------------------------------------
BIOSCODE:055A
BIOSCODE:055A Err_Exitj:			      ;	...
BIOSCODE:055A		      call    maperror	      ;	guaranteed to set carry
BIOSCODE:055D ;	START OF FUNCTION CHUNK	FOR get_bpb
BIOSCODE:055D
BIOSCODE:055D ret81:				      ;	...
BIOSCODE:055D		      mov     ah, 81h	      ;	return error status
BIOSCODE:055F		      retn		      ;	return with carry set
BIOSCODE:055F ;	END OF FUNCTION	CHUNK FOR get_bpb
BIOSCODE:0560
BIOSCODE:0560 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0560
BIOSCODE:0560
BIOSCODE:0560 Check_Time_Of_Access proc	near	      ;	...
BIOSCODE:0560		      mov     si, 1	      ;	presume	no change
BIOSCODE:0563		      call    GetTickCnt      ;	cx:dx is the elapsed time
BIOSCODE:0566		      mov     ax, es:[di+47h] ;	[es:di+BDS.tim_lo]
BIOSCODE:0566					      ;	get stored time
BIOSCODE:056A		      sub     dx, ax
BIOSCODE:056C		      mov     ax, es:[di+49h] ;	[es:di+BDS.tim_hi]
BIOSCODE:0570		      sbb     cx, ax
BIOSCODE:0572		      jnz     short timecheck_unk ; cx<>0 => >1	hour
BIOSCODE:0574		      or      dx, dx	      ;	time must pass
BIOSCODE:0576		      jnz     short timepassed ; yes, examine max value
BIOSCODE:0578		      inc     ds:accesscount
BIOSCODE:057C		      cmp     ds:accesscount, 5
BIOSCODE:0581		      jb      short timecheck_ret ; if count is	less than threshold, ok
BIOSCODE:0583		      dec     ds:accesscount
BIOSCODE:0587		      jmp     short timecheck_unk
BIOSCODE:0589 ;	---------------------------------------------------------------------------
BIOSCODE:0589
BIOSCODE:0589 timepassed:			      ;	...
BIOSCODE:0589		      cmp     dx, 36	      ;	18*2 ; 18.2 tics per second.
BIOSCODE:0589					      ;	min elapsed time? (2 seconds)
BIOSCODE:058C		      jbe     short timecheck_ret
BIOSCODE:058E
BIOSCODE:058E timecheck_unk:			      ;	...
BIOSCODE:058E		      dec     si	      ;	presume	i don't know
BIOSCODE:058F
BIOSCODE:058F timecheck_ret:			      ;	...
BIOSCODE:058F		      retn
BIOSCODE:058F Check_Time_Of_Access endp
BIOSCODE:058F
BIOSCODE:0590 ;	---------------------------------------------------------------------------
BIOSCODE:0590
BIOSCODE:0590 Err_Exitj2:
BIOSCODE:0590		      jmp     short Err_Exitj
BIOSCODE:0592
BIOSCODE:0592 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0592
BIOSCODE:0592
BIOSCODE:0592 get_bpb	      proc near		      ;	...
BIOSCODE:0592
BIOSCODE:0592 ;	FUNCTION CHUNK AT BIOSCODE:055D	SIZE 00000003 BYTES
BIOSCODE:0592
BIOSCODE:0592		      mov     ah, es:[di]     ;	Build a	valid bpb for the disk in the drive.
BIOSCODE:0592					      ;	get fat	id byte	read by	dos
BIOSCODE:0595		      call    SetDrive
BIOSCODE:0598		      test    byte ptr es:[di+23h], 1 ;	[es:di+BDS.flags], fnon_removable
BIOSCODE:059D		      jnz     short already_gotbpb ; no	need to	build for fixed	disks
BIOSCODE:059F		      call    clear_ids
BIOSCODE:05A2		      mov     ds:set_id_flag, 1	; indicate to set system id in bds
BIOSCODE:05A7		      call    GetBp	      ;	build a	bpb if necessary
BIOSCODE:05AA		      jb      short ret81
BIOSCODE:05AC		      cmp     ds:set_id_flag, 2	; already, volume_label	set from boot
BIOSCODE:05B1		      mov     ds:set_id_flag, 0	; record to bds	table?
BIOSCODE:05B6		      jz      short already_gotbpb ; do	not set	it again from root dir
BIOSCODE:05B6					      ;	otherwise, conventional	boot record
BIOSCODE:05B8		      cmp     ds:fhave96, 0   ;	do we have changeline support?
BIOSCODE:05BD		      jz      short already_gotbpb ; brif not
BIOSCODE:05BF		      call    set_volume_id
BIOSCODE:05C2
BIOSCODE:05C2 already_gotbpb:			      ;	...
BIOSCODE:05C2		      add     di, 6	      ;	BDS.BPB	(BDS offset 6)
BIOSCODE:05C5
BIOSCODE:05C5 SetPtrSav:			      ;	...
BIOSCODE:05C5		      mov     cx, es	      ;	return point for dsk_init
BIOSCODE:05C7		      les     bx, ds:ptrsav
BIOSCODE:05CB		      mov     es:[bx+13], ah  ;	[es:bx+media]
BIOSCODE:05CF		      mov     es:[bx+18], di  ;	[es:bx+count]
BIOSCODE:05D3		      mov     es:[bx+20], cx  ;	[es:bx+count+2]
BIOSCODE:05D7		      clc
BIOSCODE:05D8		      retn
BIOSCODE:05D8 get_bpb	      endp
BIOSCODE:05D8
BIOSCODE:05D9
BIOSCODE:05D9 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:05D9
BIOSCODE:05D9
BIOSCODE:05D9 clear_ids	      proc near		      ;	...
BIOSCODE:05D9		      push    di
BIOSCODE:05DA		      xor     cx, cx	      ;	0
BIOSCODE:05DC		      mov     es:[di+57h], cx ;	[es:di+BDS.vol_serial]
BIOSCODE:05E0		      mov     es:[di+59h], cx ;	[es:di+BDS.vol_serial+2]
BIOSCODE:05E4		      mov     cx, 11
BIOSCODE:05E7		      mov     si, offset vol_no_name ; "NO NAME	   "
BIOSCODE:05EA		      add     di, 75	      ;	BDS.volid
BIOSCODE:05ED		      rep movsb
BIOSCODE:05EF		      test    byte ptr es:[di+31], 40h ; (here,	es:di points to	the BDS	offset +136)
BIOSCODE:05EF					      ;	[es:di+BDS.fatsiz], fbig
BIOSCODE:05EF					      ;
BIOSCODE:05EF					      ;	! NOTE - 26/06/2023 - Erdogan Tan
BIOSCODE:05EF					      ;	Microsoft code has a bug here because the BDS's
BIOSCODE:05EF					      ;	.volid and .filesys_id fields will be reset
BIOSCODE:05EF					      ;	(to their default text)	according to 'BDS.fatsiz' flags
BIOSCODE:05EF					      ;	at the BDS offset 31 but current (this)	code checks flags
BIOSCODE:05EF					      ;	at ES:DI+31 while DI points the	BDS offset 86!?
BIOSCODE:05EF					      ;
BIOSCODE:05EF					      ;	Correct	Code:
BIOSCODE:05EF					      ;	test byte [ES:DI+31-86],40h or
BIOSCODE:05EF					      ;	DI_POSITION equ	BDS.volid + size_of_EXT_BOOT_VOL_LABEL
BIOSCODE:05EF					      ;	test byte [ES:DI:BDS.fatsiz-DI_POSITION],40h ; fbig
BIOSCODE:05EF					      ;
BIOSCODE:05EF					      ;	(Why this bug did not affect MSDOS applications:
BIOSCODE:05EF					      ;	'clear_ids' is used for floppy disks only and the default
BIOSCODE:05EF					      ;	option of 'clear_ids' is FAT12 volid and filesys_id text
BIOSCODE:05EF					      ;	when the flag bit has wrong value for FAT16/40h.)
BIOSCODE:05F4		      mov     si, offset fat_16_id ; "FAT16   "
BIOSCODE:05F7		      jnz     short ci_bigfat
BIOSCODE:05F9		      mov     si, offset fat_12_id ; "FAT12   "
BIOSCODE:05FC
BIOSCODE:05FC ci_bigfat:			      ;	...
BIOSCODE:05FC		      mov     cx, 8	      ;	size_of_EXT_SYSTEM_ID
BIOSCODE:05FF		      add     di, 5	      ;	BDS.filesys_id (BDS offset 91)
BIOSCODE:0602		      rep movsb
BIOSCODE:0604		      pop     di	      ;	restore	bds pointer
BIOSCODE:0605
BIOSCODE:0605 getbp_retn:			      ;	26/06/2023
BIOSCODE:0605		      retn
BIOSCODE:0605 clear_ids	      endp
BIOSCODE:0605
BIOSCODE:0606
BIOSCODE:0606 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0606
BIOSCODE:0606
BIOSCODE:0606 GetBp	      proc near		      ;	...
BIOSCODE:0606		      test    byte ptr es:[di+23h], 5 ;	return_fake_bpb|fnon_removable
BIOSCODE:060B		      jz      short getbp1
BIOSCODE:060D		      jmp     getret_exit     ;	26/06/2023 - (useless far jump to 'retn'!)
BIOSCODE:060D					      ;
BIOSCODE:060D					      ;	Correct	code here:
BIOSCODE:060D					      ;	retn ; (instead	of jmp getret_exit)
BIOSCODE:060D					      ;	;or
BIOSCODE:060D					      ;	jnz short getbp_retn ; (short jump to 'retn')
BIOSCODE:0610 ;	---------------------------------------------------------------------------
BIOSCODE:0610
BIOSCODE:0610 getbp1:				      ;	...
BIOSCODE:0610		      push    cx
BIOSCODE:0611		      push    dx
BIOSCODE:0612		      push    bx
BIOSCODE:0613		      call    readbootsec
BIOSCODE:0616		      jb      short getbp_err_ret_brdg
BIOSCODE:0618		      or      bx, bx	      ;	bx is 0	if boot	sector is valid
BIOSCODE:061A		      jnz     short dofatbpb
BIOSCODE:061C		      call    movbpb
BIOSCODE:061F		      jmp     short Has1
BIOSCODE:0621 ;	---------------------------------------------------------------------------
BIOSCODE:0621
BIOSCODE:0621 getbp_err_ret_brdg:		      ;	...
BIOSCODE:0621		      jmp     getbp_err_ret
BIOSCODE:0624 ;	---------------------------------------------------------------------------
BIOSCODE:0624
BIOSCODE:0624 dofatbpb:				      ;	...
BIOSCODE:0624		      call    readfat	      ;	puts media descriptor byte in ah
BIOSCODE:0627		      jb      short getbp_err_ret_brdg
BIOSCODE:0629		      cmp     ds:fhave96, 0   ;	changeline support available?
BIOSCODE:062E		      jz      short bpb_nochangeline ; brif not
BIOSCODE:0630		      call    hidensity
BIOSCODE:0633
BIOSCODE:0633 bpb_nochangeline:			      ;	...
BIOSCODE:0633		      cmp     byte ptr es:[di+22h], 2 ;	[es:di+BDS.formfactor],	ffSmall
BIOSCODE:0638		      jnz     short is_floppy
BIOSCODE:063A		      cmp     ah, 0F9h	      ;	is it a	valid fat id byte for 3.5" ?
BIOSCODE:063D		      jnz     short got_unknown_medium ; no
BIOSCODE:063F
BIOSCODE:063F Has720K:				      ;	...
BIOSCODE:063F		      mov     bx, offset sm92 ;	pointer	to correct bpb
BIOSCODE:0642		      mov     al, [bx+0]      ;	bpbtype.sbf = 3
BIOSCODE:0646		      mov     cx, [bx+3]      ;	bpbtype.csec = 1440
BIOSCODE:064A		      mov     dx, [bx+5]      ;	dl = bpbtype.spau = 2
BIOSCODE:064A					      ;	dh = bpbtype.chead = 2
BIOSCODE:064E		      mov     bx, [bx+1]      ;	bl = bpbtype.spt = 9
BIOSCODE:064E					      ;	bh = bpbtype.dire = 112
BIOSCODE:0652		      jmp     short Has1
BIOSCODE:0654 ;	---------------------------------------------------------------------------
BIOSCODE:0654
BIOSCODE:0654 is_floppy:			      ;	...
BIOSCODE:0654		      cmp     ah, 0F8h
BIOSCODE:0657		      jb      short got_unknown_medium
BIOSCODE:0659		      mov     al, 1	      ;	pbtype.sbf = 1
BIOSCODE:065B		      mov     bx, 4008h	      ;	bl = bpbtype.spt = 8
BIOSCODE:065B					      ;	bh = bpbtype.dire = 64
BIOSCODE:065E		      mov     cx, 320	      ;	bpbtype.csec = 1440
BIOSCODE:0661		      mov     dx, 101h	      ;	dl = bpbtype.spau = 1
BIOSCODE:0661					      ;	dh = bpbtype.chead = 1
BIOSCODE:0664		      test    ah, 2
BIOSCODE:0667		      jnz     short has8
BIOSCODE:0669		      inc     al	      ;	bpbtype.sbf = 2
BIOSCODE:066B		      inc     bl	      ;	bpbtype.spt = 9
BIOSCODE:066D		      add     cx, 40	      ;	180K (360 sectors)
BIOSCODE:0670
BIOSCODE:0670 has8:				      ;	...
BIOSCODE:0670		      test    ah, 1	      ;	bpbtype.sbf = 1
BIOSCODE:0673		      jz      short Has1
BIOSCODE:0675		      add     cx, cx
BIOSCODE:0677		      mov     bh, 112	      ;	bh = bpbtype.dire = 112
BIOSCODE:0679		      inc     dh
BIOSCODE:067B		      inc     dl
BIOSCODE:067D
BIOSCODE:067D Has1:				      ;	...
BIOSCODE:067D		      mov     es:[di+8], dh   ;	[es:di+BDS.secperclus]
BIOSCODE:0681		      mov     es:[di+0Ch], bh ;	[es:di+BDS.direntries]
BIOSCODE:0685		      mov     es:[di+0Eh], cx ;	[es:di+BDS.totalsecs16]
BIOSCODE:0689		      mov     es:[di+10h], ah ;	[es:di+BDS.media]
BIOSCODE:068D		      mov     es:[di+11h], al ;	[es:di+BDS.fatsecs]
BIOSCODE:0691		      mov     es:[di+13h], bl ;	[es:di+BDS.secpertrack]
BIOSCODE:0695		      mov     es:[di+15h], dl ;	[es:di+BDS.heads]
BIOSCODE:0699		      mov     word ptr es:[di+19h], 0 ;	[es:di+BDS.hiddensecs+2]
BIOSCODE:069F		      mov     word ptr es:[di+17h], 0 ;	[es:di+BDS.hiddensecs]
BIOSCODE:06A5		      mov     word ptr es:[di+1Dh], 0 ;	[es:di+BDS.totalsecs32+2]
BIOSCODE:06AB
BIOSCODE:06AB getret:				      ;	...
BIOSCODE:06AB		      pop     bx
BIOSCODE:06AC		      pop     dx
BIOSCODE:06AD		      pop     cx
BIOSCODE:06AE
BIOSCODE:06AE getret_exit:			      ;	...
BIOSCODE:06AE		      retn
BIOSCODE:06AF ;	---------------------------------------------------------------------------
BIOSCODE:06AF
BIOSCODE:06AF getbp_err_ret:			      ;	...
BIOSCODE:06AF		      mov     ds:set_id_flag, 0
BIOSCODE:06B4		      call    maperror
BIOSCODE:06B7		      jmp     short getret
BIOSCODE:06B9 ;	---------------------------------------------------------------------------
BIOSCODE:06B9
BIOSCODE:06B9 got_unknown_medium:		      ;	...
BIOSCODE:06B9		      mov     ds:set_id_flag, 0
BIOSCODE:06BE		      mov     al, 7
BIOSCODE:06C0		      stc
BIOSCODE:06C1		      jmp     short getret
BIOSCODE:06C1 GetBp	      endp
BIOSCODE:06C1
BIOSCODE:06C3
BIOSCODE:06C3 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:06C3
BIOSCODE:06C3
BIOSCODE:06C3 readbootsec     proc near		      ;	...
BIOSCODE:06C3		      mov     dh, 0	      ;	head 0
BIOSCODE:06C5		      mov     cx, 1	      ;	cylinder 0, sector 1
BIOSCODE:06C8		      call    read_sector
BIOSCODE:06CB		      jb      short err_ret
BIOSCODE:06CD		      xor     bx, bx	      ;	bx = 0
BIOSCODE:06CF		      cmp     ds:disksector, 69h ; is it a direct jump?
BIOSCODE:06D4		      jz      short check_bpb_mediabyte	; don't need to find a nop
BIOSCODE:06D6		      cmp     ds:disksector, 0E9h ; dos	2.0 jump?
BIOSCODE:06DB		      jz      short check_bpb_mediabyte	; no need for nop
BIOSCODE:06DD		      cmp     ds:disksector, 0EBh ; how	about a	short jump?
BIOSCODE:06E2		      jnz     short invalidbootsec
BIOSCODE:06E4		      cmp     ds:disksector+2, 90h ; is	next one a nop?
BIOSCODE:06E9		      jnz     short invalidbootsec
BIOSCODE:06EB
BIOSCODE:06EB check_bpb_mediabyte:		      ;	...
BIOSCODE:06EB		      mov     al, ds:disksector+15h ;
BIOSCODE:06EB					      ;	[disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
BIOSCODE:06EE		      and     al, 0F0h
BIOSCODE:06F0		      cmp     al, 0F0h	      ;	allow for strange media
BIOSCODE:06F2		      jnz     short invalidbootsec
BIOSCODE:06F4
BIOSCODE:06F4 checksinglesided:
BIOSCODE:06F4		      mov     al, ds:disksector+15h
BIOSCODE:06F7		      cmp     al, 0F0h
BIOSCODE:06F9		      jz      short gooddsk
BIOSCODE:06FB		      test    al, 1
BIOSCODE:06FD		      jnz     short gooddsk
BIOSCODE:06FF		      cmp     word ptr ds:disksector+8,	'.3' ; 2E33h ; '3.'
BIOSCODE:0705		      jnz     short mustbeearlier
BIOSCODE:0707		      cmp     ds:disksector+0Ah, '2' ; 32h
BIOSCODE:070C		      jnb     short gooddsk
BIOSCODE:070E
BIOSCODE:070E mustbeearlier:			      ;	...
BIOSCODE:070E		      mov     ds:disksector+0Dh, 1 ; we	must have a pre-3.20 diskette.
BIOSCODE:070E					      ;	set the	sec/clus field to 1
BIOSCODE:070E					      ;	[disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]
BIOSCODE:0713		      jmp     short gooddsk
BIOSCODE:0715 ;	---------------------------------------------------------------------------
BIOSCODE:0715
BIOSCODE:0715 invalidbootsec:			      ;	...
BIOSCODE:0715		      inc     bx	      ;	indicate that boot sector invalid (bx =	1)
BIOSCODE:0716
BIOSCODE:0716 gooddsk:				      ;	...
BIOSCODE:0716		      clc
BIOSCODE:0717		      retn
BIOSCODE:0718 ;	---------------------------------------------------------------------------
BIOSCODE:0718
BIOSCODE:0718 err_ret:				      ;	...
BIOSCODE:0718		      retn
BIOSCODE:0718 readbootsec     endp
BIOSCODE:0718
BIOSCODE:0719
BIOSCODE:0719 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0719
BIOSCODE:0719
BIOSCODE:0719 movbpb	      proc near		      ;	...
BIOSCODE:0719		      mov     dh, ds:disksector+0Dh ; sectors per unit (cluster)
BIOSCODE:071D		      mov     bh, ds:disksector+11h ; number of	directory entries
BIOSCODE:0721		      mov     cx, word ptr ds:disksector+13h ; size of drive (volume)
BIOSCODE:0725		      mov     ah, ds:disksector+15h ; media descriptor
BIOSCODE:0729		      mov     al, ds:disksector+16h ; number of	fat sectors
BIOSCODE:072C		      mov     bl, ds:disksector+18h ; sectors per track
BIOSCODE:0730		      mov     dl, ds:disksector+1Ah ; number of	heads
BIOSCODE:0734		      cmp     ds:set_id_flag, 1	; called by get_bpb?
BIOSCODE:0739		      jnz     short movbpb_ret
BIOSCODE:073B		      call    mov_media_ids
BIOSCODE:073E		      jb      short movbpb_conv	; conventional boot record?
BIOSCODE:0740		      mov     ds:set_id_flag, 2	; signals that volume id is set
BIOSCODE:0745
BIOSCODE:0745 movbpb_conv:			      ;	...
BIOSCODE:0745		      cmp     ds:fhave96, 1
BIOSCODE:074A		      jnz     short movbpb_ret
BIOSCODE:074C		      call    resetchanged    ;	reset flags in bds to not fchanged
BIOSCODE:074F
BIOSCODE:074F movbpb_ret:			      ;	...
BIOSCODE:074F		      clc
BIOSCODE:0750		      retn
BIOSCODE:0750 movbpb	      endp
BIOSCODE:0750
BIOSCODE:0751
BIOSCODE:0751 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0751
BIOSCODE:0751
BIOSCODE:0751 mov_media_ids   proc near		      ;	...
BIOSCODE:0751		      cmp     ds:disksector+26h, 29h ; [disksector+EXT_BOOT.SIG],
BIOSCODE:0751					      ;		     EXT_BOOT_SIGNATURE
BIOSCODE:0756		      jnz     short mmi_not_ext
BIOSCODE:0758		      push    cx
BIOSCODE:0759		      mov     cx, word ptr ds:disksector+27h ;
BIOSCODE:0759					      ;	[disksector+EXT_BOOT.SERIAL]
BIOSCODE:075D		      mov     es:[di+57h], cx
BIOSCODE:0761		      mov     cx, word ptr ds:disksector+29h ;
BIOSCODE:0761					      ;	[disksector+EXT_BOOT.SERIAL+2]
BIOSCODE:0765		      mov     es:[di+59h], cx ;	[es:di+BDS.vol_serial+2]
BIOSCODE:0769		      push    di
BIOSCODE:076A		      push    si
BIOSCODE:076B		      mov     cx, 11	      ;	size_of_EXT_BOOT_VOL_LABEL
BIOSCODE:076E		      mov     si, (offset disksector+2Bh) ;
BIOSCODE:076E					      ;	disksector+EXT_BOOT.VOL_LABEL
BIOSCODE:0771		      add     di, 75	      ;	BDS.volid
BIOSCODE:0774		      rep movsb
BIOSCODE:0776		      mov     cx, 8	      ;	size_of_EXT_SYSTEM_ID
BIOSCODE:0779		      mov     si, (offset disksector+36h) ;
BIOSCODE:0779					      ;	disksector+EXT_BOOT.SYSTEM_ID
BIOSCODE:077C		      add     di, 5	      ;
BIOSCODE:077C					      ;	(BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
BIOSCODE:077F		      rep movsb
BIOSCODE:0781		      pop     si
BIOSCODE:0782		      pop     di
BIOSCODE:0783		      pop     cx
BIOSCODE:0784		      clc		      ;	this clc is not	required (16/06/2019 - Erdogan Tan)
BIOSCODE:0784					      ;	(20/09/2022 - 27/06/2023)
BIOSCODE:0785		      retn
BIOSCODE:0786 ;	---------------------------------------------------------------------------
BIOSCODE:0786
BIOSCODE:0786 mmi_not_ext:			      ;	...
BIOSCODE:0786		      stc
BIOSCODE:0787		      retn
BIOSCODE:0787 mov_media_ids   endp
BIOSCODE:0787
BIOSCODE:0788
BIOSCODE:0788 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0788
BIOSCODE:0788
BIOSCODE:0788 readfat	      proc near		      ;	...
BIOSCODE:0788		      mov     dh, 0	      ;	head 0
BIOSCODE:078A		      mov     cx, 2	      ;	cylinder 0, sector 2
BIOSCODE:078D		      call    read_sector
BIOSCODE:0790		      jb      short bad_fat_ret
BIOSCODE:0792		      mov     ah, [bx]	      ;	media byte
BIOSCODE:0794
BIOSCODE:0794 bad_fat_ret:			      ;	...
BIOSCODE:0794		      retn
BIOSCODE:0794 readfat	      endp
BIOSCODE:0794
BIOSCODE:0795
BIOSCODE:0795 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0795
BIOSCODE:0795
BIOSCODE:0795 read_sector     proc near		      ;	...
BIOSCODE:0795		      push    bp
BIOSCODE:0796		      mov     bp, 3	      ;	make 3 attempts
BIOSCODE:0799		      mov     dl, es:[di+4]   ;	[es:di+BDS.drivenum]
BIOSCODE:079D		      mov     bx, offset disksector ; BIOSDATA:014Eh
BIOSCODE:07A0
BIOSCODE:07A0 rd_ret:				      ;	...
BIOSCODE:07A0		      push    es
BIOSCODE:07A1		      push    ds
BIOSCODE:07A2		      pop     es
BIOSCODE:07A3		      mov     ax, 201h
BIOSCODE:07A6		      int     13h	      ;	DISK - READ SECTORS INTO MEMORY
BIOSCODE:07A6					      ;	AL = number of sectors to read,	CH = track, CL = sector
BIOSCODE:07A6					      ;	DH = head, DL =	drive, ES:BX ->	buffer to fill
BIOSCODE:07A6					      ;	Return:	CF set on error, AH = status, AL = number of sectors read
BIOSCODE:07A8		      pop     es
BIOSCODE:07A9		      jnb     short okret2
BIOSCODE:07AB
BIOSCODE:07AB rd_rty:				      ;	...
BIOSCODE:07AB		      call    again	      ;	reset disk, decrement bp
BIOSCODE:07AE		      jz      short err_rd_ret
BIOSCODE:07B0		      test    byte ptr es:[di+23h], 1 ;	[es:di+BDS.flags], fnon_removable
BIOSCODE:07B0					      ;	(BDS offset 35)
BIOSCODE:07B5		      jnz     short rd_ret
BIOSCODE:07B7		      cmp     ds:media_set_for_format, 0
BIOSCODE:07BC		      jnz     short rd_skip1_dpt
BIOSCODE:07BE		      push    ax
BIOSCODE:07BF		      push    ds	      ;	for retry, set the head	settle time to 0Fh
BIOSCODE:07C0		      lds     si, ds:dpt
BIOSCODE:07C4		      mov     al, [si+9]      ;	[si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:07C7		      mov     byte ptr [si+9], 15 ; NORMSETTLE
BIOSCODE:07CB		      pop     ds
BIOSCODE:07CC		      mov     ds:save_head_sttl, al
BIOSCODE:07CF		      pop     ax
BIOSCODE:07D0
BIOSCODE:07D0 rd_skip1_dpt:			      ;	...
BIOSCODE:07D0		      push    es
BIOSCODE:07D1		      push    ds
BIOSCODE:07D2		      pop     es
BIOSCODE:07D3		      mov     ax, 201h
BIOSCODE:07D6		      int     13h	      ;	DISK - READ SECTORS INTO MEMORY
BIOSCODE:07D6					      ;	AL = number of sectors to read,	CH = track, CL = sector
BIOSCODE:07D6					      ;	DH = head, DL =	drive, ES:BX ->	buffer to fill
BIOSCODE:07D6					      ;	Return:	CF set on error, AH = status, AL = number of sectors read
BIOSCODE:07D8		      pop     es
BIOSCODE:07D9		      pushf
BIOSCODE:07DA		      cmp     ds:media_set_for_format, 0
BIOSCODE:07DF		      jnz     short rd_skip2_dpt
BIOSCODE:07E1		      push    ax
BIOSCODE:07E2		      mov     al, ds:save_head_sttl
BIOSCODE:07E5		      push    ds
BIOSCODE:07E6		      lds     si, ds:dpt
BIOSCODE:07EA		      mov     [si+9], al      ;	[si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:07ED		      pop     ds
BIOSCODE:07EE		      pop     ax
BIOSCODE:07EF
BIOSCODE:07EF rd_skip2_dpt:			      ;	...
BIOSCODE:07EF		      popf
BIOSCODE:07F0		      jnb     short okret2
BIOSCODE:07F2		      jmp     short rd_rty
BIOSCODE:07F4 ;	---------------------------------------------------------------------------
BIOSCODE:07F4
BIOSCODE:07F4 err_rd_ret:			      ;	...
BIOSCODE:07F4		      mov     dl, 0FFh
BIOSCODE:07F6		      stc
BIOSCODE:07F7
BIOSCODE:07F7 okret2:				      ;	...
BIOSCODE:07F7		      mov     ds:step_drv, dl
BIOSCODE:07FB		      mov     ds:tim_drv, dl
BIOSCODE:07FF		      mov     es:[di+46h], ch ;	[es:di+BDS.track]
BIOSCODE:07FF					      ;	(BDS offset 70)
BIOSCODE:07FF					      ;	save last track	accessed on this drive
BIOSCODE:0803		      pushf
BIOSCODE:0804		      call    set_tim
BIOSCODE:0807		      popf		      ;	restore	flags
BIOSCODE:0808		      pop     bp
BIOSCODE:0809		      retn
BIOSCODE:0809 read_sector     endp
BIOSCODE:0809
BIOSCODE:080A
BIOSCODE:080A ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:080A
BIOSCODE:080A
BIOSCODE:080A dsk_open	      proc near		      ;	...
BIOSCODE:080A		      cmp     ds:fhave96, 0
BIOSCODE:080F		      jz      short dsk_open_exit
BIOSCODE:0811		      call    SetDrive
BIOSCODE:0814		      inc     word ptr es:[di+20h] ; [es:di+BDS.opcnt]
BIOSCODE:0814					      ;	(BDS offset 32)
BIOSCODE:0818
BIOSCODE:0818 dsk_open_exit:			      ;	...
BIOSCODE:0818		      clc		      ;	CF is already ZERO here	- Erdogan Tan
BIOSCODE:0819		      retn
BIOSCODE:0819 dsk_open	      endp
BIOSCODE:0819
BIOSCODE:081A
BIOSCODE:081A ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:081A
BIOSCODE:081A
BIOSCODE:081A dsk_close	      proc near		      ;	...
BIOSCODE:081A		      cmp     ds:fhave96, 0
BIOSCODE:081F		      jz      short exitjx    ;	done if	no changeline support
BIOSCODE:0821		      call    SetDrive	      ;	get bds	for drive
BIOSCODE:0824		      cmp     word ptr es:[di+20h], 0 ;	[es:di+BDS.opcnt]
BIOSCODE:0829		      jz      short exitjx    ;	watch out for wrap
BIOSCODE:082B		      dec     word ptr es:[di+20h]
BIOSCODE:082F
BIOSCODE:082F exitjx:				      ;	...
BIOSCODE:082F		      clc		      ;	CF is already ZERO here	- Erdogan Tan
BIOSCODE:0830		      retn
BIOSCODE:0830 dsk_close	      endp
BIOSCODE:0830
BIOSCODE:0831
BIOSCODE:0831 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0831
BIOSCODE:0831
BIOSCODE:0831 dsk_rem	      proc near		      ;	...
BIOSCODE:0831		      call    SetDrive
BIOSCODE:0834		      test    byte ptr es:[di+23h], 1 ;	[es:di+BDS.flags], fnon_removable
BIOSCODE:0839		      jnz     short x_bus_exit
BIOSCODE:083B		      clc		      ;	CF is already ZERO here	- Erdogan Tan
BIOSCODE:083C		      retn
BIOSCODE:083D ;	---------------------------------------------------------------------------
BIOSCODE:083D
BIOSCODE:083D x_bus_exit:			      ;	...
BIOSCODE:083D		      mov     ah, 3	      ;	non_rem
BIOSCODE:083D					      ;	return busy status
BIOSCODE:083F		      stc
BIOSCODE:0840
BIOSCODE:0840 dsk_ret:				      ;	...
BIOSCODE:0840		      retn
BIOSCODE:0840 dsk_rem	      endp
BIOSCODE:0840
BIOSCODE:0841 ;	---------------------------------------------------------------------------
BIOSCODE:0841
BIOSCODE:0841 dsk_writv:			      ;	...
BIOSCODE:0841		      mov     word ptr ds:rflag, 103h ;	write and verify
BIOSCODE:0847		      jmp     short dsk_cl
BIOSCODE:0849 ;	---------------------------------------------------------------------------
BIOSCODE:0849
BIOSCODE:0849 dsk_writ:				      ;	...
BIOSCODE:0849		      mov     word ptr ds:rflag, 3 ; romwrite
BIOSCODE:084F
BIOSCODE:084F dsk_cl:				      ;	...
BIOSCODE:084F		      call    diskio	      ;	prepare	for rombios read/write
BIOSCODE:0852
BIOSCODE:0852 dsk_io:				      ;	...
BIOSCODE:0852		      jnb     short dsk_ret
BIOSCODE:0854		      jmp     bc_err_cnt
BIOSCODE:0857 ;	---------------------------------------------------------------------------
BIOSCODE:0857
BIOSCODE:0857 dsk_read:				      ;	...
BIOSCODE:0857		      call    DISKRD
BIOSCODE:085A		      jmp     short dsk_io
BIOSCODE:085C
BIOSCODE:085C ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:085C
BIOSCODE:085C
BIOSCODE:085C checksingle     proc near		      ;	...
BIOSCODE:085C		      push    ax
BIOSCODE:085D		      push    bx
BIOSCODE:085E		      mov     bx, es:[di+23h] ;	[es:di+BDS.flags]
BIOSCODE:0862		      test    bl, 21h	      ;	fnon_removable|fi_own_physical
BIOSCODE:0865		      jnz     short singleret
BIOSCODE:0867		      test    bl, 10h	      ;	fi_am_mult
BIOSCODE:0867					      ;	is there a drive sharing this physical drive?
BIOSCODE:086A		      jz      short singleret
BIOSCODE:086C		      mov     al, es:[di+4]   ;	[es:di+BDS.drivenum]
BIOSCODE:086C					      ;	get physical drive number
BIOSCODE:0870		      push    es	      ;	preserve pointer to current bds
BIOSCODE:0871		      push    di
BIOSCODE:0872		      les     di, dword	ptr ds:start_bds ; get first bds
BIOSCODE:0876
BIOSCODE:0876 scan_list:			      ;	...
BIOSCODE:0876		      cmp     es:[di+4], al
BIOSCODE:087A		      jnz     short scan_skip ;	Not our	drive. Try next	bds.
BIOSCODE:087C		      mov     bl, 20h	      ;	fi_own_physical	; test ownership flag
BIOSCODE:087E		      test    es:[di+23h], bl
BIOSCODE:0882		      jz      short scan_skip ;	he doesn't own it either. continue
BIOSCODE:0884		      xor     es:[di+23h], bl ;	reset ownership	flag
BIOSCODE:0888		      pop     di
BIOSCODE:0889		      pop     es
BIOSCODE:088A		      or      es:[di+23h], bl
BIOSCODE:088E		      cmp     ds:fsetowner, 1
BIOSCODE:0893		      jnz     short not_fsetowner
BIOSCODE:0895		      cmp     byte ptr es:[di+4], 0 ; are we handling drive number 0 ?
BIOSCODE:089A		      jnz     short singleret
BIOSCODE:089C		      mov     al, es:[di+5]   ;	[es:di+BDS.drivelet]
BIOSCODE:089C					      ;	get the	DOS drive letter
BIOSCODE:08A0		      push    es
BIOSCODE:08A1		      mov     es, ds:zeroseg
BIOSCODE:08A5		      assume es:nothing
BIOSCODE:08A5		      mov     byte ptr es:0504h, al ; [es:LSTDRV]
BIOSCODE:08A5					      ;	set up sdsb
BIOSCODE:08A9		      pop     es	      ;	restore	bds pointer
BIOSCODE:08AA		      assume es:nothing
BIOSCODE:08AA		      jmp     short singleret
BIOSCODE:08AC ;	---------------------------------------------------------------------------
BIOSCODE:08AC
BIOSCODE:08AC not_fsetowner:			      ;	...
BIOSCODE:08AC		      cmp     ds:single, 2    ;	if (single_drive_system)
BIOSCODE:08B1		      jnz     short ignore_sdsb
BIOSCODE:08B3		      push    ax
BIOSCODE:08B4		      mov     al, es:[di+5]   ;	if (curr_drv ==	req_drv)
BIOSCODE:08B8		      mov     ah, al
BIOSCODE:08BA		      push    es
BIOSCODE:08BB		      mov     es, ds:zeroseg
BIOSCODE:08BF		      assume es:nothing
BIOSCODE:08BF		      xchg    al, byte ptr es:0504h ; [es:LSTDRV]
BIOSCODE:08BF					      ;	then swap(curr_drv,req_drv)
BIOSCODE:08C4		      pop     es
BIOSCODE:08C5		      assume es:nothing
BIOSCODE:08C5		      cmp     ah, al	      ;	else
BIOSCODE:08C7		      pop     ax	      ;	swap(curr_drv,req_drv)
BIOSCODE:08C8		      jz      short singleret ;	issue swap_dsk_msg
BIOSCODE:08CA
BIOSCODE:08CA ignore_sdsb:			      ;	...
BIOSCODE:08CA		      call    swpdsk
BIOSCODE:08CD		      jmp     short singleret
BIOSCODE:08CF ;	---------------------------------------------------------------------------
BIOSCODE:08CF
BIOSCODE:08CF scan_skip:			      ;	...
BIOSCODE:08CF		      les     di, es:[di]
BIOSCODE:08D2		      cmp     di, 0FFFFh      ;	-1 ; end of list?
BIOSCODE:08D5		      jnz     short scan_list ;	continue until hit end of list
BIOSCODE:08D7		      stc
BIOSCODE:08D8		      pop     di	      ;	restore	current	bds
BIOSCODE:08D9		      pop     es
BIOSCODE:08DA
BIOSCODE:08DA singleret:			      ;	...
BIOSCODE:08DA		      pop     bx
BIOSCODE:08DB		      pop     ax
BIOSCODE:08DC		      retn
BIOSCODE:08DC checksingle     endp
BIOSCODE:08DC
BIOSCODE:08DD ;	---------------------------------------------------------------------------
BIOSCODE:08DD ;	START OF FUNCTION CHUNK	FOR diskio
BIOSCODE:08DD
BIOSCODE:08DD baddrive:				      ;	...
BIOSCODE:08DD		      mov     al, 8	      ;	sector not found
BIOSCODE:08DF		      jmp     short baddrive_ret
BIOSCODE:08E1 ;	---------------------------------------------------------------------------
BIOSCODE:08E1
BIOSCODE:08E1 unformatteddrive:			      ;	...
BIOSCODE:08E1		      mov     al, 7	      ;	unknown	media
BIOSCODE:08E3
BIOSCODE:08E3 baddrive_ret:			      ;	...
BIOSCODE:08E3		      stc
BIOSCODE:08E3 ;	END OF FUNCTION	CHUNK FOR diskio
BIOSCODE:08E4
BIOSCODE:08E4 ioret:				      ;	...
BIOSCODE:08E4		      retn
BIOSCODE:08E5
BIOSCODE:08E5 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:08E5
BIOSCODE:08E5
BIOSCODE:08E5 DISKRD	      proc near		      ;	...
BIOSCODE:08E5		      mov     ds:rflag,	2     ;	romread
BIOSCODE:08E5 DISKRD	      endp
BIOSCODE:08E5
BIOSCODE:08EA
BIOSCODE:08EA ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:08EA
BIOSCODE:08EA
BIOSCODE:08EA diskio	      proc near		      ;	...
BIOSCODE:08EA
BIOSCODE:08EA ;	FUNCTION CHUNK AT BIOSCODE:08DD	SIZE 00000007 BYTES
BIOSCODE:08EA
BIOSCODE:08EA		      mov     bx, di	      ;	al = drive number
BIOSCODE:08EA					      ;	cx = sector count
BIOSCODE:08EA					      ;	dx = first sector (low)
BIOSCODE:08EA					      ;	[start_sec_h] =	first sector (high)
BIOSCODE:08EA					      ;
BIOSCODE:08EA					      ;	es:bx =	transfer address
BIOSCODE:08EC		      mov     ds:xfer_seg, es ;	save transfer segment
BIOSCODE:08F0		      call    SetDrive
BIOSCODE:08F3		      mov     al, es:[di+10h] ;	[es:di+BDS.media]
BIOSCODE:08F7		      mov     ds:medbyt, al
BIOSCODE:08FA		      jcxz    short ioret
BIOSCODE:08FC		      test    byte ptr es:[di+24h], 2 ;	[es:di+BDS.flags+1],
BIOSCODE:08FC					      ;	 unformatted_media
BIOSCODE:0901		      jnz     short unformatteddrive
BIOSCODE:0903		      mov     ds:seccnt, cx   ;	save sector count
BIOSCODE:0907		      mov     ds:spsav,	sp    ;	save sp
BIOSCODE:090B		      mov     ax, dx
BIOSCODE:090D		      xor     si, si
BIOSCODE:090F		      add     dx, cx
BIOSCODE:0911		      adc     si, 0
BIOSCODE:0914		      cmp     word ptr es:[di+0Eh], 0 ;	[es:di+BDS.totalsecs16]
BIOSCODE:0914					      ;	> 32 bit sector	?
BIOSCODE:0919		      jz      short sanity32
BIOSCODE:091B		      cmp     si, 0
BIOSCODE:091E		      jnz     short baddrive
BIOSCODE:0920		      cmp     dx, es:[di+0Eh] ;	[es:di+BDS.totalsecs16]
BIOSCODE:0924		      ja      short baddrive
BIOSCODE:0926		      jmp     short sanityok
BIOSCODE:0928 ;	---------------------------------------------------------------------------
BIOSCODE:0928
BIOSCODE:0928 sanity32:				      ;	...
BIOSCODE:0928		      add     si, ds:start_sec_h
BIOSCODE:092C		      cmp     si, es:[di+1Dh] ;	[es:di+BDS.totalsecs32+2]
BIOSCODE:0930		      jb      short sanityok
BIOSCODE:0932		      ja      short baddrive
BIOSCODE:0934		      cmp     dx, es:[di+1Bh] ;	[es:di+BDS.totalsecs32]
BIOSCODE:0938		      ja      short baddrive
BIOSCODE:093A
BIOSCODE:093A sanityok:				      ;	...
BIOSCODE:093A		      mov     dx, ds:start_sec_h
BIOSCODE:093E		      add     ax, es:[di+17h] ;	[es:di+BDS.hiddensecs]
BIOSCODE:0942		      adc     dx, es:[di+19h] ;	[es:di+BDS.hiddensecs+2]
BIOSCODE:0946		      mov     ds:saved_word, ax	; save the sector number (low)
BIOSCODE:0949		      push    es
BIOSCODE:094A		      mov     es, ds:zeroseg  ;	0
BIOSCODE:094E		      assume es:nothing
BIOSCODE:094E		      les     si, dword	ptr es:single ;	[es:DSKADR] ; INT 1Eh vector
BIOSCODE:094E					      ;	current	disk parm table
BIOSCODE:0953		      assume es:nothing
BIOSCODE:0953		      mov     word ptr ds:dpt, si
BIOSCODE:0957		      mov     word ptr ds:dpt+2, es
BIOSCODE:095B		      pop     es
BIOSCODE:095C		      test    byte ptr es:[di+23h], 1 ;	[es:di+BDS.flags],
BIOSCODE:095C					      ;	fnon_removable
BIOSCODE:0961		      jnz     short skip_setup
BIOSCODE:0963		      call    checksingle
BIOSCODE:0966		      cmp     ds:fhave96, 0   ;	do we have changeline support?
BIOSCODE:096B		      jz      short diskio_nochangeline	; brif not
BIOSCODE:096D		      call    checklatchio    ;	will do	a sneaky pop stack return
BIOSCODE:096D					      ;	if a disk error	occurs
BIOSCODE:0970
BIOSCODE:0970 diskio_nochangeline:		      ;	...
BIOSCODE:0970		      call    iosetup	      ;	set up tables and variables for	i/o
BIOSCODE:0973
BIOSCODE:0973 skip_setup:			      ;	...
BIOSCODE:0973		      mov     ax, dx
BIOSCODE:0975		      xor     dx, dx
BIOSCODE:0977		      div     word ptr es:[di+13h] ; [es:di+BDS.secpertrack]
BIOSCODE:0977					      ;	divide by sec per track
BIOSCODE:097B		      mov     ds:temp_h, ax
BIOSCODE:097E		      mov     ax, ds:saved_word
BIOSCODE:0981		      div     word ptr es:[di+13h] ; [es:di+BDS.secpertrack]
BIOSCODE:0981					      ;	now, [temp_h]:ax = track #, dx = sector
BIOSCODE:0981					      ;	sector number is 1 based.
BIOSCODE:0985		      inc     dl
BIOSCODE:0987		      mov     ds:cursec, dl   ;	save current sector
BIOSCODE:098B		      mov     cx, es:[di+15h] ;	[es:di+BDS.heads]
BIOSCODE:098B					      ;	get number of heads
BIOSCODE:098F		      push    ax
BIOSCODE:0990		      xor     dx, dx
BIOSCODE:0992		      mov     ax, ds:temp_h   ;	divide tracks by heads per cylinder
BIOSCODE:0995		      div     cx
BIOSCODE:0997		      mov     ds:temp_h, ax
BIOSCODE:099A		      pop     ax
BIOSCODE:099B		      div     cx	      ;	now, [temp_h]:ax = cylinder #, dx = head
BIOSCODE:099D		      cmp     ds:temp_h, 0
BIOSCODE:09A2		      ja      short baddrive_brdg
BIOSCODE:09A4		      cmp     ax, 1024	      ;	2^10 currently maxium for track	#.
BIOSCODE:09A7		      ja      short baddrive_brdg
BIOSCODE:09A9		      mov     ds:curhd,	dl    ;	save current head
BIOSCODE:09AD		      mov     ds:curtrk, ax   ;	save current track
BIOSCODE:09B0		      mov     ax, ds:seccnt
BIOSCODE:09B3		      call    block
BIOSCODE:09B6		      call    done
BIOSCODE:09B9		      retn
BIOSCODE:09BA ;	---------------------------------------------------------------------------
BIOSCODE:09BA
BIOSCODE:09BA baddrive_brdg:			      ;	...
BIOSCODE:09BA		      jmp     baddrive
BIOSCODE:09BA diskio	      endp
BIOSCODE:09BA
BIOSCODE:09BD
BIOSCODE:09BD ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:09BD
BIOSCODE:09BD
BIOSCODE:09BD iosetup	      proc near		      ;	...
BIOSCODE:09BD		      mov     al, es:[di+4]   ;	[es:di+BDS.drivenum]
BIOSCODE:09C1		      mov     ds:tim_drv, al  ;	save drive letter
BIOSCODE:09C4		      cmp     ds:media_set_for_format, 0
BIOSCODE:09C9		      jnz     short skip_dpt_setting
BIOSCODE:09CB		      mov     al, ds:eot      ;	fetch up eot before changing ds
BIOSCODE:09CE		      push    ds
BIOSCODE:09CF		      lds     si, ds:dpt      ;	get pointer to disk base table
BIOSCODE:09D3		      mov     [si+4], al
BIOSCODE:09D6		      mov     al, [si+10]     ;	[si+DISK_PARMS.DISK_MOTOR_STRT]
BIOSCODE:09D9		      mov     ah, [si+4]      ;	[si+DISK_PARMS.DISK_EOT]
BIOSCODE:09DC		      pop     ds
BIOSCODE:09DD		      mov     ds:motorstartup, al
BIOSCODE:09E0		      mov     ds:save_eot, ah
BIOSCODE:09E4		      push    ds
BIOSCODE:09E5		      lds     si, ds:dpt
BIOSCODE:09E9		      cmp     byte ptr es:[di+34], 2 ; [es:di+BDS.formfactor], ffSmall
BIOSCODE:09EE		      jnz     short motor_start_ok
BIOSCODE:09F0		      mov     al, 4
BIOSCODE:09F2		      xchg    al, [si+10]     ;	[si+DISK_PARMS.DISK_MOTOR_STRT]
BIOSCODE:09F5
BIOSCODE:09F5 motor_start_ok:			      ;	...
BIOSCODE:09F5		      xor     al, al
BIOSCODE:09F7		      inc     al	      ;	ibm wants fast settle to be 1
BIOSCODE:09F9		      xchg    al, [si+9]      ;	[si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:09F9					      ;	get settle and set up for fast
BIOSCODE:09FC		      pop     ds
BIOSCODE:09FD		      mov     ds:settlecurrent,	al
BIOSCODE:0A00		      mov     al, 15	      ;	NORMSETTLE
BIOSCODE:0A00					      ;	someone	has diddled the	settle
BIOSCODE:0A02		      mov     ds:settleslow, al
BIOSCODE:0A05
BIOSCODE:0A05 skip_dpt_setting:			      ;	...
BIOSCODE:0A05		      retn
BIOSCODE:0A05 iosetup	      endp
BIOSCODE:0A05
BIOSCODE:0A06
BIOSCODE:0A06 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0A06
BIOSCODE:0A06
BIOSCODE:0A06 done	      proc near		      ;	...
BIOSCODE:0A06		      test    byte ptr es:[di+23h], 1
BIOSCODE:0A0B		      jnz     short ddbx      ;	do not set for non-removable media
BIOSCODE:0A0D		      call    set_tim
BIOSCODE:0A10
BIOSCODE:0A10 diddle_back:			      ;	...
BIOSCODE:0A10		      pushf
BIOSCODE:0A11		      cmp     ds:media_set_for_format, 0
BIOSCODE:0A16		      jnz     short nodiddleback
BIOSCODE:0A18		      push    ax
BIOSCODE:0A19		      push    es
BIOSCODE:0A1A		      les     si, ds:dpt
BIOSCODE:0A1E		      mov     al, ds:save_eot
BIOSCODE:0A21		      mov     es:[si+4], al   ;	[es:si+DISK_PARMS.DISK_EOT]
BIOSCODE:0A25		      mov     al, ds:settlecurrent
BIOSCODE:0A28		      mov     ah, ds:motorstartup
BIOSCODE:0A2C		      mov     es:[si+9], al   ;	[es:si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:0A30		      mov     byte ptr es:[si+3], 2 ; [es:si+DISK_PARMS.DISK_SECTOR_SIZ]
BIOSCODE:0A35		      mov     es:[si+0Ah], ah ;	[es:si+DISK_PARMS.DISK_MOTOR_STRT]
BIOSCODE:0A39		      pop     es
BIOSCODE:0A3A		      pop     ax
BIOSCODE:0A3B
BIOSCODE:0A3B nodiddleback:			      ;	...
BIOSCODE:0A3B		      popf
BIOSCODE:0A3C
BIOSCODE:0A3C ddbx:				      ;	...
BIOSCODE:0A3C		      retn
BIOSCODE:0A3C done	      endp
BIOSCODE:0A3C
BIOSCODE:0A3D
BIOSCODE:0A3D ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0A3D
BIOSCODE:0A3D
BIOSCODE:0A3D block	      proc near		      ;	...
BIOSCODE:0A3D		      or      ax, ax
BIOSCODE:0A3F		      jz      short ddbx
BIOSCODE:0A41		      test    byte ptr es:[di+23h], 1 ;	[es:di+BDS.flags], fnon_removable
BIOSCODE:0A46		      jz      short block_floppy
BIOSCODE:0A48		      test    byte ptr ds:multrk_flag, 80h ; multrk_on
BIOSCODE:0A4D		      jz      short block_floppy
BIOSCODE:0A4F		      call    disk
BIOSCODE:0A52		      xor     ax, ax
BIOSCODE:0A54		      retn
BIOSCODE:0A55 ;	---------------------------------------------------------------------------
BIOSCODE:0A55
BIOSCODE:0A55 block_floppy:			      ;	...
BIOSCODE:0A55		      mov     cl, es:[di+19]
BIOSCODE:0A59		      inc     cl
BIOSCODE:0A5B		      sub     cl, ds:cursec
BIOSCODE:0A5F		      xor     ch, ch
BIOSCODE:0A61		      cmp     ax, cx
BIOSCODE:0A63		      jnb     short gotmin
BIOSCODE:0A65		      mov     cx, ax
BIOSCODE:0A67
BIOSCODE:0A67 gotmin:				      ;	...
BIOSCODE:0A67		      push    ax
BIOSCODE:0A68		      push    cx
BIOSCODE:0A69		      mov     ax, cx
BIOSCODE:0A6B		      call    disk
BIOSCODE:0A6E		      pop     cx
BIOSCODE:0A6F		      pop     ax
BIOSCODE:0A70		      sub     ax, cx	      ;	reduce sectors-remaining by last i/o
BIOSCODE:0A72		      shl     cl, 1
BIOSCODE:0A74		      add     bh, cl	      ;	adjust transfer	address
BIOSCODE:0A76		      jmp     short block
BIOSCODE:0A76 block	      endp
BIOSCODE:0A76
BIOSCODE:0A78 ;	---------------------------------------------------------------------------
BIOSCODE:0A78 ;	START OF FUNCTION CHUNK	FOR disk
BIOSCODE:0A78
BIOSCODE:0A78 dskerr_brdg:			      ;	...
BIOSCODE:0A78		      jmp     dskerr
BIOSCODE:0A78 ;	END OF FUNCTION	CHUNK FOR disk
BIOSCODE:0A7B
BIOSCODE:0A7B ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0A7B
BIOSCODE:0A7B
BIOSCODE:0A7B disk	      proc near		      ;	...
BIOSCODE:0A7B
BIOSCODE:0A7B ;	FUNCTION CHUNK AT BIOSCODE:0A78	SIZE 00000003 BYTES
BIOSCODE:0A7B
BIOSCODE:0A7B		      mov     bp, 5	      ;	al = number of sectors (1-8, all on one	track)
BIOSCODE:0A7B					      ;	es:di point to drive parameters
BIOSCODE:0A7B					      ;	xfer_seg:bx = transfer address
BIOSCODE:0A7B					      ;	     (must not cross a 64k physical boundary)
BIOSCODE:0A7B					      ;	[rflag]	= 2 if read, 3 if write
BIOSCODE:0A7B					      ;	[verify] = 0 for normal, 1 for verify after write
BIOSCODE:0A7B					      ;
BIOSCODE:0A7B					      ;	bp = MAXERR
BIOSCODE:0A7B					      ;	     retry_count
BIOSCODE:0A7E		      test    byte ptr es:[di+23h], 1 ;	[es:di+BDS.flags], fnon_removable
BIOSCODE:0A83		      jz      short GetRdWrInd
BIOSCODE:0A85		      cmp     ah, 4	      ;	romverify ; Is this a track verify?
BIOSCODE:0A88		      jz      short GetRdWrInd
BIOSCODE:0A8A		      mov     bp, 2	      ;	This is	not verify so only 1 retry
BIOSCODE:0A8D
BIOSCODE:0A8D GetRdWrInd:			      ;	...
BIOSCODE:0A8D		      mov     ds:vretry_cnt, bp	; verify op. retry cnt for write-verify
BIOSCODE:0A91		      mov     ds:soft_ecc_cnt, bp ; soft ecc error retry count
BIOSCODE:0A95		      mov     ah, ds:rflag    ;	get read/write indicator
BIOSCODE:0A99
BIOSCODE:0A99 _retry:				      ;	...
BIOSCODE:0A99		      push    ax
BIOSCODE:0A9A		      mov     dx, ds:curtrk
BIOSCODE:0A9E		      test    byte ptr es:[di+23h], 1 ;	[es:di+BDS.bdsm_ismini]
BIOSCODE:0A9E					      ;	is this	a mini disk? ((logical dos partition))
BIOSCODE:0AA3		      jz      short disk_not_mini ; no.	continue to next
BIOSCODE:0AA5		      cmp     word ptr es:[di+47h], 1
BIOSCODE:0AAA		      jnz     short disk_not_mini
BIOSCODE:0AAC		      add     dx, es:[di+49h] ;	[es:di+BDS.bdsm_hidden_trks]
BIOSCODE:0AAC					      ;	add hidden tracks
BIOSCODE:0AB0
BIOSCODE:0AB0 disk_not_mini:			      ;	...
BIOSCODE:0AB0		      ror     dh, 1
BIOSCODE:0AB2		      ror     dh, 1
BIOSCODE:0AB4		      or      dh, ds:cursec
BIOSCODE:0AB8		      mov     cx, dx
BIOSCODE:0ABA		      xchg    ch, cl	      ;	cl = sector, ch	= cylinder
BIOSCODE:0ABC		      mov     dh, ds:curhd    ;	load current head number and
BIOSCODE:0AC0		      mov     dl, es:[di+4]   ;	physical drive number
BIOSCODE:0AC0					      ;	[es:di+BDS.drivenum]
BIOSCODE:0AC4		      cmp     byte ptr es:[di+22h], 5 ;	[es:di+BDS.formfactor],	ffHardFile
BIOSCODE:0AC9		      jz      short do_fast   ;	hard files use fast speed
BIOSCODE:0ACB		      cmp     ds:step_drv, 0FFh	; -1
BIOSCODE:0AD0		      jz      short do_writej
BIOSCODE:0AD2		      cmp     ah, 2	      ;	romread
BIOSCODE:0AD5		      jz      short do_fast
BIOSCODE:0AD7		      cmp     ah, 4	      ;	romverify
BIOSCODE:0ADA		      jz      short do_fast
BIOSCODE:0ADC
BIOSCODE:0ADC do_writej:			      ;	...
BIOSCODE:0ADC		      jmp     short do_write
BIOSCODE:0ADE ;	---------------------------------------------------------------------------
BIOSCODE:0ADE
BIOSCODE:0ADE do_fast:				      ;	...
BIOSCODE:0ADE		      call    fastspeed	      ;	change settle mode
BIOSCODE:0AE1
BIOSCODE:0AE1 testerr:				      ;	...
BIOSCODE:0AE1		      jb      short dskerr_brdg
BIOSCODE:0AE3		      mov     ds:step_drv, dl
BIOSCODE:0AE7		      mov     es:[di+46h], ch ;	[es:di+BDS.track]
BIOSCODE:0AEB		      cmp     word ptr ds:rflag, 103h
BIOSCODE:0AF1		      jz      short doverify
BIOSCODE:0AF3
BIOSCODE:0AF3 noverify:				      ;	...
BIOSCODE:0AF3		      pop     ax
BIOSCODE:0AF4		      test    byte ptr es:[di+23h], 1 ;	[es:di+BDS.flags], fnon_removable
BIOSCODE:0AF9		      jz      short its_removable
BIOSCODE:0AFB		      test    byte ptr ds:multrk_flag, 80h ; multrk_on
BIOSCODE:0B00		      jnz     short disk_ret
BIOSCODE:0B02
BIOSCODE:0B02 its_removable:			      ;	...
BIOSCODE:0B02		      and     cl, 3Fh	      ;	eliminate cylinder bits	from sector
BIOSCODE:0B05		      xor     ah, ah
BIOSCODE:0B07		      sub     ds:seccnt, ax   ;	reduce count of	sectors	to go next sector
BIOSCODE:0B0B		      add     cl, al
BIOSCODE:0B0D		      mov     ds:cursec, cl
BIOSCODE:0B11		      cmp     cl, es:[di+13h] ;	[es:di+BDS.secpertrack]
BIOSCODE:0B11					      ;	see if sector/track limit reached
BIOSCODE:0B15		      jbe     short disk_ret
BIOSCODE:0B17		      mov     ds:cursec, 1
BIOSCODE:0B1C		      mov     dh, ds:curhd
BIOSCODE:0B20		      inc     dh
BIOSCODE:0B22		      cmp     dh, es:[di+15h]
BIOSCODE:0B26		      jb      short noxor
BIOSCODE:0B28		      xor     dh, dh	      ;	head 0
BIOSCODE:0B2A		      inc     ds:curtrk	      ;	next track
BIOSCODE:0B2E
BIOSCODE:0B2E noxor:				      ;	...
BIOSCODE:0B2E		      mov     ds:curhd,	dh
BIOSCODE:0B32
BIOSCODE:0B32 disk_ret:				      ;	...
BIOSCODE:0B32		      clc
BIOSCODE:0B33		      retn
BIOSCODE:0B34 ;	---------------------------------------------------------------------------
BIOSCODE:0B34
BIOSCODE:0B34 do_write:				      ;	...
BIOSCODE:0B34		      cmp     dl, ds:step_drv
BIOSCODE:0B38		      jnz     short do_norm
BIOSCODE:0B3A		      cmp     ch, es:[di+46h]
BIOSCODE:0B3E		      jz      short do_fast
BIOSCODE:0B40
BIOSCODE:0B40 do_norm:				      ;	...
BIOSCODE:0B40		      call    normspeed
BIOSCODE:0B43		      jmp     short testerr
BIOSCODE:0B45 ;	---------------------------------------------------------------------------
BIOSCODE:0B45
BIOSCODE:0B45 doverify:				      ;	...
BIOSCODE:0B45		      pop     ax
BIOSCODE:0B46		      push    ax
BIOSCODE:0B47		      mov     ah, 4
BIOSCODE:0B49		      call    fastspeed
BIOSCODE:0B4C		      jnb     short noverify
BIOSCODE:0B4E		      cmp     ah, 11h	      ;	soft ecc error ?
BIOSCODE:0B51		      jnz     short not_softecc_err
BIOSCODE:0B53		      dec     ds:soft_ecc_cnt
BIOSCODE:0B57		      jz      short noverify  ;	no more	retry
BIOSCODE:0B59		      call    resetdisk
BIOSCODE:0B5C		      jmp     short dskerr1   ;	retry
BIOSCODE:0B5E ;	---------------------------------------------------------------------------
BIOSCODE:0B5E
BIOSCODE:0B5E not_softecc_err:			      ;	...
BIOSCODE:0B5E		      call    resetdisk
BIOSCODE:0B61		      dec     ds:vretry_cnt
BIOSCODE:0B65		      jmp     short dskerr0
BIOSCODE:0B67 ;	---------------------------------------------------------------------------
BIOSCODE:0B67
BIOSCODE:0B67 loc_3127:				      ;	...
BIOSCODE:0B67 dskerr:				      ;	do we have changeline support?
BIOSCODE:0B67		      cmp     ds:fhave96, 0
BIOSCODE:0B6C		      jz      short dskerr_nochangeline	; brif not
BIOSCODE:0B6E		      call    checkio
BIOSCODE:0B71
BIOSCODE:0B71 dskerr_nochangeline:		      ;	...
BIOSCODE:0B71		      cmp     ds:multitrk_format_flag, 1 ; multi trk format request?
BIOSCODE:0B76		      jnz     short dochkagain ; no more retry
BIOSCODE:0B78		      mov     bp, 1
BIOSCODE:0B7B		      mov     ds:multitrk_format_flag, 0 ; clear the flag
BIOSCODE:0B80
BIOSCODE:0B80 dochkagain:			      ;	...
BIOSCODE:0B80		      call    again
BIOSCODE:0B83
BIOSCODE:0B83 dskerr0:				      ;	...
BIOSCODE:0B83		      jz      short harderr
BIOSCODE:0B85		      test    byte ptr es:[di+23h], 1 ;	[es:di+BDS.flags], fnon_removable
BIOSCODE:0B8A		      jnz     short skip_timeout_chk
BIOSCODE:0B8C		      cmp     ah, 80h	      ;	timeout?
BIOSCODE:0B8F		      jz      short harderr
BIOSCODE:0B91
BIOSCODE:0B91 skip_timeout_chk:			      ;	...
BIOSCODE:0B91		      cmp     ah, 0CCh	      ;	write fault error?
BIOSCODE:0B94		      jz      short write_fault_err ; then, don't retry.
BIOSCODE:0B96		      mov     ds:soft_ecc_cnt, 5 ; MAXERR
BIOSCODE:0B96					      ;	set soft_ecc_cnt back	to maxerr
BIOSCODE:0B9C
BIOSCODE:0B9C dskerr1:				      ;	...
BIOSCODE:0B9C		      pop     ax	      ;	estore sector count
BIOSCODE:0B9D		      jmp     _retry
BIOSCODE:0BA0 ;	---------------------------------------------------------------------------
BIOSCODE:0BA0
BIOSCODE:0BA0 write_fault_err:			      ;	...
BIOSCODE:0BA0		      mov     bp, 1	      ;	just retry only	once
BIOSCODE:0BA0					      ;	for write fault	error
BIOSCODE:0BA3		      jmp     short dskerr1
BIOSCODE:0BA5 ;	---------------------------------------------------------------------------
BIOSCODE:0BA5
BIOSCODE:0BA5 harderr:				      ;	...
BIOSCODE:0BA5		      call    maperror
BIOSCODE:0BA8
BIOSCODE:0BA8 harderr2:				      ;	...
BIOSCODE:0BA8		      mov     ds:tim_drv, 0FFh ; force a media check through rom
BIOSCODE:0BAD		      mov     cx, ds:seccnt   ;	get count of sectors to	go
BIOSCODE:0BB1		      mov     sp, ds:spsav    ;	recover	entry stack pointer
BIOSCODE:0BB5		      jmp     diddle_back
BIOSCODE:0BB5 disk	      endp
BIOSCODE:0BB5
BIOSCODE:0BB8
BIOSCODE:0BB8 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0BB8
BIOSCODE:0BB8
BIOSCODE:0BB8 normspeed	      proc near		      ;	...
BIOSCODE:0BB8		      cmp     ds:media_set_for_format, 0
BIOSCODE:0BBD		      jnz     short fastspeed
BIOSCODE:0BBF		      push    es
BIOSCODE:0BC0		      push    ax
BIOSCODE:0BC1		      mov     al, ds:settleslow
BIOSCODE:0BC4		      les     si, ds:dpt      ;	current	disk parm table
BIOSCODE:0BC8		      mov     es:[si+9], al   ;	[es:si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:0BCC		      pop     ax
BIOSCODE:0BCD		      pop     es
BIOSCODE:0BCE		      call    fastspeed
BIOSCODE:0BD1		      push    es
BIOSCODE:0BD2		      les     si, ds:dpt
BIOSCODE:0BD6		      mov     byte ptr es:[si+9], 1 ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:0BD6					      ;	1 is fast settle value
BIOSCODE:0BDB		      pop     es
BIOSCODE:0BDC		      retn
BIOSCODE:0BDC normspeed	      endp
BIOSCODE:0BDC
BIOSCODE:0BDD
BIOSCODE:0BDD ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0BDD
BIOSCODE:0BDD
BIOSCODE:0BDD fastspeed	      proc near		      ;	...
BIOSCODE:0BDD		      test    byte ptr es:[di+1Fh], 80h	; [es:di+BDS.fatsiz], ftoobig
BIOSCODE:0BE2		      jnz     short notready
BIOSCODE:0BE4		      push    es
BIOSCODE:0BE5		      mov     es, ds:xfer_seg
BIOSCODE:0BE9		      int     13h	      ;	DISK -
BIOSCODE:0BEB		      mov     ds:xfer_seg, es
BIOSCODE:0BEF		      pop     es
BIOSCODE:0BF0		      retn
BIOSCODE:0BF1 ;	---------------------------------------------------------------------------
BIOSCODE:0BF1
BIOSCODE:0BF1 notready:				      ;	...
BIOSCODE:0BF1		      stc
BIOSCODE:0BF2		      mov     ah, 80h
BIOSCODE:0BF4		      retn
BIOSCODE:0BF4 fastspeed	      endp
BIOSCODE:0BF4
BIOSCODE:0BF5
BIOSCODE:0BF5 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0BF5
BIOSCODE:0BF5
BIOSCODE:0BF5 maperror	      proc near		      ;	...
BIOSCODE:0BF5		      push    cx
BIOSCODE:0BF6		      push    es
BIOSCODE:0BF7		      push    ds
BIOSCODE:0BF8		      pop     es	      ;	set es=Bios_Data
BIOSCODE:0BF9		      mov     al, ah
BIOSCODE:0BFB		      mov     ds:lsterr, al   ;	terminate list with error code
BIOSCODE:0BFE		      mov     cx, 9	      ;	numerr (= errout-errin)
BIOSCODE:0BFE					      ;	number of possible error conditions
BIOSCODE:0C01		      mov     di, offset errin
BIOSCODE:0C04		      repne scasb
BIOSCODE:0C06		      mov     al, [di+8]      ;	[di+numerr-1]
BIOSCODE:0C06					      ;	get translation
BIOSCODE:0C0A		      pop     es
BIOSCODE:0C0B		      pop     cx
BIOSCODE:0C0C		      stc		      ;	flag error condition
BIOSCODE:0C0D		      retn
BIOSCODE:0C0D maperror	      endp
BIOSCODE:0C0D
BIOSCODE:0C0E
BIOSCODE:0C0E ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0C0E
BIOSCODE:0C0E
BIOSCODE:0C0E set_tim	      proc near		      ;	...
BIOSCODE:0C0E		      push    ax	      ;	set the	time of	last access for	this drive.
BIOSCODE:0C0E					      ;	this is	done only for removable	media.
BIOSCODE:0C0E					      ;	es:di -> bds
BIOSCODE:0C0F		      call    GetTickCnt      ;	Does INT 1A ah=0 & updates daycnt
BIOSCODE:0C12		      cmp     dx, es:[di+47h] ;	[es:di+BDS.tim_lo]
BIOSCODE:0C16		      jnz     short setaccess
BIOSCODE:0C18		      cmp     cx, es:[di+49h]
BIOSCODE:0C1C		      jz      short done_set
BIOSCODE:0C1E
BIOSCODE:0C1E setaccess:			      ;	...
BIOSCODE:0C1E		      mov     ds:accesscount, 0	; the time has passed
BIOSCODE:0C1E					      ;	reset the threshold counter
BIOSCODE:0C23		      mov     es:[di+47h], dx
BIOSCODE:0C27		      mov     es:[di+49h], cx
BIOSCODE:0C2B
BIOSCODE:0C2B done_set:				      ;	...
BIOSCODE:0C2B		      clc
BIOSCODE:0C2C		      pop     ax
BIOSCODE:0C2D		      retn
BIOSCODE:0C2D set_tim	      endp
BIOSCODE:0C2D
BIOSCODE:0C2E
BIOSCODE:0C2E ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0C2E
BIOSCODE:0C2E
BIOSCODE:0C2E again	      proc near		      ;	...
BIOSCODE:0C2E		      call    resetdisk
BIOSCODE:0C31		      cmp     ah, 6	      ;	If it is a media change	error
BIOSCODE:0C31					      ;	do not decrement retry count
BIOSCODE:0C34		      jz      short dont_dec_retry_count
BIOSCODE:0C36		      dec     bp	      ;	decrement retry	count
BIOSCODE:0C37		      retn
BIOSCODE:0C38 ;	---------------------------------------------------------------------------
BIOSCODE:0C38
BIOSCODE:0C38 dont_dec_retry_count:		      ;	...
BIOSCODE:0C38		      or      ah, ah
BIOSCODE:0C3A		      retn
BIOSCODE:0C3A again	      endp
BIOSCODE:0C3A
BIOSCODE:0C3A ;	---------------------------------------------------------------------------
BIOSCODE:0C3B		      db 0
BIOSCODE:0C3C IoReadJumpTable db 8		      ;	...
BIOSCODE:0C3D		      dw offset	GetDeviceParameters ; 60h
BIOSCODE:0C3F		      dw offset	ReadTrack     ;	61h
BIOSCODE:0C41		      dw offset	VerifyTrack   ;	62h
BIOSCODE:0C43		      dw offset	Cmd_Error_Proc ; 63h
BIOSCODE:0C45		      dw offset	Cmd_Error_Proc ; 64h
BIOSCODE:0C47		      dw offset	Cmd_Error_Proc ; 65h
BIOSCODE:0C49		      dw offset	GetMediaId    ;	66h
BIOSCODE:0C4B		      dw offset	GetAccessFlag ;	67h
BIOSCODE:0C4D		      dw offset	SenseMediaType ; 68h
BIOSCODE:0C4F IoWriteJumpTable db 7		      ;	...
BIOSCODE:0C50		      dw offset	SetDeviceParameters ; 40h
BIOSCODE:0C52		      dw offset	WriteTrack    ;	41h
BIOSCODE:0C54		      dw offset	FormatTrack   ;	42h
BIOSCODE:0C56		      dw offset	Cmd_Error_Proc ; 43h
BIOSCODE:0C58		      dw offset	Cmd_Error_Proc ; 44h
BIOSCODE:0C5A		      dw offset	Cmd_Error_Proc ; 45h
BIOSCODE:0C5C		      dw offset	SetMediaId    ;	46h
BIOSCODE:0C5E		      dw offset	SetAccessFlag ;	47h
BIOSCODE:0C60 IOC_DC_Table    db 60h, 40h, 61h,	41h, 62h, 42h, 66h, 46h, 67h, 47h, 68h ; ...
BIOSCODE:0C6B ;	---------------------------------------------------------------------------
BIOSCODE:0C6B
BIOSCODE:0C6B Do_Generic_IOCtl:			      ;	...
BIOSCODE:0C6B		      call    SetDrive	      ;	es:di points to	bds for	drive
BIOSCODE:0C6E		      push    es
BIOSCODE:0C6F		      les     bx, ds:18	      ;	es:bx points to	request	header
BIOSCODE:0C73		      cmp     byte ptr es:[bx+0Dh], 8 ;	[es:bx+IOCTL_REQ.MAJORFUNCTION],
BIOSCODE:0C73					      ;	RAWIO
BIOSCODE:0C78		      mov     al, es:[bx+0Eh]
BIOSCODE:0C7C		      pop     es
BIOSCODE:0C7D		      jnz     short IoctlFuncErr
BIOSCODE:0C7F		      mov     si, offset IoReadJumpTable
BIOSCODE:0C82		      test    al, 20h	      ;	GEN_IOCTL_FN_TST ; test	of req.	function
BIOSCODE:0C84		      jnz     short NotGenericWrite
BIOSCODE:0C86		      mov     si, offset IoWriteJumpTable
BIOSCODE:0C89
BIOSCODE:0C89 NotGenericWrite:			      ;	...
BIOSCODE:0C89		      and     al, 0DFh	      ;	~GEN_IOCTL_FN_TST ; get	rid of read/write bit
BIOSCODE:0C8B		      sub     al, 40h	      ;	offset for base	function
BIOSCODE:0C8D		      cmp     al, cs:[si]
BIOSCODE:0C90		      ja      short IoctlFuncErr
BIOSCODE:0C92		      cbw
BIOSCODE:0C93		      shl     ax, 1
BIOSCODE:0C95		      inc     si
BIOSCODE:0C96		      add     si, ax
BIOSCODE:0C98		      call    word ptr cs:[si]
BIOSCODE:0C9B		      mov     ds, cs:Bios_Data_Word
BIOSCODE:0CA0		      assume ds:nothing
BIOSCODE:0CA0		      mov     ah, 81h	      ;	Return this status in case of carry
BIOSCODE:0CA2		      retn
BIOSCODE:0CA3 ;	---------------------------------------------------------------------------
BIOSCODE:0CA3
BIOSCODE:0CA3 Cmd_Error_Proc:			      ;	...
BIOSCODE:0CA3		      pop     dx
BIOSCODE:0CA4
BIOSCODE:0CA4 IoctlFuncErr:			      ;	...
BIOSCODE:0CA4		      jmp     bc_cmderr
BIOSCODE:0CA7 ;	---------------------------------------------------------------------------
BIOSCODE:0CA7
BIOSCODE:0CA7 GetDeviceParameters:		      ;	...
BIOSCODE:0CA7		      lds     bx, ds:ptrsav   ;	ds:bx points to	request	header
BIOSCODE:0CAB		      assume ds:nothing
BIOSCODE:0CAB		      lds     bx, [bx+13h]    ;	[bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:0CAB					      ;	(ds:bx)	= return buffer
BIOSCODE:0CAE		      mov     al, es:[di+22h] ;	[es:di+BDS.formfactor]
BIOSCODE:0CB2		      mov     [bx+1], al      ;	[bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
BIOSCODE:0CB5		      mov     ax, es:[di+23h] ;	[es:di+BDS.flags]
BIOSCODE:0CB9		      and     ax, 3	      ;	fnon_removable+fchangeline
BIOSCODE:0CB9					      ;	Mask off other bits
BIOSCODE:0CBC		      mov     [bx+2], ax      ;	[bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
BIOSCODE:0CBF		      mov     ax, es:[di+25h] ;	[es:di+BDS.cylinders]
BIOSCODE:0CC3		      mov     [bx+4], ax      ;	[bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
BIOSCODE:0CC6		      xor     al, al	      ;	Set media type to default
BIOSCODE:0CC8		      mov     [bx+6], al      ;	[bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
BIOSCODE:0CCB		      lea     si, [di+27h]    ;	[di+BDS.rbytespersec] =	[di+BDS.R_BPB]
BIOSCODE:0CCB					      ;	(copy recommended bpb)
BIOSCODE:0CCE		      test    byte ptr [bx], 1 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
BIOSCODE:0CCE					      ;	BUILD_DEVICE_BPB
BIOSCODE:0CD1		      jz      short UseBpbPresent ; Point back to BIOSDATA
BIOSCODE:0CD3		      push    ds
BIOSCODE:0CD4		      mov     ds, cs:Bios_Data_Word ; Point back to BIOSDATA
BIOSCODE:0CD9		      assume ds:nothing
BIOSCODE:0CD9		      call    checksingle
BIOSCODE:0CDC		      call    GetBp	      ;	Build the bpb from scratch
BIOSCODE:0CDF		      pop     ds
BIOSCODE:0CE0		      assume ds:nothing
BIOSCODE:0CE0		      jb      short GetParmRet
BIOSCODE:0CE2		      lea     si, [di+6]      ;	[di+BDS.bytespersec] = [di+BSD.DP_BPB]
BIOSCODE:0CE2					      ;	Use this subfield of bds instead
BIOSCODE:0CE5
BIOSCODE:0CE5 UseBpbPresent:			      ;	...
BIOSCODE:0CE5		      lea     di, [bx+7]      ;	[bx+A_DEVICEPARAMETERS.DP_BPB]
BIOSCODE:0CE5					      ;	This is	where the result goes
BIOSCODE:0CE8		      mov     cx, 25	      ;	A_BPB.size - 6
BIOSCODE:0CE8					      ;	For now	use 'small' bpb
BIOSCODE:0CEB		      push    ds	      ;	reverse	segments for copy
BIOSCODE:0CEC		      push    es
BIOSCODE:0CED		      pop     ds
BIOSCODE:0CEE		      pop     es
BIOSCODE:0CEF		      rep movsb
BIOSCODE:0CF1		      clc
BIOSCODE:0CF2
BIOSCODE:0CF2 GetParmRet:			      ;	...
BIOSCODE:0CF2		      retn
BIOSCODE:0CF3 ;	---------------------------------------------------------------------------
BIOSCODE:0CF3
BIOSCODE:0CF3 SetDeviceParameters:		      ;	...
BIOSCODE:0CF3		      lds     bx, ds:ptrsav   ;	ds:bx points to	request	header
BIOSCODE:0CF7		      lds     bx, [bx+13h]    ;	[bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:0CFA		      or      word ptr es:[di+23h], 140h ; [es:di+BDS.flags],
BIOSCODE:0CFA					      ;	 fchanged_by_format|fchanged
BIOSCODE:0D00		      test    byte ptr [bx], 2 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
BIOSCODE:0D00					      ;	 ONLY_SET_TRACKLAYOUT
BIOSCODE:0D03		      jnz     short setTrackTable
BIOSCODE:0D05		      mov     al, [bx+1]      ;	[bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
BIOSCODE:0D08		      mov     es:[di+22h], al ;	[es:di+BDS.formfactor]
BIOSCODE:0D0C		      mov     ax, [bx+4]      ;	[bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
BIOSCODE:0D0F		      mov     es:[di+25h], ax ;	[es:di+BDS.cylinders]
BIOSCODE:0D13		      mov     ax, [bx+2]      ;	[bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
BIOSCODE:0D16		      push    ds
BIOSCODE:0D17		      mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
BIOSCODE:0D1C		      assume ds:nothing
BIOSCODE:0D1C		      cmp     ds:fhave96, 0
BIOSCODE:0D21		      pop     ds
BIOSCODE:0D22		      assume ds:nothing
BIOSCODE:0D22		      jnz     short HaveChange ; we have changeline support
BIOSCODE:0D24		      and     ax, 0FFFDh
BIOSCODE:0D27
BIOSCODE:0D27 HaveChange:			      ;	...
BIOSCODE:0D27		      and     ax, 3	      ;	Ignore all bits	except non_removable and changeline
BIOSCODE:0D27					      ;	fnon_removable|fchangeline
BIOSCODE:0D2A		      mov     cx, es:[di+23h] ;	[es:di+BDS.flags]
BIOSCODE:0D2E		      and     cx, 0FDF4h      ;	~(fnon_removable|fchangeline|good_tracklayout|unformatted_media)
BIOSCODE:0D32		      or      ax, cx
BIOSCODE:0D34		      mov     es:[di+23h], ax ;	[es:di+BDS.flags]
BIOSCODE:0D38		      mov     al, [bx+6]      ;	[bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
BIOSCODE:0D38					      ;	Set media type
BIOSCODE:0D3B		      push    ds
BIOSCODE:0D3C		      mov     ds, cs:Bios_Data_Word
BIOSCODE:0D41		      assume ds:nothing
BIOSCODE:0D41		      mov     ds:mediatype, al
BIOSCODE:0D44		      pop     ds
BIOSCODE:0D45		      assume ds:nothing
BIOSCODE:0D45		      or      word ptr es:[di+23h], 80h	; [es:di+BDS.flags]
BIOSCODE:0D45					      ;	set_dasd_true (the next	time we	format a track)
BIOSCODE:0D4B		      push    di
BIOSCODE:0D4C		      test    byte ptr [bx], 1 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
BIOSCODE:0D4C					      ;	 INSTALL_FAKE_BPB
BIOSCODE:0D4F		      jnz     short InstallFakeBpb
BIOSCODE:0D51		      test    word ptr es:[di+23h], 4 ;	[es:di+BDS.flags], return_fake_bpb
BIOSCODE:0D51					      ;	were we	returning a fake bpb when asked	to build a bpb?
BIOSCODE:0D57		      jz      short InstallRecommendedBpb
BIOSCODE:0D59		      and     word ptr es:[di+23h], 0FFFBh ; [es:di+BDS.flags],	~return_fake_bpb
BIOSCODE:0D59					      ;	we were	returning a fake bpb but we can	stop now
BIOSCODE:0D5E
BIOSCODE:0D5E InstallRecommendedBpb:		      ;	...
BIOSCODE:0D5E		      mov     cx, 31	      ;	A_BPB.size
BIOSCODE:0D61		      lea     di, [di+27h]    ;	[di+BDS.R_BPB] = [di+BDS.rbytespersec]
BIOSCODE:0D64		      jmp     short CopyTheBpb
BIOSCODE:0D66 ;	---------------------------------------------------------------------------
BIOSCODE:0D66
BIOSCODE:0D66 InstallFakeBpb:			      ;	...
BIOSCODE:0D66		      or      word ptr es:[di+23h], 4
BIOSCODE:0D6B		      mov     cx, 25	      ;	A_BPB.size - 6
BIOSCODE:0D6E		      lea     di, [di+6]      ;	[es:di+BDS.BPB]	= [es:di+BDS.bytespersec]
BIOSCODE:0D71
BIOSCODE:0D71 CopyTheBpb:			      ;	...
BIOSCODE:0D71		      lea     si, [bx+7]      ;	[bx+A_DEVICEPARAMETERS.DP_BPB]
BIOSCODE:0D74		      rep movsb
BIOSCODE:0D76		      push    ds	      ;	Save packet segment
BIOSCODE:0D77		      mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
BIOSCODE:0D7C		      assume ds:nothing
BIOSCODE:0D7C		      call    RestoreOldDpt
BIOSCODE:0D7F		      pop     ds
BIOSCODE:0D80		      assume ds:nothing
BIOSCODE:0D80		      pop     di
BIOSCODE:0D81
BIOSCODE:0D81 setTrackTable:			      ;	...
BIOSCODE:0D81		      mov     cx, [bx+26h]    ;	[bx+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
BIOSCODE:0D81					      ;	offset 31+7 (A_BPB.size+7)
BIOSCODE:0D84		      push    ds
BIOSCODE:0D85		      mov     ds, cs:Bios_Data_Word
BIOSCODE:0D8A		      assume ds:nothing
BIOSCODE:0D8A		      mov     ds:sectorspertrack, cx
BIOSCODE:0D8E		      pop     ds
BIOSCODE:0D8F		      assume ds:nothing
BIOSCODE:0D8F		      and     word ptr es:[di+23h], 0FFF7h ; [es:di+BDS.flags],	~good_tracklayout
BIOSCODE:0D94		      test    byte ptr [bx], 4 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
BIOSCODE:0D94					      ;	 TRACKLAYOUT_IS_GOOD
BIOSCODE:0D97		      jz      short UglyTrackLayOut
BIOSCODE:0D99		      or      word ptr es:[di+23h], 8 ;	[es:di+BDS.flags], good_tracklayout
BIOSCODE:0D9E
BIOSCODE:0D9E UglyTrackLayOut:			      ;	...
BIOSCODE:0D9E		      cmp     cx, 63	      ;	MAX_SECTORS_IN_TRACK
BIOSCODE:0DA1		      ja      short TooManyPerTrack
BIOSCODE:0DA3		      jcxz    short SectorInfoSaved
BIOSCODE:0DA5		      mov     di, offset tracktable
BIOSCODE:0DA8		      lea     si, [bx+28h]    ;	[bx+A_DEVICEPARAMETERS.DP_SECTORTABLE]
BIOSCODE:0DA8					      ;	offset 31+9 (A_BPB.size+9)
BIOSCODE:0DAB		      mov     es, cs:Bios_Data_Word ; BIOSDATA segment
BIOSCODE:0DAB					      ;	Trash our bds pointer
BIOSCODE:0DB0		      assume es:nothing
BIOSCODE:0DB0
BIOSCODE:0DB0 StoreSectorInfo:			      ;	...
BIOSCODE:0DB0		      inc     di
BIOSCODE:0DB1		      inc     di	      ;	Skip over cylinder and head
BIOSCODE:0DB2		      lodsw		      ;	Get sector id
BIOSCODE:0DB3		      stosb		      ;	Copy it
BIOSCODE:0DB4		      lodsw		      ;	Get sector size
BIOSCODE:0DB5		      call    SectSizeToSectIndex ; SectSizeToSectIndex:
BIOSCODE:0DB5					      ;	     Input:  ax	contains sector	size in	bytes
BIOSCODE:0DB5					      ;	     Output: al	contains index
BIOSCODE:0DB8		      stosb
BIOSCODE:0DB9		      loop    StoreSectorInfo
BIOSCODE:0DBB
BIOSCODE:0DBB SectorInfoSaved:			      ;	...
BIOSCODE:0DBB		      clc
BIOSCODE:0DBC		      retn
BIOSCODE:0DBD ;	---------------------------------------------------------------------------
BIOSCODE:0DBD
BIOSCODE:0DBD TooManyPerTrack:			      ;	...
BIOSCODE:0DBD		      mov     al, 0Ch
BIOSCODE:0DBF		      stc
BIOSCODE:0DC0		      retn
BIOSCODE:0DC1 ;	---------------------------------------------------------------------------
BIOSCODE:0DC1
BIOSCODE:0DC1 FormatTrack:			      ;	...
BIOSCODE:0DC1		      lds     bx, ds:ptrsav
BIOSCODE:0DC5		      lds     bx, [bx+13h]    ;	[bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:0DC8		      test    byte ptr [bx], 1 ; bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
BIOSCODE:0DC8					      ;	 STATUS_FOR_FORMAT
BIOSCODE:0DCB		      jz      short DoFormatTrack
BIOSCODE:0DCD		      push    ds
BIOSCODE:0DCE		      mov     ds, cs:Bios_Data_Word
BIOSCODE:0DD3		      assume ds:nothing
BIOSCODE:0DD3		      call    SetMediaForFormat	; Also moves current Dpt to TempDpt
BIOSCODE:0DD6		      pop     ds
BIOSCODE:0DD7		      assume ds:nothing
BIOSCODE:0DD7		      mov     [bx], al	      ;	[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
BIOSCODE:0DD9		      clc
BIOSCODE:0DDA		      retn
BIOSCODE:0DDB ;	---------------------------------------------------------------------------
BIOSCODE:0DDB
BIOSCODE:0DDB DoFormatTrack:			      ;	...
BIOSCODE:0DDB		      cmp     byte ptr es:[di+22h], 5 ;	[es:di+BDS.formfactor],	DEV_HARDDISK
BIOSCODE:0DE0		      jnz     short DoFormatDiskette
BIOSCODE:0DE2		      mov     ds, cs:Bios_Data_Word
BIOSCODE:0DE7		      assume ds:nothing
BIOSCODE:0DE7		      jmp     VerifyTrack
BIOSCODE:0DEA ;	---------------------------------------------------------------------------
BIOSCODE:0DEA
BIOSCODE:0DEA DoFormatDiskette:			      ;	...
BIOSCODE:0DEA		      mov     cx, [bx+1]      ;	[bx+A_FORMATPACKET.FP_HEAD]
BIOSCODE:0DED		      mov     dx, [bx+3]      ;	[bx+A_FORMATPACKET.FP_CYLINDER]
BIOSCODE:0DF0		      test    byte ptr [bx], 2 ; [bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]
BIOSCODE:0DF0					      ;	    FP_TRACKCOUNT is only meaningful
BIOSCODE:0DF0					      ;	    when FP_SPECIALFUNCTIONS bit 1 = 1
BIOSCODE:0DF3		      mov     ds, cs:Bios_Data_Word
BIOSCODE:0DF8		      jz      short DoFormatDiskette_1
BIOSCODE:0DFA		      jmp     VerifyTrack_Err
BIOSCODE:0DFD ;	---------------------------------------------------------------------------
BIOSCODE:0DFD
BIOSCODE:0DFD DoFormatDiskette_1:		      ;	...
BIOSCODE:0DFD		      call    SetMediaForFormat	; Also moves current Dpt to TempDpt
BIOSCODE:0E00		      cmp     al, 1
BIOSCODE:0E02		      jz      short NeedToSetDasd ; Old	rom
BIOSCODE:0E04		      cmp     al, 3	      ;	Time out error?
BIOSCODE:0E06		      jnz     short NoSetDasd ;	No,fine. (at this point, don't care
BIOSCODE:0E06					      ;	about the illegal combination)
BIOSCODE:0E08		      jmp     short FormatFailed
BIOSCODE:0E0A ;	---------------------------------------------------------------------------
BIOSCODE:0E0A
BIOSCODE:0E0A NeedToSetDasd:			      ;	...
BIOSCODE:0E0A		      push    dx
BIOSCODE:0E0B		      call    SetDasd	      ;	INT 13h, ah=17h
BIOSCODE:0E0E		      pop     dx
BIOSCODE:0E0F
BIOSCODE:0E0F NoSetDasd:			      ;	...
BIOSCODE:0E0F		      call    checksingle     ;	Do any needed diskette swapping
BIOSCODE:0E12		      mov     ax, dx	      ;	Get track from packet
BIOSCODE:0E14		      mov     ds:trknum, ax
BIOSCODE:0E17		      mov     ds:hdnum,	cl
BIOSCODE:0E1B		      mov     ah, cl
BIOSCODE:0E1D		      mov     bx, offset tracktable
BIOSCODE:0E20		      mov     cx, ds:sectorspertrack
BIOSCODE:0E24
BIOSCODE:0E24 StoreCylinderHead:		      ;	...
BIOSCODE:0E24		      mov     [bx], ax	      ;	Store into TrackTable
BIOSCODE:0E26		      add     bx, 4	      ;	Skip to	next sector field
BIOSCODE:0E29		      loop    StoreCylinderHead
BIOSCODE:0E2B		      mov     cx, 5	      ;	MAXERR - Set up	retry count
BIOSCODE:0E2E
BIOSCODE:0E2E FormatRetry:			      ;	...
BIOSCODE:0E2E		      push    cx	      ;	Now verify the sectors just formatted.
BIOSCODE:0E2E					      ;	NOTE: because of bug in	some BIOSes
BIOSCODE:0E2E					      ;	      we have to set ES:BX to 00:00
BIOSCODE:0E2F		      mov     bx, offset tracktable
BIOSCODE:0E32		      mov     al, byte ptr ds:sectorspertrack
BIOSCODE:0E35		      mov     ah, 5
BIOSCODE:0E37		      mov     ds:xfer_seg, ds
BIOSCODE:0E3B		      call    ToRom
BIOSCODE:0E3E		      pop     cx
BIOSCODE:0E3F		      jb      short FormatError
BIOSCODE:0E41		      push    cx
BIOSCODE:0E42		      push    bx
BIOSCODE:0E43		      xor     bx, bx
BIOSCODE:0E45		      mov     ds:xfer_seg, bx
BIOSCODE:0E49		      mov     al, byte ptr ds:sectorspertrack
BIOSCODE:0E4C		      mov     ah, 4
BIOSCODE:0E4E		      mov     cl, 1
BIOSCODE:0E50		      call    ToRom
BIOSCODE:0E53		      pop     bx
BIOSCODE:0E54		      pop     cx
BIOSCODE:0E55		      jnb     short FormatOk
BIOSCODE:0E57
BIOSCODE:0E57 FormatError:			      ;	...
BIOSCODE:0E57		      call    resetdisk
BIOSCODE:0E5A		      mov     ds:had_format_error, 1
BIOSCODE:0E5F		      push    ax
BIOSCODE:0E60		      push    cx
BIOSCODE:0E61		      push    dx
BIOSCODE:0E62		      call    SetMediaForFormat
BIOSCODE:0E65		      cmp     al, 1
BIOSCODE:0E67		      jnz     short WhileErr
BIOSCODE:0E69		      call    SetDasd
BIOSCODE:0E6C
BIOSCODE:0E6C WhileErr:				      ;	...
BIOSCODE:0E6C		      pop     dx
BIOSCODE:0E6D		      pop     cx
BIOSCODE:0E6E		      pop     ax
BIOSCODE:0E6F		      loop    FormatRetry
BIOSCODE:0E71
BIOSCODE:0E71 FormatFailed:			      ;	...
BIOSCODE:0E71		      mov     ds:had_format_error, 1
BIOSCODE:0E76		      cmp     ah, 6	      ;	DSK_CHANGELINE_ERR
BIOSCODE:0E76					      ;	convert	change line error to time out error
BIOSCODE:0E79		      jnz     short DoMapIt
BIOSCODE:0E7B		      mov     ah, 80h	      ;	DSK_TIMEOUT_ERR
BIOSCODE:0E7D
BIOSCODE:0E7D DoMapIt:				      ;	...
BIOSCODE:0E7D		      jmp     maperror
BIOSCODE:0E80 ;	---------------------------------------------------------------------------
BIOSCODE:0E80
BIOSCODE:0E80 FormatOk:				      ;	...
BIOSCODE:0E80		      mov     ds:had_format_error, 0 ; reset the format	error flag
BIOSCODE:0E85		      retn
BIOSCODE:0E86 ;	---------------------------------------------------------------------------
BIOSCODE:0E86
BIOSCODE:0E86 VerifyTrack:			      ;	...
BIOSCODE:0E86		      push    ds
BIOSCODE:0E87		      lds     bx, ds:ptrsav   ;	ds:bx points to	request	header.
BIOSCODE:0E8B		      assume ds:nothing
BIOSCODE:0E8B		      lds     bx, [bx+13h]    ;	[bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:0E8E		      mov     cx, [bx+3]      ;	[bx+A_VERIFYPACKET.VP_CYLINDER]
BIOSCODE:0E91		      mov     ax, [bx+1]      ;	[bx+A_VERIFYPACKET.VP_HEAD]
BIOSCODE:0E94		      mov     dx, [bx+5]      ;	[bx+A_FORMATPACKET.FP_TRACKCOUNT]
BIOSCODE:0E97		      mov     bl, [bx]	      ;	[bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]
BIOSCODE:0E99		      pop     ds
BIOSCODE:0E9A		      mov     ds:rflag,	4     ;	romverify
BIOSCODE:0E9F		      mov     ds:curtrk, cx
BIOSCODE:0EA3		      mov     ds:curhd,	al    ;	assume heads < 256
BIOSCODE:0EA6		      mov     cx, ds:sectorspertrack
BIOSCODE:0EAA		      test    bl, 2	      ;	DO_FAST_FORMAT
BIOSCODE:0EAD		      jz      short NormVerifyTrack
BIOSCODE:0EAF		      mov     ax, dx	      ;	Get ax = number	of trks	to verify
BIOSCODE:0EB1		      or      ah, ah
BIOSCODE:0EB3		      jnz     short VerifyTrack_Err ; #tracks >	255
BIOSCODE:0EB5		      mul     cl
BIOSCODE:0EB7		      or      ah, ah
BIOSCODE:0EB9		      jnz     short VerifyTrack_Err
BIOSCODE:0EBB		      mov     cx, ax
BIOSCODE:0EBD		      test    word ptr es:[di+23h], 1 ;	[es:di+BDS.flags], fnon_removable
BIOSCODE:0EC3		      jz      short NormVerifyTrack
BIOSCODE:0EC5		      test    ds:multrk_flag, 80h ; MULTI_TRK_ON
BIOSCODE:0ECB		      jz      short NormVerifyTrack
BIOSCODE:0ECD		      mov     ds:multitrk_format_flag, 1
BIOSCODE:0ED2
BIOSCODE:0ED2 NormVerifyTrack:			      ;	...
BIOSCODE:0ED2		      xor     ax, ax	      ;	1st sector
BIOSCODE:0ED4		      xor     bx, bx
BIOSCODE:0ED6		      mov     ds:xfer_seg, bx ;	Use 0:0	as the transfer	address	for verify
BIOSCODE:0EDA		      call    TrackIo
BIOSCODE:0EDD		      mov     ds:multitrk_format_flag, 0
BIOSCODE:0EE2		      retn
BIOSCODE:0EE3 ;	---------------------------------------------------------------------------
BIOSCODE:0EE3
BIOSCODE:0EE3 VerifyTrack_Err:			      ;	...
BIOSCODE:0EE3		      mov     ah, 1
BIOSCODE:0EE5		      jmp     maperror
BIOSCODE:0EE8 ;	---------------------------------------------------------------------------
BIOSCODE:0EE8
BIOSCODE:0EE8 ReadTrack:			      ;	...
BIOSCODE:0EE8		      mov     ds:rflag,	2     ;	romread
BIOSCODE:0EED		      jmp     short ReadWriteTrack
BIOSCODE:0EEF ;	---------------------------------------------------------------------------
BIOSCODE:0EEF
BIOSCODE:0EEF WriteTrack:			      ;	...
BIOSCODE:0EEF		      mov     ds:rflag,	3
BIOSCODE:0EF4
BIOSCODE:0EF4 ReadWriteTrack:			      ;	...
BIOSCODE:0EF4		      push    es
BIOSCODE:0EF5		      les     bx, ds:ptrsav   ;	es:bx -> to request header
BIOSCODE:0EF9		      assume es:nothing
BIOSCODE:0EF9		      les     bx, es:[bx+13h] ;	[es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:0EFD		      mov     ax, es:[bx+3]   ;	[es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]
BIOSCODE:0F01		      mov     ds:curtrk, ax
BIOSCODE:0F04		      mov     ax, es:[bx+1]   ;	[es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]
BIOSCODE:0F08		      mov     ds:curhd,	al    ;	Assume heads < 256 !
BIOSCODE:0F0B		      mov     ax, es:[bx+5]   ;	[es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]
BIOSCODE:0F0F		      mov     cx, es:[bx+7]   ;	[es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]
BIOSCODE:0F13		      les     bx, es:[bx+9]   ;	[es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]
BIOSCODE:0F13					      ;	Get transfer address
BIOSCODE:0F17		      mov     ds:xfer_seg, es ;	Pass transfer segment
BIOSCODE:0F1B		      pop     es
BIOSCODE:0F1C
BIOSCODE:0F1C ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0F1C
BIOSCODE:0F1C
BIOSCODE:0F1C TrackIo	      proc near		      ;	...
BIOSCODE:0F1C		      mov     ds:spsav,	sp    ;	performs track read/write/verify
BIOSCODE:0F1C					      ;
BIOSCODE:0F1C					      ;	 input:
BIOSCODE:0F1C					      ;	  rFlag	- 2 = read
BIOSCODE:0F1C					      ;		  3 = write
BIOSCODE:0F1C					      ;		  4 = verify
BIOSCODE:0F1C					      ;	  ax - Index into track	table of first sector to io
BIOSCODE:0F1C					      ;	  cx - Number of sectors to io
BIOSCODE:0F1C					      ;	  Xfer_Seg:bx -	Transfer address
BIOSCODE:0F1C					      ;	  es:di	- Pointer to bds
BIOSCODE:0F1C					      ;	  CurTrk - Current cylinder
BIOSCODE:0F1C					      ;	  CurHd	- Current head
BIOSCODE:0F20		      call    checksingle
BIOSCODE:0F23		      cmp     ds:media_set_for_format, 1 ; See if we have already set disk
BIOSCODE:0F28		      jz      short Dptalreadyset
BIOSCODE:0F2A		      push    ax	      ;	set up tables and variables for	i/o
BIOSCODE:0F2B		      push    cx
BIOSCODE:0F2C		      call    iosetup
BIOSCODE:0F2F		      pop     cx
BIOSCODE:0F30		      pop     ax
BIOSCODE:0F31
BIOSCODE:0F31 Dptalreadyset:			      ;	...
BIOSCODE:0F31		      mov     si, offset tracktable ; Point si at the table entry of the
BIOSCODE:0F31					      ;	first sector to	be io'd
BIOSCODE:0F34		      shl     ax, 1
BIOSCODE:0F36		      shl     ax, 1
BIOSCODE:0F38		      add     si, ax
BIOSCODE:0F3A		      mov     dx, 1
BIOSCODE:0F3D		      test    word ptr es:[di+23h], 8 ;	[es:di+BDS.flags], good_tracklayout
BIOSCODE:0F43		      jz      short IoNextSector
BIOSCODE:0F45		      xchg    dx, cx	      ;	We can read all	secs in	one blow
BIOSCODE:0F47
BIOSCODE:0F47 IoNextSector:			      ;	...
BIOSCODE:0F47		      push    cx
BIOSCODE:0F48		      push    dx
BIOSCODE:0F49		      inc     si
BIOSCODE:0F4A		      inc     si	      ;	Skip over the cylinder and head	in
BIOSCODE:0F4A					      ;	the track table
BIOSCODE:0F4B		      lodsb		      ;	Get sector ID from track table
BIOSCODE:0F4C		      mov     ds:cursec, al
BIOSCODE:0F4F		      test    word ptr es:[di+23h], 1 ;	[es:di+BDS.flags], fnon_removable
BIOSCODE:0F4F					      ;	Fixed disk?
BIOSCODE:0F55		      jz      short IoRemovable	; No
BIOSCODE:0F57		      test    ds:multrk_flag, 80h ; MULTI_TRK_ON
BIOSCODE:0F5D		      jz      short IoRemovable	; No,don't do that.
BIOSCODE:0F5F		      mov     ds:seccnt, dx
BIOSCODE:0F63		      mov     ax, dx
BIOSCODE:0F65		      call    disk
BIOSCODE:0F68		      pop     dx
BIOSCODE:0F69		      pop     cx
BIOSCODE:0F6A		      clc
BIOSCODE:0F6B		      retn
BIOSCODE:0F6C ;	---------------------------------------------------------------------------
BIOSCODE:0F6C
BIOSCODE:0F6C IoRemovable:			      ;	...
BIOSCODE:0F6C		      lodsb		      ;	Get sector size	index from track
BIOSCODE:0F6C					      ;	table and save it
BIOSCODE:0F6D		      push    ax
BIOSCODE:0F6E		      push    si
BIOSCODE:0F6F		      push    ds	      ;	Save BIOSDATA
BIOSCODE:0F70		      push    ax
BIOSCODE:0F71		      mov     ah, ds:eot      ;	Preserve whatever might	be in ah
BIOSCODE:0F71					      ;	Fetch EOT while	ds-> BIOSDATA
BIOSCODE:0F75		      lds     si, ds:dpt
BIOSCODE:0F79		      mov     [si+3], al      ;	[si+DISK_PARMS.DISK_SECTOR_SIZ]
BIOSCODE:0F7C		      mov     [si+4], ah      ;	[si+DISK_PARMS.DISK_EOT]
BIOSCODE:0F7F		      pop     ax
BIOSCODE:0F80		      pop     ds
BIOSCODE:0F81		      mov     al, dl
BIOSCODE:0F83		      mov     ds:seccnt, ax
BIOSCODE:0F86		      call    disk
BIOSCODE:0F89		      pop     si	      ;	Advance	buffer pointer by adding
BIOSCODE:0F89					      ;	sector size
BIOSCODE:0F8A		      pop     ax
BIOSCODE:0F8B		      call    SectorSizeIndexToSectorSize
BIOSCODE:0F8E		      add     bx, ax
BIOSCODE:0F90		      pop     dx
BIOSCODE:0F91		      pop     cx
BIOSCODE:0F92		      loop    IoNextSector
BIOSCODE:0F94		      cmp     ds:media_set_for_format, 1
BIOSCODE:0F99		      jz      short NoNeedDone
BIOSCODE:0F9B		      call    done
BIOSCODE:0F9E
BIOSCODE:0F9E NoNeedDone:			      ;	...
BIOSCODE:0F9E		      clc
BIOSCODE:0F9F		      retn
BIOSCODE:0F9F TrackIo	      endp
BIOSCODE:0F9F
BIOSCODE:0FA0
BIOSCODE:0FA0 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0FA0
BIOSCODE:0FA0
BIOSCODE:0FA0 SectSizeToSectIndex proc near	      ;	...
BIOSCODE:0FA0		      cmp     ah, 2	      ;	(0=>128,1=>256,2=>512,3=>1024)
BIOSCODE:0FA0					      ;	 examine upper byte only
BIOSCODE:0FA3		      ja      short OneK
BIOSCODE:0FA5		      mov     al, ah	      ;	value in ah is the index!
BIOSCODE:0FA7		      retn
BIOSCODE:0FA8 ;	---------------------------------------------------------------------------
BIOSCODE:0FA8
BIOSCODE:0FA8 OneK:				      ;	...
BIOSCODE:0FA8		      mov     al, 3
BIOSCODE:0FAA		      retn
BIOSCODE:0FAA SectSizeToSectIndex endp
BIOSCODE:0FAA
BIOSCODE:0FAB
BIOSCODE:0FAB ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0FAB
BIOSCODE:0FAB
BIOSCODE:0FAB SectorSizeIndexToSectorSize proc near   ;	...
BIOSCODE:0FAB		      mov     cl, al
BIOSCODE:0FAD		      mov     ax, 80h
BIOSCODE:0FB0		      shl     ax, cl
BIOSCODE:0FB2		      retn
BIOSCODE:0FB2 SectorSizeIndexToSectorSize endp
BIOSCODE:0FB2
BIOSCODE:0FB3
BIOSCODE:0FB3 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:0FB3
BIOSCODE:0FB3
BIOSCODE:0FB3 SetDasd	      proc near		      ;	...
BIOSCODE:0FB3		      cmp     ds:had_format_error, 1 ; See if we've previously set dasd type
BIOSCODE:0FB8		      jz      short DoSetDasd
BIOSCODE:0FBA		      test    word ptr es:[di+23h], 80h	; [es:di+BDS.flags], set_dasd_true
BIOSCODE:0FC0		      jz      short DasdHasBeenSet
BIOSCODE:0FC2		      and     word ptr es:[di+23h], 0FF7Fh ; [es:di+BDS.flags],	~set_dasd_true
BIOSCODE:0FC8
BIOSCODE:0FC8 DoSetDasd:			      ;	...
BIOSCODE:0FC8		      mov     ds:had_format_error, 0 ; Reset it
BIOSCODE:0FCD		      mov     ds:gap_patch, 50h	; Format gap for 48tpi disks
BIOSCODE:0FD2		      mov     al, 4
BIOSCODE:0FD4		      cmp     byte ptr es:[di+22h], 2 ;	[es:di+BDS.formfactor],	DEV_3INCH720KB
BIOSCODE:0FD9		      jz      short DoSet
BIOSCODE:0FDB		      cmp     byte ptr es:[di+22h], 1 ;	[es:di+BDS.formfactor],	DEV_5INCH96TPI
BIOSCODE:0FE0		      jz      short GotBig
BIOSCODE:0FE2		      mov     al, 1
BIOSCODE:0FE4		      jmp     short DoSet
BIOSCODE:0FE6 ;	---------------------------------------------------------------------------
BIOSCODE:0FE6
BIOSCODE:0FE6 GotBig:				      ;	...
BIOSCODE:0FE6		      mov     al, 2	      ;	160/320k in a 1.2 meg drive
BIOSCODE:0FE8		      cmp     ds:mediatype, 0
BIOSCODE:0FED		      jnz     short DoSet
BIOSCODE:0FEF		      mov     al, 3	      ;	1.2meg in a 1.2meg drive
BIOSCODE:0FF1		      mov     ds:gap_patch, 54h	; Format gap for 96 tpi, 1.2MB diskette
BIOSCODE:0FF6
BIOSCODE:0FF6 DoSet:				      ;	...
BIOSCODE:0FF6		      push    ds
BIOSCODE:0FF7		      push    si
BIOSCODE:0FF8		      mov     ds, ds:zeroseg
BIOSCODE:0FFC		      assume ds:nothing
BIOSCODE:0FFC		      lds     si, dword	ptr ds:78h ; [DSKADR] (Int 1Eh)
BIOSCODE:1000		      assume ds:nothing
BIOSCODE:1000		      mov     byte ptr [si+9], 0Fh ; [si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:1004		      pop     si
BIOSCODE:1005		      pop     ds
BIOSCODE:1006		      mov     ah, 17h
BIOSCODE:1008		      mov     dl, es:[di+4]
BIOSCODE:100C		      int     13h	      ;	DISK - SET TYPE	(AT,XT2,XT286,CONV,PS
BIOSCODE:100C					      ;	AL = disk type
BIOSCODE:100E
BIOSCODE:100E DasdHasBeenSet:			      ;	...
BIOSCODE:100E		      mov     ah, es:[di+13h] ;	[es:di+BDS.secpertrack]
BIOSCODE:1012		      mov     ds:formt_eot, ah
BIOSCODE:1016		      retn
BIOSCODE:1016 SetDasd	      endp
BIOSCODE:1016
BIOSCODE:1017
BIOSCODE:1017 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1017
BIOSCODE:1017
BIOSCODE:1017 SetMediaForFormat	proc near	      ;	...
BIOSCODE:1017		      push    cx
BIOSCODE:1018		      push    dx
BIOSCODE:1019		      cmp     ds:had_format_error, 1
BIOSCODE:101E		      jz      short SkipSaveDskAdr
BIOSCODE:1020		      xor     al, al	      ;	If already done	return 0
BIOSCODE:1022		      cmp     ds:media_set_for_format, 1
BIOSCODE:1027		      jnz     short DoSetMediaForFormat
BIOSCODE:1029		      jmp     SetMediaRet     ;	Media already set
BIOSCODE:102C ;	---------------------------------------------------------------------------
BIOSCODE:102C
BIOSCODE:102C DoSetMediaForFormat:		      ;	...
BIOSCODE:102C		      push    es
BIOSCODE:102D		      push    si
BIOSCODE:102E		      mov     es, ds:zeroseg  ;	0 ; Point to interrupt vectors
BIOSCODE:1032		      assume es:nothing
BIOSCODE:1032		      les     si, dword	ptr es:78h ; [es:DSKADR]
BIOSCODE:1032					      ;	Get pointer to disk base table
BIOSCODE:1037		      assume es:nothing
BIOSCODE:1037		      mov     word ptr ds:dpt, si
BIOSCODE:103B		      mov     word ptr ds:dpt+2, es
BIOSCODE:103F		      mov     byte ptr es:[si+9], 0Fh ;	[es:si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:1044		      pop     si
BIOSCODE:1045		      pop     es
BIOSCODE:1046
BIOSCODE:1046 SkipSaveDskAdr:			      ;	...
BIOSCODE:1046		      mov     cx, es:[di+25h] ;	[es:di+BDS.cylinders]
BIOSCODE:104A		      dec     cx
BIOSCODE:104B		      and     ch, 3
BIOSCODE:104E		      ror     ch, 1
BIOSCODE:1050		      ror     ch, 1
BIOSCODE:1052		      xchg    ch, cl
BIOSCODE:1054		      or      cl, es:[di+13h] ;	[es:di+BDS.secpertrack]
BIOSCODE:1058		      mov     dl, es:[di+4]   ;	[es:di+BDS.drivenum]
BIOSCODE:105C		      push    es
BIOSCODE:105D		      push    ds
BIOSCODE:105E		      push    si
BIOSCODE:105F		      push    di
BIOSCODE:1060		      mov     ah, 18h
BIOSCODE:1062		      int     13h	      ;	DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)
BIOSCODE:1062					      ;	DL = drive number, CH =	lower 8	bits of	number of tracks,
BIOSCODE:1062					      ;	CL = sectors per track
BIOSCODE:1064		      jb      short FormaStatErr
BIOSCODE:1066		      cmp     ds:had_format_error, 1
BIOSCODE:106B		      jz      short skip_disk_base_setting
BIOSCODE:106D		      push    es
BIOSCODE:106E		      mov     es, ds:zeroseg  ;	0
BIOSCODE:1072		      assume es:nothing
BIOSCODE:1072		      les     si, dword	ptr es:78h ; [es:DSKADR] (Int 1Eh)
BIOSCODE:1072					      ;	Get current disk base table
BIOSCODE:1077		      assume es:nothing
BIOSCODE:1077		      mov     word ptr ds:tempdpt, si
BIOSCODE:107B		      mov     word ptr ds:tempdpt+2, es	; Save it
BIOSCODE:107F		      mov     es, ds:zeroseg  ;	0
BIOSCODE:1083		      assume es:nothing
BIOSCODE:1083		      mov     word ptr es:78h, di
BIOSCODE:1088		      pop     word ptr es:fsetowner
BIOSCODE:108D		      mov     ds:media_set_for_format, 1
BIOSCODE:1092
BIOSCODE:1092 skip_disk_base_setting:		      ;	...
BIOSCODE:1092		      xor     al, al	      ;	Legal combination + rom	support	code
BIOSCODE:1094		      mov     ds:had_format_error, al ;	Reset the flag
BIOSCODE:1097		      jmp     short PopStatRet
BIOSCODE:1099 ;	---------------------------------------------------------------------------
BIOSCODE:1099
BIOSCODE:1099 FormaStatErr:			      ;	...
BIOSCODE:1099		      cmp     ah, 0Ch	      ;	DSK_ILLEGAL_COMBINATION
BIOSCODE:1099					      ;	Illegal	combination = 0Ch
BIOSCODE:109C		      jz      short FormatStatIllegalComb
BIOSCODE:109E		      cmp     ah, 80h	      ;	DSK_TIMEOUT_ERR
BIOSCODE:10A1		      jz      short FormatStatTimeOut
BIOSCODE:10A3		      mov     al, 1	      ;	Function not supported.
BIOSCODE:10A5		      jmp     short PopStatRet
BIOSCODE:10A7 ;	---------------------------------------------------------------------------
BIOSCODE:10A7
BIOSCODE:10A7 FormatStatIllegalComb:		      ;	...
BIOSCODE:10A7		      mov     al, 2	      ;	Function supported, but
BIOSCODE:10A7					      ;	Illegal	sect/trk,trk combination.
BIOSCODE:10A9		      jmp     short PopStatRet
BIOSCODE:10AB ;	---------------------------------------------------------------------------
BIOSCODE:10AB
BIOSCODE:10AB FormatStatTimeOut:		      ;	...
BIOSCODE:10AB		      mov     al, 3	      ;	Function supported, but
BIOSCODE:10AB					      ;	Media not present
BIOSCODE:10AD
BIOSCODE:10AD PopStatRet:			      ;	...
BIOSCODE:10AD		      pop     di
BIOSCODE:10AE		      pop     si
BIOSCODE:10AF		      pop     ds
BIOSCODE:10B0		      pop     es
BIOSCODE:10B1		      assume es:nothing
BIOSCODE:10B1
BIOSCODE:10B1 SetMediaRet:			      ;	...
BIOSCODE:10B1		      pop     dx
BIOSCODE:10B2		      pop     cx
BIOSCODE:10B3		      retn
BIOSCODE:10B3 SetMediaForFormat	endp
BIOSCODE:10B3
BIOSCODE:10B4
BIOSCODE:10B4 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:10B4
BIOSCODE:10B4
BIOSCODE:10B4 resetdisk	      proc near		      ;	...
BIOSCODE:10B4		      push    ax
BIOSCODE:10B5		      cmp     ds:media_set_for_format, 1 ; Reset while formatting?
BIOSCODE:10BA		      jnz     short ResetDisk_cont
BIOSCODE:10BC		      mov     ds:had_format_error, 1 ; Then verify operation in	"fmt & vrfy"
BIOSCODE:10BC					      ;	Might have failed.
BIOSCODE:10BC					      ;	So signals that	we had a format	error.
BIOSCODE:10C1
BIOSCODE:10C1 ResetDisk_cont:			      ;	...
BIOSCODE:10C1		      xor     ah, ah
BIOSCODE:10C3		      int     13h	      ;	DISK - RESET DISK SYSTEM
BIOSCODE:10C3					      ;	DL = drive (if bit 7 is	set both hard disks and	floppy disks reset)
BIOSCODE:10C5		      mov     ds:step_drv, 0FFh	; -1
BIOSCODE:10C5					      ;	Zap up the speed
BIOSCODE:10CA		      pop     ax
BIOSCODE:10CB		      retn
BIOSCODE:10CB resetdisk	      endp
BIOSCODE:10CB
BIOSCODE:10CC
BIOSCODE:10CC ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:10CC
BIOSCODE:10CC
BIOSCODE:10CC ToRom	      proc near		      ;	...
BIOSCODE:10CC		      push    bx
BIOSCODE:10CD		      push    si
BIOSCODE:10CE		      test    ds:media_set_for_format, 1
BIOSCODE:10D3		      jnz     short GotValidDpt
BIOSCODE:10D5		      push    ax
BIOSCODE:10D6		      push    es	      ;	Save bds segment
BIOSCODE:10D7		      cmp     byte ptr es:[di+22h], 2 ;	[es:di+BDS.formfactor],	ffSmall
BIOSCODE:10D7					      ;	is it a	3.5" drive?
BIOSCODE:10DC		      pushf
BIOSCODE:10DD		      mov     es, ds:zeroseg  ;	0
BIOSCODE:10E1		      assume es:nothing
BIOSCODE:10E1		      les     si, dword	ptr es:78h ; Get pointer to disk base table
BIOSCODE:10E6		      assume es:nothing
BIOSCODE:10E6		      mov     word ptr ds:dpt, si ; Save pointer to table
BIOSCODE:10EA		      mov     word ptr ds:dpt+2, es
BIOSCODE:10EE		      mov     al, ds:formt_eot
BIOSCODE:10F1		      mov     es:[si+4], al   ;	[es:si+DISK_PARMS.DISK_EOT]
BIOSCODE:10F5		      mov     al, ds:gap_patch
BIOSCODE:10F8		      mov     es:[si+7], al   ;	[es:si+DISK_PARMS.DISK_FORMT_GAP]
BIOSCODE:10F8					      ;	Important for format
BIOSCODE:10FC		      mov     byte ptr es:[si+9], 0Fh ;	[es:si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:10FC					      ;	Assume we are doing a seek operation
BIOSCODE:10FC					      ;	Setup motor start correctly for	3.5" drives
BIOSCODE:1101		      popf
BIOSCODE:1102		      jnz     short MotorStrtOK
BIOSCODE:1104		      mov     byte ptr es:[si+0Ah], 4 ;	[es:si+DISK_PARMS.DISK_MOTOR_STRT]
BIOSCODE:1109
BIOSCODE:1109 MotorStrtOK:			      ;	...
BIOSCODE:1109		      pop     es	      ;	Restore	bds segment
BIOSCODE:110A		      pop     ax
BIOSCODE:110B
BIOSCODE:110B GotValidDpt:			      ;	...
BIOSCODE:110B		      mov     dx, ds:trknum   ;	Set track number
BIOSCODE:110F		      mov     ch, dl	      ;	Set low	8 bits in ch
BIOSCODE:1111		      mov     dl, es:[di+4]   ;	Set drive number
BIOSCODE:1115		      mov     dh, ds:hdnum    ;	Set head number
BIOSCODE:1119		      push    es	      ;	Save bds segment
BIOSCODE:111A		      mov     es, word ptr ds:537h
BIOSCODE:111E		      int     13h	      ;	DISK -
BIOSCODE:1120		      pop     es	      ;	Restore	bds segment
BIOSCODE:1121		      pop     si
BIOSCODE:1122		      pop     bx
BIOSCODE:1123		      retn
BIOSCODE:1123 ToRom	      endp
BIOSCODE:1123
BIOSCODE:1124
BIOSCODE:1124 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1124
BIOSCODE:1124
BIOSCODE:1124 ioctl_getown    proc near		      ;	...
BIOSCODE:1124		      call    SetDrive
BIOSCODE:1127		      mov     al, es:[di+4]   ;	[es:di+BDS.drivenum]
BIOSCODE:1127					      ;	Get physical drive number
BIOSCODE:112B		      les     di, dword	ptr ds:start_bds ; Get start of	bds chain
BIOSCODE:112F
BIOSCODE:112F OwnLoop:				      ;	...
BIOSCODE:112F		      cmp     es:[di+4], al   ;	[es:di+BDS.drivenum]
BIOSCODE:1133		      jnz     short getnextBDS
BIOSCODE:1135		      test    word ptr es:[di+23h], 20h	; [es:di+BDS.flags], fi_own_physical
BIOSCODE:113B		      jnz     short ExitOwn
BIOSCODE:113D
BIOSCODE:113D getnextBDS:			      ;	...
BIOSCODE:113D		      les     di, es:[di]     ;	[es:di+BDS.link]
BIOSCODE:1140		      jmp     short OwnLoop
BIOSCODE:1142 ;	---------------------------------------------------------------------------
BIOSCODE:1142
BIOSCODE:1142 ioctl_setown:			      ;	...
BIOSCODE:1142		      call    SetDrive
BIOSCODE:1145		      mov     ds:fsetowner, 1 ;	set flag for CheckSingle to look at.
BIOSCODE:114A		      call    checksingle
BIOSCODE:114D		      mov     ds:fsetowner, 0 ;	set ownership of drive reset flag
BIOSCODE:1152
BIOSCODE:1152 ExitOwn:				      ;	...
BIOSCODE:1152		      xor     cl, cl
BIOSCODE:1154		      test    word ptr es:[di+23h], 10h	; [es:di+BDS.flags], fi_am_mult
BIOSCODE:115A		      jz      short ExitNoMult
BIOSCODE:115C		      mov     cl, es:[di+5]   ;	[es:di+BDS.drivelet]
BIOSCODE:115C					      ;	Get logical drive number
BIOSCODE:1160		      inc     cl	      ;	Get it 1-based
BIOSCODE:1162
BIOSCODE:1162 ExitNoMult:			      ;	...
BIOSCODE:1162		      lds     bx, ds:ptrsav
BIOSCODE:1166		      mov     [bx+1], cl      ;	[bx+unit]
BIOSCODE:1166					      ;	Exit normal termination
BIOSCODE:1169		      clc
BIOSCODE:116A		      retn
BIOSCODE:116A ioctl_getown    endp
BIOSCODE:116A
BIOSCODE:116B
BIOSCODE:116B ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:116B
BIOSCODE:116B
BIOSCODE:116B RestoreOldDpt   proc near		      ;	...
BIOSCODE:116B		      push    ax
BIOSCODE:116C		      xor     al, al
BIOSCODE:116E		      mov     ds:had_format_error, al ;	Reset flag and
BIOSCODE:1171		      xchg    al, ds:media_set_for_format ; get	current	flag setting
BIOSCODE:1175		      or      al, al
BIOSCODE:1177		      jz      short DontRestore
BIOSCODE:1179		      push    si
BIOSCODE:117A		      push    ds
BIOSCODE:117B		      push    es
BIOSCODE:117C		      lds     si, ds:tempdpt
BIOSCODE:1180		      mov     es, cs:Bios_Data_Word
BIOSCODE:1185		      assume es:nothing
BIOSCODE:1185		      mov     es, es:zeroseg  ;	es = 0
BIOSCODE:118A		      assume es:nothing
BIOSCODE:118A		      mov     word ptr es:78h, si ; [es:DSKADR]	(Int 1Eh)
BIOSCODE:118F		      mov     word ptr es:78h+2, ds ; [es:DSKADR+2]
BIOSCODE:1194		      pop     es
BIOSCODE:1195		      assume es:nothing
BIOSCODE:1195		      pop     ds
BIOSCODE:1196		      pop     si
BIOSCODE:1197
BIOSCODE:1197 DontRestore:			      ;	...
BIOSCODE:1197		      pop     ax
BIOSCODE:1198		      clc
BIOSCODE:1199		      retn
BIOSCODE:1199 RestoreOldDpt   endp
BIOSCODE:1199
BIOSCODE:119A
BIOSCODE:119A ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:119A
BIOSCODE:119A
BIOSCODE:119A GetMediaId      proc near		      ;	...
BIOSCODE:119A		      call    ChangeLineChk
BIOSCODE:119D		      mov     al, es:[di+5]   ;	[es:di+BDS.drivelet] ; Logical drive number
BIOSCODE:11A1		      mov     ds:rflag,	2     ;	Read operation
BIOSCODE:11A6		      call    BootIo	      ;	Read boot sector into DiskSector
BIOSCODE:11A9		      jb      short IOCtl_If1
BIOSCODE:11AB		      cmp     ds:disksector+15h, 0F0h ;	Valid? (0F0h-0FFh?)
BIOSCODE:11B0		      jb      short IOCtl_If2 ;	brif not valid (0F0h - 0FFh)
BIOSCODE:11B2		      cmp     ds:disksector+26h, 29h ; disksector+EXT_BOOT.SIG
BIOSCODE:11B2					      ;	BS_BootSig
BIOSCODE:11B7		      jnz     short IOCtl_If2
BIOSCODE:11B9		      les     di, ds:ptrsav
BIOSCODE:11BD		      les     di, es:[bx+19]  ;	[es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:11C1		      mov     si, (offset disksector+27h) ; BS_VolID
BIOSCODE:11C4		      add     di, 2	      ;	A_MEDIA_ID_INFO.MI_SERIAL
BIOSCODE:11C7		      mov     cx, 23	      ;	+size_of_EXT_BOOT_VOL_LABEL
BIOSCODE:11C7					      ;	+size_of_EXT_SYSTEM_ID
BIOSCODE:11CA		      rep movsb
BIOSCODE:11CC		      clc
BIOSCODE:11CD		      retn
BIOSCODE:11CE ;	---------------------------------------------------------------------------
BIOSCODE:11CE
BIOSCODE:11CE IOCtl_If2:			      ;	...
BIOSCODE:11CE		      mov     al, 7
BIOSCODE:11D0		      stc
BIOSCODE:11D1
BIOSCODE:11D1 IOCtl_If1:			      ;	...
BIOSCODE:11D1		      retn
BIOSCODE:11D1 GetMediaId      endp
BIOSCODE:11D1
BIOSCODE:11D2 ;	---------------------------------------------------------------------------
BIOSCODE:11D2
BIOSCODE:11D2 SetMediaId:			      ;	...
BIOSCODE:11D2		      call    ChangeLineChk
BIOSCODE:11D5		      mov     al, es:[di+5]   ;	[es:di+BDS.drivelet]
BIOSCODE:11D5					      ;	Logical	drive number
BIOSCODE:11D9		      mov     dl, al
BIOSCODE:11DB		      mov     ds:rflag,	2     ;	romread
BIOSCODE:11E0		      push    dx
BIOSCODE:11E1		      call    BootIo	      ;	Read boot sector to BIOSDATA:DiskSector
BIOSCODE:11E4		      pop     dx
BIOSCODE:11E5		      jb      short IOCtl_If6
BIOSCODE:11E7		      cmp     ds:disksector+15h, 0F0h ;	Valid? (0F0h-0FFh?)
BIOSCODE:11E7					      ;	[disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
BIOSCODE:11EC		      jb      short IOCtl_If7
BIOSCODE:11EE		      cmp     ds:disksector+26h, 29h
BIOSCODE:11F3		      jnz     short IOCtl_If7
BIOSCODE:11F5		      push    es
BIOSCODE:11F6		      push    di
BIOSCODE:11F7		      push    ds
BIOSCODE:11F8		      pop     es
BIOSCODE:11F9		      mov     di, (offset disksector+27h) ; disksector+EXT_BOOT.SERIAL
BIOSCODE:11FC		      lds     si, ds:ptrsav
BIOSCODE:1200		      lds     si, [si+13h]
BIOSCODE:1203		      add     si, 2
BIOSCODE:1206		      mov     cx, 23	      ;	copy volume serial, label and system id
BIOSCODE:1206					      ;	cx = 23	= size_of_EXT_BOOT_SERIAL
BIOSCODE:1206					      ;		+ size_of_EXT_BOOT_VOL_LABEL
BIOSCODE:1206					      ;		+ size_of_EXT_SYSTEM_ID
BIOSCODE:1209		      rep movsb
BIOSCODE:120B		      push    es	      ;	point ds back to BIOSDATA
BIOSCODE:120C		      pop     ds
BIOSCODE:120D		      pop     di	      ;	restore	bds pointer
BIOSCODE:120E		      pop     es
BIOSCODE:120F		      call    mov_media_ids   ;	update the bds media id	info.
BIOSCODE:1212		      mov     al, dl
BIOSCODE:1214		      mov     ds:rflag,	3     ;	romwrite
BIOSCODE:1219		      call    BootIo	      ;	write it back
BIOSCODE:121C		      mov     ds:tim_drv, 0FFh ; make sure chk_media check the driver
BIOSCODE:121C					      ;	return with error code from BootIo
BIOSCODE:1221		      retn
BIOSCODE:1222 ;	---------------------------------------------------------------------------
BIOSCODE:1222
BIOSCODE:1222 IOCtl_If7:			      ;	...
BIOSCODE:1222		      mov     al, 7	      ;	error_unknown_media
BIOSCODE:1224		      stc
BIOSCODE:1225
BIOSCODE:1225 IOCtl_If6:			      ;	...
BIOSCODE:1225		      retn
BIOSCODE:1226
BIOSCODE:1226 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1226
BIOSCODE:1226
BIOSCODE:1226 BootIo	      proc near		      ;	...
BIOSCODE:1226		      push    es
BIOSCODE:1227		      push    di
BIOSCODE:1228		      push    bx
BIOSCODE:1229		      push    ds
BIOSCODE:122A		      pop     es
BIOSCODE:122B		      mov     di, offset disksector ; es:di -> transfer	address
BIOSCODE:122E		      xor     dx, dx	      ;	First sector (h) -> 0
BIOSCODE:1230		      mov     ds:start_sec_h, dx ; Start sector	(h) -> 0
BIOSCODE:1234		      mov     cx, 1
BIOSCODE:1237		      call    diskio
BIOSCODE:123A		      pop     bx
BIOSCODE:123B		      pop     di
BIOSCODE:123C		      pop     es
BIOSCODE:123D		      retn
BIOSCODE:123D BootIo	      endp
BIOSCODE:123D
BIOSCODE:123E
BIOSCODE:123E ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:123E
BIOSCODE:123E
BIOSCODE:123E ChangeLineChk   proc near		      ;	...
BIOSCODE:123E		      mov     dl, es:[di+4]   ;	[es:di+BDS.drivenum]
BIOSCODE:1242		      or      dl, dl	      ;	Fixed disk?
BIOSCODE:1244		      js      short ChangeLnChkRet
BIOSCODE:1246		      test    word ptr es:[di+23h], 4 ;	[es:di+BDS.flags], return_fake_bpb
BIOSCODE:124C		      jnz     short ChangeLnChkRet
BIOSCODE:124E		      cmp     ds:fhave96, 1   ;	This rom support change	line?
BIOSCODE:1253		      jnz     short ChangeLnChkRet ; no
BIOSCODE:1255		      call    HasChange	      ;	This drive support change line?
BIOSCODE:1258		      jz      short ChangeLnChkRet ; Do	nothing
BIOSCODE:125A		      mov     ah, 16h
BIOSCODE:125C		      int     13h	      ;	DISK -
BIOSCODE:125E		      jnb     short ChangeLnChkRet
BIOSCODE:1260		      push    bx
BIOSCODE:1261		      mov     bx, 40h	      ;	fchanged
BIOSCODE:1261					      ;	Update flag in BDS for this physical drive
BIOSCODE:1264		      call    Set_Changed_DL
BIOSCODE:1267		      pop     bx
BIOSCODE:1268
BIOSCODE:1268 ChangeLnChkRet:			      ;	...
BIOSCODE:1268		      retn
BIOSCODE:1268 ChangeLineChk   endp
BIOSCODE:1268
BIOSCODE:1269 ;	---------------------------------------------------------------------------
BIOSCODE:1269
BIOSCODE:1269 GetAccessFlag:			      ;	...
BIOSCODE:1269		      lds     bx, ds:ptrsav   ;	ds:bx points to	request	header
BIOSCODE:126D		      lds     bx, [bx+13h]    ;	[bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:1270		      mov     al, 0	      ;	Assume result is unformatted
BIOSCODE:1272		      test    word ptr es:[di+23h], 200h ; [es:di+BDS.flags], unformatted_media
BIOSCODE:1278		      jnz     short GafDone   ;	Done if	unformatted
BIOSCODE:127A		      inc     al	      ;	Return true for	formatted
BIOSCODE:127C
BIOSCODE:127C GafDone:				      ;	...
BIOSCODE:127C		      mov     [bx+1], al      ;	[bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
BIOSCODE:127F		      retn
BIOSCODE:1280 ;	---------------------------------------------------------------------------
BIOSCODE:1280
BIOSCODE:1280 SetAccessFlag:			      ;	...
BIOSCODE:1280		      lds     bx, ds:12h      ;	ds:bx points to	request	header
BIOSCODE:1284		      lds     bx, [bx+13h]    ;	[bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:1287		      and     word ptr es:[di+23h], 0FDFFh ; [es:di+BDS.flags],	~unformatted_media
BIOSCODE:128D		      cmp     byte ptr [bx+1], 0 ; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
BIOSCODE:1291		      jnz     short saf_Done
BIOSCODE:1293		      or      word ptr es:[di+23h], 200h ; [es:di+BDS.flags], unformatted_media
BIOSCODE:1299
BIOSCODE:1299 saf_Done:				      ;	...
BIOSCODE:1299		      retn
BIOSCODE:129A ;	---------------------------------------------------------------------------
BIOSCODE:129A
BIOSCODE:129A ioctl_support_query:		      ;	...
BIOSCODE:129A		      push    es
BIOSCODE:129B		      les     bx, ds:ptrsav   ;	es:bx points to	request	header.
BIOSCODE:129F		      mov     ax, es:[bx+0Dh] ;	[es:bx+IOCTL_REQ.MAJORFUNCTION]
BIOSCODE:129F					      ;	al == Major, ah	== Minor
BIOSCODE:12A3		      cmp     al, 8	      ;	IOC_DC
BIOSCODE:12A5		      jnz     short NoSupport
BIOSCODE:12A7		      push    cs
BIOSCODE:12A8		      pop     es
BIOSCODE:12A9		      assume es:BIOSCODE
BIOSCODE:12A9		      mov     cx, 11	      ;	IOC_DC_TABLE_LEN
BIOSCODE:12AC		      mov     di, offset IOC_DC_Table
BIOSCODE:12AF		      xchg    al, ah
BIOSCODE:12B1		      repne scasb
BIOSCODE:12B3		      jnz     short NoSupport
BIOSCODE:12B5		      mov     ax, 100h
BIOSCODE:12B8		      jmp     short $+2
BIOSCODE:12BA ;	---------------------------------------------------------------------------
BIOSCODE:12BA
BIOSCODE:12BA ioctl_support:			      ;	...
BIOSCODE:12BA		      pop     es
BIOSCODE:12BB		      assume es:nothing
BIOSCODE:12BB		      clc
BIOSCODE:12BC		      retn
BIOSCODE:12BD ;	---------------------------------------------------------------------------
BIOSCODE:12BD
BIOSCODE:12BD NoSupport:			      ;	...
BIOSCODE:12BD		      pop     es
BIOSCODE:12BE		      jmp     bc_cmderr
BIOSCODE:12C1 ;	---------------------------------------------------------------------------
BIOSCODE:12C1
BIOSCODE:12C1 SenseMediaType:			      ;	...
BIOSCODE:12C1		      lds     bx, ds:ptrsav   ;	s:bx points to request header.
BIOSCODE:12C5		      lds     bx, [bx+13h]    ;	[bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:12C8		      mov     word ptr [bx], 0 ; 0 ; Initialize	the 2 packet bytes
BIOSCODE:12C8					      ;	invalidate drive type (byte 1)
BIOSCODE:12C8					      ;	and default type flag (byte 0)
BIOSCODE:12CC		      mov     dl, es:[di+4]   ;	[es:di+BDS.drivenum]
BIOSCODE:12D0		      xor     dh, dh
BIOSCODE:12D2		      mov     ah, 20h
BIOSCODE:12D4		      int     13h	      ;	Compaq,	ATAPI Removable	Media Device
BIOSCODE:12D4					      ;	GET CURRENT MEDIA FORMAT
BIOSCODE:12D4					      ;	  AH = 20h
BIOSCODE:12D4					      ;	  DL = drive number (00h,01h)
BIOSCODE:12D4					      ;	Return:	CF clear if successful
BIOSCODE:12D4					      ;	  AL = media type
BIOSCODE:12D4					      ;	  AH = 00h
BIOSCODE:12D4					      ;	  CF set on error
BIOSCODE:12D4					      ;	     AH	= error	code
BIOSCODE:12D4					      ;
BIOSCODE:12D4					      ;	(Ref: Ralf Interrupt List, INTERRUP.B)
BIOSCODE:12D6		      jb      short MediaSenseErr
BIOSCODE:12D8		      inc     byte ptr [bx]   ;	[bx+A_MEDIA_SENSE.MS_ISDEFAULT]
BIOSCODE:12D8					      ;	1 = default media type
BIOSCODE:12DA
BIOSCODE:12DA DetermineMediaType:		      ;	...
BIOSCODE:12DA		      dec     al	      ;	3 -> 2,	4 -> 3,	6 -> 5
BIOSCODE:12DC		      cmp     al, 2	      ;	3.5 inch, 720 KB
BIOSCODE:12DE		      jz      short GotMediaType
BIOSCODE:12E0		      add     al, 4	      ;	3 -> 6,	4 -> 7,	6 -> 9
BIOSCODE:12E2		      cmp     al, 7	      ;	3.5 inch, 1.44 MB
BIOSCODE:12E4		      jz      short GotMediaType
BIOSCODE:12E6		      cmp     al, 9	      ;	3.5 inch, 2.88 MB
BIOSCODE:12E8		      jnz     short UnknownMediaType ; Just didn't recognize media type
BIOSCODE:12EA
BIOSCODE:12EA GotMediaType:			      ;	...
BIOSCODE:12EA		      mov     [bx+1], al      ;	[bx+A_MEDIA_SENSE.MS_DEVICETYPE]
BIOSCODE:12ED		      clc
BIOSCODE:12EE		      retn
BIOSCODE:12EF ;	---------------------------------------------------------------------------
BIOSCODE:12EF
BIOSCODE:12EF MediaSenseErr:			      ;	...
BIOSCODE:12EF		      cmp     ah, 32h	      ;	non-default media /
BIOSCODE:12EF					      ;	drive does not support media type
BIOSCODE:12F2		      jz      short DetermineMediaType
BIOSCODE:12F4		      mov     al, 2	      ;	function supported but,	drive not ready
BIOSCODE:12F6		      cmp     ah, 31h	      ;	no such	drive /	media not present
BIOSCODE:12F9		      jz      short SenseErrExit
BIOSCODE:12FB
BIOSCODE:12FB UnknownMediaType:			      ;	...
BIOSCODE:12FB		      mov     al, 7	      ;	error_unknown_media
BIOSCODE:12FD
BIOSCODE:12FD SenseErrExit:			      ;	...
BIOSCODE:12FD		      mov     ah, 81h	      ;	Return this status in case of carry
BIOSCODE:12FF		      stc
BIOSCODE:1300		      retn
BIOSCODE:1300 ;	---------------------------------------------------------------------------
BIOSCODE:1301		      db    0
BIOSCODE:1302 ;	---------------------------------------------------------------------------
BIOSCODE:1302
BIOSCODE:1302 i2f_handler:			      ;	...
BIOSCODE:1302		      cmp     ah, 13h
BIOSCODE:1305		      jz      short int2f_replace_int13
BIOSCODE:1307		      cmp     ah, 8
BIOSCODE:130A		      jz      short mine
BIOSCODE:130C		      cmp     ah, 16h
BIOSCODE:130F		      jz      short win386call
BIOSCODE:1311		      cmp     ah, 4Ah
BIOSCODE:1314		      jnz     short i2f_handler_iret
BIOSCODE:1316		      jmp     handle_multmult
BIOSCODE:1319 ;	---------------------------------------------------------------------------
BIOSCODE:1319
BIOSCODE:1319 i2f_handler_iret:			      ;	...
BIOSCODE:1319		      iret
BIOSCODE:131A ;	---------------------------------------------------------------------------
BIOSCODE:131A
BIOSCODE:131A int2f_replace_int13:		      ;	...
BIOSCODE:131A		      push    ax
BIOSCODE:131B		      mov     ax, ds
BIOSCODE:131D		      mov     ds, cs:Bios_Data_Word
BIOSCODE:1322		      assume ds:nothing
BIOSCODE:1322		      push    word ptr ds:Orig13
BIOSCODE:1326		      push    word ptr ds:Orig13+2
BIOSCODE:132A		      push    word ptr ds:Old13
BIOSCODE:132E		      push    word ptr ds:Old13+2
BIOSCODE:1332		      mov     word ptr ds:Orig13, dx
BIOSCODE:1336		      mov     word ptr ds:Orig13+2, ax
BIOSCODE:1339		      mov     word ptr ds:Old13, bx
BIOSCODE:133D		      mov     word ptr ds:Old13+2, es
BIOSCODE:1341		      pop     es
BIOSCODE:1342		      pop     bx
BIOSCODE:1343		      pop     ds
BIOSCODE:1344		      assume ds:nothing
BIOSCODE:1344		      pop     dx
BIOSCODE:1345		      pop     ax
BIOSCODE:1346
BIOSCODE:1346 i2f_iret:				      ;	...
BIOSCODE:1346		      iret
BIOSCODE:1347 ;	---------------------------------------------------------------------------
BIOSCODE:1347
BIOSCODE:1347 mine:				      ;	...
BIOSCODE:1347		      cmp     al, 0F8h	      ;	iret on	reserved functions
BIOSCODE:1349		      jnb     short i2f_iret
BIOSCODE:134B		      or      al, al	      ;	a get installed	state request?
BIOSCODE:134D		      jnz     short disp_func
BIOSCODE:134F		      mov     al, 0FFh
BIOSCODE:1351		      jmp     short i2f_iret
BIOSCODE:1353 ;	---------------------------------------------------------------------------
BIOSCODE:1353
BIOSCODE:1353 disp_func:			      ;	...
BIOSCODE:1353		      cmp     al, 1	      ;	request	for installing bds?
BIOSCODE:1355		      jz      short do_subfun_01
BIOSCODE:1357		      cmp     al, 3	      ;	get bds	vector?
BIOSCODE:1359		      jz      short do_get_bds_vector
BIOSCODE:135B		      push    ds
BIOSCODE:135C		      mov     ds, cs:Bios_Data_Word
BIOSCODE:1361		      assume ds:nothing
BIOSCODE:1361		      mov     word ptr ds:ptrsav, bx
BIOSCODE:1365		      mov     word ptr ds:ptrsav+2, es
BIOSCODE:1369		      pop     ds
BIOSCODE:136A		      assume ds:nothing
BIOSCODE:136A		      jmp     far ptr 70h:898h ; BIOSDATA:dsk_entry
BIOSCODE:136A					      ;
BIOSCODE:136A					      ;	NOTE: jump to a	FAR function, not an
BIOSCODE:136A					      ;	IRET type function. Callers of
BIOSCODE:136A					      ;	this int2f subfunction will have
BIOSCODE:136A					      ;	to be careful to do a popf
BIOSCODE:136F ;	---------------------------------------------------------------------------
BIOSCODE:136F
BIOSCODE:136F do_subfun_01:			      ;	...
BIOSCODE:136F		      push    es
BIOSCODE:1370		      push    ds
BIOSCODE:1371		      push    ds
BIOSCODE:1372		      pop     es
BIOSCODE:1373		      mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
BIOSCODE:1378		      assume ds:nothing
BIOSCODE:1378		      call    install_bds
BIOSCODE:137B		      pop     ds
BIOSCODE:137C		      assume ds:nothing
BIOSCODE:137C		      pop     es
BIOSCODE:137D		      jmp     short i2f_iret
BIOSCODE:137F ;	---------------------------------------------------------------------------
BIOSCODE:137F
BIOSCODE:137F do_get_bds_vector:		      ;	...
BIOSCODE:137F		      mov     ds, cs:Bios_Data_Word
BIOSCODE:1384		      assume ds:nothing
BIOSCODE:1384		      lds     di, dword	ptr ds:start_bds
BIOSCODE:1388		      assume ds:nothing
BIOSCODE:1388
BIOSCODE:1388 ii2f_iret:			      ;	...
BIOSCODE:1388		      jmp     short i2f_iret
BIOSCODE:138A ;	---------------------------------------------------------------------------
BIOSCODE:138A
BIOSCODE:138A win386call:			      ;	...
BIOSCODE:138A		      push    ds
BIOSCODE:138B		      mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
BIOSCODE:1390		      assume ds:nothing
BIOSCODE:1390		      cmp     al, 5	      ;	Win386_Init
BIOSCODE:1390					      ;	is it win386 initializing?
BIOSCODE:1392		      jz      short Win386Init
BIOSCODE:1394		      cmp     al, 6	      ;	Win386_Exit
BIOSCODE:1394					      ;	is it win386 exiting?
BIOSCODE:1396		      jnz     short win_iret
BIOSCODE:1398		      test    dx, 1	      ;	is it win386 or	win286 dos extender?
BIOSCODE:139C		      jnz     short win_iret  ;	if not win386, then continue
BIOSCODE:139E		      and     ds:IsWin386, 0  ;	indicate that win386 is	not present
BIOSCODE:13A3		      jmp     short win_iret
BIOSCODE:13A5 ;	---------------------------------------------------------------------------
BIOSCODE:13A5
BIOSCODE:13A5 Win386Init:			      ;	...
BIOSCODE:13A5		      test    dx, 1	      ;	is it win386 or	win286 dos extender?
BIOSCODE:13A9		      jnz     short win_iret  ;	if not win386, then continue
BIOSCODE:13AB		      or      ds:IsWin386, 1
BIOSCODE:13B0		      mov     word ptr ds:SI_Next, bx
BIOSCODE:13B4		      mov     word ptr ds:SI_Next+2, es	; Hook our structure into chain
BIOSCODE:13B8		      mov     bx, offset Win386_SI ; point es:bx to Win386_SI
BIOSCODE:13BB		      push    ds
BIOSCODE:13BC		      pop     es
BIOSCODE:13BD		      assume es:nothing
BIOSCODE:13BD
BIOSCODE:13BD win_iret:				      ;	...
BIOSCODE:13BD		      pop     ds
BIOSCODE:13BE		      assume ds:nothing
BIOSCODE:13BE		      jmp     short i2f_iret  ;	return back up the chain
BIOSCODE:13C0 ;	---------------------------------------------------------------------------
BIOSCODE:13C0
BIOSCODE:13C0 handle_multmult:			      ;	...
BIOSCODE:13C0		      cmp     al, 1
BIOSCODE:13C2		      jnz     short try_2
BIOSCODE:13C4		      push    ds
BIOSCODE:13C5		      call    HMAPtr	      ;	get offset of free HMA
BIOSCODE:13C8		      mov     bx, 0FFFFh
BIOSCODE:13CB		      mov     es, bx	      ;	seg of HMA
BIOSCODE:13CD		      assume es:nothing
BIOSCODE:13CD		      mov     bx, di
BIOSCODE:13CF		      not     bx
BIOSCODE:13D1		      or      bx, bx
BIOSCODE:13D3		      jz      short try_1
BIOSCODE:13D5		      inc     bx
BIOSCODE:13D6
BIOSCODE:13D6 try_1:				      ;	...
BIOSCODE:13D6		      pop     ds
BIOSCODE:13D7		      jmp     short ii2f_iret
BIOSCODE:13D9 ;	---------------------------------------------------------------------------
BIOSCODE:13D9
BIOSCODE:13D9 try_2:				      ;	...
BIOSCODE:13D9		      cmp     al, 2	      ;	multMULTALLOCHMA
BIOSCODE:13DB		      jnz     short try_3
BIOSCODE:13DD		      push    ds
BIOSCODE:13DE		      mov     di, 0FFFFh      ;	assume not enough space
BIOSCODE:13E1		      mov     es, di
BIOSCODE:13E3		      call    HMAPtr	      ;	get offset of free HMA
BIOSCODE:13E6		      cmp     di, 0FFFFh
BIOSCODE:13E9		      jz      short InsuffHMA
BIOSCODE:13EB		      neg     di	      ;	free space in HMA
BIOSCODE:13ED		      cmp     bx, di
BIOSCODE:13EF		      jbe     short try_4
BIOSCODE:13F1		      mov     di, 0FFFFh
BIOSCODE:13F4		      jmp     short InsuffHMA
BIOSCODE:13F6 ;	---------------------------------------------------------------------------
BIOSCODE:13F6
BIOSCODE:13F6 try_4:				      ;	...
BIOSCODE:13F6		      mov     di, ds:FreeHMAPtr
BIOSCODE:13FA		      add     bx, 15
BIOSCODE:13FD		      and     bx, 0FFF0h
BIOSCODE:1400		      add     ds:FreeHMAPtr, bx	; update the free pointer
BIOSCODE:1404		      jnz     short InsuffHMA
BIOSCODE:1406		      mov     ds:FreeHMAPtr, 0FFFFh ; -1
BIOSCODE:1406					      ;	no more	HMA if we have wrapped
BIOSCODE:140C
BIOSCODE:140C InsuffHMA:			      ;	...
BIOSCODE:140C		      pop     ds
BIOSCODE:140D		      jmp     ii2f_iret
BIOSCODE:1410 ;	---------------------------------------------------------------------------
BIOSCODE:1410
BIOSCODE:1410 try_3:				      ;	...
BIOSCODE:1410		      jmp     ii2f_iret
BIOSCODE:1413
BIOSCODE:1413 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1413
BIOSCODE:1413
BIOSCODE:1413 HMAPtr	      proc near		      ;	...
BIOSCODE:1413		      mov     ds, cs:Bios_Data_Word
BIOSCODE:1418		      assume ds:nothing
BIOSCODE:1418		      mov     di, ds:FreeHMAPtr
BIOSCODE:141C		      cmp     di, 0FFFFh
BIOSCODE:141F		      jnz     short HMAPtr_retn_
BIOSCODE:1421		      cmp     ds:SysinitPresent, 0
BIOSCODE:1426		      jz      short HMAPtr_retn_
BIOSCODE:1428		      call    dword ptr	ds:MoveDOSIntoHMA ; call far [MoveDOSIntoHMA]
BIOSCODE:142C
BIOSCODE:142C loc_39EC:
BIOSCODE:142C		      mov     di, ds:FreeHMAPtr
BIOSCODE:1430
BIOSCODE:1430 HMAPtr_retn_:			      ;	...
BIOSCODE:1430		      retn
BIOSCODE:1430 HMAPtr	      endp
BIOSCODE:1430
BIOSCODE:1431
BIOSCODE:1431 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1431
BIOSCODE:1431
BIOSCODE:1431 move_sector     proc near		      ;	...
BIOSCODE:1431		      cld
BIOSCODE:1432		      push    cx
BIOSCODE:1433		      mov     cx, 256
BIOSCODE:1436		      cmp     si, 0FE00h
BIOSCODE:143A		      ja      short movsec_bytes
BIOSCODE:143C		      cmp     di, 0FE00h
BIOSCODE:1440		      ja      short movsec_bytes
BIOSCODE:1442		      rep movsw
BIOSCODE:1444		      pop     cx
BIOSCODE:1445		      retn
BIOSCODE:1446 ;	---------------------------------------------------------------------------
BIOSCODE:1446
BIOSCODE:1446 movsec_bytes:			      ;	...
BIOSCODE:1446		      shl     cx, 1
BIOSCODE:1448		      rep movsb
BIOSCODE:144A		      pop     cx
BIOSCODE:144B		      retn
BIOSCODE:144B move_sector     endp
BIOSCODE:144B
BIOSCODE:144C
BIOSCODE:144C ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:144C
BIOSCODE:144C
BIOSCODE:144C check_wrap      proc near		      ;	...
BIOSCODE:144C		      push    ax
BIOSCODE:144D		      push    bx
BIOSCODE:144E		      push    es
BIOSCODE:144F		      push    di
BIOSCODE:1450		      call    find_bds	      ;	get pointer to bds for drive in	dl
BIOSCODE:1453		      jb      short no_wrap   ;	finished if DOS	doesn't use it
BIOSCODE:1455		      test    word ptr es:[di+23h], 1 ;	[es:di+BDS.flags],fnon_removable
BIOSCODE:145B		      jz      short no_wrap   ;	no wrapping for	removable media
BIOSCODE:145D		      mov     bx, es:[di+13h] ;	[es:di+BDS.secpertrack]
BIOSCODE:1461		      mov     ax, cx
BIOSCODE:1463		      and     ax, 3Fh	      ;	extract	sector number
BIOSCODE:1466		      cmp     ax, bx	      ;	are we going to	wrap?
BIOSCODE:1468		      jbe     short no_wrap
BIOSCODE:146A		      div     bl	      ;	ah=new sector #, al=# of head wraps
BIOSCODE:146C		      or      ah, ah
BIOSCODE:146E		      jnz     short not_on_bound
BIOSCODE:1470		      mov     ah, bl	      ;	set sector=BDS_BPB.BPB_SECTORSPERTRACK
BIOSCODE:1472		      dec     al	      ;	if on boundary
BIOSCODE:1472					      ;	also decrement # of head wrap
BIOSCODE:1474
BIOSCODE:1474 not_on_bound:			      ;	...
BIOSCODE:1474		      and     cl, 0C0h	      ;	zero out sector	#
BIOSCODE:1477		      or      cl, ah	      ;	or in new sector #
BIOSCODE:1479		      xor     ah, ah	      ;	ax = # of head wraps
BIOSCODE:147B		      inc     ax
BIOSCODE:147C		      add     al, dh	      ;	add in starting	head #
BIOSCODE:147E		      adc     ah, 0	      ;	catch any carry
BIOSCODE:1481		      cmp     ax, es:[di+15h] ;	[es:di+BDS.heads]
BIOSCODE:1481					      ;	are we going to	wrap around a head?
BIOSCODE:1485		      jbe     short no_wrap_head
BIOSCODE:1487		      push    dx	      ;	preserve drive number and head number
BIOSCODE:1488		      xor     dx, dx
BIOSCODE:148A		      mov     bx, es:[di+15h] ;	[es:di+BDS.heads]
BIOSCODE:148A					      ;	dx = new head #, ax = #	of cylinder wraps
BIOSCODE:148E		      div     bx
BIOSCODE:1490		      or      dx, dx	      ;	if new head # is 0, then we are	on the last head
BIOSCODE:1492		      jnz     short no_head_bound
BIOSCODE:1494		      mov     dx, bx	      ;	on boundary. set to BDS_BPB.BPB_HEADS
BIOSCODE:1496		      or      ax, ax	      ;	if we had some cylinder	wraps,
BIOSCODE:1496					      ;	we need	to reduce them by on
BIOSCODE:1498		      jz      short no_head_bound
BIOSCODE:149A		      dec     ax	      ;	reduce number of cylinder wraps
BIOSCODE:149B
BIOSCODE:149B no_head_bound:			      ;	...
BIOSCODE:149B		      mov     bh, dl	      ;	bh has new head	number
BIOSCODE:149D		      pop     dx	      ;	restore	drive number and head number
BIOSCODE:149E		      dec     bh
BIOSCODE:14A0		      mov     dh, bh
BIOSCODE:14A2		      mov     bh, cl
BIOSCODE:14A4		      and     bh, 3Fh	      ;	preserve sector	number
BIOSCODE:14A7		      mov     bl, 6
BIOSCODE:14A9		      xchg    cl, bl
BIOSCODE:14AB		      shr     bl, cl	      ;	get ms cylinder	bits to	ls end
BIOSCODE:14AD		      add     ch, al	      ;	add in cylinder	wrap
BIOSCODE:14AF		      adc     bl, ah	      ;	add in high byte
BIOSCODE:14B1		      shl     bl, cl	      ;	move up	to ms end
BIOSCODE:14B3		      xchg    bl, cl	      ;	restore	cylinder bits into cl
BIOSCODE:14B5		      or      cl, bh	      ;	or in sector number
BIOSCODE:14B7
BIOSCODE:14B7 no_wrap:				      ;	...
BIOSCODE:14B7		      clc
BIOSCODE:14B8		      pop     di
BIOSCODE:14B9		      pop     es
BIOSCODE:14BA		      assume es:nothing
BIOSCODE:14BA		      pop     bx
BIOSCODE:14BB		      pop     ax
BIOSCODE:14BC		      retn
BIOSCODE:14BD ;	---------------------------------------------------------------------------
BIOSCODE:14BD
BIOSCODE:14BD no_wrap_head:			      ;	...
BIOSCODE:14BD		      mov     dh, al	      ;	do not lose new	head number
BIOSCODE:14BF		      dec     dh	      ;	get it 0-based
BIOSCODE:14C1		      jmp     short no_wrap
BIOSCODE:14C1 check_wrap      endp
BIOSCODE:14C1
BIOSCODE:14C3
BIOSCODE:14C3 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:14C3
BIOSCODE:14C3
BIOSCODE:14C3 find_bds	      proc near		      ;	...
BIOSCODE:14C3		      les     di, dword	ptr ds:start_bds ; point es:di to first	bds
BIOSCODE:14C7
BIOSCODE:14C7 fbds_1:				      ;	...
BIOSCODE:14C7		      cmp     es:[di+4], dl   ;	[es:di+BDS.drivenum]
BIOSCODE:14CB		      jz      short fbds_2
BIOSCODE:14CD		      les     di, es:[di]     ;	[es:di+BDS.link]
BIOSCODE:14CD					      ;	go to next bds
BIOSCODE:14D0		      cmp     di, 0FFFFh
BIOSCODE:14D3		      jnz     short fbds_1
BIOSCODE:14D5		      stc
BIOSCODE:14D6
BIOSCODE:14D6 fbds_2:				      ;	...
BIOSCODE:14D6		      retn
BIOSCODE:14D6 find_bds	      endp
BIOSCODE:14D6
BIOSCODE:14D7
BIOSCODE:14D7 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:14D7
BIOSCODE:14D7
BIOSCODE:14D7 doint	      proc near		      ;	...
BIOSCODE:14D7		      mov     dl, [bp+8]      ;	[bp+INT13FRAME.olddx]
BIOSCODE:14D7					      ;	get physical drive number
BIOSCODE:14DB		      xor     ah, ah
BIOSCODE:14DD		      or      al, al
BIOSCODE:14DF		      jz      short dointdone ;	if zero	sectors, return	ax=0
BIOSCODE:14E1		      mov     ah, [bp+3]      ;	[bp+INT13FRAME.oldax+1]
BIOSCODE:14E1					      ;	get request code
BIOSCODE:14E5		      push    word ptr [bp+10h]	; [bp+INT13FRAME.oldf]
BIOSCODE:14E9		      popf
BIOSCODE:14EA		      call    far ptr 70h:797h ; call BIOSDATA:call_orig13
BIOSCODE:14EA					      ;	call DOSBIOSSEG:call_orig13
BIOSCODE:14EF		      pushf
BIOSCODE:14F0		      pop     word ptr [bp+10h]	; [bp+INT13FRAME.oldf]
BIOSCODE:14F4
BIOSCODE:14F4 dointdone:			      ;	...
BIOSCODE:14F4		      retn
BIOSCODE:14F4 doint	      endp
BIOSCODE:14F4
BIOSCODE:14F4 ;	---------------------------------------------------------------------------
BIOSCODE:14F5 dtype_array     dd 400090h	      ;	...
BIOSCODE:14F5					      ;	40h:90h	is drive type array
BIOSCODE:14F9 ;	---------------------------------------------------------------------------
BIOSCODE:14F9
BIOSCODE:14F9 format_special_stuff:		      ;	...
BIOSCODE:14F9		      cmp     ds:fhave96, 0   ;	do we have changeline support?
BIOSCODE:14FE
BIOSCODE:14FE loc_3ABE:				      ;	brif not
BIOSCODE:14FE		      jz      short format_special_stuff_done
BIOSCODE:1500		      push    bx
BIOSCODE:1501		      mov     bx, 140h	      ;	fchanged_by_format+fchanged
BIOSCODE:1504		      call    Set_Changed_DL  ;	indicate that media changed by format
BIOSCODE:1507		      pop     bx
BIOSCODE:1508		      jmp     short format_special_stuff_done
BIOSCODE:150A ;	---------------------------------------------------------------------------
BIOSCODE:150A
BIOSCODE:150A ec35_special_stuff:		      ;	...
BIOSCODE:150A		      test    dl, dl	      ;	floppy or hard disk?
BIOSCODE:150C		      js      short ec35_special_stuff_done ; if hard drive, we're done
BIOSCODE:150E		      push    ax	      ;	see if this PARTICULAR drive is	ec35
BIOSCODE:150F		      push    cx
BIOSCODE:1510		      mov     cl, dl	      ;	turn drive number into bit map
BIOSCODE:1512		      mov     al, 1	      ;	assume drive 0
BIOSCODE:1514		      shl     al, cl	      ;	shift over correct number of times
BIOSCODE:1516		      test    ds:ec35_flag, al ; electrically compatible 3.5 incher?
BIOSCODE:151A		      pop     cx
BIOSCODE:151B		      pop     ax
BIOSCODE:151C		      jz      short ec35_special_stuff_done ; done if this floppy is not an ec35
BIOSCODE:151E		      push    bx	      ;	free up	a far pointer (es:bx)
BIOSCODE:151F		      push    es
BIOSCODE:1520		      les     bx, cs:dtype_array
BIOSCODE:1525		      add     bl, dl
BIOSCODE:1527		      adc     bh, 0	      ;	find entry for this drive
BIOSCODE:152A		      mov     byte ptr es:[bx],	93h ; establish	drive type as:
BIOSCODE:152A					      ;	(360k disk in 360k drive,
BIOSCODE:152A					      ;	no double-stepping, 250	kbs transfer rate)
BIOSCODE:152E		      pop     es
BIOSCODE:152F		      pop     bx
BIOSCODE:1530		      jmp     short ec35_special_stuff_done
BIOSCODE:1532 ;	---------------------------------------------------------------------------
BIOSCODE:1532
BIOSCODE:1532 ps2_special_stuff:		      ;	...
BIOSCODE:1532		      cmp     ds:prevoper, 8  ;	(ps2_30)
BIOSCODE:1532					      ;	read driver parm?
BIOSCODE:1537		      jz      short ps2_30_problem
BIOSCODE:1539		      cmp     ds:prevoper, 15h ; apparently function 15h fails,	too
BIOSCODE:153E		      jnz     short ps2_special_stuff_done
BIOSCODE:1540
BIOSCODE:1540 ps2_30_problem:			      ;	...
BIOSCODE:1540		      push    ax
BIOSCODE:1541		      mov     ah, 1
BIOSCODE:1543		      call    far ptr 70h:797h ; call BIOSDATA:call_orig13
BIOSCODE:1548		      pop     ax
BIOSCODE:1549		      jmp     short ps2_special_stuff_done
BIOSCODE:154B ;	---------------------------------------------------------------------------
BIOSCODE:154B
BIOSCODE:154B i13z:				      ;	...
BIOSCODE:154B		      push    ds
BIOSCODE:154C		      mov     ds, cs:Bios_Data_Word
BIOSCODE:1551		      mov     ds:prevoper, ax ;	save request
BIOSCODE:1554		      cmp     ah, 5	      ;	romformat
BIOSCODE:1557		      jz      short format_special_stuff
BIOSCODE:1559
BIOSCODE:1559 format_special_stuff_done:	      ;	...
BIOSCODE:1559		      cmp     ds:ec35_flag, 0 ;	any electrically compat	3.5 inchers?
BIOSCODE:155E		      jnz     short ec35_special_stuff ; go handle it out of line if so
BIOSCODE:1560
BIOSCODE:1560 ec35_special_stuff_done:		      ;	...
BIOSCODE:1560		      call    far ptr 70h:797h ; call BIOSDATA:call_orig13
BIOSCODE:1565		      pushf
BIOSCODE:1566		      cmp     ds:model_byte, 0FAh ; is this a ps2/30?
BIOSCODE:1566					      ;	mdl_ps2_30
BIOSCODE:156B		      jz      short ps2_special_stuff ;	exit mainline to address special
BIOSCODE:156D
BIOSCODE:156D ps2_special_stuff_done:		      ;	...
BIOSCODE:156D		      popf
BIOSCODE:156E		      jb      short goterr13  ;	error on original orig13 call-thru?
BIOSCODE:1570
BIOSCODE:1570 ret_from_i13:			      ;	...
BIOSCODE:1570		      pop     ds
BIOSCODE:1571		      assume ds:nothing
BIOSCODE:1571		      retf    2		      ;	restore	ds & iret w/flags
BIOSCODE:1574 ;	---------------------------------------------------------------------------
BIOSCODE:1574
BIOSCODE:1574 i13ret_ck_chglinerr:		      ;	...
BIOSCODE:1574		      jnb     short ret_from_i13 ; done	if not an error	termination
BIOSCODE:1576
BIOSCODE:1576 i13_ret_error:			      ;	...
BIOSCODE:1576		      cmp     ah, 6	      ;	did i see a change event?
BIOSCODE:1579		      jnz     short int13b    ;	skip if	wrong error
BIOSCODE:157B		      or      dl, dl	      ;	is this	for the	hard disk?
BIOSCODE:157D		      js      short int13b    ;	yes, ignore
BIOSCODE:157F		      cmp     ds:fhave96, 0
BIOSCODE:1584		      jz      short int13b    ;	just in	case ROM returned this
BIOSCODE:1584					      ;	error even though it told us it
BIOSCODE:1584					      ;	never would
BIOSCODE:1586		      push    bx
BIOSCODE:1587		      mov     bx, 40h	      ;	fchanged
BIOSCODE:158A		      call    Set_Changed_DL
BIOSCODE:158D		      pop     bx
BIOSCODE:158E
BIOSCODE:158E int13b:				      ;	...
BIOSCODE:158E		      stc		      ;	now return the error
BIOSCODE:158F		      jmp     short ret_from_i13
BIOSCODE:1591 ;	---------------------------------------------------------------------------
BIOSCODE:1591
BIOSCODE:1591 goterr13:				      ;	...
BIOSCODE:1591		      cmp     ah, 9	      ;	dma error?
BIOSCODE:1594		      jz      short gotdmaerr
BIOSCODE:1596
BIOSCODE:1596 goterr13_xxxx:			      ;	...
BIOSCODE:1596		      cmp     ah, 11h	      ;	ecc error?
BIOSCODE:1599		      jnz     short i13_ret_error ; other error. just return back.
BIOSCODE:159B		      cmp     ds:media_set_for_format, 1 ; formatting?
BIOSCODE:15A0		      jz      short i13_ret_error
BIOSCODE:15A2		      cmp     byte ptr ds:prevoper+1, 2	; ecc-corrected	error
BIOSCODE:15A2					      ;	(2 = romread)
BIOSCODE:15A2					      ;	ECC correction only applies to reads
BIOSCODE:15A7		      jnz     short i13_ret_error
BIOSCODE:15A9		      xor     ah, ah
BIOSCODE:15AB		      call    far ptr 70h:797h ; call BIOSDATA:call_orig13
BIOSCODE:15AB					      ;	call DOSBIOSSEG:call_orig13
BIOSCODE:15B0		      mov     ax, ds:prevoper
BIOSCODE:15B3		      xor     ah, ah	      ;	return code = no error
BIOSCODE:15B5		      cmp     al, 1	      ;	if request for one sector, assume ok
BIOSCODE:15B7		      jz      short ret_from_i13 ; return with carry clear
BIOSCODE:15B9		      push    bx
BIOSCODE:15BA		      push    cx
BIOSCODE:15BB		      push    dx
BIOSCODE:15BC		      mov     ds:number_of_sec,	al
BIOSCODE:15BF
BIOSCODE:15BF loop_ecc:				      ;	...
BIOSCODE:15BF		      mov     ax, 201h	      ;	read one sector
BIOSCODE:15C2		      call    check_wrap      ;	get correct parameters for int 13
BIOSCODE:15C5		      call    far ptr 70h:797h ; call BIOSDATA:call_orig13
BIOSCODE:15C5					      ;	call DOSBIOSSEG:call_orig13
BIOSCODE:15CA		      jnb     short ok11_op
BIOSCODE:15CC		      cmp     ah, 9	      ;	DMA error during ECC read?
BIOSCODE:15CF		      jz      short handle_dma_during_ecc
BIOSCODE:15D1		      cmp     ah, 11h	      ;	only allow ecc errors
BIOSCODE:15D4		      jnz     short ok11_exit_err
BIOSCODE:15D6		      mov     ah, 0
BIOSCODE:15D8		      xor     ax, ax	      ;	ecc error. reset the system again.
BIOSCODE:15D8					      ;	clear the error	code so	that if	this
BIOSCODE:15D8					      ;	was the	last sector, no	error code
BIOSCODE:15D8					      ;	will be	returned for the corrected read.
BIOSCODE:15D8					      ;	(clear carry too.)
BIOSCODE:15DA
BIOSCODE:15DA ok11_op:				      ;	...
BIOSCODE:15DA		      dec     ds:number_of_sec
BIOSCODE:15DE		      jz      short ok11_exit ;	all done?
BIOSCODE:15E0		      inc     cl	      ;	advance	sector number
BIOSCODE:15E0					      ;	add 200h to address
BIOSCODE:15E2		      inc     bh
BIOSCODE:15E4		      inc     bh
BIOSCODE:15E6		      jmp     short loop_ecc
BIOSCODE:15E8 ;	---------------------------------------------------------------------------
BIOSCODE:15E8
BIOSCODE:15E8 ok11_exit_err:			      ;	...
BIOSCODE:15E8		      stc		      ;	set carry bit again.
BIOSCODE:15E9
BIOSCODE:15E9 ok11_exit:			      ;	...
BIOSCODE:15E9		      pop     dx
BIOSCODE:15EA		      pop     cx
BIOSCODE:15EB		      pop     bx
BIOSCODE:15EC		      jmp     short i13ret_ck_chglinerr
BIOSCODE:15EE ;	---------------------------------------------------------------------------
BIOSCODE:15EE
BIOSCODE:15EE handle_dma_during_ecc:		      ;	...
BIOSCODE:15EE		      push    es
BIOSCODE:15EF		      push    bx
BIOSCODE:15F0		      mov     bx, offset disksector ; BIOSDATA:014Eh
BIOSCODE:15F3		      push    ds
BIOSCODE:15F4		      pop     es	      ;	point es:bx to buffer
BIOSCODE:15F5		      mov     ax, 201h	      ;	read one sector
BIOSCODE:15F8		      call    far ptr 70h:797h ; call BIOSDATA:call_orig13
BIOSCODE:15FD		      pop     bx
BIOSCODE:15FE		      pop     es
BIOSCODE:15FF		      jnb     short handle_dma_during_ecc_noerr
BIOSCODE:1601		      cmp     ah, 11h
BIOSCODE:1604		      jnz     short ok11_exit_err
BIOSCODE:1606
BIOSCODE:1606 handle_dma_during_ecc_noerr:	      ;	...
BIOSCODE:1606		      push    si
BIOSCODE:1607		      push    di
BIOSCODE:1608		      mov     di, bx
BIOSCODE:160A		      mov     si, offset disksector
BIOSCODE:160D		      call    move_sector
BIOSCODE:1610		      pop     di
BIOSCODE:1611		      pop     si
BIOSCODE:1612		      jmp     short ok11_op
BIOSCODE:1614 ;	---------------------------------------------------------------------------
BIOSCODE:1614
BIOSCODE:1614 gotdmaerr:			      ;	...
BIOSCODE:1614		      mov     ax, ds:prevoper
BIOSCODE:1617		      sti
BIOSCODE:1618		      cmp     ah, 2	      ;	romread
BIOSCODE:161B		      jb      short i13_done_dmaerr
BIOSCODE:161D		      cmp     ah, 4	      ;	romverify
BIOSCODE:1620		      jz      short intverify
BIOSCODE:1622		      cmp     ah, 5	      ;	romformat
BIOSCODE:1625		      jz      short intformat
BIOSCODE:1627		      ja      short i13_done_dmaerr
BIOSCODE:1629		      push    dx	      ;	set up stack frame here!
BIOSCODE:162A		      push    cx
BIOSCODE:162B		      push    bx
BIOSCODE:162C		      push    ax
BIOSCODE:162D		      push    bp
BIOSCODE:162E		      mov     bp, sp
BIOSCODE:1630		      mov     dx, es	      ;	check for 64k boundary error
BIOSCODE:1632		      shl     dx, 1
BIOSCODE:1634		      shl     dx, 1
BIOSCODE:1636		      shl     dx, 1
BIOSCODE:1638		      shl     dx, 1	      ;	dx = dx*16
BIOSCODE:163A		      add     dx, bx
BIOSCODE:163C		      add     dx, 511
BIOSCODE:1640		      jnb     short no_skip_first
BIOSCODE:1642		      jmp     bufferx	      ;	restore	dh=head	& do buffer
BIOSCODE:1645 ;	---------------------------------------------------------------------------
BIOSCODE:1645
BIOSCODE:1645 no_skip_first:			      ;	...
BIOSCODE:1645		      shr     dh, 1	      ;	dh = number of sectors before address
BIOSCODE:1647		      mov     ah, 128	      ;	ah = max number	of sectors in segment
BIOSCODE:1649		      sub     ah, dh
BIOSCODE:164B		      cmp     ah, al	      ;	can we fit it in?
BIOSCODE:164D		      jb      short doblock   ;	no, perform blocking.
BIOSCODE:164D					      ;	yes, the request fits. let it happe
BIOSCODE:164F		      mov     dh, [bp+9]      ;	[bp+INT13FRAME.olddx+1]
BIOSCODE:164F					      ;	set up head number
BIOSCODE:1652		      call    doint
BIOSCODE:1655		      jmp     bad13	      ;	and return from	this place
BIOSCODE:1658 ;	---------------------------------------------------------------------------
BIOSCODE:1658
BIOSCODE:1658 i13_done_dmaerr:			      ;	...
BIOSCODE:1658		      mov     ah, 9	      ;	pass dma error thru to caller
BIOSCODE:165A		      stc
BIOSCODE:165B		      jmp     ret_from_i13    ;	return with error,
BIOSCODE:165B					      ;	we know	it's not a changeline error
BIOSCODE:165E ;	---------------------------------------------------------------------------
BIOSCODE:165E
BIOSCODE:165E intverify:			      ;	...
BIOSCODE:165E		      push    es	      ;	save caller's dma address
BIOSCODE:165F		      push    bx
BIOSCODE:1660		      push    ds
BIOSCODE:1661		      pop     es
BIOSCODE:1662
BIOSCODE:1662 dosimple:				      ;	...
BIOSCODE:1662		      mov     bx, offset disksector ; es:bx -> BIOSDATA:disksector
BIOSCODE:1665		      call    far ptr 70h:797h ; call DOSBIOSSEG:call_orig13
BIOSCODE:1665					      ;	call BIOSDATA:call_orig13
BIOSCODE:166A		      pop     bx
BIOSCODE:166B		      pop     es
BIOSCODE:166C		      jmp     i13ret_ck_chglinerr
BIOSCODE:166F ;	---------------------------------------------------------------------------
BIOSCODE:166F
BIOSCODE:166F intformat:			      ;	...
BIOSCODE:166F		      push    es
BIOSCODE:1670		      push    bx
BIOSCODE:1671		      push    si
BIOSCODE:1672		      push    di
BIOSCODE:1673		      push    ds
BIOSCODE:1674		      push    es
BIOSCODE:1675		      push    ds
BIOSCODE:1676		      pop     es
BIOSCODE:1677		      pop     ds
BIOSCODE:1678		      mov     si, bx
BIOSCODE:167A		      mov     di, offset disksector ; user's data into BIOSDATA:disksector
BIOSCODE:167D		      call    move_sector
BIOSCODE:1680		      pop     ds
BIOSCODE:1681		      pop     di
BIOSCODE:1682		      pop     si	      ;	do the i/o from
BIOSCODE:1683		      jmp     short dosimple  ;	BIOSDATA:disksector
BIOSCODE:1685 ;	---------------------------------------------------------------------------
BIOSCODE:1685
BIOSCODE:1685 doblock:				      ;	...
BIOSCODE:1685		      mov     dx, [bp+8]      ;	[bp+INT13FRAME.olddx]
BIOSCODE:1685					      ;	get head #, drive #
BIOSCODE:1688		      push    cx
BIOSCODE:1689		      push    es
BIOSCODE:168A		      push    di	      ;	ah - # of sectors before dma boundary
BIOSCODE:168A					      ;	al - requested # of sectors for	i/o.
BIOSCODE:168B		      call    find_bds
BIOSCODE:168E		      mov     cx, es:[di+13h] ;	[es:di+BDS.secpertrack]
BIOSCODE:1692		      test    word ptr es:[di+23h], 1 ;	[es:di+BDS.flags], fnon_removable
BIOSCODE:1698		      pop     di
BIOSCODE:1699		      pop     es
BIOSCODE:169A		      mov     al, ah	      ;	set al=ah for floppies
BIOSCODE:169C		      jz      short doblockflop	; they are track by track operation
BIOSCODE:169E		      mov     ah, 63	      ;	ah = 63-secpt (# safe sectors??)
BIOSCODE:16A0		      sub     ah, cl	      ;	al - # of sectors before dma boundary
BIOSCODE:16A2
BIOSCODE:16A2 doblockflop:			      ;	...
BIOSCODE:16A2		      pop     cx
BIOSCODE:16A3
BIOSCODE:16A3 doblockcontinue:			      ;	...
BIOSCODE:16A3		      cmp     ah, al	      ;	if safe_# >= #_of_sectors_to_go_before dma,
BIOSCODE:16A5		      jnb     short doblocklast	; then #_of_sectors_to_go as it	is for doint.
BIOSCODE:16A7		      push    ax
BIOSCODE:16A8		      mov     al, ah	      ;	otherwise, set al to ah	to operate.
BIOSCODE:16AA		      jmp     short doblockdoint
BIOSCODE:16AC ;	---------------------------------------------------------------------------
BIOSCODE:16AC
BIOSCODE:16AC doblocklast:			      ;	...
BIOSCODE:16AC		      mov     ah, al
BIOSCODE:16AE		      push    ax
BIOSCODE:16AF
BIOSCODE:16AF doblockdoint:			      ;	...
BIOSCODE:16AF		      call    doint
BIOSCODE:16B2		      jb      short bad13
BIOSCODE:16B4		      pop     ax
BIOSCODE:16B5		      sub     [bp+2], ah
BIOSCODE:16B8		      add     cl, ah
BIOSCODE:16BA		      add     bh, ah
BIOSCODE:16BC		      add     bh, ah
BIOSCODE:16BE		      cmp     ah, al
BIOSCODE:16C0		      jz      short buffer
BIOSCODE:16C2		      sub     al, ah
BIOSCODE:16C4		      call    check_wrap
BIOSCODE:16C7		      jmp     short doblockcontinue
BIOSCODE:16C9 ;	---------------------------------------------------------------------------
BIOSCODE:16C9
BIOSCODE:16C9 bufferx:				      ;	...
BIOSCODE:16C9		      mov     dh, [bp+9]      ;	[bp+INT13FRAME.olddx+1]
BIOSCODE:16C9					      ;	set up head number
BIOSCODE:16CC
BIOSCODE:16CC buffer:				      ;	...
BIOSCODE:16CC		      push    bx
BIOSCODE:16CD		      mov     ah, [bp+3]      ;	[bp+INT13FRAME.oldax+1]
BIOSCODE:16D0		      cmp     ah, 3	      ;	romwrite
BIOSCODE:16D3		      jnz     short doread
BIOSCODE:16D5		      push    es
BIOSCODE:16D6		      push    ds
BIOSCODE:16D7		      push    si
BIOSCODE:16D8		      push    di
BIOSCODE:16D9		      push    ds
BIOSCODE:16DA		      push    es
BIOSCODE:16DB		      pop     ds
BIOSCODE:16DC		      pop     es
BIOSCODE:16DD		      mov     di, offset disksector ; where to move
BIOSCODE:16E0		      push    di	      ;	save it
BIOSCODE:16E1		      mov     si, bx	      ;	source
BIOSCODE:16E3		      call    move_sector     ;	move sector into local buffer
BIOSCODE:16E6		      pop     bx	      ;	new transfer address
BIOSCODE:16E6					      ;	(es:bx = BIOSDATA:disksector)
BIOSCODE:16E7		      pop     di	      ;	restore	caller's di & si
BIOSCODE:16E8		      pop     si
BIOSCODE:16E9		      pop     ds	      ;	restore	BIOSDATA
BIOSCODE:16EA		      mov     al, 1
BIOSCODE:16EC		      mov     dl, [bp+8]      ;	[bp+INT13FRAME.olddx]
BIOSCODE:16EC					      ;	get drive number
BIOSCODE:16EF		      call    check_wrap      ;	sets up	registers if wrap-around
BIOSCODE:16EF					      ;
BIOSCODE:16EF					      ;	ah is function
BIOSCODE:16EF					      ;	al is 1	for single sector transfer
BIOSCODE:16EF					      ;	es:bx is local transfer	addres
BIOSCODE:16EF					      ;	cx is track/sector number
BIOSCODE:16EF					      ;	dx is head/drive number
BIOSCODE:16EF					      ;	si, di unchanged
BIOSCODE:16F2		      call    doint
BIOSCODE:16F5		      pop     es	      ;	restore	caller's dma segment
BIOSCODE:16F6		      jb      short bad13     ;	go clean up
BIOSCODE:16F8		      jmp     short dotail
BIOSCODE:16FA ;	---------------------------------------------------------------------------
BIOSCODE:16FA
BIOSCODE:16FA doread:				      ;	...
BIOSCODE:16FA		      push    es
BIOSCODE:16FB		      push    bx
BIOSCODE:16FC		      push    ds
BIOSCODE:16FD		      pop     es	      ;	es = BIOSCODE segment
BIOSCODE:16FE		      mov     bx, offset disksector
BIOSCODE:1701		      mov     al, 1
BIOSCODE:1703		      mov     dl, [bp+8]      ;	[bp+INT13FRAME.olddx]
BIOSCODE:1703					      ;	get drive number
BIOSCODE:1706		      call    check_wrap      ;	ah = function
BIOSCODE:1706					      ;	al = 1 for single sector
BIOSCODE:1706					      ;	es:bx points to	local	buffer
BIOSCODE:1706					      ;	cx, dx are track/sector, head/drive
BIOSCODE:1709		      call    doint
BIOSCODE:170C		      pop     bx
BIOSCODE:170D		      pop     es
BIOSCODE:170E		      jb      short bad13
BIOSCODE:1710		      push    si
BIOSCODE:1711		      push    di
BIOSCODE:1712		      mov     di, bx
BIOSCODE:1714		      mov     si, offset disksector
BIOSCODE:1717		      call    move_sector
BIOSCODE:171A		      pop     di
BIOSCODE:171B		      pop     si
BIOSCODE:171C
BIOSCODE:171C dotail:				      ;	...
BIOSCODE:171C		      pop     bx	      ;	retrieve new dma area
BIOSCODE:171D		      add     bh, 2	      ;	advance	over sector
BIOSCODE:1720		      inc     cx
BIOSCODE:1721		      mov     al, [bp+2]      ;	[bp+INT13FRAME.oldax]
BIOSCODE:1724		      clc
BIOSCODE:1725		      dec     al
BIOSCODE:1727		      jz      short bad13     ;	no more	i/o
BIOSCODE:1729		      mov     dl, [bp+8]      ;	[bp+INT13FRAME.olddx]
BIOSCODE:172C		      call    check_wrap
BIOSCODE:172F		      call    doint
BIOSCODE:1732
BIOSCODE:1732 bad13:				      ;	...
BIOSCODE:1732		      mov     sp, bp
BIOSCODE:1734		      pop     bp
BIOSCODE:1735		      pop     bx
BIOSCODE:1736		      pop     bx
BIOSCODE:1737		      pop     cx
BIOSCODE:1738		      pop     dx
BIOSCODE:1739		      jb      short xgoterr13_xxxx ; go	handle ECC errors
BIOSCODE:173B		      jmp     ret_from_i13    ;	non-error exit
BIOSCODE:173E ;	---------------------------------------------------------------------------
BIOSCODE:173E
BIOSCODE:173E xgoterr13_xxxx:			      ;	...
BIOSCODE:173E		      jmp     goterr13_xxxx
BIOSCODE:173E ;	---------------------------------------------------------------------------
BIOSCODE:1741		      db    0
BIOSCODE:1742
BIOSCODE:1742 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1742
BIOSCODE:1742
BIOSCODE:1742 dsk_init	      proc near		      ;	...
BIOSCODE:1742		      mov     ah, ds:drvmax
BIOSCODE:1746		      mov     di, offset dskdrvs ; pass	result in es:di
BIOSCODE:1749		      push    ds
BIOSCODE:174A		      pop     es
BIOSCODE:174B		      jmp     SetPtrSav
BIOSCODE:174B dsk_init	      endp
BIOSCODE:174B
BIOSCODE:174E
BIOSCODE:174E ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:174E
BIOSCODE:174E
BIOSCODE:174E install_bds     proc near		      ;	...
BIOSCODE:174E		      push    ds	      ;	save Bios_Data (BIOSDATA) segment
BIOSCODE:174F		      mov     si, offset start_bds ; beginning of chain
BIOSCODE:1752
BIOSCODE:1752 loop_next_bds:			      ;	...
BIOSCODE:1752		      lds     si, [si]	      ;	[si+BDS.link]
BIOSCODE:1752					      ;	fetch next bds
BIOSCODE:1754		      mov     al, es:[di+4]   ;	[es:di+BDS.drivenum]
BIOSCODE:1758		      cmp     [si+4], al      ;	does this one share a physical
BIOSCODE:1758					      ;	drive with new one?
BIOSCODE:175B		      jnz     short next_bds
BIOSCODE:175D		      mov     bl, 10h	      ;	fi_am_mult
BIOSCODE:175F		      or      es:[di+23h], bl ;	[es:di+BDS.flags]
BIOSCODE:175F					      ;	set both of them to i_am_mult if so
BIOSCODE:1763		      or      [si+23h],	bl    ;	[si+BDS.flags]
BIOSCODE:1766		      and     byte ptr es:[di+23h], 0DFh ; [es:di+BDS.flags],~fi_own_physical
BIOSCODE:1766					      ;	we don't own it
BIOSCODE:176B		      mov     bl, [si+23h]    ;	[si+BDS.flags]
BIOSCODE:176B					      ;	determine if changeline	available
BIOSCODE:176E		      and     bl, 2	      ;	fchangeline
BIOSCODE:1771		      or      es:[di+23h], bl ;	[es:di+BDS.flags]
BIOSCODE:1775
BIOSCODE:1775 next_bds:				      ;	...
BIOSCODE:1775		      cmp     word ptr [si], 0FFFFh ; [si+BDS.link],-1
BIOSCODE:1775					      ;	are we at end of list?
BIOSCODE:1778		      jnz     short loop_next_bds
BIOSCODE:177A		      mov     word ptr [si+2], es ; [si+BDS.link+2], es
BIOSCODE:177A					      ;	install	bds
BIOSCODE:177D		      mov     [si], di
BIOSCODE:177F		      mov     word ptr es:[di],	0FFFFh ; [es:di+BDS.link],-1
BIOSCODE:177F					      ;	set next pointer to null
BIOSCODE:1784		      pop     ds
BIOSCODE:1785		      mov     al, es:[di+34h] ;	[es:di+BDS.rsecpertrack]
BIOSCODE:1789		      cmp     al, ds:eot
BIOSCODE:178D		      jbe     short _eot_ok
BIOSCODE:178F		      mov     ds:eot, al
BIOSCODE:1792
BIOSCODE:1792 _eot_ok:				      ;	...
BIOSCODE:1792		      retn
BIOSCODE:1792 install_bds     endp
BIOSCODE:1792
BIOSCODE:1793
BIOSCODE:1793 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1793
BIOSCODE:1793
BIOSCODE:1793 swpdsk	      proc near		      ;	...
BIOSCODE:1793		      test    ds:IsWin386, 1  ;	Is win386 present?
BIOSCODE:1798		      jz      short no_win386 ;	no, skip SetFocus
BIOSCODE:179A		      call    far ptr 70h:8D1h ; call DOSBIOSSEG:V86_Crit_SetFocus
BIOSCODE:179A					      ;	call BIOSDATA:V86_Crit_SetFocus
BIOSCODE:179F
BIOSCODE:179F no_win386:			      ;	...
BIOSCODE:179F		      push    cx
BIOSCODE:17A0		      push    dx
BIOSCODE:17A1		      mov     dl, es:[di+5]   ;	[es:di+BDS.drivelet]
BIOSCODE:17A1					      ;	get the	drive letter
BIOSCODE:17A5		      mov     dh, dl
BIOSCODE:17A7		      xor     dh, 1
BIOSCODE:17AA		      sub     cx, cx	      ;	nobody has handled swap	disk
BIOSCODE:17AC		      mov     ax, 4A00h	      ;	multMULT<<8)|multMULTSWPDSK
BIOSCODE:17AC					      ;	broadcast code for swap	disk
BIOSCODE:17AC					      ;	Broadcast it
BIOSCODE:17AF		      int     2Fh
BIOSCODE:17B1		      inc     cx
BIOSCODE:17B2		      jz      short swpdsk9
BIOSCODE:17B4		      add     dl, 'A'
BIOSCODE:17B7		      mov     byte ptr cs:drvlet, dl ; "A: and press any key when ready\r\n\n"
BIOSCODE:17BC		      mov     si, offset sngmsg	; "\r\nInsert diskette for drive "
BIOSCODE:17BF		      push    bx
BIOSCODE:17C0		      lods    byte ptr cs:[si] ; get the next character	of the message
BIOSCODE:17C2
BIOSCODE:17C2 wrmsg_loop:			      ;	...
BIOSCODE:17C2		      int     29h	      ;	DOS 2+ internal	- FAST PUTCHAR
BIOSCODE:17C2					      ;	AL = character to display
BIOSCODE:17C4		      lods    byte ptr cs:[si] ; get the next character	of the message
BIOSCODE:17C6		      or      al, al
BIOSCODE:17C8		      jnz     short wrmsg_loop
BIOSCODE:17CA		      call    con_flush	      ;	flush out keyboard queue
BIOSCODE:17CA					      ;	call rom-bios
BIOSCODE:17CD		      xor     ah, ah
BIOSCODE:17CF		      int     16h	      ;	KEYBOARD - READ	CHAR FROM BUFFER, WAIT IF EMPTY
BIOSCODE:17CF					      ;	Return:	AH = scan code,	AL = character
BIOSCODE:17D1		      pop     bx
BIOSCODE:17D2
BIOSCODE:17D2 swpdsk9:				      ;	...
BIOSCODE:17D2		      pop     dx
BIOSCODE:17D3		      pop     cx
BIOSCODE:17D4		      retn
BIOSCODE:17D4 swpdsk	      endp
BIOSCODE:17D4
BIOSCODE:17D4 ;	---------------------------------------------------------------------------
BIOSCODE:17D5 sngmsg	      db 0Dh,0Ah	      ;	...
BIOSCODE:17D5		      db 'Insert diskette for drive '
BIOSCODE:17F1 drvlet	      db 'A: and press any key when ready',0Dh,0Ah ; ...
BIOSCODE:17F1		      db 0Ah,0
BIOSCODE:1814
BIOSCODE:1814 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1814
BIOSCODE:1814
BIOSCODE:1814 chkopcnt	      proc near		      ;	...
BIOSCODE:1814		      cmp     word ptr es:[di+20h], 0 ;	[es:di+BDS.opcnt]
BIOSCODE:1819		      retn
BIOSCODE:1819 chkopcnt	      endp
BIOSCODE:1819
BIOSCODE:181A
BIOSCODE:181A ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:181A
BIOSCODE:181A
BIOSCODE:181A MediaCheck      proc near		      ;	...
BIOSCODE:181A		      call    checksingle     ;	make sure correct disk is in place
BIOSCODE:181D		      xor     si, si
BIOSCODE:181F		      call    HasChange
BIOSCODE:1822		      jz      short mediaret
BIOSCODE:1824		      call    checkromchange  ;	[es:di+BDS.flags], fchanged ; 40h
BIOSCODE:1824					      ;	(BDS offset 63)
BIOSCODE:1827		      jnz     short mediadovolid
BIOSCODE:1829		      push    ax
BIOSCODE:182A		      push    dx
BIOSCODE:182B		      mov     dl, es:[di+4]   ;	[es:di+BDS.drivenum]
BIOSCODE:182F		      mov     ah, 16h
BIOSCODE:1831		      int     13h	      ;	DISK - FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
BIOSCODE:1831					      ;	DL = drive to check
BIOSCODE:1831					      ;	Return:	AH = disk change status
BIOSCODE:1833
BIOSCODE:1833 loc_3DF3:
BIOSCODE:1833		      pop     dx
BIOSCODE:1834		      pop     ax
BIOSCODE:1835		      jb      short mediadovolid
BIOSCODE:1837
BIOSCODE:1837 loc_3DF7:
BIOSCODE:1837		      mov     si, 1
BIOSCODE:183A		      mov     bl, ds:tim_drv  ;	get last drive accessed
BIOSCODE:183E		      cmp     es:[di+4], bl   ;	[es:di+BDS.drivenum]
BIOSCODE:183E					      ;	(If the	last drive accessed is not current drive
BIOSCODE:183E					      ;	media change status may	be incorrect. So,
BIOSCODE:183E					      ;	"I don't now" will be returned even if it is indicated
BIOSCODE:183E					      ;	as media is not	changed.)
BIOSCODE:1842		      jz      short mediaret  ;	(same drive, media changeline indication is reliable)
BIOSCODE:1844		      push    ax
BIOSCODE:1845		      push    cx
BIOSCODE:1846		      push    dx
BIOSCODE:1847		      call    Check_Time_Of_Access
BIOSCODE:184A		      pop     dx
BIOSCODE:184B		      pop     cx
BIOSCODE:184C		      pop     ax
BIOSCODE:184D		      or      si, si
BIOSCODE:184F		      jz      short mediadovolid ; check_time says ">= 2 secs passed"
BIOSCODE:184F					      ;	(volume	id will	be checked)
BIOSCODE:1851		      xor     si, si	      ;	return "i don't know"
BIOSCODE:1853
BIOSCODE:1853 mediaret:				      ;	...
BIOSCODE:1853		      retn
BIOSCODE:1854 ;	---------------------------------------------------------------------------
BIOSCODE:1854
BIOSCODE:1854 mediadovolid:			      ;	...
BIOSCODE:1854		      call    GetBp	      ;	build a	new bpb	in current bds
BIOSCODE:1857		      jb      short mediaret
BIOSCODE:1859		      call    check_vid
BIOSCODE:185C		      jnb     short mediaret
BIOSCODE:185E		      jmp     maperror	      ;	fix up al for return to	dos
BIOSCODE:185E MediaCheck      endp
BIOSCODE:185E
BIOSCODE:1861
BIOSCODE:1861 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1861
BIOSCODE:1861
BIOSCODE:1861 checklatchio    proc near		      ;	...
BIOSCODE:1861		      call    chkopcnt	      ;	 [es:di+BDS.opcnt] > 0
BIOSCODE:1864		      jz      short checkret  ;	done if	zero
BIOSCODE:1866		      call    checkromchange  ;	test [es:di+BDS.flags],	fchanged ; 40h
BIOSCODE:1869		      jz      short checkret  ;	not changed
BIOSCODE:186B		      call    GetBp
BIOSCODE:186E		      jb      short ret_no_error_map
BIOSCODE:1870		      call    check_vid
BIOSCODE:1873		      jb      short checklatchret
BIOSCODE:1875		      or      si, si	      ;	is changed for sure?
BIOSCODE:1877		      jns     short checkret  ;	no
BIOSCODE:1879		      call    returnvid	      ;	yes
BIOSCODE:187C
BIOSCODE:187C checklatchret:			      ;	...
BIOSCODE:187C		      call    maperror	      ;	fix up al for return to	dos
BIOSCODE:187F
BIOSCODE:187F ret_no_error_map:			      ;	...
BIOSCODE:187F		      stc
BIOSCODE:1880		      pop     si	      ;	pop off	return address
BIOSCODE:1881
BIOSCODE:1881 checkret:				      ;	...
BIOSCODE:1881		      retn
BIOSCODE:1881 checklatchio    endp
BIOSCODE:1881
BIOSCODE:1882
BIOSCODE:1882 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1882
BIOSCODE:1882
BIOSCODE:1882 checkfatvid     proc near		      ;	...
BIOSCODE:1882		      call    fat_check	      ;	check the fat and the vid
BIOSCODE:1885		      or      si, si
BIOSCODE:1887		      js      short changed_drv	; fall into check_vid
BIOSCODE:1887 checkfatvid     endp
BIOSCODE:1887
BIOSCODE:1889
BIOSCODE:1889 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1889
BIOSCODE:1889
BIOSCODE:1889 check_vid	      proc near		      ;	...
BIOSCODE:1889		      cmp     ds:disksector+26h, 29h ; BS_FAT_BootSig ;	BS_BootSig
BIOSCODE:1889					      ;	[disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
BIOSCODE:188E		      jz      short do_ext_check_id
BIOSCODE:1890		      call    HasChange
BIOSCODE:1893		      jz      short checkret
BIOSCODE:1895		      xor     si, si
BIOSCODE:1897		      cmp     ds:disksector+10h, 0 ; BPB_NumFATs
BIOSCODE:1897					      ;	[disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]
BIOSCODE:189C		      jz      short checkfatret	; don't read vol id if not fat system
BIOSCODE:189E		      call    read_volume_id
BIOSCODE:18A1		      jb      short checkfatret
BIOSCODE:18A3		      call    check_volume_id
BIOSCODE:18A6		      mov     si, 0FFFFh      ;	-1
BIOSCODE:18A6					      ;	definitely changed
BIOSCODE:18A9		      jnz     short changed_drv
BIOSCODE:18AB		      inc     si
BIOSCODE:18AC
BIOSCODE:18AC vid_no_changed:			      ;	...
BIOSCODE:18AC		      call    resetchanged
BIOSCODE:18AF		      clc
BIOSCODE:18B0
BIOSCODE:18B0 checkfatret:			      ;	...
BIOSCODE:18B0		      retn
BIOSCODE:18B1 ;	---------------------------------------------------------------------------
BIOSCODE:18B1
BIOSCODE:18B1 changed_drv:			      ;	...
BIOSCODE:18B1		      clc		      ;	cas -- return no error
BIOSCODE:18B2		      mov     ds:tim_drv, 0FFh ; ensure	that we	ask rom	for media
BIOSCODE:18B2					      ;	 check next time round
BIOSCODE:18B7		      retn
BIOSCODE:18B8 ;	---------------------------------------------------------------------------
BIOSCODE:18B8
BIOSCODE:18B8 do_ext_check_id:			      ;	...
BIOSCODE:18B8		      push    ax
BIOSCODE:18B9		      mov     ax, word ptr ds:disksector+27h ; [DiskSector+EXT_BOOT.SERIAL]
BIOSCODE:18BC		      cmp     ax, es:[di+57h] ;	[DiskSector+EXT_BOOT.SERIAL] = [di+BDS.vol_serial] ?
BIOSCODE:18C0		      jnz     short ext_changed	; no
BIOSCODE:18C2		      mov     ax, word ptr ds:disksector+29h
BIOSCODE:18C5		      cmp     ax, es:[di+59h] ;	[DiskSector+EXT_BOOT.SERIAL+2] = [di+BDS.vol_serial+2] ?
BIOSCODE:18C9		      jnz     short ext_changed	; no
BIOSCODE:18CB		      xor     si, si	      ;	don't know
BIOSCODE:18CD		      pop     ax
BIOSCODE:18CE		      jmp     short vid_no_changed ; reset the flag
BIOSCODE:18D0 ;	---------------------------------------------------------------------------
BIOSCODE:18D0
BIOSCODE:18D0 ext_changed:			      ;	...
BIOSCODE:18D0		      pop     ax
BIOSCODE:18D1		      mov     si, 0FFFFh      ;	-1
BIOSCODE:18D1					      ;	disk changed!
BIOSCODE:18D4		      clc
BIOSCODE:18D5		      jmp     short changed_drv
BIOSCODE:18D5 check_vid	      endp
BIOSCODE:18D5
BIOSCODE:18D7
BIOSCODE:18D7 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:18D7
BIOSCODE:18D7
BIOSCODE:18D7 checkio	      proc near		      ;	...
BIOSCODE:18D7		      cmp     ah, 6
BIOSCODE:18DA		      jnz     short checkfatret
BIOSCODE:18DC		      call    chkopcnt	      ;	[es:di+BDS.opcnt] > 0 ?
BIOSCODE:18DF		      jz      short checkfatret	; no
BIOSCODE:18E1		      call    GetBp
BIOSCODE:18E4		      jb      short no_error_map
BIOSCODE:18E6		      call    checkfatvid
BIOSCODE:18E9		      jb      short checkioret ; disk error trying to read in.
BIOSCODE:18EB		      or      si, si	      ;	is changed for sure?
BIOSCODE:18ED		      js      short checkioerr ; yes changed
BIOSCODE:18EF		      inc     bp	      ;	allow a	retry
BIOSCODE:18F0		      retn
BIOSCODE:18F1 ;	---------------------------------------------------------------------------
BIOSCODE:18F1
BIOSCODE:18F1 checkioerr:			      ;	...
BIOSCODE:18F1		      call    returnvid
BIOSCODE:18F4
BIOSCODE:18F4 checkioret:			      ;	...
BIOSCODE:18F4		      stc		      ;	make sure carry	gets passed through
BIOSCODE:18F5		      jmp     harderr
BIOSCODE:18F8 ;	---------------------------------------------------------------------------
BIOSCODE:18F8
BIOSCODE:18F8 no_error_map:			      ;	...
BIOSCODE:18F8		      jmp     harderr2
BIOSCODE:18F8 checkio	      endp
BIOSCODE:18F8
BIOSCODE:18FB
BIOSCODE:18FB ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:18FB
BIOSCODE:18FB
BIOSCODE:18FB returnvid	      proc near		      ;	...
BIOSCODE:18FB		      mov     si, 22	      ;	trans+8
BIOSCODE:18FB					      ;	offset into pointer to return value
BIOSCODE:18FE		      call    vid_into_packet
BIOSCODE:1901		      mov     ah, 6
BIOSCODE:1903		      stc
BIOSCODE:1904		      retn
BIOSCODE:1904 returnvid	      endp
BIOSCODE:1904
BIOSCODE:1905
BIOSCODE:1905 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1905
BIOSCODE:1905
BIOSCODE:1905 Media_Set_vId   proc near		      ;	...
BIOSCODE:1905		      mov     si, 15	      ;	trans+1
BIOSCODE:1908
BIOSCODE:1908 vid_into_packet:			      ;	...
BIOSCODE:1908		      push    ds
BIOSCODE:1909		      lds     bx, ds:ptrsav
BIOSCODE:190D		      add     di, 75	      ;	BDS.volid (BDS offset 75)
BIOSCODE:1910		      mov     [bx+si], di
BIOSCODE:1912		      sub     di, 75	      ;	BDS start (BDS offset 0)
BIOSCODE:1915		      mov     word ptr [bx+si+2], es
BIOSCODE:1918		      pop     ds
BIOSCODE:1919		      retn
BIOSCODE:1919 Media_Set_vId   endp
BIOSCODE:1919
BIOSCODE:191A
BIOSCODE:191A ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:191A
BIOSCODE:191A
BIOSCODE:191A hidensity	      proc near		      ;	...
BIOSCODE:191A		      test    word ptr es:[di+23h], 2 ;	check for correct drive
BIOSCODE:191A					      ;	is it special?
BIOSCODE:191A					      ;	[es:di+BDS.flags], fchangeline
BIOSCODE:1920		      jz      short dofloppy  ;	no, do normal floppy test
BIOSCODE:1922		      cmp     byte ptr es:[di+22h], 2 ;	is it single-media?
BIOSCODE:1927		      jz      short dofloppy  ;	[es:di+BDS.formfactor],	ffSmall
BIOSCODE:1927					      ;	yes, use fatid.
BIOSCODE:1929		      cmp     ah, 0F9h
BIOSCODE:192C		      jnz     short dofloppy
BIOSCODE:192E		      cmp     byte ptr es:[di+22h], 7 ;	[es:di+BDS.formfactor],	ffOther
BIOSCODE:1933		      jz      short Is720K
BIOSCODE:1935		      cmp     byte ptr es:[di+22h], 9 ;	[es:di+BDS.formfactor],	ff288
BIOSCODE:193A		      jz      short Is720K
BIOSCODE:193C		      mov     al, 7	      ;	seven sectors /	fat
BIOSCODE:193E		      mov     bx, 0E00Fh      ;	224*256+0Fh (57359)
BIOSCODE:193E					      ;	224 root dir entries & 0Fh sector max
BIOSCODE:1941		      mov     cx, 2400	      ;	80*15*2
BIOSCODE:1941					      ;	80 tracks, 15 sectors/track, 2 sides
BIOSCODE:1944		      mov     dx, 258	      ;	1*256+2
BIOSCODE:1944					      ;	sectors/allocation unit	& head max
BIOSCODE:1947		      add     sp, 2	      ;	pop off	return address
BIOSCODE:194A		      jmp     Has1	      ;	return to tail of getbp
BIOSCODE:194D ;	---------------------------------------------------------------------------
BIOSCODE:194D
BIOSCODE:194D Is720K:				      ;	...
BIOSCODE:194D		      add     sp, 2	      ;	pop off	return address
BIOSCODE:1950		      jmp     Has720K	      ;	return to 720K code
BIOSCODE:1953 ;	---------------------------------------------------------------------------
BIOSCODE:1953
BIOSCODE:1953 dofloppy:				      ;	...
BIOSCODE:1953		      retn
BIOSCODE:1953 hidensity	      endp
BIOSCODE:1953
BIOSCODE:1954
BIOSCODE:1954 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1954
BIOSCODE:1954
BIOSCODE:1954 Set_Changed_DL  proc near		      ;	...
BIOSCODE:1954		      push    es
BIOSCODE:1955		      push    di
BIOSCODE:1956		      les     di, dword	ptr ds:start_bds
BIOSCODE:195A
BIOSCODE:195A scan_bds:				      ;	...
BIOSCODE:195A		      cmp     es:[di+4], dl   ;	[es:di+BDS.drivenum]
BIOSCODE:195E		      jnz     short get_next_bds
BIOSCODE:1960		      or      es:[di+23h], bx ;	[es:di+BDS.flags]
BIOSCODE:1960					      ;	signal change on other drive
BIOSCODE:1964
BIOSCODE:1964 get_next_bds:			      ;	...
BIOSCODE:1964		      les     di, es:[di]     ;	[es:di+BDS.link]
BIOSCODE:1964					      ;	go to next bds
BIOSCODE:1967		      cmp     di, 0FFFFh      ;	loop unless end	of chain
BIOSCODE:196A		      jnz     short scan_bds
BIOSCODE:196C		      pop     di
BIOSCODE:196D		      pop     es
BIOSCODE:196E		      retn
BIOSCODE:196E Set_Changed_DL  endp
BIOSCODE:196E
BIOSCODE:196F
BIOSCODE:196F ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:196F
BIOSCODE:196F
BIOSCODE:196F checkromchange  proc near		      ;	...
BIOSCODE:196F		      test    word ptr es:[di+23h], 40h	; [es:di+BDS.flags], fchanged
BIOSCODE:1975		      retn
BIOSCODE:1975 checkromchange  endp
BIOSCODE:1975
BIOSCODE:1976
BIOSCODE:1976 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1976
BIOSCODE:1976
BIOSCODE:1976 resetchanged    proc near		      ;	...
BIOSCODE:1976		      and     word ptr es:[di+23h], 0FFBFh ; [es:di+BDS.flags],	~fchanged
BIOSCODE:197B		      retn
BIOSCODE:197B resetchanged    endp
BIOSCODE:197B
BIOSCODE:197C
BIOSCODE:197C ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:197C
BIOSCODE:197C
BIOSCODE:197C HasChange	      proc near		      ;	...
BIOSCODE:197C		      test    word ptr es:[di+23h], 2 ;	[es:di+BDS.flags], fchangeline
BIOSCODE:1982		      retn
BIOSCODE:1982 HasChange	      endp
BIOSCODE:1982
BIOSCODE:1983
BIOSCODE:1983 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1983
BIOSCODE:1983
BIOSCODE:1983 set_volume_id   proc near		      ;	...
BIOSCODE:1983		      push    dx
BIOSCODE:1984		      push    ax
BIOSCODE:1985		      call    HasChange	      ;	does drive have	changeline support?
BIOSCODE:1988		      jz      short setvret   ;	no, get	out
BIOSCODE:198A		      call    read_volume_id
BIOSCODE:198D		      jb      short seterr
BIOSCODE:198F		      call    transfer_volume_id ; copy	the volume id to special drive
BIOSCODE:1992		      call    resetchanged
BIOSCODE:1995
BIOSCODE:1995 setvret:				      ;	...
BIOSCODE:1995		      clc
BIOSCODE:1996		      pop     ax
BIOSCODE:1997		      pop     dx
BIOSCODE:1998		      retn
BIOSCODE:1999 ;	---------------------------------------------------------------------------
BIOSCODE:1999
BIOSCODE:1999 seterr:				      ;	...
BIOSCODE:1999		      pop     dx	      ;	pop stack but don't overwrite ax
BIOSCODE:199A		      pop     dx
BIOSCODE:199B		      retn
BIOSCODE:199B set_volume_id   endp
BIOSCODE:199B
BIOSCODE:199B ;	---------------------------------------------------------------------------
BIOSCODE:199C root_sec	      dw 0		      ;	...
BIOSCODE:199E
BIOSCODE:199E ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:199E
BIOSCODE:199E
BIOSCODE:199E read_volume_id  proc near		      ;	...
BIOSCODE:199E		      push    dx
BIOSCODE:199F		      push    cx
BIOSCODE:19A0		      push    bx
BIOSCODE:19A1		      push    ax
BIOSCODE:19A2		      push    es	      ;	stack the bds last
BIOSCODE:19A3		      push    di
BIOSCODE:19A4		      push    ds	      ;	point es to Bios_Data (BIOSDATA)
BIOSCODE:19A5		      pop     es
BIOSCODE:19A6		      mov     di, offset tmp_vid ; "NO NAME    "
BIOSCODE:19A9		      mov     si, offset nul_vid ; "NO NAME    "
BIOSCODE:19AC		      mov     cx, 12	      ;	initialize tmp_vid to null vi_id
BIOSCODE:19AF		      rep movsb
BIOSCODE:19B1		      pop     di
BIOSCODE:19B2		      pop     es
BIOSCODE:19B3		      mov     al, es:[di+0Bh] ;	[es:di+BDS.fats]
BIOSCODE:19B3					      ;	# of fats
BIOSCODE:19B7		      mov     cx, es:[di+11h] ;	[es:di+BDS.fatsecs]
BIOSCODE:19B7					      ;	sectors	/ fat
BIOSCODE:19BB		      mul     cl
BIOSCODE:19BD		      add     ax, es:[di+9]   ;	[es:di+BDS.resectors]
BIOSCODE:19BD					      ;	add on reserved	sectors
BIOSCODE:19BD					      ;	now, ax	is sector # (0 based)
BIOSCODE:19C1		      mov     cs:root_sec, ax
BIOSCODE:19C5		      mov     ax, es:[di+0Ch] ;	[es:di+BDS.direntries]
BIOSCODE:19C5					      ;	# root dir entries
BIOSCODE:19C9		      mov     cl, 4	      ;	16 entries/sector
BIOSCODE:19CB		      shr     ax, cl	      ;	divide by 16
BIOSCODE:19CD		      mov     cx, ax	      ;	cx is #	of sectors to scan
BIOSCODE:19CF
BIOSCODE:19CF next_sec:				      ;	...
BIOSCODE:19CF		      push    cx	      ;	save outer loop	counter
BIOSCODE:19D0		      mov     ax, cs:root_sec ;	get sector #
BIOSCODE:19D4		      mov     cx, es:[di+13h] ;	[es:di+BDS.secpertrack]
BIOSCODE:19D4					      ;	sectors	/ track
BIOSCODE:19D8		      xor     dx, dx
BIOSCODE:19DA		      div     cx
BIOSCODE:19DC		      inc     dx	      ;	dx = sectors into track
BIOSCODE:19DC					      ;	ax = track count from 0
BIOSCODE:19DD		      mov     cl, dl	      ;	sector to read
BIOSCODE:19DF		      xor     dx, dx
BIOSCODE:19E1		      div     word ptr es:[di+15h] ; [es:di+BDS.heads]
BIOSCODE:19E1					      ;	# heads	on this	disc
BIOSCODE:19E5		      mov     dh, dl	      ;	head number
BIOSCODE:19E7		      mov     ch, al	      ;	track #
BIOSCODE:19E9		      call    read_sector     ;	get first sector of the	root directory,
BIOSCODE:19E9					      ;	ds:bx -> directory sector
BIOSCODE:19EC		      jb      short readviderr
BIOSCODE:19EE		      mov     cx, 16	      ;	# of dir entries in a block of root
BIOSCODE:19F1		      mov     al, 8	      ;	volume label bit
BIOSCODE:19F3
BIOSCODE:19F3 fvid_loop:			      ;	...
BIOSCODE:19F3		      cmp     byte ptr [bx], 0 ; end of	dir?
BIOSCODE:19F6		      jz      short no_vid    ;	yes, no	vol id
BIOSCODE:19F8		      cmp     byte ptr [bx], 0E5h ; empty entry?
BIOSCODE:19FB		      jz      short ent_loop  ;	yes, skip
BIOSCODE:19FD		      test    [bx+11], al     ;	is volume label	bit set	in fcb?
BIOSCODE:1A00		      jnz     short found_vid ;	yes
BIOSCODE:1A02
BIOSCODE:1A02 ent_loop:				      ;	...
BIOSCODE:1A02		      add     bx, 32	      ;	add length of directory	entry
BIOSCODE:1A05		      loop    fvid_loop
BIOSCODE:1A07		      pop     cx	      ;	outer loop
BIOSCODE:1A08		      inc     cs:root_sec     ;	inc word [root_sec]
BIOSCODE:1A08					      ;	next sector
BIOSCODE:1A0D		      loop    next_sec	      ;	continue
BIOSCODE:1A0F
BIOSCODE:1A0F notfound:				      ;	...
BIOSCODE:1A0F		      xor     si, si
BIOSCODE:1A11		      jmp     short fvid_ret
BIOSCODE:1A13 ;	---------------------------------------------------------------------------
BIOSCODE:1A13
BIOSCODE:1A13 found_vid:			      ;	...
BIOSCODE:1A13		      pop     cx	      ;	clean stack of outer loop counter
BIOSCODE:1A14		      mov     si, bx	      ;	point to volume_id
BIOSCODE:1A16		      push    es	      ;	preserve current bds
BIOSCODE:1A17		      push    di
BIOSCODE:1A18		      push    ds	      ;	point es to Bios_Data (BIOSDATA)
BIOSCODE:1A19		      pop     es
BIOSCODE:1A1A		      mov     di, offset tmp_vid ; "NO NAME    "
BIOSCODE:1A1D		      mov     cx, 11	      ;	VOLID_SIZ-1
BIOSCODE:1A1D					      ;	length of string minus nul
BIOSCODE:1A20		      rep movsb
BIOSCODE:1A22		      xor     al, al
BIOSCODE:1A24		      stosb		      ;	null terminate
BIOSCODE:1A25		      xor     si, si
BIOSCODE:1A27		      pop     di	      ;	restore	current	bds
BIOSCODE:1A28		      pop     es
BIOSCODE:1A29
BIOSCODE:1A29 fvid_ret:				      ;	...
BIOSCODE:1A29		      pop     ax
BIOSCODE:1A2A		      clc
BIOSCODE:1A2B
BIOSCODE:1A2B rvidret:				      ;	...
BIOSCODE:1A2B		      pop     bx
BIOSCODE:1A2C		      pop     cx
BIOSCODE:1A2D		      pop     dx
BIOSCODE:1A2E		      retn
BIOSCODE:1A2F ;	---------------------------------------------------------------------------
BIOSCODE:1A2F
BIOSCODE:1A2F no_vid:				      ;	...
BIOSCODE:1A2F		      pop     cx
BIOSCODE:1A30		      jmp     short notfound
BIOSCODE:1A32 ;	---------------------------------------------------------------------------
BIOSCODE:1A32
BIOSCODE:1A32 readviderr:			      ;	...
BIOSCODE:1A32		      pop     si
BIOSCODE:1A33		      pop     si
BIOSCODE:1A34		      jmp     short rvidret
BIOSCODE:1A34 read_volume_id  endp
BIOSCODE:1A34
BIOSCODE:1A36
BIOSCODE:1A36 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1A36
BIOSCODE:1A36
BIOSCODE:1A36 transfer_volume_id proc near	      ;	...
BIOSCODE:1A36		      push    di
BIOSCODE:1A37		      push    si
BIOSCODE:1A38		      push    cx
BIOSCODE:1A39		      mov     si, offset tmp_vid ; "NO NAME    "
BIOSCODE:1A3C		      add     di, 75	      ;	BDS.volid
BIOSCODE:1A3F		      mov     cx, 12	      ;	VOLID_SIZ
BIOSCODE:1A42		      cld
BIOSCODE:1A43		      rep movsb
BIOSCODE:1A45		      pop     cx
BIOSCODE:1A46		      pop     si
BIOSCODE:1A47		      pop     di
BIOSCODE:1A48		      retn
BIOSCODE:1A48 transfer_volume_id endp
BIOSCODE:1A48
BIOSCODE:1A49
BIOSCODE:1A49 ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1A49
BIOSCODE:1A49
BIOSCODE:1A49 check_volume_id proc near		      ;	...
BIOSCODE:1A49		      push    di
BIOSCODE:1A4A		      push    cx
BIOSCODE:1A4B		      mov     si, offset tmp_vid ; "NO NAME    "
BIOSCODE:1A4E		      add     di, 75	      ;	BDS.volid
BIOSCODE:1A51		      mov     cx, 12	      ;	VOLID_SIZ
BIOSCODE:1A54		      cld
BIOSCODE:1A55		      repe cmpsb
BIOSCODE:1A57		      pop     cx
BIOSCODE:1A58		      pop     di
BIOSCODE:1A59		      retn
BIOSCODE:1A59 check_volume_id endp
BIOSCODE:1A59
BIOSCODE:1A5A
BIOSCODE:1A5A ;	===============	S U B R	O U T I	N E =======================================
BIOSCODE:1A5A
BIOSCODE:1A5A
BIOSCODE:1A5A fat_check	      proc near		      ;	...
BIOSCODE:1A5A		      push    ax
BIOSCODE:1A5B		      xor     si, si	      ;	say fat	id's are same.
BIOSCODE:1A5D		      mov     al, ds:medbyt
BIOSCODE:1A60		      cmp     al, es:[di+10h] ;	[es:di+BDS.media]
BIOSCODE:1A60					      ;	compare	it with	the bds	medbyte
BIOSCODE:1A64		      jz      short okret1
BIOSCODE:1A66		      dec     si
BIOSCODE:1A67
BIOSCODE:1A67 okret1:				      ;	...
BIOSCODE:1A67		      pop     ax
BIOSCODE:1A68		      retn
BIOSCODE:1A68 fat_check	      endp
BIOSCODE:1A68
BIOSCODE:1A68 ;	---------------------------------------------------------------------------
BIOSCODE:1A69		      db 7 dup(0)
BIOSCODE:1A69 BIOSCODE	      ends
BIOSCODE:1A69
SYSINIT:0000 ; ===========================================================================
SYSINIT:0000
SYSINIT:0000 ; Segment type: Regular
SYSINIT:0000 SYSINIT	     segment byte public 'SYSINIT' use16
SYSINIT:0000		     assume cs:SYSINIT
SYSINIT:0000		     assume es:nothing,	ss:nothing, ds:nothing,	fs:nothing, gs:nothing
SYSINIT:0000 SYSINIT$	     dw	0
SYSINIT:0002 stackcount	     dw	0		     ; ...
SYSINIT:0004 stackat	     dw	0		     ; ...
SYSINIT:0006 stacksize	     dw	0		     ; ...
SYSINIT:0008 stacks	     dw	2 dup(0)	     ; ...
SYSINIT:000C firstentry	     dw	offset stacks	     ; ...
SYSINIT:000C					     ; stacks+(defaultcount*entrysize)-entrysize
SYSINIT:000E lastentry	     dw	48h		     ; ...
SYSINIT:000E					     ; stacks+(defaultcount*entrysize)-entrysize
SYSINIT:0010 nextentry	     dw	48h		     ; ...
SYSINIT:0012 old02	     dd	0		     ; ...
SYSINIT:0016 ; ---------------------------------------------------------------------------
SYSINIT:0016
SYSINIT:0016 int02:				     ; ...
SYSINIT:0016		     push    ax
SYSINIT:0017		     push    es
SYSINIT:0018		     mov     ax, 0F000h
SYSINIT:001B		     mov     es, ax
SYSINIT:001D		     assume es:nothing
SYSINIT:001D		     cmp     byte ptr es:0FFFEh, 0F9h ;	mdl_convert ; check if convertible
SYSINIT:0023		     pop     es
SYSINIT:0024		     assume es:nothing
SYSINIT:0024		     jnz     short normal02
SYSINIT:0026		     in	     al, 62h	     ; PC/XT PPI port C. Bits:
SYSINIT:0026					     ; 0-3: values of DIP switches
SYSINIT:0026					     ; 5: 1=Timer 2 channel out
SYSINIT:0026					     ; 6: 1=I/O	channel	check
SYSINIT:0026					     ; 7: 1=RAM	parity check error occurred.
SYSINIT:0028		     test    al, 80h
SYSINIT:002A		     jz	     short normal02
SYSINIT:002C		     pop     ax
SYSINIT:002D		     jmp     cs:old02
SYSINIT:0032 ; ---------------------------------------------------------------------------
SYSINIT:0032
SYSINIT:0032 normal02:				     ; ...
SYSINIT:0032		     pop     ax
SYSINIT:0033		     call    near ptr do_int_stacks
SYSINIT:0033 ; ---------------------------------------------------------------------------
SYSINIT:0036		     dw	offset old02
SYSINIT:0038 old08	     dd	0		     ; ...
SYSINIT:003C ; ---------------------------------------------------------------------------
SYSINIT:003C
SYSINIT:003C int08:				     ; ...
SYSINIT:003C		     call    near ptr do_int_stacks
SYSINIT:003C ; ---------------------------------------------------------------------------
SYSINIT:003F		     dw	offset old08
SYSINIT:0041 old09	     dd	0		     ; ...
SYSINIT:0045 ; ---------------------------------------------------------------------------
SYSINIT:0045
SYSINIT:0045 int09:				     ; ...
SYSINIT:0045		     jmp     short keyboard_lbl
SYSINIT:0047 ; ---------------------------------------------------------------------------
SYSINIT:0047		     nop
SYSINIT:0047 ; ---------------------------------------------------------------------------
SYSINIT:0048		     db	0
SYSINIT:0049 ; ---------------------------------------------------------------------------
SYSINIT:0049
SYSINIT:0049 keyboard_lbl:			     ; ...
SYSINIT:0049		     call    near ptr do_int_stacks
SYSINIT:0049 ; ---------------------------------------------------------------------------
SYSINIT:004C		     dw	offset old09
SYSINIT:004E old70	     dd	0		     ; ...
SYSINIT:0052 ; ---------------------------------------------------------------------------
SYSINIT:0052
SYSINIT:0052 int70:				     ; ...
SYSINIT:0052		     call    near ptr do_int_stacks
SYSINIT:0052 ; ---------------------------------------------------------------------------
SYSINIT:0055		     dw	offset old70
SYSINIT:0057 ; ---------------------------------------------------------------------------
SYSINIT:0057
SYSINIT:0057 int0A:				     ; ...
SYSINIT:0057		     jmp     short entry_int0A_stk
SYSINIT:0057 ; ---------------------------------------------------------------------------
SYSINIT:0059 old0A	     dd	0		     ; ...
SYSINIT:005D		     dw	424Bh
SYSINIT:005F firstflag0A     db	0
SYSINIT:0060 ; ---------------------------------------------------------------------------
SYSINIT:0060		     jmp     short intret_0A
SYSINIT:0060 ; ---------------------------------------------------------------------------
SYSINIT:0062		     db	7 dup(0)
SYSINIT:0069 ; ---------------------------------------------------------------------------
SYSINIT:0069
SYSINIT:0069 entry_int0A_stk:			     ; ...
SYSINIT:0069		     call    near ptr do_int_stacks
SYSINIT:0069 ; ---------------------------------------------------------------------------
SYSINIT:006C		     dw	offset old0A
SYSINIT:006E ; ---------------------------------------------------------------------------
SYSINIT:006E
SYSINIT:006E intret_0A:				     ; ...
SYSINIT:006E		     iret
SYSINIT:006F ; ---------------------------------------------------------------------------
SYSINIT:006F
SYSINIT:006F int0B:				     ; ...
SYSINIT:006F		     jmp     short entry_int0B_stk
SYSINIT:006F ; ---------------------------------------------------------------------------
SYSINIT:0071 old0B	     dd	0		     ; ...
SYSINIT:0075		     dw	424Bh
SYSINIT:0077		     db	0
SYSINIT:0078 ; ---------------------------------------------------------------------------
SYSINIT:0078		     jmp     short intret_0B
SYSINIT:0078 ; ---------------------------------------------------------------------------
SYSINIT:007A		     db	7 dup(0)
SYSINIT:0081 ; ---------------------------------------------------------------------------
SYSINIT:0081
SYSINIT:0081 entry_int0B_stk:			     ; ...
SYSINIT:0081		     call    near ptr do_int_stacks
SYSINIT:0081 ; ---------------------------------------------------------------------------
SYSINIT:0084		     dw	offset old0B
SYSINIT:0086 ; ---------------------------------------------------------------------------
SYSINIT:0086
SYSINIT:0086 intret_0B:				     ; ...
SYSINIT:0086		     iret
SYSINIT:0087 ; ---------------------------------------------------------------------------
SYSINIT:0087
SYSINIT:0087 int0C:				     ; ...
SYSINIT:0087		     jmp     short entry_int0C_stk
SYSINIT:0087 ; ---------------------------------------------------------------------------
SYSINIT:0089 old0C	     dd	0		     ; ...
SYSINIT:008D		     dw	424Bh
SYSINIT:008F firstflag0C     db	0
SYSINIT:0090 ; ---------------------------------------------------------------------------
SYSINIT:0090		     jmp     short intret_0C
SYSINIT:0090 ; ---------------------------------------------------------------------------
SYSINIT:0092		     db	7 dup(0)
SYSINIT:0099 ; ---------------------------------------------------------------------------
SYSINIT:0099
SYSINIT:0099 entry_int0C_stk:			     ; ...
SYSINIT:0099		     call    near ptr do_int_stacks
SYSINIT:0099 ; ---------------------------------------------------------------------------
SYSINIT:009C		     dw	offset old0C
SYSINIT:009E ; ---------------------------------------------------------------------------
SYSINIT:009E
SYSINIT:009E intret_0C:				     ; ...
SYSINIT:009E		     iret
SYSINIT:009F ; ---------------------------------------------------------------------------
SYSINIT:009F
SYSINIT:009F int0D:				     ; ...
SYSINIT:009F		     jmp     short int0D_stk
SYSINIT:009F ; ---------------------------------------------------------------------------
SYSINIT:00A1 old0D	     dd	0		     ; ...
SYSINIT:00A5		     dw	424Bh
SYSINIT:00A7 firstflag0D     db	0
SYSINIT:00A8 ; ---------------------------------------------------------------------------
SYSINIT:00A8		     jmp     short intret_0D
SYSINIT:00A8 ; ---------------------------------------------------------------------------
SYSINIT:00AA		     db	7 dup(0)
SYSINIT:00B1 ; ---------------------------------------------------------------------------
SYSINIT:00B1
SYSINIT:00B1 int0D_stk:				     ; ...
SYSINIT:00B1		     call    near ptr do_int_stacks
SYSINIT:00B1 ; ---------------------------------------------------------------------------
SYSINIT:00B4		     dw	offset old0D
SYSINIT:00B6 ; ---------------------------------------------------------------------------
SYSINIT:00B6
SYSINIT:00B6 intret_0D:				     ; ...
SYSINIT:00B6		     iret
SYSINIT:00B7 ; ---------------------------------------------------------------------------
SYSINIT:00B7
SYSINIT:00B7 int0Eh:				     ; ...
SYSINIT:00B7		     jmp     short entry_int0E_stk
SYSINIT:00B7 ; ---------------------------------------------------------------------------
SYSINIT:00B9 old0E	     dd	0		     ; ...
SYSINIT:00BD		     dw	424Bh
SYSINIT:00BF firstflag0E     db	0
SYSINIT:00C0 ; ---------------------------------------------------------------------------
SYSINIT:00C0		     jmp     short intret_0E
SYSINIT:00C0 ; ---------------------------------------------------------------------------
SYSINIT:00C2		     db	7 dup(0)
SYSINIT:00C9 ; ---------------------------------------------------------------------------
SYSINIT:00C9
SYSINIT:00C9 entry_int0E_stk:			     ; ...
SYSINIT:00C9		     call    near ptr do_int_stacks
SYSINIT:00C9 ; ---------------------------------------------------------------------------
SYSINIT:00CC		     dw	offset old0E
SYSINIT:00CE ; ---------------------------------------------------------------------------
SYSINIT:00CE
SYSINIT:00CE intret_0E:				     ; ...
SYSINIT:00CE		     iret
SYSINIT:00CF ; ---------------------------------------------------------------------------
SYSINIT:00CF
SYSINIT:00CF int72:				     ; ...
SYSINIT:00CF		     jmp     short entry_int72_stk
SYSINIT:00CF ; ---------------------------------------------------------------------------
SYSINIT:00D1 old72	     dd	0		     ; ...
SYSINIT:00D5		     dw	424Bh
SYSINIT:00D7 firstflag72     db	0
SYSINIT:00D8 ; ---------------------------------------------------------------------------
SYSINIT:00D8		     jmp     short intret_72
SYSINIT:00D8 ; ---------------------------------------------------------------------------
SYSINIT:00DA		     db	7 dup(0)
SYSINIT:00E1 ; ---------------------------------------------------------------------------
SYSINIT:00E1
SYSINIT:00E1 entry_int72_stk:			     ; ...
SYSINIT:00E1		     call    near ptr do_int_stacks
SYSINIT:00E1 ; ---------------------------------------------------------------------------
SYSINIT:00E4		     dw	offset old72
SYSINIT:00E6 ; ---------------------------------------------------------------------------
SYSINIT:00E6
SYSINIT:00E6 intret_72:				     ; ...
SYSINIT:00E6		     iret
SYSINIT:00E7 ; ---------------------------------------------------------------------------
SYSINIT:00E7
SYSINIT:00E7 int73:				     ; ...
SYSINIT:00E7		     jmp     short entry_int73_stk
SYSINIT:00E7 ; ---------------------------------------------------------------------------
SYSINIT:00E9 old73	     dd	0		     ; ...
SYSINIT:00ED		     dw	424Bh
SYSINIT:00EF firstflag73     db	0
SYSINIT:00F0 ; ---------------------------------------------------------------------------
SYSINIT:00F0		     jmp     short intret_73
SYSINIT:00F0 ; ---------------------------------------------------------------------------
SYSINIT:00F2		     db	7 dup(0)
SYSINIT:00F9 ; ---------------------------------------------------------------------------
SYSINIT:00F9
SYSINIT:00F9 entry_int73_stk:			     ; ...
SYSINIT:00F9		     call    near ptr do_int_stacks
SYSINIT:00F9 ; ---------------------------------------------------------------------------
SYSINIT:00FC		     dw	offset old73
SYSINIT:00FE ; ---------------------------------------------------------------------------
SYSINIT:00FE
SYSINIT:00FE intret_73:				     ; ...
SYSINIT:00FE		     iret
SYSINIT:00FF ; ---------------------------------------------------------------------------
SYSINIT:00FF
SYSINIT:00FF int74:				     ; ...
SYSINIT:00FF		     jmp     short entry_int74_stk
SYSINIT:00FF ; ---------------------------------------------------------------------------
SYSINIT:0101 old74	     dd	0		     ; ...
SYSINIT:0105		     dw	424Bh
SYSINIT:0107 firstflag74     db	0
SYSINIT:0108 ; ---------------------------------------------------------------------------
SYSINIT:0108		     jmp     short intret_74
SYSINIT:0108 ; ---------------------------------------------------------------------------
SYSINIT:010A		     db	7 dup(0)
SYSINIT:0111 ; ---------------------------------------------------------------------------
SYSINIT:0111
SYSINIT:0111 entry_int74_stk:			     ; ...
SYSINIT:0111		     call    near ptr do_int_stacks
SYSINIT:0111 ; ---------------------------------------------------------------------------
SYSINIT:0114		     dw	offset old74
SYSINIT:0116 ; ---------------------------------------------------------------------------
SYSINIT:0116
SYSINIT:0116 intret_74:				     ; ...
SYSINIT:0116		     iret
SYSINIT:0117 ; ---------------------------------------------------------------------------
SYSINIT:0117
SYSINIT:0117 int76:				     ; ...
SYSINIT:0117		     jmp     short entry_int76_stk
SYSINIT:0117 ; ---------------------------------------------------------------------------
SYSINIT:0119 old76	     dd	0		     ; ...
SYSINIT:011D		     dw	424Bh
SYSINIT:011F firstflag76     db	0
SYSINIT:0120 ; ---------------------------------------------------------------------------
SYSINIT:0120		     jmp     short intret_76
SYSINIT:0120 ; ---------------------------------------------------------------------------
SYSINIT:0122		     db	7 dup(0)
SYSINIT:0129 ; ---------------------------------------------------------------------------
SYSINIT:0129
SYSINIT:0129 entry_int76_stk:			     ; ...
SYSINIT:0129		     call    near ptr do_int_stacks
SYSINIT:0129 ; ---------------------------------------------------------------------------
SYSINIT:012C		     dw	offset old76
SYSINIT:012E ; ---------------------------------------------------------------------------
SYSINIT:012E
SYSINIT:012E intret_76:				     ; ...
SYSINIT:012E		     iret
SYSINIT:012F ; ---------------------------------------------------------------------------
SYSINIT:012F
SYSINIT:012F int77:				     ; ...
SYSINIT:012F		     jmp     short entry_int77_stk
SYSINIT:012F ; ---------------------------------------------------------------------------
SYSINIT:0131 old77	     dd	0		     ; ...
SYSINIT:0135		     dw	424Bh
SYSINIT:0137 firstflag77     db	0
SYSINIT:0138 ; ---------------------------------------------------------------------------
SYSINIT:0138		     jmp     short intret_77
SYSINIT:0138 ; ---------------------------------------------------------------------------
SYSINIT:013A		     db	7 dup(0)
SYSINIT:0141 ; ---------------------------------------------------------------------------
SYSINIT:0141
SYSINIT:0141 entry_int77_stk:			     ; ...
SYSINIT:0141		     call    near ptr do_int_stacks
SYSINIT:0141 ; ---------------------------------------------------------------------------
SYSINIT:0144		     dw	offset old77
SYSINIT:0146 ; ---------------------------------------------------------------------------
SYSINIT:0146
SYSINIT:0146 intret_77:				     ; ...
SYSINIT:0146		     iret
SYSINIT:0147
SYSINIT:0147 ; =============== S U B R O U T I N E =======================================
SYSINIT:0147
SYSINIT:0147
SYSINIT:0147 do_int_stacks   proc far		     ; ...
SYSINIT:0147		     push    ax
SYSINIT:0148		     push    bp
SYSINIT:0149		     push    es
SYSINIT:014A		     mov     es, cs:stacks+2 ; Get segment of stacks
SYSINIT:014F		     assume es:nothing
SYSINIT:014F		     mov     bp, cs:nextentry ;	get most likely	candidate
SYSINIT:0154		     mov     al, 1	     ; allocated
SYSINIT:0156		     xchg    al, es:[bp+0]   ; grab the	entry
SYSINIT:015A		     cmp     al, 0	     ; free ; still avail?
SYSINIT:015C		     jnz     short notfree02
SYSINIT:015E		     sub     cs:nextentry, 8 ; entrysize ; set for next	interrupt
SYSINIT:0164
SYSINIT:0164 fopund02:				     ; ...
SYSINIT:0164		     mov     es:[bp+2],	sp   ; [es:bp+savedsp],sp ; save sp value
SYSINIT:0168		     mov     word ptr es:[bp+4], ss ; [es:bp+savedss],ss ; save	ss also
SYSINIT:016C		     mov     ax, bp	     ; temp save of table offset
SYSINIT:016E		     mov     bp, es:[bp+6]   ; [es:bp+newsp] ; get new SP value
SYSINIT:0172		     cmp     es:[bp+0],	ax   ; check for offset	into table
SYSINIT:0176		     jnz     short foundbad02
SYSINIT:0178		     mov     ax, es	     ; point ss,sp to the new stack
SYSINIT:017A		     mov     es, bp
SYSINIT:017C		     assume es:nothing
SYSINIT:017C		     mov     bp, sp
SYSINIT:017E		     mov     bp, [bp+6]
SYSINIT:0181		     mov     ss, ax
SYSINIT:0183		     assume ss:nothing
SYSINIT:0183		     mov     sp, es
SYSINIT:0185		     mov     es, ax
SYSINIT:0187		     assume es:nothing
SYSINIT:0187		     mov     bp, cs:[bp+0]
SYSINIT:018B		     pushf		     ; go execute the real interrupt handler
SYSINIT:018C		     call    dword ptr cs:[bp+0] ; which will iret back	to here
SYSINIT:018C					     ; call far	[cs:bp]
SYSINIT:0190		     mov     bp, sp	     ; retrieve	the table offset for us
SYSINIT:0192		     mov     bp, es:[bp+0]   ; but leave it on the stack
SYSINIT:0196		     mov     ss, word ptr es:[bp+4] ; [es:bp+savedss] ;	get old	stack back
SYSINIT:019A		     assume ss:nothing
SYSINIT:019A		     mov     sp, es:[bp+2]   ; [es:bp+savedsp]
SYSINIT:019E		     mov     byte ptr es:[bp+0], 0 ; [es:bp+allocbyte],free ; free the entry
SYSINIT:01A3		     mov     cs:nextentry, bp ;	setup to use next time
SYSINIT:01A8		     pop     es		     ; saved on	entry
SYSINIT:01A9		     assume es:nothing
SYSINIT:01A9		     pop     bp		     ; saved on	entry
SYSINIT:01AA		     pop     ax		     ; saved on	entry
SYSINIT:01AB		     add     sp, 2	     ; (skip near call return addr)
SYSINIT:01AE		     iret		     ; done with this interrupt
SYSINIT:01AF ; ---------------------------------------------------------------------------
SYSINIT:01AF
SYSINIT:01AF notfree02:				     ; ...
SYSINIT:01AF		     cmp     al, 1	     ; allocated ; error flag
SYSINIT:01B1		     jz	     short findnext02 ;	no, continue
SYSINIT:01B3		     xchg    al, es:[bp+0]   ; [es:bp+allocbyte] ; yes,	restore	error value
SYSINIT:01B7
SYSINIT:01B7 findnext02:			     ; ...
SYSINIT:01B7		     call    longpath
SYSINIT:01BA		     jmp     short fopund02
SYSINIT:01BC ; ---------------------------------------------------------------------------
SYSINIT:01BC
SYSINIT:01BC foundbad02:			     ; ...
SYSINIT:01BC		     cmp     bp, cs:firstentry
SYSINIT:01C1		     jb	     short findnext02
SYSINIT:01C3		     mov     bp, ax	     ; flag this entry
SYSINIT:01C5		     mov     byte ptr es:[bp+0], 3 ; clobbered
SYSINIT:01CA		     jmp     short findnext02 ;	keep looking
SYSINIT:01CA do_int_stacks   endp
SYSINIT:01CA
SYSINIT:01CC
SYSINIT:01CC ; =============== S U B R O U T I N E =======================================
SYSINIT:01CC
SYSINIT:01CC
SYSINIT:01CC longpath	     proc near		     ; ...
SYSINIT:01CC		     mov     bp, cs:lastentry
SYSINIT:01D1
SYSINIT:01D1 lploopp:				     ; ...
SYSINIT:01D1		     cmp     byte ptr es:[bp+0], 0 ; free ?
SYSINIT:01D6		     jnz     short inuse     ; no, try next one
SYSINIT:01D8		     mov     al, 1
SYSINIT:01DA		     xchg    al, es:[bp+0]   ; [es:bp+allocbyte] ; allocate entry
SYSINIT:01DE		     cmp     al, 0	     ; is it still free?
SYSINIT:01E0		     jz	     short found     ; yes, go use it
SYSINIT:01E2		     cmp     al, 1	     ; allocated ?
SYSINIT:01E2					     ; is it other than	Allocated or Free?
SYSINIT:01E4		     jz	     short inuse     ; no, check the next one
SYSINIT:01E6		     mov     es:[bp+0],	al   ; yes, put	back the error state
SYSINIT:01EA
SYSINIT:01EA inuse:				     ; ...
SYSINIT:01EA		     cmp     bp, cs:firstentry
SYSINIT:01EF		     jz	     short fatal
SYSINIT:01F1		     sub     bp, 8
SYSINIT:01F4		     jmp     short lploopp
SYSINIT:01F6 ; ---------------------------------------------------------------------------
SYSINIT:01F6
SYSINIT:01F6 found:				     ; ...
SYSINIT:01F6		     retn
SYSINIT:01F7 ; ---------------------------------------------------------------------------
SYSINIT:01F7
SYSINIT:01F7 fatal:				     ; ...
SYSINIT:01F7		     push    ds
SYSINIT:01F8		     mov     ax, 0F000h	     ; look at the model byte
SYSINIT:01FB		     mov     ds, ax
SYSINIT:01FD		     assume ds:nothing
SYSINIT:01FD		     cmp     byte ptr ds:0FFFEh, 0F9h ;	mdl_convert ; convertible?
SYSINIT:0202		     pop     ds
SYSINIT:0203		     assume ds:nothing
SYSINIT:0203		     jnz     short skip_nmis
SYSINIT:0205		     mov     al, 7	     ; disable pc convertible nmis
SYSINIT:0207		     out     72h, al	     ; CMOS Memory/RTC Index Register (Extended	RAM)
SYSINIT:0209
SYSINIT:0209 skip_nmis:				     ; ...
SYSINIT:0209		     cli		     ; disable and mask
SYSINIT:020A		     mov     al, 0FFh	     ; all other ints
SYSINIT:020C		     out     21h, al	     ; Interrupt controller, 8259A.
SYSINIT:020E		     out     0A1h, al	     ; Interrupt Controller #2,	8259A
SYSINIT:0210		     mov     si, cs
SYSINIT:0212		     mov     ds, si
SYSINIT:0214		     assume ds:SYSINIT
SYSINIT:0214		     mov     si, offset	fatal_msg ; 'Internal stack overflow'
SYSINIT:0214					     ;	    'System halted
SYSINIT:0217		     push    ax
SYSINIT:0218		     push    ds
SYSINIT:0219		     mov     ax, 70h	     ; DOSBIODATASEG (BIOSDATA segment)
SYSINIT:021C		     mov     ds, ax
SYSINIT:021E		     assume ds:nothing
SYSINIT:021E		     test    ds:IsWin386, 1  ; BIOSDATA:08D0h
SYSINIT:0223		     pop     ds
SYSINIT:0224		     assume ds:nothing
SYSINIT:0224		     pop     ax
SYSINIT:0225		     jz	     short fatal_loop
SYSINIT:0227		     call    far ptr 70h:8D1h ;	call DOSBIODATASEG:V86_Crit_SetFocus
SYSINIT:022C
SYSINIT:022C fatal_loop:			     ; ...
SYSINIT:022C		     lodsb
SYSINIT:022D		     cmp     al, 24h ; '$'
SYSINIT:022F		     jz	     short fatal_done
SYSINIT:0231		     mov     bl, 7
SYSINIT:0233		     mov     ah, 0Eh
SYSINIT:0235		     int     10h	     ; (whoops,	this enables ints)
SYSINIT:0235					     ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
SYSINIT:0235					     ; AL = character, BH = display page (alpha	modes)
SYSINIT:0235					     ; BL = foreground color (graphics modes)
SYSINIT:0237		     jmp     short fatal_loop
SYSINIT:0239 ; ---------------------------------------------------------------------------
SYSINIT:0239
SYSINIT:0239 fatal_done:			     ; ...
SYSINIT:0239		     jmp     short fatal_done
SYSINIT:0239 longpath	     endp
SYSINIT:0239
SYSINIT:0239 ; ---------------------------------------------------------------------------
SYSINIT:023B fatal_msg	     db	0Dh		     ; ...
SYSINIT:023C		     db	0Ah
SYSINIT:023D		     db	7,0Dh,0Ah
SYSINIT:023D		     db	'Internal stack overflow',0Dh,0Ah
SYSINIT:023D		     db	'System halted',0Dh,0Ah,'$'
SYSINIT:0269 ; ---------------------------------------------------------------------------
SYSINIT:0269
SYSINIT:0269 _SYSINIT:				     ; ...
SYSINIT:0269		     jmp     goinit
SYSINIT:0269 ; ---------------------------------------------------------------------------
SYSINIT:026C runhigh	     db	0		     ; ...
SYSINIT:026D DOSINFO	     dd	0		     ; ...
SYSINIT:026D					     ; address of the DOS Sysini Variables
SYSINIT:0271 dosinit	     dw	0		     ; ...
SYSINIT:0273 CURRENT_DOS_LOCATION dw 0		     ; ...
SYSINIT:0275 DEVICE_LIST     dd	0		     ; ...
SYSINIT:0279 sysi_country    dd	0		     ; ...
SYSINIT:0279					     ; pointer to country table	in dos
SYSINIT:027D dos_segreinit   dd	0		     ; ...
SYSINIT:027D					     ; room for	dword
SYSINIT:0281 lo_doscod_size  dw	0		     ; ...
SYSINIT:0281					     ; dos code	size when in low mem
SYSINIT:0283 hi_doscod_size  dw	0		     ; ...
SYSINIT:0283					     ; dos code	size when in HMA
SYSINIT:0285 def_php	     dw	0		     ; ...
SYSINIT:0287 _seg_reinit_ptr dw	offset _seg_reinit   ; ...
SYSINIT:0287					     ; BIOSCODE:0032h
SYSINIT:0289 temp_bcode_seg  dw	2CCh		     ; ...
SYSINIT:0289					     ; DOSBIOCODESEG (BIOSCODE)
SYSINIT:028B fake_floppy_drv db	0		     ; ...
SYSINIT:028B					     ; set to 1	if this	machine
SYSINIT:028B					     ; does not	have any floppies!!!
SYSINIT:028C stack_count     dw	9		     ; ...
SYSINIT:028C					     ; defaultcount ; 9
SYSINIT:028E stack_size	     dw	128		     ; ...
SYSINIT:028E					     ; defaultsize  ; 128
SYSINIT:0290 stack_addr	     dw	2 dup(0)	     ; ...
SYSINIT:0294 MEMORY_SIZE     dw	1		     ; ...
SYSINIT:0296 RPLMemTop	     dw	0		     ; ...
SYSINIT:0298 DEFAULT_DRIVE   db	0		     ; ...
SYSINIT:0298					     ; initialized by ibminit
SYSINIT:0299 buffers	     dw	0FFFFh		     ; ...
SYSINIT:0299					     ; initialized during buffer allocation
SYSINIT:029B h_buffers	     dw	0		     ; ...
SYSINIT:029B					     ; # of the	heuristic buffers. initially 0.
SYSINIT:029D singlebuffersize dw 0		     ; ...
SYSINIT:029D					     ; maximum sector size + buffer head
SYSINIT:029F FILES	     db	8		     ; ...
SYSINIT:029F					     ; enough files for	pipe
SYSINIT:02A0 FCBS	     db	4		     ; ...
SYSINIT:02A0					     ; performance for recycling
SYSINIT:02A1 KEEP	     db	0		     ; ...
SYSINIT:02A1					     ; keep original set
SYSINIT:02A2 NUM_CDS	     db	5		     ; ...
SYSINIT:02A2					     ; 5 net drives
SYSINIT:02A3 CONFBOT	     dw	0		     ; ...
SYSINIT:02A5 ALLOCLIM	     dw	0		     ; ...
SYSINIT:02A7 top_of_cdss     dw	0		     ; ...
SYSINIT:02A9 DirStrng	     db	'A:\',0              ; ...
SYSINIT:02A9					     ; string for the root directory of	a drive
SYSINIT:02AD ZERO	     db	0		     ; ...
SYSINIT:02AE sepchr	     db	0		     ; ...
SYSINIT:02AF linecount	     dw	0		     ; ...
SYSINIT:02AF					     ; line count in config.sys
SYSINIT:02B1 showcount	     db	'     ',0Dh,0Ah,'$'  ; ...
SYSINIT:02B1					     ; used to convert linecount to ascii.
SYSINIT:02B9 buffer_linenum  dw	0		     ; ...
SYSINIT:02BB sys_model_byte  db	0FFh		     ; ...
SYSINIT:02BB					     ; model byte used in sysinit
SYSINIT:02BC sys_scnd_model_byte db 0		     ; ...
SYSINIT:02BC					     ; secondary model byte used in sysinit
SYSINIT:02BD buf_prev_off    dw	0		     ; ...
SYSINIT:02BF EXEC0_ENVIRON   dw	0		     ; ...
SYSINIT:02BF					     ; COMEXE ;	seg addr of environment
SYSINIT:02C1 EXEC0_COM_LINE  dw	offset command_line  ; pointer to asciz	command	line
SYSINIT:02C3		     dw	473h		     ; SYSINIT segment
SYSINIT:02C5 EXEC0_5C_FCB    dw	offset DEFAULT_DRIVE
SYSINIT:02C7		     dw	473h		     ; SYSINIT segment
SYSINIT:02C9 EXEC0_6C_FCB    dw	offset ZERO
SYSINIT:02CB		     dw	473h		     ; SYSINIT segment
SYSINIT:02CD multi_pass_id   db	0		     ; ...
SYSINIT:02CD					     ; parameter passed	to multi_pass
SYSINIT:02CD					     ; indicating the pass number
SYSINIT:02CD					     ;	0 - do scan for	DOS=HIGH/LOW
SYSINIT:02CD					     ;	1 - load device	drivers
SYSINIT:02CD					     ;	2 - was	to load	IFS
SYSINIT:02CD					     ;	    now	it is unused
SYSINIT:02CD					     ;	3 - do install=
SYSINIT:02CD					     ; >3 - nop
SYSINIT:02CE install_flag    dw	0		     ; ...
SYSINIT:02CE					     ; bit 0 - config.sys has install= commands
SYSINIT:02CE					     ; bit 1 - sysinit_base installed
SYSINIT:02D0 config_size     dw	0		     ; ...
SYSINIT:02D0					     ; size of config.sys file
SYSINIT:02D2 sysinit_base_ptr dd 0		     ; ...
SYSINIT:02D2					     ; pointer to sysinit_base
SYSINIT:02D6 sysinit_ptr     dw	2 dup(0)	     ; ...
SYSINIT:02D6					     ; returning address from sysinit_base
SYSINIT:02DA checksum	     dw	0		     ; ...
SYSINIT:02DC ldexec_fcb	     db	14h dup(20h)	     ; ...
SYSINIT:02DC					     ; db 20 dup (' ') ; big enough
SYSINIT:02F0 ldexec_line     db	0		     ; ...
SYSINIT:02F0					     ; # of parm characters
SYSINIT:02F1 ldexec_start    db	' '                  ; ...
SYSINIT:02F2 ldexec_parm     db	80 dup(0)	     ; ...
SYSINIT:02F2					     ; times 80	db 0
SYSINIT:0342 iexec_environ   dw	0		     ; ...
SYSINIT:0342					     ; instexe ; seg addr of environment
SYSINIT:0344 iexec_ldexec_line dw offset ldexec_line ; pointer to asciiz command line
SYSINIT:0346 iexec_ldexec_line_seg dw 473h	     ; ...
SYSINIT:0348 iexec_ldexec_5c_fcb dw offset ldexec_fcb ;	default	fcb at 5Ch
SYSINIT:034A iexec_ldexec_5c_fcb_seg dw	473h	     ; ...
SYSINIT:034C iexec_ldexec_6c_fcb dw offset ldexec_fcb ;	default	fcb at 6Ch
SYSINIT:034E iexec_ldexec_6c_fcb_seg dw	473h	     ; ...
SYSINIT:0350 com_level	     db	0		     ; ...
SYSINIT:0350					     ; level of	" " in command line
SYSINIT:0351 cmmt	     db	0		     ; ...
SYSINIT:0351					     ; length of comment string	token
SYSINIT:0352 cmmt1	     db	0		     ; ...
SYSINIT:0352					     ; token
SYSINIT:0353 cmmt2	     db	0		     ; ...
SYSINIT:0353					     ; token
SYSINIT:0354 cmd_indicator   db	0		     ; ...
SYSINIT:0355 donotshownum    db	0		     ; ...
SYSINIT:0356 count	     dw	0		     ; ...
SYSINIT:0358 org_count	     dw	0		     ; ...
SYSINIT:035A chrptr	     dw	0		     ; ...
SYSINIT:035C cntryfilehandle dw	0		     ; ...
SYSINIT:035E old_area	     dw	0		     ; ...
SYSINIT:0360 impossible_owner_size dw 0		     ; ...
SYSINIT:0360					     ; paragraph
SYSINIT:0362 memlo	     dw	0		     ; ...
SYSINIT:0362					     ; bufptr, bucketptr (dword)
SYSINIT:0364 memhi	     dw	0		     ; ...
SYSINIT:0364					     ; prmblk (word)
SYSINIT:0366 ldoff	     dw	0
SYSINIT:0368 area	     dw	0		     ; ...
SYSINIT:036A packet	     db	24		     ; ...
SYSINIT:036A					     ; was 22
SYSINIT:036B		     db	0
SYSINIT:036C		     db	0		     ; initialize code
SYSINIT:036D		     dw	0
SYSINIT:036F		     db	8 dup(0)
SYSINIT:0377 unitcount	     db	0		     ; ...
SYSINIT:0378 break_addr	     dw	2 dup(0)	     ; ...
SYSINIT:037C bpb_addr	     dd	0		     ; ...
SYSINIT:0380 devdrivenum     db	0		     ; ...
SYSINIT:0381 configmsgflag   db	0		     ; ...
SYSINIT:0381					     ; used to control "error in config.sys line #" message
SYSINIT:0381					     ; (configmsgflag is the last word of the 25 byte packet)
SYSINIT:0381					     ; ((default value is 0, device driver init	may change? it))
SYSINIT:0382		     db	0
SYSINIT:0383 drivenumber     db	0		     ; ...
SYSINIT:0384 toomanydrivesflag db 0		     ; ...
SYSINIT:0384					     ; >24 fixed disk partitions flag
SYSINIT:0385 BCodeSeg	     dw	2CCh		     ; ...
SYSINIT:0385					     ; DOSBIOCODESEG (BIOSCODE segment)
SYSINIT:0387 Magicbackdoor   dd	0		     ; ...
SYSINIT:038B ; ---------------------------------------------------------------------------
SYSINIT:038B
SYSINIT:038B NullBackdoor:			     ; ...
SYSINIT:038B		     retf
SYSINIT:038B ; ---------------------------------------------------------------------------
SYSINIT:038C _timer_lw_	     dw	0		     ; ...
SYSINIT:038E BiosComBlock    dw	offset SysinitPresent ;	...
SYSINIT:038E					     ; BIOSDATA:08FDh
SYSINIT:0390		     dw	70h		     ; BIOSDATA	segment
SYSINIT:0392 tempstack	     db	128 dup(0)
SYSINIT:0412 ; ---------------------------------------------------------------------------
SYSINIT:0412
SYSINIT:0412 goinit:				     ; ...
SYSINIT:0412		     mov     ah, 0C0h
SYSINIT:0414		     int     15h	     ; SYSTEM -	GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
SYSINIT:0416		     jb	     short no_rom_config
SYSINIT:0418		     cmp     ah, 0
SYSINIT:041B		     jnz     short no_rom_config
SYSINIT:041D		     mov     al, es:[bx+2]   ; [es:bx+ROMBIOS_DESC.bios_sd_modelbyte]
SYSINIT:0421		     mov     cs:sys_model_byte,	al
SYSINIT:0425		     mov     al, es:[bx+3]   ; [es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]
SYSINIT:0429		     mov     cs:sys_scnd_model_byte, al
SYSINIT:042D		     jmp     short move_myself
SYSINIT:042F ; ---------------------------------------------------------------------------
SYSINIT:042F
SYSINIT:042F no_rom_config:			     ; ...
SYSINIT:042F		     mov     ax, 0F000h
SYSINIT:0432		     mov     ds, ax
SYSINIT:0434		     assume ds:nothing
SYSINIT:0434		     mov     al, ds:0FFFEh
SYSINIT:0437		     mov     cs:sys_model_byte,	al
SYSINIT:043B		     int     11h	     ; EQUIPMENT DETERMINATION
SYSINIT:043B					     ; Return: AX = equipment flag bits
SYSINIT:043D		     test    ax, 1	     ; have any	floppies?
SYSINIT:0440		     jnz     short move_myself ; yes,normal system
SYSINIT:0442		     push    es
SYSINIT:0443		     xor     cl, cl
SYSINIT:0445		     mov     ah, 8	     ; get disk	parameters
SYSINIT:0447		     mov     dl, 0
SYSINIT:0449		     int     13h	     ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
SYSINIT:0449					     ; DL = drive number
SYSINIT:0449					     ; Return: CF set on error,	AH = status code, BL = drive type
SYSINIT:0449					     ; DL = number of consecutive drives
SYSINIT:0449					     ; DH = maximum value for head number, ES:DI -> drive parameter
SYSINIT:044B		     pop     es
SYSINIT:044C		     jb	     short move_myself ; if error lets assume that the ROM BIOS	lied
SYSINIT:044E		     cmp     cl, 0	     ; double check (max sec no	cannot be 0)
SYSINIT:0451		     jz	     short move_myself
SYSINIT:0453		     or	     dl, dl	     ; number of flp drvs == 0?
SYSINIT:0455		     jnz     short move_myself
SYSINIT:0457		     mov     cs:fake_floppy_drv, 1 ; set fake flag
SYSINIT:045D
SYSINIT:045D move_myself:			     ; ...
SYSINIT:045D		     cld		     ; set up move
SYSINIT:045E		     xor     si, si
SYSINIT:0460		     mov     di, si
SYSINIT:0462		     mov     cx, cs:MEMORY_SIZE
SYSINIT:0467		     push    cs
SYSINIT:0468		     pop     ds
SYSINIT:0469		     assume ds:SYSINIT
SYSINIT:0469		     dec     cx
SYSINIT:046A		     xor     bx, bx
SYSINIT:046C		     mov     es, bx	     ; 0
SYSINIT:046E		     assume es:nothing
SYSINIT:046E		     mov     bx, es:0BCh     ; Int 2Fh vector (4*2Fh)
SYSINIT:0473		     mov     es, es:0BEh
SYSINIT:0478		     assume es:nothing
SYSINIT:0478		     cmp     word ptr es:[bx+3], 5052h ; 'RP'
SYSINIT:047E		     jnz     short NoRPL
SYSINIT:0480		     cmp     byte ptr es:[bx+5], 4Ch ; 'L'
SYSINIT:0485		     jnz     short NoRPL
SYSINIT:0487		     mov     dx, cx	     ; get TOM into DX
SYSINIT:0489		     push    dx
SYSINIT:048A		     mov     ax, 4A06h	     ; (multMULT<<8)+multMULTRPLTOM
SYSINIT:048D		     int     2Fh	     ; Get new TOM from	any RPL
SYSINIT:048F		     pop     ax
SYSINIT:0490		     mov     cx, dx
SYSINIT:0492		     cmp     dx, ax
SYSINIT:0494		     jz	     short NoRPL
SYSINIT:0496		     mov     cs:RPLMemTop, dx
SYSINIT:049B		     dec     cx
SYSINIT:049C
SYSINIT:049C NoRPL:				     ; ...
SYSINIT:049C		     mov     ax, 58A0h	     ; SI_end ;	need this much room for	sysinit
SYSINIT:049C					     ; (SI_end == sysinit code size)
SYSINIT:049F		     call    _off_to_para
SYSINIT:04A2		     sub     cx, ax
SYSINIT:04A4		     sub     cx, 0A00h	     ; DOSSIZE/16 (2560)
SYSINIT:04A4					     ; leave this much room for	DOS
SYSINIT:04A8		     mov     ax, 1A70h	     ; BCODE_END
SYSINIT:04AB		     call    _off_to_para    ; leave this much room for	BIOS code
SYSINIT:04AE		     sub     cx, ax
SYSINIT:04B0		     mov     es, cx	     ; offset where sysinit will be located
SYSINIT:04B2		     mov     cx, 58A0h	     ; SI_end ;	(sysinit code size)
SYSINIT:04B5		     shr     cx, 1	     ; divide by 2 to get words
SYSINIT:04B7		     rep movsw		     ; relocate	sysinit
SYSINIT:04B9		     push    es		     ; push relocated segment
SYSINIT:04BA		     mov     ax, offset	SYSIN ;	SYSINIT:048Fh
SYSINIT:04BD		     push    ax		     ; push relocated entry point
SYSINIT:04BE		     retf		     ; far jump	to relocated sysinit
SYSINIT:04BF ; ---------------------------------------------------------------------------
SYSINIT:04BF
SYSINIT:04BF SYSIN:				     ; ...
SYSINIT:04BF		     mov     ax, 70h
SYSINIT:04C2		     mov     ds, ax
SYSINIT:04C4		     assume ds:nothing
SYSINIT:04C4		     mov     ds:MoveDOSIntoHMA_2, cs ; set seg of routine to move DOS
SYSINIT:04C4					     ; update SYSINITSEG field
SYSINIT:04C4					     ; MoveDOSIntoHMA+2
SYSINIT:04C8		     mov     ds:SysinitPresent,	1 ; flag that MoveDOSIntoHMA can be called
SYSINIT:04CD		     mov     ax, 58A0h	     ; SI_end ;	how big	is sysinitseg?
SYSINIT:04D0		     call    _off_to_para
SYSINIT:04D3		     mov     cx, cs	     ; pick a buffer for msdos above us
SYSINIT:04D5		     add     ax, cx
SYSINIT:04D7		     mov     es, ax
SYSINIT:04D9		     xor     si, si
SYSINIT:04DB		     mov     di, si
SYSINIT:04DD		     mov     ds, cs:CURRENT_DOS_LOCATION ; where it is (set by msinit)
SYSINIT:04E2		     assume ds:nothing
SYSINIT:04E2		     mov     cx, 5000h	     ; DOSSIZE/2 (20480)
SYSINIT:04E5		     rep movsw
SYSINIT:04E7		     mov     cs:CURRENT_DOS_LOCATION, es
SYSINIT:04EC		     mov     ax, ds:3	     ; get offset of dos
SYSINIT:04EC					     ; ax = 3DE0h for MSDOS 6.21 kernel
SYSINIT:04EC					     ;	(MSDOS.SYS, offset 3)
SYSINIT:04EF		     mov     cs:dosinit, ax
SYSINIT:04F3		     call    _off_to_para    ; subtract	this much from segment
SYSINIT:04F6		     sub     cs:CURRENT_DOS_LOCATION, ax ; FINAL_DOS_LOCATION
SYSINIT:04FB		     mov     ax, es
SYSINIT:04FD		     add     ax, 0A00h	     ; DOSSIZE/16 ; DOSSIZE = 0A000h = 40960
SYSINIT:0500		     mov     es, ax
SYSINIT:0502		     assume es:nothing
SYSINIT:0502		     xchg    ax, cs:temp_bcode_seg ; swap with original	home of	Bios_Code
SYSINIT:0507		     mov     ds, ax	     ; point to	loaded image of	Bios_Code
SYSINIT:0509		     mov     si, offset	Bios_Data_Word ; BCODESTART (= BiosDataWord)
SYSINIT:0509					     ; BIOSCODE:BCODESTART (BIOSCODE:0030h)
SYSINIT:050C		     mov     di, si
SYSINIT:050E		     mov     cx, 1A70h	     ; BCODE_END = (SYSINITSEG-DOSBIOCODESEG)*16
SYSINIT:050E					     ; (473h-2CCh)*10h = 1A70h (for MSDOS 6.21 IO.SYS)
SYSINIT:0511		     sub     cx, si
SYSINIT:0513		     shr     cx, 1
SYSINIT:0515		     rep movsw		     ; move Bios_Code into place
SYSINIT:0517		     mov     ax, es	     ; tell it what segment it's in
SYSINIT:0519		     call    dword ptr cs:_seg_reinit_ptr
SYSINIT:051E		     les     di, dword ptr cs:BiosComBlock
SYSINIT:0523		     assume es:nothing
SYSINIT:0523		     lds     si, cs:DEVICE_LIST
SYSINIT:0528		     mov     dx, cs:MEMORY_SIZE
SYSINIT:052D		     cli
SYSINIT:052E		     mov     ax, cs
SYSINIT:0530		     mov     ss, ax
SYSINIT:0532		     assume ss:SYSINIT
SYSINIT:0532
SYSINIT:0532 locstack:				     ; ...
SYSINIT:0532		     mov     sp, offset	locstack ; set stack
SYSINIT:0532					     ; mov sp, 532h ; mov sp, locstack
SYSINIT:0532					     ; %define locstack	($ - SYSINIT$) & 0FFFEh
SYSINIT:0532					     ; locstack	= $ & 0FFFEh (SYSINIT:SYSINIT=473h:0)
SYSINIT:0535		     sti
SYSINIT:0536		     call    dword ptr cs:dosinit ; call dosinit
SYSINIT:0536					     ; es:di ->	sysinitvars_ext
SYSINIT:053B		     mov     cs:def_php, ds  ; save pointer to PSP
SYSINIT:0540		     mov     cs:hi_doscod_size,	ax ; size of doscode (including	exepatch)
SYSINIT:0544		     mov     cs:lo_doscod_size,	cx ; (as exepatch excluded)
SYSINIT:0549		     mov     word ptr cs:dos_segreinit,	dx ; save offset of segreinit
SYSINIT:054E		     mov     ax, es:[di]     ; [es:di+SysInitVars_Ext.SYSI_InitVars]
SYSINIT:0551		     mov     word ptr cs:DOSINFO, ax
SYSINIT:0555		     mov     ax, es:[di+2]   ; [es:di+SysInitVars_Ext.SYSI_InitVars+2]
SYSINIT:0559		     mov     word ptr cs:DOSINFO+2, ax
SYSINIT:055D		     mov     ax, es:[di+4]   ; [es:di+SysInitVars_Ext.SYSI_Country_Tab]
SYSINIT:0561		     mov     word ptr cs:sysi_country, ax
SYSINIT:0565		     mov     ax, es:[di+6]   ; [es:di+SysInitVars_Ext.SYSI_Country_Tab+2]
SYSINIT:0569		     mov     word ptr cs:sysi_country+2, ax
SYSINIT:056D		     mov     es, cs:CURRENT_DOS_LOCATION ; = [FINAL_DOS_LOCATION]
SYSINIT:0572		     mov     word ptr cs:dos_segreinit+2, es
SYSINIT:0577		     cmp     cs:RPLMemTop, 0
SYSINIT:057D		     jz	     short NoRPLArena
SYSINIT:057F		     mov     bx, 0FFFFh
SYSINIT:0582		     mov     ah, 48h
SYSINIT:0584		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:0584					     ; BX = number of 16-byte paragraphs desired
SYSINIT:0586		     mov     ah, 48h
SYSINIT:0588		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:0588					     ; BX = number of 16-byte paragraphs desired
SYSINIT:058A		     mov     es, ax
SYSINIT:058C		     push    es		     ; resize upto RPL mem
SYSINIT:058D		     sub     ax, cs:RPLMemTop
SYSINIT:0592		     neg     ax
SYSINIT:0594		     dec     ax
SYSINIT:0595		     mov     bx, ax
SYSINIT:0597		     mov     ah, 4Ah
SYSINIT:0599		     int     21h	     ; DOS - 2+	- ADJUST MEMORY	BLOCK SIZE (SETBLOCK)
SYSINIT:0599					     ; ES = segment address of block to	change
SYSINIT:0599					     ; BX = new	size in	paragraphs
SYSINIT:059B		     mov     bx, 0FFFFh
SYSINIT:059E		     mov     ah, 48h
SYSINIT:05A0		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:05A0					     ; BX = number of 16-byte paragraphs desired
SYSINIT:05A2		     mov     ah, 48h
SYSINIT:05A4		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:05A4					     ; BX = number of 16-byte paragraphs desired
SYSINIT:05A6		     dec     ax
SYSINIT:05A7		     mov     es, ax
SYSINIT:05A9		     mov     word ptr es:1, 8 ;	[es:arena_owner]
SYSINIT:05B0		     mov     word ptr es:8, 5052h ; [es:arena_name],'RP'
SYSINIT:05B7		     mov     word ptr es:0Ah, 4Ch ; [es:arena_name+2],'L'
SYSINIT:05BE		     mov     word ptr es:0Ch, 0	; [es:arena_name+4]
SYSINIT:05C5		     mov     word ptr es:0Eh, 0	; [es:arena_name+6]
SYSINIT:05CC		     pop     es
SYSINIT:05CD		     mov     ah, 49h
SYSINIT:05CF		     int     21h	     ; DOS - 2+	- FREE MEMORY
SYSINIT:05CF					     ; ES = segment address of area to be freed
SYSINIT:05D1
SYSINIT:05D1 NoRPLArena:			     ; ...
SYSINIT:05D1		     les     di, cs:DOSINFO
SYSINIT:05D6		     clc
SYSINIT:05D7		     mov     ah, 88h
SYSINIT:05D9		     int     15h	     ; EXTENDED	MEMORY - GET MEMORY SIZE (AT,XT286,PS)
SYSINIT:05D9					     ; Return: AX = memory size	in K
SYSINIT:05DB		     jb	     short no_ext_memory
SYSINIT:05DD		     mov     es:[di+45h], ax ; [es:di+SYSI_EXT_MEM],ax
SYSINIT:05DD					     ; save extended memory size
SYSINIT:05E1		     or	     ax, ax
SYSINIT:05E3		     jz	     short no_ext_memory
SYSINIT:05E5		     call    ClrVDISKHeader
SYSINIT:05E8
SYSINIT:05E8 no_ext_memory:			     ; ...
SYSINIT:05E8		     mov     ax, es:[di+10h] ; [es:di+SYSI_MAXSEC] ; get the sector size
SYSINIT:05EC		     add     ax, 20	     ; bufinsiz	; size of buffer header
SYSINIT:05EF		     mov     cs:singlebuffersize, ax
SYSINIT:05F3		     mov     al, cs:DEFAULT_DRIVE
SYSINIT:05F7		     mov     es:[di+43h], al ; [es:di+SYSI_BOOT_DRIVE]
SYSINIT:05FB
SYSINIT:05FB _get_cpu_type_:
SYSINIT:05FB		     pushf
SYSINIT:05FC		     push    bx
SYSINIT:05FD		     xor     bx, bx
SYSINIT:05FF		     xor     ax, ax
SYSINIT:0601		     push    ax
SYSINIT:0602		     popf
SYSINIT:0603		     pushf
SYSINIT:0604		     pop     ax
SYSINIT:0605		     and     ax, 0F000h
SYSINIT:0608		     cmp     ax, 0F000h
SYSINIT:060B		     jz	     short _cpu_8086
SYSINIT:060D		     mov     ax, 0F000h
SYSINIT:0610		     push    ax
SYSINIT:0611		     popf
SYSINIT:0612		     pushf
SYSINIT:0613		     pop     ax
SYSINIT:0614		     and     ax, 0F000h
SYSINIT:0617		     jz	     short _cpu_286
SYSINIT:0619
SYSINIT:0619 _cpu_386:
SYSINIT:0619		     inc     bx
SYSINIT:061A
SYSINIT:061A _cpu_286:				     ; ...
SYSINIT:061A		     inc     bx
SYSINIT:061B
SYSINIT:061B _cpu_8086:				     ; ...
SYSINIT:061B		     mov     ax, bx
SYSINIT:061D		     pop     bx
SYSINIT:061E		     popf
SYSINIT:061F		     cmp     ax, 2
SYSINIT:0622		     jnz     short _not_386_cpu
SYSINIT:0624		     mov     byte ptr es:[di+44h], 1 ; [es:di+SYSI_DWMOVE],1
SYSINIT:0624					     ; set doubleword moving flag
SYSINIT:0629
SYSINIT:0629 _not_386_cpu:			     ; ...
SYSINIT:0629		     mov     al, es:[di+20h] ; [es:di+SYSI_NUMIO]
SYSINIT:062D		     mov     cs:drivenumber, al	; save start of	installable block drvs
SYSINIT:0631		     mov     ax, cs
SYSINIT:0633		     sub     ax, 11h	     ; room for	PSP we will copy shortly
SYSINIT:0636		     mov     cx, cs:singlebuffersize ; temporary single	buffer area
SYSINIT:063B		     shr     cx, 1
SYSINIT:063D		     shr     cx, 1
SYSINIT:063F		     shr     cx, 1
SYSINIT:0641		     shr     cx, 1	     ; divide size by 16..
SYSINIT:0641					     ; ...to get paragraphs...
SYSINIT:0643		     inc     cx		     ; ... and round up
SYSINIT:0644		     sub     ax, cx
SYSINIT:0646		     mov     cs:top_of_cdss, ax	; temp "unsafe"	location
SYSINIT:064A		     push    es
SYSINIT:064B		     push    di
SYSINIT:064C		     mov     cx, ax	     ; save pointer for	buffer
SYSINIT:064E		     sub     ax, 143	     ; sub ax,((26 *(curdirlen))+15)/16
SYSINIT:064E					     ; (curdirlen=88)
SYSINIT:0651		     mov     cs:ALLOCLIM, ax
SYSINIT:0655		     mov     cs:CONFBOT, ax
SYSINIT:0659		     les     di, es:[di+12h] ; [es:di+SYSI_BUF]
SYSINIT:065D		     mov     word ptr es:[di+4], 0 ; [es:di+BUFFINF.Dirty_Buff_Count]
SYSINIT:0663		     mov     word ptr es:[di], 0 ; [es:di+BUFFINF.Buff_Queue]
SYSINIT:0668		     mov     es:[di+2],	cx   ; [es:di+BUFFINF.Buff_Queue+2]
SYSINIT:0668					     ; cx = [top_of_cdss]
SYSINIT:066C		     mov     es, cx
SYSINIT:066E		     xor     ax, ax
SYSINIT:0670		     mov     di, ax
SYSINIT:0672		     mov     es:[di], ax     ; [es:di+buffinfo.buf_next],0
SYSINIT:0675		     mov     es:[di+2],	ax   ; [es:di+buffinfo.buf_prev],0
SYSINIT:0679		     mov     word ptr es:[di+4], 0FFh ;	[es:di+buffinfo.buf_ID],00FFh
SYSINIT:0679					     ; free buffer,clear flag
SYSINIT:067F		     mov     word ptr es:[di+6], 0 ; [es:di+buffinfo.buf_sector]
SYSINIT:0685		     mov     word ptr es:[di+8], 0 ; [es:di+buffinfo.buf_sector+2]
SYSINIT:068B		     pop     di
SYSINIT:068C		     pop     es
SYSINIT:068D		     push    cs
SYSINIT:068E		     pop     ds
SYSINIT:068F		     assume ds:SYSINIT
SYSINIT:068F		     call    TempCDS	     ; set up cdss so re_init and sysinit
SYSINIT:068F					     ; can make	disk system calls
SYSINIT:068F					     ; tempcds trashes ds
SYSINIT:0692		     mov     ds, cs:def_php  ; retrieve	pointer	to PSP returned	by DOSINIT
SYSINIT:0697		     assume ds:nothing
SYSINIT:0697		     call    far ptr 70h:89Bh ;	call DOSBIODATASEG:re_init
SYSINIT:069C		     sti
SYSINIT:069D		     cld
SYSINIT:069E		     mov     bx, cs
SYSINIT:06A0		     sub     bx, 10h
SYSINIT:06A3		     mov     es, bx
SYSINIT:06A5		     assume es:nothing
SYSINIT:06A5		     xor     si, si
SYSINIT:06A7		     mov     di, si
SYSINIT:06A9		     mov     cx, 128
SYSINIT:06AC		     rep movsw
SYSINIT:06AE		     mov     word ptr es:36h, es ; [es:PDB.JFN_POINTER+2],es ; Relocate
SYSINIT:06B3		     mov     ah, 50h
SYSINIT:06B5		     int     21h	     ; DOS - 2+	internal - SET PSP SEGMENT
SYSINIT:06B5					     ; BX = segment address of new PSP
SYSINIT:06B7		     push    ds
SYSINIT:06B8		     push    cs
SYSINIT:06B9		     pop     ds
SYSINIT:06BA		     assume ds:SYSINIT
SYSINIT:06BA		     mov     dx, offset	int24 ;	set up int 24h handler
SYSINIT:06BD		     mov     ax, 2524h
SYSINIT:06C0		     int     21h	     ; DOS - SET INTERRUPT VECTOR
SYSINIT:06C0					     ; AL = interrupt number
SYSINIT:06C0					     ; DS:DX = new vector to be	used for specified interrupt
SYSINIT:06C2		     cmp     toomanydrivesflag,	0
SYSINIT:06C7		     jz	     short no_err
SYSINIT:06C9		     mov     dx, offset	TooManyDrivesMsg ; "WARNING! Logical drives past Z: exist a"...
SYSINIT:06CC		     call    print
SYSINIT:06CF
SYSINIT:06CF no_err:				     ; ...
SYSINIT:06CF		     pop     ds
SYSINIT:06D0		     assume ds:nothing
SYSINIT:06D0		     mov     dl, cs:DEFAULT_DRIVE
SYSINIT:06D5		     or	     dl, dl
SYSINIT:06D7		     jz	     short nodrvset
SYSINIT:06D9		     dec     dl
SYSINIT:06DB		     mov     ah, 0Eh
SYSINIT:06DD		     int     21h	     ; DOS - SELECT DISK
SYSINIT:06DD					     ; DL = new	default	drive number (0	= A, 1 = B, etc.)
SYSINIT:06DD					     ; Return: AL = number of logical drives
SYSINIT:06DF
SYSINIT:06DF nodrvset:				     ; ...
SYSINIT:06DF		     push    ds
SYSINIT:06E0		     sub     ax, ax
SYSINIT:06E2		     mov     ds, ax	     ; 0 ; ROMBIOS data	area
SYSINIT:06E4		     assume ds:nothing
SYSINIT:06E4		     mov     ax, ds:46Ch     ; Counter for Interrupt 1Ah
SYSINIT:06E4					     ; timer tick count	(18.2 ticks per	second)
SYSINIT:06E7		     pop     ds
SYSINIT:06E8		     assume ds:nothing
SYSINIT:06E8		     mov     cs:_timer_lw_, ax
SYSINIT:06EC		     mov     word ptr cs:Magicbackdoor,	offset NullBackdoor
SYSINIT:06F3		     mov     word ptr cs:Magicbackdoor+2, cs
SYSINIT:06F8		     call    AllocFreeMem    ; get the largest free block from DOS
SYSINIT:06FB		     call    MagicPreload    ; **** PRE-LOAD MAGICDRV!!! ****
SYSINIT:06FE		     or	     ax, ax
SYSINIT:0700		     jnz     short PreloadFailed
SYSINIT:0702		     mov     es, cs:area
SYSINIT:0707		     assume es:nothing
SYSINIT:0707		     mov     bx, cs:memhi
SYSINIT:070C		     sub     bx, cs:area
SYSINIT:0711		     mov     ah, 4Ah
SYSINIT:0713		     int     21h	     ; DOS - 2+	- ADJUST MEMORY	BLOCK SIZE (SETBLOCK)
SYSINIT:0713					     ; ES = segment address of block to	change
SYSINIT:0713					     ; BX = new	size in	paragraphs
SYSINIT:0715		     mov     ax, es
SYSINIT:0717		     dec     ax
SYSINIT:0718		     mov     es, ax
SYSINIT:071A		     assume es:nothing
SYSINIT:071A		     mov     word ptr es:1, 8 ;	[es:arena_owner], 8 ; set impossible owner
SYSINIT:0721		     mov     word ptr es:8, 4453h ; [es:arena_name],'SD' ; System Data
SYSINIT:0728		     mov     ax, es	     ; get Magicdrv arena
SYSINIT:072A		     add     ax, es:3	     ; get MCB length
SYSINIT:072F		     inc     ax		     ; get addr	of next	MCB
SYSINIT:0730		     les     si, cs:DOSINFO  ; get to arena header
SYSINIT:0735		     assume es:nothing
SYSINIT:0735		     mov     es:[si-2],	ax   ; store that
SYSINIT:0739		     jmp     short ProcessConfig
SYSINIT:073B ; ---------------------------------------------------------------------------
SYSINIT:073B
SYSINIT:073B PreloadFailed:			     ; ...
SYSINIT:073B		     mov     ah, 49h	     ; Dealloc ; free the block	if no load
SYSINIT:073D		     mov     es, cs:area
SYSINIT:0742		     int     21h	     ; DOS - 2+	- FREE MEMORY
SYSINIT:0742					     ; ES = segment address of area to be freed
SYSINIT:0744
SYSINIT:0744 ProcessConfig:			     ; ...
SYSINIT:0744		     call    doconf
SYSINIT:0747		     cmp     cs:runhigh, 0
SYSINIT:074D		     jz	     short dont_install_stub
SYSINIT:074F		     mov     es, cs:CURRENT_DOS_LOCATION
SYSINIT:0754		     xor     ax, ax
SYSINIT:0756		     call    cs:dos_segreinit
SYSINIT:075B		     jmp     short do_multi_pass
SYSINIT:075D ; ---------------------------------------------------------------------------
SYSINIT:075D
SYSINIT:075D dont_install_stub:			     ; ...
SYSINIT:075D		     xor     bx, bx
SYSINIT:075F		     call    MovDOSLo
SYSINIT:0762		     mov     ax, 1
SYSINIT:0765		     mov     es, cs:CURRENT_DOS_LOCATION
SYSINIT:076A		     call    cs:dos_segreinit
SYSINIT:076F
SYSINIT:076F do_multi_pass:			     ; ...
SYSINIT:076F		     call    AllocFreeMem
SYSINIT:0772		     mov     bx, 0	     ; magic backdoor to place int hooks
SYSINIT:0775		     call    cs:Magicbackdoor
SYSINIT:077A		     inc     cs:multi_pass_id
SYSINIT:077F		     call    multi_pass
SYSINIT:0782		     call    ShrinkUMB
SYSINIT:0785		     call    UnlinkUMB
SYSINIT:0788		     inc     cs:multi_pass_id
SYSINIT:078D		     call    multi_pass
SYSINIT:0790		     call    MagicPostload
SYSINIT:0793		     call    endfile
SYSINIT:0796		     call    MagicSetCdss
SYSINIT:0799		     mov     ax, 70h
SYSINIT:079C		     mov     es, ax
SYSINIT:079E		     assume es:nothing
SYSINIT:079E		     mov     es:SysinitPresent,	0
SYSINIT:07A4		     test    cs:install_flag, 1
SYSINIT:07AB		     jz	     short dolast
SYSINIT:07AD		     inc     cs:multi_pass_id
SYSINIT:07B2		     call    multi_pass
SYSINIT:07B5
SYSINIT:07B5 dolast:				     ; ...
SYSINIT:07B5		     cmp     cs:runhigh, 0FFh
SYSINIT:07BB		     jnz     short _@@_
SYSINIT:07BD		     call    LoadDOSHiOrLo
SYSINIT:07C0
SYSINIT:07C0 _@@_:				     ; ...
SYSINIT:07C0		     cmp     cs:runhigh, 0
SYSINIT:07C6		     jz	     short ConfigDone
SYSINIT:07C8		     call    CPMHack
SYSINIT:07CB
SYSINIT:07CB ConfigDone:			     ; ...
SYSINIT:07CB		     mov     cs:donotshownum, 1
SYSINIT:07D1		     mov     es, cs:area
SYSINIT:07D6		     assume es:nothing
SYSINIT:07D6		     mov     ah, 49h	     ; DEALLOC ; free allocated	memory for command.com
SYSINIT:07D8		     int     21h	     ; DOS - 2+	- FREE MEMORY
SYSINIT:07D8					     ; ES = segment address of area to be freed
SYSINIT:07DA		     test    cs:install_flag, 2	; has_installed
SYSINIT:07E1		     jz	     short skip_free_sysinitbase ; no
SYSINIT:07E3		     push    es
SYSINIT:07E4		     push    bx
SYSINIT:07E5		     mov     es, cs:old_area
SYSINIT:07EA		     mov     bx, cs:impossible_owner_size
SYSINIT:07EF		     mov     ah, 4Ah
SYSINIT:07F1		     int     21h	     ; DOS - 2+	- ADJUST MEMORY	BLOCK SIZE (SETBLOCK)
SYSINIT:07F1					     ; ES = segment address of block to	change
SYSINIT:07F1					     ; BX = new	size in	paragraphs
SYSINIT:07F3		     mov     ax, es
SYSINIT:07F5		     dec     ax
SYSINIT:07F6		     mov     es, ax	     ; point to	arena
SYSINIT:07F8		     assume es:nothing
SYSINIT:07F8		     mov     word ptr es:1, 8 ;	[es:ARENA.OWNER],8 ; set impossible owner
SYSINIT:07FF		     mov     word ptr es:8, 4453h ; [es:ARENA.NAME],'SD' ; System Data
SYSINIT:0806		     pop     bx
SYSINIT:0807		     pop     es
SYSINIT:0808		     assume es:nothing
SYSINIT:0808
SYSINIT:0808 skip_free_sysinitbase:		     ; ...
SYSINIT:0808		     cmp     cs:runhigh, 0
SYSINIT:080E		     jz	     short _@@@_
SYSINIT:0810		     call    InstVDiskHeader ; Install VDISK header (allocates some mem	from DOS)
SYSINIT:0813
SYSINIT:0813 _@@@_:				     ; ...
SYSINIT:0813		     push    cs
SYSINIT:0814		     pop     ds
SYSINIT:0815		     assume ds:SYSINIT
SYSINIT:0815		     mov     config_cmd, 0   ; set special code	for query_user
SYSINIT:081A		     call    query_user	     ; to issue	the AUTOEXEC prompt
SYSINIT:081D		     jnb     short process_autoexec ; we should	process	autoexec normally
SYSINIT:081F		     or	     bQueryOpt,	4    ; set "skip all" flag
SYSINIT:0824		     call    disable_autoexec ;	no, we should disable it
SYSINIT:0827
SYSINIT:0827 process_autoexec:			     ; ...
SYSINIT:0827		     call    CheckQueryOpt
SYSINIT:082A		     mov     cl, byte ptr command_line ; "\x02/P"
SYSINIT:082E		     mov     ch, 0
SYSINIT:0830		     inc     cx
SYSINIT:0831		     mov     si, offset	command_line ; "\x02/P"
SYSINIT:0834		     add     si, cx
SYSINIT:0836		     mov     byte ptr [si], 0Dh	; cr-terminate command line
SYSINIT:0839
SYSINIT:0839 retry:				     ; ...
SYSINIT:0839		     mov     dx, offset	commnd ; "\\COMMAND.COM"
SYSINIT:083C		     push    dx		     ; save pointer to file name
SYSINIT:083D		     mov     bx, 0FFFFh	     ; get biggest piece (second time gets it)
SYSINIT:0840		     mov     ah, 48h
SYSINIT:0842		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:0842					     ; BX = number of 16-byte paragraphs desired
SYSINIT:0844		     mov     ah, 48h
SYSINIT:0846		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:0846					     ; BX = number of 16-byte paragraphs desired
SYSINIT:0848		     jb	     short memerrjx  ; oooops!
SYSINIT:084A		     mov     es, ax
SYSINIT:084C		     mov     ah, 49h
SYSINIT:084E		     int     21h	     ; DOS - 2+	- FREE MEMORY
SYSINIT:084E					     ; ES = segment address of area to be freed
SYSINIT:0850		     mov     bp, bx
SYSINIT:0852		     mov     bx, MEMORY_SIZE ; get location of end of memory
SYSINIT:0856		     mov     ax, cs	     ; get location of beginning of sysinit
SYSINIT:0858		     mov     cx, config_envlen
SYSINIT:085C		     jcxz    short no_env    ; use config_wrkseg only if there's env data
SYSINIT:085E		     mov     ax, config_wrkseg
SYSINIT:0861
SYSINIT:0861 no_env:				     ; ...
SYSINIT:0861		     sub     bx, ax
SYSINIT:0863		     add     bx, 11h	     ; add the sysinit php
SYSINIT:0866		     sub     bp, bx	     ; sub sysinit size	from amount of free memory
SYSINIT:0868		     jb	     short memerrjx  ; if there	isn't even this much memory, give up
SYSINIT:086A		     mov     ax, 3D00h
SYSINIT:086D		     stc
SYSINIT:086E		     int     21h	     ; DOS - 2+	- OPEN DISK FILE WITH HANDLE
SYSINIT:086E					     ; DS:DX ->	ASCIZ filename
SYSINIT:086E					     ; AL = access mode
SYSINIT:086E					     ; 0 - read
SYSINIT:0870		     jb	     short comerr
SYSINIT:0872		     mov     bx, ax
SYSINIT:0874		     cmp     newcmd, 0	     ; was a new shell selected?
SYSINIT:0879		     jnz     short skip_validation ; yes
SYSINIT:087B		     mov     dx, offset	retry-4	; SYSINIT:0835h
SYSINIT:087E		     mov     cx, 4
SYSINIT:0881		     mov     ah, 3Fh
SYSINIT:0883		     int     21h	     ; DOS - 2+	- READ FROM FILE WITH HANDLE
SYSINIT:0883					     ; BX = file handle, CX = number of	bytes to read
SYSINIT:0883					     ; DS:DX ->	buffer
SYSINIT:0885		     cmp     byte ptr retry-4, 0E9h
SYSINIT:088A		     jnz     short comerr
SYSINIT:088C		     cmp     byte ptr retry-1, 64h ; COMMAND.COM Version 6.20  (not 6.21!)
SYSINIT:088C					     ; ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
SYSINIT:0891		     jnz     short comerr
SYSINIT:0893
SYSINIT:0893 skip_validation:			     ; ...
SYSINIT:0893		     xor     cx, cx
SYSINIT:0895		     xor     dx, dx
SYSINIT:0897		     mov     ax, 4202h
SYSINIT:089A		     stc
SYSINIT:089B		     int     21h	     ; DOS - 2+	- MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:089B					     ; AL = method: offset from	end of file
SYSINIT:089D		     jb	     short comerr
SYSINIT:089F		     add     ax, 0Fh	     ; convert size in dx:ax to	para in	ax
SYSINIT:08A2		     adc     dx, 0	     ; round up	size for conversion to para
SYSINIT:08A5		     call    _off_to_para
SYSINIT:08A8		     mov     cl, 12
SYSINIT:08AA		     shl     dx, cl	     ; low nibble of dx	to high	nibble
SYSINIT:08AC		     or	     ax, dx	     ; ax is now # of para for file
SYSINIT:08AE		     add     ax, 10h	     ; 100h byte php
SYSINIT:08B1		     cmp     ax, bp	     ; will command fit	in available mem?
SYSINIT:08B3		     jb	     short okld	     ; jump if yes.
SYSINIT:08B5
SYSINIT:08B5 memerrjx:				     ; ...
SYSINIT:08B5		     mov     dx, offset	badmem ; "\r\nConfiguration too	large for memory\"...
SYSINIT:08B8		     call    print
SYSINIT:08BB		     jmp     short continue
SYSINIT:08BD ; ---------------------------------------------------------------------------
SYSINIT:08BD
SYSINIT:08BD okld:				     ; ...
SYSINIT:08BD		     mov     ah, 3Eh
SYSINIT:08BF		     int     21h	     ; DOS - 2+	- CLOSE	A FILE WITH HANDLE
SYSINIT:08BF					     ; BX = file handle
SYSINIT:08C1		     push    cs
SYSINIT:08C2		     pop     es
SYSINIT:08C3		     assume es:SYSINIT
SYSINIT:08C3		     mov     bx, offset	EXEC0_ENVIRON ;	offset COMEXE
SYSINIT:08C3					     ; point to	exec block
SYSINIT:08C6		     pop     dx
SYSINIT:08C7		     mov     cx, config_envlen
SYSINIT:08CB		     jcxz    short no_envdata
SYSINIT:08CD		     mov     cx, config_wrkseg
SYSINIT:08D1
SYSINIT:08D1 no_envdata:			     ; ...
SYSINIT:08D1		     mov     [bx], cx	     ; set segments
SYSINIT:08D1					     ; [bx+EXEC0.ENVIRON],cx
SYSINIT:08D3		     mov     word ptr [bx+4], cs ; [bx+EXEC0.COM_LINE+2],cs
SYSINIT:08D6		     mov     word ptr [bx+8], cs ; [bx+EXEC0.5C_FCB+2],cs
SYSINIT:08D9		     mov     word ptr [bx+0Ch],	cs ; [bx+EXEC0.6C_FCB+2],cs
SYSINIT:08DC		     mov     ax, 4B00h	     ; (EXEC<<8)
SYSINIT:08DF		     stc
SYSINIT:08E0		     int     21h	     ; DOS - 2+	- LOAD OR EXECUTE (EXEC)
SYSINIT:08E0					     ; DS:DX ->	ASCIZ filename
SYSINIT:08E0					     ; ES:BX ->	parameter block
SYSINIT:08E0					     ; AL = subfunc: load & execute program
SYSINIT:08E2		     push    cs
SYSINIT:08E3		     pop     ds
SYSINIT:08E4		     push    dx
SYSINIT:08E5
SYSINIT:08E5 comerr:				     ; ...
SYSINIT:08E5		     cmp     byte ptr commnd4, 0 ; "\\DOS\\COMMAND.COM"
SYSINIT:08EA		     jz	     short comerr2   ; all defaults exhausted, print err msg
SYSINIT:08EC		     cmp     newcmd, 0
SYSINIT:08F1		     jz	     short continue  ; don't print err msg for defaults just yet
SYSINIT:08F3
SYSINIT:08F3 comerr2:				     ; ...
SYSINIT:08F3		     mov     dx, offset	badcom ; "Command Interpreter"
SYSINIT:08F6		     call    badfil
SYSINIT:08F9
SYSINIT:08F9 continue:				     ; ...
SYSINIT:08F9		     pop     dx
SYSINIT:08FA		     mov     ah, 19h
SYSINIT:08FC		     int     21h	     ; DOS - GET DEFAULT DISK NUMBER
SYSINIT:08FE		     add     al, 'A'
SYSINIT:0900		     mov     dl, al	     ; dl == default drive letter
SYSINIT:0902		     mov     si, offset	commnd2	; "\\COMMAND.COM"
SYSINIT:0905		     cmp     newcmd, 0	     ; if a SHELL= was given
SYSINIT:090A		     jnz     short do_def2   ; then try	the 2nd	alternate;
SYSINIT:090C		     mov     byte ptr [si], 0 ;	otherwise, the default SHELL= was tried,
SYSINIT:090F		     jmp     short do_def3   ; which is	the same as our	2nd alt, so skip it
SYSINIT:0911 ; ---------------------------------------------------------------------------
SYSINIT:0911
SYSINIT:0911 do_def2:				     ; ...
SYSINIT:0911		     cmp     byte ptr [si], 0 ;	has 2nd	alternate been tried?
SYSINIT:0914		     jnz     short do_alt    ; no
SYSINIT:0916
SYSINIT:0916 do_def3:				     ; ...
SYSINIT:0916		     mov     si, offset	commnd3	; "\\MSDOS\\COMMAND.COM"
SYSINIT:0919		     cmp     byte ptr [si], 0 ;	has 3rd	alternate been tried?
SYSINIT:091C		     jnz     short do_alt    ; no
SYSINIT:091E		     mov     si, offset	commnd4	; "\\DOS\\COMMAND.COM"
SYSINIT:0921		     cmp     byte ptr [si], 0 ;	has 4th	alternate been tried?
SYSINIT:0924		     jnz     short do_alt    ; no
SYSINIT:0926		     push    dx
SYSINIT:0927		     mov     dx, offset	badcomprmpt ; "Enter correct name of Command Interpret"...
SYSINIT:092A		     call    print
SYSINIT:092D		     pop     dx		     ; recover default drive letter in dl
SYSINIT:092E
SYSINIT:092E request_input:			     ; ...
SYSINIT:092E		     mov     ah, 2	     ; STD_CON_OUTPUT
SYSINIT:0930		     int     21h	     ; DOS - DISPLAY OUTPUT
SYSINIT:0930					     ; DL = character to send to standard output
SYSINIT:0932		     push    dx
SYSINIT:0933		     mov     dl, '>'         ; 3Eh
SYSINIT:0935		     int     21h	     ; DOS - DISPLAY OUTPUT
SYSINIT:0935					     ; DL = character to send to standard output
SYSINIT:0937		     mov     bl, tmplate+1   ; [tmplate] = max.	chars buffer can hold =	64
SYSINIT:093B		     mov     bh, 0
SYSINIT:093D		     mov     byte ptr commnd[bx], 0Dh ;	"\\COMMAND.COM"
SYSINIT:0942		     mov     dx, offset	tmplate
SYSINIT:0945		     mov     ah, 0Ah	     ; STD_CON_STRING_INPUT
SYSINIT:0947		     int     21h	     ; DOS - BUFFERED KEYBOARD INPUT
SYSINIT:0947					     ; DS:DX ->	buffer
SYSINIT:0949		     mov     dx, offset	crlfm ;	"\r\n$"
SYSINIT:094C		     call    print
SYSINIT:094F		     pop     dx
SYSINIT:0950		     mov     bl, tmplate+1
SYSINIT:0954		     or	     bl, bl	     ; was anything typed?
SYSINIT:0956		     jz	     short request_input
SYSINIT:0958		     mov     newcmd, 1	     ; disable validation for user-specified binaries
SYSINIT:095D		     mov     byte ptr commnd[bx], 0 ; NULL-terminate it	before execing it
SYSINIT:0962		     mov     word ptr command_line, 0D00h ; "\x02/P"
SYSINIT:0968		     jmp     short do_exec   ; ...
SYSINIT:096A ; ---------------------------------------------------------------------------
SYSINIT:096A
SYSINIT:096A do_alt:				     ; ...
SYSINIT:096A		     push    ds
SYSINIT:096B		     pop     es
SYSINIT:096C		     mov     newcmd, 0	     ; force validation	for alternate binaries
SYSINIT:0971		     mov     di, offset	commnd ; "\\COMMAND.COM"
SYSINIT:0974
SYSINIT:0974 do_alt1:				     ; ...
SYSINIT:0974		     lodsb		     ; copy the	alternate, zapping it as we go
SYSINIT:0975		     mov     byte ptr [si-1], 0	; so that we know it's been tried
SYSINIT:0979		     stosb
SYSINIT:097A		     or	     al, al
SYSINIT:097C		     jnz     short do_alt1
SYSINIT:097E		     mov     di, offset	command_line ; "\x02/P"
SYSINIT:0981		     cmp     byte ptr [si+2], ':'
SYSINIT:0985		     jnz     short do_alt2
SYSINIT:0987		     mov     [si+1], dl	     ; stuff default drive into	alt. command line
SYSINIT:098A
SYSINIT:098A do_alt2:				     ; ...
SYSINIT:098A		     lodsb
SYSINIT:098B		     stosb
SYSINIT:098C		     or	     al, al
SYSINIT:098E		     jnz     short do_alt2
SYSINIT:0990		     mov     byte ptr [di-1], 0Dh ; cr
SYSINIT:0994		     mov     dae_flag, 0
SYSINIT:0999		     call    disable_autoexec
SYSINIT:099C		     call    CheckQueryOpt
SYSINIT:099F
SYSINIT:099F do_exec:				     ; ...
SYSINIT:099F		     jmp     retry
SYSINIT:09A2
SYSINIT:09A2 ; =============== S U B R O U T I N E =======================================
SYSINIT:09A2
SYSINIT:09A2
SYSINIT:09A2 AllocFreeMem    proc near		     ; ...
SYSINIT:09A2		     mov     bx, 0FFFFh
SYSINIT:09A5		     mov     ah, 48h
SYSINIT:09A7		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:09A7					     ; BX = number of 16-byte paragraphs desired
SYSINIT:09A9		     mov     ah, 48h
SYSINIT:09AB		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:09AB					     ; BX = number of 16-byte paragraphs desired
SYSINIT:09AD		     mov     cs:area, ax
SYSINIT:09B1		     mov     cs:memhi, ax
SYSINIT:09B5		     retn
SYSINIT:09B5 AllocFreeMem    endp
SYSINIT:09B5
SYSINIT:09B5 ; ---------------------------------------------------------------------------
SYSINIT:09B6 DOSLOMSG	     db	'HMA not available: Loading DOS low',0Dh,0Ah,'$' ; ...
SYSINIT:09DB FEmsg	     db	'Fatal Error: Cannot allocate Memory for DOS',0Dh,0Ah,'$' ; ...
SYSINIT:0A09
SYSINIT:0A09 ; =============== S U B R O U T I N E =======================================
SYSINIT:0A09
SYSINIT:0A09
SYSINIT:0A09 LoadDOSHiOrLo   proc near		     ; ...
SYSINIT:0A09		     call    TryToMovDOSHi   ; Try moving it into HMA
SYSINIT:0A0C		     jb	     short LdngLo    ; If that don't work...
SYSINIT:0A0E		     retn
SYSINIT:0A0F ; ---------------------------------------------------------------------------
SYSINIT:0A0F
SYSINIT:0A0F LdngLo:				     ; ...
SYSINIT:0A0F		     push    cs
SYSINIT:0A10		     pop     ds
SYSINIT:0A11		     mov     ah, 9
SYSINIT:0A13		     mov     dx, offset	DOSLOMSG ; "HMA	not available: Loading DOS low\r\n$"
SYSINIT:0A16		     int     21h	     ; DOS - PRINT STRING
SYSINIT:0A16					     ; DS:DX ->	string terminated by "$"
SYSINIT:0A18		     mov     bx, 1	     ; use int 21 alloc	for mem
SYSINIT:0A1B		     call    MovDOSLo
SYSINIT:0A1E		     mov     es, cs:CURRENT_DOS_LOCATION ; give	dos its	temporary loc.
SYSINIT:0A23		     assume es:nothing
SYSINIT:0A23		     xor     ax, ax
SYSINIT:0A25		     call    cs:dos_segreinit
SYSINIT:0A2A		     mov     cs:runhigh, 0   ; mark that we are	running	lo
SYSINIT:0A30		     retn
SYSINIT:0A30 LoadDOSHiOrLo   endp
SYSINIT:0A30
SYSINIT:0A31
SYSINIT:0A31 ; =============== S U B R O U T I N E =======================================
SYSINIT:0A31
SYSINIT:0A31
SYSINIT:0A31 TryToMovDOSHi   proc near		     ; ...
SYSINIT:0A31		     call    MovDOSHi
SYSINIT:0A34		     jb	     short ttldhx
SYSINIT:0A36		     mov     es, cs:CURRENT_DOS_LOCATION ; give	dos its	temporary loc.
SYSINIT:0A3B		     xor     ax, ax	     ; ax = 0 --> install stub
SYSINIT:0A3D		     call    cs:dos_segreinit
SYSINIT:0A42		     mov     cs:runhigh, 1
SYSINIT:0A48		     clc
SYSINIT:0A49
SYSINIT:0A49 ttldhx:				     ; ...
SYSINIT:0A49		     retn
SYSINIT:0A49 TryToMovDOSHi   endp
SYSINIT:0A49
SYSINIT:0A4A
SYSINIT:0A4A ; =============== S U B R O U T I N E =======================================
SYSINIT:0A4A
SYSINIT:0A4A
SYSINIT:0A4A MovDOSHi	     proc near		     ; ...
SYSINIT:0A4A		     call    AllocHMA	     ; did we get HMA?
SYSINIT:0A4D		     jb	     short mdhx	     ; no
SYSINIT:0A4F		     mov     ax, 0FFFFh	     ; yes, HMA	seg = 0ffffh
SYSINIT:0A52		     mov     es, ax
SYSINIT:0A54		     assume es:nothing
SYSINIT:0A54		     call    MovBIOS	     ; First move BIOS into HMA
SYSINIT:0A57		     mov     cx, cs:hi_doscod_size ; when it is	in HMA
SYSINIT:0A5C		     call    MovDOS	     ; and move	it
SYSINIT:0A5F		     call    SaveFreeHMAPtr
SYSINIT:0A62		     clc
SYSINIT:0A63
SYSINIT:0A63 mdhx:				     ; ...
SYSINIT:0A63		     retn
SYSINIT:0A63 MovDOSHi	     endp
SYSINIT:0A63
SYSINIT:0A64
SYSINIT:0A64 ; =============== S U B R O U T I N E =======================================
SYSINIT:0A64
SYSINIT:0A64
SYSINIT:0A64 MovDOSLo	     proc near		     ; ...
SYSINIT:0A64		     call    AllocMemForDOS  ; incestuosly!
SYSINIT:0A67		     mov     es, ax	     ; pass the	segment	to MovBIOS
SYSINIT:0A69		     assume es:nothing
SYSINIT:0A69		     call    MovBIOS
SYSINIT:0A6C		     mov     cx, cs:lo_doscod_size ; DOS code size when	loaded
SYSINIT:0A71		     call    MovDOS
SYSINIT:0A74		     retn
SYSINIT:0A74 MovDOSLo	     endp
SYSINIT:0A74
SYSINIT:0A75
SYSINIT:0A75 ; =============== S U B R O U T I N E =======================================
SYSINIT:0A75
SYSINIT:0A75
SYSINIT:0A75 MovBIOS	     proc near		     ; ...
SYSINIT:0A75		     mov     ds, cs:temp_bcode_seg
SYSINIT:0A7A		     assume ds:nothing
SYSINIT:0A7A		     mov     si, 30h	     ; BCODE_START
SYSINIT:0A7D		     mov     di, si
SYSINIT:0A7F		     mov     cx, 1A70h	     ; BCODE_END
SYSINIT:0A82		     sub     cx, si	     ; size of BIOS
SYSINIT:0A84		     shr     cx, 1	     ; Both the	labels are para	aligned
SYSINIT:0A86		     rep movsw
SYSINIT:0A88		     push    es
SYSINIT:0A89		     push    di		     ; save end	of BIOS
SYSINIT:0A8A		     mov     ax, es
SYSINIT:0A8C		     mov     cs:BCodeSeg, ax ; save it for later use
SYSINIT:0A90		     call    dword ptr cs:_seg_reinit_ptr ; far	call to	seg_reinit
SYSINIT:0A90					     ; call far	[cs:seg_reinit_ptr]
SYSINIT:0A95		     pop     di		     ; get back	end of BIOS
SYSINIT:0A96		     pop     es
SYSINIT:0A97		     retn
SYSINIT:0A97 MovBIOS	     endp
SYSINIT:0A97
SYSINIT:0A98
SYSINIT:0A98 ; =============== S U B R O U T I N E =======================================
SYSINIT:0A98
SYSINIT:0A98
SYSINIT:0A98 MovDOS	     proc near		     ; ...
SYSINIT:0A98		     push    es
SYSINIT:0A99		     push    di
SYSINIT:0A9A		     lds     si, dword ptr cs:dosinit
SYSINIT:0A9F		     rep movsb
SYSINIT:0AA1		     pop     bx		     ; get back	offset into which DOS was moved
SYSINIT:0AA2		     mov     ax, cs:dosinit  ; get the offset at which DOS wants to run
SYSINIT:0AA6		     sub     ax, bx
SYSINIT:0AA8		     call    _off_to_para
SYSINIT:0AAB		     pop     bx		     ; get the segment at which	we moved DOS into
SYSINIT:0AAC		     sub     bx, ax	     ; Adjust segment
SYSINIT:0AAE		     mov     cs:CURRENT_DOS_LOCATION, bx ; and save it
SYSINIT:0AB3		     retn
SYSINIT:0AB3 MovDOS	     endp
SYSINIT:0AB3
SYSINIT:0AB4
SYSINIT:0AB4 ; =============== S U B R O U T I N E =======================================
SYSINIT:0AB4
SYSINIT:0AB4
SYSINIT:0AB4 AllocMemForDOS  proc near		     ; ...
SYSINIT:0AB4
SYSINIT:0AB4 ; FUNCTION	CHUNK AT SYSINIT:12BD SIZE 00000001 BYTES
SYSINIT:0AB4
SYSINIT:0AB4		     mov     ax, 1A70h	     ; BCODE_END
SYSINIT:0AB7		     sub     ax, 30h	     ; BCODE_START
SYSINIT:0AB7					     ; BCODE_END-BCODE_START = BIOS code size
SYSINIT:0ABA		     add     ax, cs:lo_doscod_size
SYSINIT:0ABF		     add     ax, 0Fh
SYSINIT:0AC2		     call    _off_to_para    ; convert to para
SYSINIT:0AC5		     or	     bx, bx	     ; can we use int 21h for alloc ?
SYSINIT:0AC7		     mov     bx, ax
SYSINIT:0AC9		     jz	     short update_arena	; no
SYSINIT:0ACB		     mov     ah, 48h
SYSINIT:0ACD		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:0ACD					     ; BX = number of 16-byte paragraphs desired
SYSINIT:0ACF		     jb	     short FatalErr
SYSINIT:0AD1		     sub     ax, 3	     ; Take care ORG 30h of BIOS code
SYSINIT:0AD4		     mov     es, ax
SYSINIT:0AD6		     mov     word ptr es:21h, 8	; [es:20h+ARENA.OWNER],08h
SYSINIT:0ADD		     mov     word ptr es:28h, 4353h ; 'SC' ; mark it as system code area
SYSINIT:0AE4		     retn
SYSINIT:0AE5 ; ---------------------------------------------------------------------------
SYSINIT:0AE5
SYSINIT:0AE5 update_arena:			     ; ...
SYSINIT:0AE5		     push    ds
SYSINIT:0AE6		     push    di
SYSINIT:0AE7		     push    cx
SYSINIT:0AE8		     push    dx
SYSINIT:0AE9		     lds     di, cs:DOSINFO  ; get ptr to DOS var
SYSINIT:0AEE		     dec     di
SYSINIT:0AEF		     dec     di		     ; Arena head is immediately before	sysvar
SYSINIT:0AF0		     mov     es, word ptr [di] ; es = arena head
SYSINIT:0AF2		     mov     cx, es:3	     ; [es:ARENA.SIZE] ; total low mem size
SYSINIT:0AF7		     cmp     cx, bx	     ; is it sufficient	?
SYSINIT:0AF9		     jb	     short FatalErr  ; no, fatal error
SYSINIT:0AFB		     mov     dl, es:0	     ; [es:ARENA.SIGNATURE]
SYSINIT:0B00		     mov     ax, es
SYSINIT:0B02		     add     ax, bx	     ; ax = new	arena head
SYSINIT:0B04		     mov     [di], ax	     ; store it	in DOS data area
SYSINIT:0B06		     mov     ds, ax
SYSINIT:0B08		     mov     ds:0, dl	     ; [ARENA.SIGNATURE] ; type	of arena
SYSINIT:0B0C		     mov     word ptr ds:1, 0 ;	[ARENA.OWNER],0	; free
SYSINIT:0B12		     sub     cx, bx	     ; size of the new block
SYSINIT:0B14		     mov     ds:3, cx	     ; [ARENA.SIZE],cx ; store it in the arena
SYSINIT:0B18		     mov     ax, es	     ; return seg to the caller
SYSINIT:0B1A		     sub     ax, 3	     ; Take care ORG 30h of BIOS code
SYSINIT:0B1D		     pop     dx
SYSINIT:0B1E		     pop     cx
SYSINIT:0B1F		     pop     di
SYSINIT:0B20		     pop     ds
SYSINIT:0B21		     retn
SYSINIT:0B22 ; ---------------------------------------------------------------------------
SYSINIT:0B22
SYSINIT:0B22 FatalErr:				     ; ...
SYSINIT:0B22		     push    cs
SYSINIT:0B23		     pop     ds
SYSINIT:0B24		     assume ds:SYSINIT
SYSINIT:0B24		     mov     dx, offset	FEmsg ;	"Fatal Error: Cannot allocate Memory for"...
SYSINIT:0B27		     mov     ah, 9
SYSINIT:0B29		     int     21h	     ; DOS - PRINT STRING
SYSINIT:0B29					     ; DS:DX ->	string terminated by "$"
SYSINIT:0B2B		     jmp     stall
SYSINIT:0B2B AllocMemForDOS  endp
SYSINIT:0B2B
SYSINIT:0B2E
SYSINIT:0B2E ; =============== S U B R O U T I N E =======================================
SYSINIT:0B2E
SYSINIT:0B2E
SYSINIT:0B2E AllocHMA	     proc near		     ; ...
SYSINIT:0B2E		     push    ds
SYSINIT:0B2F		     mov     ax, 70h	     ; DOSBIODATASEG ; BIOSDATA	segment
SYSINIT:0B32		     mov     ds, ax
SYSINIT:0B34		     assume ds:nothing
SYSINIT:0B34		     call    IsXMSLoaded
SYSINIT:0B37		     jnz     short grabhma_error
SYSINIT:0B39		     mov     ax, 4310h
SYSINIT:0B3C		     int     2Fh	     ; - Multiplex - XMS - GET DRIVER ADDRESS
SYSINIT:0B3C					     ; Return: ES:BX ->	driver entry point
SYSINIT:0B3E		     mov     word ptr ds:xms, bx
SYSINIT:0B42		     mov     word ptr ds:xms+2,	es
SYSINIT:0B46		     mov     ah, 1	     ; request HMA
SYSINIT:0B48		     mov     dx, 0FFFFh
SYSINIT:0B4B		     call    ds:xms	     ; call far	[xms]
SYSINIT:0B4F		     dec     ax
SYSINIT:0B50		     jz	     short allocHMA_1 ;	error if not able to allocate HMA
SYSINIT:0B52		     mov     ah, 88h
SYSINIT:0B54		     int     15h	     ; Get Extended Memory Size
SYSINIT:0B54					     ; Return: CF clear	on success
SYSINIT:0B54					     ; AX = size of memory above 1M in K
SYSINIT:0B56		     cmp     ax, 64	     ; less than 64 K of hma ?
SYSINIT:0B59		     jb	     short grabhma_error
SYSINIT:0B5B
SYSINIT:0B5B allocHMA_1:			     ; ...
SYSINIT:0B5B		     mov     ah, 5	     ; localenableA20
SYSINIT:0B5D		     call    ds:xms
SYSINIT:0B61		     dec     ax
SYSINIT:0B62		     jnz     short grabhma_error ; error if couldn't enable A20
SYSINIT:0B64		     call    IsVDiskInstalled
SYSINIT:0B67		     jz	     short grabhma_error ; yes,	we cant	use HMA
SYSINIT:0B69		     mov     ax, 0FFFFh
SYSINIT:0B6C		     mov     es, ax
SYSINIT:0B6E		     assume es:nothing
SYSINIT:0B6E		     mov     word ptr es:10h, 1234h ; see if we	can really read/write there
SYSINIT:0B75		     cmp     word ptr es:10h, 1234h
SYSINIT:0B7C		     jnz     short grabhma_error ; don't try to load there if XMS lied
SYSINIT:0B7E		     clc
SYSINIT:0B7F		     pop     ds
SYSINIT:0B80		     assume ds:nothing
SYSINIT:0B80		     retn
SYSINIT:0B81 ; ---------------------------------------------------------------------------
SYSINIT:0B81
SYSINIT:0B81 grabhma_error:			     ; ...
SYSINIT:0B81		     stc
SYSINIT:0B82		     pop     ds
SYSINIT:0B83		     retn
SYSINIT:0B83 AllocHMA	     endp
SYSINIT:0B83
SYSINIT:0B84
SYSINIT:0B84 ; =============== S U B R O U T I N E =======================================
SYSINIT:0B84
SYSINIT:0B84
SYSINIT:0B84 IsXMSLoaded     proc near		     ; ...
SYSINIT:0B84		     mov     ax, 4300h
SYSINIT:0B87		     int     2Fh	     ; - Multiplex - XMS - INSTALLATION	CHECK
SYSINIT:0B87					     ; Return: AL = 80h	XMS driver installed
SYSINIT:0B87					     ; AL <> 80h no driver
SYSINIT:0B89		     cmp     al, 80h	     ; XMS installed?
SYSINIT:0B8B		     retn
SYSINIT:0B8B IsXMSLoaded     endp
SYSINIT:0B8B
SYSINIT:0B8C ; ---------------------------------------------------------------------------
SYSINIT:0B8C
SYSINIT:0B8C FTryToMovDOSHi:			     ; ...
SYSINIT:0B8C		     push    ax
SYSINIT:0B8D		     push    bx
SYSINIT:0B8E		     push    cx
SYSINIT:0B8F		     push    dx
SYSINIT:0B90		     push    si
SYSINIT:0B91		     push    di
SYSINIT:0B92		     push    ds
SYSINIT:0B93		     push    es
SYSINIT:0B94		     cmp     cs:runhigh, 0FFh
SYSINIT:0B9A		     jnz     short _ftymdh_1
SYSINIT:0B9C		     call    TryToMovDOSHi
SYSINIT:0B9F
SYSINIT:0B9F _ftymdh_1:				     ; ...
SYSINIT:0B9F		     pop     es
SYSINIT:0BA0		     assume es:nothing
SYSINIT:0BA0		     pop     ds
SYSINIT:0BA1		     pop     di
SYSINIT:0BA2		     pop     si
SYSINIT:0BA3		     pop     dx
SYSINIT:0BA4		     pop     cx
SYSINIT:0BA5		     pop     bx
SYSINIT:0BA6		     pop     ax
SYSINIT:0BA7		     retf
SYSINIT:0BA7 ; ---------------------------------------------------------------------------
SYSINIT:0BA8 StartVDHead     dd	0		     ; ...
SYSINIT:0BA8					     ; link to next device driver
SYSINIT:0BAC		     dw	8000h		     ; device attribute
SYSINIT:0BAE		     dw	0		     ; strategy	routine	offset
SYSINIT:0BB0		     dw	0		     ; interrupt routine offset
SYSINIT:0BB2		     db	1		     ; number of units
SYSINIT:0BB3		     db	7 dup(0)	     ; reserved	area
SYSINIT:0BBA VDiskSig1	     db	'VDISK'              ; ...
SYSINIT:0BBF		     db	'  V3.3'             ; vdisk label ; VLEN1 equ ($-VDiskSig1)
SYSINIT:0BC5		     db	15 dup(0)	     ; pad
SYSINIT:0BD4		     dw	0		     ; bits 0-15 of free HMA
SYSINIT:0BD6		     db	11h		     ; bits 16-23 of free HMA (1M + 64K)
SYSINIT:0BD7 VDInt19	     db	0EAh		     ; jmp to old vector
SYSINIT:0BD8 OldVDInt19	     dw	2 dup(0)	     ; ...
SYSINIT:0BDC VDiskHMAHead    db	0, 0, 0		     ; ...
SYSINIT:0BDC					     ; EndVDHead
SYSINIT:0BDC					     ; non-bootable disk
SYSINIT:0BDF VDiskSig2	     db	'VDISK'              ; ...
SYSINIT:0BE4		     db	'3.3'                ; VLEN2 equ ($-VDiskSig2)
SYSINIT:0BE4					     ; OEM - signature
SYSINIT:0BE7		     dw	128		     ; number of bytes/sector
SYSINIT:0BE9		     db	1		     ; sectors/cluster
SYSINIT:0BEA		     dw	1		     ; reserved	sectors
SYSINIT:0BEC		     db	1		     ; number of FAT copies
SYSINIT:0BED		     dw	64		     ; number of root dir entries
SYSINIT:0BEF		     dw	512		     ; number of sectors
SYSINIT:0BF1		     db	0FEh		     ; media descriptor
SYSINIT:0BF2		     dw	6		     ; number of sectors/FAT
SYSINIT:0BF4		     dw	8		     ; sectors per track
SYSINIT:0BF6		     dw	1		     ; number of heads
SYSINIT:0BF8		     dw	0		     ; number of hidden	sectors
SYSINIT:0BFA		     dw	440h		     ; Start of	free HMA in K (1M+64K)
SYSINIT:0BFC
SYSINIT:0BFC ; =============== S U B R O U T I N E =======================================
SYSINIT:0BFC
SYSINIT:0BFC
SYSINIT:0BFC InstVDiskHeader proc near		     ; ...
SYSINIT:0BFC		     xor     ax, ax	     ; EndVDiskHMAHead (SYSINIT:0BFCh)
SYSINIT:0BFE		     mov     ds, ax	     ; seg of int vect table
SYSINIT:0C00		     assume ds:nothing
SYSINIT:0C00		     mov     ax, word ptr ds:64h ; [19h*4]
SYSINIT:0C03		     mov     cs:OldVDInt19, ax
SYSINIT:0C07		     mov     ax, word ptr ds:66h ; [19h*4+2]
SYSINIT:0C0A		     mov     cs:OldVDInt19+2, ax
SYSINIT:0C0E		     mov     ah, 48h
SYSINIT:0C10		     mov     bx, 4
SYSINIT:0C13		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:0C13					     ; BX = number of 16-byte paragraphs desired
SYSINIT:0C15		     dec     ax
SYSINIT:0C16		     mov     es, ax
SYSINIT:0C18		     mov     word ptr es:1, 8 ;	[es:ARENA.OWNER],8 ; owner = System
SYSINIT:0C1F		     mov     word ptr es:8, 4353h ; [es:ARENA.NAME],'SC' ; System Code
SYSINIT:0C26		     inc     ax
SYSINIT:0C27		     mov     es, ax	     ; get back	to allocated memory
SYSINIT:0C29		     cli		     ; no reboots at this time
SYSINIT:0C29					     ; install new int 19 vector
SYSINIT:0C2A		     mov     word ptr ds:64h, 47 ; (VDInt19-StartVDHead)
SYSINIT:0C2A					     ; 0BD7h-0BA8h = 2Fh = 47
SYSINIT:0C30		     mov     word ptr ds:66h, ax
SYSINIT:0C33		     mov     cx, 52	     ; (EndVDHead-StartVDHead)
SYSINIT:0C36		     mov     si, offset	StartVDHead ; SYSINIT:0BA8h
SYSINIT:0C39		     xor     di, di
SYSINIT:0C3B		     push    cs
SYSINIT:0C3C		     pop     ds
SYSINIT:0C3D		     assume ds:SYSINIT
SYSINIT:0C3D		     cld
SYSINIT:0C3E		     rep movsb
SYSINIT:0C40		     sti		     ; mov the HMA VDisk head into HMA
SYSINIT:0C41		     push    di
SYSINIT:0C42		     push    es
SYSINIT:0C43		     mov     ax, 0FFFFh
SYSINIT:0C46		     mov     es, ax
SYSINIT:0C48		     assume es:nothing
SYSINIT:0C48		     mov     di, 10h
SYSINIT:0C4B		     mov     cx, 32	     ; (EndVDiskHMAHead-VDiskHMAHead)
SYSINIT:0C4E		     mov     si, offset	VDiskHMAHead ; SYSINIT:0BDCh
SYSINIT:0C51		     rep movsb
SYSINIT:0C53		     pop     di
SYSINIT:0C54		     pop     es
SYSINIT:0C55		     assume es:nothing
SYSINIT:0C55		     retn
SYSINIT:0C55 InstVDiskHeader endp
SYSINIT:0C55
SYSINIT:0C55 ; ---------------------------------------------------------------------------
SYSINIT:0C56 dummy	     db	8 dup(0)	     ; ...
SYSINIT:0C56					     ; bmove
SYSINIT:0C5E gdt	     db	8 dup(0)	     ; times desc.size db 0
SYSINIT:0C66 src_desc	     dw	0FFFFh		     ; des <0ffffh,0,0,93h,0>
SYSINIT:0C68 desc_lo_word    dw	0		     ; ...
SYSINIT:0C6A desc_hi_byte    db	0		     ; ...
SYSINIT:0C6B		     db	93h
SYSINIT:0C6C		     dw	0
SYSINIT:0C6E tgt_desc	     dw	0FFFFh		     ; desc <0ffffh,0,10h,93h,0>  ; 1MB
SYSINIT:0C6E					     ; desc.seg_lim
SYSINIT:0C70		     dw	0		     ; desc.lo_word
SYSINIT:0C72		     db	10h		     ; desc.hi_byte
SYSINIT:0C73		     db	93h		     ; desc.acc_rights
SYSINIT:0C74		     dw	0		     ; desc.reserved
SYSINIT:0C76 rombios_code    db	8 dup(0)	     ; times desc.size db 0
SYSINIT:0C7E temp_stack	     db	8 dup(0)	     ; times desc.size db 0
SYSINIT:0C86 ClrdVDISKHead   db	32 dup(0)	     ; ...
SYSINIT:0CA6
SYSINIT:0CA6 ; =============== S U B R O U T I N E =======================================
SYSINIT:0CA6
SYSINIT:0CA6
SYSINIT:0CA6 ClrVDISKHeader  proc near		     ; ...
SYSINIT:0CA6		     in	     al, 64h	     ; 8042 keyboard controller	status register
SYSINIT:0CA6					     ; 7:  PERR	   1=parity error in data received from	keyboard
SYSINIT:0CA6					     ;	  +----------- AT Mode ----------+------------ PS/2 Mode ------------+
SYSINIT:0CA6					     ; 6: |RxTO	   receive (Rx)	timeout	 | TO	   general timeout (Rx or Tx)|
SYSINIT:0CA6					     ; 5: |TxTO	   transmit (Tx) timeout | MOBF	   mouse output	buffer full  |
SYSINIT:0CA6					     ;	  +------------------------------+-----------------------------------+
SYSINIT:0CA6					     ; 4:  INH	   0=keyboard communications inhibited
SYSINIT:0CA6					     ; 3:  A2	   0=60h was the port last written to, 1=64h was last
SYSINIT:0CA6					     ; 2:  SYS	   distinguishes reset types: 0=cold reboot, 1=warm reboot
SYSINIT:0CA6					     ; 1:  IBF	   1=input buffer full (keyboard can't accept data)
SYSINIT:0CA6					     ; 0:  OBF	   1=output buffer full	(data from keyboard is available)
SYSINIT:0CA8		     test    al, 10h	     ; test bit	4 - Is keyboard	inhibited?
SYSINIT:0CAA		     jnz     short ClrVDISKok ;	no, go do block	move
SYSINIT:0CAC		     cmp     word ptr cs:sys_model_byte, 19F8h ; check for TORTUGA models
SYSINIT:0CB3		     jz	     short ClrVDISKno ;	do not use INT 15h block move code
SYSINIT:0CB3					     ; (while 8042 is disabled)
SYSINIT:0CB5		     cmp     word ptr cs:sys_model_byte, 9FCh ;	Check for PS/2 30-286 model
SYSINIT:0CBC		     jnz     short ClrVDISKok
SYSINIT:0CBE
SYSINIT:0CBE ClrVDISKno:			     ; ...
SYSINIT:0CBE		     retn
SYSINIT:0CBF ; ---------------------------------------------------------------------------
SYSINIT:0CBF
SYSINIT:0CBF ClrVDISKok:			     ; ...
SYSINIT:0CBF		     push    es
SYSINIT:0CC0		     mov     ax, cs
SYSINIT:0CC2		     mov     dx, ax
SYSINIT:0CC4		     mov     cl, 12
SYSINIT:0CC6		     shr     dx, cl	     ; dx = higher 4 bits of the segment number
SYSINIT:0CC6					     ;	  = segment number / 4096 (= byte address / 65536)
SYSINIT:0CC8		     mov     cl, 4
SYSINIT:0CCA		     shl     ax, cl	     ; ax = (lower 12 bits of the segment number)*16
SYSINIT:0CCC		     add     ax, offset	ClrdVDISKHead
SYSINIT:0CCF		     adc     dl, 0	     ; dl:ax = 24 bit linear address
SYSINIT:0CD2		     mov     cs:desc_lo_word, ax
SYSINIT:0CD6		     mov     cs:desc_hi_byte, dl
SYSINIT:0CDB		     mov     cx, 16	     ; 16 words
SYSINIT:0CDE		     push    cs
SYSINIT:0CDF		     pop     es
SYSINIT:0CE0		     assume es:SYSINIT
SYSINIT:0CE0		     mov     si, offset	dummy ;	offset bmove
SYSINIT:0CE3		     mov     ah, 87h
SYSINIT:0CE5		     int     15h	     ; EXTENDED	MEMORY - BLOCK MOVE (AT,XT286,PS)
SYSINIT:0CE5					     ; CX = number of words to move, ES:SI -> global descriptor	table
SYSINIT:0CE5					     ; Return: CF set on error,	AH = status
SYSINIT:0CE7		     pop     es
SYSINIT:0CE8		     assume es:nothing
SYSINIT:0CE8		     retn
SYSINIT:0CE8 ClrVDISKHeader  endp
SYSINIT:0CE8
SYSINIT:0CE9
SYSINIT:0CE9 ; =============== S U B R O U T I N E =======================================
SYSINIT:0CE9
SYSINIT:0CE9
SYSINIT:0CE9 SaveFreeHMAPtr  proc near		     ; ...
SYSINIT:0CE9		     mov     bx, es
SYSINIT:0CEB		     mov     ax, 0FFFFh	     ; HMA segment
SYSINIT:0CEE		     sub     ax, bx
SYSINIT:0CF0		     add     di, 15	     ; para round
SYSINIT:0CF3		     and     di, 0FFF0h
SYSINIT:0CF6		     mov     cl, 4
SYSINIT:0CF8		     shl     ax, cl
SYSINIT:0CFA		     sub     di, ax
SYSINIT:0CFC		     push    ds
SYSINIT:0CFD		     mov     ax, 70h	     ; DOSBIODATASEG ; BIOSDATA	segment
SYSINIT:0D00		     mov     ds, ax
SYSINIT:0D02		     assume ds:nothing
SYSINIT:0D02		     mov     ds:FreeHMAPtr, di ; BIOSDATA:08F7h
SYSINIT:0D06		     mov     ds:inHMA, 0FFh  ; BIOSDATA:000Dh
SYSINIT:0D0B		     pop     ds
SYSINIT:0D0C		     assume ds:nothing
SYSINIT:0D0C		     retn
SYSINIT:0D0C SaveFreeHMAPtr  endp
SYSINIT:0D0C
SYSINIT:0D0D
SYSINIT:0D0D ; =============== S U B R O U T I N E =======================================
SYSINIT:0D0D
SYSINIT:0D0D
SYSINIT:0D0D IsVDiskInstalled proc near		     ; ...
SYSINIT:0D0D		     xor     ax, ax
SYSINIT:0D0F		     mov     ds, ax
SYSINIT:0D11		     assume ds:nothing
SYSINIT:0D11		     mov     ds, ds:4Eh	     ; [13h*4+2]
SYSINIT:0D15		     assume ds:nothing
SYSINIT:0D15		     mov     si, 12h	     ; VDiskSig1-StartVDHead
SYSINIT:0D18		     mov     cx, 5	     ; VLEN1
SYSINIT:0D1B		     push    cs
SYSINIT:0D1C		     pop     es
SYSINIT:0D1D		     assume es:SYSINIT
SYSINIT:0D1D		     mov     di, offset	VDiskSig1 ; "VDISK"
SYSINIT:0D20		     repe cmpsb
SYSINIT:0D22		     jz	     short ivdins_retn
SYSINIT:0D24		     mov     ax, 0FFFFh
SYSINIT:0D27		     mov     ds, ax
SYSINIT:0D29		     assume ds:nothing
SYSINIT:0D29		     mov     si, 13h	     ; 10h+(VDiskSig2-VDiskHMAHead)
SYSINIT:0D2C		     mov     di, offset	VDiskSig2 ; "VDISK"
SYSINIT:0D2F		     mov     cx, 5
SYSINIT:0D32		     repe cmpsb
SYSINIT:0D34
SYSINIT:0D34 ivdins_retn:			     ; ...
SYSINIT:0D34		     retn
SYSINIT:0D34 IsVDiskInstalled endp
SYSINIT:0D34
SYSINIT:0D35
SYSINIT:0D35 ; =============== S U B R O U T I N E =======================================
SYSINIT:0D35
SYSINIT:0D35
SYSINIT:0D35 CPMHack	     proc near		     ; ...
SYSINIT:0D35		     push    ds
SYSINIT:0D36		     mov     cx, 0FFFFh
SYSINIT:0D39		     mov     es, cx
SYSINIT:0D3B		     assume es:nothing
SYSINIT:0D3B		     xor     cx, cx
SYSINIT:0D3D		     mov     ds, cx
SYSINIT:0D3F		     assume ds:nothing
SYSINIT:0D3F		     mov     si, 0C0h
SYSINIT:0D42		     mov     di, 0D0h
SYSINIT:0D45		     mov     cx, 5
SYSINIT:0D48		     cld
SYSINIT:0D49		     rep movsb		     ; move 5 bytes from 0:C0h to FFFFh:D0h
SYSINIT:0D4B		     pop     ds
SYSINIT:0D4C		     assume ds:nothing
SYSINIT:0D4C		     retn
SYSINIT:0D4C CPMHack	     endp
SYSINIT:0D4C
SYSINIT:0D4D
SYSINIT:0D4D ; =============== S U B R O U T I N E =======================================
SYSINIT:0D4D
SYSINIT:0D4D
SYSINIT:0D4D _off_to_para    proc near		     ; ...
SYSINIT:0D4D		     shr     ax, 1
SYSINIT:0D4F		     shr     ax, 1
SYSINIT:0D51		     shr     ax, 1
SYSINIT:0D53		     shr     ax, 1
SYSINIT:0D55		     retn
SYSINIT:0D55 _off_to_para    endp
SYSINIT:0D55
SYSINIT:0D56
SYSINIT:0D56 ; =============== S U B R O U T I N E =======================================
SYSINIT:0D56
SYSINIT:0D56
SYSINIT:0D56 TempCDS	     proc near		     ; ...
SYSINIT:0D56		     les     di, ds:DOSINFO
SYSINIT:0D5A		     assume es:nothing
SYSINIT:0D5A		     mov     cl, es:[di+20h] ; [es:di+SYSI_NUMIO]
SYSINIT:0D5E		     xor     ch, ch	     ; (cx) = #	of block devices
SYSINIT:0D60		     mov     es:[di+21h], cl ; [es:di+SYSI_NCDS] ; one CDS per device
SYSINIT:0D64		     mov     al, cl
SYSINIT:0D66		     mov     ah, 88	     ; curdirlen ; curdir_list.size
SYSINIT:0D68		     mul     ah
SYSINIT:0D6A		     call    ParaRound
SYSINIT:0D6D		     mov     si, ds:top_of_cdss
SYSINIT:0D71		     sub     si, ax
SYSINIT:0D73		     mov     es:[di+18h], si ; [es:di+SYSI_CDS+2]
SYSINIT:0D77		     mov     ax, si
SYSINIT:0D79		     mov     word ptr es:[di+16h], 0 ; [es:di+SYSI_CDS]
SYSINIT:0D79					     ; set address of CDS list
SYSINIT:0D7F		     lds     si, es:[di]     ; lds si,[es:di+SYSI_DPB]
SYSINIT:0D7F					     ; (ds:si) = address of first DPB
SYSINIT:0D82		     mov     es, ax
SYSINIT:0D84		     xor     di, di	     ; (es:di) = address of 1st	CDS
SYSINIT:0D84 TempCDS	     endp
SYSINIT:0D84
SYSINIT:0D86
SYSINIT:0D86 ; =============== S U B R O U T I N E =======================================
SYSINIT:0D86
SYSINIT:0D86
SYSINIT:0D86 fooset	     proc near		     ; ...
SYSINIT:0D86		     mov     ax, word ptr cs:DirStrng ;	"A:\"
SYSINIT:0D8A		     stosw		     ; setup the root as the curdir
SYSINIT:0D8B		     call    get_dpb_for_drive_al ; get	dpb for	drive in dpb
SYSINIT:0D8B					     ; (ds:si) = address of DPB
SYSINIT:0D8B					     ;	  (si) = -1 if no drive
SYSINIT:0D8E		     mov     ax, word ptr cs:DirStrng+2	; "\",0
SYSINIT:0D92		     stosw
SYSINIT:0D93		     inc     byte ptr cs:DirStrng ; "A:\"
SYSINIT:0D98		     xor     ax, ax
SYSINIT:0D9A		     push    cx
SYSINIT:0D9B		     mov     cx, 63	     ; curdir_list.cdir_flags -	4
SYSINIT:0D9E		     rep stosb		     ; zero out	rest of	CURDIR_TEXTs
SYSINIT:0D9E					     ; (ax) = 0
SYSINIT:0D9E					     ; (es:di) = CURDIR_FLAGS in the CDS records
SYSINIT:0D9E					     ; (ds:si) = Next DPB (-1 if none)
SYSINIT:0DA0		     cmp     si, 0FFFFh	     ; -1
SYSINIT:0DA3		     jz	     short fooset_zero ; don't have any physical drive.
SYSINIT:0DA5		     cmp     cs:fake_floppy_drv, 1
SYSINIT:0DAB		     jnz     short normcds   ; machine has floppy drives
SYSINIT:0DAD		     cmp     byte ptr [si], 1 ;	cmp [si+DPB.drive],1
SYSINIT:0DAD					     ; if dpb_drive = 0	(A) or 1 (B).
SYSINIT:0DB0		     ja	     short normcds
SYSINIT:0DB2		     mov     cl, 3	     ; the next	dbp pointer
SYSINIT:0DB4		     rep stosw		     ; ax should be zero here
SYSINIT:0DB6		     pop     cx
SYSINIT:0DB7		     jmp     short get_next_dpb
SYSINIT:0DB9 ; ---------------------------------------------------------------------------
SYSINIT:0DB9
SYSINIT:0DB9 fooset_zero:			     ; ...
SYSINIT:0DB9		     mov     cl, 3
SYSINIT:0DBB		     rep stosw
SYSINIT:0DBD		     pop     cx
SYSINIT:0DBE		     jmp     short get_next_dpb	; jmp short fincds
SYSINIT:0DC0 ; ---------------------------------------------------------------------------
SYSINIT:0DC0
SYSINIT:0DC0 normcds:				     ; ...
SYSINIT:0DC0		     pop     cx
SYSINIT:0DC1		     cmp     byte ptr [si+8], 0	; [si+DPB.FAT_COUNT] ; non fat system?
SYSINIT:0DC5		     jz	     short etnormcds ; yes. set	curdir_flags to	0. ax =	0 now.
SYSINIT:0DC7		     mov     ax, 4000h	     ; curdir_inuse ; else,fat system.
SYSINIT:0DC7					     ; set the flag to curdir_inuse.
SYSINIT:0DCA
SYSINIT:0DCA etnormcds:				     ; ...
SYSINIT:0DCA		     stosw		     ; curdir_flags
SYSINIT:0DCB		     mov     ax, si
SYSINIT:0DCD		     stosw		     ; curdir_devptr
SYSINIT:0DCE		     mov     ax, ds
SYSINIT:0DD0		     stosw
SYSINIT:0DD1
SYSINIT:0DD1 get_next_dpb:			     ; ...
SYSINIT:0DD1		     mov     ax, 0FFFFh	     ; entry point for fake_fooset_zero
SYSINIT:0DD1					     ; mov ax,-1
SYSINIT:0DD4		     stosw		     ; curdir_id
SYSINIT:0DD5		     stosw		     ; curdir_id
SYSINIT:0DD6		     stosw		     ; curdir_user_word
SYSINIT:0DD7		     mov     ax, 2	     ; curdir_end
SYSINIT:0DDA		     stosw
SYSINIT:0DDB		     mov     al, 0	     ; clear out 7 bytes (curdir_type,
SYSINIT:0DDD		     stosb
SYSINIT:0DDE		     stosw		     ; curdir_ifs_hdr,curdir_fsda)
SYSINIT:0DDF		     stosw
SYSINIT:0DE0		     stosw
SYSINIT:0DE1		     loop    fooset
SYSINIT:0DE3		     mov     byte ptr cs:DirStrng, 'A' ; "A:\",0
SYSINIT:0DE9		     retn
SYSINIT:0DE9 fooset	     endp
SYSINIT:0DE9
SYSINIT:0DEA
SYSINIT:0DEA ; =============== S U B R O U T I N E =======================================
SYSINIT:0DEA
SYSINIT:0DEA
SYSINIT:0DEA get_dpb_for_drive_al proc near	     ; ...
SYSINIT:0DEA		     lds     si, cs:DOSINFO  ; point to	first DPB
SYSINIT:0DEF		     lds     si, [si]	     ; (ds:si) = address of first DPB
SYSINIT:0DF1		     sub     al, 'A'
SYSINIT:0DF3
SYSINIT:0DF3 get_dpb_for_drive_1:		     ; ...
SYSINIT:0DF3		     cmp     al, [si]	     ; cmp al,[si+DPB.DRIVE] ; match?
SYSINIT:0DF5		     jz	     short got_dpb_for_drive
SYSINIT:0DF7		     lds     si, [si+19h]    ; lds si,[si+DPB.NEXT_DPB]
SYSINIT:0DFA		     cmp     si, 0FFFFh
SYSINIT:0DFD		     jnz     short get_dpb_for_drive_1 ; loop until hit	end of DPBs
SYSINIT:0DFF
SYSINIT:0DFF got_dpb_for_drive:			     ; ...
SYSINIT:0DFF		     retn
SYSINIT:0DFF get_dpb_for_drive_al endp
SYSINIT:0DFF
SYSINIT:0E00
SYSINIT:0E00 ; =============== S U B R O U T I N E =======================================
SYSINIT:0E00
SYSINIT:0E00
SYSINIT:0E00 endfile	     proc near		     ; ...
SYSINIT:0E00		     push    ds		     ; Build DOS structures
SYSINIT:0E01		     mov     ax, 70h	     ; DOSBIODATASEG
SYSINIT:0E04		     mov     ds, ax
SYSINIT:0E06		     assume ds:nothing
SYSINIT:0E06		     cmp     ds:multrk_flag, 0 ; multrk_off1
SYSINIT:0E06					     ; multrack= command entered?
SYSINIT:0E0B		     jnz     short multrk_flag_done
SYSINIT:0E0D		     or	     ds:multrk_flag, 80h ; or [multrk_flag],multrk_on
SYSINIT:0E13
SYSINIT:0E13 multrk_flag_done:			     ; ...
SYSINIT:0E13		     pop     ds
SYSINIT:0E14		     assume ds:nothing
SYSINIT:0E14		     mov     ax, cs:CONFBOT
SYSINIT:0E18		     mov     cs:ALLOCLIM, ax
SYSINIT:0E1C		     push    cs
SYSINIT:0E1D		     pop     ds
SYSINIT:0E1E		     assume ds:SYSINIT
SYSINIT:0E1E		     call    round
SYSINIT:0E21		     mov     al, cs:FILES
SYSINIT:0E25		     sub     al, 5
SYSINIT:0E27		     jbe     short dofcbs
SYSINIT:0E29		     push    ax
SYSINIT:0E2A		     mov     al, 'F'         ; devmark_files
SYSINIT:0E2C		     call    setdevmark	     ; set devmark for sfts (files)
SYSINIT:0E2F		     pop     ax
SYSINIT:0E30		     xor     ah, ah	     ; do not use cbw instruction!
SYSINIT:0E30					     ; it does sign extend.
SYSINIT:0E32		     mov     bx, cs:memlo
SYSINIT:0E37		     mov     dx, cs:memhi
SYSINIT:0E3C		     lds     di, cs:DOSINFO  ; get pointer to dos data
SYSINIT:0E41		     assume ds:nothing
SYSINIT:0E41		     lds     di, [di+4]	     ; lds di,[di+SYSI_SFT] ; ds:di points to sft
SYSINIT:0E44		     mov     [di], bx	     ; [di+SF.SFLink],bx
SYSINIT:0E46		     mov     [di+2], dx	     ; [di+SF.SFLink+2],dx ; set pointer to new	sft
SYSINIT:0E49		     push    cs
SYSINIT:0E4A		     pop     ds
SYSINIT:0E4B		     assume ds:SYSINIT
SYSINIT:0E4B		     les     di, dword ptr cs:memlo ; point to new sft
SYSINIT:0E50		     mov     word ptr es:[di], 0FFFFh ;	mov word [es:di+SF.SFLink],-1
SYSINIT:0E55		     mov     es:[di+4],	ax   ; mov [es:di+SF.SFCount],ax
SYSINIT:0E59		     mov     bl, 59	     ; SF_ENTRY.size
SYSINIT:0E5B		     mul     bl
SYSINIT:0E5D		     mov     cx, ax	     ; ax = number of bytes to clear
SYSINIT:0E5F		     add     cs:memlo, ax    ; allocate	memory
SYSINIT:0E64		     mov     ax, 6
SYSINIT:0E67		     add     cs:memlo, ax    ; remember	the header too
SYSINIT:0E6C		     or	     cs:setdevmarkflag,	2 ; for_devmark
SYSINIT:0E72		     call    round	     ; check for mem error before the stosb
SYSINIT:0E75		     add     di, ax	     ; ax = 6
SYSINIT:0E77		     xor     ax, ax
SYSINIT:0E79		     rep stosb		     ; clean out the stuff
SYSINIT:0E7B
SYSINIT:0E7B dofcbs:				     ; ...
SYSINIT:0E7B		     push    cs
SYSINIT:0E7C		     pop     ds
SYSINIT:0E7D		     call    round
SYSINIT:0E80		     mov     al, 'X'         ; devmark_fcbs
SYSINIT:0E82		     call    setdevmark
SYSINIT:0E85		     mov     al, cs:FCBS
SYSINIT:0E89		     xor     ah, ah	     ; do not use cbw instruction!
SYSINIT:0E89					     ; it does sign extend.
SYSINIT:0E8B		     mov     bx, cs:memlo
SYSINIT:0E90		     mov     dx, cs:memhi
SYSINIT:0E95		     lds     di, cs:DOSINFO  ; get pointer to dos data
SYSINIT:0E9A		     assume ds:nothing
SYSINIT:0E9A		     mov     [di+1Ah], bx    ; [di+SYSI_FCB]
SYSINIT:0E9D		     mov     [di+1Ch], dx    ; [di+SYSI_FCB+2] ; set pointer to	new table
SYSINIT:0EA0		     mov     bl, cs:KEEP
SYSINIT:0EA5		     xor     bh, bh
SYSINIT:0EA7		     mov     [di+1Eh], bx    ; [di+SYSI_KEEP]
SYSINIT:0EAA		     push    cs
SYSINIT:0EAB		     pop     ds
SYSINIT:0EAC		     assume ds:SYSINIT
SYSINIT:0EAC		     les     di, dword ptr memlo ; point to new	table
SYSINIT:0EB0		     mov     word ptr es:[di], 0FFFFh ;	[es:di+SF.SFLink],-1
SYSINIT:0EB5		     mov     es:[di+4],	ax   ; [es:di+SF.SFCount]
SYSINIT:0EB9		     mov     bl, 59	     ; SF_ENTRY.size
SYSINIT:0EBB		     mov     cx, ax
SYSINIT:0EBD		     mul     bl
SYSINIT:0EBF		     add     memlo, ax	     ; ax = number of bytes to clear
SYSINIT:0EC3		     mov     ax, 6	     ; SF.size-2
SYSINIT:0EC6		     add     memlo, ax	     ; remember	the header too
SYSINIT:0ECA		     or	     setdevmarkflag, 2 ; for_devmark
SYSINIT:0ECF		     call    round	     ; check for mem error before the stosb
SYSINIT:0ED2		     add     di, ax	     ; skip over header
SYSINIT:0ED4		     mov     al, 'A'
SYSINIT:0ED6
SYSINIT:0ED6 fillloop:				     ; ...
SYSINIT:0ED6		     push    cx		     ; save count
SYSINIT:0ED7		     mov     cx, 59	     ; number of bytes to fill
SYSINIT:0EDA		     cld
SYSINIT:0EDB		     rep stosb		     ; filled
SYSINIT:0EDD		     mov     word ptr es:[di-3Bh], 0 ; [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_ref_count]
SYSINIT:0EE3		     mov     word ptr es:[di-26h], 0 ; [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position]
SYSINIT:0EE9		     mov     word ptr es:[di-24h], 0 ; [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position+2]
SYSINIT:0EEF		     pop     cx
SYSINIT:0EF0		     loop    fillloop
SYSINIT:0EF2		     cmp     buffers, 0FFFFh ; -1 ; has	buffers	been already set?
SYSINIT:0EF7		     jz	     short dodefaultbuff
SYSINIT:0EF9		     jmp     dobuff	     ; the user	entered	the buffers=.
SYSINIT:0EFC ; ---------------------------------------------------------------------------
SYSINIT:0EFC
SYSINIT:0EFC dodefaultbuff:			     ; ...
SYSINIT:0EFC		     mov     h_buffers,	0    ; default is no heuristic buffers.
SYSINIT:0F02		     mov     buffers, 2	     ; default to 2 buffers
SYSINIT:0F08		     push    ax
SYSINIT:0F09		     push    ds
SYSINIT:0F0A		     les     bp, cs:DOSINFO  ; search through the dpb's
SYSINIT:0F0F		     les     bp, es:[bp+0]   ; [es:bp+SYSI_DPB]	; get first dpb
SYSINIT:0F13		     push    cs
SYSINIT:0F14		     pop     ds
SYSINIT:0F15
SYSINIT:0F15 nextdpb:				     ; ...
SYSINIT:0F15		     mov     bl, es:[bp+0]   ; [es:bp+DPB.drive]
SYSINIT:0F19		     inc     bl
SYSINIT:0F1B		     mov     ax, 4408h	     ; (IOCTL<<8)|8
SYSINIT:0F1E		     int     21h	     ; DOS - 2+	- IOCTL	-
SYSINIT:0F20		     or	     ax, ax	     ; 0 = removable disk, 1 = fixed disk
SYSINIT:0F22		     jnz     short nosetbuf  ; ax is nonzero if	disk is	nonremoveable
SYSINIT:0F24		     xor     bx, bx	     ; get parameters of (removable) drive
SYSINIT:0F26		     mov     bl, es:[bp+0]   ; [es:bp+DPB.drive]
SYSINIT:0F2A		     inc     bl
SYSINIT:0F2C		     mov     dx, offset	devp_specialfunc
SYSINIT:0F2F		     mov     ax, 440Dh	     ; (IOCTL<<8)|GENERIC_IOCTL
SYSINIT:0F32		     mov     cx, 860h	     ; (RAWIO<<8)|GET_DEVICE_PARAMETERS
SYSINIT:0F35		     int     21h	     ; DOS - 2+	- IOCTL	-
SYSINIT:0F37		     jb	     short nosetbuf  ; get next	dpb if driver doesn't support
SYSINIT:0F37					     ; generic ioctl
SYSINIT:0F39		     mov     bx, devp_totalsecs	; [deviceparameters+15]
SYSINIT:0F39					     ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
SYSINIT:0F3D		     mov     ax, devp_bps    ; [deviceparameters+7]
SYSINIT:0F3D					     ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_BYTESPERSECTOR]
SYSINIT:0F40		     xor     dx, dx
SYSINIT:0F42		     mov     cx, 512	     ; scale sector size in factor of 512 bytes
SYSINIT:0F45		     div     cx
SYSINIT:0F47		     mul     bx		     ; ax = #sectors * size factor
SYSINIT:0F49		     or	     dx, dx	     ; just in case of large floppies
SYSINIT:0F4B		     jnz     short setbuf
SYSINIT:0F4D		     cmp     ax, 720	     ; 720 sectors * size factor of 1
SYSINIT:0F50		     jbe     short nosetbuf
SYSINIT:0F52
SYSINIT:0F52 setbuf:				     ; ...
SYSINIT:0F52		     mov     buffers, 3
SYSINIT:0F58		     jmp     short chk_memsize_for_buffers ; now check the memory size
SYSINIT:0F58					     ; for default buffer count
SYSINIT:0F5A ; ---------------------------------------------------------------------------
SYSINIT:0F5A
SYSINIT:0F5A nosetbuf:				     ; ...
SYSINIT:0F5A		     cmp     word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB],-1
SYSINIT:0F5F		     jz	     short chk_memsize_for_buffers
SYSINIT:0F61		     les     bp, es:[bp+19h] ; les bp,[es:bp+DPB.NEXT_DPB]
SYSINIT:0F65		     jmp     short nextdpb
SYSINIT:0F67 ; ---------------------------------------------------------------------------
SYSINIT:0F67
SYSINIT:0F67 chk_memsize_for_buffers:		     ; ...
SYSINIT:0F67		     cmp     MEMORY_SIZE, 2000h	; 128kb
SYSINIT:0F6D		     jbe     short bufset
SYSINIT:0F6F		     mov     buffers, 5
SYSINIT:0F75		     cmp     MEMORY_SIZE, 4000h	; 256kb
SYSINIT:0F7B		     jbe     short bufset
SYSINIT:0F7D		     mov     buffers, 10
SYSINIT:0F83		     cmp     MEMORY_SIZE, 8000h	; 512kb
SYSINIT:0F89		     jbe     short bufset
SYSINIT:0F8B		     mov     buffers, 15
SYSINIT:0F91
SYSINIT:0F91 bufset:				     ; ...
SYSINIT:0F91		     pop     ds
SYSINIT:0F92		     assume ds:nothing
SYSINIT:0F92		     pop     ax
SYSINIT:0F93
SYSINIT:0F93 dobuff:				     ; ...
SYSINIT:0F93		     lds     bx, cs:DOSINFO  ; ds:bx ->	sysinitvar
SYSINIT:0F98		     mov     ax, cs:buffers
SYSINIT:0F9C		     mov     [bx+3Fh], ax    ; [bx+SYSI_BUFFERS] ; set sysi_buffers
SYSINIT:0F9F		     mov     ax, cs:h_buffers
SYSINIT:0FA3		     mov     [bx+41h], ax    ; [bx+SYSI_BUFFERS+2]
SYSINIT:0FA6		     lds     bx, [bx+12h]    ; [bx+SYSI_BUF] ; now, ds:bx -> buffinfo
SYSINIT:0FA9		     call    round	     ; get [memhi]:[memlo]
SYSINIT:0FAC		     mov     al, 'B'         ; devmark_buf
SYSINIT:0FAE		     call    setdevmark
SYSINIT:0FB1		     push    ds		     ; save buffer info. ptr.
SYSINIT:0FB2		     push    bx
SYSINIT:0FB3		     call    set_buffer
SYSINIT:0FB6		     pop     bx		     ; restore buffer info. ptr.
SYSINIT:0FB7		     pop     ds
SYSINIT:0FB8		     cmp     cs:h_buffers, 0 ; set the secondary buffer	if specified
SYSINIT:0FBE		     jz	     short xif16
SYSINIT:0FC0		     call    round
SYSINIT:0FC3		     mov     cx, cs:memlo
SYSINIT:0FC8		     mov     [bx+6], cx	     ; [bx+BUFFINF.Cache_ptr]
SYSINIT:0FCB		     mov     cx, cs:memhi
SYSINIT:0FD0		     mov     [bx+8], cx	     ; [bx+BUFFINF.Cache_ptr+2]
SYSINIT:0FD3		     mov     cx, cs:h_buffers
SYSINIT:0FD8		     mov     [bx+10], cx     ; [bx+BUFFINF.Cache_count]
SYSINIT:0FDB		     mov     ax, 512	     ; 512 bytes
SYSINIT:0FDE		     mul     cx
SYSINIT:0FE0		     mov     cs:memlo, ax
SYSINIT:0FE4		     or	     cs:setdevmarkflag,	2 ; for_devmark
SYSINIT:0FEA		     call    round
SYSINIT:0FED
SYSINIT:0FED xif16:				     ; ...
SYSINIT:0FED		     call    round	     ; buf1
SYSINIT:0FF0		     push    ax
SYSINIT:0FF1		     mov     ax, 'L'         ; devmark_cds
SYSINIT:0FF4		     call    setdevmark
SYSINIT:0FF7		     pop     ax
SYSINIT:0FF8		     les     di, cs:DOSINFO
SYSINIT:0FFD		     mov     cl, es:[di+20h] ; [es:di+SYSI_NUMIO]
SYSINIT:1001		     cmp     cl, cs:NUM_CDS
SYSINIT:1006		     jnb     short gotncds   ; user setting must be at least numio
SYSINIT:1008		     mov     cl, cs:NUM_CDS
SYSINIT:100D
SYSINIT:100D gotncds:				     ; ...
SYSINIT:100D		     xor     ch, ch
SYSINIT:100F		     mov     es:[di+21h], cl ; [es:di+SYSI_NCDS]
SYSINIT:1013		     mov     ax, cs:memhi
SYSINIT:1017		     mov     es:[di+18h], ax ; [es:di+SYSI_CDS+2]
SYSINIT:101B		     mov     ax, cs:memlo
SYSINIT:101F		     mov     es:[di+16h], ax ; [es:di+SYSI_CDS]
SYSINIT:1023		     mov     al, cl
SYSINIT:1025		     mov     ah, 88	     ; curdirlen ; curdir_list.size
SYSINIT:1027		     mul     ah
SYSINIT:1029		     call    ParaRound
SYSINIT:102C		     add     cs:memhi, ax
SYSINIT:1031		     or	     cs:setdevmarkflag,	2 ; for_devmark
SYSINIT:1037		     call    round	     ; check for mem error before initializing
SYSINIT:103A		     lds     si, es:[di]     ; lds si,[es:di+SYSI_DPB] ; [es:di+0]
SYSINIT:103D		     les     di, es:[di+16h] ; les di,[es:di+SYSI_CDS] ; [es:di+22]
SYSINIT:1041		     call    fooset
SYSINIT:1044		     push    cs
SYSINIT:1045		     pop     ds
SYSINIT:1046		     assume ds:SYSINIT
SYSINIT:1046		     cmp     stack_addr, 0FFFFh	; -1 ; has the user entered "stacks=" command?
SYSINIT:104B		     jz	     short doinstallstack ; then install as specified by the user
SYSINIT:104D		     cmp     sys_scnd_model_byte, 0 ; pc1,xt has the secondary model byte = 0
SYSINIT:1052		     jnz     short doinstallstack ; other model	should have default stack of 9,128
SYSINIT:1054		     cmp     sys_model_byte, 0FEh ; pc1, pc/xt or pc portable ?
SYSINIT:1059		     jnb     short skipstack
SYSINIT:105B
SYSINIT:105B doinstallstack:			     ; ...
SYSINIT:105B		     mov     ax, stack_count ; stack_count = 0?
SYSINIT:105E		     or	     ax, ax	     ; then, stack size	must be	0 too.
SYSINIT:1060		     jz	     short skipstack ; don't install stack.
SYSINIT:1062		     call    round	     ; dynamic relocation of stack code.
SYSINIT:1062					     ; [memhi] = seg. for stack	code
SYSINIT:1062					     ; [memlo] = 0
SYSINIT:1065		     mov     al, 'S'         ; devmark_stk
SYSINIT:1067		     call    setdevmark
SYSINIT:106A		     mov     ax, memhi
SYSINIT:106D		     mov     es, ax	     ; es -> seg. the stack code is going to move.
SYSINIT:106F		     push    cs
SYSINIT:1070		     pop     ds
SYSINIT:1071		     xor     si, si	     ; ! we know that stack code is at the beginning of	sysinit.
SYSINIT:1073		     xor     di, di
SYSINIT:1075		     mov     cx, offset	_SYSINIT ; offset endstackcode = offset	_SYSINIT
SYSINIT:1075					     ; SYSINIT:0269h
SYSINIT:1078		     mov     memlo, cx
SYSINIT:107C		     call    round	     ; have enough space for relocation?
SYSINIT:107F		     rep movsb
SYSINIT:1081		     push    ds
SYSINIT:1082		     mov     ax, 70h	     ; DOSBIODATASEG
SYSINIT:1085		     mov     ds, ax
SYSINIT:1087		     assume ds:nothing
SYSINIT:1087		     mov     ds:NextStack, offset nextentry ; [BIOSDATA:NextStack],
SYSINIT:1087					     ;	offset SYSINIT:nextentry (SYSINIT:0010h)
SYSINIT:108D		     mov     ds:NextStack+2, es
SYSINIT:1091		     mov     ax, cs:memlo
SYSINIT:1095		     mov     cs:stack_addr, ax ; set for stack area initialization
SYSINIT:1099		     mov     word ptr ds:IT_StackLoc, ax ; pass	it as Instance Data, too
SYSINIT:109C		     mov     ax, cs:memhi    ; this will be used by stack_init routine.
SYSINIT:10A0		     mov     cs:stack_addr+2, ax
SYSINIT:10A4		     mov     word ptr ds:IT_StackLoc+2,	ax
SYSINIT:10A7		     mov     ax, 8	     ; entrysize
SYSINIT:10AA		     add     ax, cs:stack_size
SYSINIT:10AF		     mul     cs:stack_count
SYSINIT:10B4		     mov     ds:IT_StackSize, ax ; pass	through	to Instance Table
SYSINIT:10B7		     pop     ds
SYSINIT:10B8		     assume ds:nothing
SYSINIT:10B8		     call    ParaRound
SYSINIT:10BB		     add     cs:memhi, ax
SYSINIT:10C0		     or	     cs:setdevmarkflag,	2 ; for_devmark
SYSINIT:10C0					     ; to set the devmark_size for stack by round routine.
SYSINIT:10C6		     call    round	     ; check for memory	error before continuing
SYSINIT:10C9		     call    stackinit	     ; initialize hardware stack.
SYSINIT:10C9					     ; cs=ds=sysinitseg,es=relocated stack code	& data
SYSINIT:10CC
SYSINIT:10CC skipstack:				     ; ...
SYSINIT:10CC		     push    cs
SYSINIT:10CD		     pop     ds
SYSINIT:10CE		     assume ds:SYSINIT
SYSINIT:10CE		     mov     al, FILES
SYSINIT:10D1		     xor     ah, ah	     ; do not use cbw instruction!
SYSINIT:10D1					     ; it does sign extend.
SYSINIT:10D3		     mov     cx, ax
SYSINIT:10D5		     xor     bx, bx	     ; close standard input
SYSINIT:10D7		     mov     ah, 3Eh
SYSINIT:10D9		     int     21h	     ; DOS - 2+	- CLOSE	A FILE WITH HANDLE
SYSINIT:10D9					     ; BX = file handle
SYSINIT:10DB		     mov     bx, 2	     ; close everybody but standard output
SYSINIT:10DB					     ; need output so we can print message
SYSINIT:10DB					     ;	in case	we can't get new one open.
SYSINIT:10DE
SYSINIT:10DE rcclloop:				     ; ...
SYSINIT:10DE		     mov     ah, 3Eh
SYSINIT:10E0		     int     21h	     ; DOS - 2+	- CLOSE	A FILE WITH HANDLE
SYSINIT:10E0					     ; BX = file handle
SYSINIT:10E2		     inc     bx
SYSINIT:10E3		     loop    rcclloop
SYSINIT:10E5		     mov     dx, offset	condev ; "CON"
SYSINIT:10E8		     mov     al, 2
SYSINIT:10EA		     mov     ah, 3Dh	     ; open con	for read/write
SYSINIT:10EC		     stc		     ; set for possible	int 24
SYSINIT:10ED		     int     21h	     ; DOS - 2+	- OPEN DISK FILE WITH HANDLE
SYSINIT:10ED					     ; DS:DX ->	ASCIZ filename
SYSINIT:10ED					     ; AL = access mode
SYSINIT:10ED					     ; 2 - read	& write
SYSINIT:10EF		     jnb     short goaux
SYSINIT:10F1		     call    badfil
SYSINIT:10F4		     jmp     short goaux2
SYSINIT:10F6 ; ---------------------------------------------------------------------------
SYSINIT:10F6
SYSINIT:10F6 goaux:				     ; ...
SYSINIT:10F6		     push    ax
SYSINIT:10F7		     mov     bx, 1	     ; close standard output
SYSINIT:10FA		     mov     ah, 3Eh
SYSINIT:10FC		     int     21h	     ; DOS - 2+	- CLOSE	A FILE WITH HANDLE
SYSINIT:10FC					     ; BX = file handle
SYSINIT:10FE		     pop     ax
SYSINIT:10FF		     mov     bx, ax	     ; new device handle
SYSINIT:1101		     mov     ah, 45h	     ; XDUP ; dup to 1,	stdout
SYSINIT:1103		     int     21h	     ; DOS - 2+	- CREATE DUPLICATE HANDLE (DUP)
SYSINIT:1103					     ; BX = file handle	to duplicate
SYSINIT:1105		     mov     ah, 45h	     ; XDUP ; dup to 2,	stderr
SYSINIT:1107		     int     21h	     ; DOS - 2+	- CREATE DUPLICATE HANDLE (DUP)
SYSINIT:1107					     ; BX = file handle	to duplicate
SYSINIT:1109
SYSINIT:1109 goaux2:				     ; ...
SYSINIT:1109		     mov     dx, offset	auxdev ; "AUX"
SYSINIT:110C		     mov     al, 2	     ; read/write access
SYSINIT:110E		     call    open_dev
SYSINIT:1111		     mov     dx, offset	prndev ; "PRN"
SYSINIT:1114		     mov     al, 1	     ; write only
SYSINIT:1116		     call    open_dev
SYSINIT:1119		     push    ax
SYSINIT:111A		     push    bx
SYSINIT:111B		     push    dx
SYSINIT:111C		     push    es
SYSINIT:111D		     mov     al, 0FFh	     ; reset h/w by writing to port
SYSINIT:111F		     mov     dx, 2F2h	     ; get starting address
SYSINIT:1122		     out     dx, al	     ; out 02f2h,0ffh
SYSINIT:1123		     inc     dx
SYSINIT:1124		     out     dx, al
SYSINIT:1125		     inc     dx
SYSINIT:1126		     out     dx, al
SYSINIT:1127		     inc     dx
SYSINIT:1128		     out     dx, al
SYSINIT:1129		     inc     dx
SYSINIT:112A		     out     dx, al
SYSINIT:112B		     inc     dx
SYSINIT:112C		     out     dx, al	     ; out 02f7h,0ffh
SYSINIT:112D		     mov     ax, 0F000h	     ; get machine type
SYSINIT:1130		     mov     es, ax
SYSINIT:1132		     assume es:nothing
SYSINIT:1132		     cmp     byte ptr es:0FFFEh, 0FCh ;	is it a	at type	machine
SYSINIT:1138		     jz	     short startrearm ;	*if AT no need to check
SYSINIT:113A		     mov     ah, 0C0h
SYSINIT:113C		     int     15h	     ; SYSTEM -	GET CONFIGURATION
SYSINIT:113C					     ; (XT after 1/10/86,AT mdl	3x9,CONV,XT286,PS)
SYSINIT:113E		     jb	     short finishrearm ; *jmp if old rom
SYSINIT:1140		     test    byte ptr es:[bx+5], 40h ; [es:bx+ROMBIOS_DESC.bios_sd_featurebyte1],
SYSINIT:1140					     ; ScndIntController
SYSINIT:1145		     jz	     short finishrearm
SYSINIT:1147
SYSINIT:1147 startrearm:			     ; ...
SYSINIT:1147		     mov     al, 0FFh	     ; write any pattern to port
SYSINIT:1149		     mov     dx, 6F2h	     ; get starting address
SYSINIT:114C		     out     dx, al
SYSINIT:114D		     inc     dx
SYSINIT:114E		     out     dx, al	     ; out 06f3h,0ffh
SYSINIT:114F		     inc     dx
SYSINIT:1150		     out     dx, al	     ; out 06f4h,0ffh
SYSINIT:1151		     inc     dx
SYSINIT:1152		     inc     dx
SYSINIT:1153		     out     dx, al	     ; out 06f6h,0ffh
SYSINIT:1154		     inc     dx
SYSINIT:1155		     out     dx, al	     ; out 06f7h,0ffh
SYSINIT:1156
SYSINIT:1156 finishrearm:			     ; ...
SYSINIT:1156		     pop     es
SYSINIT:1157		     assume es:nothing
SYSINIT:1157		     pop     dx
SYSINIT:1158		     pop     bx
SYSINIT:1159		     pop     ax
SYSINIT:115A
SYSINIT:115A set_sysinit_base:			     ; sysinit_base will be established
SYSINIT:115A		     push    ax		     ; in the secure area of lower memory
SYSINIT:115A					     ; when it handles the first install= command.
SYSINIT:115A					     ; if sysinit module (in high memory) has been broken,
SYSINIT:115A					     ; then "memory error..." message is displayed
SYSINIT:115A					     ; by sysinit_base
SYSINIT:115B		     mov     ax, memhi
SYSINIT:115E		     sub     ax, area
SYSINIT:1162		     mov     impossible_owner_size, ax
SYSINIT:1165		     mov     al, 'T'
SYSINIT:1167		     call    setdevmark
SYSINIT:116A		     pop     ax
SYSINIT:116B		     mov     di, memhi
SYSINIT:116F		     mov     es, di
SYSINIT:1171		     mov     word ptr sysinit_base_ptr+2, di ; save this entry for the next use.
SYSINIT:1175		     xor     di, di
SYSINIT:1177		     mov     word ptr sysinit_base_ptr,	di ; es:di -> destination.
SYSINIT:117B		     mov     si, offset	sysinit_base ; ds:si ->	source code to be relocated.
SYSINIT:117E		     mov     cx, 129	     ; end_sysinit_base-sysinit_base ; 129
SYSINIT:1181		     add     memlo, cx
SYSINIT:1185		     or	     cs:setdevmarkflag,	2 ; for_devmark
SYSINIT:118B		     call    round
SYSINIT:118E		     rep movsb
SYSINIT:1190		     mov     sysinit_ptr, offset sysinitptr ; returning	address	from
SYSINIT:1190					     ; sysinit_base back to sysinit
SYSINIT:1196		     mov     sysinit_ptr+2, cs
SYSINIT:119A		     or	     install_flag, 2 ; for_devmark
SYSINIT:119F		     call    round
SYSINIT:11A2		     mov     bx, memhi
SYSINIT:11A6		     mov     ax, area
SYSINIT:11A9		     mov     old_area, ax    ; save [area]
SYSINIT:11AC		     mov     es, ax	     ; calc what we needed
SYSINIT:11AE		     sub     bx, ax
SYSINIT:11B0		     mov     ah, 4Ah	     ; SETBLOCK
SYSINIT:11B2		     int     21h	     ; DOS - 2+	- ADJUST MEMORY	BLOCK SIZE (SETBLOCK)
SYSINIT:11B2					     ; ES = segment address of block to	change
SYSINIT:11B2					     ; BX = new	size in	paragraphs
SYSINIT:11B4		     push    es
SYSINIT:11B5		     mov     ax, es
SYSINIT:11B7		     dec     ax
SYSINIT:11B8		     mov     es, ax	     ; point to	arena
SYSINIT:11BA		     assume es:nothing
SYSINIT:11BA		     mov     word ptr es:1, 8 ;	[es:ARENA.OWNER],8 ; set impossible owner
SYSINIT:11C1		     mov     word ptr es:8, 4453h ; [es:ARENA.NAME],'SD' ; System Data
SYSINIT:11C8		     pop     es
SYSINIT:11C9		     assume es:nothing
SYSINIT:11C9		     mov     bx, 0FFFFh
SYSINIT:11CC		     mov     ah, 48h
SYSINIT:11CE		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:11CE					     ; BX = number of 16-byte paragraphs desired
SYSINIT:11D0		     mov     ah, 48h	     ; allocate	the rest of the	memory
SYSINIT:11D2		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:11D2					     ; BX = number of 16-byte paragraphs desired
SYSINIT:11D4		     mov     memhi, ax	     ; start of	the allocated memory
SYSINIT:11D7		     mov     memlo, 0	     ; to be used next.
SYSINIT:11DD		     mov     es, ax
SYSINIT:11DF		     assume es:nothing
SYSINIT:11DF		     mov     bx, CONFBOT
SYSINIT:11E3		     sub     bx, ax	     ; confbot - memhi
SYSINIT:11E5		     dec     bx		     ; make a room for the memory block	id.
SYSINIT:11E6		     dec     bx		     ; make sure!
SYSINIT:11E7		     mov     ah, 4Ah	     ; this will free (confbot to top of memory)
SYSINIT:11E9		     int     21h	     ; DOS - 2+	- ADJUST MEMORY	BLOCK SIZE (SETBLOCK)
SYSINIT:11E9					     ; ES = segment address of block to	change
SYSINIT:11E9					     ; BX = new	size in	paragraphs
SYSINIT:11EB		     mov     bx, 0FFFFh
SYSINIT:11EE		     mov     ah, 48h
SYSINIT:11F0		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:11F0					     ; BX = number of 16-byte paragraphs desired
SYSINIT:11F2		     mov     ah, 48h	     ; allocate	(confbot to top	of memory)
SYSINIT:11F4		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:11F4					     ; BX = number of 16-byte paragraphs desired
SYSINIT:11F6		     mov     area, ax	     ; save allocated memory segment.
SYSINIT:11F6					     ; need this to free this area for command.com.
SYSINIT:11F9		     mov     es, memhi
SYSINIT:11FD		     assume es:nothing
SYSINIT:11FD		     mov     ah, 49h	     ; free allocated memory
SYSINIT:11FD					     ; free (memhi to confbot(=area))
SYSINIT:11FF		     int     21h	     ; DOS - 2+	- FREE MEMORY
SYSINIT:11FF					     ; ES = segment address of area to be freed
SYSINIT:1201		     retn
SYSINIT:1201 endfile	     endp
SYSINIT:1201
SYSINIT:1202
SYSINIT:1202 ; =============== S U B R O U T I N E =======================================
SYSINIT:1202
SYSINIT:1202
SYSINIT:1202 do_install_exec proc near		     ; ...
SYSINIT:1202		     push    si		     ; EXEC a program being loaded via the
SYSINIT:1202					     ; "install=" mechanism in config.sys
SYSINIT:1203		     push    es
SYSINIT:1204		     push    ds
SYSINIT:1205		     pop     es
SYSINIT:1206		     assume es:SYSINIT
SYSINIT:1206		     pop     ds		     ; es->sysinitseg,ds->confbot seg
SYSINIT:1207		     assume ds:nothing
SYSINIT:1207		     mov     dx, si	     ; ds:dx->file name,0 in config.sys	image.
SYSINIT:1209		     xor     cx, cx
SYSINIT:120B		     cld
SYSINIT:120C		     mov     cs:ldexec_start, 20h ; ' ' ; clear out the parm area
SYSINIT:1212		     mov     di, offset	ldexec_parm
SYSINIT:1215
SYSINIT:1215 installfilename:			     ; ...
SYSINIT:1215		     lodsb		     ; skip the	file name
SYSINIT:1215					     ; al = ds:si; si++
SYSINIT:1216		     cmp     al, 0
SYSINIT:1218		     jz	     short got_installparm
SYSINIT:121A		     jmp     short installfilename
SYSINIT:121C ; ---------------------------------------------------------------------------
SYSINIT:121C
SYSINIT:121C got_installparm:			     ; ...
SYSINIT:121C		     lodsb		     ; copy the	parameters to ldexec_parm
SYSINIT:121D		     mov     es:[di], al
SYSINIT:1220		     cmp     al, 0Ah	     ; lf ; line feed?
SYSINIT:1222		     jz	     short done_installparm
SYSINIT:1224		     inc     cl		     ; # of char. in the parm.
SYSINIT:1226		     inc     di
SYSINIT:1227		     jmp     short got_installparm
SYSINIT:1229 ; ---------------------------------------------------------------------------
SYSINIT:1229
SYSINIT:1229 done_installparm:			     ; ...
SYSINIT:1229		     mov     cs:ldexec_line, cl	; length of the	parm.
SYSINIT:122E		     cmp     cl, 0	     ; if no parm,then
SYSINIT:1231		     jnz     short install_seg_set ; let the parm area
SYSINIT:1233		     mov     cs:ldexec_start, 0Dh ; cr ; starts	with cr.
SYSINIT:1239
SYSINIT:1239 install_seg_set:			     ; ...
SYSINIT:1239		     mov     cs:0, 0	     ; make a null environment segment
SYSINIT:1240		     mov     ax, cs	     ; by overlap jmp instruction of sysinitseg.
SYSINIT:1242		     mov     cx, ax
SYSINIT:1244		     cmp     cs:config_envlen, 0
SYSINIT:124A		     jz	     short no_envdata2
SYSINIT:124C		     mov     cx, cs:config_wrkseg
SYSINIT:1251
SYSINIT:1251 no_envdata2:			     ; ...
SYSINIT:1251		     mov     cs:iexec_environ, cx ; [cs:instexe.exec0_environ]
SYSINIT:1251					     ; set the environment seg.
SYSINIT:1256		     mov     cs:iexec_ldexec_line_seg, ax ; [cs:instexe.exec0_com_line+2]
SYSINIT:1256					     ; set the seg.
SYSINIT:125A		     mov     cs:iexec_ldexec_5c_fcb_seg, ax ; [cs:instexe.exec0_5c_fcb+2]
SYSINIT:125E		     mov     cs:iexec_ldexec_6c_fcb_seg, ax ; [cs:instexe.exec0_6c_fcb+2]
SYSINIT:1262		     call    sum_up
SYSINIT:1265		     mov     es:checksum, ax ; save the	value of the sum
SYSINIT:1269		     xor     ax, ax
SYSINIT:126B		     mov     ah, 4Bh	     ; EXEC ; load/exec
SYSINIT:126D		     mov     bx, offset	iexec_environ ;	instexe	; es:bx	-> parm	block.
SYSINIT:1270		     push    es		     ; save es,ds for load/exec
SYSINIT:1271		     push    ds		     ; these registers will be restored	in sysinit_base.
SYSINIT:1272		     jmp     cs:sysinit_base_ptr ; jmp to sysinit_base to execute
SYSINIT:1272 do_install_exec endp		     ; load/exec function and check sum.
SYSINIT:1272
SYSINIT:1277 ; ---------------------------------------------------------------------------
SYSINIT:1277
SYSINIT:1277 sysinitptr:			     ; ...
SYSINIT:1277		     pop     si		     ; returning far address from sysinit_base
SYSINIT:1277					     ; restore si for config.sys file.
SYSINIT:1278		     push    es
SYSINIT:1279		     push    ds
SYSINIT:127A		     pop     es
SYSINIT:127B		     assume es:nothing
SYSINIT:127B		     pop     ds		     ; now ds -	sysinitseg, es - confbot
SYSINIT:127C		     jnb     short install_exit_ret
SYSINIT:127E		     push    si		     ; error in	loading	the file for install=.
SYSINIT:127F		     call    badload	     ; es:si-> path,filename,0.
SYSINIT:1282		     pop     si
SYSINIT:1283
SYSINIT:1283 install_exit_ret:			     ; ...
SYSINIT:1283		     retn
SYSINIT:1284
SYSINIT:1284 ; =============== S U B R O U T I N E =======================================
SYSINIT:1284
SYSINIT:1284
SYSINIT:1284 ParaRound	     proc near		     ; ...
SYSINIT:1284		     add     ax, 15	     ; round up	length in paragraphs
SYSINIT:1284					     ; 0Fh
SYSINIT:1287		     rcr     ax, 1
SYSINIT:1289		     shr     ax, 1
SYSINIT:128B		     shr     ax, 1
SYSINIT:128D		     shr     ax, 1
SYSINIT:128F		     retn
SYSINIT:128F ParaRound	     endp
SYSINIT:128F
SYSINIT:1290 ; ---------------------------------------------------------------------------
SYSINIT:1290
SYSINIT:1290 sysinit_base:			     ; ...
SYSINIT:1290		     mov     word ptr cs:sysinit_base_ss, ss ; sysinit_base module
SYSINIT:1295		     mov     word ptr cs:sysinit_base_sp, sp
SYSINIT:129A		     int     21h	     ; load/exec dos call
SYSINIT:129C		     mov     ss, word ptr cs:sysinit_base_ss
SYSINIT:12A1		     assume ss:nothing
SYSINIT:12A1		     mov     sp, word ptr cs:sysinit_base_sp
SYSINIT:12A6		     pop     ds
SYSINIT:12A7		     pop     es
SYSINIT:12A8		     jb	     short sysinit_base_end
SYSINIT:12AA		     call    sum_up
SYSINIT:12AD		     cmp     es:checksum, ax
SYSINIT:12B2		     jz	     short sysinit_base_end
SYSINIT:12B4		     mov     ah, 9	     ; memory broken.
SYSINIT:12B4					     ; show "memory allocation error" message and stall.
SYSINIT:12B6		     push    cs
SYSINIT:12B7		     pop     ds
SYSINIT:12B8		     assume ds:SYSINIT
SYSINIT:12B8		     mov     dx, 102	     ; mem_alloc_err_msgx-sysinit_base ; 66h
SYSINIT:12BB		     int     21h	     ; DOS - PRINT STRING
SYSINIT:12BB					     ; DS:DX ->	string terminated by "$"
SYSINIT:12BD ; START OF	FUNCTION CHUNK FOR AllocMemForDOS
SYSINIT:12BD
SYSINIT:12BD stall:				     ; ...
SYSINIT:12BD		     hlt		     ; use HLT to minimize energy consumption
SYSINIT:12BD ; END OF FUNCTION CHUNK FOR AllocMemForDOS
SYSINIT:12BE ; ---------------------------------------------------------------------------
SYSINIT:12BE		     jmp     short stall
SYSINIT:12C0 ; ---------------------------------------------------------------------------
SYSINIT:12C0
SYSINIT:12C0 sysinit_base_end:			     ; ...
SYSINIT:12C0		     jmp     dword ptr es:sysinit_ptr ;	return back to sysinit module
SYSINIT:12C5
SYSINIT:12C5 ; =============== S U B R O U T I N E =======================================
SYSINIT:12C5
SYSINIT:12C5
SYSINIT:12C5 sum_up	     proc near		     ; ...
SYSINIT:12C5		     push    ds
SYSINIT:12C6		     mov     ax, es:CONFBOT
SYSINIT:12CA		     mov     ds, ax
SYSINIT:12CC		     assume ds:nothing
SYSINIT:12CC		     xor     si, si
SYSINIT:12CE		     xor     ax, ax
SYSINIT:12D0		     mov     cx, es:config_size	; if config_size has been broken, then this
SYSINIT:12D0					     ; whole test better fail.
SYSINIT:12D5		     shr     cx, 1	     ; make it a word count
SYSINIT:12D7		     jz	     short sum_sys_code	; when config.sys file not exist.
SYSINIT:12D9
SYSINIT:12D9 sum1:				     ; ...
SYSINIT:12D9		     add     ax, [si]
SYSINIT:12DB		     inc     si
SYSINIT:12DC		     inc     si
SYSINIT:12DD		     loop    sum1
SYSINIT:12DF
SYSINIT:12DF sum_sys_code:			     ; ...
SYSINIT:12DF		     mov     si, offset	locstack ; 532h
SYSINIT:12DF					     ; starting	after the stack.
SYSINIT:12DF					     ; this does not cover the possible	stack code!
SYSINIT:12E2		     mov     cx, 58A0h	     ; SI_end (22688)
SYSINIT:12E2					     ; SI_end is the label at the end of sysinit
SYSINIT:12E2					     ; from after_checksum to SI_end
SYSINIT:12E5		     sub     cx, si
SYSINIT:12E7		     shr     cx, 1
SYSINIT:12E9
SYSINIT:12E9 sum2:				     ; ...
SYSINIT:12E9		     add     ax, es:[si]
SYSINIT:12EC		     inc     si
SYSINIT:12ED		     inc     si
SYSINIT:12EE		     loop    sum2
SYSINIT:12F0		     pop     ds
SYSINIT:12F1		     retn
SYSINIT:12F1 sum_up	     endp
SYSINIT:12F1
SYSINIT:12F1 ; ---------------------------------------------------------------------------
SYSINIT:12F2 sysinit_base_ssx dw 0		     ; sysinit_base_ss equ $-sysinit_base ; 62
SYSINIT:12F4 sysinit_base_spx dw 0		     ; sysinit_base_sp equ $-sysinit_base ; 64
SYSINIT:12F6 mem_alloc_err_msgx	db 0Dh,0Ah
SYSINIT:12F6		     db	'Memory allocation error $'
SYSINIT:1311
SYSINIT:1311 ; =============== S U B R O U T I N E =======================================
SYSINIT:1311
SYSINIT:1311
SYSINIT:1311 set_buffer	     proc near		     ; ...
SYSINIT:1311		     xor     dl, dl	     ; input:
SYSINIT:1311					     ;	 ds:bx -> buffinfo.
SYSINIT:1311					     ;	 [memhi]:[memlo=0] = available space for the hash bucket.
SYSINIT:1311					     ;	 singlebuffersize = buff header	size + sector size
SYSINIT:1311					     ; output:
SYSINIT:1311					     ;	 buffers Queue established.
SYSINIT:1311					     ;	 [memhi]:[memlo] = addr	of the next available free space.
SYSINIT:1311					     ;
SYSINIT:1311					     ; assume buffers not in HMA
SYSINIT:1313		     call    GetBufferAddr
SYSINIT:1316		     jz	     short set_buff_1
SYSINIT:1318		     mov     dl, 1	     ; buffers in HMA
SYSINIT:131A
SYSINIT:131A set_buff_1:			     ; ...
SYSINIT:131A		     mov     [bx], di	     ; [bx+BUFFINF.Buff_Queue] ; head of Buff Q
SYSINIT:131C		     mov     word ptr [bx+2], es ; [bx+BUFFINF.Buff_Queue+2]
SYSINIT:131F		     mov     word ptr [bx+4], 0	; [bx+BUFFINF.Dirty_Buff_Count]	; set dirty_count to 0.
SYSINIT:1324		     mov     ax, di
SYSINIT:1326		     mov     cx, cs:buffers
SYSINIT:132B		     push    di		     ; remember	first buffer
SYSINIT:132C
SYSINIT:132C nxt_buff:				     ; ...
SYSINIT:132C		     call    set_buffer_info ; set buf_link,buf_id...
SYSINIT:132F		     mov     di, ax
SYSINIT:1331		     loop    nxt_buff
SYSINIT:1333		     sub     di, cs:singlebuffersize ; point to	last buffer
SYSINIT:1338		     pop     cx		     ; get first buffer
SYSINIT:1339		     mov     es:[di], cx     ; [es:di+buffinfo.buf_next] ; last->next =	first
SYSINIT:133C		     xchg    cx, di
SYSINIT:133E		     mov     es:[di+2],	cx   ; [es:di+buffinfo.buf_prev] ; first->prev = last
SYSINIT:1342		     or	     dl, dl	     ; In HMa ?
SYSINIT:1344		     jz	     short set_buff_2 ;	no
SYSINIT:1346		     mov     byte ptr [bx+0Ch],	1 ; mov	byte [bx+BUFFINF.Buff_In_HMA],1
SYSINIT:134A		     mov     ax, cs:memhi    ; seg of scratch buff
SYSINIT:134E		     mov     word ptr [bx+0Dh],	0 ; [bx+BUFFINF.Lo_Mem_Buff] ; offset of scratch buff is 0
SYSINIT:1353		     mov     [bx+0Fh], ax    ; mov [bx+BUFFINF.Lo_Mem_Buff+2],ax
SYSINIT:1356		     mov     ax, cs:singlebuffersize ; size of scratch buff
SYSINIT:135A		     sub     ax, 20	     ; bufinsiz	; buffer head not required
SYSINIT:135D
SYSINIT:135D set_buff_2:			     ; ...
SYSINIT:135D		     add     cs:memlo, ax
SYSINIT:1362		     or	     cs:setdevmarkflag,	2
SYSINIT:1368		     call    round
SYSINIT:136B		     retn
SYSINIT:136B set_buffer	     endp
SYSINIT:136B
SYSINIT:136C
SYSINIT:136C ; =============== S U B R O U T I N E =======================================
SYSINIT:136C
SYSINIT:136C
SYSINIT:136C GetBufferAddr   proc near		     ; ...
SYSINIT:136C		     push    bx
SYSINIT:136D		     push    dx
SYSINIT:136E		     mov     ax, cs:singlebuffersize
SYSINIT:1372		     mul     cs:buffers
SYSINIT:1377		     add     ax, 0Fh	     ; 15
SYSINIT:137A		     and     ax, 0FFF0h	     ; ~15 ; not 0Fh
SYSINIT:137D		     mov     bx, ax
SYSINIT:137F		     mov     ax, 4A02h	     ; ((multMULT<<8)+multMULTALLOCHMA)
SYSINIT:1382		     int     2Fh	     ; DOS 5+ -	ALLOCATE HMA SPACE
SYSINIT:1382					     ;	   AX =	4A02h
SYSINIT:1382					     ;	   BX =	number of bytes
SYSINIT:1382					     ; Return:
SYSINIT:1382					     ;	   ES:DI -> start of allocated HMA block or FFFFh:FFFFh
SYSINIT:1382					     ;	   BX =	number of bytes	actually allocated (rounded up to next
SYSINIT:1382					     ;		paragraph for DOS 5.0 and 6.0)
SYSINIT:1382					     ; Notes:
SYSINIT:1382					     ;	   this	call is	not valid unless DOS is	loaded in the HMA (DOS=HIGH)
SYSINIT:1382					     ;
SYSINIT:1382					     ;	   called by Windows 3.1 DOSX.EXE
SYSINIT:1382					     ;	   supported by	Novell DOS 7
SYSINIT:1384		     cmp     di, 0FFFFh
SYSINIT:1387		     jnz     short got_hma
SYSINIT:1389		     mov     di, 0	     ; dont xor	di,di Z	flag needed
SYSINIT:138C		     mov     es, cs:memhi
SYSINIT:1391
SYSINIT:1391 got_hma:				     ; ...
SYSINIT:1391		     pop     dx
SYSINIT:1392		     pop     bx
SYSINIT:1393		     retn
SYSINIT:1393 GetBufferAddr   endp
SYSINIT:1393
SYSINIT:1394
SYSINIT:1394 ; =============== S U B R O U T I N E =======================================
SYSINIT:1394
SYSINIT:1394
SYSINIT:1394 set_buffer_info proc near		     ; ...
SYSINIT:1394		     push    cs:buf_prev_off ; es:di ->	buffer header to be set.
SYSINIT:1394					     ; ax = di
SYSINIT:1399		     pop     word ptr es:[di+2]	; [es:di+buffinfo.buf_prev]
SYSINIT:139D		     mov     cs:buf_prev_off, ax
SYSINIT:13A1		     add     ax, cs:singlebuffersize ; adjust ax
SYSINIT:13A6		     mov     es:[di], ax     ; [es:di+buffinfo.buf_next]
SYSINIT:13A9		     mov     word ptr es:[di+4], 0FFh ;	[es:di+buffinfo.buf_ID]
SYSINIT:13A9					     ; new buffer free
SYSINIT:13AF		     mov     word ptr es:[di+6], 0 ; [es:di+buffinfo.buf_sector]
SYSINIT:13B5		     mov     word ptr es:[di+8], 0 ; [es:di+buffinfo.buf_sector+2]
SYSINIT:13BB		     retn
SYSINIT:13BB set_buffer_info endp
SYSINIT:13BB
SYSINIT:13BC
SYSINIT:13BC ; =============== S U B R O U T I N E =======================================
SYSINIT:13BC
SYSINIT:13BC
SYSINIT:13BC stackinit	     proc near		     ; ...
SYSINIT:13BC		     push    ax		     ; ibmstack	initialization routine
SYSINIT:13BC					     ; in - cs,	ds -> sysinitseg,
SYSINIT:13BC					     ;	    es -> relocated stack code & data.
SYSINIT:13BD		     push    ds
SYSINIT:13BE		     push    es
SYSINIT:13BF		     push    bx
SYSINIT:13C0		     push    cx
SYSINIT:13C1		     push    dx
SYSINIT:13C2		     push    di
SYSINIT:13C3		     push    si
SYSINIT:13C4		     push    bp
SYSINIT:13C5		     mov     ax, cs:stack_count
SYSINIT:13C9		     mov     es:stackcount, ax
SYSINIT:13CD		     mov     ax, ds:stack_size
SYSINIT:13D0		     mov     es:stacksize, ax
SYSINIT:13D4		     mov     ax, cs:stack_addr ; offset
SYSINIT:13D8		     mov     es:stacks,	ax
SYSINIT:13DC		     mov     ax, cs:stack_addr+2
SYSINIT:13E0		     mov     es:stacks+2, ax ; segment
SYSINIT:13E4		     mov     bp, es:stacks   ; "firstentry" will always	be at stacks
SYSINIT:13E4					     ; the stacks will always immediately follow the table entries
SYSINIT:13E9		     mov     es:firstentry, bp
SYSINIT:13EE		     mov     ax, 8	     ; entrysize
SYSINIT:13F1		     mov     cx, es:stackcount
SYSINIT:13F6		     mul     cx
SYSINIT:13F8		     add     ax, bp
SYSINIT:13FA		     mov     es:stackat, ax
SYSINIT:13FE		     mov     bx, ax
SYSINIT:1400		     sub     bx, 2
SYSINIT:1403		     mov     di, es:stackat  ; zero the	entire stack area to start with
SYSINIT:1408		     mov     ax, es:stacksize
SYSINIT:140C		     mul     cx
SYSINIT:140E		     mov     cx, ax
SYSINIT:1410		     xor     ax, ax	     ; 0
SYSINIT:1412		     push    es
SYSINIT:1413		     pop     ds		     ; ds = relocated stack code seg.
SYSINIT:1414		     mov     es, ds:stacks+2 ; get segment of stack area.
SYSINIT:1418		     cld
SYSINIT:1419		     rep stosb
SYSINIT:141B		     mov     cx, ds:stackcount ; loop for "count" times, building a table entry
SYSINIT:141B					     ; cs = sysinitseg,	ds = relocated stack code seg,
SYSINIT:141B					     ; es = segment of stack space
SYSINIT:141B					     ; cx = number of entries
SYSINIT:141B					     ; es:bp =>	base of	stacks - 2
SYSINIT:141B					     ; es:bx =>	first table entry
SYSINIT:141F
SYSINIT:141F buildloop:				     ; ...
SYSINIT:141F		     mov     byte ptr es:[bp+0], 0 ; [es:bp+allocbyte],free
SYSINIT:1424		     mov     es:[bp+1],	al   ; [es:bp+intlevel]
SYSINIT:1424					     ; ax = 0
SYSINIT:1428		     mov     es:[bp+2],	ax   ; [es:bp+savedsp]
SYSINIT:142C		     mov     es:[bp+4],	ax   ; [es:bp+savedss]
SYSINIT:1430		     add     bx, ds:stacksize
SYSINIT:1434		     mov     es:[bp+6],	bx   ; [es:bp+newsp]
SYSINIT:1438		     mov     es:[bx], bp
SYSINIT:143B		     add     bp, 8	     ; entrysize
SYSINIT:143E		     loop    buildloop
SYSINIT:1440		     sub     bp, 8	     ; entrysize
SYSINIT:1443		     mov     ds:lastentry, bp
SYSINIT:1447		     mov     ds:nextentry, bp
SYSINIT:144B		     push    ds
SYSINIT:144C		     mov     ax, 0F000h	     ; look at the model byte
SYSINIT:144F		     mov     ds, ax
SYSINIT:1451		     assume ds:nothing
SYSINIT:1451		     cmp     byte ptr ds:0FFFEh, 0F9h ;	mdl_convert ; convertible?
SYSINIT:1456		     pop     ds
SYSINIT:1457		     assume ds:nothing
SYSINIT:1457		     jnz     short skip_disablenmis
SYSINIT:1459		     mov     al, 7	     ; disable convertible nmis
SYSINIT:145B		     out     72h, al	     ; CMOS Memory/RTC Index Register (Extended	RAM)
SYSINIT:145D
SYSINIT:145D skip_disablenmis:			     ; ...
SYSINIT:145D		     xor     ax, ax
SYSINIT:145F		     mov     es, ax
SYSINIT:1461		     assume es:nothing
SYSINIT:1461		     cli
SYSINIT:1462
SYSINIT:1462 stkinit_02:			     ; Int 02h vector table offset
SYSINIT:1462		     mov     si, 8
SYSINIT:1465		     mov     di, offset	int19old02
SYSINIT:1468		     mov     bx, offset	old02
SYSINIT:146B		     mov     dx, offset	int02
SYSINIT:146E		     call    new_init_loop
SYSINIT:1471
SYSINIT:1471 stkinit_08:			     ; Int 08h vector table offset
SYSINIT:1471		     mov     si, 20h
SYSINIT:1474		     mov     di, offset	int19old08
SYSINIT:1477		     mov     bx, offset	old08
SYSINIT:147A		     mov     dx, offset	int08
SYSINIT:147D		     call    new_init_loop
SYSINIT:1480
SYSINIT:1480 stkinit_09:			     ; Int 09h vector table offset
SYSINIT:1480		     mov     si, 24h
SYSINIT:1483		     mov     di, offset	int19old09
SYSINIT:1486		     mov     bx, offset	old09
SYSINIT:1489		     mov     dx, offset	int09
SYSINIT:148C		     call    new_init_loop
SYSINIT:148F
SYSINIT:148F stkinit_70:			     ; Int 70h vector table offset
SYSINIT:148F		     mov     si, 1C0h
SYSINIT:1492		     mov     di, offset	int19old70
SYSINIT:1495		     mov     bx, offset	old70
SYSINIT:1498		     mov     dx, offset	int70
SYSINIT:149B		     call    new_init_loop
SYSINIT:149E
SYSINIT:149E stkinit_0A:			     ; 0Ah*4 ; 40
SYSINIT:149E		     mov     si, 28h	     ; Int 0Ah vector table offset
SYSINIT:14A1		     push    ds		     ; save relocated stack code segment
SYSINIT:14A2		     lds     bx, es:[si]     ; ds:bx ->	original interrupt handler
SYSINIT:14A5		     push    ds
SYSINIT:14A6		     pop     dx		     ; dx = segment value
SYSINIT:14A7		     cmp     dx, 0
SYSINIT:14AA		     jz	     short int_0A_first
SYSINIT:14AC		     cmp     byte ptr [bx], 0CFh ; does	vector point to	an iret?
SYSINIT:14AF		     jz	     short int_0A_first
SYSINIT:14B1		     cmp     word ptr [bx+6], 424Bh ; magic offset (see	int&aa,	msstack.inc)
SYSINIT:14B6		     jz	     short int_0A_not_first
SYSINIT:14B8		     cmp     dx, 0F000h	     ; rom bios	segment
SYSINIT:14BC		     jnz     short int_0A_not_first
SYSINIT:14BE		     push    es
SYSINIT:14BF		     push    dx
SYSINIT:14C0		     mov     dx, 0F000h
SYSINIT:14C3		     mov     es, dx
SYSINIT:14C5		     assume es:nothing
SYSINIT:14C5		     cmp     bx, es:0FF01h
SYSINIT:14CA		     pop     dx
SYSINIT:14CB		     pop     es
SYSINIT:14CC		     assume es:nothing
SYSINIT:14CC		     jz	     short int_0A_first
SYSINIT:14CE
SYSINIT:14CE int_0A_not_first:			     ; ...
SYSINIT:14CE		     pop     ds		     ; not the first. we are going to hook vector.
SYSINIT:14CF		     mov     di, offset	int19old0A ; we	have to	set old&aa for int19 handler too.
SYSINIT:14D2		     mov     bx, offset	old0A ;	pass where to save original owner pointer
SYSINIT:14D5		     mov     dx, offset	int0A ;	pass where new handler is
SYSINIT:14D8		     call    new_init_loop   ; adjust the vector to new	handler,
SYSINIT:14D8					     ; saving pointer to original owner.
SYSINIT:14DB		     jmp     short stkinit_0B
SYSINIT:14DD ; ---------------------------------------------------------------------------
SYSINIT:14DD
SYSINIT:14DD int_0A_first:			     ; ...
SYSINIT:14DD		     pop     ds		     ; the first. don't have to hook stack code.
SYSINIT:14DE
SYSINIT:14DE stkinit_0B:			     ; ...
SYSINIT:14DE		     mov     si, 2Ch	     ; Int 0Bh vector table offset
SYSINIT:14E1		     push    ds
SYSINIT:14E2		     lds     bx, es:[si]
SYSINIT:14E5		     push    ds
SYSINIT:14E6		     pop     dx
SYSINIT:14E7		     cmp     dx, 0
SYSINIT:14EA		     jz	     short int_0B_first
SYSINIT:14EC		     cmp     byte ptr [bx], 0CFh
SYSINIT:14EF		     jz	     short int_0B_first
SYSINIT:14F1		     cmp     word ptr [bx+6], 424Bh
SYSINIT:14F6		     jz	     short int_0B_not_first
SYSINIT:14F8		     cmp     dx, 0F000h
SYSINIT:14FC		     jnz     short int_0B_not_first
SYSINIT:14FE		     push    es
SYSINIT:14FF		     push    dx
SYSINIT:1500		     mov     dx, 0F000h
SYSINIT:1503		     mov     es, dx
SYSINIT:1505		     assume es:nothing
SYSINIT:1505		     cmp     bx, es:0FF01h
SYSINIT:150A		     pop     dx
SYSINIT:150B		     pop     es
SYSINIT:150C		     assume es:nothing
SYSINIT:150C		     jz	     short int_0B_first
SYSINIT:150E
SYSINIT:150E int_0B_not_first:			     ; ...
SYSINIT:150E		     pop     ds
SYSINIT:150F		     mov     di, offset	int19old0B
SYSINIT:1512		     mov     bx, offset	old0B
SYSINIT:1515		     mov     dx, offset	int0B
SYSINIT:1518		     call    new_init_loop
SYSINIT:151B		     jmp     short stkinit_0C
SYSINIT:151D ; ---------------------------------------------------------------------------
SYSINIT:151D
SYSINIT:151D int_0B_first:			     ; ...
SYSINIT:151D		     pop     ds
SYSINIT:151E
SYSINIT:151E stkinit_0C:			     ; ...
SYSINIT:151E		     mov     si, 30h	     ; Int 0Ch vector table offset
SYSINIT:1521		     push    ds
SYSINIT:1522		     lds     bx, es:[si]
SYSINIT:1525		     push    ds
SYSINIT:1526		     pop     dx
SYSINIT:1527		     cmp     dx, 0
SYSINIT:152A		     jz	     short int_0C_first
SYSINIT:152C		     cmp     byte ptr [bx], 0CFh
SYSINIT:152F		     jz	     short int_0C_first
SYSINIT:1531		     cmp     word ptr [bx+6], 424Bh
SYSINIT:1536		     jz	     short int_0C_not_first
SYSINIT:1538		     cmp     dx, 0F000h
SYSINIT:153C		     jnz     short int_0C_not_first
SYSINIT:153E		     push    es
SYSINIT:153F		     push    dx
SYSINIT:1540		     mov     dx, 0F000h
SYSINIT:1543		     mov     es, dx
SYSINIT:1545		     assume es:nothing
SYSINIT:1545		     cmp     bx, es:0FF01h
SYSINIT:154A		     pop     dx
SYSINIT:154B		     pop     es
SYSINIT:154C		     assume es:nothing
SYSINIT:154C		     jz	     short int_0C_first
SYSINIT:154E
SYSINIT:154E int_0C_not_first:			     ; ...
SYSINIT:154E		     pop     ds
SYSINIT:154F		     mov     di, offset	int19old0C
SYSINIT:1552		     mov     bx, offset	old0C
SYSINIT:1555		     mov     dx, offset	int0C
SYSINIT:1558		     call    new_init_loop
SYSINIT:155B		     jmp     short stkinit_0D
SYSINIT:155D ; ---------------------------------------------------------------------------
SYSINIT:155D
SYSINIT:155D int_0C_first:			     ; ...
SYSINIT:155D		     pop     ds
SYSINIT:155E
SYSINIT:155E stkinit_0D:			     ; ...
SYSINIT:155E		     mov     si, 34h	     ; Int 0Dh vector table offset
SYSINIT:1561		     push    ds
SYSINIT:1562		     lds     bx, es:[si]
SYSINIT:1565		     push    ds
SYSINIT:1566		     pop     dx
SYSINIT:1567		     cmp     dx, 0
SYSINIT:156A		     jz	     short int_0D_first
SYSINIT:156C		     cmp     byte ptr [bx], 0CFh
SYSINIT:156F		     jz	     short int_0D_first
SYSINIT:1571		     cmp     word ptr [bx+6], 424Bh
SYSINIT:1576		     jz	     short int_0D_not_first
SYSINIT:1578		     cmp     dx, 0F000h
SYSINIT:157C		     jnz     short int_0D_not_first
SYSINIT:157E		     push    es
SYSINIT:157F		     push    dx
SYSINIT:1580		     mov     dx, 0F000h
SYSINIT:1583		     mov     es, dx
SYSINIT:1585		     assume es:nothing
SYSINIT:1585		     cmp     bx, es:0FF01h
SYSINIT:158A		     pop     dx
SYSINIT:158B		     pop     es
SYSINIT:158C		     assume es:nothing
SYSINIT:158C		     jz	     short int_0D_first
SYSINIT:158E
SYSINIT:158E int_0D_not_first:			     ; ...
SYSINIT:158E		     pop     ds
SYSINIT:158F		     mov     di, offset	int19old0D
SYSINIT:1592		     mov     bx, offset	old0D
SYSINIT:1595		     mov     dx, offset	int0D
SYSINIT:1598		     call    new_init_loop
SYSINIT:159B		     jmp     short stkinit_0E
SYSINIT:159D ; ---------------------------------------------------------------------------
SYSINIT:159D
SYSINIT:159D int_0D_first:			     ; ...
SYSINIT:159D		     pop     ds
SYSINIT:159E
SYSINIT:159E stkinit_0E:			     ; ...
SYSINIT:159E		     mov     si, 38h	     ; 0Eh*4 ; Int 0Eh vector table offset
SYSINIT:15A1		     push    ds
SYSINIT:15A2		     lds     bx, es:[si]
SYSINIT:15A5		     push    ds
SYSINIT:15A6		     pop     dx
SYSINIT:15A7		     cmp     dx, 0
SYSINIT:15AA		     jz	     short int_0E_first
SYSINIT:15AC		     cmp     byte ptr [bx], 0CFh
SYSINIT:15AF		     jz	     short int_0E_first
SYSINIT:15B1		     cmp     word ptr [bx+6], 424Bh
SYSINIT:15B6		     jz	     short int_0E_not_first
SYSINIT:15B8		     cmp     dx, 0F000h
SYSINIT:15BC		     jnz     short int_0E_not_first
SYSINIT:15BE		     push    es
SYSINIT:15BF		     push    dx
SYSINIT:15C0		     mov     dx, 0F000h
SYSINIT:15C3		     mov     es, dx
SYSINIT:15C5		     assume es:nothing
SYSINIT:15C5		     cmp     bx, es:0FF01h
SYSINIT:15CA		     pop     dx
SYSINIT:15CB		     pop     es
SYSINIT:15CC		     assume es:nothing
SYSINIT:15CC		     jz	     short int_0E_first
SYSINIT:15CE
SYSINIT:15CE int_0E_not_first:			     ; ...
SYSINIT:15CE		     pop     ds
SYSINIT:15CF		     mov     di, offset	int19old0E
SYSINIT:15D2		     mov     bx, offset	old0E
SYSINIT:15D5		     mov     dx, offset	int0Eh
SYSINIT:15D8		     call    new_init_loop
SYSINIT:15DB		     jmp     short stkinit_72
SYSINIT:15DD ; ---------------------------------------------------------------------------
SYSINIT:15DD
SYSINIT:15DD int_0E_first:			     ; ...
SYSINIT:15DD		     pop     ds
SYSINIT:15DE
SYSINIT:15DE stkinit_72:			     ; ...
SYSINIT:15DE		     mov     si, 1C8h	     ; 72h*4 ; 456
SYSINIT:15DE					     ; Int 72h vector table offset
SYSINIT:15E1		     push    ds
SYSINIT:15E2		     lds     bx, es:[si]
SYSINIT:15E5		     push    ds
SYSINIT:15E6		     pop     dx
SYSINIT:15E7		     cmp     dx, 0
SYSINIT:15EA		     jz	     short int_72_first
SYSINIT:15EC		     cmp     byte ptr [bx], 0CFh
SYSINIT:15EF		     jz	     short int_72_first
SYSINIT:15F1		     cmp     word ptr [bx+6], 424Bh
SYSINIT:15F6		     jz	     short int_72_not_first
SYSINIT:15F8		     cmp     dx, 0F000h
SYSINIT:15FC		     jnz     short int_72_not_first
SYSINIT:15FE		     push    es
SYSINIT:15FF		     push    dx
SYSINIT:1600		     mov     dx, 0F000h
SYSINIT:1603		     mov     es, dx
SYSINIT:1605		     assume es:nothing
SYSINIT:1605		     cmp     bx, es:0FF01h
SYSINIT:160A		     pop     dx
SYSINIT:160B		     pop     es
SYSINIT:160C		     assume es:nothing
SYSINIT:160C		     jz	     short int_72_first
SYSINIT:160E
SYSINIT:160E int_72_not_first:			     ; ...
SYSINIT:160E		     pop     ds
SYSINIT:160F		     mov     di, offset	int19old72
SYSINIT:1612		     mov     bx, offset	old72
SYSINIT:1615		     mov     dx, offset	int72
SYSINIT:1618		     call    new_init_loop
SYSINIT:161B		     jmp     short stkinit_73
SYSINIT:161D ; ---------------------------------------------------------------------------
SYSINIT:161D
SYSINIT:161D int_72_first:			     ; ...
SYSINIT:161D		     pop     ds
SYSINIT:161E
SYSINIT:161E stkinit_73:			     ; ...
SYSINIT:161E		     mov     si, 1CCh	     ; 73h*4 ; 460
SYSINIT:1621		     push    ds
SYSINIT:1622		     lds     bx, es:[si]
SYSINIT:1625		     push    ds
SYSINIT:1626		     pop     dx
SYSINIT:1627		     cmp     dx, 0
SYSINIT:162A		     jz	     short int_73_first
SYSINIT:162C		     cmp     byte ptr [bx], 0CFh
SYSINIT:162F		     jz	     short int_73_first
SYSINIT:1631		     cmp     word ptr [bx+6], 424Bh
SYSINIT:1636		     jz	     short int_73_not_first
SYSINIT:1638		     cmp     dx, 0F000h
SYSINIT:163C		     jnz     short int_73_not_first
SYSINIT:163E		     push    es
SYSINIT:163F		     push    dx
SYSINIT:1640		     mov     dx, 0F000h
SYSINIT:1643		     mov     es, dx
SYSINIT:1645		     assume es:nothing
SYSINIT:1645		     cmp     bx, es:0FF01h
SYSINIT:164A		     pop     dx
SYSINIT:164B		     pop     es
SYSINIT:164C		     assume es:nothing
SYSINIT:164C		     jz	     short int_73_first
SYSINIT:164E
SYSINIT:164E int_73_not_first:			     ; ...
SYSINIT:164E		     pop     ds
SYSINIT:164F		     mov     di, offset	int19old73
SYSINIT:1652		     mov     bx, offset	old73
SYSINIT:1655		     mov     dx, offset	int73
SYSINIT:1658		     call    new_init_loop
SYSINIT:165B		     jmp     short stkinit_74
SYSINIT:165D ; ---------------------------------------------------------------------------
SYSINIT:165D
SYSINIT:165D int_73_first:			     ; ...
SYSINIT:165D		     pop     ds
SYSINIT:165E
SYSINIT:165E stkinit_74:			     ; ...
SYSINIT:165E		     mov     si, 1D0h	     ; 74h*4 ; 464
SYSINIT:1661		     push    ds
SYSINIT:1662		     lds     bx, es:[si]
SYSINIT:1665		     push    ds
SYSINIT:1666		     pop     dx
SYSINIT:1667		     cmp     dx, 0
SYSINIT:166A		     jz	     short int_74_first
SYSINIT:166C		     cmp     byte ptr [bx], 0CFh
SYSINIT:166F		     jz	     short int_74_first
SYSINIT:1671		     cmp     word ptr [bx+6], 424Bh
SYSINIT:1676		     jz	     short int_74_not_first
SYSINIT:1678		     cmp     dx, 0F000h
SYSINIT:167C		     jnz     short int_74_not_first
SYSINIT:167E		     push    es
SYSINIT:167F		     push    dx
SYSINIT:1680		     mov     dx, 0F000h
SYSINIT:1683		     mov     es, dx
SYSINIT:1685		     assume es:nothing
SYSINIT:1685		     cmp     bx, es:0FF01h
SYSINIT:168A		     pop     dx
SYSINIT:168B		     pop     es
SYSINIT:168C		     assume es:nothing
SYSINIT:168C		     jz	     short int_74_first
SYSINIT:168E
SYSINIT:168E int_74_not_first:			     ; ...
SYSINIT:168E		     pop     ds
SYSINIT:168F		     mov     di, offset	int19old74
SYSINIT:1692		     mov     bx, offset	old74
SYSINIT:1695		     mov     dx, offset	int74
SYSINIT:1698		     call    new_init_loop
SYSINIT:169B		     jmp     short stkinit_76
SYSINIT:169D ; ---------------------------------------------------------------------------
SYSINIT:169D
SYSINIT:169D int_74_first:			     ; ...
SYSINIT:169D		     pop     ds
SYSINIT:169E
SYSINIT:169E stkinit_76:			     ; ...
SYSINIT:169E		     mov     si, 1D8h	     ; 76h*4 ; 472
SYSINIT:16A1		     push    ds
SYSINIT:16A2		     lds     bx, es:[si]
SYSINIT:16A5		     push    ds
SYSINIT:16A6		     pop     dx
SYSINIT:16A7		     cmp     dx, 0
SYSINIT:16AA		     jz	     short int_76_first
SYSINIT:16AC		     cmp     byte ptr [bx], 0CFh
SYSINIT:16AF		     jz	     short int_76_first
SYSINIT:16B1		     cmp     word ptr [bx+6], 424Bh
SYSINIT:16B6		     jz	     short int_76_not_first
SYSINIT:16B8		     cmp     dx, 0F000h
SYSINIT:16BC		     jnz     short int_76_not_first
SYSINIT:16BE		     push    es
SYSINIT:16BF		     push    dx
SYSINIT:16C0		     mov     dx, 0F000h
SYSINIT:16C3		     mov     es, dx
SYSINIT:16C5		     assume es:nothing
SYSINIT:16C5		     cmp     bx, es:0FF01h
SYSINIT:16CA		     pop     dx
SYSINIT:16CB		     pop     es
SYSINIT:16CC		     assume es:nothing
SYSINIT:16CC		     jz	     short int_76_first
SYSINIT:16CE
SYSINIT:16CE int_76_not_first:			     ; ...
SYSINIT:16CE		     pop     ds
SYSINIT:16CF		     mov     di, offset	int19old76
SYSINIT:16D2		     mov     bx, offset	old76
SYSINIT:16D5		     mov     dx, offset	int76
SYSINIT:16D8		     call    new_init_loop
SYSINIT:16DB		     jmp     short stkinit_77
SYSINIT:16DD ; ---------------------------------------------------------------------------
SYSINIT:16DD
SYSINIT:16DD int_76_first:			     ; ...
SYSINIT:16DD		     pop     ds
SYSINIT:16DE
SYSINIT:16DE stkinit_77:			     ; ...
SYSINIT:16DE		     mov     si, 1DCh	     ; mov si,77h*4 ; 476
SYSINIT:16DE					     ; Int 77h vector table offset
SYSINIT:16E1		     push    ds		     ; save relocated stack code segment
SYSINIT:16E2		     lds     bx, es:[si]     ; ds:bx ->	original interrupt handler
SYSINIT:16E5		     push    ds
SYSINIT:16E6		     pop     dx		     ; dx = segment value
SYSINIT:16E7		     cmp     dx, 0
SYSINIT:16EA		     jz	     short int_77_first
SYSINIT:16EC		     cmp     byte ptr [bx], 0CFh ; does	vector point to	an iret?
SYSINIT:16EF		     jz	     short int_77_first
SYSINIT:16F1		     cmp     word ptr [bx+6], 424Bh ; magic offset (see	int&aa,	msstack.inc)
SYSINIT:16F6		     jz	     short int_77_not_first
SYSINIT:16F8		     cmp     dx, 0F000h	     ; rom bios	segment
SYSINIT:16FC		     jnz     short int_77_not_first
SYSINIT:16FE		     push    es
SYSINIT:16FF		     push    dx
SYSINIT:1700		     mov     dx, 0F000h
SYSINIT:1703		     mov     es, dx
SYSINIT:1705		     assume es:nothing
SYSINIT:1705		     cmp     bx, es:0FF01h
SYSINIT:170A		     pop     dx
SYSINIT:170B		     pop     es
SYSINIT:170C		     assume es:nothing
SYSINIT:170C		     jz	     short int_77_first
SYSINIT:170E
SYSINIT:170E int_77_not_first:			     ; ...
SYSINIT:170E		     pop     ds		     ; not the first. we are going to hook vector.
SYSINIT:170F		     mov     di, offset	int19old77 ; we	have to	set old&aa for int19 handler too.
SYSINIT:1712		     mov     bx, offset	old77 ;	pass where to save original owner pointer
SYSINIT:1715		     mov     dx, offset	int77 ;	pass where new handler is
SYSINIT:1718		     call    new_init_loop   ; adjust the vector to new	handler,
SYSINIT:1718					     ; saving pointer to original owner.
SYSINIT:171B		     jmp     short int_77_end
SYSINIT:171D ; ---------------------------------------------------------------------------
SYSINIT:171D
SYSINIT:171D int_77_first:			     ; ...
SYSINIT:171D		     pop     ds		     ; the first. don't have to hook stack code.
SYSINIT:171E
SYSINIT:171E int_77_end:			     ; ...
SYSINIT:171E		     push    ds
SYSINIT:171F		     mov     ax, 0F000h
SYSINIT:1722		     mov     ds, ax
SYSINIT:1724		     assume ds:nothing
SYSINIT:1724		     cmp     byte ptr ds:0FFFEh, 0F9h ;	mdl_convert ; pc convertible?
SYSINIT:1729		     pop     ds
SYSINIT:172A		     assume ds:nothing
SYSINIT:172A		     jnz     short skip_enablenmis
SYSINIT:172C		     mov     al, 27h	     ; enable convertible nmis
SYSINIT:172E		     out     72h, al	     ; CMOS Memory/RTC Index Register (Extended	RAM)
SYSINIT:1730
SYSINIT:1730 skip_enablenmis:			     ; ...
SYSINIT:1730		     sti
SYSINIT:1731		     mov     ax, 70h	     ; DOSBIODATASEG
SYSINIT:1734		     mov     ds, ax
SYSINIT:1736		     assume ds:nothing
SYSINIT:1736		     mov     ds:int19sem, 1  ; indicate	that int 19h
SYSINIT:1736					     ; initialization is complete
SYSINIT:173B		     pop     bp
SYSINIT:173C		     pop     si
SYSINIT:173D		     pop     di
SYSINIT:173E		     pop     dx
SYSINIT:173F		     pop     cx
SYSINIT:1740		     pop     bx
SYSINIT:1741		     pop     es
SYSINIT:1742		     pop     ds
SYSINIT:1743		     assume ds:nothing
SYSINIT:1743		     pop     ax
SYSINIT:1744		     retn
SYSINIT:1744 stackinit	     endp
SYSINIT:1744
SYSINIT:1745
SYSINIT:1745 ; =============== S U B R O U T I N E =======================================
SYSINIT:1745
SYSINIT:1745
SYSINIT:1745 new_init_loop   proc near		     ; ...
SYSINIT:1745		     mov     ax, es:[si]     ; new stack initialization
SYSINIT:1745					     ; (dx = new handler offset,
SYSINIT:1745					     ;	bx = original handler saving addr,
SYSINIT:1745					     ;	si = int vector	table offset
SYSINIT:1745					     ;	di = int19old??	field offset
SYSINIT:1745					     ;		       -in DOSBIOSDATASEG-
SYSINIT:1745					     ;	es = zero, segid of vector table
SYSINIT:1745					     ;	ds = relocated stack code segment)
SYSINIT:1748		     mov     [bx], ax
SYSINIT:174A		     mov     ax, es:[si+2]
SYSINIT:174E		     mov     [bx+2], ax
SYSINIT:1751		     push    ds
SYSINIT:1752		     mov     ax, 70h	     ; DOSBIODATASEG
SYSINIT:1755		     mov     ds, ax
SYSINIT:1757		     assume ds:nothing
SYSINIT:1757		     mov     ax, es:[si]
SYSINIT:175A		     mov     [di], ax
SYSINIT:175C		     mov     ax, es:[si+2]
SYSINIT:1760		     mov     [di+2], ax
SYSINIT:1763		     pop     ds
SYSINIT:1764		     assume ds:nothing
SYSINIT:1764		     mov     es:[si], dx
SYSINIT:1767		     mov     word ptr es:[si+2], ds
SYSINIT:176B		     retn
SYSINIT:176B new_init_loop   endp
SYSINIT:176B
SYSINIT:176C
SYSINIT:176C ; =============== S U B R O U T I N E =======================================
SYSINIT:176C
SYSINIT:176C
SYSINIT:176C setdevmark	     proc near		     ; ...
SYSINIT:176C		     push    es		     ; set the devmark for mem command.
SYSINIT:176C					     ; in:
SYSINIT:176C					     ;	 [memhi] - the address to place	devmark
SYSINIT:176C					     ;	 [memlo] = 0
SYSINIT:176C					     ;	 al = id for devmark_id
SYSINIT:176C					     ; out:
SYSINIT:176C					     ;	 devmark established.
SYSINIT:176C					     ;	 the address saved in cs:[devmark_addr]
SYSINIT:176C					     ;	 [memhi] increase by 1.
SYSINIT:176D		     push    cx
SYSINIT:176E		     mov     cx, cs:memhi
SYSINIT:1773		     mov     cs:devmark_addr, cx
SYSINIT:1778		     mov     es, cx
SYSINIT:177A		     mov     es:0, al
SYSINIT:177E		     inc     cx
SYSINIT:177F		     mov     es:1, cx
SYSINIT:1784		     pop     cx
SYSINIT:1785		     pop     es
SYSINIT:1786		     inc     cs:memhi
SYSINIT:178B		     retn
SYSINIT:178B setdevmark	     endp
SYSINIT:178B
SYSINIT:178B ; ---------------------------------------------------------------------------
SYSINIT:178C config_envlen   dw	0		     ; ...
SYSINIT:178C					     ; when config_wrkseg is being used	as
SYSINIT:178C					     ; a scratch env, this is its length
SYSINIT:178E config_wrkseg   dw	0		     ; ...
SYSINIT:178E					     ; config work area	(above confbot)
SYSINIT:178E					     ; segment of work area
SYSINIT:1790 config_cmd	     db	0		     ; ...
SYSINIT:1790					     ; current config cmd
SYSINIT:1790					     ; (with CONFIG_OPTION_QUERY bit intact)
SYSINIT:1791 config_multi    db	0		     ; ...
SYSINIT:1791					     ; non-zero	if multi-config	config.sys
SYSINIT:1792 multdeviceflag  db	0		     ; ...
SYSINIT:1793 devmark_addr    dw	0		     ; ...
SYSINIT:1793					     ; segment address for devmark.
SYSINIT:1795 setdevmarkflag  db	0		     ; ...
SYSINIT:1795					     ; flag used for devmark
SYSINIT:1796 driver_units    db	0		     ; ...
SYSINIT:1796					     ; total unitcount for driver
SYSINIT:1797 ems_stub_installed	db 0		     ; (not used)
SYSINIT:1798 badparm_ptr     dd	0		     ; ...
SYSINIT:1798					     ; badparm_off equ badparm_ptr
SYSINIT:1798					     ; badparm_seg equ badparm_ptr+2
SYSINIT:179C _$P_ORDINAL     dw	0		     ; ...
SYSINIT:179C					     ; Operand ordinal save area
SYSINIT:179E _$P_RC	     dw	0		     ; ...
SYSINIT:179E					     ; Return code from	parser
SYSINIT:17A0 _$P_SI_Save     dw	0		     ; ...
SYSINIT:17A0					     ; Pointer of command buffer
SYSINIT:17A2 _$P_DX	     dw	0		     ; ...
SYSINIT:17A2					     ; Return result buffer address
SYSINIT:17A4 _$P_Terminator  db	0		     ; ...
SYSINIT:17A4					     ; Terminator code (ASCII)
SYSINIT:17A5 _$P_DBCSEV_OFF  dw	0		     ; ...
SYSINIT:17A5					     ; Offset of DBCS EV
SYSINIT:17A7 _$P_DBCSEV_SEG  dw	0		     ; ...
SYSINIT:17A7					     ; Segment of DBCS EV
SYSINIT:17A9 _$P_Flags	     db	0		     ; ...
SYSINIT:17A9					     ; Parser internal flags
SYSINIT:17A9					     ; %define _$P_Flags1 _$P_Flags
SYSINIT:17A9					     ;	       to reference 1st	byte flags
SYSINIT:17A9					     ; %define _$P_Flags2 _$P_Flags+1
SYSINIT:17A9					     ;	       to reference 2nd	byte flags only
SYSINIT:17AA _$P_Flags2	     db	0		     ; ...
SYSINIT:17AB _$P_SaveSI_Cmpx dw	0		     ; ...
SYSINIT:17AB					     ; save si for later use by	complex
SYSINIT:17AD _$P_KEYorSW_Ptr dw	0		     ; ...
SYSINIT:17AD					     ; points next to "=" or ":" code
SYSINIT:17AF _$P_Save_EOB    dw	0		     ; ...
SYSINIT:17AF					     ; save pointer to EOB
SYSINIT:17B1 _$P_Found_SYNONYM dw 0		     ; ...
SYSINIT:17B1					     ; es:@ points to found synonym
SYSINIT:17B3 _$P_STRING_BUF  db	128 dup(0)	     ; ...
SYSINIT:17B3					     ; Pick a operand from command line
SYSINIT:1833 _$P_Char_CAP_Ptr db 0FFh		     ; ...
SYSINIT:1833					     ; info id
SYSINIT:1834		     dw	0		     ; offset of char case map table
SYSINIT:1836		     dw	0		     ; segment of char case map	table
SYSINIT:1838 _$P_FileSp_Char db	'[]|<>+=;"'          ; ...
SYSINIT:1838					     ; delimitters of file spec
SYSINIT:1838					     ; _$P_FileSp_Len equ $-_$P_FileSp_Char
SYSINIT:1841 _$P_err_flag    db	0		     ; ...
SYSINIT:1841					     ; flag set	if filespec parsing error
SYSINIT:1841					     ; was detected
SYSINIT:1842
SYSINIT:1842 ; =============== S U B R O U T I N E =======================================
SYSINIT:1842
SYSINIT:1842
SYSINIT:1842 SysParse	     proc near		     ; ...
SYSINIT:1842		     mov     word ptr cs:_$P_Flags, 0 ;	Clear all internal flags
SYSINIT:1849		     cld		     ; confirm forward direction
SYSINIT:184A		     mov     cs:_$P_ORDINAL, cx	; save operand ordinal
SYSINIT:184F		     mov     cs:_$P_RC,	0    ; _$P_No_Error ; assume no	error
SYSINIT:1856		     mov     cs:_$P_Found_SYNONYM, 0 ; initalize synonym pointer
SYSINIT:185D		     mov     cs:_$P_DX,	0    ; The table of special chars _$P_FileSp_Char
SYSINIT:185D					     ; should be initialized on	every entry to SysParse
SYSINIT:1864		     mov     word ptr cs:_$P_FileSp_Char, 5D5Bh	; "[]|<>+=;\""
SYSINIT:186B		     mov     word ptr cs:_$P_FileSp_Char+2, 3C7Ch
SYSINIT:1872		     mov     word ptr cs:_$P_FileSp_Char+4, 2B3Eh
SYSINIT:1879		     mov     word ptr cs:_$P_FileSp_Char+6, 3B3Dh
SYSINIT:1880		     call    _$P_Skip_Delim  ; Move si to 1st non white	space
SYSINIT:1883		     jnb     short _$P_Start ; If EOL is not encountered, do parse
SYSINIT:1885		     mov     ax, 0FFFFh	     ; _$P_RC_EOL  ; set exit code to -1
SYSINIT:1888		     push    bx
SYSINIT:1889		     mov     bx, es:[di]     ; [es:di+_$P_PARMS_Blk.PARMSX_Address]
SYSINIT:1889					     ; Get the PARMSX address to
SYSINIT:188C		     cmp     cl, es:[bx]     ; [es:bx+_$P_PARMSX_Blk.MinP]
SYSINIT:188C					     ; check ORDINAL to	see if the minimum
SYSINIT:188F		     jnb     short _$P_Fin   ; positional found.
SYSINIT:1891		     mov     ax, 2	     ; $P_Op_Missing ; If no, set exit code to missing operand
SYSINIT:1894
SYSINIT:1894 _$P_Fin:				     ; ...
SYSINIT:1894		     pop     bx
SYSINIT:1895		     jmp     _$P_Single_Exit ; return to the caller
SYSINIT:1898 ; ---------------------------------------------------------------------------
SYSINIT:1898
SYSINIT:1898 _$P_Start:				     ; ...
SYSINIT:1898		     mov     cs:_$P_SaveSI_Cmpx, si ; save ptr to command line for later use
SYSINIT:1898					     ; by complex quoted string	or file	spec.
SYSINIT:189D		     push    bx
SYSINIT:189E		     push    di
SYSINIT:189F		     push    bp
SYSINIT:18A0		     lea     bx, _$P_STRING_BUF	; set buffer to	copy from command string
SYSINIT:18A4		     test    cs:_$P_Flags2, 20h	; _$P_Extra ; 3/9 extra	delimiter encountered ?
SYSINIT:18AA		     jnz     short _$P_Pack_End	; 3/9 if yes, no need to copy
SYSINIT:18AC
SYSINIT:18AC _$P_Pack_Loop:			     ; ...
SYSINIT:18AC		     lodsb		     ; Pick a operand from buffer
SYSINIT:18AD		     call    _$P_Chk_Switch  ; Check switch character
SYSINIT:18B0		     jb	     short _$P_Pack_End_BY_EOL ; if carry set found delimiter type slash,
SYSINIT:18B0					     ; need backup si, else continue
SYSINIT:18B2		     call    _$P_Chk_EOL     ; Check EOL character
SYSINIT:18B5		     jz	     short _$P_Pack_End_BY_EOL ; need backup si
SYSINIT:18B7		     call    _$P_Chk_Delim   ; Check delimiter
SYSINIT:18BA		     jnz     short _$P_PL01  ; If no, process next byte
SYSINIT:18BC		     test    cs:_$P_Flags2, 20h	; _$P_Extra ; 3/9 If yes and white spec,
SYSINIT:18C2		     jnz     short _$P_Pack_End_backup_si ; 3/9	then
SYSINIT:18C4		     call    _$P_Skip_Delim  ; skip subsequent white space,too
SYSINIT:18C7		     jmp     short _$P_Pack_End	; finish copy by placing NUL at	end
SYSINIT:18C9 ; ---------------------------------------------------------------------------
SYSINIT:18C9
SYSINIT:18C9 _$P_Pack_End_backup_si:		     ; ...
SYSINIT:18C9		     test    cs:_$P_Flags2, 41h	; _$P_SW+_$P_equ
SYSINIT:18CF		     jz	     short _$P_Pack_End
SYSINIT:18D1		     dec     si
SYSINIT:18D2		     jmp     short _$P_Pack_End
SYSINIT:18D4 ; ---------------------------------------------------------------------------
SYSINIT:18D4
SYSINIT:18D4 _$P_PL01:				     ; ...
SYSINIT:18D4		     mov     cs:[bx], al     ; move byte to STRING_BUF
SYSINIT:18D7		     cmp     al, 3Dh ; '='   ; _$P_Keyword ; if it is equal character,
SYSINIT:18D9		     jnz     short _$P_PL00  ; then
SYSINIT:18DB		     or	     cs:_$P_Flags2, 1 ;	_$P_equ	; remember it in flag
SYSINIT:18E1
SYSINIT:18E1 _$P_PL00:				     ; ...
SYSINIT:18E1		     inc     bx		     ; ready to	see next byte
SYSINIT:18E2		     call    _$P_Chk_DBCS    ; was it 1st byte of DBCS ?
SYSINIT:18E5		     jnb     short _$P_Pack_Loop ; if no, process to next byte
SYSINIT:18E7		     lodsb
SYSINIT:18E8		     mov     cs:[bx], al     ; if yes, store 2nd byte of DBCS
SYSINIT:18EB		     inc     bx		     ; update pointer
SYSINIT:18EC		     jmp     short _$P_Pack_Loop ; process to next byte
SYSINIT:18EE ; ---------------------------------------------------------------------------
SYSINIT:18EE
SYSINIT:18EE _$P_Pack_End_BY_EOL:		     ; ...
SYSINIT:18EE		     dec     si		     ; backup si pointer
SYSINIT:18EF
SYSINIT:18EF _$P_Pack_End:			     ; ...
SYSINIT:18EF		     mov     cs:_$P_SI_Save, si	; save next pointer, SI
SYSINIT:18F4		     mov     byte ptr cs:[bx], 0 ; _$P_NULL ; put NULL at the end
SYSINIT:18F8		     mov     cs:_$P_Save_EOB, bx ; keep	the address for	later use of complex
SYSINIT:18FD		     mov     bx, es:[di]     ; [es:di+_$P_PARMS_Blk.PARMSX_Address]
SYSINIT:18FD					     ; get PARMSX address
SYSINIT:1900		     lea     si, _$P_STRING_BUF
SYSINIT:1904		     cmp     byte ptr cs:[si], 2Fh ; '/' ; the operand begins w/ switch char ?
SYSINIT:1904					     ; _$P_Switch
SYSINIT:1908		     jz	     short _$P_SW_Manager ; if yes, process as switch
SYSINIT:190A		     cmp     byte ptr cs:[si], 22h ; '"' ; _$P_DQuote  ; is it a string?
SYSINIT:190E		     jz	     short _$P_Positional_Manager ; if so, process as one!
SYSINIT:1910		     test    cs:_$P_Flags2, 1 ;	$P_equ ; the operand includes equal
SYSINIT:1916		     jnz     short _$P_Key_Manager ; if	yes, process as	keyword
SYSINIT:1918
SYSINIT:1918 _$P_Positional_Manager:		     ; ...
SYSINIT:1918		     mov     al, es:[bx+1]   ; else process as positional
SYSINIT:1918					     ; get maxp
SYSINIT:191C		     xor     ah, ah	     ; ax = maxp
SYSINIT:191E		     cmp     cs:_$P_ORDINAL, ax	; too many positional ?
SYSINIT:1923		     jnb     short _$P_Too_Many_Error ;	if yes,	set exit code to too many
SYSINIT:1925		     mov     ax, cs:_$P_ORDINAL	; see what the current ordinal
SYSINIT:1929		     shl     ax, 1	     ; ax = ax*2
SYSINIT:192B		     inc     bx
SYSINIT:192C		     inc     bx		     ; add '2' to bx reg
SYSINIT:192C					     ; now bx points to	1st CONTROL
SYSINIT:192D		     add     bx, ax	     ; now bx points to	specified CONTROL address
SYSINIT:192F		     mov     bx, es:[bx]     ; now bx points to	specified CONTROL itself
SYSINIT:1932		     call    _$P_Chk_Pos_Control ; Do process for positional
SYSINIT:1935		     jmp     short _$P_Return_to_Caller	; and return to	the caller
SYSINIT:1937 ; ---------------------------------------------------------------------------
SYSINIT:1937
SYSINIT:1937 _$P_Too_Many_Error:		     ; ...
SYSINIT:1937		     mov     cs:_$P_RC,	1    ; set exit	code
SYSINIT:193E		     jmp     short _$P_Return_to_Caller	; and return to	the caller
SYSINIT:1940 ; ---------------------------------------------------------------------------
SYSINIT:1940
SYSINIT:1940 _$P_SW_Manager:			     ; ...
SYSINIT:1940		     mov     al, es:[bx+1]   ; [es:bx+_$P_PARMSX_Blk.MaxP] ; get maxp
SYSINIT:1944		     xor     ah, ah	     ; ax = maxp
SYSINIT:1946		     inc     ax
SYSINIT:1947		     shl     ax, 1	     ; ax = (ax+1)*2
SYSINIT:1949		     add     bx, ax	     ; now bx points to	maxs
SYSINIT:194B		     mov     cl, es:[bx]
SYSINIT:194E		     xor     ch, ch	     ; cx = maxs
SYSINIT:1950		     or	     cx, cx	     ; at least	one switch ?
SYSINIT:1952		     jz	     short _$P_SW_Not_Found ; no
SYSINIT:1954		     inc     bx		     ; now bx points to	1st CONTROL address
SYSINIT:1955
SYSINIT:1955 _$P_SW_Mgr_Loop:			     ; ...
SYSINIT:1955		     push    bx
SYSINIT:1956		     mov     bx, es:[bx]     ; bx points to Switch CONTROL itself
SYSINIT:1959		     call    _$P_Chk_SW_Control	; do process for switch
SYSINIT:195C		     pop     bx
SYSINIT:195D		     jnb     short _$P_Return_to_Caller	;
SYSINIT:195D					     ; if the CONTROL is for the switch, exit
SYSINIT:195F		     inc     bx
SYSINIT:1960		     inc     bx		     ;	  add '2' to bx reg
SYSINIT:1960					     ; else bx points to the next CONTROL
SYSINIT:1961		     loop    _$P_SW_Mgr_Loop ; and loop
SYSINIT:1963
SYSINIT:1963 _$P_SW_Not_Found:			     ; ...
SYSINIT:1963		     mov     cs:_$P_RC,	3    ; _$P_Not_In_SW
SYSINIT:1963					     ; here no CONTROL for the switch has
SYSINIT:196A		     jmp     short _$P_Return_to_Caller
SYSINIT:196C ; ---------------------------------------------------------------------------
SYSINIT:196C
SYSINIT:196C _$P_Key_Manager:			     ; ...
SYSINIT:196C		     mov     al, es:[bx+1]   ; [es:bx+_$P_PARMSX_Blk.MaxP] ; get maxp
SYSINIT:1970		     xor     ah, ah	     ; ax = maxp
SYSINIT:1972		     inc     ax
SYSINIT:1973		     shl     ax, 1	     ; ax = (ax+1)*2
SYSINIT:1975		     add     bx, ax	     ; now bx points to	maxs
SYSINIT:1977		     mov     al, es:[bx]
SYSINIT:197A		     xor     ah, ah	     ; ax = maxs
SYSINIT:197C		     shl     ax, 1
SYSINIT:197E		     inc     ax		     ; ax = ax*2+1
SYSINIT:197F		     add     bx, ax	     ; now bx points to	maxk
SYSINIT:1981		     mov     cl, es:[bx]
SYSINIT:1984		     xor     ch, ch	     ; cx = maxk
SYSINIT:1986		     or	     cx, cx	     ; at least	one keyword ?
SYSINIT:1988		     jz	     short _$P_Key_Not_Found ; no
SYSINIT:198A		     inc     bx		     ; now bx points to	1st CONTROL
SYSINIT:198B
SYSINIT:198B _$P_Key_Mgr_Loop:			     ; ...
SYSINIT:198B		     push    bx
SYSINIT:198C		     mov     bx, es:[bx]     ; bx points to keyword CONTROL itself
SYSINIT:198F		     call    _$P_Chk_Key_Control ; do process for keyword
SYSINIT:1992		     pop     bx
SYSINIT:1993		     jnb     short _$P_Return_to_Caller	;
SYSINIT:1993					     ; if the CONTROL is for the keyword, exit
SYSINIT:1995		     inc     bx
SYSINIT:1996		     inc     bx		     ;	  add '2' to bx reg
SYSINIT:1996					     ; else bx points to the next CONTROL
SYSINIT:1997		     loop    _$P_Key_Mgr_Loop ;	and loop
SYSINIT:1999
SYSINIT:1999 _$P_Key_Not_Found:			     ; ...
SYSINIT:1999		     mov     cs:_$P_RC,	4    ; _$P_Not_In_Key
SYSINIT:1999					     ; here no CONTROL for the keyword has
SYSINIT:19A0
SYSINIT:19A0 _$P_Return_to_Caller:		     ; ...
SYSINIT:19A0		     pop     bp
SYSINIT:19A1		     pop     di
SYSINIT:19A2		     pop     bx
SYSINIT:19A3		     mov     cx, cs:_$P_ORDINAL	; return next ordinal
SYSINIT:19A8		     mov     ax, cs:_$P_RC   ; return exit code
SYSINIT:19AC		     mov     si, cs:_$P_SI_Save	; return next operand pointer
SYSINIT:19B1		     mov     dx, cs:_$P_DX   ; return result buffer address
SYSINIT:19B6		     mov     bl, cs:_$P_Terminator ; return delimiter code found
SYSINIT:19BB
SYSINIT:19BB _$P_Single_Exit:			     ; ...
SYSINIT:19BB		     clc
SYSINIT:19BC		     retn
SYSINIT:19BC SysParse	     endp
SYSINIT:19BC
SYSINIT:19BD
SYSINIT:19BD ; =============== S U B R O U T I N E =======================================
SYSINIT:19BD
SYSINIT:19BD
SYSINIT:19BD _$P_Chk_Pos_Control proc near	     ; ...
SYSINIT:19BD		     push    ax
SYSINIT:19BE		     mov     ax, es:[bx]     ; [es:bx+_$P_Control_Blk.Match_Flag]
SYSINIT:19C1		     test    ax, 2	     ; $P_Repeat ; repeat allowed ?
SYSINIT:19C4		     jnz     short _$P_CPC00 ; then do not increment ORDINAL
SYSINIT:19C6		     inc     cs:_$P_ORDINAL  ; update the ordinal
SYSINIT:19CB
SYSINIT:19CB _$P_CPC00:				     ; ...
SYSINIT:19CB		     cmp     byte ptr cs:[si], 0 ; _$P_NULL ; no data ?
SYSINIT:19CF		     jnz     short _$P_CPC01
SYSINIT:19D1		     test    ax, 1	     ; _$P_Optional ; yes, then	is it optional ?
SYSINIT:19D4		     jnz     short _$P_CPC02
SYSINIT:19D6		     mov     cs:_$P_RC,	2    ; _$P_Op_Missing ;	no, then error
SYSINIT:19DD		     jmp     short _$P_CPC_Exit
SYSINIT:19DF ; ---------------------------------------------------------------------------
SYSINIT:19DF
SYSINIT:19DF _$P_CPC02:				     ; ...
SYSINIT:19DF		     push    ax
SYSINIT:19E0		     mov     al, 3	     ; _$P_String
SYSINIT:19E2		     mov     ah, 0FFh	     ; _$P_No_Tag
SYSINIT:19E2					     ; if it is	optional return	NULL
SYSINIT:19E2					     ; no item tag indication
SYSINIT:19E4		     call    _$P_Fill_Result
SYSINIT:19E7		     pop     ax
SYSINIT:19E8		     jmp     short _$P_CPC_Exit
SYSINIT:19EA ; ---------------------------------------------------------------------------
SYSINIT:19EA
SYSINIT:19EA _$P_CPC01:				     ; ...
SYSINIT:19EA		     call    _$P_Check_Match_Flags
SYSINIT:19ED
SYSINIT:19ED _$P_CPC_Exit:			     ; ...
SYSINIT:19ED		     pop     ax
SYSINIT:19EE		     retn
SYSINIT:19EE _$P_Chk_Pos_Control endp
SYSINIT:19EE
SYSINIT:19EF
SYSINIT:19EF ; =============== S U B R O U T I N E =======================================
SYSINIT:19EF
SYSINIT:19EF
SYSINIT:19EF _$P_Chk_Key_Control proc near	     ; ...
SYSINIT:19EF		     stc		     ; this logic works
SYSINIT:19EF					     ; when the	KeySW is reset.
SYSINIT:19F0		     retn
SYSINIT:19F0 _$P_Chk_Key_Control endp
SYSINIT:19F0
SYSINIT:19F1
SYSINIT:19F1 ; =============== S U B R O U T I N E =======================================
SYSINIT:19F1
SYSINIT:19F1
SYSINIT:19F1 _$P_Search_KEYorSW	proc near	     ; ...
SYSINIT:19F1		     push    bp
SYSINIT:19F2		     push    cx
SYSINIT:19F3		     mov     cl, es:[bx+8]   ; [es:bx+_$P_Control_Blk.nid] ; Get synonym count
SYSINIT:19F7		     xor     ch, ch	     ; and set it to cx
SYSINIT:19F9		     or	     cx, cx	     ; No synonyms specified ?
SYSINIT:19FB		     jz	     short _$P_KEYorSW_Not_Found ; then	indicate not found by CY
SYSINIT:19FD		     lea     bp, [bx+9]	     ; [bx+_$P_Control_Blk.KEYorSW]
SYSINIT:1A00
SYSINIT:1A00 _$P_KEYorSW_Loop:			     ; ...
SYSINIT:1A00		     call    _$P_String_Comp ; compare string in buffer	w/ the synonym
SYSINIT:1A03		     jnb     short _$P_KEYorSW_Found ; If match, set it	to synonym pointer
SYSINIT:1A05		     call    _$P_MoveBP_NUL  ; else, bp	points to the next string
SYSINIT:1A08		     loop    _$P_KEYorSW_Loop ;	loop nid times
SYSINIT:1A0A
SYSINIT:1A0A _$P_KEYorSW_Not_Found:		     ; ...
SYSINIT:1A0A		     stc		     ; indicate	not found in synonym list
SYSINIT:1A0B		     jmp     short _$P_KEYorSW_Exit ; and exit
SYSINIT:1A0D ; ---------------------------------------------------------------------------
SYSINIT:1A0D
SYSINIT:1A0D _$P_KEYorSW_Found:			     ; ...
SYSINIT:1A0D		     mov     cs:_$P_Found_SYNONYM, bp ;	set synonym pointer
SYSINIT:1A12		     clc		     ; indicate	found
SYSINIT:1A13
SYSINIT:1A13 _$P_KEYorSW_Exit:			     ; ...
SYSINIT:1A13		     pop     cx
SYSINIT:1A14		     pop     bp
SYSINIT:1A15		     retn
SYSINIT:1A15 _$P_Search_KEYorSW	endp
SYSINIT:1A15
SYSINIT:1A16
SYSINIT:1A16 ; =============== S U B R O U T I N E =======================================
SYSINIT:1A16
SYSINIT:1A16
SYSINIT:1A16 _$P_MoveBP_NUL  proc near		     ; ...
SYSINIT:1A16		     cmp     byte ptr es:[bp+0], 0 ; _$P_NULL
SYSINIT:1A16					     ; Increment BP that points
SYSINIT:1A1B		     jz	     short _$P_MBP_Exit	; to the synomym list
SYSINIT:1A1D		     inc     bp		     ; until
SYSINIT:1A1E		     jmp     short _$P_MoveBP_NUL ; NULL encountered.
SYSINIT:1A1E					     ; _$P_MBP_Loop
SYSINIT:1A20 ; ---------------------------------------------------------------------------
SYSINIT:1A20
SYSINIT:1A20 _$P_MBP_Exit:			     ; ...
SYSINIT:1A20		     inc     bp		     ; bp points to next to NULL
SYSINIT:1A21		     retn
SYSINIT:1A21 _$P_MoveBP_NUL  endp
SYSINIT:1A21
SYSINIT:1A22
SYSINIT:1A22 ; =============== S U B R O U T I N E =======================================
SYSINIT:1A22
SYSINIT:1A22
SYSINIT:1A22 _$P_Chk_SW_Control	proc near	     ; ...
SYSINIT:1A22		     or	     cs:_$P_Flags2, 10h	; (Check if switch is supported)
SYSINIT:1A22					     ; _$P_SW_Cmp
SYSINIT:1A22					     ; Indicate	switch for later string	comparison
SYSINIT:1A28		     call    _$P_Search_KEYorSW	; Search the switch in the CONTROL block
SYSINIT:1A2B		     jb	     short _$P_Chk_SW_Err0 ; not found,	then try next CONTROL
SYSINIT:1A2D		     and     cs:_$P_Flags2, 0EFh ; and byte [cs:_$P_Flags2],0FFh-_$P_SW_Cmp
SYSINIT:1A2D					     ; reset the indicator previously set /switch
SYSINIT:1A33		     push    ax
SYSINIT:1A34		     mov     ax, cs:_$P_KEYorSW_Ptr
SYSINIT:1A38		     sub     ax, si	     ; [si] = KEY or SW
SYSINIT:1A3A		     add     cs:_$P_SaveSI_Cmpx, ax ; update for complex list
SYSINIT:1A3F		     pop     ax
SYSINIT:1A40		     mov     si, cs:_$P_KEYorSW_Ptr ; set si at	the end	or colon
SYSINIT:1A45		     cmp     byte ptr cs:[si], 0 ; _$P_NULL ; any data after colon ?
SYSINIT:1A49		     jnz     short _$P_CSW00 ; if yes, process match flags
SYSINIT:1A4B		     cmp     byte ptr cs:[si-1], ':' ; _$P_Colon
SYSINIT:1A4B					     ; if no, the switch terminated by colon ?
SYSINIT:1A50		     jnz     short _$P_Chk_if_data_required ;
SYSINIT:1A50					     ; if yes,
SYSINIT:1A52		     mov     cs:_$P_RC,	9    ; _$P_Syntax ; return syntax error
SYSINIT:1A59		     jmp     short _$P_Chk_SW_Exit
SYSINIT:1A5B ; ---------------------------------------------------------------------------
SYSINIT:1A5B
SYSINIT:1A5B _$P_Chk_if_data_required:		     ; ...
SYSINIT:1A5B		     cmp     word ptr es:[bx], 0 ; [es:bx+_$P_Control_Blk.Match_Flag]
SYSINIT:1A5B					     ; should have data?
SYSINIT:1A5B					     ; zero match flag means switch followed by	nothing	is OK
SYSINIT:1A5F		     jz	     short _$P_Chk_SW_Exit ; match flags not zero so
SYSINIT:1A5F					     ; should have something if	optional bit is	not on
SYSINIT:1A61		     test    word ptr es:[bx], 1 ; _$P_Optional	; see if no value is valid
SYSINIT:1A66		     jnz     short _$P_Chk_SW_Exit ; if	so, then leave,	else yell
SYSINIT:1A68		     mov     cs:_$P_RC,	2    ; _$P_Op_Missing
SYSINIT:1A68					     ; return required operand missing
SYSINIT:1A6F		     jmp     short _$P_Chk_SW_Exit
SYSINIT:1A71 ; ---------------------------------------------------------------------------
SYSINIT:1A71
SYSINIT:1A71 _$P_CSW00:				     ; ...
SYSINIT:1A71		     call    _$P_Check_Match_Flags ; process match flag
SYSINIT:1A74		     clc		     ; indicate	match
SYSINIT:1A75		     jmp     short _$P_Chk_SW_Single_Exit
SYSINIT:1A77 ; ---------------------------------------------------------------------------
SYSINIT:1A77
SYSINIT:1A77 _$P_Chk_SW_Err0:			     ; ...
SYSINIT:1A77		     stc		     ; not found in switch synonym list
SYSINIT:1A78		     jmp     short _$P_Chk_SW_Single_Exit
SYSINIT:1A7A ; ---------------------------------------------------------------------------
SYSINIT:1A7A
SYSINIT:1A7A _$P_Chk_SW_Exit:			     ; ...
SYSINIT:1A7A		     push    ax
SYSINIT:1A7B		     mov     al, 3	     ; _$P_String
SYSINIT:1A7D		     mov     ah, 0FFh	     ; _$ P_No_Tag
SYSINIT:1A7F		     call    _$P_Fill_Result ; set result buffer
SYSINIT:1A82		     pop     ax
SYSINIT:1A83		     clc
SYSINIT:1A84
SYSINIT:1A84 _$P_Chk_SW_Single_Exit:		     ; ...
SYSINIT:1A84		     retn
SYSINIT:1A84 _$P_Chk_SW_Control	endp
SYSINIT:1A84
SYSINIT:1A85
SYSINIT:1A85 ; =============== S U B R O U T I N E =======================================
SYSINIT:1A85
SYSINIT:1A85
SYSINIT:1A85 _$P_Fill_Result proc near		     ; ...
SYSINIT:1A85		     push    di
SYSINIT:1A86		     mov     di, es:[bx+4]   ; [es:bx+_$P_Control_Blk.Result_Buf]
SYSINIT:1A86					     ; di points to result buffer
SYSINIT:1A8A		     mov     cs:_$P_DX,	di   ; set returned result address
SYSINIT:1A8F		     mov     es:[di], al     ; [es:di+_$P_Result_Blk.Type] ; store type
SYSINIT:1A92		     mov     es:[di+1],	ah   ; [es:di+_$P_Result_Blk.Item_Tag] ; store item tag
SYSINIT:1A96		     push    ax
SYSINIT:1A97		     mov     ax, cs:_$P_Found_SYNONYM
SYSINIT:1A9B		     mov     es:[di+2],	ax   ; [es:di+_$P_Result_Blk.SYNONYM_Ptr]
SYSINIT:1A9F		     pop     ax
SYSINIT:1AA0
SYSINIT:1AA0 _$P_RLT04:				     ;
SYSINIT:1AA0		     cmp     al, 1	     ; _$P_Number ; if number
SYSINIT:1AA2		     jnz     short _$P_RLT00 ;
SYSINIT:1AA2					     ; then store 32 bit
SYSINIT:1AA4
SYSINIT:1AA4 _$P_RLT02:				     ; ...
SYSINIT:1AA4		     mov     es:[di+4],	dx   ; [es:di+_$P_Result_Blk.Picked_Val]
SYSINIT:1AA8		     mov     es:[di+6],	cx   ; [es:di+_$P_Result_Blk.Picked_Val+2]
SYSINIT:1AAC		     jmp     short _$P_RLT_Exit
SYSINIT:1AAE ; ---------------------------------------------------------------------------
SYSINIT:1AAE
SYSINIT:1AAE _$P_RLT00:				     ; ...
SYSINIT:1AAE		     cmp     al, 2	     ; _$P_List_Idx ; if list index
SYSINIT:1AB0		     jnz     short _$P_RLT01 ;
SYSINIT:1AB0					     ; then store list index
SYSINIT:1AB2		     mov     es:[di+4],	dx   ; [es:di+_$P_Result_Blk.Picked_Val]
SYSINIT:1AB6		     jmp     short _$P_RLT_Exit
SYSINIT:1AB8 ; ---------------------------------------------------------------------------
SYSINIT:1AB8
SYSINIT:1AB8 _$P_RLT01:				     ; ...
SYSINIT:1AB8		     cmp     al, 7	     ; _$P_Date_F ; Date format	?
SYSINIT:1ABA		     jz	     short _$P_RLT02
SYSINIT:1ABC		     cmp     al, 8	     ; _$P_Time_F ; Time format	?
SYSINIT:1ABE		     jz	     short _$P_RLT02
SYSINIT:1AC0		     cmp     al, 6	     ; _$P_Drive ; drive format	?
SYSINIT:1AC2		     jnz     short _$P_RLT03
SYSINIT:1AC4		     mov     es:[di+4],	dl   ; [es:di+_$P_Result_Blk.Picked_Val]
SYSINIT:1AC4					     ; store drive number
SYSINIT:1AC8		     jmp     short _$P_RLT_Exit
SYSINIT:1ACA ; ---------------------------------------------------------------------------
SYSINIT:1ACA
SYSINIT:1ACA _$P_RLT03:				     ; ...
SYSINIT:1ACA		     cmp     al, 4	     ; _$P_Complex ; complex format ?
SYSINIT:1ACC		     jnz     short _$P_RLT05
SYSINIT:1ACE		     mov     ax, cs:_$P_SaveSI_Cmpx ;
SYSINIT:1ACE					     ; then get	pointer	in command buffer
SYSINIT:1AD2		     inc     ax		     ; skip left Parentheses
SYSINIT:1AD3		     mov     es:[di+4],	ax   ; [es:di+_$P_Result_Blk.Picked_Val]
SYSINIT:1AD3					     ; store offset
SYSINIT:1AD7		     mov     word ptr es:[di+6], ds ; [es:di+_$P_Result_Blk.Picked_Val+2]
SYSINIT:1AD7					     ; store segment
SYSINIT:1ADB		     jmp     short _$P_RLT_Exit
SYSINIT:1ADD ; ---------------------------------------------------------------------------
SYSINIT:1ADD
SYSINIT:1ADD _$P_RLT05:				     ; ...
SYSINIT:1ADD		     mov     es:[di+4],	si   ; AL = 3, 5, or 9
SYSINIT:1ADD					     ; [es:di+_$P_Result_Blk.Picked_Val]
SYSINIT:1ADD					     ; store offset of STRING_BUF
SYSINIT:1AE1		     mov     word ptr es:[di+6], cs ; [es:di+_$P_Result_Blk.Picked_Val+2]
SYSINIT:1AE1					     ; store segment of	STRING_BUF
SYSINIT:1AE5		     push    ax
SYSINIT:1AE6		     test    byte ptr es:[bx+2], 1 ; [es:bx+_$P_Control_Blk.Function_Flag],
SYSINIT:1AE6					     ; _$P_CAP_File
SYSINIT:1AE6					     ; need CAPS by file table?
SYSINIT:1AEB		     jz	     short _$P_RLT_CAP00
SYSINIT:1AED		     mov     al, 4	     ; _$P_DOSTBL_File ; use file upper	case table
SYSINIT:1AEF		     jmp     short _$P_RLT_CAP02
SYSINIT:1AF1 ; ---------------------------------------------------------------------------
SYSINIT:1AF1
SYSINIT:1AF1 _$P_RLT_CAP00:			     ; ...
SYSINIT:1AF1		     test    byte ptr es:[bx+2], 2 ; [es:bx+_$P_Control_Blk.Function_Flag],
SYSINIT:1AF1					     ; _$P_CAP_Char
SYSINIT:1AF1					     ; need CAPS by char table
SYSINIT:1AF6		     jz	     short _$P_RLT_CAP01
SYSINIT:1AF8		     mov     al, 2	     ; _$P_DOSTBL_Char
SYSINIT:1AF8					     ; use character upper case	table
SYSINIT:1AFA
SYSINIT:1AFA _$P_RLT_CAP02:			     ; ...
SYSINIT:1AFA		     call    _$P_Do_CAPS_String	; process CAPS along the table
SYSINIT:1AFD
SYSINIT:1AFD _$P_RLT_CAP01:			     ; ...
SYSINIT:1AFD		     pop     ax
SYSINIT:1AFE		     test    byte ptr es:[bx+2], 10h ; [es:bx+_$P_Control_Blk.Function_Flag],
SYSINIT:1AFE					     ; _$P_Rm_Colon
SYSINIT:1AFE					     ; removing	colon at end ?
SYSINIT:1B03		     jz	     short _$P_RLT_Exit
SYSINIT:1B05		     call    _$P_Remove_Colon ;	then process it.
SYSINIT:1B08
SYSINIT:1B08 _$P_RLT_Exit:			     ; ...
SYSINIT:1B08		     pop     di
SYSINIT:1B09		     retn
SYSINIT:1B09 _$P_Fill_Result endp
SYSINIT:1B09
SYSINIT:1B0A
SYSINIT:1B0A ; =============== S U B R O U T I N E =======================================
SYSINIT:1B0A
SYSINIT:1B0A
SYSINIT:1B0A _$P_Check_Match_Flags proc	near	     ; ...
SYSINIT:1B0A		     mov     cs:_$P_err_flag, 0	; _$P_NULL ; clear filespec error flag.
SYSINIT:1B10		     push    ax
SYSINIT:1B11		     mov     ax, es:[bx]     ; [es:bx+_$P_Control_Blk.Match_Flag]
SYSINIT:1B11					     ; load match flag (16bit) to ax
SYSINIT:1B14		     or	     ax, ax	     ; test ax for zero
SYSINIT:1B16		     jnz     short _$P_Mat
SYSINIT:1B18		     push    ax
SYSINIT:1B19		     push    bx
SYSINIT:1B1A		     push    dx
SYSINIT:1B1B		     push    di
SYSINIT:1B1C		     mov     cs:_$P_RC,	9    ; _$P_Syntax
SYSINIT:1B23		     mov     ah, 0FFh	     ; _$P_No_Tag
SYSINIT:1B25		     mov     al, 3	     ; _$P_String
SYSINIT:1B27		     call    _$P_Fill_Result
SYSINIT:1B2A		     pop     di
SYSINIT:1B2B		     pop     dx
SYSINIT:1B2C		     pop     bx
SYSINIT:1B2D		     pop     ax
SYSINIT:1B2E		     jmp     short _$P_Bridge
SYSINIT:1B30 ; ---------------------------------------------------------------------------
SYSINIT:1B30
SYSINIT:1B30 _$P_Mat:				     ; ...
SYSINIT:1B30		     jmp     short _$P_Match03
SYSINIT:1B32 ; ---------------------------------------------------------------------------
SYSINIT:1B32
SYSINIT:1B32 _$P_Bridge:			     ; ...
SYSINIT:1B32		     jmp     short _$P_Match_Exit
SYSINIT:1B34 ; ---------------------------------------------------------------------------
SYSINIT:1B34		     nop		     ; 90h
SYSINIT:1B35
SYSINIT:1B35 _$P_Match03:			     ; ...
SYSINIT:1B35		     test    ax, 8000h	     ; _$P_Num_Val ; Numeric value
SYSINIT:1B38		     jz	     short _$P_Match04
SYSINIT:1B3A		     mov     cs:_$P_RC,	0    ; _$P_No_Error ; assume no	error
SYSINIT:1B41		     call    _$P_Value	     ; do process
SYSINIT:1B44		     cmp     cs:_$P_RC,	9    ; _$P_Syntax ; if error, examine the next type
SYSINIT:1B4A		     jnz     short _$P_Match_Exit
SYSINIT:1B4C
SYSINIT:1B4C _$P_Match04:			     ; ...
SYSINIT:1B4C		     test    ax, 4000h	     ; _$P_SNum_Val ; Signed numeric value
SYSINIT:1B4F		     jz	     short _$P_Match05
SYSINIT:1B51		     mov     cs:_$P_RC,	0    ; _$P_No_Error ; assume no	error
SYSINIT:1B58		     call    _$P_SValue	     ; do process
SYSINIT:1B5B		     cmp     cs:_$P_RC,	9    ; _$P_Syntax ; if error, examine the next type
SYSINIT:1B61		     jnz     short _$P_Match_Exit
SYSINIT:1B63
SYSINIT:1B63 _$P_Match05:			     ; ...
SYSINIT:1B63		     test    ax, 100h	     ; _$P_Drv_Only ; Drive only
SYSINIT:1B66		     jz	     short _$P_Match06
SYSINIT:1B68		     mov     cs:_$P_RC,	0    ; _$P_No_Error ; assume no	error
SYSINIT:1B6F		     call    _$P_File_Format ; 1st, call file format
SYSINIT:1B72		     call    _$P_Drive_Format ;	check drive format, next
SYSINIT:1B75		     cmp     cs:_$P_RC,	9    ; _$P_Syntax ; if error, examine the next type
SYSINIT:1B7B		     jnz     short _$P_Match_Exit
SYSINIT:1B7D
SYSINIT:1B7D _$P_Match06:			     ; ...
SYSINIT:1B7D		     test    ax, 200h	     ; _$P_File_Spc ; File spec
SYSINIT:1B80		     jz	     short _$P_Match07
SYSINIT:1B82		     mov     cs:_$P_RC,	0    ; _$P_No_Error ; assume no	error
SYSINIT:1B89		     call    _$P_File_Format ; do process
SYSINIT:1B8C		     cmp     cs:_$P_RC,	9    ; _$P_Syntax ; if error, examine the next type
SYSINIT:1B92		     jnz     short _$P_Match_Exit
SYSINIT:1B94
SYSINIT:1B94 _$P_Match07:			     ; ...
SYSINIT:1B94		     test    ax, 2000h	     ; _$P_Simple_S ; Simple string
SYSINIT:1B97		     jz	     short _$P_Match_Exit
SYSINIT:1B99		     mov     cs:_$P_RC,	0    ; _$P_No_Error ; assume no	error
SYSINIT:1BA0		     call    _$P_Simple_String ; do process
SYSINIT:1BA3
SYSINIT:1BA3 _$P_Match_Exit:			     ; ...
SYSINIT:1BA3		     cmp     cs:_$P_err_flag, 1	; _$P_error_filespec ; bad filespec ?
SYSINIT:1BA9		     jnz     short _$P_Match2_Exit ; no, continue
SYSINIT:1BAB		     cmp     cs:_$P_RC,	0    ; _$P_No_Error ; check for	other errors ?
SYSINIT:1BB1		     jnz     short _$P_Match2_Exit ; no, continue
SYSINIT:1BB3		     mov     cs:_$P_RC,	9    ; _$P_Syntax ; set	error flag
SYSINIT:1BBA
SYSINIT:1BBA _$P_Match2_Exit:			     ; ...
SYSINIT:1BBA		     pop     ax
SYSINIT:1BBB		     retn
SYSINIT:1BBB _$P_Check_Match_Flags endp
SYSINIT:1BBB
SYSINIT:1BBC
SYSINIT:1BBC ; =============== S U B R O U T I N E =======================================
SYSINIT:1BBC
SYSINIT:1BBC
SYSINIT:1BBC _$P_Remove_Colon proc near		     ; ...
SYSINIT:1BBC		     push    ax
SYSINIT:1BBD		     push    si
SYSINIT:1BBE
SYSINIT:1BBE _$P_RCOL_Loop:			     ; ...
SYSINIT:1BBE		     mov     al, cs:[si]     ; get character
SYSINIT:1BC1		     or	     al, al	     ; end of string ?
SYSINIT:1BC3		     jz	     short _$P_RCOL_Exit ; if yes, just	exit
SYSINIT:1BC5		     cmp     al, ':'         ; _$P_Colon ; is it colon ?
SYSINIT:1BC7		     jnz     short _$P_RCOL00
SYSINIT:1BC9		     cmp     byte ptr cs:[si+1], 0 ; _$P_NULL
SYSINIT:1BC9					     ; if so, next is NULL ?
SYSINIT:1BCE		     jnz     short _$P_RCOL00
SYSINIT:1BD0		     mov     byte ptr cs:[si], 0 ; _$P_NULL ; yes, remove colon
SYSINIT:1BD4		     jmp     short _$P_RCOL_Exit ; and exit.
SYSINIT:1BD6 ; ---------------------------------------------------------------------------
SYSINIT:1BD6
SYSINIT:1BD6 _$P_RCOL00:			     ; ...
SYSINIT:1BD6		     call    _$P_Chk_DBCS    ; if not colon, then check	if
SYSINIT:1BD6					     ; DBCS leading byte.
SYSINIT:1BD9		     jnb     short _$P_RCOL01
SYSINIT:1BDB		     inc     si		     ; if yes, skip trailing byte
SYSINIT:1BDC
SYSINIT:1BDC _$P_RCOL01:			     ; ...
SYSINIT:1BDC		     inc     si		     ; si points to next byte
SYSINIT:1BDD		     jmp     short _$P_RCOL_Loop ; loop	until NULL encountered
SYSINIT:1BDF ; ---------------------------------------------------------------------------
SYSINIT:1BDF
SYSINIT:1BDF _$P_RCOL_Exit:			     ; ...
SYSINIT:1BDF		     pop     si
SYSINIT:1BE0		     pop     ax
SYSINIT:1BE1		     retn
SYSINIT:1BE1 _$P_Remove_Colon endp
SYSINIT:1BE1
SYSINIT:1BE2
SYSINIT:1BE2 ; =============== S U B R O U T I N E =======================================
SYSINIT:1BE2
SYSINIT:1BE2
SYSINIT:1BE2 _$P_Do_CAPS_String	proc near	     ; ...
SYSINIT:1BE2		     push    si
SYSINIT:1BE3		     push    dx
SYSINIT:1BE4		     mov     dl, al	     ; save info id
SYSINIT:1BE6
SYSINIT:1BE6 _$P_DCS_Loop:			     ; ...
SYSINIT:1BE6		     mov     al, cs:[si]     ; load charater and
SYSINIT:1BE9		     call    _$P_Chk_DBCS    ; check if	DBCS leading byte
SYSINIT:1BEC		     jb	     short _$P_DCS00 ; if yes, do not need CAPS
SYSINIT:1BEE		     or	     al, al	     ; end of string ?
SYSINIT:1BF0		     jz	     short _$P_DCS_Exit	; then exit.
SYSINIT:1BF2		     call    _$P_Do_CAPS_Char ;	Here a SBCS char need to be CAPS
SYSINIT:1BF5		     mov     cs:[si], al     ; stored upper case char to buffer
SYSINIT:1BF8		     jmp     short _$P_DCS01 ; process next
SYSINIT:1BFA ; ---------------------------------------------------------------------------
SYSINIT:1BFA
SYSINIT:1BFA _$P_DCS00:				     ; ...
SYSINIT:1BFA		     inc     si		     ; skip DBCS leading and trailing byte
SYSINIT:1BFB
SYSINIT:1BFB _$P_DCS01:				     ; ...
SYSINIT:1BFB		     inc     si		     ; si points to next byte
SYSINIT:1BFC		     jmp     short _$P_DCS_Loop	; loop until NULL encountered
SYSINIT:1BFE ; ---------------------------------------------------------------------------
SYSINIT:1BFE
SYSINIT:1BFE _$P_DCS_Exit:			     ; ...
SYSINIT:1BFE		     pop     dx
SYSINIT:1BFF		     pop     si
SYSINIT:1C00		     retn
SYSINIT:1C00 _$P_Do_CAPS_String	endp
SYSINIT:1C00
SYSINIT:1C01
SYSINIT:1C01 ; =============== S U B R O U T I N E =======================================
SYSINIT:1C01
SYSINIT:1C01
SYSINIT:1C01 _$P_Do_CAPS_Char proc near		     ; ...
SYSINIT:1C01		     cmp     al, 80h	     ; _$P_ASCII80 ; need upper	case table ?
SYSINIT:1C03		     jnb     short _$P_DCC_Go ;	no
SYSINIT:1C05		     cmp     al, 'a'         ; check if  "a" <= AL <= "z"
SYSINIT:1C07		     jb	     short _$P_CAPS_Ret
SYSINIT:1C09		     cmp     al, 'z'
SYSINIT:1C0B		     ja	     short _$P_CAPS_Ret
SYSINIT:1C0D		     and     al, 0DFh	     ; _$P_Make_Upper ;	make CAPS
SYSINIT:1C0F		     jmp     short _$P_CAPS_Ret
SYSINIT:1C11 ; ---------------------------------------------------------------------------
SYSINIT:1C11
SYSINIT:1C11 _$P_DCC_Go:			     ; ...
SYSINIT:1C11		     push    bx
SYSINIT:1C12		     push    es
SYSINIT:1C13		     push    di
SYSINIT:1C14		     lea     di, _$P_Char_CAP_Ptr ; or use char	CAPS table ?
SYSINIT:1C18		     cmp     cs:[di], dl     ; already got table address ?
SYSINIT:1C1B		     jz	     short _$P_DCC01 ; no
SYSINIT:1C1D		     push    ax
SYSINIT:1C1E		     push    cx
SYSINIT:1C1F		     push    dx
SYSINIT:1C20		     push    cs
SYSINIT:1C21		     pop     es
SYSINIT:1C22		     assume es:SYSINIT
SYSINIT:1C22		     mov     ah, 65h	     ; _$P_DOS_Get_TBL
SYSINIT:1C24		     mov     al, dl	     ; function
SYSINIT:1C26		     mov     bx, 0FFFFh	     ; _$P_DOSTBL_Def =	-1
SYSINIT:1C29		     mov     cx, 5	     ; _$P_DOSTBL_BL
SYSINIT:1C2C		     mov     dx, 0FFFFh	     ; _$P_DOSTBL_Def
SYSINIT:1C2F		     int     21h	     ; DOS - 4.x internal
SYSINIT:1C2F					     ; COUNTRY-DEPENDENT FILENAME CAPITALIZATION
SYSINIT:1C2F					     ; AL = function -
SYSINIT:1C2F					     ;
SYSINIT:1C2F					     ; DI already set to point to buffer
SYSINIT:1C31		     pop     dx
SYSINIT:1C32		     pop     cx
SYSINIT:1C33		     pop     ax
SYSINIT:1C34
SYSINIT:1C34 _$P_DCC01:				     ; ...
SYSINIT:1C34		     mov     bx, cs:[di+1]   ; [cs:di+_$P_DOS_TBL.Off]
SYSINIT:1C34					     ; get offset of table
SYSINIT:1C38		     mov     es, word ptr cs:[di+3] ; [cs:di+_$P_DOS_TBL.Seg]
SYSINIT:1C38					     ; get segment of table
SYSINIT:1C3C		     assume es:nothing
SYSINIT:1C3C		     inc     bx
SYSINIT:1C3D		     inc     bx		     ; add 2 to	bx reg
SYSINIT:1C3E		     sub     al, 80h	     ; _$P_ASCII80 ; make char to index
SYSINIT:1C40		     xlat    byte ptr es:[bx] ;	perform	case map
SYSINIT:1C42		     pop     di
SYSINIT:1C43		     pop     es
SYSINIT:1C44		     pop     bx
SYSINIT:1C45
SYSINIT:1C45 _$P_CAPS_Ret:			     ; ...
SYSINIT:1C45		     retn
SYSINIT:1C45 _$P_Do_CAPS_Char endp
SYSINIT:1C45
SYSINIT:1C46
SYSINIT:1C46 ; =============== S U B R O U T I N E =======================================
SYSINIT:1C46
SYSINIT:1C46
SYSINIT:1C46 _$P_SValue	     proc near		     ; ...
SYSINIT:1C46		     push    ax
SYSINIT:1C47		     or	     cs:_$P_Flags2, 80h	; _$P_Signed ; indicate	a signed numeric
SYSINIT:1C4D		     and     cs:_$P_Flags2, 0FDh ; 0FFh-_$P_Neg	; assume positive value
SYSINIT:1C4D					     ; and byte	[cs:$_Flags2],~_$P_Neg ; ~2
SYSINIT:1C53		     mov     al, cs:[si]     ; get sign
SYSINIT:1C56		     cmp     al, '+'         ; _$P_Plus
SYSINIT:1C58		     jz	     short _$P_SVal00
SYSINIT:1C5A		     cmp     al, '-'         ; _$P_Minus
SYSINIT:1C5C		     jnz     short _$P_Sval01
SYSINIT:1C5E		     or	     cs:_$P_Flags2, 2 ;	_$P_Neg
SYSINIT:1C5E					     ; set this	is negative value
SYSINIT:1C64
SYSINIT:1C64 _$P_SVal00:			     ; ...
SYSINIT:1C64		     inc     si		     ; skip sign char
SYSINIT:1C65
SYSINIT:1C65 _$P_Sval01:			     ; ...
SYSINIT:1C65		     call    _$P_Value	     ; and process value
SYSINIT:1C68		     pop     ax
SYSINIT:1C69		     retn
SYSINIT:1C69 _$P_SValue	     endp
SYSINIT:1C69
SYSINIT:1C6A
SYSINIT:1C6A ; =============== S U B R O U T I N E =======================================
SYSINIT:1C6A
SYSINIT:1C6A
SYSINIT:1C6A _$P_Value	     proc near		     ; ...
SYSINIT:1C6A		     push    ax
SYSINIT:1C6B		     push    cx
SYSINIT:1C6C		     push    dx
SYSINIT:1C6D		     push    si
SYSINIT:1C6E		     xor     cx, cx	     ; cx = higher 16 bits
SYSINIT:1C70		     xor     dx, dx	     ; dx = lower 16 bits
SYSINIT:1C72		     push    bx
SYSINIT:1C73
SYSINIT:1C73 _$P_Value_Loop:			     ; ...
SYSINIT:1C73		     mov     al, cs:[si]     ; get character
SYSINIT:1C76		     or	     al, al	     ; end of line ?
SYSINIT:1C78		     jz	     short _$P_Value00
SYSINIT:1C7A		     call    _$P_0099	     ; make asc(0..9) to bin(0..9)
SYSINIT:1C7D		     jb	     short _$P_Value_Err0 ; then error,	exit
SYSINIT:1C7F		     xor     ah, ah
SYSINIT:1C81		     mov     bp, ax	     ; save binary number
SYSINIT:1C83		     shl     dx, 1	     ; to have 2*x
SYSINIT:1C85		     rcl     cx, 1	     ; shift left w/ carry
SYSINIT:1C87		     call    _$P_Check_OVF   ; Overflow	occurred ?
SYSINIT:1C8A		     jb	     short _$P_Value_Err0 ; then error,	exit
SYSINIT:1C8C		     mov     bx, dx	     ; save low(2*x)
SYSINIT:1C8E		     mov     ax, cx	     ; save high(2*x)
SYSINIT:1C90		     shl     dx, 1	     ; to have 4*x
SYSINIT:1C92		     rcl     cx, 1	     ; shift left w/ carry
SYSINIT:1C94		     call    _$P_Check_OVF   ; Overflow	occurred ?
SYSINIT:1C97		     jb	     short _$P_Value_Err0 ; then error,	exit
SYSINIT:1C99		     shl     dx, 1	     ; to have 8*x
SYSINIT:1C9B		     rcl     cx, 1	     ; shift left w/ carry
SYSINIT:1C9D		     call    _$P_Check_OVF
SYSINIT:1CA0		     jb	     short _$P_Value_Err0
SYSINIT:1CA2		     add     dx, bx	     ; now have	10*x
SYSINIT:1CA4		     adc     cx, ax	     ; 32bit ADD
SYSINIT:1CA6		     call    _$P_Check_OVF   ; Overflow	occurred ?
SYSINIT:1CA9		     jb	     short _$P_Value_Err0 ; then error,	exit
SYSINIT:1CAB		     add     dx, bp	     ; Add the current one degree decimal
SYSINIT:1CAD		     adc     cx, 0	     ; if carry, add 1 to high 16bit
SYSINIT:1CB0		     call    _$P_Check_OVF   ; Overflow	occurred ?
SYSINIT:1CB3		     jb	     short _$P_Value_Err0 ; then error,	exit
SYSINIT:1CB5		     inc     si		     ; update pointer
SYSINIT:1CB6		     jmp     short _$P_Value_Loop ; loop until NULL encountered
SYSINIT:1CB8 ; ---------------------------------------------------------------------------
SYSINIT:1CB8
SYSINIT:1CB8 _$P_Value_Err0:			     ; ...
SYSINIT:1CB8		     pop     bx
SYSINIT:1CB9		     jmp     _$P_Value_Err   ; bridge
SYSINIT:1CBC ; ---------------------------------------------------------------------------
SYSINIT:1CBC
SYSINIT:1CBC _$P_Value00:			     ; ...
SYSINIT:1CBC		     pop     bx		     ; restore control pointer
SYSINIT:1CBC					     ; here cx,dx = 32bit value
SYSINIT:1CBD		     test    cs:_$P_Flags2, 2 ;	_$P_Neg	; was it negative ?
SYSINIT:1CC3		     jz	     short _$P_Value01
SYSINIT:1CC5		     not     cx		     ; | Make 2's complement
SYSINIT:1CC7		     not     dx		     ; |
SYSINIT:1CC9		     add     dx, 1	     ; |
SYSINIT:1CCC		     adc     cx, 0	     ; |
SYSINIT:1CCF
SYSINIT:1CCF _$P_Value01:			     ; ...
SYSINIT:1CCF		     mov     si, es:[bx+6]   ; [es:bx+_$P_Control_Blk.Value_List]
SYSINIT:1CCF					     ; si points to value list
SYSINIT:1CD3		     mov     al, es:[si]     ; get nval
SYSINIT:1CD6		     cmp     al, 0	     ; _$P_nval_None ; no value	list ?
SYSINIT:1CD8		     jnz     short _$P_Value02
SYSINIT:1CDA		     mov     al, 1	     ; _$P_Number ; Set	type
SYSINIT:1CDC		     mov     ah, 0FFh	     ; _$P_No_Tag ; No ITEM_TAG	set
SYSINIT:1CDE		     jmp     short _$P_Value_Exit
SYSINIT:1CE0 ; ---------------------------------------------------------------------------
SYSINIT:1CE0		     nop		     ; 90h
SYSINIT:1CE1
SYSINIT:1CE1 _$P_Value02:			     ; ...
SYSINIT:1CE1		     inc     si
SYSINIT:1CE2		     mov     al, es:[si]     ; al = number of range
SYSINIT:1CE5		     cmp     al, 0	     ; _$P_No_nrng
SYSINIT:1CE7		     jz	     short _$P_Value_Err ; _$P_Value03
SYSINIT:1CE9		     inc     si		     ; si points to 1st	item_tag
SYSINIT:1CEA
SYSINIT:1CEA _$P_Val02_Loop:			     ; ...
SYSINIT:1CEA		     test    cs:_$P_Flags2, 80h	; _$P_Signed
SYSINIT:1CF0		     jnz     short _$P_Val02_Sign
SYSINIT:1CF2		     cmp     cx, es:[si+3]   ; [es:si+_$P_Val_List.Val_XH]
SYSINIT:1CF2					     ; comp cx with XH
SYSINIT:1CF6		     jb	     short _$P_Val02_Next
SYSINIT:1CF8		     ja	     short _$P_Val_In
SYSINIT:1CFA		     cmp     dx, es:[si+1]   ; [es:si+_$P_Val_List.Val_XL]
SYSINIT:1CFA					     ; comp dx with XL
SYSINIT:1CFE		     jb	     short _$P_Val02_Next
SYSINIT:1D00
SYSINIT:1D00 _$P_Val_In:			     ; ...
SYSINIT:1D00		     cmp     cx, es:[si+7]   ; [es:si+_$P_Val_List.Val_YH]
SYSINIT:1D00					     ; comp cx with YH
SYSINIT:1D04		     ja	     short _$P_Val02_Next
SYSINIT:1D06		     jb	     short _$P_Val_Found
SYSINIT:1D08		     cmp     dx, es:[si+5]   ; [es:si+_$P_Val_List.Val_YL]
SYSINIT:1D08					     ; comp dx with YL
SYSINIT:1D0C		     ja	     short _$P_Val02_Next
SYSINIT:1D0E		     jmp     short _$P_Val_Found
SYSINIT:1D10 ; ---------------------------------------------------------------------------
SYSINIT:1D10
SYSINIT:1D10 _$P_Val02_Sign:			     ; ...
SYSINIT:1D10		     cmp     cx, es:[si+3]   ; [es:si+_$P_Val_List.Val_XH]
SYSINIT:1D10					     ; comp cx with XH
SYSINIT:1D14		     jl	     short _$P_Val02_Next
SYSINIT:1D16		     jg	     short _$P_SVal_In
SYSINIT:1D18		     cmp     dx, es:[si+1]   ; [es:si+_$P_Val_List.Val_XL]
SYSINIT:1D18					     ; comp dx with XL
SYSINIT:1D1C		     jl	     short _$P_Val02_Next
SYSINIT:1D1E
SYSINIT:1D1E _$P_SVal_In:			     ; ...
SYSINIT:1D1E		     cmp     cx, es:[si+7]   ; [es:si+_$P_Val_List.Val_YH]
SYSINIT:1D1E					     ; comp cx with YH
SYSINIT:1D22		     jg	     short _$P_Val02_Next
SYSINIT:1D24		     jl	     short _$P_Val_Found
SYSINIT:1D26		     cmp     dx, es:[si+5]   ; [es:si+_$P_Val_List.Val_YL]
SYSINIT:1D26					     ; comp dx with YL
SYSINIT:1D2A		     jg	     short _$P_Val02_Next
SYSINIT:1D2C		     jmp     short _$P_Val_Found
SYSINIT:1D2E ; ---------------------------------------------------------------------------
SYSINIT:1D2E
SYSINIT:1D2E _$P_Val02_Next:			     ; ...
SYSINIT:1D2E		     add     si, 9	     ; _$P_Len_Range
SYSINIT:1D31		     dec     al		     ; loop nrng times in AL
SYSINIT:1D33		     jnz     short _$P_Val02_Loop
SYSINIT:1D35		     mov     cs:_$P_RC,	6    ; _$P_Out_Of_Range
SYSINIT:1D3C		     mov     al, 1	     ; _$P_Number
SYSINIT:1D3E		     mov     ah, 0FFh	     ; _$P_No_Tag
SYSINIT:1D40		     jmp     short _$P_Value_Exit
SYSINIT:1D42 ; ---------------------------------------------------------------------------
SYSINIT:1D42
SYSINIT:1D42 _$P_Val_Found:			     ; ...
SYSINIT:1D42		     mov     al, 1	     ; _$P_Number
SYSINIT:1D44		     mov     ah, es:[si]     ; found ITEM_TAG set
SYSINIT:1D47		     jmp     short _$P_Value_Exit
SYSINIT:1D49 ; ---------------------------------------------------------------------------
SYSINIT:1D49
SYSINIT:1D49 _$P_Value_Err:			     ; ...
SYSINIT:1D49		     mov     cs:_$P_RC,	9    ; _$P_Syntax
SYSINIT:1D50		     mov     al, 3	     ; _$P_String ; Set	type
SYSINIT:1D52		     mov     ah, 0FFh	     ; _$P_No_Tag ; No ITEM_TAG	set
SYSINIT:1D54
SYSINIT:1D54 _$P_Value_Exit:			     ; ...
SYSINIT:1D54		     call    _$P_Fill_Result
SYSINIT:1D57		     pop     si
SYSINIT:1D58		     pop     dx
SYSINIT:1D59		     pop     cx
SYSINIT:1D5A		     pop     ax
SYSINIT:1D5B		     retn
SYSINIT:1D5B _$P_Value	     endp
SYSINIT:1D5B
SYSINIT:1D5C
SYSINIT:1D5C ; =============== S U B R O U T I N E =======================================
SYSINIT:1D5C
SYSINIT:1D5C
SYSINIT:1D5C _$P_Check_OVF   proc near		     ; ...
SYSINIT:1D5C		     pushf
SYSINIT:1D5D		     test    cs:_$P_Flags2, 2 ;	_$P_Neg	; is it	negative value ?
SYSINIT:1D63		     jnz     short _$P_COVF
SYSINIT:1D65		     popf		     ; if no, check overflow by	the CY bit
SYSINIT:1D66		     retn
SYSINIT:1D67 ; ---------------------------------------------------------------------------
SYSINIT:1D67
SYSINIT:1D67 _$P_COVF:				     ; ...
SYSINIT:1D67		     popf		     ; else, check overflow by the OF
SYSINIT:1D68		     jo	     short _$P_COVF00
SYSINIT:1D6A		     clc		     ; indicate	it with	CY bit
SYSINIT:1D6A					     ; CY=0 means no overflow
SYSINIT:1D6B		     retn
SYSINIT:1D6C ; ---------------------------------------------------------------------------
SYSINIT:1D6C
SYSINIT:1D6C _$P_COVF00:			     ; ...
SYSINIT:1D6C		     stc		     ; and CY=1	means overflow
SYSINIT:1D6D		     retn
SYSINIT:1D6D _$P_Check_OVF   endp
SYSINIT:1D6D
SYSINIT:1D6E
SYSINIT:1D6E ; =============== S U B R O U T I N E =======================================
SYSINIT:1D6E
SYSINIT:1D6E
SYSINIT:1D6E _$P_0099	     proc near		     ; ...
SYSINIT:1D6E		     cmp     al, '0'         ; must be 0 =< al =< 9
SYSINIT:1D70		     jb	     short _$P_0099Err
SYSINIT:1D72		     cmp     al, '9'
SYSINIT:1D74		     ja	     short _$P_0099Err
SYSINIT:1D76		     sub     al, '0'         ; sub al,30h ; make char -> bin
SYSINIT:1D78		     clc		     ; indicate	no error
SYSINIT:1D78					     ; (clc is not required here, cf=0)
SYSINIT:1D79		     retn
SYSINIT:1D7A ; ---------------------------------------------------------------------------
SYSINIT:1D7A
SYSINIT:1D7A _$P_0099Err:			     ; ...
SYSINIT:1D7A		     stc
SYSINIT:1D7B		     retn
SYSINIT:1D7B _$P_0099	     endp
SYSINIT:1D7B
SYSINIT:1D7C
SYSINIT:1D7C ; =============== S U B R O U T I N E =======================================
SYSINIT:1D7C
SYSINIT:1D7C
SYSINIT:1D7C _$P_Simple_String proc near	     ; ...
SYSINIT:1D7C		     push    ax
SYSINIT:1D7D		     push    bx
SYSINIT:1D7E		     push    dx
SYSINIT:1D7F		     push    di
SYSINIT:1D80		     mov     di, es:[bx+6]   ; [es:bx+_$P_Control_Blk.Value_List]
SYSINIT:1D80					     ; di points to value list
SYSINIT:1D84		     mov     al, es:[di]     ; get nval
SYSINIT:1D87		     or	     al, al	     ; no value	list ?
SYSINIT:1D89		     jnz     short _$P_Sim00
SYSINIT:1D8B		     mov     ah, 0FFh	     ; _$P_No_Tag ; then, No ITEM_TAG set
SYSINIT:1D8D		     jmp     short _$P_Sim_Exit	; and set result buffer
SYSINIT:1D8F ; ---------------------------------------------------------------------------
SYSINIT:1D8F
SYSINIT:1D8F _$P_Sim00:				     ; ...
SYSINIT:1D8F		     cmp     al, 3	     ; Check if	keyword	or value list id #3 is supported
SYSINIT:1D8F					     ; _$P_nval_String ; String	choice list provided ?
SYSINIT:1D91		     jnz     short _$P_Sim01 ; if no, syntax error
SYSINIT:1D93		     inc     di
SYSINIT:1D94		     mov     al, es:[di]     ; al = nrng
SYSINIT:1D97		     mov     ah, 9	     ; _$P_Len_Range
SYSINIT:1D99		     mul     ah		     ; Skip nrng field
SYSINIT:1D9B		     inc     ax		     ; ax = (nrng*9)+1
SYSINIT:1D9C		     add     di, ax	     ; di points to nnval
SYSINIT:1D9E		     mov     al, es:[di]     ; get nnval
SYSINIT:1DA1		     mov     ah, 5	     ; _$P_Len_Value
SYSINIT:1DA3		     mul     ah		     ; skip nnval field
SYSINIT:1DA5		     inc     ax		     ; ax = (nnval*5)+1
SYSINIT:1DA6		     add     di, ax	     ; di points to nstrval
SYSINIT:1DA8		     mov     al, es:[di]     ; get nstrval c
SYSINIT:1DAB		     inc     di
SYSINIT:1DAC		     inc     di		     ; add '2' to di reg
SYSINIT:1DAC					     ; di points to 1st	string in list
SYSINIT:1DAD
SYSINIT:1DAD _$P_Sim_Loop:			     ; ...
SYSINIT:1DAD		     mov     bp, es:[di]     ; get string pointer
SYSINIT:1DB0		     call    _$P_String_Comp ; compare it with operand
SYSINIT:1DB3		     jnb     short _$P_Sim_Found ; found on list
SYSINIT:1DB5		     add     di, 3	     ; _$P_Len_String ;	if no, point to	next choice
SYSINIT:1DB8		     dec     al		     ; loop nstval times in AL
SYSINIT:1DBA		     jnz     short _$P_Sim_Loop
SYSINIT:1DBC		     mov     cs:_$P_RC,	8    ; / Not found ; _$P_Not_In_Str
SYSINIT:1DC3		     mov     ah, 0FFh	     ; _$P_No_Tag  ; No	ITEM_TAG set
SYSINIT:1DC5		     jmp     short _$P_Sim_Exit
SYSINIT:1DC7 ; ---------------------------------------------------------------------------
SYSINIT:1DC7
SYSINIT:1DC7 _$P_Sim_Found:			     ; ...
SYSINIT:1DC7		     mov     ah, es:[di-1]   ; set item_tag
SYSINIT:1DCB		     mov     al, 2	     ; _$P_List_Idx
SYSINIT:1DCD		     mov     dx, es:[di]     ; get address of STRING
SYSINIT:1DD0		     jmp     short _$P_Sim_Exit0
SYSINIT:1DD2 ; ---------------------------------------------------------------------------
SYSINIT:1DD2
SYSINIT:1DD2 _$P_Sim01:				     ; ...
SYSINIT:1DD2		     mov     cs:_$P_RC,	9    ; _$P_Syntax
SYSINIT:1DD9		     mov     ah, 0FFh	     ; _$P_No_Tag
SYSINIT:1DDB
SYSINIT:1DDB _$P_Sim_Exit:			     ; ...
SYSINIT:1DDB		     mov     al, 3	     ; _$P_String ; Set	type
SYSINIT:1DDD
SYSINIT:1DDD _$P_Sim_Exit0:			     ; ...
SYSINIT:1DDD		     call    _$P_Fill_Result
SYSINIT:1DE0		     pop     di
SYSINIT:1DE1		     pop     dx
SYSINIT:1DE2		     pop     bx
SYSINIT:1DE3		     pop     ax
SYSINIT:1DE4		     retn
SYSINIT:1DE4 _$P_Simple_String endp
SYSINIT:1DE4
SYSINIT:1DE5
SYSINIT:1DE5 ; =============== S U B R O U T I N E =======================================
SYSINIT:1DE5
SYSINIT:1DE5
SYSINIT:1DE5 _$P_String_Comp proc near		     ; ...
SYSINIT:1DE5		     push    ax
SYSINIT:1DE6		     push    bp
SYSINIT:1DE7		     push    dx
SYSINIT:1DE8		     push    si
SYSINIT:1DE9		     mov     dl, 2	     ; _$P_DOSTBL_Char ; use character case map	table
SYSINIT:1DEB
SYSINIT:1DEB _$P_SCOM_Loop:			     ; ...
SYSINIT:1DEB		     mov     al, cs:[si]     ; get command character
SYSINIT:1DEE		     call    _$P_Chk_DBCS    ; DBCS ?
SYSINIT:1DF1		     jb	     short _$P_SCOM00 ;	yes
SYSINIT:1DF3		     call    _$P_Do_CAPS_Char ;	else, upper case map before comparison
SYSINIT:1DF6		     test    cs:_$P_Flags2, 8 ;	Check if keyword or switch is supported
SYSINIT:1DF6					     ; _$P_Key_Cmp ; keyword search ?
SYSINIT:1DFC		     jz	     short _$P_SCOM04
SYSINIT:1DFE		     cmp     al, '='         ; _$P_Keyword  ; "=" is delimiter
SYSINIT:1E00		     jnz     short _$P_SCOM03 ;	IF "=" on command line AND
SYSINIT:1E00					     ; (bp+1=> char after the "=" in synonym list)
SYSINIT:1E02		     cmp     byte ptr es:[bp+1], 0 ; _$P_NULL ;	at end of keyword string
SYSINIT:1E02					     ;			in the control block THEN
SYSINIT:1E07		     jnz     short _$P_SCOM_Differ
SYSINIT:1E09		     jmp     short _$P_SCOM05 ;	keyword	found in synonym list
SYSINIT:1E0B ; ---------------------------------------------------------------------------
SYSINIT:1E0B
SYSINIT:1E0B _$P_SCOM04:			     ; ...
SYSINIT:1E0B		     test    cs:_$P_Flags2, 10h	; _$P_SW_Cmp ; switch search ?
SYSINIT:1E11		     jz	     short _$P_SCOM03
SYSINIT:1E13		     cmp     al, ':'         ; _$P_Colon ; ":" is delimiter,
SYSINIT:1E13					     ;		  at end of switch on command line
SYSINIT:1E15		     jnz     short _$P_SCOM03
SYSINIT:1E17		     cmp     byte ptr es:[bp+0], 0 ; _$P_NULL
SYSINIT:1E17					     ; IF at end of switch on command AND
SYSINIT:1E1C		     jnz     short _$P_SCOM_Differ ;
SYSINIT:1E1C					     ; at end of switch	string
SYSINIT:1E1C					     ; in the control block THEN
SYSINIT:1E1E
SYSINIT:1E1E _$P_SCOM05:			     ; ...
SYSINIT:1E1E		     inc     si		     ; found a match
SYSINIT:1E1E					     ; si points to just after "=" or ":"
SYSINIT:1E1F		     jmp     short _$P_SCOM_Same ; exit
SYSINIT:1E21 ; ---------------------------------------------------------------------------
SYSINIT:1E21
SYSINIT:1E21 _$P_SCOM03:			     ; ...
SYSINIT:1E21		     cmp     al, es:[bp+0]   ; compare operand w/ a synonym
SYSINIT:1E25		     jnz     short _$P_SCOM_Differ0 ; if different,
SYSINIT:1E25					     ; check ignore colon option
SYSINIT:1E27		     or	     al, al	     ; end of line ?
SYSINIT:1E29		     jz	     short _$P_SCOM_Same ; if so, exit
SYSINIT:1E2B		     inc     si		     ; update operand pointer
SYSINIT:1E2C		     inc     bp		     ; and synonym pointer
SYSINIT:1E2D		     jmp     short _$P_SCOM01 ;	loop until NULL	or "=" or ":"
SYSINIT:1E2D					     ;	found in case
SYSINIT:1E2F ; ---------------------------------------------------------------------------
SYSINIT:1E2F
SYSINIT:1E2F _$P_SCOM00:			     ; ...
SYSINIT:1E2F		     cmp     al, es:[bp+0]   ; Here al is DBCS leading byte
SYSINIT:1E2F					     ; compare leading byte
SYSINIT:1E33		     jnz     short _$P_SCOM_Differ ; if	not match, say different
SYSINIT:1E35		     inc     si		     ; else, load next byte
SYSINIT:1E36		     mov     al, cs:[si]
SYSINIT:1E39		     inc     bp
SYSINIT:1E3A		     cmp     al, es:[bp+0]   ; and compare 2nd byte
SYSINIT:1E3E		     jnz     short _$P_SCOM_Differ ; if	not match, say different, too
SYSINIT:1E40		     inc     si		     ; else update operand pointer
SYSINIT:1E41		     inc     bp		     ; and synonym pointer
SYSINIT:1E42
SYSINIT:1E42 _$P_SCOM01:			     ; ...
SYSINIT:1E42		     jmp     short _$P_SCOM_Loop ; loop	until NULL or "="
SYSINIT:1E42					     ; or "/" found in case
SYSINIT:1E44 ; ---------------------------------------------------------------------------
SYSINIT:1E44
SYSINIT:1E44 _$P_SCOM_Differ0:			     ; ...
SYSINIT:1E44		     test    cs:_$P_Flags2, 40h	; _$P_SW
SYSINIT:1E4A		     jz	     short _$P_not_applicable
SYSINIT:1E4C		     test    word ptr es:[bx+2], 20h ; [es:bx+_$P_Control_Blk.Function_Flag],
SYSINIT:1E4C					     ; _$P_colon_is_not_necessary
SYSINIT:1E52		     jz	     short _$P_not_applicable
SYSINIT:1E54		     cmp     byte ptr es:[bp+0], 0 ; _$P_NULL
SYSINIT:1E59		     jz	     short _$P_SCOM_Same
SYSINIT:1E5B
SYSINIT:1E5B _$P_not_applicable:		     ; ...
SYSINIT:1E5B		     test    word ptr es:[bx], 10h ; [es:bx+_$P_Control_Blk.Match_Flag],
SYSINIT:1E5B					     ; _$P_Ig_Colon
SYSINIT:1E5B					     ; ignore colon option specified ?
SYSINIT:1E60		     jz	     short _$P_SCOM_Differ
SYSINIT:1E62		     cmp     al, ':'         ; _$P_Colon ; End up with ":" and subseqently
SYSINIT:1E64		     jnz     short _$P_SCOM02
SYSINIT:1E66		     cmp     byte ptr es:[bp+0], 0 ; _$P_NULL ;	null ?
SYSINIT:1E6B		     jnz     short _$P_SCOM_Differ ; if	no, say	different
SYSINIT:1E6D		     jmp     short _$P_SCOM_Same ; else, say same
SYSINIT:1E6F ; ---------------------------------------------------------------------------
SYSINIT:1E6F
SYSINIT:1E6F _$P_SCOM02:			     ; ...
SYSINIT:1E6F		     cmp     al, 0	     ; _$P_NULL	; end up NULL and :
SYSINIT:1E71		     jnz     short _$P_SCOM_Differ
SYSINIT:1E73		     cmp     byte ptr es:[bp+0], ':' ; $P_Colon ; if no, say different
SYSINIT:1E78		     jz	     short _$P_SCOM_Same ; else, say same
SYSINIT:1E7A
SYSINIT:1E7A _$P_SCOM_Differ:			     ; ...
SYSINIT:1E7A		     stc		     ; indicate	not found
SYSINIT:1E7B		     jmp     short _$P_SCOM_Exit
SYSINIT:1E7D ; ---------------------------------------------------------------------------
SYSINIT:1E7D
SYSINIT:1E7D _$P_SCOM_Same:			     ; ...
SYSINIT:1E7D		     mov     cs:_$P_KEYorSW_Ptr, si ; for later	use by keyword or switch
SYSINIT:1E82		     clc		     ; indicate	found
SYSINIT:1E82					     ; (cf is already 0	here.. clc is not needed)
SYSINIT:1E83
SYSINIT:1E83 _$P_SCOM_Exit:			     ; ...
SYSINIT:1E83		     pop     si
SYSINIT:1E84		     pop     dx
SYSINIT:1E85		     pop     bp
SYSINIT:1E86		     pop     ax
SYSINIT:1E87		     retn
SYSINIT:1E87 _$P_String_Comp endp
SYSINIT:1E87
SYSINIT:1E88
SYSINIT:1E88 ; =============== S U B R O U T I N E =======================================
SYSINIT:1E88
SYSINIT:1E88
SYSINIT:1E88 _$P_File_Format proc near		     ; ...
SYSINIT:1E88		     push    ax
SYSINIT:1E89		     push    di
SYSINIT:1E8A		     push    si
SYSINIT:1E8B		     mov     di, cs:_$P_SaveSI_Cmpx ; get user buffer address
SYSINIT:1E90
SYSINIT:1E90 _$P_FileF_Loop0:			     ; / skip special characters
SYSINIT:1E90		     mov     al, cs:[si]     ; load character
SYSINIT:1E93		     or	     al, al	     ; end of line ?
SYSINIT:1E95		     jz	     short _$P_FileF_Err ; if yes, error exit
SYSINIT:1E97		     call    _$P_FileSp_Chk  ; else, check if file special character
SYSINIT:1E9A		     jnz     short _$P_FileF03
SYSINIT:1E9C		     mov     cs:_$P_err_flag, 1	; $P_error_filespec
SYSINIT:1E9C					     ; set error flag -	bad char.
SYSINIT:1EA2		     pop     si
SYSINIT:1EA3		     mov     byte ptr cs:[si], 0 ; _$P_NULL
SYSINIT:1EA7		     pop     di
SYSINIT:1EA8		     jmp     short _$P_FileF02
SYSINIT:1EAA ; ---------------------------------------------------------------------------
SYSINIT:1EAA
SYSINIT:1EAA _$P_FileF_Err:			     ; ...
SYSINIT:1EAA		     pop     si
SYSINIT:1EAB		     mov     byte ptr cs:[si], 0 ; _$P_NULL
SYSINIT:1EAF		     pop     di
SYSINIT:1EB0		     test    word ptr es:[bx], 1 ; [es:bx+_$P_Control_Blk.Match_Flag],
SYSINIT:1EB0					     ; _$P_Optional
SYSINIT:1EB5		     jnz     short _$P_FileF02
SYSINIT:1EB7		     mov     cs:_$P_RC,	2    ; _$P_Op_Missing
SYSINIT:1EBE		     jmp     short _$P_FileF02
SYSINIT:1EC0 ; ---------------------------------------------------------------------------
SYSINIT:1EC0
SYSINIT:1EC0 _$P_FileF03:			     ; ...
SYSINIT:1EC0		     pop     ax		     ; discard si on top of stack
SYSINIT:1EC1		     push    si		     ; save new	si
SYSINIT:1EC2
SYSINIT:1EC2 _$P_FileF_Loop1:			     ; ...
SYSINIT:1EC2		     mov     al, cs:[si]     ; load character (not special char)
SYSINIT:1EC5		     or	     al, al	     ; end of line ?
SYSINIT:1EC7		     jz	     short _$P_FileF_RLT
SYSINIT:1EC9		     call    _$P_FileSp_Chk  ; File special character ?
SYSINIT:1ECC		     jz	     short _$P_FileF00
SYSINIT:1ECE		     call    _$P_Chk_DBCS    ; no, then	DBCS ?
SYSINIT:1ED1		     jnb     short _$P_FileF01
SYSINIT:1ED3		     inc     di
SYSINIT:1ED4		     inc     si
SYSINIT:1ED5
SYSINIT:1ED5 _$P_FileF01:			     ; ...
SYSINIT:1ED5		     inc     di		     ; if yes, skip next byte
SYSINIT:1ED6		     inc     si
SYSINIT:1ED7		     jmp     short _$P_FileF_Loop1
SYSINIT:1ED9 ; ---------------------------------------------------------------------------
SYSINIT:1ED9
SYSINIT:1ED9 _$P_FileF00:			     ; ...
SYSINIT:1ED9		     mov     cs:_$P_Terminator,	al
SYSINIT:1EDD		     mov     byte ptr cs:[si], 0 ; _$P_NULL ; update end of string
SYSINIT:1EE1		     inc     di
SYSINIT:1EE2		     mov     cs:_$P_SI_Save, di	; update next pointer in command line
SYSINIT:1EE7
SYSINIT:1EE7 _$P_FileF_RLT:			     ; ...
SYSINIT:1EE7		     pop     si
SYSINIT:1EE8		     pop     di
SYSINIT:1EE9
SYSINIT:1EE9 _$P_FileF02:			     ; ...
SYSINIT:1EE9		     pop     ax
SYSINIT:1EEA		     test    ax, 200h	     ; _$P_File_Spc
SYSINIT:1EED		     jz	     short _$P_Drv_Only_Exit
SYSINIT:1EEF		     push    ax
SYSINIT:1EF0		     mov     ah, 0FFh	     ; _$P_No_Tag
SYSINIT:1EF2		     mov     al, 5	     ; _$P_File_Spec
SYSINIT:1EF4		     call    _$P_Fill_Result ; set result buffer to file spec
SYSINIT:1EF7		     pop     ax
SYSINIT:1EF8
SYSINIT:1EF8 _$P_Drv_Only_Exit:			     ; ...
SYSINIT:1EF8		     retn
SYSINIT:1EF8 _$P_File_Format endp
SYSINIT:1EF8
SYSINIT:1EF9
SYSINIT:1EF9 ; =============== S U B R O U T I N E =======================================
SYSINIT:1EF9
SYSINIT:1EF9
SYSINIT:1EF9 _$P_FileSp_Chk  proc near		     ; ...
SYSINIT:1EF9		     push    bx
SYSINIT:1EFA		     push    cx
SYSINIT:1EFB		     lea     bx, _$P_FileSp_Char ; "[]|<>+=;\""
SYSINIT:1EFF		     mov     cx, 9	     ; _$P_FileSp_Len
SYSINIT:1EFF					     ; load length of special character	table
SYSINIT:1EFF					     ; at SYSINIT:1838h	(for MSDOS 6.21	IO.SYS)
SYSINIT:1F02
SYSINIT:1F02 _$P_FileSp_Loop:			     ; ...
SYSINIT:1F02		     cmp     al, cs:[bx]     ; is it one of special character ?
SYSINIT:1F05		     jz	     short _$P_FileSp_Exit
SYSINIT:1F07		     inc     bx
SYSINIT:1F08		     loop    _$P_FileSp_Loop
SYSINIT:1F0A		     inc     cx		     ; reset ZF
SYSINIT:1F0B
SYSINIT:1F0B _$P_FileSp_Exit:			     ; ...
SYSINIT:1F0B		     pop     cx
SYSINIT:1F0C		     pop     bx
SYSINIT:1F0D		     retn
SYSINIT:1F0D _$P_FileSp_Chk  endp
SYSINIT:1F0D
SYSINIT:1F0E
SYSINIT:1F0E ; =============== S U B R O U T I N E =======================================
SYSINIT:1F0E
SYSINIT:1F0E
SYSINIT:1F0E _$P_Drive_Format proc near		     ; ...
SYSINIT:1F0E		     push    ax
SYSINIT:1F0F		     push    dx
SYSINIT:1F10		     mov     al, cs:[si]
SYSINIT:1F13		     or	     al, al	     ; if null string
SYSINIT:1F15		     jz	     short _$P_Drv_Exit	; do nothing
SYSINIT:1F17		     call    _$P_Chk_DBCS    ; is it leading byte ?
SYSINIT:1F1A		     jb	     short _$P_Drv_Err ; yes, error
SYSINIT:1F1C		     cmp     word ptr cs:[si+1], 3Ah ; ':' ; _$P_Colon
SYSINIT:1F1C					     ; "d", ":", 0 ?
SYSINIT:1F21		     jz	     short _$P_DrvF00
SYSINIT:1F23		     test    word ptr es:[bx], 10h ; [es:bx+_$P_Control_Blk.Match_Flag],
SYSINIT:1F23					     ; _$P_Ig_Colon
SYSINIT:1F23					     ; colon can be ignored?
SYSINIT:1F28		     jz	     short _$P_Drv_Err
SYSINIT:1F2A		     cmp     byte ptr cs:[si+1], 0 ; _$P_NULL ;	"d", 0 ?
SYSINIT:1F2F		     jnz     short _$P_Drv_Err
SYSINIT:1F31
SYSINIT:1F31 _$P_DrvF00:			     ; ...
SYSINIT:1F31		     or	     al, 20h	     ; _$P_Make_Lower ;	lower case
SYSINIT:1F33		     cmp     al, 61h ; 'a'   ; drive letter must
SYSINIT:1F35		     jb	     short _$P_Drv_Err ; in range of
SYSINIT:1F37		     cmp     al, 7Ah ; 'z'   ; "a"-"z"
SYSINIT:1F39		     ja	     short _$P_Drv_Err ; if no,	error
SYSINIT:1F3B		     sub     al, 60h	     ; "a"-1 ; make text drive to binary drive
SYSINIT:1F3D		     mov     dl, al
SYSINIT:1F3F		     mov     ah, 0FFh	     ; _$P_No_Tag
SYSINIT:1F41		     mov     al, 6	     ; _$P_Drive
SYSINIT:1F43		     call    _$P_Fill_Result ; set result buffer to drive
SYSINIT:1F46		     jmp     short _$P_Drv_Exit
SYSINIT:1F48 ; ---------------------------------------------------------------------------
SYSINIT:1F48
SYSINIT:1F48 _$P_Drv_Err:			     ; ...
SYSINIT:1F48		     mov     cs:_$P_RC,	9    ; _$P_Syntax
SYSINIT:1F4F
SYSINIT:1F4F _$P_Drv_Exit:			     ; ...
SYSINIT:1F4F		     pop     dx
SYSINIT:1F50		     pop     ax
SYSINIT:1F51		     retn
SYSINIT:1F51 _$P_Drive_Format endp
SYSINIT:1F51
SYSINIT:1F52
SYSINIT:1F52 ; =============== S U B R O U T I N E =======================================
SYSINIT:1F52
SYSINIT:1F52
SYSINIT:1F52 _$P_Skip_Delim  proc near		     ; ...
SYSINIT:1F52		     lodsb
SYSINIT:1F53		     call    _$P_Chk_EOL     ; is it EOL character ?
SYSINIT:1F56		     jz	     short _$P_Skip_Delim_CY ; if yes, exit w/ CY on
SYSINIT:1F58		     call    _$P_Chk_Delim   ; is it one of delimiters ?
SYSINIT:1F5B		     jnz     short _$P_Skip_Delim_NCY ;	if no, exit w/ CY off
SYSINIT:1F5D		     test    cs:_$P_Flags2, 20h	; _$P_Extra ; extra delim or comma found
SYSINIT:1F63		     jz	     short _$P_Skip_Delim ; _$P_Skip_Delim_Loop
SYSINIT:1F63					     ; if no, loop
SYSINIT:1F65		     test    cs:_$P_Flags2, 41h	; _$P_SW+_$P_equ ; /x ,	or xxx=zzz ,
SYSINIT:1F6B		     jz	     short _$P_Exit_At_Extra ; no switch, no keyword
SYSINIT:1F6D		     dec     si
SYSINIT:1F6E		     jmp     short _$P_Exit_At_Extra
SYSINIT:1F70 ; ---------------------------------------------------------------------------
SYSINIT:1F70
SYSINIT:1F70 _$P_Skip_Delim_CY:			     ; ...
SYSINIT:1F70		     stc		     ; indicate	EOL
SYSINIT:1F71		     jmp     short _$P_Skip_Delim_Exit
SYSINIT:1F73 ; ---------------------------------------------------------------------------
SYSINIT:1F73
SYSINIT:1F73 _$P_Skip_Delim_NCY:		     ; ...
SYSINIT:1F73		     clc		     ; indicate	non delim
SYSINIT:1F74
SYSINIT:1F74 _$P_Skip_Delim_Exit:		     ; ...
SYSINIT:1F74		     dec     si		     ; in this case, need backup index pointer
SYSINIT:1F75		     retn
SYSINIT:1F76 ; ---------------------------------------------------------------------------
SYSINIT:1F76
SYSINIT:1F76 _$P_Exit_At_Extra:			     ; ...
SYSINIT:1F76		     clc		     ; indicate	extra delim
SYSINIT:1F77		     retn
SYSINIT:1F77 _$P_Skip_Delim  endp
SYSINIT:1F77
SYSINIT:1F78
SYSINIT:1F78 ; =============== S U B R O U T I N E =======================================
SYSINIT:1F78
SYSINIT:1F78
SYSINIT:1F78 _$P_Chk_EOL     proc near		     ; ...
SYSINIT:1F78		     push    bx
SYSINIT:1F79		     push    cx
SYSINIT:1F7A		     cmp     al, 0Dh	     ; _$P_CR ;	Carriage return	?
SYSINIT:1F7C		     jz	     short _$P_Chk_EOL_Exit
SYSINIT:1F7E		     cmp     al, 0	     ; _$P_NULL	; zero ?
SYSINIT:1F80		     jz	     short _$P_Chk_EOL_Exit
SYSINIT:1F82		     cmp     al, 0Ah	     ; _$P_LF ;	Line feed ?
SYSINIT:1F84		     jz	     short _$P_Chk_EOL_Exit
SYSINIT:1F86		     cmp     byte ptr es:[di+2], 2 ; [es:di+_$P_PARMS_Blk.Num_Extra],
SYSINIT:1F86					     ; _$P_I_Have_EOL
SYSINIT:1F8B		     jb	     short _$P_Chk_EOL_Exit
SYSINIT:1F8D		     xor     bx, bx
SYSINIT:1F8F		     mov     bl, es:[di+3]   ; [es:di+_$P_PARMS_Blk.Len_Extra_Delim]
SYSINIT:1F8F					     ; get length of delimiter list
SYSINIT:1F93		     add     bx, 4	     ; _$P_Len_PARMS ; skip it
SYSINIT:1F96		     cmp     byte ptr es:[bx+di], 0 ; _$P_I_Use_Default
SYSINIT:1F96					     ; No extra	EOL character ?
SYSINIT:1F9A		     jz	     short _$P_Chk_EOL_NZ
SYSINIT:1F9C		     xor     cx, cx	     ; Get number of extra character
SYSINIT:1F9E		     mov     cl, es:[bx+di]
SYSINIT:1FA1
SYSINIT:1FA1 _$P_Chk_EOL_Loop:			     ; ...
SYSINIT:1FA1		     inc     bx
SYSINIT:1FA2		     cmp     al, es:[bx+di]  ; Check extra EOL character
SYSINIT:1FA5		     jz	     short _$P_Chk_EOL_Exit
SYSINIT:1FA7		     loop    _$P_Chk_EOL_Loop
SYSINIT:1FA9
SYSINIT:1FA9 _$P_Chk_EOL_NZ:			     ; ...
SYSINIT:1FA9		     cmp     al, 0Dh	     ; _$P_CR ;	reset ZF
SYSINIT:1FAB
SYSINIT:1FAB _$P_Chk_EOL_Exit:			     ; ...
SYSINIT:1FAB		     pop     cx
SYSINIT:1FAC		     pop     bx
SYSINIT:1FAD		     retn
SYSINIT:1FAD _$P_Chk_EOL     endp
SYSINIT:1FAD
SYSINIT:1FAE
SYSINIT:1FAE ; =============== S U B R O U T I N E =======================================
SYSINIT:1FAE
SYSINIT:1FAE
SYSINIT:1FAE _$P_Chk_Delim   proc near		     ; ...
SYSINIT:1FAE		     push    bx
SYSINIT:1FAF		     push    cx
SYSINIT:1FB0		     mov     cs:_$P_Terminator,	20h ; ' ' ; _$P_Space
SYSINIT:1FB0					     ; assume terminated by space
SYSINIT:1FB6		     and     cs:_$P_Flags2, 0DFh ; 0FFh-_$P_Extra ; ~$P_Extra ;	~20h
SYSINIT:1FBC		     cmp     al, 20h ; ' '   ; _$P_Space ; Space ?
SYSINIT:1FBE		     jz	     short _$P_Chk_Delim_Exit
SYSINIT:1FC0		     cmp     al, 9	     ; _$P_TAB ; TAB ?
SYSINIT:1FC2		     jz	     short _$P_Chk_Delim_Exit
SYSINIT:1FC4		     cmp     al, 2Ch ; ','   ; _$P_Comma ; Comma ?
SYSINIT:1FC6		     jz	     short _$P_Chk_Delim_Exit0
SYSINIT:1FC8
SYSINIT:1FC8 _$P_Chk_Delim00:			     ; Note: _$P_Chk_Delim00 part of code is nonsense
SYSINIT:1FC8		     cmp     al, 20h ; ' '   ;       here because _$P_Space = _$P_DBSP1 = 20h
SYSINIT:1FC8					     ;	     Erdogan Tan - 08/07/2023
SYSINIT:1FC8					     ;
SYSINIT:1FC8					     ; _$P_DBSP1 ; 1st byte of DBCS Space ?
SYSINIT:1FCA		     jnz     short $P_Chk_Delim01
SYSINIT:1FCC		     cmp     byte ptr [si], 20h	; ' ' ; _$P_DBSP2 ; 2nd byte of DBCS Space ?
SYSINIT:1FCF		     jnz     short $P_Chk_Delim01
SYSINIT:1FD1		     mov     al, 20h ; ' '   ; _$P_Space
SYSINIT:1FD3		     inc     si		     ; make si point to	next character
SYSINIT:1FD4		     cmp     al, al	     ; Set ZF
SYSINIT:1FD6		     jmp     short _$P_Chk_Delim_Exit
SYSINIT:1FD8 ; ---------------------------------------------------------------------------
SYSINIT:1FD8
SYSINIT:1FD8 $P_Chk_Delim01:			     ; ...
SYSINIT:1FD8		     cmp     byte ptr es:[di+2], 1 ; [es:di-_$P_PARMS_Blk.Num_Extra],
SYSINIT:1FD8					     ; _$P_I_Have_Delim
SYSINIT:1FD8					     ; delimiter character specified ?
SYSINIT:1FDD		     jb	     short _$P_Chk_Delim_Exit ;	no
SYSINIT:1FDF		     xor     cx, cx
SYSINIT:1FE1		     mov     cl, es:[di+3]   ; [es:di+_$P_PARMS_Blk.Len_Extra_Delim]
SYSINIT:1FE1					     ; get length of delimiter list
SYSINIT:1FE5		     or	     cx, cx
SYSINIT:1FE7		     jz	     short _$P_Chk_Delim_NZ ; no extra delim character
SYSINIT:1FE9		     mov     bx, 3	     ; _$P_Len_PARMS-1
SYSINIT:1FE9					     ; set bx to 1st extra delimiter
SYSINIT:1FEC
SYSINIT:1FEC _$P_Chk_Delim_Loop:		     ; ...
SYSINIT:1FEC		     inc     bx
SYSINIT:1FED		     cmp     al, es:[bx+di]  ; check extra delim character
SYSINIT:1FF0		     jz	     short _$P_Chk_Delim_Exit0
SYSINIT:1FF2		     loop    _$P_Chk_Delim_Loop	; examine all extra delimiter
SYSINIT:1FF4
SYSINIT:1FF4 _$P_Chk_Delim_NZ:			     ; ...
SYSINIT:1FF4		     cmp     al, 20h ; ' '   ; _$P_Space ; reset ZF
SYSINIT:1FF6
SYSINIT:1FF6 _$P_Chk_Delim_Exit:		     ; ...
SYSINIT:1FF6		     pop     cx
SYSINIT:1FF7		     pop     bx
SYSINIT:1FF8		     retn
SYSINIT:1FF9 ; ---------------------------------------------------------------------------
SYSINIT:1FF9
SYSINIT:1FF9 _$P_Chk_Delim_Exit0:		     ; ...
SYSINIT:1FF9		     mov     cs:_$P_Terminator,	al ; keep terminated delimiter
SYSINIT:1FFD		     test    cs:_$P_Flags2, 1 ;	_$P_equ	; if terminating a key=
SYSINIT:2003		     jnz     short _$P_No_Set_Extra ; then do not set the EXTRA	bit
SYSINIT:2005		     or	     cs:_$P_Flags2, 20h	; _$P_Extra
SYSINIT:2005					     ; flag terminated extra delim or comma
SYSINIT:200B
SYSINIT:200B _$P_No_Set_Extra:			     ; ...
SYSINIT:200B		     cmp     al, al	     ; set ZF
SYSINIT:200D		     jmp     short _$P_Chk_Delim_Exit
SYSINIT:200D _$P_Chk_Delim   endp
SYSINIT:200D
SYSINIT:200F
SYSINIT:200F ; =============== S U B R O U T I N E =======================================
SYSINIT:200F
SYSINIT:200F
SYSINIT:200F _$P_Chk_Switch  proc near		     ; ...
SYSINIT:200F		     lea     bp, _$P_STRING_BUF	; BP = Offset of _$P_String_Buf
SYSINIT:200F					     ; (mov bp,	offset _$P_STRING_BUF)
SYSINIT:2013		     cmp     bx, bp	     ; IF not first char THEN
SYSINIT:2015		     jz	     short _$P_STRUC_L2
SYSINIT:2017		     cmp     al, 2Fh ; '/'   ; _$P_Switch ; see if a slash
SYSINIT:2019		     jnz     short _$P_STRUC_L5
SYSINIT:201B		     stc		     ; not in first position and is slash
SYSINIT:201C		     jmp     short _$P_STRUC_L1
SYSINIT:201E ; ---------------------------------------------------------------------------
SYSINIT:201E
SYSINIT:201E _$P_STRUC_L5:			     ; ...
SYSINIT:201E		     clc
SYSINIT:201F		     jmp     short _$P_STRUC_L1
SYSINIT:2021 ; ---------------------------------------------------------------------------
SYSINIT:2021
SYSINIT:2021 _$P_STRUC_L2:			     ; ...
SYSINIT:2021		     cmp     al, 2Fh ; '/'   ; _$P_Switch
SYSINIT:2023		     jnz     short _$P_STRUC_L12 ; not a slash
SYSINIT:2025		     or	     cs:_$P_Flags2, 40h	; _$P_SW
SYSINIT:2025					     ; could be	valid switch,
SYSINIT:2025					     ; first char and is slash
SYSINIT:202B
SYSINIT:202B _$P_STRUC_L12:			     ; ...
SYSINIT:202B		     clc		     ; is first	char in	the buffer, ZF=0
SYSINIT:202B					     ; (CF=0 indicating	first char)
SYSINIT:202C
SYSINIT:202C _$P_STRUC_L1:			     ; ...
SYSINIT:202C		     retn
SYSINIT:202C _$P_Chk_Switch  endp
SYSINIT:202C
SYSINIT:202D
SYSINIT:202D ; =============== S U B R O U T I N E =======================================
SYSINIT:202D
SYSINIT:202D
SYSINIT:202D _$P_Chk_DBCS    proc near		     ; ...
SYSINIT:202D		     push    ds
SYSINIT:202E		     push    si
SYSINIT:202F		     push    bx
SYSINIT:2030		     cmp     cs:_$P_DBCSEV_SEG,	0 ; already set	?
SYSINIT:2036		     jnz     short _$P_DBCS00 ;	yes
SYSINIT:2038		     push    ax
SYSINIT:2039		     push    ds
SYSINIT:203A		     push    cx
SYSINIT:203B		     push    dx
SYSINIT:203C		     push    di
SYSINIT:203D		     push    bp
SYSINIT:203E		     push    es
SYSINIT:203F		     xor     si, si
SYSINIT:2041		     mov     ds, si
SYSINIT:2043		     assume ds:nothing
SYSINIT:2043		     mov     ax, 6300h	     ; _$P_DOS_GetEV ; GET DBCS	EV CALL
SYSINIT:2046		     int     21h	     ; DOS - 3.2+ only
SYSINIT:2046					     ; GET DOUBLE BYTE CHARACTER SET LEAD TABLE
SYSINIT:2048		     mov     bx, ds
SYSINIT:204A		     or	     bx, bx
SYSINIT:204C		     pop     es
SYSINIT:204D		     pop     bp
SYSINIT:204E		     pop     di
SYSINIT:204F		     pop     dx
SYSINIT:2050		     pop     cx
SYSINIT:2051		     pop     ds
SYSINIT:2052		     assume ds:nothing
SYSINIT:2052		     pop     ax
SYSINIT:2053		     jz	     short _$P_NON_DBCS
SYSINIT:2055		     mov     cs:_$P_DBCSEV_OFF,	si ; save EV offset
SYSINIT:205A		     mov     cs:_$P_DBCSEV_SEG,	bx ; save EV segment
SYSINIT:205F
SYSINIT:205F _$P_DBCS00:			     ; ...
SYSINIT:205F		     mov     si, cs:_$P_DBCSEV_OFF ; load EV offset and	segment
SYSINIT:2064		     mov     ds, cs:_$P_DBCSEV_SEG
SYSINIT:2069
SYSINIT:2069 _$P_DBCS_LOOP:			     ; ...
SYSINIT:2069		     cmp     word ptr [si], 0 ;	zero vector ?
SYSINIT:206C		     jz	     short _$P_NON_DBCS	; then exit
SYSINIT:206E		     cmp     al, [si]	     ; Check if	AL is in range of the vector
SYSINIT:2070		     jb	     short $P_DBCS01
SYSINIT:2072		     cmp     al, [si+1]
SYSINIT:2075		     ja	     short $P_DBCS01
SYSINIT:2077		     stc		     ; if yes, indicate	DBCS and exit
SYSINIT:2078		     jmp     short _$P_DBCS_EXIT
SYSINIT:207A ; ---------------------------------------------------------------------------
SYSINIT:207A
SYSINIT:207A $P_DBCS01:				     ; ...
SYSINIT:207A		     inc     si		     ; add 2 to	si reg
SYSINIT:207B		     inc     si		     ; get next	vector
SYSINIT:207C		     jmp     short _$P_DBCS_LOOP ; loop	until zero vector found
SYSINIT:207E ; ---------------------------------------------------------------------------
SYSINIT:207E
SYSINIT:207E _$P_NON_DBCS:			     ; ...
SYSINIT:207E		     clc		     ; indicate	SBCS
SYSINIT:207E					     ; (note: cf is already 0 here)
SYSINIT:207F
SYSINIT:207F _$P_DBCS_EXIT:			     ; ...
SYSINIT:207F		     pop     bx
SYSINIT:2080		     pop     si
SYSINIT:2081		     pop     ds
SYSINIT:2082		     retn
SYSINIT:2082 _$P_Chk_DBCS    endp
SYSINIT:2082
SYSINIT:2082 ; ---------------------------------------------------------------------------
SYSINIT:2083 buf_parms	     dw	offset buf_parmsx    ; ...
SYSINIT:2083					     ; buffer =	[n | n,m] {/e}
SYSINIT:2085		     db	1		     ; an extra	delimiter list
SYSINIT:2086		     db	1		     ; length is 1
SYSINIT:2087		     db	';'                  ; delimiter
SYSINIT:2088 buf_parmsx	     db	1		     ; ...
SYSINIT:2089		     db	2		     ; min 1, max 2 positionals
SYSINIT:208A		     dw	offset buf_pos1
SYSINIT:208C		     dw	offset buf_pos2
SYSINIT:208E		     db	1		     ; one switch
SYSINIT:208F		     dw	offset sw_x_ctrl
SYSINIT:2091		     db	0		     ; no keywords
SYSINIT:2091					     ;
SYSINIT:2091					     ; buf_pos1	p_pos <8000h,0,result_val,buf_range_1>
SYSINIT:2091					     ; numeric
SYSINIT:2092 buf_pos1	     dw	8000h		     ; ...
SYSINIT:2092					     ; match_flags - numeric value
SYSINIT:2094		     dw	0		     ; function	flags
SYSINIT:2096		     dw	offset result_val    ; result value buffer
SYSINIT:2098		     dw	offset buf_range_1   ; value list
SYSINIT:209A		     db	0		     ; no switches/keywords
SYSINIT:209B buf_range_1     db	1		     ; ...
SYSINIT:209B					     ; range definition
SYSINIT:209C		     db	1		     ; 1 definition of range
SYSINIT:209D		     db	1		     ; item tag	for this range
SYSINIT:209E		     dd	1		     ; numeric min
SYSINIT:20A2		     dd	99		     ; numeric max
SYSINIT:20A2					     ;
SYSINIT:20A2					     ; buf_pos2	p_pos <8001h,0,result_val,buf_range_2>
SYSINIT:20A2					     ; optional	num.
SYSINIT:20A6 buf_pos2	     dw	8001h		     ; ...
SYSINIT:20A8		     dw	0
SYSINIT:20AA		     dw	offset result_val
SYSINIT:20AC		     dw	offset buf_range_2
SYSINIT:20AE		     db	0		     ;
SYSINIT:20AE					     ; buf_range_2 p_range <,,,0,8>
SYSINIT:20AF buf_range_2     db	1		     ; ...
SYSINIT:20B0		     db	1
SYSINIT:20B1		     db	1
SYSINIT:20B2		     dd	0
SYSINIT:20B6		     dd	8		     ;
SYSINIT:20B6					     ; sw_x_ctrl p_pos <0,0,result_val,noval,1>
SYSINIT:20B6					     ; followed	by one switch
SYSINIT:20BA sw_x_ctrl	     dw	0		     ; ...
SYSINIT:20BC		     dw	0
SYSINIT:20BE		     dw	offset result_val
SYSINIT:20C0		     dw	offset noval
SYSINIT:20C2		     db	1		     ; 1 switch
SYSINIT:20C3 switch_x	     db	'/X',0               ; ...
SYSINIT:20C6 p_buffers	     dw	0		     ; ...
SYSINIT:20C8 p_h_buffers     dw	0		     ; ...
SYSINIT:20CA p_buffer_slash_x db 0		     ; ...
SYSINIT:20CA					     ;
SYSINIT:20CA					     ; common definitions
SYSINIT:20CB noval	     db	0		     ; ...
SYSINIT:20CC result_val	     db	0		     ; ...
SYSINIT:20CC					     ; type returned
SYSINIT:20CD result_val_itag db	0		     ; ...
SYSINIT:20CD					     ; item tag	returned
SYSINIT:20CE result_val_swoff dw 0		     ; ...
SYSINIT:20CE					     ; es:offset of the	switch defined
SYSINIT:20D0 rv_dword	     dd	0		     ; ...
SYSINIT:20D0					     ; rv_byte
SYSINIT:20D0					     ; value if	number,	or seg:offset to string.
SYSINIT:20D0					     ; ;;
SYSINIT:20D4 brk_parms	     dw	offset brk_parmsx    ; ...
SYSINIT:20D4					     ; break = [ on | off ]
SYSINIT:20D6		     db	1		     ; an extra	delimiter list
SYSINIT:20D7		     db	1		     ; length is 1
SYSINIT:20D8		     db	';'                  ; delimiter
SYSINIT:20D9 brk_parmsx	     db	1		     ; ...
SYSINIT:20DA		     db	1		     ; min,max = 1 positional
SYSINIT:20DB		     dw	offset brk_pos
SYSINIT:20DD		     db	0		     ; no switches
SYSINIT:20DE		     db	0		     ; no keywords
SYSINIT:20DE					     ;
SYSINIT:20DE					     ; brk_pos p_pos <2000h,0,result_val,on_off_string>
SYSINIT:20DE					     ; simple string
SYSINIT:20DF brk_pos	     dw	2000h		     ; ...
SYSINIT:20E1		     dw	0
SYSINIT:20E3		     dw	offset result_val
SYSINIT:20E5		     dw	offset on_off_string
SYSINIT:20E7		     db	0
SYSINIT:20E8 on_off_string   db	3		     ; ...
SYSINIT:20E8					     ; signals that there is a string choice
SYSINIT:20E9		     db	0		     ; no range	definition
SYSINIT:20EA		     db	0		     ; no numeric values choice
SYSINIT:20EB		     db	2		     ; 2 strings for choice
SYSINIT:20EC		     db	1		     ; the 1st string tag
SYSINIT:20ED		     dw	offset _on_string    ; "ON"
SYSINIT:20EF		     db	2		     ; the 2nd string tag
SYSINIT:20F0		     dw	offset _off_string   ; "OFF"
SYSINIT:20F2 _on_string	     db	'ON',0               ; ...
SYSINIT:20F5 _off_string     db	'OFF',0              ; ...
SYSINIT:20F9 p_ctrl_break    db	0		     ; ...
SYSINIT:20F9					     ; local variable
SYSINIT:20F9					     ; ;;
SYSINIT:20FA cntry_parms     dw	offset cntry_parmsx  ; ...
SYSINIT:20FA					     ; country = n {m {path}}
SYSINIT:20FA					     ; or country = n,,path
SYSINIT:20FC		     db	1
SYSINIT:20FD		     db	1
SYSINIT:20FE		     db	';'
SYSINIT:20FF cntry_parmsx    db	1		     ; ...
SYSINIT:20FF					     ; min 1, max 3 pos.
SYSINIT:2100		     db	3
SYSINIT:2101		     dw	offset cntry_pos1
SYSINIT:2103		     dw	offset cntry_pos2
SYSINIT:2105		     dw	offset cntry_pos3
SYSINIT:2107		     db	0		     ; no switches
SYSINIT:2108		     db	0		     ; no keywords
SYSINIT:2109 cntry_pos1	     dw	8000h		     ; ...
SYSINIT:2109					     ; cntry_pos1 p_pos	<8000h,0,result_val,cc_range>
SYSINIT:2109					     ; numeric value
SYSINIT:210B		     dw	0
SYSINIT:210D		     dw	offset result_val
SYSINIT:210F		     dw	offset cc_range
SYSINIT:2111		     db	0
SYSINIT:2112 cc_range	     db	1		     ; ...
SYSINIT:2112					     ; cc_range	p_range	<,,,1,999>
SYSINIT:2113		     db	1
SYSINIT:2114		     db	1
SYSINIT:2115		     dd	1
SYSINIT:2119		     dd	999
SYSINIT:211D cntry_pos2	     dw	8001h		     ; ...
SYSINIT:211D					     ; cntry_pos2 p_pos	<8001h,0,result_val,cc_range>
SYSINIT:211D					     ; optional	num.
SYSINIT:211F		     dw	0
SYSINIT:2121		     dw	offset result_val
SYSINIT:2123		     dw	offset cc_range
SYSINIT:2125		     db	0
SYSINIT:2126 cntry_pos3	     dw	201h		     ; ...
SYSINIT:2126					     ; cntry_pos3 p_pos	<201h,0,result_val,noval>
SYSINIT:2126					     ; optional	filespec
SYSINIT:2128		     dw	0
SYSINIT:212A		     dw	offset result_val
SYSINIT:212C		     dw	offset noval
SYSINIT:212E		     db	0
SYSINIT:212F p_cntry_code    dw	0		     ; ...
SYSINIT:212F					     ; local variable
SYSINIT:2131 p_code_page     dw	0		     ; ...
SYSINIT:2131					     ; local variable
SYSINIT:2131					     ; ;;
SYSINIT:2133 files_parms     dw	offset files_parmsx  ; ...
SYSINIT:2133					     ; files = n
SYSINIT:2135		     db	1
SYSINIT:2136		     db	1
SYSINIT:2137		     db	';'
SYSINIT:2138 files_parmsx    db	1		     ; ...
SYSINIT:2139		     db	1		     ; min,max 1 positional
SYSINIT:213A		     dw	offset files_pos
SYSINIT:213C		     db	0		     ; no switches
SYSINIT:213D		     db	0		     ; no keywords
SYSINIT:213E files_pos	     dw	8000h		     ; ...
SYSINIT:213E					     ; files_pos p_pos <8000h,0,result_val,files_range,0>
SYSINIT:213E					     ; numeric value
SYSINIT:2140		     dw	0
SYSINIT:2142		     dw	offset result_val
SYSINIT:2144		     dw	offset files_range
SYSINIT:2146		     db	0
SYSINIT:2147 files_range     db	1		     ; ...
SYSINIT:2147					     ; files_range p_range <,,,8,255>
SYSINIT:2148		     db	1
SYSINIT:2149		     db	1
SYSINIT:214A		     dd	8
SYSINIT:214E		     dd	255
SYSINIT:2152 p_files	     db	0		     ; ...
SYSINIT:2152					     ; local variable
SYSINIT:2152					     ; ;;
SYSINIT:2153 fcbs_parms	     dw	offset fcbs_parmsx   ; fcbs = n,m
SYSINIT:2155		     db	1
SYSINIT:2156		     db	1
SYSINIT:2157		     db	';'
SYSINIT:2158 fcbs_parmsx     db	1		     ; ...
SYSINIT:2159		     db	2
SYSINIT:215A		     dw	offset fcbs_pos_1
SYSINIT:215C		     dw	offset fcbs_pos_2
SYSINIT:215E		     db	0		     ; no switches
SYSINIT:215F		     db	0		     ; no keywords
SYSINIT:2160 fcbs_pos_1	     dw	8000h		     ; ...
SYSINIT:2160					     ; fcbs_pos_1 p_pos	<8000h,0,result_val,fcbs_range>
SYSINIT:2160					     ; numeric value
SYSINIT:2162		     dw	0
SYSINIT:2164		     dw	offset result_val
SYSINIT:2166		     dw	offset fcbs_range
SYSINIT:2168		     db	0
SYSINIT:2169 fcbs_range	     db	1		     ; ...
SYSINIT:2169					     ; fcbs_range p_range <,,,1,255>
SYSINIT:216A		     db	1
SYSINIT:216B		     db	1
SYSINIT:216C		     dd	1
SYSINIT:2170		     dd	255
SYSINIT:2174 fcbs_pos_2	     dw	8000h		     ; ...
SYSINIT:2174					     ; fcbs_pos_2 p_pos	<8000h,0,result_val,fcbs_keep_range>
SYSINIT:2174					     ; numeric value
SYSINIT:2176		     dw	0
SYSINIT:2178		     dw	offset result_val
SYSINIT:217A		     dw	offset fcbs_keep_range
SYSINIT:217C		     db	0
SYSINIT:217D fcbs_keep_range db	1		     ; ...
SYSINIT:217D					     ; fcbs_keep_range p_range <,,,0,255>
SYSINIT:217E		     db	1
SYSINIT:217F		     db	1
SYSINIT:2180		     dd	0
SYSINIT:2184		     dd	255
SYSINIT:2188 p_fcbs	     db	0		     ; ...
SYSINIT:2188					     ; local variable
SYSINIT:2189 p_keep	     db	0		     ; ...
SYSINIT:2189					     ; local variable
SYSINIT:2189					     ; ;;
SYSINIT:218A ldrv_parms	     dw	offset ldrv_parmsx   ; ...
SYSINIT:218A					     ; lastdrive = x
SYSINIT:218C		     db	1
SYSINIT:218D		     db	1
SYSINIT:218E		     db	';'
SYSINIT:218F ldrv_parmsx     db	1		     ; ...
SYSINIT:2190		     db	1		     ; min,max = 1 positional
SYSINIT:2191		     dw	offset ldrv_pos
SYSINIT:2193		     db	0		     ; no switches
SYSINIT:2194		     db	0		     ; no keywords
SYSINIT:2195 ldrv_pos	     dw	110h		     ; ...
SYSINIT:2195					     ; ldrv_pos	p_pos <110h,10h,result_val,noval>
SYSINIT:2195					     ; drive only, ignore colon	at end
SYSINIT:2197		     dw	10h
SYSINIT:2199		     dw	offset result_val
SYSINIT:219B		     dw	offset noval
SYSINIT:219D		     db	0
SYSINIT:219E p_ldrv	     db	0		     ; ...
SYSINIT:219E					     ; local variable
SYSINIT:219E					     ; ;;
SYSINIT:219F stks_parms	     dw	offset stks_parmsx   ; ...
SYSINIT:219F					     ; stacks =	n,m
SYSINIT:21A1		     db	1
SYSINIT:21A2		     db	1
SYSINIT:21A3		     db	';'
SYSINIT:21A4 stks_parmsx     db	2		     ; ...
SYSINIT:21A5		     db	2		     ; min,max = 2 positionals
SYSINIT:21A6		     dw	offset stks_pos_1
SYSINIT:21A8		     dw	offset stks_pos_2
SYSINIT:21AA		     db	0		     ; no switches
SYSINIT:21AB		     db	0		     ; no keywords
SYSINIT:21AC stks_pos_1	     dw	8000h		     ; ...
SYSINIT:21AC					     ; stks_pos_1 p_pos	<8000h,0,result_val,stks_range>
SYSINIT:21AC					     ; numeric value
SYSINIT:21AE		     dw	0
SYSINIT:21B0		     dw	offset result_val
SYSINIT:21B2		     dw	offset stks_range
SYSINIT:21B4		     db	0
SYSINIT:21B5 stks_range	     db	1		     ; ...
SYSINIT:21B5					     ; stks_range p_range <,,,0,64>
SYSINIT:21B6		     db	1
SYSINIT:21B7		     db	1
SYSINIT:21B8		     dd	0
SYSINIT:21BC		     dd	64
SYSINIT:21C0 stks_pos_2	     dw	8000h		     ; ...
SYSINIT:21C0					     ; stks_pos_2 p_pos	<8000h,0,result_val,stk_size_range>
SYSINIT:21C0					     ; numeric value
SYSINIT:21C2		     dw	0
SYSINIT:21C4		     dw	offset result_val
SYSINIT:21C6		     dw	offset stk_size_range
SYSINIT:21C8		     db	0
SYSINIT:21C9 stk_size_range  db	1		     ; ...
SYSINIT:21C9					     ; stk_size_range p_range <,,,0,512>
SYSINIT:21CA		     db	1
SYSINIT:21CB		     db	1
SYSINIT:21CC		     dd	0
SYSINIT:21D0		     dd	512
SYSINIT:21D4 p_stack_count   dw	0		     ; ...
SYSINIT:21D4					     ; local variable
SYSINIT:21D6 p_stack_size    dw	0		     ; ...
SYSINIT:21D6					     ; local variable
SYSINIT:21D6					     ; ;;
SYSINIT:21D8 mtrk_parms	     dw	offset mtrk_parmsx   ; ...
SYSINIT:21D8					     ; multitrack = [ on | off ]
SYSINIT:21DA		     db	1
SYSINIT:21DB		     db	1
SYSINIT:21DC		     db	';'
SYSINIT:21DD mtrk_parmsx     db	1		     ; ...
SYSINIT:21DD					     ; min,max = 1 positional
SYSINIT:21DE		     db	1
SYSINIT:21DF		     dw	offset mtrk_pos
SYSINIT:21E1		     db	0		     ; no switches
SYSINIT:21E2		     db	0		     ; no keywords
SYSINIT:21E3 mtrk_pos	     dw	2000h		     ; ...
SYSINIT:21E3					     ; mtrk_pos	p_pos <2000h,0,result_val,on_off_string>
SYSINIT:21E3					     ; simple string
SYSINIT:21E5		     dw	0
SYSINIT:21E7		     dw	offset result_val
SYSINIT:21E9		     dw	offset on_off_string
SYSINIT:21EB		     db	0
SYSINIT:21EC p_mtrk	     db	0		     ; ...
SYSINIT:21EC					     ; local variable
SYSINIT:21EC					     ; ;;
SYSINIT:21ED swit_parms	     dw	offset swit_parmsx   ; ...
SYSINIT:21ED					     ; switches=/k
SYSINIT:21EF		     db	1
SYSINIT:21F0		     db	1
SYSINIT:21F1		     db	';'
SYSINIT:21F2 swit_parmsx     dw	0		     ; ...
SYSINIT:21F2					     ; no positionals
SYSINIT:21F4		     db	5		     ; # of switches
SYSINIT:21F5		     dw	offset swit_k_ctrl   ; /k control
SYSINIT:21F7		     dw	offset swit_n_ctrl   ; /n control (for MULTI_CONFIG only)
SYSINIT:21F9		     dw	offset swit_f_ctrl   ; /f control (for MULTI_CONFIG only)
SYSINIT:21FB		     dw	offset swit_t_ctrl   ; /t control
SYSINIT:21FD		     dw	offset swit_w_ctrl   ; /w control
SYSINIT:21FF		     db	0		     ; no keywords
SYSINIT:2200 swit_k_ctrl     dw	0		     ; ...
SYSINIT:2200					     ; swit_k_ctrl p_pos <0,0,result_val,noval,1>
SYSINIT:2200					     ; switch string follows
SYSINIT:2202		     dw	0
SYSINIT:2204		     dw	offset result_val
SYSINIT:2206		     dw	offset noval
SYSINIT:2208		     db	1
SYSINIT:2209 swit_k	     db	'/K',0               ; ...
SYSINIT:220C swit_n_ctrl     dw	0		     ; ...
SYSINIT:220C					     ; swit_n_ctrl p_pos <0,0,result_val,noval,1>
SYSINIT:220C					     ; switch string follows
SYSINIT:220E		     dw	0
SYSINIT:2210		     dw	offset result_val
SYSINIT:2212		     dw	offset noval
SYSINIT:2214		     db	1
SYSINIT:2215 swit_n	     db	'/N',0               ; ...
SYSINIT:2218 swit_f_ctrl     dw	0		     ; ...
SYSINIT:2218					     ; swit_f_ctrl p_pos <0,0,result_val,noval,1>
SYSINIT:2218					     ; switch string follows
SYSINIT:221A		     dw	0
SYSINIT:221C		     dw	offset result_val
SYSINIT:221E		     dw	offset noval
SYSINIT:2220		     db	1
SYSINIT:2221 swit_f	     db	'/F',0               ; ...
SYSINIT:2224 swit_t_ctrl     dw	0		     ; ...
SYSINIT:2224					     ; swit_t_ctrl p_pos <0,0,result_val,noval,1>
SYSINIT:2224					     ; switch string follows
SYSINIT:2226		     dw	0
SYSINIT:2228		     dw	offset result_val
SYSINIT:222A		     dw	offset noval
SYSINIT:222C		     db	1
SYSINIT:222D swit_t	     db	'/T',0               ; ...
SYSINIT:2230 swit_w_ctrl     dw	0		     ; ...
SYSINIT:2230					     ; swit_w_ctrl p_pos <0,0,result_val,noval,1>
SYSINIT:2230					     ; switch string follows
SYSINIT:2232		     dw	0
SYSINIT:2234		     dw	offset result_val
SYSINIT:2236		     dw	offset noval
SYSINIT:2238		     db	1
SYSINIT:2239 swit_w	     db	'/W',0               ; ...
SYSINIT:223C p_swit_k	     db	0		     ; ...
SYSINIT:223C					     ; local variable
SYSINIT:223D p_swit_t	     db	0		     ; ...
SYSINIT:223D					     ; local variable
SYSINIT:223E p_swit_w	     db	0		     ; ...
SYSINIT:223E					     ; local variable
SYSINIT:223E					     ; ;;
SYSINIT:223F dos_parms	     dw	offset dos_parmsx    ; ...
SYSINIT:223F					     ; DOS = [ high | low ]
SYSINIT:223F					     ; DOS = HIGH|LOW[,UMB|,NOUMB]
SYSINIT:2241		     db	1
SYSINIT:2242		     db	1
SYSINIT:2243		     db	';'
SYSINIT:2244 dos_parmsx	     db	1		     ; ...
SYSINIT:2244					     ; min parameters
SYSINIT:2245		     db	2
SYSINIT:2246		     dw	offset dos_pos
SYSINIT:2248		     dw	offset dos_pos
SYSINIT:224A		     db	   0		     ; no switches
SYSINIT:224B		     db	   0		     ; no keywords
SYSINIT:224C dos_pos	     dw	2000h		     ; ...
SYSINIT:224C					     ; dos_pos p_pos <2000h,0,result_val,dos_strings>
SYSINIT:224C					     ; simple string
SYSINIT:224E		     dw	0
SYSINIT:2250		     dw	offset result_val
SYSINIT:2252		     dw	offset dos_strings
SYSINIT:2254		     db	0
SYSINIT:2255 dos_pos2	     dw	2000h		     ; dos_pos p_pos <2000h,0,result_val,dos_strings>
SYSINIT:2255					     ; simple string
SYSINIT:2255					     ; (this is	not needed) - E.TAN - 08/07/2023
SYSINIT:2257		     dw	0
SYSINIT:2259		     dw	offset result_val
SYSINIT:225B		     dw	offset dos_strings
SYSINIT:225D		     db	0
SYSINIT:225E dos_strings     db	3		     ; ...
SYSINIT:225E					     ; signals that there is a string choice
SYSINIT:225F		     db	0		     ; no range	definition
SYSINIT:2260		     db	0		     ; no numeric values choice
SYSINIT:2261		     db	4		     ; 4 strings for choice
SYSINIT:2262		     db	1		     ; the 1st string tag
SYSINIT:2263		     dw	offset hi_string     ; "HIGH"
SYSINIT:2265		     db	2		     ; the 2nd string tag
SYSINIT:2266		     dw	offset lo_string     ; "LOW"
SYSINIT:2268		     db	3
SYSINIT:2269		     dw	offset umb_string    ; "UMB"
SYSINIT:226B		     db	4
SYSINIT:226C		     dw	offset noumb_string  ; "NOUMB"
SYSINIT:226E hi_string	     db	'HIGH',0             ; ...
SYSINIT:2273 lo_string	     db	'LOW',0              ; ...
SYSINIT:2277 umb_string	     db	'UMB',0              ; ...
SYSINIT:227B noumb_string    db	'NOUMB',0            ; ...
SYSINIT:2281 p_dos_hi	     db	0		     ; local variable (parser does not use this)
SYSINIT:2281					     ;
SYSINIT:2281					     ; for LoadHigh and	DeviceHigh:
SYSINIT:2281					     ;	  fInHigh  - Is	set to 1 during	HideUMBs(), and	back to	zero in
SYSINIT:2281					     ;		     UnHideUMBs().
SYSINIT:2281					     ;	  fUmbTiny - Is	set to 1 iff the user has specified /S on the
SYSINIT:2281					     ;		     command line.
SYSINIT:2281					     ;	  SegLoad  - Segment address for first UMB specified; set
SYSINIT:2281					     ;		     automatically.
SYSINIT:2281					     ;	  UmbLoad  - The load UMB number; for example, this is 3 if the
SYSINIT:2281					     ;		     user has given a command-line like	"/L:3,500;4"
SYSINIT:2281					     ;	  fm_umb   - Set to the	old UMB	link-state (0x80 or 0x00)
SYSINIT:2281					     ;	  fm_strat - Set to the	old memory-allocation strategy (0$00000???)
SYSINIT:2281					     ;	  fm_argc  - Number of arguments received by ParseVar()
SYSINIT:2282 fInHigh	     db	0		     ; ...
SYSINIT:2283 fUmbTiny	     db	0		     ; ...
SYSINIT:2284 SegLoad	     dw	0		     ; ...
SYSINIT:2286 UmbLoad	     db	0		     ; ...
SYSINIT:2286					     ; UmbUsed - An array of characters, each of which is 1 if the UMB
SYSINIT:2286					     ;		 matching its index number was specified on the
SYSINIT:2286					     ;		 command line;
SYSINIT:2286					     ;	      for example, after "/L:3,500;4;7", UmbUsed[3],[4]	& [7]
SYSINIT:2286					     ;	      will be set to 1.	All others will	be set to 0.
SYSINIT:2286					     ; UmbSize - An array of words, each of which is interpereted as a
SYSINIT:2286					     ;		 size specified	by the user for	a UMB (in the above
SYSINIT:2286					     ;		 example, all elements would be	zero save UmbSize[3],
SYSINIT:2286					     ;		 which would be	500.
SYSINIT:2287 UmbUsed	     db	16 dup(0)	     ; ...
SYSINIT:2287					     ; times MAXUMB db 0
SYSINIT:2297 UmbSize	     dw	16 dup(0)	     ; ...
SYSINIT:2297					     ; times MAXUMB dw 0
SYSINIT:22B7 fm_umb	     db	0		     ; ...
SYSINIT:22B8 fm_strat	     db	0
SYSINIT:22B9 fm_argc	     db	0		     ; ...
SYSINIT:22BA DevSize	     dw	0		     ; ...
SYSINIT:22BA					     ; size of the device driver being loaded (paras)
SYSINIT:22BC DevLoadAddr     dw	0		     ; ...
SYSINIT:22BC					     ; Mem addr	where the device driver	is 2 b loaded
SYSINIT:22BE DevLoadEnd	     dw	0		     ; ...
SYSINIT:22BE					     ; MaxAddr to which	device can be loaded
SYSINIT:22C0 DevEntry	     dd	0		     ; ...
SYSINIT:22C0					     ; Entry point to the device driver
SYSINIT:22C4 DevBrkAddr	     dd	0		     ; ...
SYSINIT:22C4					     ; Break address of	the device driver
SYSINIT:22C8 ConvLoad	     db	0		     ; ...
SYSINIT:22C8					     ; Use conventional	(dos 5 style) InitDevLoad?
SYSINIT:22C9 DevUMB	     db	0		     ; ...
SYSINIT:22C9					     ; byte indicating whether to load DDs in UMBs
SYSINIT:22CA DevUMBAddr	     dw	0		     ; ...
SYSINIT:22CA					     ; current UMB used	for loading devices (paras)
SYSINIT:22CC DevUMBSize	     dw	0		     ; ...
SYSINIT:22CC					     ; Size of the current UMB being used (paras)
SYSINIT:22CE DevUMBFree	     dw	0		     ; ...
SYSINIT:22CE					     ; Start of	free mem blk in	the current UMB	(paras)
SYSINIT:22D0 DevXMSAddr	     dd	0		     ; ...
SYSINIT:22D4 DevExecAddr     dw	0		     ; ...
SYSINIT:22D4					     ; Device load address parameter to	Exec call
SYSINIT:22D6 DevExecReloc    dw	0		     ; ...
SYSINIT:22D6					     ; Device load relocation factor
SYSINIT:22D8 DeviceHi	     db	0		     ; ...
SYSINIT:22D8					     ; Flag indicating whether the current device
SYSINIT:22D8					     ; is being	loaded into UMB
SYSINIT:22D9 DevSizeOption   dw	0		     ; ...
SYSINIT:22D9					     ; SIZE= option
SYSINIT:22DB Int12Lied	     db	0		     ; ...
SYSINIT:22DB					     ; did we trap int 12h ?
SYSINIT:22DC OldInt12Mem     dw	0		     ; ...
SYSINIT:22DC					     ; value in	40:13h (int 12h	ram)
SYSINIT:22DE ThreeComName    db	'PROTMAN$'           ; ...
SYSINIT:22DE					     ; 3Com Device name
SYSINIT:22E6 FirstUMBLinked  db	0		     ; ...
SYSINIT:22E7 DevDOSData	     dw	0		     ; ...
SYSINIT:22E7					     ; segment of DOS Data
SYSINIT:22E9 DevCmdLine	     dd	0		     ; ...
SYSINIT:22E9					     ; Current Command line
SYSINIT:22ED DevSavedDelim   db	0		     ; ...
SYSINIT:22ED					     ; The delimiter which was replaced	with null
SYSINIT:22ED					     ; to use the file name in the command line
SYSINIT:22EE MagicHomeFlag   db	0		     ; ...
SYSINIT:22EE					     ; set non-zero when MagicDrv is final placed
SYSINIT:22EF
SYSINIT:22EF ; =============== S U B R O U T I N E =======================================
SYSINIT:22EF
SYSINIT:22EF
SYSINIT:22EF doconf	     proc near		     ; ...
SYSINIT:22EF		     push    cs
SYSINIT:22F0		     pop     ds
SYSINIT:22F1		     assume ds:SYSINIT
SYSINIT:22F1		     mov     ax, 3700h
SYSINIT:22F4		     int     21h	     ; DOS - 2+	internal - GET SWITCHAR/AVAILDEV
SYSINIT:22F4					     ; Return: AL = FFh	unsupported subfunction
SYSINIT:22F4					     ; DL = current switch character
SYSINIT:22F6		     mov     byte ptr command_line+1, dl
SYSINIT:22FA		     mov     def_swchr,	dl   ; save default switchchar
SYSINIT:22FE		     mov     dx, offset	config ; "\\CONFIG.SYS"
SYSINIT:2301		     mov     ax, 3D00h	     ; OPEN<<8
SYSINIT:2304		     stc		     ; (in case	of int 24h)
SYSINIT:2305		     int     21h	     ; DOS - 2+	- OPEN DISK FILE WITH HANDLE
SYSINIT:2305					     ; DS:DX ->	ASCIZ filename
SYSINIT:2305					     ; AL = access mode
SYSINIT:2305					     ; 0 - read
SYSINIT:2307		     jnb     short noprob    ; brif opened okay
SYSINIT:2307					     ;
SYSINIT:2307					     ; config.sys file open error
SYSINIT:2309		     call    kbd_read	     ; we still	want to	give the guy
SYSINIT:2309					     ; a chance	to select clean	boot!
SYSINIT:2309					     ; (ie, no autoexec.bat processing)
SYSINIT:230C		     mov     multi_pass_id, 11 ; set it	to unreasonable	number
SYSINIT:2311		     retn
SYSINIT:2312 ; ---------------------------------------------------------------------------
SYSINIT:2312
SYSINIT:2312 noprob:				     ; ...
SYSINIT:2312		     mov     bx, ax	     ; get file	size (note < 64k!!)
SYSINIT:2312					     ; File handle
SYSINIT:2314		     xor     cx, cx
SYSINIT:2316		     xor     dx, dx
SYSINIT:2318		     mov     ax, 4202h
SYSINIT:231B		     int     21h	     ; DOS - 2+	- MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:231B					     ; AL = method: offset from	end of file
SYSINIT:231D		     mov     count, ax
SYSINIT:2320		     xor     dx, dx	     ; reset pointer to	beginning of file
SYSINIT:2322		     mov     ax, 4200h
SYSINIT:2325		     int     21h	     ; DOS - 2+	- MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:2325					     ; AL = method: offset from	beginning of file
SYSINIT:2327		     mov     dx, ALLOCLIM    ; use current alloclim value
SYSINIT:232B		     mov     ax, count
SYSINIT:232E		     mov     config_size, ax ; save the	size of	config.sys file.
SYSINIT:2331		     call    ParaRound
SYSINIT:2334		     sub     dx, ax
SYSINIT:2336		     dec     dx		     ; reserve 1 additional paragraph
SYSINIT:2337		     mov     config_wrkseg, dx ; this is the segment to	be used	for
SYSINIT:233B		     sub     dx, ax	     ; rebuilding the config.sys memory	image
SYSINIT:233D		     sub     dx, 11h	     ; room for	header
SYSINIT:2340		     mov     ALLOCLIM, dx    ; config starts here. new alloclim	value.
SYSINIT:2344		     mov     CONFBOT, dx
SYSINIT:2348		     mov     ds, dx
SYSINIT:234A		     assume ds:nothing
SYSINIT:234A		     mov     es, dx
SYSINIT:234C		     xor     dx, dx
SYSINIT:234E		     mov     cx, cs:count
SYSINIT:2353		     mov     ah, 3Fh
SYSINIT:2355		     stc		     ; (in case	of int 24h)
SYSINIT:2356		     int     21h	     ; DOS - 2+	- READ FROM FILE WITH HANDLE
SYSINIT:2356					     ; BX = file handle, CX = number of	bytes to read
SYSINIT:2356					     ; DS:DX ->	buffer
SYSINIT:2358		     pushf
SYSINIT:2359		     push    ax		     ; find the	eof mark in the	file.
SYSINIT:2359					     ; if present,then trim length.
SYSINIT:235A		     push    di
SYSINIT:235B		     push    cx
SYSINIT:235C		     mov     al, 1Ah	     ; eof mark
SYSINIT:235E		     mov     di, dx	     ; point to	buffer
SYSINIT:2360		     jcxz    short puteol    ; no chars
SYSINIT:2362		     repne scasb	     ; find end
SYSINIT:2364		     jnz     short puteol    ; none found and count exhausted
SYSINIT:2366		     dec     di		     ; backup past 1Ah
SYSINIT:2367
SYSINIT:2367 puteol:				     ; ...
SYSINIT:2367		     mov     al, 0Dh	     ; cr,lf
SYSINIT:2369		     stosb
SYSINIT:236A		     mov     al, 0Ah
SYSINIT:236C		     stosb
SYSINIT:236D		     sub     di, dx	     ; difference moved
SYSINIT:236F		     mov     cs:count, di    ; new count
SYSINIT:2374		     pop     cx
SYSINIT:2375		     pop     di
SYSINIT:2376		     pop     ax
SYSINIT:2377		     push    cs
SYSINIT:2378		     pop     ds
SYSINIT:2379		     assume ds:SYSINIT
SYSINIT:2379		     push    ax
SYSINIT:237A		     mov     ah, 3Eh
SYSINIT:237C		     int     21h	     ; DOS - 2+	- CLOSE	A FILE WITH HANDLE
SYSINIT:237C					     ; BX = file handle
SYSINIT:237E		     pop     ax
SYSINIT:237F		     popf
SYSINIT:2380		     jb	     short conferr   ; we've got a problem
SYSINIT:2382		     cmp     cx, ax
SYSINIT:2384		     jz	     short getcom    ; if ax <(>) cx
SYSINIT:2384					     ; couldn't read the file
SYSINIT:2386
SYSINIT:2386 conferr:				     ; ...
SYSINIT:2386		     mov     dx, offset	config ; "\\CONFIG.SYS"
SYSINIT:2389		     call    badfil
SYSINIT:238C
SYSINIT:238C endconv:				     ; ...
SYSINIT:238C		     retn
SYSINIT:238C doconf	     endp
SYSINIT:238C
SYSINIT:238D
SYSINIT:238D ; =============== S U B R O U T I N E =======================================
SYSINIT:238D
SYSINIT:238D
SYSINIT:238D multi_pass	     proc near		     ; ...
SYSINIT:238D
SYSINIT:238D ; FUNCTION	CHUNK AT SYSINIT:2968 SIZE 0000012A BYTES
SYSINIT:238D ; FUNCTION	CHUNK AT SYSINIT:2AA6 SIZE 000002B7 BYTES
SYSINIT:238D ; FUNCTION	CHUNK AT SYSINIT:2DAB SIZE 0000000C BYTES
SYSINIT:238D
SYSINIT:238D		     push    cs
SYSINIT:238E		     pop     ds
SYSINIT:238F		     cmp     multi_pass_id, 10 ; do nothing. just return.
SYSINIT:2394
SYSINIT:2394 jae_endconv:			     ; ...
SYSINIT:2394		     jnb     short endconv
SYSINIT:2396		     push    CONFBOT
SYSINIT:239A		     pop     es		     ; es = [confbot] (CONFIG.SYS image	seg)
SYSINIT:239B		     mov     si, org_count   ; set count
SYSINIT:239F		     mov     count, si
SYSINIT:23A3		     xor     si, si	     ; 0
SYSINIT:23A5		     mov     chrptr, si	     ; reset chrptr
SYSINIT:23A9		     mov     linecount,	si   ; reset linecount
SYSINIT:23AD		     call    getchr
SYSINIT:23B0		     jmp     short conflp
SYSINIT:23B2 ; ---------------------------------------------------------------------------
SYSINIT:23B2
SYSINIT:23B2 getcom:				     ; ...
SYSINIT:23B2		     call    organize	     ; organize	the file
SYSINIT:23B5		     call    getchr
SYSINIT:23B8
SYSINIT:23B8 conflp:				     ; ...
SYSINIT:23B8		     jb	     short endconv
SYSINIT:23BA		     inc     linecount	     ; increase	linecount
SYSINIT:23BE		     mov     multdeviceflag, 0 ; reset multdeviceflag.
SYSINIT:23C3		     mov     setdevmarkflag, 0 ; reset setdevmarkflag.
SYSINIT:23C8		     cmp     al, 0Ah	     ; lf ; linefeed?
SYSINIT:23CA		     jz	     short blank_line ;	then ignore this line.
SYSINIT:23CA					     ;
SYSINIT:23CA					     ; If this is a genuine CONFIG.SYS command,
SYSINIT:23CA					     ; then there should be a line number
SYSINIT:23CA					     ; immediately following it
SYSINIT:23CC		     mov     config_cmd, al  ; save original command code
SYSINIT:23CF		     and     al, 7Fh	     ; ~CONFIG_OPTION_QUERY
SYSINIT:23D1		     cmp     config_multi, 0 ; is this a multi-config config.sys?
SYSINIT:23D6		     jz	     short not_final ; no, line	number is not embedded
SYSINIT:23D8		     push    ax
SYSINIT:23D9		     call    getchr	     ; ignore end-of-image errors
SYSINIT:23DC		     mov     ah, al	     ; because if there's an error
SYSINIT:23DE		     call    getchr	     ; fetching	the line number	that's
SYSINIT:23E1		     xchg    al, ah	     ; supposed	to be there, the next
SYSINIT:23E3		     mov     linecount,	ax   ; getchr call will	get the	same error
SYSINIT:23E6		     pop     ax
SYSINIT:23E7		     cmp     multi_pass_id, 2 ;	final pass?
SYSINIT:23EC		     jb	     short not_final ; no
SYSINIT:23EE		     test    install_flag, 1 ; have_install_cmd
SYSINIT:23EE					     ; are there install commands?
SYSINIT:23F4		     jz	     short final     ; no install cmds,	yes it is
SYSINIT:23F6		     cmp     multi_pass_id, 3 ;	final pass?
SYSINIT:23FB		     jb	     short not_final ; no
SYSINIT:23FD
SYSINIT:23FD final:				     ; ...
SYSINIT:23FD		     mov     es:[si], al     ; save backward-compatible	command	code
SYSINIT:2400
SYSINIT:2400 not_final:				     ; ...
SYSINIT:2400		     mov     ah, al
SYSINIT:2402		     call    getchr
SYSINIT:2405		     jnb     short tryi
SYSINIT:2407		     cmp     multi_pass_id, 2
SYSINIT:240C		     jnb     short jae_endconv ; it would be 'jnb short endconv'
SYSINIT:240C					     ; (E.TAN -	09/07/2023)
SYSINIT:240C					     ; do not show badop again for multi_pass.
SYSINIT:240E		     jmp     badop
SYSINIT:2411 ; ---------------------------------------------------------------------------
SYSINIT:2411
SYSINIT:2411 coff:				     ; ...
SYSINIT:2411		     push    cs
SYSINIT:2412		     pop     ds
SYSINIT:2413		     call    newline
SYSINIT:2416		     jmp     short conflp
SYSINIT:2418 ; ---------------------------------------------------------------------------
SYSINIT:2418
SYSINIT:2418 blank_line:			     ; ...
SYSINIT:2418		     call    getchr
SYSINIT:241B		     jmp     short conflp
SYSINIT:241D ; ---------------------------------------------------------------------------
SYSINIT:241D		     push    cs
SYSINIT:241E		     pop     ds
SYSINIT:241F
SYSINIT:241F tryi:				     ; ...
SYSINIT:241F		     cmp     multi_pass_id, 0 ;	the initial pass for DOS=HI
SYSINIT:2424		     jnz     short not_init_pass
SYSINIT:2426		     jmp     multi_try_doshi
SYSINIT:2429 ; ---------------------------------------------------------------------------
SYSINIT:2429
SYSINIT:2429 not_init_pass:			     ; ...
SYSINIT:2429		     cmp     multi_pass_id, 2 ;	the second pass	was for	ifs=
SYSINIT:242E		     jz	     short multi_pass_coff2 ; now it is	NOPs
SYSINIT:242E					     ;
SYSINIT:242E					     ; This pass can be	made use of if
SYSINIT:242E					     ; we want do some config.sys process
SYSINIT:242E					     ; after device drivers are	loaded and
SYSINIT:242E					     ; before install= commands	are processed
SYSINIT:2430		     cmp     multi_pass_id, 3 ;	the third pass for install= ?
SYSINIT:2435		     jz	     short multi_try_i
SYSINIT:2437		     cmp     ah, 48h ; 'H'   ; CONFIG_DOS
SYSINIT:243A		     jz	     short multi_pass_coff2
SYSINIT:243C		     cmp     ah, 49h ; 'I'   ; CONFIG_INSTALL ; install= command?
SYSINIT:243F		     jnz     short precheck_installhigh	;
SYSINIT:243F					     ; the first pass is for normal operation.
SYSINIT:2441		     or	     install_flag, 1 ; have_install_cmd	; set the flag
SYSINIT:2446
SYSINIT:2446 multi_pass_coff2:			     ; ...
SYSINIT:2446		     jmp     short coff	     ; and handles the next command
SYSINIT:2448 ; ---------------------------------------------------------------------------
SYSINIT:2448
SYSINIT:2448 precheck_installhigh:		     ; ...
SYSINIT:2448		     cmp     ah, 57h ; 'W'   ; CONFIG_INSTALLHIGH ; signifier for INSTALLHIGH
SYSINIT:244B		     jnz     short tryb	     ; carry on	with normal processing
SYSINIT:244D		     or	     install_flag, 1 ; have_install_cmd
SYSINIT:2452		     jmp     short coff
SYSINIT:2454 ; ---------------------------------------------------------------------------
SYSINIT:2454
SYSINIT:2454 multi_try_i:			     ; ...
SYSINIT:2454		     cmp     ah, 49h ; 'I'   ; CONFIG_INSTALL ; install= command?
SYSINIT:2457		     jnz     short multi_try_n ; no, check for installhigh
SYSINIT:2459		     call    query_user	     ; query the user if config_cmd
SYSINIT:245C		     jb	     short multi_pass_filter ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:245E		     call    do_install_exec ; install it.
SYSINIT:2461		     jmp     short coff	     ; to handle next install= command.
SYSINIT:2463 ; ---------------------------------------------------------------------------
SYSINIT:2463
SYSINIT:2463 multi_try_n:			     ; ...
SYSINIT:2463		     cmp     ah, 57h ; 'W'   ; CONFIG_INSTALLHIGH ; installhigh= command?
SYSINIT:2466		     jnz     short multi_pass_filter
SYSINIT:2468		     call    query_user	     ; query the user if config_cmd
SYSINIT:246B		     jb	     short multi_pass_filter ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:246D		     mov     ax, 5800h
SYSINIT:2470		     int     21h	     ; DOS - 3+	- GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:2470					     ; AL = function code: get allocation strategy
SYSINIT:2472		     mov     bx, ax
SYSINIT:2474		     push    bx		     ; save for	the return
SYSINIT:2475		     or	     bx, 80h	     ; HIGH_FIRST ; set	alloc to HighFirst
SYSINIT:2479		     mov     ax, 5801h	     ; (ALLOCOPER<<8)|1
SYSINIT:247C		     int     21h	     ; DOS - 3+	- GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:247C					     ; AL = function code: set allocation strategy
SYSINIT:247E		     mov     ax, 5802h
SYSINIT:2481		     int     21h	     ; DOS - 3+	- GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:2481					     ; AL = function code: (DOS	5beta) get UMB link state
SYSINIT:2483		     xor     ah, ah
SYSINIT:2485		     push    ax		     ; save for	the return
SYSINIT:2486		     mov     ax, 5803h	     ; (ALLOCOPER<<8)|3
SYSINIT:2489		     mov     bx, 1	     ; link in UMBs
SYSINIT:248C		     int     21h	     ; DOS - 3+	- GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:248C					     ; AL = function code: (DOS	5beta) set UMB link state
SYSINIT:248E		     call    do_install_exec ; install it.
SYSINIT:2491		     mov     ax, 5803h
SYSINIT:2494		     pop     bx		     ; recover original	link state
SYSINIT:2495		     int     21h	     ; DOS - 3+	- GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:2495					     ; AL = function code: (DOS	5beta) set UMB link state
SYSINIT:2497		     pop     bx		     ; recover original	alloc strategy
SYSINIT:2498		     mov     ax, 5801h
SYSINIT:249B		     int     21h	     ; DOS - 3+	- GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:249B					     ; AL = function code: set allocation strategy
SYSINIT:249D		     jmp     coff	     ; to handle next install= commands.
SYSINIT:24A0 ; ---------------------------------------------------------------------------
SYSINIT:24A0
SYSINIT:24A0 multi_pass_filter:			     ; ...
SYSINIT:24A0		     cmp     ah, 59h ; 'Y'   ; CONFIG_COMMENT ; comment?
SYSINIT:24A3		     jz	     short multi_pass_adjust
SYSINIT:24A5		     cmp     ah, 5Ah ; 'Z'   ; CONFIG_UNKNOWN ; bad command?
SYSINIT:24A8		     jz	     short multi_pass_adjust
SYSINIT:24AA		     cmp     ah, 30h ; '0'   ; CONFIG_REM ; rem?
SYSINIT:24AD		     jnz     short multi_pass_coff ; ignore the	rest of	the commands.
SYSINIT:24AF
SYSINIT:24AF multi_pass_adjust:			     ; ...
SYSINIT:24AF		     dec     chrptr	     ; these commands need to
SYSINIT:24AF					     ; adjust chrptr,count
SYSINIT:24B3		     inc     count	     ; for newline proc.
SYSINIT:24B7
SYSINIT:24B7 multi_pass_coff:			     ; ...
SYSINIT:24B7		     jmp     coff	     ; to handle next install= commands.
SYSINIT:24BA ; ---------------------------------------------------------------------------
SYSINIT:24BA
SYSINIT:24BA tryb:				     ; ...
SYSINIT:24BA		     cmp     ah, 42h ; 'B'   ; CONFIG_BUFFERS
SYSINIT:24BD		     jnz     short tryc
SYSINIT:24BF		     call    query_user	     ; query the user if config_cmd
SYSINIT:24BF					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:24C2		     jb	     short tryc
SYSINIT:24C4		     mov     p_buffer_slash_x, 0
SYSINIT:24C9		     mov     di, offset	buf_parms
SYSINIT:24CC		     xor     cx, cx
SYSINIT:24CE		     mov     dx, cx
SYSINIT:24D0
SYSINIT:24D0 do7:				     ; ...
SYSINIT:24D0		     call    sysinit_parse
SYSINIT:24D3		     jnb     short if7	     ;
SYSINIT:24D3					     ; parse error,
SYSINIT:24D3					     ; and show	messages and end the search
SYSINIT:24D5		     call    badparm_p
SYSINIT:24D8		     jmp     short sr7
SYSINIT:24DA ; ---------------------------------------------------------------------------
SYSINIT:24DA
SYSINIT:24DA if7:				     ; ...
SYSINIT:24DA		     cmp     ax, 0FFFFh	     ; _$P_RC_EOL ; end	of line?
SYSINIT:24DD		     jz	     short en7	     ; then jmp	to $endloop for	semantic check
SYSINIT:24DF		     cmp     result_val_swoff, offset switch_x ; (/X switch)
SYSINIT:24DF					     ; [result_val+_$P_Result_Blk.SYNONYM_Ptr]
SYSINIT:24E5		     jnz     short if11
SYSINIT:24E7		     jmp     short en11
SYSINIT:24E9 ; ---------------------------------------------------------------------------
SYSINIT:24E9
SYSINIT:24E9 if11:				     ; ...
SYSINIT:24E9		     mov     ax, word ptr rv_dword ; [result_val+_$P_Result_Blk.Picked_Val]
SYSINIT:24EC		     cmp     cx, 1
SYSINIT:24EF		     jnz     short if13
SYSINIT:24F1		     mov     p_buffers,	ax
SYSINIT:24F4		     jmp     short en11
SYSINIT:24F6 ; ---------------------------------------------------------------------------
SYSINIT:24F6
SYSINIT:24F6 if13:				     ; ...
SYSINIT:24F6		     mov     p_h_buffers, ax
SYSINIT:24F9
SYSINIT:24F9 en11:				     ; ...
SYSINIT:24F9		     jmp     short do7
SYSINIT:24FB ; ---------------------------------------------------------------------------
SYSINIT:24FB
SYSINIT:24FB en7:				     ; ...
SYSINIT:24FB		     cmp     p_buffers,	99
SYSINIT:2500		     jbe     short if18
SYSINIT:2502		     call    badparm_p
SYSINIT:2505		     mov     p_h_buffers, 0
SYSINIT:250B		     jmp     short sr7
SYSINIT:250D ; ---------------------------------------------------------------------------
SYSINIT:250D
SYSINIT:250D if18:				     ; ...
SYSINIT:250D		     mov     ax, p_buffers   ; we don't have any problem.
SYSINIT:2510		     mov     buffers, ax     ; now,let's set it really.
SYSINIT:2513		     mov     ax, p_h_buffers
SYSINIT:2516		     mov     h_buffers,	ax
SYSINIT:2519		     mov     ax, linecount
SYSINIT:251C		     mov     buffer_linenum, ax	; save the line	number
SYSINIT:251C					     ; for the future use
SYSINIT:251F
SYSINIT:251F sr7:				     ; ...
SYSINIT:251F		     jmp     coff
SYSINIT:2522 ; ---------------------------------------------------------------------------
SYSINIT:2522
SYSINIT:2522 tryc:				     ; ...
SYSINIT:2522		     cmp     ah, 43h ; 'C'   ; CONFIG_BREAK
SYSINIT:2525		     jnz     short trym
SYSINIT:2527		     call    query_user	     ; query the user if config_cmd
SYSINIT:2527					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:252A		     jb	     short trym
SYSINIT:252C		     mov     di, offset	brk_parms
SYSINIT:252F		     xor     cx, cx
SYSINIT:2531		     mov     dx, cx
SYSINIT:2533
SYSINIT:2533 do22:				     ; ...
SYSINIT:2533		     call    sysinit_parse
SYSINIT:2536		     jnb     short if22	     ;
SYSINIT:2536					     ; parse error
SYSINIT:2538		     call    badparm_p
SYSINIT:253B		     jmp     short sr22
SYSINIT:253D ; ---------------------------------------------------------------------------
SYSINIT:253D
SYSINIT:253D if22:				     ; ...
SYSINIT:253D		     cmp     ax, 0FFFFh	     ; _$P_RC_EOL ; end	of line?
SYSINIT:2540		     jz	     short en22	     ; then end	the $endloop
SYSINIT:2542		     cmp     result_val_itag, 1	; [result_val+_$P_Result_Blk.Item_Tag]
SYSINIT:2547		     jnz     short if26
SYSINIT:2549		     mov     p_ctrl_break, 1 ; turn it on
SYSINIT:254E		     jmp     short en26
SYSINIT:2550 ; ---------------------------------------------------------------------------
SYSINIT:2550
SYSINIT:2550 if26:				     ; ...
SYSINIT:2550		     mov     p_ctrl_break, 0 ; turn it off
SYSINIT:2555
SYSINIT:2555 en26:				     ; ...
SYSINIT:2555		     jmp     short do22	     ; we actually set the ctrl	break
SYSINIT:2557 ; ---------------------------------------------------------------------------
SYSINIT:2557
SYSINIT:2557 en22:				     ; ...
SYSINIT:2557		     mov     ah, 33h	     ; SET_CTRL_C_TRAPPING
SYSINIT:2557					     ; if we don't have any parse error.
SYSINIT:2559		     mov     al, 1
SYSINIT:255B		     mov     dl, p_ctrl_break
SYSINIT:255F		     int     21h	     ; DOS - EXTENDED CONTROL-BREAK CHECKING
SYSINIT:255F					     ; AL = 00h	get state / 01h	set state / 02h	set AND	get
SYSINIT:255F					     ; DL = 00h	for OFF	or 01h for ON
SYSINIT:2561
SYSINIT:2561 sr22:				     ; ...
SYSINIT:2561		     jmp     coff
SYSINIT:2564 ; ---------------------------------------------------------------------------
SYSINIT:2564
SYSINIT:2564 trym:				     ; ...
SYSINIT:2564		     cmp     ah, 4Dh ; 'M'   ; CONFIG_MULTITRACK
SYSINIT:2567		     jnz     short tryu
SYSINIT:2569		     call    query_user	     ; query the user if config_cmd
SYSINIT:2569					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:256C		     jb	     short tryu
SYSINIT:256E		     mov     di, offset	mtrk_parms
SYSINIT:2571		     xor     cx, cx
SYSINIT:2573		     mov     dx, cx
SYSINIT:2575
SYSINIT:2575 do31:				     ; ...
SYSINIT:2575		     call    sysinit_parse
SYSINIT:2578		     jnb     short if31	     ;
SYSINIT:2578					     ; parse_error
SYSINIT:257A		     call    badparm_p	     ; show message and	end the	search loop.
SYSINIT:257D		     jmp     short sr31
SYSINIT:257F ; ---------------------------------------------------------------------------
SYSINIT:257F
SYSINIT:257F if31:				     ; ...
SYSINIT:257F		     cmp     ax, 0FFFFh	     ; _$P_RC_EOL ; end	of line?
SYSINIT:2582		     jz	     short en31
SYSINIT:2584		     cmp     result_val_itag, 1	; [result_val+_$P_Result_Blk.Item_Tag]
SYSINIT:2589		     jnz     short if35
SYSINIT:258B		     mov     p_mtrk, 1	     ; turn it on temporarily.
SYSINIT:2590		     jmp     short en35
SYSINIT:2592 ; ---------------------------------------------------------------------------
SYSINIT:2592
SYSINIT:2592 if35:				     ; ...
SYSINIT:2592		     mov     p_mtrk, 0	     ; turn it off temporarily.
SYSINIT:2597
SYSINIT:2597 en35:				     ; ...
SYSINIT:2597		     jmp     short do31	     ; we actually set the multrk_flag here
SYSINIT:2599 ; ---------------------------------------------------------------------------
SYSINIT:2599
SYSINIT:2599 en31:				     ; ...
SYSINIT:2599		     push    ds
SYSINIT:259A		     mov     ax, 70h	     ; DOSBIODATASEG ; BIOSDATA	segment
SYSINIT:259D		     mov     ds, ax
SYSINIT:259F		     assume ds:nothing
SYSINIT:259F		     cmp     cs:p_mtrk,	0
SYSINIT:25A5		     jnz     short if39
SYSINIT:25A7		     mov     ds:multrk_flag, 1 ; multrk_off2
SYSINIT:25AD		     jmp     short en39
SYSINIT:25AF ; ---------------------------------------------------------------------------
SYSINIT:25AF
SYSINIT:25AF if39:				     ; ...
SYSINIT:25AF		     mov     ds:multrk_flag, 80h ; multrk_on
SYSINIT:25B5
SYSINIT:25B5 en39:				     ; ...
SYSINIT:25B5		     pop     ds
SYSINIT:25B6		     assume ds:nothing
SYSINIT:25B6
SYSINIT:25B6 sr31:				     ; ...
SYSINIT:25B6		     jmp     coff
SYSINIT:25B9 ; ---------------------------------------------------------------------------
SYSINIT:25B9
SYSINIT:25B9 multi_try_doshi:			     ; ...
SYSINIT:25B9		     cmp     ah, 48h ; 'H'   ; CONFIG_DOS
SYSINIT:25BC		     jz	     short it_is_h
SYSINIT:25BE
SYSINIT:25BE skip_it:				     ; ...
SYSINIT:25BE		     jmp     multi_pass_filter
SYSINIT:25C1 ; ---------------------------------------------------------------------------
SYSINIT:25C1
SYSINIT:25C1 it_is_h:				     ; ...
SYSINIT:25C1		     call    query_user	     ; query the user if config_cmd
SYSINIT:25C1					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:25C4		     jb	     short skip_it
SYSINIT:25C6		     mov     di, offset	dos_parms
SYSINIT:25C9		     xor     cx, cx
SYSINIT:25CB		     mov     dx, cx
SYSINIT:25CD
SYSINIT:25CD h_do_parse:			     ; ...
SYSINIT:25CD		     call    sysinit_parse
SYSINIT:25D0		     jnb     short h_parse_ok
SYSINIT:25D2
SYSINIT:25D2 h_badparm:				     ; parse error
SYSINIT:25D2		     call    badparm_p	     ; show message and	end the	search loop.
SYSINIT:25D5		     jmp     short h_end
SYSINIT:25D7 ; ---------------------------------------------------------------------------
SYSINIT:25D7
SYSINIT:25D7 h_parse_ok:			     ; ...
SYSINIT:25D7		     cmp     ax, 0FFFFh	     ; _$P_RC_EOL ; end	of line?
SYSINIT:25DA		     jz	     short h_end     ; then end	the $endloop
SYSINIT:25DC		     call    ProcDOS
SYSINIT:25DF		     jmp     short h_do_parse
SYSINIT:25E1 ; ---------------------------------------------------------------------------
SYSINIT:25E1
SYSINIT:25E1 h_end:				     ; ...
SYSINIT:25E1		     jmp     coff
SYSINIT:25E4 ; ---------------------------------------------------------------------------
SYSINIT:25E4
SYSINIT:25E4 tryu:				     ; ...
SYSINIT:25E4		     cmp     ah, 55h ; 'U'   ; CONFIG_DEVICEHIGH
SYSINIT:25E7		     jnz     short tryd
SYSINIT:25E9		     call    query_user	     ; query the user if config_cmd
SYSINIT:25E9					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:25EC		     jb	     short tryd
SYSINIT:25EE		     call    InitVar
SYSINIT:25F1		     call    ParseSize	     ; process the size= option
SYSINIT:25F4		     jnb     short tryu_1    ;
SYSINIT:25F4					     ; stash it	there in case of an error
SYSINIT:25F6		     mov     word ptr cs:badparm_ptr, si
SYSINIT:25FB		     mov     word ptr cs:badparm_ptr+2,	es
SYSINIT:2600		     call    badparm_p
SYSINIT:2603		     jmp     coff
SYSINIT:2606 ; ---------------------------------------------------------------------------
SYSINIT:2606
SYSINIT:2606 tryu_1:				     ; ...
SYSINIT:2606		     mov     ax, cs:DevSizeOption
SYSINIT:260A		     or	     ax, ax
SYSINIT:260C		     jnz     short tryu_2
SYSINIT:260E		     call    ParseVar
SYSINIT:2611		     jnb     short tryu_2
SYSINIT:2613		     mov     word ptr cs:badparm_ptr, si ;
SYSINIT:2613					     ; If ParseVar up there failed, then
SYSINIT:2613					     ; ES:SI points to its problem area..
SYSINIT:2618		     mov     word ptr cs:badparm_ptr+2,	es
SYSINIT:261D		     call    badparm_p	     ; so all we have to do is choke and
SYSINIT:261D					     ; die, rather verbosely.
SYSINIT:2620		     jmp     coff
SYSINIT:2623 ; ---------------------------------------------------------------------------
SYSINIT:2623
SYSINIT:2623 tryu_2:				     ; ...
SYSINIT:2623		     push    si
SYSINIT:2624		     push    es
SYSINIT:2625
SYSINIT:2625 tryu_3:				     ; ...
SYSINIT:2625		     mov     al, es:[si]
SYSINIT:2628		     cmp     al, 0Dh	     ; cr
SYSINIT:262A		     jz	     short tryu_4
SYSINIT:262C		     cmp     al, 0Ah	     ; lf
SYSINIT:262E		     jz	     short tryu_4
SYSINIT:2630		     call    delim
SYSINIT:2633		     jz	     short tryu_4
SYSINIT:2635		     inc     si
SYSINIT:2636		     jmp     short tryu_3
SYSINIT:2638 ; ---------------------------------------------------------------------------
SYSINIT:2638
SYSINIT:2638 tryu_4:				     ; ...
SYSINIT:2638		     mov     cs:DevSavedDelim, al ; Save the delimiter
SYSINIT:2638					     ; before replacing	it with	null
SYSINIT:263C		     mov     byte ptr es:[si], 0
SYSINIT:2640		     pop     es
SYSINIT:2641		     pop     si
SYSINIT:2642		     call    UmbTest	     ; See if UMBs are around...
SYSINIT:2645		     jnb     short NrmTst    ; yep. So do that normal thang.
SYSINIT:2647		     mov     cs:DeviceHi, 0  ; nope... so load low.
SYSINIT:264D		     jmp     short LoadDevice
SYSINIT:264F ; ---------------------------------------------------------------------------
SYSINIT:264F
SYSINIT:264F NrmTst:				     ; ...
SYSINIT:264F		     mov     cs:DeviceHi, 0
SYSINIT:2655		     cmp     cs:DevUMB,	0    ; do we support UMBs ?
SYSINIT:265B		     jz	     short LoadDevice ;	no, we don't
SYSINIT:265D		     mov     cs:DeviceHi, 1
SYSINIT:2663		     jmp     short LoadDevice
SYSINIT:2665 ; ---------------------------------------------------------------------------
SYSINIT:2665
SYSINIT:2665 tryd:				     ; ...
SYSINIT:2665		     cmp     ah, 44h ; 'D'   ; CONFIG_DEVICE
SYSINIT:2668		     jz	     short gotd
SYSINIT:266A
SYSINIT:266A skip_it2:				     ; ...
SYSINIT:266A		     jmp     tryq
SYSINIT:266D ; ---------------------------------------------------------------------------
SYSINIT:266D
SYSINIT:266D gotd:				     ; ...
SYSINIT:266D		     call    query_user	     ; query the user if config_cmd
SYSINIT:266D					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2670		     jb	     short skip_it2
SYSINIT:2672		     mov     cs:DeviceHi, 0  ; not to be loaded	in UMB
SYSINIT:2678		     mov     cs:DevSizeOption, 0
SYSINIT:267F		     mov     cs:DevSavedDelim, 20h ; ' ' ; In case of DEVICE=
SYSINIT:267F					     ; the null	has to be replaced with	a ' '
SYSINIT:2685
SYSINIT:2685 LoadDevice:			     ; ...
SYSINIT:2685		     push    cs
SYSINIT:2686		     pop     ds
SYSINIT:2687		     assume ds:SYSINIT
SYSINIT:2687		     mov     word ptr bpb_addr,	si ;
SYSINIT:2687					     ; pass the	command	line to	the device
SYSINIT:268B		     mov     word ptr bpb_addr+2, es
SYSINIT:268F		     mov     word ptr DevCmdLine, si ; save it for ourself
SYSINIT:2693		     mov     word ptr DevCmdLine+2, es
SYSINIT:2697		     mov     driver_units, 0 ; clear total block units for driver
SYSINIT:269C		     call    round
SYSINIT:269F		     call    SizeDevice
SYSINIT:26A2		     jb	     short BadFile
SYSINIT:26A4		     mov     ConvLoad, 1     ; Doesn't matter if DeviceHi==0
SYSINIT:26A9		     mov     al, DeviceHi    ; If not using upper memory,
SYSINIT:26A9					     ; ('mov al, [DeviceHi]' is not needed here
SYSINIT:26A9					     ;	because	al value is not	used after here)
SYSINIT:26AC		     or	     DeviceHi, 0     ; (or al, al) - Erdogan Tan - 10/07/2023
SYSINIT:26B1		     jz	     short DevConvLoad ; Skip all this and go on
SYSINIT:26B1					     ; to the actual load.
SYSINIT:26B3		     call    GetLoadUMB	     ; ('mov al, [UmbLoad]' would be better here)
SYSINIT:26B6		     cmp     al, 0FFh	     ; -1 ; If umb0 not	specified, it's old style
SYSINIT:26B8		     jz	     short DevConvLoad ; so load high even if SIZE= is smaller
SYSINIT:26BA		     dec     ConvLoad	     ; 0 ; They	specified /L, so use new loader
SYSINIT:26BE		     call    GetLoadSize     ; Returns size of first UMB specified
SYSINIT:26C1		     or	     ax, ax
SYSINIT:26C3		     jz	     short tryd_1    ; If size is not specified..
SYSINIT:26C5		     cmp     ax, DevSize     ; /L:...,Size < DevSize?
SYSINIT:26C9		     jge     short DevConvLoad
SYSINIT:26CB
SYSINIT:26CB tryd_1:				     ; ...
SYSINIT:26CB		     mov     ax, DevSize     ; Size < DevSize, so write	DevSize	as
SYSINIT:26CE		     call    StoLoadSize     ; minsize for load	UMB.
SYSINIT:26D1
SYSINIT:26D1 DevConvLoad:			     ; ...
SYSINIT:26D1		     call    InitDevLoad
SYSINIT:26D4		     mov     ax, DevLoadAddr
SYSINIT:26D7		     add     ax, DevSize
SYSINIT:26DB		     jb	     short NoMem
SYSINIT:26DD		     cmp     DevLoadEnd, ax
SYSINIT:26E1		     jnb     short LoadDev
SYSINIT:26E3
SYSINIT:26E3 NoMem:				     ; ...
SYSINIT:26E3		     jmp     mem_err
SYSINIT:26E6 ; ---------------------------------------------------------------------------
SYSINIT:26E6
SYSINIT:26E6 BadFile:				     ; ...
SYSINIT:26E6		     call    RetFromUM	     ; Does nothing if didn't call HideUMBs
SYSINIT:26E9		     cmp     byte ptr es:[si], 20h ; ' ' ; blank/space
SYSINIT:26ED		     jnb     short tryd_2
SYSINIT:26EF		     jmp     badop
SYSINIT:26F2 ; ---------------------------------------------------------------------------
SYSINIT:26F2
SYSINIT:26F2 tryd_2:				     ; ...
SYSINIT:26F2		     call    badload
SYSINIT:26F5		     jmp     coff
SYSINIT:26F8 ; ---------------------------------------------------------------------------
SYSINIT:26F8
SYSINIT:26F8 LoadDev:				     ; ...
SYSINIT:26F8		     push    es
SYSINIT:26F9		     pop     ds
SYSINIT:26FA		     assume ds:nothing
SYSINIT:26FA		     mov     dx, si	     ; ds:dx points to file name
SYSINIT:26FC		     call    ExecDev	     ; load device driver using	exec call
SYSINIT:26FF		     push    ds
SYSINIT:2700		     pop     es		     ; es:si back to config.sys
SYSINIT:2701		     push    cs
SYSINIT:2702		     pop     ds		     ; ds back to sysinit
SYSINIT:2703		     assume ds:SYSINIT
SYSINIT:2703		     jb	     short BadFile
SYSINIT:2705
SYSINIT:2705 goodld:				     ; ...
SYSINIT:2705		     push    es
SYSINIT:2706		     push    si
SYSINIT:2707		     call    RemoveNull
SYSINIT:270A		     push    es
SYSINIT:270B		     push    si
SYSINIT:270C		     push    cs
SYSINIT:270D		     pop     es
SYSINIT:270E		     assume es:SYSINIT
SYSINIT:270E		     push    ds
SYSINIT:270F		     push    si
SYSINIT:2710		     lds     si, cs:DevEntry
SYSINIT:2715		     assume ds:nothing
SYSINIT:2715		     test    word ptr [si+4], 8000h ; [si+SYSDEV.ATT],DEVTYP
SYSINIT:2715					     ; block device driver?
SYSINIT:271A		     jnz     short got_device_com_cont ; no.
SYSINIT:271C		     lds     si, cs:DOSINFO  ; ds:si ->	sys_var
SYSINIT:2721		     cmp     byte ptr [si+20h],	26 ; [si+SYSI_NUMIO]
SYSINIT:2721					     ; no more than 26 drive number
SYSINIT:2725		     jb	     short got_device_com_cont
SYSINIT:2727		     pop     si
SYSINIT:2728		     pop     ds
SYSINIT:2729		     pop     si		     ; clear the stack
SYSINIT:272A		     pop     es
SYSINIT:272B		     assume es:nothing
SYSINIT:272B		     call    RetFromUM	     ; Do this before we leave
SYSINIT:272E		     jmp     badnumblock
SYSINIT:2731 ; ---------------------------------------------------------------------------
SYSINIT:2731
SYSINIT:2731 got_device_com_cont:		     ; ...
SYSINIT:2731		     pop     si
SYSINIT:2732		     pop     ds
SYSINIT:2733		     call    LieInt12Mem
SYSINIT:2736		     call    UpdatePDB	     ; update the PSP:2	value
SYSINIT:2739		     cmp     cs:multdeviceflag,	0 ; Pass limit only for
SYSINIT:2739					     ; the 1st device driver in	the file
SYSINIT:273F		     jnz     short skip_pass_limit
SYSINIT:2741		     mov     cs:break_addr, 0 ;	pass the limit to the DD
SYSINIT:2748		     mov     bx, cs:DevLoadEnd
SYSINIT:274D		     mov     cs:break_addr+2, bx
SYSINIT:2752
SYSINIT:2752 skip_pass_limit:			     ; ...
SYSINIT:2752		     push    ds
SYSINIT:2753		     lds     bx, cs:DOSINFO  ; ds:bx ->	sys_var
SYSINIT:2758		     mov     al, cs:drivenumber	; temporarily use this next drv	value
SYSINIT:275C		     mov     cs:devdrivenum, al	; pass drive number in packet to driver
SYSINIT:2760		     mov     ah, al
SYSINIT:2762		     xchg    ax, [bx+20h]    ; [bx+SYSI_NUMIO]
SYSINIT:2762					     ; swap with existing values
SYSINIT:2765		     pop     ds
SYSINIT:2766		     push    ax		     ; save real sysi_numio/ncds in ax
SYSINIT:2766					     ;
SYSINIT:2766					     ; mov word	ptr cs:configmsgflag, 0
SYSINIT:2766					     ; PCDOS 7.1 IBMBIO.COM - SYSINIT:2C5Fh
SYSINIT:2766					     ; (disable	"error in config.sys line #" msg)
SYSINIT:2766					     ; ((before	loading	-next- device driver))
SYSINIT:2766					     ; E.TAN - 10/07/2023
SYSINIT:2766					     ; ;
SYSINIT:2767		     mov     bx, 6	     ; SYSDEV.STRAT
SYSINIT:276A		     call    calldev	     ; calldev (sdevstrat);
SYSINIT:276D		     mov     bx, 8	     ; SYSDEV.INT
SYSINIT:2770		     call    calldev	     ; calldev (sdevint);
SYSINIT:2773		     pop     ax		     ; get real	sysi_numio value
SYSINIT:2774		     push    ds
SYSINIT:2775		     lds     bx, cs:DOSINFO  ; ds:bx ->	sys_var
SYSINIT:277A		     mov     [bx+20h], ax    ; [bx+SYSI_NUMIO]
SYSINIT:277A					     ; restore previous/real value
SYSINIT:277D		     pop     ds
SYSINIT:277E		     call    TrueInt12Mem
SYSINIT:2781		     mov     ax, cs:break_addr ; move break addr from the req packet
SYSINIT:2785		     mov     word ptr cs:DevBrkAddr, ax
SYSINIT:2789		     mov     ax, cs:break_addr+2
SYSINIT:278D		     mov     word ptr cs:DevBrkAddr+2, ax
SYSINIT:2791		     call    RetFromUM	     ; There we	go... all done.
SYSINIT:2794		     cmp     cs:DevUMB,	0
SYSINIT:279A		     jz	     short tryd_3
SYSINIT:279C		     call    AllocUMB
SYSINIT:279F
SYSINIT:279F tryd_3:				     ; ...
SYSINIT:279F		     cmp     cs:runhigh, 0FFh
SYSINIT:27A5		     jnz     short tryd_4
SYSINIT:27A7		     call    TryToMovDOSHi   ; move DOS	into HMA if requsted
SYSINIT:27AA
SYSINIT:27AA tryd_4:				     ; ...
SYSINIT:27AA		     pop     si
SYSINIT:27AB		     pop     ds
SYSINIT:27AC		     mov     byte ptr [si], 0 ;	*p = 0;
SYSINIT:27AF		     push    cs
SYSINIT:27B0		     pop     ds
SYSINIT:27B1		     assume ds:SYSINIT
SYSINIT:27B1		     jmp     short was_device_com
SYSINIT:27B3 ; ---------------------------------------------------------------------------
SYSINIT:27B3
SYSINIT:27B3 badnumblock:			     ; ...
SYSINIT:27B3		     push    cs
SYSINIT:27B4		     pop     ds
SYSINIT:27B5		     mov     dx, offset	badblock ; "\r\nToo many block devices\r\n$"
SYSINIT:27B8		     call    print
SYSINIT:27BB
SYSINIT:27BB erase_dev_do:			     ; ...
SYSINIT:27BB		     call    CheckDoubleSpace ;	(Note: 'call CheckDoubleSpace'
SYSINIT:27BB					     ; has been	removed	at 'erase_dev_do:' pos
SYSINIT:27BB					     ; in PCDOS	7.1 IBMBIO.COM - SYSINIT:2CBAh)
SYSINIT:27BB					     ; Erdogan Tan - 10/07/2023
SYSINIT:27BE		     pop     si
SYSINIT:27BF		     pop     es
SYSINIT:27C0		     push    cs
SYSINIT:27C1		     pop     ds
SYSINIT:27C2		     cmp     word ptr cs:configmsgflag,	0 ; is error_line msg disabled ?
SYSINIT:27C8		     jz	     short no_error_line_msg ; yes
SYSINIT:27CA		     call    error_line	     ; show "error in config.sys ..." message.
SYSINIT:27CD		     mov     word ptr cs:configmsgflag,	0 ; set	the default value again.
SYSINIT:27D4
SYSINIT:27D4 no_error_line_msg:			     ; ...
SYSINIT:27D4		     jmp     coff
SYSINIT:27D7 ; ---------------------------------------------------------------------------
SYSINIT:27D7
SYSINIT:27D7 was_device_com:			     ; ...
SYSINIT:27D7		     mov     ax, word ptr cs:DevBrkAddr+2
SYSINIT:27DB		     cmp     ax, cs:DevLoadEnd
SYSINIT:27E0		     jbe     short breakok
SYSINIT:27E2		     pop     si
SYSINIT:27E3		     pop     es
SYSINIT:27E4		     jmp     BadFile
SYSINIT:27E7 ; ---------------------------------------------------------------------------
SYSINIT:27E7
SYSINIT:27E7 breakok:				     ; ...
SYSINIT:27E7		     lds     dx, cs:DevEntry ; set ds:dx to header
SYSINIT:27EC		     assume ds:nothing
SYSINIT:27EC		     mov     si, dx
SYSINIT:27EE		     les     di, cs:DOSINFO  ; es:di point to dos info
SYSINIT:27F3		     mov     ax, [si+4]	     ; [si+SYSDEV.ATT] ; get attributes
SYSINIT:27F6		     test    ax, 8000h	     ; DEVTYP ;	test if	block dev
SYSINIT:27F9		     jz	     short isblock
SYSINIT:27FB		     or	     cs:setdevmarkflag,	2 ; for_devmark
SYSINIT:2801		     call    DevSetBreak     ; go ahead	and alloc mem for device
SYSINIT:2804
SYSINIT:2804 jc_edd:				     ; ...
SYSINIT:2804		     jb	     short erase_dev_do	; device driver's init routine failed.
SYSINIT:2806		     test    ax, 1	     ; ISCIN ; is it a console in?
SYSINIT:2809		     jz	     short tryclk
SYSINIT:280B		     mov     es:[di+0Ch], dx ; [es:di+SYSI_CON]
SYSINIT:280F		     mov     word ptr es:[di+0Eh], ds ;	[es:di+SYSI_CON+2]
SYSINIT:2813
SYSINIT:2813 tryclk:				     ; ...
SYSINIT:2813		     test    ax, 8	     ; ISCLOCK ; is it a clock device?
SYSINIT:2816		     jz	     short golink
SYSINIT:2818		     mov     es:[di+8],	dx   ; [es:di+SYSI_CLOCK]
SYSINIT:281C		     mov     word ptr es:[di+0Ah], ds ;	[es:di+SYSI_CLOCK]
SYSINIT:2820
SYSINIT:2820 golink:				     ; ...
SYSINIT:2820		     jmp     linkit
SYSINIT:2823 ; ---------------------------------------------------------------------------
SYSINIT:2823
SYSINIT:2823 isblock:				     ; ...
SYSINIT:2823		     mov     al, cs:unitcount
SYSINIT:2827		     or	     al, al	     ; if no units found, erase	the device
SYSINIT:2829		     jz	     short erase_dev_do
SYSINIT:282B		     mov     [si+0Ah], al    ; [si+SYSDEV.NAME]
SYSINIT:282B					     ; number of units in name field
SYSINIT:282E		     add     cs:driver_units, al ; keep	total for all drivers in file
SYSINIT:2833
SYSINIT:2833 perdrv:				     ; warning no device > 127 units
SYSINIT:2833		     cbw
SYSINIT:2834		     mov     cx, ax
SYSINIT:2836		     mov     dh, ah
SYSINIT:2838		     mov     dl, es:[di+20h] ; [es:di+SYSI_NUMIO]
SYSINIT:2838					     ; get number of devices
SYSINIT:283C		     mov     ah, dl
SYSINIT:283E		     add     ah, al	     ; check for too many devices
SYSINIT:2840		     cmp     ah, 26	     ; 'A' - 'Z' is 26 devices
SYSINIT:2843		     jbe     short ok_block
SYSINIT:2845		     jmp     badnumblock
SYSINIT:2848 ; ---------------------------------------------------------------------------
SYSINIT:2848
SYSINIT:2848 ok_block:				     ; ...
SYSINIT:2848		     or	     cs:setdevmarkflag,	2 ; for_devmark
SYSINIT:284E		     call    DevSetBreak     ; alloc the device
SYSINIT:2851		     jb	     short jc_edd
SYSINIT:2853		     add     es:[di+20h], al ; [es:di+SYSI_NUMIO]
SYSINIT:2853					     ; update the amount
SYSINIT:2857		     add     cs:drivenumber, al	; remember amount for next device
SYSINIT:285C		     lds     bx, cs:bpb_addr ; point to	bpb array
SYSINIT:2861
SYSINIT:2861 perunit:				     ; ...
SYSINIT:2861		     les     bp, cs:DOSINFO
SYSINIT:2866		     les     bp, es:[bp+0]   ; [es:bp+SYSI_DPB]	; get first dpb
SYSINIT:286A
SYSINIT:286A scandpb:				     ; ...
SYSINIT:286A		     cmp     word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB],-1
SYSINIT:286F		     jz	     short founddpb
SYSINIT:2871		     les     bp, es:[bp+19h] ; [es:bp+DPB.NEXT_DPB] ; [es:bp+25]
SYSINIT:2875		     jmp     short scandpb
SYSINIT:2877 ; ---------------------------------------------------------------------------
SYSINIT:2877
SYSINIT:2877 founddpb:				     ; ...
SYSINIT:2877		     mov     ax, word ptr cs:DevBrkAddr
SYSINIT:287B		     mov     es:[bp+19h], ax ; [es:bp+DPB.NEXT_DPB]
SYSINIT:287F		     mov     ax, word ptr cs:DevBrkAddr+2
SYSINIT:2883		     mov     es:[bp+1Bh], ax ; [es:bp+DPB.NEXT_DPB+2]
SYSINIT:2887		     les     bp, cs:DevBrkAddr
SYSINIT:288C		     add     word ptr cs:DevBrkAddr, 33	; DPBSIZ = 33
SYSINIT:288C					     ; (61 in PCDOS 7.1	IBMBIO.COM)
SYSINIT:2892		     call    RoundBreakAddr
SYSINIT:2895		     mov     word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB],-1
SYSINIT:289B		     mov     byte ptr es:[bp+18h], 0FFh	; [es:bp+DPB.FIRST_ACCESS],-1 ;	byte
SYSINIT:28A0		     mov     si, [bx]	     ; ds:si points to bpb
SYSINIT:28A2		     inc     bx
SYSINIT:28A3		     inc     bx		     ; point to	next bpb
SYSINIT:28A4		     mov     es:[bp+0],	dx   ; [es:bp+DPB.DRIVE]
SYSINIT:28A8		     mov     ah, 53h	     ; SETDPB ;	hidden system call
SYSINIT:28AA		     int     21h	     ; DOS - 2+	internal - TRANSLATE BIOS PARAMETER BLOCK
SYSINIT:28AA					     ; DS:SI ->	BPB (BIOS Parameter Block)
SYSINIT:28AA					     ; ES:BP ->	buffer for DOS Drive Parameter Block
SYSINIT:28AC		     mov     ax, es:[bp+2]   ; [es:bp+DPB.SECTOR_SIZE]
SYSINIT:28B0		     push    es
SYSINIT:28B1		     les     di, cs:DOSINFO  ; es:di point to dos info
SYSINIT:28B6		     cmp     ax, es:[di+10h] ; [es:di+SYSI_MAXSEC]
SYSINIT:28BA		     pop     es
SYSINIT:28BB		     jbe     short iblk_1
SYSINIT:28BD		     jmp     bad_bpb_size_sector
SYSINIT:28C0 ; ---------------------------------------------------------------------------
SYSINIT:28C0
SYSINIT:28C0 iblk_1:				     ; ...
SYSINIT:28C0		     push    ds
SYSINIT:28C1		     push    dx
SYSINIT:28C2		     lds     dx, cs:DevEntry
SYSINIT:28C7		     mov     es:[bp+13h], dx ; [es:bp+DPB.DRIVER_ADDR]
SYSINIT:28CB		     mov     word ptr es:[bp+15h], ds ;	[es:bp+DPB.DRIVER_ADDR+2]
SYSINIT:28CF		     pop     dx
SYSINIT:28D0		     pop     ds
SYSINIT:28D1		     inc     dx
SYSINIT:28D2		     inc     dh
SYSINIT:28D4		     loop    perunit	     ; cx = cx - 1
SYSINIT:28D4					     ; cx = remain count from [cs:unitcount]
SYSINIT:28D4					     ; loop until cx is	0
SYSINIT:28D6		     push    cs
SYSINIT:28D7		     pop     ds
SYSINIT:28D8		     assume ds:SYSINIT
SYSINIT:28D8		     call    TempCDS
SYSINIT:28DB
SYSINIT:28DB linkit:				     ; ...
SYSINIT:28DB		     les     di, cs:DOSINFO  ; es:di = dos table
SYSINIT:28E0		     mov     cx, es:[di+22h] ; [es:di+SYSI_DEV]	; dx:cx	= head of list
SYSINIT:28E4		     mov     dx, es:[di+24h] ; [es:di+SYSI_DEV+2]
SYSINIT:28E8		     lds     si, cs:DevEntry ; ds:si = device location
SYSINIT:28ED		     assume ds:nothing
SYSINIT:28ED		     mov     es:[di+22h], si ; set head	of list	in dos
SYSINIT:28ED					     ; [es:di+SYSI_DEV]
SYSINIT:28F1		     mov     word ptr es:[di+24h], ds ;	[es:di+SYSI_DEV+2]
SYSINIT:28F5		     mov     ax, [si]	     ; get pointer to next device
SYSINIT:28F7		     mov     word ptr cs:DevEntry, ax ;	and save it
SYSINIT:28FB		     mov     [si], cx	     ; link in the driver
SYSINIT:28FD		     mov     [si+2], dx
SYSINIT:2900		     pop     si
SYSINIT:2901		     pop     es
SYSINIT:2902		     inc     ax		     ; ax = 0FFFFh (no more devs if yes)?
SYSINIT:2903		     jz	     short coffj3
SYSINIT:2905		     inc     cs:multdeviceflag ; possibly multiple device driver.
SYSINIT:290A		     call    DevBreak
SYSINIT:290D		     jmp     goodld	     ; otherwise pretend we loaded it in
SYSINIT:2910 ; ---------------------------------------------------------------------------
SYSINIT:2910
SYSINIT:2910 coffj3:				     ; ...
SYSINIT:2910		     mov     cs:multdeviceflag,	0 ; reset the flag
SYSINIT:2916		     call    DevBreak
SYSINIT:2919		     call    CheckProtmanArena ; adjust	alloclim if Protman$ just
SYSINIT:2919					     ; created a bogus arena to	try
SYSINIT:2919					     ; to protect some of its resident-
SYSINIT:2919					     ; init code.
SYSINIT:291C		     call    CheckDoubleSpace ;
SYSINIT:291C					     ; inquire of MagicDrv whether it is present,
SYSINIT:291C					     ; and final located
SYSINIT:291F		     jmp     coff
SYSINIT:291F multi_pass	     endp
SYSINIT:291F
SYSINIT:2922
SYSINIT:2922 ; =============== S U B R O U T I N E =======================================
SYSINIT:2922
SYSINIT:2922
SYSINIT:2922 CheckDoubleSpace proc near		     ; ...
SYSINIT:2922		     cmp     cs:MagicHomeFlag, 0 ; already home?
SYSINIT:2928		     jnz     short no_more_magic_calls ; nothing more to do if so
SYSINIT:292A		     mov     ax, 4A11h	     ; multMagicdrv
SYSINIT:292D		     mov     bx, 0	     ; MD_VERSION
SYSINIT:2930		     int     2Fh	     ;	ch = number of MagicDrv	drive letters
SYSINIT:2932		     or	     ax, ax	     ; is it there?
SYSINIT:2934		     jnz     short no_more_magic_calls ; done if not
SYSINIT:2936		     test    dx, 8000h	     ; is it final placed?
SYSINIT:293A		     jnz     short magic_not_yet_home ;	skip if	not
SYSINIT:293C		     mov     cs:MagicHomeFlag, 0FFh ; set the flag!
SYSINIT:2942		     add     cs:drivenumber, ch	; add number of	MagicDrv volumes to
SYSINIT:2942					     ; the drive number	we'll pass to the
SYSINIT:2942					     ; next loadable block device.
SYSINIT:2947		     jmp     short no_more_magic_calls ; and finished.
SYSINIT:2947					     ; (retn)
SYSINIT:2949 ; ---------------------------------------------------------------------------
SYSINIT:2949
SYSINIT:2949 magic_not_yet_home:		     ; ...
SYSINIT:2949		     push    es
SYSINIT:294A		     push    si
SYSINIT:294B		     mov     cx, cs:memhi    ; pass it a work buffer
SYSINIT:2950		     mov     dx, cs:ALLOCLIM ; address in cx (segment)
SYSINIT:2955		     sub     dx, cx	     ; for len dx (paragraphs)
SYSINIT:2957		     mov     bx, 2
SYSINIT:295A		     mov     al, cs:driver_units ; shuffle magicdrives and new drives
SYSINIT:295A					     ; by this many units
SYSINIT:295E		     mov     ah, 55h	     ; backdoor	won't shuffle unless it
SYSINIT:295E					     ; sees this, to prevent bad things
SYSINIT:295E					     ; from happening if people	run the
SYSINIT:295E					     ; new driver with an old (dos) BIOS
SYSINIT:2960		     call    cs:Magicbackdoor
SYSINIT:2965		     pop     si
SYSINIT:2966		     pop     es
SYSINIT:2967
SYSINIT:2967 no_more_magic_calls:		     ; ...
SYSINIT:2967		     retn
SYSINIT:2967 CheckDoubleSpace endp
SYSINIT:2967
SYSINIT:2968 ; ---------------------------------------------------------------------------
SYSINIT:2968 ; START OF	FUNCTION CHUNK FOR multi_pass
SYSINIT:2968
SYSINIT:2968 bad_bpb_size_sector:		     ; ...
SYSINIT:2968		     pop     si
SYSINIT:2969		     pop     es
SYSINIT:296A		     mov     dx, offset	badsiz_pre ; "\r\nSector size too large	in file	$"
SYSINIT:296D		     mov     bx, offset	crlfm ;	"\r\n$"
SYSINIT:2970		     call    prnerr
SYSINIT:2973		     jmp     coff
SYSINIT:2976 ; ---------------------------------------------------------------------------
SYSINIT:2976
SYSINIT:2976 tryq:				     ; ...
SYSINIT:2976		     cmp     ah, 51h ; 'Q'   ; CONFIG_COUNTRY
SYSINIT:2979		     jz	     short tryq_cont
SYSINIT:297B
SYSINIT:297B skip_it3:				     ; ...
SYSINIT:297B		     jmp     tryf
SYSINIT:297E ; ---------------------------------------------------------------------------
SYSINIT:297E
SYSINIT:297E tryq_cont:				     ; ...
SYSINIT:297E		     call    query_user	     ; query the user if config_cmd
SYSINIT:297E					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2981		     jb	     short skip_it3
SYSINIT:2983		     mov     byte ptr cs:cntry_drv, 0 ;
SYSINIT:2983					     ; reset the drive,path to default value.
SYSINIT:2989		     mov     cs:p_code_page, 0
SYSINIT:2990		     mov     di, offset	cntry_parms
SYSINIT:2993		     xor     cx, cx
SYSINIT:2995		     mov     dx, cx
SYSINIT:2997
SYSINIT:2997 do52:				     ; ...
SYSINIT:2997		     call    sysinit_parse
SYSINIT:299A		     jnb     short if52	     ; parse error,check error code and
SYSINIT:299C		     call    cntry_error     ; show message and	end the	search loop.
SYSINIT:299F		     mov     cs:p_cntry_code, 0FFFFh ; -1 ; signals that parse error.
SYSINIT:29A6		     jmp     short sr52
SYSINIT:29A8 ; ---------------------------------------------------------------------------
SYSINIT:29A8
SYSINIT:29A8 if52:				     ; ...
SYSINIT:29A8		     cmp     ax, 0FFFFh	     ; _$P_RC_EOL ; end	of line?
SYSINIT:29AB		     jz	     short sr52
SYSINIT:29AD		     cmp     cs:result_val, 1 ;	_$P_Number
SYSINIT:29B3		     jnz     short if56
SYSINIT:29B5		     mov     ax, word ptr cs:rv_dword ;
SYSINIT:29B5					     ; [cs:result_val+_$P_Result_Blk.Picked_Val]
SYSINIT:29B9		     cmp     cx, 1
SYSINIT:29BC		     jnz     short if57
SYSINIT:29BE		     mov     cs:p_cntry_code, ax
SYSINIT:29C2		     jmp     short en57
SYSINIT:29C4 ; ---------------------------------------------------------------------------
SYSINIT:29C4
SYSINIT:29C4 if57:				     ; ...
SYSINIT:29C4		     mov     cs:p_code_page, ax
SYSINIT:29C8
SYSINIT:29C8 en57:				     ; ...
SYSINIT:29C8		     jmp     short en56	     ; path entered
SYSINIT:29CA ; ---------------------------------------------------------------------------
SYSINIT:29CA
SYSINIT:29CA if56:				     ; ...
SYSINIT:29CA		     push    ds
SYSINIT:29CB		     push    es
SYSINIT:29CC		     push    si
SYSINIT:29CD		     push    di
SYSINIT:29CE		     push    cs
SYSINIT:29CF		     pop     es
SYSINIT:29D0		     assume es:SYSINIT
SYSINIT:29D0		     lds     si, cs:rv_dword ; move the	path to	known place.
SYSINIT:29D5		     mov     di, offset	cntry_drv ; "A:"
SYSINIT:29D8		     call    move_asciiz
SYSINIT:29DB		     pop     di
SYSINIT:29DC		     pop     si
SYSINIT:29DD		     pop     es
SYSINIT:29DE		     assume es:nothing
SYSINIT:29DE		     pop     ds
SYSINIT:29DF
SYSINIT:29DF en56:				     ; ...
SYSINIT:29DF		     jmp     short do52
SYSINIT:29E1 ; ---------------------------------------------------------------------------
SYSINIT:29E1
SYSINIT:29E1 sr52:				     ; ...
SYSINIT:29E1		     cmp     cs:p_cntry_code, 0FFFFh ; -1 ; had	a parse	error?
SYSINIT:29E7		     jnz     short tryq_open
SYSINIT:29E9		     jmp     coff
SYSINIT:29EC ; ---------------------------------------------------------------------------
SYSINIT:29EC
SYSINIT:29EC tryqbad:				     ; ...
SYSINIT:29EC		     stc
SYSINIT:29ED		     mov     dx, offset	badcountry ; "\r\nInvalid country code or code page\r"...
SYSINIT:29F0		     jmp     tryqchkerr
SYSINIT:29F3 ; ---------------------------------------------------------------------------
SYSINIT:29F3
SYSINIT:29F3 tryq_open:				     ; ...
SYSINIT:29F3		     cmp     byte ptr cs:cntry_drv, 0 ;	"A:"
SYSINIT:29F9		     jz	     short tryq_def
SYSINIT:29FB		     mov     dx, offset	cntry_drv ; "A:"
SYSINIT:29FE		     jmp     short tryq_openit
SYSINIT:2A00 ; ---------------------------------------------------------------------------
SYSINIT:2A00
SYSINIT:2A00 tryq_def:				     ; ...
SYSINIT:2A00		     mov     dx, offset	cntry_root
SYSINIT:2A03
SYSINIT:2A03 tryq_openit:			     ; ...
SYSINIT:2A03		     mov     ax, 3D00h	     ; open a file
SYSINIT:2A06		     stc
SYSINIT:2A07		     int     21h	     ; DOS - 2+	- OPEN DISK FILE WITH HANDLE
SYSINIT:2A07					     ; DS:DX ->	ASCIZ filename
SYSINIT:2A07					     ; AL = access mode
SYSINIT:2A07					     ; 0 - read
SYSINIT:2A09		     jb	     short tryqfilebad
SYSINIT:2A0B		     mov     cs:cntryfilehandle, ax ; save file	handle
SYSINIT:2A0F		     mov     bx, ax
SYSINIT:2A11		     mov     ax, cs:p_cntry_code
SYSINIT:2A15		     mov     dx, cs:p_code_page	; ax=country id, bx=filehandle
SYSINIT:2A1A		     mov     cx, cs:memhi
SYSINIT:2A1F		     add     cx, 384	     ; need 6k buffer to handle	country.sys
SYSINIT:2A1F					     ; (384*16 bytes)
SYSINIT:2A23		     cmp     cx, cs:ALLOCLIM
SYSINIT:2A28		     ja	     short tryqmemory ;	cannot allocate	the buffer for country.sys
SYSINIT:2A2A		     mov     si, offset	cntry_drv ; "A:"
SYSINIT:2A2D		     cmp     byte ptr [si], 0 ;	default	path?
SYSINIT:2A30		     jnz     short tryq_set_for_dos ; no
SYSINIT:2A32		     inc     si
SYSINIT:2A33		     inc     si		     ; ds:si ->	cntry_root
SYSINIT:2A34
SYSINIT:2A34 tryq_set_for_dos:			     ; ...
SYSINIT:2A34		     les     di, cs:sysi_country ; es:di -> country info tab in	dos
SYSINIT:2A39		     push    di		     ; save di
SYSINIT:2A3A		     add     di, 8	     ; country_cdpg_info.ccPath_CountrySys
SYSINIT:2A3D		     call    move_asciiz     ; set the path to country.sys in dos.
SYSINIT:2A40		     pop     di		     ; es:di ->	country	info tab again.
SYSINIT:2A41		     mov     cx, cs:memhi
SYSINIT:2A46		     mov     ds, cx
SYSINIT:2A48		     xor     si, si	     ; ds:si ->	2k buffer to be	used.
SYSINIT:2A4A		     call    setdoscountryinfo ; now do	the job!
SYSINIT:2A4D		     jnb     short tryqchkerr ;	read error or could not	find country,
SYSINIT:2A4D					     ; code page combination
SYSINIT:2A4F		     cmp     cx, 0FFFFh	     ; -1
SYSINIT:2A4F					     ; could not find matching country_id, code	page?
SYSINIT:2A52		     jz	     short tryqbad   ; then "invalid country code or code page"
SYSINIT:2A54
SYSINIT:2A54 tryqfilebad:			     ; ...
SYSINIT:2A54		     push    cs
SYSINIT:2A55		     pop     es
SYSINIT:2A56		     assume es:SYSINIT
SYSINIT:2A56		     cmp     byte ptr cs:cntry_drv, 0 ;	is the default file used?
SYSINIT:2A5C		     jz	     short tryqdefbad
SYSINIT:2A5E		     mov     si, offset	cntry_drv ; "A:"
SYSINIT:2A61		     jmp     short tryqbadload
SYSINIT:2A63 ; ---------------------------------------------------------------------------
SYSINIT:2A63
SYSINIT:2A63 tryqdefbad:			     ; ...
SYSINIT:2A63		     mov     si, offset	cntry_root ; default file has been used.
SYSINIT:2A63					     ; es:si ->	\country.sys in	sysinit_seg
SYSINIT:2A66
SYSINIT:2A66 tryqbadload:			     ; ...
SYSINIT:2A66		     call    badload
SYSINIT:2A69		     mov     cx, cs:CONFBOT
SYSINIT:2A6E		     mov     es, cx	     ; restore es -> confbot.
SYSINIT:2A70		     assume es:nothing
SYSINIT:2A70		     jmp     short coffj4
SYSINIT:2A72 ; ---------------------------------------------------------------------------
SYSINIT:2A72
SYSINIT:2A72 tryqmemory:			     ; ...
SYSINIT:2A72		     mov     dx, offset	insufmemory ; "\r\nInsufficient	memory for COUNTRY.SYS"...
SYSINIT:2A75
SYSINIT:2A75 tryqchkerr:			     ; ...
SYSINIT:2A75		     mov     cx, cs:CONFBOT
SYSINIT:2A7A		     mov     es, cx	     ; restore es -> confbot seg
SYSINIT:2A7C		     push    cs
SYSINIT:2A7D		     pop     ds		     ; restore ds to sysinit_seg
SYSINIT:2A7E		     assume ds:SYSINIT
SYSINIT:2A7E		     jnb     short coffj4    ; if no error,then	exit
SYSINIT:2A80		     call    print	     ; else show error message
SYSINIT:2A83		     call    error_line
SYSINIT:2A86
SYSINIT:2A86 coffj4:				     ; ...
SYSINIT:2A86		     mov     bx, cs:cntryfilehandle ; close a file.
SYSINIT:2A86					     ; don't care even if it fails.
SYSINIT:2A8B		     mov     ah, 3Eh
SYSINIT:2A8D		     int     21h	     ; DOS - 2+	- CLOSE	A FILE WITH HANDLE
SYSINIT:2A8D					     ; BX = file handle
SYSINIT:2A8F		     jmp     coff
SYSINIT:2A8F ; END OF FUNCTION CHUNK FOR multi_pass
SYSINIT:2A92
SYSINIT:2A92 ; =============== S U B R O U T I N E =======================================
SYSINIT:2A92
SYSINIT:2A92
SYSINIT:2A92 cntry_error     proc near		     ; ...
SYSINIT:2A92		     cmp     ax, 6	     ; _$P_Out_Of_Range
SYSINIT:2A95		     jnz     short if64
SYSINIT:2A97		     mov     dx, offset	badcountry ; "\r\nInvalid country code or code page\r"...
SYSINIT:2A9A		     jmp     short en64
SYSINIT:2A9C ; ---------------------------------------------------------------------------
SYSINIT:2A9C
SYSINIT:2A9C if64:				     ; ...
SYSINIT:2A9C		     mov     dx, offset	badcountrycom ;	"\r\nError in COUNTRY command\r\n$"
SYSINIT:2A9F
SYSINIT:2A9F en64:				     ; ...
SYSINIT:2A9F		     call    print
SYSINIT:2AA2		     call    error_line
SYSINIT:2AA5		     retn
SYSINIT:2AA5 cntry_error     endp
SYSINIT:2AA5
SYSINIT:2AA6 ; ---------------------------------------------------------------------------
SYSINIT:2AA6 ; START OF	FUNCTION CHUNK FOR multi_pass
SYSINIT:2AA6
SYSINIT:2AA6 tryf:				     ; ...
SYSINIT:2AA6		     cmp     ah, 46h ; 'F'   ; CONFIG_FILES
SYSINIT:2AA9		     jnz     short tryl
SYSINIT:2AAB		     call    query_user	     ; query the user if config_cmd
SYSINIT:2AAB					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2AAE		     jb	     short tryl
SYSINIT:2AB0		     mov     di, offset	files_parms
SYSINIT:2AB3		     xor     cx, cx
SYSINIT:2AB5		     mov     dx, cx
SYSINIT:2AB7
SYSINIT:2AB7 do67:				     ; ...
SYSINIT:2AB7		     call    sysinit_parse
SYSINIT:2ABA		     jnb     short if67	     ;
SYSINIT:2ABA					     ; parse error
SYSINIT:2ABA					     ; show messages and end the search	loop.
SYSINIT:2ABC		     call    badparm_p
SYSINIT:2ABF		     jmp     short sr67
SYSINIT:2AC1 ; ---------------------------------------------------------------------------
SYSINIT:2AC1
SYSINIT:2AC1 if67:				     ; ...
SYSINIT:2AC1		     cmp     ax, 0FFFFh	     ; _$P_RC_EOL ; end	of line?
SYSINIT:2AC4		     jz	     short en67	     ; then end	the $endloop
SYSINIT:2AC6		     mov     al, byte ptr cs:rv_dword ;
SYSINIT:2AC6					     ; [result_val+_$P_Result_Blk.Picked_Val]
SYSINIT:2ACA		     mov     cs:p_files, al  ; save it temporarily
SYSINIT:2ACE		     jmp     short do67
SYSINIT:2AD0 ; ---------------------------------------------------------------------------
SYSINIT:2AD0
SYSINIT:2AD0 en67:				     ; ...
SYSINIT:2AD0		     mov     al, cs:p_files
SYSINIT:2AD4		     mov     cs:FILES, al    ; no error. really	set the	value now.
SYSINIT:2AD8
SYSINIT:2AD8 sr67:				     ; ...
SYSINIT:2AD8		     jmp     coff
SYSINIT:2ADB ; ---------------------------------------------------------------------------
SYSINIT:2ADB
SYSINIT:2ADB tryl:				     ; ...
SYSINIT:2ADB		     cmp     ah, 4Ch ; 'L'   ; CONFIG_LASTDRIVE
SYSINIT:2ADE		     jnz     short tryp
SYSINIT:2AE0		     call    query_user	     ; query the user if config_cmd
SYSINIT:2AE0					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2AE3		     jb	     short tryp
SYSINIT:2AE5		     mov     di, offset	ldrv_parms
SYSINIT:2AE8		     xor     cx, cx
SYSINIT:2AEA		     mov     dx, cx
SYSINIT:2AEC
SYSINIT:2AEC do73:				     ; ...
SYSINIT:2AEC		     call    sysinit_parse
SYSINIT:2AEF		     jnb     short if73	     ;
SYSINIT:2AEF					     ; parse error
SYSINIT:2AEF					     ; show messages and end the search	loop.
SYSINIT:2AF1		     call    badparm_p
SYSINIT:2AF4		     jmp     short badparm_p_coff
SYSINIT:2AF6 ; ---------------------------------------------------------------------------
SYSINIT:2AF6
SYSINIT:2AF6 if73:				     ; ...
SYSINIT:2AF6		     cmp     ax, 0FFFFh	     ; _$P_RC_EOL ; end	of line?
SYSINIT:2AF9		     jz	     short en73	     ; then end	the $endloop
SYSINIT:2AFB		     mov     al, byte ptr cs:rv_dword ;	[rv_byte]
SYSINIT:2AFB					     ; pick up the drive number
SYSINIT:2AFF		     mov     cs:p_ldrv,	al   ; save it temporarily
SYSINIT:2B03		     jmp     short do73
SYSINIT:2B05 ; ---------------------------------------------------------------------------
SYSINIT:2B05
SYSINIT:2B05 en73:				     ; ...
SYSINIT:2B05		     mov     al, cs:p_ldrv
SYSINIT:2B09		     mov     cs:NUM_CDS, al  ; no error.
SYSINIT:2B09					     ; really set the value now.
SYSINIT:2B0D
SYSINIT:2B0D badparm_p_coff:			     ; ...
SYSINIT:2B0D		     jmp     coff
SYSINIT:2B10 ; ---------------------------------------------------------------------------
SYSINIT:2B10
SYSINIT:2B10 tryp:				     ; ...
SYSINIT:2B10		     cmp     ah, 50h ; 'P'   ; CONFIG_DRIVPARM
SYSINIT:2B13		     jnz     short tryk
SYSINIT:2B15		     call    query_user	     ; query the user if config_cmd
SYSINIT:2B15					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2B18		     jb	     short tryk
SYSINIT:2B1A		     call    parseline
SYSINIT:2B1D		     jb	     short trypbad
SYSINIT:2B1F		     call    setparms
SYSINIT:2B22		     call    diddleback
SYSINIT:2B25		     jmp     coff
SYSINIT:2B28 ; ---------------------------------------------------------------------------
SYSINIT:2B28
SYSINIT:2B28 trypbad:				     ; ...
SYSINIT:2B28		     jmp     badop
SYSINIT:2B2B ; ---------------------------------------------------------------------------
SYSINIT:2B2B
SYSINIT:2B2B tryk:				     ; ...
SYSINIT:2B2B		     cmp     ah, 4Bh ; 'K'   ; CONFIG_STACKS
SYSINIT:2B2E		     jz	     short do_tryk
SYSINIT:2B30
SYSINIT:2B30 skip_it4:				     ; ...
SYSINIT:2B30		     jmp     trys
SYSINIT:2B33 ; ---------------------------------------------------------------------------
SYSINIT:2B33
SYSINIT:2B33 do_tryk:				     ; ...
SYSINIT:2B33		     call    query_user	     ; query the user if config_cmd
SYSINIT:2B33					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2B36		     jb	     short skip_it4
SYSINIT:2B38		     mov     di, offset	stks_parms
SYSINIT:2B3B		     xor     cx, cx
SYSINIT:2B3D		     mov     dx, cx
SYSINIT:2B3F
SYSINIT:2B3F do79:				     ; ...
SYSINIT:2B3F		     call    sysinit_parse
SYSINIT:2B42		     jnb     short if79	     ; parse error
SYSINIT:2B44		     mov     dx, offset	badstack ; "\r\nInvalid	STACK parameters\r\n$"
SYSINIT:2B47		     call    print	     ; show messages and end the search	loop.
SYSINIT:2B4A		     call    error_line
SYSINIT:2B4D		     jmp     sr79	     ; (jmp coff)
SYSINIT:2B50 ; ---------------------------------------------------------------------------
SYSINIT:2B50
SYSINIT:2B50 if79:				     ; ...
SYSINIT:2B50		     cmp     ax, 0FFFFh	     ; _$P_RC_EOL ; end	of line?
SYSINIT:2B53		     jz	     short en79	     ; then end	the $endloop
SYSINIT:2B55		     mov     ax, word ptr cs:rv_dword ;
SYSINIT:2B55					     ; [cs:result_val+_$P_Result_Blk.Picked_Val]
SYSINIT:2B59		     cmp     cx, 1
SYSINIT:2B5C		     jnz     short if83
SYSINIT:2B5E		     mov     cs:p_stack_count, ax
SYSINIT:2B62		     jmp     short en83
SYSINIT:2B64 ; ---------------------------------------------------------------------------
SYSINIT:2B64
SYSINIT:2B64 if83:				     ; ...
SYSINIT:2B64		     mov     cs:p_stack_size, ax
SYSINIT:2B68
SYSINIT:2B68 en83:				     ; ...
SYSINIT:2B68		     jmp     short do79
SYSINIT:2B6A ; ---------------------------------------------------------------------------
SYSINIT:2B6A
SYSINIT:2B6A en79:				     ; ...
SYSINIT:2B6A		     cmp     cs:p_stack_count, 0
SYSINIT:2B70		     jz	     short if87
SYSINIT:2B72		     cmp     cs:p_stack_count, 8 ; mincount
SYSINIT:2B78		     jb	     short ll88
SYSINIT:2B7A		     cmp     cs:p_stack_size, 32 ; minsize
SYSINIT:2B80		     jnb     short if88
SYSINIT:2B82
SYSINIT:2B82 ll88:				     ; ...
SYSINIT:2B82		     mov     cs:p_stack_count, 0FFFFh
SYSINIT:2B89
SYSINIT:2B89 if88:				     ; ...
SYSINIT:2B89		     jmp     short en87
SYSINIT:2B8B ; ---------------------------------------------------------------------------
SYSINIT:2B8B
SYSINIT:2B8B if87:				     ; ...
SYSINIT:2B8B		     cmp     cs:p_stack_size, 0
SYSINIT:2B91		     jz	     short en87
SYSINIT:2B93		     mov     cs:p_stack_count, 0FFFFh ;	-1 ; invalid
SYSINIT:2B9A
SYSINIT:2B9A en87:				     ; ...
SYSINIT:2B9A		     cmp     cs:p_stack_count, 0FFFFh ;	-1 ; invalid?
SYSINIT:2BA0		     jnz     short if94
SYSINIT:2BA2		     mov     cs:stack_count, 9 ; defaultcount
SYSINIT:2BA2					     ; reset to	default	value.
SYSINIT:2BA9		     mov     cs:stack_size, 128	; defaultsize
SYSINIT:2BB0		     mov     cs:stack_addr, 0 ;	stacks=	been accepted.
SYSINIT:2BB7		     mov     dx, offset	badstack ; "\r\nInvalid	STACK parameters\r\n$"
SYSINIT:2BBA		     call    print
SYSINIT:2BBD		     call    error_line
SYSINIT:2BC0		     jmp     short sr79
SYSINIT:2BC2 ; ---------------------------------------------------------------------------
SYSINIT:2BC2
SYSINIT:2BC2 if94:				     ; ...
SYSINIT:2BC2		     mov     ax, cs:p_stack_count
SYSINIT:2BC6		     mov     cs:stack_count, ax
SYSINIT:2BCA		     mov     ax, cs:p_stack_size
SYSINIT:2BCE		     mov     cs:stack_size, ax
SYSINIT:2BD2		     mov     cs:stack_addr, 0FFFFh ; -1	; stacks= been accepted.
SYSINIT:2BD9
SYSINIT:2BD9 sr79:				     ; ...
SYSINIT:2BD9		     jmp     coff
SYSINIT:2BDC ; ---------------------------------------------------------------------------
SYSINIT:2BDC
SYSINIT:2BDC trys:				     ; ...
SYSINIT:2BDC		     cmp     ah, 53h ; 'S'   ; CONFIG_SHELL
SYSINIT:2BDF		     jnz     short tryx
SYSINIT:2BE1		     call    query_user	     ; query the user if config_cmd
SYSINIT:2BE1					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2BE4		     jb	     short tryx
SYSINIT:2BE6		     mov     cs:newcmd,	1
SYSINIT:2BEC		     mov     word ptr cs:command_line, 0 ;
SYSINIT:2BEC					     ; zap length,first	byte of	command-line
SYSINIT:2BF3		     mov     di, (offset commnd+1) ; we	already	have the first char
SYSINIT:2BF6		     mov     [di-1], al	     ; of the new shell	in AL, save it now
SYSINIT:2BF9
SYSINIT:2BF9 storeshell:			     ; ...
SYSINIT:2BF9		     call    getchr
SYSINIT:2BFC		     or	     al, al	     ; this is the normal case:	"organize"
SYSINIT:2BFE		     jz	     short getshparms ;	put a ZERO right after the filename
SYSINIT:2C00		     cmp     al, 20h ; ' '   ; this may happen if there are no args
SYSINIT:2C02		     jb	     short endofshell ;	I suppose...
SYSINIT:2C04		     mov     [di], al
SYSINIT:2C06		     inc     di
SYSINIT:2C07		     cmp     di, offset	commnd_63 ; commnd+63
SYSINIT:2C07					     ; this makes sure we don't overflow
SYSINIT:2C07					     ; commnd (the filename)
SYSINIT:2C0B		     jb	     short storeshell
SYSINIT:2C0D		     jmp     short endofshell
SYSINIT:2C0F ; ---------------------------------------------------------------------------
SYSINIT:2C0F
SYSINIT:2C0F getshparms:			     ; ...
SYSINIT:2C0F		     mov     byte ptr [di], 0 ;	zero-terminate the filename
SYSINIT:2C12		     mov     di, (offset command_line+1) ;
SYSINIT:2C12					     ; prepare to process the command-line
SYSINIT:2C15
SYSINIT:2C15 parmloop:				     ; ...
SYSINIT:2C15		     call    getchr
SYSINIT:2C18		     cmp     al, 20h ; ' '
SYSINIT:2C1A		     jb	     short endofparms
SYSINIT:2C1C		     mov     [di], al
SYSINIT:2C1E		     inc     di
SYSINIT:2C1F		     cmp     di, offset	command_line_126 ; command_line+126
SYSINIT:2C23		     jb	     short parmloop
SYSINIT:2C25
SYSINIT:2C25 endofparms:			     ; ...
SYSINIT:2C25		     mov     cx, di
SYSINIT:2C27		     sub     cx, (offset command_line+1)
SYSINIT:2C2B		     mov     byte ptr cs:command_line, cl ; "\x02/P"
SYSINIT:2C30
SYSINIT:2C30 endofshell:			     ; ...
SYSINIT:2C30		     mov     byte ptr [di], 0 ;	zero-terminate the filename
SYSINIT:2C30					     ; (or the command-line as the case	may be)
SYSINIT:2C33
SYSINIT:2C33 skipline:				     ; ...
SYSINIT:2C33		     cmp     al, 0Ah	     ; lf ; the	safest way to eat the rest of
SYSINIT:2C35		     jz	     short endofline ; the line: watch for ever-present	LF
SYSINIT:2C37		     call    getchr
SYSINIT:2C3A		     jnb     short skipline
SYSINIT:2C3C
SYSINIT:2C3C endofline:				     ; ...
SYSINIT:2C3C		     jmp     conflp
SYSINIT:2C3F ; ---------------------------------------------------------------------------
SYSINIT:2C3F
SYSINIT:2C3F tryx:				     ; ...
SYSINIT:2C3F		     cmp     ah, 58h ; 'X'   ; CONFIG_FCBS
SYSINIT:2C42		     jnz     short try1
SYSINIT:2C44		     call    query_user	     ; query the user if config_cmd
SYSINIT:2C44					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2C47		     jb	     short try1
SYSINIT:2C49		     mov     di, 2153h
SYSINIT:2C4C		     xor     cx, cx
SYSINIT:2C4E		     mov     dx, cx
SYSINIT:2C50
SYSINIT:2C50 do98:				     ; ...
SYSINIT:2C50		     call    sysinit_parse
SYSINIT:2C53		     jnb     short if98
SYSINIT:2C55		     call    badparm_p	     ; parse error
SYSINIT:2C55					     ; show messages and end the search	loop.
SYSINIT:2C58		     jmp     short sr98
SYSINIT:2C5A ; ---------------------------------------------------------------------------
SYSINIT:2C5A
SYSINIT:2C5A if98:				     ; ...
SYSINIT:2C5A		     cmp     ax, 0FFFFh	     ; _$P_RC_EOL ; end	of line?
SYSINIT:2C5D		     jz	     short en98	     ; then end	the $endloop
SYSINIT:2C5F		     mov     al, byte ptr cs:rv_dword ;
SYSINIT:2C5F					     ; [cs:result_val+_$P_Result_Blk.Picked_Val]
SYSINIT:2C63		     cmp     cx, 1	     ; the first positional?
SYSINIT:2C66		     jnz     short if102
SYSINIT:2C68		     mov     cs:p_fcbs,	al
SYSINIT:2C6C		     jmp     short en102
SYSINIT:2C6E ; ---------------------------------------------------------------------------
SYSINIT:2C6E
SYSINIT:2C6E if102:				     ; ...
SYSINIT:2C6E		     mov     cs:p_keep,	al
SYSINIT:2C72
SYSINIT:2C72 en102:				     ; ...
SYSINIT:2C72		     jmp     short do98
SYSINIT:2C74 ; ---------------------------------------------------------------------------
SYSINIT:2C74
SYSINIT:2C74 en98:				     ; ...
SYSINIT:2C74		     mov     al, cs:p_fcbs
SYSINIT:2C78		     mov     cs:FCBS, al
SYSINIT:2C7C		     mov     cs:KEEP, 0
SYSINIT:2C82
SYSINIT:2C82 sr98:				     ; ...
SYSINIT:2C82		     jmp     coff
SYSINIT:2C85 ; ---------------------------------------------------------------------------
SYSINIT:2C85
SYSINIT:2C85 try1:				     ; ...
SYSINIT:2C85		     cmp     ah, 31h ; '1'   ; CONFIG_SWITCHES
SYSINIT:2C85					     ; switches= command entered?
SYSINIT:2C88		     jz	     short do_try1   ; yes
SYSINIT:2C8A
SYSINIT:2C8A skip_it5:				     ; ...
SYSINIT:2C8A		     jmp     tryv
SYSINIT:2C8D ; ---------------------------------------------------------------------------
SYSINIT:2C8D
SYSINIT:2C8D do_try1:				     ; ...
SYSINIT:2C8D		     call    query_user	     ; query the user if config_cmd
SYSINIT:2C8D					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2C90		     jb	     short skip_it5
SYSINIT:2C92		     mov     di, offset	swit_parms
SYSINIT:2C95		     xor     cx, cx
SYSINIT:2C97		     mov     dx, cx
SYSINIT:2C99
SYSINIT:2C99 do110:				     ; ...
SYSINIT:2C99		     call    sysinit_parse
SYSINIT:2C9C		     jnb     short if110     ;
SYSINIT:2C9C					     ; parse error
SYSINIT:2C9C					     ; show messages and end the search	loop.
SYSINIT:2C9E		     call    badparm_p
SYSINIT:2CA1		     jmp     short sr110
SYSINIT:2CA3 ; ---------------------------------------------------------------------------
SYSINIT:2CA3
SYSINIT:2CA3 if110:				     ; ...
SYSINIT:2CA3		     cmp     ax, 0FFFFh	     ; _$P_RC_EOL ; end	of line?
SYSINIT:2CA6		     jz	     short en110     ; then jmp	to $endloop for	semantic check
SYSINIT:2CA8		     cmp     cs:result_val_swoff, offset swit_k	; offset "/K"
SYSINIT:2CA8					     ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
SYSINIT:2CAF		     jnz     short if115
SYSINIT:2CB1		     mov     cs:p_swit_k, 1  ; set the flag
SYSINIT:2CB7		     jmp     short do110
SYSINIT:2CB9 ; ---------------------------------------------------------------------------
SYSINIT:2CB9
SYSINIT:2CB9 if115:				     ; ...
SYSINIT:2CB9		     cmp     cs:result_val_swoff, offset swit_t	; offset "/T"
SYSINIT:2CB9					     ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
SYSINIT:2CC0		     jnz     short if116
SYSINIT:2CC2		     mov     cs:p_swit_t, 1  ; set the flag
SYSINIT:2CC8		     jmp     short do110
SYSINIT:2CCA ; ---------------------------------------------------------------------------
SYSINIT:2CCA
SYSINIT:2CCA if116:				     ; ...
SYSINIT:2CCA		     cmp     cs:result_val_swoff, offset swit_w	; "/W"
SYSINIT:2CD1		     jnz     short do110
SYSINIT:2CD3		     mov     cs:p_swit_w, 1  ; set the flag
SYSINIT:2CD9		     jmp     short do110
SYSINIT:2CDB ; ---------------------------------------------------------------------------
SYSINIT:2CDB
SYSINIT:2CDB en110:				     ; ...
SYSINIT:2CDB		     cmp     cs:p_swit_k, 1  ; if /k entered,
SYSINIT:2CE1		     push    ds
SYSINIT:2CE2		     mov     ax, 70h	     ; DOSBIODATASEG ; BIOSDATA	segment
SYSINIT:2CE5		     mov     ds, ax
SYSINIT:2CE7		     assume ds:nothing
SYSINIT:2CE7		     jnz     short if117
SYSINIT:2CE9		     mov     ds:keyrd_func, 0 ;	BIOSDATA:04E5h
SYSINIT:2CE9					     ; use the conventional keyboard functions
SYSINIT:2CEE		     mov     ds:keysts_func, 1 ; BIOSDATA:04E6h
SYSINIT:2CF3
SYSINIT:2CF3 if117:				     ; ...
SYSINIT:2CF3		     mov     al, cs:p_swit_t
SYSINIT:2CF7		     mov     ds:t_switch, al
SYSINIT:2CFA		     cmp     cs:p_swit_w, 0
SYSINIT:2D00		     jz	     short skip_dos_flag
SYSINIT:2D02		     push    es
SYSINIT:2D03		     push    bx
SYSINIT:2D04		     mov     ah, 52h	     ; GET_IN_VARS
SYSINIT:2D06		     int     21h	     ; DOS - 2+	internal - GET LIST OF LISTS
SYSINIT:2D06					     ; Return: ES:BX ->	DOS list of lists
SYSINIT:2D08		     or	     byte ptr es:86h, 2	; [es:DOS_FLAG_OFFSET],	SUPPRESS_WINA20
SYSINIT:2D0E		     pop     bx
SYSINIT:2D0F		     pop     es
SYSINIT:2D10
SYSINIT:2D10 skip_dos_flag:			     ; ...
SYSINIT:2D10		     pop     ds
SYSINIT:2D11		     assume ds:nothing
SYSINIT:2D11
SYSINIT:2D11 sr110:				     ; ...
SYSINIT:2D11		     jmp     coff
SYSINIT:2D14 ; ---------------------------------------------------------------------------
SYSINIT:2D14
SYSINIT:2D14 tryv:				     ; ...
SYSINIT:2D14		     cmp     ah, 56h ; 'V'   ; CONFIG_SET ; set var=value<cr/lf>
SYSINIT:2D17		     jnz     short tryn
SYSINIT:2D19		     call    query_user	     ; query the user if config_cmd
SYSINIT:2D19					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2D1C		     jb	     short tryn
SYSINIT:2D1E		     call    copy_envvar     ; copy var	at ES:SI to "config_wrkseg"
SYSINIT:2D21		     jnb     short sr110     ; no error
SYSINIT:2D23
SYSINIT:2D23 err:				     ; ...
SYSINIT:2D23		     call    error_line	     ; whoops, display error in	line XXX
SYSINIT:2D26		     jmp     short sr110     ; jump to coff (to	skip to	next line)
SYSINIT:2D28 ; ---------------------------------------------------------------------------
SYSINIT:2D28
SYSINIT:2D28 tryn:				     ; ...
SYSINIT:2D28		     cmp     ah, 4Eh ; 'N'   ; CONFIG_NUMLOCK ; numlock=on|off
SYSINIT:2D2B		     jnz     short tryy
SYSINIT:2D2D		     call    query_user	     ; query the user if config_cmd
SYSINIT:2D2D					     ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2D30		     jb	     short tryy
SYSINIT:2D32		     call    set_numlock
SYSINIT:2D35		     jb	     short err
SYSINIT:2D37		     jmp     short sr110     ; all done
SYSINIT:2D39 ; ---------------------------------------------------------------------------
SYSINIT:2D39
SYSINIT:2D39 tryy:				     ; ...
SYSINIT:2D39		     cmp     ah, 59h ; 'Y'   ; CONFIG_COMMENT
SYSINIT:2D39					     ; (do nothing with	this line.)
SYSINIT:2D3C		     jnz     short try0
SYSINIT:2D3E
SYSINIT:2D3E donothing:				     ; ...
SYSINIT:2D3E		     dec     ds:chrptr
SYSINIT:2D42		     inc     ds:count
SYSINIT:2D46		     jmp     coff
SYSINIT:2D49 ; ---------------------------------------------------------------------------
SYSINIT:2D49
SYSINIT:2D49 try0:				     ; ...
SYSINIT:2D49		     cmp     ah, 30h ; '0'   ; CONFIG_REM
SYSINIT:2D49					     ; (do nothing with	this line.)
SYSINIT:2D4C		     jz	     short donothing
SYSINIT:2D4E		     cmp     ah, 0FFh	     ; null/bogus command?
SYSINIT:2D51		     jz	     short donothing
SYSINIT:2D53		     dec     ds:chrptr
SYSINIT:2D57		     inc     ds:count
SYSINIT:2D5B		     jmp     short badop
SYSINIT:2D5B ; END OF FUNCTION CHUNK FOR multi_pass
SYSINIT:2D5D
SYSINIT:2D5D ; =============== S U B R O U T I N E =======================================
SYSINIT:2D5D
SYSINIT:2D5D
SYSINIT:2D5D CheckProtmanArena proc near	     ; ...
SYSINIT:2D5D		     push    es		     ; adjusts alloclim	if Protman$
SYSINIT:2D5D					     ; reduced our arena through a manual hack
SYSINIT:2D5E		     mov     ax, cs:area     ; get our arena header
SYSINIT:2D62		     dec     ax
SYSINIT:2D63		     mov     es, ax
SYSINIT:2D65		     add     ax, es:3	     ; [es:ARENA.SIZE] ; find end of arena
SYSINIT:2D6A		     inc     ax
SYSINIT:2D6B		     cmp     ax, cs:ALLOCLIM ; is it less than alloclim?
SYSINIT:2D70		     ja	     short CheckProtmanDone
SYSINIT:2D72		     mov     cs:ALLOCLIM, ax ; reduce alloclim then
SYSINIT:2D76
SYSINIT:2D76 CheckProtmanDone:			     ; ...
SYSINIT:2D76		     pop     es
SYSINIT:2D77		     retn
SYSINIT:2D77 CheckProtmanArena endp
SYSINIT:2D77
SYSINIT:2D78
SYSINIT:2D78 ; =============== S U B R O U T I N E =======================================
SYSINIT:2D78
SYSINIT:2D78
SYSINIT:2D78 sysinit_parse   proc near		     ; ...
SYSINIT:2D78		     push    es		     ; set up registers	for sysparse
SYSINIT:2D78					     ; in:
SYSINIT:2D78					     ;	  es:si	-> command line	in confbot
SYSINIT:2D78					     ;	     di	-> offset of the parse control definition.
SYSINIT:2D78					     ; out:
SYSINIT:2D78					     ;	  calls	sysparse.
SYSINIT:2D78					     ;	  carry	will set if parse error.
SYSINIT:2D78					     ;	  *** the caller should	check the eol condition	by looking at ax
SYSINIT:2D78					     ;	  *** after each call.
SYSINIT:2D78					     ;	  *** if no parameters are found,then ax will contain a	error code.
SYSINIT:2D78					     ;	  *** if the caller needs to look at the synomym@ of the result,
SYSINIT:2D78					     ;	  *** the caller should	use cs:@ instead of es:@.
SYSINIT:2D78					     ;	  cx should be set to 0	at the 1st time	the caller calls this proc.
SYSINIT:2D78					     ;	  ax - exit code
SYSINIT:2D78					     ;	  bl - terminated delimeter code
SYSINIT:2D78					     ;	  cx - new positional ordinal
SYSINIT:2D78					     ;	  si - set to pase scanned operand
SYSINIT:2D78					     ;	  dx - selected	result buffer
SYSINIT:2D79		     push    ds
SYSINIT:2D7A		     push    es		     ; now ds:si -> command line
SYSINIT:2D7B		     pop     ds
SYSINIT:2D7C		     push    cs
SYSINIT:2D7D		     pop     es		     ; now es:di -> control definition
SYSINIT:2D7E		     assume es:SYSINIT
SYSINIT:2D7E		     mov     word ptr cs:badparm_ptr+2,	ds ; save the pointer to the parm
SYSINIT:2D83		     mov     word ptr cs:badparm_ptr, si ; we are about	to parse for badparm msg.
SYSINIT:2D88		     mov     dx, 0
SYSINIT:2D8B		     call    SysParse
SYSINIT:2D8E		     cmp     ax, 0	     ; _$P_No_Error ; no error
SYSINIT:2D91		     jz	     short ll4	     ; cf=0
SYSINIT:2D93		     cmp     ax, 0FFFFh	     ; _$P_RC_EOL ; end	of line?
SYSINIT:2D96		     jnz     short if4	     ; or the end of line?
SYSINIT:2D98
SYSINIT:2D98 ll4:				     ; ...
SYSINIT:2D98		     clc
SYSINIT:2D99		     jmp     short en4
SYSINIT:2D9B ; ---------------------------------------------------------------------------
SYSINIT:2D9B
SYSINIT:2D9B if4:				     ; ...
SYSINIT:2D9B		     stc
SYSINIT:2D9C
SYSINIT:2D9C en4:				     ; ...
SYSINIT:2D9C		     pop     ds
SYSINIT:2D9D		     pop     es
SYSINIT:2D9E		     assume es:nothing
SYSINIT:2D9E		     retn
SYSINIT:2D9E sysinit_parse   endp
SYSINIT:2D9E
SYSINIT:2D9F ; ---------------------------------------------------------------------------
SYSINIT:2D9F
SYSINIT:2D9F badop_p:				     ; 'badop_p' is not used in
SYSINIT:2D9F		     push    cs		     ; MSDOS 6.21 IO.SYS and PCDOS 7.1 IBMBIO.COM
SYSINIT:2D9F					     ; (but it was/is not removed)
SYSINIT:2D9F					     ; Erdogan Tan - 11/07/2023
SYSINIT:2DA0		     pop     ds
SYSINIT:2DA1		     assume ds:SYSINIT
SYSINIT:2DA1		     mov     dx, offset	badopm ; "\r\nUnrecognized command in CONFIG.SYS"
SYSINIT:2DA4		     call    print
SYSINIT:2DA7		     call    error_line
SYSINIT:2DAA		     retn
SYSINIT:2DAB ; ---------------------------------------------------------------------------
SYSINIT:2DAB ; START OF	FUNCTION CHUNK FOR multi_pass
SYSINIT:2DAB
SYSINIT:2DAB badop:				     ; ...
SYSINIT:2DAB		     mov     dx, offset	badopm ; "\r\nUnrecognized command in CONFIG.SYS"
SYSINIT:2DAE		     call    print
SYSINIT:2DB1		     call    error_line
SYSINIT:2DB4		     jmp     coff
SYSINIT:2DB4 ; END OF FUNCTION CHUNK FOR multi_pass
SYSINIT:2DB7
SYSINIT:2DB7 ; =============== S U B R O U T I N E =======================================
SYSINIT:2DB7
SYSINIT:2DB7
SYSINIT:2DB7 badparm_p	     proc near		     ; ...
SYSINIT:2DB7		     push    ds
SYSINIT:2DB8		     push    dx
SYSINIT:2DB9		     push    si
SYSINIT:2DBA		     push    cs
SYSINIT:2DBB		     pop     ds
SYSINIT:2DBC		     mov     dx, offset	badparm	; "\r\nBad command or parameters - $"
SYSINIT:2DBF		     call    print
SYSINIT:2DC2		     lds     si, badparm_ptr
SYSINIT:2DC6		     assume ds:nothing
SYSINIT:2DC6
SYSINIT:2DC6 do1:				     ; ...
SYSINIT:2DC6		     mov     dl, [si]	     ; print "xxxx" until cr.
SYSINIT:2DC8		     cmp     dl, 0Dh	     ; cr ?
SYSINIT:2DCB		     jz	     short en1	     ; yes
SYSINIT:2DCD		     mov     ah, 2	     ; display character
SYSINIT:2DCF		     int     21h	     ; DOS - DISPLAY OUTPUT
SYSINIT:2DCF					     ; DL = character to send to standard output
SYSINIT:2DD1		     inc     si
SYSINIT:2DD2		     jmp     short do1
SYSINIT:2DD4 ; ---------------------------------------------------------------------------
SYSINIT:2DD4
SYSINIT:2DD4 en1:				     ; ...
SYSINIT:2DD4		     push    cs
SYSINIT:2DD5		     pop     ds
SYSINIT:2DD6		     assume ds:SYSINIT
SYSINIT:2DD6		     mov     dx, offset	crlfm ;	"\r\n$"
SYSINIT:2DD9		     call    print
SYSINIT:2DDC		     call    error_line
SYSINIT:2DDF		     pop     si
SYSINIT:2DE0		     pop     dx
SYSINIT:2DE1		     pop     ds
SYSINIT:2DE2		     assume ds:nothing
SYSINIT:2DE2		     retn
SYSINIT:2DE2 badparm_p	     endp
SYSINIT:2DE2
SYSINIT:2DE3
SYSINIT:2DE3 ; =============== S U B R O U T I N E =======================================
SYSINIT:2DE3
SYSINIT:2DE3
SYSINIT:2DE3 getchr	     proc near		     ; ...
SYSINIT:2DE3		     push    cx
SYSINIT:2DE4		     mov     cx, ds:count
SYSINIT:2DE8		     jcxz    short nochar
SYSINIT:2DEA		     mov     si, ds:chrptr
SYSINIT:2DEE		     mov     al, es:[si]
SYSINIT:2DF1		     dec     ds:count
SYSINIT:2DF5		     inc     ds:chrptr
SYSINIT:2DF9		     clc
SYSINIT:2DFA
SYSINIT:2DFA get_ret:				     ; ...
SYSINIT:2DFA		     pop     cx
SYSINIT:2DFB		     retn
SYSINIT:2DFC ; ---------------------------------------------------------------------------
SYSINIT:2DFC
SYSINIT:2DFC nochar:				     ; ...
SYSINIT:2DFC		     stc
SYSINIT:2DFD		     jmp     short get_ret
SYSINIT:2DFD getchr	     endp
SYSINIT:2DFD
SYSINIT:2DFF ; ---------------------------------------------------------------------------
SYSINIT:2DFF
SYSINIT:2DFF incorrect_order:			     ; 'incorrect_order' is not used in
SYSINIT:2DFF		     mov     dx, offset	badorder ; MSDOS 6.21 IO.SYS and PCDOS 7.1 IBMBIO.COM
SYSINIT:2DFF					     ; (but it was/is not removed)
SYSINIT:2DFF					     ; Erdogan Tan - 11/07/2023
SYSINIT:2E02		     call    print
SYSINIT:2E05		     call    showlinenum
SYSINIT:2E08		     retn
SYSINIT:2E09
SYSINIT:2E09 ; =============== S U B R O U T I N E =======================================
SYSINIT:2E09
SYSINIT:2E09
SYSINIT:2E09 error_line	     proc near		     ; ...
SYSINIT:2E09		     push    cs
SYSINIT:2E0A		     pop     ds
SYSINIT:2E0B		     assume ds:SYSINIT
SYSINIT:2E0B		     mov     dx, offset	errorcmd ; "Error in CONFIG.SYS	line $"
SYSINIT:2E0E		     call    print
SYSINIT:2E11		     call    showlinenum
SYSINIT:2E14		     retn
SYSINIT:2E14 error_line	     endp
SYSINIT:2E14
SYSINIT:2E15
SYSINIT:2E15 ; =============== S U B R O U T I N E =======================================
SYSINIT:2E15
SYSINIT:2E15
SYSINIT:2E15 showlinenum     proc near		     ; ...
SYSINIT:2E15		     push    es
SYSINIT:2E16		     push    ds
SYSINIT:2E17		     push    di
SYSINIT:2E18		     push    cs
SYSINIT:2E19		     pop     es
SYSINIT:2E1A		     assume es:SYSINIT
SYSINIT:2E1A		     push    cs
SYSINIT:2E1B		     pop     ds
SYSINIT:2E1C		     mov     di, (offset showcount+4) ;
SYSINIT:2E1C					     ; di -> the least significant decimal field.
SYSINIT:2E1F		     mov     cx, 10
SYSINIT:2E22		     mov     ax, cs:linecount
SYSINIT:2E26
SYSINIT:2E26 sln_loop:				     ; ...
SYSINIT:2E26		     cmp     ax, 10	     ; < 10 ?
SYSINIT:2E29		     jb	     short sln_last  ; yes
SYSINIT:2E2B		     xor     dx, dx
SYSINIT:2E2D		     div     cx		     ; cx = 10
SYSINIT:2E2F		     or	     dl, 30h	     ; convert to ascii	numeric	char ("0" to "9")
SYSINIT:2E32		     mov     [di], dl
SYSINIT:2E34		     dec     di
SYSINIT:2E35		     jmp     short sln_loop
SYSINIT:2E37 ; ---------------------------------------------------------------------------
SYSINIT:2E37
SYSINIT:2E37 sln_last:				     ; ...
SYSINIT:2E37		     or	     al, 30h	     ; convert to ascii	numeric	char ("0" to "9")
SYSINIT:2E39		     mov     [di], al
SYSINIT:2E3B		     mov     dx, di
SYSINIT:2E3D		     call    print	     ; show it
SYSINIT:2E40		     pop     di
SYSINIT:2E41		     pop     ds
SYSINIT:2E42		     assume ds:nothing
SYSINIT:2E42		     pop     es
SYSINIT:2E43		     assume es:nothing
SYSINIT:2E43		     retn
SYSINIT:2E43 showlinenum     endp
SYSINIT:2E43
SYSINIT:2E44
SYSINIT:2E44 ; =============== S U B R O U T I N E =======================================
SYSINIT:2E44
SYSINIT:2E44
SYSINIT:2E44 ProcDOS	     proc near		     ; ...
SYSINIT:2E44		     xor     ah, ah
SYSINIT:2E46		     mov     al, cs:result_val_itag ;
SYSINIT:2E46					     ; [cs:result_val+_$P_Result_Blk.Item_Tag]
SYSINIT:2E46					     ;
SYSINIT:2E46					     ; result_val._$P_item_tag
SYSINIT:2E46					     ;		= 1 for	DOS=HIGH
SYSINIT:2E46					     ;		= 2 for	DOS=LOW
SYSINIT:2E46					     ;		= 3 for	DOS=UMB
SYSINIT:2E46					     ;		= 4 for	DOS=NOUMB
SYSINIT:2E4A		     dec     ax
SYSINIT:2E4B		     jz	     short pd_hi
SYSINIT:2E4D		     dec     ax
SYSINIT:2E4E		     jz	     short pd_lo
SYSINIT:2E50		     dec     ax
SYSINIT:2E51		     jz	     short pd_umb
SYSINIT:2E53		     mov     cs:DevUMB,	0
SYSINIT:2E59		     retn
SYSINIT:2E5A ; ---------------------------------------------------------------------------
SYSINIT:2E5A
SYSINIT:2E5A pd_umb:				     ; ...
SYSINIT:2E5A		     mov     cs:DevUMB,	0FFh
SYSINIT:2E60		     retn
SYSINIT:2E61 ; ---------------------------------------------------------------------------
SYSINIT:2E61
SYSINIT:2E61 pd_lo:				     ; ...
SYSINIT:2E61		     mov     cs:runhigh, 0
SYSINIT:2E67		     retn
SYSINIT:2E68 ; ---------------------------------------------------------------------------
SYSINIT:2E68
SYSINIT:2E68 pd_hi:				     ; ...
SYSINIT:2E68		     mov     cs:runhigh, 0FFh
SYSINIT:2E6E		     retn
SYSINIT:2E6E ProcDOS	     endp
SYSINIT:2E6E
SYSINIT:2E6F
SYSINIT:2E6F ; =============== S U B R O U T I N E =======================================
SYSINIT:2E6F
SYSINIT:2E6F
SYSINIT:2E6F LieInt12Mem     proc near		     ; ...
SYSINIT:2E6F		     mov     ax, cs:ALLOCLIM ; lie INT 12h as alloclim
SYSINIT:2E6F					     ; assuming	that it	is 3Com
SYSINIT:2E73		     call    IsIt3Com	     ; Is it 3Com driver?
SYSINIT:2E76		     jz	     short lim_set   ; yes, lie	to him differently
SYSINIT:2E78		     cmp     cs:DeviceHi, 0  ; Is the DD being loaded in UMB
SYSINIT:2E7E		     jz	     short limx	     ; no, don't lie
SYSINIT:2E80		     mov     ax, cs:DevLoadEnd ; lie INT 12h as	end of UMB
SYSINIT:2E84
SYSINIT:2E84 lim_set:				     ; ...
SYSINIT:2E84		     call    SetInt12Mem
SYSINIT:2E87
SYSINIT:2E87 limx:				     ; ...
SYSINIT:2E87		     retn
SYSINIT:2E87 LieInt12Mem     endp
SYSINIT:2E87
SYSINIT:2E88
SYSINIT:2E88 ; =============== S U B R O U T I N E =======================================
SYSINIT:2E88
SYSINIT:2E88
SYSINIT:2E88 SetInt12Mem     proc near		     ; ...
SYSINIT:2E88		     push    ds
SYSINIT:2E89		     mov     bx, 40h	     ; ROMBIOS data area segment
SYSINIT:2E8C		     mov     ds, bx
SYSINIT:2E8E		     assume ds:nothing
SYSINIT:2E8E		     mov     bx, ds:13h	     ; memory size (KB)
SYSINIT:2E92		     mov     cs:OldInt12Mem, bx
SYSINIT:2E97		     mov     cl, 6	     ; 16*64 = 1024
SYSINIT:2E99		     shr     ax, cl	     ; convert paragraphs to kilobyte
SYSINIT:2E9B		     mov     ds:13h, ax
SYSINIT:2E9E		     mov     cs:Int12Lied, 0FFh	; mark that we are lying
SYSINIT:2EA4		     pop     ds
SYSINIT:2EA5		     assume ds:nothing
SYSINIT:2EA5		     retn
SYSINIT:2EA5 SetInt12Mem     endp
SYSINIT:2EA5
SYSINIT:2EA6
SYSINIT:2EA6 ; =============== S U B R O U T I N E =======================================
SYSINIT:2EA6
SYSINIT:2EA6
SYSINIT:2EA6 TrueInt12Mem    proc near		     ; ...
SYSINIT:2EA6		     cmp     cs:Int12Lied, 0 ; were we lying so	far?
SYSINIT:2EAC		     mov     cs:Int12Lied, 0
SYSINIT:2EB2		     jz	     short timx	     ; yes
SYSINIT:2EB2					     ; no, we weren't
SYSINIT:2EB4		     push    ds
SYSINIT:2EB5		     mov     ax, 40h
SYSINIT:2EB8		     mov     ds, ax
SYSINIT:2EBA		     assume ds:nothing
SYSINIT:2EBA		     mov     ax, cs:OldInt12Mem
SYSINIT:2EBE		     mov     ds:13h, ax	     ; restore INT 12h memory
SYSINIT:2EC1		     pop     ds
SYSINIT:2EC2		     assume ds:nothing
SYSINIT:2EC2
SYSINIT:2EC2 timx:				     ; ...
SYSINIT:2EC2		     retn
SYSINIT:2EC2 TrueInt12Mem    endp
SYSINIT:2EC2
SYSINIT:2EC3
SYSINIT:2EC3 ; =============== S U B R O U T I N E =======================================
SYSINIT:2EC3
SYSINIT:2EC3
SYSINIT:2EC3 IsIt3Com	     proc near		     ; ...
SYSINIT:2EC3		     push    ds
SYSINIT:2EC4		     push    es
SYSINIT:2EC5		     push    si
SYSINIT:2EC6		     lds     si, cs:DevEntry ; ptr to device header
SYSINIT:2ECB		     add     si, 10	     ; SYSDEV.NAME ; ptr device	name
SYSINIT:2ECE		     push    cs
SYSINIT:2ECF		     pop     es
SYSINIT:2ED0		     assume es:SYSINIT
SYSINIT:2ED0		     mov     di, offset	ThreeComName ; "PROTMAN$"
SYSINIT:2ED3		     mov     cx, 8	     ; name length
SYSINIT:2ED6		     repe cmpsb
SYSINIT:2ED8		     pop     si
SYSINIT:2ED9		     pop     es
SYSINIT:2EDA		     assume es:nothing
SYSINIT:2EDA		     pop     ds
SYSINIT:2EDB		     retn
SYSINIT:2EDB IsIt3Com	     endp
SYSINIT:2EDB
SYSINIT:2EDC
SYSINIT:2EDC ; =============== S U B R O U T I N E =======================================
SYSINIT:2EDC
SYSINIT:2EDC
SYSINIT:2EDC UpdatePDB	     proc near		     ; ...
SYSINIT:2EDC		     push    ds
SYSINIT:2EDD		     mov     ah, 62h
SYSINIT:2EDF		     int     21h	     ; DOS - 3+	- GET PSP ADDRESS
SYSINIT:2EE1		     mov     ds, bx
SYSINIT:2EE3		     mov     bx, cs:ALLOCLIM
SYSINIT:2EE8		     mov     ds:2, bx	     ; [PDB.BLOCK_LEN]
SYSINIT:2EEC		     pop     ds
SYSINIT:2EED		     retn
SYSINIT:2EED UpdatePDB	     endp
SYSINIT:2EED
SYSINIT:2EEE
SYSINIT:2EEE ; =============== S U B R O U T I N E =======================================
SYSINIT:2EEE
SYSINIT:2EEE
SYSINIT:2EEE InitVar	     proc near		     ; ...
SYSINIT:2EEE		     push    ax
SYSINIT:2EEF		     push    cx
SYSINIT:2EF0		     push    di
SYSINIT:2EF1		     push    es
SYSINIT:2EF2		     push    cs
SYSINIT:2EF3		     pop     es
SYSINIT:2EF4		     assume es:SYSINIT
SYSINIT:2EF4		     xor     ax, ax	     ; 0
SYSINIT:2EF6		     mov     es:fUmbTiny, al ; Shrink UMBs? (made 1 if /S given)
SYSINIT:2EFA		     mov     es:fInHigh, al  ; Set to 1	when DH/LH has been called
SYSINIT:2EFE		     mov     es:SegLoad, ax  ; Load Address (seg), used	for DH only
SYSINIT:2F02		     mov     es:UmbLoad, 0FFh ;	UNSPECIFIED
SYSINIT:2F02					     ; Later is	the # of the 1st spec'd UMB
SYSINIT:2F08		     mov     es:fm_argc, al  ; Start with zero args having been	read
SYSINIT:2F0C		     cld
SYSINIT:2F0D		     mov     cx, 16	     ; MAXUMB
SYSINIT:2F10		     mov     di, offset	UmbUsed	;
SYSINIT:2F10					     ; For each	entry on the UmbUsed array,
SYSINIT:2F13		     rep stosb		     ; Store 0
SYSINIT:2F15		     mov     cx, 16	     ; MAXUMB
SYSINIT:2F18		     mov     di, offset	UmbSize	; Okay...
SYSINIT:2F18					     ; for each	entry on the UmbSize array,
SYSINIT:2F1B		     rep stosw		     ; Store 0
SYSINIT:2F1D		     pop     es
SYSINIT:2F1E		     assume es:nothing
SYSINIT:2F1E		     pop     di
SYSINIT:2F1F		     pop     cx
SYSINIT:2F20		     pop     ax
SYSINIT:2F21		     retn
SYSINIT:2F21 InitVar	     endp
SYSINIT:2F21
SYSINIT:2F22
SYSINIT:2F22 ; =============== S U B R O U T I N E =======================================
SYSINIT:2F22
SYSINIT:2F22
SYSINIT:2F22 FixMem	     proc near		     ; ...
SYSINIT:2F22		     push    ax		     ; scans the upper memory chain
SYSINIT:2F22					     ; and concatenates	adjacent free MCBs
SYSINIT:2F23		     push    bx
SYSINIT:2F24		     push    cx
SYSINIT:2F25		     push    dx
SYSINIT:2F26		     push    es
SYSINIT:2F27		     call    fm_link	     ; Link in UMBs
SYSINIT:2F2A		     call    UmbHead	     ; Get first upper-memory MCB address (0x9FFF)
SYSINIT:2F2D		     jb	     short fmX	     ; (if couldn't get it, leave now).
SYSINIT:2F2F		     mov     es, ax	     ; It returns in AX, so move it to ES.
SYSINIT:2F31		     xor     dx, dx	     ; We're keeping the address of the last MCB
SYSINIT:2F33		     mov     cx, dx	     ; in CX...	and the	last owner
SYSINIT:2F35		     inc     dx		     ; in dx as	we go through the loop
SYSINIT:2F36
SYSINIT:2F36 fm10:				     ; ...
SYSINIT:2F36		     mov     al, es:0	     ; [es:ARENA.SIGNATURE]
SYSINIT:2F36					     ; if 'Z', don't repeat loop
SYSINIT:2F3A		     mov     bx, es:1	     ; [es:ARENA.OWNER]	; if not zero, do nothing
SYSINIT:2F3F		     or	     bx, dx	     ; dx was owner of previous	MCB
SYSINIT:2F41		     jnz     short fm30	     ; If not both zero, don't cat.
SYSINIT:2F43
SYSINIT:2F43 fm20:				     ; [es:ARENA.SIZE]
SYSINIT:2F43		     mov     bx, es:3	     ; Grab this block's Size,
SYSINIT:2F48		     mov     es, cx	     ; Go back to prev MCB's address
SYSINIT:2F4A		     assume es:nothing
SYSINIT:2F4A		     mov     byte ptr es:0, al ; [es:ARENA.SIGNATURE]
SYSINIT:2F4A					     ; & move the SECOND sig here
SYSINIT:2F4E		     add     bx, es:3	     ; [es:ARENA.SIZE]
SYSINIT:2F4E					     ; Size += first MCB's size
SYSINIT:2F53		     add     bx, 1	     ; And add one for the header
SYSINIT:2F56		     mov     es:3, bx	     ; [es:ARENA.SIZE] ; Write the size
SYSINIT:2F5B
SYSINIT:2F5B fm30:				     ; ...
SYSINIT:2F5B		     mov     cx, es	     ; Save MCB	address
SYSINIT:2F5D		     mov     dx, word ptr es:1 ; [es:ARENA.OWNER] ; And	remember its owner
SYSINIT:2F62		     mov     bx, es	     ; Move to the next	MCB
SYSINIT:2F64		     add     bx, es:DosDataSg
SYSINIT:2F69		     inc     bx
SYSINIT:2F6A		     mov     es, bx
SYSINIT:2F6C		     assume es:nothing
SYSINIT:2F6C		     cmp     al, 5Ah ; 'Z'   ; arena_signature_end
SYSINIT:2F6E		     jnz     short fm10	     ; If signature != 'Z', there are more.
SYSINIT:2F70
SYSINIT:2F70 fmX:				     ; ...
SYSINIT:2F70		     call    fm_unlink	     ; Unlink UMBs
SYSINIT:2F73		     pop     es
SYSINIT:2F74		     pop     dx
SYSINIT:2F75		     pop     cx
SYSINIT:2F76		     pop     bx
SYSINIT:2F77		     pop     ax
SYSINIT:2F78		     retn
SYSINIT:2F78 FixMem	     endp
SYSINIT:2F78
SYSINIT:2F79
SYSINIT:2F79 ; =============== S U B R O U T I N E =======================================
SYSINIT:2F79
SYSINIT:2F79
SYSINIT:2F79 fm_link	     proc near		     ; ...
SYSINIT:2F79		     mov     ax, 5802h	     ; DOS_CHECK_UMBLINK
SYSINIT:2F7C		     int     21h	     ; DOS - 3+	- GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:2F7C					     ; AL = function code: (DOS	5beta) get UMB link state
SYSINIT:2F7E		     push    es
SYSINIT:2F7F		     push    cs
SYSINIT:2F80		     pop     es
SYSINIT:2F81		     assume es:SYSINIT
SYSINIT:2F81		     mov     es:fm_umb,	al   ; store current link-state	(to use/set later)
SYSINIT:2F85		     pop     es
SYSINIT:2F86		     assume es:nothing
SYSINIT:2F86		     mov     ax, 5803h
SYSINIT:2F89		     mov     bx, 1
SYSINIT:2F8C		     int     21h	     ; DOS - 3+	- GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:2F8C					     ; AL = function code: (DOS	5beta) set UMB link state
SYSINIT:2F8E		     retn
SYSINIT:2F8E fm_link	     endp
SYSINIT:2F8E
SYSINIT:2F8F
SYSINIT:2F8F ; =============== S U B R O U T I N E =======================================
SYSINIT:2F8F
SYSINIT:2F8F
SYSINIT:2F8F fm_unlink	     proc near		     ; ...
SYSINIT:2F8F		     xor     bx, bx
SYSINIT:2F91		     push    ds
SYSINIT:2F92		     push    cs
SYSINIT:2F93		     pop     ds
SYSINIT:2F94		     assume ds:SYSINIT
SYSINIT:2F94		     mov     bl, fm_umb	     ; old link-state (to set again)
SYSINIT:2F98		     pop     ds
SYSINIT:2F99		     assume ds:nothing
SYSINIT:2F99		     mov     ax, 5803h	     ; DOS_SET_UMBLINK
SYSINIT:2F9C		     int     21h	     ; DOS - 3+	- GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:2F9C					     ; AL = function code: (DOS	5beta) set UMB link state
SYSINIT:2F9E		     retn
SYSINIT:2F9E fm_unlink	     endp
SYSINIT:2F9E
SYSINIT:2F9F
SYSINIT:2F9F ; =============== S U B R O U T I N E =======================================
SYSINIT:2F9F
SYSINIT:2F9F
SYSINIT:2F9F ParseVar	     proc near		     ; ...
SYSINIT:2F9F		     push    di		     ; parses [/S][/L:umb[,size][;umb[,size]]*]
SYSINIT:2F9F					     ;	 and builds the	table laid out in highvar.inc
SYSINIT:2F9F					     ; ENTRY:
SYSINIT:2F9F					     ;	 ES:SI points to command tail of LoadHigh/DeviceHigh
SYSINIT:2F9F					     ;	     (whitespace ok)
SYSINIT:2F9F					     ; EXIT:
SYSINIT:2F9F					     ;	 ES:SI points to first character in child program name
SYSINIT:2FA0		     push    ds
SYSINIT:2FA1		     push    es
SYSINIT:2FA2		     push    es		     ; Make DS:SI point	to it, as well as ES:SI
SYSINIT:2FA3		     pop     ds		     ; (regardless if we're in devhigh or loadhigh)
SYSINIT:2FA4		     cld
SYSINIT:2FA5
SYSINIT:2FA5 pv10:				     ; ...
SYSINIT:2FA5		     lodsb		     ; here, ES:SI=="  /L..."--must eat	whitespace
SYSINIT:2FA6		     call    isWhite
SYSINIT:2FA9		     jz	     short pv10	     ; ES:SI=="	/L..."--keep eating.
SYSINIT:2FAB		     cmp     al, 2Fh ; '/'   ; SWTCH ; ES:SI=="/L..."--go process a switch
SYSINIT:2FAD		     jz	     short pv20
SYSINIT:2FAF		     dec     si		     ; Backup--it's now "odule options", and we need
SYSINIT:2FB0		     clc		     ; that "m"	we just	read (or whatever it is).
SYSINIT:2FB1		     jmp     short pvX	     ; Then return with	carry clear == we're done.
SYSINIT:2FB3 ; ---------------------------------------------------------------------------
SYSINIT:2FB3
SYSINIT:2FB3 pv20:				     ; ...
SYSINIT:2FB3		     lodsb		     ; Just read 'S' or 'L', hopefully
SYSINIT:2FB4		     and     al, 0DFh	     ; So we make it upper-case, and...
SYSINIT:2FB6		     cmp     al, 53h ; 'S'   ; just read 'S'?
SYSINIT:2FB8		     jnz     short pv30
SYSINIT:2FBA		     call    incArgc	     ; If it's /S, it's another arg for LH to skip.
SYSINIT:2FBA					     ;
SYSINIT:2FBA					     ; Note: 'inc byte [cs:fm_argc]' would be enough here
SYSINIT:2FBA					     ; Erdogan Tan - 19/04/2019	(Retro DOS v4) - 11/07/2023
SYSINIT:2FBD		     push    es
SYSINIT:2FBE		     push    cs
SYSINIT:2FBF		     pop     es
SYSINIT:2FC0		     assume es:SYSINIT
SYSINIT:2FC0		     mov     es:fUmbTiny, 1  ; /S, so ES:SI=="	/L..." or " module opts", or
SYSINIT:2FC6		     pop     es
SYSINIT:2FC7		     assume es:nothing
SYSINIT:2FC7		     jmp     short pv10	     ; possibly	even "/L...".
SYSINIT:2FC9 ; ---------------------------------------------------------------------------
SYSINIT:2FC9
SYSINIT:2FC9 pv30:				     ; ...
SYSINIT:2FC9		     cmp     al, 4Ch ; 'L'   ; If it's not 'L' either, then it's a bad switch!
SYSINIT:2FCB		     jnz     short pvE1
SYSINIT:2FCD		     call    incArgc
SYSINIT:2FD0		     call    parseL	     ; If no carry, go back and	look for more
SYSINIT:2FD3		     jnb     short pv10
SYSINIT:2FD5		     dec     si		     ; Else, back up and exit.
SYSINIT:2FD6		     jmp     short pvErr     ; AX has already been set by parseL
SYSINIT:2FD8 ; ---------------------------------------------------------------------------
SYSINIT:2FD8
SYSINIT:2FD8 pvE1:				     ; ...
SYSINIT:2FD8		     mov     ax, 3	     ; PV_InvSwt ; Unrecognized	switch passed
SYSINIT:2FDB
SYSINIT:2FDB pvErr:				     ; ...
SYSINIT:2FDB		     dec     si
SYSINIT:2FDC		     dec     si
SYSINIT:2FDD		     stc
SYSINIT:2FDE
SYSINIT:2FDE pvX:				     ; ...
SYSINIT:2FDE		     pop     es
SYSINIT:2FDF		     pop     ds
SYSINIT:2FE0		     pop     di
SYSINIT:2FE1		     retn
SYSINIT:2FE1 ParseVar	     endp
SYSINIT:2FE1
SYSINIT:2FE2
SYSINIT:2FE2 ; =============== S U B R O U T I N E =======================================
SYSINIT:2FE2
SYSINIT:2FE2
SYSINIT:2FE2 parseL	     proc near		     ; ...
SYSINIT:2FE2		     lodsb
SYSINIT:2FE3		     cmp     al, 3Ah ; ':'   ; Make sure they did /L:
SYSINIT:2FE5		     jnz     short plE1	     ; If they didn't, return with carry set.
SYSINIT:2FE7
SYSINIT:2FE7 pl10:				     ; ...
SYSINIT:2FE7		     call    GetXNum	     ; After this, it's ",size" or ";umb" or " mod"
SYSINIT:2FEA		     jb	     short plE2	     ; And error if it's a bad number.
SYSINIT:2FEC		     call    convUMB	     ; Convert any address to a	UMB number
SYSINIT:2FEF		     mov     cl, al	     ; Remember	the UMB	number
SYSINIT:2FF1		     call    stowUMB	     ; Mark this UMB # as used;
SYSINIT:2FF4		     jb	     short plE2	     ; If it was already marked, it'll error
SYSINIT:2FF6		     call    incArgc	     ; Each UMB	number is another arg for LH to	skip
SYSINIT:2FF6					     ; ('inc byte [cs:fm_argc]' would be enough)
SYSINIT:2FF6					     ; Erdogan Tan - 08/04/2019	(Retro DOS v4) - 11/07/2023
SYSINIT:2FF9		     lodsb
SYSINIT:2FFA		     cmp     al, 3Bh ; ';'   ; Did "umb;" ?
SYSINIT:2FFC		     jz	     short pl10	     ; Yep: go back and	get another UMB.
SYSINIT:2FFE		     call    isWhite	     ; Did "umb	" ?
SYSINIT:3001		     jz	     short plX	     ; Yep: return (it'll go back to whitespace)
SYSINIT:3003		     call    isEOL	     ; Did "umb" ?
SYSINIT:3006		     jz	     short plSwX     ; If so, backup and exit like everything's ok
SYSINIT:3008		     cmp     al, 2Fh ; '/'   ; Did "umb/" ? (as in, "/L:1,100;2/S")
SYSINIT:300A		     jz	     short plSwX     ; If so, back up ES:SI one	character and return
SYSINIT:300C		     cmp     al, 2Ch ; ','   ; Did "umb," ?
SYSINIT:300E		     jnz     short plE1	     ; Just what the heck DID they do? Return error.
SYSINIT:3010		     call    GetXNum	     ; Stop on "size;" or "size	" or anything else
SYSINIT:3013		     jb	     short plE1	     ; And error if it's a bad size.
SYSINIT:3015		     call    toPara	     ; Convert from bytes to paragraphs
SYSINIT:3018		     call    stowSiz	     ; CL still	has the	UMB number for this routine
SYSINIT:301B		     call    incArgc	     ; Each UMB	size is	another	arg for	LH to skip
SYSINIT:301B					     ; ('inc byte [cs:fm_argc]')
SYSINIT:301E		     lodsb
SYSINIT:301F		     cmp     al, 3Bh ; ';'   ; They did "umb,size;", so get another UMB.
SYSINIT:3021		     jz	     short pl10
SYSINIT:3023		     call    isWhite	     ; Did it end with whitespace?
SYSINIT:3026		     jz	     short plX	     ; If so, we're done here--go back.
SYSINIT:3028		     call    isEOL	     ; Did they	do "umb,size" and end??? (stupid)
SYSINIT:302B		     jz	     short plSwX     ; If so, backup and exit like everything's ok
SYSINIT:302D		     cmp     al, 2Fh ; '/'   ; SWTCH ; Did they do "umb,size/" ?
SYSINIT:302F		     jz	     short plSwX     ; If so, again, we're done here.
SYSINIT:3031
SYSINIT:3031 plE1:				     ; ...
SYSINIT:3031		     mov     ax, 1	     ; PV_InvArg ; If not, we don't know WHAT they did.
SYSINIT:3034		     dec     si
SYSINIT:3035		     stc
SYSINIT:3036		     retn
SYSINIT:3037 ; ---------------------------------------------------------------------------
SYSINIT:3037
SYSINIT:3037 plE2:				     ; ...
SYSINIT:3037		     mov     ax, 2	     ; In this case, they've specified a UMB twice
SYSINIT:303A		     stc
SYSINIT:303B		     retn
SYSINIT:303C ; ---------------------------------------------------------------------------
SYSINIT:303C
SYSINIT:303C plSwX:				     ; ...
SYSINIT:303C		     dec     si		     ; If we hit a '/' character, back up one char
SYSINIT:303C					     ; so the whitespace checker will see it too.
SYSINIT:303D
SYSINIT:303D plX:				     ; ...
SYSINIT:303D		     clc		     ; Then just return	with carry clear, so
SYSINIT:303D					     ; ParseVar	will go	about its business.
SYSINIT:303E		     retn
SYSINIT:303E parseL	     endp
SYSINIT:303E
SYSINIT:303F
SYSINIT:303F ; =============== S U B R O U T I N E =======================================
SYSINIT:303F
SYSINIT:303F
SYSINIT:303F incArgc	     proc near		     ; ...
SYSINIT:303F		     push    ax		     ; increments fm_argc,
SYSINIT:303F					     ; for use with LoadHigh command-line parsing
SYSINIT:303F					     ; ***
SYSINIT:303F					     ; ('inc byte [cs:fm_argc]' would be enough)
SYSINIT:303F					     ; Erdogan Tan - 11/07/2023
SYSINIT:3040		     push    ds
SYSINIT:3041		     push    cs
SYSINIT:3042		     pop     ds
SYSINIT:3043		     assume ds:SYSINIT
SYSINIT:3043		     mov     al, fm_argc     ; Obtain previous value of	fm_argc,
SYSINIT:3046		     pop     ds
SYSINIT:3047		     assume ds:nothing
SYSINIT:3047		     inc     al		     ; Increment it,
SYSINIT:3049		     push    es
SYSINIT:304A		     push    cs
SYSINIT:304B		     pop     es
SYSINIT:304C		     assume es:SYSINIT
SYSINIT:304C		     mov     es:fm_argc, al  ; And store it right back.
SYSINIT:3050		     pop     es
SYSINIT:3051		     assume es:nothing
SYSINIT:3051		     pop     ax
SYSINIT:3052		     retn
SYSINIT:3052 incArgc	     endp
SYSINIT:3052
SYSINIT:3053
SYSINIT:3053 ; =============== S U B R O U T I N E =======================================
SYSINIT:3053
SYSINIT:3053
SYSINIT:3053 isEOL	     proc near		     ; ...
SYSINIT:3053		     cmp     al, 0	     ; Null-terminator
SYSINIT:3055		     jz	     short ieX
SYSINIT:3057		     cmp     al, 0Dh	     ; CR ; Carriage Return
SYSINIT:3059		     jz	     short ieX
SYSINIT:305B		     cmp     al, 0Ah	     ; LF ; LineFeed
SYSINIT:305D
SYSINIT:305D ieX:				     ; ...
SYSINIT:305D		     retn		     ; zf=1 if AL contains EOL character
SYSINIT:305D isEOL	     endp
SYSINIT:305D
SYSINIT:305E
SYSINIT:305E ; =============== S U B R O U T I N E =======================================
SYSINIT:305E
SYSINIT:305E
SYSINIT:305E isWhite	     proc near		     ; ...
SYSINIT:305E		     cmp     al, 20h ; ' '   ; Space
SYSINIT:3060		     jz	     short iwX
SYSINIT:3062		     cmp     al, 3Dh ; '='   ; Equals (treat as whitespace)
SYSINIT:3064		     jz	     short iwX
SYSINIT:3066		     cmp     al, 9	     ; Tab
SYSINIT:3068
SYSINIT:3068 iwX:				     ; ...
SYSINIT:3068		     retn		     ; zf=1 if AL contains space,
SYSINIT:3068 isWhite	     endp		     ;	       tab or equals character
SYSINIT:3068
SYSINIT:3069
SYSINIT:3069 ; =============== S U B R O U T I N E =======================================
SYSINIT:3069
SYSINIT:3069
SYSINIT:3069 unMarkUMB	     proc near		     ; ...
SYSINIT:3069		     push    ax		     ; marks a given UMB as unused
SYSINIT:3069					     ; AL contains UMB number
SYSINIT:306A		     push    bx
SYSINIT:306B		     push    di
SYSINIT:306C		     push    es
SYSINIT:306D		     push    cs
SYSINIT:306E		     pop     es
SYSINIT:306F		     assume es:SYSINIT
SYSINIT:306F		     xor     ah, ah
SYSINIT:3071		     mov     bx, ax
SYSINIT:3073		     mov     es:UmbUsed[bx], 0
SYSINIT:3079		     cmp     es:UmbLoad, al
SYSINIT:307E		     jnz     short umu10     ; If unmarked the load UMB,
SYSINIT:307E					     ; load into convent.
SYSINIT:3080		     mov     es:UmbLoad, 0
SYSINIT:3086
SYSINIT:3086 umu10:				     ; ...
SYSINIT:3086		     pop     es
SYSINIT:3087		     assume es:nothing
SYSINIT:3087		     pop     di
SYSINIT:3088		     pop     bx
SYSINIT:3089		     pop     ax
SYSINIT:308A		     retn
SYSINIT:308A unMarkUMB	     endp
SYSINIT:308A
SYSINIT:308B
SYSINIT:308B ; =============== S U B R O U T I N E =======================================
SYSINIT:308B
SYSINIT:308B
SYSINIT:308B stowUMB	     proc near		     ; ...
SYSINIT:308B		     cmp     al, 16	     ; MAXUMB
SYSINIT:308D		     jb	     short su10
SYSINIT:308F		     stc		     ; Ooops-- UMB # >=	MAXUMB
SYSINIT:3090		     retn
SYSINIT:3091 ; ---------------------------------------------------------------------------
SYSINIT:3091
SYSINIT:3091 su10:				     ; ...
SYSINIT:3091		     push    bx
SYSINIT:3092		     push    di
SYSINIT:3093		     push    si
SYSINIT:3094		     push    ds
SYSINIT:3095		     push    es
SYSINIT:3096		     push    cs
SYSINIT:3097		     pop     es
SYSINIT:3098		     assume es:SYSINIT
SYSINIT:3098		     push    cs
SYSINIT:3099		     pop     ds
SYSINIT:309A		     assume ds:SYSINIT
SYSINIT:309A		     cmp     UmbLoad, 0FFh   ; UNSPECIFIED
SYSINIT:309A					     ; If this,	we haven't been here before
SYSINIT:309F		     jnz     short su20
SYSINIT:30A1		     mov     UmbLoad, al     ; So remember this	UMB as the load	UMB slot.
SYSINIT:30A4
SYSINIT:30A4 su20:				     ; ...
SYSINIT:30A4		     or	     al, al	     ; If they gave UMB	0, there's really nothing
SYSINIT:30A6		     jz	     short su30	     ; that we should do here.
SYSINIT:30A8		     mov     bl, al
SYSINIT:30AA		     xor     bh, bh
SYSINIT:30AC		     mov     ax, 1	     ; Now, AX = 1, and	BX = UMB Number
SYSINIT:30AF		     xchg    al, es:UmbUsed[bx]
SYSINIT:30B4		     or	     al, al	     ; If it was already 1,
SYSINIT:30B4					     ; then al==1... and that means an error.
SYSINIT:30B6		     jz	     short su30
SYSINIT:30B8		     stc		     ; OOOPS! This one's been used before. :(
SYSINIT:30B9
SYSINIT:30B9 su30:				     ; ...
SYSINIT:30B9		     pop     es
SYSINIT:30BA		     assume es:nothing
SYSINIT:30BA		     pop     ds
SYSINIT:30BB		     assume ds:nothing
SYSINIT:30BB		     pop     si
SYSINIT:30BC		     pop     di
SYSINIT:30BD		     pop     bx
SYSINIT:30BE		     retn
SYSINIT:30BE stowUMB	     endp
SYSINIT:30BE
SYSINIT:30BF
SYSINIT:30BF ; =============== S U B R O U T I N E =======================================
SYSINIT:30BF
SYSINIT:30BF
SYSINIT:30BF stowSiz	     proc near		     ; ...
SYSINIT:30BF		     push    bx
SYSINIT:30C0		     push    di
SYSINIT:30C1		     push    es
SYSINIT:30C2		     push    cs
SYSINIT:30C3		     pop     es
SYSINIT:30C4		     assume es:SYSINIT
SYSINIT:30C4		     mov     bl, cl	     ; Now bl==UMB number, AX==size
SYSINIT:30C6		     mov     bh, 0	     ; bx==UMB number, AX==size
SYSINIT:30C8		     shl     bl, 1	     ; bx==offset into array, AX=size
SYSINIT:30CA		     mov     es:UmbSize[bx], ax	; Store	the size
SYSINIT:30CF		     pop     es
SYSINIT:30D0		     assume es:nothing
SYSINIT:30D0		     pop     di
SYSINIT:30D1		     pop     bx
SYSINIT:30D2		     retn
SYSINIT:30D2 stowSiz	     endp
SYSINIT:30D2
SYSINIT:30D2 ; ---------------------------------------------------------------------------
SYSINIT:30D3 gnradix	     dw	0		     ; ...
SYSINIT:30D3					     ; Must be a word--16x16 multiplication
SYSINIT:30D5
SYSINIT:30D5 ; =============== S U B R O U T I N E =======================================
SYSINIT:30D5
SYSINIT:30D5
SYSINIT:30D5 toDigit	     proc near		     ; ...
SYSINIT:30D5		     cmp     cs:gnradix, 10h
SYSINIT:30DB		     jnz     short td10	     ; Don't check hex digits if radix isn't 16
SYSINIT:30DD		     cmp     cl, 61h ; 'a'
SYSINIT:30E0		     jb	     short td20
SYSINIT:30E2		     cmp     cl, 66h ; 'f'
SYSINIT:30E5		     ja	     short tdE	     ; Nothing valid above 'f' at all...
SYSINIT:30E7		     sub     cl, 57h	     ; 'a'-10 ; 87 ; Make 'a'==10 and return.
SYSINIT:30EA		     retn
SYSINIT:30EB ; ---------------------------------------------------------------------------
SYSINIT:30EB
SYSINIT:30EB td20:				     ; ...
SYSINIT:30EB		     cmp     cl, 41h ; 'A'   ; Below 'A'? Not a letter...
SYSINIT:30EE		     jb	     short td10
SYSINIT:30F0		     cmp     cl, 46h ; 'F'   ; Above 'F'? Not a digit.
SYSINIT:30F3		     ja	     short tdE
SYSINIT:30F5		     sub     cl, 37h	     ; 'A'-10 ; 55 ; Make 'A'==10 and return.
SYSINIT:30F8		     retn
SYSINIT:30F9 ; ---------------------------------------------------------------------------
SYSINIT:30F9
SYSINIT:30F9 td10:				     ; ...
SYSINIT:30F9		     cmp     cl, 30h ; '0'   ; If less than zero,
SYSINIT:30FC		     jb	     short tdE	     ; Done.
SYSINIT:30FE		     cmp     cl, 39h ; '9'   ; Or, if greater than nine,
SYSINIT:3101		     ja	     short tdE	     ; Done.
SYSINIT:3103		     sub     cl, 30h ; '0'   ; Okay--make '0'==0 and return.
SYSINIT:3106		     retn
SYSINIT:3107 ; ---------------------------------------------------------------------------
SYSINIT:3107
SYSINIT:3107 tdE:				     ; ...
SYSINIT:3107		     stc
SYSINIT:3108		     retn
SYSINIT:3108 toDigit	     endp
SYSINIT:3108
SYSINIT:3109
SYSINIT:3109 ; =============== S U B R O U T I N E =======================================
SYSINIT:3109
SYSINIT:3109
SYSINIT:3109 GetXNum	     proc near		     ; ...
SYSINIT:3109		     push    bx		     ; reads a 32-bit ASCII number at ES:SI
SYSINIT:3109					     ; and returns it in DX:AX
SYSINIT:310A		     push    cx
SYSINIT:310B		     push    ds
SYSINIT:310C		     cld
SYSINIT:310D		     xor     ax, ax
SYSINIT:310F		     xor     bx, bx
SYSINIT:3111		     xor     cx, cx
SYSINIT:3113		     xor     dx, dx	     ; Start with 0 (makes sense)
SYSINIT:3115		     mov     cs:gnradix, 0Ah ; And default to a	radix of 10 (dec)
SYSINIT:311C		     mov     cl, es:[si]
SYSINIT:311F		     call    toDigit
SYSINIT:3122		     jb	     short gxnE	     ; If it's not a digit, leave now.
SYSINIT:3124		     or	     cl, cl
SYSINIT:3126		     jnz     short gxn20     ; Doesn't have '0x'
SYSINIT:3128		     mov     cl, es:[si+1]
SYSINIT:312C		     cmp     cl, 'x'         ; Either 'x'...
SYSINIT:312F		     jz	     short gxn10
SYSINIT:3131		     cmp     cl, 'X'
SYSINIT:3134		     jnz     short gxn20
SYSINIT:3136
SYSINIT:3136 gxn10:				     ; ...
SYSINIT:3136		     mov     cs:gnradix, 16
SYSINIT:313D		     inc     si		     ; Since we	read "0x", march over it.
SYSINIT:313E		     inc     si
SYSINIT:313F
SYSINIT:313F gxn20:				     ; ...
SYSINIT:313F		     mov     cl, es:[si]     ; Now DX:AX=current total,	CH=0/CL=char
SYSINIT:3142		     inc     si
SYSINIT:3143		     call    toDigit	     ;	Accepts	only valid digits, A-F -> 10-16
SYSINIT:3146		     jb	     short gxnQ	     ; <- Ah...	wasn't a digit. Stop.
SYSINIT:3148		     call    mul32
SYSINIT:314B		     jb	     short gxnX
SYSINIT:314D		     add     ax, cx
SYSINIT:314F		     adc     dx, bx
SYSINIT:3151		     jb	     short gxnX
SYSINIT:3153		     jmp     short gxn20
SYSINIT:3155 ; ---------------------------------------------------------------------------
SYSINIT:3155
SYSINIT:3155 gxnE:				     ; ...
SYSINIT:3155		     stc
SYSINIT:3156		     jmp     short gxnX
SYSINIT:3158 ; ---------------------------------------------------------------------------
SYSINIT:3158
SYSINIT:3158 gxnQ:				     ; ...
SYSINIT:3158		     dec     si
SYSINIT:3159		     clc
SYSINIT:315A
SYSINIT:315A gxnX:				     ; ...
SYSINIT:315A		     pop     ds
SYSINIT:315B		     pop     cx
SYSINIT:315C		     pop     bx
SYSINIT:315D		     retn
SYSINIT:315D GetXNum	     endp
SYSINIT:315D
SYSINIT:315E
SYSINIT:315E ; =============== S U B R O U T I N E =======================================
SYSINIT:315E
SYSINIT:315E
SYSINIT:315E mul32	     proc near		     ; ...
SYSINIT:315E		     push    ax		     ; multiplies the number in	DX:AX by gnradix
SYSINIT:315E					     ; DX=old:hi, AX=old:lo, TOS=old:lo, BX=0
SYSINIT:315F		     mov     ax, dx
SYSINIT:3161		     mul     cs:gnradix	     ; DX=?, AX=new:hi,	TOS=old:lo, BX=0
SYSINIT:3166		     jb	     short m32E	     ; Too big?
SYSINIT:3168		     mov     dx, ax	     ; DX=new:hi, AX=new:hi, TOS=old:lo, BX=0
SYSINIT:316A		     pop     ax		     ; DX=new:hi, AX=old:lo, TOS=orig, BX=0
SYSINIT:316B		     xchg    dx, bx	     ; DX=0, AX=old:lo,	TOS=orig, BX=new:hi
SYSINIT:316D		     mul     cs:gnradix	     ; DX=carry, AX=new:lo, TOS=orig, BX=new:hi
SYSINIT:3172		     xchg    dx, bx
SYSINIT:3174		     add     dx, bx	     ; DX=new:hi, AX=new:lo, TOS=orig, BX=carry
SYSINIT:3176		     xor     bx, bx	     ; BX=0
SYSINIT:3178		     retn
SYSINIT:3179 ; ---------------------------------------------------------------------------
SYSINIT:3179
SYSINIT:3179 m32E:				     ; ...
SYSINIT:3179		     pop     ax
SYSINIT:317A		     retn
SYSINIT:317A mul32	     endp
SYSINIT:317A
SYSINIT:317B
SYSINIT:317B ; =============== S U B R O U T I N E =======================================
SYSINIT:317B
SYSINIT:317B
SYSINIT:317B toPara	     proc near		     ; ...
SYSINIT:317B		     push    cx		     ; divides DX:AX by	16; result in AX only
SYSINIT:317C		     mov     cl, 4	     ; DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll	llll
SYSINIT:317E		     shr     ax, cl	     ; DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll	llll
SYSINIT:3180		     xchg    ax, dx	     ; DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh	hhhh
SYSINIT:3181		     mov     cl, 12
SYSINIT:3183		     shl     ax, cl	     ; DX:AX=0000 LLLL llll llll:hhhh 0000 0000	0000
SYSINIT:3185		     or	     ax, dx	     ; AX=hhhh LLLL llll llll
SYSINIT:3187		     pop     cx
SYSINIT:3188		     retn
SYSINIT:3188 toPara	     endp
SYSINIT:3188
SYSINIT:3189
SYSINIT:3189 ; =============== S U B R O U T I N E =======================================
SYSINIT:3189
SYSINIT:3189
SYSINIT:3189 UmbHead	     proc near		     ; ...
SYSINIT:3189		     push    si
SYSINIT:318A		     push    ds
SYSINIT:318B		     push    es
SYSINIT:318C		     mov     ah, 52h	     ; GET_IN_VARS
SYSINIT:318E		     int     21h	     ; DOS - 2+	internal - GET LIST OF LISTS
SYSINIT:318E					     ; Return: ES:BX ->	DOS list of lists
SYSINIT:3190		     mov     ax, es:8Ch	     ; [es:DOS_UMB_HEAD]
SYSINIT:3194		     cmp     ax, 0FFFFh
SYSINIT:3197		     jz	     short uhE
SYSINIT:3199		     clc
SYSINIT:319A		     jmp     short uhX
SYSINIT:319C ; ---------------------------------------------------------------------------
SYSINIT:319C
SYSINIT:319C uhE:				     ; ...
SYSINIT:319C		     stc
SYSINIT:319D
SYSINIT:319D uhX:				     ; ...
SYSINIT:319D		     pop     es
SYSINIT:319E		     pop     ds
SYSINIT:319F		     pop     si
SYSINIT:31A0		     retn
SYSINIT:31A0 UmbHead	     endp
SYSINIT:31A0
SYSINIT:31A1
SYSINIT:31A1 ; =============== S U B R O U T I N E =======================================
SYSINIT:31A1
SYSINIT:31A1
SYSINIT:31A1 isSysMCB	     proc near		     ; ...
SYSINIT:31A1		     push    ax		     ; sets ZF if ES points to an MCB owned by "SC"
SYSINIT:31A2		     mov     ax, es:1	     ; [es:ARENA.OWNER]
SYSINIT:31A6		     cmp     ax, 8	     ; SystemPSPOwner ;	8 (for US or Japan) is valid
SYSINIT:31A9		     jz	     short ism10
SYSINIT:31AB		     cmp     ax, 9	     ; JapanPSPOwner ; 9 (for Japan) is	valid
SYSINIT:31AE		     jz	     short ism10
SYSINIT:31B0		     jmp     short ismX
SYSINIT:31B2 ; ---------------------------------------------------------------------------
SYSINIT:31B2
SYSINIT:31B2 ism10:				     ; ...
SYSINIT:31B2		     mov     ax, es:8	     ; [es:ARENA.NAME]
SYSINIT:31B6		     cmp     ax, 4353h	     ; 'SC'
SYSINIT:31B9
SYSINIT:31B9 ismX:				     ; ...
SYSINIT:31B9		     pop     ax
SYSINIT:31BA		     retn
SYSINIT:31BA isSysMCB	     endp
SYSINIT:31BA
SYSINIT:31BB
SYSINIT:31BB ; =============== S U B R O U T I N E =======================================
SYSINIT:31BB
SYSINIT:31BB
SYSINIT:31BB AddrToUmb	     proc near		     ; ...
SYSINIT:31BB		     push    cx		     ; converts	a segment address in AX
SYSINIT:31BB					     ; to its appropriate UMB number
SYSINIT:31BC		     push    dx
SYSINIT:31BD		     push    es
SYSINIT:31BE		     mov     dx, ax	     ; DX = address to search for
SYSINIT:31C0		     call    UmbHead	     ; AX = first segment
SYSINIT:31C3		     jb	     short atuE	     ; If it couldn't get it, error out
SYSINIT:31C5		     mov     es, ax
SYSINIT:31C7		     xor     cx, cx	     ; 0
SYSINIT:31C9
SYSINIT:31C9 atu10:				     ; ...
SYSINIT:31C9		     mov     ax, es
SYSINIT:31CB		     cmp     ax, dx	     ; Present segment >= given	segment?
SYSINIT:31CD		     jnb     short atuX	     ; yes, done.
SYSINIT:31CF		     call    isSysMCB	     ; Returns with ZF set if this is a	system MCB
SYSINIT:31D2		     jnz     short atu20
SYSINIT:31D4		     inc     cx		     ; If it _was_ a system MCB, we're in a new UMB.
SYSINIT:31D5
SYSINIT:31D5 atu20:				     ; ...
SYSINIT:31D5		     mov     al, es:0	     ; [es:ARENA.SIGNATURE]
SYSINIT:31D9		     cmp     al, 5Ah ; 'Z'
SYSINIT:31DB		     jz	     short atu30     ; 'Z' means this was the last MCB... that's it.
SYSINIT:31DD		     mov     ax, es
SYSINIT:31DF		     add     ax, es:3	     ; [es:ARENA.SIZE]
SYSINIT:31E4		     inc     ax
SYSINIT:31E5		     mov     es, ax
SYSINIT:31E7		     jmp     short atu10
SYSINIT:31E9 ; ---------------------------------------------------------------------------
SYSINIT:31E9
SYSINIT:31E9 atu30:				     ; ...
SYSINIT:31E9		     mov     ax, es
SYSINIT:31EB		     add     ax, es:3	     ; [es:ARENA.SIZE]
SYSINIT:31F0		     cmp     ax, dx	     ; Present >= given?
SYSINIT:31F2		     jnb     short atuX	     ; Yep! It _was_ inside.
SYSINIT:31F4
SYSINIT:31F4 atuE:				     ; ...
SYSINIT:31F4		     xor     cx, cx
SYSINIT:31F6		     dec     cx		     ; Address is above	UM Range,
SYSINIT:31F6					     ; AX will return as 0FFFFh.
SYSINIT:31F7
SYSINIT:31F7 atuX:				     ; ...
SYSINIT:31F7		     mov     ax, cx	     ; Return the UMB number in	AX (0==conv)
SYSINIT:31F9		     pop     es
SYSINIT:31FA		     pop     dx
SYSINIT:31FB		     pop     cx
SYSINIT:31FC		     retn
SYSINIT:31FC AddrToUmb	     endp
SYSINIT:31FC
SYSINIT:31FD
SYSINIT:31FD ; =============== S U B R O U T I N E =======================================
SYSINIT:31FD
SYSINIT:31FD
SYSINIT:31FD convUMB	     proc near		     ; ...
SYSINIT:31FD		     cmp     cs:gnradix, 10h ; convert address to UMB number after GetXNum
SYSINIT:31FD					     ; (GetXNum	has read a hex number)
SYSINIT:3203		     jnz     short cu10	     ; GetXNum didn't read in hex, it is not an addr
SYSINIT:3205		     call    AddrToUmb	     ; convert the address to a	UMB number
SYSINIT:3208		     cmp     ax, 0FFFFh
SYSINIT:320B		     jnz     short cu10
SYSINIT:320D		     inc     ax		     ; If too high, ignore it (make it conventional)
SYSINIT:320E
SYSINIT:320E cu10:				     ; ...
SYSINIT:320E		     retn
SYSINIT:320E convUMB	     endp
SYSINIT:320E
SYSINIT:320F
SYSINIT:320F ; =============== S U B R O U T I N E =======================================
SYSINIT:320F
SYSINIT:320F
SYSINIT:320F setUMBs	     proc near		     ; ...
SYSINIT:320F		     push    ax
SYSINIT:3210		     push    bx
SYSINIT:3211		     call    fm_link
SYSINIT:3214		     pop     bx
SYSINIT:3215		     pop     ax
SYSINIT:3216		     retn
SYSINIT:3216 setUMBs	     endp
SYSINIT:3216
SYSINIT:3217 ; ---------------------------------------------------------------------------
SYSINIT:3217
SYSINIT:3217 loadLow:				     ; loadLow subroutine is not used
SYSINIT:3217		     push    ds		     ; anywhere	of MSDOS 6.21 (& 5.0) IO.SYS
SYSINIT:3217					     ; Erdogan Tan - 18/07/2023
SYSINIT:3218		     push    cs
SYSINIT:3219		     pop     ds
SYSINIT:321A		     assume ds:SYSINIT
SYSINIT:321A		     mov     al, UmbLoad
SYSINIT:321D		     cmp     al, 0FFh	     ; UNSPECIFIED ; -1
SYSINIT:321F		     jnz     short ll10
SYSINIT:3221		     mov     al, 1
SYSINIT:3223		     stc
SYSINIT:3224		     jmp     short llx
SYSINIT:3226 ; ---------------------------------------------------------------------------
SYSINIT:3226
SYSINIT:3226 ll10:				     ; ...
SYSINIT:3226		     or	     al, al
SYSINIT:3228		     jz	     short llx
SYSINIT:322A		     mov     al, 1
SYSINIT:322C		     clc
SYSINIT:322D
SYSINIT:322D llx:				     ; ...
SYSINIT:322D		     pop     ds
SYSINIT:322E		     assume ds:nothing
SYSINIT:322E		     retn
SYSINIT:322F
SYSINIT:322F ; =============== S U B R O U T I N E =======================================
SYSINIT:322F
SYSINIT:322F
SYSINIT:322F HideUMBs	     proc near		     ; ...
SYSINIT:322F		     push    ax		     ; links UMBs and hides upper-memory as appropriate
SYSINIT:3230		     push    cx
SYSINIT:3231		     push    ds
SYSINIT:3232		     push    es
SYSINIT:3233		     call    UmbTest	     ; cf=0 if UMBs are	available
SYSINIT:3236		     jb	     short husX	     ; there is	nothing	to do.
SYSINIT:3238		     call    FixMem	     ; Concatenate adjacent free MCBs in upper mem
SYSINIT:323B		     call    setUMBs	     ; Link UMBs and set memory-allocation strategy
SYSINIT:323E		     push    es
SYSINIT:323F		     push    cs
SYSINIT:3240		     pop     es
SYSINIT:3241		     assume es:SYSINIT
SYSINIT:3241		     mov     es:fInHigh, 1   ; Remember	that we're now running high
SYSINIT:3247		     pop     es
SYSINIT:3248		     assume es:nothing
SYSINIT:3248		     call    GetLoadUMB	     ; See if they gave	us a list to leave free
SYSINIT:324B		     cmp     al, 0FFh	     ; UNSPECIFIED ; If	they didn't,
SYSINIT:324D		     jz	     short husX
SYSINIT:324F		     xor     cx, cx	     ; 0
SYSINIT:3251
SYSINIT:3251 hus10:				     ; ...
SYSINIT:3251		     inc     cx		     ; +1 for each UMB
SYSINIT:3252		     cmp     cx, 16	     ; MAXUMB
SYSINIT:3255		     jnb     short hus20
SYSINIT:3257		     mov     al, cl
SYSINIT:3259		     push    es
SYSINIT:325A		     call    findUMB	     ; ES:0 points to first MCB	in UMB
SYSINIT:325A					     ; Carry set if couldn't reach UMB
SYSINIT:325D		     pop     es
SYSINIT:325E		     jb	     short hus20     ; outside of the valid range of UMBs
SYSINIT:3260		     call    _hideUMB_	     ; hide what we need to hide.
SYSINIT:3263		     jmp     short hus10
SYSINIT:3265 ; ---------------------------------------------------------------------------
SYSINIT:3265
SYSINIT:3265 hus20:				     ; ...
SYSINIT:3265		     call    GetLoadUMB	     ; mov al,[cs:UmbLoad]
SYSINIT:3268		     or	     al, al	     ; or byte [cs:UmbLoad],0
SYSINIT:3268					     ; Is the load UMB 0? (-1==unspecified)
SYSINIT:326A		     jnz     short husX	     ; no, done.
SYSINIT:326C		     call    hl_unlink	     ; fix UMBs	and strategy.
SYSINIT:326F
SYSINIT:326F husX:				     ; ...
SYSINIT:326F		     pop     es
SYSINIT:3270		     pop     ds
SYSINIT:3271		     pop     cx
SYSINIT:3272		     pop     ax
SYSINIT:3273		     retn
SYSINIT:3273 HideUMBs	     endp
SYSINIT:3273
SYSINIT:3274
SYSINIT:3274 ; =============== S U B R O U T I N E =======================================
SYSINIT:3274
SYSINIT:3274
SYSINIT:3274 GetLoadUMB	     proc near		     ; ...
SYSINIT:3274		     push    ds		     ; Instead of calling this subroutine
SYSINIT:3274					     ; "or byte	[cs:UmbLoad],0"	then "jz/jnz .."
SYSINIT:3274					     ; would be	enough.	Erdogan	Tan - 18/07/2023
SYSINIT:3275		     push    cs
SYSINIT:3276		     pop     ds
SYSINIT:3277		     assume ds:SYSINIT
SYSINIT:3277		     mov     al, UmbLoad
SYSINIT:327A		     pop     ds
SYSINIT:327B		     assume ds:nothing
SYSINIT:327B		     retn
SYSINIT:327B GetLoadUMB	     endp
SYSINIT:327B
SYSINIT:327C
SYSINIT:327C ; =============== S U B R O U T I N E =======================================
SYSINIT:327C
SYSINIT:327C
SYSINIT:327C GetLoadSize     proc near		     ; ...
SYSINIT:327C		     push    bx
SYSINIT:327D		     push    si
SYSINIT:327E		     push    ds
SYSINIT:327F		     push    cs
SYSINIT:3280		     pop     ds
SYSINIT:3281		     assume ds:SYSINIT
SYSINIT:3281		     mov     al, UmbLoad
SYSINIT:3284		     xor     ah, ah
SYSINIT:3286		     mov     bx, offset	UmbSize	; array
SYSINIT:3289		     shl     al, 1
SYSINIT:328B		     add     ax, bx
SYSINIT:328D		     mov     si, ax
SYSINIT:328F		     lodsw		     ; ax==size
SYSINIT:3290		     pop     ds
SYSINIT:3291		     assume ds:nothing
SYSINIT:3291		     pop     si
SYSINIT:3292		     pop     bx
SYSINIT:3293		     retn
SYSINIT:3293 GetLoadSize     endp
SYSINIT:3293
SYSINIT:3294
SYSINIT:3294 ; =============== S U B R O U T I N E =======================================
SYSINIT:3294
SYSINIT:3294
SYSINIT:3294 GetSize	     proc near		     ; ...
SYSINIT:3294		     push    bx		     ; Returns the UMB in AL's minimum size
SYSINIT:3294					     ;	(0 if not specified)
SYSINIT:3295		     push    si
SYSINIT:3296		     push    ds
SYSINIT:3297		     push    cs
SYSINIT:3298		     pop     ds
SYSINIT:3299		     assume ds:SYSINIT
SYSINIT:3299		     xor     ah, ah
SYSINIT:329B		     mov     bx, offset	UmbSize	; array
SYSINIT:329E		     shl     al, 1
SYSINIT:32A0		     add     ax, bx
SYSINIT:32A2		     mov     si, ax
SYSINIT:32A4		     lodsw		     ; ax==size
SYSINIT:32A5		     pop     ds
SYSINIT:32A6		     assume ds:nothing
SYSINIT:32A6		     pop     si
SYSINIT:32A7		     pop     bx
SYSINIT:32A8		     retn
SYSINIT:32A8 GetSize	     endp
SYSINIT:32A8
SYSINIT:32A9 ; ---------------------------------------------------------------------------
SYSINIT:32A9
SYSINIT:32A9 StoLoadUMB:			     ; StoLoadUMB subroutine is	not used
SYSINIT:32A9		     push    es		     ; anywhere	of MSDOS 6.21 (& 5.0) IO.SYS
SYSINIT:32A9					     ; Erdogan Tan - 18/07/2023
SYSINIT:32AA		     push    cs
SYSINIT:32AB		     pop     es
SYSINIT:32AC		     assume es:SYSINIT
SYSINIT:32AC		     mov     es:UmbLoad, al  ; Overrides the load UMB number with what's in AL
SYSINIT:32B0		     pop     es
SYSINIT:32B1		     assume es:nothing
SYSINIT:32B1		     retn
SYSINIT:32B2
SYSINIT:32B2 ; =============== S U B R O U T I N E =======================================
SYSINIT:32B2
SYSINIT:32B2
SYSINIT:32B2 StoLoadSize     proc near		     ; ...
SYSINIT:32B2		     push    dx		     ; Overrides the load UMB min. size	with what's in AX
SYSINIT:32B3		     push    ds
SYSINIT:32B4		     push    cs
SYSINIT:32B5		     pop     ds
SYSINIT:32B6		     assume ds:SYSINIT
SYSINIT:32B6		     mov     dl, UmbLoad     ; Put UMB#	in DL
SYSINIT:32B6					     ;
SYSINIT:32B6					     ; BUG ! CL	would be used here instead of DL (*)
SYSINIT:32B6					     ; 18/07/2023
SYSINIT:32BA		     pop     ds
SYSINIT:32BB		     assume ds:nothing
SYSINIT:32BB		     cmp     dl, 0FFh	     ; UNSPECIFIED
SYSINIT:32BE		     jz	     short sls10
SYSINIT:32C0		     call    stowSiz	     ; We've got a function to do just this
SYSINIT:32C0					     ;
SYSINIT:32C0					     ; BUG ! stowSiz uses CL instead of	DL !
SYSINIT:32C0					     ; (CL is set in ParseL which calls	stowSiz)
SYSINIT:32C0					     ; (This BUG existing in PCDOS 7.1 IBMBIO.COM also)
SYSINIT:32C0					     ; Erdogan Tan - 18/07/2023
SYSINIT:32C3
SYSINIT:32C3 sls10:				     ; ...
SYSINIT:32C3		     pop     dx
SYSINIT:32C4		     retn
SYSINIT:32C4 StoLoadSize     endp
SYSINIT:32C4
SYSINIT:32C5
SYSINIT:32C5 ; =============== S U B R O U T I N E =======================================
SYSINIT:32C5
SYSINIT:32C5
SYSINIT:32C5 hideUMB	     proc near		     ; ...
SYSINIT:32C5		     push    ax		     ; marks as	HIDDEN all FREE	elements in UMB	passed as AL
SYSINIT:32C6		     push    es
SYSINIT:32C7		     call    findUMB	     ; Returns with carry if err, else ES == MCB
SYSINIT:32CA		     jb	     short huX
SYSINIT:32CC
SYSINIT:32CC hu10:				     ; ...
SYSINIT:32CC		     call    isSysMCB	     ; Returns with ZF set if owner is SYSTEM
SYSINIT:32CF		     jz	     short huX
SYSINIT:32D1		     call    isFreeMCB	     ; or word [es:ARENA.OWNER],0
SYSINIT:32D4		     jnz     short hu20
SYSINIT:32D6		     call    hideMCB
SYSINIT:32D9
SYSINIT:32D9 hu20:				     ; ...
SYSINIT:32D9		     mov     al, es:0	     ; [es:ARENA.SIGNATURE]
SYSINIT:32DD		     cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:32DF		     jz	     short huX
SYSINIT:32E1		     mov     ax, es	     ; Go on forward.
SYSINIT:32E3		     add     ax, es:3	     ; [es:ARENA.SIZE]
SYSINIT:32E8		     inc     ax
SYSINIT:32E9		     mov     es, ax
SYSINIT:32EB		     jmp     short hu10
SYSINIT:32ED ; ---------------------------------------------------------------------------
SYSINIT:32ED
SYSINIT:32ED huX:				     ; ...
SYSINIT:32ED		     pop     es
SYSINIT:32EE		     pop     ax
SYSINIT:32EF		     retn
SYSINIT:32EF hideUMB	     endp
SYSINIT:32EF
SYSINIT:32F0
SYSINIT:32F0 ; =============== S U B R O U T I N E =======================================
SYSINIT:32F0
SYSINIT:32F0
SYSINIT:32F0 isTiny	     proc near		     ; ...
SYSINIT:32F0		     push    ax		     ; returns with ZF set if user didn't specify /S
SYSINIT:32F1		     push    ds
SYSINIT:32F2		     push    cs
SYSINIT:32F3		     pop     ds
SYSINIT:32F4		     assume ds:SYSINIT
SYSINIT:32F4		     mov     al, fUmbTiny
SYSINIT:32F7		     pop     ds
SYSINIT:32F8		     assume ds:nothing
SYSINIT:32F8		     or	     al, al
SYSINIT:32FA		     pop     ax
SYSINIT:32FB		     retn
SYSINIT:32FB isTiny	     endp
SYSINIT:32FB
SYSINIT:32FC
SYSINIT:32FC ; =============== S U B R O U T I N E =======================================
SYSINIT:32FC
SYSINIT:32FC
SYSINIT:32FC isFreeMCB	     proc near		     ; ...
SYSINIT:32FC		     or	     word ptr es:1, 0 ;	or word	[es:ARENA.OWNER],0
SYSINIT:3302		     retn
SYSINIT:3302 isFreeMCB	     endp
SYSINIT:3302
SYSINIT:3303
SYSINIT:3303 ; =============== S U B R O U T I N E =======================================
SYSINIT:3303
SYSINIT:3303
SYSINIT:3303 hideMCB	     proc near		     ; ...
SYSINIT:3303		     mov     word ptr es:1, 8 ;	marks as HIDDEN	the MCB	at ES:0
SYSINIT:330A		     mov     word ptr es:8, 4948h ; 'HI'
SYSINIT:3311		     mov     word ptr es:0Ah, 4444h ; 'DD'
SYSINIT:3318		     mov     word ptr es:0Ch, 4E45h ; 'EN'
SYSINIT:331F		     mov     word ptr es:0Eh, 2020h ; '  '
SYSINIT:3326		     retn
SYSINIT:3326 hideMCB	     endp
SYSINIT:3326
SYSINIT:3327
SYSINIT:3327 ; =============== S U B R O U T I N E =======================================
SYSINIT:3327
SYSINIT:3327
SYSINIT:3327 unHideMCB	     proc near		     ; ...
SYSINIT:3327		     push    ax		     ; marks as	FREE the MCB at	ES:0
SYSINIT:3328		     mov     word ptr es:1, 0 ;	[es:ARENA.OWNER],FreePSPOwner
SYSINIT:332F		     mov     ax, 2020h	     ; '  '
SYSINIT:3332		     mov     es:8, ax	     ; [es:ARENA.NAME+0]
SYSINIT:3336		     mov     es:0Ah, ax	     ; [es:ARENA.NAME+2]
SYSINIT:333A		     mov     es:0Ch, ax	     ; [es:ARENA.NAME+4]
SYSINIT:333E		     mov     es:0Eh, ax	     ; [es:ARENA.NAME+6]
SYSINIT:3342		     pop     ax
SYSINIT:3343		     retn
SYSINIT:3343 unHideMCB	     endp
SYSINIT:3343
SYSINIT:3344
SYSINIT:3344 ; =============== S U B R O U T I N E =======================================
SYSINIT:3344
SYSINIT:3344
SYSINIT:3344 findUMB	     proc near		     ; ...
SYSINIT:3344		     push    ax		     ; makes ES:0 point	to the first MCB in UMB	given as AL
SYSINIT:3345		     push    cx
SYSINIT:3346		     push    dx
SYSINIT:3347		     xor     ah, ah
SYSINIT:3349		     mov     dx, ax	     ; Store the to-be-found UMB number	in DX
SYSINIT:334B		     call    UmbHead	     ; Returns first UMB segment in AX
SYSINIT:334E		     mov     es, ax
SYSINIT:3350		     xor     cx, cx	     ; Pretend we're on UMB 0 for now...
SYSINIT:3352
SYSINIT:3352 fu10:				     ; ...
SYSINIT:3352		     cmp     cx, dx	     ; If CX==DX, the UMB is found
SYSINIT:3354		     jz	     short fuX
SYSINIT:3356		     call    isSysMCB	     ; Returns with ZF set if owner is SYSTEM
SYSINIT:3359		     jnz     short fu20
SYSINIT:335B		     inc     cx
SYSINIT:335C
SYSINIT:335C fu20:				     ; ...
SYSINIT:335C		     mov     al, es:0
SYSINIT:3360		     cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:3362		     jz	     short fuE	     ; 'Z' means this was the last MCB
SYSINIT:3364		     mov     ax, es	     ; Go on forward.
SYSINIT:3366		     add     ax, es:3	     ; [es:ARENA.SIZE]
SYSINIT:336B		     inc     ax
SYSINIT:336C		     mov     es, ax
SYSINIT:336E		     jmp     short fu10
SYSINIT:3370 ; ---------------------------------------------------------------------------
SYSINIT:3370
SYSINIT:3370 fuE:				     ; ...
SYSINIT:3370		     stc
SYSINIT:3371
SYSINIT:3371 fuX:				     ; ...
SYSINIT:3371		     pop     dx
SYSINIT:3372		     pop     cx
SYSINIT:3373		     pop     ax		     ; The address is already in ES.
SYSINIT:3374		     retn
SYSINIT:3374 findUMB	     endp
SYSINIT:3374
SYSINIT:3375
SYSINIT:3375 ; =============== S U B R O U T I N E =======================================
SYSINIT:3375
SYSINIT:3375
SYSINIT:3375 BigFree	     proc near		     ; ...
SYSINIT:3375		     push    bx		     ; makes ES:0 point	to the largest free MCB
SYSINIT:3375					     ; in UMB given as AL
SYSINIT:3376		     push    cx
SYSINIT:3377		     call    findUMB	     ; Returns with CF if err, else ES==MCB
SYSINIT:337A		     jb	     short bfX
SYSINIT:337C		     xor     bx, bx	     ; Segment address of largest free MCB
SYSINIT:337E		     xor     cx, cx	     ; Size of largest free MCB
SYSINIT:3380
SYSINIT:3380 bf10:				     ; ...
SYSINIT:3380		     call    isSysMCB	     ; If we've left the MCB, we're done.
SYSINIT:3383		     jz	     short bf30
SYSINIT:3385		     call    isFreeMCB	     ; or word [es:ARENA.OWNER],0
SYSINIT:3388		     jnz     short bf20
SYSINIT:338A		     cmp     cx, es:3	     ; [es:ARENA.SIZE] ; Compare sizes..
SYSINIT:338F		     jg	     short bf20
SYSINIT:3391		     mov     bx, es	     ; Unless we're bigger,
SYSINIT:3393		     mov     cx, es:3	     ; Store this new element's addr and size.
SYSINIT:3398
SYSINIT:3398 bf20:				     ; ...
SYSINIT:3398		     mov     al, es:0
SYSINIT:339C		     cmp     al, 5Ah ; 'Z'   ; [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:339E		     jz	     short bf30
SYSINIT:33A0		     mov     ax, es	     ; NextMCB es,ax ; (macro) ; Go on forward.
SYSINIT:33A2		     add     ax, es:3	     ; es:ARENA.SIZE]
SYSINIT:33A7		     inc     ax
SYSINIT:33A8		     mov     es, ax
SYSINIT:33AA		     jmp     short bf10
SYSINIT:33AC ; ---------------------------------------------------------------------------
SYSINIT:33AC
SYSINIT:33AC bf30:				     ; ...
SYSINIT:33AC		     mov     es, bx	     ; Return the address
SYSINIT:33AE		     mov     ax, cx	     ; Return the size
SYSINIT:33B0		     or	     bx, bx
SYSINIT:33B2		     jnz     short bfX
SYSINIT:33B4		     stc		     ; (if size==0, there's nothing free)
SYSINIT:33B5
SYSINIT:33B5 bfX:				     ; ...
SYSINIT:33B5		     pop     cx
SYSINIT:33B6		     pop     bx
SYSINIT:33B7		     retn
SYSINIT:33B7 BigFree	     endp
SYSINIT:33B7
SYSINIT:33B8
SYSINIT:33B8 ; =============== S U B R O U T I N E =======================================
SYSINIT:33B8
SYSINIT:33B8
SYSINIT:33B8 isSpecified     proc near		     ; ...
SYSINIT:33B8		     push    ax		     ; sets ZF if UMB in AL wasn't specified in DH/LH line.
SYSINIT:33B9		     xor     bh, bh
SYSINIT:33BB		     mov     bl, al
SYSINIT:33BD		     push    ds
SYSINIT:33BE		     push    cs
SYSINIT:33BF		     pop     ds
SYSINIT:33C0		     assume ds:SYSINIT
SYSINIT:33C0		     mov     al, UmbUsed[bx]
SYSINIT:33C4		     pop     ds
SYSINIT:33C5		     assume ds:nothing
SYSINIT:33C5		     or	     al, al	     ; ets ZF if al==0 (ie, if unspecified)
SYSINIT:33C7		     pop     ax
SYSINIT:33C8		     retn
SYSINIT:33C8 isSpecified     endp
SYSINIT:33C8
SYSINIT:33C9
SYSINIT:33C9 ; =============== S U B R O U T I N E =======================================
SYSINIT:33C9
SYSINIT:33C9
SYSINIT:33C9 shrinkMCB	     proc near		     ; ...
SYSINIT:33C9		     push    bx		     ; breaks an MCB into two pieces, the lowest one's size==AX
SYSINIT:33C9					     ; AX == new size, ES:0 == current MCB
SYSINIT:33CA		     push    cx
SYSINIT:33CB		     push    es
SYSINIT:33CC		     mov     bx, ax	     ; requested size (lowest one)
SYSINIT:33CE		     mov     ax, es
SYSINIT:33D0		     mov     cx, es:3	     ; [es:ARENA.SIZE]
SYSINIT:33D5		     sub     cx, 32	     ; MIN_SPLIT_SIZE =	32
SYSINIT:33D8		     cmp     bx, cx	     ; {New size} vs {Current Size-20h}
SYSINIT:33DA		     ja	     short smE	     ; if wanted_size >	cur-20h, abort.
SYSINIT:33DC		     mov     dl, es:0	     ; [es:ARENA.SIGNATURE]
SYSINIT:33E1		     mov     cx, es:3
SYSINIT:33E6		     mov     es:3, bx	     ; [es:ARENA.SIZE]
SYSINIT:33EB		     mov     byte ptr es:0, 4Dh	; 'M' ; [es:ARENA.SIGNATURE],'M'
SYSINIT:33F1		     add     ax, bx
SYSINIT:33F3		     inc     ax
SYSINIT:33F4		     mov     es, ax	     ; Move to new arena area
SYSINIT:33F6		     mov     ax, cx
SYSINIT:33F8		     sub     ax, bx
SYSINIT:33FA		     dec     ax		     ; And prepare the new size
SYSINIT:33FB		     mov     es:0, dl	     ; [es:ARENA.SIGNATURE],dl
SYSINIT:3400		     mov     word ptr es:1, 0 ;	[es:ARENA.OWNER]
SYSINIT:3407		     mov     es:3, ax	     ; [es:ARENA.SIZE]
SYSINIT:340B		     mov     ax, 2020h	     ; '  '
SYSINIT:340E		     mov     es:8, ax	     ; [es:ARENA.NAME+0]
SYSINIT:3412		     mov     es:0Ah, ax	     ; [es:ARENA.NAME+2]
SYSINIT:3416		     mov     es:0Ch, ax	     ; [es:ARENA.NAME+4]
SYSINIT:341A		     mov     es:0Eh, ax	     ; [es:ARENA.NAME+6]
SYSINIT:341E		     clc
SYSINIT:341F		     jmp     short smX
SYSINIT:3421 ; ---------------------------------------------------------------------------
SYSINIT:3421
SYSINIT:3421 smE:				     ; ...
SYSINIT:3421		     stc
SYSINIT:3422
SYSINIT:3422 smX:				     ; ...
SYSINIT:3422		     pop     es
SYSINIT:3423		     pop     cx
SYSINIT:3424		     pop     bx
SYSINIT:3425		     retn
SYSINIT:3425 shrinkMCB	     endp
SYSINIT:3425
SYSINIT:3426
SYSINIT:3426 ; =============== S U B R O U T I N E =======================================
SYSINIT:3426
SYSINIT:3426
SYSINIT:3426 _hideUMB_	     proc near		     ; ...
SYSINIT:3426		     push    bx		     ; hides as	appropriate the	UMB in CL
SYSINIT:3427		     push    dx
SYSINIT:3428		     push    es
SYSINIT:3429		     mov     al, cl
SYSINIT:342B		     call    isSpecified     ; Returns ZF set if al's umb was NOT specified
SYSINIT:342E		     jz	     short hu_20
SYSINIT:3430		     mov     al, cl
SYSINIT:3432		     call    BigFree	     ; Retrieve	the size of the	largest	free element
SYSINIT:3432					     ; in AX, put its address in ES.
SYSINIT:3435		     jb	     short hu_20
SYSINIT:3437		     push    ax		     ; TOS==size of BigFree in UMB
SYSINIT:3438		     mov     al, cl	     ; Retrieve	the user's specified
SYSINIT:343A		     call    GetSize	     ; minimum size for	this umb (into AX)
SYSINIT:343D		     pop     bx		     ; BX==BigFree, AX==Specified Size
SYSINIT:343E		     or	     ax, ax	     ; If they didn't specify one,
SYSINIT:343E					     ; skip over all this.
SYSINIT:3440		     jz	     short hu_20
SYSINIT:3442		     cmp     ax, bx	     ; if (specified > max free)
SYSINIT:3444		     jbe     short hu_10
SYSINIT:3446		     mov     al, cl	     ; then mark that UMB as unused.
SYSINIT:3448		     call    unMarkUMB
SYSINIT:344B		     jmp     short hu_20
SYSINIT:344D ; ---------------------------------------------------------------------------
SYSINIT:344D
SYSINIT:344D hu_10:				     ; ...
SYSINIT:344D		     call    isTiny	     ; or byte [cs:fUmbTiny],0
SYSINIT:3450		     jz	     short hu_20
SYSINIT:3452		     call    shrinkMCB	     ; They specified /S, so shrink the	MCB to AX
SYSINIT:3455		     jb	     short hu_20
SYSINIT:3457		     mov     dx, es
SYSINIT:3459		     jmp     short hu_30     ; Skip the	spec check.. we	wanna hide this	one.
SYSINIT:345B ; ---------------------------------------------------------------------------
SYSINIT:345B
SYSINIT:345B hu_20:				     ; ...
SYSINIT:345B		     mov     ax, cx
SYSINIT:345D		     call    isSpecified     ; If they specified this UMB, we're done.
SYSINIT:3460		     jnz     short hu_X	     ; so leave.
SYSINIT:3462		     xor     dx, dx	     ; 0
SYSINIT:3464
SYSINIT:3464 hu_30:				     ; ...
SYSINIT:3464		     mov     al, cl
SYSINIT:3466		     call    hideUMB	     ; Hides everything	in UMB #al
SYSINIT:3469		     or	     dx, dx	     ; Did we shrink a UMB? If not, DX==0,
SYSINIT:346B		     jz	     short hu_X	     ; So we should leave.
SYSINIT:346D		     mov     es, dx	     ; Ah, but if it isn't, DX==the MCB's address;
SYSINIT:346F		     call    unHideMCB	     ; Un-hides	the lower portion of that MCB.
SYSINIT:3472
SYSINIT:3472 hu_X:				     ; ...
SYSINIT:3472		     pop     es
SYSINIT:3473		     pop     dx
SYSINIT:3474		     pop     bx
SYSINIT:3475		     retn
SYSINIT:3475 _hideUMB_	     endp
SYSINIT:3475
SYSINIT:3476
SYSINIT:3476 ; =============== S U B R O U T I N E =======================================
SYSINIT:3476
SYSINIT:3476
SYSINIT:3476 UnFreeze	     proc near		     ; ...
SYSINIT:3476		     push    ax		     ; Marks FROZEN elements as	FREE
SYSINIT:3477		     push    es
SYSINIT:3478		     call    UmbHead	     ; Returns with carry if err, else ES == MCB
SYSINIT:347B		     jb	     short ufX
SYSINIT:347D		     mov     es, ax
SYSINIT:347F
SYSINIT:347F uf10:				     ; ...
SYSINIT:347F		     call    isFrozMCB	     ; Returns with ZF set if MCB is FROZEN
SYSINIT:3482		     jnz     short uf20
SYSINIT:3484		     call    unHideMCB
SYSINIT:3487
SYSINIT:3487 uf20:				     ; ...
SYSINIT:3487		     mov     al, es:0
SYSINIT:348B		     cmp     al, 5Ah ; 'Z'
SYSINIT:348D		     jz	     short ufX
SYSINIT:348F		     mov     ax, es
SYSINIT:3491		     add     ax, es:3	     ; [es:ARENA.SIZE]
SYSINIT:3496		     inc     ax
SYSINIT:3497		     mov     es, ax
SYSINIT:3499		     jmp     short uf10
SYSINIT:349B ; ---------------------------------------------------------------------------
SYSINIT:349B
SYSINIT:349B ufX:				     ; ...
SYSINIT:349B		     pop     es
SYSINIT:349C		     pop     ax
SYSINIT:349D		     retn
SYSINIT:349D UnFreeze	     endp
SYSINIT:349D
SYSINIT:349E
SYSINIT:349E ; =============== S U B R O U T I N E =======================================
SYSINIT:349E
SYSINIT:349E
SYSINIT:349E isFrozMCB	     proc near		     ; ...
SYSINIT:349E		     push    ax
SYSINIT:349F		     mov     ax, es:1	     ; [es:ARENA.OWNER]	; Check	the owner..
SYSINIT:34A3		     cmp     ax, 8	     ; 8 (for US OR Japan) is valid
SYSINIT:34A6		     jnz     short ifmX
SYSINIT:34A8		     mov     ax, es:8	     ; [es:ARENA.NAME+0]
SYSINIT:34AC		     cmp     ax, 5246h	     ; 'FR'
SYSINIT:34AF		     jnz     short ifmX
SYSINIT:34B1		     mov     ax, es:0Ah	     ; [es:ARENA.NAME+2]
SYSINIT:34B5		     cmp     ax, 5A4Fh	     ; 'OZ'
SYSINIT:34B8		     jnz     short ifmX
SYSINIT:34BA		     mov     ax, es:0Ch	     ; [es:ARENA.NAME+4]
SYSINIT:34BE		     cmp     ax, 4E45h	     ; 'EN'
SYSINIT:34C1		     jnz     short ifmX
SYSINIT:34C3		     mov     ax, es:0Eh	     ; [es:ARENA.NAME+6]
SYSINIT:34C7		     cmp     ax, 2020h	     ; '  '
SYSINIT:34CA
SYSINIT:34CA ifmX:				     ; ...
SYSINIT:34CA		     pop     ax
SYSINIT:34CB		     retn
SYSINIT:34CB isFrozMCB	     endp
SYSINIT:34CB
SYSINIT:34CC
SYSINIT:34CC ; =============== S U B R O U T I N E =======================================
SYSINIT:34CC
SYSINIT:34CC
SYSINIT:34CC frezMCB	     proc near		     ; ...
SYSINIT:34CC		     mov     word ptr es:1, 8 ;	marks as 8+FROZEN the MCB at ES:0
SYSINIT:34CC					     ; mov word	[es:ARENA.OWNER],SystemPSPOwner
SYSINIT:34D3		     mov     word ptr es:8, 5246h ; [es:ARENA.NAME+0],'FR'
SYSINIT:34DA		     mov     word ptr es:0Ah, 5A4Fh ; [es:ARENA.NAME+2],'OZ'
SYSINIT:34E1		     mov     word ptr es:0Ch, 4E45h ; [es:ARENA.NAME+4],'EN'
SYSINIT:34E8		     mov     word ptr es:0Eh, 2020h ; [es:ARENA.NAME+6],'  '
SYSINIT:34EF		     retn
SYSINIT:34EF frezMCB	     endp
SYSINIT:34EF
SYSINIT:34F0
SYSINIT:34F0 ; =============== S U B R O U T I N E =======================================
SYSINIT:34F0
SYSINIT:34F0
SYSINIT:34F0 FreezeUM	     proc near		     ; ...
SYSINIT:34F0		     push    ax		     ; Marks FROZEN all	UM elements now	FREE,
SYSINIT:34F0					     ; save those in load UMB
SYSINIT:34F1		     push    cx
SYSINIT:34F2		     push    dx
SYSINIT:34F3		     push    es
SYSINIT:34F4		     call    GetLoadUMB	     ; mov al,[cs:UmbLoad]
SYSINIT:34F7		     xor     ah, ah	     ; 0
SYSINIT:34F9		     mov     dx, ax	     ; Store the load UMB in DX, so we can skip	it
SYSINIT:34FB		     call    UmbHead	     ; Returns first UMB segment in AX
SYSINIT:34FE		     mov     es, ax
SYSINIT:3500		     xor     cx, cx	     ; Pretend we're on UMB 0 for now..
SYSINIT:3502
SYSINIT:3502 fum10:				     ; ...
SYSINIT:3502		     call    isSysMCB	     ; Returns with ZF set if owner is SYSTEM
SYSINIT:3505		     jnz     short fum20
SYSINIT:3507		     inc     cx		     ; If it _was_ SYSTEM, we're in a new UMB.
SYSINIT:3508
SYSINIT:3508 fum20:				     ; ...
SYSINIT:3508		     cmp     cx, dx	     ; DX - UMB	number to skip (load UMB)
SYSINIT:3508					     ;
SYSINIT:3508					     ; If this is the load UMB,	we don't want to
SYSINIT:3508					     ; freeze anything.. so skip that section.
SYSINIT:350A		     jz	     short fum30
SYSINIT:350C		     call    isFreeMCB	     ; or word [es:ARENA.OWNER],0
SYSINIT:350C					     ; If it's not free, we can't freeze it
SYSINIT:350F		     jnz     short fum30
SYSINIT:3511		     call    frezMCB
SYSINIT:3514
SYSINIT:3514 fum30:				     ; ...
SYSINIT:3514		     mov     al, es:0
SYSINIT:3518		     cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:351A		     jz	     short fumX
SYSINIT:351C		     mov     ax, es	     ; NextMCB es, ax (macro) ;	Go on forward.
SYSINIT:351E		     add     ax, es:3	     ; [es:ARENA.SIZE]
SYSINIT:3523		     inc     ax
SYSINIT:3524		     mov     es, ax
SYSINIT:3526		     jmp     short fum10
SYSINIT:3528 ; ---------------------------------------------------------------------------
SYSINIT:3528
SYSINIT:3528 fumX:				     ; ...
SYSINIT:3528		     pop     es
SYSINIT:3529		     pop     dx
SYSINIT:352A		     pop     cx
SYSINIT:352B		     pop     ax
SYSINIT:352C		     retn
SYSINIT:352C FreezeUM	     endp
SYSINIT:352C
SYSINIT:352D
SYSINIT:352D ; =============== S U B R O U T I N E =======================================
SYSINIT:352D
SYSINIT:352D
SYSINIT:352D UmbTest	     proc near		     ; ...
SYSINIT:352D		     push    ax		     ; returns with carry set if UMBs are not available,
SYSINIT:352D					     ;	else CF==false
SYSINIT:352E		     push    bx
SYSINIT:352F		     push    ds
SYSINIT:3530		     push    es
SYSINIT:3531		     call    fm_link	     ; Link in UMBs (if	not already linked)
SYSINIT:3534		     call    WalkMem	     ; Check to	see if they're really linked
SYSINIT:3537		     pushf		     ; And remember what we found out
SYSINIT:3538		     call    fm_unlink	     ; Unlink UMBs (if we have linked 'em)
SYSINIT:353B		     popf		     ; And restore what	we found out.
SYSINIT:353C		     pop     es
SYSINIT:353D		     pop     ds
SYSINIT:353E		     pop     bx
SYSINIT:353F		     pop     ax
SYSINIT:3540		     retn
SYSINIT:3540 UmbTest	     endp
SYSINIT:3540
SYSINIT:3541
SYSINIT:3541 ; =============== S U B R O U T I N E =======================================
SYSINIT:3541
SYSINIT:3541
SYSINIT:3541 WalkMem	     proc near		     ; ...
SYSINIT:3541		     push    ax		     ; WalkMem - travels memory	chain and
SYSINIT:3541					     ; returns carry clear if UMBs are linked
SYSINIT:3542		     push    bx
SYSINIT:3543		     push    es
SYSINIT:3544		     mov     ah, 52h
SYSINIT:3546		     int     21h	     ; DOS - 2+	internal - GET LIST OF LISTS
SYSINIT:3546					     ; Return: ES:BX ->	DOS list of lists
SYSINIT:3548		     mov     ax, es:[bx-2]
SYSINIT:354C		     mov     es, ax	     ; ES = Current MCB	pointer
SYSINIT:354E
SYSINIT:354E um10:				     ; ...
SYSINIT:354E		     mov     al, es:0
SYSINIT:3552		     cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end ; 'Z'
SYSINIT:3554		     jz	     short um20
SYSINIT:3556		     mov     bx, es	     ; Move to the next	MCB
SYSINIT:3558		     add     bx, es:3	     ; [es:ARENA.SIZE]
SYSINIT:355D		     inc     bx
SYSINIT:355E		     mov     es, bx
SYSINIT:3560		     jmp     short um10
SYSINIT:3562 ; ---------------------------------------------------------------------------
SYSINIT:3562
SYSINIT:3562 um20:				     ; ...
SYSINIT:3562		     mov     ax, es
SYSINIT:3564		     cmp     ax, 9FFFh	     ; This sets CF if ax < 9FFFh.
SYSINIT:3567		     pop     es
SYSINIT:3568		     pop     bx
SYSINIT:3569		     pop     ax
SYSINIT:356A		     retn
SYSINIT:356A WalkMem	     endp
SYSINIT:356A
SYSINIT:356B
SYSINIT:356B ; =============== S U B R O U T I N E =======================================
SYSINIT:356B
SYSINIT:356B
SYSINIT:356B hl_unlink	     proc near		     ; ...
SYSINIT:356B		     xor     bh, bh	     ; unlinks UMBs if fm_umb is set to	0;
SYSINIT:356B					     ;	restores strategy too
SYSINIT:356D		     push    ds
SYSINIT:356E		     push    cs
SYSINIT:356F		     pop     ds
SYSINIT:3570		     assume ds:SYSINIT
SYSINIT:3570		     mov     bl, fm_umb
SYSINIT:3574		     pop     ds
SYSINIT:3575		     assume ds:nothing
SYSINIT:3575		     mov     ax, 5803h	     ; DOS_SET_UMBLINK
SYSINIT:3578		     int     21h	     ; DOS - 3+	- GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:3578					     ; AL = function code: (DOS	5beta) set UMB link state
SYSINIT:357A		     retn
SYSINIT:357A hl_unlink	     endp
SYSINIT:357A
SYSINIT:357B
SYSINIT:357B ; =============== S U B R O U T I N E =======================================
SYSINIT:357B
SYSINIT:357B
SYSINIT:357B UnHideUMBs	     proc near		     ; ...
SYSINIT:357B		     push    ax		     ; Marks HIDDEN elements as	FREE
SYSINIT:357C		     push    ds
SYSINIT:357D		     push    cs
SYSINIT:357E		     pop     ds
SYSINIT:357F		     assume ds:SYSINIT
SYSINIT:357F		     mov     al, fInHigh     ; mov al,[cs:fInHigh]
SYSINIT:3582		     pop     ds
SYSINIT:3583		     assume ds:nothing
SYSINIT:3583		     or	     al, al
SYSINIT:3585		     jnz     short uhu10     ; If didn't call loadhigh/devicehigh earlier,
SYSINIT:3587		     pop     ax		     ; then there's nothing to do here.
SYSINIT:3588		     stc
SYSINIT:3589		     retn
SYSINIT:358A ; ---------------------------------------------------------------------------
SYSINIT:358A
SYSINIT:358A uhu10:				     ; ...
SYSINIT:358A		     call    linkumb	     ; Make sure UMBs are linked in.
SYSINIT:358D		     call    FreeUMBs
SYSINIT:3590		     push    es
SYSINIT:3591		     push    cs
SYSINIT:3592		     pop     es
SYSINIT:3593		     assume es:SYSINIT
SYSINIT:3593		     mov     es:fInHigh, 0   ; We're leaving, so update fInHigh.
SYSINIT:3599		     pop     es
SYSINIT:359A		     assume es:nothing
SYSINIT:359A		     call    he_unlink	     ; Unlink UMBs
SYSINIT:359D		     pop     ax
SYSINIT:359E		     clc
SYSINIT:359F		     retn
SYSINIT:359F UnHideUMBs	     endp
SYSINIT:359F
SYSINIT:35A0
SYSINIT:35A0 ; =============== S U B R O U T I N E =======================================
SYSINIT:35A0
SYSINIT:35A0
SYSINIT:35A0 he_unlink	     proc near		     ; ...
SYSINIT:35A0		     xor     bh, bh	     ; unlinks UMBs if fm_umb is set to	0
SYSINIT:35A2		     push    ds
SYSINIT:35A3		     push    cs
SYSINIT:35A4		     pop     ds
SYSINIT:35A5		     assume ds:SYSINIT
SYSINIT:35A5		     mov     bl, fm_umb
SYSINIT:35A9		     pop     ds
SYSINIT:35AA		     assume ds:nothing
SYSINIT:35AA		     mov     ax, 5803h
SYSINIT:35AD		     int     21h	     ; DOS - 3+	- GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:35AD					     ; AL = function code: (DOS	5beta) set UMB link state
SYSINIT:35AF		     retn
SYSINIT:35AF he_unlink	     endp
SYSINIT:35AF
SYSINIT:35B0
SYSINIT:35B0 ; =============== S U B R O U T I N E =======================================
SYSINIT:35B0
SYSINIT:35B0
SYSINIT:35B0 FreeUMBs	     proc near		     ; ...
SYSINIT:35B0		     push    ax		     ; frees all HIDDEN	memory elements	in upper-memory
SYSINIT:35B1		     push    es
SYSINIT:35B2		     call    HeadUmb	     ; Returns with carry if err, else ES == MCB
SYSINIT:35B5		     jb	     short fusX
SYSINIT:35B7		     mov     es, ax	     ; Prepare for the loop; ES	= current MCB addr.
SYSINIT:35B9
SYSINIT:35B9 fus10:				     ; ...
SYSINIT:35B9		     call    isHideMCB	     ; Returns with ZF set if owner is 0
SYSINIT:35BC		     jnz     short fus20
SYSINIT:35BE		     call    freeMCB
SYSINIT:35C1
SYSINIT:35C1 fus20:				     ; ...
SYSINIT:35C1		     mov     al, es:0
SYSINIT:35C5		     cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:35C7		     jz	     short fusX
SYSINIT:35C9		     mov     ax, es
SYSINIT:35CB		     add     ax, es:3	     ; [es:ARENA.SIZE]
SYSINIT:35D0		     inc     ax
SYSINIT:35D1		     mov     es, ax
SYSINIT:35D3		     jmp     short fus10     ; Go on forward.
SYSINIT:35D5 ; ---------------------------------------------------------------------------
SYSINIT:35D5
SYSINIT:35D5 fusX:				     ; ...
SYSINIT:35D5		     pop     es
SYSINIT:35D6		     pop     ax
SYSINIT:35D7		     retn
SYSINIT:35D7 FreeUMBs	     endp
SYSINIT:35D7
SYSINIT:35D8
SYSINIT:35D8 ; =============== S U B R O U T I N E =======================================
SYSINIT:35D8
SYSINIT:35D8
SYSINIT:35D8 isHideMCB	     proc near		     ; ...
SYSINIT:35D8		     push    ax		     ; returns with ZF set if current MCB (ES:0) is HIDDEN
SYSINIT:35D9		     cmp     word ptr es:1, 8 ;	[es:ARENA.OWNER],SystemPSPOwner
SYSINIT:35D9					     ; If the owner's SYSTEM then check for HIDDEN
SYSINIT:35DF		     jnz     short ihm_x
SYSINIT:35E1		     mov     ax, es:8
SYSINIT:35E5		     cmp     ax, 4948h	     ; cmp word	[es:ARENA.NAME+0],'HI'
SYSINIT:35E8		     jnz     short ihm_x
SYSINIT:35EA		     mov     ax, es:0Ah
SYSINIT:35EE		     cmp     ax, 4444h	     ; cmp word	[es:ARENA.NAME+2],'DD'
SYSINIT:35F1		     jnz     short ihm_x
SYSINIT:35F3		     mov     ax, es:0Ch
SYSINIT:35F7		     cmp     ax, 4E45h	     ; cmp word	[es:ARENA.NAME+4],'EN'
SYSINIT:35FA		     jnz     short ihm_x
SYSINIT:35FC		     mov     ax, es:0Eh
SYSINIT:3600		     cmp     ax, 2020h	     ; [es:ARENA.NAME+4],'  '
SYSINIT:3603
SYSINIT:3603 ihm_x:				     ; ...
SYSINIT:3603		     pop     ax
SYSINIT:3604		     retn
SYSINIT:3604 isHideMCB	     endp
SYSINIT:3604
SYSINIT:3605
SYSINIT:3605 ; =============== S U B R O U T I N E =======================================
SYSINIT:3605
SYSINIT:3605
SYSINIT:3605 freeMCB	     proc near		     ; ...
SYSINIT:3605		     mov     word ptr es:1, 0 ;	marks as free the MCB at ES:0
SYSINIT:360C		     mov     ax, 2020h	     ; '  '
SYSINIT:360F		     mov     es:8, ax	     ; mov word	[es:ARENA.NAME+0],'  '
SYSINIT:3613		     mov     es:0Ah, ax
SYSINIT:3617		     mov     es:0Ch, ax
SYSINIT:361B		     mov     es:0Eh, ax	     ; [es:ARENA.NAME+6]
SYSINIT:361F		     retn
SYSINIT:361F freeMCB	     endp
SYSINIT:361F
SYSINIT:3620
SYSINIT:3620 ; =============== S U B R O U T I N E =======================================
SYSINIT:3620
SYSINIT:3620
SYSINIT:3620 HeadUmb	     proc near		     ; ...
SYSINIT:3620		     push    si		     ; returns in AX the addr of the 1st UMB block (0x9FFF)
SYSINIT:3621		     push    ds
SYSINIT:3622		     push    es
SYSINIT:3623		     mov     ah, 52h
SYSINIT:3625		     int     21h	     ; DOS - 2+	internal - GET LIST OF LISTS
SYSINIT:3625					     ; Return: ES:BX ->	DOS list of lists
SYSINIT:3627		     mov     ax, es:8Ch	     ; [es:UMB_HeadIdx]
SYSINIT:362B		     cmp     ax, 0FFFFh
SYSINIT:362E		     jz	     short xhu_e     ; If it's 0xFFFF, it's an error...
SYSINIT:3630		     clc		     ; AX contains 0x9FFF for most systems
SYSINIT:3631		     jmp     short xhu_x
SYSINIT:3633 ; ---------------------------------------------------------------------------
SYSINIT:3633
SYSINIT:3633 xhu_e:				     ; ...
SYSINIT:3633		     stc		     ; error
SYSINIT:3634
SYSINIT:3634 xhu_x:				     ; ...
SYSINIT:3634		     pop     es
SYSINIT:3635		     pop     ds
SYSINIT:3636		     pop     si
SYSINIT:3637		     retn
SYSINIT:3637 HeadUmb	     endp
SYSINIT:3637
SYSINIT:3638
SYSINIT:3638 ; =============== S U B R O U T I N E =======================================
SYSINIT:3638
SYSINIT:3638
SYSINIT:3638 linkumb	     proc near		     ; ...
SYSINIT:3638		     mov     ax, 5802h
SYSINIT:363B		     int     21h	     ; DOS - 3+	- GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:363B					     ; AL = function code: (DOS	5beta) get UMB link state
SYSINIT:363D		     or	     al, al
SYSINIT:363F		     jnz     short lumbX
SYSINIT:3641		     mov     ax, 5803h
SYSINIT:3644		     mov     bx, 1
SYSINIT:3647		     int     21h	     ; DOS - 3+	- GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:3647					     ; AL = function code: (DOS	5beta) set UMB link state
SYSINIT:3649
SYSINIT:3649 lumbX:				     ; ...
SYSINIT:3649		     retn
SYSINIT:3649 linkumb	     endp
SYSINIT:3649
SYSINIT:364A
SYSINIT:364A ; =============== S U B R O U T I N E =======================================
SYSINIT:364A
SYSINIT:364A
SYSINIT:364A InitDevLoad     proc near		     ; ...
SYSINIT:364A		     cmp     cs:DeviceHi, 0  ; Are we loading in UMB ?
SYSINIT:3650		     jz	     short InitForLo ; no, init	for lo mem
SYSINIT:3652		     cmp     cs:ConvLoad, 1  ; Are we loading as per Dos 5?
SYSINIT:3658		     jz	     short InitForConv
SYSINIT:365A		     call    ShrinkUMB	     ; Stop using the old device arena
SYSINIT:365D		     call    HideUMBs	     ; Mark up the UM area as we see fit
SYSINIT:3660		     call    FreezeUM	     ; Hide everything BUT the load area
SYSINIT:3663		     call    GetUMBForDev    ; And grab	that load area as needed
SYSINIT:3666		     pushf
SYSINIT:3667		     call    UnFreeze	     ; Then unhide everything frozen
SYSINIT:366A		     popf
SYSINIT:366B		     jb	     short InitForLo ; (if carry, it's loading low)
SYSINIT:366D		     jmp     short InitForHi
SYSINIT:366F ; ---------------------------------------------------------------------------
SYSINIT:366F
SYSINIT:366F InitForConv:			     ; ...
SYSINIT:366F		     call    SpaceInUMB	     ; Do we have space	left in	the current UMB	?
SYSINIT:3672		     jnb     short InitForHi ; yes, we have
SYSINIT:3674		     call    ShrinkUMB	     ; shrink the current UMB in use
SYSINIT:3677		     call    GetUMBForDev    ; else try	to allocate new	UMB
SYSINIT:367A		     jb	     short InitForLo ; we didn't succeed, so load in low memory
SYSINIT:367C
SYSINIT:367C InitForHi:				     ; ...
SYSINIT:367C		     mov     ax, cs:DevUMBFree ; get Para addr of free mem
SYSINIT:3680		     mov     dx, cs:DevUMBAddr ; UMB start addr
SYSINIT:3685		     add     dx, cs:DevUMBSize ; dx = UMB End addr
SYSINIT:368A		     jmp     short idl1
SYSINIT:368C ; ---------------------------------------------------------------------------
SYSINIT:368C
SYSINIT:368C InitForLo:				     ; ...
SYSINIT:368C		     mov     cs:DeviceHi, 0  ; in case we failed to load into UMB
SYSINIT:368C					     ; indicate	that we	are loading low
SYSINIT:3692		     mov     ax, cs:memhi    ; start of	Low memory
SYSINIT:3696		     mov     dx, cs:ALLOCLIM ; end of Low memory
SYSINIT:369B
SYSINIT:369B idl1:				     ; ...
SYSINIT:369B		     call    DevSetMark	     ; setup a sub-arena for DD
SYSINIT:369E		     mov     cs:DevLoadAddr, ax	; init the Device load address
SYSINIT:36A2		     mov     cs:DevLoadEnd, dx ; init the limit	of the block
SYSINIT:36A7		     mov     word ptr cs:DevEntry, 0 ; init Entry point	to DD
SYSINIT:36AE		     mov     word ptr cs:DevEntry+2, ax
SYSINIT:36B2		     retn
SYSINIT:36B2 InitDevLoad     endp
SYSINIT:36B2
SYSINIT:36B3
SYSINIT:36B3 ; =============== S U B R O U T I N E =======================================
SYSINIT:36B3
SYSINIT:36B3
SYSINIT:36B3 SpaceInUMB	     proc near		     ; ...
SYSINIT:36B3		     mov     ax, cs:DevUMBSize
SYSINIT:36B7		     add     ax, cs:DevUMBAddr ; End of	UMB
SYSINIT:36BC		     sub     ax, cs:DevUMBFree ; - Free	= Remaining space
SYSINIT:36C1		     or	     ax, ax	     ; Nospace ?
SYSINIT:36C3		     jnz     short spcinumb1
SYSINIT:36C5		     stc
SYSINIT:36C6		     retn
SYSINIT:36C7 ; ---------------------------------------------------------------------------
SYSINIT:36C7
SYSINIT:36C7 spcinumb1:				     ; ...
SYSINIT:36C7		     dec     ax		     ; space for sub-arena
SYSINIT:36C8		     cmp     ax, cs:DevSize  ; do we have space	?
SYSINIT:36CD		     retn
SYSINIT:36CD SpaceInUMB	     endp
SYSINIT:36CD
SYSINIT:36CE
SYSINIT:36CE ; =============== S U B R O U T I N E =======================================
SYSINIT:36CE
SYSINIT:36CE
SYSINIT:36CE PrepareMark     proc near		     ; ...
SYSINIT:36CE		     push    ds
SYSINIT:36CF		     mov     ds, ax
SYSINIT:36D1		     mov     word ptr ds:1, 8 ;	[ARENA.OWNER]
SYSINIT:36D7		     mov     word ptr ds:8, 4453h ; [ARENA.NAME],'SD'
SYSINIT:36DD		     pop     ds
SYSINIT:36DE		     inc     ax
SYSINIT:36DF		     mov     cs:DevUMBAddr, ax
SYSINIT:36E3		     mov     cs:DevUMBFree, ax
SYSINIT:36E7		     mov     cs:DevUMBSize, bx ; update	the UMB	Variables
SYSINIT:36EC		     retn
SYSINIT:36EC PrepareMark     endp
SYSINIT:36EC
SYSINIT:36ED
SYSINIT:36ED ; =============== S U B R O U T I N E =======================================
SYSINIT:36ED
SYSINIT:36ED
SYSINIT:36ED GetUMBForDev    proc near		     ; ...
SYSINIT:36ED		     mov     bx, 0FFFFh
SYSINIT:36F0		     mov     ax, 4800h
SYSINIT:36F3		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:36F3					     ; BX = number of 16-byte paragraphs desired
SYSINIT:36F5		     or	     bx, bx
SYSINIT:36F7		     jz	     short gufd_err
SYSINIT:36F9		     dec     bx
SYSINIT:36FA		     cmp     cs:DevSize, bx
SYSINIT:36FF		     ja	     short gufd_err
SYSINIT:3701		     inc     bx
SYSINIT:3702		     mov     ax, 4800h
SYSINIT:3705		     int     21h	     ; DOS - 2+	- ALLOCATE MEMORY
SYSINIT:3705					     ; BX = number of 16-byte paragraphs desired
SYSINIT:3707		     jb	     short gufd_err
SYSINIT:3709		     dec     ax
SYSINIT:370A		     call    PrepareMark
SYSINIT:370D		     clc
SYSINIT:370E		     retn
SYSINIT:370F ; ---------------------------------------------------------------------------
SYSINIT:370F
SYSINIT:370F gufd_err:				     ; ...
SYSINIT:370F		     xor     ax, ax	     ; 0
SYSINIT:3711		     mov     cs:DevUMBSize, ax ; erase the previous values
SYSINIT:3715		     mov     cs:DevUMBAddr, ax
SYSINIT:3719		     mov     cs:DevUMBFree, ax
SYSINIT:371D		     stc
SYSINIT:371E		     retn
SYSINIT:371E GetUMBForDev    endp
SYSINIT:371E
SYSINIT:371F
SYSINIT:371F ; =============== S U B R O U T I N E =======================================
SYSINIT:371F
SYSINIT:371F
SYSINIT:371F DevSetMark	     proc near		     ; ...
SYSINIT:371F		     push    es		     ; Input :
SYSINIT:371F					     ; AX - Free segment were device is	going to be loaded
SYSINIT:371F					     ; Output :
SYSINIT:371F					     ; AX - Segment at which device can	be loaded (AX=AX+1)
SYSINIT:371F					     ;
SYSINIT:371F					     ; Creates a sub-arena for the device driver
SYSINIT:371F					     ; puts 'D' marker in the sub-arena
SYSINIT:3720		     push    di
SYSINIT:3721		     push    ds
SYSINIT:3722		     push    si
SYSINIT:3723		     mov     es, ax
SYSINIT:3725		     mov     byte ptr es:0, 44h	; 'D' ; [es:devmark.id],devmark_device ; 'D'
SYSINIT:372B		     inc     ax
SYSINIT:372C		     mov     es:1, ax	     ; [es:devmark.seg]
SYSINIT:3730		     push    ax		     ; save load address
SYSINIT:3731		     lds     si, cs:bpb_addr ; command line is still there
SYSINIT:3736		     mov     di, si
SYSINIT:3738		     cld
SYSINIT:3739
SYSINIT:3739 dsm_again:				     ; ...
SYSINIT:3739		     lodsb
SYSINIT:373A		     cmp     al, 3Ah ; ':'
SYSINIT:373C		     jnz     short isit_slash
SYSINIT:373E		     mov     di, si
SYSINIT:3740		     jmp     short dsm_again
SYSINIT:3742 ; ---------------------------------------------------------------------------
SYSINIT:3742
SYSINIT:3742 isit_slash:			     ; ...
SYSINIT:3742		     cmp     al, 5Ch ; '\'
SYSINIT:3744		     jnz     short isit_null
SYSINIT:3746		     mov     di, si
SYSINIT:3748		     jmp     short dsm_again
SYSINIT:374A ; ---------------------------------------------------------------------------
SYSINIT:374A
SYSINIT:374A isit_null:				     ; ...
SYSINIT:374A		     or	     al, al
SYSINIT:374C		     jnz     short dsm_again
SYSINIT:374E		     mov     si, di
SYSINIT:3750		     mov     di, 8	     ; devmark.filename	; 8
SYSINIT:3753		     mov     cx, 8	     ; maximum 8 characters
SYSINIT:3756
SYSINIT:3756 dsm_next_char:			     ; ...
SYSINIT:3756		     lodsb
SYSINIT:3757		     or	     al, al
SYSINIT:3759		     jz	     short blankout
SYSINIT:375B		     cmp     al, 2Eh ; '.'
SYSINIT:375D		     jz	     short blankout
SYSINIT:375F		     stosb
SYSINIT:3760		     loop    dsm_next_char
SYSINIT:3762
SYSINIT:3762 blankout:				     ; ...
SYSINIT:3762		     jcxz    short dsm_exit
SYSINIT:3764		     mov     al, 20h ; ' '
SYSINIT:3766		     rep stosb		     ; blank out the rest
SYSINIT:3768
SYSINIT:3768 dsm_exit:				     ; ...
SYSINIT:3768		     pop     ax		     ; restore load address
SYSINIT:3769		     pop     si
SYSINIT:376A		     pop     ds
SYSINIT:376B		     pop     di
SYSINIT:376C		     pop     es
SYSINIT:376D		     retn
SYSINIT:376D DevSetMark	     endp
SYSINIT:376D
SYSINIT:376E
SYSINIT:376E ; =============== S U B R O U T I N E =======================================
SYSINIT:376E
SYSINIT:376E
SYSINIT:376E SizeDevice	     proc near		     ; ...
SYSINIT:376E		     push    ds		     ; Calculates the size of the device file in paras
SYSINIT:376E					     ; and stores it in	DevSize
SYSINIT:376F		     push    es
SYSINIT:3770		     pop     ds
SYSINIT:3771		     mov     dx, si
SYSINIT:3773		     mov     ax, 3D00h
SYSINIT:3776		     int     21h	     ; DOS - 2+	- OPEN DISK FILE WITH HANDLE
SYSINIT:3776					     ; DS:DX ->	ASCIZ filename
SYSINIT:3776					     ; AL = access mode
SYSINIT:3776					     ; 0 - read
SYSINIT:3778		     jb	     short sd_err
SYSINIT:377A		     mov     bx, ax	     ; BX - file handle
SYSINIT:377C		     mov     ax, 4202h
SYSINIT:377F		     xor     cx, cx
SYSINIT:3781		     mov     dx, cx
SYSINIT:3783		     int     21h	     ; DOS - 2+	- MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:3783					     ; AL = method: offset from	end of file
SYSINIT:3785		     jb	     short sd_close
SYSINIT:3787		     add     ax, 0Fh
SYSINIT:378A		     adc     dx, 0
SYSINIT:378D		     test    dx, 0FFF0h	     ; size > 0ffffh paras ?
SYSINIT:3791		     jz	     short szdev1    ; no
SYSINIT:3793		     mov     cs:DevSize, 0FFFFh	; invalid device size
SYSINIT:3793					     ;	assuming that we fail later
SYSINIT:379A		     jmp     short sd_close
SYSINIT:379C ; ---------------------------------------------------------------------------
SYSINIT:379C
SYSINIT:379C szdev1:				     ; ...
SYSINIT:379C		     mov     cl, 4	     ; convert it to paras
SYSINIT:379E		     shr     ax, cl
SYSINIT:37A0		     mov     cl, 0Ch
SYSINIT:37A2		     shl     dx, cl
SYSINIT:37A4		     or	     ax, dx
SYSINIT:37A6		     mov     cs:DevSize, ax  ; save file size (in paragraphs)
SYSINIT:37AA		     clc		     ; CLC is not needed here
SYSINIT:37AA					     ; (OR instruction clears CF) - E.TAN 22/07/2023
SYSINIT:37AB
SYSINIT:37AB sd_close:				     ; ...
SYSINIT:37AB		     pushf		     ; save carry flag
SYSINIT:37AC		     mov     ax, 3E00h
SYSINIT:37AF		     int     21h	     ; DOS - 2+	- CLOSE	A FILE WITH HANDLE
SYSINIT:37AF					     ; BX = file handle
SYSINIT:37B1		     popf		     ; restore carry flag
SYSINIT:37B1					     ; (we are not checking for	'close file' err)
SYSINIT:37B2
SYSINIT:37B2 sd_err:				     ; ...
SYSINIT:37B2		     pop     ds
SYSINIT:37B3		     retn
SYSINIT:37B3 SizeDevice	     endp
SYSINIT:37B3
SYSINIT:37B4
SYSINIT:37B4 ; =============== S U B R O U T I N E =======================================
SYSINIT:37B4
SYSINIT:37B4
SYSINIT:37B4 ExecDev	     proc near		     ; ...
SYSINIT:37B4		     mov     bx, cs:DevLoadAddr
SYSINIT:37B9		     mov     cs:DevExecAddr, bx	; Load the parameter block
SYSINIT:37BE		     mov     cs:DevExecReloc, bx ; block for exec with	load address
SYSINIT:37C3		     mov     bx, cs
SYSINIT:37C5		     mov     es, bx
SYSINIT:37C7		     assume es:SYSINIT
SYSINIT:37C7		     mov     bx, offset	DevExecAddr ; es:bx points to parameters
SYSINIT:37CA		     mov     al, 3	     ; (load program only)
SYSINIT:37CC		     mov     ah, 4Bh	     ; load in the device driver
SYSINIT:37CE		     int     21h	     ; DOS - 2+	- LOAD OR EXECUTE (EXEC)
SYSINIT:37CE					     ; DS:DX ->	ASCIZ filename
SYSINIT:37CE					     ; ES:BX ->	parameter block
SYSINIT:37CE					     ; AL = subfunc: called by MSC spawn(P_NOWAIT,...) when running DOS	4.x.
SYSINIT:37D0		     retn
SYSINIT:37D0 ExecDev	     endp
SYSINIT:37D0
SYSINIT:37D1
SYSINIT:37D1 ; =============== S U B R O U T I N E =======================================
SYSINIT:37D1
SYSINIT:37D1
SYSINIT:37D1 RetFromUM	     proc near		     ; ...
SYSINIT:37D1		     pushf
SYSINIT:37D2		     mov     cs:ConvLoad, 1  ; ConvLoad	set if didn't previously call HideUMBs
SYSINIT:37D8		     call    UnHideUMBs
SYSINIT:37DB		     jb	     short rfUM1
SYSINIT:37DD		     mov     cs:ConvLoad, 0  ; ConvLoad	clear if did.
SYSINIT:37E3
SYSINIT:37E3 rfUM1:				     ; ...
SYSINIT:37E3		     popf
SYSINIT:37E4		     retn
SYSINIT:37E4 RetFromUM	     endp
SYSINIT:37E4
SYSINIT:37E5
SYSINIT:37E5 ; =============== S U B R O U T I N E =======================================
SYSINIT:37E5
SYSINIT:37E5
SYSINIT:37E5 RemoveNull	     proc near		     ; ...
SYSINIT:37E5		     mov     bl, es:[si]
SYSINIT:37E8		     or	     bl, bl	     ; null ?
SYSINIT:37EA		     jz	     short rn_gotnull
SYSINIT:37EC		     inc     si		     ; advance the pointer
SYSINIT:37ED		     jmp     short RemoveNull
SYSINIT:37EF ; ---------------------------------------------------------------------------
SYSINIT:37EF
SYSINIT:37EF rn_gotnull:			     ; ...
SYSINIT:37EF		     mov     bl, cs:DevSavedDelim
SYSINIT:37F4		     mov     es:[si], bl     ; replace null with blank
SYSINIT:37F7		     retn
SYSINIT:37F7 RemoveNull	     endp
SYSINIT:37F7
SYSINIT:37F8
SYSINIT:37F8 ; =============== S U B R O U T I N E =======================================
SYSINIT:37F8
SYSINIT:37F8
SYSINIT:37F8 RoundBreakAddr  proc near		     ; ...
SYSINIT:37F8		     mov     ax, word ptr cs:DevBrkAddr	; Rounds DevBrkAddr to a para addr
SYSINIT:37F8					     ; so that it is of	the form xxxx:0
SYSINIT:37FC		     call    ParaRound
SYSINIT:37FF		     add     word ptr cs:DevBrkAddr+2, ax
SYSINIT:3804		     mov     word ptr cs:DevBrkAddr, 0
SYSINIT:380B		     mov     ax, cs:DevLoadEnd
SYSINIT:380F		     cmp     word ptr cs:DevBrkAddr+2, ax
SYSINIT:3814		     jbe     short rba_ok
SYSINIT:3816		     jmp     mem_err
SYSINIT:3819 ; ---------------------------------------------------------------------------
SYSINIT:3819
SYSINIT:3819 rba_ok:				     ; ...
SYSINIT:3819		     retn
SYSINIT:3819 RoundBreakAddr  endp
SYSINIT:3819
SYSINIT:381A
SYSINIT:381A ; =============== S U B R O U T I N E =======================================
SYSINIT:381A
SYSINIT:381A
SYSINIT:381A DevSetBreak     proc near		     ; ...
SYSINIT:381A		     push    ax
SYSINIT:381B		     mov     ax, word ptr cs:DevBrkAddr+2 ; remove the init code
SYSINIT:381F		     cmp     cs:multdeviceflag,	0
SYSINIT:3825		     jnz     short set_break_continue ;	do not check it.
SYSINIT:3827		     cmp     ax, cs:DevLoadAddr
SYSINIT:382C		     jnz     short set_break_continue ;	if not same, then o.k.
SYSINIT:382E		     cmp     word ptr cs:DevBrkAddr, 0
SYSINIT:3834		     jz	     short break_failed	; [DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0
SYSINIT:3836
SYSINIT:3836 set_break_continue:		     ; ...
SYSINIT:3836		     call    RoundBreakAddr
SYSINIT:3839		     pop     ax
SYSINIT:383A		     clc
SYSINIT:383B		     retn
SYSINIT:383C ; ---------------------------------------------------------------------------
SYSINIT:383C
SYSINIT:383C break_failed:			     ; ...
SYSINIT:383C		     pop     ax
SYSINIT:383D		     stc
SYSINIT:383E		     retn
SYSINIT:383E DevSetBreak     endp
SYSINIT:383E
SYSINIT:383F
SYSINIT:383F ; =============== S U B R O U T I N E =======================================
SYSINIT:383F
SYSINIT:383F
SYSINIT:383F DevBreak	     proc near		     ; ...
SYSINIT:383F		     push    ds		     ; Marks a succesful install of a device driver
SYSINIT:383F					     ; Sets device size	field in sub-arena &
SYSINIT:383F					     ; Updates Free ptr	in UMB or adjusts memhi
SYSINIT:3840		     mov     ax, cs:DevLoadAddr
SYSINIT:3844		     mov     bx, word ptr cs:DevBrkAddr+2
SYSINIT:3849		     dec     ax		     ; seg of sub-arena
SYSINIT:384A		     mov     ds, ax
SYSINIT:384C		     inc     ax		     ; Back to Device segment
SYSINIT:384D		     sub     ax, bx
SYSINIT:384F		     neg     ax		     ; size of device in paras
SYSINIT:3851		     mov     ds:3, ax	     ; [devmark.size]
SYSINIT:3851					     ; store it	in sub-arena
SYSINIT:3854		     cmp     cs:DeviceHi, 0
SYSINIT:385A		     jz	     short db_lo
SYSINIT:385C		     mov     cs:DevUMBFree, bx ; update	Free ptr in UMB
SYSINIT:3861		     jmp     short db_exit
SYSINIT:3863 ; ---------------------------------------------------------------------------
SYSINIT:3863
SYSINIT:3863 db_lo:				     ; ...
SYSINIT:3863		     mov     cs:memhi, bx
SYSINIT:3868		     mov     cs:memlo, 0
SYSINIT:386F
SYSINIT:386F db_exit:				     ; ...
SYSINIT:386F		     pop     ds
SYSINIT:3870		     retn
SYSINIT:3870 DevBreak	     endp
SYSINIT:3870
SYSINIT:3871
SYSINIT:3871 ; =============== S U B R O U T I N E =======================================
SYSINIT:3871
SYSINIT:3871
SYSINIT:3871 ParseSize	     proc near		     ; ...
SYSINIT:3871		     push    bx		     ; Parses the command line for SIZE= command
SYSINIT:3872		     mov     bx, si
SYSINIT:3874		     mov     cs:DevSizeOption, 0 ; init	the value
SYSINIT:387B		     mov     word ptr cs:DevCmdLine, si
SYSINIT:3880		     mov     word ptr cs:DevCmdLine+2, es
SYSINIT:3885		     call    SkipDelim
SYSINIT:3888		     cmp     word ptr es:[si], 4953h ; 'SI'
SYSINIT:388D		     jnz     short ps_no_size
SYSINIT:388F		     cmp     word ptr es:[si+2], 455Ah ; 'ZE'
SYSINIT:3895		     jnz     short ps_no_size
SYSINIT:3897		     mov     al, es:[si+4]
SYSINIT:389B		     call    delim
SYSINIT:389E		     jnz     short ps_no_size ;	cf=0 here
SYSINIT:38A0		     add     si, 5
SYSINIT:38A3		     call    GetHexNum
SYSINIT:38A6		     jb	     short ps_err
SYSINIT:38A8		     mov     cs:DevSizeOption, ax
SYSINIT:38AC		     call    SkipDelim
SYSINIT:38AF		     mov     bx, si	     ; cf=0 here
SYSINIT:38B1
SYSINIT:38B1 ps_no_size:			     ; ...
SYSINIT:38B1		     mov     si, bx
SYSINIT:38B3		     pop     bx
SYSINIT:38B4		     clc		     ; cf=0 here (clc is not needed)
SYSINIT:38B4					     ; 22/07/2023 - Erdogan Tan
SYSINIT:38B5		     retn
SYSINIT:38B6 ; ---------------------------------------------------------------------------
SYSINIT:38B6
SYSINIT:38B6 ps_err:				     ; ...
SYSINIT:38B6		     pop     bx
SYSINIT:38B7		     stc
SYSINIT:38B8		     retn
SYSINIT:38B8 ParseSize	     endp
SYSINIT:38B8
SYSINIT:38B9
SYSINIT:38B9 ; =============== S U B R O U T I N E =======================================
SYSINIT:38B9
SYSINIT:38B9
SYSINIT:38B9 SkipDelim	     proc near		     ; ...
SYSINIT:38B9		     mov     al, es:[si]     ; Skips delimiters	in the string pointed to by ES:SI
SYSINIT:38B9					     ; Returns ptr to first non-delimiter character in ES:SI
SYSINIT:38BC		     call    delim
SYSINIT:38BF		     jnz     short sd_ret
SYSINIT:38C1		     inc     si
SYSINIT:38C2		     jmp     short SkipDelim
SYSINIT:38C4 ; ---------------------------------------------------------------------------
SYSINIT:38C4
SYSINIT:38C4 sd_ret:				     ; ...
SYSINIT:38C4		     retn
SYSINIT:38C4 SkipDelim	     endp
SYSINIT:38C4
SYSINIT:38C5
SYSINIT:38C5 ; =============== S U B R O U T I N E =======================================
SYSINIT:38C5
SYSINIT:38C5
SYSINIT:38C5 GetHexNum	     proc near		     ; ...
SYSINIT:38C5		     xor     ax, ax	     ; Converts	an ascii string
SYSINIT:38C5					     ; terminated by a delimiter into binary.
SYSINIT:38C5					     ; Assumes that the	ES:SI
SYSINIT:38C5					     ; points to a Hexadecimal string
SYSINIT:38C7		     xor     dx, dx
SYSINIT:38C9
SYSINIT:38C9 ghn_next:				     ; ...
SYSINIT:38C9		     mov     bl, es:[si]
SYSINIT:38CC		     cmp     bl, 0Dh	     ; cr
SYSINIT:38CF		     jz	     short ghn_err
SYSINIT:38D1		     cmp     bl, 0Ah	     ; lf
SYSINIT:38D4		     jz	     short ghn_err
SYSINIT:38D6		     push    ax
SYSINIT:38D7		     mov     al, bl
SYSINIT:38D9		     call    delim
SYSINIT:38DC		     pop     ax
SYSINIT:38DD		     jz	     short ghn_into_paras
SYSINIT:38DF		     call    GetNibble
SYSINIT:38E2		     jb	     short ghn_err
SYSINIT:38E4		     mov     cx, 4
SYSINIT:38E7
SYSINIT:38E7 ghn_shift1:			     ; ...
SYSINIT:38E7		     shl     ax, 1
SYSINIT:38E9		     rcl     dx, 1
SYSINIT:38EB		     loop    ghn_shift1
SYSINIT:38ED		     or	     al, bl
SYSINIT:38EF		     inc     si
SYSINIT:38F0		     jmp     short ghn_next
SYSINIT:38F2 ; ---------------------------------------------------------------------------
SYSINIT:38F2
SYSINIT:38F2 ghn_into_paras:			     ; ...
SYSINIT:38F2		     add     ax, 15
SYSINIT:38F5		     adc     dx, 0
SYSINIT:38F8		     test    dx, 0FFF0h
SYSINIT:38FC		     jnz     short ghn_err
SYSINIT:38FE		     mov     cx, 4
SYSINIT:3901
SYSINIT:3901 ghn_shift2:			     ; ...
SYSINIT:3901		     clc
SYSINIT:3902		     rcr     dx, 1
SYSINIT:3904		     rcr     ax, 1
SYSINIT:3906		     loop    ghn_shift2
SYSINIT:3908		     clc		     ; AX = number of paras equivalent to the
SYSINIT:3908					     ; hex number of bytes specified
SYSINIT:3908					     ; by the hexadecimal string.
SYSINIT:3909		     retn
SYSINIT:390A ; ---------------------------------------------------------------------------
SYSINIT:390A
SYSINIT:390A ghn_err:				     ; ...
SYSINIT:390A		     stc		     ; encountered a non-hex character or crlf
SYSINIT:390B		     retn
SYSINIT:390B GetHexNum	     endp
SYSINIT:390B
SYSINIT:390C
SYSINIT:390C ; =============== S U B R O U T I N E =======================================
SYSINIT:390C
SYSINIT:390C
SYSINIT:390C GetNibble	     proc near		     ; ...
SYSINIT:390C		     cmp     bl, 30h ; '0'   ; Convert one nibble (hex digit) in BL into binary
SYSINIT:390F		     jb	     short gnib_err
SYSINIT:3911		     cmp     bl, 39h ; '9'
SYSINIT:3914		     ja	     short is_it_hex
SYSINIT:3916		     sub     bl, 30h ; '0'
SYSINIT:3919		     retn
SYSINIT:391A ; ---------------------------------------------------------------------------
SYSINIT:391A
SYSINIT:391A is_it_hex:				     ; ...
SYSINIT:391A		     cmp     bl, 41h ; 'A'
SYSINIT:391D		     jb	     short gnib_err
SYSINIT:391F		     cmp     bl, 46h ; 'F'
SYSINIT:3922		     ja	     short gnib_err
SYSINIT:3924		     sub     bl, 37h ; '7'
SYSINIT:3927		     retn
SYSINIT:3928 ; ---------------------------------------------------------------------------
SYSINIT:3928
SYSINIT:3928 gnib_err:				     ; ...
SYSINIT:3928		     stc
SYSINIT:3929		     retn
SYSINIT:3929 GetNibble	     endp
SYSINIT:3929
SYSINIT:392A
SYSINIT:392A ; =============== S U B R O U T I N E =======================================
SYSINIT:392A
SYSINIT:392A
SYSINIT:392A AllocUMB	     proc near		     ; ...
SYSINIT:392A		     call    InitAllocUMB    ; Allocate	all UMBs and link it to	DOS arena chain
SYSINIT:392A					     ; link in the first UMB
SYSINIT:392D		     jb	     short au_exit   ; quit on error
SYSINIT:392F
SYSINIT:392F au_next:				     ; ...
SYSINIT:392F		     call    umb_allocate    ; allocate
SYSINIT:3932		     jb	     short au_coalesce
SYSINIT:3934		     call    umb_insert	     ; & insert	till no	UMBs
SYSINIT:3937		     jmp     short au_next
SYSINIT:3939 ; ---------------------------------------------------------------------------
SYSINIT:3939
SYSINIT:3939 au_coalesce:			     ; ...
SYSINIT:3939		     call    umb_coalesce    ; coalesce	all UMBs
SYSINIT:393C
SYSINIT:393C au_exit:				     ; ...
SYSINIT:393C		     retn
SYSINIT:393C AllocUMB	     endp
SYSINIT:393C
SYSINIT:393D
SYSINIT:393D ; =============== S U B R O U T I N E =======================================
SYSINIT:393D
SYSINIT:393D
SYSINIT:393D InitAllocUMB    proc near		     ; ...
SYSINIT:393D		     call    IsXMSLoaded
SYSINIT:3940		     jnz     short iau_err   ; quit on no XMS driver
SYSINIT:3942		     mov     ah, 52h
SYSINIT:3944		     int     21h	     ; DOS - 2+	internal - GET LIST OF LISTS
SYSINIT:3944					     ; Return: ES:BX ->	DOS list of lists
SYSINIT:3946		     mov     cs:DevDOSData, es ; save dos data segment
SYSINIT:394B		     mov     ax, 4310h
SYSINIT:394E		     int     2Fh	     ; - Multiplex - XMS - GET DRIVER ADDRESS
SYSINIT:394E					     ; Return: ES:BX ->	driver entry point
SYSINIT:3950		     mov     word ptr cs:DevXMSAddr, bx	; get XMS driver address
SYSINIT:3955		     mov     word ptr cs:DevXMSAddr+2, es
SYSINIT:395A		     cmp     cs:FirstUMBLinked,	0 ; have we already linked a UMB?
SYSINIT:3960		     jnz     short ia_1	     ; quit if we already did it
SYSINIT:3962		     call    LinkFirstUMB    ; else link the first UMB
SYSINIT:3965		     jb	     short iau_err
SYSINIT:3967		     mov     cs:FirstUMBLinked,	0FFh ; mark that 1st UMB linked
SYSINIT:396D
SYSINIT:396D ia_1:				     ; ...
SYSINIT:396D		     clc		     ; (cf is already zero here)
SYSINIT:396D					     ; Erdogan tan - 27/07/2023
SYSINIT:396E		     retn
SYSINIT:396F ; ---------------------------------------------------------------------------
SYSINIT:396F
SYSINIT:396F iau_err:				     ; ...
SYSINIT:396F		     stc
SYSINIT:3970		     retn
SYSINIT:3970 InitAllocUMB    endp
SYSINIT:3970
SYSINIT:3971
SYSINIT:3971 ; =============== S U B R O U T I N E =======================================
SYSINIT:3971
SYSINIT:3971
SYSINIT:3971 umb_allocate    proc near		     ; ...
SYSINIT:3971		     push    ax
SYSINIT:3972		     mov     ah, 16	     ; XMM_REQUEST_UMB
SYSINIT:3974		     mov     dx, 0FFFFh	     ; try to allocate largest possible
SYSINIT:3977		     call    cs:DevXMSAddr
SYSINIT:397C		     or	     dx, dx
SYSINIT:397E		     jz	     short ua_err
SYSINIT:3980		     mov     ah, 16
SYSINIT:3982		     call    cs:DevXMSAddr
SYSINIT:3987		     cmp     ax, 1	     ; Q: was the reqst	successful
SYSINIT:398A		     jnz     short ua_err    ; N: error
SYSINIT:398C		     clc
SYSINIT:398D
SYSINIT:398D ua_done:				     ; ...
SYSINIT:398D		     pop     ax
SYSINIT:398E		     retn
SYSINIT:398F ; ---------------------------------------------------------------------------
SYSINIT:398F
SYSINIT:398F ua_err:				     ; ...
SYSINIT:398F		     stc
SYSINIT:3990		     jmp     short ua_done
SYSINIT:3990 umb_allocate    endp
SYSINIT:3990
SYSINIT:3992
SYSINIT:3992 ; =============== S U B R O U T I N E =======================================
SYSINIT:3992
SYSINIT:3992
SYSINIT:3992 umb_insert	     proc near		     ; ...
SYSINIT:3992		     push    ds		     ; links the UMB into the arena chain
SYSINIT:3993		     mov     ds, cs:DevDOSData
SYSINIT:3998		     mov     ds, word ptr ds:8Ch ; [UMB_ARENA]	; ds = UMB_HEAD
SYSINIT:399C		     mov     ax, ds
SYSINIT:399E		     mov     es, ax
SYSINIT:39A0		     assume es:nothing
SYSINIT:39A0
SYSINIT:39A0 ui_next:				     ; ...
SYSINIT:39A0		     cmp     ax, bx	     ; BX = seg	address	of UMB to be linked in
SYSINIT:39A2		     ja	     short ui_insert ; current block above new block, insert it
SYSINIT:39A4		     cmp     byte ptr es:0, 5Ah	; 'Z' ; [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:39AA		     jz	     short ui_append ; if current block	is the last,
SYSINIT:39AA					     ; append new block	to chain
SYSINIT:39AC		     mov     ds, ax
SYSINIT:39AE		     call    get_next
SYSINIT:39B1		     jmp     short ui_next   ; ax = es = next block
SYSINIT:39B3 ; ---------------------------------------------------------------------------
SYSINIT:39B3
SYSINIT:39B3 ui_insert:				     ; ...
SYSINIT:39B3		     mov     cx, ds	     ; ds = previous arena
SYSINIT:39B5		     inc     cx		     ; top of previous block
SYSINIT:39B6		     sub     cx, bx
SYSINIT:39B8		     neg     cx		     ; cx = size of used block
SYSINIT:39BA		     mov     byte ptr ds:0, 4Dh	; 'M' ; [ARENA.SIGNATURE],arena_signature_normal
SYSINIT:39BF		     mov     word ptr ds:1, 8 ;	[ARENA.OWNER],8	; mark as system owned
SYSINIT:39C5		     mov     ds:3, cx	     ; [ARENA.SIZE],cx
SYSINIT:39C9		     mov     word ptr ds:8, 4353h ; [ARENA.NAME],'SC'
SYSINIT:39CF		     mov     es, bx	     ; prepare the arena at start of new block
SYSINIT:39D1		     mov     byte ptr es:0, 4Dh	; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
SYSINIT:39D7		     mov     word ptr es:1, 0 ;	[es:ARENA.OWNER],arena_owner_system ; mark as free
SYSINIT:39DE		     sub     dx, 2	     ; DX = size of UMB	to be linked in	paras
SYSINIT:39DE					     ; make room for arena at start & end of new block
SYSINIT:39E1		     mov     es:3, dx	     ; [es:ARENA.SIZE],dx
SYSINIT:39E6		     add     bx, dx	     ; prepare arena at	end of new block
SYSINIT:39E8		     inc     bx
SYSINIT:39E9		     mov     es, bx	     ; es = arena at top of new	block
SYSINIT:39EB		     inc     bx		     ; bx = top	of new block
SYSINIT:39EC		     sub     ax, bx	     ; ax contains arena just above this block
SYSINIT:39EC					     ; result: ax = size of used block
SYSINIT:39EE		     mov     byte ptr es:0, 4Dh	; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
SYSINIT:39F4		     mov     word ptr es:1, 8 ;	[es:ARENA.OWNER],8 ; mark as system owned
SYSINIT:39FB		     mov     es:3, ax	     ; [es:ARENA.SIZE],ax
SYSINIT:39FF		     mov     word ptr es:8, 4353h ; [es:ARENA.NAME],'SC'
SYSINIT:3A06		     jmp     short ui_done
SYSINIT:3A08 ; ---------------------------------------------------------------------------
SYSINIT:3A08
SYSINIT:3A08 ui_append:				     ; ...
SYSINIT:3A08		     add     ax, es:3	     ; es = arena of last block
SYSINIT:3A08					     ; [es:ARENA.SIZE] ; ax=top	of last	block-1	para
SYSINIT:3A0D		     sub     word ptr es:3, 1 ;	reserve	space on top of	this
SYSINIT:3A0D					     ; block for the next arena.
SYSINIT:3A13		     mov     byte ptr es:0, 4Dh	; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
SYSINIT:3A19		     mov     cx, ax	     ; cx = top	of prev	block-1
SYSINIT:3A1B		     inc     ax
SYSINIT:3A1C		     sub     ax, bx	     ; ax = top	of prev	block -	seg. addr of new block
SYSINIT:3A1E		     neg     ax
SYSINIT:3A20		     mov     es, cx	     ; ds = arena of unused block
SYSINIT:3A22		     mov     byte ptr es:0, 4Dh	; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
SYSINIT:3A28		     mov     word ptr es:1, 8 ;	[es:ARENA.OWNER],8 ; mark as system owned
SYSINIT:3A2F		     mov     es:3, ax	     ; mov [es:ARENA.SIZE],ax
SYSINIT:3A33		     mov     word ptr es:8, 4353h ; mov	word [es:ARENA.NAME],'SC'
SYSINIT:3A3A		     mov     es, bx	     ; prepare the arena at start of new block
SYSINIT:3A3C		     mov     byte ptr es:0, 5Ah	; 'Z' ; [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:3A42		     mov     word ptr es:1, 0 ;	[es:ARENA.OWNER],arena_owner_system
SYSINIT:3A42					     ; mark as free
SYSINIT:3A49		     dec     dx		     ; make room for arena
SYSINIT:3A4A		     mov     es:3, dx	     ; mov [es:ARENA.SIZE],dx
SYSINIT:3A4F
SYSINIT:3A4F ui_done:				     ; ...
SYSINIT:3A4F		     pop     ds
SYSINIT:3A50		     retn
SYSINIT:3A50 umb_insert	     endp
SYSINIT:3A50
SYSINIT:3A51
SYSINIT:3A51 ; =============== S U B R O U T I N E =======================================
SYSINIT:3A51
SYSINIT:3A51
SYSINIT:3A51 umb_coalesce    proc near		     ; ...
SYSINIT:3A51		     xor     di, di	     ; Combine free blocks ahead with current block
SYSINIT:3A53		     mov     es, cs:DevDOSData
SYSINIT:3A58		     mov     es, word ptr es:8Ch ; [es:UMB_ARENA] ; es = UMB_HEAD
SYSINIT:3A5D
SYSINIT:3A5D uc_nextfree:			     ; ...
SYSINIT:3A5D		     mov     ax, es
SYSINIT:3A5F		     mov     ds, ax
SYSINIT:3A61		     cmp     es:1, di	     ; [es:ARENA.OWNER],di
SYSINIT:3A61					     ; Q: is current arena free
SYSINIT:3A66		     jz	     short uc_again  ; Y: try to coalesce with next block
SYSINIT:3A66					     ; N: get next arena
SYSINIT:3A68		     call    get_next	     ; es, ax =	next arena
SYSINIT:3A6B		     jb	     short uc_done
SYSINIT:3A6D		     jmp     short uc_nextfree
SYSINIT:3A6F ; ---------------------------------------------------------------------------
SYSINIT:3A6F
SYSINIT:3A6F uc_again:				     ; ...
SYSINIT:3A6F		     call    get_next	     ; es, ax =	next arena
SYSINIT:3A72		     jb	     short uc_done
SYSINIT:3A74		     cmp     es:1, di	     ; [es:ARENA.OWNER],di
SYSINIT:3A74					     ; Q: is arena free
SYSINIT:3A79		     jnz     short uc_nextfree ; N: get	next free arena
SYSINIT:3A79					     ; Y: coalesce
SYSINIT:3A7B		     mov     cx, es:3	     ; [es:ARENA.SIZE]
SYSINIT:3A7B					     ; cx = next block size
SYSINIT:3A80		     inc     cx		     ; cx = cx + 1 (for	header size)
SYSINIT:3A81		     add     ds:3, cx	     ; [ARENA.SIZE],cx
SYSINIT:3A81					     ; current size = current size + cx
SYSINIT:3A85		     mov     cl, es:[di]     ; move up signature
SYSINIT:3A88		     mov     [di], cl
SYSINIT:3A8A		     jmp     short uc_again  ; try again
SYSINIT:3A8C ; ---------------------------------------------------------------------------
SYSINIT:3A8C
SYSINIT:3A8C uc_done:				     ; ...
SYSINIT:3A8C		     retn
SYSINIT:3A8C umb_coalesce    endp
SYSINIT:3A8C
SYSINIT:3A8D
SYSINIT:3A8D ; =============== S U B R O U T I N E =======================================
SYSINIT:3A8D
SYSINIT:3A8D
SYSINIT:3A8D get_next	     proc near		     ; ...
SYSINIT:3A8D		     cmp     byte ptr ds:0, 5Ah	; 'Z' ; Find Next item in Arena
SYSINIT:3A8D					     ; cmp byte	[ARENA.SIGNATURE],arena_signature_end
SYSINIT:3A92		     jz	     short gn_err
SYSINIT:3A94		     mov     ax, ds	     ; ax = current block
SYSINIT:3A96		     add     ax, ds:3	     ; add ax,[ARENA.SIZE]
SYSINIT:3A96					     ; ax = ax + current block length
SYSINIT:3A9A		     inc     ax		     ; remember	that header!
SYSINIT:3A9B		     mov     es, ax
SYSINIT:3A9D		     clc
SYSINIT:3A9E		     retn
SYSINIT:3A9F ; ---------------------------------------------------------------------------
SYSINIT:3A9F
SYSINIT:3A9F gn_err:				     ; ...
SYSINIT:3A9F		     stc
SYSINIT:3AA0		     retn
SYSINIT:3AA0 get_next	     endp
SYSINIT:3AA0
SYSINIT:3AA1
SYSINIT:3AA1 ; =============== S U B R O U T I N E =======================================
SYSINIT:3AA1
SYSINIT:3AA1
SYSINIT:3AA1 LinkFirstUMB    proc near		     ; ...
SYSINIT:3AA1		     call    umb_allocate
SYSINIT:3AA4		     jb	     short lfu_er
SYSINIT:3AA6		     int     12h	     ; MEMORY SIZE -
SYSINIT:3AA6					     ; Return: AX = number of contiguous 1K blocks of memory
SYSINIT:3AA8		     mov     cl, 6
SYSINIT:3AAA		     shl     ax, cl	     ; ax = size in paragraphs
SYSINIT:3AAC		     mov     cx, ax
SYSINIT:3AAE		     sub     ax, bx	     ; bx = segment of allocated UMB
SYSINIT:3AAE					     ; ax = - size of unused block
SYSINIT:3AB0		     neg     ax
SYSINIT:3AB2		     sub     cx, 1	     ; cx = first umb_arena
SYSINIT:3AB5		     mov     es, cx	     ; es = first umb_arena
SYSINIT:3AB7		     mov     byte ptr es:0, 4Dh	; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
SYSINIT:3ABD		     mov     word ptr es:1, 8 ;	[es:ARENA.OWNER],8 ; mark as system owned
SYSINIT:3AC4		     mov     es:3, ax	     ; mov [es:ARENA.SIZE],ax
SYSINIT:3AC8		     mov     word ptr es:8, 4353h ; [es:ARENA.NAME],'SC'
SYSINIT:3ACF		     mov     es, bx	     ; put in the arena	for the	first UMB
SYSINIT:3ACF					     ; es has first free umb seg
SYSINIT:3AD1		     mov     byte ptr es:0, 5Ah	; 'Z' ; [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:3AD7		     mov     word ptr es:1, 0 ;	es:ARENA.OWNER],arena_owner_system
SYSINIT:3AD7					     ; mark as free
SYSINIT:3ADE		     dec     dx		     ; dx = size of UMB
SYSINIT:3ADE					     ; make room for arena
SYSINIT:3ADF		     mov     es:3, dx	     ; [es:ARENA.SIZE],dx
SYSINIT:3AE4		     mov     es, cs:DevDOSData
SYSINIT:3AE9		     mov     di, 8Ch	     ; UMB_ARENA
SYSINIT:3AEC		     mov     es:[di], cx     ; initialize umb_head in DOS data segment
SYSINIT:3AEC					     ; with the	arena just below Top of	Memory
SYSINIT:3AEC					     ;
SYSINIT:3AEC					     ; we must now scan	the arena chain	and
SYSINIT:3AEC					     ; update the size of the last arena
SYSINIT:3AEF		     mov     di, 24h	     ; DOS_ARENA
SYSINIT:3AF2		     mov     es, word ptr es:[di] ; es = start arena
SYSINIT:3AF5		     xor     di, di
SYSINIT:3AF7
SYSINIT:3AF7 scannext:				     ; ...
SYSINIT:3AF7		     cmp     byte ptr es:[di], 5Ah ; 'Z' ; arena_signature_end
SYSINIT:3AFB		     jz	     short got_last
SYSINIT:3AFD		     mov     ax, es
SYSINIT:3AFF		     add     ax, es:3	     ; [es:ARENA.SIZE]
SYSINIT:3B04		     inc     ax
SYSINIT:3B05		     mov     es, ax
SYSINIT:3B07		     jmp     short scannext
SYSINIT:3B09 ; ---------------------------------------------------------------------------
SYSINIT:3B09
SYSINIT:3B09 got_last:				     ; ...
SYSINIT:3B09		     sub     word ptr es:3, 1 ;	sub word [es:ARENA.SIZE],1
SYSINIT:3B0F		     mov     byte ptr es:0, 4Dh	; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
SYSINIT:3B15		     clc
SYSINIT:3B16		     retn
SYSINIT:3B17 ; ---------------------------------------------------------------------------
SYSINIT:3B17
SYSINIT:3B17 lfu_er:				     ; ...
SYSINIT:3B17		     stc
SYSINIT:3B18		     retn
SYSINIT:3B18 LinkFirstUMB    endp
SYSINIT:3B18
SYSINIT:3B19
SYSINIT:3B19 ; =============== S U B R O U T I N E =======================================
SYSINIT:3B19
SYSINIT:3B19
SYSINIT:3B19 ShrinkUMB	     proc near		     ; ...
SYSINIT:3B19		     cmp     cs:DevUMBAddr, 0 ;	Shrinks	the current UMB	in use,
SYSINIT:3B19					     ; so that the unused portions of the UMB
SYSINIT:3B19					     ; is given	back to	the DOS	free mem pool
SYSINIT:3B1F		     jz	     short su_exit
SYSINIT:3B21		     push    es
SYSINIT:3B22		     push    bx
SYSINIT:3B23		     mov     bx, cs:DevUMBFree
SYSINIT:3B28		     sub     bx, cs:DevUMBAddr
SYSINIT:3B2D		     mov     es, cs:DevUMBAddr
SYSINIT:3B32		     mov     ax, 4A00h
SYSINIT:3B35		     int     21h	     ; DOS - 2+	- ADJUST MEMORY	BLOCK SIZE (SETBLOCK)
SYSINIT:3B35					     ; ES = segment address of block to	change
SYSINIT:3B35					     ; BX = new	size in	paragraphs
SYSINIT:3B37		     mov     ax, es
SYSINIT:3B39		     dec     ax
SYSINIT:3B3A		     mov     es, ax
SYSINIT:3B3C		     assume es:nothing
SYSINIT:3B3C		     mov     word ptr es:1, 8 ;	[es:ARENA.OWNER]
SYSINIT:3B43		     pop     bx
SYSINIT:3B44		     pop     es
SYSINIT:3B45		     assume es:nothing
SYSINIT:3B45
SYSINIT:3B45 su_exit:				     ; ...
SYSINIT:3B45		     retn
SYSINIT:3B45 ShrinkUMB	     endp
SYSINIT:3B45
SYSINIT:3B46
SYSINIT:3B46 ; =============== S U B R O U T I N E =======================================
SYSINIT:3B46
SYSINIT:3B46
SYSINIT:3B46 UnlinkUMB	     proc near		     ; ...
SYSINIT:3B46		     push    ds		     ; Unlinks the UMBs	from the DOS arena chain
SYSINIT:3B47		     push    es
SYSINIT:3B48		     cmp     cs:FirstUMBLinked,	0
SYSINIT:3B4E		     jz	     short ulu_x     ; nothing to unlink
SYSINIT:3B50		     mov     es, cs:DevDOSData ; get DOS data seg
SYSINIT:3B55		     mov     ds, word ptr es:24h ; [es:DOS_ARENA]
SYSINIT:3B5A		     mov     di, es:8Ch	     ; [es:UMB_ARENA]
SYSINIT:3B5F
SYSINIT:3B5F ulu_next:				     ; ...
SYSINIT:3B5F		     call    get_next
SYSINIT:3B62		     jb	     short ulu_x
SYSINIT:3B64		     cmp     di, ax	     ; is the next one UMB ?
SYSINIT:3B66		     jz	     short ulu_found
SYSINIT:3B68		     mov     ds, ax
SYSINIT:3B6A		     jmp     short ulu_next
SYSINIT:3B6C ; ---------------------------------------------------------------------------
SYSINIT:3B6C
SYSINIT:3B6C ulu_found:				     ; ...
SYSINIT:3B6C		     mov     byte ptr ds:0, 5Ah	; 'Z' ; [ARENA.SIGNATURE],arena_signature_end
SYSINIT:3B71
SYSINIT:3B71 ulu_x:				     ; ...
SYSINIT:3B71		     pop     es
SYSINIT:3B72		     pop     ds
SYSINIT:3B73		     retn
SYSINIT:3B73 UnlinkUMB	     endp
SYSINIT:3B73
SYSINIT:3B73 ; ---------------------------------------------------------------------------
SYSINIT:3B74 MagicDDName     db	'\DBLSPACE.BIN',0    ; ...
SYSINIT:3B82
SYSINIT:3B82 ; =============== S U B R O U T I N E =======================================
SYSINIT:3B82
SYSINIT:3B82
SYSINIT:3B82 MagicPreload    proc near		     ; ...
SYSINIT:3B82		     mov     cs:DeviceHi, 0  ; not to be loaded	in UMB
SYSINIT:3B88		     mov     cs:DevSizeOption, 0
SYSINIT:3B8F		     push    cs
SYSINIT:3B90		     pop     ds
SYSINIT:3B91		     assume ds:SYSINIT
SYSINIT:3B91		     mov     si, offset	MagicDDName ; "\\DBLSPACE.BIN"
SYSINIT:3B94		     mov     word ptr cs:bpb_addr, si ;	pass the command line to the device
SYSINIT:3B99		     mov     word ptr cs:bpb_addr+2, cs
SYSINIT:3B9E		     mov     word ptr cs:DevCmdLine, si	; save it for error reporting
SYSINIT:3BA3		     mov     word ptr cs:DevCmdLine+2, cs
SYSINIT:3BA8		     call    round	     ; normalize memhi:memlo (first free memory)
SYSINIT:3BAB		     push    cs
SYSINIT:3BAC		     pop     es
SYSINIT:3BAD		     assume es:SYSINIT
SYSINIT:3BAD		     call    SizeDevice	     ; get size	of device file into DevSize
SYSINIT:3BB0		     mov     ax, 40h	     ; SYSPRE_BADFILE_ERROR
SYSINIT:3BB3		     jb	     short pre_exit1
SYSINIT:3BB5		     mov     cs:ConvLoad, 1  ; Doesn't matter if DeviceHi==0
SYSINIT:3BBB		     call    InitDevLoad     ; set up sub-arena, DevLoadAddr,
SYSINIT:3BBB					     ; DevLoadEnd, and DevEntry
SYSINIT:3BBB					     ; gets arena name from bpb_addr
SYSINIT:3BBE		     mov     ax, cs:DevLoadAddr
SYSINIT:3BC2		     add     ax, cs:DevSize  ; calculate seg after DD load
SYSINIT:3BC7		     jb	     short pre_exit_memory_err1	; choke	if overflows address space
SYSINIT:3BC9		     cmp     cs:DevLoadEnd, ax ; does it overflow available space?
SYSINIT:3BCE		     jnb     short _LoadDev  ; we're golden if not
SYSINIT:3BD0
SYSINIT:3BD0 pre_exit_memory_err1:		     ; ...
SYSINIT:3BD0		     mov     ax, 42h	     ; SYSPRE_MEMORY_ERROR
SYSINIT:3BD3
SYSINIT:3BD3 pre_exit1:				     ; ...
SYSINIT:3BD3		     jmp     pre_exit
SYSINIT:3BD6 ; ---------------------------------------------------------------------------
SYSINIT:3BD6
SYSINIT:3BD6 _LoadDev:				     ; ...
SYSINIT:3BD6		     lds     dx, cs:DevCmdLine ; get the load file name
SYSINIT:3BDB		     assume ds:nothing
SYSINIT:3BDB		     call    ExecDev	     ; load device driver using	exec call
SYSINIT:3BDE		     mov     ax, 41h	     ; SYSPRE_EXEC_FAIL_ERROR
SYSINIT:3BE1		     jb	     short pre_exit1
SYSINIT:3BE3		     mov     cs:break_addr, 0 ;	pass the limit to the DD
SYSINIT:3BEA		     mov     ax, cs:DevLoadEnd
SYSINIT:3BEE		     mov     cs:break_addr+2, ax
SYSINIT:3BF2		     les     bx, cs:DevEntry ; point to	the Magic DD header
SYSINIT:3BF7		     assume es:nothing
SYSINIT:3BF7		     cmp     word ptr es:[bx+12h], 2E2Ch ; '.,' ; is it our stamp?
SYSINIT:3BF7					     ; (',.' in NASM syntax)
SYSINIT:3BFD		     mov     ax, 46h	     ; SYSPRE_NOT_MAGIC
SYSINIT:3C00		     jnz     short pre_exit3 ; abort if	not MagicDrv!
SYSINIT:3C02		     mov     word ptr cs:Magicbackdoor,	14h ; save the backdoor	entry
SYSINIT:3C09		     mov     word ptr cs:Magicbackdoor+2, es
SYSINIT:3C0E		     mov     al, cs:drivenumber	; pass drive number to DBLSPACE	as if
SYSINIT:3C12		     mov     cs:devdrivenum, al	; it is	a normal block device driver
SYSINIT:3C16		     push    cs
SYSINIT:3C17		     pop     es		     ; calldev needs packet segment in es
SYSINIT:3C18		     assume es:SYSINIT
SYSINIT:3C18		     mov     bx, offset	packet
SYSINIT:3C1B		     mov     ax, 10	     ; DS_INTERNAL_REVISION
SYSINIT:3C1B					     ; tell it what revision we	expect
SYSINIT:3C1E		     call    cs:Magicbackdoor ;	first time call	is init	entry point
SYSINIT:3C1E					     ; with a standard device driver
SYSINIT:3C1E					     ; init packet at es:bx
SYSINIT:3C23		     jnb     short no_driver_version_fail
SYSINIT:3C25		     push    cs
SYSINIT:3C26		     pop     ds
SYSINIT:3C27		     assume ds:SYSINIT
SYSINIT:3C27		     mov     dx, offset	baddblspace ; "Wrong DBLSPACE.BIN version\r\n$"
SYSINIT:3C2A		     mov     ah, 9	     ; display the message
SYSINIT:3C2C		     int     21h	     ; DOS - PRINT STRING
SYSINIT:3C2C					     ; DS:DX ->	string terminated by "$"
SYSINIT:3C2E		     jmp     short fail_driver_load
SYSINIT:3C30 ; ---------------------------------------------------------------------------
SYSINIT:3C30
SYSINIT:3C30 no_driver_version_fail:		     ; ...
SYSINIT:3C30		     or	     ax, ax	     ; error code returned?
SYSINIT:3C32		     jz	     short magic_is_resident ; skip if no error
SYSINIT:3C34
SYSINIT:3C34 fail_driver_load:			     ; ...
SYSINIT:3C34		     mov     word ptr cs:Magicbackdoor,	offset NullBackdoor ;
SYSINIT:3C34					     ; point backdoor call back	to safe	far return
SYSINIT:3C3B		     mov     word ptr cs:Magicbackdoor+2, cs
SYSINIT:3C40		     mov     ax, 47h	     ; SYSPRE_DRIVER_FAILED ; error code
SYSINIT:3C43
SYSINIT:3C43 pre_exit3:				     ; ...
SYSINIT:3C43		     jmp     short pre_exit_2
SYSINIT:3C45 ; ---------------------------------------------------------------------------
SYSINIT:3C45
SYSINIT:3C45 magic_is_resident:			     ; ...
SYSINIT:3C45		     mov     ax, cs:break_addr
SYSINIT:3C49		     add     ax, 15
SYSINIT:3C4C		     rcr     ax, 1
SYSINIT:3C4E		     shr     ax, 1
SYSINIT:3C50		     shr     ax, 1
SYSINIT:3C52		     shr     ax, 1	     ; convert to paragraphs
SYSINIT:3C54		     add     ax, cs:break_addr+2 ; add to terminate segment
SYSINIT:3C59		     mov     word ptr cs:DevBrkAddr+2, ax
SYSINIT:3C5D		     mov     word ptr cs:DevBrkAddr, 0 ; store normalized end here
SYSINIT:3C64		     mov     bx, 4	     ; inquire how many	paragraphs it wants
SYSINIT:3C67		     call    cs:Magicbackdoor
SYSINIT:3C6C		     mov     bx, cs:ALLOCLIM ; get top of free memory
SYSINIT:3C71		     sub     bx, ax	     ; see how much we'll lower it
SYSINIT:3C73		     cmp     bx, word ptr cs:DevBrkAddr+2 ; is there that much room free?
SYSINIT:3C78		     jb	     short cant_move_driver ; if not, just leave it low
SYSINIT:3C7A		     sub     cs:ALLOCLIM, ax ; allocate	space!
SYSINIT:3C7F		     mov     es, cs:ALLOCLIM
SYSINIT:3C84		     assume es:nothing
SYSINIT:3C84		     mov     bx, 6	     ; tell the	driver to move itself
SYSINIT:3C87		     call    cs:Magicbackdoor
SYSINIT:3C8C		     mov     word ptr cs:DevBrkAddr+2, ax ; save end of	low stub
SYSINIT:3C90
SYSINIT:3C90 cant_move_driver:			     ; ...
SYSINIT:3C90		     mov     ax, word ptr cs:DevBrkAddr+2 ; get	terminate segment
SYSINIT:3C94		     cmp     ax, cs:DevLoadEnd ; terminate size	TOO big?
SYSINIT:3C99		     mov     ax, 42h	     ; SYSPRE_MEMORY_ERROR
SYSINIT:3C9C		     ja	     short pre_exit2 ; error out if so
SYSINIT:3C9E		     lds     si, cs:DevEntry ; set ds:si to header
SYSINIT:3CA3		     assume ds:nothing
SYSINIT:3CA3		     les     di, cs:DOSINFO  ; es:di point to dos info
SYSINIT:3CA8		     jmp     short _isblock
SYSINIT:3CAA ; ---------------------------------------------------------------------------
SYSINIT:3CAA
SYSINIT:3CAA pre_exit_memory_err:		     ; ...
SYSINIT:3CAA		     mov     ax, 42h	     ; SYSPRE_MEMORY_ERROR
SYSINIT:3CAD
SYSINIT:3CAD pre_exit_2:			     ; ...
SYSINIT:3CAD		     jmp     pre_exit
SYSINIT:3CB0 ; ---------------------------------------------------------------------------
SYSINIT:3CB0
SYSINIT:3CB0 _isblock:				     ; ...
SYSINIT:3CB0		     mov     al, cs:unitcount ;	if no units found, erase the device
SYSINIT:3CB4		     or	     al, al
SYSINIT:3CB6		     jz	     short pre_exit_no_units_err
SYSINIT:3CB8		     mov     [si+10], al     ; mov [si+SYSDEV.NAME],al
SYSINIT:3CB8					     ; number of units in name field
SYSINIT:3CB8					     ; device drivers are *supposed*
SYSINIT:3CB8					     ; to do this for themselves.
SYSINIT:3CBB		     xor     ah, ah
SYSINIT:3CBD		     mov     cx, ax
SYSINIT:3CBF		     mov     dh, ah
SYSINIT:3CC1		     mov     dl, es:[di+20h] ; [es:di+SYSI_NUMIO]
SYSINIT:3CC1					     ; get number of devices
SYSINIT:3CC5		     mov     ah, dl
SYSINIT:3CC7		     add     ah, al	     ; check for too many devices
SYSINIT:3CC9		     cmp     ah, 26	     ; 'A' - 'Z' is 26 devices
SYSINIT:3CCC		     ja	     short pre_exit_too_many_units_err
SYSINIT:3CCE		     call    DevSetBreak
SYSINIT:3CD1		     jb	     short pre_exit_memory_err
SYSINIT:3CD3
SYSINIT:3CD3 _ok_block:				     ; [es:di+SYSI_NUMIO] ; update the amount
SYSINIT:3CD3		     add     es:[di+20h], al
SYSINIT:3CD7		     lds     bx, cs:bpb_addr ; point to	bpb array (*)
SYSINIT:3CDC
SYSINIT:3CDC _perunit:				     ; ...
SYSINIT:3CDC		     les     bp, cs:DOSINFO
SYSINIT:3CE1		     les     bp, es:[bp+0]   ; es:[bp.sysi_dpb]
SYSINIT:3CE1					     ; get first dpb
SYSINIT:3CE1					     ; [es:bp+SysInitvars.SYSI_DPB] ; [es:bp+0]
SYSINIT:3CE5
SYSINIT:3CE5 _scandpb:				     ; ...
SYSINIT:3CE5		     cmp     word ptr es:[bp+19h], 0FFFFh ; -1 ; es:[bp.dpb_next_dpb]
SYSINIT:3CEA		     jz	     short _foundpb
SYSINIT:3CEC		     les     bp, es:[bp+19h] ; les bp,es:[bp.dpb_next_dpb]
SYSINIT:3CEC					     ; [es:bp+DPB.NEXT_DPB]
SYSINIT:3CF0		     jmp     short _scandpb
SYSINIT:3CF2 ; ---------------------------------------------------------------------------
SYSINIT:3CF2
SYSINIT:3CF2 pre_exit_too_many_units_err:	     ; ...
SYSINIT:3CF2		     mov     ax, 44h	     ; SYSPRE_TOO_MANY_UNITS_ERROR
SYSINIT:3CF5		     jmp     short pre_exit2
SYSINIT:3CF7 ; ---------------------------------------------------------------------------
SYSINIT:3CF7
SYSINIT:3CF7 pre_exit_no_units_err:		     ; ...
SYSINIT:3CF7		     mov     ax, 43h	     ; SYSPRE_NO_UNITS_ERROR
SYSINIT:3CFA
SYSINIT:3CFA pre_exit2:				     ; ...
SYSINIT:3CFA		     jmp     pre_exit
SYSINIT:3CFD ; ---------------------------------------------------------------------------
SYSINIT:3CFD
SYSINIT:3CFD _foundpb:				     ; ...
SYSINIT:3CFD		     mov     ax, word ptr cs:DevBrkAddr
SYSINIT:3D01		     mov     es:[bp+19h], ax ; es:[bp.dpb_next_dpb] ; DPB.NEXT_DPB
SYSINIT:3D05		     mov     ax, word ptr cs:DevBrkAddr+2
SYSINIT:3D09		     mov     es:[bp+1Bh], ax ; es:[bp.dpb_next_dpb+2] ;	DPB.NEXT_DPB+2
SYSINIT:3D0D		     les     bp, cs:DevBrkAddr
SYSINIT:3D12		     add     word ptr cs:DevBrkAddr, 33	; DPBSIZ ; 21h
SYSINIT:3D18		     call    RoundBreakAddr
SYSINIT:3D1B		     mov     word ptr es:[bp+19h], 0FFFFh ; -1
SYSINIT:3D21		     mov     byte ptr es:[bp+18h], 0FFh	; es:[bp.dpb_first_access],-1
SYSINIT:3D21					     ; DPB.FIRST_ACCESS
SYSINIT:3D26		     mov     si, [bx]	     ; ds:si points to bpb (*)
SYSINIT:3D26					     ; (mov si,[bx] ..and then.. add bx,2)
SYSINIT:3D26					     ; Note: If	unit count > 1,	bx points to a BPB in the BPB array,
SYSINIT:3D26					     ; the array address is in [bpb_addr] (*) -I don't understand how and
SYSINIT:3D26					     ; what for	but DBLSPACE.BIN code may set this- (bx=bx+2 for next)
SYSINIT:3D26					     ; Erdogan Tan - 07/07/2023
SYSINIT:3D28		     inc     bx
SYSINIT:3D29		     inc     bx		     ; point to	next BPB
SYSINIT:3D29					     ; (in the BPB array) (*) -add bx,2-
SYSINIT:3D2A		     mov     es:[bp+0],	dx   ; mov word	ptr es:[bp.dpb_drive],dx
SYSINIT:3D2A					     ; [es:bp+DPB.DRIVE],dl ; [es:bp+DPB.UNIT],dh
SYSINIT:3D2E		     mov     ah, 53h	     ; SETDPB ;	hidden system call
SYSINIT:3D30		     int     21h	     ; DOS - 2+	internal - TRANSLATE BIOS PARAMETER BLOCK
SYSINIT:3D30					     ; DS:SI ->	BPB (BIOS Parameter Block)
SYSINIT:3D30					     ; ES:BP ->	buffer for DOS Drive Parameter Block
SYSINIT:3D32		     mov     ax, es:[bp+2]   ; es:[bp.dpb_sector_size]	; [es:bp+DPB.SECTOR_SIZE]
SYSINIT:3D36		     push    es
SYSINIT:3D37		     les     di, cs:DOSINFO
SYSINIT:3D3C		     cmp     ax, es:[di+10h] ; es:[di.sysi_maxsec] ; [es:di+SysInitvars.SYSI_MAXSEC]
SYSINIT:3D40		     pop     es
SYSINIT:3D41		     mov     ax, 45h	     ; SYSPRE_BAD_SECTOR_SIZE_ERROR
SYSINIT:3D44		     ja	     short pre_exit
SYSINIT:3D46		     push    ds
SYSINIT:3D47		     lds     ax, cs:DevEntry
SYSINIT:3D4C		     mov     es:[bp+13h], ax ; [es:bp+DPB.DRIVER_ADDR]
SYSINIT:3D50		     mov     word ptr es:[bp+15h], ds ;	[es:bp+DPB.DRIVER_ADDR+2]
SYSINIT:3D54		     pop     ds
SYSINIT:3D55		     inc     dl		     ; increment drive number
SYSINIT:3D57		     inc     dh		     ; increment unix number
SYSINIT:3D59		     loop    _perunit
SYSINIT:3D5B		     push    cs
SYSINIT:3D5C		     pop     ds
SYSINIT:3D5D		     assume ds:SYSINIT
SYSINIT:3D5D		     call    TempCDS	     ; set cds for new drives
SYSINIT:3D60		     les     di, cs:DOSINFO  ; es:di = dos table (SysInitVars)
SYSINIT:3D65		     mov     cx, es:[di+22h] ; [es:di+SYSI_DEV]	; dx:cx	= head of list
SYSINIT:3D69		     mov     dx, es:[di+24h] ; [es:di+SYSI_DEV+2]
SYSINIT:3D6D		     lds     si, cs:DevEntry ; ds:si = device location
SYSINIT:3D72		     assume ds:nothing
SYSINIT:3D72		     mov     es:[di+22h], si ; [es:di+SYSI_DEV]	; set head of list in dos
SYSINIT:3D76		     mov     word ptr es:[di+24h], ds ;	[es:di+SYSI_DEV+2]
SYSINIT:3D7A		     mov     [si], cx	     ; link in the driver
SYSINIT:3D7C		     mov     [si+2], dx
SYSINIT:3D7F		     call    DevBreak
SYSINIT:3D82		     mov     cx, word ptr cs:DevBrkAddr+2 ; pass it a work buffer
SYSINIT:3D87		     mov     dx, cs:ALLOCLIM ; address in cx (segment)
SYSINIT:3D8C		     sub     dx, cx	     ; for len dx (paragraphs)
SYSINIT:3D8E		     mov     ax, 5500h	     ; we're shuffle aware, but don't move
SYSINIT:3D8E					     ; any drives at this point.
SYSINIT:3D91		     mov     bx, 2	     ; switch what we can now
SYSINIT:3D94		     call    cs:Magicbackdoor
SYSINIT:3D99		     xor     ax, ax	     ; no errors!
SYSINIT:3D99					     ; zf=1
SYSINIT:3D9B
SYSINIT:3D9B pre_exit:				     ; ...
SYSINIT:3D9B		     or	     ax, ax	     ; reset zero flag if error
SYSINIT:3D9D		     retn
SYSINIT:3D9D MagicPreload    endp
SYSINIT:3D9D
SYSINIT:3D9E
SYSINIT:3D9E ; =============== S U B R O U T I N E =======================================
SYSINIT:3D9E
SYSINIT:3D9E
SYSINIT:3D9E MagicPostload   proc near		     ; ...
SYSINIT:3D9E		     mov     ax, 4A11h	     ; multMagicdrv
SYSINIT:3D9E					     ; DBLSPACE.BIN - "GetVersion" -
SYSINIT:3D9E					     ;		     INSTALLATION CHECK
SYSINIT:3D9E					     ; (BX = 0)
SYSINIT:3DA1		     mov     bx, 0	     ; MD_VERSION
SYSINIT:3DA4		     int     2Fh
SYSINIT:3DA6		     or	     ax, ax	     ; ax = 0 (successful, zf=1)
SYSINIT:3DA6					     ; is it there?
SYSINIT:3DA8		     jnz     short no_magic  ; done if not
SYSINIT:3DAA		     test    dx, 8000h	     ; is it already permanent?
SYSINIT:3DAE		     jz	     short no_magic  ; no, done	if so (not in final position)
SYSINIT:3DB0		     mov     bx, 0FFFFh	     ; -1 ; how	much space does	it want?
SYSINIT:3DB3		     mov     ax, 4A11h	     ; multMagicdrv
SYSINIT:3DB3					     ; DBLSPACE.BIN - GET RELOCATION SIZE
SYSINIT:3DB6		     int     2Fh	     ; get paragraphs into ax
SYSINIT:3DB8		     add     ax, 2	     ; extra 2 paragraphs for the stub
SYSINIT:3DB8					     ; add ax,((tiny_stub_end-tiny_stub_start)+15)/16
SYSINIT:3DB8					     ; (18+15)/16 = 2
SYSINIT:3DBB		     mov     cs:DevSize, ax  ; store that (**)
SYSINIT:3DBF		     mov     cs:DeviceHi, 0  ; not to be loaded	in UMB
SYSINIT:3DC5		     mov     cs:DevSizeOption, 0
SYSINIT:3DCC		     mov     cs:ConvLoad, 1  ; conventional (memory) load
SYSINIT:3DD2		     push    cs
SYSINIT:3DD3		     pop     ds
SYSINIT:3DD4		     assume ds:SYSINIT
SYSINIT:3DD4		     mov     word ptr cs:bpb_addr, offset MagicDDName ;	"\\DBLSPACE.BIN"
SYSINIT:3DDB		     mov     word ptr cs:bpb_addr+2, cs	; pass name so that
SYSINIT:3DDB					     ; arena header can	be set
SYSINIT:3DE0		     call    round	     ; normalize memhi:memlo
SYSINIT:3DE3		     call    InitDevLoad     ; set up sub-arena, DevLoadAddr,
SYSINIT:3DE3					     ; DevLoadEnd, and DevEntry
SYSINIT:3DE3					     ; gets arena name from bpb_addr
SYSINIT:3DE6		     mov     ax, cs:DevLoadAddr	; (**) (InitDevload sets this)
SYSINIT:3DEA		     add     ax, cs:DevSize  ; calculate seg after DD load
SYSINIT:3DEF		     mov     word ptr cs:DevBrkAddr+2, ax ; save as ending address!
SYSINIT:3DF3		     mov     word ptr cs:DevBrkAddr, 0
SYSINIT:3DFA		     mov     es, cs:DevLoadAddr
SYSINIT:3DFF		     mov     si, offset	tiny_stub_start
SYSINIT:3E02		     xor     di, di	     ; move a little header in place
SYSINIT:3E02					     ; so that this looks to the mem command
SYSINIT:3E02					     ; like a legitimate driver	load
SYSINIT:3E04		     mov     cx, 18	     ; (tiny_stub_end-tiny_stub_start)
SYSINIT:3E07		     rep movsb		     ; move it!
SYSINIT:3E09		     mov     ax, es	     ; advance es appropriately
SYSINIT:3E0B		     add     ax, 2	     ; add ax,((tiny_stub_end-tiny_stub_start)+15)/16
SYSINIT:3E0E		     mov     es, ax
SYSINIT:3E10		     assume es:BIOSDATA
SYSINIT:3E10		     mov     ax, 4A11h	     ; multMagicdrv
SYSINIT:3E13		     mov     bx, 0FFFEh	     ; -2 ; final placement!
SYSINIT:3E16		     int     2Fh	     ; DBLSPACE.BIN - RELOCATE
SYSINIT:3E16					     ; es = segment to which to	relocate DBLSPACE.BIN
SYSINIT:3E18		     call    DevSetBreak     ; go ahead	and alloc mem for device
SYSINIT:3E1B		     call    DevBreak
SYSINIT:3E1E
SYSINIT:3E1E no_magic:				     ; ...
SYSINIT:3E1E		     retn
SYSINIT:3E1E MagicPostload   endp
SYSINIT:3E1E
SYSINIT:3E1F
SYSINIT:3E1F ; =============== S U B R O U T I N E =======================================
SYSINIT:3E1F
SYSINIT:3E1F
SYSINIT:3E1F MagicSetCdss    proc near		     ; ...
SYSINIT:3E1F		     mov     ax, 4A11h	     ; multMagicdrv
SYSINIT:3E1F					     ; DBLSPACE.BIN - "GetVersion" -
SYSINIT:3E1F					     ;		     INSTALLATION CHECK
SYSINIT:3E1F					     ; (BX = 0)
SYSINIT:3E22		     mov     bx, 0	     ; MD_VERSION
SYSINIT:3E25		     int     2Fh
SYSINIT:3E27		     or	     ax, ax	     ; ax = 0 (successful, zf=1)
SYSINIT:3E27					     ; is it there?
SYSINIT:3E29		     jnz     short magic_set_exit ; done if not
SYSINIT:3E2B		     mov     al, cl	     ; get first DblSpace drive	letter
SYSINIT:3E2D		     sub     al, 'A'         ; make it zero based.
SYSINIT:3E2F		     mov     dl, al	     ; and save	for drive testing loop
SYSINIT:3E31		     les     si, cs:DOSINFO  ; point to	DOS data area (SysInitVars)
SYSINIT:3E36		     assume es:nothing
SYSINIT:3E36		     les     si, es:[si+16h] ; les si,es:[si].sysi_cds ; fetch CDSs
SYSINIT:3E36					     ; [es:si+SYSI_CDS]
SYSINIT:3E3A		     mov     ah, 88	     ; curdirLen
SYSINIT:3E3C		     mul     ah		     ; find first DblSpace CDS
SYSINIT:3E3E		     add     si, ax	     ; cds pointer
SYSINIT:3E40		     mov     cl, ch	     ; get DblSpace drive count	into cx
SYSINIT:3E42		     xor     ch, ch
SYSINIT:3E44
SYSINIT:3E44 magic_set_cdss_1:			     ; ...
SYSINIT:3E44		     push    si
SYSINIT:3E45		     push    es
SYSINIT:3E46		     push    cx
SYSINIT:3E47		     push    dx
SYSINIT:3E48		     mov     ax, 4A11h	     ; multMagicdrv
SYSINIT:3E4B		     mov     bx, 1	     ; MD_DRIVE_MAP ; inquire drive map
SYSINIT:3E4E		     int     2Fh	     ; DBLSPACE.BIN - "GetDriveMapping"
SYSINIT:3E4E					     ; see if this is an unused	DblSpace drive
SYSINIT:3E50		     pop     dx
SYSINIT:3E51		     pop     cx
SYSINIT:3E52		     pop     es
SYSINIT:3E53		     pop     si
SYSINIT:3E54		     cmp     bl, dl	     ; if mapped to itself, it is vacant
SYSINIT:3E56		     jnz     short magic_set_cdss_2 ; skip if used
SYSINIT:3E58		     and     word ptr es:[si+43h], 0BFFFh ; reset the bit in flags (curdir_inuse bit)
SYSINIT:3E58					     ; [si+curdir_list.cdir_flags],~curdir_inuse ; word
SYSINIT:3E58					     ; (.. [si+1+curdir_list.cdir_flags],0BFh ;	byte)
SYSINIT:3E5E
SYSINIT:3E5E magic_set_cdss_2:			     ; ...
SYSINIT:3E5E		     add     si, 88	     ; curdirLen
SYSINIT:3E61		     inc     dl		     ; next drive
SYSINIT:3E63		     loop    magic_set_cdss_1
SYSINIT:3E65
SYSINIT:3E65 magic_set_exit:			     ; ...
SYSINIT:3E65		     retn
SYSINIT:3E65 MagicSetCdss    endp
SYSINIT:3E65
SYSINIT:3E65 ; ---------------------------------------------------------------------------
SYSINIT:3E66 tiny_stub_start dw	0FFFFh		     ; ...
SYSINIT:3E66					     ; phony device driver link
SYSINIT:3E68		     dw	0FFFFh		     ; dw -1, -1
SYSINIT:3E6A		     dw	8000h		     ; mark as character device	for MEM	display
SYSINIT:3E6C		     dw	2 dup(0)	     ; strat and irpt
SYSINIT:3E70		     db	'DBLSBIN$'           ; magic default load
SYSINIT:3E70					     ; (tiny_stub_end-tiny_stub_start =	18)
SYSINIT:3E78 insert_blank    db	0		     ; ...
SYSINIT:3E78					     ; tiny_stub_end equ $
SYSINIT:3E79
SYSINIT:3E79 ; =============== S U B R O U T I N E =======================================
SYSINIT:3E79
SYSINIT:3E79
SYSINIT:3E79 setparms	     proc near		     ; ...
SYSINIT:3E79		     push    ds
SYSINIT:3E7A		     push    ax
SYSINIT:3E7B		     push    bx
SYSINIT:3E7C		     push    cx
SYSINIT:3E7D		     push    dx
SYSINIT:3E7E		     push    cs
SYSINIT:3E7F		     pop     ds
SYSINIT:3E80		     xor     bx, bx
SYSINIT:3E82		     mov     bl, drive
SYSINIT:3E86		     inc     bl		     ; get it correct for ioctl	call
SYSINIT:3E86					     ; (1=A,2=A...)
SYSINIT:3E88		     mov     dx, offset	devp_specialfunc ; offset deviceparameters
SYSINIT:3E8B		     mov     ah, 44h	     ; IOCTL
SYSINIT:3E8D		     mov     al, 0Dh	     ; GENERIC_IOCTL
SYSINIT:3E8F		     mov     ch, 8	     ; RAWIO
SYSINIT:3E91		     mov     cl, 40h	     ; SET_DEVICE_PARAMETERS
SYSINIT:3E93		     int     21h	     ; DOS - 2+	- IOCTL	-
SYSINIT:3E95		     mov     ax, 70h	     ; DOSBIODATASEG ; BIOSDATA	segment
SYSINIT:3E98		     mov     ds, ax
SYSINIT:3E9A		     assume ds:nothing
SYSINIT:3E9A		     test    cs:switches, 4  ; flagec35
SYSINIT:3EA1		     jz	     short not_ec35
SYSINIT:3EA3		     mov     cl, cs:drive    ; which drive was this for?
SYSINIT:3EA8		     mov     al, 1	     ; assume drive 0
SYSINIT:3EAA		     shl     al, cl	     ; set proper bit depending	on drive
SYSINIT:3EAC		     or	     ds:ec35_flag, al ;	set the	bit in the permanent flags
SYSINIT:3EB0
SYSINIT:3EB0 not_ec35:				     ; ...
SYSINIT:3EB0		     mov     al, byte ptr cs:devp_spt ;	mov al,[cs:deviceparameters+20]
SYSINIT:3EB0					     ; [cs:deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:3EB0					     ; +A_BPB.BPB_SECTORSPERTRACK]
SYSINIT:3EB4		     cmp     al, ds:eot
SYSINIT:3EB8		     jbe     short eot_ok
SYSINIT:3EBA		     mov     ds:eot, al
SYSINIT:3EBD
SYSINIT:3EBD eot_ok:				     ; ...
SYSINIT:3EBD		     pop     dx
SYSINIT:3EBE		     pop     cx
SYSINIT:3EBF		     pop     bx
SYSINIT:3EC0		     pop     ax
SYSINIT:3EC1		     pop     ds
SYSINIT:3EC2		     assume ds:nothing
SYSINIT:3EC2		     retn
SYSINIT:3EC2 setparms	     endp
SYSINIT:3EC2
SYSINIT:3EC3
SYSINIT:3EC3 ; =============== S U B R O U T I N E =======================================
SYSINIT:3EC3
SYSINIT:3EC3
SYSINIT:3EC3 diddleback	     proc near		     ; ...
SYSINIT:3EC3		     push    ds		     ; replace default values for further drivparm commands
SYSINIT:3EC4		     push    cs
SYSINIT:3EC5		     pop     ds
SYSINIT:3EC6		     assume ds:SYSINIT
SYSINIT:3EC6		     mov     devp_cylinders, 80	; [deviceparameters+4],80
SYSINIT:3EC6					     ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],80
SYSINIT:3ECC		     mov     devp_devtype, 2 ; [deviceparameters+1],2
SYSINIT:3ECC					     ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_3INCH720KB
SYSINIT:3ED1		     mov     devp_devattr, 0 ; [deviceparameters+2],0
SYSINIT:3ED1					     ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],0
SYSINIT:3ED7		     mov     switches, 0     ; zero all	switches
SYSINIT:3EDD		     pop     ds
SYSINIT:3EDE		     assume ds:nothing
SYSINIT:3EDE		     retn
SYSINIT:3EDE diddleback	     endp
SYSINIT:3EDE
SYSINIT:3EDF
SYSINIT:3EDF ; =============== S U B R O U T I N E =======================================
SYSINIT:3EDF
SYSINIT:3EDF
SYSINIT:3EDF parseline	     proc near		     ; ...
SYSINIT:3EDF		     push    ds
SYSINIT:3EE0		     push    cs
SYSINIT:3EE1		     pop     ds
SYSINIT:3EE2		     assume ds:SYSINIT
SYSINIT:3EE2
SYSINIT:3EE2 nextswtch:				     ; ...
SYSINIT:3EE2		     cmp     al, 0Dh	     ; al contains the first character in command line.
SYSINIT:3EE4		     jz	     short done_line ; cr
SYSINIT:3EE6		     cmp     al, 0Ah
SYSINIT:3EE8		     jz	     short put_back  ; lf ; put	it back	and done
SYSINIT:3EEA		     cmp     al, 20h ; ' '
SYSINIT:3EEC		     jbe     short getnext   ; skip over space
SYSINIT:3EEE		     cmp     al, 2Fh ; '/'
SYSINIT:3EF0		     jz	     short getparm
SYSINIT:3EF2		     stc		     ; mark error invalid-character-in-input
SYSINIT:3EF3		     jmp     short exitpl
SYSINIT:3EF5 ; ---------------------------------------------------------------------------
SYSINIT:3EF5
SYSINIT:3EF5 getparm:				     ; ...
SYSINIT:3EF5		     call    check_switch
SYSINIT:3EF8		     mov     switches, bx    ; save switches read so far
SYSINIT:3EFC		     jb	     short swterr
SYSINIT:3EFE
SYSINIT:3EFE getnext:				     ; ...
SYSINIT:3EFE		     call    getchr
SYSINIT:3F01		     jb	     short done_line
SYSINIT:3F03		     jmp     short nextswtch
SYSINIT:3F05 ; ---------------------------------------------------------------------------
SYSINIT:3F05
SYSINIT:3F05 swterr:				     ; ...
SYSINIT:3F05		     jmp     short exitpl    ; exit if error
SYSINIT:3F07 ; ---------------------------------------------------------------------------
SYSINIT:3F07
SYSINIT:3F07 done_line:				     ; ...
SYSINIT:3F07		     test    switches, 8     ; flagdrive ; see if drive	specified
SYSINIT:3F0D		     jnz     short okay
SYSINIT:3F0F		     stc		     ; mark error no-drive-specified
SYSINIT:3F10		     jmp     short exitpl
SYSINIT:3F12 ; ---------------------------------------------------------------------------
SYSINIT:3F12
SYSINIT:3F12 okay:				     ; ...
SYSINIT:3F12		     mov     ax, switches
SYSINIT:3F15		     and     ax, 3	     ; get flag	bits for changeline and	non-rem
SYSINIT:3F18		     mov     devp_devattr, ax ;	[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
SYSINIT:3F1B		     mov     devp_trktblents, 0	; [deviceparameters+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
SYSINIT:3F21		     clc		     ; everything is fine
SYSINIT:3F22		     call    setdeviceparameters
SYSINIT:3F25
SYSINIT:3F25 exitpl:				     ; ...
SYSINIT:3F25		     pop     ds
SYSINIT:3F26		     assume ds:nothing
SYSINIT:3F26		     retn
SYSINIT:3F27 ; ---------------------------------------------------------------------------
SYSINIT:3F27
SYSINIT:3F27 put_back:				     ; ...
SYSINIT:3F27		     inc     ds:count	     ; one more	char to	scan
SYSINIT:3F2B		     dec     ds:chrptr	     ; back up over linefeed
SYSINIT:3F2F		     jmp     short done_line
SYSINIT:3F2F parseline	     endp
SYSINIT:3F2F
SYSINIT:3F31
SYSINIT:3F31 ; =============== S U B R O U T I N E =======================================
SYSINIT:3F31
SYSINIT:3F31
SYSINIT:3F31 check_switch    proc near		     ; ...
SYSINIT:3F31		     call    getchr
SYSINIT:3F34		     jb	     short err_chk
SYSINIT:3F36		     and     al, 0DFh	     ; convert it to upper case
SYSINIT:3F38		     cmp     al, 41h ; 'A'
SYSINIT:3F3A		     jb	     short err_chk
SYSINIT:3F3C		     cmp     al, 5Ah ; 'Z'
SYSINIT:3F3E		     ja	     short err_chk
SYSINIT:3F40		     push    es
SYSINIT:3F41		     push    cs
SYSINIT:3F42		     pop     es
SYSINIT:3F43		     assume es:SYSINIT
SYSINIT:3F43		     mov     cl, byte ptr ds:switchlist	; get number of	valid switches
SYSINIT:3F47		     mov     ch, 0
SYSINIT:3F49		     mov     di, (offset switchlist+1) ; point to string of valid switches
SYSINIT:3F4C		     repne scasb
SYSINIT:3F4E		     pop     es
SYSINIT:3F4F		     assume es:nothing
SYSINIT:3F4F		     jnz     short err_chk
SYSINIT:3F51		     mov     ax, 1
SYSINIT:3F54		     shl     ax, cl	     ; set bit to indicate switch
SYSINIT:3F56		     mov     bx, ds:switches ; get switches so far
SYSINIT:3F5A		     or	     bx, ax	     ; save this with other switches
SYSINIT:3F5C		     mov     cx, ax
SYSINIT:3F5E		     test    ax, 0F8h	     ; switchnum ; 0F8h
SYSINIT:3F5E					     ; test against switches that require number to follow
SYSINIT:3F61		     jz	     short done_swtch
SYSINIT:3F63		     call    getchr
SYSINIT:3F66		     jb	     short err_swtch
SYSINIT:3F68		     cmp     al, ':'
SYSINIT:3F6A		     jnz     short err_swtch
SYSINIT:3F6C		     call    getchr
SYSINIT:3F6F		     push    bx		     ; preserve	switches
SYSINIT:3F70		     mov     cs:sepchr,	20h ; ' ' ; allow space separators
SYSINIT:3F76		     call    getnum
SYSINIT:3F79		     mov     cs:sepchr,	0
SYSINIT:3F7F		     pop     bx		     ; restore switches
SYSINIT:3F80		     call    process_num
SYSINIT:3F83
SYSINIT:3F83 done_swtch:			     ; ...
SYSINIT:3F83		     clc
SYSINIT:3F84		     retn
SYSINIT:3F85 ; ---------------------------------------------------------------------------
SYSINIT:3F85
SYSINIT:3F85 err_swtch:				     ; ...
SYSINIT:3F85		     xor     bx, cx	     ; remove this switch from the records
SYSINIT:3F87
SYSINIT:3F87 err_chk:				     ; ...
SYSINIT:3F87		     stc
SYSINIT:3F88		     retn
SYSINIT:3F88 check_switch    endp
SYSINIT:3F88
SYSINIT:3F89
SYSINIT:3F89 ; =============== S U B R O U T I N E =======================================
SYSINIT:3F89
SYSINIT:3F89
SYSINIT:3F89 process_num     proc near		     ; ...
SYSINIT:3F89		     test    ds:switches, cx ; if this switch has been done before,
SYSINIT:3F8D		     jnz     short done_ret  ; ignore this one.
SYSINIT:3F8F		     test    cx, 8	     ; flagdrive
SYSINIT:3F93		     jz	     short try_f
SYSINIT:3F95		     mov     ds:drive, al
SYSINIT:3F98		     jmp     short done_ret
SYSINIT:3F9A ; ---------------------------------------------------------------------------
SYSINIT:3F9A
SYSINIT:3F9A try_f:				     ; ...
SYSINIT:3F9A		     test    cx, 80h	     ; flagff
SYSINIT:3F9E		     jz	     short try_t
SYSINIT:3FA0		     mov     ds:530Dh, al
SYSINIT:3FA3		     jmp     short done_ret
SYSINIT:3FA5 ; ---------------------------------------------------------------------------
SYSINIT:3FA5
SYSINIT:3FA5 try_t:				     ; ...
SYSINIT:3FA5		     or	     ax, ax	     ; if number entered was 0,	assume default value
SYSINIT:3FA7		     jz	     short done_ret
SYSINIT:3FA9		     test    cx, 10h	     ; flagcyln
SYSINIT:3FAD		     jz	     short try_s
SYSINIT:3FAF		     mov     ds:devp_cylinders,	ax ; [deviceparameters+4],ax
SYSINIT:3FAF					     ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
SYSINIT:3FB2		     jmp     short done_ret
SYSINIT:3FB4 ; ---------------------------------------------------------------------------
SYSINIT:3FB4
SYSINIT:3FB4 try_s:				     ; ...
SYSINIT:3FB4		     test    cx, 20h	     ; flagseclim
SYSINIT:3FB8		     jz	     short try_h     ; must be for number of heads
SYSINIT:3FBA		     mov     ds:slim, ax
SYSINIT:3FBD		     jmp     short done_ret
SYSINIT:3FBF ; ---------------------------------------------------------------------------
SYSINIT:3FBF
SYSINIT:3FBF try_h:				     ; ...
SYSINIT:3FBF		     mov     ds:hlim, ax
SYSINIT:3FC2
SYSINIT:3FC2 done_ret:				     ; ...
SYSINIT:3FC2		     clc		     ; (test instruction resets	cf)
SYSINIT:3FC3		     retn
SYSINIT:3FC3 process_num     endp
SYSINIT:3FC3
SYSINIT:3FC4
SYSINIT:3FC4 ; =============== S U B R O U T I N E =======================================
SYSINIT:3FC4
SYSINIT:3FC4
SYSINIT:3FC4 setdeviceparameters proc near	     ; ...
SYSINIT:3FC4		     push    es
SYSINIT:3FC5		     push    cs
SYSINIT:3FC6		     pop     es
SYSINIT:3FC7		     assume es:SYSINIT
SYSINIT:3FC7		     xor     bx, bx
SYSINIT:3FC9		     mov     bl, ds:devp_devtype ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE]
SYSINIT:3FCD		     cmp     bl, 0	     ; DEV_5INCH
SYSINIT:3FD0		     jnz     short got_80
SYSINIT:3FD2		     mov     ds:devp_cylinders,	40 ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
SYSINIT:3FD2					     ; 48 tpi =	40 cyl
SYSINIT:3FD8
SYSINIT:3FD8 got_80:				     ; ...
SYSINIT:3FD8		     shl     bx, 1	     ; get index into bpb table
SYSINIT:3FDA		     mov     si, ds:_bpbtable[bx] ; get	address	of bpb
SYSINIT:3FDE		     mov     di, offset	devp_bps ; deviceparameters+7
SYSINIT:3FDE					     ; deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:3FDE					     ; es:di ->	bpb
SYSINIT:3FE1		     mov     cx, 31	     ; A_BPB.size
SYSINIT:3FE4		     cld
SYSINIT:3FE5		     rep movsb
SYSINIT:3FE7		     pop     es
SYSINIT:3FE8		     assume es:nothing
SYSINIT:3FE8		     test    ds:switches, 20h ;	flagseclim
SYSINIT:3FEE		     jz	     short see_heads
SYSINIT:3FF0		     mov     ax, ds:slim
SYSINIT:3FF3		     mov     ds:devp_spt, ax ; [deviceparameters+20]
SYSINIT:3FF3					     ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:3FF3					     ;	+A_BPB.BPB_SECTORSPERTRACK]
SYSINIT:3FF6
SYSINIT:3FF6 see_heads:				     ; ...
SYSINIT:3FF6		     test    ds:switches, 40h ;	flagheads
SYSINIT:3FFC		     jz	     short heads_not_altered
SYSINIT:3FFE		     mov     ax, ds:hlim
SYSINIT:4001		     mov     ds:devp_heads, ax ; [deviceparameters+22]
SYSINIT:4001					     ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]
SYSINIT:4004
SYSINIT:4004 heads_not_altered:			     ; ...
SYSINIT:4004		     mov     ds:devp_secperclus, 2 ; [deviceparameters+9],2
SYSINIT:4004					     ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:4004					     ;	+A_BPB.BPB_SECTORSPERCLUSTER]
SYSINIT:4009		     mov     bl, 0F0h ;	'ð'  ; get default mediabyte
SYSINIT:400B		     mov     bh, ds:devp_mediaid ; [deviceparameters+17]
SYSINIT:400B					     ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]
SYSINIT:400F		     cmp     ds:devp_heads, 2
SYSINIT:4014		     ja	     short got_correct_mediaid ; just use default if heads>2
SYSINIT:4016		     jnz     short only_one_head ; one head, do	one head stuff
SYSINIT:4018		     mov     bl, bh
SYSINIT:401A		     cmp     ds:devp_spt, 18 ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:401A					     ;	+A_BPB.BPB_SECTORSPERTRACK]
SYSINIT:401F		     jnz     short not_144m
SYSINIT:4021		     cmp     ds:devp_cylinders,	80 ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
SYSINIT:4026		     jnz     short not_144m
SYSINIT:4028		     jmp     short got_one_secperclus_drive ; cyl=80, heads=2, secpertrack=18.
SYSINIT:4028					     ;	Set cluster size to 1.
SYSINIT:402A ; ---------------------------------------------------------------------------
SYSINIT:402A
SYSINIT:402A not_144m:				     ; ...
SYSINIT:402A		     cmp     ds:devp_cylinders,	40
SYSINIT:402F		     jnz     short got_correct_mediaid
SYSINIT:4031		     cmp     ds:devp_spt, 8
SYSINIT:4036		     jnz     short got_correct_mediaid
SYSINIT:4038		     mov     bl, 0FCh
SYSINIT:403A		     jmp     short got_correct_mediaid
SYSINIT:403C ; ---------------------------------------------------------------------------
SYSINIT:403C
SYSINIT:403C only_one_head:			     ; ...
SYSINIT:403C		     cmp     ds:devp_devtype, 0	; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_5INCH
SYSINIT:4041		     jnz     short got_one_secperclus_drive
SYSINIT:4043		     mov     bl, 0FCh
SYSINIT:4045		     cmp     ds:devp_spt, 8  ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:4045					     ;	+A_BPB.BPB_SECTORSPERTRACK],8
SYSINIT:404A		     jnz     short got_one_secperclus_drive ; okay if anything besides 8
SYSINIT:404C		     mov     bl, 0FEh	     ; 160K mediaid
SYSINIT:404E
SYSINIT:404E got_one_secperclus_drive:		     ; ...
SYSINIT:404E		     mov     ds:devp_secperclus, 1 ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:404E					     ;	+A_BPB.BPB_SECTORSPERCLUSTER],1
SYSINIT:4053
SYSINIT:4053 got_correct_mediaid:		     ; ...
SYSINIT:4053		     mov     ds:devp_mediaid, bl ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:4053					     ;	+A_BPB.BPB_MEDIADESCRIPTOR],bl
SYSINIT:4057		     mov     ax, ds:devp_cylinders ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
SYSINIT:405A		     mul     ds:devp_heads   ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]
SYSINIT:405E		     mul     ds:devp_spt     ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
SYSINIT:4062		     mov     ds:devp_totalsecs,	ax ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
SYSINIT:4065		     clc
SYSINIT:4066		     retn
SYSINIT:4066 setdeviceparameters endp
SYSINIT:4066
SYSINIT:4067
SYSINIT:4067 ; =============== S U B R O U T I N E =======================================
SYSINIT:4067
SYSINIT:4067
SYSINIT:4067 organize	     proc near		     ; ...
SYSINIT:4067		     mov     cx, cs:count
SYSINIT:406C		     jcxz    short nochar1
SYSINIT:406E		     xor     si, si
SYSINIT:4070		     mov     di, si
SYSINIT:4072		     xor     ax, ax
SYSINIT:4074		     mov     cs:com_level, 0
SYSINIT:407A
SYSINIT:407A org1:				     ; ...
SYSINIT:407A		     call    skip_comment
SYSINIT:407D		     jz	     short end_commd_line ; found a comment string and skipped.
SYSINIT:407F		     call    get2	     ; not a comment string. then get a	char.
SYSINIT:4082		     cmp     al, 0Ah	     ; lf
SYSINIT:4084		     jz	     short end_commd_line ; starts with	a blank	line.
SYSINIT:4086		     cmp     al, 20h ; ' '
SYSINIT:4088		     jbe     short org1	     ; skip leading control characters
SYSINIT:408A		     jmp     short findit
SYSINIT:408C ; ---------------------------------------------------------------------------
SYSINIT:408C
SYSINIT:408C end_commd_line:			     ; ...
SYSINIT:408C		     stosb		     ; store line feed char in buffer for the linecount.
SYSINIT:408D		     mov     cs:com_level, 0 ; reset the command level.
SYSINIT:4093		     jmp     short org1
SYSINIT:4095 ; ---------------------------------------------------------------------------
SYSINIT:4095
SYSINIT:4095 nochar1:				     ; ...
SYSINIT:4095		     stc
SYSINIT:4096		     retn
SYSINIT:4097 ; ---------------------------------------------------------------------------
SYSINIT:4097
SYSINIT:4097 findit:				     ; ...
SYSINIT:4097		     push    cx		     ; prepare to search command table
SYSINIT:4098		     push    si
SYSINIT:4099		     push    di
SYSINIT:409A		     mov     bp, si
SYSINIT:409C		     dec     bp
SYSINIT:409D		     mov     si, offset	comtab ; "\x01[["
SYSINIT:40A0		     mov     ch, 0
SYSINIT:40A2
SYSINIT:40A2 findcom:				     ; ...
SYSINIT:40A2		     mov     di, bp
SYSINIT:40A4		     mov     cl, [si]
SYSINIT:40A6		     inc     si
SYSINIT:40A7		     jcxz    short nocom
SYSINIT:40A9		     cmp     byte ptr es:[di], 3Bh ; ';' ; CONFIG_SEMICOLON
SYSINIT:40AD		     jz	     short semicolon
SYSINIT:40AF
SYSINIT:40AF loopcom:				     ; ...
SYSINIT:40AF		     mov     al, es:[di]
SYSINIT:40B2		     inc     di
SYSINIT:40B3		     and     al, 0DFh	     ; ~20h ; force upper case
SYSINIT:40B5		     inc     si
SYSINIT:40B6		     cmp     al, [si-1]	     ; compare to byte @es:di
SYSINIT:40B9		     loope   loopcom
SYSINIT:40BB		     lahf
SYSINIT:40BC		     add     si, cx	     ; bump to next position without affecting flags
SYSINIT:40BE		     sahf
SYSINIT:40BF		     lodsb		     ; get indicator letter
SYSINIT:40C0		     jnz     short findcom
SYSINIT:40C2		     cmp     byte ptr es:[di], 0Dh ; the next char might be cr,lf
SYSINIT:40C6		     jz	     short gotcom0
SYSINIT:40C8		     cmp     byte ptr es:[di], 0Ah ; such as in	"rem",cr,lf case.
SYSINIT:40CC		     jz	     short gotcom0
SYSINIT:40CE		     cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
SYSINIT:40D0		     jz	     short gotcom0
SYSINIT:40D2		     push    ax
SYSINIT:40D3		     mov     al, es:[di]     ; now the next char. should be a delim.
SYSINIT:40D6		     cmp     al, 3Fh ; '?'   ; explicit interactive command?
SYSINIT:40D8		     jnz     short no_query  ; no
SYSINIT:40DA		     pop     ax		     ; yes, so retrieve	the original code
SYSINIT:40DB		     or	     al, 80h	     ; CONFIG_OPTION_QUERY ; and set the QUERY bit
SYSINIT:40DD		     jmp     short gotcom0
SYSINIT:40DF ; ---------------------------------------------------------------------------
SYSINIT:40DF
SYSINIT:40DF semicolon:				     ; ...
SYSINIT:40DF		     mov     al, 30h ; '0'   ; CONFIG_REM
SYSINIT:40E1		     jmp     short gotcom0
SYSINIT:40E3 ; ---------------------------------------------------------------------------
SYSINIT:40E3
SYSINIT:40E3 no_query:				     ; ...
SYSINIT:40E3		     call    delim
SYSINIT:40E6		     pop     ax
SYSINIT:40E7		     jnz     short findcom
SYSINIT:40E9
SYSINIT:40E9 gotcom0:				     ; ...
SYSINIT:40E9		     pop     di
SYSINIT:40EA		     pop     si
SYSINIT:40EB		     pop     cx
SYSINIT:40EC		     jmp     short gotcom
SYSINIT:40EE ; ---------------------------------------------------------------------------
SYSINIT:40EE
SYSINIT:40EE nocom:				     ; ...
SYSINIT:40EE		     pop     di
SYSINIT:40EF		     pop     si
SYSINIT:40F0		     pop     cx
SYSINIT:40F1		     mov     al, 5Ah ; 'Z'   ; CONFIG_UNKNOWN
SYSINIT:40F3		     stosb		     ; save indicator char.
SYSINIT:40F4
SYSINIT:40F4 _skipline:				     ; ...
SYSINIT:40F4		     call    get2
SYSINIT:40F7		     cmp     al, 0Ah	     ; lf ; skip this bad command line
SYSINIT:40F9		     jnz     short _skipline
SYSINIT:40FB		     jmp     short end_commd_line
SYSINIT:40FD ; ---------------------------------------------------------------------------
SYSINIT:40FD
SYSINIT:40FD gotcom:				     ; ...
SYSINIT:40FD		     stosb		     ; save indicator char in buffer
SYSINIT:40FE		     and     al, 7Fh	     ; ~CONFIG_OPTION_QUERY
SYSINIT:4100		     mov     cs:cmd_indicator, al ; save it for	the future use.
SYSINIT:4104		     cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
SYSINIT:4106		     jz	     short org31
SYSINIT:4108		     cmp     al, 4Fh ; 'O'   ; CONFIG_SUBMENU
SYSINIT:410A		     jz	     short org2
SYSINIT:410C		     cmp     al, 45h ; 'E'   ; CONFIG_MENUITEM
SYSINIT:410E		     jz	     short org2
SYSINIT:4110		     cmp     al, 41h ; 'A'   ; CONFIG_MENUDEFAULT
SYSINIT:4112		     jz	     short org2
SYSINIT:4114		     cmp     al, 4Ah ; 'J'   ; CONFIG_INCLUDE
SYSINIT:4116		     jz	     short org2
SYSINIT:4118		     call    mapcase	     ; map case	of rest	of line	to UPPER
SYSINIT:411B
SYSINIT:411B org2:				     ; ...
SYSINIT:411B		     call    get2	     ; skip the	command	name until delimiter
SYSINIT:411E		     cmp     al, 0Ah	     ; lf
SYSINIT:4120		     jz	     short org21
SYSINIT:4122		     cmp     al, 0Dh	     ; cr
SYSINIT:4124		     jz	     short org21
SYSINIT:4126		     cmp     al, 2Fh ; '/'   ; Added to allow DEVHIGH/L:...
SYSINIT:4128		     jz	     short org21     ; to be parsed properly
SYSINIT:412A		     call    delim
SYSINIT:412D		     jnz     short org2
SYSINIT:412F		     jmp     short org3
SYSINIT:4131 ; ---------------------------------------------------------------------------
SYSINIT:4131
SYSINIT:4131 org21:				     ; ...
SYSINIT:4131		     dec     si		     ; if cr or	lf then
SYSINIT:4132		     inc     cx		     ; undo si,	cx register and	continue
SYSINIT:4133
SYSINIT:4133 org3:				     ; ...
SYSINIT:4133		     cmp     cs:cmd_indicator, 59h ; 'Y' ; CONFIG_COMMENT
SYSINIT:4139		     jz	     short get_cmt_token
SYSINIT:413B		     cmp     cs:cmd_indicator, 44h ; 'D' ; CONFIG_DEVICE
SYSINIT:4141		     jz	     short org_file
SYSINIT:4143		     cmp     cs:cmd_indicator, 49h ; 'I' ; CONFIG_INSTALL
SYSINIT:4149		     jz	     short org_file
SYSINIT:414B		     cmp     cs:cmd_indicator, 57h ; 'W' ; CONFIG_INSTALLHIGH
SYSINIT:4151		     jz	     short org_file
SYSINIT:4153		     cmp     cs:cmd_indicator, 53h ; 'S' ; CONFIG_SHELL
SYSINIT:4159		     jz	     short org_file
SYSINIT:415B		     cmp     cs:cmd_indicator, 31h ; '1' ; CONFIG_SWITCHES
SYSINIT:4161		     jz	     short org_switch
SYSINIT:4163
SYSINIT:4163 org31:				     ; ...
SYSINIT:4163		     jmp     org4
SYSINIT:4166 ; ---------------------------------------------------------------------------
SYSINIT:4166
SYSINIT:4166 org_switch:			     ; ...
SYSINIT:4166		     call    skip_comment
SYSINIT:4169		     jz	     short end_commd_line_brdg
SYSINIT:416B		     call    get2
SYSINIT:416E		     call    org_delim
SYSINIT:4171		     jz	     short org_switch
SYSINIT:4173		     stosb
SYSINIT:4174		     jmp     org5
SYSINIT:4177 ; ---------------------------------------------------------------------------
SYSINIT:4177
SYSINIT:4177 org_file:				     ; ...
SYSINIT:4177		     call    skip_comment    ; get the filename	and put	0 at end
SYSINIT:417A		     jz	     short org_put_zero
SYSINIT:417C		     call    get2	     ; not a comment
SYSINIT:417F		     call    delim
SYSINIT:4182		     jz	     short org_file  ; skip the	possible delimiters
SYSINIT:4184		     stosb		     ; copy the	first non delim	char found in buffer
SYSINIT:4185
SYSINIT:4185 org_copy_file:			     ; ...
SYSINIT:4185		     call    skip_comment    ; comment char in the filename?
SYSINIT:4188		     jz	     short org_put_zero	; then stop copying filename at	that point
SYSINIT:418A		     call    get2
SYSINIT:418D		     cmp     al, 2Fh ; '/'   ; a switch char? (device=filename/xxx)
SYSINIT:418F		     jz	     short end_file_slash ; this will be the special case.
SYSINIT:4191		     stosb		     ; save the	char. in buffer
SYSINIT:4192		     call    delim
SYSINIT:4195		     jz	     short end_copy_file
SYSINIT:4197		     cmp     al, 20h ; ' '
SYSINIT:4199		     ja	     short org_copy_file ; keep	copying
SYSINIT:419B		     jmp     short end_copy_file ; otherwise, assume end of the	filename.
SYSINIT:419D ; ---------------------------------------------------------------------------
SYSINIT:419D
SYSINIT:419D get_cmt_token:			     ; ...
SYSINIT:419D		     call    get2	     ; get the token. just max.	2 char.
SYSINIT:41A0		     cmp     al, 20h ; ' '   ; skip white spaces or "=" char.
SYSINIT:41A2		     jz	     short get_cmt_token ; (we are allowing the	other special
SYSINIT:41A4		     cmp     al, 9	     ; characters can used for comment id.
SYSINIT:41A6		     jz	     short get_cmt_token ; character.)
SYSINIT:41A8		     cmp     al, 3Dh ; '='   ;  = is special in this case.
SYSINIT:41AA		     jz	     short get_cmt_token
SYSINIT:41AC		     cmp     al, 0Dh
SYSINIT:41AE		     jz	     short get_cmt_end ; cannot	accept the carriage return
SYSINIT:41B0		     cmp     al, 0Ah
SYSINIT:41B2		     jz	     short get_cmt_end
SYSINIT:41B4		     mov     cs:cmmt1, al    ; store it
SYSINIT:41B8		     mov     cs:cmmt, 1	     ; 1 char. so far.
SYSINIT:41BE		     call    get2
SYSINIT:41C1		     cmp     al, 20h ; ' '
SYSINIT:41C3		     jz	     short get_cmt_end
SYSINIT:41C5		     cmp     al, 9	     ; tab
SYSINIT:41C7		     jz	     short get_cmt_end
SYSINIT:41C9		     cmp     al, 0Dh	     ; cr
SYSINIT:41CB		     jz	     short get_cmt_end
SYSINIT:41CD		     cmp     al, 0Ah	     ; lf
SYSINIT:41CF		     jz	     short end_commd_line_brdg
SYSINIT:41D1		     mov     cs:cmmt2, al
SYSINIT:41D5		     inc     cs:cmmt
SYSINIT:41DA
SYSINIT:41DA get_cmt_end:			     ; ...
SYSINIT:41DA		     call    get2
SYSINIT:41DD		     cmp     al, 0Ah	     ; lf
SYSINIT:41DF		     jnz     short get_cmt_end ; skip it.
SYSINIT:41E1
SYSINIT:41E1 end_commd_line_brdg:		     ; ...
SYSINIT:41E1		     jmp     end_commd_line  ; else jmp	to end_commd_line
SYSINIT:41E4 ; ---------------------------------------------------------------------------
SYSINIT:41E4
SYSINIT:41E4 org_put_zero:			     ; ...
SYSINIT:41E4		     mov     byte ptr es:[di], 0 ; make	the filename in	front of
SYSINIT:41E4					     ; the comment string to be	an asciiz.
SYSINIT:41E8		     inc     di
SYSINIT:41E9		     jmp     end_commd_line  ; (maybe null if device=/*)
SYSINIT:41EC ; ---------------------------------------------------------------------------
SYSINIT:41EC
SYSINIT:41EC end_file_slash:			     ; ...
SYSINIT:41EC		     mov     byte ptr es:[di], 0 ; al =	"/" option char.
SYSINIT:41EC					     ; make a filename an asciiz
SYSINIT:41F0		     inc     di		     ; and
SYSINIT:41F1		     stosb		     ; store "/" after that.
SYSINIT:41F2		     jmp     short org5	     ; continue	with the rest of the line
SYSINIT:41F4 ; ---------------------------------------------------------------------------
SYSINIT:41F4
SYSINIT:41F4 end_copy_file:			     ; ...
SYSINIT:41F4		     mov     byte ptr es:[di-1], 0 ; make it an	asciiz and handle the next char.
SYSINIT:41F9		     cmp     al, 0Ah	     ; lf
SYSINIT:41FB		     jz	     short end_commd_line_brdg
SYSINIT:41FD		     jmp     short org5
SYSINIT:41FF ; ---------------------------------------------------------------------------
SYSINIT:41FF
SYSINIT:41FF org4:				     ; ...
SYSINIT:41FF		     call    skip_comment    ; org4 skips all delimiters
SYSINIT:41FF					     ; after the command name except for '/'
SYSINIT:4202		     jz	     short end_commd_line_brdg
SYSINIT:4204		     call    get2
SYSINIT:4207		     call    org_delim	     ; skip delimiters except '/'
SYSINIT:420A		     jz	     short org4
SYSINIT:420C		     jmp     short org51
SYSINIT:420E ; ---------------------------------------------------------------------------
SYSINIT:420E
SYSINIT:420E org5:				     ; ...
SYSINIT:420E		     call    skip_comment    ; rest of the line	is
SYSINIT:4211		     jz	     short end_commd_line_brdg ; comment.
SYSINIT:4213		     call    get2	     ; not a comment.
SYSINIT:4216
SYSINIT:4216 org51:				     ; ...
SYSINIT:4216		     stosb		     ; copy the	character
SYSINIT:4217		     cmp     al, 22h ; '"'   ; a quote ?
SYSINIT:4219		     jz	     short at_quote
SYSINIT:421B		     cmp     al, 20h ; ' '
SYSINIT:421D		     ja	     short org5
SYSINIT:421F		     cmp     cs:cmd_indicator, 'U' ; CONFIG_DEVICEHIGH
SYSINIT:421F					     ; Q: is this devicehigh
SYSINIT:4225		     jnz     short not_dh    ; N:
SYSINIT:4227		     cmp     al, 0Ah	     ; Q: is this line feed
SYSINIT:4229		     jz	     short org_dhlf  ; Y: stuff	a blank	before the lf
SYSINIT:422B		     cmp     al, 0Dh	     ; Q: is this a cr
SYSINIT:422D		     jnz     short org5	     ; N:
SYSINIT:422F		     mov     byte ptr es:[di-1], 20h ; ' ' ; overwrite cr with blank
SYSINIT:4234		     stosb		     ; put cr after blank
SYSINIT:4235		     inc     cs:insert_blank ; indicate	that blank has been inserted
SYSINIT:423A		     jmp     short org5
SYSINIT:423C ; ---------------------------------------------------------------------------
SYSINIT:423C
SYSINIT:423C not_dh:				     ; ...
SYSINIT:423C		     cmp     al, 0Ah	     ; lf ; line feed?
SYSINIT:423E		     jz	     short org1_brdg ; handles the next	command	line.
SYSINIT:4240		     jmp     short org5	     ; handles next char in this line.
SYSINIT:4242 ; ---------------------------------------------------------------------------
SYSINIT:4242
SYSINIT:4242 org_dhlf:				     ; ...
SYSINIT:4242		     cmp     cs:insert_blank, 1	; Q:has	a blank	already	been inserted
SYSINIT:4248		     jz	     short org1_brdg ; Y:
SYSINIT:424A		     mov     byte ptr es:[di-1], 20h ; ' ' ; overwrite lf with blank
SYSINIT:424F		     stosb		     ; put lf after blank
SYSINIT:4250
SYSINIT:4250 org1_brdg:				     ; ...
SYSINIT:4250		     mov     cs:insert_blank, 0	; clear	blank indicator	for devicehigh
SYSINIT:4256		     jmp     org1
SYSINIT:4259 ; ---------------------------------------------------------------------------
SYSINIT:4259
SYSINIT:4259 at_quote:				     ; ...
SYSINIT:4259		     cmp     cs:com_level, 0
SYSINIT:425F		     jz	     short up_level
SYSINIT:4261		     mov     cs:com_level, 0 ; reset it
SYSINIT:4267		     jmp     short org5
SYSINIT:4269 ; ---------------------------------------------------------------------------
SYSINIT:4269
SYSINIT:4269 up_level:				     ; ...
SYSINIT:4269		     inc     cs:com_level    ; set it
SYSINIT:426E		     jmp     short org5
SYSINIT:426E organize	     endp
SYSINIT:426E
SYSINIT:4270 ; ---------------------------------------------------------------------------
SYSINIT:4270
SYSINIT:4270 get2:				     ; ...
SYSINIT:4270		     jcxz    short noget
SYSINIT:4272		     lods    byte ptr es:[si]
SYSINIT:4274		     dec     cx
SYSINIT:4275		     retn
SYSINIT:4276 ; ---------------------------------------------------------------------------
SYSINIT:4276
SYSINIT:4276 noget:				     ; ...
SYSINIT:4276		     pop     cx		     ; This was	the rather kludgy way
SYSINIT:4276					     ; out of procedure	"organize",
SYSINIT:4276					     ; but instead of returning	to doconf,
SYSINIT:4276					     ; we now want to check config.sys BEGIN/END blocks
SYSINIT:4276					     ; and the new boot	menu stuff
SYSINIT:4277		     mov     cs:count, di
SYSINIT:427C		     mov     cs:org_count, di
SYSINIT:4281		     xor     si, si
SYSINIT:4283		     mov     cs:chrptr,	si
SYSINIT:4288		     mov     cx, di
SYSINIT:428A		     jmp     menu_check
SYSINIT:428D
SYSINIT:428D ; =============== S U B R O U T I N E =======================================
SYSINIT:428D
SYSINIT:428D
SYSINIT:428D skip_comment    proc near		     ; ...
SYSINIT:428D		     jcxz    short noget     ; get out of the organize routine.
SYSINIT:428D					     ; ...
SYSINIT:428D					     ; skip the	commented string until lf,
SYSINIT:428D					     ; if current es:si-> a comment string.
SYSINIT:428D					     ; ...
SYSINIT:428F		     cmp     cs:com_level, 0 ; only check it if	parameter level	is 0.
SYSINIT:4295		     jnz     short no_commt  ; (not inside quotations)
SYSINIT:4297		     cmp     cs:cmmt, 1
SYSINIT:429D		     jb	     short no_commt
SYSINIT:429F		     mov     al, es:[si]
SYSINIT:42A2		     cmp     cs:cmmt1, al
SYSINIT:42A7		     jnz     short no_commt
SYSINIT:42A9		     cmp     cs:cmmt, 2
SYSINIT:42AF		     jnz     short skip_cmmt
SYSINIT:42B1		     mov     al, es:[si+1]
SYSINIT:42B5		     cmp     cs:cmmt2, al
SYSINIT:42BA		     jnz     short no_commt
SYSINIT:42BC
SYSINIT:42BC skip_cmmt:				     ; ...
SYSINIT:42BC		     jcxz    short noget     ; get out of organize routine.
SYSINIT:42BE		     mov     al, es:[si]
SYSINIT:42C1		     inc     si
SYSINIT:42C2		     dec     cx
SYSINIT:42C3		     cmp     al, 0Ah	     ; lf ; line feed ?
SYSINIT:42C5		     jnz     short skip_cmmt
SYSINIT:42C7
SYSINIT:42C7 no_commt:				     ; ...
SYSINIT:42C7		     retn
SYSINIT:42C7 skip_comment    endp
SYSINIT:42C7
SYSINIT:42C8
SYSINIT:42C8 ; =============== S U B R O U T I N E =======================================
SYSINIT:42C8
SYSINIT:42C8
SYSINIT:42C8 kbd_read	     proc near		     ; ...
SYSINIT:42C8		     test    ds:bDisableUI, 2 ;	wait for keystroke
SYSINIT:42CD		     jnz     short kbd_nodelay ;
SYSINIT:42CD					     ; the bios	timer tick count is incremented
SYSINIT:42CD					     ; 18.2 times per second;
SYSINIT:42CD					     ; watch the timer tick count for 37 transitions
SYSINIT:42CD					     ; get initial value
SYSINIT:42CF		     push    ds
SYSINIT:42D0		     sub     ax, ax
SYSINIT:42D2		     mov     ds, ax
SYSINIT:42D4		     assume ds:nothing
SYSINIT:42D4
SYSINIT:42D4 kbd_loop:				     ; ...
SYSINIT:42D4		     mov     ah, 1	     ; peek the	keyboard
SYSINIT:42D6		     int     16h	     ; KEYBOARD	- CHECK	BUFFER,	DO NOT CLEAR
SYSINIT:42D6					     ; Return: ZF clear	if character in	buffer
SYSINIT:42D6					     ; AH = scan code, AL = character
SYSINIT:42D6					     ; ZF set if no character in buffer
SYSINIT:42D8		     jnz     short kbd_loopdone
SYSINIT:42DA		     mov     ah, 2
SYSINIT:42DC		     int     16h	     ; KEYBOARD	- GET SHIFT STATUS
SYSINIT:42DC					     ; AL = shift status bits
SYSINIT:42DE		     test    al, 3	     ; either right or left shift key bits set?
SYSINIT:42E0		     jnz     short kbd_loopdone
SYSINIT:42E2		     mov     ax, ds:046Ch    ; system timer, lw
SYSINIT:42E5		     sub     ax, cs:_timer_lw_ ; get difference
SYSINIT:42EA		     cmp     ax, 37	     ; reached limit? ;	(2 seconds)
SYSINIT:42ED		     jb	     short kbd_loop
SYSINIT:42EF
SYSINIT:42EF kbd_loopdone:			     ; ...
SYSINIT:42EF		     pop     ds		     ; delay complete!
SYSINIT:42F0		     assume ds:nothing
SYSINIT:42F0
SYSINIT:42F0 kbd_nodelay:			     ; ...
SYSINIT:42F0		     sub     bx, bx	     ; assume clean boot
SYSINIT:42F2		     mov     ah, 2	     ; peek the	shift states
SYSINIT:42F4		     int     16h	     ; KEYBOARD	- GET SHIFT STATUS
SYSINIT:42F4					     ; AL = shift status bits
SYSINIT:42F6		     test    al, 3	     ; either right or left shift key bits set?
SYSINIT:42F8		     jz	     short kbd_notshift	; no
SYSINIT:42FA		     inc     bx		     ; yes
SYSINIT:42FB		     inc     bx
SYSINIT:42FC		     or	     ds:bQueryOpt, 4
SYSINIT:4301
SYSINIT:4301 kbd_notshift:			     ; ...
SYSINIT:4301		     mov     ah, 1	     ; peek the	keyboard
SYSINIT:4303		     int     16h	     ; KEYBOARD	- CHECK	BUFFER,	DO NOT CLEAR
SYSINIT:4303					     ; Return: ZF clear	if character in	buffer
SYSINIT:4303					     ; AH = scan code, AL = character
SYSINIT:4303					     ; ZF set if no character in buffer
SYSINIT:4305		     jz	     short kbd_test  ; no key present
SYSINIT:4307		     or	     al, al	     ; is it a function	key?
SYSINIT:4309		     jnz     short kbd_test  ; no
SYSINIT:430B		     cmp     ah, 62h	     ; CTRL F5
SYSINIT:430E		     jz	     short kbd_cfg_bypass
SYSINIT:4310		     cmp     ah, 3Fh	     ; F5 function key?
SYSINIT:4313		     jnz     short kbd_notf5 ; no
SYSINIT:4315
SYSINIT:4315 kbd_cfg_bypass:			     ; ...
SYSINIT:4315		     mov     dx, offset	_$CleanMsg ; "MS-DOS is	bypassing your CONFIG.SYS and"...
SYSINIT:4318		     call    print
SYSINIT:431B		     or	     ds:bQueryOpt, 4
SYSINIT:4320		     jmp     short kbd_eat   ; yes, clean boot selected
SYSINIT:4322 ; ---------------------------------------------------------------------------
SYSINIT:4322
SYSINIT:4322 kbd_notf5:				     ; ...
SYSINIT:4322		     cmp     ah, 65h	     ; CTRL F8
SYSINIT:4325		     jz	     short kbd_cfg_confirm
SYSINIT:4327		     cmp     ah, 42h	     ; F8
SYSINIT:432A		     jnz     short kbd_exit
SYSINIT:432C
SYSINIT:432C kbd_cfg_confirm:			     ; ...
SYSINIT:432C		     mov     dx, offset	_$InterMsg ; "MS-DOS will prompt you to	confirm	each "...
SYSINIT:432F		     call    print
SYSINIT:4332		     mov     bl, 1	     ; yes, interactive-boot option enabled
SYSINIT:4334		     mov     ds:bQueryOpt, bl ;	change default setting
SYSINIT:4338
SYSINIT:4338 kbd_eat:				     ; ...
SYSINIT:4338		     mov     ah, 0	     ; eat the key we assumed was a signal
SYSINIT:433A		     int     16h	     ; KEYBOARD	- READ CHAR FROM BUFFER, WAIT IF EMPTY
SYSINIT:433A					     ; Return: AH = scan code, AL = character
SYSINIT:433C		     mov     ds:secElapsed, 0FFh ; -1
SYSINIT:4341		     or	     bx, bx
SYSINIT:4343		     jz	     short kbd_clean
SYSINIT:4345
SYSINIT:4345 kbd_test:				     ; ...
SYSINIT:4345		     cmp     bl, 2
SYSINIT:4348		     jb	     short kbd_exit
SYSINIT:434A
SYSINIT:434A kbd_clean:				     ; ...
SYSINIT:434A		     call    disable_autoexec ;	yes, tell COMMAND to skip autoexec.bat
SYSINIT:434D		     stc		     ; set carry to indicate abort
SYSINIT:434E		     retn
SYSINIT:434F ; ---------------------------------------------------------------------------
SYSINIT:434F
SYSINIT:434F kbd_exit:				     ; ...
SYSINIT:434F		     clc		     ; clear carry to indicate success
SYSINIT:4350		     retn
SYSINIT:4350 kbd_read	     endp
SYSINIT:4350
SYSINIT:4351
SYSINIT:4351 ; =============== S U B R O U T I N E =======================================
SYSINIT:4351
SYSINIT:4351
SYSINIT:4351 set_numlock     proc near		     ; ...
SYSINIT:4351		     push    ax		     ; set numlock LED
SYSINIT:4352		     push    ds
SYSINIT:4353		     sub     ax, ax
SYSINIT:4355		     mov     ds, ax
SYSINIT:4357		     assume ds:nothing
SYSINIT:4357		     mov     ax, es:[si]     ; get 1st 2 bytes of value	(ON or OF)
SYSINIT:435A		     cmp     ax, word ptr cs:OnOff2 ; "OFF"
SYSINIT:435F		     jnz     short not_off
SYSINIT:4361		     and     byte ptr ds:0417h,	0DFh ; ~20h ; turn it off
SYSINIT:4366		     jmp     short set_done
SYSINIT:4368 ; ---------------------------------------------------------------------------
SYSINIT:4368
SYSINIT:4368 not_off:				     ; ...
SYSINIT:4368		     cmp     ax, word ptr cs:OnOff ; "ON"
SYSINIT:436D		     stc
SYSINIT:436E		     jnz     short set_done
SYSINIT:4370		     or	     byte ptr ds:0417h,	20h ; turn it on
SYSINIT:4375
SYSINIT:4375 set_done:				     ; ...
SYSINIT:4375		     pop     ds
SYSINIT:4376		     assume ds:nothing
SYSINIT:4376		     pop     ax
SYSINIT:4377		     retn
SYSINIT:4377 set_numlock     endp
SYSINIT:4377
SYSINIT:4378
SYSINIT:4378 ; =============== S U B R O U T I N E =======================================
SYSINIT:4378
SYSINIT:4378
SYSINIT:4378 menu_check	     proc near		     ; ...
SYSINIT:4378		     push    cx		     ; Search for SWITCHES,
SYSINIT:4378					     ; determine if /N or /F are present;
SYSINIT:4378					     ; if so, then disable clean/interactive boot options
SYSINIT:4379		     push    si
SYSINIT:437A		     sub     bx, bx	     ; remains ZERO until first	block
SYSINIT:437C
SYSINIT:437C swchk_loop:			     ; ...
SYSINIT:437C		     call    get_char	     ; get first char of current line
SYSINIT:437F		     jb	     short swchk_end ; hit eof
SYSINIT:4381		     cmp     al, 5Bh ; '['
SYSINIT:4383		     jnz     short swchk_next1
SYSINIT:4385		     inc     bx		     ; remember	that we've seen a block
SYSINIT:4386		     jmp     short swchk_nextline
SYSINIT:4388 ; ---------------------------------------------------------------------------
SYSINIT:4388
SYSINIT:4388 swchk_next1:			     ; ...
SYSINIT:4388		     cmp     al, 4Eh ; 'N'   ; CONFIG_NUMLOCK
SYSINIT:438A		     jnz     short swchk_next2
SYSINIT:438C		     or	     bx, bx	     ; only do NUMLOCK commands	that exist
SYSINIT:438E		     jnz     short swchk_nextline ; before the first block
SYSINIT:4390		     call    set_numlock     ; REM it out so we	don't act on it later, too
SYSINIT:4393		     mov     byte ptr es:[si-1], 30h ; '0' ; CONFIG_REM
SYSINIT:4398		     jmp     short swchk_nextline
SYSINIT:439A ; ---------------------------------------------------------------------------
SYSINIT:439A
SYSINIT:439A swchk_next2:			     ; ...
SYSINIT:439A		     cmp     al, 31h ; '1'   ; CONFIG_SWITCHES
SYSINIT:439C		     jnz     short swchk_nextline ; this line ain't it
SYSINIT:439E
SYSINIT:439E swchk_scan:			     ; ...
SYSINIT:439E		     call    get_char	     ; look for	/N or /F
SYSINIT:43A1
SYSINIT:43A1 swchk_scan1:			     ; ...
SYSINIT:43A1		     cmp     al, 0Ah	     ; LF ; end	of line	?
SYSINIT:43A3		     jz	     short swchk_nextline
SYSINIT:43A5		     cmp     al, 2Fh ; '/'   ; switch-char?
SYSINIT:43A7		     jnz     short swchk_scan ;	no
SYSINIT:43A9		     call    get_char
SYSINIT:43AC		     and     al, 0DFh	     ; ~20h ; convert to upper case
SYSINIT:43AE		     cmp     al, byte ptr ds:swit_n+1
SYSINIT:43B2		     jnz     short swchk_scan2 ; no
SYSINIT:43B4		     or	     ds:bDisableUI, 1
SYSINIT:43B9		     jmp     short swchk_scan ;	continue looking for switches of interest
SYSINIT:43BB ; ---------------------------------------------------------------------------
SYSINIT:43BB
SYSINIT:43BB swchk_scan2:			     ; ...
SYSINIT:43BB		     cmp     al, byte ptr ds:swit_f+1
SYSINIT:43BF		     jnz     short swchk_scan1 ; no
SYSINIT:43C1		     or	     ds:bDisableUI, 2
SYSINIT:43C6		     jmp     short swchk_scan ;	continue looking for switches of interest
SYSINIT:43C8 ; ---------------------------------------------------------------------------
SYSINIT:43C8
SYSINIT:43C8 swchk_nextline:			     ; ...
SYSINIT:43C8		     call    skip_opt_line
SYSINIT:43CB		     jmp     short swchk_loop
SYSINIT:43CD ; ---------------------------------------------------------------------------
SYSINIT:43CD
SYSINIT:43CD swchk_end:				     ; ...
SYSINIT:43CD		     pop     si
SYSINIT:43CE		     pop     cx		     ;
SYSINIT:43CE					     ; Do the keyboard tests for clean/interactive boot	now,
SYSINIT:43CE					     ; but only	if the DisableUI flag is still clear
SYSINIT:43CF		     test    ds:bDisableUI, 1
SYSINIT:43D4		     jnz     short menu_search ;
SYSINIT:43D4					     ; Wait for	2 seconds first,
SYSINIT:43D4					     ; UNLESS the /F bit was set in bDisableUI,	or
SYSINIT:43D4					     ; there is	anything at all	in the keyboard	buffer
SYSINIT:43D6		     call    kbd_read
SYSINIT:43D9		     jnb     short menu_search
SYSINIT:43DB		     jmp     menu_abort
SYSINIT:43DE ; ---------------------------------------------------------------------------
SYSINIT:43DE
SYSINIT:43DE menu_search:			     ; ...
SYSINIT:43DE		     sub     bx, bx	     ; Search for MENU block;
SYSINIT:43DE					     ; it is allowed to	be anywhere in config.sys
SYSINIT:43E0		     mov     di, offset	szMenu ; "MENU"
SYSINIT:43E3		     call    find_block	     ; find the	MENU block
SYSINIT:43E3					     ; if no MENU, default to zero for no_selection
SYSINIT:43E6		     jnb     short menu_found
SYSINIT:43E8		     mov     byte ptr ds:szBoot, 0 ; "CONFIG="
SYSINIT:43ED		     jmp     no_selection    ; not found
SYSINIT:43F0 ; ---------------------------------------------------------------------------
SYSINIT:43F0
SYSINIT:43F0 menu_color:			     ; ...
SYSINIT:43F0		     push    cx		     ; Process the requested menu color(s)
SYSINIT:43F1		     push    dx
SYSINIT:43F2		     mov     dx, 7	     ; default color setting
SYSINIT:43F5		     call    get_number	     ; get first number
SYSINIT:43F8		     and     bl, 0Fh	     ; first # is foreground color (for	low nibble)
SYSINIT:43FB		     mov     ch, bl	     ; save it in CH
SYSINIT:43FD		     and     dl, 0F0h
SYSINIT:4400		     or	     dl, bl
SYSINIT:4402		     call    delim	     ; did we hit a delimiter
SYSINIT:4405		     jnz     short check_color ; no, all done
SYSINIT:4407		     call    get_number	     ; get next	number
SYSINIT:440A		     and     bl, 0Fh	     ; second #	is background color (for high nibble)
SYSINIT:440D		     mov     dh, bl	     ; save it in DH
SYSINIT:440F		     and     dl, 0Fh
SYSINIT:4412		     mov     cl, 4
SYSINIT:4414		     shl     bl, cl
SYSINIT:4416		     or	     dl, bl
SYSINIT:4418
SYSINIT:4418 check_color:			     ; ...
SYSINIT:4418		     cmp     ch, dh	     ; are foreground/background the same?
SYSINIT:441A		     jnz     short set_color ; no
SYSINIT:441C		     xor     dl, 8	     ; yes, so modify the fgnd intensity
SYSINIT:441F
SYSINIT:441F set_color:				     ; ...
SYSINIT:441F		     mov     ds:bMenuColor, dl
SYSINIT:4423		     pop     dx
SYSINIT:4424		     pop     cx
SYSINIT:4425		     jmp     menu_nextitem
SYSINIT:4428 ; ---------------------------------------------------------------------------
SYSINIT:4428
SYSINIT:4428 menu_found:			     ; ...
SYSINIT:4428		     mov     ds:bDefBlock, 1
SYSINIT:442D		     mov     ds:offDefBlock, 0
SYSINIT:4433		     mov     ds:secTimeOut, 0FFh ; -1
SYSINIT:4438		     and     ds:bQueryOpt, 0FDh	; ~2
SYSINIT:443D		     call    skip_opt_line   ; skip to next line
SYSINIT:4440		     sub     dx, dx	     ; initialize total	block count (0 => none yet)
SYSINIT:4442
SYSINIT:4442 menu_process:			     ; ...
SYSINIT:4442		     call    get_char	     ; get first char of current line
SYSINIT:4445		     jb	     short to_menu_getdefault ;	could happen if	menu block at end (rare)
SYSINIT:4447		     and     al, 7Fh	     ; ~CONFIG_OPTION_QUERY
SYSINIT:4449		     cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
SYSINIT:444B		     jz	     short to_menu_getdefault ;	BEGIN implies END
SYSINIT:444D		     cmp     al, 4Fh ; 'O'   ; CONFIG_SUBMENU
SYSINIT:444F		     jz	     short menu_item ; go process sub-menu
SYSINIT:4451		     cmp     al, 45h ; 'E'   ; CONFIG_MENUITEM
SYSINIT:4453		     jz	     short menu_item ; go process menu item
SYSINIT:4455		     cmp     al, 41h ; 'A'   ; CONFIG_MENUDEFAULT
SYSINIT:4457		     jz	     short menu_default	; go process menu default
SYSINIT:4459		     cmp     al, 52h ; 'R'   ; CONFIG_MENUCOLOR
SYSINIT:445B		     jz	     short menu_color ;	go process menu	color
SYSINIT:445D		     cmp     al, 4Eh ; 'N'   ; CONFIG_NUMLOCK
SYSINIT:445F		     jz	     short menu_numlock
SYSINIT:4461		     cmp     al, 30h ; '0'   ; CONFIG_REM
SYSINIT:4463		     jz	     short menu_nextitem ; allow remarks in menu block
SYSINIT:4465		     call    any_delim	     ; allow blank lines and such
SYSINIT:4468		     jz	     short menu_nextitem
SYSINIT:446A		     stc
SYSINIT:446B		     call    print_error     ; non-MENU	command!
SYSINIT:446E		     jmp     short menu_nextitem
SYSINIT:4470 ; ---------------------------------------------------------------------------
SYSINIT:4470
SYSINIT:4470 menu_numlock:			     ; ...
SYSINIT:4470		     call    set_numlock
SYSINIT:4473		     jmp     short menu_nextitem
SYSINIT:4475 ; ---------------------------------------------------------------------------
SYSINIT:4475
SYSINIT:4475 to_menu_getdefault:		     ; ...
SYSINIT:4475		     jmp     short menu_getdefault
SYSINIT:4477 ; ---------------------------------------------------------------------------
SYSINIT:4477
SYSINIT:4477 menu_default:			     ; ...
SYSINIT:4477		     mov     ds:offDefBlock, si	; save address of default block	name
SYSINIT:447B		     cmp     ds:secElapsed, 0
SYSINIT:4480		     jnz     short timeout_skip	; secElapsed is	only zero for the FIRST	menu,
SYSINIT:4482		     call    skip_token	     ; and for subsequent menus	IF nothing was typed;
SYSINIT:4485		     jb	     short menu_nextitem ; secElapsed becomes -1 forever as soon as
SYSINIT:4487		     call    skip_delim	     ; something is typed
SYSINIT:448A		     jb	     short menu_nextitem
SYSINIT:448C		     mov     si, bx
SYSINIT:448E		     call    get_number	     ; get number (of seconds for timeout)
SYSINIT:4491		     cmp     bl, 90	     ; limit it	to a reasonable	number
SYSINIT:4494		     jb	     short timeout_ok ;	(besides, 99 is	the largest # my simple
SYSINIT:4496		     mov     bl, 90	     ; display function	can handle)
SYSINIT:4498
SYSINIT:4498 timeout_ok:			     ; ...
SYSINIT:4498		     mov     ds:secTimeOut, bl
SYSINIT:449C
SYSINIT:449C timeout_skip:			     ; ...
SYSINIT:449C		     jmp     short menu_nextitem
SYSINIT:449E ; ---------------------------------------------------------------------------
SYSINIT:449E
SYSINIT:449E menu_item:				     ; ...
SYSINIT:449E		     cmp     dl, 9	     ; MAX_MULTI_CONFIG
SYSINIT:449E					     ; have we reached the max # of items yet?
SYSINIT:44A1		     jnb     short menu_nextitem
SYSINIT:44A3		     mov     di, si	     ; DS:DI ->	block name to search for
SYSINIT:44A5		     call    srch_block
SYSINIT:44A8		     jz	     short menu_itemfound ; srch_block,	having succeeded,
SYSINIT:44A8					     ; returns DI -> past the token that it just matched,
SYSINIT:44A8					     ; which in	this case should be a descriptive string;
SYSINIT:44A8					     ; ES:SI and CX are	unmodified
SYSINIT:44AA		     stc
SYSINIT:44AB		     call    print_error     ; print error and pause
SYSINIT:44AE		     jmp     short menu_nextitem ; if not found, ignore	this menu item
SYSINIT:44B0 ; ---------------------------------------------------------------------------
SYSINIT:44B0
SYSINIT:44B0 menu_itemfound:			     ; ...
SYSINIT:44B0		     inc     dx		     ; otherwise, increment total block	count
SYSINIT:44B1		     mov     bx, dx	     ; and use it to index the arrays of offsets
SYSINIT:44B3		     mov     ds:abBlockType[bx], al
SYSINIT:44B7		     add     bx, bx	     ; of recorded block names and descriptions
SYSINIT:44B9		     mov     ds:aoffBlockName[bx], si ;
SYSINIT:44B9					     ; There should be a description immediately following
SYSINIT:44B9					     ; the block name on MENUITEM line;	failing	that,
SYSINIT:44B9					     ; we'll just use the block name as the description...
SYSINIT:44BD		     mov     ds:aoffBlockDesc[bx], si
SYSINIT:44C1		     mov     di, bx	     ; skip_delim modifies BX, so stash	it in DI
SYSINIT:44C3		     call    skip_token
SYSINIT:44C6		     jb	     short menu_nextitem ; hit eol/eof
SYSINIT:44C8		     call    skip_delim
SYSINIT:44CB		     jb	     short menu_nextitem ; hit eol/eof
SYSINIT:44CD		     xchg    bx, di
SYSINIT:44CF		     mov     ds:aoffBlockDesc[bx], di
SYSINIT:44D3
SYSINIT:44D3 menu_nextitem:			     ; ...
SYSINIT:44D3		     call    skip_opt_line
SYSINIT:44D6		     jmp     menu_process    ; go back for more	lines
SYSINIT:44D9 ; ---------------------------------------------------------------------------
SYSINIT:44D9
SYSINIT:44D9 menu_getdefault:			     ; ...
SYSINIT:44D9		     or	     dl, dl	     ; Display menu items now,
SYSINIT:44D9					     ; after determining which one is default
SYSINIT:44D9					     ;
SYSINIT:44D9					     ; where there any valid blocks at all?
SYSINIT:44DB		     jnz     short menu_valid ;	yes
SYSINIT:44DD		     sub     bx, bx	     ; no, so force autoselect of 0
SYSINIT:44DF		     jmp     menu_autoselect ; (meaning: process common	blocks only)
SYSINIT:44E2 ; ---------------------------------------------------------------------------
SYSINIT:44E2
SYSINIT:44E2 menu_valid:			     ; ...
SYSINIT:44E2		     sub     bx, bx
SYSINIT:44E4		     mov     ds:bMaxBlock, dl ;	first, record how many blocks we found
SYSINIT:44E8		     mov     di, ds:offDefBlock
SYSINIT:44EC		     or	     di, di	     ;	does a default block exist?
SYSINIT:44EE		     jz	     short menu_nodefault ; no
SYSINIT:44F0		     inc     bx		     ; yes, walk name table, looking for default
SYSINIT:44F1
SYSINIT:44F1 menu_chkdefault:			     ; ...
SYSINIT:44F1		     push    bx
SYSINIT:44F2		     add     bx, bx
SYSINIT:44F4		     mov     si, ds:aoffBlockName[bx]
SYSINIT:44F8		     mov     cx, 128	     ; arbitrary maximum length	of a name
SYSINIT:44FB		     push    ds
SYSINIT:44FC		     push    es
SYSINIT:44FD		     pop     ds
SYSINIT:44FE		     call    comp_names	     ; is this block the same as the default?
SYSINIT:4501		     pop     ds
SYSINIT:4502		     pop     bx
SYSINIT:4503		     jz	     short menu_setdefault ; yes
SYSINIT:4505		     inc     bx
SYSINIT:4506		     cmp     bl, ds:bMaxBlock ;	all done searching?
SYSINIT:450A		     jbe     short menu_chkdefault ; not yet
SYSINIT:450C
SYSINIT:450C menu_nodefault:			     ; ...
SYSINIT:450C		     mov     bl, 1	     ; if no default, force default to #1
SYSINIT:450E
SYSINIT:450E menu_setdefault:			     ; ...
SYSINIT:450E		     mov     ds:bDefBlock, bl ;	yes, this will be the initial current block
SYSINIT:450E					     ;
SYSINIT:450E					     ; If the timeout was explicitly set to 0 (or technically,
SYSINIT:450E					     ; anything	that failed to resolve to a number, like "NONE"
SYSINIT:450E					     ; or "EAT POTATOES"), then	we're supposed to skip menu display
SYSINIT:450E					     ; and run with the	specified default block; however,
SYSINIT:450E					     ; if the user hit Enter prior to boot, thereby requesting fully
SYSINIT:450E					     ; INTERACTIVE boot, then we shall display the menu	block anyway
SYSINIT:450E					     ; (though still with no timeout)
SYSINIT:4512		     cmp     ds:secTimeOut, 0 ;	is timeout zero? (ie, assume default)
SYSINIT:4517		     jnz     short menu_display	; no
SYSINIT:4519		     test    ds:bQueryOpt, 1 ; yes, but	was INTERACTIVE	requested?
SYSINIT:451E		     jnz     short menu_display	; yes, so *don't* assume default after all
SYSINIT:4520		     jmp     not_topmenu
SYSINIT:4523 ; ---------------------------------------------------------------------------
SYSINIT:4523
SYSINIT:4523 menu_display:			     ; ...
SYSINIT:4523		     mov     ah, 0Fh	     ; Reset the mode,
SYSINIT:4523					     ; so that we know screen is clean and cursor is home
SYSINIT:4523					     ; ;
SYSINIT:4525		     int     10h	     ; - VIDEO - GET CURRENT VIDEO MODE
SYSINIT:4525					     ; Return: AH = number of columns on screen
SYSINIT:4525					     ; AL = current video mode
SYSINIT:4525					     ; BH = current active display page
SYSINIT:4527		     mov     ah, 0
SYSINIT:4529		     int     10h	     ; - VIDEO - SET VIDEO MODE
SYSINIT:4529					     ; AL = mode
SYSINIT:452B		     push    es
SYSINIT:452C		     mov     ax, 40h	     ; reach down into the ROM BIOS data area
SYSINIT:452F		     mov     es, ax	     ; and save	the current (default) video page
SYSINIT:4531		     assume es:nothing
SYSINIT:4531		     mov     ax, es:4Eh	     ; start address and page #, in case the
SYSINIT:4535		     mov     ds:wCRTStart, ax ;	undocumented QUIET option was enabled
SYSINIT:4538		     mov     al, es:62h
SYSINIT:453C		     mov     ds:bCRTPage, al
SYSINIT:453F		     mov     ax, word ptr ds:bMenuPage ; select	new page for menu
SYSINIT:4542		     int     10h	     ; - VIDEO -
SYSINIT:4544		     mov     ax, 600h	     ; clear entire screen
SYSINIT:4547		     mov     bh, ds:bMenuColor ; using this color
SYSINIT:454B		     sub     cx, cx	     ; upper left row/col
SYSINIT:454D		     mov     dl, es:4Ah	     ; [es:CRT_Cols]
SYSINIT:4552		     dec     dl
SYSINIT:4554		     mov     dh, es:84h	     ; [es:CRT_Rows]
SYSINIT:4559		     or	     dh, dh	     ; # of rows valid?
SYSINIT:455B		     jnz     short menu_clear ;	hopefully
SYSINIT:455D		     mov     dh, ds:bLastRow ; no, use a default
SYSINIT:4561
SYSINIT:4561 menu_clear:			     ; ...
SYSINIT:4561		     int     10h	     ; clear the screen	using the req. attribute
SYSINIT:4561					     ;
SYSINIT:4561					     ; - VIDEO - SCROLL	PAGE UP
SYSINIT:4561					     ; AL = number of lines to scroll window (0	= blank	whole window)
SYSINIT:4561					     ; BH = attributes to be used on blanked lines
SYSINIT:4561					     ; CH,CL = row,column of upper left	corner of window to scroll
SYSINIT:4561					     ; DH,DL = row,column of lower right corner	of window
SYSINIT:4563		     pop     es
SYSINIT:4564		     assume es:nothing
SYSINIT:4564		     mov     ds:bLastRow, dh ; save DH
SYSINIT:4568		     mov     dx, offset	_$MenuHeader ; "\r\n  MS-DOS 6.2 Startup Menu\r\n"
SYSINIT:456B		     call    print	     ; cursor now on row 3 (numbered from 0)
SYSINIT:456E		     test    ds:bDisableUI, 1
SYSINIT:4573		     jnz     short menu_nostatus
SYSINIT:4575		     mov     bh, ds:bMenuPage
SYSINIT:4579		     mov     dh, ds:bLastRow ; restore DH
SYSINIT:457D		     mov     dl, 0	     ; print the status	line on	row DH,	col 0
SYSINIT:457F		     mov     ah, 2	     ; now that	we can trash the cursor	position
SYSINIT:4581		     int     10h	     ; - VIDEO - SET CURSOR POSITION
SYSINIT:4581					     ; DH,DL = row, column (0,0	= upper	left)
SYSINIT:4581					     ; BH = page number
SYSINIT:4583		     mov     dx, offset	_$StatusLine ; "F5=Bypass startup files	F8=Confirm each"...
SYSINIT:4586		     call    print
SYSINIT:4589		     mov     ah, 3	     ; get cursor position
SYSINIT:458B		     int     10h	     ; - VIDEO - READ CURSOR POSITION
SYSINIT:458B					     ; BH = page number
SYSINIT:458B					     ; Return: DH,DL = row,column, CH =	cursor start line, CL =	cursor end line
SYSINIT:458D		     sub     dl, 2
SYSINIT:4590		     mov     ds:bLastCol, dl ; save column where status	char will go
SYSINIT:4594
SYSINIT:4594 menu_nostatus:			     ; ...
SYSINIT:4594		     mov     bx, 1	     ; now prepare to display all the menu items
SYSINIT:4597
SYSINIT:4597 menu_disploop:			     ; ...
SYSINIT:4597		     call    print_item	     ; print item #BL
SYSINIT:459A		     inc     bx		     ; why "inc	bx"? because it's a 1-byte opcode
SYSINIT:459B		     cmp     bl, ds:bMaxBlock ;	all done?
SYSINIT:459F		     jbe     short menu_disploop ; not yet
SYSINIT:45A1		     mov     dl, 0	     ; Set cursor position to just below the menu items
SYSINIT:45A1					     ; column 0
SYSINIT:45A3		     mov     dh, bl
SYSINIT:45A5		     add     dh, 4	     ; select row below	menu
SYSINIT:45A8		     mov     bh, ds:bMenuPage
SYSINIT:45AC		     mov     ah, 2	     ; set cursor position beneath the block list
SYSINIT:45AE		     int     10h	     ; - VIDEO - SET CURSOR POSITION
SYSINIT:45AE					     ; DH,DL = row, column (0,0	= upper	left)
SYSINIT:45AE					     ; BH = page number
SYSINIT:45B0		     mov     dx, offset	_$MenuPrmpt ; "	 Enter a choice: $"
SYSINIT:45B3		     call    print
SYSINIT:45B6		     call    select_item     ; make a selection, return	# in BX
SYSINIT:45B9		     mov     dx, offset	crlfm ;	"\r\n$"
SYSINIT:45BC		     call    print
SYSINIT:45BF		     push    word ptr ds:bDisableUI
SYSINIT:45C3		     or	     ds:bDisableUI, 1
SYSINIT:45C8		     call    show_status     ; clear the status	line now
SYSINIT:45CB		     pop     word ptr ds:bDisableUI ;
SYSINIT:45CB					     ; Now begins the "re-organization"	process...
SYSINIT:45CF
SYSINIT:45CF menu_autoselect:			     ; ...
SYSINIT:45CF		     cmp     bx, 0FFFFh	     ; -1 ; clean boot requested?
SYSINIT:45D2		     jnz     short normal_boot ; no
SYSINIT:45D4		     call    disable_autoexec
SYSINIT:45D7
SYSINIT:45D7 menu_abort:			     ; ...
SYSINIT:45D7		     sub     cx, cx
SYSINIT:45D9		     jmp     menu_exit
SYSINIT:45DC ; ---------------------------------------------------------------------------
SYSINIT:45DC
SYSINIT:45DC normal_boot:			     ; ...
SYSINIT:45DC		     cmp     bx, 0FFFEh	     ; -2 ; back to top-level menu?
SYSINIT:45DF		     jnz     short not_topmenu
SYSINIT:45E1		     mov     cx, ds:count    ; yes, start all over
SYSINIT:45E5		     sub     si, si
SYSINIT:45E7		     jmp     menu_search
SYSINIT:45EA ; ---------------------------------------------------------------------------
SYSINIT:45EA
SYSINIT:45EA not_topmenu:			     ; ...
SYSINIT:45EA		     cmp     ds:abBlockType[bx], 4Fh ; CONFIG_SUBMENU
SYSINIT:45EF		     jnz     short not_submenu
SYSINIT:45F1		     add     bx, bx
SYSINIT:45F3		     mov     di, ds:aoffBlockName[bx]
SYSINIT:45F7		     call    srch_block	     ; THIS CANNOT FAIL!
SYSINIT:45FA		     mov     si, di
SYSINIT:45FC		     mov     cx, bx	     ; ES:SI and CX are	ready for another round
SYSINIT:45FE		     jmp     menu_found
SYSINIT:4601 ; ---------------------------------------------------------------------------
SYSINIT:4601
SYSINIT:4601 not_submenu:			     ; ...
SYSINIT:4601		     add     bx, bx	     ; get BX -> name of selected block
SYSINIT:4603		     mov     bx, ds:aoffBlockName[bx] ;
SYSINIT:4603					     ; BX should now either be ZERO
SYSINIT:4603					     ; (meaning	no block has been selected) or the offset
SYSINIT:4603					     ; relative	to ES of the block name	to be processed
SYSINIT:4603					     ; (along with all the "common" lines of course)
SYSINIT:4607
SYSINIT:4607 no_selection:			     ; ...
SYSINIT:4607		     mov     ds:offDefBlock, bx	; save selection
SYSINIT:460B		     mov     cx, ds:count    ; reset ES:SI and CX for reprocessing
SYSINIT:460F		     sub     si, si
SYSINIT:4611		     push    ds
SYSINIT:4612		     mov     ds, ds:config_wrkseg ; this is where we'll store new config.sys image
SYSINIT:4616		     sub     di, di	     ;
SYSINIT:4616					     ; ES:SI-> config.sys, DS:DI -> new	config.sys workspace
SYSINIT:4616					     ;
SYSINIT:4616					     ; Work our	way through the	config.sys image again,	this time copying
SYSINIT:4616					     ; all lines that are (A) "common" lines outside any block or (B) lines
SYSINIT:4616					     ; within the requested block. Lines inside	INCLUDEd blocks	are
SYSINIT:4616					     ; transparently copied by copy_block in a recursive fashion;
SYSINIT:4616					     ; the amount of recursion is limited by the fact INCLUDE statements are
SYSINIT:4616					     ; REMed by	copy_block as they are processed and by	the number of unique
SYSINIT:4616					     ; INCLUDE stmts in	config.sys...
SYSINIT:4618
SYSINIT:4618 copyblock_loop:			     ; ...
SYSINIT:4618		     push    bx		     ; save selected block name
SYSINIT:4619		     call    copy_block	     ; process (named or common) block
SYSINIT:461C		     pop     bx
SYSINIT:461D		     jb	     short move_config
SYSINIT:461F
SYSINIT:461F copyblock_begin:			     ; ...
SYSINIT:461F		     push    ax		     ; copy_block can only return for two reasons:
SYSINIT:461F					     ;	it hit eof or a	new block
SYSINIT:4620		     push    cx
SYSINIT:4621		     push    si
SYSINIT:4622		     push    di		     ; always do "common" blocks
SYSINIT:4623		     mov     di, offset	szCommon ; "COMMON"
SYSINIT:4626		     push    ds
SYSINIT:4627		     push    cs
SYSINIT:4628		     pop     ds
SYSINIT:4629		     assume ds:SYSINIT
SYSINIT:4629		     call    comp_names
SYSINIT:462C		     pop     ds
SYSINIT:462D		     assume ds:nothing
SYSINIT:462D		     pop     di
SYSINIT:462E		     pop     si
SYSINIT:462F		     pop     cx
SYSINIT:4630		     pop     ax
SYSINIT:4631		     jz	     short copyblock_check
SYSINIT:4633		     or	     bx, bx	     ; is there	a block	name to	check?
SYSINIT:4635		     jz	     short copyblock_skip ; no
SYSINIT:4637		     push    di
SYSINIT:4638		     mov     di, bx	     ; check block against given block name
SYSINIT:463A		     push    ds
SYSINIT:463B		     push    es
SYSINIT:463C		     pop     ds
SYSINIT:463D		     call    comp_names	     ; is this the block we really want	to do?
SYSINIT:4640		     pop     ds
SYSINIT:4641		     pop     di
SYSINIT:4642
SYSINIT:4642 copyblock_check:			     ; ...
SYSINIT:4642		     jb	     short move_config ; hit eof
SYSINIT:4644		     jnz     short copyblock_skip
SYSINIT:4646		     call    skip_opt_line
SYSINIT:4649		     jmp     short copyblock_loop
SYSINIT:464B ; ---------------------------------------------------------------------------
SYSINIT:464B
SYSINIT:464B copyblock_skip:			     ; ...
SYSINIT:464B		     call    skip_opt_line   ; this ain't the block we wanted, so skip it
SYSINIT:464E		     call    get_char
SYSINIT:4651		     jb	     short move_config ; hit eof
SYSINIT:4653		     and     al, 7Fh	     ; ~CONFIG_OPTION_QUERY
SYSINIT:4655		     cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
SYSINIT:4657		     jz	     short copyblock_begin
SYSINIT:4659		     jmp     short copyblock_skip ; anything else is just skipped
SYSINIT:465B ; ---------------------------------------------------------------------------
SYSINIT:465B
SYSINIT:465B move_config:			     ; ...
SYSINIT:465B		     mov     cx, di	     ; To create as little risk	to the rest of SysInit
SYSINIT:465B					     ; as little as possible, and to free the workspace
SYSINIT:465B					     ; at "config_wrkseg" for creating an environment,
SYSINIT:465B					     ; copy the	new config.sys image to	"confbot".
SYSINIT:465B					     ;
SYSINIT:465B					     ; now copy	workspace at DS:DI to "confbot"
SYSINIT:465D		     push    cx		     ;
SYSINIT:465D					     ; But first, copy the CONFIG=<configuration><0> string
SYSINIT:465D					     ; to the workspace, since the configuration name only
SYSINIT:465D					     ; currently exists	in the "confbot" area.
SYSINIT:465D					     ; ;
SYSINIT:465E		     mov     cx, 7	     ; szMenu-szBoot-1
SYSINIT:465E					     ; first copy the CONFIG= part
SYSINIT:4661		     mov     si, offset	szBoot ; "CONFIG="
SYSINIT:4664		     inc     di		     ; skip a byte, in case absolutely nothing
SYSINIT:4664					     ; was copied to the workspace, because we always
SYSINIT:4664					     ; zero the	first byte of the workspace (below)
SYSINIT:4665
SYSINIT:4665 copy_boot:				     ; ...
SYSINIT:4665		     lods    byte ptr cs:[si]
SYSINIT:4667		     mov     [di], al
SYSINIT:4669		     inc     di
SYSINIT:466A		     loop    copy_boot
SYSINIT:466C		     push    es		     ; then copy the configuration name
SYSINIT:466D		     mov     cx, 121	     ; 128-7 ; put an upper limit on the name, to be safe
SYSINIT:4670		     mov     si, cs:offDefBlock	; ES:SI	-> default block name
SYSINIT:4675		     or	     si, si	     ; valid?
SYSINIT:4677		     jnz     short l1	     ; yes
SYSINIT:4679		     push    cs
SYSINIT:467A		     pop     es
SYSINIT:467B		     assume es:SYSINIT
SYSINIT:467B		     mov     si, offset	szCommon ; "COMMON"
SYSINIT:467E
SYSINIT:467E l1:				     ; ...
SYSINIT:467E		     mov     al, es:[si]
SYSINIT:4681		     call    any_delim
SYSINIT:4684		     jz	     short l2
SYSINIT:4686		     mov     [di], al
SYSINIT:4688		     inc     si
SYSINIT:4689		     inc     di
SYSINIT:468A		     loop    l1
SYSINIT:468C
SYSINIT:468C l2:				     ; ...
SYSINIT:468C		     mov     byte ptr [di], 0Ah	; terminate the	configuration string
SYSINIT:468F		     pop     es
SYSINIT:4690		     assume es:nothing
SYSINIT:4690		     sub     di, di	     ; Now we can copy "config_wrkseg" (DS) to "confbot" (ES)
SYSINIT:4692		     mov     cs:config_envlen, di
SYSINIT:4697		     sub     si, si
SYSINIT:4699		     pop     cx		     ; recover the size	of "config_wrkseg"
SYSINIT:469A		     push    cx
SYSINIT:469B		     rep movsb		     ; moved!
SYSINIT:469D		     pop     cx
SYSINIT:469E		     mov     ax, ds
SYSINIT:46A0		     pop     ds		     ; Now that	the config_wrkseg is available once again,
SYSINIT:46A0					     ; we shall	use it to create an environment. The first
SYSINIT:46A0					     ; thing to	go in will be the "CONFIG=configuration" thing.
SYSINIT:46A0					     ; It is also important to zero the	first byte of the workspace,
SYSINIT:46A0					     ; so that copy_envvar knows the buffer is empty.
SYSINIT:46A1		     push    es
SYSINIT:46A2		     mov     es, ax
SYSINIT:46A4		     inc     si		     ; ES:SI ->	"CONFIG=configuration"
SYSINIT:46A5		     mov     byte ptr es:0, 0 ;	empty the environment block
SYSINIT:46AB		     call    copy_envvar     ; copy envvar at ES:SI to "config_wrkseg"
SYSINIT:46AE		     pop     es		     ;
SYSINIT:46AE					     ; Before returning, restore the default video page	setting
SYSINIT:46AE					     ; but do NOT do it	using INT 10h's Set Active Page function,
SYSINIT:46AE					     ; because if the menu was displayed on a different	page,
SYSINIT:46AE					     ; then it's because we don't want to see all the device
SYSINIT:46AE					     ; driver/TSR goop (which goes to the default page)
SYSINIT:46AF		     cmp     ds:bMenuPage, 0
SYSINIT:46B4		     jz	     short menu_exit
SYSINIT:46B6		     push    es
SYSINIT:46B7		     mov     ax, 40h
SYSINIT:46BA		     mov     es, ax
SYSINIT:46BC		     assume es:nothing
SYSINIT:46BC		     mov     ax, ds:wCRTStart
SYSINIT:46BF		     mov     es:4Eh, ax
SYSINIT:46C3		     mov     al, ds:bCRTPage
SYSINIT:46C6		     mov     es:62h, al
SYSINIT:46CA		     pop     es
SYSINIT:46CB		     assume es:nothing
SYSINIT:46CB
SYSINIT:46CB menu_exit:				     ; ...
SYSINIT:46CB		     mov     ds:count, cx
SYSINIT:46CF		     mov     ds:org_count, cx
SYSINIT:46D3		     retn
SYSINIT:46D3 menu_check	     endp
SYSINIT:46D3
SYSINIT:46D4
SYSINIT:46D4 ; =============== S U B R O U T I N E =======================================
SYSINIT:46D4
SYSINIT:46D4
SYSINIT:46D4 copy_envvar     proc near		     ; ...
SYSINIT:46D4		     push    cx		     ; copy the	envvar at ES:SI	to "config_wrkseg"
SYSINIT:46D4					     ; ES:SI ->	environment variable
SYSINIT:46D4					     ;		(in the	form "var=string<cr/lf>")
SYSINIT:46D5		     push    si
SYSINIT:46D6		     push    ds
SYSINIT:46D7		     push    es
SYSINIT:46D8		     push    es
SYSINIT:46D9		     mov     es, ds:config_wrkseg ; ES:DI to point to next available byte
SYSINIT:46DD		     pop     ds		     ; DS:SI to	point to envvar
SYSINIT:46DE		     sub     cx, cx
SYSINIT:46E0
SYSINIT:46E0 copy_varlen:			     ; ...
SYSINIT:46E0		     lodsb
SYSINIT:46E1		     or	     al, al	     ; NULL?
SYSINIT:46E3		     stc
SYSINIT:46E4		     jz	     short copy_envexit	; yes, abort
SYSINIT:46E6		     cmp     al, 0Dh	     ; cr
SYSINIT:46E8		     stc
SYSINIT:46E9		     jz	     short copy_envexit
SYSINIT:46EB		     cmp     al, 0Ah	     ; lf
SYSINIT:46ED		     stc
SYSINIT:46EE		     jz	     short copy_envexit
SYSINIT:46F0		     inc     cx
SYSINIT:46F1		     cmp     al, 3Dh ; '='
SYSINIT:46F3		     jnz     short copy_varlen
SYSINIT:46F5		     mov     al, 0
SYSINIT:46F7		     mov     ah, [si]	     ; save char after '='
SYSINIT:46F9		     sub     si, cx	     ; back up to given	varname
SYSINIT:46FB		     dec     cx		     ; CX == # of bytes	in varname
SYSINIT:46FC		     sub     di, di	     ; start looking for DS:SI at ES:0
SYSINIT:46FE
SYSINIT:46FE copy_varsrch:			     ; ...
SYSINIT:46FE		     cmp     es:[di], al
SYSINIT:4701		     jz	     short copy_envprep	; search failed, just copy var
SYSINIT:4703		     mov     bx, di	     ; ES:BX ->	start of this varname
SYSINIT:4705		     push    cx
SYSINIT:4706		     push    si
SYSINIT:4707		     repe cmpsb
SYSINIT:4709		     pop     si
SYSINIT:470A		     pop     cx
SYSINIT:470B		     jnz     short copy_varnext	; no match, skip to next varname
SYSINIT:470D		     cmp     byte ptr es:[di], '='
SYSINIT:4711		     jnz     short copy_varnext	; no match, there's more characters
SYSINIT:4711					     ;
SYSINIT:4711					     ; Previous	occurrence of variable has been	found;
SYSINIT:4711					     ; determine the entire length and then destroy it
SYSINIT:4713		     mov     cx, 0FFFFh	     ; -1
SYSINIT:4716		     repne scasb	     ; guaranteed to get null (since we	put it there)
SYSINIT:4718		     push    si
SYSINIT:4719		     mov     si, di
SYSINIT:471B		     mov     di, bx
SYSINIT:471D		     mov     cx, cs:config_envlen
SYSINIT:4722		     sub     cx, si	     ; destroy variable	now
SYSINIT:4724		     rep movs byte ptr es:[di],	byte ptr es:[si]
SYSINIT:4727		     pop     si
SYSINIT:4728
SYSINIT:4728 copy_envprep:			     ; ...
SYSINIT:4728		     cmp     ah, 0Dh	     ; if there	is nothing after the '='
SYSINIT:472B		     jz	     short copy_envdel
SYSINIT:472D		     cmp     ah, 0Ah
SYSINIT:4730		     jz	     short copy_envdel
SYSINIT:4732		     jmp     short copy_envloop
SYSINIT:4734 ; ---------------------------------------------------------------------------
SYSINIT:4734
SYSINIT:4734 copy_varnext:			     ; ...
SYSINIT:4734		     push    cx
SYSINIT:4735		     mov     cx, 0FFFFh	     ; -1
SYSINIT:4738		     repne scasb
SYSINIT:473A		     pop     cx
SYSINIT:473B		     jmp     short copy_varsrch
SYSINIT:473D ; ---------------------------------------------------------------------------
SYSINIT:473D
SYSINIT:473D copy_envloop:			     ; ...
SYSINIT:473D		     lodsb
SYSINIT:473E		     cmp     al, 0Dh	     ; cr
SYSINIT:4740		     jz	     short copy_envdone
SYSINIT:4742		     cmp     al, 0Ah	     ; lf
SYSINIT:4744		     jz	     short copy_envdone
SYSINIT:4746		     stosb
SYSINIT:4747		     jmp     short copy_envloop
SYSINIT:4749 ; ---------------------------------------------------------------------------
SYSINIT:4749
SYSINIT:4749 copy_envdone:			     ; ...
SYSINIT:4749		     sub     al, al	     ; do SUB to clear carry as	well
SYSINIT:474B		     stosb		     ; always null-terminate these puppies
SYSINIT:474C
SYSINIT:474C copy_envdel:			     ; ...
SYSINIT:474C		     mov     es:[di], al     ; and stick another null to terminate the env.
SYSINIT:474F		     mov     cs:config_envlen, di
SYSINIT:4754
SYSINIT:4754 copy_envexit:			     ; ...
SYSINIT:4754		     pop     es
SYSINIT:4755		     pop     ds
SYSINIT:4756		     pop     si
SYSINIT:4757		     pop     cx
SYSINIT:4758		     retn
SYSINIT:4758 copy_envvar     endp
SYSINIT:4758
SYSINIT:4759
SYSINIT:4759 ; =============== S U B R O U T I N E =======================================
SYSINIT:4759
SYSINIT:4759
SYSINIT:4759 copy_block	     proc near		     ; ...
SYSINIT:4759		     call    get_char	     ; copy the	current	block to the new config.sys workspace
SYSINIT:4759					     ;
SYSINIT:4759					     ; CX == remaining bytes in	"organized" config.sys memory image
SYSINIT:4759					     ; ES:SI ->	remaining bytes	in "organized" config.sys memory image
SYSINIT:4759					     ; DS:DI ->	new config.sys workspace (equal	in size	to the original
SYSINIT:4759					     ;	      config.sys image)	where the current block	is to be copied
SYSINIT:4759					     ;
SYSINIT:4759					     ; check for include
SYSINIT:475C		     jb	     short copy_done
SYSINIT:475E		     and     al, 7Fh	     ; ~CONFIG_OPTION_QUERY
SYSINIT:4760		     cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
SYSINIT:4760					     ; another BEGIN implies END as well
SYSINIT:4762		     jz	     short copy_done
SYSINIT:4764		     cmp     al, 4Ah ; 'J'   ; CONFIG_INCLUDE ; 'J'
SYSINIT:4766		     mov     al, ah	     ; AL == the original line code
SYSINIT:4768		     jnz     short copy_line ; not an "include"	line
SYSINIT:4768					     ;
SYSINIT:4768					     ; We have hit an "INCLUDE"	line; first, REM out the line
SYSINIT:4768					     ; so that we never	try to include the block again
SYSINIT:4768					     ; (no infinite include loops please), then	search for
SYSINIT:4768					     ; the named block and call	copy_block again.
SYSINIT:476A		     mov     byte ptr es:[si-1], 30h ; '0' ; CONFIG_REM
SYSINIT:476F		     push    di
SYSINIT:4770		     mov     di, offset	szMenu ; "MENU"
SYSINIT:4773		     call    omp_names_safe  ; don't allow INCLUDE MENU
SYSINIT:4776		     jz	     short copy_skip
SYSINIT:4778		     mov     di, offset	szCommon ; "COMMON"
SYSINIT:477B		     call    omp_names_safe  ; don't allow INCLUDE COMMON
SYSINIT:477E		     jz	     short copy_skip
SYSINIT:4780		     mov     di, si	     ; try to find the block
SYSINIT:4782		     call    srch_block
SYSINIT:4785		     mov     dx, di
SYSINIT:4787		     pop     di
SYSINIT:4788		     jnz     short copy_error ;	no such	block
SYSINIT:478A		     push    cx
SYSINIT:478B		     mov     cx, bx
SYSINIT:478D		     push    si
SYSINIT:478E		     dec     dx
SYSINIT:478F		     mov     si, dx
SYSINIT:4791		     call    skip_line	     ; skip the	rest of	the "block name" line
SYSINIT:4794		     call    copy_block	     ; and copy	in the rest of that block
SYSINIT:4797		     pop     si
SYSINIT:4798		     pop     cx
SYSINIT:4799		     sub     al, al	     ; force skip_opt_line to skip...
SYSINIT:479B		     jmp     short copy_nextline
SYSINIT:479D ; ---------------------------------------------------------------------------
SYSINIT:479D
SYSINIT:479D copy_skip:				     ; ...
SYSINIT:479D		     pop     di
SYSINIT:479E
SYSINIT:479E copy_error:			     ; ...
SYSINIT:479E		     clc
SYSINIT:479F		     call    print_error     ; note that carry is clear, no pause
SYSINIT:47A2		     jmp     short copy_nextline
SYSINIT:47A4 ; ---------------------------------------------------------------------------
SYSINIT:47A4
SYSINIT:47A4 copy_line:				     ; ...
SYSINIT:47A4		     mov     [di], al	     ; Copy the	line at	ES:SI
SYSINIT:47A4					     ;	to the current location	at DS:DI
SYSINIT:47A6		     inc     di
SYSINIT:47A7		     cmp     al, 20h ; ' '   ; is this is a "real" line with a "real" code?
SYSINIT:47A9		     jb	     short copy_nextline ; no
SYSINIT:47AB		     cmp     cs:config_multi, 0
SYSINIT:47B1		     jz	     short copy_loop ; not a multi-config config.sys, don't embed #s
SYSINIT:47B3		     call    get_linenum     ; BX == line # of line @ES:SI
SYSINIT:47B6		     mov     [di], bx	     ; stash it	immediately following the line code
SYSINIT:47B8		     inc     di
SYSINIT:47B9		     inc     di
SYSINIT:47BA		     jmp     short copy_next
SYSINIT:47BC ; ---------------------------------------------------------------------------
SYSINIT:47BC
SYSINIT:47BC copy_loop:				     ; ...
SYSINIT:47BC		     call    get_char
SYSINIT:47BF		     jb	     short copy_done ; end of file
SYSINIT:47C1		     mov     [di], al
SYSINIT:47C3		     inc     di
SYSINIT:47C4
SYSINIT:47C4 copy_next:				     ; ...
SYSINIT:47C4		     cmp     al, 0Ah	     ; lf ; done with line?
SYSINIT:47C6		     jnz     short copy_loop ; nope
SYSINIT:47C8
SYSINIT:47C8 copy_nextline:			     ; ...
SYSINIT:47C8		     call    skip_opt_line
SYSINIT:47CB		     jmp     short copy_block
SYSINIT:47CD ; ---------------------------------------------------------------------------
SYSINIT:47CD
SYSINIT:47CD copy_done:				     ; ...
SYSINIT:47CD		     retn
SYSINIT:47CD copy_block	     endp
SYSINIT:47CD
SYSINIT:47CE
SYSINIT:47CE ; =============== S U B R O U T I N E =======================================
SYSINIT:47CE
SYSINIT:47CE
SYSINIT:47CE get_linenum     proc near		     ; ...
SYSINIT:47CE		     push    ax		     ; return line # (in BX) of	current	line (@ES:SI)
SYSINIT:47CF		     sub     bx, bx	     ; BX == line # (to	be returned)
SYSINIT:47D1		     push    cx
SYSINIT:47D2		     mov     dx, si	     ; DX == the offset	we're looking for
SYSINIT:47D4		     push    si
SYSINIT:47D5		     mov     cx, cs:count
SYSINIT:47DA		     sub     si, si	     ; prepare to scan entire file
SYSINIT:47DC
SYSINIT:47DC get_linenum_loop:			     ; ...
SYSINIT:47DC		     call    skip_line
SYSINIT:47DF		     jb	     short get_linenum_done
SYSINIT:47E1		     inc     bx
SYSINIT:47E2		     cmp     si, dx	     ; have we exceeded	the desired offset yet?
SYSINIT:47E4		     jb	     short get_linenum_loop ; no
SYSINIT:47E6
SYSINIT:47E6 get_linenum_done:			     ; ...
SYSINIT:47E6		     pop     si
SYSINIT:47E7		     pop     cx
SYSINIT:47E8		     pop     ax
SYSINIT:47E9		     retn
SYSINIT:47E9 get_linenum     endp
SYSINIT:47E9
SYSINIT:47EA
SYSINIT:47EA ; =============== S U B R O U T I N E =======================================
SYSINIT:47EA
SYSINIT:47EA
SYSINIT:47EA srch_block	     proc near		     ; ...
SYSINIT:47EA		     push    ax		     ; searches	entire config.sys
SYSINIT:47EA					     ; for block name @ES:DI
SYSINIT:47EB		     push    cx
SYSINIT:47EC		     mov     cx, cs:count
SYSINIT:47F1		     push    si
SYSINIT:47F2		     sub     si, si
SYSINIT:47F4		     push    ds
SYSINIT:47F5		     push    es
SYSINIT:47F6		     pop     ds
SYSINIT:47F7		     call    find_block
SYSINIT:47FA		     mov     di, si	     ; ES:DI ->	just past the name in the block	heading, if found
SYSINIT:47FC		     mov     bx, cx	     ; BX == # bytes remaining from that point,	if found
SYSINIT:47FE		     pop     ds
SYSINIT:47FF		     pop     si
SYSINIT:4800		     pop     cx
SYSINIT:4801		     pop     ax
SYSINIT:4802		     retn
SYSINIT:4802 srch_block	     endp
SYSINIT:4802
SYSINIT:4803
SYSINIT:4803 ; =============== S U B R O U T I N E =======================================
SYSINIT:4803
SYSINIT:4803
SYSINIT:4803 find_block	     proc near		     ; ...
SYSINIT:4803		     call    get_char	     ; searches	rest of	config.sys for block name @DS:DI
SYSINIT:4803					     ; get line	code
SYSINIT:4806		     jb	     short find_exit ; end of file
SYSINIT:4808		     and     al, 7Fh	     ; ~CONFIG_OPTION_QUERY
SYSINIT:480A		     cmp     al, 5Bh ; '['   ; CONFIG_BEGIN ; beginning of a block?
SYSINIT:480C		     jz	     short check_line ;	no
SYSINIT:480E		     cmp     al, 4Ah ; 'J'   ; CONFIG_INCLUDE
SYSINIT:4810		     jnz     short next_line
SYSINIT:4812		     or	     cs:config_multi, 1
SYSINIT:4818		     jmp     short next_line
SYSINIT:481A ; ---------------------------------------------------------------------------
SYSINIT:481A
SYSINIT:481A check_line:			     ; ...
SYSINIT:481A		     or	     cs:config_multi, 1
SYSINIT:4820		     call    comp_names	     ; compare block names
SYSINIT:4823		     jbe     short find_exit ; end of file, or names matched
SYSINIT:4825
SYSINIT:4825 next_line:				     ; ...
SYSINIT:4825		     call    skip_opt_line   ; no, so skip to next line
SYSINIT:4828		     jmp     short find_block
SYSINIT:482A ; ---------------------------------------------------------------------------
SYSINIT:482A
SYSINIT:482A find_exit:				     ; ...
SYSINIT:482A		     retn
SYSINIT:482A find_block	     endp
SYSINIT:482A
SYSINIT:482B
SYSINIT:482B ; =============== S U B R O U T I N E =======================================
SYSINIT:482B
SYSINIT:482B
SYSINIT:482B comp_names	     proc near		     ; ...
SYSINIT:482B		     push    di		     ; compares	keyword	@DS:DI
SYSINIT:482B					     ;	to position in config.sys @ES:SI
SYSINIT:482C
SYSINIT:482C comp_loop:				     ; ...
SYSINIT:482C		     call    get_char
SYSINIT:482F		     jb	     short comp_exit
SYSINIT:4831		     call    any_delim	     ; is next character a delimiter?
SYSINIT:4834		     mov     ah, [di]	     ; (get next character we're supposed to match)
SYSINIT:4836		     jz	     short comp_almost ; yes, it *could* be a match
SYSINIT:4838		     inc     di
SYSINIT:4839		     and     ax, 0DFDFh	     ; ~2020h
SYSINIT:483C		     cmp     al, ah	     ; match?
SYSINIT:483E		     jz	     short comp_loop ; yes, keep looking at the	characters
SYSINIT:4840		     clc		     ; prevent erroneous eof indication: clear carry
SYSINIT:4841
SYSINIT:4841 comp_exit:				     ; ...
SYSINIT:4841		     pop     di
SYSINIT:4842		     retn
SYSINIT:4843 ; ---------------------------------------------------------------------------
SYSINIT:4843
SYSINIT:4843 comp_almost:			     ; ...
SYSINIT:4843		     xchg    al, ah	     ; we don't know for sure if it's a match
SYSINIT:4845		     call    any_delim	     ; until we	verify that the	second string
SYSINIT:4848		     xchg    al, ah	     ; has been	exhausted also...
SYSINIT:484A		     jmp     short comp_exit ; if we are, this call to any_delim will tell...
SYSINIT:484A comp_names	     endp
SYSINIT:484A
SYSINIT:484C
SYSINIT:484C ; =============== S U B R O U T I N E =======================================
SYSINIT:484C
SYSINIT:484C
SYSINIT:484C omp_names_safe  proc near		     ; ...
SYSINIT:484C		     push    ax
SYSINIT:484D		     push    cx
SYSINIT:484E		     push    si
SYSINIT:484F		     push    ds
SYSINIT:4850		     push    cs
SYSINIT:4851		     pop     ds
SYSINIT:4852		     assume ds:SYSINIT
SYSINIT:4852		     call    comp_names
SYSINIT:4855		     pop     ds
SYSINIT:4856		     assume ds:nothing
SYSINIT:4856		     pop     si
SYSINIT:4857		     pop     cx
SYSINIT:4858		     pop     ax
SYSINIT:4859		     retn
SYSINIT:4859 omp_names_safe  endp
SYSINIT:4859
SYSINIT:485A
SYSINIT:485A ; =============== S U B R O U T I N E =======================================
SYSINIT:485A
SYSINIT:485A
SYSINIT:485A print_item	     proc near		     ; ...
SYSINIT:485A		     push    ax		     ; display menu item #BL
SYSINIT:485B		     push    bx
SYSINIT:485C		     push    cx
SYSINIT:485D		     push    dx
SYSINIT:485E		     push    si
SYSINIT:485F		     mov     ah, 3	     ; get cursor position
SYSINIT:4861		     mov     bh, ds:bMenuPage ;	always page zero
SYSINIT:4865		     int     10h	     ; - VIDEO - READ CURSOR POSITION
SYSINIT:4865					     ; BH = page number
SYSINIT:4865					     ; Return: DH,DL = row,column, CH =	cursor start line, CL =	cursor end line
SYSINIT:4867		     push    dx
SYSINIT:4868		     mov     ah, 2	     ; set cursor position for correct row/col
SYSINIT:486A		     mov     dh, bl
SYSINIT:486C		     add     dh, 3
SYSINIT:486F		     mov     dl, 5
SYSINIT:4871		     int     10h	     ; - VIDEO - SET CURSOR POSITION
SYSINIT:4871					     ; DH,DL = row, column (0,0	= upper	left)
SYSINIT:4871					     ; BH = page number
SYSINIT:4873		     mov     al, bl
SYSINIT:4875		     add     al, 30h ; '0'   ; convert menu item # to ASCII digit
SYSINIT:4877		     mov     ah, ds:bMenuColor ; normal	attribute
SYSINIT:487B		     cmp     bl, ds:bDefBlock ;	are we printing	the current block?
SYSINIT:487F		     jnz     short print_other
SYSINIT:4881		     or	     ah, 70h	     ; yes, set	bgnd color to white
SYSINIT:4884		     mov     ch, ah
SYSINIT:4886		     mov     cl, 4
SYSINIT:4888		     rol     ch, cl
SYSINIT:488A		     cmp     ch, ah	     ; are fgnd/bgnd the same?
SYSINIT:488C		     jnz     short print_other ; no
SYSINIT:488E		     xor     ah, 8	     ; yes, so modify the fgnd intensity
SYSINIT:4891
SYSINIT:4891 print_other:			     ; ...
SYSINIT:4891		     mov     bh, 0
SYSINIT:4893		     add     bx, bx
SYSINIT:4895		     mov     di, ds:aoffBlockDesc[bx]
SYSINIT:4899		     mov     bl, ah	     ; put the attribute in the	correct	register now
SYSINIT:489B		     mov     bh, ds:bMenuPage
SYSINIT:489F		     mov     ah, 9	     ; write char/attr
SYSINIT:48A1		     mov     cx, 1
SYSINIT:48A4		     int     10h	     ; - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT	CURSOR POSITION
SYSINIT:48A4					     ; AL = character, BH = display page
SYSINIT:48A4					     ; BL = attributes of character (alpha modes) or color (graphics modes)
SYSINIT:48A4					     ; CX = number of times to write character
SYSINIT:48A6		     inc     dl
SYSINIT:48A8		     mov     ah, 2
SYSINIT:48AA		     int     10h	     ; - VIDEO - SET CURSOR POSITION
SYSINIT:48AA					     ; DH,DL = row, column (0,0	= upper	left)
SYSINIT:48AA					     ; BH = page number
SYSINIT:48AC		     mov     ax, 92Eh
SYSINIT:48AF		     int     10h	     ; - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT	CURSOR POSITION
SYSINIT:48AF					     ; AL = character, BH = display page
SYSINIT:48AF					     ; BL = attributes of character (alpha modes) or color (graphics modes)
SYSINIT:48AF					     ; CX = number of times to write character
SYSINIT:48B1		     inc     dl
SYSINIT:48B3		     mov     ah, 2
SYSINIT:48B5		     int     10h	     ; - VIDEO - SET CURSOR POSITION
SYSINIT:48B5					     ; DH,DL = row, column (0,0	= upper	left)
SYSINIT:48B5					     ; BH = page number
SYSINIT:48B7		     mov     ax, 920h
SYSINIT:48BA		     int     10h	     ; - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT	CURSOR POSITION
SYSINIT:48BA					     ; AL = character, BH = display page
SYSINIT:48BA					     ; BL = attributes of character (alpha modes) or color (graphics modes)
SYSINIT:48BA					     ; CX = number of times to write character
SYSINIT:48BC		     inc     dl
SYSINIT:48BE		     mov     ah, 2
SYSINIT:48C0		     int     10h	     ; - VIDEO - SET CURSOR POSITION
SYSINIT:48C0					     ; DH,DL = row, column (0,0	= upper	left)
SYSINIT:48C0					     ; BH = page number
SYSINIT:48C2		     push    es
SYSINIT:48C3
SYSINIT:48C3 print_loop:			     ; ...
SYSINIT:48C3		     mov     al, es:[di]     ; get a character of the description
SYSINIT:48C6		     inc     di
SYSINIT:48C7		     cmp     al, 9	     ; TAB ; substitute	spaces for tabs
SYSINIT:48C9		     jnz     short print_montab
SYSINIT:48CB		     mov     al, 20h ; ' '
SYSINIT:48CD
SYSINIT:48CD print_montab:			     ; ...
SYSINIT:48CD		     cmp     al, 20h ; ' '
SYSINIT:48CF		     jb	     short print_done ;	stop at	the 1st	character < space
SYSINIT:48D1		     cmp     al, 24h ; '$'
SYSINIT:48D3		     jz	     short print_done ;	also stop on $
SYSINIT:48D5		     mov     ah, 9
SYSINIT:48D7		     int     10h	     ; - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT	CURSOR POSITION
SYSINIT:48D7					     ; AL = character, BH = display page
SYSINIT:48D7					     ; BL = attributes of character (alpha modes) or color (graphics modes)
SYSINIT:48D7					     ; CX = number of times to write character
SYSINIT:48D9		     inc     dl		     ; increment column
SYSINIT:48DB		     cmp     dl, 78	     ; far enough?
SYSINIT:48DE		     jnb     short print_done ;	yes
SYSINIT:48E0		     mov     ah, 2
SYSINIT:48E2		     int     10h	     ; - VIDEO - SET CURSOR POSITION
SYSINIT:48E2					     ; DH,DL = row, column (0,0	= upper	left)
SYSINIT:48E2					     ; BH = page number
SYSINIT:48E4		     jmp     short print_loop
SYSINIT:48E6 ; ---------------------------------------------------------------------------
SYSINIT:48E6
SYSINIT:48E6 print_done:			     ; ...
SYSINIT:48E6		     pop     es
SYSINIT:48E7		     pop     dx
SYSINIT:48E8		     mov     ah, 2	     ; restore previous	row/col
SYSINIT:48EA		     int     10h	     ; - VIDEO - SET CURSOR POSITION
SYSINIT:48EA					     ; DH,DL = row, column (0,0	= upper	left)
SYSINIT:48EA					     ; BH = page number
SYSINIT:48EC		     pop     si
SYSINIT:48ED		     pop     dx
SYSINIT:48EE		     pop     cx
SYSINIT:48EF		     pop     bx
SYSINIT:48F0		     pop     ax
SYSINIT:48F1		     retn
SYSINIT:48F1 print_item	     endp
SYSINIT:48F1
SYSINIT:48F2
SYSINIT:48F2 ; =============== S U B R O U T I N E =======================================
SYSINIT:48F2
SYSINIT:48F2
SYSINIT:48F2 select_item     proc near		     ; ...
SYSINIT:48F2		     mov     bl, ds:bDefBlock ;	wait for user to select	menu item, with	time-out
SYSINIT:48F2					     ;
SYSINIT:48F2					     ; returns digit value in BX (trashes AX/CX/DX)
SYSINIT:48F6		     mov     al, bl	     ; BL will be the default block #
SYSINIT:48F8		     call    disp_num
SYSINIT:48FB		     call    show_status     ; display current interactive status
SYSINIT:48FE		     cmp     ds:secTimeOut, 0FFh ; -1
SYSINIT:4903		     jz	     short input_key ; no time-out, just go to input
SYSINIT:4905		     mov     ah, 2Ch	     ; GET_TIME
SYSINIT:4907		     int     21h	     ; DOS - GET CURRENT TIME
SYSINIT:4907					     ; Return: CH = hours, CL =	minutes, DH = seconds
SYSINIT:4907					     ; DL = hundredths of seconds
SYSINIT:4907					     ; ;
SYSINIT:4909		     mov     bh, dh	     ; BH = initial # of seconds
SYSINIT:490B
SYSINIT:490B check_time:			     ; ...
SYSINIT:490B		     mov     al, ds:secTimeOut
SYSINIT:490E		     sub     al, ds:secElapsed
SYSINIT:4912		     jnb     short show_time
SYSINIT:4914		     or	     ds:bQueryOpt, 2 ; disable all further prompting
SYSINIT:4919		     mov     ds:secElapsed, 0
SYSINIT:491E		     jmp     select_done     ; time's up!
SYSINIT:4921 ; ---------------------------------------------------------------------------
SYSINIT:4921
SYSINIT:4921 show_time:				     ; ...
SYSINIT:4921		     push    bx
SYSINIT:4922		     mov     bl, al	     ; save # in BL
SYSINIT:4924		     mov     bh, ds:bMenuPage
SYSINIT:4928		     mov     ah, 3
SYSINIT:492A		     int     10h	     ; - VIDEO - READ CURSOR POSITION
SYSINIT:492A					     ; BH = page number
SYSINIT:492A					     ; Return: DH,DL = row,column, CH =	cursor start line, CL =	cursor end line
SYSINIT:492C		     push    dx
SYSINIT:492D		     add     dl, 8	     ; move cursor to the right
SYSINIT:4930		     mov     ah, 2
SYSINIT:4932		     int     10h	     ; - VIDEO - SET CURSOR POSITION
SYSINIT:4932					     ; DH,DL = row, column (0,0	= upper	left)
SYSINIT:4932					     ; BH = page number
SYSINIT:4934		     mov     dx, offset	_$TimeOut ; "Time remaining: $"
SYSINIT:4937		     call    print	     ; print the "Time remaining: " prompt
SYSINIT:493A		     mov     al, bl	     ; recover # from BL
SYSINIT:493C		     cbw		     ; this works because AL is	always <= 90
SYSINIT:493D		     mov     cl, 10
SYSINIT:493F		     div     cl		     ; AL = tens digit,	AH = ones digit
SYSINIT:4941		     mov     cl, ah
SYSINIT:4943		     add     al, '0'         ; write TTY tens digit
SYSINIT:4945		     mov     ah, 0Eh
SYSINIT:4947		     int     10h	     ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
SYSINIT:4947					     ; AL = character, BH = display page (alpha	modes)
SYSINIT:4947					     ; BL = foreground color (graphics modes)
SYSINIT:4949		     mov     al, cl
SYSINIT:494B		     add     al, '0'         ; write TTY ones digit
SYSINIT:494D		     mov     ah, 0Eh
SYSINIT:494F		     int     10h	     ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
SYSINIT:494F					     ; AL = character, BH = display page (alpha	modes)
SYSINIT:494F					     ; BL = foreground color (graphics modes)
SYSINIT:4951		     pop     dx
SYSINIT:4952		     mov     ah, 2	     ; set cursor position back	to where it was
SYSINIT:4954		     int     10h	     ; - VIDEO - SET CURSOR POSITION
SYSINIT:4954					     ; DH,DL = row, column (0,0	= upper	left)
SYSINIT:4954					     ; BH = page number
SYSINIT:4956		     pop     bx
SYSINIT:4957
SYSINIT:4957 input_key:				     ; ...
SYSINIT:4957		     mov     ah, 6	     ; RAW_CON_IO
SYSINIT:4959		     mov     dl, 0FFh	     ; input request
SYSINIT:495B		     int     21h	     ; DOS - DIRECT CONSOLE I/O	CHARACTER OUTPUT
SYSINIT:495B					     ; DL = character <> FFh
SYSINIT:495B					     ;	Return:	ZF set = no character
SYSINIT:495B					     ;	 ZF clear = character recieved,	AL = character
SYSINIT:495D		     jnz     short got_key
SYSINIT:495F		     cmp     ds:secTimeOut, 0FFh ; -1 ;	is there a time-out?
SYSINIT:4964		     jz	     short input_key ; no, just	go back	to input
SYSINIT:4966		     mov     ah, 2Ch	     ; GET_TIME
SYSINIT:4968		     int     21h	     ; DOS - GET CURRENT TIME
SYSINIT:4968					     ; Return: CH = hours, CL =	minutes, DH = seconds
SYSINIT:4968					     ; DL = hundredths of seconds
SYSINIT:496A		     mov     ah, dh
SYSINIT:496C		     sub     dh, bh	     ; should generally	be zero	or one
SYSINIT:496E		     mov     bh, ah
SYSINIT:4970		     jnb     short got_time
SYSINIT:4972		     mov     dh, 1	     ; it wrapped back to zero,	so assume one
SYSINIT:4974
SYSINIT:4974 got_time:				     ; ...
SYSINIT:4974		     or	     dh, dh	     ; any change?
SYSINIT:4976		     jz	     short input_key ; no
SYSINIT:4978		     add     ds:secElapsed, dh
SYSINIT:497C		     jmp     short check_time
SYSINIT:497E ; ---------------------------------------------------------------------------
SYSINIT:497E
SYSINIT:497E got_key:				     ; ...
SYSINIT:497E		     push    ax
SYSINIT:497F		     mov     ax, 0FFFFh	     ; -1 ; zap	both secTimeOut	and secElapsed
SYSINIT:4982		     xchg    ax, word ptr ds:secTimeOut
SYSINIT:4986		     cmp     al, 0FFh	     ; -1 ; was	time-out already disabled?
SYSINIT:4988		     jz	     short timeout_disabled ; yes
SYSINIT:498A		     push    bx		     ; let's disable # seconds display
SYSINIT:498B		     mov     ax, 0A20h	     ; write multiple spaces
SYSINIT:498E		     mov     bx, word ptr ds:bMenuColor
SYSINIT:4992		     mov     cx, 80	     ; 80 of them, to be safe
SYSINIT:4992					     ; to completely obliterate	# seconds display
SYSINIT:4995		     int     10h	     ; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
SYSINIT:4995					     ; AL = character, BH = display page - alpha mode
SYSINIT:4995					     ; BL = color of character (graphics mode, PCjr only)
SYSINIT:4995					     ; CX = number of times to write character
SYSINIT:4997		     pop     bx
SYSINIT:4998
SYSINIT:4998 timeout_disabled:			     ; ...
SYSINIT:4998		     pop     ax
SYSINIT:4999		     or	     al, al	     ; extended	key pressed?
SYSINIT:499B		     jnz     short normal_key ;	no
SYSINIT:499D		     int     21h	     ; get the next part of the	key then
SYSINIT:499F		     jz	     short input_key ; what happened to	the second part!?
SYSINIT:49A1		     cmp     al, 48h	     ; up arrow?
SYSINIT:49A3		     jnz     short not_up    ; no
SYSINIT:49A5		     cmp     bl, 1	     ; are we as up as up can get?
SYSINIT:49A8		     jbe     short input_key ; yes, ignore it
SYSINIT:49AA		     dec     ds:bDefBlock
SYSINIT:49AE		     call    print_item	     ; re-print	the current item
SYSINIT:49B1		     dec     bl		     ; and then	print the new current item
SYSINIT:49B3		     jmp     short print1
SYSINIT:49B5 ; ---------------------------------------------------------------------------
SYSINIT:49B5
SYSINIT:49B5 not_up:				     ; ...
SYSINIT:49B5		     cmp     al, 50h ; 'P'   ; down arrow?
SYSINIT:49B7		     jnz     short not_down  ; no
SYSINIT:49B9		     cmp     bl, ds:bMaxBlock ;	are we as down as down can get?
SYSINIT:49BD		     jnb     short to_input_key	; yes, ignore it
SYSINIT:49BF		     inc     ds:bDefBlock
SYSINIT:49C3		     call    print_item	     ; re-print	the current item
SYSINIT:49C6		     inc     bx		     ; and then	print the new current item
SYSINIT:49C7
SYSINIT:49C7 print1:				     ; ...
SYSINIT:49C7		     mov     al, bl
SYSINIT:49C9
SYSINIT:49C9 print2:				     ; ...
SYSINIT:49C9		     call    print_item
SYSINIT:49CC		     call    disp_num
SYSINIT:49CF
SYSINIT:49CF to_input_key:			     ; ...
SYSINIT:49CF		     jmp     short input_key
SYSINIT:49D1 ; ---------------------------------------------------------------------------
SYSINIT:49D1
SYSINIT:49D1 not_down:				     ; ...
SYSINIT:49D1		     test    ds:bDisableUI, 1
SYSINIT:49D6		     jnz     short to_input_key	; don't allow F8 or F5
SYSINIT:49D8		     cmp     al, 42h	     ; F8 function key?
SYSINIT:49DA		     jnz     short not_f8    ; no
SYSINIT:49DC		     xor     ds:bQueryOpt, 1
SYSINIT:49E1		     call    show_status
SYSINIT:49E4		     jmp     input_key
SYSINIT:49E7 ; ---------------------------------------------------------------------------
SYSINIT:49E7
SYSINIT:49E7 not_f8:				     ; ...
SYSINIT:49E7		     cmp     al, 3Fh	     ; F5 function key?
SYSINIT:49E9		     jnz     short to_input_key	; no
SYSINIT:49EB		     or	     ds:bQueryOpt, 4 ; no more queries
SYSINIT:49F0		     mov     bx, 0FFFFh	     ; special return code (-1)	indicating clean boot
SYSINIT:49F3		     mov     al, 20h ; ' '   ; don't want to display anything really;
SYSINIT:49F5		     jmp     short disp_input
SYSINIT:49F7 ; ---------------------------------------------------------------------------
SYSINIT:49F7
SYSINIT:49F7 normal_key:			     ; ...
SYSINIT:49F7		     cmp     al, 0Dh	     ; Enter?
SYSINIT:49F9		     jz	     short select_done ; yes
SYSINIT:49FB		     cmp     al, 8	     ; backspace?
SYSINIT:49FD		     jnz     short not_backspace ; no
SYSINIT:49FF		     mov     bx, 0FFFEh	     ; -2 ; yes, special return	code
SYSINIT:4A02		     retn
SYSINIT:4A03 ; ---------------------------------------------------------------------------
SYSINIT:4A03
SYSINIT:4A03 not_backspace:			     ; ...
SYSINIT:4A03		     sub     al, 30h ; '0'   ; is greater than '0'?
SYSINIT:4A05		     jbe     short to_input_key	; no
SYSINIT:4A07		     cmp     al, ds:bMaxBlock ;	is less	than or	equal to the maximum digit?
SYSINIT:4A0B		     ja	     short to_input_key	; no
SYSINIT:4A0D		     mov     ds:bDefBlock, al
SYSINIT:4A10		     call    print_item	     ; redisplay the current selection
SYSINIT:4A13		     mov     bl, al	     ; set new selection
SYSINIT:4A15		     jmp     short print2
SYSINIT:4A17 ; ---------------------------------------------------------------------------
SYSINIT:4A17
SYSINIT:4A17 select_done:			     ; ...
SYSINIT:4A17		     mov     bh, 0	     ; return a	full 16-bit value (for indexing)
SYSINIT:4A19		     mov     al, bl
SYSINIT:4A1B		     add     al, 30h ; '0'   ; convert it into a digit, then display it
SYSINIT:4A1B select_item     endp
SYSINIT:4A1B
SYSINIT:4A1D
SYSINIT:4A1D ; =============== S U B R O U T I N E =======================================
SYSINIT:4A1D
SYSINIT:4A1D
SYSINIT:4A1D disp_input	     proc near		     ; ...
SYSINIT:4A1D		     push    ax		     ; display a single	character + cr/lf
SYSINIT:4A1E		     cmp     al, 20h ; ' '
SYSINIT:4A20		     jnb     short disp_ok
SYSINIT:4A22		     mov     al, 20h ; ' '
SYSINIT:4A24
SYSINIT:4A24 disp_ok:				     ; ...
SYSINIT:4A24		     mov     dl, al
SYSINIT:4A26		     mov     ah, 2
SYSINIT:4A28		     int     21h	     ; DOS - DISPLAY OUTPUT
SYSINIT:4A28					     ; DL = character to send to standard output
SYSINIT:4A2A		     mov     dx, offset	crlfm ;	"\r\n$"
SYSINIT:4A2D		     call    print
SYSINIT:4A30		     pop     ax
SYSINIT:4A31		     retn
SYSINIT:4A31 disp_input	     endp
SYSINIT:4A31
SYSINIT:4A32
SYSINIT:4A32 ; =============== S U B R O U T I N E =======================================
SYSINIT:4A32
SYSINIT:4A32
SYSINIT:4A32 disp_num	     proc near		     ; ...
SYSINIT:4A32		     push    bx
SYSINIT:4A33		     add     al, '0'
SYSINIT:4A35		     mov     ah, 0Ah
SYSINIT:4A37		     mov     bx, word ptr ds:bMenuColor
SYSINIT:4A3B		     mov     cx, 1
SYSINIT:4A3E		     int     10h	     ; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
SYSINIT:4A3E					     ; AL = character, BH = display page - alpha mode
SYSINIT:4A3E					     ; BL = color of character (graphics mode, PCjr only)
SYSINIT:4A3E					     ; CX = number of times to write character
SYSINIT:4A40		     pop     bx
SYSINIT:4A41		     retn
SYSINIT:4A41 disp_num	     endp
SYSINIT:4A41
SYSINIT:4A42
SYSINIT:4A42 ; =============== S U B R O U T I N E =======================================
SYSINIT:4A42
SYSINIT:4A42
SYSINIT:4A42 show_status     proc near		     ; ...
SYSINIT:4A42		     push    bx		     ; display current interactive mode	setting	(on/off/none)
SYSINIT:4A43		     mov     bx, word ptr ds:bMenuColor
SYSINIT:4A47		     mov     ah, 3
SYSINIT:4A49		     int     10h	     ; - VIDEO - READ CURSOR POSITION
SYSINIT:4A49					     ; BH = page number
SYSINIT:4A49					     ; Return: DH,DL = row,column, CH =	cursor start line, CL =	cursor end line
SYSINIT:4A4B		     push    dx
SYSINIT:4A4C		     mov     ah, 2
SYSINIT:4A4E		     mov     dx, word ptr ds:bLastCol ;	set correct row/col
SYSINIT:4A52		     test    ds:bDisableUI, 1
SYSINIT:4A57		     jz	     short show_onoff ;	just show on/off
SYSINIT:4A59		     mov     dl, 0
SYSINIT:4A5B		     int     10h	     ; - VIDEO - SET CURSOR POSITION
SYSINIT:4A5B					     ; DH,DL = row, column (0,0	= upper	left)
SYSINIT:4A5B					     ; BH = page number
SYSINIT:4A5D		     mov     ax, 0A20h	     ; write multiple spaces
SYSINIT:4A60		     mov     cx, 80	     ; 80 of them, to be exact to obliterate the status	line
SYSINIT:4A63		     int     10h	     ; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
SYSINIT:4A63					     ; AL = character, BH = display page - alpha mode
SYSINIT:4A63					     ; BL = color of character (graphics mode, PCjr only)
SYSINIT:4A63					     ; CX = number of times to write character
SYSINIT:4A65		     jmp     short show_done
SYSINIT:4A67 ; ---------------------------------------------------------------------------
SYSINIT:4A67
SYSINIT:4A67 show_onoff:			     ; ...
SYSINIT:4A67		     int     10h	     ; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
SYSINIT:4A67					     ; AL = character, BH = display page - alpha mode
SYSINIT:4A67					     ; BL = color of character (graphics mode, PCjr only)
SYSINIT:4A67					     ; CX = number of times to write character
SYSINIT:4A69		     mov     al, byte ptr ds:_$NO ; "NO	$"
SYSINIT:4A6C		     cmp     ds:bQueryOpt, 1 ; is interactive mode on?
SYSINIT:4A71		     jnz     short show_noton ;	no
SYSINIT:4A73		     mov     al, byte ptr ds:_$YES ; "YES$"
SYSINIT:4A76
SYSINIT:4A76 show_noton:			     ; ...
SYSINIT:4A76		     mov     ah, 0Eh
SYSINIT:4A78		     int     10h	     ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
SYSINIT:4A78					     ; AL = character, BH = display page (alpha	modes)
SYSINIT:4A78					     ; BL = foreground color (graphics modes)
SYSINIT:4A7A
SYSINIT:4A7A show_done:				     ; ...
SYSINIT:4A7A		     pop     dx		     ; restore original	cursor position
SYSINIT:4A7B		     mov     ah, 2
SYSINIT:4A7D		     int     10h	     ; - VIDEO - SET CURSOR POSITION
SYSINIT:4A7D					     ; DH,DL = row, column (0,0	= upper	left)
SYSINIT:4A7D					     ; BH = page number
SYSINIT:4A7F		     pop     bx
SYSINIT:4A80		     retn
SYSINIT:4A80 show_status     endp
SYSINIT:4A80
SYSINIT:4A81
SYSINIT:4A81 ; =============== S U B R O U T I N E =======================================
SYSINIT:4A81
SYSINIT:4A81
SYSINIT:4A81 skip_token	     proc near		     ; ...
SYSINIT:4A81		     call    get_char	     ; advances	ES:SI/CX past the current token
SYSINIT:4A84		     jb	     short skip_token_done
SYSINIT:4A86		     call    any_delim
SYSINIT:4A89		     jnz     short skip_token
SYSINIT:4A8B
SYSINIT:4A8B skip_check_eol:			     ; ...
SYSINIT:4A8B		     cmp     al, 0Dh	     ; CR
SYSINIT:4A8D		     jz	     short skip_token_eol
SYSINIT:4A8F		     cmp     al, 0Ah	     ; LF
SYSINIT:4A91		     jz	     short skip_token_eol
SYSINIT:4A93		     clc
SYSINIT:4A94		     jmp     short skip_token_done
SYSINIT:4A96 ; ---------------------------------------------------------------------------
SYSINIT:4A96
SYSINIT:4A96 skip_token_eol:			     ; ...
SYSINIT:4A96		     stc
SYSINIT:4A97
SYSINIT:4A97 skip_token_done:			     ; ...
SYSINIT:4A97		     retn
SYSINIT:4A97 skip_token	     endp
SYSINIT:4A97
SYSINIT:4A98
SYSINIT:4A98 ; =============== S U B R O U T I N E =======================================
SYSINIT:4A98
SYSINIT:4A98
SYSINIT:4A98 skip_delim	     proc near		     ; ...
SYSINIT:4A98		     call    get_char	     ; advances	ES:SI/CX past the current delimiter
SYSINIT:4A9B		     lea     bx, [si-1]
SYSINIT:4A9E		     jb	     short skip_token_done
SYSINIT:4AA0		     call    delim
SYSINIT:4AA3		     jz	     short skip_delim
SYSINIT:4AA5		     jmp     short skip_check_eol
SYSINIT:4AA5 skip_delim	     endp
SYSINIT:4AA5
SYSINIT:4AA7
SYSINIT:4AA7 ; =============== S U B R O U T I N E =======================================
SYSINIT:4AA7
SYSINIT:4AA7
SYSINIT:4AA7 skip_opt_line   proc near		     ; ...
SYSINIT:4AA7		     cmp     al, 0Ah	     ; LF
SYSINIT:4AA9		     jz	     short skip_line_done
SYSINIT:4AA9 skip_opt_line   endp
SYSINIT:4AA9
SYSINIT:4AAB
SYSINIT:4AAB ; =============== S U B R O U T I N E =======================================
SYSINIT:4AAB
SYSINIT:4AAB
SYSINIT:4AAB skip_line	     proc near		     ; ...
SYSINIT:4AAB		     call    get_char
SYSINIT:4AAE		     jb	     short skip_line_done
SYSINIT:4AB0		     cmp     al, 0Ah	     ; LF
SYSINIT:4AB2		     jnz     short skip_line
SYSINIT:4AB4
SYSINIT:4AB4 skip_line_done:			     ; ...
SYSINIT:4AB4		     retn
SYSINIT:4AB4 skip_line	     endp
SYSINIT:4AB4
SYSINIT:4AB5
SYSINIT:4AB5 ; =============== S U B R O U T I N E =======================================
SYSINIT:4AB5
SYSINIT:4AB5
SYSINIT:4AB5 get_number	     proc near		     ; ...
SYSINIT:4AB5		     sub     bx, bx	     ; return binary equivalent	of numeric string
SYSINIT:4AB5					     ; BX = result
SYSINIT:4AB7
SYSINIT:4AB7 num_loop:				     ; ...
SYSINIT:4AB7		     call    get_char
SYSINIT:4ABA		     jb	     short num_done
SYSINIT:4ABC		     cmp     al, 30h ; '0'   ; convert to value
SYSINIT:4ABE		     jb	     short num_done  ; no more number
SYSINIT:4AC0		     cmp     al, 39h ; '9'
SYSINIT:4AC2		     ja	     short num_done
SYSINIT:4AC4		     push    ax
SYSINIT:4AC5		     mov     ax, 10
SYSINIT:4AC8		     push    dx
SYSINIT:4AC9		     mul     bx
SYSINIT:4ACB		     pop     dx
SYSINIT:4ACC		     mov     bx, ax
SYSINIT:4ACE		     pop     ax
SYSINIT:4ACF		     sub     al, 30h ; '0'
SYSINIT:4AD1		     cbw
SYSINIT:4AD2		     add     bx, ax
SYSINIT:4AD4		     jmp     short num_loop
SYSINIT:4AD6 ; ---------------------------------------------------------------------------
SYSINIT:4AD6
SYSINIT:4AD6 num_done:				     ; ...
SYSINIT:4AD6		     retn
SYSINIT:4AD6 get_number	     endp
SYSINIT:4AD6
SYSINIT:4AD7
SYSINIT:4AD7 ; =============== S U B R O U T I N E =======================================
SYSINIT:4AD7
SYSINIT:4AD7
SYSINIT:4AD7 get_char	     proc near		     ; ...
SYSINIT:4AD7		     sub     cx, 1	     ; return next character,
SYSINIT:4AD7					     ; advance ES:SI, and decrement CX
SYSINIT:4AD7					     ; (use SUB	to set carry,zero)
SYSINIT:4ADA		     jb	     short get_fail
SYSINIT:4ADC		     lods    byte ptr es:[si] ;	es
SYSINIT:4ADC					     ; lodsb
SYSINIT:4ADE		     mov     ah, al
SYSINIT:4AE0		     retn
SYSINIT:4AE1 ; ---------------------------------------------------------------------------
SYSINIT:4AE1
SYSINIT:4AE1 get_fail:				     ; ...
SYSINIT:4AE1		     mov     cx, 0	     ; restore CX to zero
SYSINIT:4AE1					     ; leave carry set,	zero not set
SYSINIT:4AE4
SYSINIT:4AE4 nearby_ret:			     ; ...
SYSINIT:4AE4		     retn
SYSINIT:4AE4 get_char	     endp
SYSINIT:4AE4
SYSINIT:4AE5
SYSINIT:4AE5 ; =============== S U B R O U T I N E =======================================
SYSINIT:4AE5
SYSINIT:4AE5
SYSINIT:4AE5 query_user	     proc near		     ; ...
SYSINIT:4AE5		     test    ds:bQueryOpt, 4 ; ask user	whether	to execute current config.sys command
SYSINIT:4AE5					     ; answer no to everything?
SYSINIT:4AEA		     jz	     short qu_1	     ; no
SYSINIT:4AEC		     jmp     skip_all	     ; yes
SYSINIT:4AEF ; ---------------------------------------------------------------------------
SYSINIT:4AEF
SYSINIT:4AEF qu_1:				     ; ...
SYSINIT:4AEF		     test    ds:bQueryOpt, 2 ; answer yes to everything?
SYSINIT:4AF4		     jnz     short nearby_ret ;	yes (and return	carry clear!)
SYSINIT:4AF6		     push    ax
SYSINIT:4AF7		     mov     al, ds:config_cmd
SYSINIT:4AFA		     test    ds:bQueryOpt, 1 ; query every command?
SYSINIT:4AFF		     jnz     short query_all ; yes
SYSINIT:4B01		     test    al, 80h	     ; CONFIG_OPTION_QUERY
SYSINIT:4B03		     jnz     short query_all
SYSINIT:4B05		     jmp     do_cmd
SYSINIT:4B08 ; ---------------------------------------------------------------------------
SYSINIT:4B08
SYSINIT:4B08 query_all:				     ; ...
SYSINIT:4B08		     push    si		     ; save pointer to rest of CONFIG.SYS line
SYSINIT:4B09		     mov     dx, offset	_$AutoPrmpt ; "Process AUTOEXEC.BAT [Y,N]?$"
SYSINIT:4B0C		     and     al, 7Fh	     ; ~CONFIG_OPTION_QUERY
SYSINIT:4B0E		     jz	     short generic_prompt ; config_cmd must have been 0
SYSINIT:4B10		     mov     dh, al	     ; save config_cmd in DH
SYSINIT:4B12		     sub     bx, bx	     ; 0
SYSINIT:4B14		     mov     di, offset	comtab ; "\x01[["
SYSINIT:4B17
SYSINIT:4B17 find_match:			     ; ...
SYSINIT:4B17		     mov     bl, [di]	     ; get size	of current keyword
SYSINIT:4B19		     or	     bl, bl
SYSINIT:4B1B		     jz	     short line_print ;	end of table
SYSINIT:4B1D		     inc     di
SYSINIT:4B1E		     cmp     al, [bx+di]     ; match?
SYSINIT:4B20		     jz	     short cmd_match ; yes
SYSINIT:4B22		     lea     di, [bx+di+1]   ; otherwise, skip this command code
SYSINIT:4B25		     jmp     short find_match ;	loop
SYSINIT:4B27 ; ---------------------------------------------------------------------------
SYSINIT:4B27
SYSINIT:4B27 cmd_match:				     ; ...
SYSINIT:4B27		     mov     cl, [di-1]
SYSINIT:4B2A		     mov     ch, 0
SYSINIT:4B2C		     mov     ah, 2	     ; STD_CON_OUTPUT
SYSINIT:4B2E
SYSINIT:4B2E cmd_print:				     ; ...
SYSINIT:4B2E		     mov     al, [di]
SYSINIT:4B30		     inc     di
SYSINIT:4B31		     mov     dl, al
SYSINIT:4B33		     int     21h	     ; DOS - DISPLAY OUTPUT
SYSINIT:4B33					     ; DL = character to send to standard output
SYSINIT:4B35		     loop    cmd_print
SYSINIT:4B37		     mov     dl, '='
SYSINIT:4B39		     cmp     dh, 'V'         ; CONFIG_SET
SYSINIT:4B3C		     jnz     short cmd_notset
SYSINIT:4B3E		     mov     dl, 20h ; ' '   ; for SET commands, don't display a '='
SYSINIT:4B40
SYSINIT:4B40 cmd_notset:			     ; ...
SYSINIT:4B40		     int     21h	     ; DOS - DISPLAY OUTPUT
SYSINIT:4B40					     ; DL = character to send to standard output
SYSINIT:4B42
SYSINIT:4B42 line_print:			     ; ...
SYSINIT:4B42		     lods    byte ptr es:[si]
SYSINIT:4B44		     or	     al, al
SYSINIT:4B46		     jnz     short non_null
SYSINIT:4B48		     mov     al, 20h ; ' '
SYSINIT:4B4A
SYSINIT:4B4A non_null:				     ; ...
SYSINIT:4B4A		     cmp     al, 20h ; ' '   ; control code?
SYSINIT:4B4C		     jb	     short prompt_user ; yes, assume end of line
SYSINIT:4B4E		     jnz     short non_space
SYSINIT:4B50		     cmp     byte ptr es:[si], 20h ; ' '
SYSINIT:4B54		     jb	     short prompt_user
SYSINIT:4B56
SYSINIT:4B56 non_space:				     ; ...
SYSINIT:4B56		     mov     dl, al
SYSINIT:4B58		     mov     ah, 2
SYSINIT:4B5A		     int     21h	     ; DOS - DISPLAY OUTPUT
SYSINIT:4B5A					     ; DL = character to send to standard output
SYSINIT:4B5C		     jmp     short line_print
SYSINIT:4B5E ; ---------------------------------------------------------------------------
SYSINIT:4B5E
SYSINIT:4B5E prompt_user:			     ; ...
SYSINIT:4B5E		     mov     dx, offset	_$InterPrmpt ; " [Y,N]?$"
SYSINIT:4B61
SYSINIT:4B61 generic_prompt:			     ; ...
SYSINIT:4B61		     call    print
SYSINIT:4B64
SYSINIT:4B64 input_loop:			     ; ...
SYSINIT:4B64		     mov     ah, 0
SYSINIT:4B66		     int     16h	     ; KEYBOARD	- READ CHAR FROM BUFFER, WAIT IF EMPTY
SYSINIT:4B66					     ; Return: AH = scan code, AL = character
SYSINIT:4B68		     or	     al, al	     ; is it a function	key?
SYSINIT:4B6A		     jnz     short not_func  ; no
SYSINIT:4B6C		     cmp     ah, 3Fh	     ; F5 function key?
SYSINIT:4B6F		     jnz     short input_loop ;	no
SYSINIT:4B71		     mov     al, ds:57CEh
SYSINIT:4B74		     or	     ds:bQueryOpt, 4 ; no more queries
SYSINIT:4B79		     jmp     short legal_char
SYSINIT:4B7B ; ---------------------------------------------------------------------------
SYSINIT:4B7B
SYSINIT:4B7B not_func:				     ; ...
SYSINIT:4B7B		     and     al, 0DFh	     ; ~20h ; converting to upper case
SYSINIT:4B7B					     ; converting to upper case
SYSINIT:4B7B					     ; verify character	is legal
SYSINIT:4B7D		     cmp     al, byte ptr ds:_$NO ; "NO	$"
SYSINIT:4B81		     jz	     short legal_char
SYSINIT:4B83		     cmp     al, byte ptr ds:_$YES ; "YES$"
SYSINIT:4B87		     jz	     short legal_char
SYSINIT:4B89		     cmp     ds:config_cmd, 0
SYSINIT:4B8E		     jz	     short input_loop ;	don't allow Esc on this query
SYSINIT:4B90		     cmp     al, 1Bh	     ; Esc?
SYSINIT:4B92		     jnz     short input_loop
SYSINIT:4B94		     or	     ds:bQueryOpt, 2 ; no more interactive boot	prompts
SYSINIT:4B99		     mov     al, byte ptr ds:_$YES ; "YES$"
SYSINIT:4B9C
SYSINIT:4B9C legal_char:			     ; ...
SYSINIT:4B9C		     call    disp_input
SYSINIT:4B9F		     pop     si		     ; restore pointer to rest of CONFIG.SYS line
SYSINIT:4B9F					     ; process line?
SYSINIT:4BA0		     cmp     al, byte ptr ds:_$NO ; "NO	$"
SYSINIT:4BA4		     jz	     short skip_cmd  ; no
SYSINIT:4BA6
SYSINIT:4BA6 do_cmd:				     ; ...
SYSINIT:4BA6		     pop     ax
SYSINIT:4BA7		     clc		     ; just do the command
SYSINIT:4BA8		     retn
SYSINIT:4BA9 ; ---------------------------------------------------------------------------
SYSINIT:4BA9
SYSINIT:4BA9 skip_cmd:				     ; ...
SYSINIT:4BA9		     pop     ax
SYSINIT:4BAA
SYSINIT:4BAA skip_all:				     ; ...
SYSINIT:4BAA		     mov     ah, 30h ; '0'   ; CONFIG_REM ; fake out the rest of sysinit's processing
SYSINIT:4BAC		     stc
SYSINIT:4BAD		     retn
SYSINIT:4BAD query_user	     endp
SYSINIT:4BAD
SYSINIT:4BAE
SYSINIT:4BAE ; =============== S U B R O U T I N E =======================================
SYSINIT:4BAE
SYSINIT:4BAE
SYSINIT:4BAE print_error     proc near		     ; ...
SYSINIT:4BAE		     push    ax		     ; displays	multi-config error conditions
SYSINIT:4BAF		     push    bx
SYSINIT:4BB0		     push    cx
SYSINIT:4BB1		     push    dx
SYSINIT:4BB2		     push    ds
SYSINIT:4BB3		     push    cs
SYSINIT:4BB4		     pop     ds
SYSINIT:4BB5		     assume ds:SYSINIT
SYSINIT:4BB5		     pushf
SYSINIT:4BB6		     call    get_linenum
SYSINIT:4BB9		     mov     linecount,	bx
SYSINIT:4BBD		     call    error_line
SYSINIT:4BC0		     popf
SYSINIT:4BC1		     jnb     short pe_ret
SYSINIT:4BC3		     mov     dx, offset	_$PauseMsg ; "Press any	key to continue	. . .\r\n$"
SYSINIT:4BC6		     call    print
SYSINIT:4BC9		     mov     ax, 0C07h	     ; flush input buffer, then	wait for key
SYSINIT:4BCC		     int     21h	     ; DOS - CLEAR KEYBOARD BUFFER
SYSINIT:4BCC					     ; AL must be 01h, 06h, 07h, 08h, or 0Ah.
SYSINIT:4BCE		     or	     al, al	     ; extended	key?
SYSINIT:4BD0		     jnz     short pe_1	     ; no
SYSINIT:4BD2		     mov     ah, 7	     ; yes, eat	it too
SYSINIT:4BD4		     int     21h	     ; DOS - DIRECT STDIN INPUT, NO ECHO
SYSINIT:4BD6
SYSINIT:4BD6 pe_1:				     ; ...
SYSINIT:4BD6		     mov     dx, offset	crlfm ;	"\r\n$"
SYSINIT:4BD9		     call    print
SYSINIT:4BDC
SYSINIT:4BDC pe_ret:				     ; ...
SYSINIT:4BDC		     pop     ds
SYSINIT:4BDD		     assume ds:nothing
SYSINIT:4BDD		     pop     dx
SYSINIT:4BDE		     pop     cx
SYSINIT:4BDF		     pop     bx
SYSINIT:4BE0		     pop     ax
SYSINIT:4BE1		     retn
SYSINIT:4BE1 print_error     endp
SYSINIT:4BE1
SYSINIT:4BE2
SYSINIT:4BE2 ; =============== S U B R O U T I N E =======================================
SYSINIT:4BE2
SYSINIT:4BE2
SYSINIT:4BE2 disable_autoexec proc near		     ; ...
SYSINIT:4BE2		     test    ds:bQueryOpt, 4 ; This function is	very simple:
SYSINIT:4BE2					     ; it merely prepends a "/D" to the	command-line for the shell;
SYSINIT:4BE2					     ; this (undocumented) switch disables AUTOEXEC.BAT	processing
SYSINIT:4BE2					     ; and the date/time prompt	that is	usually	displayed
SYSINIT:4BE2					     ; when there's no AUTOEXEC.BAT.
SYSINIT:4BE7		     jz	     short disable_exit
SYSINIT:4BE9		     test    ds:dae_flag, 1
SYSINIT:4BEE		     jnz     short disable_exit
SYSINIT:4BF0		     or	     ds:dae_flag, 1
SYSINIT:4BF5		     or	     word ptr ds:bQueryOpt, 102h ; [bDefBlock] = 1
SYSINIT:4BFB		     mov     dx, ' D'        ; 2044h ; 'D ' (NASM syntax)
SYSINIT:4BFE
SYSINIT:4BFE dae_1:				     ; ...
SYSINIT:4BFE		     mov     al, ds:def_swchr ;	get default switchchar
SYSINIT:4C01		     or	     al, al
SYSINIT:4C03		     jz	     short disable_exit
SYSINIT:4C05		     mov     bl, byte ptr ds:command_line ; "\x02/P"
SYSINIT:4C09		     mov     bh, 0	     ; BX == command-line length
SYSINIT:4C0B		     mov     cx, bx
SYSINIT:4C0D		     add     bl, 3
SYSINIT:4C10		     cmp     bl, 126
SYSINIT:4C13		     ja	     short disable_exit	;
SYSINIT:4C13					     ; update length
SYSINIT:4C15		     mov     byte ptr ds:command_line, bl ; "\x02/P"
SYSINIT:4C19		     add     bx, (offset command_line+1) ;
SYSINIT:4C19					     ; make sure we move the NULL too
SYSINIT:4C1D		     inc     cx		     ; (just for consistency sake)
SYSINIT:4C1E
SYSINIT:4C1E disable_loop:			     ; ...
SYSINIT:4C1E		     mov     ah, [bx-3]
SYSINIT:4C21		     mov     [bx], ah
SYSINIT:4C23		     dec     bx
SYSINIT:4C24		     loop    disable_loop
SYSINIT:4C26		     mov     [bx-2], al
SYSINIT:4C29		     mov     [bx-1], dx	     ; 'D ' ; /D is stuffed into place now
SYSINIT:4C2C
SYSINIT:4C2C disable_exit:			     ; ...
SYSINIT:4C2C		     retn
SYSINIT:4C2C disable_autoexec endp
SYSINIT:4C2C
SYSINIT:4C2D
SYSINIT:4C2D ; =============== S U B R O U T I N E =======================================
SYSINIT:4C2D
SYSINIT:4C2D
SYSINIT:4C2D CheckQueryOpt   proc near		     ; ...
SYSINIT:4C2D		     cmp     ds:bQueryOpt, 1
SYSINIT:4C32		     jnz     short disable_exit
SYSINIT:4C34		     test    ds:dae_flag, 2
SYSINIT:4C39		     jnz     short disable_exit
SYSINIT:4C3B		     or	     ds:dae_flag, 2
SYSINIT:4C40		     mov     dx, ' Y'        ; 'Y ' ; 2059h
SYSINIT:4C43		     jmp     short dae_1
SYSINIT:4C43 CheckQueryOpt   endp
SYSINIT:4C43
SYSINIT:4C45
SYSINIT:4C45 ; =============== S U B R O U T I N E =======================================
SYSINIT:4C45
SYSINIT:4C45
SYSINIT:4C45 any_delim	     proc near		     ; ...
SYSINIT:4C45		     cmp     al, 0Dh	     ; cr
SYSINIT:4C47		     jz	     short delim_ret
SYSINIT:4C49		     cmp     al, 0Ah	     ; lf
SYSINIT:4C4B		     jz	     short delim_ret
SYSINIT:4C4D		     cmp     al, '['
SYSINIT:4C4F		     jz	     short delim_ret
SYSINIT:4C51		     cmp     al, ']'
SYSINIT:4C53		     jz	     short delim_ret
SYSINIT:4C53 any_delim	     endp
SYSINIT:4C53
SYSINIT:4C55
SYSINIT:4C55 ; =============== S U B R O U T I N E =======================================
SYSINIT:4C55
SYSINIT:4C55
SYSINIT:4C55 delim	     proc near		     ; ...
SYSINIT:4C55		     cmp     al, '/'         ; ibm will assume "/" as an delimeter
SYSINIT:4C57		     jz	     short delim_ret
SYSINIT:4C59		     cmp     al, 0	     ; special case for	sysinit!
SYSINIT:4C5B		     jz	     short delim_ret
SYSINIT:4C5D
SYSINIT:4C5D org_delim:				     ; ...
SYSINIT:4C5D		     cmp     al, 20h ; ' '   ; space
SYSINIT:4C5F		     jz	     short delim_ret
SYSINIT:4C61		     cmp     al, 9	     ; tab
SYSINIT:4C63		     jz	     short delim_ret
SYSINIT:4C65		     cmp     al, '='
SYSINIT:4C67		     jz	     short delim_ret
SYSINIT:4C69		     cmp     al, ','
SYSINIT:4C6B		     jz	     short delim_ret
SYSINIT:4C6D		     cmp     al, ';'
SYSINIT:4C6F		     clc
SYSINIT:4C70
SYSINIT:4C70 delim_ret:				     ; ...
SYSINIT:4C70		     retn
SYSINIT:4C70 delim	     endp
SYSINIT:4C70
SYSINIT:4C71
SYSINIT:4C71 ; =============== S U B R O U T I N E =======================================
SYSINIT:4C71
SYSINIT:4C71
SYSINIT:4C71 newline	     proc near		     ; ...
SYSINIT:4C71		     call    getchr
SYSINIT:4C74		     jb	     short nl_ret    ; no char
SYSINIT:4C76		     cmp     al, 0Ah	     ; lf
SYSINIT:4C78		     jnz     short newline
SYSINIT:4C7A		     call    getchr
SYSINIT:4C7D
SYSINIT:4C7D nl_ret:				     ; ...
SYSINIT:4C7D		     retn		     ; al = first character of next line (if cf=0)
SYSINIT:4C7D newline	     endp
SYSINIT:4C7D
SYSINIT:4C7E
SYSINIT:4C7E ; =============== S U B R O U T I N E =======================================
SYSINIT:4C7E
SYSINIT:4C7E
SYSINIT:4C7E mapcase	     proc near		     ; ...
SYSINIT:4C7E		     push    cx
SYSINIT:4C7F		     push    si
SYSINIT:4C80		     push    ds
SYSINIT:4C81		     push    es
SYSINIT:4C82		     pop     ds
SYSINIT:4C83		     mov     bl, al
SYSINIT:4C85
SYSINIT:4C85 convloop:				     ; ...
SYSINIT:4C85		     lodsb
SYSINIT:4C86		     cmp     al, 'a'
SYSINIT:4C88		     jb	     short noconv
SYSINIT:4C8A		     cmp     al, 'z'
SYSINIT:4C8C		     ja	     short noconv
SYSINIT:4C8E		     sub     al, 20h	     ; convert to upper-case (and al,0DFh)
SYSINIT:4C90		     mov     [si-1], al
SYSINIT:4C93
SYSINIT:4C93 noconv:				     ; ...
SYSINIT:4C93		     cmp     bl, 'V'         ; CONFIG_SET ; preserve case for part of the line?
SYSINIT:4C96		     jnz     short check_eol ; no, just	check for end-of-line
SYSINIT:4C98		     cmp     al, '='         ; separator between SET var and value?
SYSINIT:4C9A		     jz	     short convdone  ; yes
SYSINIT:4C9A					     ; (we don't want to upper-case
SYSINIT:4C9A					     ; anything	after the "=" in a SET)
SYSINIT:4C9C
SYSINIT:4C9C check_eol:				     ; ...
SYSINIT:4C9C		     cmp     al, 0Dh	     ; cr
SYSINIT:4C9E		     jz	     short convdone
SYSINIT:4CA0		     cmp     al, 0Ah	     ; lf
SYSINIT:4CA2		     jz	     short convdone
SYSINIT:4CA4		     loop    convloop
SYSINIT:4CA6
SYSINIT:4CA6 convdone:				     ; ...
SYSINIT:4CA6		     pop     ds
SYSINIT:4CA7		     pop     si
SYSINIT:4CA8		     pop     cx
SYSINIT:4CA9		     retn
SYSINIT:4CA9 mapcase	     endp
SYSINIT:4CA9
SYSINIT:4CAA
SYSINIT:4CAA ; =============== S U B R O U T I N E =======================================
SYSINIT:4CAA
SYSINIT:4CAA
SYSINIT:4CAA round	     proc near		     ; ...
SYSINIT:4CAA		     push    ax		     ; round the values	in memlo and memhi
SYSINIT:4CAA					     ; to paragraph boundary.
SYSINIT:4CAA					     ; perform bounds check.
SYSINIT:4CAB		     mov     ax, cs:memlo
SYSINIT:4CAF		     call    ParaRound	     ; para round up
SYSINIT:4CB2		     add     cs:memhi, ax
SYSINIT:4CB7		     mov     cs:memlo, 0
SYSINIT:4CBE		     mov     ax, cs:memhi    ; ax = new	memhi
SYSINIT:4CC2		     cmp     ax, cs:ALLOCLIM ; if new memhi >= alloclim, error
SYSINIT:4CC7		     jnb     short mem_err
SYSINIT:4CC9		     test    cs:setdevmarkflag,	2 ; for_devmark
SYSINIT:4CCF		     jz	     short skip_set_devmarksize
SYSINIT:4CD1		     push    es
SYSINIT:4CD2		     push    si
SYSINIT:4CD3		     mov     si, cs:devmark_addr
SYSINIT:4CD8		     mov     es, si
SYSINIT:4CDA		     sub     ax, si
SYSINIT:4CDC		     dec     ax
SYSINIT:4CDD		     mov     es:3, ax	     ; mov [es:devmark.size],ax	; paragraph
SYSINIT:4CE1		     and     cs:setdevmarkflag,	0FDh ; ~2 ; not	2
SYSINIT:4CE1					     ; not_for_devmark
SYSINIT:4CE7		     pop     si
SYSINIT:4CE8		     pop     es
SYSINIT:4CE9
SYSINIT:4CE9 skip_set_devmarksize:		     ; ...
SYSINIT:4CE9		     pop     ax
SYSINIT:4CEA		     clc
SYSINIT:4CEB		     retn
SYSINIT:4CEC ; ---------------------------------------------------------------------------
SYSINIT:4CEC
SYSINIT:4CEC mem_err:				     ; ...
SYSINIT:4CEC		     mov     dx, offset	badmem ; "\r\nConfiguration too	large for memory\"...
SYSINIT:4CEF		     push    cs
SYSINIT:4CF0		     pop     ds
SYSINIT:4CF1		     assume ds:SYSINIT
SYSINIT:4CF1		     call    print
SYSINIT:4CF4		     jmp     stall
SYSINIT:4CF4 round	     endp
SYSINIT:4CF4
SYSINIT:4CF7
SYSINIT:4CF7 ; =============== S U B R O U T I N E =======================================
SYSINIT:4CF7
SYSINIT:4CF7
SYSINIT:4CF7 calldev	     proc near		     ; ...
SYSINIT:4CF7		     mov     ds, word ptr cs:DevEntry+2
SYSINIT:4CFC		     assume ds:nothing
SYSINIT:4CFC		     add     bx, word ptr cs:DevEntry ;	do a little relocation
SYSINIT:4D01		     mov     ax, [bx]
SYSINIT:4D03		     push    word ptr cs:DevEntry
SYSINIT:4D08		     mov     word ptr cs:DevEntry, ax
SYSINIT:4D0C		     mov     bx, 36Ah
SYSINIT:4D0F		     call    cs:DevEntry
SYSINIT:4D14		     pop     word ptr cs:DevEntry
SYSINIT:4D19		     retn
SYSINIT:4D19 calldev	     endp
SYSINIT:4D19
SYSINIT:4D1A
SYSINIT:4D1A ; =============== S U B R O U T I N E =======================================
SYSINIT:4D1A
SYSINIT:4D1A
SYSINIT:4D1A todigit	     proc near		     ; ...
SYSINIT:4D1A		     sub     al, '0'
SYSINIT:4D1C		     jb	     short notdig
SYSINIT:4D1E		     cmp     al, 9
SYSINIT:4D20		     ja	     short notdig
SYSINIT:4D22		     clc
SYSINIT:4D23		     retn
SYSINIT:4D24 ; ---------------------------------------------------------------------------
SYSINIT:4D24
SYSINIT:4D24 notdig:				     ; ...
SYSINIT:4D24		     stc
SYSINIT:4D25		     retn
SYSINIT:4D25 todigit	     endp
SYSINIT:4D25
SYSINIT:4D26
SYSINIT:4D26 ; =============== S U B R O U T I N E =======================================
SYSINIT:4D26
SYSINIT:4D26
SYSINIT:4D26 getnum	     proc near		     ; ...
SYSINIT:4D26		     push    bx		     ; getnum parses a decimal number.
SYSINIT:4D26					     ; returns it in ax, sets zero flag	if ax =	0
SYSINIT:4D26					     ; (may be considered an error),
SYSINIT:4D26					     ; if number is bad	carry is set, zero is set, ax=0.
SYSINIT:4D26					     ; ;;
SYSINIT:4D27		     xor     bx, bx	     ; running count is	zero
SYSINIT:4D29
SYSINIT:4D29 b2:				     ; ...
SYSINIT:4D29		     call    todigit	     ; do we have a digit ?
SYSINIT:4D2C		     jb	     short badnum    ; no, bomb
SYSINIT:4D2E		     xchg    ax, bx	     ; put total in ax
SYSINIT:4D2F		     push    bx		     ; save digit (0 to	9)
SYSINIT:4D30		     mov     bx, 10	     ; base of arithmetic
SYSINIT:4D33		     mul     bx		     ; shift by	one decimal digit
SYSINIT:4D35		     pop     bx		     ; get back	digit (0 to 9)
SYSINIT:4D36		     add     al, bl	     ; get total
SYSINIT:4D38		     adc     ah, 0	     ; make that 16 bits
SYSINIT:4D3B		     jb	     short badnum    ; too big a number
SYSINIT:4D3D		     xchg    ax, bx	     ; stash total
SYSINIT:4D3E		     call    getchr	     ; get next	digit
SYSINIT:4D41		     jb	     short b1	     ; no more characters
SYSINIT:4D43		     cmp     al, ' '         ; space?
SYSINIT:4D45		     jz	     short b15	     ; then end	of digits
SYSINIT:4D47		     cmp     al, ','         ; ',' is a seperator!!!
SYSINIT:4D49		     jz	     short b15	     ; then end	of digits.
SYSINIT:4D4B		     cmp     al, 9	     ; tab
SYSINIT:4D4D		     jz	     short b15
SYSINIT:4D4F		     cmp     al, cs:sepchr   ; allow 0 or special separators
SYSINIT:4D54		     jz	     short b15
SYSINIT:4D56		     cmp     al, '/'         ; see if another switch follows
SYSINIT:4D58		     nop		     ; cas - remnant of	old bad	code
SYSINIT:4D59		     nop		     ; (04/08/2023 - Erdogan Tan - 'nop,nop' is not neded)
SYSINIT:4D5A		     jz	     short b15
SYSINIT:4D5C		     cmp     al, 0Ah	     ; lf ; line-feed?
SYSINIT:4D5E		     jz	     short b15
SYSINIT:4D60		     cmp     al, 0Dh	     ; cr ; carriage return?
SYSINIT:4D62		     jz	     short b15
SYSINIT:4D64		     or	     al, al	     ; end of line separator?
SYSINIT:4D66		     jnz     short b2	     ; no, try as a valid char...
SYSINIT:4D68
SYSINIT:4D68 b15:				     ; ...
SYSINIT:4D68		     inc     cs:count	     ; one more	character to s...
SYSINIT:4D6D		     dec     cs:chrptr	     ; clears carry, sets zero accordingly
SYSINIT:4D72
SYSINIT:4D72 b1:				     ; ...
SYSINIT:4D72		     mov     ax, bx
SYSINIT:4D74		     or	     ax, ax
SYSINIT:4D76		     pop     bx
SYSINIT:4D77		     retn
SYSINIT:4D78 ; ---------------------------------------------------------------------------
SYSINIT:4D78
SYSINIT:4D78 badnum:				     ; ...
SYSINIT:4D78		     mov     cs:sepchr,	0
SYSINIT:4D7E		     xor     ax, ax	     ; set zero	flag, and ax = 0
SYSINIT:4D80		     pop     bx
SYSINIT:4D81		     stc		     ; and carry set
SYSINIT:4D82		     retn
SYSINIT:4D82 getnum	     endp
SYSINIT:4D82
SYSINIT:4D83
SYSINIT:4D83 ; =============== S U B R O U T I N E =======================================
SYSINIT:4D83
SYSINIT:4D83
SYSINIT:4D83 setdoscountryinfo proc near	     ; ...
SYSINIT:4D83		     push    di		     ; input:
SYSINIT:4D83					     ;	 es:di -> pointer to dos_country_cdpg_info
SYSINIT:4D83					     ;	 ds:0  -> buffer.
SYSINIT:4D83					     ;	    si = 0
SYSINIT:4D83					     ;	    ax = country id
SYSINIT:4D83					     ;	    dx = code page id. (if 0, then use ccsyscodepage as	a default.)
SYSINIT:4D83					     ;	    bx = file handle
SYSINIT:4D83					     ;	 this routine can handle maximum 438 country_data entries.
SYSINIT:4D83					     ; output:
SYSINIT:4D83					     ;	 dos_country_cdpg_info set.
SYSINIT:4D83					     ;	 carry set if any file read failure or wrong information in the	file.
SYSINIT:4D83					     ;	 carry set and cx = -1 if cannot find the matching country_id,
SYSINIT:4D83					     ;	       codepage_id in the file.
SYSINIT:4D84		     push    ax
SYSINIT:4D85		     push    dx
SYSINIT:4D86		     xor     cx, cx
SYSINIT:4D88		     xor     dx, dx
SYSINIT:4D8A		     mov     ax, 512	     ; read 512	bytes
SYSINIT:4D8D		     call    readincontrolbuffer ; read	the file header
SYSINIT:4D90		     jb	     short setdosdata_fail
SYSINIT:4D92		     push    es
SYSINIT:4D93		     push    si
SYSINIT:4D94		     push    cs
SYSINIT:4D95		     pop     es
SYSINIT:4D96		     assume es:SYSINIT
SYSINIT:4D96		     mov     di, offset	country_file_signature ; db 0FFh,'COUNTRY'
SYSINIT:4D99		     mov     cx, 8	     ; length of the signature
SYSINIT:4D9C		     repe cmpsb
SYSINIT:4D9E		     pop     si
SYSINIT:4D9F		     pop     es
SYSINIT:4DA0		     assume es:nothing
SYSINIT:4DA0		     jnz     short setdosdata_fail ; signature mismatch
SYSINIT:4DA2		     add     si, 18
SYSINIT:4DA5		     cmp     byte ptr [si], 1 ;	si -> county info type
SYSINIT:4DA5					     ; only accept type	1 (currently only 1 header type)
SYSINIT:4DA8		     jnz     short setdosdata_fail ; cannot proceed. error return
SYSINIT:4DAA		     inc     si		     ; si -> file offset
SYSINIT:4DAB		     mov     dx, [si]	     ; get the info file offset.
SYSINIT:4DAD		     mov     cx, [si+2]
SYSINIT:4DB0		     mov     ax, 6144	     ; read 6144 bytes.
SYSINIT:4DB3		     call    readincontrolbuffer ; read	info
SYSINIT:4DB6		     jb	     short setdosdata_fail
SYSINIT:4DB8		     mov     cx, [si]	     ; get the # of country, codepage combination entries
SYSINIT:4DBA		     cmp     cx, 438	     ; cannot handle more than 438 entries.
SYSINIT:4DBE		     ja	     short setdosdata_fail
SYSINIT:4DC0		     inc     si
SYSINIT:4DC1		     inc     si		     ; si -> entry information packet
SYSINIT:4DC2		     pop     dx		     ; restore code page id
SYSINIT:4DC3		     pop     ax		     ; restore country id
SYSINIT:4DC4		     pop     di		     ; search for desired country_id,codepage_id.
SYSINIT:4DC5
SYSINIT:4DC5 setdoscntry_find:			     ; ...
SYSINIT:4DC5		     cmp     ax, [si+2]	     ; compare country_id
SYSINIT:4DC8		     jnz     short setdoscntry_next
SYSINIT:4DCA		     cmp     dx, 0	     ; no user specified code page ?
SYSINIT:4DCD		     jz	     short setdoscntry_any_codepage ; then no need to match code page id.
SYSINIT:4DCF		     cmp     dx, [si+4]	     ; compare code page id
SYSINIT:4DD2		     jz	     short setdoscntry_got_it
SYSINIT:4DD4
SYSINIT:4DD4 setdoscntry_next:			     ; ...
SYSINIT:4DD4		     add     si, [si]	     ; next entry
SYSINIT:4DD6		     inc     si
SYSINIT:4DD7		     inc     si		     ; take a word for size of entry itself
SYSINIT:4DD8		     loop    setdoscntry_find
SYSINIT:4DDA		     mov     cx, 0FFFFh	     ; -1 ; signals that bad country id	entered.
SYSINIT:4DDD
SYSINIT:4DDD setdoscntry_fail:			     ; ...
SYSINIT:4DDD		     stc
SYSINIT:4DDE		     retn
SYSINIT:4DDF ; ---------------------------------------------------------------------------
SYSINIT:4DDF
SYSINIT:4DDF setdosdata_fail:			     ; ...
SYSINIT:4DDF		     pop     si
SYSINIT:4DE0		     pop     cx
SYSINIT:4DE1		     pop     di
SYSINIT:4DE2		     jmp     short setdoscntry_fail
SYSINIT:4DE4 ; ---------------------------------------------------------------------------
SYSINIT:4DE4
SYSINIT:4DE4 setdoscntry_any_codepage:		     ; ...
SYSINIT:4DE4		     mov     dx, [si+4]	     ; use the code_page_id of the country_id found.
SYSINIT:4DE7
SYSINIT:4DE7 setdoscntry_got_it:		     ; ...
SYSINIT:4DE7		     mov     cs:cntrycodepage_id, dx ; save code page id for this country.
SYSINIT:4DEC		     mov     dx, [si+10]     ; get the file offset of country data
SYSINIT:4DEF		     mov     cx, [si+12]
SYSINIT:4DF2		     mov     ax, 512	     ; read 512	bytes
SYSINIT:4DF5		     call    readincontrolbuffer
SYSINIT:4DF8		     jb	     short setdoscntry_fail
SYSINIT:4DFA		     mov     cx, [si]	     ; get the number of entries to handle.
SYSINIT:4DFC		     inc     si
SYSINIT:4DFD		     inc     si		     ; si -> first entry
SYSINIT:4DFE
SYSINIT:4DFE setdoscntry_data:			     ; ...
SYSINIT:4DFE		     push    di		     ; es:di ->	dos_country_cdpg_info
SYSINIT:4DFF		     push    cx		     ; save # of entry left
SYSINIT:4E00		     push    si		     ; si -> current entry in control buffer
SYSINIT:4E01		     mov     al, [si+2]	     ; get data	entry id
SYSINIT:4E04		     call    getcountrydestination ; get the address of	destination in es:di
SYSINIT:4E07		     jb	     short setdoscntry_data_next ; no matching data entry id in	dos
SYSINIT:4E09		     mov     dx, [si+4]	     ; get offset of data
SYSINIT:4E0C		     mov     cx, [si+6]
SYSINIT:4E0F		     mov     ax, 4200h
SYSINIT:4E12		     stc
SYSINIT:4E13		     int     21h	     ; DOS - 2+	- MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:4E13					     ; AL = method: offset from	beginning of file
SYSINIT:4E15		     jb	     short setdosdata_fail ;
SYSINIT:4E15					     ; read the	country.sys data
SYSINIT:4E17		     mov     dx, 512	     ; start of	data buffer
SYSINIT:4E1A		     mov     cx, 20	     ; read 20 bytes only. we only need	to
SYSINIT:4E1D		     mov     ah, 3Fh	     ; look at the length of the data in the file.
SYSINIT:4E1F		     stc
SYSINIT:4E20		     int     21h	     ; DOS - 2+	- READ FROM FILE WITH HANDLE
SYSINIT:4E20					     ; BX = file handle, CX = number of	bytes to read
SYSINIT:4E20					     ; DS:DX ->	buffer
SYSINIT:4E22		     jb	     short setdosdata_fail ; read failure
SYSINIT:4E24		     cmp     ax, cx
SYSINIT:4E26		     jnz     short setdosdata_fail
SYSINIT:4E28		     mov     dx, [si+4]	     ; get offset of data again.
SYSINIT:4E2B		     mov     cx, [si+6]
SYSINIT:4E2E		     mov     ax, 4200h	     ; move pointer back again
SYSINIT:4E31		     stc
SYSINIT:4E32		     int     21h	     ; DOS - 2+	- MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:4E32					     ; AL = method: offset from	beginning of file
SYSINIT:4E34		     jb	     short setdosdata_fail
SYSINIT:4E36		     push    si
SYSINIT:4E37		     mov     si, 520	     ; (512+8) ; get length of the data	from the file
SYSINIT:4E3A		     mov     cx, [si]
SYSINIT:4E3C		     pop     si
SYSINIT:4E3D		     mov     dx, 512	     ; start of	data buffer
SYSINIT:4E40		     add     cx, 10	     ; signature + a word for the length itself
SYSINIT:4E43		     mov     ah, 3Fh	     ; read the	data from the file.
SYSINIT:4E45		     stc
SYSINIT:4E46		     int     21h	     ; DOS - 2+	- READ FROM FILE WITH HANDLE
SYSINIT:4E46					     ; BX = file handle, CX = number of	bytes to read
SYSINIT:4E46					     ; DS:DX ->	buffer
SYSINIT:4E48		     jb	     short setdosdata_fail
SYSINIT:4E4A		     cmp     ax, cx
SYSINIT:4E4C		     jnz     short setdosdata_fail
SYSINIT:4E4E		     mov     al, [si+2]	     ; save data id for	future use.
SYSINIT:4E51		     mov     si, 520	     ; (512+8) ; si-> data buffer + id tag field
SYSINIT:4E54		     mov     cx, [si]	     ; get the length of the file
SYSINIT:4E56		     inc     cx		     ; take care of a word for lenght of tab itself.
SYSINIT:4E57		     inc     cx
SYSINIT:4E58		     cmp     cx, 1528	     ; (2048-512-8) ; fit into the buffer?
SYSINIT:4E5C		     ja	     short setdosdata_fail
SYSINIT:4E5E		     call    setdbcs_before_copy
SYSINIT:4E61		     cmp     al, 1	     ; SetCountryInfo ;	is the data for	setcountryinfo table?
SYSINIT:4E63		     jnz     short setdoscntry_mov ; no, don't worry
SYSINIT:4E65		     push    word ptr es:[di+24] ;
SYSINIT:4E65					     ; [es:di+country_cdpg_info.ccMono_Ptr
SYSINIT:4E65					     ;	-country_cdpg_info.ccCountryInfoLen]
SYSINIT:4E69		     push    word ptr es:[di+26] ;
SYSINIT:4E69					     ; [es:di+country_cdpg_info.ccMono_Ptr
SYSINIT:4E69					     ;	-country_cdpg_info.ccCountryInfoLen+2]
SYSINIT:4E69					     ;
SYSINIT:4E69					     ; at this time di -> cccountryinfolen
SYSINIT:4E6D		     push    di
SYSINIT:4E6E		     push    ax
SYSINIT:4E6F		     mov     ax, cs:cntrycodepage_id ; do not use the code page	info in	country_info
SYSINIT:4E73		     mov     [si+4], ax	     ; use the saved one for this !!!
SYSINIT:4E76		     pop     ax
SYSINIT:4E77
SYSINIT:4E77 setdoscntry_mov:			     ; ...
SYSINIT:4E77		     rep movsb		     ; copy the	table into dos
SYSINIT:4E79		     cmp     al, 1	     ; SetCountryInfo ;	was the	ccmono_ptr saved?
SYSINIT:4E7B		     jnz     short setdoscntry_data_next
SYSINIT:4E7D		     pop     di
SYSINIT:4E7E		     pop     word ptr es:[di+26] ;
SYSINIT:4E7E					     ; [es:di+country_cdpg_info.ccMono_Ptr
SYSINIT:4E7E					     ;	-country_cdpg_info.ccCountryInfoLen+2]
SYSINIT:4E82		     pop     word ptr es:[di+24] ;
SYSINIT:4E82					     ; [es:di+country_cdpg_info.ccMono_Ptr
SYSINIT:4E82					     ;	-country_cdpg_info.ccCountryInfoLen]
SYSINIT:4E86
SYSINIT:4E86 setdoscntry_data_next:		     ; ...
SYSINIT:4E86		     pop     si		     ; restore control buffer pointer
SYSINIT:4E87		     pop     cx		     ; restore # of entries left
SYSINIT:4E88		     pop     di		     ; restore pointer to dso_country_cdpg
SYSINIT:4E89		     add     si, [si]	     ; try to get the next entry
SYSINIT:4E8B		     inc     si
SYSINIT:4E8C		     inc     si		     ; take a word of entry length itself
SYSINIT:4E8D		     dec     cx
SYSINIT:4E8E		     cmp     cx, 0
SYSINIT:4E91		     jz	     short setdoscntry_ok
SYSINIT:4E93		     jmp     setdoscntry_data
SYSINIT:4E96 ; ---------------------------------------------------------------------------
SYSINIT:4E96
SYSINIT:4E96 setdoscntry_ok:			     ; ...
SYSINIT:4E96		     retn
SYSINIT:4E96 setdoscountryinfo endp
SYSINIT:4E96
SYSINIT:4E97
SYSINIT:4E97 ; =============== S U B R O U T I N E =======================================
SYSINIT:4E97
SYSINIT:4E97
SYSINIT:4E97 setdbcs_before_copy proc near	     ; ...
SYSINIT:4E97		     cmp     al, 7	     ; SetDBCS ; dbcs vector set?
SYSINIT:4E99		     jnz     short sdbcsbc   ; jump if not
SYSINIT:4E9B		     cmp     word ptr es:[di], 0 ; zero	byte data block?
SYSINIT:4E9F		     jz	     short sdbcsbc   ; jump if so
SYSINIT:4EA1		     push    di
SYSINIT:4EA2		     push    ax
SYSINIT:4EA3		     push    cx
SYSINIT:4EA4		     mov     cx, es:[di]     ; load block length
SYSINIT:4EA7		     add     di, 2	     ; points actual data
SYSINIT:4EAA		     xor     al, al	     ; fill bytes
SYSINIT:4EAC		     rep stosb		     ; clear data block
SYSINIT:4EAE		     pop     cx
SYSINIT:4EAF		     pop     ax
SYSINIT:4EB0		     pop     di
SYSINIT:4EB1
SYSINIT:4EB1 sdbcsbc:				     ; ...
SYSINIT:4EB1		     retn
SYSINIT:4EB1 setdbcs_before_copy endp
SYSINIT:4EB1
SYSINIT:4EB2
SYSINIT:4EB2 ; =============== S U B R O U T I N E =======================================
SYSINIT:4EB2
SYSINIT:4EB2
SYSINIT:4EB2 getcountrydestination proc	near	     ; ...
SYSINIT:4EB2		     push    cx		     ; get the destination address
SYSINIT:4EB2					     ;	in the dos country info	table.
SYSINIT:4EB3		     add     di, 74	     ; country_cdpg_info.ccNumber_of_entries
SYSINIT:4EB3					     ; skip the	reserved area, syscodepage etc.
SYSINIT:4EB6		     mov     cx, es:[di]     ; get the number of entries
SYSINIT:4EB9		     inc     di
SYSINIT:4EBA		     inc     di		     ; si -> the first start entry id
SYSINIT:4EBB
SYSINIT:4EBB getcntrydest:			     ; ...
SYSINIT:4EBB		     cmp     es:[di], al
SYSINIT:4EBE		     jz	     short getcntrydest_ok
SYSINIT:4EC0		     cmp     byte ptr es:[di], 1 ; SetCountryInfo ; was	it setcountryinfo entry?
SYSINIT:4EC4		     jz	     short getcntrydest_1
SYSINIT:4EC6		     add     di, 5	     ; next data id
SYSINIT:4EC9		     jmp     short getcntrydest_loop
SYSINIT:4ECB ; ---------------------------------------------------------------------------
SYSINIT:4ECB
SYSINIT:4ECB getcntrydest_1:			     ; ...
SYSINIT:4ECB		     add     di, 41	     ; NEW_COUNTRY_SIZE+3 ; next data id
SYSINIT:4ECE
SYSINIT:4ECE getcntrydest_loop:			     ; ...
SYSINIT:4ECE		     loop    getcntrydest
SYSINIT:4ED0		     stc
SYSINIT:4ED1		     jmp     short getcntrydest_exit
SYSINIT:4ED3 ; ---------------------------------------------------------------------------
SYSINIT:4ED3
SYSINIT:4ED3 getcntrydest_ok:			     ; ...
SYSINIT:4ED3		     cmp     al, 1	     ; SetCountryInfo ;	select country info?
SYSINIT:4ED5		     jnz     short getcntrydest_ok1
SYSINIT:4ED7		     inc     di		     ; now di -> cccountryinfolen
SYSINIT:4ED8		     jmp     short getcntrydest_exit
SYSINIT:4EDA ; ---------------------------------------------------------------------------
SYSINIT:4EDA
SYSINIT:4EDA getcntrydest_ok1:			     ; ...
SYSINIT:4EDA		     les     di, es:[di+1]   ; get the destination in es:di
SYSINIT:4EDE
SYSINIT:4EDE getcntrydest_exit:			     ; ...
SYSINIT:4EDE		     pop     cx
SYSINIT:4EDF		     retn
SYSINIT:4EDF getcountrydestination endp
SYSINIT:4EDF
SYSINIT:4EE0
SYSINIT:4EE0 ; =============== S U B R O U T I N E =======================================
SYSINIT:4EE0
SYSINIT:4EE0
SYSINIT:4EE0 readincontrolbuffer proc near	     ; ...
SYSINIT:4EE0		     push    ax		     ; # of bytes to read
SYSINIT:4EE1		     mov     ax, 4200h
SYSINIT:4EE4		     stc
SYSINIT:4EE5		     int     21h	     ; DOS - 2+	- MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:4EE5					     ; AL = method: offset from	beginning of file
SYSINIT:4EE7		     pop     cx		     ; # of bytes to read
SYSINIT:4EE8		     jb	     short ricb_exit
SYSINIT:4EEA		     xor     dx, dx	     ; ds:dx ->	control	buffer
SYSINIT:4EEC		     xor     si, si
SYSINIT:4EEE		     mov     ah, 3Fh	     ; read into the buffer
SYSINIT:4EEE					     ; should be less than 1024	bytes.
SYSINIT:4EF0		     stc
SYSINIT:4EF1		     int     21h	     ; DOS - 2+	- READ FROM FILE WITH HANDLE
SYSINIT:4EF1					     ; BX = file handle, CX = number of	bytes to read
SYSINIT:4EF1					     ; DS:DX ->	buffer
SYSINIT:4EF3
SYSINIT:4EF3 ricb_exit:				     ; ...
SYSINIT:4EF3		     retn
SYSINIT:4EF3 readincontrolbuffer endp
SYSINIT:4EF3
SYSINIT:4EF4 ; ---------------------------------------------------------------------------
SYSINIT:4EF4
SYSINIT:4EF4 set_country_path:			     ; ! this procedure	is not called from anywhere !
SYSINIT:4EF4		     push    si		     ; Erdogan Tan - 04/08/2023
SYSINIT:4EF5		     push    ds
SYSINIT:4EF6		     push    es
SYSINIT:4EF7		     pop     ds
SYSINIT:4EF8		     pop     es
SYSINIT:4EF9		     call    chk_drive_letter
SYSINIT:4EFC		     jb	     short scp_default_drv
SYSINIT:4EFE		     mov     al, [si]
SYSINIT:4F00		     inc     si
SYSINIT:4F01		     inc     si
SYSINIT:4F02		     jmp     short scp_setdrv
SYSINIT:4F04 ; ---------------------------------------------------------------------------
SYSINIT:4F04
SYSINIT:4F04 scp_default_drv:			     ; ...
SYSINIT:4F04		     mov     ah, 19h
SYSINIT:4F06		     int     21h	     ; DOS - GET DEFAULT DISK NUMBER
SYSINIT:4F08		     add     al, 'A'
SYSINIT:4F0A
SYSINIT:4F0A scp_setdrv:			     ; ...
SYSINIT:4F0A		     mov     byte ptr cs:cntry_drv, al ; "A:"
SYSINIT:4F0E		     mov     di, offset	cntry_path ; "COUNTRY.SYS"
SYSINIT:4F11		     mov     al, [si]
SYSINIT:4F13		     cmp     al, '\'
SYSINIT:4F15		     jz	     short scp_root_dir
SYSINIT:4F17		     cmp     al, '/'
SYSINIT:4F19		     jz	     short scp_root_dir
SYSINIT:4F1B		     jmp     short scp_path
SYSINIT:4F1D ; ---------------------------------------------------------------------------
SYSINIT:4F1D
SYSINIT:4F1D scp_root_dir:			     ; ...
SYSINIT:4F1D		     dec     di
SYSINIT:4F1E
SYSINIT:4F1E scp_path:				     ; ...
SYSINIT:4F1E		     call    move_asciiz
SYSINIT:4F21		     mov     di, offset	cntry_drv ; "A:"
SYSINIT:4F24		     push    ds
SYSINIT:4F25		     push    es
SYSINIT:4F26		     pop     ds
SYSINIT:4F27		     pop     es
SYSINIT:4F28		     pop     si
SYSINIT:4F29		     retn
SYSINIT:4F2A
SYSINIT:4F2A ; =============== S U B R O U T I N E =======================================
SYSINIT:4F2A
SYSINIT:4F2A
SYSINIT:4F2A chk_drive_letter proc near		     ; ...
SYSINIT:4F2A		     push    ax
SYSINIT:4F2B		     cmp     byte ptr [si], 'A'
SYSINIT:4F2E		     jb	     short cdletter_no
SYSINIT:4F30		     cmp     byte ptr [si], 'Z'
SYSINIT:4F33		     ja	     short cdletter_no
SYSINIT:4F35		     cmp     byte ptr [si+1], ':'
SYSINIT:4F39		     jnz     short cdletter_no
SYSINIT:4F3B		     jmp     short cdletter_exit
SYSINIT:4F3D ; ---------------------------------------------------------------------------
SYSINIT:4F3D
SYSINIT:4F3D cdletter_no:			     ; ...
SYSINIT:4F3D		     stc
SYSINIT:4F3E
SYSINIT:4F3E cdletter_exit:			     ; ...
SYSINIT:4F3E		     pop     ax
SYSINIT:4F3F		     retn
SYSINIT:4F3F chk_drive_letter endp
SYSINIT:4F3F
SYSINIT:4F40
SYSINIT:4F40 ; =============== S U B R O U T I N E =======================================
SYSINIT:4F40
SYSINIT:4F40
SYSINIT:4F40 move_asciiz     proc near		     ; ...
SYSINIT:4F40		     movsb
SYSINIT:4F41		     cmp     byte ptr [si-1], 0	; was it 0?
SYSINIT:4F45		     jnz     short move_asciiz
SYSINIT:4F47		     retn
SYSINIT:4F47 move_asciiz     endp
SYSINIT:4F47
SYSINIT:4F48
SYSINIT:4F48 ; =============== S U B R O U T I N E =======================================
SYSINIT:4F48
SYSINIT:4F48
SYSINIT:4F48 badfil	     proc near		     ; ...
SYSINIT:4F48		     push    cs
SYSINIT:4F49		     pop     es
SYSINIT:4F4A		     assume es:SYSINIT
SYSINIT:4F4A		     mov     si, dx
SYSINIT:4F4C
SYSINIT:4F4C badload:				     ; ...
SYSINIT:4F4C		     mov     dx, offset	badld_pre ; "\r\nBad or	missing	$"
SYSINIT:4F4F		     mov     bx, offset	crlfm ;	"\r\n$"
SYSINIT:4F4F badfil	     endp
SYSINIT:4F4F
SYSINIT:4F52
SYSINIT:4F52 ; =============== S U B R O U T I N E =======================================
SYSINIT:4F52
SYSINIT:4F52
SYSINIT:4F52 prnerr	     proc near		     ; ...
SYSINIT:4F52		     push    cs
SYSINIT:4F53		     pop     ds
SYSINIT:4F54		     assume ds:SYSINIT
SYSINIT:4F54		     call    print
SYSINIT:4F57
SYSINIT:4F57 prn1:				     ; ...
SYSINIT:4F57		     mov     dl, es:[si]
SYSINIT:4F5A		     or	     dl, dl
SYSINIT:4F5C		     jz	     short prn2
SYSINIT:4F5E		     mov     ah, 2
SYSINIT:4F60		     int     21h	     ; DOS - DISPLAY OUTPUT
SYSINIT:4F60					     ; DL = character to send to standard output
SYSINIT:4F62		     inc     si
SYSINIT:4F63		     jmp     short prn1
SYSINIT:4F65 ; ---------------------------------------------------------------------------
SYSINIT:4F65
SYSINIT:4F65 prn2:				     ; ...
SYSINIT:4F65		     mov     dx, bx
SYSINIT:4F67		     call    print
SYSINIT:4F6A		     cmp     cs:donotshownum, 1
SYSINIT:4F70		     jz	     short prnexit
SYSINIT:4F72		     call    error_line
SYSINIT:4F75
SYSINIT:4F75 prnexit:				     ; ...
SYSINIT:4F75		     retn
SYSINIT:4F75 prnerr	     endp
SYSINIT:4F75
SYSINIT:4F76
SYSINIT:4F76 ; =============== S U B R O U T I N E =======================================
SYSINIT:4F76
SYSINIT:4F76
SYSINIT:4F76 print	     proc near		     ; ...
SYSINIT:4F76		     mov     ah, 9
SYSINIT:4F78		     int     21h	     ; DOS - PRINT STRING
SYSINIT:4F78					     ; DS:DX ->	string terminated by "$"
SYSINIT:4F7A		     retn
SYSINIT:4F7A print	     endp
SYSINIT:4F7A
SYSINIT:4F7B
SYSINIT:4F7B ; =============== S U B R O U T I N E =======================================
SYSINIT:4F7B
SYSINIT:4F7B
SYSINIT:4F7B open_dev	     proc near		     ; ...
SYSINIT:4F7B		     call    open_file
SYSINIT:4F7E		     jnb     short open_dev3
SYSINIT:4F80
SYSINIT:4F80 open_dev1:				     ; ...
SYSINIT:4F80		     mov     dx, offset	nuldev ; "NUL"
SYSINIT:4F83		     call    open_file
SYSINIT:4F86
SYSINIT:4F86 of_retn:				     ; ...
SYSINIT:4F86		     retn
SYSINIT:4F87 ; ---------------------------------------------------------------------------
SYSINIT:4F87
SYSINIT:4F87 open_dev3:				     ; ...
SYSINIT:4F87		     mov     bx, ax
SYSINIT:4F89		     xor     ax, ax
SYSINIT:4F8B		     mov     ah, 44h
SYSINIT:4F8D		     int     21h	     ; DOS - 2+	- IOCTL	- GET DEVICE INFORMATION
SYSINIT:4F8D					     ; BX = file or device handle
SYSINIT:4F8F		     test    dl, 80h
SYSINIT:4F92		     jnz     short of_retn
SYSINIT:4F94		     mov     ah, 3Eh
SYSINIT:4F96		     int     21h	     ; DOS - 2+	- CLOSE	A FILE WITH HANDLE
SYSINIT:4F96					     ; BX = file handle
SYSINIT:4F98		     jmp     short open_dev1
SYSINIT:4F98 open_dev	     endp
SYSINIT:4F98
SYSINIT:4F9A
SYSINIT:4F9A ; =============== S U B R O U T I N E =======================================
SYSINIT:4F9A
SYSINIT:4F9A
SYSINIT:4F9A open_file	     proc near		     ; ...
SYSINIT:4F9A		     mov     ah, 3Dh	     ; OPEN
SYSINIT:4F9C		     stc
SYSINIT:4F9D		     int     21h	     ; DOS - 2+	- OPEN DISK FILE WITH HANDLE
SYSINIT:4F9D					     ; DS:DX ->	ASCIZ filename
SYSINIT:4F9D					     ; AL = access mode
SYSINIT:4F9D					     ; 0 - read
SYSINIT:4F9F		     retn
SYSINIT:4F9F open_file	     endp
SYSINIT:4F9F
SYSINIT:4FA0 ; ---------------------------------------------------------------------------
SYSINIT:4FA0
SYSINIT:4FA0 int24:				     ; ...
SYSINIT:4FA0		     mov     al, 3	     ; fail the	system call
SYSINIT:4FA2		     iret		     ; return back to dos.
SYSINIT:4FA2 ; ---------------------------------------------------------------------------
SYSINIT:4FA3 MsDosVersion6Copyr	db 'MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp Licensed M'
SYSINIT:4FA3		     db	'aterial - Property of Microsoft All rights reserved '
SYSINIT:5018 nuldev	     db	'NUL',0              ; ...
SYSINIT:501C condev	     db	'CON',0              ; ...
SYSINIT:5020 auxdev	     db	'AUX',0              ; ...
SYSINIT:5024 prndev	     db	'PRN',0              ; ...
SYSINIT:5028 config	     db	'\CONFIG.SYS',0      ; ...
SYSINIT:5034 cntry_drv	     db	'A:'                 ; ...
SYSINIT:5036 cntry_root	     db	'\'                  ; ...
SYSINIT:5037 cntry_path	     db	'COUNTRY.SYS',0      ; ...
SYSINIT:5043		     db	52 dup(0)
SYSINIT:5077 country_file_signature db 0FFh	     ; ...
SYSINIT:5078		     db	'COUNTRY'
SYSINIT:507F cntrycodepage_id dw 0		     ; ...
SYSINIT:5081 newcmd	     db	0		     ; ...
SYSINIT:5081					     ; non-zero	if non-std shell specified
SYSINIT:5082 tmplate	     db	64, 12		     ; ...
SYSINIT:5082					     ; must precede commnd
SYSINIT:5082					     ; size of commnd line (excl. null)
SYSINIT:5082					     ; 50C4h-5084h = 40h = 64
SYSINIT:5084 commnd	     db	'\COMMAND.COM',0     ; ...
SYSINIT:5091		     db	50 dup(0)
SYSINIT:50C3 commnd_63	     db	0		     ; ...
SYSINIT:50C4 commnd2	     db	'\COMMAND.COM',0     ; ...
SYSINIT:50C4					     ; alternate commands to exec
SYSINIT:50D1		     db	2,'/P',0             ; followed by their respective alternate command lines
SYSINIT:50D5 commnd3	     db	'\MSDOS\COMMAND.COM',0 ; ...
SYSINIT:50E8		     db	11
SYSINIT:50E9		     db	'A:\MSDOS /P',0
SYSINIT:50F5 commnd4	     db	'\DOS\COMMAND.COM',0 ; ...
SYSINIT:5106		     db	   9
SYSINIT:5107		     db	'A:\DOS /P',0
SYSINIT:5111 def_swchr	     db	0		     ; ...
SYSINIT:5112 command_line    db	2,'/P'               ; ...
SYSINIT:5112					     ; default command.com args
SYSINIT:5115		     db	123 dup(0)
SYSINIT:5190 command_line_126 db 0		     ; ...
SYSINIT:5191		     db	0
SYSINIT:5192 pathstring	     db	64 dup(0)
SYSINIT:51D2 dae_flag	     db	0		     ; ...
SYSINIT:51D3 bMenuColor	     db	7		     ; ...
SYSINIT:51D3					     ; default fgnd/bgnd color
SYSINIT:51D4 bMenuPage	     db	0		     ; ...
SYSINIT:51D4					     ; menu video page (KEEP AFTER bMenuColor)
SYSINIT:51D5		     db	5		     ; video page function # (KEEP AFTER bMenuPage)
SYSINIT:51D6 bLastCol	     db	0		     ; ...
SYSINIT:51D6					     ; ending column on	status line
SYSINIT:51D7 bLastRow	     db	24		     ; ...
SYSINIT:51D7					     ; row # of	status line (KEEP AFTER	bLastCol)
SYSINIT:51D8 bDisableUI	     db	0		     ; ...
SYSINIT:51D8					     ; 1=disable clean/interactive
SYSINIT:51D8					     ; 2=disable default 2-second delay
SYSINIT:51D9 bCRTPage	     db	0		     ; ...
SYSINIT:51D9					     ; value saved from	BIOS data area
SYSINIT:51DA wCRTStart	     dw	0		     ; ...
SYSINIT:51DA					     ; value saved from	BIOS data area
SYSINIT:51DC bQueryOpt	     db	0		     ; ...
SYSINIT:51DC					     ; 0=off, 1=prompt all, 2=prompt none, 4=skip all
SYSINIT:51DD bDefBlock	     db	1		     ; ...
SYSINIT:51DD					     ; default block #
SYSINIT:51DE bMaxBlock	     db	0		     ; ...
SYSINIT:51DE					     ; maximum block #
SYSINIT:51DF offDefBlock     dw	0		     ; ...
SYSINIT:51DF					     ; offset of name of default block (if any)
SYSINIT:51E1 secTimeOut	     db	0FFh		     ; ...
SYSINIT:51E1					     ; # of seconds for	timeout	(-1 == indefinite)
SYSINIT:51E2 secElapsed	     db	0		     ; ...
SYSINIT:51E2					     ; # of seconds elapsed so far (KEEP AFTER secTimeOut)
SYSINIT:51E3 abBlockType     db	10 dup(0)	     ; ...
SYSINIT:51E3					     ; times MAX_MULTI_CONFIG+1	db 0
SYSINIT:51E3					     ; array of	block types
SYSINIT:51ED aoffBlockName   dw	10 dup(0)	     ; ...
SYSINIT:51ED					     ; times MAX_MULTI_CONFIG+1	dw 0
SYSINIT:51ED					     ; array of	offsets	of block names
SYSINIT:5201 aoffBlockDesc   dw	10 dup(0)	     ; ...
SYSINIT:5201					     ; times MAX_MULTI_CONFIG+1	dw 0
SYSINIT:5201					     ; array of	offsets	of block descriptions
SYSINIT:5215 szBoot	     db	'CONFIG=',0          ; ...
SYSINIT:521D szMenu	     db	'MENU',0             ; ...
SYSINIT:5222 szCommon	     db	'COMMON',0           ; ...
SYSINIT:5229 comtab	     db	1,'[['               ; ...
SYSINIT:5229					     ; CONFIG.SYS Command Table
SYSINIT:5229					     ; CONFIG_BEGIN
SYSINIT:522C aBreak	     db	5,'BREAKC'           ; CONFIG_BREAK
SYSINIT:5233 aBuffers	     db	7,'BUFFERSB'         ; CONFIG_BUFFERS
SYSINIT:523C aComment	     db	7,'COMMENTY'         ; CONFIG_COMMENT
SYSINIT:5245 aCountry	     db	7,'COUNTRYQ'         ; CONFIG_COUNTRY
SYSINIT:524E aDevice	     db	6,'DEVICED'          ; CONFIG_DEVICE
SYSINIT:5256 aDevicehigh     db	0Ah		     ; CONFIG_DEVICEHIGH
SYSINIT:5256		     db	'DEVICEHIGHU'
SYSINIT:5262 aDos	     db	3,'DOSH'             ; CONFIG_DOS
SYSINIT:5267 aDrivparm	     db	8,'DRIVPARMP'        ; CONFIG_DRIVPARM
SYSINIT:5271 aFcbs	     db	4,'FCBSX'            ; CONFIG_FCBS
SYSINIT:5277 aFiles	     db	5,'FILESF'           ; CONFIG_FILES
SYSINIT:527E aInclude	     db	7,'INCLUDEJ'         ; CONFIG_INCLUDE
SYSINIT:5287 aInstall	     db	7,'INSTALLI'         ; CONFIG_INSTALL
SYSINIT:5290 aInstallhigh    db	0Bh,'INSTALLHIGHW'   ; CONFIG_INSTALLHIGH
SYSINIT:529D aLastdrive	     db	9,'LASTDRIVEL'       ; CONFIG_LASTDRIVE
SYSINIT:52A8 aSubmenu	     db	7,'SUBMENUO'         ; CONFIG_SUBMENU
SYSINIT:52B1 aMenucolor	     db	9,'MENUCOLORR'       ; CONFIG_MENUCOLOR
SYSINIT:52BC aMenudefault    db	0Bh,'MENUDEFAULTA'   ; CONFIG_MENUDEFAULT
SYSINIT:52C9 aMenuitem	     db	8,'MENUITEME'        ; CONFIG_MENUITEM
SYSINIT:52D3 aMultitrack     db	0Ah		     ; CONFIG_MULTITRACK
SYSINIT:52D3		     db	'MULTITRACKM'
SYSINIT:52DF aNumlock	     db	7,'NUMLOCKN'         ; CONFIG_NUMLOCK
SYSINIT:52E8 aRem0Set	     db	3,'REM0'             ; CONFIG_REM
SYSINIT:52ED aSet	     db	3,'SETV'             ; CONFIG_SET
SYSINIT:52F2 aShell	     db	5,'SHELLS'           ; CONFIG_SHELL
SYSINIT:52F9 aStacks	     db	6,'STACKSK'          ; CONFIG_STACKS
SYSINIT:5301 aSwitches	     db	8,'SWITCHES1'        ; CONFIG_SWITCHES
SYSINIT:530B		     db	0		     ; end of command table
SYSINIT:530C devp_specialfunc db 0		     ; ...
SYSINIT:530C					     ; deviceparameters
SYSINIT:530D devp_devtype    db	2		     ; ...
SYSINIT:530E devp_devattr    dw	0		     ; ...
SYSINIT:5310 devp_cylinders  dw	80		     ; ...
SYSINIT:5312		     db	0
SYSINIT:5313 devp_bps	     dw	0		     ; ...
SYSINIT:5313					     ; A_DEVICEPARAMETERS.DP_BPB
SYSINIT:5313					     ; bytes per sectors
SYSINIT:5315 devp_secperclus db	6 dup(0)	     ; ...
SYSINIT:531B devp_totalsecs  dw	0		     ; ...
SYSINIT:531D devp_mediaid    db	3 dup(0)	     ; ...
SYSINIT:5320 devp_spt	     dw	0		     ; ...
SYSINIT:5322 devp_heads	     dw	0		     ; ...
SYSINIT:5324		     db	14 dup(0)
SYSINIT:5332 devp_trktblents dw	0		     ; ...
SYSINIT:5334		     db	252 dup(0)
SYSINIT:5430 hlim	     dw	2		     ; ...
SYSINIT:5432 slim	     dw	9		     ; ...
SYSINIT:5434 drive	     db	0		     ; ...
SYSINIT:5435 switches	     dw	0		     ; ...
SYSINIT:5437 _bpb48t	     dw	512		     ; ...
SYSINIT:5437					     ; 48 tpi diskettes
SYSINIT:5439		     db	2
SYSINIT:543A		     dw	1
SYSINIT:543C		     db	2
SYSINIT:543D		     dw	112
SYSINIT:543F		     dw	720		     ; 2*9*40
SYSINIT:5441		     db	0FDh
SYSINIT:5442		     dw	2
SYSINIT:5444		     dw	9
SYSINIT:5446		     dw	2
SYSINIT:5448		     dd	0
SYSINIT:544C		     dd	0
SYSINIT:5450 _bpb96t	     dw	512		     ; ...
SYSINIT:5450					     ; 96 tpi diskettes
SYSINIT:5452		     db	1
SYSINIT:5453		     dw	1
SYSINIT:5455		     db	2
SYSINIT:5456		     dw	224
SYSINIT:5458		     dw	2400		     ; 2*15*80
SYSINIT:545A		     db	0F9h
SYSINIT:545B		     dw	7
SYSINIT:545D		     dw	15
SYSINIT:545F		     dw	2
SYSINIT:5461		     dd	0
SYSINIT:5465		     dd	0
SYSINIT:5469 _bpb35	     dw	512		     ; ...
SYSINIT:5469					     ; 3 1/2 inch diskette bpb
SYSINIT:546B		     db	2
SYSINIT:546C		     dw	1
SYSINIT:546E		     db	2
SYSINIT:546F		     dw	112
SYSINIT:5471		     dw	1440		     ; 2*9*80
SYSINIT:5473		     db	0F9h
SYSINIT:5474		     dw	3
SYSINIT:5476		     dw	9
SYSINIT:5478		     dw	2
SYSINIT:547A		     dd	0
SYSINIT:547E		     dd	0
SYSINIT:5482 _bpb35h	     dw	512		     ; ...
SYSINIT:5484		     db	1
SYSINIT:5485		     dw	1
SYSINIT:5487		     db	2
SYSINIT:5488		     dw	224
SYSINIT:548A		     dw	2880		     ; 2*18*80
SYSINIT:548C		     db	0F0h
SYSINIT:548D		     dw	9
SYSINIT:548F		     dw	18
SYSINIT:5491		     dw	2
SYSINIT:5493		     dd	0
SYSINIT:5497		     dd	0
SYSINIT:549B _bpb288	     dw	512		     ; ...
SYSINIT:549D		     db	2
SYSINIT:549E		     dw	1
SYSINIT:54A0		     db	2
SYSINIT:54A1		     dw	240
SYSINIT:54A3		     dw	5760		     ; 2*36*80
SYSINIT:54A5		     db	0F0h
SYSINIT:54A6		     dw	9
SYSINIT:54A8		     dw	36
SYSINIT:54AA		     dw	2
SYSINIT:54AC		     dd	0
SYSINIT:54B0		     dd	0
SYSINIT:54B4 _bpbtable	     dw	offset _bpb48t	     ; ...
SYSINIT:54B4					     ; 48tpi drives
SYSINIT:54B6		     dw	offset _bpb96t	     ; 96tpi drives
SYSINIT:54B8		     dw	offset _bpb35	     ; 3.5" drives
SYSINIT:54BA		     dw	offset _bpb35	     ; not used	- 8" drives - default to 3.5"
SYSINIT:54BC		     dw	offset _bpb35	     ; not used	- 8" drives - default to 3.5"
SYSINIT:54BE		     dw	offset _bpb35	     ; not used	- hard files - default to 3.5"
SYSINIT:54C0		     dw	offset _bpb35	     ; not used	- tape drives -	default	to 3.5"
SYSINIT:54C2		     dw	offset _bpb35h	     ; 3-1/2" 1.44mb drive
SYSINIT:54C4		     dw	offset _bpb35	     ; ERIMO
SYSINIT:54C6		     dw	offset _bpb288	     ; 2.88 MB diskette	drives
SYSINIT:54C8 switchlist	     db	8,'FHSTDICN'         ; ...
SYSINIT:54C8					     ; preserve	the positions of n and c
SYSINIT:54D1		     db	0
SYSINIT:54D2 badopm	     db	0Dh,0Ah		     ; ...
SYSINIT:54D2		     db	'Unrecognized command in CONFIG.SYS'
SYSINIT:54F6 crlfm	     db	0Dh,0Ah,'$'          ; ...
SYSINIT:54F9 badparm	     db	0Dh,0Ah		     ; ...
SYSINIT:54F9		     db	'Bad command or parameters - $'
SYSINIT:5518 badsiz_pre	     db	0Dh,0Ah		     ; ...
SYSINIT:5518		     db	'Sector size too large in file $'
SYSINIT:5539 badld_pre	     db	0Dh,0Ah		     ; ...
SYSINIT:5539		     db	'Bad or missing $'
SYSINIT:554B badcom	     db	'Command Interpreter',0 ; ...
SYSINIT:555F badcountry	     db	0Dh,0Ah		     ; ...
SYSINIT:555F		     db	'Invalid country code or code page',0Dh,0Ah,'$'
SYSINIT:5585 badcountrycom   db	0Dh,0Ah		     ; ...
SYSINIT:5585		     db	'Error in COUNTRY command',0Dh,0Ah,'$'
SYSINIT:55A2 insufmemory     db	0Dh,0Ah		     ; ...
SYSINIT:55A2		     db	'Insufficient memory for COUNTRY.SYS file',0Dh,0Ah,'$'
SYSINIT:55CF badmem	     db	0Dh,0Ah		     ; ...
SYSINIT:55CF		     db	'Configuration too large for memory',0Dh,0Ah,'$'
SYSINIT:55F6 badblock	     db	0Dh,0Ah		     ; ...
SYSINIT:55F6		     db	'Too many block devices',0Dh,0Ah,'$'
SYSINIT:5611 badstack	     db	0Dh,0Ah		     ; ...
SYSINIT:5611		     db	'Invalid STACK parameters',0Dh,0Ah,'$'
SYSINIT:562E badorder	     db	0Dh,0Ah		     ; ...
SYSINIT:562E		     db	'Incorrect order in CONFIG.SYS line $'
SYSINIT:5654 errorcmd	     db	'Error in CONFIG.SYS line $' ; ...
SYSINIT:566E OnOff	     db	'ON'                 ; ...
SYSINIT:5670 OnOff2	     db	'OFF'                ; ...
SYSINIT:5673 StartMsg	     db	'Starting MS-DOS...',0Dh,0Ah ; ...
SYSINIT:5673		     db	0Ah,0
SYSINIT:5689 _$PauseMsg	     db	'Press any key to continue . . .',0Dh,0Ah,'$' ; ...
SYSINIT:56AB _$CleanMsg	     db	'MS-DOS is bypassing your CONFIG.SYS and AUTOEXEC.BAT files.',0Dh,0Ah,'$' ; ...
SYSINIT:56E9 _$InterMsg	     db	'MS-DOS will prompt you to confirm each CONFIG.SYS command.',0Dh,0Ah,'$' ; ...
SYSINIT:5726 _$MenuHeader    db	0Dh,0Ah		     ; ...
SYSINIT:5726		     db	'  MS-DOS 6.2 Startup Menu',0Dh,0Ah
SYSINIT:5743		     db	'  '
SYSINIT:5745		     db	17h dup(0CDh)	     ; db '=======================' ; ALT 205
SYSINIT:575C		     db	0Dh,0Ah,'$'
SYSINIT:575F _$MenuPrmpt     db	'  Enter a choice: $' ; ...
SYSINIT:5772 _$StatusLine    db	'F5=Bypass startup files F8=Confirm each line of CONFIG.SYS and AU' ; ...
SYSINIT:5772		     db	'TOEXEC.BAT [ ]$'
SYSINIT:57C2 _$InterPrmpt    db	' [Y,N]?$'           ; ...
SYSINIT:57CA _$YES	     db	'YES$'               ; ...
SYSINIT:57CE _$NO	     db	'NO $'               ; ...
SYSINIT:57D2 _$TimeOut	     db	'Time remaining: $'  ; ...
SYSINIT:57E3 badcomprmpt     db	'Enter correct name of Command Interpreter (eg, C:\COMMAND.COM)',0Dh,0Ah ; ...
SYSINIT:57E3		     db	'$'
SYSINIT:5824 _$AutoPrmpt     db	'Process AUTOEXEC.BAT [Y,N]?$' ; ...
SYSINIT:5840 TooManyDrivesMsg db 'WARNING! Logical drives past Z: exist and will be ignored',0Dh,0Ah,'$' ; ...
SYSINIT:587C baddblspace     db	'Wrong DBLSPACE.BIN version',0Dh,0Ah,'$' ; ...
SYSINIT:5899		     db	7 dup(0)
SYSINIT:5899 SYSINIT	     ends
SYSINIT:5899
SYSINIT:5899
SYSINIT:5899		     end
