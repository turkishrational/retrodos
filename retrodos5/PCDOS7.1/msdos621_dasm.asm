

;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 Licensed to: Freeware version			    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	75959BC417C19135B982F7959EE9C92A


		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
DOSDATA		segment	para private 'DATA' use16
		assume cs:DOSDATA
		db 4 dup(0)		; ...
DataVersion	dw 1			; ...
WinoldPatch1	db 8 dup(0)		; ...
MYNUM		dw 0			; ...
FCBLRU		dw 0			; ...
OpenLRU		dw 0
OEM_HANDLER	dd 0FFFFFFFFh		; ...
LeaveAddr	dw offset LeaveDOS	; ...
RetryCount	dw 3			; ...
RetryLoop	dw 1			; ...
LastBuffer	dd 0FFFFFFFFh		; ...
CONTPOS		dw 0			; ...
arena_head	dw 0			; ...
DPBHEAD		dd 0			; ...
SFT_ADDR	dd SFTABL		; ...
BCLOCK		dd 0			; ...
BCON		dd 0			; ...
MAXSEC		dw 128			; ...
BUFFHEAD	dd 0			; ...
CDSADDR		dd 0			; ...
SFTFCB		dd 0			; ...
KEEPCOUNT	dw 0
NUMIO		db 0			; ...
CDSCOUNT	db 0			; ...
NULDEV		dd 0			; ...
		dw 8004h
		dw offset SNULDEV
off_50		dw offset INULDEV	; ...
asc_52		db 'NUL     '           ; ...
SPLICES		db 0			; ...
Special_Entries	dw 0
UU_IFS_DOS_CALL	dd 0			; ...
ChkCopyProt	dw 0			; ...
A20OFF_PSP	dw 0			; ...
BUFFERS_PARM1	dw 0
BUFFERS_PARM2	dw 0
BOOTDRIVE	db 0			; ...
DDMOVE		db 0			; ...
EXT_MEM_SIZE	dw 0
BufferQueue	dd 0			; ...
DirtyBufferCount dw 0			; ...
SC_CACHE_PTR	dd 0			; ...
SC_CACHE_COUNT	dw 0			; ...
BuffInHMA	db 0			; ...
LoMemBuff	dd 0			; ...
UU_BUF_EMS_FIRST_PAGE db 0, 0, 0
CL0FATENTRY	dw 0FFFFh		; ...
IoStatFail	db 0			; ...
ALLOCMSAVE	db 0			; ...
A20OFF_COUNT	db 0			; ...
DOS_FLAG	db 0			; ...
UNPACK_OFFSET	dw 0			; ...
UMBFLAG		db 0			; ...
SAVE_AX		dw 0			; ...
UMB_HEAD	dw 0FFFFh		; ...
START_ARENA	dw 1			; ...
JShare		dd BadCall		; ...
MFT_enter	dd OKCall		; ...
MFTClose	dd OKCall		; ...
MFTclU		dd BadCall		; ...
MFTCloseP	dd BadCall		; ...
MFTCloN		dd BadCall		; ...
set_block	dd BadCall		; ...
clr_block	dd BadCall		; ...
chk_block	dd OKCall		; ...
MFT_get		dd BadCall		; ...
ShSave		dd BadCall		; ...
ShChk		dd BadCall		; ...
ShCol		dd OKCall		; ...
ShCloseFile	dd BadCall		; ...
ShSU		dd BadCall		; ...
SFTABL		dd 0FFFFFFFFh		; ...
		dw 5
SFT0_SFTable	db 295 dup(0)		; ...
CARPOS		db 0			; ...
STARTPOS	db 0			; ...
INBUF		db 128 dup(0)		; ...
CONBUF		db 131 dup(0)		; ...
PFLAG		db 0			; ...
VERFLG		db 0			; ...
CHARCO		db 3			; ...
chSwitch	db '/'
AllocMethod	db 0			; ...
fShare		db 0			; ...
DIFFNAM		db 1			; ...
MYNAME		db 16 dup(32)		; ...
CritPatch	dw offset redir_patch	; ...
		dw offset redir_patch
		dw offset redir_patch
		dw offset redir_patch
		dw 0
		db 90h
ERRORMODE	db 0			; ...
INDOS		db 0			; ...
WPERR		db 0FFh			; ...
EXTERR_LOCUS	db 0			; ...
EXTERR		dw 0			; ...
EXTERR_ACT_CLASS dw 0			; ...
EXTERRPT	dd 0			; ...
DMAADD		dd 80h			; ...
CurrentPDB	dw 0			; ...
ConC_Spsave	dw 0			; ...
exit_code	dw 0			; ...
CURDRV		db 0			; ...
CNTCFLAG	db 0			; ...
CPSWFLAG	db 0
CPSWSAVE	db 0
USER_IN_AX	dw 0			; ...
PROC_ID		dw 0			; ...
USER_ID		dw 0			; ...
FirstArena	dw 0			; ...
BestArena	dw 0			; ...
LastArena	dw 0			; ...
ENDMEM		dw 0			; ...
LASTENT		dw 0			; ...
FAILERR		db 0			; ...
ALLOWED		db 0			; ...
NoSetDir	db 0			; ...
DidCTRLC	db 0			; ...
SpaceFlag	db 0			; ...
		db 90h
DAY		db 0			; ...
MONTH		db 0			; ...
YEAR		dw 0			; ...
DAYCNT		dw 0FFFFh		; ...
WEEKDAY		db 0			; ...
CONSWAP		db 0			; ...
IDLEINT		db 1			; ...
fAborting	db 0			; ...
DEVCALL		db 0			; ...
DEVCALL_REQUNIT	db 0			; ...
DEVCALL_REQFUNC	db 0			; ...
DEVCALL_REQSTAT	dw 0			; ...
		db 8 dup(0)
CALLUNIT	db 0			; ...
CALLBR		dd 0			; ...
CALLBPB		dd 0			; ...
CALLVIDRW	dd 0			; ...
CALLNEWSC	dd 0			; ...
CALLDEVAD	dd 0			; ...
IOCALL		db 0			; ...
IOCALL_REQUNIT	db 0			; ...
IOCALL_REQFUNC	db 0			; ...
IOCALL_REQSTAT	dw 0			; ...
		db 8 dup(0)
IOMED		db 0			; ...
IOXAD		dd 0			; ...
IOSCNT		dw 0			; ...
IOSSEC		dw 0			; ...
DSKSTCALL	db 14			; ...
		db 0
DSKSTCOM	db 5			; ...
DSKSTST		dw 0			; ...
		db 8 dup(0)
DSKCHRET	db 0			; ...
DEVIOBUF_PTR	dw offset DEVIOBUF	; ...
DOSSEG_INIT	dw 0			; ...
DSKSTCNT	dw 1			; ...
		dw 0
CreatePDB	db 0			; ...
Lock_Buffer	dd 0			; ...
		dd 0
		db 90h
USERNUM		dw 0			; ...
USERNUM_hb	db 0			; ...
OEMNUM		db 0FFh
TIMEBUF		dw 3 dup(0)		; ...
DEVIOBUF	dw 0			; ...
OPENBUF		db 128 dup(0)		; ...
RENBUF		db 128 dup(0)		; ...
SEARCHBUF	db 53 dup(0)		; ...
DUMMYCDS	db 88 dup(0)		; ...
NAME1		db 12 dup(0)		; ...
NAME2		db 13 dup(0)		; ...
DESTSTART	dw 0			; ...
		db 5 dup(0)
ATTRIB		db 0			; ...
EXTFCB		db 0			; ...
SATTRIB		db 0			; ...
OPEN_ACCESS	db 0			; ...
FOUNDDEL	db 0			; ...
FOUND_DEV	db 0			; ...
FSPLICE		db 0			; ...
FSHARING	db 0			; ...
SECCLUSPOS	db 0			; ...
TRANS		db 0			; ...
READOP		db 0			; ...
THISDRV		db 0			; ...
CLUSFAC		db 0			; ...
CLUSSPLIT	db 0			; ...
INSMODE		db 0			; ...
CMETA		db 0			; ...
VOLID		db 0			; ...
EXIT_TYPE	db 0			; ...
		db 90h
CREATING	db 0			; ...
DELALL		db 0			; ...
EXITHOLD	dd 0			; ...
USER_SP		dw 0			; ...
USER_SS		dw 0			; ...
CONTSTK		dw 0			; ...
THISDPB		dd 0			; ...
CLUSSAVE	dw 0			; ...
CLUSSEC		dw 2 dup(0)		; 0 ; ...
PREREAD		dw 0			; ...
FATBYT		dw 0			; ...
FATBYTE		dw 0			; ...
DEVPT		dd 0			; ...
THISSFT		dd 0			; ...
THISCDS		dd 0			; ...
THISFCB		dd 0			; ...
SFN		dw 0FFFFh		; ...
JFN		dw 0			; ...
PJFN		dd 0			; ...
WFP_START	dw 0			; ...
REN_WFP		dw 0			; ...
CURR_DIR_END	dw 0			; ...
NEXTADD		dw 0			; ...
LASTPOS		dw 0			; ...
CLUSNUM		dw 0			; ...
DIRSEC		dw 2 dup(0)		; 0 ; ...
DIRSTART	dw 0			; ...
SECPOS		dw 2 dup(0)		; 0 ; ...
VALSEC		dw 2 dup(0)		; 0 ; ...
BYTSECPOS	dw 0			; ...
BYTPOS		dw 2 dup(0)		; 0 ; ...
BYTCNT1		dw 0			; ...
BYTCNT2		dw 0			; ...
SECCNT		dw 0			; ...
ENTFREE		dw 0			; ...
ENTLAST		dw 0			; ...
NXTCLUSNUM	dw 0			; ...
GROWCNT		dw 2 dup(0)		; 0 ; ...
CURBUF		dd 0			; ...
CONSFT		dd 0			; ...
SAVEBX		dw 0			; ...
SAVEDS		dw 0			; ...
RESTORE_TMP	dw 0			; ...
NSS		dw 0			; ...
NSP		dw 0			; ...
EXTOPEN_FLAG	dw 0			; ...
EXTOPEN_ON	db 0			; ...
EXTOPEN_IO_MODE	dw 0			; ...
SAVE_DI		dw 0			; ...
SAVE_ES		dw 0			; ...
SAVE_DX		dw 0			; ...
SAVE_CX		dw 0			; ...
SAVE_BX		dw 0			; ...
SAVE_SI		dw 0			; ...
SAVE_DS		dw 0			; ...
HIGH_SECTOR	dw 0			; ...
OffsetMagicPatch dw offset MagicPatch	; ...
DISK_FULL	db 0			; ...
TEMP_VAR	dw 0			; ...
TEMP_VAR2	dw 0			; ...
DrvErr		db 0			; ...
DOS34_FLAG	dw 0			; ...
NO_FILTER_PATH	dd 0
NO_FILTER_DPATH	dd 0
AbsRdWr_SS	dw 0			; ...
AbsRdWr_SP	dw 0			; ...
		db 0
RENAMEDMA	db 180h	dup(0)		; ...
AUXSTACK	db 384 dup(0)		; ...
DSKSTACK	db 384 dup(0)		; ...
PRINTER_FLAG	db 0			; ...
VOLCHNG_FLAG	db 0			; ...
VIRTUAL_OPEN	db 0			; ...
FSeek_drive	db 0
FSeek_firclus	dw 0
FSeek_logclus	dw 0
FSeek_logsave	dw 0
TEMP_DOSLOC	dw 0FFFFh		; ...
SWAP_END	db 0			; ...
UCASE_TAB	dw 128			; ...
UCASE_TAB_2	db 128,154, 69,	65,142,	65,143,128 ; ...
		db  69,	69, 69,	73, 73,	73,142,143
		db 144,146,146,	79,153,	79, 85,	85
		db  89,153,154,155,156,157,158,159
		db  65,	73, 79,	85,165,165,166,167
		db 168,169,170,171,172,173,174,175
		db 176,177,178,179,180,181,182,183
		db 184,185,186,187,188,189,190,191
		db 192,193,194,195,196,197,198,199
		db 200,201,202,203,204,205,206,207
		db 208,209,210,211,212,213,214,215
		db 216,217,218,219,220,221,222,223
		db 224,225,226,227,228,229,230,231
		db 232,233,234,235,236,237,238,239
		db 240,241,242,243,244,245,246,247
		db 248,249,250,251,252,253,254,255
FILE_UCASE_TAB	dw 128			; ...
FILE_UCASE_TAB_2 db 128,154, 69, 65,142, 65,143,128 ; ...
		db  69,	69, 69,	73, 73,	73,142,143
		db 144,146,146,	79,153,	79, 85,	85
		db  89,153,154,155,156,157,158,159
		db  65,	73, 79,	85,165,165,166,167
		db 168,169,170,171,172,173,174,175
		db 176,177,178,179,180,181,182,183
		db 184,185,186,187,188,189,190,191
		db 192,193,194,195,196,197,198,199
		db 200,201,202,203,204,205,206,207
		db 208,209,210,211,212,213,214,215
		db 216,217,218,219,220,221,222,223
		db 224,225,226,227,228,229,230,231
		db 232,233,234,235,236,237,238,239
		db 240,241,242,243,244,245,246,247
		db 248,249,250,251,252,253,254,255
FILE_CHAR_TAB	dw 22			; ...
		db 1, 0, 255, 0, 0, 32,	2, 14
		db '."/\[]:|<>+=;,'
		db 24 dup(0)
COLLATE_TAB	dw 256			; ...
		db  0, 1, 2, 3,	4, 5, 6, 7
		db  8, 9,10,11,12,13,14,15
		db 16,17,18,19,20,21,22,23
		db 24,25,26,27,28,29,30,31
		db ' !"#$%&',27h,'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]'
		db '^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~'
		db 127
		db 'CUEAAAACEEEIIIAAEAAOOOUUYOU$$$$$AIOUNN'
		db 166,	167
		db '?'
		db 169,	170, 171, 172
		db '!', '"', '"'
		db 176,	177, 178, 179, 180, 181, 182, 183, 184,	185, 186
		db 187,	188, 189, 190, 191, 192, 193, 194, 195,	196, 197
		db 198,	199, 200, 201, 202, 203, 204, 205, 206,	207, 208
		db 209,	210, 211, 212, 213, 214, 215, 216, 217,	218, 219
		db 220,	221, 222, 223, 224
		db 'S'
		db 226,	227, 228, 229, 230, 231, 232, 233, 234,	235, 236
		db 237,	238, 239, 240, 241, 242, 243, 244, 245,	246, 247
		db 248,	249, 250, 251, 252, 253, 254, 255
DBCS_TAB	dw 0			; ...
DBCS_TAB_2	db 16 dup(0)		; ...

; =============== S U B	R O U T	I N E =======================================


MAP_CASE	proc far		; ...
		cmp	al, 80h
		jnb	short Map1
		retf
; ---------------------------------------------------------------------------

Map1:					; ...
		sub	al, 80h
		push	ds
		push	bx
		mov	bx, offset UCASE_TAB_2
		push	cs
		pop	ds
		xlat
		pop	bx
		pop	ds
		retf
MAP_CASE	endp

; ---------------------------------------------------------------------------
InterChar	db 0
InterCon	db 0
SaveCurFlg	db 0
TEMPSEG		dw 0			; ...
redir_patch	db 0			; ...
Mark1		db 5 dup(0)
MSVERSION	db 6
		db 20
YRTAB		db 200,	166, 200, 165, 200, 165, 200, 165 ; ...
MONTAB		db 31			; ...
february	db 28			; ...
		db 31, 30, 31, 30, 2 dup(31), 30, 31, 30, 31
SysInitTable	dd DPBHEAD		; ...
		dd COUNTRY_CDPG
FastOpenTable	dw 2			; ...
FastTable_2	dw offset FastRet	; ...
		dw 0
		dw offset FastRet
		dw 0
FastOpenFlg	db 0			; ...
FastOpen_Ext_Info db 11	dup(0)		; ...
Dir_Info_Buff	db 32 dup(0)		; ...
Next_Element_Start dw 0			; ...
Del_ExtCluster	dw 0
USER_SP_2F	dw offset FAKE_STACK_2F	; ...
FAKE_STACK_2F	dw 14 dup(0)		; ...
Hash_Temp	dw 4 dup(0)
SCAN_FLAG	db 0			; ...
DATE_FLAG	dw 0			; ...
FETCHI_TAG	dw 0
MSG_EXTERROR	dd 0
		dd 0
		dd 0
		dd 0
		dd 0
SEQ_SECTOR	dw 2 dup(0FFFFh)	; 0 ; ...
SC_SECTOR_SIZE	dw 0			; ...
SC_DRIVE	db 0			; ...
CurSC_DRIVE	db 0FFh			; ...
CurSC_SECTOR	dw 2 dup(     0)	; 0 ; ...
SC_STATUS	dw 0			; ...
SC_FLAG		db 0			; ...
AbsDskErr	dw 0			; ...
NO_NAME_ID	db 'NO NAME    '        ; ...
LOOKSIZ		db 0
; ---------------------------------------------------------------------------

SNULDEV:				; ...
		or	word ptr es:[bx+3], 100h

INULDEV:				; ...
		retf
; ---------------------------------------------------------------------------
WinoldPatch2	db 8 dup(0)		; ...
UmbSave2	db 5 dup(0)		; ...
UmbSaveFlag	db 0			; ...
ERR_TABLE_21	db 1, 7, 4, 0FFh	; ...
		db 2, 8, 3, 2
		db 3, 8, 3, 2
		db 4, 1, 4, 1
		db 5, 3, 3, 0FFh
		db 6, 7, 4, 1
		db 7, 7, 5, 5
		db 8, 1, 4, 5
		db 9, 7, 4, 5
		db 0Ah,	7, 4, 5
		db 0Bh,	9, 3, 1
		db 0Ch,	7, 4, 1
		db 0Dh,	9, 4, 1
		db 0Fh,	8, 3, 2
		db 10h,	3, 3, 2
		db 11h,	0Dh, 3,	2
		db 12h,	8, 3, 2
		db 50h,	0Ch, 3,	2
		db 20h,	0Ah, 2,	2
		db 21h,	0Ah, 2,	2
		db 54h,	1, 4, 0FFh
		db 56h,	3, 3, 1
		db 52h,	1, 4, 2
		db 32h,	9, 3, 3
		db 55h,	0Ch, 3,	3
		db 57h,	9, 3, 1
		db 53h,	0Dh, 4,	1
		db 24h,	1, 4, 5
		db 26h,	1, 4, 1
		db 27h,	1, 4, 1
		db 5Ah,	0Dh, 4,	2
		db 0FFh, 0FFh, 0FFh, 0FFh
ERR_TABLE_24	db 13h,	0Bh, 7,	2	; ...
		db 14h,	4, 5, 1
		db 15h,	5, 7, 0FFh
		db 16h,	4, 5, 1
		db 17h,	0Bh, 4,	2
		db 18h,	4, 5, 1
		db 19h,	5, 1, 2
		db 1Ah,	0Bh, 7,	2
		db 1Bh,	0Bh, 4,	2
		db 1Ch,	2, 7, 4
		db 1Dh,	5, 4, 0FFh
		db 1Eh,	5, 4, 0FFh
		db 1Fh,	0Dh, 4,	0FFh
		db 20h,	0Ah, 2,	2
		db 21h,	0Ah, 2,	2
		db 22h,	0Bh, 7,	2
		db 32h,	9, 3, 3
		db 23h,	7, 4, 1
		db 24h,	1, 4, 5
		db 0FFh, 0Dh, 5, 0FFh
ErrMap24	db 13h,	14h, 15h, 16h, 17h, 18h, 19h, 1Ah ; ...
		db 1Bh,	1Ch, 1Dh, 1Eh, 1Fh, 1Fh, 1Fh, 22h
FIRST_BUFF_ADDR	dw 0			; ...
SPECIAL_VERSION	dw 0			; ...
FAKE_COUNT	db 255 dup(0)
OLD_FIRSTCLUS	dw 0			; ...
exec_init_SP	dw 0			; ...
exec_init_SS	dw 0			; ...
exec_init_IP	dw 0			; ...
exec_init_CS	dw 0			; ...
exec_signature	dw 0			; ...
exec_len_mod_512 dw 0
exec_pages	dw 0			; ...
exec_rle_count	dw 0			; ...
exec_par_dir	dw 0			; ...
exec_min_BSS	dw 0			; ...
exec_max_BSS	dw 0			; ...
exec_SS		dw 0			; ...
exec_SP		dw 0			; ...
exec_chksum	dw 0
exec_IP		dw 0			; ...
exec_CS		dw 0
exec_rle_table	dw 0			; ...
Win386_Info	db 3			; ...
		db 0
		dd 0
Win386_Info_6	dd 0			; ...
		dd 0
SIS_Instance_Data_Ptr dw offset	Instance_Table
SIS_Instance_Data_Ptr_2	dw 0		; ...
Instance_Table	dw offset CONTPOS	; ...
Instance_Table_2 dw 0			; ...
		dw 2
		dw offset BCON
		dw 0
		dw 4
		dw offset CARPOS
		dw 0
		dw 106h
		dw offset CHARCO
		dw 0
		dw 1
		dw offset exec_init_SP
		dw 0
		dw 34
		dw offset UMBFLAG
		dw 0
		dw 1
		dw offset UMB_HEAD
		dw 0
		dw 2
		dw 0
		dw 0
Win386_DOSVars	db 5			; ...
		db 0
		dw offset SAVEDS
		dw offset SAVEBX
		dw offset INDOS
		dw offset USER_ID
		dw offset CritPatch
		dw offset UMB_HEAD
IsWin386	db 0			; ...
VxDpath		db 'c:\wina20.386',0    ; ...
DriverLoad	db 1			; ...
BiosDataPtr	dd 0			; ...
		db 36h,	0F6h, 6, 20h, 3, 0FFh
		db 75h,	0Ch
		db 36h,	0FFh, 36h, 58h,	3
		db 0CDh, 28h
		db 80h,	3Eh, 20h, 3, 0
		db 75h,	37h
		db 0BCh, 0A0h, 0Ah
LocalSFT	dd 0			; ...
		db 90h
DOSINTTABLE	dd DIVOV		; ...
DOSINTTABLE_4	dd quit			; ...
DOSINTTABLE_8	dd command		; ...
DOSINTTABLE_12	dd ABSDRD		; ...
DOSINTTABLE_16	dd ABSDWRT		; ...
DOSINTTABLE_20	dd stay_resident	; ...
DOSINTTABLE_24	dd INT2F		; ...
DOSINTTABLE_28	dd call_entry		; ...
DOSINTTABLE_32	dd irett
SS_Save		dw 0			; ...
SP_Save		dw 0			; ...
; ---------------------------------------------------------------------------

ldivov:					; ...
		jmp	short divov_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

divov_cont:				; ...
		jmp	cs:DOSINTTABLE
; ---------------------------------------------------------------------------

lquit:					; ...
		jmp	short quit_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

quit_cont:				; ...
		jmp	cs:DOSINTTABLE_4
; ---------------------------------------------------------------------------

lcommand:				; ...
		jmp	short command_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

command_cont:				; ...
		jmp	cs:DOSINTTABLE_8
; ---------------------------------------------------------------------------

labsdrd:				; ...
		jmp	short absdrd_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

absdrd_cont:				; ...
		jmp	cs:DOSINTTABLE_12
; ---------------------------------------------------------------------------

labsdwrt:				; ...
		jmp	short absdwrt_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

absdwrt_cont:				; ...
		jmp	cs:DOSINTTABLE_16
; ---------------------------------------------------------------------------

lstay_resident:				; ...
		jmp	short sr_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

sr_cont:				; ...
		jmp	cs:DOSINTTABLE_20
; ---------------------------------------------------------------------------

lint2f:					; ...
		jmp	short int2f_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

int2f_cont:				; ...
		jmp	cs:DOSINTTABLE_24
; ---------------------------------------------------------------------------

lcall_entry:				; ...
		jmp	short callentry_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

callentry_cont:				; ...
		jmp	cs:DOSINTTABLE_28
; ---------------------------------------------------------------------------

lirett:					; ...
		iret
; ---------------------------------------------------------------------------
DosRetAddr23	dd 0			; ...
DosRetAddr24	dd 0			; ...
DosRetAddr28	dd 0
; ---------------------------------------------------------------------------

LowInt23:				; ...
		pop	word ptr cs:DosRetAddr23
		pop	word ptr cs:DosRetAddr23+2
		int	23h		; DOS -	CONTROL	"C" EXIT ADDRESS
					; Return: return via RETF 2 with CF set
					; DOS will abort program with errorlevel 0
					; else
					; interrupted DOS call continues
		call	EnsureA20ON
		jmp	cs:DosRetAddr23
; ---------------------------------------------------------------------------

LowInt24:				; ...
		pop	word ptr cs:DosRetAddr24
		pop	word ptr cs:DosRetAddr24+2
		int	24h		; DOS -	FATAL ERROR HANDLER ADDRESS
					; Automatically	called upon detection of unrecoverable I/O error.
		call	EnsureA20ON
		jmp	cs:DosRetAddr24
; ---------------------------------------------------------------------------

LowInt28:				; ...
		int	28h		; DOS 2+ internal - KEYBOARD BUSY LOOP
		call	EnsureA20ON
		retf
; ---------------------------------------------------------------------------

disa20_xfer:				; ...
		call	XMMDisableA20
		cli
		mov	cs:INDOS, 0
		mov	ss, ax
		mov	sp, di
		sti
		push	ds
		push	si
		mov	es, dx
		mov	ds, dx
		mov	ax, bx
		retf
; ---------------------------------------------------------------------------

disa20_iret:				; ...
		call	XMMDisableA20
		dec	ds:INDOS
		mov	ss, ds:USER_SS
		mov	sp, ds:USER_SP
		mov	bp, sp
		mov	[bp+0],	al
		mov	ax, ds:NSP
		mov	ds:USER_SP, ax
		mov	ax, ds:NSS
		mov	ds:USER_SS, ax
		pop	ax
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	di
		pop	bp
		pop	ds
		pop	es
		iret

; =============== S U B	R O U T	I N E =======================================


XMMDisableA20	proc near		; ...
		push	bx
		push	ax
		mov	ah, 6
		call	cs:XMMcontrol
		pop	ax
		pop	bx
		retn
XMMDisableA20	endp

; ---------------------------------------------------------------------------
XMMcontrol	dd 0			; ...
LowMemory	dd 80h			; ...
HighMemory	dd 0FFFF0090h		; ...

; =============== S U B	R O U T	I N E =======================================


EnsureA20ON	proc near		; ...
		pushf
		push	ds
		push	es
		push	cx
		push	si
		push	di
		lds	si, cs:LowMemory
		les	di, cs:HighMemory
		mov	cx, 4
		cld
		repe cmpsw
		jz	short EA20_OFF

EA20_RET:				; ...
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ds
		popf
		retn
; ---------------------------------------------------------------------------

EA20_OFF:				; ...
		push	bx
		push	ax
		mov	ax, ss
		mov	cs:SS_Save, ax
		mov	cs:SP_Save, sp
		mov	ax, cs
		mov	ss, ax
		mov	sp, offset AUXSTACK
		mov	ah, 5
		call	cs:XMMcontrol
		or	ax, ax
		jz	short XMMerror
		mov	ax, cs:SS_Save
		mov	ss, ax
		mov	sp, cs:SP_Save
		pop	ax
		pop	bx
		jmp	short EA20_RET
; ---------------------------------------------------------------------------

XMMerror:				; ...
		mov	ah, 0Fh
		int	10h		; - VIDEO - GET	CURRENT	VIDEO MODE
					; Return: AH = number of columns on screen
					; AL = current video mode
					; BH = current active display page
		cmp	al, 7
		jz	short XMMcont
		xor	ah, ah
		mov	al, 2
		int	10h		; - VIDEO - SET	VIDEO MODE
					; AL = mode

XMMcont:				; ...
		mov	ah, 5
		xor	al, al
		int	10h		; - VIDEO - SELECT DISPLAY PAGE
					; AL = display page, 0-7  for modes 0 &	1, 0-3	for modes 2 & 3
		mov	si, offset XMMERRMSG ; "\r\nA20	Hardware Error\r\n$"
		push	cs
		pop	ds
		cld

XMMprnt:				; ...
		lodsb
		cmp	al, '$'
		jz	short XMMStall
		mov	ah, 0Eh
		mov	bx, 7
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		jmp	short XMMprnt
; ---------------------------------------------------------------------------

XMMStall:				; ...
		sti
		jmp	short XMMStall
EnsureA20ON	endp

; ---------------------------------------------------------------------------
OldInstanceJunk	dw 70h			; ...
		dw 0
		dw 6
OldInstanceJunk_6 dw 0			; ...
		dw offset CONTPOS
		dw 2
		dw 0
		dw offset BCON
		dw 4
		dw 0
		dw offset CARPOS
		dw 106h
		dw 0
		dw offset CHARCO
		dw 1
		dw 0
		dw offset exec_init_SP
		dw 34
		dw 70h
		dw 0Ch
		dw 1
DosHasHMA	db 0			; ...
FixExePatch	dw 0			; ...
RationalPatchPtr dw 0			; ...
; ---------------------------------------------------------------------------

RatBugCode:				; ...
		push	cx
		mov	cx, ds:10h

rbc_loop:				; ...
		loop	rbc_loop
		pop	cx
		retf
; ---------------------------------------------------------------------------
UmbSave1	db 11 dup(0)		; ...
COUNTRY_CDPG	db 0, 0, 0, 0, 0, 0, 0,	0 ; ...
		db '\COUNTRY.SYS',0
		db 51 dup(0)
		dw 437
		dw 6
COUNTRY_CDPG_76	db 2			; ...
		dw offset UCASE_TAB
		dw 0
		db 4
		dw offset FILE_UCASE_TAB
		dw 0
		db 5
		dw offset FILE_CHAR_TAB
		dw 0
		db 6
		dw offset COLLATE_TAB
		dw 0
		db 7
		dw offset DBCS_TAB
		dw 0
		db 1
		dw 38
		dw 1
		dw 437
COUNTRY_CDPG_108 dw 0			; ...
		db '$',0,0,0,0
		db ',',0
		db '.',0
		db '-',0
		db ':',0
		db 0
		db 2
		db 0
		dw offset MAP_CASE
		dw 0
		db ',',0
		dw 0, 0, 0, 0, 0
XMMERRMSG	db 0Dh,0Ah		; ...
		db 'A20 Hardware Error',0Dh,0Ah,'$'
DOSP1_ID	db 36h,	0C5h, 36h
DOSP1_THISSFT	db 36h,	5, 0C5h, 74h, 7, 0E8h
		db 90h,	90h
DOSP12_ID	db 36h,	0C5h, 36h
DOSP12_THISSFT	db 36h,	5, 0C5h, 74h, 7, 0E8h
DOSP3_ID	db 51h,	6, 57h,	0BAh
DOSP3_CONBUF	db 29h,	2, 0E8h
		db 9Ah,	0E3h, 5Fh, 7
DOSP4_ID	db 59h
DOSP5_ID	db 51h
		db 0ACh, 3Ch, 1Ah, 74h,	5
		db 0E8h
DOSP7_ID	db 2Eh,	8Ch, 1Eh
DOSP7_SAVEDS	db 7Eh,	5
		db 2Eh,	89h, 1Eh
DOSP7_SAVEBX	db 7Ch,	5
		db 8Ch,	0CBh
		db 8Eh,	0DBh
		db 0FEh, 6
DOSP7_INDOS	db 0CFh, 2
		db 33h,	0C0h
DOSP8_ID	db 50h
		db 36h,	0A1h
DOSP8_USER_ID	db 0EAh, 2
		db 26h,	3Bh, 45h
		db 2Fh,	58h
DOSP10_ID	db 6, 1Fh
DOSP10_LOC	db 8Bh,	0DFh
		db 33h,	0C0h, 8Bh, 0D0h, 0E8h
		db 0DFh, 0Eh
		db 1Eh,	36h, 0C5h, 36h,	36h, 5,	0E8h, 0AFh, 0Eh
		db 8Bh,	0D7h, 0B4h, 86h, 36h, 8Bh, 3Eh
		db 9, 3
		db 0F7h, 0C7h, 0, 80h, 74h, 19h, 0E8h, 47h, 17h
		db 8Bh,	0FAh, 0Ah, 0C0h, 74h, 10h, 3Ch,	3, 74h,	3
		db 1Fh,	0EBh, 0CFh
		db 5Fh
		db 36h,	0C4h, 3Eh, 36h,	5, 0E9h, 0A1h, 4
		db 5Fh,	8Bh, 0FAh
DOSP13_ID	db 0ACh
		db 3Ch,	24h
		db 74h,	8
		db 0B3h, 7
		db 0B4h, 0Eh
		db 0CDh, 10h
		db 0EBh, 0F3h
		db 0EBh, 0FEh
Rational386PatchPtr dw 0		; ...
; ---------------------------------------------------------------------------

MagicPatch:				; ...
		retf
; ---------------------------------------------------------------------------
		nop
		nop
		nop
		nop
		nop
DOSDATA		ends

; ---------------------------------------------------------------------------
; File Name   :	C:\retrodos4\MSDOS621.SYS
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 94FAh Loaded length: 94FAh
; ===========================================================================

; Segment type:	Pure code
DOSCODE		segment	byte public 'CODE' use16
		assume cs:DOSCODE
		;org 3DE0h
		assume es:DOSDATA, ss:DOSDATA, ds:DOSDATA, fs:DOSDATA, gs:DOSDATA

$STARTCODE:				; ...
		jmp	DOSINIT
; ---------------------------------------------------------------------------
		dw offset $STARTCODE
BioDataSeg	dw 70h
DosDSeg		dw 0			; ...
MSMAJOR		db 6
MSMINOR		db 20
I21_MAP_E_TAB	db 38h,	2, 1, 2		; ...
		db 39h,	3, 3, 2, 5
		db 3Ah,	4, 10h,	3, 2, 5
		db 3Bh,	2, 2, 3
		db 3Ch,	4, 3, 2, 4, 5
		db 3Dh,	6, 3, 2, 0Ch, 4, 1Ah, 5
		db 3Eh,	1, 6
		db 3Fh,	2, 6, 5
		db 40h,	2, 6, 5
		db 41h,	3, 3, 2, 5
		db 42h,	2, 6, 1
		db 43h,	4, 3, 2, 1, 5
		db 44h,	5, 0Fh,	0Dh, 1,	6, 5
		db 45h,	2, 6, 4
		db 46h,	2, 6, 4
		db 47h,	2, 1Ah,	0Fh
		db 48h,	2, 7, 8
		db 49h,	2, 7, 9
		db 4Ah,	3, 7, 9, 8
		db 4Bh,	8, 3, 1, 2, 4, 0Bh, 0Ah, 8, 5
		db 4Eh,	3, 3, 2, 12h
		db 4Fh,	1, 12h
		db 56h,	5, 11h,	3, 2, 10h, 5
		db 57h,	4, 6, 8, 0Dh, 1
		db 58h,	1, 1
		db 5Ah,	4, 3, 2, 4, 5
		db 5Bh,	5, 50h,	3, 2, 4, 5
		db 5Ch,	4, 6, 1, 24h, 21h
		db 65h,	2, 1, 2
		db 66h,	2, 1, 2
		db 68h,	1, 6
		db 67h,	3, 4, 8, 1
		db 6Ch,	0Ah, 3,	2, 0Ch,	4, 50h,	8, 1Ah,	0Dh, 1,	5
		db 69h,	4, 0Fh,	0Dh, 1,	5
		db 0FFh
DISPATCH	dw offset $ABORT	; ...
		dw offset $STD_CON_INPUT
		dw offset $STD_CON_OUTPUT
		dw offset $STD_AUX_INPUT
		dw offset $STD_AUX_OUTPUT
		dw offset $STD_PRINTER_OUTPUT
		dw offset $RAW_CON_IO
		dw offset $RAW_CON_INPUT
		dw offset $STD_CON_INPUT_NO_ECHO
		dw offset $STD_CON_STRING_OUTPUT
		dw offset $STD_CON_STRING_INPUT
		dw offset $STD_CON_INPUT_STATUS
		dw offset $STD_CON_INPUT_FLUSH
		dw offset $DISK_RESET
		dw offset $SET_DEFAULT_DRIVE
		dw offset $FCB_OPEN
		dw offset $FCB_CLOSE
		dw offset $DIR_SEARCH_FIRST
		dw offset $DIR_SEARCH_NEXT
		dw offset $FCB_DELETE
		dw offset $FCB_SEQ_READ
		dw offset $FCB_SEQ_WRITE
		dw offset $FCB_CREATE
		dw offset $FCB_RENAME
		dw offset NO_OP
		dw offset $GET_DEFAULT_DRIVE
		dw offset $SET_DMA
		dw offset $SLEAZEFUNC
		dw offset $SLEAZEFUNCDL
		dw offset NO_OP
		dw offset NO_OP
		dw offset $GET_DEFAULT_DPB
		dw offset NO_OP
		dw offset $FCB_RANDOM_READ
		dw offset $FCB_RANDOM_WRITE
		dw offset $GET_FCB_FILE_LENGTH
		dw offset $GET_FCB_POSITION
		dw offset $SET_INTERRUPT_VECTOR
		dw offset $CREATE_PROCESS_DATA_BLOCK
		dw offset $FCB_RANDOM_READ_BLOCK
		dw offset $FCB_RANDOM_WRITE_BLOCK
		dw offset $PARSE_FILE_DESCRIPTOR
		dw offset $GET_DATE
		dw offset $SET_DATE
		dw offset $GET_TIME
		dw offset $SET_TIME
		dw offset $SET_VERIFY_ON_WRITE
		dw offset $GET_DMA
		dw offset $GET_VERSION
		dw offset $KEEP_PROCESS
		dw offset $GET_DPB
		dw offset $SET_CTRL_C_TRAPPING
		dw offset $GET_INDOS_FLAG
		dw offset $GET_INTERRUPT_VECTOR
		dw offset $GET_DRIVE_FREESPACE
		dw offset $CHAR_OPER
		dw offset $INTERNATIONAL
		dw offset $MKDIR
		dw offset $RMDIR
		dw offset $CHDIR
		dw offset $CREAT
		dw offset $OPEN
		dw offset $CLOSE
		dw offset $READ
		dw offset $WRITE
		dw offset $UNLINK
		dw offset $LSEEK
		dw offset $CHMOD
		dw offset $IOCTL
		dw offset $DUP
		dw offset $DUP2
		dw offset $CURRENT_DIR
		dw offset $ALLOC
		dw offset $DEALLOC
		dw offset $SETBLOCK
		dw offset $EXEC
		dw offset $EXIT
		dw offset $WAIT
		dw offset $FIND_FIRST
		dw offset $FIND_NEXT
		dw offset $SET_CURRENT_PDB
		dw offset $GET_CURRENT_PDB
		dw offset $GET_IN_VARS
		dw offset $SETDPB
		dw offset $GET_VERIFY_ON_WRITE
		dw offset $DUP_PDB
		dw offset $RENAME
		dw offset $FILE_TIMES
		dw offset $ALLOCOPER
		dw offset $GetExtendedError
		dw offset $CreateTempFile
		dw offset $CreateNewFile
		dw offset $LockOper
		dw offset $ServerCall
		dw offset $UserOper
		dw offset $AssignOper
		dw offset $NameTrans
		dw offset NO_OP
		dw offset $GET_CURRENT_PDB
		dw offset $ECS_Call
		dw offset $SET_PRINTER_FLAG
		dw offset $GetExtCntry
		dw offset $GetSetCdPg
		dw offset $ExtHandle
		dw offset $COMMIT
		dw offset $GSetMediaID
		dw offset $COMMIT
		dw offset NO_OP
		dw offset $Extended_Open
FOO		dw offset Leave2F	; ...
DTab		dw offset DOSTable	; ...
DOSTable	db 48			; ...
		dw offset DOSInstall
		dw offset DOS_CLOSE
		dw offset RECSET
		dw offset DOSGetGroup
		dw offset PATHCHRCMP
		dw offset OUTT
		dw offset NET_I24_ENTRY
		dw offset PLACEBUF
		dw offset FREE_SFT
		dw offset BUFWRITE
		dw offset SHARE_VIOLATION
		dw offset SHARE_ERROR
		dw offset SET_SFT_MODE
		dw offset DATE16
		dw offset Idle
		dw offset SCANPLACE
		dw offset Idle
		dw offset StrCpy
		dw offset StrLen
		dw offset UCase
		dw offset POINTCOMP
		dw offset CHECKFLUSH
		dw offset SFFromSFN
		dw offset GetCDSFromDrv
		dw offset Get_User_Stack
		dw offset GETTHISDRV
		dw offset DriveFromText
		dw offset SETYEAR
		dw offset DSUM
		dw offset DSLIDE
		dw offset StrCmp
		dw offset InitCDS
		dw offset pJFNFromHandle
		dw offset $NameTrans
		dw offset CAL_LK
		dw offset DEVNAME
		dw offset Idle
		dw offset DStrLen
		dw offset NLS_OPEN
		dw offset $CLOSE
		dw offset NLS_LSEEK
		dw offset $READ
		dw offset FastInit
		dw offset NLS_IOCTL
		dw offset GetDevList
		dw offset NLS_GETEXT
		dw offset MSG_RETRIEVAL
		dw offset NO_OP
ms_copyright	db 'MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp Licensed M'
		db 'aterial - Property of Microsoft All rights reserved '
; ---------------------------------------------------------------------------

$SET_CTRL_C_TRAPPING:			; ...
		cmp	al, 6
		jbe	short scct_1
		mov	al, 0FFh
		iret
; ---------------------------------------------------------------------------

scct_1:					; ...
		push	ds
		mov	ds, cs:DosDSeg
		push	ax
		push	si
		mov	si, offset CNTCFLAG
		xor	ah, ah
		or	ax, ax
		jnz	short scct_2
		mov	dl, [si]
		jmp	short scct_9s
; ---------------------------------------------------------------------------

scct_2:					; ...
		dec	ax
		jnz	short scct_3
		and	dl, 1
		mov	[si], dl
		jmp	short scct_9s
; ---------------------------------------------------------------------------

scct_3:					; ...
		dec	ax
		jnz	short scct_4
		and	dl, 1
		xchg	dl, [si]
		jmp	short scct_9s
; ---------------------------------------------------------------------------

scct_4:					; ...
		cmp	ax, 3
		jnz	short scct_5
		mov	dl, BOOTDRIVE
		jmp	short scct_9s
; ---------------------------------------------------------------------------

scct_5:					; ...
		cmp	ax, 4
		jnz	short scct_9s
		mov	bx, 1406h
		mov	dl, 0
		xor	dh, dh
		cmp	DosHasHMA, 0
		jz	short scct_9s
		or	dh, 10h

scct_9s:				; ...
		pop	si
		pop	ax
		pop	ds
		iret
; ---------------------------------------------------------------------------

SetCtrlShortEntry:			; ...
		jmp	short $SET_CTRL_C_TRAPPING
; ---------------------------------------------------------------------------

$SET_CURRENT_PDB:			; ...
		push	ds
		mov	ds, cs:DosDSeg
		mov	CurrentPDB, bx
		pop	ds
		iret
; ---------------------------------------------------------------------------

$GET_CURRENT_PDB:			; ...
		push	ds
		mov	ds, cs:DosDSeg
		mov	bx, CurrentPDB
		pop	ds
		iret
; ---------------------------------------------------------------------------

$SET_PRINTER_FLAG:			; ...
		push	ds
		mov	ds, cs:DosDSeg
		mov	PRINTER_FLAG, al
		pop	ds
		iret
; ---------------------------------------------------------------------------

quit:					; ...
		xor	ah, ah
		jmp	short SAVREGS
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR STATCHK

BADCALL:				; ...
		xor	al, al

irett:					; ...
		iret
; END OF FUNCTION CHUNK	FOR STATCHK
; ---------------------------------------------------------------------------

call_entry:				; ...
		push	ds
		mov	ds, cs:DosDSeg
		pop	SAVEDS
		pop	ax
		pop	ax
		pop	USER_SP
		pushf
		cli
		push	ax
		push	USER_SP
		push	SAVEDS
		pop	ds
		cmp	cl, 36
		ja	short BADCALL
		mov	ah, cl
		jmp	short SAVREGS
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR STATCHK

command:				; ...
		cli
		cmp	ah, 6Ch
		ja	short BADCALL
; END OF FUNCTION CHUNK	FOR STATCHK

SAVREGS:				; ...
		cmp	ah, 33h
		jb	short SaveAllRegs
		jz	short SetCtrlShortEntry
		cmp	ah, 64h
		ja	short SaveAllRegs
		jz	short $SET_PRINTER_FLAG
		cmp	ah, 51h
		jz	short $GET_CURRENT_PDB
		cmp	ah, 62h
		jz	short $GET_CURRENT_PDB
		cmp	ah, 50h
		jz	short $SET_CURRENT_PDB

SaveAllRegs:				; ...
		push	es
		push	ds
		push	bp
		push	di
		push	si
		push	dx
		push	cx
		push	bx
		push	ax
		mov	ax, ds
		mov	ds, cs:DosDSeg
		mov	SAVEDS,	ax
		mov	SAVEBX,	bx
		mov	ax, USER_SP
		mov	NSP, ax
		mov	ax, USER_SS
		mov	NSS, ax
		xor	ax, ax
		mov	FSHARING, al
		test	IsWin386, 1
		jnz	short set_indos_flag
		mov	USER_ID, ax

set_indos_flag:				; ...
		inc	INDOS
		mov	USER_SP, sp
		mov	USER_SS, ss
		mov	ax, CurrentPDB
		mov	PROC_ID, ax
		mov	ds, ax
		pop	ax
		push	ax
		mov	word ptr BCLOCK, sp
		mov	word ptr BCLOCK+2, ss
		mov	ss, cs:DosDSeg

REDISP:					; ...
		mov	sp, offset AUXSTACK
		sti
		mov	bx, ss
		mov	ds, bx
		xchg	ax, bx
		xor	ax, ax
		mov	ss:EXTOPEN_ON, al
		and	ss:DOS34_FLAG, 800h
		mov	ss:CONSWAP, al
		mov	ss:NoSetDir, al
		mov	ss:FAILERR, al
		inc	ax
		mov	ss:IDLEINT, al
		xchg	ax, bx
		mov	bl, ah
		shl	bx, 1
		cld
		or	ah, ah
		jz	short DSKROUT
		cmp	ah, 59h
		jz	short DISPCALL
		cmp	ah, 0Ch
		ja	short DSKROUT

IOROUT:
		cmp	ss:ERRORMODE, 0
		jnz	short DISPCALL
		mov	sp, offset PRINTER_FLAG
		jmp	short DISPCALL
; ---------------------------------------------------------------------------

DSKROUT:				; ...
		mov	ss:USER_IN_AX, ax
		mov	ss:EXTERR_LOCUS, 1
		mov	ss:ERRORMODE, 0
		mov	ss:WPERR, 0FFh
		push	ax
		mov	ah, 82h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTIONS 0 THROUGH 7
		pop	ax
		mov	ss:IDLEINT, 0
		mov	sp, offset DSKSTACK
		test	ss:CNTCFLAG, 0FFh
		jz	short DISPCALL
		push	ax
		call	DSKSTATCHK
		pop	ax

DISPCALL:				; ...
		mov	bx, cs:DISPATCH[bx]
		xchg	bx, ss:SAVEBX
		mov	ds, ss:SAVEDS
		call	ss:SAVEBX
		and	ss:DOS_FLAG, 0FBh

LeaveDOS:				; ...
		cli
		mov	ds, cs:DosDSeg
		cmp	A20OFF_COUNT, 0
		jnz	short disa20

LeaveA20On:				; ...
		dec	INDOS
		mov	ss, USER_SS
		mov	sp, USER_SP
		mov	bp, sp
		mov	[bp+0],	al
		mov	ax, NSP
		mov	USER_SP, ax
		mov	ax, NSS
		mov	USER_SS, ax
		pop	ax
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	di
		pop	bp
		pop	ds
		pop	es
		iret
; ---------------------------------------------------------------------------

disa20:					; ...
		mov	bx, A20OFF_PSP
		cmp	bx, CurrentPDB
		jnz	short LeaveA20On
		dec	A20OFF_COUNT
		push	ds
		mov	bx, offset disa20_iret
		push	bx
		retf

; =============== S U B	R O U T	I N E =======================================


restore_world	proc near		; ...
		mov	es, cs:DosDSeg
		pop	es:RESTORE_TMP
		pop	ax
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	di
		pop	bp
		pop	ds
		jmp	es:RESTORE_TMP
restore_world	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

save_world	proc near		; ...
		mov	es, cs:DosDSeg
		pop	es:RESTORE_TMP
		push	ds
		push	bp
		push	di
		push	si
		push	dx
		push	cx
		push	bx
		push	ax
		push	es:RESTORE_TMP
		push	bp
		mov	bp, sp
		mov	es, word ptr [bp+20]
		pop	bp
		retn
save_world	endp


; =============== S U B	R O U T	I N E =======================================


Get_User_Stack	proc near		; ...
		mov	ds, cs:DosDSeg
		lds	si, dword ptr USER_SP
		retn
Get_User_Stack	endp

; ---------------------------------------------------------------------------
ERRIN		db 2			; ...
		db 6
		db 12
		db 4
		db 8
		db 0
ERROUT		db 80h
		db 40h
		db 2
		db 10h
		db 4
		db 3

; =============== S U B	R O U T	I N E =======================================


AbsSetup	proc near		; ...
		inc	ss:INDOS
		sti
		cld
		push	ds
		push	ss
		pop	ds
		call	GETBP
		jb	short errdriv
		mov	word ptr es:[bp+1Fh], 0FFFFh

errdriv:				; ...
		pop	ds
		jnb	short AbsSetup2

AbsSetup_retn:				; ...
		retn
; ---------------------------------------------------------------------------

AbsSetup2:				; ...
		mov	ss:HIGH_SECTOR,	0
		call	RW32_CONVERT
		jb	short AbsSetup_retn
		call	SET_RQ_SC_PARMS
		push	ds
		push	si
		push	ax
		push	ss
		pop	ds
		mov	si, offset OPENBUF
		mov	[si], al
		add	byte ptr [si], 'A'
		mov	word ptr [si+1], ':'
		mov	ax, 300h
		clc
		int	2Ah		; Microsoft Networks - CHECK DIRECT I/O
					; DS:SI	-> ASCIZ disk device name (may be full path or only drive
					; specifier--must include the colon)
					; Return: CF clear if absolute disk access allowed
		pop	ax
		pop	si
		pop	ds
		jnb	short AbsSetup_retn
		mov	ss:EXTERR, 32h ; '2'
		retn
AbsSetup	endp

; ---------------------------------------------------------------------------

ABSDRD:					; ...
		cli
		push	ax
		mov	ax, ds
		mov	ds, cs:DosDSeg
		mov	TEMPSEG, ax
		pop	ax
		push	es
		mov	AbsRdWr_SS, ss
		mov	AbsRdWr_SP, sp
		mov	ss, cs:DosDSeg
		mov	sp, offset DSKSTACK
		mov	ds, TEMPSEG
		push	es
		call	save_world
		push	es
		call	AbsSetup
		jb	short ILEAVE
		call	ECritDisk
		mov	ss:CurSC_DRIVE,	0FFh
		call	LCritDisk
		call	DSKREAD
		jnz	short ERR_LEAVE
		mov	cx, di
		mov	ss:TEMP_VAR2, ds
		mov	ss:TEMP_VAR, bx
		call	DskRdBufScan
		jmp	short ILEAVE
; ---------------------------------------------------------------------------

TLEAVE:					; ...
		jz	short ILEAVE

ERR_LEAVE:				; ...
		push	es
		push	cs
		pop	es
		xor	ah, ah
		mov	cx, 6
		mov	di, offset ERRIN
		repne scasb
		jnz	short LEAVECODE
		mov	ah, es:[di+5]

LEAVECODE:				; ...
		pop	es
		mov	ss:AbsDskErr, ax
		stc

ILEAVE:					; ...
		pop	es
		call	restore_world
		pop	es
		cli
		mov	ax, ss:AbsDskErr
		dec	ss:INDOS
		push	ss
		pop	es
		mov	ss, es:AbsRdWr_SS
		mov	sp, es:AbsRdWr_SP
		pop	es
		sti
		retf
; ---------------------------------------------------------------------------

ABSDWRT:				; ...
		cli
		push	ax
		mov	ax, ds
		mov	ds, cs:DosDSeg
		mov	TEMPSEG, ax
		pop	ax
		push	es
		mov	AbsRdWr_SS, ss
		mov	AbsRdWr_SP, sp
		mov	ss, cs:DosDSeg
		mov	sp, offset DSKSTACK
		mov	ds, TEMPSEG
		push	es
		call	save_world
		push	es
		call	AbsSetup
		jb	short ILEAVE
		call	ECritDisk
		mov	ss:CurSC_DRIVE,	0FFh
		call	Fastxxx_Purge
		call	LCritDisk
		push	ds
		call	DskWrtBufPurge
		pop	ds
		call	DSKWRITE
		jmp	short TLEAVE
; ---------------------------------------------------------------------------

GETBP:					; ...
		push	ax
		add	al, 1
		jb	short SKIPGET
		call	GETTHISDRV
		jnb	short SKIPGET
		xor	ah, ah
		cmp	ax, 1Ah
		jz	short SKIPGET
		stc
		mov	EXTERR,	ax
		mov	AbsDskErr, 201h

SKIPGET:				; ...
		pop	ax
		jnb	short GETBP_@f
		retn
; ---------------------------------------------------------------------------

GETBP_@f:				; ...
		les	bp, THISCDS
		test	word ptr es:[bp+43h], 8000h
		jz	short GETBP_CDS
		mov	EXTERR,	32h ; '2'
		stc
		retn
; ---------------------------------------------------------------------------

GETBP_CDS:				; ...
		les	bp, es:[bp+45h]

GOTDPB:					; ...
		mov	word ptr THISDPB, bp
		mov	word ptr THISDPB+2, es
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $Extended_Open

SYS_RET_OK:				; ...
		call	Get_User_Stack
		and	word ptr [si+16h], 0FFFEh
		jmp	short DO_RET
; END OF FUNCTION CHUNK	FOR $Extended_Open
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $IOCTL

SYS_RET_ERR:				; ...
		xor	ah, ah
		call	ETAB_LK
		call	ErrorMap

From_GetSet:				; ...
		call	Get_User_Stack
		or	word ptr [si+16h], 1
		stc

DO_RET:					; ...
		mov	[si], ax
		retn
; END OF FUNCTION CHUNK	FOR $IOCTL
; ---------------------------------------------------------------------------

NO_OP:					; ...
		xor	al, al
		retn

; =============== S U B	R O U T	I N E =======================================


FCB_RET_ERR	proc near		; ...
		xor	ah, ah
		mov	ss:EXTERR, ax
		call	ErrorMap
		mov	al, 0FFh
		retn
FCB_RET_ERR	endp


; =============== S U B	R O U T	I N E =======================================


ErrorMap	proc near		; ...
		push	si
		mov	si, offset ERR_TABLE_21
		cmp	ss:FAILERR, 0
		jz	short EXTENDED_NORMAL
		mov	ss:EXTERR, 53h ; 'S'

EXTENDED_NORMAL:			; ...
		call	CAL_LK
		pop	si
		retn
ErrorMap	endp


; =============== S U B	R O U T	I N E =======================================


CAL_LK		proc near		; ...
		push	ds
		push	ax
		push	bx
		mov	ds, cs:DosDSeg
		mov	bx, EXTERR

TABLK1:					; ...
		lodsb
		cmp	al, 0FFh
		jz	short GOT_VALS
		cmp	al, bl
		jz	short GOT_VALS
		add	si, 3
		jmp	short TABLK1
; ---------------------------------------------------------------------------

GOT_VALS:				; ...
		lodsw
		cmp	ah, 0FFh
		jz	short NO_SET_ACT
		mov	byte ptr EXTERR_ACT_CLASS, ah

NO_SET_ACT:				; ...
		cmp	al, 0FFh
		jz	short NO_SET_CLS
		mov	byte ptr EXTERR_ACT_CLASS+1, al

NO_SET_CLS:				; ...
		lodsb
		cmp	al, 0FFh
		jz	short NO_SET_LOC
		mov	EXTERR_LOCUS, al

NO_SET_LOC:				; ...
		pop	bx
		pop	ax
		pop	ds
		retn
CAL_LK		endp


; =============== S U B	R O U T	I N E =======================================


ETAB_LK		proc near		; ...
		push	ds
		push	si
		push	cx
		push	bx
		push	ss
		pop	ds
		mov	EXTERR,	ax
		mov	si, offset I21_MAP_E_TAB
		mov	bh, al
		mov	bl, byte ptr USER_IN_AX+1

TABLK2:					; ...
		lods	word ptr cs:[si]
		cmp	al, 0FFh
		jz	short NOT_IN_TABLE
		cmp	al, bl
		jz	short GOT_CALL
		xchg	ah, al
		xor	ah, ah
		add	si, ax
		jmp	short TABLK2
; ---------------------------------------------------------------------------

NOT_IN_TABLE:				; ...
		mov	al, bh
		jmp	short NO_MAP
; ---------------------------------------------------------------------------

GOT_CALL:				; ...
		mov	cl, ah
		xor	ch, ch

CHECK_CODE:				; ...
		lods	byte ptr cs:[si]
		cmp	al, bh
		jz	short NO_MAP
		loop	CHECK_CODE

NO_MAP:					; ...
		xor	ah, ah
		pop	bx
		pop	cx
		pop	si
		pop	ds
		retn
ETAB_LK		endp


; =============== S U B	R O U T	I N E =======================================


SetBad		proc near		; ...
		mov	ax, 1
		push	ds
		mov	ds, cs:DosDSeg
		mov	EXTERR_LOCUS, 1
		pop	ds
		stc
		retn
SetBad		endp


; =============== S U B	R O U T	I N E =======================================


BadCall		proc far		; ...
		call	SetBad
		retf
BadCall		endp


; =============== S U B	R O U T	I N E =======================================


OKCall		proc far		; ...
		clc
		retf
OKCall		endp

; ---------------------------------------------------------------------------

INT2F:					; ...
		sti
		cmp	ah, 11h		; MultNET
		jnz	short INT2FSHR

TestInstall:				; ...
		or	al, al
		jz	short Leave2F

BadFunc:				; ...
		call	SetBad

Leave2F:				; ...
		retf	2
; ---------------------------------------------------------------------------

INT2FSHR:				; ...
		cmp	ah, 10h		; MultSHARE
		jz	short TestInstall
		cmp	ah, 14h		; NLSFUNC
		jz	short TestInstall
		cmp	ah, 12h		; MultDOS
		jnz	short check_win
		jmp	DispatchDOS
; ---------------------------------------------------------------------------

check_win:				; ...
		cmp	ah, 16h
		jz	short Win386_Msg
		cmp	ah, 46h	; 'F'
		jnz	short next_i2f
		jmp	Winold_swap
; ---------------------------------------------------------------------------

next_i2f:				; ...
		jmp	far ptr	70h:5
; ---------------------------------------------------------------------------

Win386_Msg:				; ...
		push	ds
		mov	ds, cs:DosDSeg
		cmp	al, 3
		jnz	short Win386_Msg_exit
		jmp	OldWin386Init
; ---------------------------------------------------------------------------

Win386_Msg_exit:			; ...
		cmp	al, 6
		jnz	short Win386_Msg_devcall
		jmp	Win386_Leaving
; ---------------------------------------------------------------------------

Win386_Msg_devcall:			; ...
		cmp	al, 7
		jnz	short Win386_Msg_init
		jmp	Win386_Query
; ---------------------------------------------------------------------------

Win386_Msg_init:			; ...
		cmp	al, 5
		jz	short Win386_Starting
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_Starting:			; ...
		test	dx, 1
		jz	short Win386_vchk
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_vchk:				; ...
		mov	word ptr Win386_Info_6,	0
		mov	word ptr Win386_Info_6+2, 0
		cmp	di, 30Ah
		jb	short Win386_vxd
		jmp	noVxD31
; ---------------------------------------------------------------------------

Win386_vxd:				; ...
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		mov	bx, UMB_HEAD
		cmp	bx, 0FFFFh
		jz	short Vxd31
		mov	UmbSaveFlag, 1
		push	ds
		push	es
		mov	ax, ds
		mov	es, ax
		mov	ds, bx
		assume ds:nothing
		xor	si, si
		cld
		mov	di, offset UmbSave1
		mov	cx, 11
		rep movsb
		mov	di, offset UmbSave2
		mov	cx, 5
		rep movsb
		pop	es
		pop	ds
		assume ds:DOSDATA

Vxd31:					; ...
		test	DOS_FLAG, 2
		jz	short Dont_Supress
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jmp	short noVxD31
; ---------------------------------------------------------------------------

Dont_Supress:				; ...
		mov	al, BOOTDRIVE
		add	al, 40h	; '@'
		mov	byte ptr VxDpath, al ; "c:\\wina20.386"
		mov	ah, 6Ch	; 'l'
		mov	al, 0
		mov	bx, 2080h
		mov	cx, 7
		mov	dx, 1
		mov	si, offset VxDpath ; "c:\\wina20.386"
		mov	di, 0FFFFh
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		pop	di
		pop	si
		pop	dx
		pop	cx
		jnb	short VxDthere
		push	dx
		push	ds
		push	si
		mov	si, offset NoVxDErrMsg ; "You must have	the file WINA20.386 in th"...
		push	cs
		pop	ds
		mov	cx, 99
		mov	ah, 2
		cld

vxdlp:					; ...
		lodsb
		xchg	dl, al
		int	21h		; DOS -
		loop	vxdlp
		pop	si
		pop	ds
		pop	dx
		pop	bx
		pop	ax
		inc	cx
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

VxDthere:				; ...
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	bx, offset Win386_Info
		mov	word ptr [bx+6], offset	VxDpath	; "c:\\wina20.386"
		mov	word ptr [bx+8], ds
		pop	bx
		pop	ax

noVxD31:				; ...
		or	IsWin386, 1
		or	redir_patch, 1
		push	dx
		mov	dx, bx
		mov	bx, offset Win386_Info
		mov	[bx+2],	dx
		mov	word ptr [bx+4], es
		pop	dx
		push	ds
		pop	es
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_Leaving:				; ...
		test	dx, 1
		jz	short Win386_Leaving_c
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_Leaving_c:			; ...
		cmp	UmbSaveFlag, 1
		jnz	short noumb
		mov	UmbSaveFlag, 0
		push	ax
		push	es
		push	cx
		push	si
		push	di
		mov	ax, UMB_HEAD
		mov	es, ax
		xor	di, di
		cld
		mov	si, offset UmbSave1
		mov	cx, 11
		rep movsb
		mov	si, offset UmbSave2
		mov	cx, 5
		rep movsb
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ax

noumb:					; ...
		and	IsWin386, 0
		and	redir_patch, 0
		jmp	short win_nexti2f
; ---------------------------------------------------------------------------

Win386_Query:				; ...
		cmp	bx, 15h
		jnz	short win_nexti2f
		or	cx, cx
		jnz	short dosmgr_func
		inc	cx
		mov	bx, offset Win386_DOSVars
		push	ds
		pop	es
		jmp	short PopIret
; ---------------------------------------------------------------------------

OldWin386Init:				; ...
		pop	ax
		mov	si, offset OldInstanceJunk
		mov	ax, 5248h
		jmp	next_i2f
; ---------------------------------------------------------------------------

dosmgr_func:				; ...
		dec	cx
		jz	short win386_patch
		dec	cx
		jz	short PopIret
		dec	cx
		jz	short win386_size
		dec	cx
		jz	short win386_inst
		dec	cx
		jnz	short PopIret
		mov	ax, es
		dec	ax
		push	es
		mov	es, ax
		cmp	byte ptr es:[di], 'D'
		jnz	short cantsize
		inc	ax
		cmp	es:[di+1], ax
		jnz	short cantsize
		mov	ax, es:[di+3]
		pop	es
		mov	bx, 16
		mul	bx
		mov	cx, ax
		mov	bx, dx
		jmp	short win386_done
; ---------------------------------------------------------------------------

cantsize:				; ...
		pop	es
		xor	ax, ax
		xor	dx, dx
		jmp	short PopIret
; ---------------------------------------------------------------------------

win386_patch:				; ...
		mov	bx, dx
		jmp	short win386_done
; ---------------------------------------------------------------------------

win386_size:				; ...
		test	dx, 1
		jz	short PopIret
		mov	cx, 88
		jmp	short win386_done
; ---------------------------------------------------------------------------

win386_inst:				; ...
		xor	dx, dx
		jmp	short PopIret
; ---------------------------------------------------------------------------

win386_done:				; ...
		mov	ax, 0B97Ch
		mov	dx, 0A2ABh

PopIret:				; ...
		pop	ds
		iret
; ---------------------------------------------------------------------------

win_nexti2f:				; ...
		pop	ds
		jmp	next_i2f

; =============== S U B	R O U T	I N E =======================================


getwinlast	proc near		; ...
		mov	si, CurrentPDB
		dec	si
		mov	es, si
		add	si, word ptr es:byte_0+3
		retn
getwinlast	endp

; ---------------------------------------------------------------------------

Winold_swap:				; ...
		push	ds
		push	es
		push	si
		push	di
		push	cx
		mov	ds, cs:DosDSeg
		cmp	al, 1
		jnz	short swapin
		call	getwinlast
		push	ds
		pop	es
		mov	ds, si
		xor	si, si
		mov	di, offset WinoldPatch1
		mov	cx, 8
		cld
		push	cx
		rep movsb
		pop	cx
		mov	di, offset WinoldPatch2
		rep movsb
		jmp	short winold_done
; ---------------------------------------------------------------------------

swapin:					; ...
		cmp	al, 2
		jnz	short winold_done
		call	getwinlast
		mov	es, si
		xor	di, di
		mov	si, offset WinoldPatch1
		mov	cx, 8
		cld
		push	cx
		rep movsb
		pop	cx
		mov	si, offset WinoldPatch2
		rep movsb

winold_done:				; ...
		pop	cx
		pop	di
		pop	si
		pop	es
		pop	ds
		jmp	next_i2f
; ---------------------------------------------------------------------------

DispatchDOS:				; ...
		push	cs:FOO
		push	cs:DTab
		push	ax
		push	bp
		mov	bp, sp
		mov	ax, [bp+0Eh]
		pop	bp
		call	TableDispatch
		jmp	BadFunc
; ---------------------------------------------------------------------------

DOSGetGroup:				; ...
		mov	ds, cs:DosDSeg
		retn
; ---------------------------------------------------------------------------

DOSInstall:				; ...
		mov	al, 0FFh
		retn

; =============== S U B	R O U T	I N E =======================================


RW32_CONVERT	proc near		; ...
		cmp	cx, 0FFFFh
		jz	short new32format
		push	ax
		push	dx
		mov	ax, es:[bp+0Dh]
		mov	dl, es:[bp+4]
		cmp	dl, 0FEh ; ''
		jz	short letold
		inc	dl
		xor	dh, dh
		mul	dx
		or	dx, dx

letold:					; ...
		pop	dx
		pop	ax
		jz	short old_style
		push	ds
		mov	ds, cs:DosDSeg
		mov	AbsDskErr, 207h
		pop	ds
		stc
		retn
; ---------------------------------------------------------------------------

new32format:				; ...
		mov	dx, [bx+2]
		push	ds
		mov	ds, cs:DosDSeg
		mov	HIGH_SECTOR, dx
		pop	ds
		mov	dx, [bx]
		mov	cx, [bx+4]
		lds	bx, [bx+6]

old_style:				; ...
		clc
		retn
RW32_CONVERT	endp


; =============== S U B	R O U T	I N E =======================================


Fastxxx_Purge	proc near		; ...
		push	ax
		push	si
		push	dx
		push	ds
		mov	ds, cs:DosDSeg
		test	FastOpenFlg, 80h
		pop	ds
		jz	short nofast
		mov	ah, 1
		mov	al, 5
		mov	dl, es:[bp+0]
		call	Fast_Dispatch

nofast:					; ...
		pop	dx
		pop	si
		pop	ax
		retn
Fastxxx_Purge	endp

; ---------------------------------------------------------------------------
DIVMES		db 0Dh,0Ah		; ...
		db 'Divide overflow',0Dh,0Ah
DivMesLen	dw 19			; ...
NoVxDErrMsg	db 'You must have the file WINA20.386 in the root of your boot drive',0Dh ; ...
		db 0Ah
		db 'to run Windows in Enhanced Mode',0Dh,0Ah
NLS_YES		db 'Y'                  ; ...
NLS_NO		db 'N'                  ; ...
NLS_yes2	db 'y'                  ; ...
NLS_no2		db 'n'                  ; ...
CANCHAR		db 1Bh			; ...
ESCCHAR		db 0			; ...
ESCTAB		db 64, 77, 59, 83, 60, 62, 61 ;	...
		db 61, 63, 75, 82, 82, 65, 65
ESCFUNC		dw offset GETCH		; ...
		dw offset TWOESC
		dw offset EXITINS_ENTERINS
		dw offset EXITINS_ENTERINS
		dw offset BACKSP
		dw offset REEDIT
		dw offset KILNEW
		dw offset COPYLIN
		dw offset SKIPSTR
		dw offset COPYSTR
		dw offset SKIPONE
		dw offset COPYONE
		dw offset COPYONE
		dw offset CTRLZ
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $STD_CON_STRING_INPUT

OEMFunctionKey:				; ...
		call	$STD_CON_INPUT_NO_ECHO
		mov	cl, 14
		push	di
		mov	di, offset ESCTAB
		push	es
		push	cs
		pop	es
		repne scasb
		pop	es
		pop	di
		shl	cx, 1
		mov	bp, cx
		jmp	cs:ESCFUNC[bp]
; END OF FUNCTION CHUNK	FOR $STD_CON_STRING_INPUT
; ---------------------------------------------------------------------------

$GET_DATE:				; ...
		push	ss
		pop	ds
		call	READTIME
		mov	ax, YEAR
		mov	bx, word ptr DAY
		call	Get_User_Stack
		mov	[si+6],	bx
		add	ax, 1980
		mov	[si+4],	ax
		mov	al, ss:WEEKDAY

_RET24:					; ...
		retn
; ---------------------------------------------------------------------------

$SET_DATE:				; ...
		mov	al, -1
		sub	cx, 1980
		jb	short _RET24
		cmp	cx, 119
		ja	short RET24
		or	dh, dh
		jz	short _RET24
		or	dl, dl
		jz	short _RET24
		cmp	dh, 12
		ja	short RET24
		push	ss
		pop	ds
		call	DODATE

RET24:					; ...
		retn
; ---------------------------------------------------------------------------

$GET_TIME:				; ...
		push	ss
		pop	ds
		call	READTIME
		call	Get_User_Stack
		mov	[si+6],	dx
		mov	[si+4],	cx
		xor	al, al

RET26:					; ...
		retn
; ---------------------------------------------------------------------------

$SET_TIME:				; ...
		mov	al, -1
		cmp	ch, 24
		jnb	short RET26
		cmp	cl, 60
		jnb	short RET26
		cmp	dh, 60
		jnb	short RET26
		cmp	dl, 100
		jnb	short RET26
		push	cx
		push	dx
		push	ss
		pop	ds
		mov	bx, offset TIMEBUF
		mov	cx, 6
		xor	dx, dx
		mov	ax, dx
		push	bx
		call	SETREAD
		push	ds
		lds	si, BCLOCK
		call	DEVIOCALL2
		pop	ds
		pop	bx
		call	SETWRITE
		pop	TIMEBUF+4
		pop	TIMEBUF+2
		lds	si, BCLOCK
		call	DEVIOCALL2
		xor	al, al
		retn

; =============== S U B	R O U T	I N E =======================================


DATE16		proc near		; ...
		mov	ds, cs:DosDSeg
		push	cx
		push	es
		call	READTIME
		pop	es
		shl	cl, 1
		shl	cl, 1
		shl	cx, 1
		shl	cx, 1
		shl	cx, 1
		shr	dh, 1
		or	cl, dh
		mov	dx, cx
		mov	ax, word ptr MONTH
		mov	cl, 4
		shl	al, cl
		shl	ax, 1
		pop	cx
		or	al, DAY

RET21:					; ...
		retn
DATE16		endp


; =============== S U B	R O U T	I N E =======================================


READTIME	proc near		; ...
		mov	DATE_FLAG, 0
		push	si
		push	bx
		mov	bx, offset TIMEBUF
		mov	cx, 6
		xor	dx, dx
		mov	ax, dx
		call	SETREAD
		push	ds
		lds	si, BCLOCK
		call	DEVIOCALL2
		pop	ds
		pop	bx
		pop	si
		mov	ax, TIMEBUF
		mov	cx, TIMEBUF+2
		mov	dx, TIMEBUF+4
		cmp	ax, DAYCNT
		jz	short RET21
		cmp	ax, 43830
		jnb	short RET22
		mov	DAYCNT,	ax
		push	si
		push	cx
		push	dx
		xor	dx, dx
		mov	cx, 1461
		div	cx
		shl	ax, 1
		shl	ax, 1
		shl	ax, 1
		mov	cx, ax
		mov	si, offset YRTAB
		call	DSLIDE
		shr	cx, 1
		jnb	short SK
		add	dx, 200

SK:					; ...
		call	SETYEAR
		mov	cl, 1
		mov	si, offset MONTAB
		call	DSLIDE
		mov	MONTH, cl
		inc	dx
		mov	DAY, dl
		call	WKDAY
		pop	dx
		pop	cx
		pop	si

RET22:					; ...
		retn
READTIME	endp


; =============== S U B	R O U T	I N E =======================================


DSLIDE		proc near		; ...
		mov	ah, 0

DSLIDE1:				; ...
		lodsb
		cmp	dx, ax
		jb	short RET22
		sub	dx, ax
		inc	cx
		jmp	short DSLIDE1
DSLIDE		endp


; =============== S U B	R O U T	I N E =======================================


SETYEAR		proc near		; ...
		mov	ds, cs:DosDSeg
		mov	byte ptr YEAR, cl

CHKYR:					; ...
		test	cl, 3
		mov	al, 28
		jnz	short SAVFEB
		inc	al

SAVFEB:					; ...
		mov	february, al

RET23:					; ...
		retn
SETYEAR		endp


; =============== S U B	R O U T	I N E =======================================


DODATE		proc near		; ...
		call	CHKYR
		mov	al, dh
		mov	bx, (offset YRTAB+7) ; MONTAB-1
		xlat
		cmp	al, dl
		mov	al, -1
		jb	short RET23
		call	SETYEAR
		mov	word ptr DAY, dx
		shr	cx, 1
		shr	cx, 1
		mov	ax, 1461
		mov	bx, dx
		mul	cx
		mov	cl, byte ptr YEAR
		and	cl, 3
		mov	si, offset YRTAB
		mov	dx, ax
		shl	cx, 1
		call	DSUM
		mov	cl, bh
		mov	si, offset MONTAB
		dec	cx
		call	DSUM
		mov	cl, bl
		dec	cx
		add	dx, cx
		xchg	ax, dx
		mov	DAYCNT,	ax
		push	si
		push	bx
		push	ax
		mov	bx, offset TIMEBUF
		mov	cx, 6
		xor	dx, dx
		mov	ax, dx
		push	bx
		call	SETREAD
		push	ds
		lds	si, BCLOCK
		call	DEVIOCALL2
		pop	ds
		pop	bx
		call	SETWRITE
		pop	TIMEBUF
		push	ds
		lds	si, BCLOCK
		call	DEVIOCALL2
		pop	ds
		pop	bx
		pop	si

WKDAY:					; ...
		mov	ax, DAYCNT
		xor	dx, dx
		mov	cx, 7
		inc	ax
		inc	ax
		div	cx
		mov	WEEKDAY, dl
		xor	al, al
		retn
DODATE		endp


; =============== S U B	R O U T	I N E =======================================


DSUM		proc near		; ...
		mov	ah, 0
		jcxz	short DSUM9

DSUM1:					; ...
		lodsb
		add	dx, ax
		loop	DSUM1

DSUM9:					; ...
		retn
DSUM		endp

; ---------------------------------------------------------------------------

$GET_VERSION:				; ...
		push	ss
		pop	ds
		mov	bx, word ptr USERNUM_hb
		mov	cx, USERNUM
		cmp	al, 1
		jnz	short norm_vers
		xor	bh, bh

norm_vers:				; ...
		push	ds
		mov	ds, CurrentPDB
		mov	ax, word ptr SFTFCB
		pop	ds
		call	Get_User_Stack
		mov	[si], ax
		mov	[si+2],	bx
		mov	[si+4],	cx
		retn
; ---------------------------------------------------------------------------

$GET_VERIFY_ON_WRITE:			; ...
		mov	al, ss:VERFLG
		retn
; ---------------------------------------------------------------------------

$SET_VERIFY_ON_WRITE:			; ...
		and	al, 1
		mov	ss:VERFLG, al

RET27:					; ...
		retn
; ---------------------------------------------------------------------------

$INTERNATIONAL:				; ...
		cmp	al, 0FFh
		jz	short BX_HAS_CODE
		mov	bl, al
		xor	bh, bh

BX_HAS_CODE:				; ...
		push	ds
		pop	es
		push	dx
		pop	di
		push	ss
		pop	ds
		cmp	di, 0FFFFh
		jz	short international_set
		or	bx, bx
		jnz	short international_find
		mov	si, offset COUNTRY_CDPG
		jmp	short international_copy
; ---------------------------------------------------------------------------

international_find:			; ...
		mov	bp, 0
		call	international_get
		jb	short errtn
		cmp	bx, 0
		jnz	short international_copy
		mov	bx, dx
		jmp	short international_ok3

; =============== S U B	R O U T	I N E =======================================


international_get proc near		; ...
		mov	si, offset COUNTRY_CDPG
		cmp	bx, ss:[si+68h]
		jz	short RET27
		mov	dx, bx
		xor	bx, bx
		mov	ax, 1400h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh
		jnz	short interr
		or	bp, bp
		jnz	short stcdpg
		mov	ax, 1404h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - GET COUNTRY INFO
					; BX = code page, DX = country code, DS:SI -> internal code page structure
					; ES:DI	-> user	buffer
					; Return: AL = status
		jmp	short chkok
; ---------------------------------------------------------------------------

stcdpg:					; ...
		mov	ax, 1403h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - SET COUNTRY INFO
					; DS:SI	-> internal code page structure
					; BX = code page, DX = country code
					; Return: AL = status

chkok:					; ...
		or	al, al
		jz	short RET27

setcarry:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

interr:					; ...
		mov	al, 0FFh
		jmp	short setcarry
international_get endp

; ---------------------------------------------------------------------------

international_copy:			; ...
		mov	bx, ss:[si+68h]
		mov	si, offset COUNTRY_CDPG_108
		mov	cx, 24
		push	ds
		push	ss
		pop	ds
		rep movsb
		pop	ds

international_ok3:			; ...
		call	Get_User_Stack
		mov	[si+2],	bx

international_ok:			; ...
		mov	ax, bx

SYS_RET_OK_jmp:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

international_set:			; ...
		mov	bp, 1
		call	international_get
		jnb	short international_ok

errtn:					; ...
		cmp	al, 0FFh
		jz	short errtn2

errtn1:					; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

errtn2:					; ...
		mov	al, 1
		jmp	short errtn1
; ---------------------------------------------------------------------------

$GetExtCntry:				; ...
		cmp	al, 20h	; ' '
		jb	short notcap
		test	al, 80h
		jnz	short fileupper
		mov	bx, offset UCASE_TAB_2
		jmp	short capit
; ---------------------------------------------------------------------------

fileupper:				; ...
		mov	bx, offset FILE_UCASE_TAB_2

capit:					; ...
		cmp	al, 20h	; ' '
		jnz	short chkyes
		mov	al, dl
		call	GETLET3
		call	Get_User_Stack
		mov	[si+6],	al
		jmp	short nono
; ---------------------------------------------------------------------------

chkyes:					; ...
		cmp	al, 23h
		jnz	short capstring
		xor	ax, ax
		cmp	dl, cs:NLS_YES
		jz	short yesyes
		cmp	dl, cs:NLS_yes2
		jz	short yesyes
		cmp	dl, cs:NLS_NO
		jz	short nono
		cmp	dl, cs:NLS_no2
		jz	short nono
		inc	ax

yesyes:					; ...
		inc	ax

nono:					; ...
		jmp	short SYS_RET_OK_jmp
; ---------------------------------------------------------------------------

capstring:				; ...
		mov	si, dx
		cmp	al, 21h
		jnz	short capascii
		or	cx, cx
		jz	short nono

concap:					; ...
		lodsb
		call	GETLET3
		mov	[si-1],	al
		loop	concap
		jmp	short nono
; ---------------------------------------------------------------------------

capascii:				; ...
		cmp	al, 22h
		jnz	short capinval

concap2:				; ...
		lodsb
		or	al, al
		jz	short nono
		call	GETLET3
		mov	[si-1],	al
		jmp	short concap2
; ---------------------------------------------------------------------------

notcap:					; ...
		cmp	cx, 5
		jb	short sizeerror
		push	ss
		pop	ds
		mov	si, offset COUNTRY_CDPG
		cmp	dx, 0FFFFh
		jnz	short GETCDPG
		mov	dx, [si+68h]

GETCDPG:				; ...
		cmp	bx, 0FFFFh
		jnz	short CHKAGAIN
		mov	bx, [si+6Ah]

CHKAGAIN:				; ...
		cmp	dx, [si+68h]
		jnz	short CHKNLS
		cmp	bx, [si+6Ah]
		jnz	short CHKNLS
		mov	bx, [si+48h]
		push	cx
		mov	cx, [si+4Ah]
		mov	si, offset COUNTRY_CDPG_76

NXTENTRY:				; ...
		cmp	al, [si]
		jz	short FOUNDIT
		add	si, 5
		loop	NXTENTRY
		pop	cx

capinval:				; ...
		mov	al, 1

SYS_RET_ERR_jmp:			; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

FOUNDIT:				; ...
		movsb
		pop	cx
		cmp	al, 1
		jz	short setsize
		mov	cx, 4
		mov	ax, 5

OK_RETN:				; ...
		rep movsb
		mov	cx, ax
		mov	ax, bx

GETDONE:				; ...
		call	Get_User_Stack
		mov	[si+4],	cx

jmp_to_nono:				; ...
		jmp	short nono
; ---------------------------------------------------------------------------

setsize:				; ...
		sub	cx, 3
		cmp	[si], cx
		jnb	short setsize2
		mov	cx, [si]

setsize2:				; ...
		mov	es:[di], cx
		add	di, 2
		add	si, 2
		mov	ax, cx
		add	ax, 3
		jmp	short OK_RETN
; ---------------------------------------------------------------------------

CHKNLS:					; ...
		xor	ah, ah
		push	ax
		pop	bp
		mov	ax, 1400h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh
		jz	short NLSNXT

sizeerror:				; ...
		mov	al, 1

sizeerror_jmp:				; ...
		jmp	short SYS_RET_ERR_jmp
; ---------------------------------------------------------------------------

NLSNXT:					; ...
		mov	ax, 1402h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - GET COUNTRY INFO
					; BP = subfunction, BX = code page
					; DX = country code, DS:SI -> internal code page structure
					; ES:DI	-> user	buffer,	CX = size of user buffer
					; Return: AL = status
					; 00h successful
					; else DOS error code
		cmp	al, 0
		jnz	short NLSERROR
		mov	ax, [si+48h]
		jmp	short GETDONE
; ---------------------------------------------------------------------------

NLSERROR:				; ...
		jmp	short sizeerror_jmp
; ---------------------------------------------------------------------------

$GetSetCdPg:				; ...
		push	ss
		pop	ds
		mov	si, offset COUNTRY_CDPG
		cmp	al, 1
		jnz	short setglpg
		mov	bx, [si+6Ah]
		mov	dx, [si+48h]
		call	Get_User_Stack
		mov	[si+2],	bx
		mov	[si+6],	dx

OK_RETURN:				; ...
		jmp	short jmp_to_nono
; ---------------------------------------------------------------------------

setglpg:				; ...
		cmp	al, 2
		jnz	short nomem
		mov	dx, [si+68h]
		mov	ax, 1400h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh
		jnz	short nomem
		mov	ax, 1401h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - CHANGE CODE PAGE
					; DS:SI	-> internal code page structure
					; BX = new code	page, DX = country code???
					; Return: AL = status
					; 00h successful
					; else DOS error code
		or	al, al
		jz	short OK_RETURN
		cmp	al, 65
		jnz	short seterr
		mov	ax, 65
		mov	EXTERR,	ax
		mov	byte ptr EXTERR_ACT_CLASS, 6
		mov	byte ptr EXTERR_ACT_CLASS+1, 5
		mov	EXTERR_LOCUS, 4
		jmp	From_GetSet
; ---------------------------------------------------------------------------

seterr:					; ...
		jmp	short NLSERROR
; ---------------------------------------------------------------------------

nomem:					; ...
		mov	al, 1
		jmp	short seterr
; ---------------------------------------------------------------------------

$GET_DRIVE_FREESPACE:			; ...
		push	ss
		pop	ds
		mov	al, dl
		call	GETTHISDRV

SET_AX_RET:				; ...
		jb	short BADFDRV
		call	DISK_INFO
		xchg	dx, bx
		jb	short SET_AX_RET
		xor	ah, ah

DoSt:					; ...
		call	Get_User_Stack
		mov	[si+6],	dx
		mov	[si+4],	cx
		mov	[si+2],	bx
		mov	[si], ax
		retn
; ---------------------------------------------------------------------------

BADFDRV:				; ...
		call	FCB_RET_ERR
		mov	ax, -1
		jmp	short DoSt
; ---------------------------------------------------------------------------

$GET_DMA:				; ...
		mov	bx, word ptr ss:DMAADD
		mov	cx, word ptr ss:DMAADD+2
		call	Get_User_Stack
		mov	[si+2],	bx
		mov	[si+10h], cx
		retn
; ---------------------------------------------------------------------------

$SET_DMA:				; ...
		mov	word ptr ss:DMAADD, dx
		mov	word ptr ss:DMAADD+2, ds
		retn
; ---------------------------------------------------------------------------

$GET_DEFAULT_DRIVE:			; ...
		mov	al, ss:CURDRV
		retn
; ---------------------------------------------------------------------------

$SET_DEFAULT_DRIVE:			; ...
		mov	al, dl
		inc	al
		call	GetVisDrv
		jb	short SETRET
		mov	ss:CURDRV, al

SETRET:					; ...
		mov	al, ss:CDSCOUNT
		retn

; =============== S U B	R O U T	I N E =======================================


$GET_INTERRUPT_VECTOR proc near		; ...
		call	RECSET
		les	bx, es:[bx]
		call	Get_User_Stack
		mov	[si+2],	bx
		mov	word ptr [si+10h], es
		retn
$GET_INTERRUPT_VECTOR endp

; ---------------------------------------------------------------------------

$SET_INTERRUPT_VECTOR:			; ...
		call	RECSET
		cli
		mov	es:[bx], dx
		mov	word ptr es:[bx+2], ds
		sti
		test	ss:DOS_FLAG, 4
		jnz	short siv_1
		retn
; ---------------------------------------------------------------------------

siv_1:					; ...
		cmp	ss:A20OFF_COUNT, 0
		jnz	short siv_2
		mov	ss:A20OFF_COUNT, 1

siv_2:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


RECSET		proc near		; ...
		xor	bx, bx
		mov	es, bx
		mov	bl, al
		shl	bx, 1
		shl	bx, 1
		retn
RECSET		endp

; ---------------------------------------------------------------------------

$CHAR_OPER:				; ...
		or	al, al
		mov	dl, '/'
		jz	short chop_1
		cmp	al, 2
		mov	dl, 0FFh
		jz	short chop_1
		retn
; ---------------------------------------------------------------------------

chop_1:					; ...
		call	Get_User_Stack
		mov	[si+6],	dx
		retn
; ---------------------------------------------------------------------------

$GetExtendedError:			; ...
		push	ss
		pop	ds
		mov	ax, EXTERR
		les	di, EXTERRPT
		mov	bx, EXTERR_ACT_CLASS
		mov	ch, EXTERR_LOCUS
		call	Get_User_Stack
		mov	[si+0Ah], di
		mov	word ptr [si+10h], es
		mov	[si+2],	bx
		mov	[si+4],	cx

jmp_SYS_RET_OK:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------
		push	si
		mov	si, offset COUNTRY_CDPG
		mov	ax, ss:[si+6Ah]
		pop	si
		retn
; ---------------------------------------------------------------------------

$ECS_Call:				; ...
		or	al, al
		jnz	short _okok
		call	Get_User_Stack
		mov	word ptr [si+8], offset	DBCS_TAB_2
		push	es
		mov	es, cs:DosDSeg
		mov	word ptr [si+14], es
		pop	es

_okok:					; ...
		jmp	short jmp_SYS_RET_OK
; ---------------------------------------------------------------------------

$PARSE_FILE_DESCRIPTOR:			; ...
		call	MAKEFCB
		push	si
		call	Get_User_Stack
		pop	word ptr [si+8]
		retn
; ---------------------------------------------------------------------------

$SLEAZEFUNC:				; ...
		mov	dl, 0

$SLEAZEFUNCDL:				; ...
		push	ss
		pop	ds
		mov	al, dl
		call	GETTHISDRV

SET_AL_RET:				; ...
		jb	short BADSLDRIVE
		call	DISK_INFO
		jb	short SET_AL_RET
		mov	byte ptr FATBYTE, ah
		mov	di, offset FATBYTE
		xor	ah, ah
		call	Get_User_Stack
		mov	[si+4],	cx
		mov	[si+6],	bx
		mov	[si+2],	di
		mov	word ptr [si+0Eh], ss
		retn
; ---------------------------------------------------------------------------

BADSLDRIVE:				; ...
		jmp	FCB_RET_ERR
; ---------------------------------------------------------------------------

$GET_INDOS_FLAG:			; ...
		call	Get_User_Stack
		mov	word ptr [si+2], offset	INDOS
		mov	word ptr [si+10h], ss
		retn
; ---------------------------------------------------------------------------

$GET_IN_VARS:				; ...
		call	Get_User_Stack
		mov	word ptr [si+2], offset	DPBHEAD
		mov	word ptr [si+10h], ss
		retn
; ---------------------------------------------------------------------------

$GET_DEFAULT_DPB:			; ...
		mov	dl, 0

$GET_DPB:				; ...
		push	ss
		pop	ds
		mov	al, dl
		call	GETTHISDRV
		jb	short ISNODRV
		les	di, THISCDS
		test	byte ptr es:[di+44h], 80h
		jnz	short ISNODRV
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk
		jb	short ISNODRV
		call	Get_User_Stack
		mov	[si+2],	bp
		mov	word ptr [si+0Eh], es
		xor	al, al
		retn
; ---------------------------------------------------------------------------

ISNODRV:				; ...
		mov	al, 0FFh
		retn
; ---------------------------------------------------------------------------

$DISK_RESET:				; ...
		mov	al, 0FFh
		push	ss
		pop	ds
		call	ECritDisk
		or	DOS34_FLAG, 4
		call	FLUSHBUF
		and	DOS34_FLAG, 0FFFBh
		mov	SC_STATUS, 0
		mov	bx, 0FFFFh
		mov	word ptr LastBuffer+2, bx
		mov	word ptr LastBuffer, bx
		call	LCritDisk
		mov	ax, 0FFFFh
		push	ax
		mov	ax, 1120h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
					; DS = DOS CS
					; Return: CF clear (successful)
		pop	ax
		retn
; ---------------------------------------------------------------------------
word3		dw 3			; ...

; =============== S U B	R O U T	I N E =======================================


$SETDPB		proc near		; ...
		mov	di, bp
		add	di, 2
		lodsw
		stosw
		cmp	byte ptr [si+3], 0
		jnz	short yesfat
		mov	byte ptr es:[di+4], 0
		jmp	short setend
; ---------------------------------------------------------------------------

yesfat:					; ...
		mov	dx, ax
		lodsb
		dec	al
		stosb
		inc	al
		xor	ah, ah

LOG2LOOP:				; ...
		test	al, 1
		jnz	short SAVLOG
		inc	ah
		shr	al, 1
		jmp	short LOG2LOOP
; ---------------------------------------------------------------------------

SAVLOG:					; ...
		mov	al, ah
		stosb
		mov	bl, al
		movsw
		lodsb
		stosb
		mov	bh, al
		lodsw
		stosw
		mov	cl, 5
		shr	dx, cl
		dec	ax
		add	ax, dx
		mov	cx, dx
		xor	dx, dx
		div	cx
		mov	cx, ax
		inc	di
		inc	di
		movsw
		lodsb
		mov	es:[bp+17h], al
		lodsw
		stosw
		mov	dl, bh
		xor	dh, dh
		mul	dx
		add	ax, es:[bp+6]
		stosw
		add	ax, cx
		mov	es:[bp+0Bh], ax
		mov	cl, bl
		cmp	word ptr es:[bp+0Dh], 0
		jnz	short normal_dpb
		xor	ch, ch
		mov	bx, [si+8]
		mov	dx, [si+0Ah]
		sub	bx, ax
		sbb	dx, 0
		or	cx, cx
		jz	short norot

rott:					; ...
		clc
		rcr	dx, 1
		rcr	bx, 1
		loop	rott

norot:					; ...
		mov	ax, bx
		jmp	short setend
; ---------------------------------------------------------------------------

normal_dpb:				; ...
		sub	ax, es:[bp+0Dh]
		neg	ax
		shr	ax, cl

setend:					; ...
		inc	ax
		mov	bx, ax
		mov	ax, es:[bp+0Fh]
		mul	word ptr es:[bp+2]
		cmp	bx, 0FF6h
		jb	short setend_fat12
		shr	dx, 1
		jnz	short setend_faterr
		rcr	ax, 1
		cmp	ax, 0FF7h
		jb	short setend_faterr
		jmp	short setend_fat16
; ---------------------------------------------------------------------------

setend_fat12:				; ...
		add	ax, ax
		adc	dx, dx
		cmp	dx, 3
		jnb	short setend_faterr
		div	cs:word3

setend_fat16:				; ...
		dec	ax
		cmp	ax, bx
		jbe	short setend_fat

setend_faterr:				; ...
		mov	ax, bx

setend_fat:				; ...
		mov	es:[bp+0Dh], ax
		mov	word ptr es:[bp+1Dh], 0
		mov	word ptr es:[bp+1Fh], 0FFFFh
		retn
$SETDPB		endp


; =============== S U B	R O U T	I N E =======================================


$DUP_PDB	proc near		; ...
		mov	ds, cs:DosDSeg
		mov	CreatePDB, 0FFh
		mov	ds, CurrentPDB
		push	si
		jmp	short CreateCopy
$DUP_PDB	endp


; =============== S U B	R O U T	I N E =======================================


$CREATE_PROCESS_DATA_BLOCK proc	near	; ...
		call	Get_User_Stack
		mov	ds, word ptr [si+14h]
		push	word ptr byte_0+2

CreateCopy:				; ...
		mov	es, dx
		xor	si, si
		mov	di, si
		mov	cx, 128
		rep movsw
		mov	cx, 20
		mov	di, 18h
		push	ds
		lds	si, BCON+2
		rep movsb
		pop	ds
		mov	ds, cs:DosDSeg
		cmp	CreatePDB, 0
		jz	short Create_PDB_cont
		mov	ds, cs:DosDSeg
		xor	bx, bx
		mov	cx, 20

Create_dup_jfn:				; ...
		push	es
		call	SFFromHandle
		mov	al, 0FFh
		jb	short CreateStash
		test	byte ptr es:[di+6], 10h
		jnz	short CreateStash
		mov	ah, es:[di+2]
		and	ah, 0F0h
		cmp	ah, 70h
		jz	short CreateStash
		mov	word ptr THISSFT, di
		mov	word ptr THISSFT+2, es
		call	DOS_DUP
		call	pJFNFromHandle
		mov	al, es:[di]

CreateStash:				; ...
		pop	es
		mov	es:[bx+18h], al
		inc	bx
		loop	Create_dup_jfn
		mov	bx, CurrentPDB
		mov	word ptr es:OEM_HANDLER+2, bx
		mov	CurrentPDB, es
		mov	ds, bx

Create_PDB_cont:			; ...
		push	ds
		mov	ds, cs:DosDSeg
		mov	CreatePDB, 0
		pop	ds
		pop	ax

SETMEM:					; ...
		xor	cx, cx
		mov	ds, cx
		mov	es, dx
		mov	si, 88h
		mov	di, 10
		mov	cx, 6
		rep movsw
		mov	word ptr es:byte_0+2, ax
		sub	ax, dx
		cmp	ax, 0FFFh
		jbe	short HAVDIF
		mov	ax, 0FFFh

HAVDIF:					; ...
		sub	ax, 10h
		mov	bx, 0Ch
		sub	bx, ax
		mov	cl, 4
		shl	ax, cl
		mov	ds, dx
		mov	word ptr WinoldPatch1, ax
		mov	word ptr WinoldPatch1+2, bx
		cmp	ax, 0FEF0h
		jz	short addr_ok
		mov	word ptr WinoldPatch1, 0C0h ; ''
		mov	word ptr WinoldPatch1+2, 0

addr_ok:				; ...
		mov	word ptr 0, 20CDh
		mov	byte ptr DataVersion+1,	9Ah ; ''
		mov	off_50,	21CDh
		mov	byte ptr asc_52, 0CBh ;	'' ; "NUL     "
		mov	word ptr BCON+2, 18h
		mov	MAXSEC,	ds
		mov	word ptr BCON, 20
		mov	word ptr BUFFHEAD, 0FFFFh
		mov	word ptr BUFFHEAD+2, 0FFFFh
		mov	word ptr es:SFTFCB, 1406h
		retn
$CREATE_PROCESS_DATA_BLOCK endp

; ---------------------------------------------------------------------------

$GSetMediaID:				; ...
		mov	cx, 866h
		cmp	al, 0
		jz	short doioctl
		cmp	al, 1
		jnz	short errorfunc
		mov	cx, 846h

doioctl:				; ...
		mov	al, 0Dh
		call	$IOCTL
		retn
; ---------------------------------------------------------------------------

errorfunc:				; ...
		mov	al, 1
		jmp	SYS_RET_ERR

; =============== S U B	R O U T	I N E =======================================


StrCmp		proc near		; ...
		push	si
		push	di
		push	ax

Cmplp:					; ...
		lodsb
		call	UCase
		call	PATHCHRCMP
		mov	ah, al
		mov	al, es:[di]
		inc	di
		call	UCase
		call	PATHCHRCMP
		cmp	ah, al
		jnz	short PopRet
		or	al, al
		jnz	short Cmplp

PopRet:					; ...
		pop	ax
		pop	di
		pop	si
		retn
StrCmp		endp


; =============== S U B	R O U T	I N E =======================================


StrCpy		proc near		; ...
		push	ax

CPYLoop:				; ...
		lodsb
		call	UCase
		call	PATHCHRCMP
		stosb
		or	al, al
		jnz	short CPYLoop
		pop	ax
		retn
StrCpy		endp


; =============== S U B	R O U T	I N E =======================================


FStrCpy		proc near		; ...
		push	ax

FCPYLoop:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short FCPYLoop
		pop	ax
		retn
FStrCpy		endp


; =============== S U B	R O U T	I N E =======================================


StrLen		proc near		; ...
		push	di
		push	ax
		mov	cx, 0FFFFh
		xor	al, al
		repne scasb
		not	cx
		pop	ax
		pop	di
		retn
StrLen		endp


; =============== S U B	R O U T	I N E =======================================


DStrLen		proc near		; ...
		call	XCHGP
		call	StrLen
		call	XCHGP
		retn
DStrLen		endp


; =============== S U B	R O U T	I N E =======================================


XCHGP		proc near		; ...
		push	ds
		push	es
		pop	ds
		pop	es
		xchg	si, di

xchgp_retn:				; ...
		retn
XCHGP		endp


; =============== S U B	R O U T	I N E =======================================


Idle		proc near		; ...
		cmp	ss:FSHARING, 0
		jnz	short xchgp_retn
		push	cx
		mov	cx, ss:RetryLoop
		jcxz	short Idle3

Idle1:					; ...
		push	cx
		xor	cx, cx

Idle2:					; ...
		loop	Idle2
		pop	cx
		loop	Idle1

Idle3:					; ...
		pop	cx
		retn
Idle		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

TableDispatch	proc near		; ...

arg_0		= byte ptr  4
arg_2		= word ptr  6

		push	bp
		mov	bp, sp
		push	bx
		mov	bx, [bp+arg_2]
		mov	bl, cs:[bx]
		cmp	[bp+arg_0], bl
		jnb	short TableError
		mov	bl, [bp+arg_0]
		xor	bh, bh
		shl	bx, 1
		inc	bx
		add	bx, [bp+arg_2]
		mov	bx, cs:[bx]
		mov	[bp+arg_2], bx
		pop	bx
		pop	bp
		add	sp, 4
		retn
; ---------------------------------------------------------------------------

TableError:				; ...
		pop	bx
		pop	bp
		retn	6
TableDispatch	endp


; =============== S U B	R O U T	I N E =======================================


TestNet		proc near		; ...
		mov	es, cs:DosDSeg
		les	di, es:THISCDS
		cmp	di, 0FFFFh
		jz	short CMCRet
		test	byte ptr es:[di+44h], 80h
		jnz	short CMCRet
		retn
; ---------------------------------------------------------------------------

CMCRet:					; ...
		cmc
		retn
TestNet		endp


; =============== S U B	R O U T	I N E =======================================


IsSFTNet	proc near		; ...
		test	byte ptr es:[di+6], 80h
		retn
IsSFTNet	endp

; ---------------------------------------------------------------------------

FastInit:				; ...
		push	es
		mov	es, cs:DosDSeg
		mov	di, offset FastTable_2
		dec	bx
		mov	dx, bx
		shl	bx, 1
		shl	bx, 1
		add	di, bx
		mov	ax, es:[di+2]
		mov	cx, cs
		cmp	ax, cx
		jz	short ok_install
		or	ax, ax
		jz	short ok_install
		stc
		jmp	short FSret
; ---------------------------------------------------------------------------

ok_install:				; ...
		cmp	si, 0FFFFh
		jz	short FSret
		mov	cx, ds
		mov	es:[di+2], cx
		mov	es:[di], si
		mov	di, offset FastOpenFlg
		add	di, dx
		or	byte ptr es:[di], 80h

FSret:					; ...
		pop	es
		retn
; ---------------------------------------------------------------------------

FastRet:				; ...
		stc
		sbb	ax, ax
		retf
; ---------------------------------------------------------------------------

NLS_OPEN:				; ...
		mov	al, cl
		call	$OPEN
		retn
; ---------------------------------------------------------------------------

NLS_LSEEK:				; ...
		push	ss:USER_SP
		push	ss:USER_SS
		call	Fake_User_Stack
		mov	ax, bp
		call	$LSEEK
		pop	ss:USER_SS
		pop	ss:USER_SP
		retn

; =============== S U B	R O U T	I N E =======================================


Fake_User_Stack	proc near		; ...
		mov	ax, ss:USER_SP_2F
		mov	ss:USER_SP, ax
		mov	ax, ss
		mov	ss:USER_SS, ax
		retn
Fake_User_Stack	endp

; ---------------------------------------------------------------------------

GetDevList:				; ...
		mov	si, offset SysInitTable
		mov	ds, cs:DosDSeg
		lds	si, [si]
		mov	ax, [si+22h]
		mov	bx, [si+24h]
		retn
; ---------------------------------------------------------------------------

NLS_IOCTL:				; ...
		push	ss:USER_SP
		push	ss:USER_SS
		call	Fake_User_Stack
		mov	ax, bp
		call	$IOCTL
		pop	ss:USER_SS
		pop	ss:USER_SP
		retn
; ---------------------------------------------------------------------------

NLS_GETEXT:				; ...
		mov	ax, ss:EXTERR
		retn
; ---------------------------------------------------------------------------

MSG_RETRIEVAL:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


ECritDisk	proc near		; ...

; FUNCTION CHUNK AT 5146 SIZE 0000000E BYTES
; FUNCTION CHUNK AT 5155 SIZE 00000005 BYTES

		pushf
		cmp	ss:redir_patch,	0
		jz	short ECritDisk_2
		jmp	short ECritDisk_1
ECritDisk	endp

; ---------------------------------------------------------------------------

ECritDisk_iret:				; ...
		iret
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ECritDisk

ECritDisk_1:				; ...
		push	cs
		call	ECritDisk_iret

ECritDisk_0:
		push	ax
		mov	ax, 8001h
		int	2Ah		; Microsoft Networks - BEGIN DOS CRITICAL SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

ECritDisk_2:				; ...
		jmp	short ECritDisk_3
; END OF FUNCTION CHUNK	FOR ECritDisk
; ---------------------------------------------------------------------------

ECritDisk_iret2:			; ...
		iret
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ECritDisk

ECritDisk_3:				; ...
		push	cs
		call	ECritDisk_iret2
		retn
; END OF FUNCTION CHUNK	FOR ECritDisk

; =============== S U B	R O U T	I N E =======================================


LCritDisk	proc near		; ...

; FUNCTION CHUNK AT 5166 SIZE 0000000E BYTES
; FUNCTION CHUNK AT 5175 SIZE 00000005 BYTES

		pushf
		cmp	ss:redir_patch,	0
		jz	short LCritDisk_2
		jmp	short LCritDisk_1
LCritDisk	endp

; ---------------------------------------------------------------------------

LCritDisk_iret:				; ...
		iret
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR LCritDisk

LCritDisk_1:				; ...
		push	cs
		call	LCritDisk_iret
		push	ax
		mov	ax, 8101h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

LCritDisk_2:				; ...
		jmp	short LCritDisk_3
; END OF FUNCTION CHUNK	FOR LCritDisk
; ---------------------------------------------------------------------------

LCritDisk_iret2:			; ...
		iret
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR LCritDisk

LCritDisk_3:				; ...
		push	cs
		call	LCritDisk_iret2
		retn
; END OF FUNCTION CHUNK	FOR LCritDisk

; =============== S U B	R O U T	I N E =======================================


ECritDevice	proc near		; ...

; FUNCTION CHUNK AT 5186 SIZE 0000000E BYTES
; FUNCTION CHUNK AT 5195 SIZE 00000005 BYTES

		pushf
		cmp	ss:redir_patch,	0
		jz	short ECritDevice_2
		jmp	short ECritDevice_1
ECritDevice	endp

; ---------------------------------------------------------------------------

ECritDevice_iret:			; ...
		iret
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ECritDevice

ECritDevice_1:				; ...
		push	cs
		call	ECritDevice_iret
		push	ax
		mov	ax, 8002h
		int	2Ah		; Microsoft Networks - BEGIN DOS CRITICAL SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

ECritDevice_2:				; ...
		jmp	short ECritDevice_3
; END OF FUNCTION CHUNK	FOR ECritDevice
; ---------------------------------------------------------------------------

ECritDevice_iret2:			; ...
		iret
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ECritDevice

ECritDevice_3:				; ...
		push	cs
		call	ECritDevice_iret2
		retn
; END OF FUNCTION CHUNK	FOR ECritDevice

; =============== S U B	R O U T	I N E =======================================


LCritDevice	proc near		; ...

; FUNCTION CHUNK AT 51A6 SIZE 0000000E BYTES
; FUNCTION CHUNK AT 51B5 SIZE 00000005 BYTES

		pushf
		cmp	ss:redir_patch,	0
		jz	short LCritDevice_2
		jmp	short LCritDevice_1
LCritDevice	endp

; ---------------------------------------------------------------------------

LCritDevice_iret:			; ...
		iret
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR LCritDevice

LCritDevice_1:				; ...
		push	cs
		call	LCritDevice_iret
		push	ax
		mov	ax, 8102h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

LCritDevice_2:				; ...
		jmp	short LCritDevice_3
; END OF FUNCTION CHUNK	FOR LCritDevice
; ---------------------------------------------------------------------------

LCritDevice_iret2:			; ...
		iret
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR LCritDevice

LCritDevice_3:				; ...
		push	cs
		call	LCritDevice_iret2
		retn
; END OF FUNCTION CHUNK	FOR LCritDevice

; =============== S U B	R O U T	I N E =======================================


$STD_CON_INPUT_NO_ECHO proc near	; ...
		push	ds
		push	si

INTEST:					; ...
		call	near ptr STATCHK
		jnz	short GET
		cmp	ss:PRINTER_FLAG, 0
		jnz	short no_sys_wait
		mov	ah, 5
		call	IOFUNC

no_sys_wait:				; ...
		mov	ah, 84h
		int	2Ah		; Microsoft Networks - KEYBOARD	BUSY LOOP
		cmp	byte ptr ss:DATE_FLAG, 0FFh
		jnz	short NoUpdate
		push	ax
		push	bx
		push	cx
		push	dx
		push	ds
		push	ss
		pop	ds
		mov	ax, 0
		call	Save_Restore_Packet
		call	READTIME
		mov	ax, 1
		call	Save_Restore_Packet
		pop	ds
		pop	dx
		pop	cx
		pop	bx
		pop	ax

NoUpdate:				; ...
		inc	ss:DATE_FLAG
		jmp	short INTEST
; ---------------------------------------------------------------------------

GET:					; ...
		xor	ah, ah
		call	IOFUNC
		pop	si
		pop	ds
		mov	ss:SCAN_FLAG, 0
		cmp	al, 0
		jnz	short noscan
		mov	ss:SCAN_FLAG, 1

noscan:					; ...
		retn
$STD_CON_INPUT_NO_ECHO endp

; ---------------------------------------------------------------------------

$STD_CON_STRING_OUTPUT:			; ...
		mov	si, dx

STRING_OUT1:				; ...
		lodsb
		cmp	al, '$'
		jz	short noscan
		call	OUTT
		jmp	short STRING_OUT1

; =============== S U B	R O U T	I N E =======================================


$STD_CON_STRING_INPUT proc near		; ...

; FUNCTION CHUNK AT 4820 SIZE 00000019 BYTES
; FUNCTION CHUNK AT 52C5 SIZE 00000005 BYTES
; FUNCTION CHUNK AT 52F3 SIZE 00000019 BYTES
; FUNCTION CHUNK AT 537D SIZE 00000044 BYTES
; FUNCTION CHUNK AT 53F1 SIZE 00000021 BYTES

		mov	ax, ss
		mov	es, ax
		mov	si, dx
		xor	ch, ch
		lodsw
		or	al, al
		jz	short noscan
		mov	bl, ah
		mov	bh, ch
		cmp	al, bl
		jbe	short NOEDIT
		cmp	byte ptr [bx+si], 0Dh
		jz	short EDITON

NOEDIT:					; ...
		mov	bl, ch

EDITON:					; ...
		mov	dl, al
		dec	dx

NEWLIN:					; ...
		mov	al, ss:CARPOS
		mov	ss:STARTPOS, al
		push	si
		mov	di, offset INBUF
		mov	ss:INSMODE, ch
		mov	bh, ch
		mov	dh, ch
		call	$STD_CON_INPUT_NO_ECHO
		cmp	al, 0Ah
		jnz	short GOTCH

GETCH:					; ...
		call	$STD_CON_INPUT_NO_ECHO

GOTCH:					; ...
		cmp	al, 6
		jz	short GETCH
		cmp	al, cs:ESCCHAR
		jz	short ESCAPE
		cmp	al, 7Fh	; ''
		jz	short BACKSPJ
		cmp	al, 8
		jz	short BACKSPJ
		cmp	al, 17h
		nop
		nop
		cmp	al, 15h
		nop
		nop
		cmp	al, 0Dh
		jz	short ENDLIN
		cmp	al, 0Ah
		jz	short PHYCRLF
		cmp	al, cs:CANCHAR
		jz	short KILNEW

SAVCH:					; ...
		cmp	dh, dl
		jnb	short BUFFUL
		stosb
		inc	dh
		call	BUFOUT
		cmp	ss:INSMODE, 0
		jnz	short GETCH
		cmp	bh, bl
		jnb	short GETCH
		inc	si
		inc	bh
		jmp	short GETCH
; ---------------------------------------------------------------------------

BACKSPJ:				; ...
		jmp	short BACKSP
; ---------------------------------------------------------------------------

BUFFUL:					; ...
		mov	al, 7
		call	OUTT
		jmp	short GETCH
; ---------------------------------------------------------------------------

ESCAPE:					; ...
		jmp	OEMFunctionKey
; ---------------------------------------------------------------------------

ENDLIN:					; ...
		stosb
		call	OUTT
		pop	di
		mov	[di-1],	dh
		inc	dh
$STD_CON_STRING_INPUT endp


; =============== S U B	R O U T	I N E =======================================


COPYNEW		proc near		; ...
		push	ds
		push	es
		pop	ds
		pop	es
		mov	si, offset INBUF
		mov	cl, dh
		rep movsb

OLDBAK_RETN:				; ...
		retn
COPYNEW		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $STD_CON_STRING_INPUT

PHYCRLF:				; ...
		call	CRLF
		jmp	short GETCH
; END OF FUNCTION CHUNK	FOR $STD_CON_STRING_INPUT
; ---------------------------------------------------------------------------

LineDel:				; ...
		or	dh, dh
		jz	short GETCH
		call	BackSpace
		jmp	short LineDel
; ---------------------------------------------------------------------------

WordDel:				; ...
		call	BackSpace
		or	dh, dh
		jz	short getchj
		mov	al, es:[di-1]
		cmp	al, '0'
		jb	short getchj
		cmp	al, '9'
		jbe	short WordDel
		or	al, 20h
		cmp	al, 'a'
		jb	short getchj
		cmp	al, 'z'
		jbe	short WordDel

getchj:					; ...
		jmp	GETCH
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $STD_CON_STRING_INPUT

KILNEW:					; ...
		mov	al, '\'
		call	OUTT
		pop	si

PUTNEW:					; ...
		call	CRLF
		mov	al, ss:STARTPOS
		call	TAB
		jmp	NEWLIN
; ---------------------------------------------------------------------------

BACKSP:					; ...
		call	BackSpace
		jmp	GETCH
; END OF FUNCTION CHUNK	FOR $STD_CON_STRING_INPUT

; =============== S U B	R O U T	I N E =======================================


BackSpace	proc near		; ...
		or	dh, dh
		jz	short OLDBAK
		call	BACKUP
		mov	al, es:[di]
		cmp	al, 20h	; ' '
		jnb	short OLDBAK
		cmp	al, 9
		jz	short BAKTAB
		cmp	al, 15h
		jz	short OLDBAK
		cmp	al, 14h
		jz	short OLDBAK
		call	BACKMES

OLDBAK:					; ...
		cmp	ss:INSMODE, 0
		jnz	short OLDBAK_RETN
		or	bh, bh
		jz	short OLDBAK_RETN
		dec	bh
		dec	si
		retn
; ---------------------------------------------------------------------------

BAKTAB:					; ...
		push	di
		dec	di
		std
		mov	cl, dh
		mov	al, 20h	; ' '
		push	bx
		mov	bl, 7
		jcxz	short FIGTAB

FNDPOS:					; ...
		scasb
		jbe	short CHKCNT
		cmp	byte ptr es:[di+1], 9
		jz	short HAVTAB
		dec	bl

CHKCNT:					; ...
		loop	FNDPOS

FIGTAB:					; ...
		sub	bl, ss:STARTPOS

HAVTAB:					; ...
		sub	bl, dh
		add	cl, bl
		and	cl, 7
		cld
		pop	bx
		pop	di
		jz	short OLDBAK

TABBAK:					; ...
		call	BACKMES
		loop	TABBAK
		jmp	short OLDBAK
BackSpace	endp


; =============== S U B	R O U T	I N E =======================================


BACKUP		proc near		; ...
		dec	dh
		dec	di
BACKUP		endp


; =============== S U B	R O U T	I N E =======================================


BACKMES		proc near		; ...
		mov	al, 8
		call	OUTT
		mov	al, 20h	; ' '
		call	OUTT
		mov	al, 8
		jmp	OUTT
BACKMES		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $STD_CON_STRING_INPUT

TWOESC:					; ...
		mov	al, cs:ESCCHAR
		jmp	SAVCH
; ---------------------------------------------------------------------------

COPYLIN:				; ...
		mov	cl, bl
		sub	cl, bh
		jmp	short COPYEACH
; ---------------------------------------------------------------------------

COPYSTR:				; ...
		call	FINDOLD
		jmp	short COPYEACH
; ---------------------------------------------------------------------------

COPYONE:				; ...
		mov	cl, 1

COPYEACH:				; ...
		mov	ss:INSMODE, 0
		cmp	dh, dl
		jz	short GETCH2
		cmp	bh, bl
		jz	short GETCH2
		lodsb
		stosb
		call	BUFOUT
		inc	bh
		inc	dh
		loop	COPYEACH

GETCH2:					; ...
		jmp	GETCH
; ---------------------------------------------------------------------------

SKIPONE:				; ...
		cmp	bh, bl
		jz	short GETCH2
		inc	bh
		inc	si
		jmp	GETCH
; ---------------------------------------------------------------------------

SKIPSTR:				; ...
		call	FINDOLD
		add	si, cx
		add	bh, cl
		jmp	GETCH
; END OF FUNCTION CHUNK	FOR $STD_CON_STRING_INPUT
; ---------------------------------------------------------------------------

FINDOLD:				; ...
		call	$STD_CON_INPUT_NO_ECHO
		cmp	al, cs:ESCCHAR
		jnz	short FINDSETUP
		call	$STD_CON_INPUT_NO_ECHO
		jmp	short NOTFND
; ---------------------------------------------------------------------------

FINDSETUP:				; ...
		mov	cl, bl
		sub	cl, bh
		jz	short NOTFND
		dec	cx
		jz	short NOTFND
		push	es
		push	ds
		pop	es
		push	di
		mov	di, si
		inc	di
		repne scasb
		pop	di
		pop	es
		jnz	short NOTFND
		not	cl
		add	cl, bl
		sub	cl, bh

FINDOLD_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

NOTFND:					; ...
		pop	bp
		jmp	GETCH
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $STD_CON_STRING_INPUT

REEDIT:					; ...
		mov	al, '@'
		call	OUTT
		pop	di
		push	di
		push	es
		push	ds
		call	COPYNEW
		pop	ds
		pop	es
		pop	si
		mov	bl, dh
		jmp	PUTNEW
; ---------------------------------------------------------------------------

EXITINS_ENTERINS:			; ...
		not	ss:INSMODE
		jmp	GETCH
; ---------------------------------------------------------------------------

CTRLZ:					; ...
		mov	al, 1Ah
		jmp	SAVCH
; END OF FUNCTION CHUNK	FOR $STD_CON_STRING_INPUT

; =============== S U B	R O U T	I N E =======================================


CRLF		proc near		; ...
		mov	al, 0Dh
		call	OUTT
		mov	al, 0Ah
		jmp	OUTT
CRLF		endp

; ---------------------------------------------------------------------------

$RAW_CON_IO:				; ...
		mov	al, dl
		cmp	al, 0FFh
		jz	short rcio1
		jmp	short RAWOUT
; ---------------------------------------------------------------------------
		nop

rcio1:					; ...
		les	di, dword ptr ss:USER_SP
		xor	bx, bx
		call	GET_IO_SFT
		jb	short FINDOLD_RETN
		mov	ah, 1
		call	IOFUNC
		jnz	short RESFLG
		call	SPOOLINT
		or	byte ptr es:[di+16h], 40h
		xor	al, al

RET17:					; ...
		retn
; ---------------------------------------------------------------------------

RESFLG:					; ...
		and	byte ptr es:[di+16h], 0BFh

rci0:					; ...
		call	SPOOLINT

$RAW_CON_INPUT:				; ...
		push	bx
		xor	bx, bx
		call	GET_IO_SFT
		pop	bx
		jb	short RET17
		mov	ah, 1
		call	IOFUNC
		jnz	short rci5
		mov	ah, 84h	; ''
		int	2Ah		; Microsoft Networks - KEYBOARD	BUSY LOOP
		jmp	short rci0
; ---------------------------------------------------------------------------

rci5:					; ...
		xor	ah, ah
		call	IOFUNC
		retn

; =============== S U B	R O U T	I N E =======================================


RAWOUT		proc near		; ...
		push	bx
		mov	bx, 1
		call	GET_IO_SFT
		jb	short RAWRET1
		mov	bx, [si+5]
		and	bx, 8080h
		cmp	bx, 80h	; ''
		jnz	short RAWNORM
		push	ds
		lds	bx, [si+7]
		test	byte ptr [bx+4], 10h
		pop	ds
		jz	short RAWNORM
		int	29h		; DOS 2+ internal - FAST PUTCHAR
					; AL = character to display

RAWRET:					; ...
		clc

RAWRET1:				; ...
		pop	bx

RAWRET2:				; ...
		retn
; ---------------------------------------------------------------------------

RAWNORM:				; ...
		call	RAWOUT3
		jmp	short RAWRET
RAWOUT		endp


; =============== S U B	R O U T	I N E =======================================


RAWOUT2		proc near		; ...
		call	GET_IO_SFT
		jb	short RAWRET2
RAWOUT2		endp


; =============== S U B	R O U T	I N E =======================================


RAWOUT3		proc near		; ...
		push	ax
		jmp	short RAWOSTRT
; ---------------------------------------------------------------------------

ROLP:					; ...
		call	SPOOLINT
		or	ss:DOS34_FLAG, 200h
		call	DSKSTATCHK

RAWOSTRT:				; ...
		mov	ah, 3
		call	IOFUNC
		jz	short ROLP
		inc	ax
		pop	ax
		jz	short nosend
		mov	ah, 2
		call	IOFUNC

nosend:					; ...
		clc
		retn
RAWOUT3		endp


; =============== S U B	R O U T	I N E =======================================


Save_Restore_Packet proc near		; ...
		push	ds
		push	es
		push	si
		push	di
		cmp	ax, 0
		jz	short save_packet

restore_packet:
		mov	si, offset FAKE_STACK_2F
		mov	di, offset DEVCALL
		jmp	short set_seg
; ---------------------------------------------------------------------------

save_packet:				; ...
		mov	di, offset FAKE_STACK_2F
		mov	si, offset DEVCALL

set_seg:				; ...
		mov	ax, ss
		mov	ds, ax
		mov	es, ax
		mov	cx, 11
		rep movsw
		pop	di
		pop	si
		pop	es
		pop	ds
		retn
Save_Restore_Packet endp

; ---------------------------------------------------------------------------

$STD_CON_INPUT:				; ...
		call	$STD_CON_INPUT_NO_ECHO
		push	ax
		call	OUTT
		pop	ax

CON_INPUT_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

$STD_CON_OUTPUT:			; ...
		mov	al, dl

; =============== S U B	R O U T	I N E =======================================


OUTT		proc near		; ...

; FUNCTION CHUNK AT 556F SIZE 00000008 BYTES
; FUNCTION CHUNK AT 557A SIZE 00000008 BYTES
; FUNCTION CHUNK AT 55CF SIZE 00000007 BYTES

		cmp	al, 20h
		jb	short CTRLOUT
		cmp	al, 7Fh
		jz	short OUTCH
		inc	ss:CARPOS

OUTCH:					; ...
		push	ds
		push	si
		inc	ss:CHARCO
		and	ss:CHARCO, 3Fh
		jnz	short OUTSKIP
		push	ax
		call	near ptr STATCHK
		pop	ax

OUTSKIP:				; ...
		call	RAWOUT
		pop	si
		pop	ds
		test	ss:PFLAG, 0FFh
		jz	short CON_INPUT_RETN
		push	bx
		push	ds
		push	si
		mov	bx, 1
		call	GET_IO_SFT
		jb	short TRIPOPJ
		mov	bx, [si+5]
		test	bh, 80h
		jnz	short TRIPOPJ
		test	bl, 80h
		jz	short TRIPOPJ
		mov	bx, 4
		call	GET_IO_SFT
		jb	short TRIPOPJ
		test	byte ptr [si+6], 8
		jz	short LISSTRT2J
		mov	ss:PFLAG, 0

TRIPOPJ:				; ...
		jmp	TRIPOP
; ---------------------------------------------------------------------------

LISSTRT2J:				; ...
		jmp	LISSTRT2
; ---------------------------------------------------------------------------

CTRLOUT:				; ...
		cmp	al, 0Dh
		jz	short ZERPOS
		cmp	al, 8
		jz	short BACKPOS
		cmp	al, 9
		jnz	short OUTCH
		mov	al, ss:CARPOS
		or	al, 0F8h
		neg	al
OUTT		endp


; =============== S U B	R O U T	I N E =======================================


TAB		proc near		; ...
		push	cx
		mov	cl, al
		mov	ch, 0
		jcxz	short POPTAB

TABLP:					; ...
		mov	al, ' '
		call	OUTT
		loop	TABLP

POPTAB:					; ...
		pop	cx
		retn
TAB		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR OUTT

ZERPOS:					; ...
		mov	ss:CARPOS, 0
		jmp	short OUTCH
; END OF FUNCTION CHUNK	FOR OUTT
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR BUFOUT

OUTJ:					; ...
		jmp	OUTT
; END OF FUNCTION CHUNK	FOR BUFOUT
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR OUTT

BACKPOS:				; ...
		dec	ss:CARPOS
		jmp	OUTCH
; END OF FUNCTION CHUNK	FOR OUTT

; =============== S U B	R O U T	I N E =======================================


BUFOUT		proc near		; ...

; FUNCTION CHUNK AT 5577 SIZE 00000003 BYTES

		cmp	al, ' '
		jnb	short OUTJ
		cmp	al, 9
		jz	short OUTJ
		cmp	al, 15h
		jz	short CTRLU
		cmp	al, 14h
		jz	short CTRLU

NOT_CTRLU:
		push	ax
		mov	al, '^'
		call	OUTT
		pop	ax
		or	al, 40h

CTRLU:					; ...
		call	OUTT

BUFOUT_RETN:				; ...
		retn
BUFOUT		endp

; ---------------------------------------------------------------------------

$STD_AUX_INPUT:				; ...
		call	near ptr STATCHK
		mov	bx, 3
		call	GET_IO_SFT
		jb	short BUFOUT_RETN
		jmp	short TAISTRT
; ---------------------------------------------------------------------------

AUXILP:					; ...
		call	SPOOLINT

TAISTRT:				; ...
		mov	ah, 1
		call	IOFUNC
		jz	short AUXILP
		xor	ah, ah
		call	IOFUNC
		retn
; ---------------------------------------------------------------------------

$STD_AUX_OUTPUT:			; ...
		push	bx
		mov	bx, 3
		jmp	short SENDOUT
; ---------------------------------------------------------------------------

$STD_PRINTER_OUTPUT:			; ...
		push	bx
		mov	bx, 4

SENDOUT:				; ...
		mov	al, dl
		push	ax
		call	near ptr STATCHK
		pop	ax
		push	ds
		push	si
; START	OF FUNCTION CHUNK FOR OUTT

LISSTRT2:				; ...
		call	RAWOUT2

TRIPOP:					; ...
		pop	si
		pop	ds
		pop	bx

SCIS_RETN:				; ...
		retn
; END OF FUNCTION CHUNK	FOR OUTT
; ---------------------------------------------------------------------------

$STD_CON_INPUT_STATUS:			; ...
		call	near ptr STATCHK
		mov	al, 0
		jz	short SCIS_RETN
		or	al, 0FFh
		retn
; ---------------------------------------------------------------------------

$STD_CON_INPUT_FLUSH:			; ...
		push	ax
		push	dx
		xor	bx, bx
		call	GET_IO_SFT
		jb	short BADJFNCON
		mov	ah, 4
		call	IOFUNC

BADJFNCON:				; ...
		pop	dx
		pop	ax
		mov	ah, al
		cmp	al, 1
		jz	short REDISPJ
		cmp	al, 6
		jz	short REDISPJ
		cmp	al, 7
		jz	short REDISPJ
		cmp	al, 8
		jz	short REDISPJ
		cmp	al, 0Ah
		jz	short REDISPJ
		mov	al, 0
		retn
; ---------------------------------------------------------------------------

REDISPJ:				; ...
		cli
		jmp	REDISP
; ---------------------------------------------------------------------------

$GET_FCB_POSITION:			; ...
		call	GetExtended
		call	GetExtent
		mov	[si+21h], ax
		mov	[si+23h], dl
		cmp	word ptr [si+0Eh], 64
		jnb	short GetFCBBye
		mov	[si+24h], dh

GetFCBBye:				; ...
		jmp	NO_OP
; ---------------------------------------------------------------------------

$FCB_DELETE:				; ...
		mov	di, offset OPENBUF
		call	TransFCB
		jb	short BadPath
		push	ss
		pop	ds
		call	DOS_DELETE
		jb	short BadPath

GoodPath:				; ...
		jmp	short GetFCBBye
; ---------------------------------------------------------------------------

BadPath:				; ...
		jmp	FCB_RET_ERR
; ---------------------------------------------------------------------------

$GET_FCB_FILE_LENGTH:			; ...
		call	GetExtended
		mov	di, offset OPENBUF
		push	ds
		push	si
		call	TransFCB
		pop	si
		pop	ds
		jb	short BadPath
		push	ds
		push	si
		push	ss
		pop	ds
		call	GET_FILE_INFO
		pop	si
		pop	ds
		jb	short BadPath
		mov	dx, bx
		mov	ax, di
		mov	bx, [si+0Eh]
		or	bx, bx
		jnz	short GetSize
		mov	bx, 128

GetSize:				; ...
		mov	di, ax
		mov	ax, dx
		xor	dx, dx
		div	bx
		push	ax
		mov	ax, di
		div	bx
		mov	cx, dx
		pop	dx
		jcxz	short LengthStore
		add	ax, 1
		adc	dx, 0

LengthStore:				; ...
		mov	[si+21h], ax
		mov	[si+23h], dl
		or	dh, dh
		jz	short GoodPath
		mov	[si+24h], dh

GoodRet:				; ...
		jmp	short GoodPath
; ---------------------------------------------------------------------------

$FCB_CLOSE:				; ...
		xor	al, al
		call	GetExtended
		jz	short NoAttr
		mov	al, [si-1]

NoAttr:					; ...
		mov	ss:ATTRIB, al
		call	SFTFromFCB
		jb	short GoodRet
		mov	al, es:[di+4]
		xor	ah, ah
		push	ax
		call	CheckShare
		jnz	short NoStash
		mov	al, ss:ATTRIB
		mov	es:[di+4], al

NoStash:				; ...
		mov	ax, [si+14h]
		mov	es:[di+0Fh], ax
		mov	ax, [si+16h]
		mov	es:[di+0Dh], ax
		mov	ax, [si+10h]
		mov	es:[di+11h], ax
		mov	ax, [si+12h]
		mov	es:[di+13h], ax
		or	word ptr es:[di+5], 4000h
		push	ss
		pop	ds
		call	DOS_CLOSE
		les	di, THISSFT
		pop	cx
		mov	es:[di+4], cl
		pushf
		cmp	word ptr es:[di], 0
		jnz	short CloseOK
		push	ax
		mov	al, 'M'
		call	BlastSFT
		pop	ax

CloseOK:				; ...
		popf
		jnb	short GoodRet
		cmp	al, 6
		jz	short GoodRet
		mov	al, 2

jmp_to_FCB_RET_ERR:			; ...
		jmp	FCB_RET_ERR
; ---------------------------------------------------------------------------

$FCB_RENAME:				; ...
		call	GetExtended
		push	dx
		mov	al, [si]
		add	si, 10h
		mov	di, offset RENBUF
		push	word ptr [si]
		push	ds
		push	si
		mov	[si], al
		mov	dx, si
		call	TransFCB
		pop	si
		pop	ds
		pop	word ptr [si]
		pop	dx
		jb	short fren90
		mov	si, ss:WFP_START
		mov	ss:REN_WFP, si
		mov	di, offset OPENBUF
		call	TransFCB
		jb	short fren90
		call	DOS_RENAME
		jb	short fren90
		jmp	NO_OP
; ---------------------------------------------------------------------------

fren90:					; ...
		jmp	short jmp_to_FCB_RET_ERR

; =============== S U B	R O U T	I N E =======================================


SaveFCBInfo	proc near		; ...
		les	di, ss:THISSFT
		call	IsSFTNet
		jz	short SaveLocal
		mov	ax, es:[di+0Bh]
		mov	[si+1Ch], ax
		mov	bl, 80h	; ''
		jmp	short SaveSFN
; ---------------------------------------------------------------------------

SaveLocal:				; ...
		call	CheckShare
		jz	short SaveNoShare
		jmp	short SaveShare
; ---------------------------------------------------------------------------

SaveNoShare:				; ...
		test	byte ptr es:[di+5], 80h
		jnz	short SaveNoShareDev
		mov	ax, es:[di+1Bh]
		mov	[si+1Dh], ax
		mov	ax, es:[di+1Dh]
		mov	bl, es:[di+4]
		mov	bh, bl
		ror	bl, 1
		shl	bh, 1
		or	bl, bh
		and	bl, 0C0h
		or	al, bl
		mov	[si+18h], al
		mov	al, es:[di+1Fh]
		mov	[si+1Fh], al
		mov	ax, es:[di+0Bh]
		mov	[si+1Bh], ax
		mov	bl, 0

SetFCBBits:				; ...
		mov	ax, es:[di+5]
		and	al, 0C0h
		or	al, es:[di+2]
		mov	[si+1Ah], al
		or	bl, bl
		jz	short SaveNoSFN
		jmp	short SaveSFN
; ---------------------------------------------------------------------------

SaveNoShareDev:				; ...
		mov	ax, es:[di+7]
		mov	[si+1Ah], ax
		mov	ax, es:[di+9]
		mov	[si+1Ch], ax
		mov	bl, 40h	; '@'
		jmp	short SetFCBBits
; ---------------------------------------------------------------------------

SaveShare:				; ...
		call	ss:ShSave

SaveSFN:				; ...
		lea	ax, [di-6]
		sub	ax, word ptr ss:SFTFCB
		push	bx
		mov	bl, 59
		div	bl
		mov	[si+18h], al
		pop	bx

SaveNoSFN:				; ...
		mov	ax, es:[di+5]
		and	al, 3Fh
		or	al, bl
		mov	[si+19h], al
		mov	ax, ss:FCBLRU
		inc	ax
		mov	es:[di+15h], ax
		jnz	short SimpleStuff
		mov	bx, 15h
		call	ResetLRU

SimpleStuff:				; ...
		mov	ss:FCBLRU, ax
		retn
SaveFCBInfo	endp


; =============== S U B	R O U T	I N E =======================================


ResetLRU	proc near		; ...
		mov	ax, 8000h
		push	es
		push	di
		les	di, ss:SFTFCB
		mov	cx, es:[di+4]
		lea	di, [di+6]

ovScan:					; ...
		sub	es:[bx+di], ax
		ja	short ovLoop
		mov	es:[bx+di], ax

ovLoop:					; ...
		add	di, 59
		loop	ovScan
		pop	di
		pop	es
		mov	es:[bx+di], ax
		retn
ResetLRU	endp


; =============== S U B	R O U T	I N E =======================================


LRUFCB		proc near		; ...
		push	es
		call	save_world
		mov	ds, cs:DosDSeg
		or	al, al
		jnz	short lru1
		mov	di, word ptr LocalSFT
		or	di, word ptr LocalSFT+2
		jz	short lru1
		les	di, LocalSFT

gotlocalSFT:				; ...
		mov	word ptr THISSFT, di
		mov	word ptr THISSFT+2, es
		clc
		jmp	LRUDone
; ---------------------------------------------------------------------------

lru1:					; ...
		les	di, SFTFCB
		mov	cx, es:[di+4]
		lea	di, [di+6]
		mov	bx, 0FFFFh
		mov	si, bx
		mov	dx, bx
		mov	bp, bx

findSFT:				; ...
		or	word ptr es:[di], 0
		jz	short gotSFT
		cmp	word ptr es:[di], 0FFFFh
		jz	short gotSFT
		test	word ptr es:[di+5], 8000h
		jnz	short lru5
		call	CheckShare
		jnz	short lru5

hackpoint:				; ...
		mov	word ptr LocalSFT, di
		mov	word ptr LocalSFT+2, es
		or	al, al
		jz	short gotlocalSFT
		cmp	es:[di+15h], bx
		jnb	short lru4
		mov	bx, es:[di+15h]
		mov	si, di

lru4:					; ...
		add	di, 59
		loop	findSFT
		mov	di, si
		cmp	si, 0FFFFh
		jnz	short gotSFT
		mov	di, bp
		cmp	bp, 0FFFFh
		jnz	short gotnetSFT
		jmp	short errorbadSFT
; ---------------------------------------------------------------------------

lru5:					; ...
		cmp	es:[di+15h], dx
		jnb	short lru4
		mov	dx, es:[di+15h]
		mov	bp, di
		jmp	short lru4
; ---------------------------------------------------------------------------

gotSFT:					; ...
		or	al, al
		jz	short hackpoint

notlocaluse:
		mov	ax, es
		cmp	word ptr LocalSFT, di
		jnz	short notinvalid
		cmp	word ptr LocalSFT+2, ax
		jz	short zerolocalSFT

notinvalid:				; ...
		jmp	gotlocalSFT
; ---------------------------------------------------------------------------

zerolocalSFT:				; ...
		xor	ax, ax
		mov	word ptr LocalSFT, ax
		mov	word ptr LocalSFT+2, ax
		jmp	gotlocalSFT
; ---------------------------------------------------------------------------

gotnetSFT:				; ...
		or	al, al
		jnz	short closenet
		mov	word ptr LocalSFT, di
		mov	word ptr LocalSFT+2, es

closenet:				; ...
		mov	word ptr THISSFT, di
		mov	word ptr THISSFT+2, es

LRUClose:				; ...
		cmp	word ptr es:[di], 0
		jz	short LRUDone
		call	DOS_CLOSE
		jnb	short LRUClose
		cmp	al, 6
		jz	short LRUClose

errorbadSFT:				; ...
		stc
		jmp	short LRUDead
; ---------------------------------------------------------------------------

LRUDone:				; ...
		xor	al, al
		call	BlastSFT

LRUDead:				; ...
		call	restore_world
		pop	es
		mov	es, cs:DosDSeg
		les	di, es:THISSFT
		jb	short LruFCB_err
		retn
; ---------------------------------------------------------------------------

LruFCB_err:				; ...
		mov	al, 23h	; '#'
		retn
LRUFCB		endp


; =============== S U B	R O U T	I N E =======================================


RegenCopyName	proc near		; ...
		lodsb
		call	UCase
		stosb
		loop	RegenCopyName
		retn
RegenCopyName	endp


; =============== S U B	R O U T	I N E =======================================


FCBRegen	proc near		; ...
		mov	al, [si+19h]
		test	al, 80h
		jz	short RegenNoSharing
		call	CheckShare
		jnz	short RegenFail
		mov	ax, 1100h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - INSTALLATION	CHECK
					; Return: AL = 00h  not	installed, OK to install
					; 01h  not installed, not OK to	install
					; FFh  installed
		or	al, al
		jz	short RegenDead

RegenFail:				; ...
		mov	ax, ss:USER_IN_AX
		cmp	ah, 10h
		jz	short RegenDead
		call	FCBHardErr

RegenDead:				; ...
		stc

FCBRegen_retn:				; ...
		retn
; ---------------------------------------------------------------------------

RegenNoSharing:				; ...
		call	CheckShare
		jnz	short RegenFail
		push	ax
		mov	al, 0
		call	LRUFCB
		pop	ax
		jb	short FCBRegen_retn
		mov	word ptr es:[di+2], 8002h
		and	al, 3Fh
		cbw
		or	ax, 4000h
		mov	cl, [si+1Ah]
		mov	ch, cl
		and	ch, 0C0h
		or	al, ch
		and	cl, 0Fh
		mov	es:[di+2], cl
		mov	es:[di+5], ax
		mov	ax, ss:PROC_ID
		mov	es:[di+31h], ax
		push	ds
		push	si
		push	es
		push	di
		push	ss
		pop	es
		mov	di, offset NAME1
		mov	cx, 8
		inc	si
		call	RegenCopyName
		push	ss
		pop	ds
		mov	ATTRIB,	16h
		call	DEVNAME
		pop	di
		pop	es
		pop	si
		pop	ds
		jb	short RegenFileNoSharing
		mov	es:[di+5], bh
		mov	byte ptr es:[di+4], 0
		lds	si, ss:DEVPT
		mov	es:[di+7], si
		mov	word ptr es:[di+9], ds
		retn
; ---------------------------------------------------------------------------

RegenDeadJ:				; ...
		jmp	short RegenDead
; ---------------------------------------------------------------------------

RegenFileNoSharing:			; ...
		mov	ax, es:[di+5]
		and	ax, 3Fh
		push	ds
		push	si
		call	FIND_DPB
		mov	es:[di+7], si
		mov	word ptr es:[di+9], ds
		pop	si
		pop	ds
		jb	short RegenDeadJ
		mov	ax, [si+1Dh]
		mov	es:[di+1Bh], ax
		mov	al, [si+18h]
		and	al, 0C0h
		mov	ah, al
		rol	ah, 1
		shr	al, 1
		or	al, ah
		and	al, 3Fh
		mov	es:[di+4], al
		mov	al, [si+18h]
		and	al, 3Fh
		sub	ah, ah
		mov	es:[di+1Dh], ax
		mov	ax, [si+1Bh]
		mov	es:[di+0Bh], ax
		mov	es:[di+35h], ax
		mov	al, [si+1Fh]
		mov	es:[di+1Fh], al
		inc	word ptr es:[di]
		lea	si, [si+1]
		lea	di, [di+20h]
		mov	cx, 11
		call	RegenCopyName
		clc
		retn
FCBRegen	endp


; =============== S U B	R O U T	I N E =======================================


BlastSFT	proc near		; ...
		push	di
		mov	cx, 59
		rep stosb
		pop	di
		sub	ax, ax
		mov	es:[di], ax
		mov	es:[di+15h], ax
		dec	ax
		mov	es:[di+17h], ax
		retn
BlastSFT	endp


; =============== S U B	R O U T	I N E =======================================


CheckFCB	proc near		; ...
		test	byte ptr [si+19h], 0C0h
		jz	short BadSFT
		les	di, ss:SFTFCB
		cmp	es:[di+4], al
		jb	short BadSFT
		mov	bl, 59
		mul	bl
		lea	di, [di+6]
		add	di, ax
		mov	ax, ss:PROC_ID
		cmp	es:[di+31h], ax
		jnz	short BadSFT
		cmp	word ptr es:[di], 0
		jz	short BadSFT
		mov	al, [si+19h]
		test	al, 80h
		jz	short CheckNoShare
		push	ax
		and	al, 0C0h
		cmp	al, 0C0h ; ''
		pop	ax
		jnz	short CheckNet
		call	ss:ShChk
		jb	short BadSFT
		jmp	short CheckD
; ---------------------------------------------------------------------------

CheckFirClus:
		cmp	bx, es:[di+0Bh]
		jnz	short BadSFT

CheckD:					; ...
		and	al, 3Fh
		mov	ah, es:[di+5]
		and	ah, 3Fh
		cmp	ah, al
		jnz	short BadSFT

BlastSFT_retn:				; ...
		retn
; ---------------------------------------------------------------------------

BadSFT:					; ...
		stc
		retn
; ---------------------------------------------------------------------------

CheckNet:				; ...
		mov	ax, [si+1Ch]
		cmp	ax, es:[di+0Bh]
		jnz	short BadSFT
		retn
; ---------------------------------------------------------------------------

CheckNoShare:				; ...
		test	al, 40h
		jnz	short $+2
		mov	bx, [si+1Ah]
		cmp	bx, es:[di+7]
		jnz	short BadSFT
		mov	bx, [si+1Ch]
		cmp	bx, es:[di+9]
		jnz	short BadSFT
		jmp	short CheckD
CheckFCB	endp


; =============== S U B	R O U T	I N E =======================================


SFTFromFCB	proc near		; ...
		push	ax
		push	bx
		mov	al, [si+18h]
		call	CheckFCB
		pop	bx
		pop	ax
		mov	word ptr ss:THISSFT, di
		mov	word ptr ss:THISSFT+2, es
		jnb	short Set_SFT
		push	es
		call	save_world
		call	FCBRegen
		call	restore_world
		pop	es
		mov	ax, ss:EXTERR
		jb	short BlastSFT_retn

Set_SFT:				; ...
		les	di, ss:THISSFT
		push	ss:PROC_ID
		pop	word ptr es:[di+31h]
		retn
SFTFromFCB	endp


; =============== S U B	R O U T	I N E =======================================


FCBHardErr	proc near		; ...
		mov	es, cs:DosDSeg
		mov	ax, 23h	; '#'
		mov	es:ALLOWED, 8
		les	bp, es:THISDPB
		mov	di, 1
		mov	cx, di
		mov	dx, es:[bp+0Bh]
		call	HARDERR
		stc
		retn
FCBHardErr	endp


; =============== S U B	R O U T	I N E =======================================


GetRR		proc near		; ...
		mov	ax, [si+21h]
		mov	dx, [si+23h]
		cmp	bx, 64
		jb	short GetRRBye
		xor	dh, dh

GetRRBye:				; ...
		retn
GetRR		endp


; =============== S U B	R O U T	I N E =======================================


GetExtent	proc near		; ...
		mov	al, [si+20h]
		mov	dx, [si+0Ch]
		shl	al, 1
		shr	dx, 1
		rcr	al, 1
		mov	ah, dl
		mov	dl, dh
		xor	dh, dh
		retn
GetExtent	endp


; =============== S U B	R O U T	I N E =======================================


SetExtent	proc near		; ...
		push	ax
		push	dx
		mov	cx, ax
		and	al, 7Fh
		mov	[si+20h], al
		and	cl, 80h
		shl	cx, 1
		rcl	dx, 1
		mov	al, ch
		mov	ah, dl
		mov	[si+0Ch], ax
		pop	dx
		pop	ax
		retn
SetExtent	endp


; =============== S U B	R O U T	I N E =======================================


GetExtended	proc near		; ...
		mov	si, dx
		cmp	byte ptr [si], 0FFh
		jnz	short GetBye
		add	si, 7

GetBye:					; ...
		cmp	si, dx

getextd_retn:				; ...
		retn
GetExtended	endp


; =============== S U B	R O U T	I N E =======================================


GetRecSize	proc near		; ...
		mov	bx, [si+0Eh]
		or	bx, bx
		jnz	short getextd_retn
		mov	bx, 128
		mov	[si+0Eh], bx
		retn
GetRecSize	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

FCBIO		proc near		; ...

FCBOp		= byte ptr -14h
cRecRes		= word ptr -13h
cResult		= word ptr -11h
cByte		= word ptr -0Fh
bPosL		= word ptr -0Dh
bPosH		= word ptr -0Bh
RecSize		= word ptr -9
RecPosL		= word ptr -7
RecPosH		= word ptr -5
cRec		= word ptr -3
FCBErr		= byte ptr -1

		push	bp
		mov	bp, sp
		sub	sp, 20
		mov	[bp+FCBOp], al
		mov	[bp+FCBErr], 0
		call	GetExtended
		test	[bp+FCBOp], 8
		jnz	short GetPos
		mov	cx, 1

GetPos:					; ...
		mov	[bp+cRec], cx
		call	GetExtent
		call	GetRecSize
		mov	[bp+RecSize], bx
		test	[bp+FCBOp], 2
		jz	short GetRec
		call	GetRR

GetRec:					; ...
		mov	[bp+RecPosL], ax
		mov	[bp+RecPosH], dx
		call	SetExtent
		mov	ax, [bp+RecPosH]
		mul	bx
		mov	di, ax
		mov	ax, [bp+RecPosL]
		mul	bx
		add	dx, di
		mov	[bp+bPosL], ax
		mov	[bp+bPosH], dx
		mov	ax, [bp+cRec]
		mul	bx
		mov	[bp+cByte], ax
		add	ax, word ptr ss:DMAADD
		adc	dx, 0
		jz	short DoOper
		mov	[bp+FCBErr], 2
		mov	ax, word ptr ss:DMAADD
		neg	ax
		jnz	short DoDiv
		dec	ax

DoDiv:					; ...
		xor	dx, dx
		div	bx
		mov	[bp+cRec], ax
		mul	bx
		mov	[bp+cByte], ax

DoOper:					; ...
		xor	bx, bx
		mov	[bp+cResult], bx
		cmp	[bp+cByte], bx
		jnz	short DoGetExt
		test	[bp+FCBErr], 2
		jz	short DoGetExt
		jmp	short SkipOp
; ---------------------------------------------------------------------------

DoGetExt:				; ...
		call	SFTFromFCB
		jnb	short ContinueOp

FCBDeath:				; ...
		call	FCB_RET_ERR
		mov	[bp+cRecRes], 0
		mov	[bp+FCBErr], 1
		jmp	FCBSave
; ---------------------------------------------------------------------------

ContinueOp:				; ...
		mov	ax, [si+10h]
		mov	es:[di+11h], ax
		mov	ax, [si+12h]
		mov	es:[di+13h], ax
		mov	ax, [bp+bPosL]
		mov	dx, [bp+bPosH]
		mov	es:[di+15h], ax
		xchg	dx, es:[di+17h]
		push	dx
		mov	cx, [bp+cByte]
		mov	di, offset DOS_READ
		test	[bp+FCBOp], 4
		jnz	short DoContext
		mov	di, offset DOS_WRITE

DoContext:				; ...
		push	bp
		push	ds
		push	si
		push	ss
		pop	ds
		call	di ; loc_B20C
		pop	si
		pop	ds
		pop	bp
		jb	short FCBDeath
		cmp	ss:DISK_FULL, 0
		jz	short NODSKFULL
		mov	ss:DISK_FULL, 0
		mov	[bp+FCBErr], 1

NODSKFULL:				; ...
		mov	[bp+cResult], cx
		call	SaveFCBInfo
		pop	word ptr es:[di+17h]
		mov	ax, es:[di+11h]
		mov	[si+10h], ax
		mov	ax, es:[di+13h]
		mov	[si+12h], ax

SkipOp:					; ...
		mov	ax, [bp+cResult]
		xor	dx, dx
		div	[bp+RecSize]
		mov	[bp+cRecRes], ax
		add	[bp+RecPosL], ax
		adc	[bp+RecPosH], 0
		cmp	ax, [bp+cRec]
		jz	short TryBlank
		test	[bp+FCBOp], 4
		jnz	short SetEOF
		test	byte ptr es:[di+5], 80h
		jnz	short TryBlank

SetEOF:					; ...
		mov	[bp+FCBErr], 1

TryBlank:				; ...
		or	dx, dx
		jz	short SetExt
		add	[bp+RecPosL], 1
		adc	[bp+RecPosH], 0
		test	[bp+FCBOp], 4
		jz	short SetExt
		inc	[bp+cRecRes]
		mov	[bp+FCBErr], 3
		mov	cx, [bp+RecSize]
		sub	cx, dx		; ...
		xor	al, al
		les	di, ss:DMAADD
		add	di, [bp+cResult]
		rep stosb

SetExt:					; ...
		mov	dx, [bp+RecPosH]
		mov	ax, [bp+RecPosL]
		test	[bp+FCBOp], 2
		jz	short DoSetExt
		test	[bp+FCBOp], 8
		jz	short TrySetRR

DoSetExt:				; ...
		call	SetExtent

TrySetRR:				; ...
		test	[bp+FCBOp], 8
		jz	short TryReturn
		mov	[si+21h], ax
		mov	[si+23h], dl
		cmp	word ptr [si+0Eh], 64
		jnb	short TryReturn
		mov	[si+24h], dh

TryReturn:				; ...
		test	[bp+FCBOp], 4
		jnz	short FCBSave
		push	ds
		call	DATE16
		pop	ds
		mov	[si+14h], ax
		mov	[si+16h], dx

FCBSave:				; ...
		test	[bp+FCBOp], 8
		jz	short DoReturn
		mov	cx, [bp+cRecRes]
		call	Get_User_Stack
		mov	[si+4],	cx

DoReturn:				; ...
		mov	al, [bp+FCBErr]
		mov	sp, bp
		pop	bp
		retn
FCBIO		endp


; =============== S U B	R O U T	I N E =======================================


$FCB_OPEN	proc near		; ...
		mov	ax, 2
		mov	cx, offset DOS_OPEN

DoAccess:				; ...
		push	ds
		push	dx
		push	cx
		push	ax
		mov	di, offset OPENBUF
		call	TransFCB
		pop	ax
		pop	cx
		pop	dx
		pop	ds
		jnb	short FindFCB

FCBOpenErr:				; ...
		jmp	FCB_RET_ERR
; ---------------------------------------------------------------------------

FindFCB:				; ...
		call	GetExtended
		push	ax
		mov	al, 1
		call	LRUFCB
		pop	ax
		jb	short HardMessage
		mov	word ptr es:[di+2], 8000h
		push	ds
		push	si
		push	bx
		mov	si, cx
		push	ss
		pop	ds
		call	si
		pop	bx
		pop	si
		pop	ds
		les	di, ss:THISSFT
		jnb	short FCBOK
		push	ax
		mov	al, 'R'
		call	BlastSFT
		pop	ax
		cmp	ax, 4
		jz	short HardMessage
		cmp	ax, 24h	; '$'
		jnz	short DeadFCB

HardMessage:				; ...
		push	ax
		call	FCBHardErr
		pop	ax

DeadFCB:				; ...
		jmp	short FCBOpenErr
; ---------------------------------------------------------------------------

FCBOK:					; ...
		call	IsSFTNet
		jnz	short FCBOK2
		call	CheckShare
		jnz	short FCBOK2
		mov	word ptr ss:LocalSFT, di
		mov	word ptr ss:LocalSFT+2,	es

FCBOK2:					; ...
		inc	word ptr es:[di]
		call	SaveFCBInfo
		test	byte ptr es:[di+5], 80h
		jnz	short FCBNoDrive
		mov	al, [si]
		call	GETTHISDRV
		inc	al
		mov	[si], al

FCBNoDrive:				; ...
		mov	word ptr [si+0Eh], 80h
		mov	ax, es:[di+0Dh]
		mov	[si+16h], ax
		mov	ax, es:[di+0Fh]
		mov	[si+14h], ax
		mov	ax, es:[di+11h]
		mov	[si+10h], ax
		mov	ax, es:[di+13h]
		mov	[si+12h], ax
		xor	ax, ax
		mov	[si+0Ch], ax
		les	di, ss:SFTFCB
		mov	ah, es:[di+4]

OpenScan:				; ...
		cmp	al, [si+18h]
		jz	short SkipCheck
		push	ax
		call	CheckFCB
		pop	ax
		jnb	short OpenFound

SkipCheck:				; ...
		inc	al
		cmp	al, ah
		jnz	short OpenScan

OpenDone:				; ...
		xor	al, al
		retn
; ---------------------------------------------------------------------------

OpenFound:				; ...
		mov	[si+18h], al
		inc	word ptr es:[di]
		mov	ax, ss:FCBLRU
		mov	es:[di+15h], ax
		push	ss
		pop	ds
		les	di, THISSFT
		dec	word ptr es:[di]
		call	ShareEnd
		mov	al, 'C'
		call	BlastSFT
		jmp	short OpenDone
$FCB_OPEN	endp

; ---------------------------------------------------------------------------

$FCB_CREATE:				; ...
		mov	cx, offset DOS_CREATE
		xor	ax, ax
		call	GetExtended
		jz	short DoAccessJ
		mov	al, [si-1]

DoAccessJ:				; ...
		jmp	DoAccess
; ---------------------------------------------------------------------------

$FCB_RANDOM_WRITE_BLOCK:		; ...
		mov	al, 0Ah
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_RANDOM_READ_BLOCK:			; ...
		mov	al, 0Eh
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_SEQ_READ:				; ...
		mov	al, 4
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_SEQ_WRITE:				; ...
		mov	al, 0
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_RANDOM_READ:			; ...
		mov	al, 6
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_RANDOM_WRITE:			; ...
		mov	al, 2
		jmp	FCBIO
; ---------------------------------------------------------------------------

$DIR_SEARCH_FIRST:			; ...
		mov	word ptr ss:THISFCB, dx
		mov	word ptr ss:THISFCB+2, ds
		mov	si, dx
		cmp	byte ptr [si], 0FFh
		jnz	short NORMFCB4
		add	si, 7

NORMFCB4:				; ...
		push	word ptr [si]
		push	ss
		pop	es
		mov	di, offset OPENBUF
		call	TransFCB
		jnb	short SearchIt
		pop	bx

dsf_err:				; ...
		jmp	FCB_RET_ERR
; ---------------------------------------------------------------------------

SearchIt:				; ...
		push	ss
		pop	ds
		push	word ptr DMAADD
		push	word ptr DMAADD+2
		mov	word ptr DMAADD, offset	SEARCHBUF
		mov	word ptr DMAADD+2, ds
		call	GET_FAST_SEARCH
		pop	word ptr DMAADD+2
		pop	word ptr DMAADD
		jnb	short SearchSet
		pop	bx
		jmp	short dsf_err
; ---------------------------------------------------------------------------

SearchSet:				; ...
		mov	si, offset SEARCHBUF
		les	di, THISFCB
		test	EXTFCB,	0FFh
		jz	short NORMFCB1
		add	di, 7

NORMFCB1:				; ...
		pop	bx
		or	bl, bl
		jnz	short SearchDrv
		mov	bl, CURDRV
		inc	bl

SearchDrv:				; ...
		lodsb
		xchg	al, bl
		inc	di
		mov	cx, 10
		rep movsw
		xchg	al, bl
		stosb
		les	di, DMAADD
		test	EXTFCB,	0FFh
		jz	short NORMFCB2
		mov	al, 0FFh
		stosb
		inc	al
		mov	cx, 5
		rep stosb
		mov	al, SATTRIB
		stosb

NORMFCB2:				; ...
		mov	al, bl
		stosb
		mov	cx, 16
		rep movsw
		jmp	NO_OP
; ---------------------------------------------------------------------------

$DIR_SEARCH_NEXT:			; ...
		mov	word ptr ss:THISFCB, dx
		mov	word ptr ss:THISFCB+2, ds
		mov	ss:SATTRIB, 0
		mov	ss:EXTFCB, 0
		push	ss
		pop	es
		mov	di, offset SEARCHBUF
		mov	si, dx
		cmp	byte ptr [si], 0FFh
		jnz	short NORMFCB6
		add	si, 6
		lodsb
		mov	ss:SATTRIB, al
		dec	ss:EXTFCB

NORMFCB6:				; ...
		lodsb
		push	ax
		mov	al, [si+20]
		stosb
		mov	cx, 10
		rep movsw
		push	ss
		pop	ds
		push	word ptr DMAADD
		push	word ptr DMAADD+2
		mov	word ptr DMAADD, offset	SEARCHBUF
		mov	word ptr DMAADD+2, ds
		call	DOS_SEARCH_NEXT
		pop	word ptr DMAADD+2
		pop	word ptr DMAADD
		jb	short SearchNoMore
		jmp	SearchSet
; ---------------------------------------------------------------------------

SearchNoMore:				; ...
		les	di, THISFCB
		test	EXTFCB,	0FFh
		jz	short NORMFCB8
		add	di, 7

NORMFCB8:				; ...
		pop	bx
		mov	es:[di], bl
		jmp	FCB_RET_ERR
; ---------------------------------------------------------------------------

$FIND_FIRST:				; ...
		mov	si, dx
		mov	ss:SATTRIB, cl
		mov	di, offset OPENBUF
		call	TransPathSet
		jnb	short Find_it
		mov	al, 3

FindError:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

Find_it:				; ...
		push	ss
		pop	ds
		push	word ptr DMAADD
		push	word ptr DMAADD+2
		mov	word ptr DMAADD, offset	SEARCHBUF
		mov	word ptr DMAADD+2, ds
		call	GET_FAST_SEARCH
		pop	word ptr DMAADD+2
		pop	word ptr DMAADD
		jnb	short FindSet

FindItError:				; ...
		jmp	short FindError
; ---------------------------------------------------------------------------

FindSet:				; ...
		mov	si, offset SEARCHBUF
		les	di, DMAADD
		mov	cx, 21
		rep movsb
		push	si
		mov	al, [si+0Bh]
		stosb
		add	si, 16h
		movsw
		movsw
		inc	si
		inc	si
		movsw
		movsw
		pop	si
		call	PackName
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

$FIND_NEXT:				; ...
		push	ss
		pop	es
		mov	di, offset SEARCHBUF
		lds	si, ss:DMAADD
		mov	cx, 21
		rep movsb
		push	ss
		pop	ds
		push	word ptr DMAADD
		push	word ptr DMAADD+2
		mov	word ptr DMAADD, offset	SEARCHBUF
		mov	word ptr DMAADD+2, ds
		call	DOS_SEARCH_NEXT
		pop	word ptr DMAADD+2
		pop	word ptr DMAADD
		jnb	short FindSet
		jmp	short FindItError

; =============== S U B	R O U T	I N E =======================================


PackName	proc near		; ...
		mov	cx, 8
		rep movsb

main_kill_tail:				; ...
		cmp	byte ptr es:[di-1], ' '
		jnz	short find_check_dot
		dec	di
		inc	cx
		cmp	cx, 8
		jb	short main_kill_tail

find_check_dot:				; ...
		cmp	word ptr [si], '  '
		jnz	short got_ext
		cmp	byte ptr [si+2], ' '
		jz	short find_done

got_ext:				; ...
		mov	al, '.'
		stosb
		mov	cx, 3
		rep movsb

ext_kill_tail:				; ...
		cmp	byte ptr es:[di-1], ' '
		jnz	short find_done
		dec	di
		jmp	short ext_kill_tail
; ---------------------------------------------------------------------------

find_done:				; ...
		xor	ax, ax
		stosb
		retn
PackName	endp


; =============== S U B	R O U T	I N E =======================================


GET_FAST_SEARCH	proc near		; ...
		or	ss:DOS34_FLAG, 400h
		call	DOS_SEARCH_FIRST
		retn
GET_FAST_SEARCH	endp

; ---------------------------------------------------------------------------

$CURRENT_DIR:				; ...
		call	ECritDisk
		mov	al, dl
		call	GetVisDrv
		jnb	short CurrentValidate

CurdirErr:				; ...
		call	LCritDisk
		push	ds
		mov	ds, cs:DosDSeg
		mov	al, DrvErr
		pop	ds

curdir_errj:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

CurrentValidate:			; ...
		push	ds
		push	si
		mov	ds, cs:DosDSeg
		lds	si, THISCDS
		test	word ptr [si+43h], 8000h
		jnz	short $+2
		push	ds
		mov	ds, cs:DosDSeg
		mov	NoSetDir, 0
		pop	ds
		mov	di, offset OPENBUF
		call	ValidateCDS
		push	es
		push	di
		pop	si
		pop	ds
		pop	di
		pop	es
		jb	short CurdirErr
		add	si, 0
		add	si, [si+4Fh]
		cmp	byte ptr [si], '\'
		jnz	short CurrentCopy
		inc	si

CurrentCopy:				; ...
		push	ax
		lodsb
		or	al, al
		jz	short FOK
		cmp	al, 5
		jz	short FCHANGE
		jmp	short FFF
; ---------------------------------------------------------------------------

FCPYNEXT:				; ...
		lodsb

FFF:					; ...
		cmp	al, '\'
		jnz	short FOK
		stosb
		lodsb
		cmp	al, 5
		jnz	short FOK

FCHANGE:				; ...
		mov	al, 0E5h ; ''

FOK:					; ...
		stosb
		or	al, al
		jnz	short FCPYNEXT
		pop	ax
		xor	al, al
		call	LCritDisk
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

$RMDIR:					; ...
		push	dx
		push	ds
		mov	si, dx
		mov	di, offset OPENBUF
		push	di
		call	TransPathNoSet
		pop	di
		jnb	short rmlset
		pop	ds
		pop	dx
		mov	al, 3

rmdir_errj:				; ...
		jmp	short curdir_errj
; ---------------------------------------------------------------------------

rmlset:					; ...
		cmp	ss:CMETA, 0FFh
		jnz	short rmerr
		push	ss
		pop	es
		xor	al, al

rmloop:					; ...
		call	GetCDSFromDrv
		jb	short rmcont
		call	StrCmp
		jz	short rmerr
		inc	al
		jmp	short rmloop
; ---------------------------------------------------------------------------

rmerr:					; ...
		pop	ds
		pop	dx
		mov	al, 10h

rmerrj:					; ...
		jmp	short rmdir_errj
; ---------------------------------------------------------------------------

rmcont:					; ...
		pop	ds
		pop	dx
		mov	si, offset DOS_RMDIR
		jmp	DoDirCall
; ---------------------------------------------------------------------------

$CHDIR:					; ...
		mov	di, offset OPENBUF
		mov	si, dx
		call	TransPath
		jnb	short ChDirCrack

ChDirErrP:				; ...
		mov	al, 3

ChDirErr:				; ...
		jmp	short rmerrj
; ---------------------------------------------------------------------------

ChDirCrack:				; ...
		cmp	CMETA, 0FFh
		jnz	short ChDirErrP
		les	di, THISCDS
		cmp	di, 0FFFFh
		jz	short ChDirErrP
		call	DOS_CHDIR
		jb	short ChDirErr
		les	di, THISCDS
		test	word ptr es:[di+43h], 2000h
		jz	short GotCDS
		push	es
		push	di
		push	cx
		call	Get_User_Stack
		mov	di, [si+6]
		mov	ds, word ptr [si+0Eh]
		mov	si, offset OPENBUF
		xchg	si, di
		xor	al, al
		push	di
		call	TransPathNoSet
		pop	si
		les	di, THISCDS
		mov	word ptr es:[di+49h], 0FFFFh
		pop	cx
		pop	di
		pop	es

GotCDS:					; ...
		call	Check_PathLen
		ja	short ChDirErrP
		test	word ptr es:[di+43h], 8000h
		jnz	short SkipRecency
		test	word ptr es:[di+43h], 2000h
		jz	short setdirclus
		mov	cx, 0FFFFh

setdirclus:				; ...
		mov	es:[di+49h], cx
		les	di, THISCDS

SkipRecency:				; ...
		call	FStrCpy
		xor	al, al

mkdir_ok:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

$MKDIR:					; ...
		mov	si, offset DOS_MKDIR

DoDirCall:				; ...
		mov	di, offset OPENBUF
		push	si
		mov	si, dx
		call	TransPath
		pop	si
		jnb	short MkDirCrack

MkErrP:					; ...
		mov	al, 3

MkErr:					; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

MkDirCrack:				; ...
		cmp	ss:CMETA, 0FFh
		jnz	short MkErrP
		push	si
		call	Check_PathLen
		pop	si
		jbe	short pathok
		mov	al, 5
		jmp	short MkErr
; ---------------------------------------------------------------------------

pathok:					; ...
		call	si
		jb	short MkErr
		jmp	short mkdir_ok

; =============== S U B	R O U T	I N E =======================================


Check_PathLen	proc near		; ...
		mov	si, ss:WFP_START
Check_PathLen	endp


; =============== S U B	R O U T	I N E =======================================


check_PathLen2	proc near		; ...
		push	ss
		pop	ds
		push	cx
		call	DStrLen
		cmp	cx, 67
		pop	cx
		retn
check_PathLen2	endp

; ---------------------------------------------------------------------------
IOCTLJMPTABLE	dw offset ioctl_getset_data ; ...
		dw offset ioctl_getset_data
		dw offset ioctl_control_string
		dw offset ioctl_control_string
		dw offset ioctl_get_dev
		dw offset ioctl_get_dev
		dw offset ioctl_status
		dw offset ioctl_status
		dw offset ioctl_rem_media
		dw offset ioctl_drive_attr
		dw offset ioctl_handle_redir
		dw offset Set_Retry_Parameters
		dw offset GENERICIOCTLHANDLE
		dw offset GENERICIOCTL
		dw offset ioctl_drive_owner
		dw offset ioctl_drive_owner
		dw offset GENERICIOCTLHANDLE ; query_handle_support
		dw offset GENERICIOCTL	; query_device_support

; =============== S U B	R O U T	I N E =======================================


$IOCTL		proc near		; ...

; FUNCTION CHUNK AT 43FA SIZE 00000013 BYTES
; FUNCTION CHUNK AT 6265 SIZE 00000090 BYTES
; FUNCTION CHUNK AT 62FA SIZE 00000074 BYTES
; FUNCTION CHUNK AT 63B3 SIZE 0000004A BYTES

		mov	si, ds
		push	ss
		pop	ds
		cmp	al, 11h
		ja	short ioctl_bad_funj2
		push	ax
		mov	di, ax
		and	di, 0FFh
		shl	di, 1
		pop	ax
		jmp	cs:IOCTLJMPTABLE[di]
; ---------------------------------------------------------------------------

ioctl_bad_funj2:			; ...
		jmp	ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_getset_data:			; ...
		call	SFFromHandle
		jnb	short ioctl_check_permissions

ioctl_bad_handle:			; ...
		mov	al, 6

ioctl_error:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

ioctl_check_permissions:		; ...
		cmp	al, 0
		mov	al, es:[di+5]
		jz	short ioctl_read
		or	dh, dh
		jz	short ioctl_check_device
		mov	al, 0Dh
		jmp	short ioctl_error
; ---------------------------------------------------------------------------

ioctl_check_device:			; ...
		test	al, 80h
		jz	short ioctl_bad_funj2
		or	dl, 80h
		mov	EXTERR_LOCUS, 4
		mov	es:[di+5], dl

ioctl_ok:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

ioctl_read:				; ...
		mov	EXTERR_LOCUS, 2
		xor	ah, ah
		test	al, 80h
		jz	short ioctl_no_high
		mov	EXTERR_LOCUS, 4
		les	di, es:[di+7]
		mov	ah, es:[di+5]

ioctl_no_high:				; ...
		mov	dx, ax
		call	Get_User_Stack
		mov	[si+6],	dx

jmp_to_ioctl_ok:			; ...
		jmp	short ioctl_ok
; ---------------------------------------------------------------------------

ioctl_control_string:			; ...
		call	SFFromHandle
		jb	short ioctl_bad_handle
		test	byte ptr es:[di+5], 80h
		jz	short ioctl_bad_funj2
		mov	EXTERR_LOCUS, 4
		les	di, es:[di+7]
		xor	bl, bl
		jmp	ioctl_do_string
; ---------------------------------------------------------------------------

ioctl_status:				; ...
		mov	ah, 1
		sub	al, 6
		jz	short ioctl_get_status
		mov	ah, 3

ioctl_get_status:			; ...
		push	ax
		call	GET_IO_SFT
		pop	ax
		jnb	short DO_IOFUNC
		jmp	short ioctl_bad_handle
; ---------------------------------------------------------------------------

DO_IOFUNC:				; ...
		call	IOFUNC
		mov	ah, al
		mov	al, 0FFh
		jnz	short ioctl_status_ret
		inc	al

ioctl_status_ret:			; ...
		jmp	short jmp_to_ioctl_ok
; ---------------------------------------------------------------------------

Set_Retry_Parameters:			; ...
		mov	RetryLoop, cx
		or	dx, dx
		jz	short ioctl_bad_fun
		mov	RetryCount, dx
		jmp	short ioctl_status_ret
; ---------------------------------------------------------------------------

GENERICIOCTLHANDLE:			; ...
		call	SFFromHandle
		jb	short ioctl_bad_handlej
		test	byte ptr es:[di+6], 80h
		jnz	short ioctl_bad_fun
		mov	EXTERR_LOCUS, 4
		les	di, es:[di+7]
		jmp	short Do_GenIOCTL
; ---------------------------------------------------------------------------

GENERICIOCTL:				; ...
		mov	EXTERR_LOCUS, 2
		cmp	ch, 8
		jnz	short ioctl_bad_fun
		call	Check_If_Net
		jnz	short ioctl_bad_fun

Do_GenIOCTL:				; ...
		test	byte ptr es:[di+4], 40h
		jz	short ioctl_bad_fun
		mov	IOCALL_REQFUNC,	13h
		cmp	al, 10h
		jl	short SetIOCtlBlock
		test	byte ptr es:[di+4], 80h
		jz	short ioctl_bad_fun
		mov	IOCALL_REQFUNC,	19h

SetIOCtlBlock:				; ...
		push	es
		push	di
		mov	IOCALL,	23
		mov	IOCALL_REQUNIT,	bl
		mov	IOMED, ch
		mov	byte ptr IOXAD,	cl
		mov	word ptr IOXAD+1, si
		mov	word ptr IOXAD+3, di
		mov	IOSCNT+1, dx
		mov	IOSSEC+1, si
		mov	bx, offset IOCALL
		push	ss
		pop	es
		pop	si
		pop	ds
		jmp	ioctl_do_IO
; ---------------------------------------------------------------------------

ioctl_bad_fun:				; ...
		mov	al, 1
		jmp	SYS_RET_ERR
$IOCTL		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $IOCTL

ioctl_bad_handlej:			; ...
		jmp	ioctl_bad_handle
; ---------------------------------------------------------------------------

ioctl_rem_media:			; ...
		call	Check_If_Net
		jnz	short ioctl_bad_fun
		test	byte ptr es:[di+5], 8
		jz	short ioctl_bad_fun
		mov	ss:IOCALL_REQFUNC, 15
		mov	al, 13
		mov	ah, bl
		mov	word ptr ss:IOCALL, ax
		xor	ax, ax
		mov	ss:IOCALL_REQSTAT, ax
		push	es
		pop	ds
		mov	si, di
		push	ss
		pop	es
		mov	bx, offset IOCALL
		push	ds
		push	si
		call	DEVIOCALL2
		pop	si
		pop	ds
		mov	ax, ss:IOCALL_REQSTAT
		and	ax, 200h
		mov	cl, 9
		shr	ax, cl

ioctlt_rmed_ok:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

ioctl_drive_attr:			; ...
		mov	al, bl
		call	GETTHISDRV
		jb	short ioctl_drv_err
		call	Get_Driver_BL
		jb	short ioctl_drv_err
		mov	dx, es:[di+4]
		mov	bl, al
		les	di, ss:THISCDS
		test	byte ptr es:[di+44h], 80h
		jz	short IOCTLShare
		mov	dx, 1000h

IOCTLShare:				; ...
		push	ss
		pop	ds
		mov	si, offset OPENBUF
		add	bl, 'A'
		mov	[si], bl
		mov	word ptr [si+1], ':'
		mov	ax, 300h
		clc
		int	2Ah		; Microsoft Networks - CHECK DIRECT I/O
					; DS:SI	-> ASCIZ disk device name (may be full path or only drive
					; specifier--must include the colon)
					; Return: CF clear if absolute disk access allowed
		jnb	short IOCTLLocal
		or	dx, 200h

IOCTLLocal:				; ...
		test	byte ptr es:[di+44h], 10h
		jz	short ioctl_set_DX
		or	dx, 8000h

ioctl_set_DX:				; ...
		call	Get_User_Stack
		mov	[si+6],	dx

ioctl_dattr_ok:				; ...
		jmp	short ioctlt_rmed_ok
; END OF FUNCTION CHUNK	FOR $IOCTL
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR Check_If_Net

ioctl_drv_err:				; ...
		mov	al, 0Fh

ioctl_dattr_errj:			; ...
		jmp	SYS_RET_ERR
; END OF FUNCTION CHUNK	FOR Check_If_Net
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $IOCTL

ioctl_handle_redir:			; ...
		call	SFFromHandle
		jnb	short ioctl_got_sft
		jmp	ioctl_bad_handle
; ---------------------------------------------------------------------------

ioctl_got_sft:				; ...
		mov	dx, es:[di+5]
		jmp	short ioctl_set_DX
; ---------------------------------------------------------------------------

ioctl_bad_funj:				; ...
		jmp	ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_get_dev:				; ...
		call	Check_If_Net
		jnz	short ioctl_bad_funj

ioctl_do_string:			; ...
		test	byte ptr es:[di+5], 40h
		jz	short ioctl_bad_funj
		mov	IOCALL_REQFUNC,	3
		test	al, 1
		jz	short ioctl_control_call
		mov	IOCALL_REQFUNC,	12

ioctl_control_call:			; ...
		mov	al, 22
		mov	ah, bl
		mov	word ptr IOCALL, ax
		xor	ax, ax
		mov	IOCALL_REQSTAT,	ax
		mov	IOMED, al
		mov	IOSCNT,	cx
		mov	word ptr IOXAD,	dx
		mov	word ptr IOXAD+2, si
		push	es
		pop	ds
		mov	si, di
		push	ss
		pop	es
		mov	bx, offset IOCALL

ioctl_do_IO:				; ...
		call	DEVIOCALL2
		test	byte ptr ss:IOCALL_REQSTAT+1, 80h
		jnz	short ioctl_string_err
		mov	ax, ss:IOSCNT
		jmp	short ioctl_dattr_ok
; ---------------------------------------------------------------------------

ioctl_string_err:			; ...
		mov	di, ss:IOCALL_REQSTAT
		and	di, 0FFh
		mov	ax, di
		call	SET_I24_EXTENDED_ERROR
		mov	ax, ss:EXTERR
		jmp	short ioctl_dattr_errj
; END OF FUNCTION CHUNK	FOR $IOCTL

; =============== S U B	R O U T	I N E =======================================


Get_Driver_BL	proc near		; ...
		push	ax
		mov	al, bl
		call	GETTHISDRV
		jb	short ioctl_bad_drv
		xor	bl, bl
		mov	EXTERR_LOCUS, 3
		les	di, THISCDS
		test	byte ptr es:[di+44h], 80h
		les	di, es:[di+45h]
		jnz	short got_dev_ptr
		mov	EXTERR_LOCUS, 2
		mov	bl, es:[di+1]
		les	di, es:[di+13h]

got_dev_ptr:				; ...
		clc

ioctl_bad_drv:				; ...
		pop	ax
		retn
Get_Driver_BL	endp


; =============== S U B	R O U T	I N E =======================================


Check_If_Net	proc near		; ...

; FUNCTION CHUNK AT 62F5 SIZE 00000005 BYTES

		call	Get_Driver_BL
		jb	short ioctl_drv_err_pop
		push	es
		push	di
		les	di, THISCDS
		test	byte ptr es:[di+44h], 80h
		pop	di
		pop	es
		retn
; ---------------------------------------------------------------------------

ioctl_drv_err_pop:			; ...
		pop	ax
		jmp	ioctl_drv_err
Check_If_Net	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $IOCTL

ioctl_bad_funj3:			; ...
		jmp	ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_string_errj:			; ...
		jmp	short ioctl_string_err
; ---------------------------------------------------------------------------

ioctl_drive_owner:			; ...
		call	Check_If_Net
		jnz	short ioctl_bad_funj3
		test	byte ptr es:[di+4], 40h
		jz	short ioctl_bad_funj3
		mov	IOCALL_REQFUNC,	23
		cmp	al, 0Eh
		jz	short GetOwner
		mov	IOCALL_REQFUNC,	24

GetOwner:				; ...
		mov	al, 13
		mov	ah, bl
		mov	word ptr IOCALL, ax
		xor	ax, ax
		mov	IOCALL_REQSTAT,	ax
		push	es
		pop	ds
		mov	si, di
		push	ss
		pop	es
		mov	bx, offset IOCALL
		push	ds
		push	si
		call	DEVIOCALL2
		pop	si
		pop	ds
		test	byte ptr ss:IOCALL_REQSTAT+1, 80h
		jnz	short ioctl_string_errj
		mov	al, ss:IOCALL_REQUNIT
		jmp	SYS_RET_OK
; END OF FUNCTION CHUNK	FOR $IOCTL

; =============== S U B	R O U T	I N E =======================================


DOS_DELETE	proc near		; ...
		call	TestNet
		jnb	short LOCAL_DELETE
		mov	ax, 1113h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
					; SS = DS = DOS	CS, SDA	first filename pointer -> fully-qualified filename in DOS CS
					; SDA CDS pointer -> current directory structure for drive with	file
					; Return: CF set on error
		retn
; ---------------------------------------------------------------------------

LOCAL_DELETE:				; ...
		mov	FOUNDDEL, 0
		call	ECritDisk
		mov	word ptr CREATING, 0E500h
		mov	si, WFP_START

SKPNUL:					; ...
		lodsb
		or	al, al
		jnz	short SKPNUL
		sub	si, 4
		cmp	word ptr [si], '.*'
		jnz	short TEST_QUEST
		cmp	byte ptr [si+2], '*'
		jz	short CHECK_ATTS

TEST_QUEST:				; ...
		sub	si, 9
		xchg	di, si
		push	ss
		pop	es
		mov	ax, '??'
		mov	cx, 4
		repe scasw
		jnz	short NOT_ALL
		xchg	di, si
		lodsw
		cmp	ax, '?.'
		jnz	short NOT_ALL
		lodsw
		cmp	ax, '??'
		jnz	short NOT_ALL

CHECK_ATTS:				; ...
		mov	al, SATTRIB
		and	al, 1Fh
		cmp	al, 1Fh
		jnz	short NOT_ALL
		mov	DELALL,	0

NOT_ALL:				; ...
		mov	NoSetDir, 1
		call	GetPathNoSet
		jnb	short Del_found
		jnz	short _bad_path
		or	cl, cl
		jz	short _bad_path

No_file:				; ...
		mov	ax, 2

ErrorReturn:				; ...
		stc
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

_bad_path:				; ...
		mov	ax, 3
		jmp	short ErrorReturn
; ---------------------------------------------------------------------------

Del_found:				; ...
		jnz	short NOT_DIR
		cmp	DELALL,	0
		jz	short NOT_DIR

Del_access_err:				; ...
		mov	ax, 5
		jmp	short ErrorReturn
; ---------------------------------------------------------------------------

NOT_DIR:				; ...
		or	ah, ah
		js	short Del_access_err

DELFILE:				; ...
		or	FOUNDDEL, 1
		push	ds
		mov	ah, DELALL
		lds	di, CURBUF
		test	ss:ATTRIB, 1
		jnz	short DoDelete
		test	byte ptr [bx+0Bh], 1
		jz	short DoDelete
		pop	ds
		jmp	short DELNXT
; ---------------------------------------------------------------------------

DoDelete:				; ...
		call	REN_DEL_Check
		jnb	short DEL_SHARE_OK
		pop	ds
		jmp	short DELNXT
; ---------------------------------------------------------------------------

DEL_SHARE_OK:				; ...
		test	byte ptr [di+5], 40h
		jnz	short yesdirty
		call	INC_DIRTY_COUNT
		or	byte ptr [di+5], 40h

yesdirty:				; ...
		mov	[bx], ah
		mov	bx, [si]
		pop	ds
		or	FOUNDDEL, 10h
		cmp	bx, 2
		jb	short DELNXT
		cmp	bx, es:[bp+0Dh]
		ja	short DELNXT
		call	RELEASE
		jb	short No_fileJ
		call	FastOpen_Delete

DELNXT:					; ...
		les	bp, THISDPB
		call	GETENTRY
		jb	short No_fileJ
		call	NEXTENT
		jnb	short DELFILE
		les	bp, THISDPB
		mov	al, es:[bp+0]
		call	FLUSHBUF
		jb	short No_fileJ
		test	FOUNDDEL, 10h
		jz	short DelError
		test	ATTRIB,	8
		jz	short No_Set_Flag
		push	ax
		push	es
		push	di
		les	di, THISCDS
		mov	ah, es:[di]
		sub	ah, 'A'
		mov	VOLCHNG_FLAG, ah
		xor	bh, bh
		call	Set_Media_ID
		call	FATREAD_CDS
		pop	di
		pop	es
		pop	ax

No_Set_Flag:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

DelError:				; ...
		test	FOUNDDEL, 1
		jnz	short Del_access_errJ

No_fileJ:				; ...
		jmp	No_file
; ---------------------------------------------------------------------------

Del_access_errJ:			; ...
		jmp	Del_access_err
DOS_DELETE	endp


; =============== S U B	R O U T	I N E =======================================


REN_DEL_Check	proc near		; ...
		push	ds
		push	di
		push	ax
		push	bx
		push	si
		push	ss
		pop	es
		mov	di, ss:WFP_START
		mov	si, bx
		mov	ds, word ptr ss:CURBUF+2
		mov	bx, di
		add	bx, 2
		call	StrLen
		dec	cx
		add	di, cx
		call	SkipBack
		inc	di
		mov	ss:SAVE_BX, di
		call	PackName
		pop	si
		pop	bx
		push	bx
		push	si
		push	ss
		pop	ds
		call	ShCloseFile
		mov	word ptr THISSFT+2, ds
		mov	word ptr THISSFT, (offset RENAMEDMA+145h) ; AUXSTACK-SF_ENTRY.size
					; RENAMEDMA+(384-59)
		xor	ah, ah
		call	DOOPEN
		les	di, THISSFT
		mov	word ptr es:[di+2], 10h
		mov	word ptr es:[di], 1
		call	ShareEnter
		jb	short CheckDone
		les	di, THISSFT
		mov	word ptr es:[di], 0
		call	ShareEnd
		clc

CheckDone:				; ...
		les	bp, THISDPB
		pop	si
		pop	bx
		pop	ax
		pop	di
		pop	ds
		retn
REN_DEL_Check	endp


; =============== S U B	R O U T	I N E =======================================


FastOpen_Delete	proc near		; ...
		pushf
		push	si
		push	bx
		push	ax
		mov	si, ss:WFP_START
		mov	al, 3

fastinvoke:				; ...
		mov	bx, offset FastTable_2
		call	dword ptr [bx]
		pop	ax
		pop	bx
		pop	si
		popf
		retn
FastOpen_Delete	endp


; =============== S U B	R O U T	I N E =======================================


FastOpen_Rename	proc near		; ...
		pushf
		push	si
		push	di
		push	bx
		push	ax
		mov	si, ss:REN_WFP
		mov	di, offset NAME1
		mov	al, 6
		mov	bx, offset FastTable_2
		call	dword ptr [bx]
		pop	ax
		pop	bx
		pop	di
		pop	si
		popf
		retn
FastOpen_Rename	endp


; =============== S U B	R O U T	I N E =======================================


FastOpen_Update	proc near		; ...
		pushf
		push	si
		push	bx
		push	ax
		mov	al, 4
		jmp	short fastinvoke
FastOpen_Update	endp


; =============== S U B	R O U T	I N E =======================================


Fast_Dispatch	proc near		; ...
		mov	si, offset FastTable_2
		call	dword ptr ss:[si]
		retn
Fast_Dispatch	endp


; =============== S U B	R O U T	I N E =======================================


DOS_RENAME	proc near		; ...
		call	TestNet
		jnb	short LOCAL_RENAME
		mov	ax, 1111h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
					; SS = DS = DOS	CS, SDA	first filename pointer = offset	of fully-qualified old name
					; SDA CDS pointer -> current directory
					; Return: CF set on error
		retn
; ---------------------------------------------------------------------------

LOCAL_RENAME:				; ...
		mov	EXTERR_LOCUS, 2
		mov	si, WFP_START
		mov	di, REN_WFP
		mov	al, [si]
		mov	ah, [di]
		or	ax, 2020h
		cmp	al, ah
		jz	short SAMEDRV
		mov	ax, 11h
		stc
		retn
; ---------------------------------------------------------------------------

SAMEDRV:				; ...
		push	word ptr DMAADD+2
		push	word ptr DMAADD
		mov	word ptr DMAADD+2, ds
		mov	word ptr DMAADD, offset	RENAMEDMA
		mov	FOUND_DEV, 0
		call	ECritDisk
		call	DOS_SEARCH_FIRST
		jnb	short Check_Dev
		cmp	ax, 12h
		jnz	short GOTERR
		mov	ax, 2

GOTERR:					; ...
		stc

RENAME_POP:				; ...
		pop	word ptr DMAADD
		pop	word ptr DMAADD+2
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

Check_Dev:				; ...
		mov	ax, 5
		push	ds
		lds	si, DMAADD
		add	si, 21
		test	byte ptr [si+11], 10h
		jz	short notdir
		mov	si, REN_WFP
		call	check_PathLen2

notdir:					; ...
		pop	ds
		ja	short GOTERR
		cmp	FOUND_DEV, 0
		jnz	short GOTERR
		mov	si, bx
		add	si, 26
		call	REN_DEL_Check
		jnb	short REN_OK1
		mov	ax, 20h
		jmp	short RENAME_POP
; ---------------------------------------------------------------------------

REN_OK1:				; ...
		push	si
		lds	si, DMAADD
		add	si, 21
		test	byte ptr [si+11], 10h
		jz	short NOT_DIR1
		pop	si
		jmp	short SWAP_SOURCE
; ---------------------------------------------------------------------------

NOT_DIR1:				; ...
		pop	si
		call	FastOpen_Delete

SWAP_SOURCE:				; ...
		mov	ax, WFP_START
		mov	si, REN_WFP
		mov	WFP_START, si
		mov	REN_WFP, ax
		mov	CURR_DIR_END, 0FFFFh
		mov	word ptr CREATING, 0E5FFh
		call	GetPathNoSet
		jb	short NODEST
		or	ah, ah
		jns	short SAVEDEST

BAD_ACC:				; ...
		mov	ax, 5
		stc

RENAME_CLEAN:				; ...
		pushf
		push	ax
		mov	al, THISDRV
		call	FLUSHBUF
		pop	ax
		cmp	FAILERR, 0
		jnz	short BAD_ERR
		popf
		jmp	RENAME_POP
; ---------------------------------------------------------------------------

BAD_ERR:				; ...
		pop	ax
		mov	ax, 3
		jmp	GOTERR
; ---------------------------------------------------------------------------

NODEST:					; ...
		jnz	short BAD_PATH
		cmp	FAILERR, 0
		jnz	short BAD_PATH
		or	cl, cl
		jnz	short SAVEDEST

BAD_PATH:				; ...
		mov	ax, 3
		stc
		jmp	RENAME_POP
; ---------------------------------------------------------------------------

SAVEDEST:				; ...
		push	ss
		pop	es
		mov	di, offset NAME2
		mov	si, offset NAME1
		mov	cx, 11
		rep movsb
		mov	ax, DIRSTART
		mov	DESTSTART, ax

BUILDDEST:				; ...
		push	ss
		pop	es
		mov	bx, (offset RENAMEDMA+15h)
		mov	di, offset NAME1
		mov	si, offset NAME2
		mov	cx, 11
		call	NEW_RENAME
		mov	ATTRIB,	16h
		mov	CREATING, 0FFh
		call	DEVNAME
		jnb	short BAD_ACC
		mov	bx, DESTSTART
		les	bp, THISDPB
		call	SETDIRSRCH
		jb	short BAD_ACC
		call	SEARCH
		jnb	short BAD_ACC
		cmp	FAILERR, 0
		jnz	short BAD_ACCJ
		mov	ax, DESTSTART
		cmp	ax, word ptr RENAMEDMA+0Fh
		jz	short SIMPLE_RENAME
		mov	al, RENAMEDMA+20h
		test	al, 10h
		jnz	short BAD_ACCJ
		mov	ATTRIB,	al
		mov	word ptr THISSFT+2, ds
		mov	si, (offset RENAMEDMA+145h)
		mov	word ptr THISSFT, si
		mov	word ptr [si+2], 2
		xor	cx, cx
		call	RENAME_MAKE
		jnb	short GOT_DEST

BAD_ACCJ:				; ...
		jmp	BAD_ACC
; ---------------------------------------------------------------------------

GOT_DEST:				; ...
		push	bx
		les	di, THISSFT
		call	ShareEnd
		pop	bx
		les	di, CURBUF
		test	byte ptr es:[di+5], 40h
		jnz	short yesdirty
		call	INC_DIRTY_COUNT
		or	byte ptr es:[di+5], 40h

yesdirty:				; ...
		mov	di, bx
		add	di, 11
		mov	si, (offset RENAMEDMA+20h)
		mov	cx, 21
		rep movsb
		call	GET_SOURCE
		jb	short RENAME_OVER
		mov	di, bx
		mov	es, word ptr CURBUF+2
		mov	al, 0E5h
		stosb
		jmp	short DIRTY_IT
; ---------------------------------------------------------------------------

SIMPLE_RENAME:				; ...
		call	GET_SOURCE
		jb	short RENAME_OVER
		mov	di, bx
		mov	es, word ptr CURBUF+2
		mov	si, offset NAME1
		mov	cx, 11
		rep movsb

DIRTY_IT:				; ...
		mov	di, word ptr CURBUF
		test	byte ptr es:[di+5], 40h
		jnz	short Yesdirty2
		call	INC_DIRTY_COUNT
		or	byte ptr es:[di+5], 40h

Yesdirty2:				; ...
		push	si
		lds	si, DMAADD
		add	si, 21
		test	byte ptr [si+11], 10h
		jz	short NOT_DIR2
		call	FastOpen_Rename
		pop	si
		jmp	short NOT_DIRTY1
; ---------------------------------------------------------------------------

NOT_DIR2:				; ...
		pop	si

NOT_DIRTY1:				; ...
		mov	si, (offset RENAMEDMA+1)
		call	ECritDisk
		mov	CREATING, 0
		call	RENAME_NEXT
		jb	short RENAME_OVER
		lea	si, [bx+26]
		call	REN_DEL_Check
		jnb	short REN_OK2
		mov	ax, 20h
		jmp	RENAME_CLEAN
; ---------------------------------------------------------------------------

REN_OK2:				; ...
		mov	al, RENAMEDMA+20h
		test	al, 10h
		jz	short Ren_Directory
		call	FastOpen_Delete
		jmp	BUILDDEST
; ---------------------------------------------------------------------------

Ren_Directory:				; ...
		call	FastOpen_Rename
		jmp	BUILDDEST
; ---------------------------------------------------------------------------

RENAME_OVER:				; ...
		clc
		jmp	RENAME_CLEAN
DOS_RENAME	endp


; =============== S U B	R O U T	I N E =======================================


GET_SOURCE	proc near		; ...
		mov	bx, word ptr RENAMEDMA+0Fh
		les	bp, THISDPB
		call	SETDIRSRCH
		jb	short gs_ret_label
		call	STARTSRCH
		mov	ax, word ptr RENAMEDMA+0Dh
		call	GETENT

gs_ret_label:				; ...
		retn
GET_SOURCE	endp


; =============== S U B	R O U T	I N E =======================================


NEW_RENAME	proc near		; ...
		lodsb
		cmp	al, '?'
		jnz	short NOCHG
		mov	al, [bx]

NOCHG:					; ...
		stosb
		inc	bx
		loop	NEW_RENAME
		retn
NEW_RENAME	endp


; =============== S U B	R O U T	I N E =======================================


GET_FILE_INFO	proc near		; ...
		call	TestNet
		jnb	short LOCAL_INFO
		mov	ax, 110Fh
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
					; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	file attributes
		retn
; ---------------------------------------------------------------------------

LOCAL_INFO:				; ...
		call	ECritDisk
		mov	NoSetDir, 1
		call	Get_FAST_PATH
		jnb	short info_check_dev

NO_PATH:				; ...
		jnz	short bad_path1
		or	cl, cl
		jz	short bad_path1

info_no_file:				; ...
		mov	ax, 2

BadRet:					; ...
		stc

JustRet:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

bad_path1:				; ...
		mov	ax, 3
		jmp	short BadRet
; ---------------------------------------------------------------------------

info_check_dev:				; ...
		or	ah, ah
		js	short info_no_file
		cmp	word ptr CURBUF, 0FFFFh
		jnz	short not_root
		xor	ah, ah
		mov	al, 10h
		clc
		jmp	short JustRet
; ---------------------------------------------------------------------------

not_root:				; ...
		push	ds
		mov	ds, word ptr CURBUF+2
		mov	si, bx
		xor	bx, bx
		mov	di, bx
		mov	cx, [si+16h]
		mov	dx, [si+18h]
		xor	ah, ah
		mov	al, [si+0Bh]
		test	al, 10h
		jnz	short NO_SIZE
		mov	di, [si+1Ch]
		mov	bx, [si+1Eh]

NO_SIZE:				; ...
		pop	ds
		clc
		jmp	short JustRet
GET_FILE_INFO	endp


; =============== S U B	R O U T	I N E =======================================


SET_FILE_ATTRIBUTE proc	near		; ...
		test	ax, 0FFD8h
		jz	short set_look

_BAD_ACC:				; ...
		mov	EXTERR_LOCUS, 1
		mov	byte ptr EXTERR_ACT_CLASS+1, 7
		mov	byte ptr EXTERR_ACT_CLASS, 4
		mov	ax, 5
		stc
		retn
; ---------------------------------------------------------------------------

set_look:				; ...
		call	TestNet
		jnb	short LOCAL_SET
		push	ax
		mov	ax, 110Eh
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
					; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
					; SDA CDS pointer -> current directory
					; STACK: WORD new file attributes
					; Return: CF set on error
		pop	bx
		retn
; ---------------------------------------------------------------------------

LOCAL_SET:				; ...
		call	ECritDisk
		push	ax
		mov	NoSetDir, 1
		call	GETPATH
		jnb	short set_check_device
		pop	bx
		jmp	short NO_PATH
; ---------------------------------------------------------------------------

set_check_device:			; ...
		or	ah, ah
		jns	short set_check_share
		pop	ax
		call	LCritDisk
		jmp	short _BAD_ACC
; ---------------------------------------------------------------------------

set_check_share:			; ...
		pop	ax
		cmp	word ptr CURBUF, 0FFFFh
		jz	short cannot_set_root
		call	REN_DEL_Check
		jnb	short set_do
		mov	ax, 32
		jmp	short OK_BYE
; ---------------------------------------------------------------------------

cannot_set_root:			; ...
		mov	ax, 5
		stc
		jmp	short OK_BYE
; ---------------------------------------------------------------------------

set_do:					; ...
		les	di, CURBUF
		and	byte ptr es:[bx+0Bh], 0D8h
		or	es:[bx+0Bh], al
		test	byte ptr es:[di+5], 40h
		jnz	short yesdirty3
		call	INC_DIRTY_COUNT
		or	byte ptr es:[di+5], 40h

yesdirty3:				; ...
		mov	al, THISDRV
		push	dx
		push	di
		mov	ah, 0
		mov	dl, al
		mov	di, bx
		call	FastOpen_Update
		pop	di
		pop	dx
		call	FLUSHBUF
		jnb	short OK_BYE
		mov	ax, 2

OK_BYE:					; ...
		call	LCritDisk
		retn
SET_FILE_ATTRIBUTE endp


; =============== S U B	R O U T	I N E =======================================


Get_FAST_PATH	proc near		; ...
		or	ss:FastOpenFlg,	1
		call	GETPATH
		pushf
		and	ss:FastOpenFlg,	80h
		popf
		retn
Get_FAST_PATH	endp


; =============== S U B	R O U T	I N E =======================================


DOS_DUP		proc near		; ...
		mov	es, cs:DosDSeg
		les	di, es:THISSFT

DOS_Dup_Direct:				; ...
		call	IsSFTNet
		jnz	short DO_INC
		call	DEV_OPEN_SFT

DO_INC:					; ...
		inc	word ptr es:[di]
		retn
DOS_DUP		endp

; ---------------------------------------------------------------------------

DOS_CREATE:				; ...
		xor	ah, ah

Create_inter:				; ...
		test	al, 80h
		jnz	short AttErr
		test	al, 8
		jz	short NoReset
		or	DOS34_FLAG, 80h
		mov	al, 8

NoReset:				; ...
		or	al, 20h
		test	al, 50h
		jz	short ATT_OK

AttErr:					; ...
		mov	ax, 5
		mov	EXTERR_LOCUS, 1
		jmp	short SET_MKND_ERR
; ---------------------------------------------------------------------------

ATT_OK:					; ...
		les	di, THISSFT
		push	es
		les	si, THISCDS
		cmp	si, 0FFFFh
		jnz	short TEST_RE_NET
		pop	es
		test	EXTOPEN_ON, 1
		jz	short NOEXTOP

IFS_extopen:				; ...
		push	ax
		mov	ax, 112Eh
		int	2Fh		; Multiplex - DOS 4 IFSFUNC.EXE	- ???
					; SS = DS = DOS	CS, STACK: WORD	???   low byte = ???
					; Return: CF set on error
					; CF clear if successful
		pop	bx
		mov	EXTOPEN_ON, 0
		retn
; ---------------------------------------------------------------------------

NOEXTOP:				; ...
		push	ax
		mov	ax, 1118h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
					; ES:DI	-> uninitialized SFT, SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	name of	file
					; STACK: WORD file creation mode???
		pop	bx
		retn
; ---------------------------------------------------------------------------

TEST_RE_NET:				; ...
		test	word ptr es:[si+43h], 8000h
		pop	es
		jz	short LOCAL_CREATE
		call	Set_EXT_mode
		jb	short dochk
		or	word ptr es:[di+2], 2

dochk:					; ...
		test	EXTOPEN_ON, 1
		jnz	short IFS_extopen
		push	ax
		mov	ax, 1117h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
					; ES:DI	-> uninitialized SFT, SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	name of	file to	open
					; SDA CDS pointer -> current directory
					; Return: CF set on error
		pop	bx
		retn
; ---------------------------------------------------------------------------

LOCAL_CREATE:				; ...
		call	Set_EXT_mode
		jb	short setdone
		or	word ptr es:[di+2], 2

setdone:				; ...
		call	ECritDisk
		call	MakeNode
		jnb	short Create_ok
		mov	VOLCHNG_FLAG, 0FFh
		call	LCritDisk

SET_MKND_ERR:				; ...
		mov	bx, offset CRTERRTAB
		xlat	byte ptr cs:[bx]
		stc
		retn
; ---------------------------------------------------------------------------
CRTERRTAB	db 0, 5, 52h, 50h, 3, 5, 20h, 2	; ...
; ---------------------------------------------------------------------------

Create_ok:				; ...
		call	FastOpen_Delete
		mov	al, SATTRIB
		test	al, 8
		jz	short NoVolLabel
		les	di, THISCDS
		mov	ah, es:[di]
		sub	ah, 'A'
		mov	VOLCHNG_FLAG, ah
		mov	bh, 1
		call	Set_Media_ID
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk

NoVolLabel:				; ...
		mov	ax, 2
		les	di, THISSFT
		call	ShSU
		call	LCritDisk
		jmp	SET_SFT_MODE
; ---------------------------------------------------------------------------

DOS_Create_New:				; ...
		mov	ah, 1
		jmp	Create_inter

; =============== S U B	R O U T	I N E =======================================


Set_Media_ID	proc near		; ...
		push	ax
		push	es
		push	di
		inc	ah
		mov	bl, ah
		mov	al, 0Dh
		mov	cx, 866h
		mov	dx, offset FAKE_STACK_2F
		push	bx
		push	dx
		xor	bh, bh
		call	$IOCTL
		pop	dx
		pop	bx
		jb	short geterr
		or	bh, bh
		jz	short NoName
		mov	si, offset NAME1
		jmp	short doset
; ---------------------------------------------------------------------------

NoName:					; ...
		mov	si, offset NO_NAME_ID ;	"NO NAME    "

doset:					; ...
		mov	di, dx
		add	di, 6
		push	ss
		pop	ds
		push	ss
		pop	es
		mov	cx, 11
		rep movsb
		mov	cx, 846h
		mov	al, 0Dh
		xor	bh, bh
		call	$IOCTL

geterr:					; ...
		push	ss
		pop	ds
		pop	di
		pop	es
		pop	ax
		retn
Set_Media_ID	endp


; =============== S U B	R O U T	I N E =======================================


Set_EXT_mode	proc near		; ...
		test	ss:EXTOPEN_ON, 1
		jz	short NOTEX
		push	ax
		mov	ax, ss:SAVE_BX
		or	es:[di+2], ax
		pop	ax
		stc

NOTEX:					; ...
		retn
Set_EXT_mode	endp


; =============== S U B	R O U T	I N E =======================================


DOS_OPEN	proc near		; ...
		mov	NoSetDir, 0
		call	Check_Access_AX
		jb	short do_ret_label
		les	di, THISSFT
		xor	ah, ah
		mov	es:[di+2], al
		push	es
		les	si, THISCDS
		cmp	si, 0FFFFh
		jnz	short TEST_RE_NET1
		pop	es
		test	EXTOPEN_ON, 1
		jz	short _NOEXTOP

_IFS_extopen:				; ...
		mov	al, byte ptr SAVE_BX
		push	ax
		mov	ax, 112Eh
		int	2Fh		; Multiplex - DOS 4 IFSFUNC.EXE	- ???
					; SS = DS = DOS	CS, STACK: WORD	???   low byte = ???
					; Return: CF set on error
					; CF clear if successful
		pop	bx
		mov	EXTOPEN_ON, 0

do_ret_label:				; ...
		retn
; ---------------------------------------------------------------------------

_NOEXTOP:				; ...
		test	DOS_FLAG, 1
		jz	short not_exec_open
		test	byte ptr DOS34_FLAG+1, 8
		jz	short not_exec_open
		mov	al, 23h	; '#'

not_exec_open:				; ...
		push	ax
		mov	ax, 1116h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - OPEN	EXISTING REMOTE	FILE
					; ES:DI	-> uninitialized SFT, SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	name of	file to	open
					; STACK: WORD file open	mode
					; Return: CF set on error
		pop	bx
		retn
; ---------------------------------------------------------------------------

TEST_RE_NET1:				; ...
		test	word ptr es:[si+43h], 8000h
		pop	es
		jz	short LOCAL_OPEN
		test	EXTOPEN_ON, 1
		jnz	short _IFS_extopen
		jmp	short _NOEXTOP
; ---------------------------------------------------------------------------

LOCAL_OPEN:				; ...
		call	ECritDisk
		or	FastOpenFlg, 5
		call	GETPATH
		jnb	short Open_found
		jnz	short bad_path2
		or	cl, cl
		jz	short bad_path2

OpenFNF:
		mov	ax, 2

OpenBadRet:				; ...
		and	ss:FastOpenFlg,	80h
		stc
		call	LCritDisk
		jmp	Clear_FastOpen
; ---------------------------------------------------------------------------

bad_path2:				; ...
		mov	ax, 3
		jmp	short OpenBadRet
; ---------------------------------------------------------------------------

Open_Bad_Access:			; ...
		mov	ax, 5
		jmp	short OpenBadRet
; ---------------------------------------------------------------------------

Open_found:				; ...
		jz	short Open_Bad_Access
		or	ah, ah
		js	short open_ok
		mov	es, word ptr CURBUF+2
		mov	al, es:[bx+0Bh]
		test	al, 8
		jnz	short Open_Bad_Access
		test	al, 1
		jz	short open_ok
		push	ds
		push	si
		lds	si, THISSFT
		mov	cx, [si+2]
		test	cx, 8000h
		jnz	short ResetAccess
		mov	dl, cl
		and	dl, 0F0h
		cmp	dl, 70h	; 'p'
		jnz	short NormalOpen

ResetAccess:				; ...
		and	cx, 0FFF0h
		mov	[si+2],	cx
		jmp	short FillSFT
; ---------------------------------------------------------------------------

NormalOpen:				; ...
		and	cl, 0Fh
		cmp	cl, 0
		jz	short FillSFT
		pop	si
		pop	ds
		jmp	short Open_Bad_Access
; ---------------------------------------------------------------------------

FillSFT:				; ...
		pop	si
		pop	ds

open_ok:				; ...
		call	DOOPEN
		and	ss:FastOpenFlg,	80h
		call	DO_SHARE_CHECK
		jnb	short SHARE_OK
		call	LCritDisk
		jmp	short Clear_FastOpen
; ---------------------------------------------------------------------------

SHARE_OK:				; ...
		mov	ax, 3
		les	di, THISSFT
		call	ShSU
		call	LCritDisk

SET_SFT_MODE:				; ...
		les	di, THISSFT
		call	DEV_OPEN_SFT
		test	word ptr es:[di+2], 8000h
		jz	short Clear_FastOpen
		mov	ax, CurrentPDB
		mov	es:[di+31h], ax

Clear_FastOpen:				; ...
		retn
DOS_OPEN	endp


; =============== S U B	R O U T	I N E =======================================


SHARE_ERROR	proc near		; ...
		test	word ptr es:[di+2], 8000h
		jnz	short _HARD_ERR
		mov	cl, es:[di+2]
		and	cl, 0F0h
		cmp	cl, 0
		jnz	short _NO_HARD_ERR

_HARD_ERR:				; ...
		call	SHARE_VIOLATION
		jnb	short Clear_FastOpen

_NO_HARD_ERR:				; ...
		mov	ax, 20h	; ' '
		stc
		retn
SHARE_ERROR	endp


; =============== S U B	R O U T	I N E =======================================


DO_SHARE_CHECK	proc near		; ...
		call	ECritDisk

OPN_RETRY:				; ...
		mov	cx, RetryCount

OpenShareRetry:				; ...
		push	cx
		call	SHARE_CHECK
		pop	cx
		jnb	short Share_Ok2
		call	Idle
		loop	OpenShareRetry
		les	di, THISSFT
		call	SHARE_ERROR
		jnb	short OPN_RETRY

Share_Ok2:				; ...
		call	LCritDisk
		retn
DO_SHARE_CHECK	endp


; =============== S U B	R O U T	I N E =======================================


Check_Access_AX	proc near		; ...
		mov	OPEN_ACCESS, al
		push	bx
		mov	bl, al
		and	bl, 0F0h
		cmp	FSHARING, 0FFh
		jnz	short CheckShareMode
		cmp	bl, 70h	; 'p'
		jz	short CheckAccessMode

CheckShareMode:				; ...
		cmp	bl, 40h	; '@'
		ja	short Make_Bad_Access

CheckAccessMode:			; ...
		mov	bl, al
		and	bl, 0Fh
		cmp	bl, 2
		ja	short Make_Bad_Access
		pop	bx
		clc
		retn
; ---------------------------------------------------------------------------

Make_Bad_Access:			; ...
		mov	ax, 0Ch
		pop	bx
		stc
		retn
Check_Access_AX	endp


; =============== S U B	R O U T	I N E =======================================


DISK_INFO	proc near		; ...
		call	TestNet
		jnb	short LOCAL_DSK_INFO
		mov	ax, 110Ch
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
					; ES:DI	-> current directory
					; Return: AL = sectors per cluster, BX = total clusters
					; CX = bytes per sector, DX = number of	available clusters
		retn
; ---------------------------------------------------------------------------

LOCAL_DSK_INFO:				; ...
		mov	EXTERR_LOCUS, 2
		call	ECritDisk
		call	FATREAD_CDS
		jb	short CRIT_LEAVE
		mov	bx, 2
		call	UNPACK
		jb	short CRIT_LEAVE
		lds	si, CURBUF
		mov	ah, [si+20]
		push	ss
		pop	ds
		mov	cx, es:[bp+0Dh]
		mov	dx, es:[bp+1Fh]
		cmp	dx, 0FFFFh
		jz	short DoScan
		cmp	dx, cx
		jb	short GotVal

DoScan:					; ...
		xor	dx, dx
		dec	cx

SCANFREE:				; ...
		call	UNPACK
		jb	short CRIT_LEAVE
		jnz	short NOTFREECLUS
		inc	dx

NOTFREECLUS:				; ...
		inc	bx
		loop	SCANFREE
		dec	bx

ReturnVals:				; ...
		dec	bx
		mov	al, es:[bp+4]
		inc	al
		mov	cx, es:[bp+2]
		mov	es:[bp+1Fh], dx
		clc

CRIT_LEAVE:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

GotVal:					; ...
		mov	bx, cx
		jmp	short ReturnVals
DISK_INFO	endp


; =============== S U B	R O U T	I N E =======================================


DOS_SEARCH_FIRST proc near		; ...

; FUNCTION CHUNK AT 6C8B SIZE 0000001F BYTES

		les	di, THISCDS
		cmp	di, 0FFFFh
		jnz	short TEST_RE_NET2
		mov	ax, 1119h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - ???
		retn
; ---------------------------------------------------------------------------

TEST_RE_NET2:				; ...
		test	word ptr es:[di+43h], 8000h
		jz	short LOCAL_SEARCH_FIRST
		mov	ax, 111Bh
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - FINDFIRST
					; SS = DS = DOS	CS, [DTA] = uninitialized 21-byte findfirst search data
					; SDA first filename pointer ->	fully-qualified	search template
					; SDA CDS pointer -> current directory
					; Return: CF set on error
		retn
; ---------------------------------------------------------------------------

LOCAL_SEARCH_FIRST:			; ...
		call	ECritDisk
		test	DOS34_FLAG, 400h
		jz	short NOFN
		or	FastOpenFlg, 1

NOFN:					; ...
		mov	NoSetDir, 1
		call	CHECK_QUESTION
		jnb	short norm_GETPATH
		and	FastOpenFlg, 80h

norm_GETPATH:				; ...
		call	GETPATH
		jnb	short find_check_dev
		jnz	short bad_path3
		or	cl, cl
		jz	short bad_path3
DOS_SEARCH_FIRST endp

; START	OF FUNCTION CHUNK FOR DOS_SEARCH_NEXT

find_no_more:				; ...
		mov	ax, 12h

BadBye:					; ...
		and	ss:FastOpenFlg,	80h
		stc
		call	LCritDisk
		retn
; END OF FUNCTION CHUNK	FOR DOS_SEARCH_NEXT
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DOS_SEARCH_FIRST

bad_path3:				; ...
		mov	ax, 3
		jmp	short BadBye
; ---------------------------------------------------------------------------

find_check_dev:				; ...
		or	ah, ah
		jns	short found_entry
		mov	LASTENT, 0FFFFh
		inc	FOUND_DEV

found_entry:				; ...
		les	di, DMAADD
		mov	si, WFP_START
		lodsb
		sub	al, 40h	; '@'
		stosb
; END OF FUNCTION CHUNK	FOR DOS_SEARCH_FIRST
; START	OF FUNCTION CHUNK FOR DOS_SEARCH_NEXT

found_it:				; ...
		les	di, DMAADD
		inc	di
		push	ds
		test	FastOpenFlg, 10h
		jz	short notfast
		mov	si, bx
		mov	ds, word ptr CURBUF+2
		jmp	short movmov
; ---------------------------------------------------------------------------

notfast:				; ...
		mov	si, offset NAME1

movmov:					; ...
		movsb
		cmp	byte ptr es:[di-1], 5
		jnz	short NOTKANJB
		mov	byte ptr es:[di-1], 0E5h ; ''

NOTKANJB:				; ...
		mov	cx, 10
		rep movsb
		pop	ds
		mov	al, ATTRIB
		stosb
		push	ax
		mov	ax, LASTENT
		stosw
		mov	ax, DIRSTART
		stosw
		add	di, 4
		pop	ax
		or	ah, ah
		js	short DOSREL
		cmp	word ptr CURBUF, 0FFFFh
		jnz	short OKSTORE
		test	FastOpenFlg, 10h
		jnz	short OKSTORE
		mov	word ptr es:[di-8], 0FFFFh
		jmp	find_no_more
; ---------------------------------------------------------------------------

OKSTORE:				; ...
		mov	ds, word ptr CURBUF+2

DOSREL:					; ...
		mov	si, bx
		mov	cx, 32
		mov	ax, di
		rep movsb
		mov	di, ax
		cmp	byte ptr es:[di], 5
		jnz	short NO05
		mov	byte ptr es:[di], 0E5h

NO05:					; ...
		and	ss:FastOpenFlg,	80h
		push	ss
		pop	ds
		clc
		call	LCritDisk
		retn
; END OF FUNCTION CHUNK	FOR DOS_SEARCH_NEXT

; =============== S U B	R O U T	I N E =======================================


DOS_SEARCH_NEXT	proc near		; ...

; FUNCTION CHUNK AT 6C7D SIZE 0000000E BYTES
; FUNCTION CHUNK AT 6CAA SIZE 0000007D BYTES

		les	di, DMAADD
		mov	al, es:[di]
		test	al, 80h
		jz	short LOCAL_SEARCH_NEXT
		mov	ax, 111Ch
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - FINDNEXT
					; SS = DS = DOS	CS, [DTA] = 21-byte findfirst search data
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_SEARCH_NEXT:			; ...
		mov	EXTERR_LOCUS, 2
		call	ECritDisk
		mov	word ptr THISCDS, offset DUMMYCDS
		mov	word ptr THISCDS+2, ds
		add	al, 40h	; '@'
		call	InitCDS
		jb	short No_files
		les	di, THISCDS
		les	bp, es:[di+45h]
		call	GOTDPB
		mov	al, es:[bp+0]
		mov	THISDRV, al
		mov	word ptr CREATING, 0E500h
		mov	NoSetDir, 1
		lds	si, DMAADD
		lodsb

RENAME_NEXT:				; ...
		push	ss
		pop	es
		mov	di, offset NAME1
		mov	cx, 11
		rep movsb
		lodsb
		mov	ss:ATTRIB, al
		lodsw
		or	ax, ax
		jns	short cont_load

No_files:				; ...
		jmp	find_no_more
; ---------------------------------------------------------------------------

cont_load:				; ...
		push	ax
		lodsw
		mov	bx, ax
		push	ss
		pop	ds
		les	bp, THISDPB
		call	SETDIRSRCH
		jnb	short SEARCH_GOON
		pop	ax
		jmp	short No_files
; ---------------------------------------------------------------------------

SEARCH_GOON:				; ...
		call	STARTSRCH
		pop	ax
		call	GETENT
		jb	short No_files
		call	NEXTENT
		jb	short No_files
		xor	ah, ah
		jmp	found_it
DOS_SEARCH_NEXT	endp


; =============== S U B	R O U T	I N E =======================================


CHECK_QUESTION	proc near		; ...
		push	ss
		pop	ds
		mov	si, ss:WFP_START

getnext:				; ...
		lodsb
		or	al, al
		jz	short NO_Question
		cmp	al, '?'
		jnz	short getnext
		stc

NO_Question:				; ...
		retn
CHECK_QUESTION	endp


; =============== S U B	R O U T	I N E =======================================


DOS_ABORT	proc near		; ...
		mov	es, ss:CurrentPDB
		mov	cx, word ptr es:32h ; [ES:PDB.JFN_Length]

reset_free_jfn:				; ...
		mov	bx, cx
		push	cx
		dec	bx
		call	$CLOSE
		pop	cx
		loop	reset_free_jfn
		push	ss
		pop	ds
		mov	ax, 111Dh
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CLOSE ALL REMOTE FILES FOR PROCESS
					; DS???, SS = DOS CS
		call	MFTCloseP
		les	di, ss:SFTFCB
		mov	cx, es:[di+4]
		jcxz	short FCBScanDone
		lea	di, [di+6]
		mov	ax, ss:PROC_ID

FCBTest:				; ...
		cmp	es:[di+31h], ax
		jnz	short FCBNext
		mov	word ptr es:[di], 0

FCBNext:				; ...
		add	di, 59
		loop	FCBTest

FCBScanDone:				; ...
		xor	bx, bx

Scan:					; ...
		push	bx
		call	SFFromSFN
		pop	bx
		jnb	short Scan1
		retn
; ---------------------------------------------------------------------------

Scan1:					; ...
		cmp	word ptr es:[di], 0FFFFh
		jnz	short scan_next
		mov	ax, ss:PROC_ID
		cmp	es:[di+31h], ax
		jnz	short scan_next
		mov	ax, ss:USER_ID
		cmp	es:[di+2Fh], ax
		jnz	short scan_next
		mov	word ptr es:[di], 0

scan_next:				; ...
		inc	bx
		jmp	short Scan
DOS_ABORT	endp


; =============== S U B	R O U T	I N E =======================================


DOS_CLOSE	proc near		; ...
		les	di, THISSFT
		mov	bx, es:[di+5]
		test	bx, 8000h
		jz	short LocalClose
		mov	ax, 1106h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE	FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LocalClose:				; ...
		call	ECritDisk
		call	SetSFTTimes
		call	FREE_SFT
		push	ss
		pop	ds
		push	ax
		push	bx
		call	ShareEnd
		pop	bx
		pop	ax

CloseEntry:				; ...
		push	ax
		test	bx, 0C0h
		jz	short rdir
		jmp	FREE_SFT_OK
; ---------------------------------------------------------------------------

rdir:					; ...
		call	DirFromSFT
		mov	al, 5
		jnb	short clook
		jmp	CloseFinish
; ---------------------------------------------------------------------------

clook:					; ...
		push	di
		push	si
		lea	si, [si+20h]
		call	XCHGP
		call	MetaCompare
		call	XCHGP
		pop	si
		pop	di
		jz	short CLOSE_GO
		mov	di, si
		push	ds
		pop	es
		push	ss
		pop	ds
		stc
		mov	al, 2
		jmp	CloseFinish
; ---------------------------------------------------------------------------

CLOSE_GO:				; ...
		test	word ptr [si+2], 8000h
		jz	short nofcb
		mov	ch, es:[di+0Bh]
		mov	al, [si+4]
		mov	ss:ATTRIB, al
		jmp	short setattr
; ---------------------------------------------------------------------------

nofcb:					; ...
		mov	al, [si+4]
		mov	es:[di+0Bh], al

setattr:				; ...
		or	byte ptr es:[di+0Bh], 20h
		mov	ax, es:[di+1Ah]
		mov	ss:OLD_FIRSTCLUS, ax
		mov	ax, [si+0Bh]
		mov	es:[di+1Ah], ax
		mov	ax, [si+11h]
		mov	es:[di+1Ch], ax
		mov	ax, [si+13h]
		mov	es:[di+1Eh], ax
		mov	ax, [si+0Fh]
		mov	es:[di+18h], ax
		mov	ax, [si+0Dh]
		mov	es:[di+16h], ax
		test	byte ptr es:[bx+5], 40h
		jnz	short yesdirty4
		call	INC_DIRTY_COUNT
		or	byte ptr es:[bx+5], 40h

yesdirty4:				; ...
		push	ds
		push	si
		mov	cx, [si+0Bh]
		mov	al, ss:THISDRV
		push	dx
		mov	ah, 0
		mov	dl, al
		or	cx, cx
		jnz	short do_update2
		mov	ah, 3
		mov	di, [si+1Bh]
		mov	cx, [si+1Dh]
		mov	dh, [si+1Fh]
		jmp	short do_update
; ---------------------------------------------------------------------------

do_update2:				; ...
		cmp	cx, ss:OLD_FIRSTCLUS
		jz	short do_update
		mov	ah, 2
		mov	cx, ss:OLD_FIRSTCLUS

do_update:				; ...
		push	ss
		pop	ds
		call	FastOpen_Update
		pop	dx
		call	FLUSHBUF
		pop	di
		pop	es
		mov	al, 5
		jb	short CloseFinish

FREE_SFT_OK:				; ...
		clc

CloseFinish:				; ...
		pushf
		call	DEV_CLOSE_SFT
		popf
		pop	cx
		pushf
		dec	cx
		jnz	short NoFree
		mov	es:[di], cx

NoFree:					; ...
		call	LCritDisk
		popf
		retn
DOS_CLOSE	endp


; =============== S U B	R O U T	I N E =======================================


FREE_SFT	proc near		; ...
		pushf
		mov	ax, es:[di]
		dec	ax
		jnz	short SetCount
		dec	ax

SetCount:				; ...
		xchg	ax, es:[di]
		popf
		retn
FREE_SFT	endp


; =============== S U B	R O U T	I N E =======================================


DirFromSFT	proc near		; ...
		mov	EXTERR_LOCUS, 2
		push	es
		push	di
		mov	dx, es:[di+1Dh]
		mov	HIGH_SECTOR, dx
		mov	dx, es:[di+1Bh]
		push	HIGH_SECTOR
		push	dx
		call	FATREAD_SFT
		pop	dx
		pop	HIGH_SECTOR
		jb	short PopDone
		xor	al, al
		mov	ALLOWED, 18h
		call	GETBUFFR
		jb	short PopDone
		pop	si
		pop	ds
		les	di, ss:CURBUF
		or	byte ptr es:[di+5], 4
		mov	bx, di
		lea	di, [di+14h]
		mov	al, 20h	; ' '
		mul	byte ptr [si+1Fh]
		add	di, ax
		retn
; ---------------------------------------------------------------------------

PopDone:				; ...
		pop	di
		pop	es

PopDone_retn:				; ...
		retn
DirFromSFT	endp


; =============== S U B	R O U T	I N E =======================================


DOS_COMMIT	proc near		; ...
		les	di, THISSFT
		mov	bx, es:[di+5]
		test	bx, 0C0h
		jnz	short PopDone_retn
		test	bx, 8000h
		jz	short LOCAL_COMMIT
		mov	ax, 1107h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_COMMIT:				; ...
		call	ECritDisk
		call	ECritDisk
		call	SetSFTTimes
		mov	ax, 0FFFFh
		call	CloseEntry
		pushf
		call	DEV_OPEN_SFT
		popf
		call	LCritDisk

localcommit_retn:			; ...
		retn
DOS_COMMIT	endp


; =============== S U B	R O U T	I N E =======================================


SetSFTTimes	proc near		; ...
		test	bx, 0C0h
		jnz	short localcommit_retn
		test	bx, 4000h
		jnz	short localcommit_retn
		push	ax
		push	bx
		call	DATE16
		mov	es:[di+0Fh], ax
		mov	es:[di+0Dh], dx
		xor	ax, ax
		call	ShSU
		pop	bx
		pop	ax
		retn
SetSFTTimes	endp

; ---------------------------------------------------------------------------

DOS_MKDIR:				; ...
		call	TestNet
		jnb	short LOCAL_MKDIR
		mov	ax, 1103h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - MAKE	REMOTE DIRECTORY
					; SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	directory name
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DOS_CHDIR

NODEACCERRJ:				; ...
		mov	ax, 5

_BadRet:				; ...
		stc
		call	LCritDisk
		retn
; END OF FUNCTION CHUNK	FOR DOS_CHDIR
; ---------------------------------------------------------------------------

PATHNFJ:				; ...
		call	LCritDisk
		jmp	SET_MKND_ERR
; ---------------------------------------------------------------------------

LOCAL_MKDIR:				; ...
		call	ECritDisk
		mov	word ptr THISSFT+2, ss
		mov	word ptr THISSFT, offset RENBUF
		mov	word ptr RENBUF+33h, 0 ; [RENBUF+SF_ENTRY.sf_MFT]
		mov	al, 10h
		call	MakeNode
		jb	short PATHNFJ
		cmp	ax, 3
		jz	short NODEACCERRJ
		les	bp, THISDPB
		lds	di, CURBUF
		sub	si, di
		push	si
		push	word ptr [di+8]
		push	word ptr [di+6]
		push	ss
		pop	ds
		push	DIRSTART
		xor	ax, ax
		mov	DIRSTART, ax
		call	NEWDIR
		jb	short NODEEXISTSPOPDEL
		call	GETENT
		jb	short NODEEXISTSPOPDEL
		les	di, CURBUF
		test	byte ptr es:[di+5], 40h
		jnz	short yesdirty5
		call	INC_DIRTY_COUNT
		or	byte ptr es:[di+5], 40h

yesdirty5:				; ...
		add	di, 20
		mov	ax, 202Eh
		mov	dx, DIRSTART
		call	SETDOTENT
		mov	ax, 2E2Eh
		pop	dx
		call	SETDOTENT
		les	bp, THISDPB
		mov	ALLOWED, 18h
		pop	dx
		pop	HIGH_SECTOR
		xor	al, al
		call	GETBUFFR
		jb	short NODEEXISTSP
		mov	dx, DIRSTART
		lds	di, CURBUF
		or	byte ptr [di+5], 4
		pop	si
		add	si, di
		mov	[si], dx
		xor	dx, dx
		mov	[si+2],	dx
		mov	[si+4],	dx

DIRUP:					; ...
		test	byte ptr [di+5], 40h
		jnz	short yesdirty6
		call	INC_DIRTY_COUNT
		or	byte ptr [di+5], 40h

yesdirty6:				; ...
		push	ss
		pop	ds
		mov	al, es:[bp+0]
		call	FLUSHBUF
		mov	ax, 5
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

NODEEXISTSPOPDEL:			; ...
		pop	dx
		pop	dx
		pop	HIGH_SECTOR
		les	bp, THISDPB
		mov	ALLOWED, 18h
		xor	al, al
		call	GETBUFFR
		jb	short NODEEXISTSP
		lds	di, CURBUF
		or	byte ptr [di+5], 4
		pop	si
		add	si, di
		sub	si, 1Ah
		mov	byte ptr [si], 0E5h ; ''
		call	DIRUP

NODEEXISTS:				; ...
		jmp	NODEACCERRJ
; ---------------------------------------------------------------------------

NODEEXISTSP:				; ...
		pop	si
		jmp	short NODEEXISTS

; =============== S U B	R O U T	I N E =======================================


DOS_CHDIR	proc near		; ...

; FUNCTION CHUNK AT 6FE5 SIZE 00000008 BYTES
; FUNCTION CHUNK AT 714E SIZE 00000095 BYTES

		call	TestNet
		jnb	short LOCAL_CHDIR
		mov	ax, 1105h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CHDIR
					; SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	directory name
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_CHDIR:				; ...
		call	ECritDisk
		test	word ptr es:[di+43h], 2000h
		jz	short nojoin
		mov	word ptr es:[di+49h], 0FFFFh

nojoin:					; ...
		mov	NoSetDir, 0
		mov	SATTRIB, 16h
		or	FastOpenFlg, 1
		call	GETPATH
		pushf
		and	FastOpenFlg, 80h
		popf
		mov	ax, 3
		jb	short ChDirDone
		jnz	short NOTDIRPATH
		mov	cx, DIRSTART
		clc

ChDirDone:				; ...
		call	LCritDisk
		retn
DOS_CHDIR	endp


; =============== S U B	R O U T	I N E =======================================


DOS_RMDIR	proc near		; ...
		call	TestNet
		jnb	short LOCAL_RMDIR
		mov	ax, 1101h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
					; SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	directory name
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_RMDIR:				; ...
		call	ECritDisk
		mov	NoSetDir, 0
		mov	SATTRIB, 16h
		call	GETPATH
		jb	short NOPATH
		jnz	short NOTDIRPATH
		mov	di, DIRSTART
		or	di, di
		jnz	short rmdir_get_buf
		jmp	short NOTDIRPATH
; ---------------------------------------------------------------------------

NOPATH:					; ...
		mov	ax, 3
		jmp	_BadRet
DOS_RMDIR	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DOS_CHDIR

NOTDIRPATHPOP:				; ...
		pop	ax
		pop	ax

NOTDIRPATHPOP2:				; ...
		pop	ax

NOTDIRPATH:				; ...
		jmp	NODEACCERRJ
; ---------------------------------------------------------------------------

rmdir_get_buf:				; ...
		lds	di, CURBUF
		sub	bx, di
		push	bx
		push	word ptr [di+8]
		push	word ptr [di+6]
		push	ss
		pop	ds
		push	ss
		pop	es
		mov	di, offset NAME1
		mov	al, '?'
		mov	cx, 11
		rep stosb
		xor	al, al
		stosb
		call	STARTSRCH
		call	GETENTRY
		jb	short NOTDIRPATHPOP
		mov	ds, word ptr CURBUF+2
		mov	si, bx
		lodsw
		cmp	ax, 202Eh
		jnz	short NOTDIRPATHPOP
		add	si, 30
		lodsw
		cmp	ax, 2E2Eh
		jnz	short NOTDIRPATHPOP
		push	ss
		pop	ds
		mov	LASTENT, 2
		call	GETENTRY
		jb	short NOTDIRPATHPOP
		mov	ATTRIB,	16h
		call	SRCH
		jnb	short NOTDIRPATHPOP
		cmp	FAILERR, 0
		jnz	short NOTDIRPATHPOP
		les	bp, THISDPB
		mov	bx, DIRSTART
		call	RELEASE
		jb	short NOTDIRPATHPOP
		pop	dx
		pop	HIGH_SECTOR
		mov	ALLOWED, 18h
		xor	al, al
		call	GETBUFFR
		jb	short NOTDIRPATHPOP2
		lds	di, CURBUF
		or	byte ptr [di+5], 4
		pop	bx
		add	bx, di
		mov	byte ptr [bx], 0E5h ; ''
		push	ds
		push	ss
		pop	ds
		call	FastOpen_Delete
		pop	ds
		jmp	DIRUP
; END OF FUNCTION CHUNK	FOR DOS_CHDIR

; =============== S U B	R O U T	I N E =======================================


SWAPBACK	proc near		; ...
		mov	CONSWAP, 0
		retn
SWAPBACK	endp


; =============== S U B	R O U T	I N E =======================================


SWAPCON		proc near		; ...
		mov	CONSWAP, 1
		push	ax
		mov	ax, word ptr THISSFT
		mov	word ptr CONSFT, ax
		mov	ax, word ptr THISSFT+2
		mov	word ptr CONSFT+2, ax
		pop	ax
		retn
SWAPCON		endp


; =============== S U B	R O U T	I N E =======================================


DOS_READ	proc near		; ...
		les	di, THISSFT
		mov	al, es:[di+2]
		and	al, 0Fh
		cmp	al, 1
		jnz	short READ_NO_MODE
		jmp	SET_ACC_ERR
; ---------------------------------------------------------------------------

READ_NO_MODE:				; ...
		call	SETUP
		jcxz	short NoIORet
		call	IsSFTNet
		jz	short LOCAL_READ
		mov	ax, 1108h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - READ	FROM REMOTE FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; CX = number of bytes,	SS = DOS CS, SDA DTA field -> user buffer
					; Return: CF set on error, CX =	bytes read
		retn
; ---------------------------------------------------------------------------

NoIORet:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

LOCAL_READ:				; ...
		test	byte ptr es:[di+5], 80h
		jnz	short READDEV
		mov	EXTERR_LOCUS, 2
		call	ECritDisk
		call	DISKREAD

critexit:
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

READDEV:				; ...
		mov	EXTERR_LOCUS, 4
		mov	bl, es:[di+5]
		les	di, DMAADD
		test	bl, 40h
		jz	short ENDRDDEVJ3
		test	bl, 4
		jz	short TESTRAW
		xor	al, al

ENDRDDEVJ3:				; ...
		jmp	ENDRDDEVJ2
; ---------------------------------------------------------------------------

TESTRAW:				; ...
		test	bl, 20h
		jnz	short DVRDRAW
		test	bl, 1
		jz	short NOTRDCON
		jmp	READCON
; ---------------------------------------------------------------------------

DVRDRAW:				; ...
		push	es
		pop	ds
		test	ss:IsWin386, 1
		jz	short ReadRawRetry
		test	bl, 1
		jz	short ReadRawRetry
		jmp	do_polling
; ---------------------------------------------------------------------------

ReadRawRetry:				; ...
		mov	bx, di
		xor	ax, ax
		mov	dx, ax
		call	SETREAD
		push	ds
		lds	si, ss:THISSFT
		call	DEVIOCALL
		mov	dx, di
		mov	ah, 86h	; ''
		mov	di, ss:DEVCALL_REQSTAT
		or	di, di
		jns	short CRDROK
		call	CHARHARD
		mov	di, dx
		add	di, word ptr ss:CALLBPB
		sub	cx, word ptr ss:CALLBPB
		or	al, al
		jz	short CRDROK
		cmp	al, 3
		jz	short CRDFERR
		pop	ds
		jmp	short ReadRawRetry
; ---------------------------------------------------------------------------

CRDFERR:				; ...
		pop	di

DEVIOFERR:				; ...
		les	di, ss:THISSFT
		jmp	SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

CRDROK:					; ...
		pop	di
		mov	di, dx
		add	di, word ptr ss:CALLBPB
		jmp	short ENDRDDEVJ3
; ---------------------------------------------------------------------------

NOTRDCON:				; ...
		mov	ax, es
		mov	ds, ax
		mov	bx, di
		xor	dx, dx
		mov	ax, dx
		push	cx
		mov	cx, 1
		call	SETREAD
		pop	cx
		lds	si, ss:THISSFT
		lds	si, [si+7]

DVRDLP:					; ...
		call	DSKSTATCHK
		call	DEVIOCALL2
		push	di
		mov	ah, 86h
		mov	di, ss:DEVCALL_REQSTAT
		or	di, di
		jns	short CRDOK
		call	CHARHARD
		pop	di
		mov	word ptr ss:CALLBPB, 1
		cmp	al, 1
		jz	short DVRDLP
		cmp	al, 3
		jz	short DEVIOFERR
		xor	al, al
		jmp	short DVRDIGN
; ---------------------------------------------------------------------------

CRDOK:					; ...
		pop	di
		cmp	word ptr ss:CALLBPB, 1 ; [SS:CALLSCNT]
		jnz	short ENDRDDEVJ2
		push	ds
		mov	ds, word ptr ss:CALLBR+2 ; [SS:CALLXAD+2]
		mov	al, [di]
		pop	ds

DVRDIGN:				; ...
		inc	word ptr ss:CALLBR ; [SS:CALLXAD]
		mov	ss:DEVCALL_REQSTAT, 0
		inc	di
		cmp	al, 1Ah
		jz	short ENDRDDEVJ2
		cmp	al, 0Dh
		loopne	DVRDLP
		inc	ax

ENDRDDEVJ2:				; ...
		jmp	ENDRDDEV
; ---------------------------------------------------------------------------

do_polling:				; ...
		mov	bx, di
		xor	ax, ax
		mov	dx, ax
		call	SETREAD

do_io:					; ...
		mov	byte ptr es:[bx+2], 5
		push	ds
		lds	si, ss:THISSFT
		call	DEVIOCALL
		pop	ds
		test	word ptr es:[bx+3], 8000h
		jz	short check_busy
		push	ds
		mov	dx, di
		call	CHARHARD
		mov	di, dx
		or	al, al
		jz	short pop_done_read
		cmp	al, 3
		jz	short devrderr
		pop	ds
		jmp	short do_io
; ---------------------------------------------------------------------------

check_busy:				; ...
		test	word ptr es:[bx+3], 200h
		jnz	short no_char
		mov	byte ptr es:[bx+2], 4
		mov	word ptr es:[bx+12h], 1
		push	ds
		lds	si, ss:THISSFT
		call	DEVIOCALL
		mov	dx, di
		mov	ah, 86h
		mov	di, es:[bx+3]
		test	di, 8000h
		jz	short next_char
		call	CHARHARD
		mov	di, dx
		or	al, al
		jz	short pop_done_read
		cmp	al, 3
		jz	short devrderr
		pop	ds
		jmp	short do_io
; ---------------------------------------------------------------------------

next_char:				; ...
		pop	ds
		mov	di, dx
		dec	cx
		jcxz	short done_read
		inc	word ptr es:[bx+14]
		jmp	short do_io
; ---------------------------------------------------------------------------

devrderr:				; ...
		pop	di
		les	di, ss:THISSFT
		jmp	SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

no_char:				; ...
		push	ax
		mov	ah, 84h
		int	2Ah		; Microsoft Networks - KEYBOARD	BUSY LOOP
		pop	ax
		jmp	do_io
; ---------------------------------------------------------------------------

pop_done_read:				; ...
		pop	ds

done_read:				; ...
		add	di, word ptr ss:CALLBPB
		jmp	ENDRDDEVJ3
; ---------------------------------------------------------------------------

TRANBUF:				; ...
		lodsb
		stosb
		cmp	al, 0Dh
		jnz	short NORMCH
		mov	byte ptr [si], 0Ah

NORMCH:					; ...
		cmp	al, 0Ah
		loopne	TRANBUF
		jnz	short ENDRDCON
		xor	si, si
		call	OUTT
		or	al, 1

ENDRDCON:				; ...
		push	ss
		pop	ds
		call	SWAPBACK
		mov	CONTPOS, si

ENDRDDEV:				; ...
		push	ss
		pop	ds
		mov	NEXTADD, di
		jnz	short SETSFTC
		les	di, THISSFT
		and	byte ptr es:[di+5], 0BFh

SETSFTC:				; ...
		call	SETSFT
		retn
; ---------------------------------------------------------------------------

READCON:				; ...
		call	SWAPCON
		mov	si, CONTPOS
		or	si, si
		jnz	short TRANBUF
		cmp	CONBUF,	128
		jz	short GETBUF
		mov	word ptr CONBUF, 0FF80h

GETBUF:					; ...
		push	cx
		push	es
		push	di
		mov	dx, offset CONBUF
		call	$STD_CON_STRING_INPUT
		pop	di
		pop	es
		pop	cx
		mov	si, (offset CONBUF+2)
		cmp	byte ptr [si], 1Ah
		jnz	short TRANBUF
		mov	al, 1Ah
		stosb
		dec	di
		mov	al, 0Ah
		call	OUTT
		xor	si, si
		jmp	short ENDRDCON
DOS_READ	endp


; =============== S U B	R O U T	I N E =======================================


DOS_WRITE	proc near		; ...
		les	di, THISSFT
		mov	al, es:[di+2]
		and	al, 0Fh
		cmp	al, 0
		jnz	short Check_FCB_RO

BadMode:				; ...
		jmp	SET_ACC_ERR
; ---------------------------------------------------------------------------

Check_FCB_RO:				; ...
		test	byte ptr es:[di+3], 80h
		jz	short WRITE_NO_MODE
		test	byte ptr es:[di+4], 1
		jnz	short BadMode

WRITE_NO_MODE:				; ...
		call	SETUP
		call	IsSFTNet
		jz	short LOCAL_WRITE
		mov	ax, 1109h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; CX = number of bytes,	SS = DOS CS, SDA DTA field -> user buffer
					; Return: CF set on error, CX =	bytes written
		retn
; ---------------------------------------------------------------------------

LOCAL_WRITE:				; ...
		test	byte ptr es:[di+5], 80h
		jnz	short WRTDEV
		mov	EXTERR_LOCUS, 2
		call	ECritDisk
		call	DISKWRITE
		jb	short nocommit
		les	di, THISSFT
		test	byte ptr es:[di+3], 40h
		jz	short nocommit
		push	cx
		call	DOS_COMMIT
		pop	cx

nocommit:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

DVWRTRAW:				; ...
		xor	ax, ax
		call	SETWRITE
		push	ds
		lds	si, ss:THISSFT
		call	DEVIOCALL
		mov	dx, di
		mov	ah, 87h
		mov	di, ss:DEVCALL_REQSTAT
		or	di, di
		jns	short CWRTROK
		call	CHARHARD
		sub	cx, word ptr ss:CALLBPB	; [ss:CALLSCNT]
		mov	bx, dx
		add	bx, word ptr ss:CALLBPB
		mov	di, bx
		or	al, al
		jz	short CWRTROK
		cmp	al, 3
		jz	short CWRFERR
		pop	ds
		jmp	short DVWRTRAW
; ---------------------------------------------------------------------------

CWRFERR:				; ...
		pop	ax
		jmp	CRDFERR
; ---------------------------------------------------------------------------

CWRTROK:				; ...
		pop	ax
		pop	ds
		mov	ax, word ptr CALLBPB

ENDWRDEV:				; ...
		les	di, THISSFT
		mov	cx, ax
		call	ADDREC
		retn
; ---------------------------------------------------------------------------

WRTNUL:					; ...
		mov	dx, cx

WRTCOOKJ:				; ...
		jmp	WRTCOOKDONE
; ---------------------------------------------------------------------------

WRTDEV:					; ...
		mov	EXTERR_LOCUS, 4
		or	byte ptr es:[di+5], 40h
		mov	bl, es:[di+5]
		xor	ax, ax
		jcxz	short ENDWRDEV
		push	ds
		mov	al, bl
		lds	bx, DMAADD
		mov	di, bx
		xor	dx, dx
		test	al, 20h
		jz	short TEST_DEV_CON
		jmp	short DVWRTRAW
; ---------------------------------------------------------------------------

TEST_DEV_CON:				; ...
		test	al, 2
		jnz	short WRITECON
		test	al, 4
		jnz	short WRTNUL
		mov	ax, dx
		cmp	byte ptr [bx], 1Ah
		jz	short WRTCOOKJ
		push	cx
		mov	cx, 1
		call	SETWRITE
		pop	cx
		lds	si, ss:THISSFT
		lds	si, [si+7]

DVWRTLP:				; ...
		call	DSKSTATCHK
		call	DEVIOCALL2
		push	di
		mov	ah, 87h
		mov	di, ss:DEVCALL_REQSTAT
		or	di, di
		jns	short CWROK
		call	CHARHARD
		pop	di
		mov	word ptr ss:CALLBPB, 1
		cmp	al, 1
		jz	short DVWRTLP
		or	al, al
		jz	short DVWRTIGN
		jmp	CRDFERR
; ---------------------------------------------------------------------------

CWROK:					; ...
		pop	di
		cmp	word ptr ss:CALLBPB, 0
		jz	short WRTCOOKDONE

DVWRTIGN:				; ...
		inc	dx
		inc	word ptr ss:CALLBR
		inc	di
		push	ds
		mov	ds, word ptr ss:CALLBR+2
		cmp	byte ptr [di], 1Ah
		pop	ds
		jz	short WRTCOOKDONE
		mov	ss:DEVCALL_REQSTAT, 0
		loop	DVWRTLP

WRTCOOKDONE:				; ...
		mov	ax, dx
		pop	ds
		jmp	ENDWRDEV
; ---------------------------------------------------------------------------

WRITECON:				; ...
		push	ds
		push	ss
		pop	ds
		call	SWAPCON
		pop	ds
		mov	si, bx
		push	cx

WRCONLP:				; ...
		lodsb
		cmp	al, 1Ah
		jz	short CONEOF
		call	OUTT
		loop	WRCONLP

CONEOF:					; ...
		pop	ax
		sub	ax, cx
		pop	ds
		call	SWAPBACK
		jmp	ENDWRDEV
DOS_WRITE	endp


; =============== S U B	R O U T	I N E =======================================


GET_IO_SFT	proc near		; ...
		cmp	ss:CONSWAP, 0
		jnz	short GetRedir

GetNormal:				; ...
		push	ss
		pop	ds
		push	es
		push	di
		call	SFFromHandle
		jb	short RET44P
		mov	si, es
		mov	ds, si
		mov	si, di

RET44P:					; ...
		pop	di
		pop	es
		retn
; ---------------------------------------------------------------------------

GetRedir:				; ...
		cmp	bx, 1
		ja	short GetNormal
		lds	si, ss:CONSFT
		clc

get_io_sft_retn:			; ...
		retn
GET_IO_SFT	endp


; =============== S U B	R O U T	I N E =======================================


DIRREAD		proc near		; ...
		xor	dx, dx
		cmp	DIRSTART, 0
		jnz	short SubDir
		xchg	ax, dx
		jmp	short DoRead
; ---------------------------------------------------------------------------

SubDir:					; ...
		mov	dl, al
		and	dl, es:[bp+4]
		mov	cl, es:[bp+5]
		shr	ax, cl

DoRead:					; ...
		mov	SECCLUSPOS, dl
		mov	cx, ax
		mov	ah, dl
		mov	dx, DIRSEC+2
		mov	HIGH_SECTOR, dx
		mov	dx, DIRSEC
		add	dl, ah
		adc	dh, 0
		adc	HIGH_SECTOR, 0
		mov	bx, CLUSNUM
		mov	NXTCLUSNUM, bx
		jcxz	short FIRSTCLUSTER

SKPCLLP:				; ...
		call	UNPACK
		jb	short get_io_sft_retn
		xchg	bx, di
		call	IsEOF
		jnb	short HAVESKIPPED
		loop	SKPCLLP

HAVESKIPPED:				; ...
		mov	NXTCLUSNUM, bx
		mov	dx, di
		mov	bl, ah
		call	FIGREC

FIRSTCLUSTER:				; ...
		mov	ALLOWED, 18h
		xor	al, al
		call	GETBUFFR
		jb	short get_io_sft_retn

SET_BUF_AS_DIR:				; ...
		push	ds
		push	si
		lds	si, CURBUF
		or	byte ptr [si+5], 4
		pop	si
		pop	ds

dirread_retn:				; ...
		retn
DIRREAD		endp


; =============== S U B	R O U T	I N E =======================================


FATSECRD	proc near		; ...

; FUNCTION CHUNK AT 7660 SIZE 00000002 BYTES

		mov	ss:ALLOWED, 18h
		mov	di, cx
		mov	cl, es:[bp+8]
		mov	ax, es:[bp+0Fh]
		xor	ch, ch
		push	dx

NXTFAT:					; ...
		mov	ss:HIGH_SECTOR,	0
		push	cx
		push	ax
		mov	cx, di
		call	DSKREAD
		pop	ax
		pop	cx
		jz	short RET41P
		add	dx, ax
		loop	NXTFAT
		pop	dx
		mov	cx, di
FATSECRD	endp


; =============== S U B	R O U T	I N E =======================================


DREAD		proc near		; ...
		call	DSKREAD
		jz	short dirread_retn
		mov	ss:READOP, 0
		call	HARDERRRW
		cmp	al, 1
		jz	short DREAD
		cmp	al, 3
		clc
		jnz	short NO_CAR
		stc

NO_CAR:					; ...
		retn
DREAD		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR FATSECRD

RET41P:					; ...
		pop	dx
		retn
; END OF FUNCTION CHUNK	FOR FATSECRD

; =============== S U B	R O U T	I N E =======================================


CHECK_WRITE_LOCK proc near		; ...
		test	byte ptr es:[di+4], 8
		jz	short write_cont
		call	SET_ACC_ERR_DS
		retn
; ---------------------------------------------------------------------------

write_cont:				; ...
		push	cx
		or	cx, cx
		jnz	short Not_Truncate
		dec	cx

Not_Truncate:				; ...
		mov	al, 80h	; ''
		call	LOCK_CHECK
		pop	cx
		jnb	short WRITE_OK
		call	WRITE_LOCK_VIOLATION
		jnb	short write_cont

WRITE_OK:				; ...
		retn
CHECK_WRITE_LOCK endp


; =============== S U B	R O U T	I N E =======================================


CHECK_READ_LOCK	proc near		; ...
		test	byte ptr es:[di+4], 8
		jz	short do_retry
		call	SET_ACC_ERR
		retn
; ---------------------------------------------------------------------------

do_retry:				; ...
		xor	al, al
		call	LOCK_CHECK
		jnb	short READLOCK_OK
		call	READ_LOCK_VIOLATION
		jnb	short do_retry

READLOCK_OK:				; ...
		retn
CHECK_READ_LOCK	endp


; =============== S U B	R O U T	I N E =======================================


DSKREAD		proc near		; ...
		push	cx
		mov	ah, es:[bp+17h]
		mov	al, es:[bp+1]
		push	bx
		push	es
		call	SETREAD
		jmp	short DODSKOP
DSKREAD		endp


; =============== S U B	R O U T	I N E =======================================


DWRITE		proc near		; ...
		call	DSKWRITE
		jz	short dw_ret_label
		mov	ss:READOP, 1
		call	HARDERRRW
		cmp	al, 1
		jz	short DWRITE
		cmp	al, 3
		clc
		jnz	short dw_ret_label
		stc

dw_ret_label:				; ...
		retn
DWRITE		endp


; =============== S U B	R O U T	I N E =======================================


DSKWRITE	proc near		; ...
		push	cx
		mov	ah, es:[bp+17h]
		mov	al, es:[bp+1]
		push	bx
		push	es
		call	SETWRITE

DODSKOP:				; ...
		mov	cx, ds
		pop	ds
		push	ds
		lds	si, ds:[bp+13h]
		call	DEVIOCALL2
		mov	ds, cx
		pop	es
		pop	bx
		mov	cx, word ptr ss:CALLBPB
		pop	di
		sub	cx, di
		neg	cx
		mov	ax, ss:DEVCALL_REQSTAT
		test	ax, 8000h
		retn
DSKWRITE	endp


; =============== S U B	R O U T	I N E =======================================


HARDERRRW	proc near		; ...
		cmp	al, 0Fh
		jnz	short DO_ERR
		push	ax
		mov	ax, word ptr ss:CALLVIDRW
		mov	word ptr ss:EXTERRPT, ax
		mov	ax, word ptr ss:CALLVIDRW+2
		mov	word ptr ss:EXTERRPT+2,	ax
		pop	ax

DO_ERR:					; ...
		call	HARDERR
		retn
HARDERRRW	endp


; =============== S U B	R O U T	I N E =======================================


SETUP		proc near		; ...
		lds	si, es:[di+7]
		mov	word ptr ss:THISDPB+2, ds
		push	ss
		pop	ds
		mov	word ptr THISDPB, si
		mov	bx, word ptr DMAADD
		mov	NEXTADD, bx
		mov	TRANS, 0
		mov	ax, es:[di+15h]
		mov	dx, es:[di+17h]
		mov	BYTPOS+2, dx
		mov	BYTPOS,	ax
		test	word ptr es:[di+5], 8080h
		jnz	short NOSETSTUFF
		push	es
		les	bp, THISDPB
		mov	bl, es:[bp+0]
		mov	THISDRV, bl
		mov	bx, es:[bp+2]
		push	cx
		call	DIV32
		mov	BYTSECPOS, dx
		mov	SECPOS,	ax
		mov	SECPOS+2, cx
		mov	dx, cx
		mov	bx, ax
		and	bl, es:[bp+4]
		mov	SECCLUSPOS, bl
		call	SHR32
		pop	cx
		jnz	short EOFERR
		cmp	ax, es:[bp+0Dh]
		ja	short EOFERR
		mov	CLUSNUM, ax
		pop	es

NOSETSTUFF:				; ...
		mov	ax, cx
		add	ax, word ptr DMAADD
		jnb	short setup_OK
		mov	ax, word ptr DMAADD
		neg	ax
		jnz	short NoDec
		dec	ax

NoDec:					; ...
		mov	cx, ax
		jcxz	short NOROOM

setup_OK:				; ...
		retn
; ---------------------------------------------------------------------------

EOFERR:					; ...
		pop	es
		xor	cx, cx

NOROOM:					; ...
		pop	bx
		clc
		retn
SETUP		endp


; =============== S U B	R O U T	I N E =======================================


BREAKDOWN	proc near		; ...
		mov	ax, BYTSECPOS
		mov	bx, cx
		or	ax, ax
		jz	short SAVFIR
		sub	ax, es:[bp+2]
		neg	ax
		sub	bx, ax
		jnb	short SAVFIR
		add	ax, bx
		xor	bx, bx

SAVFIR:					; ...
		mov	BYTCNT1, ax
		mov	ax, bx
		xor	dx, dx
		div	word ptr es:[bp+2]
		mov	SECCNT,	ax
		mov	BYTCNT2, dx

_RET45:					; ...
		retn
BREAKDOWN	endp


; =============== S U B	R O U T	I N E =======================================


READ_LOCK_VIOLATION proc near		; ...
		mov	READOP,	0

ERR_ON_CHECK:				; ...
		test	byte ptr es:[di+3], 80h
		jnz	short HARD_ERR
		push	cx
		mov	cl, es:[di+2]
		and	cl, 0F0h
		cmp	cl, 0
		pop	cx
		jnz	short NO_HARD_ERR

HARD_ERR:				; ...
		call	LOCK_VIOLATION
		jnb	short _RET45

NO_HARD_ERR:				; ...
		xor	cx, cx
		mov	ax, 21h	; '!'
		stc
		retn
READ_LOCK_VIOLATION endp


; =============== S U B	R O U T	I N E =======================================


WRITE_LOCK_VIOLATION proc near		; ...
		mov	READOP,	1
		jmp	short ERR_ON_CHECK
WRITE_LOCK_VIOLATION endp


; =============== S U B	R O U T	I N E =======================================


DISKREAD	proc near		; ...

; FUNCTION CHUNK AT 7829 SIZE 00000005 BYTES
; FUNCTION CHUNK AT 7837 SIZE 0000008B BYTES
; FUNCTION CHUNK AT 7A4E SIZE 0000000B BYTES

		mov	ax, es:[di+11h]
		mov	bx, es:[di+13h]
		sub	ax, BYTPOS
		sbb	bx, BYTPOS+2
		jb	short RDERR
		jnz	short ENUF
		or	ax, ax
		jz	short RDERR
		cmp	ax, cx
		jnb	short ENUF
		mov	cx, ax

ENUF:					; ...
		call	CHECK_READ_LOCK
		jnb	short _READ_OK
		retn
; ---------------------------------------------------------------------------

_READ_OK:				; ...
		les	bp, THISDPB
		call	BREAKDOWN
		mov	cx, CLUSNUM
		call	FNDCLUS
		jb	short SET_ACC_ERR_DS
		or	cx, cx
		jz	short SKIPERR

RDERR:					; ...
		mov	ah, 0Eh
		jmp	WRTERR22
DISKREAD	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DISKREAD

SETSFTJ2:				; ...
		jmp	SETSFT
; ---------------------------------------------------------------------------

CANOT_READ:				; ...
		pop	cx
		pop	bx
; END OF FUNCTION CHUNK	FOR DISKREAD

; =============== S U B	R O U T	I N E =======================================


SET_ACC_ERR_DS	proc near		; ...
		push	ss
		pop	ds
SET_ACC_ERR_DS	endp


; =============== S U B	R O U T	I N E =======================================


SET_ACC_ERR	proc near		; ...
		xor	cx, cx
		mov	ax, 5
		stc
		retn
SET_ACC_ERR	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DISKREAD

SKIPERR:				; ...
		mov	LASTPOS, dx
		mov	CLUSNUM, bx
		cmp	BYTCNT1, 0
		jz	short RDMID
		call	BUFRD
		jb	short SET_ACC_ERR_DS

RDMID:					; ...
		cmp	SECCNT,	0
		jz	short RDLAST
		call	NEXTSEC
		jb	short SETSFTJ2
		mov	TRANS, 1
		mov	dl, SECCLUSPOS
		mov	cx, SECCNT
		mov	bx, CLUSNUM

RDLP:					; ...
		call	OPTIMIZE
		jb	short SET_ACC_ERR_DS
		push	di
		push	ax
		push	bx
		mov	ALLOWED, 38h ; '8'
		mov	ds, word ptr DMAADD+2
		push	dx
		push	cx
		call	SET_RQ_SC_PARMS
		call	DREAD
		pop	cx
		pop	dx
		pop	ss:TEMP_VAR
		jb	short CANOT_READ
		mov	ss:TEMP_VAR2, ds
		call	DskRdBufScan
		push	ss
		pop	ds
		pop	cx
		pop	bx
		jcxz	short RDLAST
		call	IsEOF
		jnb	short SETSFT
		mov	dl, 0
		inc	LASTPOS
		jmp	short RDLP
; ---------------------------------------------------------------------------

RDLAST:					; ...
		mov	ax, BYTCNT2
		or	ax, ax
		jz	short SETSFT
		mov	BYTCNT1, ax
		call	NEXTSEC
		jb	short SETSFT
		mov	BYTSECPOS, 0
		call	BUFRD
		jnb	short SETSFT
		jmp	SET_ACC_ERR_DS
; END OF FUNCTION CHUNK	FOR DISKREAD

; =============== S U B	R O U T	I N E =======================================


SETSFT		proc near		; ...
		les	di, THISSFT

SETCLUS:				; ...
		mov	cx, NEXTADD
		sub	cx, word ptr DMAADD
		test	byte ptr es:[di+5], 80h
		jnz	short ADDREC
		mov	ax, CLUSNUM
		mov	es:[di+35h], ax
		mov	ax, LASTPOS
		mov	es:[di+19h], ax
SETSFT		endp


; =============== S U B	R O U T	I N E =======================================


ADDREC		proc near		; ...
		jcxz	short RET28
		add	es:[di+15h], cx
		adc	word ptr es:[di+17h], 0

RET28:					; ...
		clc
		retn
ADDREC		endp


; =============== S U B	R O U T	I N E =======================================


DskRdBufScan	proc near		; ...
		cmp	ss:DirtyBufferCount, 0
		jz	short bufx
		mov	bx, ss:HIGH_SECTOR
		mov	si, bx
		add	cx, dx
		adc	si, 0
		call	GETCURHEAD
		mov	ax, [di+2]
		mov	ss:FIRST_BUFF_ADDR, ax
		mov	al, es:[bp+0]

bufq:					; ...
		cmp	al, [di+4]
		jnz	short bufq1
		cmp	bx, [di+8]
		jnz	short bufq01
		cmp	dx, [di+6]

bufq01:					; ...
		ja	short bufq1
		cmp	si, [di+8]
		jnz	short bufq02
		cmp	cx, [di+6]

bufq02:					; ...
		ja	short bufq2

bufq1:					; ...
		cmp	di, ss:FIRST_BUFF_ADDR
		mov	di, [di]
		jnz	short bufq

bufx:					; ...
		retn
; ---------------------------------------------------------------------------

bufq2:					; ...
		push	ax
		test	byte ptr [di+5], 40h
		jz	short bufq3
		push	cx
		push	dx
		push	si
		push	di
		push	es
		mov	ax, dx
		sub	ax, [di+6]
		neg	ax
		lea	si, [di+20]
		mov	cx, es:[bp+2]
		mul	cx
		mov	di, ss:TEMP_VAR
		add	di, ax
		mov	es, ss:TEMP_VAR2
		shr	cx, 1
		rep movsw
		adc	cx, 0
		rep movsb
		pop	es
		pop	di
		pop	si
		pop	dx
		pop	cx

bufq3:					; ...
		mov	ax, di
		call	SCANPLACE
		cmp	ax, ss:FIRST_BUFF_ADDR
		pop	ax
		jnz	short bufq
		jmp	short bufx
DskRdBufScan	endp


; =============== S U B	R O U T	I N E =======================================


DISKWRITE	proc near		; ...

; FUNCTION CHUNK AT 7A40 SIZE 0000000E BYTES
; FUNCTION CHUNK AT 7A59 SIZE 0000016E BYTES
; FUNCTION CHUNK AT 7BCB SIZE 00000043 BYTES

		call	CHECK_WRITE_LOCK
		jnb	short _WRITE_OK
		retn
; ---------------------------------------------------------------------------

WRTEOFJ:				; ...
		jmp	WRTEOF
; ---------------------------------------------------------------------------

_WRITE_OK:				; ...
		and	word ptr es:[di+5], 0BFBFh
		mov	ax, es:[di+11h]
		mov	TEMP_VAR, ax
		mov	ax, es:[di+13h]
		mov	TEMP_VAR2, ax
		les	bp, THISDPB
		call	BREAKDOWN
		mov	ax, BYTPOS
		mov	dx, BYTPOS+2
		jcxz	short WRTEOFJ
		add	ax, cx
		adc	dx, 0
		mov	bx, es:[bp+2]
		call	DIV32
		mov	si, ax
		mov	HIGH_SECTOR, cx
		or	dx, dx
		push	dx
		mov	dx, cx
		jnz	short CALCLUS
		sub	ax, 1
		sbb	dx, 0

CALCLUS:				; ...
		call	SHR32
		pop	dx
		push	ax
		push	dx
		mov	dx, TEMP_VAR2
		mov	ax, TEMP_VAR
		call	DIV32
		mov	TEMP_VAR2, cx
		mov	VALSEC+2, cx
		mov	cx, ax
		mov	bx, si
		or	dx, dx
		jz	short NORND
		add	ax, 1
		adc	VALSEC+2, 0

NORND:					; ...
		mov	VALSEC,	ax
		xor	ax, ax
		mov	GROWCNT, ax
		mov	GROWCNT+2, ax
		pop	ax
		mov	di, HIGH_SECTOR
		cmp	di, TEMP_VAR2
		jb	short NOGROW
		jz	short lowsec
		sub	bx, cx
		sbb	di, TEMP_VAR2
		jmp	short yesgrow
; ---------------------------------------------------------------------------

lowsec:					; ...
		mov	di, 0
		sub	bx, cx
		jb	short NOGROW
		jz	short TESTTAIL

yesgrow:				; ...
		mov	cx, dx
		xchg	ax, bx
		mul	word ptr es:[bp+2]
		mov	HIGH_SECTOR, dx
		mov	TEMP_VAR2, ax
		mov	ax, di
		mul	word ptr es:[bp+2]
		add	ax, HIGH_SECTOR
		mov	dx, ax
		mov	ax, TEMP_VAR2
		sub	ax, cx
		sbb	dx, 0
		add	ax, bx
		adc	dx, 0
		jmp	short SETGRW
DISKWRITE	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DISKWRITE

HAVSTART:				; ...
		mov	cx, ax
		call	SKPCLP
		jcxz	short DOWRTJ
		call	ALLOCATE
		jnb	short DOWRTJ

WRTERR:					; ...
		mov	ah, 0Fh
; END OF FUNCTION CHUNK	FOR DISKWRITE
; START	OF FUNCTION CHUNK FOR DISKREAD

WRTERR22:				; ...
		mov	al, THISDRV
		xor	cx, cx
		les	di, THISSFT
		clc
		retn
; END OF FUNCTION CHUNK	FOR DISKREAD
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DISKWRITE

DOWRTJ:					; ...
		jmp	short DOWRT
; ---------------------------------------------------------------------------

ACC_ERRWJ:				; ...
		jmp	SET_ACC_ERRW
; ---------------------------------------------------------------------------

TESTTAIL:				; ...
		sub	ax, dx
		jbe	short NOGROW
		xor	dx, dx

SETGRW:					; ...
		mov	GROWCNT, ax
		mov	GROWCNT+2, dx

NOGROW:					; ...
		pop	ax
		mov	cx, CLUSNUM
		call	FNDCLUS
		jb	short ACC_ERRWJ
		mov	CLUSNUM, bx
		mov	LASTPOS, dx
		sub	ax, dx
		jz	short DOWRT
		jcxz	short HAVSTART
		push	cx
		mov	cx, ax
		call	ALLOCATE
		pop	cx
		jb	short WRTERR
		mov	dx, LASTPOS
		inc	dx
		dec	cx
		jz	short NOSKIP
		call	SKPCLP
		jb	short ACC_ERRWJ

NOSKIP:					; ...
		mov	CLUSNUM, bx
		mov	LASTPOS, dx

DOWRT:					; ...
		cmp	BYTCNT1, 0
		jz	short WRTMID
		mov	bx, CLUSNUM
		call	BUFWRT
		jb	short ACC_ERRWJ

WRTMID:					; ...
		mov	ax, SECCNT
		or	ax, ax
		jz	short WRTLAST
		add	SECPOS,	ax
		adc	SECPOS+2, 0
		call	NEXTSEC
		jb	short SET_ACC_ERRW
		mov	TRANS, 1
		mov	dl, SECCLUSPOS
		mov	bx, CLUSNUM
		mov	cx, SECCNT

WRTLP:					; ...
		call	OPTIMIZE
		jb	short SET_ACC_ERRW
		push	di
		push	ax
		call	DskWrtBufPurge
		mov	ds, word ptr ss:DMAADD+2
		mov	ss:ALLOWED, 38h	; '8'

DWRITE_LUP:				; ...
		call	DSKWRITE
		jz	short DWRITE_OKAY
		cmp	al, 27h	; '''
		jz	short DWRITE_DISK_FULL
		mov	ss:READOP, 1
		call	HARDERRRW
		cmp	al, 1
		jz	short DWRITE_LUP
		cmp	al, 3
		clc
		jnz	short DWRITE_OKAY
		stc

DWRITE_OKAY:				; ...
		pop	cx
		pop	bx
		push	ss
		pop	ds
		jb	short SET_ACC_ERRW
		jcxz	short WRTLAST
		mov	dl, 0
		inc	LASTPOS
		jmp	short WRTLP
; ---------------------------------------------------------------------------

DWRITE_DISK_FULL:			; ...
		push	ss
		pop	ds
		pop	cx
		pop	bx
		mov	DISK_FULL, 1
		stc
		jmp	WRTERR
; ---------------------------------------------------------------------------

SET_ACC_ERRW:				; ...
		jmp	SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

WRTLAST:				; ...
		mov	ax, BYTCNT2
		or	ax, ax
		jz	short FINWRT
		mov	BYTCNT1, ax
		call	NEXTSEC
		jb	short SET_ACC_ERRW
		mov	BYTSECPOS, 0
		call	BUFWRT
		jb	short SET_ACC_ERRW

FINWRT:					; ...
		les	di, THISSFT
		mov	ax, GROWCNT
		mov	cx, GROWCNT+2
		or	ax, ax
		jnz	short UPDATE_size
		jcxz	short SAMSIZ

UPDATE_size:				; ...
		add	es:[di+11h], ax
		adc	es:[di+13h], cx
		mov	ax, 1
		call	ShSU

SAMSIZ:					; ...
		jmp	SETCLUS
; ---------------------------------------------------------------------------

WRTEOF:					; ...
		mov	cx, ax
		or	cx, dx
		jz	short KILLFIL
		sub	ax, 1
		sbb	dx, 0
		push	bx
		mov	bx, es:[bp+2]
		call	DIV32
		pop	bx
		mov	dx, cx
		mov	HIGH_SECTOR, cx
		call	SHR32
		mov	cx, ax
		call	FNDCLUS

SET_ACC_ERRWJ2:				; ...
		jb	short SET_ACC_ERRW
		jcxz	short RELFILE
		call	ALLOCATE
		jb	short WRTERRJ

UPDATE:					; ...
		les	di, THISSFT
		mov	ax, BYTPOS
		mov	es:[di+11h], ax
		mov	ax, BYTPOS+2
		mov	es:[di+13h], ax
		mov	ax, 2
		call	ShSU
		xor	cx, cx
		jmp	ADDREC
; ---------------------------------------------------------------------------

WRTERRJ:				; ...
		jmp	WRTERR
; ---------------------------------------------------------------------------

RELFILE:				; ...
		push	es
		les	di, THISSFT
		cmp	dx, es:[di+19h]
		jnb	short SKIPRESET
		mov	word ptr es:[di+19h], 0
		mov	dx, es:[di+0Bh]
; END OF FUNCTION CHUNK	FOR DISKWRITE
		mov	es:[di+35h], dx
; START	OF FUNCTION CHUNK FOR DISKWRITE

SKIPRESET:				; ...
		pop	es
		mov	dx, 0FFFFh
		call	RELBLKS

SET_ACC_ERRWJJ:				; ...
		jb	short SET_ACC_ERRWJ2
		jmp	short UPDATE
; ---------------------------------------------------------------------------

KILLFIL:				; ...
		xor	bx, bx
		push	es
		les	di, THISSFT
		mov	es:[di+19h], bx
		mov	es:[di+35h], bx
		xchg	bx, es:[di+0Bh]
		pop	es
		or	bx, bx
		jz	short UPDATEJ
		push	es
		push	bp
		push	ax
		push	cx
		push	dx
		les	bp, THISDPB
		mov	dl, es:[bp+0]
		mov	cx, bx
		mov	ah, 2
		call	FastOpen_Update
		pop	dx
		pop	cx
		pop	ax
		pop	bp
		pop	es
		call	RELEASE
		jb	short SET_ACC_ERRWJJ

UPDATEJ:				; ...
		jmp	short UPDATE
; END OF FUNCTION CHUNK	FOR DISKWRITE

; =============== S U B	R O U T	I N E =======================================


DskWrtBufPurge	proc near		; ...
		push	bx
		push	cx
		mov	bx, ss:HIGH_SECTOR
		mov	si, bx
		add	cx, dx
		adc	si, 0
		mov	al, es:[bp+0]
		cmp	ss:SC_CACHE_COUNT, 0
		jz	short nosc
		cmp	al, ss:CurSC_DRIVE
		jnz	short nosc
		push	ax
		mov	ax, ss:CurSC_SECTOR
		mov	di, ss:CurSC_SECTOR+2
		cmp	si, di
		jnz	short sc01
		cmp	cx, ax

sc01:					; ...
		jbe	short sc5
		add	ax, ss:SC_CACHE_COUNT
		adc	di, 0
		cmp	bx, di
		jnz	short sc02
		cmp	dx, ax

sc02:					; ...
		jnb	short sc5
		mov	ss:SC_STATUS, 0

sc5:					; ...
		pop	ax

nosc:					; ...
		call	GETCURHEAD

_bufq:					; ...
		cmp	al, [di+4]
		jnz	short bufq5
		cmp	bx, [di+8]
		jnz	short bufq04
		cmp	dx, [di+6]

bufq04:					; ...
		ja	short bufq5
		cmp	si, [di+8]
		jnz	short bufq05
		cmp	cx, [di+6]

bufq05:					; ...
		jbe	short bufq5
		test	byte ptr [di+5], 40h
		jz	short bufq4
		call	DEC_DIRTY_COUNT

bufq4:					; ...
		mov	word ptr [di+4], 20FFh
		call	SCANPLACE
		jmp	short bufq6
; ---------------------------------------------------------------------------

bufq5:					; ...
		mov	di, [di]

bufq6:					; ...
		cmp	di, ss:FIRST_BUFF_ADDR
		jnz	short _bufq
		pop	cx
		pop	bx
		retn
DskWrtBufPurge	endp


; =============== S U B	R O U T	I N E =======================================


DIV32		proc near		; ...
		cmp	bx, 512
		jnz	short div5
		mov	cx, dx
		mov	dx, ax
		and	dx, 511
		mov	al, ah
		mov	ah, cl
		mov	cl, ch
		xor	ch, ch
		shr	cx, 1
		rcr	ax, 1
		retn
; ---------------------------------------------------------------------------

div5:					; ...
		mov	cx, ax
		mov	ax, dx
		xor	dx, dx
		div	bx
		xchg	ax, cx
		div	bx
		retn
DIV32		endp


; =============== S U B	R O U T	I N E =======================================


SHR32		proc near		; ...
		mov	cl, es:[bp+5]
		xor	ch, ch
		jcxz	short norota

rotashft2:				; ...
		shr	dx, 1
		rcr	ax, 1
		loop	rotashft2

norota:					; ...
		retn
SHR32		endp


; =============== S U B	R O U T	I N E =======================================


SEARCH		proc near		; ...
		call	STARTSRCH
		mov	al, ATTRIB
		and	al, 9Eh
		cmp	al, 8
		jnz	short NOTVOLSRCH
		call	SETROOTSRCH

NOTVOLSRCH:				; ...
		call	GETENTRY
		jnb	short SRCH
		jmp	SETESRET
; ---------------------------------------------------------------------------

SRCH:					; ...
		push	ds
		mov	ds, word ptr CURBUF+2
		mov	ah, [bx]
		or	ah, ah
		jz	short FREE
		cmp	ah, ss:DELALL
		jz	short FREE
		test	byte ptr [bx+0Bh], 8
		jz	short CHKFNAM
		inc	ss:VOLID

CHKFNAM:				; ...
		mov	si, ss
		mov	es, si
		mov	si, bx
		mov	di, offset NAME1
		cmp	ss:NAME1, 0E5h ; ''
		jnz	short NO_E5
		mov	ss:NAME1, 5

NO_E5:					; ...
		call	MetaCompare
		jz	short FOUND
		pop	ds

NEXTENT:				; ...
		les	bp, THISDPB
		call	NEXTENTRY
		jnb	short SRCH
		jmp	short SETESRET
; ---------------------------------------------------------------------------

FREE:					; ...
		pop	ds
		mov	cx, LASTENT
		cmp	cx, ENTFREE
		jnb	short TSTALL
		mov	ENTFREE, cx

TSTALL:					; ...
		cmp	ah, DELALL

NEXTENTJ:				; ...
		jz	short NEXTENT
		mov	ENTLAST, cx
		stc
		jmp	short SETESRET
; ---------------------------------------------------------------------------

FOUND:					; ...
		mov	ch, [si]
		pop	ds
		mov	ah, ATTRIB
		and	ah, 9Eh
		lea	si, [si+0Fh]
		test	ch, 8
		jz	short check_one_volume_id
		test	ah, 8
		jz	short NEXTENTJ
		xor	ah, ah
		jmp	short RETFF
; ---------------------------------------------------------------------------

check_one_volume_id:			; ...
		cmp	ah, 8
		jz	short NEXTENTJ
		call	MatchAttributes
		jz	short RETFF
		test	CREATING, 0FFh
		jz	short NEXTENTJ

RETFF:					; ...
		les	bp, THISDPB
		mov	ah, es:[bp+0]

SETESRET:				; ...
		push	ss
		pop	es
		retn
SEARCH		endp


; =============== S U B	R O U T	I N E =======================================


MetaCompare	proc near		; ...
		mov	cx, 11

WILDCRD:				; ...
		repe cmpsb
		jz	short MetaRet
		cmp	byte ptr es:[di-1], '?'
		jz	short WILDCRD

MetaRet:				; ...
		retn
MetaCompare	endp


; =============== S U B	R O U T	I N E =======================================


NEXTENTRY	proc near		; ...
		mov	ax, LASTENT
		cmp	ax, ENTLAST
		jz	short NONE
		inc	ax
		lea	bx, [bx+32]
		cmp	bx, dx
		jnz	short HAVIT
		mov	bl, SECCLUSPOS
		inc	bl
		cmp	bl, CLUSFAC
		jb	short SAMECLUS
		mov	bx, NXTCLUSNUM
		call	IsEOF
		jnb	short NONE
		cmp	bx, 2
		jb	short NONE
		jmp	short GETENT
; ---------------------------------------------------------------------------

NONE:					; ...
		stc
		retn
; ---------------------------------------------------------------------------

HAVIT:					; ...
		mov	LASTENT, ax
		clc

nextentry_retn:				; ...
		retn
; ---------------------------------------------------------------------------

SAMECLUS:				; ...
		mov	SECCLUSPOS, bl
		mov	LASTENT, ax
		push	ds
		lds	di, CURBUF
		mov	dx, [di+8]
		mov	ss:HIGH_SECTOR,	dx
		mov	dx, [di+6]
		add	dx, 1
		adc	ss:HIGH_SECTOR,	0
		pop	ds
		call	FIRSTCLUSTER
		xor	bx, bx
		jmp	short SETENTRY
NEXTENTRY	endp


; =============== S U B	R O U T	I N E =======================================


GETENTRY	proc near		; ...
		mov	ax, LASTENT

GETENT:					; ...
		mov	LASTENT, ax
		mov	cl, 5
		rol	ax, cl
		mov	dx, ax
		and	ax, 0FFE0h
		and	dx, 1Fh
		mov	bx, es:[bp+2]
		and	bl, 0E0h	; 255-31
		div	bx
		mov	bx, dx
		push	bx
		call	DIRREAD
		pop	bx
		jb	short nextentry_retn

SETENTRY:				; ...
		mov	dx, word ptr CURBUF
		add	dx, 20
		add	bx, dx
		add	dx, es:[bp+2]
		clc
		retn
GETENTRY	endp


; =============== S U B	R O U T	I N E =======================================


SETDIRSRCH	proc near		; ...
		or	bx, bx
		jz	short SETROOTSRCH
		mov	DIRSTART, bx
		mov	al, es:[bp+4]
		inc	al
		mov	CLUSFAC, al
		push	si
		test	FastOpenFlg, 2
		jnz	short UNP_OK
		call	UNPACK
		jnb	short UNP_OK
		pop	si
		retn
; ---------------------------------------------------------------------------

UNP_OK:					; ...
		mov	CLUSNUM, di
		mov	dx, bx
		xor	bl, bl
		mov	SECCLUSPOS, bl
		call	FIGREC
		pop	si
		push	dx
		mov	dx, HIGH_SECTOR
		mov	DIRSEC+2, dx
		pop	dx
		mov	DIRSEC,	dx
		clc
		retn
SETDIRSRCH	endp


; =============== S U B	R O U T	I N E =======================================


SETROOTSRCH	proc near		; ...
		xor	ax, ax
		mov	DIRSTART, ax
		mov	SECCLUSPOS, al
		dec	ax
		mov	CLUSNUM, ax
		mov	ax, es:[bp+0Bh]
		mov	dx, es:[bp+11h]
		sub	ax, dx
		mov	CLUSFAC, al
		mov	DIRSEC,	dx
		mov	DIRSEC+2, 0
		clc
		retn
SETROOTSRCH	endp


; =============== S U B	R O U T	I N E =======================================


GETPATH		proc near		; ...

; FUNCTION CHUNK AT 7F82 SIZE 000001A5 BYTES

		mov	word ptr CREATING, 0E500h

GetPathNoSet:				; ...
		mov	EXTERR_LOCUS, 2
		mov	word ptr CURBUF, 0FFFFh
		mov	di, WFP_START
		cmp	word ptr [di+1], '\:'
		jz	short CrackIt
		add	di, 3
		mov	si, di
		call	CHKDEV
		jb	short InternalError

Build_devJ:				; ...
		mov	al, SATTRIB
		mov	ATTRIB,	al
		mov	EXTERR_LOCUS, 1
		push	ss
		pop	es
		mov	si, offset NAME1
		mov	di, WFP_START
		mov	dx, di
		mov	cx, 8

MoveLoop:				; ...
		lodsb
		stosb
		cmp	al, 20h	; ' '
		jz	short NoSave
		mov	dx, di

NoSave:					; ...
		loop	MoveLoop
		mov	di, dx
		mov	byte ptr [di], 0
		call	Build_device_ent
		inc	al
		retn
; ---------------------------------------------------------------------------

InternalError:				; ...
		jmp	short InternalError
; ---------------------------------------------------------------------------

CrackIt:				; ...
		mov	si, CURR_DIR_END
		cmp	si, 0FFFFh
		jnz	short LOOK_SING
		lea	si, [di+3]

LOOK_SING:				; ...
		mov	ATTRIB,	16h
		les	di, THISCDS
		mov	ax, 0FFFFh
		mov	bx, es:[di+73]
		mov	si, CURR_DIR_END
		cmp	si, ax
		jz	short NO_CURR_D
		cmp	bx, ax
		jz	short NO_CURR_D
		test	FastOpenFlg, 1
		jz	short GOT_SEARCH_CLUSTER
		push	es
		push	di
		push	cx
		push	word ptr [si-1]
		push	si
		push	bx
		mov	byte ptr [si-1], 0
		mov	si, WFP_START
		mov	bx, offset FastOpenTable
		mov	di, offset Dir_Info_Buff
		mov	cx, offset FastOpen_Ext_Info
		mov	al, 1
		push	ds
		pop	es
		call	dword ptr [bx+2]
		jb	short GO_Chk_end1
		cmp	byte ptr [si], 0
		jz	short GO_Chk_end
		stc
		jmp	short GO_Chk_end
; ---------------------------------------------------------------------------

GO_Chk_end1:				; ...
		clc

GO_Chk_end:				; ...
		pop	bx
		pop	si
		pop	word ptr [si-1]
		pop	cx
		pop	di
		pop	es
		jnb	short GOT_SEARCH_CLUSTER

NO_CURR_D:				; ...
		mov	si, WFP_START
		lea	si, [si+3]
		les	bp, THISDPB
		jmp	short ROOTPATH
; ---------------------------------------------------------------------------

GOT_SEARCH_CLUSTER:			; ...
		les	bp, THISDPB
		call	SETDIRSRCH
		jb	short SETFERR
		jmp	short FINDPATH
; ---------------------------------------------------------------------------

SETFERR:				; ...
		xor	cl, cl
		stc
		retn
GETPATH		endp


; =============== S U B	R O U T	I N E =======================================


CHKDEV		proc near		; ...
		mov	si, di
		mov	di, ss
		mov	es, di
		mov	di, offset NAME1
		mov	cx, 9

TESTLOOP:				; ...
		call	GETLET
		cmp	al, 2Eh	; '.'
		jz	short TESTDEVICE
		call	PATHCHRCMP
		jz	short NOTDEV
		or	al, al
		jz	short TESTDEVICE
		stosb
		loop	TESTLOOP

NOTDEV:					; ...
		stc
		retn
; ---------------------------------------------------------------------------

TESTDEVICE:				; ...
		add	cx, 2
		mov	al, 20h	; ' '
		rep stosb
		mov	ax, ss
		mov	ds, ax
		call	DEVNAME
		retn
CHKDEV		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR GETPATH

ROOTPATH:				; ...
		call	SETROOTSRCH
		cmp	byte ptr [si], 0
		jnz	short FINDPATH
		mov	al, SATTRIB
		mov	ATTRIB,	al
		xor	ah, ah
		retn
; ---------------------------------------------------------------------------

FINDPATH:				; ...
		push	es
		push	si
		mov	di, si
		mov	cx, DIRSTART
		cmp	CURR_DIR_END, 0FFFFh
		jz	short NOIDS
		cmp	di, CURR_DIR_END
		jnz	short NOIDS
		les	di, THISCDS
		mov	es:[di+73], cx

NOIDS:					; ...
		mov	ax, ss
		mov	es, ax
		mov	di, offset NAME1
		mov	ax, 2020h
		stosb
		stosw
		stosw
		stosw
		stosw
		stosw
		mov	di, offset NAME1
		xor	ah, ah

GetNam:					; ...
		inc	cl
		lodsb
		cmp	al, '.'
		jz	short _SetExt
		or	al, al
		jz	short _GetDone
		cmp	al, '\'
		jz	short _GetDone
		cmp	al, '?'
		jnz	short StoNam
		or	ah, 1

StoNam:					; ...
		stosb
		jmp	short GetNam
; ---------------------------------------------------------------------------

_SetExt:				; ...
		mov	di, (offset NAME1+8)

GetExt:					; ...
		lodsb
		or	al, al
		jz	short _GetDone
		cmp	al, '\'
		jz	short _GetDone
		cmp	al, '?'
		jnz	short StoExt
		or	ah, 1

StoExt:					; ...
		stosb
		jmp	short GetExt
; ---------------------------------------------------------------------------

_GetDone:				; ...
		dec	si
		mov	cl, ah
		or	cl, 80h
		pop	di
		pop	es
		cmp	si, di
		jnz	short check_device
		jmp	_BADPATH
; ---------------------------------------------------------------------------

check_device:				; ...
		push	si
		mov	al, [si]
		or	al, al
		jnz	short NOT_LAST
		mov	bh, SATTRIB
		mov	ATTRIB,	bh

NOT_LAST:				; ...
		push	es
		push	ss
		pop	es
		call	DEVNAME
		pop	es
		jb	short FindFile
		or	al, al
		jz	short GO_BDEV
		jmp	FILEINPATH
; ---------------------------------------------------------------------------

GO_BDEV:				; ...
		pop	si
		jmp	Build_devJ
; ---------------------------------------------------------------------------

FindFile:				; ...
		cmp	NAME1, 0E5h ; ''
		jnz	short NOE5
		mov	NAME1, 5

NOE5:					; ...
		push	di
		push	es
		push	cx
		call	LookupPath
		jnb	short DIR_FOUND
		call	SEARCH

DIR_FOUND:				; ...
		pop	cx
		pop	es
		pop	di
		jnb	short LOAD_BUF
		jmp	BADPATHPOP
; ---------------------------------------------------------------------------

LOAD_BUF:				; ...
		lds	di, CURBUF
		test	byte ptr [bx+0Bh], 10h
		jnz	short GO_NEXT
		jmp	FILEINPATH
; ---------------------------------------------------------------------------

GO_NEXT:				; ...
		cmp	ss:NoSetDir, 0
		jz	short SetDir
		mov	dx, di
		mov	cx, ds
		push	ss
		pop	ds
		pop	di
		test	FastOpenFlg, 1
		jz	short _nofast
		test	FastOpenFlg, 2
		jz	short _nofast
		mov	di, Next_Element_Start

_nofast:				; ...
		cmp	byte ptr [di], 0
		jnz	short NEXT_ONE
		jmp	_SETRET
; ---------------------------------------------------------------------------

NEXT_ONE:				; ...
		push	di
		mov	di, dx
		mov	ds, cx

SetDir:					; ...
		mov	dx, [si]
		push	ds
		push	ss
		pop	ds
		test	FastOpenFlg, 2
		jz	short DO_NORMAL
		mov	bx, dx
		mov	di, CLUSNUM
		push	ax
		call	SETDIRSRCH
		pop	ax
		add	sp, 2
		jmp	short FAST_OPEN_SKIP
; ---------------------------------------------------------------------------

DO_NORMAL:				; ...
		pop	ds
		sub	bx, di
		sub	si, di
		push	bx
		push	ax
		push	si
		push	cx
		push	word ptr [di+6]
		push	word ptr [di+8]
		mov	bx, dx
		push	ss
		pop	ds
		call	SETDIRSRCH
		pop	HIGH_SECTOR
		pop	dx
		jb	short SKIP_GETB
		mov	ALLOWED, 18h
		xor	al, al
		call	GETBUFFR

SKIP_GETB:				; ...
		pop	cx
		pop	si
		pop	ax
		pop	bx
		jnb	short SET_THE_BUF
		pop	di
		mov	si, di
		jmp	short _BADPATH
; ---------------------------------------------------------------------------

SET_THE_BUF:				; ...
		call	SET_BUF_AS_DIR
		mov	di, word ptr CURBUF
		add	si, di
		add	bx, di

FAST_OPEN_SKIP:				; ...
		pop	di
		call	InsertPath
		mov	al, [di]
		or	al, al
		jz	short _SETRET
		inc	di
		mov	si, di
		call	PATHCHRCMP
		jnz	short find_bad_name
		jmp	FINDPATH
; ---------------------------------------------------------------------------

find_bad_name:				; ...
		dec	si

_BADPATH:				; ...
		xor	cl, cl
		jmp	short BADPRET
; ---------------------------------------------------------------------------

FILEINPATH:				; ...
		pop	di
		push	ss
		pop	ds
		test	FastOpenFlg, 1
		jz	short NO_FAST
		test	FastOpenFlg, 2
		jz	short NO_FAST
		mov	di, Next_Element_Start

NO_FAST:				; ...
		mov	al, [di]
		or	al, al
		jz	short INCRET
		mov	si, di
		jmp	short BADPRET
; ---------------------------------------------------------------------------

INCRET:					; ...
		call	InsertPath
		inc	al

_SETRET:				; ...
		retn
; ---------------------------------------------------------------------------

BADPATHPOP:				; ...
		pop	si
		mov	al, [si]
		mov	si, di
		or	al, al

BADPRET:				; ...
		mov	al, SATTRIB
		mov	ATTRIB,	al
		stc
		retn
; END OF FUNCTION CHUNK	FOR GETPATH

; =============== S U B	R O U T	I N E =======================================


STARTSRCH	proc near		; ...
		les	bp, THISDPB
		xor	ax, ax
		mov	LASTENT, ax
		mov	VOLID, al
		dec	ax
		mov	ENTFREE, ax
		mov	ENTLAST, ax
		retn
STARTSRCH	endp


; =============== S U B	R O U T	I N E =======================================


MatchAttributes	proc near		; ...
		push	ax
		mov	al, ss:ATTRIB
		not	al
		and	al, ch
		and	al, 16h
		pop	ax
		retn
MatchAttributes	endp


; =============== S U B	R O U T	I N E =======================================


DEVNAME		proc near		; ...
		push	si
		push	di
		push	cx
		push	ax
		push	word ptr NAME1
		cmp	NAME1, 5
		jnz	short NOKTR
		mov	NAME1, 0E5h ; ''

NOKTR:					; ...
		test	ATTRIB,	8
		jnz	short RET31
		mov	si, offset NULDEV

LOOKIO:					; ...
		test	word ptr [si+4], 8000h
		jz	short SKIPDEV
		mov	ax, si
		add	si, 10
		mov	di, offset NAME1
		mov	cx, 4
		repe cmpsw
		mov	si, ax
		jz	short IOCHK

SKIPDEV:				; ...
		lds	si, [si]
		cmp	si, 0FFFFh
		jnz	short LOOKIO

RET31:					; ...
		stc

RETNV:					; ...
		mov	cx, ss
		mov	ds, cx
		pop	word ptr NAME1
		pop	ax
		pop	cx
		pop	di
		pop	si
		retn
; ---------------------------------------------------------------------------

IOCHK:					; ...
		mov	word ptr ss:DEVPT+2, ds
		mov	bh, [si+4]
		or	bh, 0C0h
		and	bh, 0DFh
		mov	word ptr ss:DEVPT, si
		jmp	short RETNV
DEVNAME		endp


; =============== S U B	R O U T	I N E =======================================


Build_device_ent proc near		; ...
		mov	ax, 2020h
		mov	di, (offset NAME1+8)
		stosw
		stosb
		mov	al, 40h	; '@'
		stosb
		xor	ax, ax
		mov	cx, 10
		rep stosw
		call	DATE16
		mov	di, (offset NAME2+0Ah)
		xchg	ax, dx
		stosw
		xchg	ax, dx
		stosw
		mov	si, di
		mov	ax, word ptr DEVPT
		stosw
		mov	ax, word ptr DEVPT+2
		stosw
		mov	ah, bh
		mov	bx, offset NAME1
		xor	al, al
		retn
Build_device_ent endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

ValidateCDS	proc near		; ...

SaveCDS		= dword	ptr -6
Temp		= word ptr -2

		push	bp
		mov	bp, sp
		sub	sp, 6
		mov	[bp+Temp], di
		lds	si, ss:THISCDS
		mov	word ptr [bp+SaveCDS], si
		mov	word ptr [bp+SaveCDS+2], ds
		call	ECritDisk
		test	word ptr [si+43h], 8000h
		jz	short _DoSplice
		jmp	FatFail
; ---------------------------------------------------------------------------

_DoSplice:				; ...
		xor	dl, dl
		xchg	dl, ss:NoSetDir
		push	ss
		pop	es
		call	FStrCpy
		mov	si, [bp+Temp]
		push	ss
		pop	ds
		call	Splice
		push	ss
		pop	ds
		mov	NoSetDir, dl
		les	di, THISCDS
		push	bp
		call	FATREAD_CDS
		pop	bp
		jb	short FatFail
		lds	si, THISCDS
		cmp	word ptr [si+49h], 0FFFFh
		jnz	short RestoreCDS
		push	ss
		pop	es
		push	ss:WFP_START
		cmp	si, word ptr [bp+SaveCDS]
		jnz	short DoChdir
		mov	di, [bp+Temp]
		mov	ss:WFP_START, di
		call	FStrCpy

DoChdir:				; ...
		push	ss
		pop	ds
		push	word ptr SATTRIB
		push	bp
		call	DOS_CHDIR
		pop	bp
		pop	bx
		pop	WFP_START
		mov	SATTRIB, bl
		lds	si, [bp+SaveCDS]
		jnb	short SetCluster
		mov	word ptr ss:THISCDS, si
		mov	word ptr ss:THISCDS+2, ds
		xor	cx, cx
		mov	[si+3],	cl

SetCluster:				; ...
		mov	word ptr [si+49h], 0FFFFh
		lds	si, ss:THISCDS
		test	word ptr [si+43h], 2000h
		jz	short _setdirclus
		mov	cx, 0FFFFh

_setdirclus:				; ...
		mov	[si+49h], cx

RestoreCDS:				; ...
		les	di, [bp+SaveCDS]
		mov	word ptr ss:THISCDS, di
		mov	word ptr ss:THISCDS+2, es
		clc

FatFail:				; ...
		call	LCritDisk
		les	di, [bp+SaveCDS]
		mov	sp, bp
		pop	bp
		retn
ValidateCDS	endp


; =============== S U B	R O U T	I N E =======================================


CheckThisDevice	proc near		; ...
		push	di
		push	si
		mov	di, si
		mov	al, [si]
		call	PATHCHRCMP
		jnz	short ParseDev
		inc	si
		lodsw
		or	ax, 2020h
		cmp	ax, 'ed'
		jnz	short NotDevice
		lodsb
		or	al, 20h
		cmp	al, 'v'
		jnz	short NotDevice
		lodsb
		call	PATHCHRCMP
		jnz	short NotDevice

ParseDev:				; ...
		push	ds
		push	si
		call	NameTrans
		cmp	byte ptr [si], 0
		stc
		jnz	short SkipSearch
		push	ss
		pop	ds
		mov	al, SATTRIB
		mov	ATTRIB,	al
		call	DEVNAME

SkipSearch:				; ...
		pop	si
		pop	ds

CheckReturn:				; ...
		pop	di
		jnb	short Check_Done
		mov	si, di

Check_Done:				; ...
		pop	di
		cmc
		retn
; ---------------------------------------------------------------------------

NotDevice:				; ...
		stc
		jmp	short CheckReturn
CheckThisDevice	endp


; =============== S U B	R O U T	I N E =======================================


LookupPath	proc near		; ...
		test	ss:FastOpenFlg,	1
		jnz	short FASTINST

NOLOOK:					; ...
		jmp	NOLOOKUP
; ---------------------------------------------------------------------------

FASTINST:				; ...
		test	ss:FastOpenFlg,	8
		jnz	short NOLOOK
		mov	bx, offset FastOpenTable
		mov	si, ss:WFP_START
		mov	di, offset Dir_Info_Buff
		mov	cx, offset FastOpen_Ext_Info
		mov	al, 1
		push	ds
		pop	es
		call	dword ptr [bx+2]
		jb	short NOTFOUND
		lea	bx, [si-2]
		cmp	bx, ss:WFP_START
		jz	short NOTFOUND
		cmp	byte ptr [si], 0
		jnz	short parfnd
		push	cx
		mov	cl, ss:ATTRIB
		mov	ch, ss:SATTRIB
		mov	ss:ATTRIB, ch
		mov	ch, es:[di+0Bh]
		call	MatchAttributes
		pop	cx
		jnz	short NOLOOKUP

parfnd:					; ...
		mov	ss:Next_Element_Start, si
		mov	bx, cx
		mov	ax, [bx+7]
		mov	ss:LASTENT, ax
		mov	ax, [bx+9]
		mov	ss:DIRSTART, ax
		mov	ax, [bx+5]
		mov	ss:CLUSNUM, ax
		push	es
		les	bx, ss:THISDPB
		mov	ah, es:[bx]
		pop	es
		mov	word ptr ss:CURBUF, 0
		mov	word ptr ss:CURBUF+2, es
		mov	bx, di
		lea	si, [di+1Ah]
		or	ss:FastOpenFlg,	12h
		retn
; ---------------------------------------------------------------------------

NOTFOUND:				; ...
		cmp	ax, 0FFFFh
		jnz	short Partial_Success
		mov	ss:FastOpenFlg,	0

Partial_Success:			; ...
		and	ss:FastOpenFlg,	0FBh

NOLOOKUP:				; ...
		stc
		retn
LookupPath	endp


; =============== S U B	R O U T	I N E =======================================


InsertPath	proc near		; ...
		pushf
		test	ss:FastOpenFlg,	1
		jz	short GET_NEXT_ELEMENT
		test	ss:FastOpenFlg,	2
		jz	short INSERT_DIR_INFO
		and	ss:FastOpenFlg,	0FDh
		mov	di, ss:Next_Element_Start
		jmp	short GET_NEXT2
; ---------------------------------------------------------------------------

INSERT_DIR_INFO:			; ...
		push	ds
		push	es
		push	bx
		push	si
		push	di
		push	cx
		push	ax
		lds	di, ss:CURBUF
		mov	si, offset FastOpen_Ext_Info
		mov	ax, [di+6]
		mov	ss:[si+1], ax
		mov	ax, [di+8]
		push	ss
		pop	ds
		mov	[si+3],	ax
		mov	ax, CLUSNUM
		mov	[si+5],	ax
		mov	ax, LASTENT
		mov	[si+7],	ax
		mov	ax, DIRSTART
		mov	[si+9],	ax
		mov	ax, bx
		add	di, 20
		sub	ax, di
		mov	cl, 32
		div	cl
		mov	[si], al
		push	ds
		pop	es
		mov	ds, word ptr CURBUF+2
		mov	di, bx
		cmp	word ptr [di+1Ah], 0
		jz	short SKIP_INSERT
		push	si
		pop	bx
		mov	al, 2
		mov	si, offset FastOpenTable
		call	dword ptr es:[si+2]
		clc

SKIP_INSERT:				; ...
		pop	ax
		pop	cx
		pop	di
		pop	si
		pop	bx
		pop	es
		pop	ds

GET_NEXT2:				; ...
		or	ss:FastOpenFlg,	8

GET_NEXT_ELEMENT:			; ...
		popf
		retn
InsertPath	endp

; ---------------------------------------------------------------------------
LenTab		db 22, 14, 22, 13, 15, 14 ; ...
CmdTab		db 86h,	4		; ...
		db 86h,	5
		db 87h,	8
		db 87h,	0Ah
		db 86h,	7
		db 86h,	5

; =============== S U B	R O U T	I N E =======================================


IOFUNC		proc near		; ...
		mov	word ptr ss:IOXAD+2, ss
		mov	word ptr ss:IOXAD, offset DEVIOBUF
		mov	ss:IOSCNT, 1
		mov	ss:DEVIOBUF, ax
		test	byte ptr [si+6], 80h
		jz	short IOTO22
		jmp	IOTOFILE
; ---------------------------------------------------------------------------

IOTO22:					; ...
		test	byte ptr [si+5], 80h
		jnz	short IOTO33
		jmp	IOTOFILE
; ---------------------------------------------------------------------------

IOTO33:					; ...
		push	es
		call	save_world
		mov	dx, ds
		mov	bx, ss
		mov	ds, bx
		mov	es, bx
		xor	bx, bx
		cmp	ah, 5
		jnz	short _no_sys_wait
		or	bx, 400h

_no_sys_wait:				; ...
		mov	IOCALL_REQSTAT,	bx
		xor	bx, bx
		mov	IOMED, bl
		mov	bl, ah
		mov	ah, cs:LenTab[bx]
		shl	bx, 1
		mov	cx, word ptr cs:CmdTab[bx]
		mov	bx, offset IOCALL
		mov	IOCALL,	ah
		mov	IOCALL_REQFUNC,	ch
		mov	ds, dx
		call	DEVIOCALL
		mov	di, ss:IOCALL_REQSTAT
		and	di, di
		js	short DevErr

OKDevIO:				; ...
		mov	ax, ss
		mov	ds, ax
		cmp	ch, 5
		jnz	short DNODRD
		mov	al, IOMED
		mov	byte ptr DEVIOBUF, al

DNODRD:					; ...
		mov	ah, byte ptr IOCALL_REQSTAT+1
		not	ah
		and	ah, 2

QuickReturn:
		call	restore_world
		pop	es
		pushf
		mov	al, ss:IoStatFail
		cbw
		cmp	ax, 0FFFFh
		jnz	short not_fail_ret
		inc	ss:IoStatFail
		popf
		retn
; ---------------------------------------------------------------------------

not_fail_ret:				; ...
		mov	ax, ss:DEVIOBUF
		popf
		retn
; ---------------------------------------------------------------------------

DevErr:					; ...
		mov	ah, cl
		call	CHARHARD
		cmp	al, 1
		jnz	short NO_RETRY
		call	restore_world
		pop	es
		jmp	IOFUNC
; ---------------------------------------------------------------------------

NO_RETRY:				; ...
		and	byte ptr ss:IOCALL_REQSTAT+1, 0FDh
		cmp	al, 3
		jnz	short not_fail
		dec	ss:IoStatFail

not_fail:				; ...
		jmp	short OKDevIO
; ---------------------------------------------------------------------------

IOTOFILE:				; ...
		or	ah, ah
		jz	short IOIN
		dec	ah
		jz	short IOIST
		dec	ah
		jz	short IOUT
		retn
; ---------------------------------------------------------------------------

IOIST:					; ...
		push	word ptr [si+15h]
		push	word ptr [si+17h]
		call	IOIN
		pop	word ptr [si+17h]
		pop	word ptr [si+15h]
		retn
; ---------------------------------------------------------------------------

IOUT:					; ...
		call	SETXADDR
		call	DOS_WRITE
		call	RESTXADDR

IOUT_retn:				; ...
		retn
IOFUNC		endp


; =============== S U B	R O U T	I N E =======================================


IOIN		proc near		; ...
		call	SETXADDR
		or	ss:DOS34_FLAG, 40h
		call	DOS_READ
		and	ss:DOS34_FLAG, 0FFBFh
		or	cx, cx
		call	RESTXADDR
		mov	al, byte ptr ss:DEVIOBUF
		jnz	short IOUT_retn
		mov	al, 1Ah
		retn
IOIN		endp


; =============== S U B	R O U T	I N E =======================================


SETXADDR	proc near		; ...
		pop	word ptr ss:CALLBPB
		push	es
		call	save_world
		push	word ptr ss:DMAADD
		push	word ptr ss:DMAADD+2
		mov	word ptr ss:THISSFT+2, ds
		push	ss
		pop	ds
		mov	word ptr THISSFT, si
		mov	cx, word ptr IOXAD+2
		mov	word ptr DMAADD+2, cx
		mov	cx, word ptr IOXAD
		mov	word ptr DMAADD, cx
		mov	cx, IOSCNT
		jmp	short RESTRET
SETXADDR	endp


; =============== S U B	R O U T	I N E =======================================


RESTXADDR	proc near		; ...
		pop	word ptr CALLBPB
		pop	word ptr DMAADD+2
		pop	word ptr DMAADD
		call	restore_world
		pop	es

RESTRET:				; ...
		jmp	word ptr ss:CALLBPB
RESTXADDR	endp


; =============== S U B	R O U T	I N E =======================================


DEV_OPEN_SFT	proc near		; ...
		push	es
		call	save_world
		mov	al, 0Dh
		jmp	short DO_OPCLS
DEV_OPEN_SFT	endp


; =============== S U B	R O U T	I N E =======================================


DEV_CLOSE_SFT	proc near		; ...
		push	es
		call	save_world
		mov	al, 0Eh

DO_OPCLS:				; ...
		test	byte ptr es:[di+6], 80h
		jnz	short OPCLS_DONE
		xor	ah, ah
		test	byte ptr es:[di+5], 80h
		les	di, es:[di+7]
		jnz	short GOT_DEV_ADDR
		cmp	ss:fShare, 1
		jbe	short OPCLS_DONE
		mov	ah, es:[di+1]
		mov	cl, es:[di]
		les	di, es:[di+13h]

GOT_DEV_ADDR:				; ...
		test	byte ptr es:[di+5], 8
		jz	short OPCLS_DONE
		push	es
		pop	ds
		mov	si, di

OPCLS_RETRY:				; ...
		push	ss
		pop	es
		mov	di, offset DEVCALL
		mov	bx, di
		push	ax
		mov	al, 13
		stosb
		pop	ax
		xchg	ah, al
		stosb
		xchg	ah, al
		stosb
		mov	word ptr es:[di], 0
		push	ax
		call	DEVIOCALL2
		mov	di, es:[bx+3]
		and	di, di
		jns	short OPCLS_DONEP
		test	byte ptr [si+5], 80h
		jz	short BLKDEV
		mov	ah, 86h
		jmp	short HRDERR
; ---------------------------------------------------------------------------

BLKDEV:					; ...
		mov	al, cl
		mov	ah, 6

HRDERR:					; ...
		call	CHARHARD
		cmp	al, 1
		jnz	short OPCLS_DONEP
		pop	ax
		jmp	short OPCLS_RETRY
; ---------------------------------------------------------------------------

OPCLS_DONEP:				; ...
		pop	ax

OPCLS_DONE:				; ...
		call	restore_world
		pop	es
		retn
DEV_CLOSE_SFT	endp


; =============== S U B	R O U T	I N E =======================================


DEVIOCALL	proc near		; ...
		lds	si, [si+7]
DEVIOCALL	endp


; =============== S U B	R O U T	I N E =======================================


DEVIOCALL2	proc near		; ...
		call	ECritDevice
		test	byte ptr [si+5], 80h
		jnz	short chardev2
		cmp	byte ptr es:[bx+2], 4
		jz	short chkext
		cmp	byte ptr es:[bx+2], 8
		jz	short chkext
		cmp	byte ptr es:[bx+2], 9
		jnz	short chardev2

chkext:					; ...
		call	RW_SC
		jb	short dev_exit
		test	byte ptr [si+4], 2
		jz	short chksector
		add	byte ptr es:[bx], 8
		mov	ax, word ptr ss:CALLBPB+2
		mov	word ptr ss:CALLBPB+2, 0FFFFh
		mov	word ptr ss:CALLNEWSC, ax
		mov	ax, ss:HIGH_SECTOR
		mov	word ptr ss:CALLNEWSC+2, ax
		jmp	short chardev2
; ---------------------------------------------------------------------------

chksector:				; ...
		cmp	ss:HIGH_SECTOR,	0
		jz	short chardev2
		mov	word ptr es:[bx+3], 8107h
		jmp	short dev_exit
; ---------------------------------------------------------------------------

chardev2:				; ...
		mov	ax, [si+6]
		mov	word ptr ss:CALLDEVAD, ax
		mov	word ptr ss:CALLDEVAD+2, ds
		call	ss:CALLDEVAD
		mov	ax, [si+8]
		mov	word ptr ss:CALLDEVAD, ax
		call	ss:CALLDEVAD
		call	VIRREAD
		jb	short chardev2

dev_exit:				; ...
		call	LCritDevice
		retn
DEVIOCALL2	endp


; =============== S U B	R O U T	I N E =======================================


SETREAD		proc near		; ...
		push	di
		push	cx
		push	ax
		mov	cl, 4

SETCALLHEAD:				; ...
		mov	al, 16h
		push	ss
		pop	es
		mov	di, offset DEVCALL
		stosb
		pop	ax
		stosb
		push	ax
		mov	al, cl
		stosb
		xor	ax, ax
		stosw
		add	di, 8
		pop	ax
		xchg	ah, al
		stosb
		xchg	al, ah
		push	ax
		mov	ax, bx
		stosw
		mov	ax, ds
		stosw
		pop	cx
		pop	ax
		stosw
		xchg	ax, dx
		stosw
		xchg	ax, cx
		xchg	dx, cx
		pop	di
		mov	bx, offset DEVCALL
		retn
SETREAD		endp


; =============== S U B	R O U T	I N E =======================================


SETWRITE	proc near		; ...
		push	di
		push	cx
		push	ax
		mov	cl, 8
		add	cl, ss:VERFLG
		jmp	short SETCALLHEAD
SETWRITE	endp


; =============== S U B	R O U T	I N E =======================================


RW_SC		proc near		; ...
		cmp	ss:SC_CACHE_COUNT, 0
		jz	short scexit4
		cmp	word ptr ss:CALLBPB, 1
		jnz	short scexit4
		push	cx
		push	dx
		push	ds
		push	si
		push	es
		push	di
		mov	dx, word ptr ss:CALLBPB+2
		cmp	ss:DEVCALL_REQFUNC, 4
		jz	short doread
		call	INVALIDATE_SC
		jmp	scexit2
; ---------------------------------------------------------------------------

scexit4:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

doread:					; ...
		call	SC2BUF
		jb	short readSC
		mov	ss:DEVCALL_REQSTAT, 100h
		stc
		jmp	short saveseq
; ---------------------------------------------------------------------------

readSC:					; ...
		mov	ax, ss:HIGH_SECTOR
		mov	cx, word ptr ss:CALLBPB+2
		sub	cx, ss:SEQ_SECTOR
		sbb	ax, ss:SEQ_SECTOR+2
		cmp	ax, 0
		jnz	short saveseq2

chklow:
		cmp	cx, 1
		ja	short saveseq2
		mov	ss:SC_STATUS, 0FFFFh
		mov	ax, ss:SC_CACHE_COUNT
		mov	word ptr ss:CALLBPB, ax

readsr:
		mov	ax, word ptr ss:CALLBR+2
		mov	ss:TEMP_VAR2, ax
		mov	ax, word ptr ss:CALLBR
		mov	ss:TEMP_VAR, ax
		mov	ax, word ptr ss:SC_CACHE_PTR
		mov	word ptr ss:CALLBR, ax
		mov	ax, word ptr ss:SC_CACHE_PTR+2
		mov	word ptr ss:CALLBR+2, ax
		mov	ss:SC_FLAG, 1
		mov	al, ss:SC_DRIVE
		mov	ss:CurSC_DRIVE,	al
		mov	ax, word ptr ss:CALLBPB+2
		mov	ss:CurSC_SECTOR, ax
		mov	ax, ss:HIGH_SECTOR
		mov	ss:CurSC_SECTOR+2, ax

saveseq2:				; ...
		clc

saveseq:				; ...
		mov	ax, ss:HIGH_SECTOR
		mov	ss:SEQ_SECTOR+2, ax
		mov	ax, word ptr ss:CALLBPB+2
		mov	ss:SEQ_SECTOR, ax
		jmp	short scexit
; ---------------------------------------------------------------------------

scexit2:				; ...
		clc

scexit:					; ...
		pop	di
		pop	es
		pop	si
		pop	ds
		pop	dx
		pop	cx
		retn
RW_SC		endp


; =============== S U B	R O U T	I N E =======================================


IN_SC		proc near		; ...
		mov	al, ss:SC_DRIVE
		cmp	al, ss:CurSC_DRIVE
		jnz	short outrange2
		mov	ax, ss:HIGH_SECTOR
		mov	cx, dx
		sub	cx, ss:CurSC_SECTOR
		sbb	ax, ss:CurSC_SECTOR+2
		cmp	ax, 0
		jnz	short outrange2
		cmp	cx, ss:SC_CACHE_COUNT
		jnb	short outrange2
		clc
		jmp	short inexit
; ---------------------------------------------------------------------------

outrange2:				; ...
		stc

inexit:					; ...
		retn
IN_SC		endp


; =============== S U B	R O U T	I N E =======================================


INVALIDATE_SC	proc near		; ...
		call	IN_SC
		jb	short outrange
		mov	ax, 1
		shl	ax, cl
		not	ax
		and	ss:SC_STATUS, ax

outrange:				; ...
		retn
INVALIDATE_SC	endp


; =============== S U B	R O U T	I N E =======================================


VIRREAD		proc near		; ...
		cmp	ss:SC_FLAG, 0
		jz	short sc2end
		mov	ax, ss:TEMP_VAR2
		mov	word ptr ss:CALLBR+2, ax
		mov	ax, ss:TEMP_VAR
		mov	word ptr ss:CALLBR, ax
		mov	ss:SC_FLAG, 0
		mov	word ptr ss:CALLBPB, 1
		test	byte ptr ss:DEVCALL_REQSTAT+1, 80h
		jnz	short scerror
		push	ds
		push	si
		push	es
		push	di
		push	dx
		push	cx
		xor	cx, cx
		call	SC2BUF2
		pop	cx
		pop	dx
		pop	di
		pop	es
		pop	si
		pop	ds
		jmp	short sc2end
; ---------------------------------------------------------------------------

scerror:				; ...
		mov	word ptr ss:CALLBPB, 1
		mov	ss:SC_STATUS, 0
		mov	ss:CurSC_DRIVE,	0FFh
		stc
		retn
; ---------------------------------------------------------------------------

sc2end:					; ...
		clc
		retn
VIRREAD		endp


; =============== S U B	R O U T	I N E =======================================


SC2BUF		proc near		; ...
		call	IN_SC
		jb	short noSC
		mov	ax, 1
		shl	ax, cl
		test	ss:SC_STATUS, ax
		jz	short noSC

SC2BUF2:				; ...
		mov	ax, cx
		mul	ss:SC_SECTOR_SIZE
		add	ax, word ptr ss:SC_CACHE_PTR
		adc	dx, word ptr ss:SC_CACHE_PTR+2
		mov	ds, dx
		mov	si, ax
		mov	es, word ptr ss:CALLBR+2
		mov	di, word ptr ss:CALLBR
		mov	cx, ss:SC_SECTOR_SIZE
		shr	cx, 1

MOVWORDS:
		cmp	ss:DDMOVE, 0
		jz	short nodd
		shr	cx, 1
; ---------------------------------------------------------------------------
		db 66h
; ---------------------------------------------------------------------------

nodd:					; ...
		rep movsw
		clc
		retn
; ---------------------------------------------------------------------------

noSC:					; ...
		stc
		retn
SC2BUF		endp


; =============== S U B	R O U T	I N E =======================================


BUILDDIR	proc near		; ...
		mov	ax, ENTFREE
		cmp	ax, 0FFFFh
		jz	short CHECK_IF_ROOT
		clc
		retn
; ---------------------------------------------------------------------------

CHECK_IF_ROOT:				; ...
		cmp	DIRSTART, 0
		jnz	short NEWDIR
		stc

builddir_retn:				; ...
		retn
; ---------------------------------------------------------------------------

NEWDIR:					; ...
		mov	bx, DIRSTART
		or	bx, bx
		jz	short NULLDIR
		call	GETEOF
		jb	short builddir_retn

NULLDIR:				; ...
		mov	cx, 1
		call	ALLOCATE
		jb	short builddir_retn
		mov	dx, DIRSTART
		or	dx, dx
		jnz	short ADDINGDIR
		call	SETDIRSRCH
		jb	short builddir_retn
		mov	LASTENT, 0FFFFh
		jmp	short GOTDIRREC
; ---------------------------------------------------------------------------

ADDINGDIR:				; ...
		push	bx
		mov	bx, CLUSNUM
		call	IsEOF
		pop	bx
		jb	short NOTFIRSTGROW
		mov	CLUSNUM, bx
		push	cx
		push	ax
		push	bp
		mov	ah, 1
		mov	dl, es:[bp+0]
		mov	cx, DIRSTART
		mov	bp, bx
		call	FastOpen_Update
		pop	bp
		pop	ax
		pop	cx

NOTFIRSTGROW:				; ...
		mov	dx, bx
		xor	bl, bl
		call	FIGREC

GOTDIRREC:				; ...
		mov	cl, es:[bp+4]
		inc	cl
		xor	ch, ch

ZERODIR:				; ...
		push	cx
		mov	ALLOWED, 18h
		mov	al, 0FFh
		call	GETBUFFR
		jnb	short GET_SSIZE
		pop	cx
		retn
; ---------------------------------------------------------------------------

GET_SSIZE:				; ...
		mov	cx, es:[bp+2]
		push	es
		les	di, CURBUF
		or	byte ptr es:[di+5], 4
		push	di
		add	di, 20
		xor	ax, ax
		shr	cx, 1
		rep stosw
		jnb	short EVENZ
		stosb

EVENZ:					; ...
		pop	di
		test	byte ptr es:[di+5], 40h
		jnz	short yesdirty7
		call	INC_DIRTY_COUNT
		or	byte ptr es:[di+5], 40h

yesdirty7:				; ...
		pop	es
		pop	cx
		add	dx, 1
		adc	HIGH_SECTOR, 0
		loop	ZERODIR
		mov	ax, LASTENT
		inc	ax
		clc
		retn
BUILDDIR	endp


; =============== S U B	R O U T	I N E =======================================


SETDOTENT	proc near		; ...
		stosw
		mov	cx, 4
		mov	ax, 2020h
		rep stosw
		stosb
		mov	al, 10h
		stosb
		add	di, 10
		mov	si, word ptr THISSFT
		mov	ax, [si+0Dh]
		stosw
		mov	ax, [si+0Fh]
		stosw
		mov	ax, dx
		stosw
		xor	ax, ax
		stosw
		stosw
		retn
SETDOTENT	endp


; =============== S U B	R O U T	I N E =======================================


MakeNode	proc near		; ...
		mov	word ptr CREATING, 0E5FFh
		push	ax
		mov	NoSetDir, 0
		mov	SATTRIB, al
		call	GetPathNoSet
		mov	dl, cl
		mov	cx, ax
		pop	ax
		jnb	short make_exists
		jnz	short make_err_4
		cmp	dl, 80h	; ''
		jz	short RENAME_MAKE

make_err_4:				; ...
		mov	al, 4

make_err_ret:				; ...
		xor	ah, ah
		stc
		retn
; ---------------------------------------------------------------------------

RENAME_MAKE:				; ...
		test	EXTOPEN_ON, 1
		jz	short make_type2
		or	EXTOPEN_ON, 4
		test	byte ptr EXTOPEN_FLAG, 0F0h
		jnz	short make_type2
		stc
		mov	ax, 7

make_retn:				; ...
		retn
; ---------------------------------------------------------------------------

make_type2:				; ...
		les	di, THISSFT
		xor	ax, ax
		stc
		jmp	short make_new
; ---------------------------------------------------------------------------

make_exists:				; ...
		jz	short make_exists_dir
		mov	al, 3
		test	ATTRIB,	18h
		jnz	short make_err_ret_5
		or	ch, ch
		js	short make_share
		or	ah, ah
		jnz	short make_err_ret
		push	cx
		mov	es, word ptr CURBUF+2
		mov	ch, es:[bx+0Bh]
		test	ch, 1
		jnz	short make_err_ret_5P
		call	MatchAttributes
		pop	cx
		jnz	short make_err_ret_5
		xor	al, al

make_share:				; ...
		xor	ah, ah
		push	ax
		push	cx
		mov	ah, ch
		call	DOOPEN
		les	di, THISSFT
		push	si
		push	bx
		call	ShareEnter
		jnb	short MakeEndShare
		pop	bx
		pop	si
		pop	cx
		pop	ax

Make_Share_ret:				; ...
		mov	al, 6
		jmp	short make_err_ret
; ---------------------------------------------------------------------------

make_err_ret_5P:			; ...
		pop	cx

make_err_ret_5:				; ...
		mov	al, 5
		jmp	short make_err_ret
; ---------------------------------------------------------------------------

make_exists_dir:			; ...
		mov	al, 1
		jmp	short make_err_ret
; ---------------------------------------------------------------------------

make_save:				; ...
		push	ax
		mov	ax, cx
		call	NEWENTRY
		pop	ax
		jnb	short make_retn
		mov	al, 2

make_save_retn:				; ...
		retn
; ---------------------------------------------------------------------------

make_new:				; ...
		call	make_save
		jb	short make_save_retn
		test	ATTRIB,	10h
		jnz	short make_save_retn
		push	ax
		push	bx
		push	si
		call	ShareEnter
		pop	si
		pop	bx
		pop	ax
		jnb	short make_save_retn
		push	ax
		les	di, CURBUF
		mov	byte ptr es:[bx], 0E5h ; ''
		test	byte ptr es:[di+5], 40h
		jnz	short yesdirty8
		call	INC_DIRTY_COUNT
		or	byte ptr es:[di+5], 40h

yesdirty8:				; ...
		les	bp, THISDPB
		mov	al, es:[bp+0]
		call	FLUSHBUF
		pop	ax
		jmp	short Make_Share_ret
; ---------------------------------------------------------------------------

MakeEndShare:				; ...
		les	di, THISSFT
		xor	ax, ax
		call	ECritDisk
		xchg	ax, es:[di]
		push	ax
		push	di
		push	es
		pushf
		call	ShareEnd
		popf
		pop	es
		pop	di
		pop	word ptr es:[di]
		call	LCritDisk
		pop	bx
		pop	si
		pop	cx
		pop	ax
		call	make_save
		jb	short make_save_retn
		push	ax
		push	bx
		push	si
		pushf
		call	ShareEnter
		popf
		pop	si
		pop	bx
		pop	ax

makeendshare_retn:			; ...
		retn
MakeNode	endp


; =============== S U B	R O U T	I N E =======================================


NEWENTRY	proc near		; ...
		les	bp, THISDPB
		jnb	short EXISTENT
		cmp	FAILERR, 0
		stc
		jnz	short makeendshare_retn
		call	BUILDDIR
		jb	short makeendshare_retn
		call	GETENT
		jb	short makeendshare_retn
		jmp	short FREESPOT
; ---------------------------------------------------------------------------

ERRRET3:				; ...
		stc

newentry_retn:				; ...
		retn
; ---------------------------------------------------------------------------

EXISTENT:				; ...
		or	ah, ah
		jns	short NOT_DEV1
		jmp	DOOPEN
; ---------------------------------------------------------------------------

NOT_DEV1:				; ...
		call	FREEENT
		jb	short newentry_retn

FREESPOT:				; ...
		test	ATTRIB,	8
		jz	short NOTVOLID
		cmp	VOLID, 0
		jnz	short ERRRET3

NOTVOLID:				; ...
		mov	es, word ptr CURBUF+2
		mov	di, bx
		mov	si, offset NAME1
		mov	cx, 5
		rep movsw
		movsb
		mov	al, ATTRIB
		stosb
		mov	cl, 5
		xor	ax, ax
		rep stosw
		call	DATE16
		xchg	ax, dx
		stosw
		xchg	ax, dx
		stosw
		xor	ax, ax
		push	di
		stosw
		stosw
		stosw
		mov	si, word ptr CURBUF
		test	byte ptr es:[si+5], 40h
		jnz	short yesdirty9
		call	INC_DIRTY_COUNT
		or	byte ptr es:[si+5], 40h

yesdirty9:				; ...
		les	bp, THISDPB
		mov	al, es:[bp+0]
		push	ax
		push	bx
		push	es
		push	di
		les	di, THISSFT
		test	byte ptr es:[di+5], 80h
		jnz	short GotADevice
		push	ds
		push	bx
		lds	bx, THISDPB
		mov	es:[di+7], bx
		mov	bx, ds
		mov	es:[di+9], bx
		pop	bx
		pop	ds
		call	DEV_OPEN_SFT
		mov	VIRTUAL_OPEN, 1

GotADevice:				; ...
		pop	di
		pop	es
		call	FLUSHBUF
		call	CHECK_VIRT_OPEN
		pop	bx
		pop	ax
		pop	si
		mov	ah, al
		jnb	short DOOPEN
		retn
NEWENTRY	endp


; =============== S U B	R O U T	I N E =======================================


DOOPEN		proc near		; ...
		mov	dh, ah
		les	di, THISSFT
		add	di, 4
		xor	al, al
		or	dh, dh
		js	short DEV_SFT1
		mov	ds, word ptr CURBUF+2
		mov	al, [bx+0Bh]

DEV_SFT1:				; ...
		stosb
		xor	ax, ax
		mov	al, dh
		or	al, 40h
		stosw
		push	ds
		lds	ax, [bx+1Ah]
		or	dh, dh
		js	short DEV_SFT2
		lds	ax, ss:THISDPB

DEV_SFT2:				; ...
		stosw
		mov	ax, ds
		pop	ds
		stosw
		push	si
		movsw
		sub	si, 6
		movsw
		movsw
		lodsw
		lodsw
		mov	cx, ax
		lodsw
		or	dh, dh
		jns	short FILE_SFT1
		xor	ax, ax
		mov	cx, ax

FILE_SFT1:				; ...
		xchg	ax, cx
		stosw
		xchg	ax, cx
		stosw
		xor	ax, ax
		stosw
		stosw
		or	dh, dh
		js	short DEV_SFT3
		stosw
		mov	ax, [bx+1Ah]
		push	di
		sub	di, 1Bh
		mov	es:[di+35h], ax
		pop	di
		push	ds
		push	ss
		pop	ds
		test	FastOpenFlg, 4
		jz	short Not_FastOpen
		mov	si, offset FastOpen_Ext_Info
		mov	ax, [si+1]
		stosw
		mov	ax, [si+3]
		stosw
		mov	al, [si]
		stosb
		pop	ds
		jmp	short Next_Name
; ---------------------------------------------------------------------------

Not_FastOpen:				; ...
		pop	ds
		mov	si, word ptr ss:CURBUF
		mov	ax, [si+6]
		stosw
		mov	ax, [si+8]
		stosw
		mov	ax, bx
		add	si, 20
		sub	ax, si
		mov	cl, 32
		div	cl
		stosb

Next_Name:				; ...
		jmp	short FILE_SFT2
; ---------------------------------------------------------------------------

DEV_SFT3:				; ...
		add	di, 7

FILE_SFT2:				; ...
		mov	si, bx
		mov	cx, 11
		rep movsb
		pop	si
		push	ss
		pop	ds
		clc
		retn
DOOPEN		endp


; =============== S U B	R O U T	I N E =======================================


FREEENT		proc near		; ...
		push	ds
		lds	di, CURBUF
		mov	cx, [si]
		mov	dx, [di+8]
		mov	ss:HIGH_SECTOR,	dx
		mov	dx, [di+6]
		pop	ds
		cmp	cx, 2
		jb	short RET1
		cmp	cx, es:[bp+0Dh]
		ja	short RET1
		sub	bx, di
		push	bx
		push	HIGH_SECTOR
		push	dx
		mov	bx, cx
		call	RELEASE
		pop	dx
		pop	HIGH_SECTOR
		jnb	short GET_BUF_BACK
		pop	bx

freeent_retn:				; ...
		retn
; ---------------------------------------------------------------------------

GET_BUF_BACK:				; ...
		mov	ALLOWED, 18h
		xor	al, al
		call	GETBUFFR
		pop	bx
		jb	short freeent_retn
		call	SET_BUF_AS_DIR
		add	bx, word ptr CURBUF
		mov	si, bx
		add	si, 1Ah

RET1:					; ...
		clc
		retn
FREEENT		endp


; =============== S U B	R O U T	I N E =======================================


CHECK_VIRT_OPEN	proc near		; ...
		push	ax
		lahf
		cmp	VIRTUAL_OPEN, 0
		jz	short ALL_CLOSED
		mov	VIRTUAL_OPEN, 0
		push	es
		push	di
		les	di, THISSFT
		call	DEV_CLOSE_SFT
		pop	di
		pop	es

ALL_CLOSED:				; ...
		sahf
		pop	ax
		retn
CHECK_VIRT_OPEN	endp


; =============== S U B	R O U T	I N E =======================================


FNDCLUS		proc near		; ...
		push	es
		les	di, THISSFT
		mov	bx, es:[di+35h]
		mov	dx, es:[di+19h]
		or	bx, bx
		jz	short NOCLUS
		sub	cx, dx
		jnb	short FINDIT
		add	cx, dx
		xor	dx, dx
		mov	bx, es:[di+0Bh]

FINDIT:					; ...
		pop	es
		jcxz	short RET9

SKPCLP:					; ...
		call	UNPACK
		jb	short fndclus_retn
		xchg	bx, di
		call	IsEOF
		xchg	bx, di
		jnb	short RET9
		xchg	bx, di
		inc	dx
		loop	SKPCLP

RET9:					; ...
		clc
		retn
; ---------------------------------------------------------------------------

NOCLUS:					; ...
		pop	es
		inc	cx
		dec	dx
		clc

fndclus_retn:				; ...
		retn
FNDCLUS		endp


; =============== S U B	R O U T	I N E =======================================


BUFSEC		proc near		; ...
		mov	dx, CLUSNUM
		mov	bl, SECCLUSPOS
		mov	ALLOWED, 38h ; '8'
		call	FIGREC
		call	GETBUFFR
		jb	short fndclus_retn
		mov	TRANS, 1
		mov	si, NEXTADD
		mov	di, si
		mov	cx, BYTCNT1
		add	di, cx
		mov	NEXTADD, di
		les	di, CURBUF
		or	byte ptr es:[di+5], 8
		lea	di, [di+20]
		add	di, BYTSECPOS
		clc
		retn
BUFSEC		endp


; =============== S U B	R O U T	I N E =======================================


BUFRD		proc near		; ...
		push	es
		xor	ax, ax
		call	BUFSEC
		jnb	short BUF_OK

BUF_IO_FAIL:				; ...
		pop	es
		jmp	short RBUFPLACED
; ---------------------------------------------------------------------------

BUF_OK:					; ...
		mov	bx, es
		mov	es, word ptr DMAADD+2
		mov	ds, bx
		xchg	di, si
		shr	cx, 1
		rep movsw
		adc	cx, 0
		rep movsb
		pop	es
		lds	di, ss:CURBUF
		lea	bx, [di+20]
		sub	si, bx
		call	PLACEBUF
		cmp	si, es:[bp+2]
		jb	short RBUFPLACEDC
		mov	word ptr ss:BufferQueue, di

RBUFPLACEDC:				; ...
		clc

RBUFPLACED:				; ...
		push	ss
		pop	ds
		retn
BUFRD		endp


; =============== S U B	R O U T	I N E =======================================


BUFWRT		proc near		; ...
		mov	ax, SECPOS
		add	ax, 1
		mov	SECPOS,	ax
		adc	SECPOS+2, 0
		mov	ax, SECPOS+2
		cmp	ax, VALSEC+2
		mov	al, 1
		ja	short NOREAD
		jb	short _doread
		mov	ax, SECPOS
		cmp	ax, VALSEC
		mov	al, 1
		ja	short NOREAD

_doread:				; ...
		xor	al, al

NOREAD:					; ...
		push	es
		call	BUFSEC
		jb	short BUF_IO_FAIL
		mov	ds, word ptr DMAADD+2
		shr	cx, 1
		rep movsw
		adc	cx, 0
		rep movsb
		pop	es
		lds	bx, ss:CURBUF
		test	byte ptr [bx+5], 40h
		jnz	short yesdirty10
		call	INC_DIRTY_COUNT
		or	byte ptr [bx+5], 40h

yesdirty10:				; ...
		lea	si, [bx+20]
		sub	di, si
		cmp	di, es:[bp+2]
		jb	short WBUFPLACED
		mov	word ptr ss:BufferQueue, bx

WBUFPLACED:				; ...
		clc
		push	ss
		pop	ds
		retn
BUFWRT		endp


; =============== S U B	R O U T	I N E =======================================


NEXTSEC		proc near		; ...
		test	TRANS, 0FFh
		jz	short CLRET
		mov	al, SECCLUSPOS
		inc	al
		cmp	al, es:[bp+4]
		jbe	short SAVPOS
		mov	bx, CLUSNUM
		call	IsEOF
		jnb	short NONEXT
		call	UNPACK
		jb	short NONEXT
		mov	CLUSNUM, di
		inc	LASTPOS
		mov	al, 0

SAVPOS:					; ...
		mov	SECCLUSPOS, al

CLRET:					; ...
		clc
		retn
; ---------------------------------------------------------------------------

NONEXT:					; ...
		stc
		retn
NEXTSEC		endp


; =============== S U B	R O U T	I N E =======================================


OPTIMIZE	proc near		; ...
		push	dx
		push	bx
		mov	al, es:[bp+4]
		inc	al
		mov	ah, al
		sub	al, dl
		mov	dx, cx
		mov	cx, 0

OPTCLUS:				; ...
		call	UNPACK
		jb	short OP_ERR
		add	cl, al
		adc	ch, 0
		cmp	cx, dx
		jnb	short BLKDON
		mov	al, ah
		inc	bx
		cmp	di, bx
		jz	short OPTCLUS
		dec	bx

FINCLUS:				; ...
		mov	CLUSNUM, bx
		sub	dx, cx
		push	dx
		mov	ax, cx
		mul	word ptr es:[bp+2]
		mov	si, NEXTADD
		add	ax, si
		mov	NEXTADD, ax
		pop	ax
		pop	dx
		sub	bx, dx
		add	LASTPOS, bx
		pop	bx
		call	FIGREC
		mov	bx, si
		clc
		retn
; ---------------------------------------------------------------------------

OP_ERR:					; ...
		add	sp, 4
		stc
		retn
; ---------------------------------------------------------------------------

BLKDON:					; ...
		sub	cx, dx
		sub	ah, cl
		dec	ah
		mov	SECCLUSPOS, ah
		mov	cx, dx
		jmp	short FINCLUS
OPTIMIZE	endp


; =============== S U B	R O U T	I N E =======================================


FIGREC		proc near		; ...
		push	cx
		mov	cl, es:[bp+5]
		dec	dx
		dec	dx
		mov	ss:HIGH_SECTOR,	0
		or	cl, cl
		jz	short noshift
		xor	ch, ch

rotleft:				; ...
		clc
		rcl	dx, 1
		rcl	ss:HIGH_SECTOR,	1
		loop	rotleft

noshift:				; ...
		or	dl, bl
		add	dx, es:[bp+0Bh]
		adc	ss:HIGH_SECTOR,	0
		pop	cx

figrec_retn:				; ...
		retn
FIGREC		endp

; ---------------------------------------------------------------------------

callmagic:				; ...
		push	ds
		push	ss:OffsetMagicPatch
		retf

; =============== S U B	R O U T	I N E =======================================


ALLOCATE	proc near		; ...
		clc
		push	cs
		call	callmagic
		jnb	short Regular_Allocate_Path
		jmp	Disk_Full_Return
; ---------------------------------------------------------------------------

Regular_Allocate_Path:			; ...
		push	bx
		xor	bx, bx
		call	UNPACK
		mov	FATBYT,	di
		pop	bx
		jb	short figrec_retn
		push	cx
		push	bx
		mov	dx, bx
		mov	bx, es:[bp+1Dh]
		cmp	bx, 2
		ja	short FINDFRE

ads1:					; ...
		mov	word ptr es:[bp+1Dh], 2
		mov	bx, 1

FINDFRE:				; ...
		inc	bx
		cmp	bx, es:[bp+0Dh]
		ja	short ads7
		call	UNPACK
		jb	short ads4
		jnz	short FINDFRE
		mov	es:[bp+1Dh], bx
		xchg	ax, dx
		mov	dx, 1
		call	PACK
		jb	short ads4
		cmp	word ptr es:[bp+1Fh], 0FFFFh
		jz	short NO_ALLOC
		dec	word ptr es:[bp+1Fh]

NO_ALLOC:				; ...
		xchg	ax, dx
		xchg	bx, dx
		mov	ax, dx
		call	PACK
		jb	short ads4
		xchg	ax, bx
		mov	dx, bx
		loop	FINDFRE
		mov	dx, 0FFFFh
		call	PACK

ads4:					; ...
		pop	bx
		pop	cx
		jb	short figrec_retn
		call	UNPACK
		jb	short figrec_retn
		call	RESTFATBYT
		jb	short figrec_retn
		xchg	bx, di
		or	di, di
		jz	short dofastk
		retn
; ---------------------------------------------------------------------------

dofastk:				; ...
		push	dx
		mov	dl, es:[bp+0]
		push	es
		les	di, THISSFT
		mov	es:[di+0Bh], bx
		mov	es:[di+35h], bx
		pop	es
		pop	dx
		retn
; ---------------------------------------------------------------------------

ads7:					; ...
		cmp	word ptr es:[bp+1Dh], 2
		jnz	short ads1
		pop	bx
		mov	dx, 0FFFFh
		call	RELBLKS
		pop	ax
		sub	ax, cx
		call	RESTFATBYT

Disk_Full_Return:			; ...
		mov	DISK_FULL, 1
		stc
		retn
ALLOCATE	endp


; =============== S U B	R O U T	I N E =======================================


RESTFATBYT	proc near		; ...
		push	bx
		push	dx
		push	di
		xor	bx, bx
		mov	dx, FATBYT
		call	PACK
		pop	di
		pop	dx
		pop	bx
		retn
RESTFATBYT	endp


; =============== S U B	R O U T	I N E =======================================


RELEASE		proc near		; ...
		xor	dx, dx

RELBLKS:				; ...
		call	UNPACK
		jb	short RELEASE_flush
		jz	short RELEASE_flush
		mov	ax, di
		push	dx
		call	PACK
		pop	dx
		jb	short RELEASE_flush
		or	dx, dx
		jnz	short NO_DEALLOC
		cmp	word ptr es:[bp+1Fh], -1
		jz	short NO_DEALLOC
		inc	word ptr es:[bp+1Fh]

NO_DEALLOC:				; ...
		mov	bx, ax
		dec	ax
		jz	short RELEASE_flush
		call	IsEOF
		jb	short RELEASE

RELEASE_flush:				; ...
		mov	al, es:[bp+0]
		push	si
		push	cx
		push	es
		push	bp
		call	FLUSHBUF
		pop	bp
		pop	es
		pop	cx
		pop	si

RET12:					; ...
		retn
RELEASE		endp


; =============== S U B	R O U T	I N E =======================================


GETEOF		proc near		; ...
		call	UNPACK
		jb	short RET12
		push	bx
		mov	bx, di
		call	IsEOF
		pop	bx
		jnb	short RET12
		mov	bx, di
		jmp	short GETEOF
GETEOF		endp


; =============== S U B	R O U T	I N E =======================================


MAKEFCB		proc near		; ...
		mov	ss:SpaceFlag, 0
		xor	dl, dl
		test	al, 2
		jnz	short DEFDRV
		mov	byte ptr es:[di], 0

DEFDRV:					; ...
		inc	di
		mov	cx, 8
		test	al, 4
		xchg	ax, bx
		mov	al, ' '
		jz	short FILLB
		add	di, cx
		xor	cx, cx

FILLB:					; ...
		rep stosb
		mov	cl, 3
		test	bl, 8
		jz	short FILLB2
		add	di, cx
		xor	cx, cx

FILLB2:					; ...
		rep stosb
		xchg	ax, cx
		stosw
		stosw
		sub	di, 16
		test	bl, 1
		jz	short SKPSPC
		call	SCANB
		call	DELIM
		jnz	short NOSCAN
		inc	si

SKPSPC:					; ...
		call	SCANB

NOSCAN:					; ...
		call	GETLET
		jbe	short NODRV
		cmp	byte ptr [si], ':'
		jnz	short NODRV
		inc	si
		sub	al, '@'
		jbe	short BADDRV
		push	ax
		call	GetVisDrv
		pop	ax
		jnb	short HAVDRV
		cmp	ss:DrvErr, 1Ah
		jz	short HAVDRV

BADDRV:					; ...
		mov	dl, -1

HAVDRV:					; ...
		stosb
		inc	si
		dec	di

NODRV:					; ...
		dec	si
		inc	di

NORMSCAN:				; ...
		mov	cx, 8
		call	GETWORD
		cmp	byte ptr [si], '.'
		jnz	short NODOT
		inc	si
		test	byte ptr ss:DOS34_FLAG+1, 1
		jz	short VOLOK
		movsb
		mov	cx, 2
		jmp	short contvol
; ---------------------------------------------------------------------------

VOLOK:					; ...
		mov	cx, 3

contvol:				; ...
		call	MUSTGETWORD

NODOT:					; ...
		mov	al, dl
		and	ss:DOS34_FLAG, 0FEFFh
		retn
MAKEFCB		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR GETWORD

NONAM:					; ...
		add	di, cx
		dec	si
		retn
; END OF FUNCTION CHUNK	FOR GETWORD

; =============== S U B	R O U T	I N E =======================================


GETWORD		proc near		; ...

; FUNCTION CHUNK AT 8F67 SIZE 00000004 BYTES

		call	GETLET
		jbe	short NONAM
		dec	si

MUSTGETWORD:				; ...
		call	GETLET
		jnz	short MustCheckCX
		test	ss:SpaceFlag, 0FFh
		jz	short FILLNAM
		cmp	al, ' '
		jnz	short FILLNAM

MustCheckCX:				; ...
		jcxz	short MUSTGETWORD
		dec	cx
		cmp	al, '*'
		jnz	short NOSTAR
		mov	al, '?'
		rep stosb

NOSTAR:					; ...
		stosb
		cmp	al, '?'
		jnz	short MUSTGETWORD
		or	dl, 1
		jmp	short MUSTGETWORD
; ---------------------------------------------------------------------------

FILLNAM:				; ...
		mov	al, ' '
		rep stosb
		dec	si
		retn
GETWORD		endp


; =============== S U B	R O U T	I N E =======================================


SCANB		proc near		; ...
		lodsb
		call	SPCHK
		jz	short SCANB
		dec	si

scanb_retn:				; ...
		retn
SCANB		endp


; =============== S U B	R O U T	I N E =======================================


NameTrans	proc near		; ...
		mov	ss:SpaceFlag, 1
		push	ss
		pop	es
		mov	di, offset NAME1
		push	di
		mov	ax, '  '
		mov	cx, 5
		stosb
		rep stosw
		xor	al, al
		mov	dl, al
		stosb
		pop	di
		call	NORMSCAN
		cmp	ss:NAME1, 0E5h
		jnz	short scanb_retn
		mov	ss:NAME1, 5
		retn
NameTrans	endp

; ---------------------------------------------------------------------------
CharType	db  66h, 66h, 66h, 66h,	06h, 66h, 66h, 66h; 0 ;	...
		db  66h, 66h, 66h, 66h,	66h, 66h, 66h, 66h; 8
		db 0F8h,0F6h,0FFh,0FFh,0FFh, 4Fh,0F4h, 6Eh; 16
		db 0FFh,0FFh,0FFh,0FFh,0FFh, 44h, 44h,0F4h; 24
		db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh; 32
		db 0FFh,0FFh,0FFh,0FFh,0FFh, 6Fh, 66h,0FFh; 40
		db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh; 48
		db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0F4h; 56

; =============== S U B	R O U T	I N E =======================================


GETLET		proc near		; ...
		lodsb
GETLET		endp


; =============== S U B	R O U T	I N E =======================================


UCase		proc near		; ...
		push	bx
		mov	bx, offset FILE_UCASE_TAB_2

gl_0:					; ...
		cmp	al, 'a'
		jb	short gl_2
		cmp	al, 'z'
		ja	short gl_1
		sub	al, 20h

gl_1:					; ...
		cmp	al, 80h
		jb	short gl_2
		sub	al, 80h
		push	ds
		mov	ds, cs:DosDSeg
		xlat
		pop	ds

gl_2:					; ...
		push	ax
		call	GetCharType
		test	al, 1
		pop	ax
		pop	bx
		retn
UCase		endp


; =============== S U B	R O U T	I N E =======================================


GETLET3		proc near		; ...
		push	bx
		jmp	short gl_0
GETLET3		endp


; =============== S U B	R O U T	I N E =======================================


DELIM		proc near		; ...
		push	ax
		call	GetCharType
		test	al, 2
		pop	ax
		retn
DELIM		endp


; =============== S U B	R O U T	I N E =======================================


SPCHK		proc near		; ...
		push	ax
		call	GetCharType
		test	al, 4
		pop	ax
		retn
SPCHK		endp


; =============== S U B	R O U T	I N E =======================================


GetCharType	proc near		; ...
		cmp	al, 7Eh
		jnb	short gct_90
		push	bx
		mov	bx, offset CharType
		shr	al, 1
		xlat	byte ptr cs:[bx]
		pop	bx
		jnb	short gct_80
		shr	al, 1
		shr	al, 1
		shr	al, 1
		shr	al, 1

gct_80:					; ...
		and	al, 0Fh
		retn
; ---------------------------------------------------------------------------

gct_90:					; ...
		mov	al, 0Fh
		retn
GetCharType	endp


; =============== S U B	R O U T	I N E =======================================


PATHCHRCMP	proc near		; ...
		cmp	al, '/'
		jbe	short PathRet
		cmp	al, '\'
		retn
; ---------------------------------------------------------------------------

GotFor:					; ...
		mov	al, '\'
		retn
; ---------------------------------------------------------------------------

PathRet:				; ...
		jz	short GotFor
		retn
PATHCHRCMP	endp

; ---------------------------------------------------------------------------
LowInt23Addr	dd LowInt23		; ...
LowInt24Addr	dd LowInt24		; ...
LowInt28Addr	dd LowInt28		; ...

; =============== S U B	R O U T	I N E =======================================


DSKSTATCHK	proc near		; ...
		cmp	ss:INDOS, 1
		jz	short dskstatchk1
		retn
; ---------------------------------------------------------------------------

dskstatchk1:				; ...
		push	cx
		push	es
		push	bx
		push	ds
		push	si
		mov	bx, ss
		mov	es, bx
		mov	ds, bx
		mov	ss:DSKSTCOM, 5
		mov	ss:DSKSTCALL, 0Eh
		mov	ss:DSKSTST, 0
		mov	bx, offset DSKSTCALL
		lds	si, ss:BCON
		call	DEVIOCALL2
		test	byte ptr ss:DSKSTST+1, 2
		jz	short _GotCh
		xor	al, al

RET36:					; ...
		pop	si
		pop	ds
		pop	bx
		pop	es
		pop	cx
		retn
; ---------------------------------------------------------------------------

_GotCh:					; ...
		mov	al, ss:DSKCHRET
		cmp	al, 3
		jnz	short RET36
		mov	ss:DSKSTCOM, 4
		mov	ss:DSKSTCALL, 16h
		mov	ss:DSKCHRET, cl
		mov	ss:DSKSTST, 0
		mov	ss:DSKSTCNT, 1
		call	DEVIOCALL2
		pop	si
		pop	ds
		pop	bx
		pop	es
		pop	cx
		jmp	CNTCHAND
DSKSTATCHK	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR STATCHK

NOSTOP:					; ...
		cmp	al, 10h
		jnz	short check_next
		cmp	ss:SCAN_FLAG, 0
		jz	short INCHKJ
		retn
; ---------------------------------------------------------------------------

check_next:				; ...
		cmp	al, 3
		jz	short INCHKJ

check_end:				; ...
		retn
; ---------------------------------------------------------------------------

INCHKJ:					; ...
		jmp	INCHK
; END OF FUNCTION CHUNK	FOR STATCHK

; =============== S U B	R O U T	I N E =======================================


SPOOLINT	proc near		; ...
		pushf
		cmp	ss:IDLEINT, 0
		jz	short POPFRET
		cmp	ss:ERRORMODE, 0
		jnz	short POPFRET
		push	word ptr ss:IDLEINT
		cmp	ss:DosHasHMA, 0
		jnz	short do_low_int28
		int	28h		; DOS 2+ internal - KEYBOARD BUSY LOOP
		jmp	short spool_ret_addr
; ---------------------------------------------------------------------------

do_low_int28:				; ...
		call	cs:LowInt28Addr

spool_ret_addr:				; ...
		pop	word ptr ss:IDLEINT

POPFRET:				; ...
		popf

_RET18:					; ...
		retn
SPOOLINT	endp


; =============== S U B	R O U T	I N E =======================================


STATCHK		proc far		; ...

; FUNCTION CHUNK AT 40D0 SIZE 00000003 BYTES
; FUNCTION CHUNK AT 40F8 SIZE 00000006 BYTES
; FUNCTION CHUNK AT 90F4 SIZE 00000015 BYTES

		call	DSKSTATCHK
		push	bx
		xor	bx, bx
		call	GET_IO_SFT
		pop	bx
		jb	short _RET18
		mov	ah, 1
		call	IOFUNC
		jz	short SPOOLINT
		cmp	al, 13h
		jnz	short NOSTOP
		cmp	ss:SCAN_FLAG, 0
		jnz	short check_end
		xor	ah, ah
		call	IOFUNC
		jmp	short PAUSOSTRT
; ---------------------------------------------------------------------------

PRINTONOFF:				; ...
		not	ss:PFLAG
		push	bx
		mov	bx, 4
		call	GET_IO_SFT
		pop	bx
		jb	short _RET18
		push	es
		push	di
		push	ds
		pop	es
		mov	di, si
		test	byte ptr es:[di+6], 8
		jz	short NORM_PR
		push	ax
		mov	ax, 1126h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - ???
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	ax
		jnb	short NORM_PR
		mov	ss:PFLAG, 0
		push	ax
		mov	ax, 1124h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - ???
					; ES:DI	-> SFT,	SS = DOS CS
		pop	ax
		jmp	short RETP6
; ---------------------------------------------------------------------------

NORM_PR:				; ...
		cmp	ss:PFLAG, 0
		jnz	short PRNOPN
		call	DEV_CLOSE_SFT
		jmp	short RETP6
; ---------------------------------------------------------------------------

PRNOPN:					; ...
		call	DEV_OPEN_SFT

RETP6:					; ...
		pop	di
		pop	es

STATCHK_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

PAUSOLP:				; ...
		call	SPOOLINT

PAUSOSTRT:				; ...
		mov	ah, 1
		call	IOFUNC
		jz	short PAUSOLP

INCHK:					; ...
		push	bx
		xor	bx, bx
		call	GET_IO_SFT
		pop	bx
		jb	short STATCHK_RETN
		xor	ah, ah
		call	IOFUNC
		cmp	al, 10h
		jz	short PRINTONOFF
		cmp	al, 3
		jnz	short STATCHK_RETN

CNTCHAND:				; ...
		test	byte ptr ss:DOS34_FLAG+1, 2
		jnz	short around_deadlock
		mov	al, 3
		call	BUFOUT
		call	CRLF

around_deadlock:			; ...
		push	ss
		pop	ds
		cmp	CONSWAP, 0
		jz	short NOSWAP
		call	SWAPBACK

NOSWAP:					; ...
		cli
		mov	ss, USER_SS
		mov	sp, USER_SP
		call	restore_world
		pop	es
		push	ds
		mov	ds, cs:DosDSeg
		mov	INDOS, 0
		mov	ERRORMODE, 0
		mov	ConC_Spsave, sp
		add	ConC_Spsave, 2
		cmp	DosHasHMA, 0
		pop	ds
		jnz	short do_low_int23
		clc
		int	23h		; DOS -	CONTROL	"C" EXIT ADDRESS
					; Return: return via RETF 2 with CF set
					; DOS will abort program with errorlevel 0
					; else
					; interrupted DOS call continues
		jmp	short ctrlc_ret_addr
; ---------------------------------------------------------------------------

do_low_int23:				; ...
		clc
		call	cs:LowInt23Addr

ctrlc_ret_addr:				; ...
		cli
		push	ax
		mov	ax, ds
		mov	ds, cs:DosDSeg
		mov	TEMPSEG, ax
		pop	ax
		mov	USER_IN_AX, ax
		pushf
		pop	ax
		cmp	sp, ConC_Spsave
		jnz	short ctrlc_try_new

ctrlc_repeat:				; ...
		mov	ax, USER_IN_AX
		mov	ds, TEMPSEG

COMMANDJ:				; ...
		jmp	command
; ---------------------------------------------------------------------------

ctrlc_try_new:				; ...
		add	sp, 2
		test	al, 1
		jz	short ctrlc_repeat
		mov	ds, TEMPSEG

ctrlc_abort:				; ...
		mov	ax, 4C00h
		push	ds
		mov	ds, cs:DosDSeg
		mov	DidCTRLC, 0FFh
		pop	ds
		jmp	short COMMANDJ
STATCHK		endp

; ---------------------------------------------------------------------------

DIVOV:					; ...
		mov	si, offset DIVMES ; "\r\nDivide	overflow\r\n"
		mov	bx, cs:DivMesLen
		mov	ss, cs:DosDSeg
		mov	sp, offset AUXSTACK
		call	_OUTMES
		jmp	short ctrlc_abort

; =============== S U B	R O U T	I N E =======================================


_OUTMES		proc near		; ...
		push	ss
		pop	es
		push	ss
		pop	ds
		mov	DSKSTCOM, 8
		mov	DSKSTCALL, 16h
		mov	DSKSTST, 0
		mov	DSKSTCNT, bx
		mov	bx, offset DSKSTCALL
		mov	DEVIOBUF_PTR, si
		mov	DOSSEG_INIT, cs
		lds	si, BCON
		call	DEVIOCALL2
		mov	es:DEVIOBUF_PTR, offset	DEVIOBUF
		mov	es:DSKSTCNT, 1
		retn
_OUTMES		endp


; =============== S U B	R O U T	I N E =======================================


CHARHARD	proc near		; ...
		cmp	ss:ERRORMODE, 0
		jnz	short chard1
		or	ah, 10h
		test	ss:PFLAG, 0FFh
		jnz	short ctrlp

chard1:					; ...
		or	ah, 38h

ctrlp:					; ...
		mov	ss:ALLOWED, ah
		mov	word ptr ss:EXITHOLD+2,	es
		mov	word ptr ss:EXITHOLD, bp
		push	si
		and	di, 0FFh
		mov	bp, ds
		call	FATALC
		pop	si
		retn
CHARHARD	endp


; =============== S U B	R O U T	I N E =======================================


HARDERR		proc near		; ...
		xchg	ax, di
		and	di, 0FFh
		cmp	di, 0
		jnz	short NOSETWRPERR
		push	ax
		mov	al, es:[bp+0]
		mov	ss:WPERR, al
		pop	ax

NOSETWRPERR:				; ...
		sub	ax, cx
		add	dx, ax
		push	dx
		mul	word ptr es:[bp+2]
		pop	dx
		add	bx, ax
		xor	ah, ah
		cmp	dx, es:[bp+6]
		jb	short ERRINT
		inc	ah
		cmp	dx, es:[bp+11h]
		jnb	short TESTDIR
		mov	word ptr es:[bp+1Fh], 0FFFFh
		jmp	short ERRINT
; ---------------------------------------------------------------------------

TESTDIR:				; ...
		inc	ah
		cmp	dx, es:[bp+0Bh]
		jb	short ERRINT
		inc	ah

ERRINT:					; ...
		shl	ah, 1
		or	ah, ss:READOP
		or	ah, ss:ALLOWED
HARDERR		endp


; =============== S U B	R O U T	I N E =======================================


FATAL		proc near		; ...
		mov	al, es:[bp+0]

FATAL1:					; ...
		mov	word ptr ss:EXITHOLD+2,	es
		mov	word ptr ss:EXITHOLD, bp
		les	si, es:[bp+13h]
		mov	bp, es
FATAL		endp


; =============== S U B	R O U T	I N E =======================================


FATALC		proc near		; ...

; FUNCTION CHUNK AT 9433 SIZE 000000A0 BYTES
; FUNCTION CHUNK AT A1EA SIZE 0000000D BYTES
; FUNCTION CHUNK AT A1FF SIZE 00000022 BYTES

		call	SET_I24_EXTENDED_ERROR
		cmp	di, 0Ch
		jbe	short NET_I24_ENTRY
		mov	di, 0Ch

NET_I24_ENTRY:				; ...
		cmp	ss:ERRORMODE, 0
		jz	short NoSetFail
		mov	al, 3
		jmp	short FailRet
; ---------------------------------------------------------------------------

NoSetFail:				; ...
		mov	ss:CONTSTK, sp
		push	ss
		pop	es
		cmp	ss:SFN,	0FFFFh
		jz	short _NoFree
		push	ds
		push	si
		lds	si, ss:PJFN
		mov	byte ptr [si], 0FFh
		pop	si
		pop	ds

_NoFree:				; ...
		cli
		inc	ss:ERRORMODE
		dec	ss:INDOS
		test	ss:EXTOPEN_ON, 2
		jz	short i24yes
		mov	al, 3
		jmp	short passi24
; ---------------------------------------------------------------------------

i24yes:					; ...
		mov	ss, ss:USER_SS
		mov	sp, es:USER_SP
		cmp	es:DosHasHMA, 0
		jnz	short do_low_int24
		int	24h		; DOS -	FATAL ERROR HANDLER ADDRESS
					; Automatically	called upon detection of unrecoverable I/O error.
		jmp	short criterr_ret_addr
; ---------------------------------------------------------------------------

do_low_int24:				; ...
		call	cs:LowInt24Addr

criterr_ret_addr:			; ...
		mov	es:USER_SP, sp
		mov	es:USER_SS, ss
		mov	bp, es
		mov	ss, bp

passi24:				; ...
		mov	sp, ss:CONTSTK
		inc	ss:INDOS
		mov	ss:ERRORMODE, 0
		sti

FailRet:				; ...
		les	bp, ss:EXITHOLD
		cmp	al, 1
		jb	short CheckIgnore
		jz	short CheckRetry
		cmp	al, 3
		jnz	short DoAbort
		test	ss:ALLOWED, 8
		jz	short DoAbort

DoFail:					; ...
		mov	al, 3
		test	ss:EXTOPEN_ON, 2
		jnz	short CleanUp
		inc	ss:FAILERR

CleanUp:				; ...
		mov	ss:WPERR, 0FFh
		cmp	ss:SFN,	0FFFFh
		jnz	short CleanUp2
		retn
; ---------------------------------------------------------------------------

CleanUp2:				; ...
		push	ds
		push	si
		push	ax
		mov	ax, ss:SFN
		lds	si, ss:PJFN
		mov	[si], al
		pop	ax
		pop	si
		pop	ds
		retn
; ---------------------------------------------------------------------------

CheckIgnore:				; ...
		test	ss:ALLOWED, 20h
		jz	short DoFail
		jmp	short CleanUp
; ---------------------------------------------------------------------------

CheckRetry:				; ...
		test	ss:ALLOWED, 10h
		jz	short DoFail
		jmp	short CleanUp
; ---------------------------------------------------------------------------

DoAbort:				; ...
		push	ss
		pop	ds
		cmp	CONSWAP, 0
		jz	short NOSWAP2
		call	SWAPBACK

NOSWAP2:				; ...
		cmp	fAborting, 0
		jnz	short DoFail
		mov	EXIT_TYPE, 2
		xor	al, al
		jmp	exit_inner
FATALC		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR FATALC

reset_environment:			; ...
		push	ds
		mov	ah, 82h	; ''
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTIONS 0 THROUGH 7
		mov	ss:fAborting, 0FFh
		mov	ax, 1122h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
					; SS = DOS CS
		mov	al, 22h	; '"'
		call	$GET_INTERRUPT_VECTOR
		pop	cx
		push	es
		push	bx
		mov	bx, ss:CurrentPDB
		mov	ds, bx
		mov	ax, word ptr OEM_HANDLER+2
		cmp	ax, bx
		jz	short reset_return
		cmp	bx, cx
		jnz	short reset_return
		push	ax
		cmp	ss:EXIT_TYPE, 3
		jz	short reset_to_parent
		call	arena_free_process
		call	DOS_ABORT

reset_to_parent:			; ...
		pop	ss:CurrentPDB

reset_return:				; ...
		push	ss
		pop	ds
		mov	al, 0FFh
		call	ECritDisk
		call	FLUSHBUF
		call	LCritDisk
		call	CHECK_VIRT_OPEN
		cli
		mov	INDOS, 0
		mov	WPERR, 0FFh
		mov	fAborting, 0
		pop	word ptr EXITHOLD
		pop	word ptr EXITHOLD+2
		mov	ds, CurrentPDB
		mov	ss, word ptr BCLOCK+2
		mov	sp, word ptr BCLOCK
		call	restore_world
		pop	es
		push	ax
		mov	ax, ds
		mov	ds, cs:DosDSeg
		mov	TEMPSEG, ax
		pop	ax
		mov	USER_SP, ax
		pop	ax
		pop	ax
		pop	ax
		lahf
		xchg	ah, al
		and	al, 2
		mov	ah, 0F2h ; ''
		push	ax
		push	word ptr EXITHOLD+2
		push	word ptr EXITHOLD
		mov	ax, USER_SP
		mov	ds, TEMPSEG
		iret
; END OF FUNCTION CHUNK	FOR FATALC

; =============== S U B	R O U T	I N E =======================================


SET_I24_EXTENDED_ERROR proc near	; ...
		push	ax
		mov	ax, offset FIRST_BUFF_ADDR
		sub	ax, offset ErrMap24
		push	ds
		mov	ds, cs:DosDSeg
		cmp	di, ax
		mov	ax, di
		jnb	short NoTrans
		mov	al, ErrMap24[di]
		xor	ah, ah

NoTrans:				; ...
		mov	EXTERR,	ax
		pop	ds
		pop	ax
		push	si
		mov	si, offset ERR_TABLE_24
		call	CAL_LK
		pop	si
		retn
SET_I24_EXTENDED_ERROR endp


; =============== S U B	R O U T	I N E =======================================


IsEOF		proc near		; ...
		cmp	word ptr es:[bp+0Dh], 0FF6h
		jnb	short EOF16
		cmp	bx, 0FF0h
		jz	short IsEOF_other
		cmp	bx, 0FF8h

IsEOF_other:				; ...
		retn
; ---------------------------------------------------------------------------

EOF16:					; ...
		cmp	bx, 0FFF8h
		retn
IsEOF		endp


; =============== S U B	R O U T	I N E =======================================


UNPACK		proc near		; ...
		or	bx, bx
		jnz	short up_cont
		mov	di, CL0FATENTRY
		or	di, di
		retn
; ---------------------------------------------------------------------------

up_cont:				; ...
		cmp	bx, es:[bp+0Dh]
		ja	short HURTFAT
		call	MAPCLUSTER
		jb	short _DoContext
		mov	di, [di]
		jnz	short High12
		mov	si, es:[bp+0Dh]
		cmp	si, 0FF6h
		jb	short Unpack12
		or	di, di
		jmp	short _DoContext
; ---------------------------------------------------------------------------

High12:					; ...
		shr	di, 1
		shr	di, 1
		shr	di, 1
		shr	di, 1

Unpack12:				; ...
		and	di, 0FFFh

_DoContext:				; ...
		push	ss
		pop	ds
		retn
; ---------------------------------------------------------------------------

HURTFAT:				; ...
		mov	word ptr es:[bp+1Fh], 0FFFFh
		push	ax
		mov	ah, 88h	; ''
		mov	ss:ALLOWED, 8
		mov	di, 0FFFh
		call	FATAL
		cmp	al, 3
		clc
		jnz	short OKU_RET
		stc

OKU_RET:				; ...
		pop	ax

hurtfat_retn:				; ...
		retn
UNPACK		endp


; =============== S U B	R O U T	I N E =======================================


PACK		proc near		; ...
		or	bx, bx
		jnz	short p_cont
		mov	CL0FATENTRY, dx
		retn
; ---------------------------------------------------------------------------

p_cont:					; ...
		call	MAPCLUSTER
		jb	short _DoContext
		mov	si, [di]
		jz	short ALIGNED
		push	cx
		mov	cl, 4
		shl	dx, cl
		pop	cx
		and	si, 0Fh
		jmp	short PACKIN
; ---------------------------------------------------------------------------

ALIGNED:				; ...
		cmp	word ptr es:[bp+0Dh], 0FF6h
		jnb	short Pack16
		and	si, 0F000h
		and	dx, 0FFFh
		jmp	short PACKIN
; ---------------------------------------------------------------------------

Pack16:					; ...
		xor	si, si

PACKIN:					; ...
		or	si, dx
		mov	[di], si
		lds	si, ss:CURBUF
		test	byte ptr [si+5], 40h
		jnz	short yesdirty11
		call	INC_DIRTY_COUNT
		or	byte ptr [si+5], 40h

yesdirty11:				; ...
		cmp	ss:CLUSSPLIT, 0
		push	ss
		pop	ds
		jz	short hurtfat_retn
		push	ax
		push	bx
		push	cx
		mov	ax, CLUSSAVE
		mov	ds, word ptr CURBUF+2
		add	si, 20
		mov	[si], ah
		push	ss
		pop	ds
		push	ax
		mov	dx, CLUSSEC+2
		mov	HIGH_SECTOR, dx
		mov	dx, CLUSSEC
		mov	si, 1
		xor	al, al
		call	GETBUFFRB
		pop	ax
		jb	short POPP_RET
		lds	di, CURBUF
		test	byte ptr [di+5], 40h
		jnz	short yesdirty12
		call	INC_DIRTY_COUNT
		or	byte ptr [di+5], 40h

yesdirty12:				; ...
		add	di, 20
		dec	di
		add	di, es:[bp+2]
		mov	[di], al
		clc

POPP_RET:				; ...
		push	ss
		pop	ds
		pop	cx
		pop	bx
		pop	ax
		retn
PACK		endp


; =============== S U B	R O U T	I N E =======================================


MAPCLUSTER	proc near		; ...
		mov	CLUSSPLIT, 0
		push	ax
		push	bx
		push	cx
		push	dx
		mov	ax, bx
		cmp	word ptr es:[bp+0Dh], 0FF6h
		jnb	short Map16
		shr	ax, 1

Map16:					; ...
		xor	di, di
		add	ax, bx
		adc	di, di
		mov	cx, es:[bp+2]
		cmp	cx, 512
		jnz	short _DoDiv
		mov	dx, ax
		and	dx, 1FFh
		mov	al, ah
		shr	di, 1
		rcr	al, 1
		xor	ah, ah
		jmp	short DivDone
; ---------------------------------------------------------------------------

_DoDiv:					; ...
		mov	dx, di
		div	cx

DivDone:				; ...
		add	ax, es:[bp+6]
		dec	cx
		push	ax
		push	dx
		push	cx
		mov	dx, ax
		mov	HIGH_SECTOR, 0
		xor	al, al
		mov	si, 1
		call	GETBUFFRB
		pop	cx
		pop	ax
		pop	dx
		jb	short MAP_POP
		lds	si, CURBUF
		lea	di, [si+20]
		add	di, ax
		cmp	ax, cx
		jnz	short MAPRET
		mov	al, [di]
		push	ss
		pop	ds
		inc	CLUSSPLIT
		mov	byte ptr CLUSSAVE, al
		mov	CLUSSEC, dx
		mov	CLUSSEC+2, 0
		inc	dx
		mov	HIGH_SECTOR, 0
		xor	al, al
		mov	si, 1
		call	GETBUFFRB
		jb	short MAP_POP
		lds	si, CURBUF
		lea	di, [si+20]
		mov	al, [di]
		push	ss
		pop	ds
		mov	byte ptr CLUSSAVE+1, al
		mov	di, offset CLUSSAVE

MAPRET:					; ...
		pop	dx
		pop	cx
		pop	bx
		xor	ax, ax
		cmp	word ptr es:[bp+0Dh], 0FF6h
		jnb	short MapSet
		mov	ax, bx

MapSet:					; ...
		test	al, 1
		pop	ax
		retn
; ---------------------------------------------------------------------------

MAP_POP:				; ...
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
MAPCLUSTER	endp


; =============== S U B	R O U T	I N E =======================================


FATREAD_SFT	proc near		; ...
		les	bp, es:[di+7]
		mov	al, es:[bp+0]
		mov	THISDRV, al
		call	GOTDPB
		call	FAT_GOT_DPB

fatread_sft_retn:			; ...
		retn
FATREAD_SFT	endp


; =============== S U B	R O U T	I N E =======================================


FATREAD_CDS	proc near		; ...
		push	es
		push	di
		les	bp, es:[di+45h]
		mov	al, es:[bp+0]
		mov	THISDRV, al
		call	GOTDPB
		call	FAT_GOT_DPB
		pop	di
		pop	es
		jb	short fatread_sft_retn
		jnz	short NO_CHANGE
		xor	ax, ax
		dec	ax
		push	ds
		mov	cl, CDSCOUNT
		xor	ch, ch
		lds	si, es:[di+45h]
		les	di, ss:CDSADDR

frcd20:					; ...
		test	byte ptr es:[di+44h], 80h
		jnz	short frcd25
		cmp	si, es:[di+45h]
		jnz	short frcd25
		mov	bx, ds
		cmp	bx, es:[di+47h]
		jnz	short frcd25
		test	es:[di+49h], ax
		jz	short frcd25
		mov	es:[di+49h], ax

frcd25:					; ...
		add	di, 88
		loop	frcd20
		pop	ds

NO_CHANGE:				; ...
		les	bp, THISDPB
		clc
		retn
FATREAD_CDS	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR FAT_GOT_DPB

FAT_operation:				; ...
		mov	word ptr es:[bp+1Fh], 0FFFFh
		and	di, 0FFh
		mov	ALLOWED, 18h
		mov	ah, 1Ah
		mov	al, THISDRV
		call	FATAL1
		les	bp, THISDPB
		cmp	al, 3
		jnz	short FAT_GOT_DPB
		stc
		retn
; END OF FUNCTION CHUNK	FOR FAT_GOT_DPB

; =============== S U B	R O U T	I N E =======================================


FAT_GOT_DPB	proc near		; ...

; FUNCTION CHUNK AT 971C SIZE 00000021 BYTES

		push	ss
		pop	ds
		mov	al, 0Fh
		mov	ah, es:[bp+1]
		mov	word ptr DEVCALL, ax
		mov	DEVCALL_REQFUNC, 1
		mov	DEVCALL_REQSTAT, 0
		mov	al, es:[bp+17h]
		mov	CALLUNIT, al
		push	es
		push	ds
		mov	bx, offset DEVCALL
		lds	si, es:[bp+13h]
		pop	es
		call	DEVIOCALL2
		push	ss
		pop	ds
		pop	es
		mov	di, DEVCALL_REQSTAT
		or	di, di
		js	short FAT_operation
		xor	ah, ah
		xchg	ah, es:[bp+18h]
		mov	al, THISDRV
		cmp	VOLCHNG_FLAG, al
		jnz	short CHECK_BYT
		mov	VOLCHNG_FLAG, 0FFh
		jmp	GOGETBPB
; ---------------------------------------------------------------------------

CHECK_BYT:				; ...
		or	ah, byte ptr CALLBR
		jns	short CHECK_ZR
		jmp	short NEWDSK
; ---------------------------------------------------------------------------

CHECK_ZR:				; ...
		jz	short CHKBUFFDIRT
		clc
		retn
; ---------------------------------------------------------------------------

DISK_CHNG_ERR:				; ...
		push	es
		push	bp
		les	bp, es:[bp+13h]
		test	byte ptr es:[bp+5], 8
		pop	bp
		pop	es
		jz	short FAIL_OPJ2
		push	ds
		push	di
		push	ss
		pop	ds
		mov	ALLOWED, 18h
		push	es
		les	di, CALLBR+1
		mov	word ptr EXTERRPT+2, es
		pop	es
		mov	word ptr EXTERRPT, di
		mov	ax, 0Fh
		mov	READOP,	1
		call	HARDERR
		pop	di
		pop	ds
		cmp	al, 3

FAIL_OPJ2:				; ...
		jz	short FAIL_OP
		jmp	FAT_GOT_DPB
; ---------------------------------------------------------------------------

CHKBUFFDIRT:				; ...
		cmp	ss:DirtyBufferCount, 0
		jz	short NEWDSK
		call	GETCURHEAD

nbuffer:				; ...
		cmp	[di+4],	al
		jnz	short lfnxt
		test	byte ptr [di+5], 40h
		jz	short lfnxt
		push	ss
		pop	ds
		clc
		retn
; ---------------------------------------------------------------------------

FAIL_OP:				; ...
		push	ss
		pop	ds
		stc
		retn
; ---------------------------------------------------------------------------

lfnxt:					; ...
		mov	di, [di]
		cmp	ss:FIRST_BUFF_ADDR, di
		jnz	short nbuffer

NEWDSK:					; ...
		mov	word ptr es:[bp+1Fh], 0FFFFh
		call	GETCURHEAD

nxbuffer:				; ...
		cmp	[di+4],	al
		jnz	short lfnxt2
		test	byte ptr [di+5], 40h
		jnz	short DISK_CHNG_ERR
		mov	word ptr [di+4], 20FFh
		call	SCANPLACE
		jmp	short skpbuff
; ---------------------------------------------------------------------------

lfnxt2:					; ...
		mov	di, [di]

skpbuff:				; ...
		cmp	di, ss:FIRST_BUFF_ADDR
		jnz	short nxbuffer
		cmp	ss:SC_CACHE_COUNT, 0
		jz	short GOGETBPB
		cmp	al, ss:CurSC_DRIVE
		jnz	short GOGETBPB
		mov	ss:CurSC_DRIVE,	0FFh

GOGETBPB:				; ...
		lds	di, es:[bp+13h]
		test	byte ptr [di+5], 20h
		jnz	short GETFREEBUF
		push	ss
		pop	ds
		mov	bx, 2
		call	UNPACK

FAIL_OPJ:				; ...
		jb	short FAIL_OP
		lds	di, CURBUF
		jmp	short GOTGETBUF
; ---------------------------------------------------------------------------

GETFREEBUF:				; ...
		push	es
		push	bp
		xor	dx, dx
		mov	ss:HIGH_SECTOR,	dx
		call	GETCURHEAD
		call	BUFWRITE
		pop	bp
		pop	es
		jb	short FAIL_OPJ

GOTGETBUF:				; ...
		add	di, 20
		mov	word ptr ss:CALLBR+2, ds
		push	ss
		pop	ds
		mov	word ptr CALLBR, di
		mov	al, 16h
		mov	ah, es:[bp+1]
		mov	word ptr DEVCALL, ax
		mov	DEVCALL_REQFUNC, 2
		mov	DEVCALL_REQSTAT, 0
		mov	al, es:[bp+17h]
		mov	CALLUNIT, al
		push	es
		push	ds
		push	word ptr es:[bp+15h]
		push	word ptr es:[bp+13h]
		mov	bx, offset DEVCALL
		pop	si
		pop	ds
		pop	es
		call	DEVIOCALL2
		pop	es
		push	ss
		pop	ds
		mov	di, DEVCALL_REQSTAT
		or	di, di
		js	short FATERRJ
		mov	al, es:[bp+17h]
		lds	si, CALLBPB
		mov	word ptr es:[bp+1Dh], 0
		call	$SETDPB
		lds	di, ss:CALLBR
		mov	al, es:[bp+8]
		mov	[di-0Ah], al
		mov	ax, es:[bp+0Fh]
		mov	[di-9],	ax
		push	ss
		pop	ds
		xor	al, al
		retn
; ---------------------------------------------------------------------------

FATERRJ:				; ...
		jmp	FAT_operation
FAT_GOT_DPB	endp


; =============== S U B	R O U T	I N E =======================================


GETCURHEAD	proc near		; ...
		lds	di, ss:BufferQueue
		mov	word ptr ss:LastBuffer,	0FFFFh
		mov	ss:FIRST_BUFF_ADDR, di
		retn
GETCURHEAD	endp


; =============== S U B	R O U T	I N E =======================================


SCANPLACE	proc near		; ...
		push	word ptr [di]
		call	PLACEBUF
		pop	di
		retn
SCANPLACE	endp


; =============== S U B	R O U T	I N E =======================================


PLACEBUF	proc near		; ...
		push	ax
		push	bx
		push	si
		mov	ax, [di]
		mov	bx, word ptr ss:BufferQueue
		cmp	ax, bx
		jz	short nret
		cmp	di, bx
		jnz	short not_first
		mov	word ptr ss:BufferQueue, ax
		jmp	short nret
; ---------------------------------------------------------------------------

not_first:				; ...
		mov	si, [di+2]
		mov	[si], ax
		xchg	ax, si
		mov	[si+2],	ax
		mov	si, [bx+2]
		mov	[si], di
		mov	[bx+2],	di
		mov	[di+2],	si
		mov	[di], bx

nret:					; ...
		pop	si
		pop	bx
		pop	ax
		cmp	byte ptr [di+4], 0FFh
		jnz	short pbx
		mov	word ptr ss:BufferQueue, di

pbx:					; ...
		retn
PLACEBUF	endp

; ---------------------------------------------------------------------------

POINTCOMP:				; ...
		cmp	si, di
		jnz	short _ret_label
		push	cx
		push	dx
		mov	cx, ds
		mov	dx, es
		cmp	cx, dx
		pop	dx
		pop	cx

_ret_label:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


GETBUFFR	proc near		; ...
		xor	si, si
GETBUFFR	endp


; =============== S U B	R O U T	I N E =======================================


GETBUFFRB	proc near		; ...
		mov	PREREAD, ax
		mov	al, es:[bp+0]
		lds	di, LastBuffer
		mov	cx, ss:HIGH_SECTOR
		cmp	di, 0FFFFh
		jz	short getb5
		cmp	dx, [di+6]
		jnz	short getb5
		cmp	cx, [di+8]
		jnz	short getb5
		cmp	al, [di+4]
		jnz	short getb5
		jmp	getb35
; ---------------------------------------------------------------------------

getb5:					; ...
		call	GETCURHEAD

getb10:					; ...
		cmp	dx, [di+6]
		jnz	short getb12
		cmp	cx, [di+8]
		jnz	short getb12
		cmp	al, [di+4]
		jnz	short getb12
		jmp	getb25
; ---------------------------------------------------------------------------

getb12:					; ...
		mov	di, [di]
		cmp	di, ss:FIRST_BUFF_ADDR
		jnz	short getb10
		push	cx
		push	si
		push	dx
		push	bp
		push	es
		call	BUFWRITE
		pop	es
		pop	bp
		pop	dx
		pop	si
		pop	ss:HIGH_SECTOR
		jnb	short getb13
		jmp	getbx
; ---------------------------------------------------------------------------

getb13:					; ...
		call	SET_RQ_SC_PARMS
		xor	ah, ah
		cmp	byte ptr ss:PREREAD, ah
		jnz	short getb20
		lea	bx, [di+20]
		mov	cx, 1
		push	si
		push	di
		push	dx
		push	es
		cmp	ss:BuffInHMA, 0
		jz	short getb14
		push	ds
		push	bx
		lds	bx, ss:LoMemBuff

getb14:					; ...
		or	si, si
		jz	short getb15
		call	FATSECRD
		mov	ah, 2
		jmp	short getb17
; ---------------------------------------------------------------------------

getb15:					; ...
		call	DREAD
		mov	ah, 0

getb17:					; ...
		pushf
		cmp	ss:BuffInHMA, 0
		jz	short not_in_hma
		mov	cx, es:[bp+2]
		shr	cx, 1
		popf
		mov	si, bx
		pop	di
		pop	es
		cld
		pushf
		rep movsw
		push	es
		pop	ds

not_in_hma:				; ...
		popf
		pop	es
		pop	dx
		pop	di
		pop	si
		jb	short getbx

getb20:					; ...
		mov	cx, ss:HIGH_SECTOR
		mov	[di+8],	cx
		mov	[di+6],	dx
		mov	[di+0Dh], bp
		mov	word ptr [di+0Fh], es
		mov	al, es:[bp+0]
		mov	[di+4],	ax

getb25:					; ...
		mov	byte ptr [di+0Ah], 1
		xor	ax, ax
		or	si, si
		jz	short getb30
		mov	al, es:[bp+8]
		mov	[di+0Ah], al
		mov	ax, es:[bp+0Fh]

getb30:					; ...
		mov	[di+0Bh], ax
		call	PLACEBUF

getb35:					; ...
		mov	word ptr ss:CURBUF+2, ds
		mov	word ptr ss:LastBuffer+2, ds
		mov	word ptr ss:CURBUF, di
		mov	word ptr ss:LastBuffer,	di
		clc

getbx:					; ...
		push	ss
		pop	ds

getbuffrb_retn:				; ...
		retn
GETBUFFRB	endp


; =============== S U B	R O U T	I N E =======================================


FLUSHBUF	proc near		; ...
		call	GETCURHEAD
		test	byte ptr ss:DOS34_FLAG,	4
		jnz	short scan_buf_queue
		cmp	ss:DirtyBufferCount, 0
		jz	short end_scan

scan_buf_queue:				; ...
		call	CHECKFLUSH
		mov	ah, [di+4]
		cmp	ss:WPERR, ah
		jz	short free_the_buf
		test	byte ptr ss:DOS34_FLAG,	4
		jz	short dont_free_the_buf

free_the_buf:				; ...
		mov	word ptr [di+4], 0FFh

dont_free_the_buf:			; ...
		mov	di, [di]
		cmp	di, ss:FIRST_BUFF_ADDR
		jnz	short scan_buf_queue

end_scan:				; ...
		push	ss
		pop	ds
		cmp	FAILERR, 0
		jnz	short bad_flush
		retn
; ---------------------------------------------------------------------------

bad_flush:				; ...
		stc
		retn
FLUSHBUF	endp


; =============== S U B	R O U T	I N E =======================================


CHECKFLUSH	proc near		; ...
		mov	ah, 0FFh
		cmp	[di+4],	ah
		jz	short getbuffrb_retn
		cmp	ah, al
		jz	short DOBUFFER
		cmp	al, [di+4]
		clc
		jnz	short getbuffrb_retn

DOBUFFER:				; ...
		test	byte ptr [di+5], 40h
		jz	short getbuffrb_retn
		push	ax
		push	word ptr [di+4]
		call	BUFWRITE
		pop	ax
		jb	short LEAVE_BUF
		and	ah, 0BFh
		mov	[di+4],	ax

LEAVE_BUF:				; ...
		pop	ax

checkflush_retn:			; ...
		retn
CHECKFLUSH	endp


; =============== S U B	R O U T	I N E =======================================


BUFWRITE	proc near		; ...
		mov	ax, 0FFh
		xchg	ax, [di+4]
		cmp	al, 0FFh
		jz	short checkflush_retn
		test	ah, 40h
		jz	short checkflush_retn
		call	DEC_DIRTY_COUNT
		cmp	al, ss:WPERR
		jz	short checkflush_retn
		mov	ss:SC_DRIVE, al
		les	bp, [di+0Dh]
		lea	bx, [di+14h]
		mov	dx, [di+6]
		mov	cx, [di+8]
		mov	ss:HIGH_SECTOR,	cx
		mov	cl, [di+0Ah]
		xor	ch, ch
		mov	ss:ALLOWED, 18h
		test	ah, 8
		jz	short NO_IGNORE
		or	ss:ALLOWED, 20h

NO_IGNORE:				; ...
		mov	ax, [di+11]
		push	di
		xor	di, di
		push	ds
		push	bx

WRTAGAIN:				; ...
		push	di
		push	cx
		push	ax
		mov	cx, 1
		push	bx
		push	dx
		push	ds
		cmp	ss:BuffInHMA, 0
		jz	short NBUFFINHMA
		push	cx
		push	es
		mov	si, bx
		mov	cx, es:[bp+2]
		shr	cx, 1
		les	di, ss:LoMemBuff
		mov	bx, di
		cld
		rep movsw
		push	es
		pop	ds
		pop	es
		pop	cx

NBUFFINHMA:				; ...
		call	DWRITE
		pop	ds
		pop	dx
		pop	bx
		pop	ax
		pop	cx
		pop	di
		jb	short NOSET
		inc	di

NOSET:					; ...
		add	dx, ax
		loop	WRTAGAIN
		pop	bx
		pop	ds
		or	di, di
		jnz	short BWROK
		stc

BWROK:					; ...
		pop	di
		retn
BUFWRITE	endp


; =============== S U B	R O U T	I N E =======================================


SET_RQ_SC_PARMS	proc near		; ...
		push	ax
		mov	ax, es:[bp+2]
		mov	ss:SC_SECTOR_SIZE, ax
		mov	al, es:[bp+0]
		mov	ss:SC_DRIVE, al
		pop	ax
		retn
SET_RQ_SC_PARMS	endp


; =============== S U B	R O U T	I N E =======================================


INC_DIRTY_COUNT	proc near		; ...
		inc	ss:DirtyBufferCount
		retn
INC_DIRTY_COUNT	endp


; =============== S U B	R O U T	I N E =======================================


DEC_DIRTY_COUNT	proc near		; ...
		cmp	ss:DirtyBufferCount, 0
		jz	short ddcx
		dec	ss:DirtyBufferCount

ddcx:					; ...
		retn
DEC_DIRTY_COUNT	endp

; ---------------------------------------------------------------------------

$WAIT:					; ...
		xor	ax, ax
		xchg	ax, ss:exit_code
		jmp	SYS_RET_OK

; =============== S U B	R O U T	I N E =======================================


$EXEC		proc far		; ...
		mov	ss:A20OFF_COUNT, 0
		cmp	al, 5
		jnz	short Exec_@f
		pop	cx
		mov	cx, offset LeaveDOS
		push	cx

Exec_@f:				; ...
		push	bp
		mov	bp, sp
		sub	sp, 29
		cmp	al, 5
		jbe	short Exec_Check_2

Exec_Bad_Fun:				; ...
		mov	ss:EXTERR_LOCUS, 1
		mov	al, 1

Exec_Ret_Err:				; ...
		mov	sp, bp
		pop	bp
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

ExecReadyJ:				; ...
		call	ExecReady
		jmp	norm_ovl
; ---------------------------------------------------------------------------

Exec_Check_2:				; ...
		cmp	al, 2
		jz	short Exec_Bad_Fun
		cmp	al, 4
		jz	short Exec_Bad_Fun
		cmp	al, 5
		jz	short ExecReadyJ
		mov	[bp-4],	bx
		mov	word ptr [bp-2], es
		mov	[bp-5],	al
		mov	byte ptr [bp-6], 0
		mov	[bp-26], dx
		mov	word ptr [bp-24], ds
		mov	si, dx
		call	DStrLen
		mov	[bp-22], cx
		mov	al, ss:AllocMethod
		mov	ss:ALLOCMSAVE, al
		xor	al, al
		push	bp
		or	ss:DOS_FLAG, 1
		call	$OPEN
		pushf
		and	ss:DOS_FLAG, 0FEh
		popf
		pop	bp
		jb	short Exec_Ret_Err
		mov	[bp-8],	ax
		mov	bx, ax
		xor	al, al
		call	$IOCTL
		jb	short Exec_BombJ
		test	dl, 80h
		jz	short Exec_Check_Environ
		mov	al, 2

Exec_BombJ:				; ...
		jmp	Exec_Bomb
; ---------------------------------------------------------------------------

BadEnv:					; ...
		mov	al, 0Ah
		jmp	Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Check_Environ:			; ...
		mov	word ptr [bp-18], 0
		mov	word ptr [bp-14], 0
		test	byte ptr [bp-5], 2
		jnz	short Exec_Read_Header
		lds	si, [bp-4]
		mov	ax, [si]
		or	ax, ax
		jnz	short Exec_Scan_Env
		mov	ds, ss:CurrentPDB
		mov	ax, word ptr SFT_ADDR+2
		or	ax, ax
		jz	short Exec_Read_Header

Exec_Scan_Env:				; ...
		mov	es, ax
		xor	di, di
		mov	cx, 8000h
		xor	al, al

Exec_Get_Environ_Len:			; ...
		repne scasb
		jnz	short BadEnv
		dec	cx
		js	short BadEnv
		scasb
		jnz	short Exec_Get_Environ_Len
		push	di
		lea	bx, [di+11h]
		add	bx, [bp-22]
		mov	cl, 4
		shr	bx, cl
		push	es
		call	$ALLOC
		pop	ds
		pop	cx
		jnb	short Exec_Save_Environ
		jmp	short Exec_No_Mem
; ---------------------------------------------------------------------------

Exec_Save_Environ:			; ...
		mov	es, ax
		mov	[bp-14], ax
		xor	si, si
		mov	di, si
		rep movsb
		mov	ax, 1
		stosw
		lds	si, [bp-26]
		mov	cx, [bp-22]
		rep movsb

Exec_Read_Header:			; ...
		push	ss
		pop	ds
		mov	cx, 26
		mov	dx, offset exec_signature
		push	es
		push	ds
		call	ExecRead
		pop	ds
		pop	es
		jb	short Exec_Bad_File
		or	ax, ax
		jz	short Exec_Bad_File
		cmp	ax, 26
		jnz	short Exec_Com_Filej
		test	exec_max_BSS, 0FFFFh
		jnz	short Exec_Check_Sig
		mov	byte ptr [bp-6], 0FFh

Exec_Check_Sig:				; ...
		mov	ax, exec_signature
		cmp	ax, 'ZM'
		jz	short Exec_Save_Start
		cmp	ax, 'MZ'
		jz	short Exec_Save_Start

Exec_Com_Filej:				; ...
		jmp	Exec_Com_File
; ---------------------------------------------------------------------------

Exec_Save_Start:			; ...
		mov	ax, exec_pages
		mov	cl, 5
		shl	ax, cl
		sub	ax, exec_par_dir
		mov	[bp-12], ax
		test	byte ptr [bp-5], 2
		jz	short Exec_Allocate
		les	di, [bp-4]
		mov	ax, es:[di]
		mov	[bp-20], ax
		mov	ax, es:[di+2]
		mov	[bp-10], ax
		jmp	Exec_Find_Res
; ---------------------------------------------------------------------------

Exec_No_Mem:				; ...
		mov	al, 8
		jmp	short Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Bad_File:				; ...
		mov	al, 0Bh

Exec_Bomb:				; ...
		mov	bx, [bp-8]
		call	Exec_Dealloc
		call	LCritDisk
		push	ax
		push	bp
		call	$CLOSE
		pop	bp
		pop	ax
		jmp	Exec_Ret_Err
; ---------------------------------------------------------------------------

Exec_Chk_Mem:				; ...
		mov	al, ss:AllocMethod
		mov	bl, ss:ALLOCMSAVE
		mov	ss:AllocMethod,	bl
		test	bl, 40h
		jnz	short Exec_No_Mem
		test	al, 40h
		jz	short Exec_No_Mem
		mov	ax, ss:SAVE_AX
		jmp	short Exec_Norm_Alloc
; ---------------------------------------------------------------------------

Exec_Allocate:				; ...
		mov	byte ptr [bp-29], 0
		cmp	exec_SS, 0
		jnz	short ea1
		cmp	exec_SP, 0
		jnz	short ea1
		inc	byte ptr [bp-29]
		cmp	ax, 0FF0h
		jnb	short ea1
		add	ax, 10h

ea1:					; ...
		test	AllocMethod, 80h
		jz	short Exec_Norm_Alloc
		or	AllocMethod, 40h

Exec_Norm_Alloc:			; ...
		mov	SAVE_AX, ax
		mov	bx, 0FFFFh
		push	ds
		call	$ALLOC
		pop	ds
		mov	ax, SAVE_AX
		add	ax, 10h
		cmp	bx, 11h
		jb	short Exec_Chk_Mem
		cmp	ax, bx
		ja	short Exec_Chk_Mem
		test	byte ptr [bp-6], 0FFh
		jnz	short Exec_BX_Max
		add	ax, exec_min_BSS
		jb	short Exec_Chk_Mem
		cmp	ax, bx
		ja	short Exec_Chk_Mem
		sub	ax, exec_min_BSS
		add	ax, exec_max_BSS
		jb	short Exec_BX_Max
		cmp	ax, bx
		jbe	short Exec_Got_Block

Exec_BX_Max:				; ...
		mov	ax, bx

Exec_Got_Block:				; ...
		push	ds
		mov	bx, ax
		mov	[bp-16], bx
		call	$ALLOC
		pop	ds
		jnb	short eat0
		jmp	Exec_Chk_Mem
; ---------------------------------------------------------------------------

eat0:					; ...
		mov	cl, ALLOCMSAVE
		mov	AllocMethod, cl
		cmp	byte ptr [bp-29], 0
		jz	short ea2
		cmp	bx, 1000h
		jnb	short ea2
		mov	cl, 4
		shl	bx, cl
		sub	bx, 100h
		mov	exec_SP, bx

ea2:					; ...
		mov	[bp-18], ax
		add	ax, 10h
		test	byte ptr [bp-6], 0FFh
		jz	short Exec_Use_AX
		add	ax, [bp-16]
		sub	ax, [bp-12]
		sub	ax, 10h

Exec_Use_AX:				; ...
		mov	[bp-10], ax
		mov	[bp-20], ax

Exec_Find_Res:				; ...
		mov	dx, [bp-20]
		mov	[bp-28], dx
		mov	dx, exec_par_dir
		push	dx
		mov	cl, 4
		shl	dx, cl
		pop	ax
		mov	cl, 12
		shr	ax, cl
		mov	cx, ax
		mov	bx, [bp-8]
		push	ds
		xor	al, al
		call	$LSEEK
		pop	ds
		jnb	short Exec_Big_Read
		jmp	Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Big_Read:				; ...
		mov	bx, [bp-12]
		cmp	bx, 1000h
		jb	short Exec_Read_OK
		mov	bx, 0FE0h

Exec_Read_OK:				; ...
		sub	[bp-12], bx
		push	bx
		mov	cl, 4
		shl	bx, cl
		mov	cx, bx
		push	ds
		mov	ds, word ptr [bp-20]
		xor	dx, dx
		push	cx
		call	ExecRead
		pop	cx
		pop	ds
		jb	short Exec_Bad_FileJ
		cmp	cx, ax
		pop	bx
		jz	short ExecCheckEnd
		sub	cx, ax
		cmp	cx, 512
		jnb	short Exec_Bad_FileJ

ExecCheckEnd:				; ...
		add	[bp-20], bx
		test	word ptr [bp-12], 0FFFFh
		jnz	short Exec_Big_Read
		mov	cx, [bp-10]
		mov	ax, exec_SS
		add	ax, cx
		mov	exec_init_SS, ax
		mov	ax, exec_SP
		mov	exec_init_SP, ax
		les	ax, dword ptr exec_IP
		mov	exec_init_IP, ax
		mov	ax, es
		add	ax, cx
		mov	exec_init_CS, ax
		xor	cx, cx
		mov	dx, exec_rle_table
		mov	bx, [bp-8]
		push	ds
		xor	ax, ax
		call	$LSEEK
		pop	ds
		jnb	short exec_get_entries

Exec_Bad_FileJ:				; ...
		jmp	Exec_Bad_File
; ---------------------------------------------------------------------------

exec_get_entries:			; ...
		mov	dx, exec_rle_count

exec_read_reloc:			; ...
		push	dx
		mov	dx, offset OPENBUF
		mov	cx, 396
		push	ds
		call	ExecRead
		pop	es
		pop	dx
		jb	short Exec_Bad_FileJ
		mov	cx, 99
		mov	di, offset OPENBUF
		mov	si, [bp-10]

exec_reloc_one:				; ...
		or	dx, dx
		jz	short Exec_Set_PDBJ

exec_get_addr:
		lds	bx, es:[di]
		mov	ax, ds
		add	ax, [bp-28]
		mov	ds, ax
		add	[bx], si
		add	di, 4
		dec	dx
		loop	exec_reloc_one
		push	es
		pop	ds
		jmp	short exec_read_reloc
; ---------------------------------------------------------------------------

Exec_Set_PDBJ:				; ...
		push	es
		push	ax
		push	cx
		mov	es, word ptr [bp-28]
		mov	ax, ss:exec_init_CS
		mov	cx, ss:exec_init_IP
		call	ss:FixExePatch
		call	ss:Rational386PatchPtr
		pop	cx
		pop	ax
		pop	es
		jmp	Exec_Set_PDB
; ---------------------------------------------------------------------------

Exec_No_Memj:				; ...
		jmp	Exec_No_Mem
; ---------------------------------------------------------------------------

Exec_Com_File:				; ...
		test	byte ptr [bp-5], 2
		jz	short Exec_Alloc_Com_File
		lds	si, [bp-4]
		lodsw
		mov	[bp-20], ax
		mov	ax, 0FFFFh
		jmp	short Exec_Read_Block
; ---------------------------------------------------------------------------

Exec_Chk_Com_Mem:			; ...
		mov	al, ss:AllocMethod
		mov	bl, ss:ALLOCMSAVE
		mov	ss:AllocMethod,	bl
		test	bl, 40h
		jnz	short Exec_No_Memj
		test	al, 40h
		jz	short Exec_No_Memj
		mov	ax, [bp-18]
		xor	bx, bx
		call	ChangeOwner
		jmp	short Exec_Norm_Com_Alloc
; ---------------------------------------------------------------------------

Exec_Alloc_Com_File:			; ...
		test	ss:AllocMethod,	80h
		jz	short Exec_Norm_Com_Alloc
		or	ss:AllocMethod,	40h

Exec_Norm_Com_Alloc:			; ...
		mov	bx, 0FFFFh
		call	$ALLOC
		or	bx, bx
		jz	short Exec_Chk_Com_Mem
		mov	[bp-16], bx
		push	bx
		call	$ALLOC
		pop	bx
		mov	[bp-18], ax
		add	ax, 10h
		mov	[bp-20], ax
		xor	ax, ax
		cmp	bx, 1000h
		jnb	short Exec_Read_Com
		mov	ax, bx
		mov	cl, 4
		shl	ax, cl
		cmp	ax, 200h
		jbe	short Exec_Chk_Com_Mem
		sub	ax, 100h

Exec_Read_Com:				; ...
		sub	ax, 100h

Exec_Read_Block:			; ...
		push	ax
		mov	bx, [bp-8]
		xor	cx, cx
		mov	dx, cx
		xor	ax, ax
		call	$LSEEK
		pop	cx
		mov	ds, word ptr [bp-20]
		xor	dx, dx
		push	cx
		call	ExecRead
		pop	si
		jnb	short OkRead
		jmp	Exec_Bad_File
; ---------------------------------------------------------------------------

OkRead:					; ...
		cmp	ax, si
		jnz	short OkRead2
		jmp	Exec_Chk_Com_Mem
; ---------------------------------------------------------------------------

OkRead2:				; ...
		mov	bl, ss:ALLOCMSAVE
		mov	ss:AllocMethod,	bl
		test	byte ptr [bp-5], 2
		jnz	short Exec_Set_PDB
		mov	ax, [bp-20]
		sub	ax, 10h
		mov	ss:exec_init_CS, ax
		mov	ss:exec_init_IP, 100h
		add	si, 0FEh ; ''
		cmp	si, 0FFFEh
		jz	short Exec_St_Ok
		add	si, 100h

Exec_St_Ok:				; ...
		mov	ss:exec_init_SP, si
		mov	ss:exec_init_SS, ax
		mov	ds, ax
		mov	word ptr [si], 0
		call	ss:ChkCopyProt

Exec_Set_PDB:				; ...
		mov	bx, [bp-8]
		call	Exec_Dealloc
		push	bp
		call	$CLOSE
		pop	bp
		call	Exec_Alloc
		test	byte ptr [bp-5], 2
		jz	short Exec_Build_Header
		call	Scan_Execname
		call	Scan_Special_Entries
		cmp	ss:DriverLoad, 0
		jz	short norm_ovl
		push	si
		push	es
		les	si, ss:BiosDataPtr
		cmp	byte ptr es:[si], 0
		jz	short sysinit_done
		mov	es, ss:CurrentPDB
		push	ss:SPECIAL_VERSION
		pop	word ptr es:SFTFCB
		jmp	short setver_done
; ---------------------------------------------------------------------------

sysinit_done:				; ...
		mov	ss:DriverLoad, 0

setver_done:				; ...
		pop	es
		pop	si

norm_ovl:				; ...
		mov	sp, bp
		pop	bp
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

Exec_Build_Header:			; ...
		mov	dx, [bp-18]
		mov	si, 1
		mov	ax, [bp-14]
		or	ax, ax
		jz	short No_Owner
		dec	ax
		mov	ds, ax
		mov	[si], dx

No_Owner:				; ...
		mov	ax, [bp-18]
		dec	ax
		mov	ds, ax
		mov	[si], dx
		push	ds
		pop	es
		mov	di, 8
		call	Scan_Execname
		push	cx
		push	si

MoveName:				; ...
		lodsb
		cmp	al, '.'
		jz	short mem_done
		stosb
		cmp	di, 16
		jnb	short mem_done
		loop	MoveName

mem_done:				; ...
		xor	al, al
		cmp	di, 16
		jnb	short Fill8
		stosb

Fill8:					; ...
		pop	si
		pop	cx
		call	Scan_Special_Entries
		push	dx
		mov	si, [bp-16]
		add	si, dx
		call	$DUP_PDB
		pop	dx
		push	word ptr [bp-14]
		pop	word ptr es:SFT_ADDR+2
		push	ss:SPECIAL_VERSION
		pop	word ptr es:SFTFCB
		lds	si, [bp-4]
		push	ds
		push	si
		lds	si, [si+6]
		mov	cx, 12
		push	cx
		mov	di, 5Ch
		mov	bl, [si]
		rep movsb
		xor	ax, ax
		stosw
		stosw
		pop	cx
		pop	si
		pop	ds
		push	ds
		push	si
		lds	si, [si+0Ah]
		mov	bh, [si]
		rep movsb
		stosw
		stosw
		pop	si
		pop	ds
		lds	si, [si+2]
		or	cl, 80h
		mov	di, cx
		rep movsb
		dec	cl
		mov	al, bh
		xor	bh, bh
		call	GetVisDrv
		jnb	short Exec_BL
		mov	bh, cl

Exec_BL:				; ...
		mov	al, bl
		xor	bl, bl
		call	GetVisDrv
		jnb	short Exec_Set_Return
		mov	bl, cl

Exec_Set_Return:			; ...
		call	Get_User_Stack
		push	word ptr [si+14h]
		push	word ptr [si+12h]
		push	word ptr [si+14h]
		push	word ptr [si+12h]
		pop	word ptr es:WinoldPatch1+4
		pop	word ptr es:WinoldPatch1+6
		xor	ax, ax
		mov	ds, ax
		pop	UNPACK_OFFSET+1
		pop	SAVE_AX
		mov	word ptr ss:DMAADD, 80h	; ''
		mov	ds, ss:CurrentPDB
		mov	word ptr ss:DMAADD+2, ds
		test	byte ptr [bp-5], 1
		jz	short exec_go
		lds	si, dword ptr ss:exec_init_SP
		les	di, [bp-4]
		mov	word ptr es:[di+10h], ds
		dec	si
		dec	si
		mov	[si], bx
		mov	es:[di+0Eh], si
		lds	ax, dword ptr ss:exec_init_IP
		mov	word ptr es:[di+14h], ds
		mov	es:[di+12h], ax
		mov	sp, bp
		pop	bp
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

exec_go:				; ...
		lds	si, dword ptr ss:exec_init_IP
		les	di, dword ptr ss:exec_init_SP
		mov	ax, es
		cmp	ss:DosHasHMA, 0
		jz	short Xfer_To_User
		push	ds
		mov	ds, cs:DosDSeg
		or	DOS_FLAG, 4
		mov	A20OFF_PSP, dx
		mov	ax, ds
		pop	ds
		push	ax
		mov	ax, offset disa20_xfer
		push	ax
		mov	ax, es
		retf
; ---------------------------------------------------------------------------

Xfer_To_User:				; ...
		cli
		mov	ss:INDOS, 0
		mov	ss, ax
		mov	sp, di
		sti
		push	ds
		push	si
		mov	es, dx
		mov	ds, dx
		mov	ax, bx
		retf
$EXEC		endp


; =============== S U B	R O U T	I N E =======================================


ExecRead	proc near		; ...
		call	Exec_Dealloc
		mov	bx, [bp-8]
		push	bp
		call	$READ
		pop	bp
		call	Exec_Alloc
		retn
ExecRead	endp


; =============== S U B	R O U T	I N E =======================================


Exec_Dealloc	proc near		; ...
		push	bx
		sub	bx, bx
		call	ECritDisk
		call	ChangeOwners
		pop	bx
		retn
Exec_Dealloc	endp


; =============== S U B	R O U T	I N E =======================================


Exec_Alloc	proc near		; ...
		push	bx
		mov	bx, ss:CurrentPDB
		call	ChangeOwners
		call	LCritDisk
		pop	bx
		retn
Exec_Alloc	endp


; =============== S U B	R O U T	I N E =======================================


ChangeOwners	proc near		; ...
		pushf
		push	ax
		mov	ax, [bp-14]
		call	ChangeOwner
		mov	ax, [bp-18]
		call	ChangeOwner
		pop	ax
		popf

chgown_retn:				; ...
		retn
ChangeOwners	endp


; =============== S U B	R O U T	I N E =======================================


ChangeOwner	proc near		; ...
		or	ax, ax
		jz	short chgown_retn
		dec	ax
		push	ds
		mov	ds, ax
		mov	word ptr byte_0+1, bx
		pop	ds
		retn
ChangeOwner	endp


; =============== S U B	R O U T	I N E =======================================


Scan_Execname	proc near		; ...
		lds	si, [bp-26]

Scan_Execname1:				; ...
		mov	cx, si

Scan0:					; ...
		lodsb
		cmp	al, ':'
		jz	short Scan_Execname1
		cmp	al, '\'
		jz	short Scan_Execname1
		cmp	al, 0
		jnz	short Scan0
		sub	si, cx
		xchg	si, cx
		retn
Scan_Execname	endp


; =============== S U B	R O U T	I N E =======================================


Scan_Special_Entries proc near		; ...
		dec	cx
		mov	ss:SPECIAL_VERSION, 1406h
		les	di, ss:UU_IFS_DOS_CALL
		mov	ax, es
		or	ax, di
		jz	short End_List

GetEntries:				; ...
		mov	al, es:[di]
		or	al, al
		jz	short End_List
		mov	ss:TEMP_VAR2, di
		cmp	al, cl
		jnz	short SkipOne
		inc	di
		push	cx
		push	si
		push	ax

sse_next_char:				; ...
		lodsb
		call	UCase
		scasb
		jnz	short Not_Matched
		loop	sse_next_char
		pop	ax
		mov	ax, es:[di]
		mov	ss:SPECIAL_VERSION, ax
		pop	si
		pop	cx
		jmp	short End_List
; ---------------------------------------------------------------------------

Not_Matched:				; ...
		pop	ax
		pop	si
		pop	cx

SkipOne:				; ...
		mov	di, ss:TEMP_VAR2
		xor	ah, ah
		add	di, ax
		add	di, 3
		jmp	short GetEntries
; ---------------------------------------------------------------------------

End_List:				; ...
		retn
Scan_Special_Entries endp

; ---------------------------------------------------------------------------

$KEEP_PROCESS:				; ...
		push	ax
		mov	ss:EXIT_TYPE, 3
		mov	es, ss:CurrentPDB
		cmp	dx, 6
		jnb	short Keep_Shrink
		mov	dx, 6

Keep_Shrink:				; ...
		mov	bx, dx
		push	bx
		push	es
		call	$SETBLOCK
		pop	ds
		pop	bx
		jb	short Keep_Done
		mov	ax, ds
		add	ax, bx
		mov	word ptr byte_0+2, ax

Keep_Done:				; ...
		pop	ax
		jmp	short exit_inner
; ---------------------------------------------------------------------------

stay_resident:				; ...
		mov	ax, 3100h
		add	dx, 15
		rcr	dx, 1
		mov	cl, 3
		shr	dx, cl
		jmp	command
; ---------------------------------------------------------------------------

$EXIT:					; ...
		xor	ah, ah
		xchg	ah, ss:DidCTRLC
		or	ah, ah
		mov	ss:EXIT_TYPE, 0
		jz	short exit_inner
		mov	ss:EXIT_TYPE, 1
; START	OF FUNCTION CHUNK FOR FATALC

exit_inner:				; ...
		call	Get_User_Stack
		push	ss:CurrentPDB
		pop	word ptr [si+14h]
		jmp	short abort_inner
; END OF FUNCTION CHUNK	FOR FATALC
; ---------------------------------------------------------------------------

$ABORT:					; ...
		xor	al, al
		mov	ss:EXIT_TYPE, 0
; START	OF FUNCTION CHUNK FOR FATALC

abort_inner:				; ...
		mov	ah, ss:EXIT_TYPE
		mov	ss:exit_code, ax
		call	Get_User_Stack
		mov	ds, word ptr [si+14h]
		xor	ax, ax
		mov	es, ax
		mov	si, 10
		mov	di, 88h
		movsw
		movsw
		movsw
		movsw
		movsw
		movsw
		jmp	reset_environment
; END OF FUNCTION CHUNK	FOR FATALC
; ---------------------------------------------------------------------------

RetExePatch:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


arena_free_process proc	near		; ...
		mov	ax, ss:arena_head

arena_free_process_start:		; ...
		mov	di, 0
		call	check_signature

arena_free_process_loop:		; ...
		jb	short check_signature_ok
		push	es
		pop	ds
		cmp	word ptr byte_0+1, bx
		jnz	short arena_free_next
		mov	word ptr byte_0+1, di

arena_free_next:			; ...
		cmp	byte ptr [di], 5Ah ; 'Z'
		jz	short arena_chk_umbs
		call	arena_next
		jmp	short arena_free_process_loop
; ---------------------------------------------------------------------------

arena_chk_umbs:				; ...
		mov	ax, ss:UMB_HEAD
		cmp	ax, 0FFFFh
		jz	short check_signature_ok
		mov	di, ds
		cmp	di, ax
		jnb	short check_signature_ok
		jmp	short arena_free_process_start
arena_free_process endp


; =============== S U B	R O U T	I N E =======================================


arena_next	proc near		; ...
		mov	ax, ds
		add	ax, word ptr byte_0+3
		inc	ax
arena_next	endp


; =============== S U B	R O U T	I N E =======================================


check_signature	proc near		; ...
		mov	es, ax
		cmp	byte ptr es:[di], 4Dh ;	'M'
		jz	short check_signature_ok
		cmp	byte ptr es:[di], 5Ah ;	'Z'
		jz	short check_signature_ok
		stc

check_signature_ok:			; ...
		retn
check_signature	endp


; =============== S U B	R O U T	I N E =======================================


Coalesce	proc near		; ...
		cmp	byte ptr [di], 5Ah ; 'Z'
		jz	short check_signature_ok
		call	arena_next
		jb	short check_signature_ok
		cmp	word ptr es:byte_0+1, di
		jnz	short check_signature_ok
		mov	cx, word ptr es:byte_0+3
		inc	cx
		add	word ptr byte_0+3, cx
		mov	cl, es:[di]
		mov	[di], cl
		jmp	short Coalesce
Coalesce	endp


; =============== S U B	R O U T	I N E =======================================


$ALLOC		proc near		; ...
		call	ECritDisk
		mov	ax, ss:arena_head
		mov	ss:START_ARENA,	ax
		test	ss:AllocMethod,	0C0h
		jz	short norm_alloc
		test	ss:UMBFLAG, 1
		jz	short norm_alloc
		mov	ax, ss:UMB_HEAD
		mov	ss:START_ARENA,	ax

norm_alloc:				; ...
		xor	ax, ax
		mov	di, ax
		mov	ss:FirstArena, ax
		mov	ss:BestArena, ax
		mov	ss:LastArena, ax
		push	ax

start_scan:				; ...
		mov	ax, ss:START_ARENA
		call	check_signature
		jb	short alloc_err

alloc_scan:				; ...
		push	es
		pop	ds
		cmp	word ptr byte_0+1, di
		jz	short alloc_free

alloc_next:				; ...
		test	ss:UMBFLAG, 1
		jz	short norm_strat
		test	ss:AllocMethod,	80h
		jz	short norm_strat
		mov	ax, ss:START_ARENA
		cmp	ax, ss:arena_head
		jnz	short norm_strat
		mov	ax, ds
		cmp	ax, ss:UMB_HEAD
		jmp	short alloc_chk_end
; ---------------------------------------------------------------------------

norm_strat:				; ...
		cmp	byte ptr [di], 5Ah ; 'Z'

alloc_chk_end:				; ...
		jz	short alloc_end
		call	arena_next
		jnb	short alloc_scan

alloc_err:				; ...
		pop	ax

alloc_trashed:				; ...
		call	LCritDisk
		mov	al, 7

alloc_errj:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

alloc_end:				; ...
		cmp	ss:FirstArena, 0
		jz	short alloc_chk
		jmp	alloc_do_split
; ---------------------------------------------------------------------------

alloc_chk:				; ...
		mov	ax, ss:arena_head
		cmp	ax, ss:START_ARENA
		jz	short alloc_fail
		test	ss:AllocMethod,	40h
		jnz	short alloc_fail
		mov	ss:START_ARENA,	ax
		jmp	short start_scan
; ---------------------------------------------------------------------------

alloc_fail:				; ...
		call	Get_User_Stack
		pop	bx
		mov	[si+2],	bx
		call	LCritDisk
		mov	al, 8
		jmp	short alloc_errj
; ---------------------------------------------------------------------------

alloc_free:				; ...
		call	Coalesce
		jb	short alloc_err
		mov	cx, word ptr byte_0+3
		pop	dx
		cmp	cx, dx
		jbe	short alloc_test
		mov	dx, cx

alloc_test:				; ...
		push	dx
		cmp	bx, cx
		ja	short alloc_next
		cmp	ss:FirstArena, 0
		jnz	short alloc_best
		mov	ss:FirstArena, ds

alloc_best:				; ...
		cmp	ss:BestArena, 0
		jz	short alloc_make_best
		push	es
		mov	es, ss:BestArena
		cmp	word ptr es:byte_0+3, cx
		pop	es
		jbe	short alloc_last

alloc_make_best:			; ...
		mov	ss:BestArena, ds

alloc_last:				; ...
		mov	ss:LastArena, ds
		jmp	alloc_next
; ---------------------------------------------------------------------------

alloc_do_split_high:			; ...
		mov	ds, ss:LastArena
		mov	cx, word ptr byte_0+3
		sub	cx, bx
		mov	dx, ds
		jz	short alloc_set_owner
		add	dx, cx
		mov	es, dx
		dec	cx
		xchg	bx, cx
		jmp	short alloc_set_sizes
; ---------------------------------------------------------------------------

alloc_do_split:				; ...
		xor	cx, cx
		mov	cl, ss:AllocMethod
		and	cx, 0FF3Fh
		cmp	cx, 1
		ja	short alloc_do_split_high
		mov	ds, ss:FirstArena
		jb	short alloc_get_size
		mov	ds, ss:BestArena

alloc_get_size:				; ...
		mov	cx, word ptr byte_0+3
		sub	cx, bx
		mov	ax, ds
		mov	dx, ax
		jz	short alloc_set_owner
		add	ax, bx
		inc	ax
		mov	es, ax
		dec	cx

alloc_set_sizes:			; ...
		mov	word ptr byte_0+3, bx
		mov	word ptr es:byte_0+3, cx
		mov	bl, 4Dh	; 'M'
		xchg	bl, [di]
		mov	es:[di], bl
		mov	word ptr es:byte_0+1, di

alloc_set_owner:			; ...
		mov	ds, dx
		mov	ax, ss:CurrentPDB
		mov	word ptr byte_0+1, ax
		mov	ax, ds
		inc	ax
		pop	bx
		call	LCritDisk

alloc_ok:				; ...
		jmp	SYS_RET_OK
$ALLOC		endp

; ---------------------------------------------------------------------------

$SETBLOCK:				; ...
		call	ECritDisk
		mov	di, 0
		mov	ax, es
		dec	ax
		call	check_signature
		jnb	short setblock_grab

setblock_bad:				; ...
		jmp	alloc_trashed
; ---------------------------------------------------------------------------

setblock_grab:				; ...
		mov	ds, ax
		call	Coalesce
		jb	short setblock_bad
		mov	cx, word ptr byte_0+3
		push	cx
		cmp	bx, cx
		jbe	short alloc_get_size
		jmp	alloc_fail

; =============== S U B	R O U T	I N E =======================================


$DEALLOC	proc near		; ...
		call	ECritDisk
		test	ss:DOS_FLAG, 4
		jz	short deallocate
		cmp	ss:A20OFF_COUNT, 0
		jnz	short deallocate
		mov	ss:A20OFF_COUNT, 1

deallocate:				; ...
		mov	di, 0
		mov	ax, es
		dec	ax
		call	check_signature
		jb	short dealloc_err
		mov	word ptr es:byte_0+1, di
		call	LCritDisk

dealloc_ok:				; ...
		jmp	short alloc_ok
; ---------------------------------------------------------------------------

dealloc_err:				; ...
		call	LCritDisk
		mov	al, 9

dealloc_errj:				; ...
		jmp	SYS_RET_ERR
$DEALLOC	endp

; ---------------------------------------------------------------------------

$ALLOCOPER:				; ...
		or	al, al
		jz	short AllocGetStrat
		cmp	al, 1
		jz	short AllocSetStrat
		cmp	al, 2
		jz	short AllocGetLink
		cmp	al, 3
		jz	short AllocSetLink

AllocOperError:				; ...
		mov	ss:EXTERR_LOCUS, 5
		mov	al, 1

AllocOperErrj:				; ...
		jmp	short dealloc_errj
; ---------------------------------------------------------------------------

AllocArenaError:			; ...
		mov	ss:EXTERR_LOCUS, 5
		mov	al, 7
		jmp	short AllocOperErrj
; ---------------------------------------------------------------------------

AllocGetStrat:				; ...
		mov	al, ss:AllocMethod
		xor	ah, ah

AllocOperOK:				; ...
		jmp	short dealloc_ok
; ---------------------------------------------------------------------------

AllocSetStrat:				; ...
		push	bx
		and	bx, 0FF3Fh
		cmp	bx, 2
		pop	bx
		ja	short AllocOperError

AllocOperSet:
		mov	ss:AllocMethod,	bl

AllocOperSetOK:				; ...
		jmp	short AllocOperOK
; ---------------------------------------------------------------------------

AllocGetLink:				; ...
		mov	al, ss:UMBFLAG
		and	al, 1

AllocGetLinkOK:				; ...
		jmp	short AllocOperSetOK
; ---------------------------------------------------------------------------

AllocSetLink:				; ...
		mov	cx, ss:UMB_HEAD
		cmp	cx, 0FFFFh
		jz	short AllocOperError
		cmp	bx, 1
		jb	short UnlinkUmbs
		jz	short LinkUmbs
		jmp	short AllocOperError
; ---------------------------------------------------------------------------

UnlinkUmbs:				; ...
		test	ss:UMBFLAG, 1
		jz	short unlinked
		call	GetLastArena
		jb	short AllocArenaError
		mov	byte ptr 0, 5Ah	; 'Z'
		and	ss:UMBFLAG, 0FEh

unlinked:				; ...
		jmp	short AllocGetLinkOK
; ---------------------------------------------------------------------------

LinkUmbs:				; ...
		test	ss:UMBFLAG, 1
		jnz	short linked
		call	GetLastArena
		jb	short AllocArenaError
		mov	byte ptr 0, 4Dh	; 'M'
		or	ss:UMBFLAG, 1

linked:					; ...
		jmp	short unlinked

; =============== S U B	R O U T	I N E =======================================


GetLastArena	proc near		; ...
		push	ax
		mov	ax, ss:arena_head
		mov	es, ax
		xor	di, di
		cmp	byte ptr es:[di], 5Ah ;	'Z'
		jz	short GLA_done

GLA_next:				; ...
		mov	ds, ax
		call	arena_next
		jb	short GLA_err
		test	ss:UMBFLAG, 1
		jnz	short GLA_chkumb
		cmp	byte ptr es:[di], 5Ah ;	'Z'
		jmp	short GLA_@f
; ---------------------------------------------------------------------------

GLA_chkumb:				; ...
		cmp	ax, cx

GLA_@f:					; ...
		jnz	short GLA_next

GLA_done:				; ...
		test	ss:UMBFLAG, 1
		jnz	short GLA_ret
		mov	ds, ax
		call	arena_next
		jb	short GLA_err
		cmp	ax, cx
		jnz	short GLA_err

GLA_ret:				; ...
		clc
		pop	ax
		retn
; ---------------------------------------------------------------------------

GLA_err:				; ...
		stc
		pop	ax
		retn
GetLastArena	endp

; ---------------------------------------------------------------------------
SERVERTAB	dw offset SERVER_DISP	; ...
SERVERLEAVE	dw offset SERVERRETURN	; ...
SERVER_DISP	db 11			; ...
		dw offset SRV_CALL
		dw offset COMMIT_ALL
		dw offset CLOSE_NAME
		dw offset CLOSE_UID
		dw offset CLOSE_UID_PID
		dw offset GET_LIST
		dw offset GET_DOS_DATA
		dw offset SPOOL_OPER
		dw offset SPOOL_OPER
		dw offset SPOOL_OPER
		dw offset _$SetExtendedError
; ---------------------------------------------------------------------------

$ServerCall:				; ...
		cmp	al, 7
		jb	short SET_STUFF
		cmp	al, 9
		jbe	short NO_SET_ID

SET_STUFF:				; ...
		mov	si, dx
		mov	bx, [si+12h]
		test	ss:IsWin386, 1
		jnz	short skip_win386
		mov	ss:USER_ID, bx

skip_win386:				; ...
		mov	bx, [si+14h]
		mov	ss:PROC_ID, bx

NO_SET_ID:				; ...
		push	cs:SERVERLEAVE
		push	cs:SERVERTAB
		push	ax
		call	TableDispatch
		mov	ss:EXTERR_LOCUS, 1
		mov	al, 1

servercall_error:			; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

SERVERRETURN:				; ...
		retn
; ---------------------------------------------------------------------------

COMMIT_ALL:				; ...
		xor	bx, bx
		push	ss
		pop	ds
		call	ECritDisk

CommitLoop:				; ...
		push	bx
		call	SFFromSFN
		jb	short CommitDone
		cmp	word ptr es:[di], 0
		jz	short CommitNext
		cmp	word ptr es:[di], 0FFFFh
		jz	short CommitNext
		test	word ptr es:[di+5], 8000h
		jnz	short CommitNext
		mov	word ptr THISSFT, di
		mov	word ptr THISSFT+2, es
		call	DOS_COMMIT

CommitNext:				; ...
		pop	bx
		inc	bx
		jmp	short CommitLoop
; ---------------------------------------------------------------------------

CommitDone:				; ...
		call	LCritDisk
		pop	bx

jmp_to_SYS_RET_OK:			; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

CLOSE_NAME:				; ...
		call	ss:MFTCloN

CheckReturns:				; ...
		jb	short func_err

jmp_to_jmp_to_SYS_RET_OK:		; ...
		jmp	short jmp_to_SYS_RET_OK
; ---------------------------------------------------------------------------

func_err:				; ...
		jmp	short servercall_error
; ---------------------------------------------------------------------------

CLOSE_UID:				; ...
		call	ss:MFTclU
		jmp	short CheckReturns
; ---------------------------------------------------------------------------

CLOSE_UID_PID:				; ...
		call	ss:MFTCloseP
		jmp	short CheckReturns
; ---------------------------------------------------------------------------

GET_LIST:				; ...
		call	ss:MFT_get
		jb	short func_err
		call	Get_User_Stack
		mov	[si+2],	bx
		mov	[si+0Ah], di
		mov	word ptr [si+10h], es

SetCXOK:				; ...
		mov	[si+4],	cx

third_jmp_short_SYS_RET_OK:		; ...
		jmp	short jmp_to_jmp_to_SYS_RET_OK
; ---------------------------------------------------------------------------

SRV_CALL:				; ...
		pop	ax
		push	ds
		push	si
		call	Get_User_Stack
		pop	di
		pop	es
		call	XCHGP
		push	si
		mov	cx, 6
		rep movsw
		inc	di
		inc	di
		movsw
		movsw
		pop	si
		mov	ax, [si]
		mov	bx, [si+2]
		mov	cx, [si+4]
		mov	dx, [si+6]
		mov	di, [si+0Ah]
		mov	es, word ptr [si+0Eh]
		push	word ptr [si+8]
		mov	ds, word ptr [si+0Ch]
		pop	si
		mov	ss:SAVEDS, ds
		mov	ss:SAVEBX, bx
		mov	ss:FSHARING, 0FFh
		jmp	REDISP
; ---------------------------------------------------------------------------

GET_DOS_DATA:				; ...
		push	ss
		pop	es
		mov	di, offset ERRORMODE ; SWAP_START
		mov	cx, offset SWAP_END
		mov	dx, offset USER_IN_AX ;	SWAP_ALWAYS
		sub	cx, di
		sub	dx, di
		shr	cx, 1
		adc	cx, 0
		shl	cx, 1
		call	Get_User_Stack
		mov	word ptr [si+0Eh], es
		mov	[si+8],	di
		mov	[si+6],	dx
		jmp	short SetCXOK
; ---------------------------------------------------------------------------

SPOOL_OPER:				; ...
		push	ax
		mov	ax, 1125h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
					; STACK: WORD subfunction
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	bx
		jb	short func_err2
		jmp	short third_jmp_short_SYS_RET_OK
; ---------------------------------------------------------------------------

func_err2:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

_$SetExtendedError:			; ...
		mov	ax, [si]
		mov	ss:EXTERR, ax
		mov	ax, [si+0Ah]
		mov	word ptr ss:EXTERRPT, ax
		mov	ax, [si+0Eh]
		mov	word ptr ss:EXTERRPT+2,	ax
		mov	ax, [si+2]
		mov	ss:EXTERR_ACT_CLASS, ax
		mov	ax, [si+4]
		mov	ss:EXTERR_LOCUS, ah
		retn

; =============== S U B	R O U T	I N E =======================================


pJFNFromHandle	proc near		; ...
		mov	es, cs:DosDSeg
		mov	es, es:CurrentPDB
		cmp	bx, word ptr es:BCON
		jb	short pjfn10
		mov	al, 6

ReturnCarry:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

pjfn10:					; ...
		les	di, es:BCON+2
		add	di, bx

pJFNFromHandle_error:			; ...
		retn
pJFNFromHandle	endp


; =============== S U B	R O U T	I N E =======================================


SFFromHandle	proc near		; ...
		call	pJFNFromHandle
		jb	short pJFNFromHandle_error
		cmp	byte ptr es:[di], 0FFh
		jnz	short GetSF
		mov	al, 6
		jmp	short ReturnCarry
; ---------------------------------------------------------------------------

GetSF:					; ...
		push	bx
		mov	bl, es:[di]
		xor	bh, bh
		call	SFFromSFN
		pop	bx
		retn
SFFromHandle	endp


; =============== S U B	R O U T	I N E =======================================


SFFromSFN	proc near		; ...
		mov	es, cs:DosDSeg
		les	di, es:SFT_ADDR

sfsfn5:					; ...
		cmp	bx, es:[di+4]
		jb	short sfsfn7
		sub	bx, es:[di+4]
		les	di, es:[di]
		cmp	di, 0FFFFh
		jnz	short sfsfn5
		stc
		retn
; ---------------------------------------------------------------------------

sfsfn7:					; ...
		push	ax
		mov	ax, 59
		mul	bl
		add	di, ax
		pop	ax
		add	di, 6
		retn
SFFromSFN	endp


; =============== S U B	R O U T	I N E =======================================


JFNFree		proc near		; ...
		xor	bx, bx

jfnf1:					; ...
		call	pJFNFromHandle
		jb	short jfnf5
		cmp	byte ptr es:[di], 0FFh
		jz	short jfnfx
		inc	bx
		jmp	short jfnf1
; ---------------------------------------------------------------------------

jfnf5:					; ...
		mov	al, 4

jfnfx:					; ...
		retn
JFNFree		endp


; =============== S U B	R O U T	I N E =======================================


SFNFree		proc near		; ...
		push	ax
		xor	bx, bx

sfnf5:					; ...
		push	bx
		call	SFFromSFN
		pop	bx
		jb	short sfnf95
		cmp	word ptr es:[di], 0
		jz	short sfnf20
		cmp	word ptr es:[di], 0FFFFh
		jz	short sfnf10

sfnf7:					; ...
		inc	bx
		jmp	short sfnf5
; ---------------------------------------------------------------------------

sfnf10:					; ...
		mov	ax, ss:USER_ID
		cmp	es:[di+2Fh], ax
		jnz	short sfnf7
		mov	ax, ss:PROC_ID
		cmp	es:[di+31h], ax
		jnz	short sfnf7

sfnf20:					; ...
		mov	word ptr es:[di], 0FFFFh
		mov	ax, ss:USER_ID
		mov	es:[di+2Fh], ax
		mov	ax, ss:PROC_ID
		mov	es:[di+31h], ax
		pop	ax
		clc
		retn
; ---------------------------------------------------------------------------

sfnf95:					; ...
		pop	ax
		mov	al, 4
		retn
SFNFree		endp


; =============== S U B	R O U T	I N E =======================================


$CLOSE		proc near		; ...
		call	CheckOwner
		jb	short CloseError
		push	ss
		pop	ds
		mov	word ptr THISSFT, di
		mov	word ptr THISSFT+2, es
		cmp	word ptr es:[di], 1
		jz	short FreeJFN
		mov	al, es:[di+2]
		and	al, 0F0h
		cmp	al, 70h
		jz	short PostFree

FreeJFN:				; ...
		call	pJFNFromHandle
		mov	byte ptr es:[di], 0FFh

PostFree:				; ...
		call	DOS_CLOSE
		jb	short CloseError
		mov	ah, 3Eh

Close_OK:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

CloseError:				; ...
		jmp	SYS_RET_ERR
$CLOSE		endp

; ---------------------------------------------------------------------------

$COMMIT:				; ...
		call	CheckOwner
		jb	short CommitError
		push	ss
		pop	ds
		mov	word ptr THISSFT, di
		mov	word ptr THISSFT+2, es
		call	DOS_COMMIT
		jb	short CommitError
		mov	ah, 68h
; START	OF FUNCTION CHUNK FOR $READ

Commit_OK:				; ...
		jmp	short Close_OK
; ---------------------------------------------------------------------------

CommitError:				; ...
		jmp	short CloseError
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

$ExtHandle:				; ...
		xor	bp, bp
		cmp	bx, 20
		jnb	short exth2
		mov	bx, 20		; FILPERPROC

exth2:					; ...
		mov	es, ss:CurrentPDB
		mov	cx, word ptr es:32h ; [ES:PDB.JFN_Length]
		cmp	bx, cx
		jz	short ok_done
		ja	short larger
		mov	bp, 1
		mov	ds, word ptr es:36h ; [ES:PDB.JFN_Pointer+2]
		mov	si, bx
		sub	cx, bx

chck_handles:				; ...
		cmp	byte ptr [si], 0FFh
		jnz	short too_many_files
		inc	si
		loop	chck_handles
		cmp	bx, 20
		ja	short larger
		mov	bp, 2
		mov	di, 24		; PDB.JFN_TABLE
		push	bx
		jmp	short movhandl
; ---------------------------------------------------------------------------

larger:					; ...
		cmp	bx, 0FFFFh
		jz	short invalid_func
		clc
		push	bx
		add	bx, 0Fh
		mov	cl, 4
		rcr	bx, cl
		and	bx, 1FFFh
		push	bp
		call	$ALLOC
		pop	bp
		jb	short no_memory
		mov	es, ax
		xor	di, di

movhandl:				; ...
		mov	ds, ss:CurrentPDB
		test	bp, 3
		jz	short enlarge
		pop	cx
		push	cx
		jmp	short copy_hand
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $READ

ok_done:				; ...
		jmp	short Commit_OK
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

too_many_files:				; ...
		mov	al, 4
; START	OF FUNCTION CHUNK FOR $READ

CommitErrorj:				; ...
		jmp	short CommitError
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

enlarge:				; ...
		mov	cx, word ptr ds:32h ; [PDB.JFN_Length]

copy_hand:				; ...
		mov	dx, cx
		lds	si, ds:34h
		rep movsb
		pop	cx
		push	cx
		sub	cx, dx
		mov	al, 0FFh
		rep stosb
		mov	ds, ss:CurrentPDB
		cmp	word ptr ds:34h, 0 ; [PDB.JFN_Pointer]
		jnz	short update_info
		push	bp
		push	ds
		push	es
		mov	es, word ptr ds:36h ; [PDB.JFN_Pointer+2]
		call	$DEALLOC
		pop	es
		pop	ds
		pop	bp

update_info:				; ...
		test	bp, 2
		jz	short non_psp
		mov	word ptr ds:34h, 18h ; 24
		jmp	short final
; ---------------------------------------------------------------------------

non_psp:				; ...
		mov	word ptr ds:34h, 0

final:					; ...
		mov	word ptr ds:36h, es
		pop	word ptr ds:32h
; START	OF FUNCTION CHUNK FOR $READ

ExtHandle_OK:				; ...
		jmp	short ok_done
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

no_memory:				; ...
		pop	bx
		mov	al, 8
; START	OF FUNCTION CHUNK FOR $READ

jmp_to_jmp_CommitError:			; ...
		jmp	short CommitErrorj
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

invalid_func:				; ...
		mov	al, 1
; START	OF FUNCTION CHUNK FOR $READ

ExtHandle_err:				; ...
		jmp	short jmp_to_jmp_CommitError
; END OF FUNCTION CHUNK	FOR $READ

; =============== S U B	R O U T	I N E =======================================


$READ		proc near		; ...

; FUNCTION CHUNK AT A774 SIZE 00000004 BYTES
; FUNCTION CHUNK AT A7E0 SIZE 00000002 BYTES
; FUNCTION CHUNK AT A7E4 SIZE 00000002 BYTES
; FUNCTION CHUNK AT A82F SIZE 00000002 BYTES
; FUNCTION CHUNK AT A834 SIZE 00000002 BYTES
; FUNCTION CHUNK AT A838 SIZE 00000002 BYTES

		mov	si, offset DOS_READ

ReadDo:					; ...
		call	pJFNFromHandle
		jb	short ReadError
		mov	al, es:[di]
		call	CheckOwner
		jnb	short ReadSetup

ReadError:				; ...
		jmp	short ExtHandle_err
; ---------------------------------------------------------------------------

ReadSetup:				; ...
		mov	word ptr ss:THISSFT, di
		mov	word ptr ss:THISSFT+2, es
		test	byte ptr es:[di+3], 20h
		jz	short needi24
		or	ss:EXTOPEN_ON, 2

needi24:				; ...
		push	word ptr ss:DMAADD
		push	word ptr ss:DMAADD+2
		call	Align_Buffer
		push	ss
		pop	ds
		call	si
		pop	word ptr DMAADD+2
		pop	word ptr DMAADD
		jnb	short READ_OK
		jmp	short ReadError
; ---------------------------------------------------------------------------

READ_OK:				; ...
		mov	ax, cx

Read_OK_j:				; ...
		jmp	short ExtHandle_OK
$READ		endp


; =============== S U B	R O U T	I N E =======================================


Align_Buffer	proc near		; ...
		mov	bx, dx
		push	cx
		mov	cl, 4
		shr	bx, cl
		pop	cx
		mov	ax, ds
		add	ax, bx
		mov	ds, ax
		and	dx, 0Fh
		mov	word ptr ss:DMAADD, dx
		mov	word ptr ss:DMAADD+2, ds
		retn
Align_Buffer	endp

; ---------------------------------------------------------------------------

$WRITE:					; ...
		mov	si, offset DOS_WRITE
		jmp	short ReadDo

; =============== S U B	R O U T	I N E =======================================


$LSEEK		proc near		; ...
		call	CheckOwner

LSeekError:				; ...
		jnb	short CHKOWN_OK
		jmp	short ReadError
; ---------------------------------------------------------------------------

CHKOWN_OK:				; ...
		cmp	al, 2
		jbe	short LSeekDisp
		mov	ss:EXTERR_LOCUS, 1
		mov	al, 1

jmp_to_ReadError:			; ...
		jmp	short ReadError
; ---------------------------------------------------------------------------

LSeekDisp:				; ...
		cmp	al, 1
		jb	short LSeekStore
		ja	short LSeekEOF
		add	dx, es:[di+15h]
		adc	cx, es:[di+17h]

LSeekStore:				; ...
		mov	ax, cx
		xchg	ax, dx

LSeekSetpos:				; ...
		mov	es:[di+15h], ax
		mov	es:[di+17h], dx
		call	Get_User_Stack
		mov	[si+6],	dx

jmp_to_Read_OK_j:			; ...
		jmp	short Read_OK_j
; ---------------------------------------------------------------------------

LSeekEOF:				; ...
		test	byte ptr es:[di+6], 80h
		jnz	short Check_LSeek_Mode

LOCAL_LSeek:				; ...
		add	dx, es:[di+11h]
		adc	cx, es:[di+13h]
		jmp	short LSeekStore
; ---------------------------------------------------------------------------

Check_LSeek_Mode:			; ...
		test	byte ptr es:[di+3], 80h
		jnz	short LOCAL_LSeek
		mov	ax, es:[di+2]
		and	ax, 0F0h
		cmp	ax, 40h
		jz	short NET_LSEEK
		cmp	ax, 30h
		jnz	short LOCAL_LSeek

NET_LSEEK:				; ...
		mov	ax, 1121h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - SEEK	FROM END OF REMOTE FILE
					; CX:DX	= offset (in bytes) from end
					; ES:DI	-> SFT,	SFT DPB	field -> DPB of	drive with file
					; SS = DOS CS
					; Return: CF set on error
					; CF clear if successful, DX:AX	= new file position
		jnb	short LSeekSetpos

jmp_to_jmp_ReadError:			; ...
		jmp	short jmp_to_ReadError
$LSEEK		endp

; ---------------------------------------------------------------------------

$FILE_TIMES:				; ...
		cmp	al, 2
		jnb	short inval_func
		call	CheckOwner
		jb	short LSeekError
		or	al, al
		jnz	short ft_set_time
		cli
		mov	cx, es:[di+0Dh]
		mov	dx, es:[di+0Fh]
		sti
		call	Get_User_Stack
		mov	[si+4],	cx
		mov	[si+6],	dx
		jmp	short ok_ret
; ---------------------------------------------------------------------------

ft_set_time:				; ...
		call	ECritDisk
		mov	es:[di+0Dh], cx
		mov	es:[di+0Fh], dx
		xor	ax, ax
		call	ss:ShSU
		and	word ptr es:[di+5], 0FFBFh
		or	word ptr es:[di+5], 4000h
		call	LCritDisk

ok_ret:					; ...
		jmp	short jmp_to_Read_OK_j
; ---------------------------------------------------------------------------

inval_func:				; ...
		mov	ss:EXTERR_LOCUS, 1
		mov	al, 1

jmp3_to_ReadError:			; ...
		jmp	short jmp_to_jmp_ReadError
; ---------------------------------------------------------------------------

$DUP:					; ...
		mov	ax, bx
		call	JFNFree

DupErrorCheck:				; ...
		jb	short DupErr
		push	es
		push	di
		pop	si
		pop	ds
		xchg	ax, bx
		call	CheckOwner
		jb	short DupErr
		call	DOS_Dup_Direct
		call	pJFNFromHandle
		mov	bl, es:[di]
		mov	[si], bl
		jmp	short ok_ret
; ---------------------------------------------------------------------------

DupErr:					; ...
		jmp	short jmp3_to_ReadError
; ---------------------------------------------------------------------------

$DUP2:					; ...
		push	bx
		push	cx
		mov	bx, cx
		call	$CLOSE
		pop	bx
		pop	ax
		call	pJFNFromHandle
		jmp	short DupErrorCheck

; =============== S U B	R O U T	I N E =======================================


CheckOwner	proc near		; ...
		call	SFFromHandle
		jb	short co_ret_label
		push	ax
		test	ss:IsWin386, 1
		jz	short no_win386
		xor	ax, ax
		jmp	short _skip_win386
; ---------------------------------------------------------------------------

no_win386:				; ...
		mov	ax, ss:USER_ID
		cmp	ax, es:[di+47]

_skip_win386:				; ...
		pop	ax
		jnz	short CheckOwner_err
		retn
; ---------------------------------------------------------------------------

CheckOwner_err:				; ...
		mov	al, 6
		stc

co_ret_label:				; ...
		retn
CheckOwner	endp

; ---------------------------------------------------------------------------

$AssignOper:				; ...
		cmp	al, 7
		jnz	short chk08

srinuse:				; ...
		push	ax
		mov	al, dl
		call	GetCDSFromDrv
		pop	ax
		jb	short baddrv
		cmp	word ptr [si+45h], 0
		jz	short baddrv
		cmp	al, 7
		jnz	short resetdrv
		or	word ptr [si+43h], 4000h
		jmp	short okdone
; ---------------------------------------------------------------------------

resetdrv:				; ...
		and	word ptr [si+43h], 0BFFFh
		jmp	short okdone
; ---------------------------------------------------------------------------

baddrv:					; ...
		mov	ax, 0Fh
		jmp	short ASS_ERR
; ---------------------------------------------------------------------------

chk08:					; ...
		cmp	al, 8
		jz	short srinuse
		push	ax
		mov	ax, 111Eh
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
					; SS = DOS CS
					; STACK: WORD function to execute
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	bx
		jb	short ASS_ERR

okdone:					; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

ASS_ERR:				; ...
		jmp	SYS_RET_ERR

; =============== S U B	R O U T	I N E =======================================


FIND_DPB	proc near		; ...
		lds	si, ss:DPBHEAD

fdpb5:					; ...
		cmp	si, 0FFFFh
		jz	short fdpb10
		cmp	al, [si]
		jz	short ret_label15
		lds	si, [si+19h]
		jmp	short fdpb5
; ---------------------------------------------------------------------------

fdpb10:					; ...
		stc

ret_label15:				; ...
		retn
FIND_DPB	endp


; =============== S U B	R O U T	I N E =======================================


InitCDS		proc near		; ...
		push	ax
		les	di, ss:THISCDS
		mov	word ptr es:[di+43h], 0
		sub	al, 40h	; '@'
		cmp	ss:NUMIO, al
		jb	short icdsx
		dec	ax
		push	ax
		add	al, 'A'
		mov	ah, ':'
		mov	es:[di], ax
		mov	word ptr es:[di+2], '\'
		or	byte ptr es:[di+44h], 40h
		sub	ax, ax
		mov	es:[di+49h], ax
		mov	es:[di+4Bh], ax
		mov	al, 2
		mov	es:[di+4Fh], ax
		pop	ax
		push	ds
		push	si
		call	FIND_DPB
		jb	short icds5
		mov	es:[di+45h], si
		mov	word ptr es:[di+47h], ds

icds5:					; ...
		pop	si
		pop	ds

icdsx:					; ...
		pop	ax

RET45:					; ...
		retn
InitCDS		endp

; ---------------------------------------------------------------------------

$UserOper:				; ...
		push	ax
		sub	al, 1
		pop	ax
		jb	short UserGet
		jz	short UserSet
		cmp	al, 5
		jbe	short UserPrint
		mov	ss:EXTERR_LOCUS, 1
		mov	al, 1

useroper_error:				; ...
		jmp	short ASS_ERR
; ---------------------------------------------------------------------------

UserGet:				; ...
		push	ds
		pop	es
		mov	di, dx
		mov	cx, ss:MYNUM
		call	Get_User_Stack
		mov	[si+4],	cx
		push	ss
		pop	ds
		mov	si, offset MYNAME

UserMove:				; ...
		mov	cx, 15
		rep movsb
		xor	ax, ax
		stosb

UserBye:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

UserSet:				; ...
		mov	ss:MYNUM, cx
		mov	si, dx
		push	ss
		pop	es
		mov	di, offset MYNAME
		inc	ss:DIFFNAM
		jmp	short UserMove
; ---------------------------------------------------------------------------

UserPrint:				; ...
		push	ax
		mov	ax, 111Fh
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
					; STACK: WORD function
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	dx
		jnb	short OKPA
		jmp	short useroper_error
; ---------------------------------------------------------------------------

OKPA:					; ...
		jmp	short UserBye

; =============== S U B	R O U T	I N E =======================================


GetVisDrv	proc near		; ...
		call	GETTHISDRV
		jb	short RET45
		push	ds
		push	si
		lds	si, ss:THISCDS
		test	word ptr [si+43h], 2000h
		pop	si
		pop	ds
		jz	short RET45
		mov	ss:DrvErr, 0Fh
		stc
		retn
GetVisDrv	endp


; =============== S U B	R O U T	I N E =======================================


GETTHISDRV	proc near		; ...
		or	al, al
		jnz	short GTD10
		mov	al, ss:CURDRV
		inc	ax

GTD10:					; ...
		dec	ax
		push	ds
		push	si
		mov	ss:EXTERR_LOCUS, 2
		test	ss:FSHARING, 0FFh
		jz	short GTD20
		push	ax
		push	es
		push	di
		mov	word ptr ss:THISCDS, offset DUMMYCDS
		mov	word ptr ss:THISCDS+2, ss
		add	al, 'A'
		call	InitCDS
		test	word ptr es:[di+43h], 4000h
		pop	di
		pop	es
		pop	ax
		jz	short GTD30
		jmp	short GTDX
; ---------------------------------------------------------------------------

GTD20:					; ...
		call	GetCDSFromDrv
		jb	short GTD30
		test	word ptr [si+43h], 4000h
		jnz	short GTDX

GTD30:					; ...
		mov	al, 0Fh
		mov	ss:DrvErr, al
		mov	ss:EXTERR_LOCUS, 1
		stc

GTDX:					; ...
		pop	si
		pop	ds
		retn
GETTHISDRV	endp


; =============== S U B	R O U T	I N E =======================================


GetCDSFromDrv	proc near		; ...
		cmp	al, ss:CDSCOUNT
		jb	short GetCDS
		stc
		retn
; ---------------------------------------------------------------------------

GetCDS:					; ...
		push	bx
		push	ax
		lds	si, ss:CDSADDR
		mov	bl, 88
		mul	bl
		add	si, ax
		mov	word ptr ss:THISCDS, si
		mov	word ptr ss:THISCDS+2, ds
		pop	ax
		pop	bx
		clc
		retn
GetCDSFromDrv	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

TransFCB	proc near		; ...

FCBTmp		= byte ptr -10h

		push	bp
		mov	bp, sp
		sub	sp, 10h
		push	ss
		pop	es
		push	es
		push	di
		lea	di, [bp+FCBTmp]
		mov	ss:EXTFCB, 0
		mov	ss:SATTRIB, 0
		call	GetExtended
		jz	short GetDrive
		mov	al, [si-1]
		mov	ss:SATTRIB, al
		mov	ss:EXTFCB, 0FFh

GetDrive:				; ...
		lodsb
		call	GETTHISDRV
		jb	short BadPack
		call	TextFromDrive
		mov	cx, 0Bh
		push	si

FCBScan:				; ...
		lodsb
		call	GetCharType
		test	al, 8
		jz	short BadPack
		loop	FCBScan
		pop	si
		mov	bx, di
		call	PackName
		pop	di
		pop	es
		push	ss
		pop	ds
		lea	si, [bp+FCBTmp]
		cmp	byte ptr [bx], 0
		jz	short BadPack
		push	bp
		call	TransPathSet
		pop	bp
		jnb	short FCBRet

BadPack:				; ...
		stc
		mov	al, 3

FCBRet:					; ...
		mov	sp, bp
		pop	bp

TransPath_retn:				; ...
		retn
TransFCB	endp


; =============== S U B	R O U T	I N E =======================================


TransPath	proc near		; ...
		xor	al, al
		jmp	short SetSplice
TransPath	endp


; =============== S U B	R O U T	I N E =======================================


TransPathSet	proc near		; ...

; FUNCTION CHUNK AT AC6D SIZE 0000004E BYTES

		mov	al, 0FFh

SetSplice:				; ...
		mov	ss:NoSetDir, al
		mov	al, 0FFh

TransPathNoSet:				; ...
		mov	ss:FSPLICE, al
		mov	ss:CMETA, 0FFh
		mov	ss:WFP_START, di
		mov	ss:CURR_DIR_END, 0FFFFh
		push	ss
		pop	es
		lea	bp, [di+134]	; lea bp,[di+TEMPLEN]
		test	ss:FSHARING, 0FFh
		jz	short CheckUNC
		call	DriveFromText
		call	GETTHISDRV
		jb	short NoPath
		call	TextFromDrive
		lea	bx, [di+1]
		call	Canonicalize
		jb	short TransPath_retn
		push	ss
		pop	ds
		mov	si, WFP_START
		test	FSPLICE, 0FFh
		jz	short NoServerSplice
		call	Splice

NoServerSplice:				; ...
		push	ss
		pop	ds
		les	di, THISCDS
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk

NoPath:					; ...
		mov	al, 3
		retn
; ---------------------------------------------------------------------------

CheckUNC:				; ...
		mov	word ptr ss:THISCDS, 0FFFFh
		mov	ax, 1123h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
					; DS:SI	-> ASCIZ filename to canonicalize
					; ES:DI	-> 128-byte buffer for qualified name
					; Return: CF set if not	resolved
		jnb	short UNCDone
		call	DriveFromText
		push	ax
		mov	ax, [si]
		call	PATHCHRCMP
		xchg	ah, al
		call	PATHCHRCMP
		jnz	short CheckDevice
		cmp	ah, al
		jnz	short CheckDevice
		pop	ax
		movsw

UNCCpy:					; ...
		lodsb
		call	UCase
		or	al, al
		jz	short UNCTerm
		call	PATHCHRCMP
		mov	bx, di
		stosb
		jnz	short UNCCpy
		call	Canonicalize

UNCDone:				; ...
		push	ss
		pop	ds
		retn
; ---------------------------------------------------------------------------

UNCTerm:				; ...
		stosb
		jmp	short UNCDone
; ---------------------------------------------------------------------------

CheckDevice:				; ...
		pop	ax
		cmp	byte ptr [si], 0
		jnz	short CheckPath
		mov	al, 2
		stc
		retn
; ---------------------------------------------------------------------------

CheckPath:				; ...
		push	ax
		push	bp
		call	no5Dshere	; call CheckThisDevice
		pop	bp
		pop	ax
		jnb	short DoFile
		mov	ss:FSHARING, 0FFh
		call	GETTHISDRV
		mov	ss:FSHARING, 0
		call	TextFromDrive
		mov	al, '/'
		stosb
		call	StrCpy
		clc
		push	ss
		pop	ds

DoFile_retn:				; ...
		retn
TransPathSet	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: thunk

no5Dshere	proc near		; ...
		jmp	CheckThisDevice
no5Dshere	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR TransPathSet

DoFile:					; ...
		call	GetVisDrv
		mov	al, 3
		jb	short DoFile_retn
		push	ds
		push	si
		push	es
		push	di
		call	ValidateCDS
		pop	di
		pop	es
		pop	si
		pop	ds
		mov	al, 3
		jb	short DoFile_retn
		push	ds
		push	si
		lds	si, ss:THISCDS
		mov	bx, di
		add	bx, [si+79]
		lea	bp, [di+134]
		call	FStrCpy
		dec	di
		mov	al, '\'
		cmp	es:[di-1], al
		jz	short GetOrig
		stosb

GetOrig:				; ...
		dec	di
		pop	si
		pop	ds
		call	PathSep
		jnz	short PathAssure
		or	al, al
		jz	short DoCanon
		mov	di, bx

SkipPath:				; ...
		lodsb
		call	PATHCHRCMP
		jz	short SkipPath
		dec	si
		or	al, al
		jz	short DoCanon

PathAssure:				; ...
		mov	al, '\'
; END OF FUNCTION CHUNK	FOR TransPathSet
		stosb

DoCanon:				; ...
		call	Canonicalize
		jb	short DoFile_retn
		push	ss
		pop	ds
		mov	di, WFP_START
		lds	si, THISCDS
		call	PathPref
		jnz	short DoSplice
		mov	al, [si-1]
		call	PATHCHRCMP
		jz	short DoSplice

Pathline:
		cmp	byte ptr es:[di], 0
		jz	short DoSplice
		inc	di
		mov	ss:CURR_DIR_END, di

DoSplice:				; ...
		push	ss
		pop	ds
		mov	si, WFP_START
		xor	cx, cx
		test	FSPLICE, 0FFh
		jz	short SkipSplice
		call	Splice

SkipSplice:				; ...
		push	ss
		pop	ds
		les	di, THISCDS
		test	word ptr es:[di+67], 8000h
		jnz	short Done
		jcxz	short Done
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk
		mov	al, 3

Done:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


Canonicalize	proc near		; ...
		lodsb
		call	PATHCHRCMP
		jnz	short CanonDec
		cmp	di, bp
		jnb	short CanonBad
		stosb
		jmp	short Canonicalize
; ---------------------------------------------------------------------------

CanonDec:				; ...
		dec	si

CanonLoop:				; ...
		xor	ax, ax
		cmp	[si], al
		jnz	short DoComponent
		cmp	byte ptr es:[di-1], ':'
		jnz	short DoTerminate
		mov	al, '\'
		stosb
		mov	al, ah

DoTerminate:				; ...
		stosb
		clc
		retn
; ---------------------------------------------------------------------------

CanonBad:				; ...
		call	ScanPathChar
		mov	al, 3
		jz	short PathEnc
		mov	al, 2

PathEnc:				; ...
		stc

CanonBad_retn:				; ...
		retn
; ---------------------------------------------------------------------------

DoComponent:				; ...
		call	CopyComponent
		jb	short CanonBad_retn
		cmp	word ptr es:[di], '.' ; 2Eh
		jz	short Skip1
		cmp	word ptr es:[di], '..' ; 2E2Eh
		jnz	short CanonNormal
		dec	di

Skip1:					; ...
		call	SkipBack
		mov	al, 3
		jb	short CanonBad_retn
		jmp	short CanonPath
; ---------------------------------------------------------------------------

CanonNormal:				; ...
		add	di, cx

CanonPath:				; ...
		call	PathSep
		jnz	short CanonBad
		lodsb
		call	PATHCHRCMP
		jnz	short CanonDec
		cmp	di, bp
		jnb	short CanonBad
		stosb

CanonPathLoop:				; ...
		lodsb
		call	PATHCHRCMP
		jz	short CanonPathLoop
		dec	si
		jmp	short CanonLoop
Canonicalize	endp


; =============== S U B	R O U T	I N E =======================================


PathSep		proc near		; ...
		mov	al, [si]

PathSepGotCh:				; ...
		or	al, al
		jz	short CanonBad_retn
		call	PATHCHRCMP
		retn
PathSep		endp


; =============== S U B	R O U T	I N E =======================================


SkipBack	proc near		; ...
		cmp	di, bx
		jb	short SkipBad
		dec	di
		mov	al, es:[di]
		call	PATHCHRCMP
		jnz	short SkipBack
		clc
		retn
; ---------------------------------------------------------------------------

SkipBad:				; ...
		mov	al, 3
		stc
		retn
SkipBack	endp


; =============== S U B	R O U T	I N E =======================================


CopyComponent	proc near		; ...
		sub	sp, 14
		push	ds
		push	si
		push	es
		push	di
		push	bp
		mov	bp, sp
		mov	ah, '.'
		lodsb
		stosb
		cmp	al, ah
		jnz	short NormalComp
		call	PathSep
		jz	short NulTerm

TryTwoDot:
		lodsb
		stosb
		cmp	al, ah
		jnz	short CopyBad
		call	PathSep
		jnz	short CopyBad

NulTerm:				; ...
		xor	al, al
		stosb
		mov	[bp+6],	si
		jmp	short _GoodRet
; ---------------------------------------------------------------------------

NormalComp:				; ...
		mov	si, [bp+6]
		call	NameTrans
		cmp	si, [bp+6]
		jz	short CopyBad
		test	ss:FSHARING, 0FFh
		jnz	short DoPack
		and	dl, 1
		add	ss:CMETA, dl
		jg	short CopyBad
		jnz	short DoPack
		or	dl, dl
		jz	short CopyBadPath

DoPack:					; ...
		mov	[bp+6],	si
		push	ss
		pop	ds
		mov	si, offset NAME1
		lea	di, [bp+0Ah]
		push	di
		call	PackName
		pop	di
		call	StrLen
		dec	cx
		add	cx, [bp+2]
		cmp	cx, [bp+0]
		jnb	short CopyBad
		mov	si, di
		les	di, [bp+2]
		call	FStrCpy

_GoodRet:				; ...
		clc
		jmp	short CopyEnd
; ---------------------------------------------------------------------------

CopyBad:				; ...
		stc
		call	ScanPathChar
		mov	al, 2
		jnz	short CopyEnd

CopyBadPath:				; ...
		stc
		mov	al, 3

CopyEnd:				; ...
		pop	bp
		pop	di
		pop	es
		pop	si
		pop	ds
		lahf
		add	sp, 14
		call	StrLen
		dec	cx
		sahf
		retn
CopyComponent	endp


; =============== S U B	R O U T	I N E =======================================


Splice		proc near		; ...
		test	ss:SPLICES, 0FFh
		jz	short AllDone
		push	word ptr ss:THISCDS
		push	word ptr ss:THISCDS+2
		push	ds
		push	si
		pop	di
		pop	es
		xor	ax, ax

SpliceScan:				; ...
		call	GetCDSFromDrv
		jb	short SpliceDone
		inc	al
		test	word ptr [si+43h], 2000h
		jz	short SpliceScan
		push	di
		call	PathPref
		jz	short SpliceFound

SpliceSkip:				; ...
		pop	di
		jmp	short SpliceScan
; ---------------------------------------------------------------------------

SpliceFound:				; ...
		cmp	byte ptr es:[di], 0
		jnz	short SpliceDo
		test	ss:NoSetDir, 0FFh
		jnz	short SpliceSkip

SpliceDo:				; ...
		mov	si, di
		push	es
		pop	ds
		pop	di
		call	TextFromDrive1
		mov	ax, ss:CURR_DIR_END
		or	ax, ax
		js	short NoPoke
		add	ax, di
		sub	ax, si
		mov	ss:CURR_DIR_END, ax

NoPoke:					; ...
		cmp	byte ptr [si], 0
		jnz	short SpliceCopy
		mov	al, '\'
		stosb

SpliceCopy:				; ...
		call	FStrCpy
		add	sp, 4
		or	cl, 1
		jmp	short DoSet
; ---------------------------------------------------------------------------

SpliceDone:				; ...
		pop	word ptr ss:THISCDS+2
		pop	word ptr ss:THISCDS

AllDone:				; ...
		xor	cx, cx

DoSet:					; ...
		lds	si, ss:THISCDS
		les	di, [si+45h]
		mov	word ptr ss:THISDPB, di
		mov	word ptr ss:THISDPB+2, es

Splice_retn:				; ...
		retn
Splice		endp


; =============== S U B	R O U T	I N E =======================================


$NameTrans	proc far		; ...
		push	ds
		push	si
		push	es
		push	di
		push	cx
		mov	ch, 16h
		call	SetAttrib
		mov	di, offset OPENBUF
		call	TransPath
		pop	cx
		pop	di
		pop	es
		pop	si
		pop	ds
		jnb	short TransOK
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

TransOK:				; ...
		mov	si, offset OPENBUF
		push	ss
		pop	ds
		call	FStrCpy
		jmp	SYS_RET_OK
$NameTrans	endp


; =============== S U B	R O U T	I N E =======================================


DriveFromText	proc near		; ...
		xor	al, al
		cmp	byte ptr [si], 0
		jz	short Splice_retn
		cmp	byte ptr [si+1], ':'
		jnz	short Splice_retn
		lodsw
		or	al, 20h
		sub	al, 60h
		jnz	short Splice_retn
		mov	al, 0FFh
		retn
DriveFromText	endp


; =============== S U B	R O U T	I N E =======================================


TextFromDrive	proc near		; ...
		inc	al

TextFromDrive1:				; ...
		add	al, 40h	; '@'   ; 'A'-1
		mov	ah, ':'
		stosw

PathPref_retn:				; ...
		retn
TextFromDrive	endp


; =============== S U B	R O U T	I N E =======================================


PathPref	proc near		; ...
		call	DStrLen
		dec	cx
		repe cmpsb
		jnz	short PathPref_retn
		push	ax
		mov	al, [si-1]
		call	PATHCHRCMP
		jz	short Prefix
		mov	al, es:[di]
		call	PathSepGotCh

Prefix:					; ...
		pop	ax
		retn
PathPref	endp


; =============== S U B	R O U T	I N E =======================================


ScanPathChar	proc near		; ...
		lodsb
		call	PathSepGotCh
		jnz	short ScanPathChar
		call	PATHCHRCMP
		retn
ScanPathChar	endp


; =============== S U B	R O U T	I N E =======================================


$OPEN		proc near		; ...
		xor	ah, ah

$Open2:					; ...
		mov	ch, 16h
		call	SetAttrib
		mov	cx, offset DOS_OPEN
		push	ax

AccessFile:				; ...
		call	ECritDisk	; ECritSFT
		call	SFNFree
		call	LCritDisk	; LCritSFT
		jb	short OpenFailJ
		mov	ss:SFN,	bx
		mov	word ptr ss:THISSFT, di
		mov	word ptr ss:THISSFT+2, es
		call	JFNFree
		jnb	short SaveJFN

OpenFailJ:				; ...
		jmp	OpenFail
; ---------------------------------------------------------------------------

SaveJFN:				; ...
		mov	word ptr ss:PJFN, di
		mov	word ptr ss:PJFN+2, es
		mov	ss:JFN,	bx
		mov	bx, ss:SFN
		mov	es:[di], bl
		mov	si, dx
		mov	di, offset OPENBUF
		push	cx
		call	TransPath
		pop	bx
		lds	si, ss:THISSFT
		jb	short OpenCleanJ
		cmp	ss:CMETA, 0FFh
		jz	short SetSearch
		mov	al, 2

OpenCleanJ:				; ...
		jmp	short OpenClean
; ---------------------------------------------------------------------------

SetSearch:				; ...
		pop	ax
		xor	cx, cx
		mov	[si+2],	cx
		mov	[si+51], cx
		cmp	bx, offset DOS_OPEN
		jnz	short _DoOper
		test	al, 80h
		jz	short _DoOper
		and	al, 7Fh
		mov	cx, 1000h

_DoOper:				; ...
		push	di
		push	es
		push	ds
		pop	es
		push	si
		pop	di
		call	Set_EXT_mode
		pop	es
		pop	di
		push	ss
		pop	ds
		push	cx
		call	bx
		pop	cx
		lds	si, THISSFT
		jb	short OpenE2

OpenOK:
		mov	word ptr [si], 1
		or	[si+5],	cx
		mov	ax, ss:JFN
		call	ss:ShCol
		mov	ss:SFN,	0FFFFh

OpenOKJ:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

OpenE2:					; ...
		cmp	ax, 57h
		jnz	short OpenE
		jmp	short OpenCritLeave
; ---------------------------------------------------------------------------

OpenClean:				; ...
		pop	bx

OpenE:					; ...
		mov	word ptr [si], 0
		lds	si, ss:PJFN
		mov	byte ptr [si], 0FFh
		jmp	short OpenCritLeave
; ---------------------------------------------------------------------------

OpenFail:				; ...
		sti
		pop	cx

OpenCritLeave:				; ...
		mov	ss:SFN,	0FFFFh
		cmp	ss:EXTERR, 25h	; ...
		jnz	short NORERR
		jmp	From_GetSet
; ---------------------------------------------------------------------------

NORERR:					; ...
		jmp	SYS_RET_ERR
$OPEN		endp


; =============== S U B	R O U T	I N E =======================================


$CREAT		proc near		; ...
		push	cx
		mov	cx, offset DOS_CREATE
$CREAT		endp

; START	OF FUNCTION CHUNK FOR $CreateNewFile

AccessSet:				; ...
		mov	ss:SATTRIB, 6
		jmp	AccessFile
; END OF FUNCTION CHUNK	FOR $CreateNewFile
; ---------------------------------------------------------------------------

$CHMOD:					; ...
		mov	di, offset OPENBUF
		push	ax
		push	cx
		mov	si, dx
		call	TransPathSet
		pop	cx
		pop	ax
		jb	short ChModErr
		push	ss
		pop	ds
		cmp	CMETA, 0FFh
		jnz	short ChModErr
		mov	SATTRIB, 16h
		sub	al, 1
		jb	short ChModGet
		jz	short ChModSet
		mov	EXTERR_LOCUS, 1
		mov	al, 1
; START	OF FUNCTION CHUNK FOR $UNLINK

ChModErrj:				; ...
		jmp	short NORERR
; END OF FUNCTION CHUNK	FOR $UNLINK
; ---------------------------------------------------------------------------

ChModGet:				; ...
		call	GET_FILE_INFO
		jb	short ChModE
		call	Get_User_Stack
		mov	[si+4],	ax
; START	OF FUNCTION CHUNK FOR $UNLINK

ChModOKj:				; ...
		jmp	short OpenOKJ
; END OF FUNCTION CHUNK	FOR $UNLINK
; ---------------------------------------------------------------------------

ChModSet:				; ...
		mov	ax, cx
		call	SET_FILE_ATTRIBUTE
		jb	short ChModE
; START	OF FUNCTION CHUNK FOR $UNLINK

ChModOK:				; ...
		jmp	short ChModOKj
; ---------------------------------------------------------------------------

ChModErr:				; ...
		mov	al, 3

ChModE:					; ...
		jmp	short ChModErrj
; END OF FUNCTION CHUNK	FOR $UNLINK

; =============== S U B	R O U T	I N E =======================================


$UNLINK		proc near		; ...

; FUNCTION CHUNK AT B01D SIZE 00000002 BYTES
; FUNCTION CHUNK AT B02A SIZE 00000002 BYTES
; FUNCTION CHUNK AT B033 SIZE 00000006 BYTES

		push	cx
		mov	si, dx
		mov	di, offset OPENBUF
		call	TransPathSet
		pop	cx
		jb	short ChModErr
		cmp	ss:CMETA, 0FFh
		jnz	short NotFound
		push	ss
		pop	ds
		mov	ch, 6
		call	SetAttrib
		call	DOS_DELETE
		jb	short UnlinkE

UnLinkOK:				; ...
		jmp	short ChModOK
; ---------------------------------------------------------------------------

NotFound:				; ...
		mov	al, 3

UnlinkE:				; ...
		jmp	short ChModE
$UNLINK		endp

; ---------------------------------------------------------------------------

$RENAME:				; ...
		push	cx
		push	ds
		push	dx
		push	es
		pop	ds
		mov	si, di
		mov	di, offset RENBUF
		call	TransPathSet
		push	ss:WFP_START
		pop	ss:REN_WFP
		pop	si
		pop	ds
		pop	cx

epjc2:					; ...
		jb	short ChModErr
		cmp	ss:CMETA, 0FFh
		jnz	short NotFound
		push	cx
		mov	di, offset OPENBUF
		call	TransPathSet
		pop	cx
		jb	short epjc2
		push	ss
		pop	ds
		cmp	CMETA, 0FFh
		jb	short NotFound
		push	word ptr THISCDS
		push	word ptr THISCDS+2
		mov	di, offset OPENBUF
		push	ss
		pop	es
		xor	al, al

rnloop:					; ...
		call	GetCDSFromDrv
		jb	short dorn
		call	StrCmp
		jz	short rnerr
		inc	al
		jmp	short rnloop
; ---------------------------------------------------------------------------

rnerr:					; ...
		add	sp, 4
		mov	al, 10h
		jmp	short UnlinkE
; ---------------------------------------------------------------------------

dorn:					; ...
		pop	word ptr ss:THISCDS+2
		pop	word ptr ss:THISCDS
		push	ss
		pop	ds
		mov	ch, 16h
		call	SetAttrib
		call	DOS_RENAME
		jb	short UnlinkE
		jmp	short UnLinkOK

; =============== S U B	R O U T	I N E =======================================


$CreateNewFile	proc near		; ...

; FUNCTION CHUNK AT AFEB SIZE 00000009 BYTES

		push	cx
		mov	cx, offset DOS_Create_New
		jmp	AccessSet
$CreateNewFile	endp


; =============== S U B	R O U T	I N E =======================================


BinToAscii	proc near		; ...
		mov	cx, 404h

bta5:					; ...
		rol	ax, cl
		push	ax
		and	al, 0Fh
		add	al, 'A'
		stosb
		pop	ax
		dec	ch
		jnz	short bta5
		retn
BinToAscii	endp

; ---------------------------------------------------------------------------

$CreateTempFile:			; ...
		push	bp
		mov	bp, sp
		sub	sp, 10
		test	cx, 0FFD8h
		jz	short OKatts
		mov	ax, 5
		jmp	short SETTMPERR
; ---------------------------------------------------------------------------

OKatts:					; ...
		mov	[bp-10], cx
		mov	[bp-8],	dx
		mov	word ptr [bp-6], ds
		mov	word ptr [bp-2], ds
		push	ds
		pop	es
		mov	di, dx
		mov	cx, di
		neg	cx
		or	cx, cx
		jnz	short okok
		mov	cx, 0FFFFh

okok:					; ...
		xor	ax, ax
		repne scasb
		dec	di
		mov	al, es:[di-1]
		call	PATHCHRCMP
		jz	short SETENDPTR
		mov	al, '\'
		stosb

SETENDPTR:				; ...
		mov	[bp-4],	di

CreateLoop:				; ...
		push	ss
		pop	ds
		push	bp
		call	READTIME
		pop	bp
		les	di, [bp-4]
		mov	ax, cx
		call	BinToAscii
		mov	ax, dx
		call	BinToAscii
		xor	al, al
		stosb
		lds	dx, [bp-8]
		mov	cx, [bp-10]
		push	bp
		call	$CreateNewFile
		pop	bp
		jnb	short CreateDone
		cmp	al, 50h	; 'P'
		jz	short CreateLoop
		cmp	al, 5
		jnz	short SETTMPERR
		cmp	ss:EXTERR, 41h ; 'A'
		jz	short SETTMPERR
		cmp	ss:EXTERR, 53h ; 'S'
		jz	short SETTMPERR
		jmp	short CreateLoop
; ---------------------------------------------------------------------------

SETTMPERR:				; ...
		stc

CreateDone:				; ...
		mov	sp, bp
		pop	bp
		jb	short CreateFail
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $Extended_Open

CreateFail:				; ...
		jmp	SYS_RET_ERR
; END OF FUNCTION CHUNK	FOR $Extended_Open

; =============== S U B	R O U T	I N E =======================================


SetAttrib	proc near		; ...
		test	ss:FSHARING, 0FFh
		jnz	short Set
		mov	cl, ch

Set:					; ...
		mov	ss:SATTRIB, cl
		retn
SetAttrib	endp


; =============== S U B	R O U T	I N E =======================================


$Extended_Open	proc near		; ...

; FUNCTION CHUNK AT 43F1 SIZE 00000009 BYTES
; FUNCTION CHUNK AT B171 SIZE 00000003 BYTES

		mov	ss:EXTOPEN_FLAG, dx
		mov	ss:EXTOPEN_IO_MODE, 0
		test	dx, 0FE00h
		jnz	short ext_inval2
		mov	ah, dl
		cmp	dl, 0
		jz	short ext_inval2
		and	dl, 0Fh
		cmp	dl, 2
		ja	short ext_inval2
		and	ah, 0F0h
		cmp	ah, 10h
		ja	short ext_inval2
		mov	ss:SAVE_ES, es
		mov	ss:SAVE_DI, di
		push	ss:EXTOPEN_FLAG
		pop	ss:SAVE_DX
		mov	ss:SAVE_CX, cx
		mov	ss:SAVE_BX, bx
		mov	ss:SAVE_DS, ds
		mov	ss:SAVE_SI, si
		mov	dx, si
		mov	ax, bx
		jmp	short goopen2
; ---------------------------------------------------------------------------

ext_inval2:				; ...
		mov	al, 1

jmp_to_CreateFail:			; ...
		jmp	short CreateFail
; ---------------------------------------------------------------------------

ext_inval_parm:
		pop	cx
		pop	si
		mov	al, 13
		jmp	short jmp_to_CreateFail
; ---------------------------------------------------------------------------

error_return:				; ...
		retn
; ---------------------------------------------------------------------------

goopen2:				; ...
		test	bx, 2000h
		jz	short goopen
		or	ss:EXTOPEN_ON, 2

goopen:					; ...
		or	ss:EXTOPEN_ON, 1
		and	ss:EXTOPEN_FLAG, 0FFh
		cmp	ss:EXTOPEN_FLAG, 10h
		jnz	short chknext
		call	$CreateNewFile
		jb	short error_return

loc_B20C:				; ...
		cmp	ss:EXTOPEN_ON, 0
		jz	short ok_return2
		mov	ss:EXTOPEN_FLAG, 2
		jmp	setXAttr
; ---------------------------------------------------------------------------

ok_return2:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

chknext:				; ...
		test	ss:EXTOPEN_FLAG, 1
		jnz	short exist_open
		call	$CREAT
		jb	short error_return
		cmp	ss:EXTOPEN_ON, 0
		jz	short ok_return2
		mov	ss:EXTOPEN_FLAG, 2
		test	ss:EXTOPEN_ON, 4
		jnz	short setXAttr
		mov	ss:EXTOPEN_FLAG, 3
		jmp	short setXAttr
; ---------------------------------------------------------------------------

error_return2:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

exist_open:				; ...
		test	ss:FSHARING, 0FFh
		jz	short noserver
		mov	cl, ch

noserver:				; ...
		call	$Open2
		jnb	short ext_ok
		cmp	ss:EXTOPEN_ON, 0
		jz	short error_return2
		cmp	ax, 2
		jnz	short error_return2
		test	ss:EXTOPEN_FLAG, 10h
		jnz	short do_creat
		jmp	short extexit
; ---------------------------------------------------------------------------

do_creat:				; ...
		mov	cx, ss:SAVE_CX
		lds	si, dword ptr ss:SAVE_SI
		mov	dx, si
		call	$CREAT
		jb	short extexit
		mov	ss:EXTOPEN_FLAG, 2
		jmp	short setXAttr
; ---------------------------------------------------------------------------

ext_ok:					; ...
		cmp	ss:EXTOPEN_ON, 0
		jz	short ok_return
		mov	ss:EXTOPEN_FLAG, 1

setXAttr:				; ...
		push	ax
		call	Get_User_Stack
		mov	ax, ss:EXTOPEN_FLAG
		mov	[si+4],	ax
		pop	ax
		mov	[si], ax

ok_return:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

extexit2:
		pop	bx
		push	ax
		cmp	ss:EXTOPEN_FLAG, 2
		jnz	short justopen
		lds	si, dword ptr ss:SAVE_SI
		lds	dx, [si]
		call	$UNLINK
		jmp	short reserror
; ---------------------------------------------------------------------------

justopen:				; ...
		call	$CLOSE

reserror:				; ...
		pop	ax
		jmp	short extexit
; ---------------------------------------------------------------------------
		mov	ax, 2
		jmp	short extexit
; ---------------------------------------------------------------------------
		mov	ax, 1

extexit:				; ...
		jmp	SYS_RET_ERR
$Extended_Open	endp

; ---------------------------------------------------------------------------

$LockOper:				; ...
		cmp	al, 1
		ja	short lock_bad_func
		push	di
		call	SFFromHandle
		jnb	short lock_do
		pop	di
		mov	al, 6

LockOperErrj:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

lock_bad_func:				; ...
		mov	ss:EXTERR_LOCUS, 1
		mov	al, 1

LockOperErr:				; ...
		jmp	short LockOperErrj
; ---------------------------------------------------------------------------

lock_do:				; ...
		mov	bx, ax
		mov	bp, offset Lock_Buffer
		mov	[bp+0],	dx
		mov	[bp+2],	cx
		pop	cx
		mov	[bp+4],	cx
		mov	[bp+6],	si
		mov	cx, 1
		push	ss
		pop	ds
		mov	dx, bp
		test	al, 1
		jnz	short DOS_Unlock
		jmp	short DOS_Lock
; ---------------------------------------------------------------------------

DOS_Unlock:				; ...
		test	byte ptr es:[di+6], 80h
		jz	short LOCAL_UNLOCK
		mov	ax, 110Ah
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - LOCK	REGION OF FILE
					; BX = file handle, CX:DX = starting offset, SI	= high word of size
					; STACK: WORD low word of size,	ES:DI -> SFT
					; SFT DPB field	-> DPB of drive	containing file, SS = DOS CS
					; Return: CF set error
		jmp	short ValChk
; ---------------------------------------------------------------------------

LOCAL_UNLOCK:				; ...
		call	clr_block

ValChk:					; ...
		jnb	short Lock_OK
		jmp	short LockOperErr
; ---------------------------------------------------------------------------

Lock_OK:				; ...
		mov	ax, TEMP_VAR
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

DOS_Lock:				; ...
		test	byte ptr es:[di+6], 80h
		jz	short LOCAL_LOCK
		mov	ax, 110Ah
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - LOCK	REGION OF FILE
					; BX = file handle, CX:DX = starting offset, SI	= high word of size
					; STACK: WORD low word of size,	ES:DI -> SFT
					; SFT DPB field	-> DPB of drive	containing file, SS = DOS CS
					; Return: CF set error
		jmp	short ValChk
; ---------------------------------------------------------------------------

LOCAL_LOCK:				; ...
		call	set_block
		jmp	short ValChk

; =============== S U B	R O U T	I N E =======================================


LOCK_CHECK	proc near		; ...
		mov	bx, RetryCount

LockRetry:				; ...
		push	bx
		push	ax
		call	chk_block
		pop	ax
		pop	bx
		jnb	short lc_ret_label
		call	Idle
		dec	bx
		jnz	short LockRetry
		stc

lc_ret_label:				; ...
		retn
LOCK_CHECK	endp


; =============== S U B	R O U T	I N E =======================================


LOCK_VIOLATION	proc near		; ...
		push	ds
		push	es
		push	di
		push	cx
		mov	ax, 21h	; '!'
		mov	ALLOWED, 18h
		les	bp, THISDPB
		mov	di, 1
		mov	cx, di
		mov	dx, es:[bp+0Bh]
		call	HARDERR
		pop	cx
		pop	di
		pop	es
		pop	ds
		cmp	al, 1
		jz	short lc_ret_label
		stc
		retn
LOCK_VIOLATION	endp


; =============== S U B	R O U T	I N E =======================================


CheckShare	proc near		; ...
		push	ds
		mov	ds, cs:DosDSeg
		cmp	fShare,	0
		pop	ds
		retn
CheckShare	endp


; =============== S U B	R O U T	I N E =======================================


SHARE_CHECK	proc near		; ...
		call	MFT_enter

shchk_retn:				; ...
		retn
SHARE_CHECK	endp


; =============== S U B	R O U T	I N E =======================================


SHARE_VIOLATION	proc near		; ...
		push	ds
		push	es
		push	di
		mov	READOP,	0
		mov	ALLOWED, 18h
		les	bp, THISDPB
		mov	di, 1
		mov	cx, di
		mov	dx, es:[bp+17]
		call	HARDERR
		pop	di
		pop	es
		pop	ds
		cmp	al, 1
		jz	short shchk_retn
		stc
		retn
SHARE_VIOLATION	endp


; =============== S U B	R O U T	I N E =======================================


ShareEnd	proc near		; ...
		call	MFTClose
		retn
ShareEnd	endp


; =============== S U B	R O U T	I N E =======================================


ShareEnter	proc near		; ...
		push	cx

retry:					; ...
		mov	cx, RetryCount

attempt:				; ...
		les	di, THISSFT
		xor	ax, ax
		mov	es:[di+51], ax
		push	cx
		call	SHARE_CHECK
		pop	cx
		jnb	short done
		call	Idle
		loop	attempt
		call	SHARE_VIOLATION
		jnb	short retry

done:					; ...
		pop	cx
		retn
ShareEnter	endp


; =============== S U B	R O U T	I N E =======================================


ExecReady	proc near		; ...
		mov	si, dx
		test	word ptr [si+2], 1
		jz	short er_setver
		mov	ax, [si+8]
		add	ax, 10h
		mov	es, ax
		mov	cx, [si+0Ah]
		mov	ax, [si+0Ch]
		call	ss:FixExePatch
		call	ss:Rational386PatchPtr

er_setver:				; ...
		test	word ptr [si+2], 2
		jnz	short er_chkdoshi
		push	ds
		push	si
		lds	si, [si+4]
		call	Scan_Execname1
		call	Scan_Special_Entries
		pop	si
		pop	ds
		mov	es, word ptr [si+8]
		mov	ax, ss:SPECIAL_VERSION
		mov	word ptr es:SFTFCB, ax

er_chkdoshi:				; ...
		cmp	ss:DosHasHMA, 0
		jz	short er_done
		mov	ax, [si+8]
		or	ss:DOS_FLAG, 4
		test	word ptr [si+2], 1
		jnz	short er_seta20
		push	ds
		mov	ds, ax
		call	IsCopyProt
		pop	ds

er_seta20:				; ...
		inc	ss:A20OFF_COUNT
		mov	ss:A20OFF_PSP, ax

er_done:				; ...
		xor	ax, ax
		retn
ExecReady	endp

; ---------------------------------------------------------------------------
rpFind1		db 0FAh, 0E4h, 21h, 60h, 33h, 0C0h, 0E6h, 43h, 8Bh, 16h	; ...
rpFind1a	db 0B0h, 0Eh, 0E6h, 37h, 33h, 0C0h, 0E6h, 0F2h ; ...
rpFind2		db 0Fh,	20h, 0C0h	; ...
rpFind3		db 0Fh,	22h, 0C0h, 0EAh	; ...
rpRepl2		db 66h,	50h, 51h, 0Fh, 20h, 0C0h ; ...
rpRepl3		db 8Eh,	0D3h, 59h, 66h,	58h ; ...
rpFind4		db 93h,	58h, 8Bh, 0CCh	; ...
rpFind5		db 0B8h, 0Ch, 0DEh, 0CDh, 67h, 8Bh, 0E1h, 0FFh,	0E3h ; ...
rpRepl4		db 93h,	58h, 8Bh, 0CCh	; ...
		db 2Eh,	66h, 0A3h
		db 0, 0
		db 2Eh,	66h, 89h, 36h
		db 0, 0
rpRepl5		db 8Bh,	0E1h		; ...
		db 2Eh,	66h, 0A1h
		db 0, 0
		db 2Eh,	66h, 8Bh, 36h
		db 0, 0
		db 0FFh, 0E3h
rpFind6		db 0FAh, 52h, 51h	; ...
rpFind7a	db 0B8h, 0Ch, 0DEh, 66h, 26h, 0FFh, 1Eh	; ...
rpFind7b	db 59h,	5Ah, 5Bh	; ...
rpRepl6		db 0FAh, 66h, 50h, 66h,	53h, 66h, 51h, 66h, 52h	; ...
rpRepl7		db 66h,	5Ah, 66h, 59h, 66h, 5Bh, 66h, 58h, 5Bh ; ...
rpFind8		db 60h,	6, 1Eh,	0B8h, 0, 0, 8Eh, 0D8h ;	...
rpFind9		db 1Fh,	7, 61h		; ...
rpRepl8		db 66h,	60h, 6,	1Eh	; ...
rpRepl9		db 1Fh,	7, 66h,	61h, 0C3h ; ...
rpBug1Strs	dw offset rpFind2	; ...
		dw 3
		dw offset rpFind3
		dw 4
		dw 20h
rpBug2Strs	dw offset rpFind4	; ...
		dw 4
		dw offset rpFind5
		dw 9
		dw 80h
rpBug3Strs	dw offset rpFind6	; ...
		dw 3
		dw offset rpFind7a
		dw 7
		dw 80h
rpBug4Strs	dw offset rpFind8	; ...
		dw 4
		dw offset rpFind9
		dw 3
		dw 80h
; ---------------------------------------------------------------------------

Rational386Patch:			; ...
		cmp	word ptr es:0, 18Bh
		jnb	short rp3QuickOut
		cmp	word ptr es:WinoldPatch1+6, 20h	; ' '
		jnz	short rp3QuickOut
		push	ax
		mov	ax, 18h
		cmp	es:LeaveAddr, ax
		jnz	short rp3QO_ax
		cmp	es:RetryLoop, ax
		jnz	short rp3QO_ax
		cmp	es:arena_head, ax
		jz	short rp3Maybe

rp3QO_ax:				; ...
		pop	ax

rp3QuickOut:				; ...
		retn
; ---------------------------------------------------------------------------

rp3Maybe:				; ...
		cld
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	es
		push	ds
		push	bp
		sub	sp, 6
		mov	bp, sp
		push	cs
		pop	ds
		mov	ax, word ptr es:0
		mov	[bp+0],	ax
		call	VerifyVersion
		jnz	short rp3Exit_j
		mov	cx, 4500h
		mov	[bp+2],	cx
		mov	es, word ptr es:LastBuffer+2
		mov	si, offset rpFind1
		mov	dx, 10
		call	ScanCodeSeq
		jz	short rpGotPatch
		mov	si, offset rpFind1a
		mov	dx, 8
		call	ScanCodeSeq
		jz	short rpGotPatch

rp3Exit_j:				; ...
		jmp	rp3Exit
; ---------------------------------------------------------------------------

rpGotPatch:				; ...
		mov	[bp+4],	di
		cmp	word ptr [bp+0], 381
		jnb	short rpBug2
		mov	bx, offset rpBug1Strs
		call	FindBadCode
		jb	short rpBug2
		push	di
		mov	di, si
		mov	dx, 3
		cmp	byte ptr es:[di-1], 51h	; 'Q'
		jnz	short rp_no_cx
		dec	di
		inc	dx

rp_no_cx:				; ...
		mov	si, offset rpRepl2
		mov	cx, 6
		call	GenPatch
		pop	di
		cmp	byte ptr es:[di-1], 59h	; 'Y'
		jnz	short rp_no_cx2
		mov	byte ptr es:[di-1], 90h	; ''

rp_no_cx2:				; ...
		mov	ax, [bp+4]
		mov	es:[di+4], ax
		push	di
		mov	si, offset rpRepl3
		mov	cx, 5
		call	CopyPatch
		pop	bx
		add	bx, 8
		call	GenJump
		mov	[bp+4],	di

rpBug2:					; ...
		mov	bx, offset rpBug2Strs
		call	FindBadCode
		jb	short rpBug3
		push	word ptr [bp+4]
		push	di
		mov	di, si
		mov	dx, 4
		mov	si, offset rpRepl4
		mov	cx, 15
		call	GenPatch
		pop	di
		add	di, 5
		mov	bx, [bp+4]
		push	bx
		call	GenJump
		mov	si, offset rpRepl5
		mov	cx, 15
		call	CopyPatch
		pop	di
		pop	si
		mov	ax, [bp+4]
		mov	es:[si+7], ax
		mov	es:[di+5], ax
		add	ax, 4
		mov	es:[si+0Dh], ax
		mov	es:[di+0Bh], ax
		add	word ptr [bp+4], 8

rpBug3:					; ...
		mov	bx, offset rpBug3Strs
		call	FindBadCode
		jb	short rpBug4
		add	di, 9
		push	si
		mov	si, offset rpFind7b
		mov	dx, 3
		call	ScanCodeSeq_di
		pop	si
		jnz	short rpBug4
		push	di
		mov	di, si
		mov	dx, 3
		mov	si, offset rpRepl6
		mov	cx, 9
		call	GenPatch
		pop	di
		mov	dx, 3
		mov	si, offset rpRepl7
		mov	cx, 9
		call	GenPatch

rpBug4:					; ...
		cmp	word ptr [bp+0], 360
		jbe	short rp3Exit
		mov	bx, offset rpBug4Strs
		call	FindBadCode
		jb	short rp3Exit
		push	di
		mov	di, si
		mov	dx, 3
		mov	si, offset rpRepl8
		mov	cx, 4
		call	GenPatch
		pop	di
		mov	bx, [bp+4]
		call	GenJump
		mov	si, offset rpRepl9
		mov	cx, 5
		call	CopyPatch

rp3Exit:				; ...
		add	sp, 6
		pop	bp
		pop	ds
		pop	es
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


FindBadCode	proc near		; ...
		mov	cx, [bp+2]
		mov	si, [bx]
		mov	dx, [bx+2]
		call	ScanCodeSeq
		jnz	short fbc_error
		push	di
		mov	si, [bx+4]
		mov	dx, [bx+6]
		call	ScanCodeSeq_di
		pop	si
		jnz	short fbc_error
		mov	ax, di
		sub	ax, si
		jb	short fbc_error
		cmp	ax, [bx+8]
		ja	short fbc_error
		clc
		retn
; ---------------------------------------------------------------------------

fbc_error:				; ...
		stc
		retn
FindBadCode	endp


; =============== S U B	R O U T	I N E =======================================


GenPatch	proc near		; ...
		push	di
		mov	bx, [bp+4]
		call	GenJump
		call	CopyPatch
		pop	bx
		add	bx, dx
		call	GenJump
		mov	[bp+4],	di
		retn
GenPatch	endp


; =============== S U B	R O U T	I N E =======================================


CopyPatch	proc near		; ...
		push	cx
		mov	di, [bp+4]
		cld
		rep movsb
		pop	cx
		mov	[bp+4],	di
		retn
CopyPatch	endp


; =============== S U B	R O U T	I N E =======================================


GenJump		proc near		; ...
		mov	al, 0E9h
		stosb
		mov	ax, bx
		sub	ax, di
		sub	ax, 2
		stosw
		retn
GenJump		endp


; =============== S U B	R O U T	I N E =======================================


ScanCodeSeq	proc near		; ...
		mov	di, 200h
ScanCodeSeq	endp


; =============== S U B	R O U T	I N E =======================================


ScanCodeSeq_di	proc near		; ...
		push	cx
		sub	cx, dx
		inc	cx

scsagain:				; ...
		push	si
		push	di
		push	cx
		mov	cx, dx
		repe cmpsb
		pop	cx
		pop	di
		pop	si
		jz	short scsfound
		inc	di
		loop	scsagain

scsfound:				; ...
		pop	cx
		retn
ScanCodeSeq_di	endp


; =============== S U B	R O U T	I N E =======================================


VerifyVersion	proc near		; ...
		mov	si, word ptr es:SFT_ADDR
		mov	bl, 10
		add	si, 3
		call	VVDigit
		jnz	short vvexit
		call	VVDigit
		jnz	short vvexit
		cmp	byte ptr es:[si], '.'
		jnz	short vvexit
		dec	si
		call	VVDigit

vvexit:					; ...
		retn
VerifyVersion	endp


; =============== S U B	R O U T	I N E =======================================


VVDigit		proc near		; ...
		div	bl
		add	ah, '0'
		dec	si
		cmp	es:[si+1], ah
		mov	ah, 0
		retn
VVDigit		endp

; ---------------------------------------------------------------------------

exepatch_start:				; ...
		push	es
		mov	ax, ds
		sub	ax, dx

first:
		mov	ds, ax
		mov	es, ax
		mov	di, 0Fh
		push	di
		mov	cx, 10h
		mov	al, 0FFh
		repe scasb
		inc	di
		mov	si, di
		pop	di
		pop	ax
		sub	ax, dx

second:
		mov	es, ax

_NextRec:
		mov	cx, 204h

_norm_agn:				; ...
		mov	ax, si
		not	ax
		shr	ax, cl
		jz	short _SI_ok
		mov	dx, ds
		or	si, 0FFF0h
		sub	dx, ax
		jnb	short _SItoDS
		neg	dx
		shl	dx, cl
		sub	si, dx
		xor	dx, dx

_SItoDS:				; ...
		mov	ds, dx

_SI_ok:					; ...
		xchg	si, di
		push	ds
		push	es
		pop	ds
		pop	es
		dec	ch
		jnz	short _norm_agn
		lodsb
		xchg	ax, dx
		dec	si
		lodsw
		mov	cx, ax
		inc	si
		mov	al, dl
		and	al, 0FEh
		cmp	al, 0B0h	; RPTREC
		jnz	short TryEnum
		lodsb
		rep stosb
		jmp	short TryNext
; ---------------------------------------------------------------------------

TryEnum:				; ...
		cmp	al, 0B2h	; ENMREC
		jnz	short CorruptExe ; db 75h,6Bh
		rep movsb

TryNext:				; ...
		xchg	ax, dx
		test	al, 1
		jz	short NextRec	; db 74h,0BAh
		nop
		nop

scan_patch1:				; ...
		mov	bx, es
		mov	ax, ds
		sub	ax, dx
		mov	ds, ax
		mov	es, ax
		mov	di, 0Fh
		mov	cx, 10h
		mov	al, 0FFh
		repe scasb
		inc	di
		mov	si, di
		mov	ax, bx
		sub	ax, dx
		mov	es, ax
		mov	di, 0Fh

NextRec_1:
		mov	cl, 4
		mov	ax, si
		not	ax
		shr	ax, cl
		jz	short SI_ok_1
		mov	dx, ds
		sub	dx, ax
		mov	ds, dx
		assume ds:nothing
		or	si, 0FFF0h

SI_ok_1:				; ...
		mov	ax, di
		not	ax
		shr	ax, cl
		jz	short DI_ok_1
		mov	dx, es
		sub	dx, ax
		mov	es, dx
		or	di, 0FFF0h

scan_patch2:				; ...
		mov	bx, es
		mov	ax, ds
		dec	ax
		mov	ds, ax
		assume ds:nothing
		mov	es, ax
		assume es:nothing
		mov	di, 0Fh
		mov	cx, 10h
		mov	al, 0FFh
		repe scasb
		inc	di
		mov	si, di
		mov	ax, bx
		dec	ax
		mov	es, ax
		assume es:DOSDATA
		mov	di, 0Fh

NextRec_2:
		mov	cl, 4
		mov	ax, si
		not	ax
		shr	ax, cl
		jz	short SI_ok_2
		mov	dx, ds
		sub	dx, ax
		mov	ds, dx
		assume ds:nothing
		or	si, 0FFF0h

SI_ok_2:				; ...
		mov	ax, di
		not	ax
		shr	ax, cl
		jz	short DI_ok_2
		mov	dx, es
		sub	dx, ax
		mov	es, dx
		assume es:nothing
		or	di, 0FFF0h

scan_patch3:				; ...
		mov	bx, es
		mov	ax, ds
		dec	ax
		mov	ds, ax
		assume ds:nothing
		mov	es, ax
		assume es:nothing
		mov	di, 0Fh
		mov	cx, 10h
		mov	al, 0FFh
		repe scasb
		inc	di
		mov	si, di
		mov	ax, bx
		dec	ax
		mov	es, ax
		assume es:nothing
		mov	di, 0Fh

NextRec_3:
		mov	cl, 4
		mov	ax, si
		not	ax
		shr	ax, cl
		jz	short SI_ok_3
		mov	dx, ds
		sub	dx, ax
		mov	ds, dx
		assume ds:nothing
		or	si, 0FFF0h

SI_ok_3:				; ...
		mov	ax, di
		not	ax
		shr	ax, cl
		jz	short DI_ok_3
		mov	dx, es
		sub	dx, ax
		mov	es, dx
		assume es:nothing
		or	di, 0FFF0h

scan_com:				; ...
		lodsb
		mov	dl, al
		dec	si
		lodsw
		mov	cx, ax
		inc	si
		mov	al, dl
		and	al, 0FEh
		cmp	al, 0B0h
		jnz	short _TryEnum
		lodsb
		rep stosb
		jmp	short _TryNext
; ---------------------------------------------------------------------------
		nop

_TryEnum:				; ...
		cmp	al, 0B2h
		jnz	short CorruptExe
		rep movsb

_TryNext:				; ...
		mov	al, dl
		test	al, 1

ExePatch:				; ...
		call	ExePackPatch
		call	ss:RationalPatchPtr
		retn

; =============== S U B	R O U T	I N E =======================================


ExePackPatch	proc near		; ...
		push	bx
		mov	bx, es
		cmp	bx, 0FFFh
		jbe	short ep_cont
		pop	bx
		retn
; ---------------------------------------------------------------------------

ep_cont:				; ...
		push	ds
		push	es
		push	ax
		push	cx
		push	si
		push	di
		sub	cx, 2
		jnb	short epp_1
		jmp	ep_notpacked
; ---------------------------------------------------------------------------

epp_1:					; ...
		mov	di, cx
		mov	es, ax
		assume es:DOSDATA
		mov	ss:UNPACK_OFFSET, di
		cmp	word ptr es:[di], 'BR'
		jz	short epp_2
		jmp	ep_notpacked
; ---------------------------------------------------------------------------

epp_2:					; ...
		push	cs
		pop	ds
		assume ds:DOSDATA
		add	di, 6Ch
		call	chk_common_str
		jnz	short ep_chkpatch2
		mov	si, offset scan_patch1
		mov	di, ss:UNPACK_OFFSET
		add	di, 28h
		mov	cx, 68
		mov	bx, 142
		mov	ax, 0EF4Eh
		call	chk_patchsum
		jb	short ep_done1
		mov	si, offset exepatch_start
		mov	cx, 102
		rep movsb

ep_done1:				; ...
		jmp	ep_notpacked
; ---------------------------------------------------------------------------

ep_chkpatch2:				; ...
		mov	di, 76h
		call	chk_common_str
		jnz	short ep_chkpatch3
		mov	si, offset scan_patch2
		mov	di, 32h
		mov	cx, 68
		mov	bx, 140
		mov	ax, 78B2h
		call	chk_patchsum
		jnb	short ep_patchcode2
		mov	si, offset scan_patch2
		mov	cx, 68
		mov	bx, 129
		mov	ax, 1C47h
		call	chk_patchsum
		jb	short ep_notpacked

ep_patchcode2:				; ...
		mov	si, offset exepatch_start
		mov	cx, 3
		rep movsb
		mov	ax, 4890h
		stosw
		add	si, 2
		mov	cx, 20
		rep movsb
		stosw
		add	si, 2
		mov	cx, 75
		rep movsb
		jmp	short ep_notpacked
; ---------------------------------------------------------------------------

ep_chkpatch3:				; ...
		mov	di, 74h
		call	chk_common_str
		jnz	short ep_notpacked
		mov	si, offset scan_patch3
		mov	di, 32h
		mov	cx, 66
		mov	bx, 139
		mov	ax, 4EDEh
		call	chk_patchsum
		jb	short ep_notpacked
		mov	si, offset exepatch_start
		mov	cx, 3
		rep movsb
		mov	al, 48h	; 'H'
		stosb
		add	si, 2
		mov	cx, 20
		rep movsb
		stosb
		add	si, 2
		mov	cx, 75
		rep movsb

ep_notpacked:				; ...
		pop	di
		pop	si
		pop	cx
		pop	ax
		pop	es
		pop	ds
		pop	bx
		retn
ExePackPatch	endp


; =============== S U B	R O U T	I N E =======================================


chk_common_str	proc near		; ...
		mov	si, offset scan_com
		mov	cx, 32
		repe cmpsb
		jz	short ccs_done
		cmp	byte ptr es:[di-1], 56h
		jnz	short ccs_done
		repe cmpsb

ccs_done:				; ...
		retn
chk_common_str	endp

; ---------------------------------------------------------------------------

chk_patchsum:				; ...
		push	di
		repe cmpsb
		jnz	short cp_fail
		mov	di, ss:UNPACK_OFFSET
		mov	cx, bx
		mov	bx, ax
		xor	ax, ax

ep_chksum:				; ...
		add	ax, es:[di]
		add	di, 2
		loop	ep_chksum
		pop	di
		cmp	ax, bx
		jnz	short cp_fail
		clc
		retn
; ---------------------------------------------------------------------------

cp_fail:				; ...
		stc
		retn
; ---------------------------------------------------------------------------
RScanPattern1	db  00h, 00h, 20h, 00h,	00h, 00h, 40h, 00h; 0 ;	...
		db  01h, 00h		; 8
RScanPattern2	db  8Bh, 0Eh, 10h, 00h,	90h,0E2h,0FEh,0E8h; 0 ;	...
RScanPattern3	db  8Bh, 0Eh, 10h, 00h,0E2h,0FEh,0E8h; 0 ; ...
; ---------------------------------------------------------------------------

RationalPatch:				; ...
		cld
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	es
		push	ds
		mov	di, 0Ah
		push	cs
		pop	ds
		mov	si, offset RScanPattern1
		mov	cx, 10
		repe cmpsb
		jnz	short rpexit
		mov	ax, word ptr es:0
		cmp	ax, 348
		jb	short rpexit
		cmp	ax, 383
		ja	short rpexit
		call	VerifyVersion
		jnz	short rpexit
		mov	cx, word ptr es:16h
		sub	cx, 200h
		mov	es, word ptr es:20h
		mov	si, offset RScanPattern2
		mov	dx, 8
		call	ScanCodeSeq
		jz	short rpfound
		mov	si, offset RScanPattern3
		mov	dx, 15
		call	ScanCodeSeq
		jnz	short rpexit

rpfound:				; ...
		mov	al, 9Ah
		stosb
		mov	ax, offset RatBugCode
		stosw
		mov	ax, ss
		stosw
		mov	cx, dx
		sub	cx, 6
		mov	al, 90h
		rep stosb

rpexit:					; ...
		pop	ds
		pop	es
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
; ---------------------------------------------------------------------------
CPScanPattern	db  89h, 26h, 48h, 01h	; 0 ; ...
		db  8Ch, 0Eh, 4Ch, 01h	; 4
		db 0C7h, 06h, 4Ah, 01h	; 8
		db  00h, 01h, 8Ch, 0Eh	; 12
		db  13h, 01h,0B8h, 20h	; 16
		db  01h,0BEh, 00h, 01h	; 20

; =============== S U B	R O U T	I N E =======================================


IsCopyProt	proc near		; ...
		cmp	word ptr ds:11Bh, 5343h
		jnz	short CP_done
		cmp	word ptr ds:173h, 5044h
		jnz	short CP_done
		cmp	word ptr ds:146h, 0F413h
		jnz	short CP_done
		cmp	word ptr ds:124h, 8000h
		jnz	short CP_done
		push	cs
		pop	es
		mov	di, offset CPScanPattern
		mov	si, 175h
		mov	cx, 24
		repe cmpsb
		jnz	short CP_done
		mov	ss:A20OFF_COUNT, 0Ah

CP_done:				; ...
		retn
IsCopyProt	endp

; ---------------------------------------------------------------------------

initiret:				; ...
		iret
; ---------------------------------------------------------------------------
InitBioDataSeg	dw 70h			; ...

; =============== S U B	R O U T	I N E =======================================


ParaRound	proc near		; ...
		add	ax, 15
		rcr	ax, 1
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
		retn
ParaRound	endp

; ---------------------------------------------------------------------------

DOSINIT:				; ...
		cli
		cld
		push	dx
		push	si
		push	ds
		push	di
		mov	bx, es
		mov	ax, offset MEMSTRT
		add	ax, 0Fh
		and	ax, 0FFF0h
		mov	si, ax
		mov	ax, cs
		mov	ds, ax
		mov	es, cs:InitBioDataSeg
		assume es:nothing
		mov	es, word ptr es:3
		assume es:DOSDATA
		xor	di, di
		mov	cx, 4970
		rep movsb
		pop	di
		pop	ds
		pop	si
		pop	dx
		push	es
		push	ds
		pop	es
		pop	ds
		mov	word ptr BiosDataPtr, di
		mov	word ptr BiosDataPtr+2,	bx
		mov	cs:DosDSeg, ds
		mov	word ptr cs:LowInt23Addr+2, ds
		mov	word ptr cs:LowInt24Addr+2, ds
		mov	word ptr cs:LowInt28Addr+2, ds
		mov	ENDMEM,	dx
		mov	USER_SP, sp
		mov	USER_SS, ss
		mov	ax, ds
		mov	ss, ax
		mov	sp, offset DSKSTACK
		mov	FixExePatch, offset RetExePatch
		mov	RationalPatchPtr, offset RetExePatch
		mov	ChkCopyProt, offset RetExePatch
		call	WhatCPUType
		cmp	al, 2
		mov	ax, offset Rational386Patch
		jnb	short di_set_patch
		mov	ax, offset RetExePatch

di_set_patch:				; ...
		mov	Rational386PatchPtr, ax
		mov	ax, cs
		mov	TEMP_DOSLOC, ax
		mov	word ptr NULDEV+2, es
		mov	word ptr NULDEV, si
		mov	SIS_Instance_Data_Ptr_2, ds
		push	si
		mov	cx, 7
		mov	si, offset Instance_Table_2

Instance_init_loop:			; ...
		mov	word ptr [si], ds
		add	si, 6
		loop	Instance_init_loop
		mov	cx, 5
		mov	si, offset OldInstanceJunk_6

OldInstance_init_loop:			; ...
		mov	word ptr [si], ds
		add	si, 6
		loop	OldInstance_init_loop
		pop	si
		push	es
		pop	ds
		push	ds
		xor	ax, ax
		mov	ds, ax
		mov	ax, offset initiret
		mov	word ptr [0A8h], ax
		mov	ax, cs
		mov	word ptr [0AAh], ax
		pop	ds
		call	CHARINIT
		push	si
		push	ss
		pop	es
		mov	di, offset SFT0_SFTable
		mov	ax, 3
		stosw
		dec	al
		stosw
		xor	al, al
		stosb
		mov	al, 0C3h
		stosw
		mov	ax, si
		stosw
		mov	ax, ds
		stosw
		xor	ax, ax
		stosw
		stosw
		stosw
		dec	ax
		stosw
		stosw
		inc	ax
		stosw
		stosw
		add	di, 7
		add	si, 10
		mov	cx, 4
		rep movsw
		mov	cl, 3
		mov	al, ' '
		rep stosb
		pop	si
		or	byte ptr [si+4], 3
		mov	word ptr ss:BCON, si
		mov	word ptr ss:BCON+2, ds

char_init_loop:				; ...
		lds	si, [si]
		call	CHARINIT
		test	byte ptr [si+4], 8
		jz	short char_init_loop
		mov	word ptr ss:BCLOCK, si
		mov	word ptr ss:BCLOCK+2, ds
		mov	bp, 4970
		mov	word ptr ss:DPBHEAD, bp
		mov	word ptr ss:DPBHEAD+2, es

PERDRV:					; ...
		lds	si, [si]
		cmp	si, -1
		jz	short CONTINIT
		call	CHARINIT
		test	word ptr [si+4], 8000h
		jnz	short PERDRV
		mov	cl, ss:CALLUNIT
		xor	ch, ch
		mov	[si+10], cl
		mov	dl, ss:NUMIO
		xor	dh, dh
		add	ss:NUMIO, cl
		push	ds
		push	si
		lds	bx, ss:CALLBPB

PERUNIT:				; ...
		mov	si, [bx]
		inc	bx
		inc	bx
		mov	es:[bp+0], dl
		mov	es:[bp+1], dh
		push	bx
		push	cx
		push	dx
		call	$SETDPB
		mov	ax, es:[bp+2]
		cmp	ax, ss:MAXSEC
		jbe	short NOTMAX
		mov	ss:MAXSEC, ax

NOTMAX:					; ...
		mov	ax, bp
		add	ax, 33
		mov	es:[bp+19h], ax
		mov	word ptr es:[bp+1Bh], es
		mov	byte ptr es:[bp+18h], 0FFh
		pop	dx
		pop	cx
		pop	bx
		mov	ax, ds
		pop	si
		pop	ds
		mov	es:[bp+13h], si
		mov	word ptr es:[bp+15h], ds
		push	ds
		push	si
		inc	dh
		inc	dl
		mov	ds, ax
		add	bp, 33
		loop	PERUNIT
		pop	si
		pop	ds
		jmp	PERDRV
; ---------------------------------------------------------------------------

CONTINIT:				; ...
		sub	bp, 33
		mov	word ptr [bp+19h], 0FFFFh
		mov	word ptr [bp+1Bh], 0FFFFh
		add	bp, 33
		push	ss
		pop	ds
		mov	ax, bp
		call	ParaRound
		mov	dx, ds
		add	dx, ax
		mov	bx, 0Fh
		mov	cx, ENDMEM
		mov	DOSSEG_INIT, ds
		push	dx
		mov	ax, TEMP_DOSLOC
		mov	es, ax
		mov	TEMP_DOSLOC, 0FFFFh
		call	patch_vec_segments
		call	patch_misc_segments
		mov	TEMP_DOSLOC, es
		pop	dx
		xor	ax, ax
		mov	ds, ax
		mov	es, ax
		mov	di, 90h
		mov	ax, ss:TEMP_DOSLOC
		mov	[di+2],	ax
		mov	di, 82h
		mov	word ptr ds:0, offset DIVOV
		mov	di, 80h		; INTBASE
		mov	ax, offset irett
		mov	cx, 9

iset1:					; ...
		stosw
		add	di, 2
		loop	iset1
		add	di, 4
		mov	cx, 6

iset2:					; ...
		stosw
		add	di, 2
		loop	iset2
		add	di, 8
		mov	cx, 14

iset3:					; ...
		stosw
		add	di, 2
		loop	iset3
		mov	word ptr ds:0BCh, offset INT2F
		mov	ax, ss:TEMP_DOSLOC
		mov	word ptr ds:0BEh, ax
		mov	byte ptr ds:0C0h, 0EAh
		mov	word ptr ds:0C1h, offset call_entry
		mov	word ptr ds:80h, offset	quit
		mov	word ptr ds:84h, offset	command
		mov	word ptr ds:88h, 100h
		mov	word ptr ds:8Ah, dx
		mov	word ptr ds:94h, offset	ABSDRD
		mov	word ptr ds:98h, offset	ABSDWRT
		mov	word ptr ds:9Ch, offset	stay_resident
		push	ss
		pop	ds
		push	ss
		pop	es
		push	dx
		inc	dx
		mov	CurrentPDB, dx
		xor	di, di
		mov	es, dx
		xor	ax, ax
		mov	cx, 128
		rep stosw
		mov	ax, ENDMEM
		call	SETMEM
		push	ss
		pop	ds
		mov	di, 24
		xor	ax, ax
		stosw
		stosb
		mov	al, 0FFh
		mov	cx, 17
		rep stosb
		push	ss
		pop	es
		mov	word ptr SFT_ADDR+2, ds
		mov	si, offset SysInitTable
		mov	word ptr es:[si+6], es
		mov	word ptr es:[si+2], es
		mov	word ptr es:BUFFHEAD+2,	es
		mov	si, offset BufferQueue ; HASHINITVAR
		mov	word ptr es:BUFFHEAD, si
		pop	dx
		mov	word ptr DMAADD+2, dx
		mov	es:arena_head, dx
		mov	ds, dx
		mov	byte ptr ds:0, 'Z'
		mov	word ptr  ds:1,	0
		mov	ax, ss:ENDMEM
		sub	ax, dx
		dec	ax
		mov	word ptr byte_0+3, ax
		mov	di, offset SFT0_SFTable
		mov	ax, 3
		stosw
		mov	di, offset SysInitTable
		inc	dx
		mov	ds, dx
		mov	dx, offset _seg_reinit
		mov	cx, offset exepatch_start
		sub	cx, offset $STARTCODE
		mov	ax, offset initiret
		sub	ax, offset $STARTCODE
		mov	sp, ss:USER_SP
		mov	ss, ss:USER_SS
		retf

; =============== S U B	R O U T	I N E =======================================


CHARINIT	proc near		; ...
		mov	ss:DEVCALL, 26
		mov	ss:DEVCALL_REQUNIT, 0
		mov	ss:DEVCALL_REQFUNC, 0
		mov	ss:DEVCALL_REQSTAT, 0
		push	es
		push	bx
		push	ax
		mov	bx, offset DEVCALL
		push	ss
		pop	es
		call	DEVIOCALL2
		pop	ax
		pop	bx
		pop	es
		retn
CHARINIT	endp


; =============== S U B	R O U T	I N E =======================================


check_XMM	proc near		; ...
		push	ax
		mov	ax, 4300h
		int	2Fh		; - Multiplex -	XMS - INSTALLATION CHECK
					; Return: AL = 80h XMS driver installed
					; AL <>	80h no driver
		cmp	al, 80h
		jnz	short cXMM_no_driver
		push	bx
		push	dx
		push	ds
		push	es
		mov	ax, 4310h
		int	2Fh		; - Multiplex -	XMS - GET DRIVER ADDRESS
					; Return: ES:BX	-> driver entry	point
		mov	ds, cs:DosDSeg
		mov	word ptr XMMcontrol, bx
		mov	word ptr XMMcontrol+2, es
		clc
		pop	es
		pop	ds
		pop	dx
		pop	bx
		pop	ax
		retn
; ---------------------------------------------------------------------------

cXMM_no_driver:				; ...
		stc
		pop	ax
		retn
check_XMM	endp

; ---------------------------------------------------------------------------
num_entry	db 0			; ...
; ---------------------------------------------------------------------------

_seg_reinit:				; ...
		push	ds
		mov	ds, cs:DosDSeg
		call	patch_misc_segments
		cmp	ax, 0
		jnz	short patch_vec_seg
		cmp	cs:num_entry, 0
		jnz	short second_entry
		mov	ax, ds
		call	patch_vec_segments
		call	patch_offset

second_entry:				; ...
		mov	ax, es
		mov	di, offset DOSINTTABLE
		mov	cx, 9
		push	ds
		pop	es

dosinttabloop:				; ...
		add	di, 2
		stosw
		loop	dosinttabloop
		cmp	ax, 0F000h
		jb	short sr_done
		call	check_XMM
		jb	short sr_done
		call	patch_in_nops
		mov	DosHasHMA, 1
		mov	FixExePatch, offset ExePatch
		mov	ChkCopyProt, offset IsCopyProt
		call	WhatCPUType
		cmp	al, 1
		jnz	short sr_done
		mov	RationalPatchPtr, offset RationalPatch
		jmp	short sr_done
; ---------------------------------------------------------------------------

patch_vec_seg:				; ...
		mov	ax, es
		call	patch_vec_segments

sr_done:				; ...
		mov	cs:num_entry, 1
		pop	ds
		retf

; =============== S U B	R O U T	I N E =======================================


WhatCPUType	proc near		; ...
		pushf
		push	bx
		xor	bx, bx
		xor	ax, ax
		push	ax
		popf
		pushf
		pop	ax
		and	ax, 0F000h
		cmp	ax, 0F000h
		jz	short cpu_8086
		mov	ax, 0F000h
		push	ax
		popf
		pushf
		pop	ax
		and	ax, 0F000h
		jz	short cpu_286

cpu_386:
		inc	bx

cpu_286:				; ...
		inc	bx

cpu_8086:				; ...
		mov	ax, bx
		pop	bx
		popf
		retn
WhatCPUType	endp


; =============== S U B	R O U T	I N E =======================================


patch_vec_segments proc	near		; ...
		push	es
		xor	cx, cx
		mov	es, cx
		mov	di, 82h		; INTBASE+2
		mov	word ptr es:02h, ax
		mov	cx, 2

ps_set1:				; ...
		stosw
		add	di, 2
		loop	ps_set1
		add	di, 4
		stosw
		add	di, 6
		mov	cx, 4

ps_set2:				; ...
		stosw
		add	di, 2
		loop	ps_set2
		add	di, 4
		mov	cx, 6

ps_set3:				; ...
		stosw
		add	di, 2
		loop	ps_set3
		add	di, 8
		mov	cx, 14

ps_set4:				; ...
		stosw
		add	di, 2
		loop	ps_set4
		mov	word ptr es:0C3h, ax
		pop	es
		retn
patch_vec_segments endp


; =============== S U B	R O U T	I N E =======================================


patch_misc_segments proc near		; ...
		push	bx
		push	es
		push	ax
		mov	ax, es
		push	ds
		pop	es
		mov	di, offset JShare
		mov	bx, TEMP_DOSLOC
		mov	cx, 15

jumptabloop:				; ...
		add	di, 2
		cmp	bx, 0FFFFh
		jz	short share_patch
		cmp	bx, es:[di]
		jnz	short no_share_patch

share_patch:				; ...
		stosw

no_share_patch:				; ...
		loop	jumptabloop
		mov	si, offset COUNTRY_CDPG
		mov	word ptr [si+4Fh], ds
		mov	word ptr [si+54h], ds
		mov	word ptr [si+59h], ds
		mov	word ptr [si+5Eh], ds
		mov	word ptr [si+80h], ds
		mov	word ptr [si+63h], ds
		mov	si, offset FastOpenTable
		cmp	TEMP_DOSLOC, 0FFFFh
		jz	short fast_patch
		mov	cx, TEMP_DOSLOC
		cmp	cx, [si+4]
		jnz	short no_fast_patch

fast_patch:				; ...
		mov	[si+4],	ax

no_fast_patch:				; ...
		pop	ax
		pop	es
		pop	bx
		retn
patch_misc_segments endp


; =============== S U B	R O U T	I N E =======================================


patch_offset	proc near		; ...
		push	es
		xor	ax, ax
		mov	es, ax
		mov	word ptr es:0, offset ldivov
		mov	di, 80h
		mov	ax, offset lirett
		mov	cx, 2

po_iset1:				; ...
		stosw
		add	di, 2
		loop	po_iset1
		add	di, 4
		stosw
		add	di, 6
		mov	cx, 4

po_iset2:				; ...
		stosw
		add	di, 2
		loop	po_iset2
		add	di, 4
		mov	cx, 6

po_iset3:				; ...
		stosw
		add	di, 2
		loop	po_iset3
		add	di, 8
		mov	cx, 14

po_iset4:				; ...
		stosw
		add	di, 2
		loop	po_iset4
		mov	word ptr es:0BCh, offset lint2f
		mov	byte ptr es:0C0h, 0EAh
		mov	word ptr es:0C1h, offset lcall_entry
		mov	word ptr es:80h, offset	lquit
		mov	word ptr es:84h, offset	lcommand
		mov	word ptr es:94h, offset	labsdrd
		mov	word ptr es:98h, offset	labsdwrt
		mov	word ptr es:9Ch, offset	lstay_resident
		pop	es
		retn
patch_offset	endp

; ---------------------------------------------------------------------------
patch_table	dw offset ldivov	; ...
		dw offset lquit
		dw offset lcommand
		dw offset labsdrd
		dw offset labsdwrt
		dw offset lstay_resident
		dw offset lint2f
		dw offset lcall_entry
; ---------------------------------------------------------------------------

patch_in_nops:				; ...
		push	ax
		push	si
		mov	si, offset patch_table
		mov	ax, 9090h
		mov	cx, 8

pin_loop:				; ...
		mov	di, cs:[si]
		stosw
		add	si, 2
		loop	pin_loop
		pop	si
		pop	ax
		retn
; ---------------------------------------------------------------------------
MEMSTRT		db 7 dup(0)		; ...
DOSCODE		ends


		end
